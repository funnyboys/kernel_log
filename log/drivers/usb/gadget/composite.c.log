commit 5d363120aa548ba52d58907a295eee25f8207ed2
Author: Pawel Laszczak <pawell@cadence.com>
Date:   Mon May 18 12:08:45 2020 +0200

    usb: gadget: Fix issue with config_ep_by_speed function
    
    This patch adds new config_ep_by_speed_and_alt function which
    extends the config_ep_by_speed about alt parameter.
    This additional parameter allows to find proper usb_ss_ep_comp_descriptor.
    
    Problem has appeared during testing f_tcm (BOT/UAS) driver function.
    
    f_tcm function for SS use array of headers for both  BOT/UAS alternate
    setting:
    
    static struct usb_descriptor_header *uasp_ss_function_desc[] = {
            (struct usb_descriptor_header *) &bot_intf_desc,
            (struct usb_descriptor_header *) &uasp_ss_bi_desc,
            (struct usb_descriptor_header *) &bot_bi_ep_comp_desc,
            (struct usb_descriptor_header *) &uasp_ss_bo_desc,
            (struct usb_descriptor_header *) &bot_bo_ep_comp_desc,
    
            (struct usb_descriptor_header *) &uasp_intf_desc,
            (struct usb_descriptor_header *) &uasp_ss_bi_desc,
            (struct usb_descriptor_header *) &uasp_bi_ep_comp_desc,
            (struct usb_descriptor_header *) &uasp_bi_pipe_desc,
            (struct usb_descriptor_header *) &uasp_ss_bo_desc,
            (struct usb_descriptor_header *) &uasp_bo_ep_comp_desc,
            (struct usb_descriptor_header *) &uasp_bo_pipe_desc,
            (struct usb_descriptor_header *) &uasp_ss_status_desc,
            (struct usb_descriptor_header *) &uasp_status_in_ep_comp_desc,
            (struct usb_descriptor_header *) &uasp_status_pipe_desc,
            (struct usb_descriptor_header *) &uasp_ss_cmd_desc,
            (struct usb_descriptor_header *) &uasp_cmd_comp_desc,
            (struct usb_descriptor_header *) &uasp_cmd_pipe_desc,
            NULL,
    };
    
    The first 5 descriptors are associated with BOT alternate setting,
    and others are associated with UAS.
    
    During handling UAS alternate setting f_tcm driver invokes
    config_ep_by_speed and this function sets incorrect companion endpoint
    descriptor in usb_ep object.
    
    Instead setting ep->comp_desc to uasp_bi_ep_comp_desc function in this
    case set ep->comp_desc to uasp_ss_bi_desc.
    
    This is due to the fact that it searches endpoint based on endpoint
    address:
    
            for_each_ep_desc(speed_desc, d_spd) {
                    chosen_desc = (struct usb_endpoint_descriptor *)*d_spd;
                    if (chosen_desc->bEndpoitAddress == _ep->address)
                            goto ep_found;
            }
    
    And in result it uses the descriptor from BOT alternate setting
    instead UAS.
    
    Finally, it causes that controller driver during enabling endpoints
    detect that just enabled endpoint for bot.
    
    Signed-off-by: Jayshri Pawar <jpawar@cadence.com>
    Signed-off-by: Pawel Laszczak <pawell@cadence.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index cb4950cf1cdc..5c1eb96a5c57 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -96,40 +96,43 @@ function_descriptors(struct usb_function *f,
 }
 
 /**
- * next_ep_desc() - advance to the next EP descriptor
+ * next_desc() - advance to the next desc_type descriptor
  * @t: currect pointer within descriptor array
+ * @desc_type: descriptor type
  *
- * Return: next EP descriptor or NULL
+ * Return: next desc_type descriptor or NULL
  *
- * Iterate over @t until either EP descriptor found or
+ * Iterate over @t until either desc_type descriptor found or
  * NULL (that indicates end of list) encountered
  */
 static struct usb_descriptor_header**
-next_ep_desc(struct usb_descriptor_header **t)
+next_desc(struct usb_descriptor_header **t, u8 desc_type)
 {
 	for (; *t; t++) {
-		if ((*t)->bDescriptorType == USB_DT_ENDPOINT)
+		if ((*t)->bDescriptorType == desc_type)
 			return t;
 	}
 	return NULL;
 }
 
 /*
- * for_each_ep_desc()- iterate over endpoint descriptors in the
- *		descriptors list
- * @start:	pointer within descriptor array.
- * @ep_desc:	endpoint descriptor to use as the loop cursor
+ * for_each_desc() - iterate over desc_type descriptors in the
+ * descriptors list
+ * @start: pointer within descriptor array.
+ * @iter_desc: desc_type descriptor to use as the loop cursor
+ * @desc_type: wanted descriptr type
  */
-#define for_each_ep_desc(start, ep_desc) \
-	for (ep_desc = next_ep_desc(start); \
-	      ep_desc; ep_desc = next_ep_desc(ep_desc+1))
+#define for_each_desc(start, iter_desc, desc_type) \
+	for (iter_desc = next_desc(start, desc_type); \
+	     iter_desc; iter_desc = next_desc(iter_desc + 1, desc_type))
 
 /**
- * config_ep_by_speed() - configures the given endpoint
+ * config_ep_by_speed_and_alt() - configures the given endpoint
  * according to gadget speed.
  * @g: pointer to the gadget
  * @f: usb function
  * @_ep: the endpoint to configure
+ * @alt: alternate setting number
  *
  * Return: error code, 0 on success
  *
@@ -142,11 +145,13 @@ next_ep_desc(struct usb_descriptor_header **t)
  * Note: the supplied function should hold all the descriptors
  * for supported speeds
  */
-int config_ep_by_speed(struct usb_gadget *g,
-			struct usb_function *f,
-			struct usb_ep *_ep)
+int config_ep_by_speed_and_alt(struct usb_gadget *g,
+				struct usb_function *f,
+				struct usb_ep *_ep,
+				u8 alt)
 {
 	struct usb_endpoint_descriptor *chosen_desc = NULL;
+	struct usb_interface_descriptor *int_desc = NULL;
 	struct usb_descriptor_header **speed_desc = NULL;
 
 	struct usb_ss_ep_comp_descriptor *comp_desc = NULL;
@@ -182,8 +187,21 @@ int config_ep_by_speed(struct usb_gadget *g,
 	default:
 		speed_desc = f->fs_descriptors;
 	}
+
+	/* find correct alternate setting descriptor */
+	for_each_desc(speed_desc, d_spd, USB_DT_INTERFACE) {
+		int_desc = (struct usb_interface_descriptor *)*d_spd;
+
+		if (int_desc->bAlternateSetting == alt) {
+			speed_desc = d_spd;
+			goto intf_found;
+		}
+	}
+	return -EIO;
+
+intf_found:
 	/* find descriptors */
-	for_each_ep_desc(speed_desc, d_spd) {
+	for_each_desc(speed_desc, d_spd, USB_DT_ENDPOINT) {
 		chosen_desc = (struct usb_endpoint_descriptor *)*d_spd;
 		if (chosen_desc->bEndpointAddress == _ep->address)
 			goto ep_found;
@@ -237,6 +255,32 @@ int config_ep_by_speed(struct usb_gadget *g,
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(config_ep_by_speed_and_alt);
+
+/**
+ * config_ep_by_speed() - configures the given endpoint
+ * according to gadget speed.
+ * @g: pointer to the gadget
+ * @f: usb function
+ * @_ep: the endpoint to configure
+ *
+ * Return: error code, 0 on success
+ *
+ * This function chooses the right descriptors for a given
+ * endpoint according to gadget speed and saves it in the
+ * endpoint desc field. If the endpoint already has a descriptor
+ * assigned to it - overwrites it with currently corresponding
+ * descriptor. The endpoint maxpacket field is updated according
+ * to the chosen descriptor.
+ * Note: the supplied function should hold all the descriptors
+ * for supported speeds
+ */
+int config_ep_by_speed(struct usb_gadget *g,
+			struct usb_function *f,
+			struct usb_ep *_ep)
+{
+	return config_ep_by_speed_and_alt(g, f, _ep, 0);
+}
 EXPORT_SYMBOL_GPL(config_ep_by_speed);
 
 /**

commit 5e5caf4fa8d3039140b4548b6ab23dd17fce9b2c
Author: Thinh Nguyen <Thinh.Nguyen@synopsys.com>
Date:   Mon Feb 3 18:05:32 2020 -0800

    usb: gadget: composite: Inform controller driver of self-powered
    
    Different configuration/condition may draw different power. Inform the
    controller driver of the change so it can respond properly (e.g.
    GET_STATUS request). This fixes an issue with setting MaxPower from
    configfs. The composite driver doesn't check this value when setting
    self-powered.
    
    Cc: stable@vger.kernel.org
    Fixes: 88af8bbe4ef7 ("usb: gadget: the start of the configfs interface")
    Signed-off-by: Thinh Nguyen <thinhn@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 223f72d4d9ed..cb4950cf1cdc 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -861,6 +861,11 @@ static int set_config(struct usb_composite_dev *cdev,
 	else
 		power = min(power, 900U);
 done:
+	if (power <= USB_SELF_POWER_VBUS_MAX_DRAW)
+		usb_gadget_set_selfpowered(gadget);
+	else
+		usb_gadget_clear_selfpowered(gadget);
+
 	usb_gadget_vbus_draw(gadget, power);
 	if (result >= 0 && cdev->delayed_status)
 		result = USB_GADGET_DELAYED_STATUS;
@@ -2279,6 +2284,7 @@ void composite_suspend(struct usb_gadget *gadget)
 
 	cdev->suspended = 1;
 
+	usb_gadget_set_selfpowered(gadget);
 	usb_gadget_vbus_draw(gadget, 2);
 }
 
@@ -2307,6 +2313,9 @@ void composite_resume(struct usb_gadget *gadget)
 		else
 			maxpower = min(maxpower, 900U);
 
+		if (maxpower > USB_SELF_POWER_VBUS_MAX_DRAW)
+			usb_gadget_clear_selfpowered(gadget);
+
 		usb_gadget_vbus_draw(gadget, maxpower);
 	}
 

commit a2035411fa1d1206cea7d5dfe833e78481844a76
Author: Jack Pham <jackp@codeaurora.org>
Date:   Thu Jan 30 19:10:36 2020 -0800

    usb: gadget: composite: Support more than 500mA MaxPower
    
    USB 3.x SuperSpeed peripherals can draw up to 900mA of VBUS power
    when in configured state. However, if a configuration wanting to
    take advantage of this is added with MaxPower greater than 500
    (currently possible if using a ConfigFS gadget) the composite
    driver fails to accommodate this for a couple reasons:
    
     - usb_gadget_vbus_draw() when called from set_config() and
       composite_resume() will be passed the MaxPower value without
       regard for the current connection speed, resulting in a
       violation for USB 2.0 since the max is 500mA.
    
     - the bMaxPower of the configuration descriptor would be
       incorrectly encoded, again if the connection speed is only
       at USB 2.0 or below, likely wrapping around U8_MAX since
       the 2mA multiplier corresponds to a maximum of 510mA.
    
    Fix these by adding checks against the current gadget->speed
    when the c->MaxPower value is used (set_config() and
    composite_resume()) and appropriately limit based on whether
    it is currently at a low-/full-/high- or super-speed connection.
    
    Because 900 is not divisible by 8, with the round-up division
    currently used in encode_bMaxPower() a MaxPower of 900mA will
    result in an encoded value of 0x71. When a host stack (including
    Linux and Windows) enumerates this on a single port root hub, it
    reads this value back and decodes (multiplies by 8) to get 904mA
    which is strictly greater than 900mA that is typically budgeted
    for that port, causing it to reject the configuration. Instead,
    we should be using the round-down behavior of normal integral
    division so that 900 / 8 -> 0x70 or 896mA to stay within range.
    And we might as well change it for the high/full/low case as well
    for consistency.
    
    N.B. USB 3.2 Gen N x 2 allows for up to 1500mA but there doesn't
    seem to be any any peripheral controller supported by Linux that
    does two lane operation, so for now keeping the clamp at 900
    should be fine.
    
    Signed-off-by: Jack Pham <jackp@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index cd303a3ea680..223f72d4d9ed 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -438,9 +438,13 @@ static u8 encode_bMaxPower(enum usb_device_speed speed,
 	if (!val)
 		return 0;
 	if (speed < USB_SPEED_SUPER)
-		return DIV_ROUND_UP(val, 2);
+		return min(val, 500U) / 2;
 	else
-		return DIV_ROUND_UP(val, 8);
+		/*
+		 * USB 3.x supports up to 900mA, but since 900 isn't divisible
+		 * by 8 the integral division will effectively cap to 896mA.
+		 */
+		return min(val, 900U) / 8;
 }
 
 static int config_buf(struct usb_configuration *config,
@@ -852,6 +856,10 @@ static int set_config(struct usb_composite_dev *cdev,
 
 	/* when we return, be sure our power usage is valid */
 	power = c->MaxPower ? c->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;
+	if (gadget->speed < USB_SPEED_SUPER)
+		power = min(power, 500U);
+	else
+		power = min(power, 900U);
 done:
 	usb_gadget_vbus_draw(gadget, power);
 	if (result >= 0 && cdev->delayed_status)
@@ -2278,7 +2286,7 @@ void composite_resume(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
-	u16				maxpower;
+	unsigned			maxpower;
 
 	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?
@@ -2292,10 +2300,14 @@ void composite_resume(struct usb_gadget *gadget)
 				f->resume(f);
 		}
 
-		maxpower = cdev->config->MaxPower;
+		maxpower = cdev->config->MaxPower ?
+			cdev->config->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;
+		if (gadget->speed < USB_SPEED_SUPER)
+			maxpower = min(maxpower, 500U);
+		else
+			maxpower = min(maxpower, 900U);
 
-		usb_gadget_vbus_draw(gadget, maxpower ?
-			maxpower : CONFIG_USB_GADGET_VBUS_DRAW);
+		usb_gadget_vbus_draw(gadget, maxpower);
 	}
 
 	cdev->suspended = 0;

commit c724417baf162bd3e035659e22cdf990cfb0d917
Author: Jack Pham <jackp@codeaurora.org>
Date:   Thu Jan 30 19:10:35 2020 -0800

    usb: gadget: composite: Fix bMaxPower for SuperSpeedPlus
    
    SuperSpeedPlus peripherals must report their bMaxPower of the
    configuration descriptor in units of 8mA as per the USB 3.2
    specification. The current switch statement in encode_bMaxPower()
    only checks for USB_SPEED_SUPER but not USB_SPEED_SUPER_PLUS so
    the latter falls back to USB 2.0 encoding which uses 2mA units.
    Replace the switch with a simple if/else.
    
    Fixes: eae5820b852f ("usb: gadget: composite: Write SuperSpeedPlus config descriptors")
    Signed-off-by: Jack Pham <jackp@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3b4f67000315..cd303a3ea680 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -437,12 +437,10 @@ static u8 encode_bMaxPower(enum usb_device_speed speed,
 		val = CONFIG_USB_GADGET_VBUS_DRAW;
 	if (!val)
 		return 0;
-	switch (speed) {
-	case USB_SPEED_SUPER:
-		return DIV_ROUND_UP(val, 8);
-	default:
+	if (speed < USB_SPEED_SUPER)
 		return DIV_ROUND_UP(val, 2);
-	}
+	else
+		return DIV_ROUND_UP(val, 8);
 }
 
 static int config_buf(struct usb_configuration *config,

commit 7170d1a4cc4d5fe1c55dfd95bddb9df074fe9637
Merge: a079973f462a 726b4fba94be
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 18 08:24:12 2019 +0100

    Merge tag 'usb-for-v5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    USB: changes for v5.5
    
    We have TI's glue layer for the Cadence USB3 controller going
    upstream. Tegra's XUDC driver is also going upstream with this pull
    request.
    
    Apart from these two big features, we have a bunch of patches switching
    over to devm_platform_ioremap_resource() in order to simplify code a
    little; and a non-critical fix for DWC3 usage via kexec.
    
    * tag 'usb-for-v5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (44 commits)
      usb: dwc3: of-simple: add a shutdown
      usb: cdns3: Add TI specific wrapper driver
      dt-bindings: usb: Add binding for the TI wrapper for Cadence USB3 controller
      usb: mtu3: fix race condition about delayed_status
      usb: gadget: Add UDC driver for tegra XUSB device mode controller
      usb: dwc3: debug: Remove newline printout
      usb: dwc2: use a longer core rest timeout in dwc2_core_reset()
      usb: gadget: udc: lpc32xx: Use devm_platform_ioremap_resource() in lpc32xx_udc_probe()
      USB: gadget: udc: clean up an indentation issue
      usb: gadget: Quieten gadget config message
      phy: renesas: rcar-gen3-usb2: Use platform_get_irq_optional() for optional irq
      usb: gadget: Remove set but not used variable 'opts' in msg_do_config
      usb: gadget: Remove set but not used variable 'opts' in acm_ms_do_config
      usb: mtu3: add a new function to do status stage
      usb: gadget: configfs: fix concurrent issue between composite APIs
      usb: gadget: f_tcm: Provide support to get alternate setting in tcm function
      usb: gadget: Correct NULL pointer checking in fsl gadget
      usb: fsl: Remove unused variable
      USB: dummy-hcd: use usb_urb_dir_in instead of usb_pipein
      USB: dummy-hcd: increase max number of devices to 32
      ...

commit 1c20c89b0421b52b2417bb0f62a611bc669eda1d
Author: Chandana Kishori Chiluveru <cchiluve@codeaurora.org>
Date:   Tue Oct 1 13:16:48 2019 +0530

    usb: gadget: composite: Fix possible double free memory bug
    
    composite_dev_cleanup call from the failure of configfs_composite_bind
    frees up the cdev->os_desc_req and cdev->req. If the previous calls of
    bind and unbind is successful these will carry stale values.
    
    Consider the below sequence of function calls:
    configfs_composite_bind()
            composite_dev_prepare()
                    - Allocate cdev->req, cdev->req->buf
            composite_os_desc_req_prepare()
                    - Allocate cdev->os_desc_req, cdev->os_desc_req->buf
    configfs_composite_unbind()
            composite_dev_cleanup()
                    - free the cdev->os_desc_req->buf and cdev->req->buf
    Next composition switch
    configfs_composite_bind()
            - If it fails goto err_comp_cleanup will call the
              composite_dev_cleanup() function
            composite_dev_cleanup()
                    - calls kfree up with the stale values of cdev->req->buf and
                      cdev->os_desc_req from the previous configfs_composite_bind
                      call. The free call on these stale values leads to double free.
    
    Hence, Fix this issue by setting request and buffer pointer to NULL after
    kfree.
    
    Signed-off-by: Chandana Kishori Chiluveru <cchiluve@codeaurora.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d516e8d6cd7f..5ec54b69c29c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2170,14 +2170,18 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 			usb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);
 
 		kfree(cdev->os_desc_req->buf);
+		cdev->os_desc_req->buf = NULL;
 		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
+		cdev->os_desc_req = NULL;
 	}
 	if (cdev->req) {
 		if (cdev->setup_pending)
 			usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 
 		kfree(cdev->req->buf);
+		cdev->req->buf = NULL;
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
+		cdev->req = NULL;
 	}
 	cdev->next_string_id = 0;
 	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);

commit 1cbfb8c4f62d667f6b8b3948949737edb92992cc
Author: Joel Stanley <joel@jms.id.au>
Date:   Mon Sep 30 22:44:34 2019 +0930

    usb: gadget: Quieten gadget config message
    
    On a system that often re-configures a USB gadget device the kernel log
    is filled with:
    
      configfs-gadget gadget: high-speed config #1: c
    
    Reduce the verbosity of this print to debug.
    
    Signed-off-by: Joel Stanley <joel@jms.id.au>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d516e8d6cd7f..bb0c744d5b44 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -794,9 +794,9 @@ static int set_config(struct usb_composite_dev *cdev,
 		result = 0;
 	}
 
-	INFO(cdev, "%s config #%d: %s\n",
-	     usb_speed_string(gadget->speed),
-	     number, c ? c->label : "unconfigured");
+	DBG(cdev, "%s config #%d: %s\n",
+	    usb_speed_string(gadget->speed),
+	    number, c ? c->label : "unconfigured");
 
 	if (!c)
 		goto done;

commit 96e46dcfb8534494859936b3da4f3018de53a53f
Merge: b2fcb285ade3 18a93cd38be3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 2 19:20:57 2019 +0200

    Merge tag 'usb-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    USB: Changes for v5.4 merge window
    
    With only 45 non-merge commits, we have a small merge window from the
    Gadget perspective.
    
    The biggest change here is the addition of the Cadence USB3 DRD
    Driver. All other changes are small, non-critical fixes or smaller new
    features like the improvement to BESL handling in dwc3.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    
    * tag 'usb-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (45 commits)
      usb: gadget: net2280: Add workaround for AB chip Errata 11
      usb: gadget: net2280: Move all "ll" registers in one structure
      usb: dwc3: gadget: Workaround Mirosoft's BESL check
      usb:cdns3 Fix for stuck packets in on-chip OUT buffer.
      usb: cdns3: Add Cadence USB3 DRD Driver
      usb: common: Simplify usb_decode_get_set_descriptor function.
      usb: common: Patch simplify usb_decode_set_clear_feature function.
      usb: common: Separated decoding functions from dwc3 driver.
      dt-bindings: add binding for USBSS-DRD controller.
      usb: gadget: composite: Set recommended BESL values
      usb: dwc3: gadget: Set BESL config parameter
      usb: dwc3: Separate field holding multiple properties
      usb: gadget: Export recommended BESL values
      usb: phy: phy-fsl-usb: Make structure fsl_otg_initdata constant
      usb: udc: lpc32xx: silence fall-through warning
      usb: dwc3: meson-g12a: fix suspend resume regulator unbalanced disables
      usb: udc: lpc32xx: remove set but not used 3 variables
      usb: gadget: udc: core: Fix segfault if udc_bind_to_driver() for pending driver fails
      usb: dwc3: st: Add of_dev_put() in probe function
      usb: dwc3: st: Add of_node_put() before return in probe function
      ...

commit cca3854010c5aebf3a06be0de04f26c4f1ae5810
Author: Thinh Nguyen <Thinh.Nguyen@synopsys.com>
Date:   Mon Aug 19 18:36:12 2019 -0700

    usb: gadget: composite: Set recommended BESL values
    
    Set the recommended BESL deep and baseline values based on the gadget's
    configuration parameters to the extended BOS descriptor. This feature
    helps to optimize power savings by maximizing the opportunity for longer
    L1 residency time.
    
    Signed-off-by: Thinh Nguyen <thinhn@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9118b42c70b6..7ed009dc0f92 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -612,6 +612,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	struct usb_ext_cap_descriptor	*usb_ext;
 	struct usb_dcd_config_params	dcd_config_params;
 	struct usb_bos_descriptor	*bos = cdev->req->buf;
+	unsigned int			besl = 0;
 
 	bos->bLength = USB_DT_BOS_SIZE;
 	bos->bDescriptorType = USB_DT_BOS;
@@ -619,6 +620,29 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	bos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);
 	bos->bNumDeviceCaps = 0;
 
+	/* Get Controller configuration */
+	if (cdev->gadget->ops->get_config_params) {
+		cdev->gadget->ops->get_config_params(cdev->gadget,
+						     &dcd_config_params);
+	} else {
+		dcd_config_params.besl_baseline =
+			USB_DEFAULT_BESL_UNSPECIFIED;
+		dcd_config_params.besl_deep =
+			USB_DEFAULT_BESL_UNSPECIFIED;
+		dcd_config_params.bU1devExitLat =
+			USB_DEFAULT_U1_DEV_EXIT_LAT;
+		dcd_config_params.bU2DevExitLat =
+			cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
+	}
+
+	if (dcd_config_params.besl_baseline != USB_DEFAULT_BESL_UNSPECIFIED)
+		besl = USB_BESL_BASELINE_VALID |
+			USB_SET_BESL_BASELINE(dcd_config_params.besl_baseline);
+
+	if (dcd_config_params.besl_deep != USB_DEFAULT_BESL_UNSPECIFIED)
+		besl |= USB_BESL_DEEP_VALID |
+			USB_SET_BESL_DEEP(dcd_config_params.besl_deep);
+
 	/*
 	 * A SuperSpeed device shall include the USB2.0 extension descriptor
 	 * and shall support LPM when operating in USB2.0 HS mode.
@@ -629,7 +653,8 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
-	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);
+	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |
+					    USB_BESL_SUPPORT | besl);
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
@@ -650,17 +675,6 @@ static int bos_desc(struct usb_composite_dev *cdev)
 						      USB_HIGH_SPEED_OPERATION |
 						      USB_5GBPS_OPERATION);
 		ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
-
-		/* Get Controller configuration */
-		if (cdev->gadget->ops->get_config_params) {
-			cdev->gadget->ops->get_config_params(cdev->gadget,
-				&dcd_config_params);
-		} else {
-			dcd_config_params.bU1devExitLat =
-				USB_DEFAULT_U1_DEV_EXIT_LAT;
-			dcd_config_params.bU2DevExitLat =
-				cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
-		}
 		ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
 		ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
 	}

commit 602fda17c7356bb7ae98467d93549057481d11dd
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jul 26 14:59:03 2019 +1000

    usb: gadget: composite: Clear "suspended" on reset/disconnect
    
    In some cases, one can get out of suspend with a reset or
    a disconnect followed by a reconnect. Previously we would
    leave a stale suspended flag set.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9118b42c70b6..76883ff4f5bb 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1976,6 +1976,7 @@ void composite_disconnect(struct usb_gadget *gadget)
 	 * disconnect callbacks?
 	 */
 	spin_lock_irqsave(&cdev->lock, flags);
+	cdev->suspended = 0;
 	if (cdev->config)
 		reset_config(cdev);
 	if (cdev->driver->disconnect)

commit 4ed9890c4c44d2ead7b57ad65425e3fbe9b9d42a
Author: Anurag Kumar Vulisha <anurag.kumar.vulisha@xilinx.com>
Date:   Fri May 10 12:37:27 2019 +0530

    usb: gadget: send usb_gadget as an argument in get_config_params
    
    Passing struct usb_gadget * as an extra argument in get_config_params
    makes gadget drivers to easily update the U1DevExitLat & U2DevExitLat
    values based on the values passed from the device tree. This patch
    does the same
    
    Signed-off-by: Anurag Kumar Vulisha <anurag.kumar.vulisha@xilinx.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index b8a15840b4ff..9118b42c70b6 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -653,7 +653,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 
 		/* Get Controller configuration */
 		if (cdev->gadget->ops->get_config_params) {
-			cdev->gadget->ops->get_config_params(
+			cdev->gadget->ops->get_config_params(cdev->gadget,
 				&dcd_config_params);
 		} else {
 			dcd_config_params.bU1devExitLat =

commit 50b9773c13bffbef32060e67c4483ea7b2eca7b5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Jun 27 12:33:56 2018 +1000

    usb: gadget: Fix OS descriptors support
    
    The current code is broken as it re-defines "req" inside the
    if block, then goto out of it. Thus the request that ends
    up being sent is not the one that was populated by the
    code in question.
    
    This fixes RNDIS driver autodetect by Windows 10 for me.
    
    The bug was introduced by Chris rework to remove the local
    queuing inside the if { } block of the redefined request.
    
    Fixes: 636ba13aec8a ("usb: gadget: composite: remove duplicated code in OS desc handling")
    Cc: <stable@vger.kernel.org> # v4.17
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d2fa071c21b1..b8a15840b4ff 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1819,7 +1819,6 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		if (cdev->use_os_string && cdev->os_desc_config &&
 		    (ctrl->bRequestType & USB_TYPE_VENDOR) &&
 		    ctrl->bRequest == cdev->b_vendor_code) {
-			struct usb_request		*req;
 			struct usb_configuration	*os_desc_cfg;
 			u8				*buf;
 			int				interface;

commit 980900d6318066b9f8314bfb87329a20fd0d1ca4
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Fri May 25 17:24:57 2018 +0800

    usb: gadget: composite: fix delayed_status race condition when set_interface
    
    It happens when enable debug log, if set_alt() returns
    USB_GADGET_DELAYED_STATUS and usb_composite_setup_continue()
    is called before increasing count of @delayed_status,
    so fix it by using spinlock of @cdev->lock.
    
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Tested-by: Jay Hsu <shih-chieh.hsu@mediatek.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f242c2bcea81..d2fa071c21b1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1719,6 +1719,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 */
 		if (w_value && !f->get_alt)
 			break;
+
+		spin_lock(&cdev->lock);
 		value = f->set_alt(f, w_index, w_value);
 		if (value == USB_GADGET_DELAYED_STATUS) {
 			DBG(cdev,
@@ -1728,6 +1730,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			DBG(cdev, "delayed_status count %d\n",
 					cdev->delayed_status);
 		}
+		spin_unlock(&cdev->lock);
 		break;
 	case USB_REQ_GET_INTERFACE:
 		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))

commit 1ef6c42afc76d2e88a7972e2f59082305d9945bc
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Wed May 9 19:29:16 2018 +0800

    usb: gadget: composite: fill bcdUSB as 0x0320 for SuperSpeed or higher speeds
    
    The USB3CV version 2.1.80 (March 26, 2018) requires all devices
    ( gen1, gen2, single lane, dual lane) to return the value of 0x0320
    in the bcdUSB field
    
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 63a7cb87514a..f242c2bcea81 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1601,7 +1601,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				cdev->gadget->ep0->maxpacket;
 			if (gadget_is_superspeed(gadget)) {
 				if (gadget->speed >= USB_SPEED_SUPER) {
-					cdev->desc.bcdUSB = cpu_to_le16(0x0310);
+					cdev->desc.bcdUSB = cpu_to_le16(0x0320);
 					cdev->desc.bMaxPacketSize0 = 9;
 				} else {
 					cdev->desc.bcdUSB = cpu_to_le16(0x0210);

commit aaeab02ddcc830e31c33cdb72a3c117b2d499ae2
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Mar 23 13:44:06 2018 +1100

    usb/gadget: Add an EP dispose() callback for EP lifetime tracking
    
    Some UDC may want to allocate endpoints dynamically, either because
    the HW supports an arbitrary large number or because (like the Aspeed
    BMC SoCs), the pool of HW endpoints is shared between multiple gadgets.
    
    The allocation side can be done rather easily using the existing
    match_ep() UDC hook.
    
    However we have no good place to "free" them.
    
    This implements a "simple" variant of this, which calls an EP dispose
    callback on all EPs associated with a gadget when the composite device
    gets unbound.
    
    This is required by my upcoming Aspeed vHub driver.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1924e20f6e8c..63a7cb87514a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2142,6 +2142,7 @@ int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
 void composite_dev_cleanup(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget_string_container *uc, *tmp;
+	struct usb_ep			   *ep, *tmp_ep;
 
 	list_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {
 		list_del(&uc->list);
@@ -2163,6 +2164,21 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 	}
 	cdev->next_string_id = 0;
 	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
+
+	/*
+	 * Some UDC backends have a dynamic EP allocation scheme.
+	 *
+	 * In that case, the dispose() callback is used to notify the
+	 * backend that the EPs are no longer in use.
+	 *
+	 * Note: The UDC backend can remove the EP from the ep_list as
+	 *	 a result, so we need to use the _safe list iterator.
+	 */
+	list_for_each_entry_safe(ep, tmp_ep,
+				 &cdev->gadget->ep_list, ep_list) {
+		if (ep->ops->dispose)
+			ep->ops->dispose(ep);
+	}
 }
 
 static int composite_bind(struct usb_gadget *gadget,

commit 636ba13aec8a0198d3fa4e2246e291a19694b50f
Author: Chris Dickens <christopher.a.dickens@gmail.com>
Date:   Sun Dec 31 18:59:43 2017 -0800

    usb: gadget: composite: remove duplicated code in OS desc handling
    
    When the host wants to fetch OS descriptors, it sends two requests. The
    first is only for the header and the second for the full amount
    specified by the header in the first request. The OS descriptor handling
    code is distinguishing the header-only requests based on the wLength of
    the setup packet, but the same code is executed in both cases to
    construct the actual header. Simplify this by always constructing the
    header and then filling out the rest of the request if the wLength is
    greater than the size of the header.
    
    Also remove the duplicate code for queueing the request to ep0 by adding
    a goto label.
    
    Signed-off-by: Chris Dickens <christopher.a.dickens@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index b8b629c615d3..1924e20f6e8c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1427,6 +1427,7 @@ static int fill_ext_compat(struct usb_configuration *c, u8 *buf)
 	int i, count;
 
 	count = 16;
+	buf += 16;
 	for (i = 0; i < c->next_interface_id; ++i) {
 		struct usb_function *f;
 		int j;
@@ -1502,6 +1503,7 @@ static int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)
 
 	f = c->interface[interface];
 	count = 10; /* header length */
+	buf += 10;
 	for (j = 0; j < f->os_desc_n; ++j) {
 		if (interface != f->os_desc_table[j].if_id)
 			continue;
@@ -1833,22 +1835,14 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				if (w_index != 0x4 || (w_value >> 8))
 					break;
 				buf[6] = w_index;
-				if (w_length == 0x10) {
-					/* Number of ext compat interfaces */
-					count = count_ext_compat(os_desc_cfg);
-					buf[8] = count;
-					count *= 24; /* 24 B/ext compat desc */
-					count += 16; /* header */
-					put_unaligned_le32(count, buf);
-					value = w_length;
-				} else {
-					/* "extended compatibility ID"s */
-					count = count_ext_compat(os_desc_cfg);
-					buf[8] = count;
-					count *= 24; /* 24 B/ext compat desc */
-					count += 16; /* header */
-					put_unaligned_le32(count, buf);
-					buf += 16;
+				/* Number of ext compat interfaces */
+				count = count_ext_compat(os_desc_cfg);
+				buf[8] = count;
+				count *= 24; /* 24 B/ext compat desc */
+				count += 16; /* header */
+				put_unaligned_le32(count, buf);
+				value = w_length;
+				if (w_length > 0x10) {
 					value = fill_ext_compat(os_desc_cfg, buf);
 					value = min_t(u16, w_length, value);
 				}
@@ -1858,46 +1852,23 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 					break;
 				interface = w_value & 0xFF;
 				buf[6] = w_index;
-				if (w_length == 0x0A) {
-					count = count_ext_prop(os_desc_cfg,
-						interface);
-					put_unaligned_le16(count, buf + 8);
-					count = len_ext_prop(os_desc_cfg,
-						interface);
-					put_unaligned_le32(count, buf);
-
-					value = w_length;
-				} else {
-					count = count_ext_prop(os_desc_cfg,
-						interface);
-					put_unaligned_le16(count, buf + 8);
-					count = len_ext_prop(os_desc_cfg,
-						interface);
-					put_unaligned_le32(count, buf);
-					buf += 10;
+				count = count_ext_prop(os_desc_cfg,
+					interface);
+				put_unaligned_le16(count, buf + 8);
+				count = len_ext_prop(os_desc_cfg,
+					interface);
+				put_unaligned_le32(count, buf);
+				value = w_length;
+				if (w_length > 0x0A) {
 					value = fill_ext_prop(os_desc_cfg,
 							      interface, buf);
-					if (value < 0)
-						return value;
-					value = min_t(u16, w_length, value);
+					if (value >= 0)
+						value = min_t(u16, w_length, value);
 				}
 				break;
 			}
 
-			if (value >= 0) {
-				req->length = value;
-				req->context = cdev;
-				req->zero = value < w_length;
-				value = composite_ep0_queue(cdev, req,
-							    GFP_ATOMIC);
-				if (value < 0) {
-					DBG(cdev, "ep_queue --> %d\n", value);
-					req->status = 0;
-					composite_setup_complete(gadget->ep0,
-								 req);
-				}
-			}
-			return value;
+			goto check_value;
 		}
 
 		VDBG(cdev,
@@ -1971,6 +1942,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		goto done;
 	}
 
+check_value:
 	/* respond with data transfer before status phase? */
 	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
 		req->length = value;

commit 5d6ae4f0da8a64a185074dabb1b2f8c148efa741
Author: Chris Dickens <christopher.a.dickens@gmail.com>
Date:   Sun Dec 31 18:59:42 2017 -0800

    usb: gadget: composite: fix incorrect handling of OS desc requests
    
    When handling an OS descriptor request, one of the first operations is
    to zero out the request buffer using the wLength from the setup packet.
    There is no bounds checking, so a wLength > 4096 would clobber memory
    adjacent to the request buffer. Fix this by taking the min of wLength
    and the request buffer length prior to the memset. While at it, define
    the buffer length in a header file so that magic numbers don't appear
    throughout the code.
    
    When returning data to the host, the data length should be the min of
    the wLength and the valid data we have to return. Currently we are
    returning wLength, thus requests for a wLength greater than the amount
    of data in the OS descriptor buffer would return invalid (albeit zero'd)
    data following the valid descriptor data. Fix this by counting the
    number of bytes when constructing the data and using this when
    determining the length of the request.
    
    Signed-off-by: Chris Dickens <christopher.a.dickens@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 77c7ecca816a..b8b629c615d3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1422,7 +1422,7 @@ static int count_ext_compat(struct usb_configuration *c)
 	return res;
 }
 
-static void fill_ext_compat(struct usb_configuration *c, u8 *buf)
+static int fill_ext_compat(struct usb_configuration *c, u8 *buf)
 {
 	int i, count;
 
@@ -1449,10 +1449,12 @@ static void fill_ext_compat(struct usb_configuration *c, u8 *buf)
 				buf += 23;
 			}
 			count += 24;
-			if (count >= 4096)
-				return;
+			if (count + 24 >= USB_COMP_EP0_OS_DESC_BUFSIZ)
+				return count;
 		}
 	}
+
+	return count;
 }
 
 static int count_ext_prop(struct usb_configuration *c, int interface)
@@ -1497,25 +1499,20 @@ static int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)
 	struct usb_os_desc *d;
 	struct usb_os_desc_ext_prop *ext_prop;
 	int j, count, n, ret;
-	u8 *start = buf;
 
 	f = c->interface[interface];
+	count = 10; /* header length */
 	for (j = 0; j < f->os_desc_n; ++j) {
 		if (interface != f->os_desc_table[j].if_id)
 			continue;
 		d = f->os_desc_table[j].os_desc;
 		if (d)
 			list_for_each_entry(ext_prop, &d->ext_prop, entry) {
-				/* 4kB minus header length */
-				n = buf - start;
-				if (n >= 4086)
-					return 0;
-
-				count = ext_prop->data_len +
+				n = ext_prop->data_len +
 					ext_prop->name_len + 14;
-				if (count > 4086 - n)
-					return -EINVAL;
-				usb_ext_prop_put_size(buf, count);
+				if (count + n >= USB_COMP_EP0_OS_DESC_BUFSIZ)
+					return count;
+				usb_ext_prop_put_size(buf, n);
 				usb_ext_prop_put_type(buf, ext_prop->type);
 				ret = usb_ext_prop_put_name(buf, ext_prop->name,
 							    ext_prop->name_len);
@@ -1541,11 +1538,12 @@ static int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)
 				default:
 					return -EINVAL;
 				}
-				buf += count;
+				buf += n;
+				count += n;
 			}
 	}
 
-	return 0;
+	return count;
 }
 
 /*
@@ -1827,6 +1825,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			req->complete = composite_setup_complete;
 			buf = req->buf;
 			os_desc_cfg = cdev->os_desc_config;
+			w_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);
 			memset(buf, 0, w_length);
 			buf[5] = 0x01;
 			switch (ctrl->bRequestType & USB_RECIP_MASK) {
@@ -1850,8 +1849,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 					count += 16; /* header */
 					put_unaligned_le32(count, buf);
 					buf += 16;
-					fill_ext_compat(os_desc_cfg, buf);
-					value = w_length;
+					value = fill_ext_compat(os_desc_cfg, buf);
+					value = min_t(u16, w_length, value);
 				}
 				break;
 			case USB_RECIP_INTERFACE:
@@ -1880,8 +1879,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 							      interface, buf);
 					if (value < 0)
 						return value;
-
-					value = w_length;
+					value = min_t(u16, w_length, value);
 				}
 				break;
 			}
@@ -2156,8 +2154,8 @@ int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
 		goto end;
 	}
 
-	/* OS feature descriptor length <= 4kB */
-	cdev->os_desc_req->buf = kmalloc(4096, GFP_KERNEL);
+	cdev->os_desc_req->buf = kmalloc(USB_COMP_EP0_OS_DESC_BUFSIZ,
+					 GFP_KERNEL);
 	if (!cdev->os_desc_req->buf) {
 		ret = -ENOMEM;
 		usb_ep_free_request(ep0, cdev->os_desc_req);

commit b2fc059fa549fe6881d4c1f8d698b0f50bcd16ec
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Nov 14 16:18:28 2017 +0000

    usb: gadget: don't dereference g until after it has been null checked
    
    Avoid dereferencing pointer g until after g has been sanity null checked;
    move the assignment of cdev much later when it is required into a more
    local scope.
    
    Detected by CoverityScan, CID#1222135 ("Dereference before null check")
    
    Fixes: b785ea7ce662 ("usb: gadget: composite: fix ep->maxburst initialization")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index eec14e6ed20b..77c7ecca816a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -146,7 +146,6 @@ int config_ep_by_speed(struct usb_gadget *g,
 			struct usb_function *f,
 			struct usb_ep *_ep)
 {
-	struct usb_composite_dev	*cdev = get_gadget_data(g);
 	struct usb_endpoint_descriptor *chosen_desc = NULL;
 	struct usb_descriptor_header **speed_desc = NULL;
 
@@ -226,8 +225,12 @@ int config_ep_by_speed(struct usb_gadget *g,
 			_ep->maxburst = comp_desc->bMaxBurst + 1;
 			break;
 		default:
-			if (comp_desc->bMaxBurst != 0)
+			if (comp_desc->bMaxBurst != 0) {
+				struct usb_composite_dev *cdev;
+
+				cdev = get_gadget_data(g);
 				ERROR(cdev, "ep0 bMaxBurst must be 0\n");
+			}
 			_ep->maxburst = 1;
 			break;
 		}

commit e79bfcb795f9cabc7d5903eb779bed3f4d14b364
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:33 2017 +0100

    USB: gadget: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a9c3904dbe1b..eec14e6ed20b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -3,11 +3,6 @@
  * composite.c - infrastructure for Composite USB Gadgets
  *
  * Copyright (C) 2006-2008 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 /* #define VERBOSE_DEBUG */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1f1ab6fa3f9d..a9c3904dbe1b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * composite.c - infrastructure for Composite USB Gadgets
  *

commit 624916a95029d1aa44167cba1b4c28ef8d45740d
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Wed Oct 25 12:22:50 2017 -0500

    usb: gadget: composite: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5d061b3d8224..1f1ab6fa3f9d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -170,20 +170,20 @@ int config_ep_by_speed(struct usb_gadget *g,
 			want_comp_desc = 1;
 			break;
 		}
-		/* else: Fall trough */
+		/* fall through */
 	case USB_SPEED_SUPER:
 		if (gadget_is_superspeed(g)) {
 			speed_desc = f->ss_descriptors;
 			want_comp_desc = 1;
 			break;
 		}
-		/* else: Fall trough */
+		/* fall through */
 	case USB_SPEED_HIGH:
 		if (gadget_is_dualspeed(g)) {
 			speed_desc = f->hs_descriptors;
 			break;
 		}
-		/* else: fall through */
+		/* fall through */
 	default:
 		speed_desc = f->fs_descriptors;
 	}
@@ -224,6 +224,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 		case USB_ENDPOINT_XFER_ISOC:
 			/* mult: bits 1:0 of bmAttributes */
 			_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;
+			/* fall through */
 		case USB_ENDPOINT_XFER_BULK:
 		case USB_ENDPOINT_XFER_INT:
 			_ep->maxburst = comp_desc->bMaxBurst + 1;

commit aec17e1e249567e82b26dafbb86de7d07fde8729
Author: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Date:   Sat Sep 30 08:55:55 2017 -0700

    usb: gadget: composite: Fix use-after-free in usb_composite_overwrite_options
    
    KASAN enabled configuration reports an error
    
        BUG: KASAN: use-after-free in usb_composite_overwrite_options+...
                    [libcomposite] at addr ...
        Read of size 1 by task ...
    
    when some driver is un-bound and then bound again.
    For example, this happens with FunctionFS driver when "ffs-test"
    test application is run several times in a row.
    
    If the driver has empty manufacturer ID string in initial static data,
    it is then replaced with generated string. After driver unbinding
    the generated string is freed, but the driver data still keep that
    pointer. And if the driver is then bound again, that pointer
    is re-used for string emptiness check.
    
    The fix is to clean up the driver string data upon its unbinding
    to drop the pointer to freed memory.
    
    Fixes: cc2683c318a5 ("usb: gadget: Provide a default implementation of default manufacturer string")
    Cc: stable@vger.kernel.org
    Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index dd74c99d6ce1..5d061b3d8224 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2026,6 +2026,8 @@ static DEVICE_ATTR_RO(suspended);
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_gadget_strings	*gstr = cdev->driver->strings[0];
+	struct usb_string		*dev_str = gstr->strings;
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
@@ -2045,6 +2047,9 @@ static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 
 	composite_dev_cleanup(cdev);
 
+	if (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev->def_manufacturer)
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = "";
+
 	kfree(cdev->def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);

commit 24040a58379e2f2fa6aa9466911b758073b6bdfa
Merge: 571949a40a9c 0591bc236015
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 20 11:39:34 2017 +0800

    Merge tag 'usb-for-v4.13' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-testing
    
    Felipe writes:
    
    usb: changes for v4.13 merge window
    
    This time around we have a total of 57 non-merge commits. A list of
    most important changes follows:
    
    - Improvements to dwc3 tracing interface
    - Initial dual-role support for dwc3
    - Improvements to how we handle DMA resources in dwc3
    - A new f_uac1 implementation which much more flexible
    - Removal of AVR32 bits
    - Improvements to f_mass_storage driver

commit 0e3e97526a850f97c9fe8b646937b3a2bef58290
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Tue Jun 6 14:47:29 2017 +0300

    usb: gadget: composite: make sure to reactivate function on unbind
    
    If a function sets bind_deactivated flag, upon removal we will be left
    with an unbalanced deactivation. Let's make sure that we conditionally
    call usb_function_activate() from usb_remove_function() and make sure
    usb_remove_function() is called from remove_config().
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 49d685ad0da9..45b554032332 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -315,6 +315,9 @@ void usb_remove_function(struct usb_configuration *c, struct usb_function *f)
 	list_del(&f->list);
 	if (f->unbind)
 		f->unbind(c, f);
+
+	if (f->bind_deactivated)
+		usb_function_activate(f);
 }
 EXPORT_SYMBOL_GPL(usb_remove_function);
 
@@ -956,12 +959,8 @@ static void remove_config(struct usb_composite_dev *cdev,
 
 		f = list_first_entry(&config->functions,
 				struct usb_function, list);
-		list_del(&f->list);
-		if (f->unbind) {
-			DBG(cdev, "unbind function '%s'/%p\n", f->name, f);
-			f->unbind(config, f);
-			/* may free memory for "f" */
-		}
+
+		usb_remove_function(config, f);
 	}
 	list_del(&config->list);
 	if (config->unbind) {

commit a9548c55295a4268f9187e1ec93264a0682fa745
Author: John Youn <johnyoun@synopsys.com>
Date:   Fri Apr 28 12:55:20 2017 +0400

    usb: gadget: Allow a non-SuperSpeed gadget to support LPM
    
    This commit allows a gadget that does not support SuperSpeed to indicate
    that it supports LPM. It does this by setting the 'lpm_capable' flag in
    the gadget structure.
    
    If a gadget sets this, the composite gadget framework will set the
    bcdUSB to 0x0201 to indicate that this supports BOS descriptors, and
    also return a USB 2.0 Extension descriptor as part of the BOS descriptor
    set.
    
    See USB 2.0 LPM ECN Section 3.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Sevak Arakelyan <sevaka@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index abec93ab81ee..d62f53d7f418 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1608,7 +1608,10 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
 				}
 			} else {
-				cdev->desc.bcdUSB = cpu_to_le16(0x0200);
+				if (gadget->lpm_capable)
+					cdev->desc.bcdUSB = cpu_to_le16(0x0201);
+				else
+					cdev->desc.bcdUSB = cpu_to_le16(0x0200);
 			}
 
 			value = min(w_length, (u16) sizeof cdev->desc);
@@ -1639,7 +1642,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				value = min(w_length, (u16) value);
 			break;
 		case USB_DT_BOS:
-			if (gadget_is_superspeed(gadget)) {
+			if (gadget_is_superspeed(gadget) ||
+			    gadget->lpm_capable) {
 				value = bos_desc(cdev);
 				value = min(w_length, (u16) value);
 			}

commit 0b67a6be14be5fb050b0358022c497d0619ebc40
Author: John Youn <johnyoun@synopsys.com>
Date:   Fri Apr 28 12:55:14 2017 +0400

    usb: gadget: composite: Exclude SS Dev Cap Desc
    
    Don't send the SuperSpeed USB Device Capability descriptor if
    the gadget is not capable of SuperSpeed.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Sevak Arakelyan <sevaka@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 49d685ad0da9..abec93ab81ee 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -607,7 +607,6 @@ static int count_configs(struct usb_composite_dev *cdev, unsigned type)
 static int bos_desc(struct usb_composite_dev *cdev)
 {
 	struct usb_ext_cap_descriptor	*usb_ext;
-	struct usb_ss_cap_descriptor	*ss_cap;
 	struct usb_dcd_config_params	dcd_config_params;
 	struct usb_bos_descriptor	*bos = cdev->req->buf;
 
@@ -633,29 +632,35 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	 * The Superspeed USB Capability descriptor shall be implemented by all
 	 * SuperSpeed devices.
 	 */
-	ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
-	bos->bNumDeviceCaps++;
-	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);
-	ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
-	ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
-	ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
-	ss_cap->bmAttributes = 0; /* LTM is not supported yet */
-	ss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |
-				USB_FULL_SPEED_OPERATION |
-				USB_HIGH_SPEED_OPERATION |
-				USB_5GBPS_OPERATION);
-	ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
-
-	/* Get Controller configuration */
-	if (cdev->gadget->ops->get_config_params)
-		cdev->gadget->ops->get_config_params(&dcd_config_params);
-	else {
-		dcd_config_params.bU1devExitLat = USB_DEFAULT_U1_DEV_EXIT_LAT;
-		dcd_config_params.bU2DevExitLat =
-			cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
+	if (gadget_is_superspeed(cdev->gadget)) {
+		struct usb_ss_cap_descriptor *ss_cap;
+
+		ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+		le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);
+		ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
+		ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
+		ss_cap->bmAttributes = 0; /* LTM is not supported yet */
+		ss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |
+						      USB_FULL_SPEED_OPERATION |
+						      USB_HIGH_SPEED_OPERATION |
+						      USB_5GBPS_OPERATION);
+		ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
+
+		/* Get Controller configuration */
+		if (cdev->gadget->ops->get_config_params) {
+			cdev->gadget->ops->get_config_params(
+				&dcd_config_params);
+		} else {
+			dcd_config_params.bU1devExitLat =
+				USB_DEFAULT_U1_DEV_EXIT_LAT;
+			dcd_config_params.bU2DevExitLat =
+				cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
+		}
+		ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
+		ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
 	}
-	ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
-	ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
 
 	/* The SuperSpeedPlus USB Device Capability descriptor */
 	if (gadget_is_superspeed_plus(cdev->gadget)) {

commit 990758c53eafe5a220a780ed12e7b4d51b3df032
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Wed Jan 4 06:30:16 2017 +0100

    usb: gadget: composite: Fix function used to free memory
    
    'cdev->os_desc_req' has been allocated with 'usb_ep_alloc_request()' so
    'usb_ep_free_request()' should be used to free it.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 002822d98fda..49d685ad0da9 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2147,7 +2147,7 @@ int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
 	cdev->os_desc_req->buf = kmalloc(4096, GFP_KERNEL);
 	if (!cdev->os_desc_req->buf) {
 		ret = -ENOMEM;
-		kfree(cdev->os_desc_req);
+		usb_ep_free_request(ep0, cdev->os_desc_req);
 		goto end;
 	}
 	cdev->os_desc_req->context = cdev;

commit 7e4da3fcf7c9fe042f2f7cb7bf23861a899b4a8f
Author: Krzysztof Opasiak <k.opasiak@samsung.com>
Date:   Tue Dec 20 19:52:16 2016 +0100

    usb: gadget: composite: Test get_alt() presence instead of set_alt()
    
    By convention (according to doc) if function does not provide
    get_alt() callback composite framework should assume that it has only
    altsetting 0 and should respond with error if host tries to set
    other one.
    
    After commit dd4dff8b035f ("USB: composite: Fix bug: should test
    set_alt function pointer before use it")
    we started checking set_alt() callback instead of get_alt().
    This check is useless as we check if set_alt() is set inside
    usb_add_function() and fail if it's NULL.
    
    Let's fix this check and move comment about why we check the get
    method instead of set a little bit closer to prevent future false
    fixes.
    
    Fixes: dd4dff8b035f ("USB: composite: Fix bug: should test set_alt function pointer before use it")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 41ab61f9b6e0..002822d98fda 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1694,9 +1694,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		value = min(w_length, (u16) 1);
 		break;
 
-	/* function drivers must handle get/set altsetting; if there's
-	 * no get() method, we know only altsetting zero works.
-	 */
+	/* function drivers must handle get/set altsetting */
 	case USB_REQ_SET_INTERFACE:
 		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
 			goto unknown;
@@ -1705,7 +1703,13 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		f = cdev->config->interface[intf];
 		if (!f)
 			break;
-		if (w_value && !f->set_alt)
+
+		/*
+		 * If there's no get_alt() method, we know only altsetting zero
+		 * works. There is no need to check if set_alt() is not NULL
+		 * as we check this in usb_add_function().
+		 */
+		if (w_value && !f->get_alt)
 			break;
 		value = f->set_alt(f, w_index, w_value);
 		if (value == USB_GADGET_DELAYED_STATUS) {

commit 5002c93135947881f4f35caadf7292f40df7ef6b
Author: Juergen Gross <jgross@suse.com>
Date:   Mon Oct 10 12:48:36 2016 +0200

    usb: gadget: composite: use kasprintf() instead of open coding it
    
    Let's not reimplement generic kernel helpers,
    instead call kasprintf().
    
    [ felipe.balbi@linux.intel.com: better commit log ]
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 919d7d1b611c..41ab61f9b6e0 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2387,18 +2387,8 @@ EXPORT_SYMBOL_GPL(usb_composite_setup_continue);
 
 static char *composite_default_mfr(struct usb_gadget *gadget)
 {
-	char *mfr;
-	int len;
-
-	len = snprintf(NULL, 0, "%s %s with %s", init_utsname()->sysname,
-			init_utsname()->release, gadget->name);
-	len++;
-	mfr = kmalloc(len, GFP_KERNEL);
-	if (!mfr)
-		return NULL;
-	snprintf(mfr, len, "%s %s with %s", init_utsname()->sysname,
-			init_utsname()->release, gadget->name);
-	return mfr;
+	return kasprintf(GFP_KERNEL, "%s %s with %s", init_utsname()->sysname,
+			 init_utsname()->release, gadget->name);
 }
 
 void usb_composite_overwrite_options(struct usb_composite_dev *cdev,

commit 9ad587710a2f7704d47ddb49ce60c909be836c2b
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 14:17:38 2016 +0300

    usb: gadget: composite: remove unnecessary & operation
    
    Now that usb_endpoint_maxp() only returns the lowest
    11 bits from wMaxPacketSize, we can remove the &
    operation from this driver.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 0426d3c1fff9..919d7d1b611c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -197,7 +197,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 
 ep_found:
 	/* commit results */
-	_ep->maxpacket = usb_endpoint_maxp(chosen_desc) & 0x7ff;
+	_ep->maxpacket = usb_endpoint_maxp(chosen_desc);
 	_ep->desc = chosen_desc;
 	_ep->comp_desc = NULL;
 	_ep->maxburst = 0;

commit eaa496ffaaf19591fe471a36cef366146eeb9153
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 12:33:31 2016 +0300

    usb: gadget: composite: always set ep->mult to a sensible value
    
    ep->mult is supposed to be set to Isochronous and
    Interrupt Endapoint's multiplier value. This value
    is computed from different places depending on the
    link speed.
    
    If we're dealing with HighSpeed, then it's part of
    bits [12:11] of wMaxPacketSize. This case wasn't
    taken into consideration before.
    
    While at that, also make sure the ep->mult defaults
    to one so drivers can use it unconditionally and
    assume they'll never multiply ep->maxpacket to zero.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f6a7583ab6d1..0426d3c1fff9 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -201,7 +201,12 @@ int config_ep_by_speed(struct usb_gadget *g,
 	_ep->desc = chosen_desc;
 	_ep->comp_desc = NULL;
 	_ep->maxburst = 0;
-	_ep->mult = 0;
+	_ep->mult = 1;
+
+	if (g->speed == USB_SPEED_HIGH && (usb_endpoint_xfer_isoc(_ep->desc) ||
+				usb_endpoint_xfer_int(_ep->desc)))
+		_ep->mult = usb_endpoint_maxp_mult(_ep->desc);
+
 	if (!want_comp_desc)
 		return 0;
 
@@ -218,7 +223,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 		switch (usb_endpoint_type(_ep->desc)) {
 		case USB_ENDPOINT_XFER_ISOC:
 			/* mult: bits 1:0 of bmAttributes */
-			_ep->mult = comp_desc->bmAttributes & 0x3;
+			_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;
 		case USB_ENDPOINT_XFER_BULK:
 		case USB_ENDPOINT_XFER_INT:
 			_ep->maxburst = comp_desc->bMaxBurst + 1;

commit e8f29bb719b47a234f33b0af62974d7a9521a52c
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 10:38:11 2016 +0300

    usb: gadget: composite: correctly initialize ep->maxpacket
    
    usb_endpoint_maxp() returns wMaxPacketSize in its
    raw form. Without taking into consideration that it
    also contains other bits reserved for isochronous
    endpoints.
    
    This patch fixes one occasion where this is a
    problem by making sure that we initialize
    ep->maxpacket only with lower 10 bits of the value
    returned by usb_endpoint_maxp(). Note that seperate
    patches will be necessary to audit all call sites of
    usb_endpoint_maxp() and make sure that
    usb_endpoint_maxp() only returns lower 10 bits of
    wMaxPacketSize.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 32176f779861..f6a7583ab6d1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -197,7 +197,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 
 ep_found:
 	/* commit results */
-	_ep->maxpacket = usb_endpoint_maxp(chosen_desc);
+	_ep->maxpacket = usb_endpoint_maxp(chosen_desc) & 0x7ff;
 	_ep->desc = chosen_desc;
 	_ep->comp_desc = NULL;
 	_ep->maxburst = 0;

commit 1a00b457a5482c3822bfc0fd64c088b2dba93e26
Author: Felix Hdicke <felixhaedicke@web.de>
Date:   Wed Jun 22 01:12:08 2016 +0200

    usb: gadget: composite: let USB functions process ctrl reqs in cfg0
    
    It can sometimes be necessary for gadget drivers to process non-standard
    control requests, which host devices can send without having sent
    USB_REQ_SET_CONFIGURATION.
    
    Therefore, the req_match() usb_function method is enhanced with the new
    parameter "config0". When a USB configuration is active, this parameter
    is false. When a non-core control request is processed in
    composite_setup(), without an active configuration, req_match() of the
    USB functions of all available configurations which implement this
    function, is called with config0=true. Then the control request gets
    processed by the first usb_function instance whose req_match() returns
    true.
    
    Signed-off-by: Felix Hdicke <felixhaedicke@web.de>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5ebe6af7976e..32176f779861 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1893,17 +1893,21 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		/* functions always handle their interfaces and endpoints...
 		 * punt other recipients (other, WUSB, ...) to the current
 		 * configuration code.
-		 *
-		 * REVISIT it could make sense to let the composite device
-		 * take such requests too, if that's ever needed:  to work
-		 * in config 0, etc.
 		 */
 		if (cdev->config) {
 			list_for_each_entry(f, &cdev->config->functions, list)
-				if (f->req_match && f->req_match(f, ctrl))
+				if (f->req_match &&
+				    f->req_match(f, ctrl, false))
 					goto try_fun_setup;
-			f = NULL;
+		} else {
+			struct usb_configuration *c;
+			list_for_each_entry(c, &cdev->configs, list)
+				list_for_each_entry(f, &c->functions, list)
+					if (f->req_match &&
+					    f->req_match(f, ctrl, true))
+						goto try_fun_setup;
 		}
+		f = NULL;
 
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:

commit 3887db5c2b6531c59e9649a4293071b575d6eb3b
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sat Jul 16 08:34:33 2016 +0200

    usb: gadget: composite: Fix return value in case of error
    
    In 'composite_os_desc_req_prepare', if one of the memory allocations fail,
    0 will be returned, which means success.
    We should return -ENOMEM instead.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a8ecc7a612b9..5ebe6af7976e 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2126,14 +2126,14 @@ int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
 
 	cdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);
 	if (!cdev->os_desc_req) {
-		ret = PTR_ERR(cdev->os_desc_req);
+		ret = -ENOMEM;
 		goto end;
 	}
 
 	/* OS feature descriptor length <= 4kB */
 	cdev->os_desc_req->buf = kmalloc(4096, GFP_KERNEL);
 	if (!cdev->os_desc_req->buf) {
-		ret = PTR_ERR(cdev->os_desc_req->buf);
+		ret = -ENOMEM;
 		kfree(cdev->os_desc_req);
 		goto end;
 	}

commit c526c62d565ea5a5bba9433f28756079734f430d
Author: Peter Chen <peter.chen@nxp.com>
Date:   Fri Jul 1 15:33:28 2016 +0800

    usb: gadget: composite: fix dereference after null check coverify warning
    
    cdev->config is checked for null pointer at above code, so cdev->config
    might be null, fix it by adding null pointer check.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index eb648485a58c..a8ecc7a612b9 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1913,6 +1913,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			break;
 
 		case USB_RECIP_ENDPOINT:
+			if (!cdev->config)
+				break;
 			endp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);
 			list_for_each_entry(f, &cdev->config->functions, list) {
 				if (test_bit(endp, f->endpoints))

commit 7e14f47a55ed67c9d8a8acea6023412f92bac936
Author: William Wu <william.wu@rock-chips.com>
Date:   Fri May 13 18:30:42 2016 +0800

    usb: gadget: composite: don't queue OS desc req if length is invalid
    
    In OS descriptors handling, if ctrl->bRequestType is
    USB_RECIP_DEVICE and w_index != 0x4 or (w_value >> 8)
    is true, it will not assign a valid value to req->length,
    but use the default value(-EOPNOTSUPP), and queue an
    OS desc request with the invalid req->length. It always
    happens on the platforms which use os_desc (for example:
    rk3366, rk3399), and cause kernel panic as follows
    (use dwc3 driver):
    
    Unable to handle kernel paging request at virtual address ffffffc0f7e00000
    Internal error: Oops: 96000146 [#1] PREEMPT SMP
    PC is at __dma_clean_range+0x18/0x30
    LR is at __swiotlb_map_page+0x50/0x64
    Call trace:
    [<ffffffc0000930f8>] __dma_clean_range+0x18/0x30
    [<ffffffc00062214c>] usb_gadget_map_request+0x134/0x1b0
    [<ffffffc0005c289c>] __dwc3_ep0_do_control_data+0x110/0x14c
    [<ffffffc0005c2d38>] __dwc3_gadget_ep0_queue+0x198/0x1b8
    [<ffffffc0005c2e18>] dwc3_gadget_ep0_queue+0xc0/0xe8
    [<ffffffc00061cfec>] composite_ep0_queue.constprop.14+0x34/0x98
    [<ffffffc00061dfb0>] composite_setup+0xf60/0x100c
    [<ffffffc0006204dc>] android_setup+0xd8/0x138
    [<ffffffc0005c29a4>] dwc3_ep0_delegate_req+0x34/0x50
    [<ffffffc0005c3534>] dwc3_ep0_interrupt+0x5dc/0xb58
    [<ffffffc0005c0c3c>] dwc3_thread_interrupt+0x15c/0xa24
    
    With this patch, the gadget driver will not queue
    a request and return immediately if req->length is
    invalid. And the usb controller driver can handle
    the unsupport request correctly.
    
    Signed-off-by: William Wu <william.wu@rock-chips.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d67de0d22a2b..eb648485a58c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1868,14 +1868,19 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				}
 				break;
 			}
-			req->length = value;
-			req->context = cdev;
-			req->zero = value < w_length;
-			value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
-			if (value < 0) {
-				DBG(cdev, "ep_queue --> %d\n", value);
-				req->status = 0;
-				composite_setup_complete(gadget->ep0, req);
+
+			if (value >= 0) {
+				req->length = value;
+				req->context = cdev;
+				req->zero = value < w_length;
+				value = composite_ep0_queue(cdev, req,
+							    GFP_ATOMIC);
+				if (value < 0) {
+					DBG(cdev, "ep_queue --> %d\n", value);
+					req->status = 0;
+					composite_setup_complete(gadget->ep0,
+								 req);
+				}
 			}
 			return value;
 		}

commit ce15bda101211dd0d42d6745f3998f87096b6f7c
Merge: 328fafb94fa1 2a58f9c12bb3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 28 09:32:39 2016 -0700

    Merge tag 'usb-for-v4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: changes for v4.7 merge window
    
    Here's the big USB Gadget pull request. This time
    not as large as usual with only 57 non-merge
    commits.
    
    The most important part here is, again, all the work
    on dwc3. This time around we're treating all
    endpoints (except for control endpoint) exactly the
    same. They all have the same amount of TRBs on the
    ring, they all treat the ring as an actual ring with
    a link TRB pointing to the head, etc.
    
    We're also helping the host side burst (on
    SuperSpeed GEN1 or GEN2 at least) for as long as
    possible until the endpoint returns NRDY.
    
    Other than this big TRB ring rework on dwc3, we also
    have a dwc3-omap DMA initialization fix, some extra
    debugfs files to aid in some odd debug sessions and
    a complete removal of our FIFO resizing logic.
    
    We have a new quirk for some dwc3 P3 quirk in some
    implementations.
    
    The rest is basically non-critical fixes and the
    usual cleanups.

commit 0878263b68df372e6389b050fc2bd4f6d5b9f332
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Fri Apr 22 14:53:47 2016 +0300

    usb: gadget: composite: avoid kernel oops with bad gadgets
    
    If a gadget driver loaded to a Superspeed-capable
    peripheral controller, using a Superspeed cable,
    doesn't provide Superspeed descriptors, we will get
    a NULL pointer dereference.
    
    In order to avoid that situation, we will try to
    find any valid descriptors we can. If no set of
    descriptors is passed in, then we'll let that gadget
    oops anyhow.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index de9ffd60fcfa..3d3cdc5ed20d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -66,20 +66,36 @@ function_descriptors(struct usb_function *f,
 {
 	struct usb_descriptor_header **descriptors;
 
+	/*
+	 * NOTE: we try to help gadget drivers which might not be setting
+	 * max_speed appropriately.
+	 */
+
 	switch (speed) {
 	case USB_SPEED_SUPER_PLUS:
 		descriptors = f->ssp_descriptors;
-		break;
+		if (descriptors)
+			break;
+		/* FALLTHROUGH */
 	case USB_SPEED_SUPER:
 		descriptors = f->ss_descriptors;
-		break;
+		if (descriptors)
+			break;
+		/* FALLTHROUGH */
 	case USB_SPEED_HIGH:
 		descriptors = f->hs_descriptors;
-		break;
+		if (descriptors)
+			break;
+		/* FALLTHROUGH */
 	default:
 		descriptors = f->fs_descriptors;
 	}
 
+	/*
+	 * if we can't find any descriptors at all, then this gadget deserves to
+	 * Oops with a NULL pointer dereference
+	 */
+
 	return descriptors;
 }
 

commit 138b8638bb43d4b85eeaacde9be9c687cc7e5de7
Author: John Youn <johnyoun@synopsys.com>
Date:   Fri Apr 8 14:46:31 2016 -0700

    usb: gadget: composite: Clear reserved fields of SSP Dev Cap
    
    Set the reserved fields of the SuperSpeed Plus Device Capability
    descriptor to 0. Otherwise there might be stale data there which will
    cause USB CV to fail.
    
    Fixes: f228a8de242a ("usb: gadget: composite: Return SSP Dev Cap descriptor")
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index de9ffd60fcfa..524e233d48de 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -651,6 +651,8 @@ static int bos_desc(struct usb_composite_dev *cdev)
 		ssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(1);
 		ssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 		ssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;
+		ssp_cap->bReserved = 0;
+		ssp_cap->wReserved = 0;
 
 		/* SSAC = 1 (2 attributes) */
 		ssp_cap->bmAttributes = cpu_to_le32(1);

commit 08f8cabf715654634a0bae8bee7afea964c6c9cb
Author: John Youn <johnyoun@synopsys.com>
Date:   Mon Mar 28 16:12:24 2016 -0700

    usb: gadget: composite: Access SSP Dev Cap fields properly
    
    Access multi-byte fields of the SSP Dev Cap descriptor using the correct
    endianness.
    
    Fixes: f228a8de242a ("usb: gadget: composite: Return SSP Dev Cap descriptor")
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a5c62093c26c..de9ffd60fcfa 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -656,7 +656,8 @@ static int bos_desc(struct usb_composite_dev *cdev)
 		ssp_cap->bmAttributes = cpu_to_le32(1);
 
 		/* Min RX/TX Lane Count = 1 */
-		ssp_cap->wFunctionalitySupport = (1 << 8) | (1 << 12);
+		ssp_cap->wFunctionalitySupport =
+			cpu_to_le16((1 << 8) | (1 << 12));
 
 		/*
 		 * bmSublinkSpeedAttr[0]:
@@ -666,7 +667,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 		 *   LSM = 10 (10 Gbps)
 		 */
 		ssp_cap->bmSublinkSpeedAttr[0] =
-			(3 << 4) | (1 << 14) | (0xa << 16);
+			cpu_to_le32((3 << 4) | (1 << 14) | (0xa << 16));
 		/*
 		 * bmSublinkSpeedAttr[1] =
 		 *   ST  = Symmetric, TX
@@ -675,7 +676,8 @@ static int bos_desc(struct usb_composite_dev *cdev)
 		 *   LSM = 10 (10 Gbps)
 		 */
 		ssp_cap->bmSublinkSpeedAttr[1] =
-			(3 << 4) | (1 << 14) | (0xa << 16) | (1 << 7);
+			cpu_to_le32((3 << 4) | (1 << 14) |
+				    (0xa << 16) | (1 << 7));
 	}
 
 	return le16_to_cpu(bos->wTotalLength);

commit c5348b621bd8a61fab3de9f69bf14c8545d7d642
Author: Li Jun <jun.li@nxp.com>
Date:   Fri Feb 19 10:04:44 2016 +0800

    usb: gadget: composite: handle otg status selector request from OTG host
    
    If gadget with HNP polling support receives GetStatus request of otg
    status selector, it feedback to host with host request flag to indicate
    if it wants to take host role.
    
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 64ad1bebb0fa..a5c62093c26c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1707,15 +1707,24 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		*((u8 *)req->buf) = value;
 		value = min(w_length, (u16) 1);
 		break;
-
-	/*
-	 * USB 3.0 additions:
-	 * Function driver should handle get_status request. If such cb
-	 * wasn't supplied we respond with default value = 0
-	 * Note: function driver should supply such cb only for the first
-	 * interface of the function
-	 */
 	case USB_REQ_GET_STATUS:
+		if (gadget_is_otg(gadget) && gadget->hnp_polling_support &&
+						(w_index == OTG_STS_SELECTOR)) {
+			if (ctrl->bRequestType != (USB_DIR_IN |
+							USB_RECIP_DEVICE))
+				goto unknown;
+			*((u8 *)req->buf) = gadget->host_request_flag;
+			value = 1;
+			break;
+		}
+
+		/*
+		 * USB 3.0 additions:
+		 * Function driver should handle get_status request. If such cb
+		 * wasn't supplied we respond with default value = 0
+		 * Note: function driver should supply such cb only for the
+		 * first interface of the function
+		 */
 		if (!gadget_is_superspeed(gadget))
 			goto unknown;
 		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))

commit cd69cbeb6977bbe5747b99b380007d7ec28f8095
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:07:44 2016 -0800

    usb: gadget: composite: Update debug message for SuperSpeedPlus
    
    Update the debug message reporting the speeds that a configuration
    supports for SuperSpeedPlus.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 60b6e4b4c7e5..64ad1bebb0fa 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -891,8 +891,9 @@ int usb_add_config(struct usb_composite_dev *cdev,
 	} else {
 		unsigned	i;
 
-		DBG(cdev, "cfg %d/%p speeds:%s%s%s\n",
+		DBG(cdev, "cfg %d/%p speeds:%s%s%s%s\n",
 			config->bConfigurationValue, config,
+			config->superspeed_plus ? " superplus" : "",
 			config->superspeed ? " super" : "",
 			config->highspeed ? " high" : "",
 			config->fullspeed

commit 4eb8e32dabef701e481ae18d7f5a4a6b850cccc9
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:07:30 2016 -0800

    usb: gadget: composite: Configure the usb_ep for SuperSpeedPlus
    
    Configure the usb_ep using the SuperSpeedPlus descriptors if connected
    in SuperSpeedPlus.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index b938fcfee235..60b6e4b4c7e5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -148,6 +148,13 @@ int config_ep_by_speed(struct usb_gadget *g,
 
 	/* select desired speed */
 	switch (g->speed) {
+	case USB_SPEED_SUPER_PLUS:
+		if (gadget_is_superspeed_plus(g)) {
+			speed_desc = f->ssp_descriptors;
+			want_comp_desc = 1;
+			break;
+		}
+		/* else: Fall trough */
 	case USB_SPEED_SUPER:
 		if (gadget_is_superspeed(g)) {
 			speed_desc = f->ss_descriptors;
@@ -191,7 +198,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 	    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))
 		return -EIO;
 	_ep->comp_desc = comp_desc;
-	if (g->speed == USB_SPEED_SUPER) {
+	if (g->speed >= USB_SPEED_SUPER) {
 		switch (usb_endpoint_type(_ep->desc)) {
 		case USB_ENDPOINT_XFER_ISOC:
 			/* mult: bits 1:0 of bmAttributes */

commit eae5820b852f2b434fc7734b5b1226bcc4ae9b92
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:07:17 2016 -0800

    usb: gadget: composite: Write SuperSpeedPlus config descriptors
    
    Enable writing of SuperSpeedPlus descriptors for any SuperSpeedPlus
    capable configuration when connected in SuperSpeedPlus.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1d4f324e4bac..b938fcfee235 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -473,7 +473,7 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 	u8				type = w_value >> 8;
 	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
 
-	if (gadget->speed == USB_SPEED_SUPER)
+	if (gadget->speed >= USB_SPEED_SUPER)
 		speed = gadget->speed;
 	else if (gadget_is_dualspeed(gadget)) {
 		int	hs = 0;
@@ -504,6 +504,10 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 check_config:
 		/* ignore configs that won't work at this speed */
 		switch (speed) {
+		case USB_SPEED_SUPER_PLUS:
+			if (!c->superspeed_plus)
+				continue;
+			break;
 		case USB_SPEED_SUPER:
 			if (!c->superspeed)
 				continue;

commit f3bdbe36682631d5e13ef933670ef0b47d9aaa87
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:07:03 2016 -0800

    usb: gadget: composite: Add function to get descriptors
    
    There are a couple places in the code that get the function descriptors
    based on the speed. Move this lookup into a function call and add
    support to handle the SuperSpeedPlus descriptors as well.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 44ad7aa6f8f1..1d4f324e4bac 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -53,6 +53,36 @@ static struct usb_gadget_strings **get_containers_gs(
 	return (struct usb_gadget_strings **)uc->stash;
 }
 
+/**
+ * function_descriptors() - get function descriptors for speed
+ * @f: the function
+ * @speed: the speed
+ *
+ * Returns the descriptors or NULL if not set.
+ */
+static struct usb_descriptor_header **
+function_descriptors(struct usb_function *f,
+		     enum usb_device_speed speed)
+{
+	struct usb_descriptor_header **descriptors;
+
+	switch (speed) {
+	case USB_SPEED_SUPER_PLUS:
+		descriptors = f->ssp_descriptors;
+		break;
+	case USB_SPEED_SUPER:
+		descriptors = f->ss_descriptors;
+		break;
+	case USB_SPEED_HIGH:
+		descriptors = f->hs_descriptors;
+		break;
+	default:
+		descriptors = f->fs_descriptors;
+	}
+
+	return descriptors;
+}
+
 /**
  * next_ep_desc() - advance to the next EP descriptor
  * @t: currect pointer within descriptor array
@@ -419,17 +449,7 @@ static int config_buf(struct usb_configuration *config,
 	list_for_each_entry(f, &config->functions, list) {
 		struct usb_descriptor_header **descriptors;
 
-		switch (speed) {
-		case USB_SPEED_SUPER:
-			descriptors = f->ss_descriptors;
-			break;
-		case USB_SPEED_HIGH:
-			descriptors = f->hs_descriptors;
-			break;
-		default:
-			descriptors = f->fs_descriptors;
-		}
-
+		descriptors = function_descriptors(f, speed);
 		if (!descriptors)
 			continue;
 		status = usb_descriptor_fillbuf(next, len,
@@ -740,16 +760,7 @@ static int set_config(struct usb_composite_dev *cdev,
 		 * function's setup callback instead of the current
 		 * configuration's setup callback.
 		 */
-		switch (gadget->speed) {
-		case USB_SPEED_SUPER:
-			descriptors = f->ss_descriptors;
-			break;
-		case USB_SPEED_HIGH:
-			descriptors = f->hs_descriptors;
-			break;
-		default:
-			descriptors = f->fs_descriptors;
-		}
+		descriptors = function_descriptors(f, gadget->speed);
 
 		for (; *descriptors; ++descriptors) {
 			struct usb_endpoint_descriptor *ep;

commit a4afd012f400b5b41e2db2b0bf7e384f738411ae
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:06:49 2016 -0800

    usb: gadget: composite: Count configs for SuperSpeedPlus
    
    If enumerated in SuperSpeedPlus, count the configurations that support
    it.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 560330f5457c..44ad7aa6f8f1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -511,18 +511,24 @@ static int count_configs(struct usb_composite_dev *cdev, unsigned type)
 	unsigned			count = 0;
 	int				hs = 0;
 	int				ss = 0;
+	int				ssp = 0;
 
 	if (gadget_is_dualspeed(gadget)) {
 		if (gadget->speed == USB_SPEED_HIGH)
 			hs = 1;
 		if (gadget->speed == USB_SPEED_SUPER)
 			ss = 1;
+		if (gadget->speed == USB_SPEED_SUPER_PLUS)
+			ssp = 1;
 		if (type == USB_DT_DEVICE_QUALIFIER)
 			hs = !hs;
 	}
 	list_for_each_entry(c, &cdev->configs, list) {
 		/* ignore configs that won't work at this speed */
-		if (ss) {
+		if (ssp) {
+			if (!c->superspeed_plus)
+				continue;
+		} else if (ss) {
 			if (!c->superspeed)
 				continue;
 		} else if (hs) {

commit 554eead5436401ae3cfdb7d79fca24c14ebab143
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:06:35 2016 -0800

    usb: gadget: Update config for SuperSpeedPlus
    
    When a function is added to a configuration with usb_add_function(), the
    configuration speed flags are updated. These flags indicate for which
    speeds the configuration is valid for.
    
    This patch adds a flag in the configuration for SuperSpeedPlus and
    also updates this based on the existence of ssp_descriptors.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 11d243349ebf..560330f5457c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -237,6 +237,8 @@ int usb_add_function(struct usb_configuration *config,
 		config->highspeed = true;
 	if (!config->superspeed && function->ss_descriptors)
 		config->superspeed = true;
+	if (!config->superspeed_plus && function->ssp_descriptors)
+		config->superspeed_plus = true;
 
 done:
 	if (value)

commit f228a8de242a85659d9c86f2b9ff862775f015c2
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:05:53 2016 -0800

    usb: gadget: composite: Return SSP Dev Cap descriptor
    
    If a gadget supports SuperSpeedPlus or higher speeds, return a
    SuperSpeedPlus USB Device Capability descriptor.
    
    Currently this implementation returns a fixed descriptor with typical
    values set.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index ce5dbc59311d..11d243349ebf 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -597,6 +597,48 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
 	ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
 
+	/* The SuperSpeedPlus USB Device Capability descriptor */
+	if (gadget_is_superspeed_plus(cdev->gadget)) {
+		struct usb_ssp_cap_descriptor *ssp_cap;
+
+		ssp_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+		bos->bNumDeviceCaps++;
+
+		/*
+		 * Report typical values.
+		 */
+
+		le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SSP_CAP_SIZE(1));
+		ssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(1);
+		ssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+		ssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;
+
+		/* SSAC = 1 (2 attributes) */
+		ssp_cap->bmAttributes = cpu_to_le32(1);
+
+		/* Min RX/TX Lane Count = 1 */
+		ssp_cap->wFunctionalitySupport = (1 << 8) | (1 << 12);
+
+		/*
+		 * bmSublinkSpeedAttr[0]:
+		 *   ST  = Symmetric, RX
+		 *   LSE =  3 (Gbps)
+		 *   LP  =  1 (SuperSpeedPlus)
+		 *   LSM = 10 (10 Gbps)
+		 */
+		ssp_cap->bmSublinkSpeedAttr[0] =
+			(3 << 4) | (1 << 14) | (0xa << 16);
+		/*
+		 * bmSublinkSpeedAttr[1] =
+		 *   ST  = Symmetric, TX
+		 *   LSE =  3 (Gbps)
+		 *   LP  =  1 (SuperSpeedPlus)
+		 *   LSM = 10 (10 Gbps)
+		 */
+		ssp_cap->bmSublinkSpeedAttr[1] =
+			(3 << 4) | (1 << 14) | (0xa << 16) | (1 << 7);
+	}
+
 	return le16_to_cpu(bos->wTotalLength);
 }
 

commit 1a85329171094951956a37acc8abb7e51c1e742e
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Feb 5 17:05:40 2016 -0800

    usb: gadget: composite: Return bcdUSB 0x0310
    
    The USB 3.1 specification replaces the USB 3.0 specification and all new
    devices that are running at SuperSpeed or higher speeds must report a
    bcdUSB of 0x0310.
    
    Refer to USB 3.1 Specification, Revision 1.0, Section 9.6.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8b14c2a13ac5..ce5dbc59311d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1499,7 +1499,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				cdev->gadget->ep0->maxpacket;
 			if (gadget_is_superspeed(gadget)) {
 				if (gadget->speed >= USB_SPEED_SUPER) {
-					cdev->desc.bcdUSB = cpu_to_le16(0x0300);
+					cdev->desc.bcdUSB = cpu_to_le16(0x0310);
 					cdev->desc.bMaxPacketSize0 = 9;
 				} else {
 					cdev->desc.bcdUSB = cpu_to_le16(0x0210);

commit 5527e73305e8a9958b00331902a27514e62d539b
Author: Igor Kotrasinski <i.kotrasinsk@samsung.com>
Date:   Thu Aug 20 10:00:01 2015 +0200

    usb: gadget: composite: fill bcdUSB for any gadget max speed
    
    When handling device GET_DESCRIPTOR, composite gadget driver fills
    the bcdUSB field only if the gadget supports USB 3.0. Otherwise
    the field is left unfilled.
    
    For consistency, set bcdUSB to 0x0200 for gadgets that don't
    support superspeed.
    
    It's correct to use 0x0200 for any setting that doesn't use
    superspeed, since USB 2.0 devices can restrict themselves to
    full speed only. It is NOT correct to use 0x0210, since BOS
    descriptors are handled only if gadget_is_superspeed() is
    satisfied, otherwise it results in a stall.
    
    Signed-off-by: Igor Kotrasinski <i.kotrasinsk@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3e95c0e88b8b..8b14c2a13ac5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1504,6 +1504,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				} else {
 					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
 				}
+			} else {
+				cdev->desc.bcdUSB = cpu_to_le16(0x0200);
 			}
 
 			value = min(w_length, (u16) sizeof cdev->desc);

commit f871cb9b2e178667a351a6fae9d930826ec10e95
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Wed Sep 16 12:10:39 2015 +0200

    usb: gadget: fix few outdated comments
    
    Fix comments in code to make them up to date.
    
    composite: claiming endpoint is now done by setting ep->claimed flag,
    not ep->driver_data.
    
    epautoconf: usb_ep_autoconfig() and usb_ep_autoconfig_ss() return
    claimed endpoint with ep->claimed flag already set.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index b474499839d3..3e95c0e88b8b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -839,9 +839,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 		}
 	}
 
-	/* set_alt(), or next bind(), sets up
-	 * ep->driver_data as needed.
-	 */
+	/* set_alt(), or next bind(), sets up ep->claimed as needed */
 	usb_ep_autoconfig_reset(cdev->gadget);
 
 done:

commit 53e6242db8d60da0587d36951cc9434d1a1c21dd
Author: Macpaul Lin <macpaul@gmail.com>
Date:   Thu Jul 9 15:18:42 2015 +0800

    usb: gadget: composite: add USB_DT_OTG request handling
    
    Copy usb_otg_descriptor from config's descriptor if host requests
    USB_DT_OTG.
    
    Signed-off-by: Macpaul Lin <macpaul@gmail.com>
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 36c6f47642f8..b474499839d3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -19,6 +19,7 @@
 #include <linux/utsname.h>
 
 #include <linux/usb/composite.h>
+#include <linux/usb/otg.h>
 #include <asm/unaligned.h>
 
 #include "u_os_desc.h"
@@ -1540,6 +1541,32 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				value = min(w_length, (u16) value);
 			}
 			break;
+		case USB_DT_OTG:
+			if (gadget_is_otg(gadget)) {
+				struct usb_configuration *config;
+				int otg_desc_len = 0;
+
+				if (cdev->config)
+					config = cdev->config;
+				else
+					config = list_first_entry(
+							&cdev->configs,
+						struct usb_configuration, list);
+				if (!config)
+					goto done;
+
+				if (gadget->otg_caps &&
+					(gadget->otg_caps->otg_rev >= 0x0200))
+					otg_desc_len += sizeof(
+						struct usb_otg20_descriptor);
+				else
+					otg_desc_len += sizeof(
+						struct usb_otg_descriptor);
+
+				value = min_t(int, w_length, otg_desc_len);
+				memcpy(req->buf, config->descriptors[0], value);
+			}
+			break;
 		}
 		break;
 

commit d5bb9b81dbfa35d117ecb58022ee6e7e41e4772d
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Mon May 4 14:55:13 2015 +0200

    usb: composite: add bind_deactivated flag to usb_function
    
    This patch introduces 'bind_deactivated' flag in struct usb_function.
    Functions which don't want to be activated automatically after bind should
    set this flag, and when they start to be ready to work they should call
    usb_function_activate().
    
    When USB function sets 'bind_deactivated' flag, initial deactivation
    counter is incremented automatically, so there is no need to call
    usb_function_deactivate() in function bind.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 86d4e8fdf8d3..36c6f47642f8 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -209,6 +209,12 @@ int usb_add_function(struct usb_configuration *config,
 	function->config = config;
 	list_add_tail(&function->list, &config->functions);
 
+	if (function->bind_deactivated) {
+		value = usb_function_deactivate(function);
+		if (value)
+			goto done;
+	}
+
 	/* REVISIT *require* function->bind? */
 	if (function->bind) {
 		value = function->bind(config, function);

commit 5601250bb1b4e736cf487d332f2d8d8833a84209
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Mon May 4 14:55:12 2015 +0200

    usb: composite: fix usb_function_activate/deactivate functions
    
    Using usb_gadget_disconnect to make gadget temporarily invisible to host
    doesn't provide desired result, because gadget is connected immediately
    after binding regardless to previous usb_gadget_disconnect() calls.
    
    For this reason we use usb_gadget_deactivate() instead of
    usb_gadget_disconnect() to make it working as expected.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9ff3203b50e2..86d4e8fdf8d3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -279,7 +279,7 @@ int usb_function_deactivate(struct usb_function *function)
 	spin_lock_irqsave(&cdev->lock, flags);
 
 	if (cdev->deactivations == 0)
-		status = usb_gadget_disconnect(cdev->gadget);
+		status = usb_gadget_deactivate(cdev->gadget);
 	if (status == 0)
 		cdev->deactivations++;
 
@@ -311,7 +311,7 @@ int usb_function_activate(struct usb_function *function)
 	else {
 		cdev->deactivations--;
 		if (cdev->deactivations == 0)
-			status = usb_gadget_connect(cdev->gadget);
+			status = usb_gadget_activate(cdev->gadget);
 	}
 
 	spin_unlock_irqrestore(&cdev->lock, flags);

commit ad4676ab58ae38e5597a2d6bc0d12e9b5e0b0d18
Author: Diego Viola <diego.viola@gmail.com>
Date:   Sun May 31 15:52:41 2015 -0300

    usb: gadget: composite.c: i18n is not an acronym
    
    I18N should be spelled as i18n because it's not
    an acronym
    
    Signed-off-by: Diego Viola <diego.viola@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 58b4657fc721..9ff3203b50e2 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -896,7 +896,7 @@ void usb_remove_config(struct usb_composite_dev *cdev,
 
 /* We support strings in multiple languages ... string descriptor zero
  * says which languages are supported.  The typical case will be that
- * only one language (probably English) is used, with I18N handled on
+ * only one language (probably English) is used, with i18n handled on
  * the host side.
  */
 
@@ -949,7 +949,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	struct usb_function		*f;
 	int				len;
 
-	/* Yes, not only is USB's I18N support probably more than most
+	/* Yes, not only is USB's i18n support probably more than most
 	 * folk will ever care about ... also, it's all supported here.
 	 * (Except for UTF8 support for Unicode's "Astral Planes".)
 	 */

commit b4c21f0bdd2c0cd5d5be1bb56f0a28dae5041eed
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Jun 11 22:12:11 2015 +0530

    usb: gadget: composite: Fix NULL pointer dereference
    
    commit f563d230903210acc ("usb: gadget: composite: add req_match method
    to usb_function") accesses cdev->config even before set config
    is invoked causing a NULL pointer dereferencing error while running
    Lecroy Mass Storage Compliance test.
    
    Fix it here by accessing cdev->config only if it is non NULL.
    
    Fixes: commit f563d230903210acc ("usb: gadget: composite: add req_match
    method to usb_function").
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 4e3447bbd097..58b4657fc721 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1758,10 +1758,13 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 * take such requests too, if that's ever needed:  to work
 		 * in config 0, etc.
 		 */
-		list_for_each_entry(f, &cdev->config->functions, list)
-			if (f->req_match && f->req_match(f, ctrl))
-				goto try_fun_setup;
-		f = NULL;
+		if (cdev->config) {
+			list_for_each_entry(f, &cdev->config->functions, list)
+				if (f->req_match && f->req_match(f, ctrl))
+					goto try_fun_setup;
+			f = NULL;
+		}
+
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
 			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)

commit 06ed0de5188c9ef6553b2824b6cdd767ad46ece5
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Mar 10 22:37:46 2015 +0900

    usb: gadget: Fix typo fond in Documentation/Docbook/gadget.xml
    
    This patch fix some spelling typo found in gadget.xml.
    It is because this file is generated from comments in sources,
    I had to fix comments in the source, instead of xml file itself.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 4d25e11b1f72..4e3447bbd097 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1161,11 +1161,11 @@ static struct usb_gadget_string_container *copy_gadget_strings(
  * This function will create a deep copy of usb_gadget_strings and usb_string
  * and attach it to the cdev. The actual string (usb_string.s) will not be
  * copied but only a referenced will be made. The struct usb_gadget_strings
- * array may contain multiple languges and should be NULL terminated.
+ * array may contain multiple languages and should be NULL terminated.
  * The ->language pointer of each struct usb_gadget_strings has to contain the
  * same amount of entries.
  * For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
- * usb_string entry of es-ES containts the translation of the first usb_string
+ * usb_string entry of es-ES contains the translation of the first usb_string
  * entry of en-US. Therefore both entries become the same id assign.
  */
 struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,

commit f563d230903210acc2336af58e422216b68ded76
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Mar 3 10:52:23 2015 +0100

    usb: gadget: composite: add req_match method to usb_function
    
    Non-standard requests can encode the actual interface number in a
    non-standard way. For example composite_setup() assumes
    that it is w_index && 0xFF, but the printer function encodes the interface
    number in a context-dependet way (either w_index or w_index >> 8).
    This can lead to such requests being directed to wrong functions.
    
    This patch adds req_match() method to usb_function. Its purpose is to
    verify that a given request can be handled by a given function.
    If any function within a configuration provides the method and it returns
    true, then it is assumed that the right function is found.
    
    If a function uses req_match(), it should try as hard as possible to
    determine if the request is meant for it.
    
    If no functions in a configuration provide req_match or none of them
    returns true, then fall back to the usual approach.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9fb92310fb2b..4d25e11b1f72 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1758,6 +1758,10 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 * take such requests too, if that's ever needed:  to work
 		 * in config 0, etc.
 		 */
+		list_for_each_entry(f, &cdev->config->functions, list)
+			if (f->req_match && f->req_match(f, ctrl))
+				goto try_fun_setup;
+		f = NULL;
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
 			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
@@ -1775,7 +1779,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				f = NULL;
 			break;
 		}
-
+try_fun_setup:
 		if (f && f->setup)
 			value = f->setup(f, ctrl);
 		else {

commit 232c0102e84b7fce634c8902a5fa30ca2b3342ac
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Mar 3 10:52:04 2015 +0100

    usb: gadget: composite: don't try standard handling for non-standard requests
    
    If a non-standard request is processed and its parameters just happen
    to match those of some standard request, the logic of composite_setup()
    can be fooled, so don't even try any switch cases, just go to the
    proper place where unknown requests are handled.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 13adfd1a3f54..9fb92310fb2b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1472,6 +1472,13 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	req->length = 0;
 	gadget->ep0->driver_data = cdev;
 
+	/*
+	 * Don't let non-standard requests match any of the cases below
+	 * by accident.
+	 */
+	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)
+		goto unknown;
+
 	switch (ctrl->bRequest) {
 
 	/* we handle all standard USB descriptors */

commit df6738d0d23321da834e9025845e26e09b0f6615
Author: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date:   Mon Jan 26 20:30:27 2015 +0100

    usb: gadget: Fix os desc test
    
    USB vendor type is encoded in field bmRequestType. Make test USB_TYPE_VENDOR
    with bRequestType instead of bRequest.
    
    Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 617835348569..13adfd1a3f54 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1655,7 +1655,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 * OS descriptors handling
 		 */
 		if (cdev->use_os_string && cdev->os_desc_config &&
-		    (ctrl->bRequest & USB_TYPE_VENDOR) &&
+		    (ctrl->bRequestType & USB_TYPE_VENDOR) &&
 		    ctrl->bRequest == cdev->b_vendor_code) {
 			struct usb_request		*req;
 			struct usb_configuration	*os_desc_cfg;

commit 3a571870856f63064a3a45d7ffa2526d597b7fbe
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Wed Oct 8 12:03:36 2014 +0200

    usb: gadget: configfs: add suspend/resume
    
    USB gadgets composed with configfs lack suspend and resume
    methods. This patch uses composite_suspend()/composite_resume()
    the same way e.g. composite_setup() or composite_disconnect()
    are used in a configfs-based gadget.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index e071d580346e..617835348569 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2064,8 +2064,7 @@ static int composite_bind(struct usb_gadget *gadget,
 
 /*-------------------------------------------------------------------------*/
 
-static void
-composite_suspend(struct usb_gadget *gadget)
+void composite_suspend(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
@@ -2088,8 +2087,7 @@ composite_suspend(struct usb_gadget *gadget)
 	usb_gadget_vbus_draw(gadget, 2);
 }
 
-static void
-composite_resume(struct usb_gadget *gadget)
+void composite_resume(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;

commit a7c12eaf2e5eea0c15242ebb7d1d3b6e7fcb62bb
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Sep 18 10:01:55 2014 -0500

    usb: gadget: composite: conditionally dequeue os_desc and setup requests
    
    In case we unload a gadget driver while any of
    os_desc_req or req are still pending, we need
    to make sure to dequeue them.
    
    By using our setup_pending and os_desc_pending
    flags we achieve that in a way that doesn't
    cause any regressions because we won't dequeue
    a request which was already completed.
    
    The original idea came from Li Jun's commit
    f2267089ea17fa97b796b1b4247e3f8957655df3
    (usb: gadget: composite: dequeue cdev->req
    before free it in composite_dev_cleanup) which,
    unfortunately, caused two regressions (kfree()
    being called before usb_ep_dequeue() and calling
    usb_ep_dequeue() when the request was already
    completed). That commit also didn't take care
    of os_desc_req which can fall into the same
    situation so we must care for that one too.
    
    Note that in order to make code slightly easier
    to read, we introduce composite_ep_queue() which
    hides details about how to fiddle with our pending
    flags.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 09602dc90205..e071d580346e 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1246,10 +1246,49 @@ EXPORT_SYMBOL_GPL(usb_string_ids_n);
 
 static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
 {
+	struct usb_composite_dev *cdev;
+
 	if (req->status || req->actual != req->length)
 		DBG((struct usb_composite_dev *) ep->driver_data,
 				"setup complete --> %d, %d/%d\n",
 				req->status, req->actual, req->length);
+
+	/*
+	 * REVIST The same ep0 requests are shared with function drivers
+	 * so they don't have to maintain the same ->complete() stubs.
+	 *
+	 * Because of that, we need to check for the validity of ->context
+	 * here, even though we know we've set it to something useful.
+	 */
+	if (!req->context)
+		return;
+
+	cdev = req->context;
+
+	if (cdev->req == req)
+		cdev->setup_pending = false;
+	else if (cdev->os_desc_req == req)
+		cdev->os_desc_pending = false;
+	else
+		WARN(1, "unknown request %p\n", req);
+}
+
+static int composite_ep0_queue(struct usb_composite_dev *cdev,
+		struct usb_request *req, gfp_t gfp_flags)
+{
+	int ret;
+
+	ret = usb_ep_queue(cdev->gadget->ep0, req, gfp_flags);
+	if (ret == 0) {
+		if (cdev->req == req)
+			cdev->setup_pending = true;
+		else if (cdev->os_desc_req == req)
+			cdev->os_desc_pending = true;
+		else
+			WARN(1, "unknown request %p\n", req);
+	}
+
+	return ret;
 }
 
 static int count_ext_compat(struct usb_configuration *c)
@@ -1690,7 +1729,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			req->length = value;
 			req->context = cdev;
 			req->zero = value < w_length;
-			value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+			value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
 			if (value < 0) {
 				DBG(cdev, "ep_queue --> %d\n", value);
 				req->status = 0;
@@ -1762,7 +1801,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		req->length = value;
 		req->context = cdev;
 		req->zero = value < w_length;
-		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+		value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
 		if (value < 0) {
 			DBG(cdev, "ep_queue --> %d\n", value);
 			req->status = 0;
@@ -1957,10 +1996,16 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 		kfree(uc);
 	}
 	if (cdev->os_desc_req) {
+		if (cdev->os_desc_pending)
+			usb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);
+
 		kfree(cdev->os_desc_req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
 	}
 	if (cdev->req) {
+		if (cdev->setup_pending)
+			usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+
 		kfree(cdev->req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
@@ -2165,7 +2210,7 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 		DBG(cdev, "%s: Completing delayed status\n", __func__);
 		req->length = 0;
 		req->context = cdev;
-		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		value = composite_ep0_queue(cdev, req, GFP_ATOMIC);
 		if (value < 0) {
 			DBG(cdev, "ep_queue --> %d\n", value);
 			req->status = 0;

commit 57943716ff1b0733ab0d9879e572bad04166660a
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Sep 18 09:54:54 2014 -0500

    usb: gadget: composite: set our req->context to cdev
    
    by doing that we will be able to match our
    requests against req and os_desc_req and also
    clear our pending flags from complete callback.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f6a51fddd5b5..09602dc90205 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1428,6 +1428,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	 * when we delegate to it.
 	 */
 	req->zero = 0;
+	req->context = cdev;
 	req->complete = composite_setup_complete;
 	req->length = 0;
 	gadget->ep0->driver_data = cdev;
@@ -1624,6 +1625,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			int				count = 0;
 
 			req = cdev->os_desc_req;
+			req->context = cdev;
 			req->complete = composite_setup_complete;
 			buf = req->buf;
 			os_desc_cfg = cdev->os_desc_config;
@@ -1686,6 +1688,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				break;
 			}
 			req->length = value;
+			req->context = cdev;
 			req->zero = value < w_length;
 			value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
 			if (value < 0) {
@@ -1757,6 +1760,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	/* respond with data transfer before status phase? */
 	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
 		req->length = value;
+		req->context = cdev;
 		req->zero = value < w_length;
 		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
@@ -1893,6 +1897,7 @@ int composite_dev_prepare(struct usb_composite_driver *composite,
 		goto fail_dev;
 
 	cdev->req->complete = composite_setup_complete;
+	cdev->req->context = cdev;
 	gadget->ep0->driver_data = cdev;
 
 	cdev->driver = composite;
@@ -1937,6 +1942,7 @@ int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
 		kfree(cdev->os_desc_req);
 		goto end;
 	}
+	cdev->os_desc_req->context = cdev;
 	cdev->os_desc_req->complete = composite_setup_complete;
 end:
 	return ret;
@@ -2158,6 +2164,7 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 	} else if (--cdev->delayed_status == 0) {
 		DBG(cdev, "%s: Completing delayed status\n", __func__);
 		req->length = 0;
+		req->context = cdev;
 		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
 			DBG(cdev, "ep_queue --> %d\n", value);

commit a6615937bcd9234e6d6bb817c3701fce44d0a84d
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Sep 30 16:08:03 2014 -0500

    usb: gadget: composite: enable BESL support
    
    According to USB 2.0 ECN Errata for Link Power
    Management (USB2-LPM-Errata-final.pdf), BESL
    must be enabled if LPM is enabled.
    
    This helps with USB30CV TD 9.21 LPM L1
    Suspend Resume Test.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a8c18df171c3..f6a51fddd5b5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -560,7 +560,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
-	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);
+	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all

commit bf17eba7ae1e813b0ad67cb1078dcbd7083b906e
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Sep 18 09:31:32 2014 -0500

    Revert "usb: gadget: composite: dequeue cdev->req before free it in composite_dev_cleanup"
    
    This reverts commit f2267089ea17fa97b796b1b4247e3f8957655df3.
    
    That commit causes more problem than fixes. Firstly, kfree()
    should be called after usb_ep_dequeue() and secondly, the way
    things are, we will try to dequeue a request that has already
    completed much more frequently than one which is pending.
    
    Cc: Li Jun <b47624@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Cc: stable <stable@vger.kernel.org> # 3.17
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index e07eddbb3f8c..a8c18df171c3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1956,7 +1956,6 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 	}
 	if (cdev->req) {
 		kfree(cdev->req->buf);
-		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
 	cdev->next_string_id = 0;

commit 72a65a0d19c16de36e970ca6981732b5e8f7f4c4
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Sep 18 09:41:39 2014 -0500

    Revert "usb: gadget: composite: dequeue cdev->req before free its buffer"
    
    This reverts commit be0a8887bb931af0e21531da20c41533effbb0d6.
    
    The original commit f2267089ea17fa97b796b1b4247e3f8957655df3
    (usb: gadget: composite: dequeue cdev->req before free it in
    composite_dev_cleanup) ended up being reverted because it caused
    more issues then fixed. We will also revert this counter part
    commit so we start clean to properly add that idea back.
    
    Cc: Li Jun <b47624@freescale.com>
    Signed-of-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3f3d6f217abe..e07eddbb3f8c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1955,8 +1955,8 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
 	}
 	if (cdev->req) {
-		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 		kfree(cdev->req->buf);
+		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
 	cdev->next_string_id = 0;

commit d8a816fc6f6a1d262798dc43d6791c3e93d2d2b5
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 9 08:56:49 2014 +0800

    usb: gadget: composite: add reset API at usb_gadget_driver
    
    Add reset API at usb_gadget_driver, it calls disconnect handler currently,
    but may do different things in future.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 4514e73d9e70..3f3d6f217abe 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2073,6 +2073,7 @@ static const struct usb_gadget_driver composite_driver_template = {
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
+	.reset		= composite_disconnect,
 	.disconnect	= composite_disconnect,
 
 	.suspend	= composite_suspend,

commit be0a8887bb931af0e21531da20c41533effbb0d6
Author: Li Jun <B47624@freescale.com>
Date:   Thu Aug 28 21:44:11 2014 +0800

    usb: gadget: composite: dequeue cdev->req before free its buffer
    
    commit f226708(usb: gadget: composite: dequeue cdev->req before free it in
    composite_dev_cleanup) fixed a bug: free the usb request(i.e. cdev->req) but
    does not dequeue it beforehand. This fix is not proper enough because it
    dequeues the request after free its data buffer, considering the hardware can
    access the buffer's memory anytime before the request's complettion rountine
    runs, and usb_ep_dequeue always call the complettion rountine before it returns,
    so the best way is to dequeue the request before free its buffer.
    
    Suggested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 6935a822ce2b..4514e73d9e70 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1955,8 +1955,8 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
 	}
 	if (cdev->req) {
-		kfree(cdev->req->buf);
 		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+		kfree(cdev->req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
 	cdev->next_string_id = 0;

commit f2267089ea17fa97b796b1b4247e3f8957655df3
Author: Li Jun <B47624@freescale.com>
Date:   Tue Jul 15 22:07:40 2014 +0800

    usb: gadget: composite: dequeue cdev->req before free it in composite_dev_cleanup
    
    This patch try to dequeue the cdev->req to guarantee the request is not queued
    before free it.
    
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f80151932053..6935a822ce2b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1956,6 +1956,7 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 	}
 	if (cdev->req) {
 		kfree(cdev->req->buf);
+		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
 	cdev->next_string_id = 0;

commit 849b1333153c989b3618e05981fd23f61fcfdee4
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon May 19 06:31:07 2014 +0200

    usb: gadget: make return of 0 explicit
    
    Delete unnecessary local variable whose value is always 0 and that hides
    the fact that the result is always 0.
    
    A simplified version of the semantic patch that fixes this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    local idexpression ret;
    expression e;
    position p;
    @@
    
    -ret = 0;
    ... when != ret = e
    return
    - ret
    + 0
      ;
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 042c66b71df8..f80151932053 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1312,9 +1312,7 @@ static void fill_ext_compat(struct usb_configuration *c, u8 *buf)
 static int count_ext_prop(struct usb_configuration *c, int interface)
 {
 	struct usb_function *f;
-	int j, res;
-
-	res = 0;
+	int j;
 
 	f = c->interface[interface];
 	for (j = 0; j < f->os_desc_n; ++j) {
@@ -1326,7 +1324,7 @@ static int count_ext_prop(struct usb_configuration *c, int interface)
 		if (d && d->ext_compat_id)
 			return d->ext_prop_count;
 	}
-	return res;
+	return 0;
 }
 
 static int len_ext_prop(struct usb_configuration *c, int interface)

commit 37a3a533429ef9b3cc9f15a656c19623f0e88df7
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu May 8 14:06:23 2014 +0200

    usb: gadget: OS Feature Descriptors support
    
    There is a custom (non-USB IF) extension to the USB standard:
    
    http://msdn.microsoft.com/library/windows/hardware/gg463182
    
    They grant permission to use the specification - there is
    "Microsoft OS Descriptor Specification License Agreement"
    under the link mentioned above, and its Section 2 "Grant
    of License", letter (b) reads:
    
    "Patent license. Microsoft hereby grants to You a nonexclusive,
    royalty-free, nontransferable, worldwide license under Microsofts
    patents embodied solely within the Specification and that are owned
    or licensable by Microsoft to make, use, import, offer to sell,
    sell and distribute directly or indirectly to Your Licensees Your
    Implementation. You may sublicense this patent license to Your
    Licensees under the same terms and conditions."
    
    The said extension is maintained by Microsoft for Microsoft.
    
    Yet it is fairly common for various devices to use it, and a
    popular proprietary operating system expects devices to provide
    "OS descriptors", so Linux-based USB gadgets whishing to be able
    to talk to a variety of operating systems should be able to provide
    the "OS descriptors".
    
    This patch adds optional support for gadgets whishing to expose
    the so called "OS Feature Descriptors", that is "Extended Compatibility ID"
    and "Extended Properties".
    
    Hosts which do request "OS descriptors" from gadgets do so during
    the enumeration phase and before the configuration is set with
    SET_CONFIGURATION. What is more, those hosts never ask for configurations
    at indices other than 0. Therefore, gadgets whishing to provide
    "OS descriptors" must designate one configuration to be used with
    this kind of hosts - this is what os_desc_config is added for in
    struct usb_composite_dev. There is an additional advantage to it:
    if a gadget provides "OS descriptors" and designates one configuration
    to be used with such non-USB-compliant hosts it can invoke
    "usb_add_config" in any order because the designated configuration
    will be reported to be at index 0 anyway.
    
    This patch also adds handling vendor-specific requests addressed
    at device or interface and related to handling "OS descriptors".
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2f87b1697bf5..042c66b71df8 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -21,6 +21,8 @@
 #include <linux/usb/composite.h>
 #include <asm/unaligned.h>
 
+#include "u_os_desc.h"
+
 /**
  * struct usb_os_string - represents OS String to be reported by a gadget
  * @bLength: total length of the entire descritor, always 0x12
@@ -438,6 +440,7 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 {
 	struct usb_gadget		*gadget = cdev->gadget;
 	struct usb_configuration	*c;
+	struct list_head		*pos;
 	u8				type = w_value >> 8;
 	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
 
@@ -456,7 +459,20 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 
 	/* This is a lookup by config *INDEX* */
 	w_value &= 0xff;
-	list_for_each_entry(c, &cdev->configs, list) {
+
+	pos = &cdev->configs;
+	c = cdev->os_desc_config;
+	if (c)
+		goto check_config;
+
+	while ((pos = pos->next) !=  &cdev->configs) {
+		c = list_entry(pos, typeof(*c), list);
+
+		/* skip OS Descriptors config which is handled separately */
+		if (c == cdev->os_desc_config)
+			continue;
+
+check_config:
 		/* ignore configs that won't work at this speed */
 		switch (speed) {
 		case USB_SPEED_SUPER:
@@ -1236,6 +1252,158 @@ static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
 				req->status, req->actual, req->length);
 }
 
+static int count_ext_compat(struct usb_configuration *c)
+{
+	int i, res;
+
+	res = 0;
+	for (i = 0; i < c->next_interface_id; ++i) {
+		struct usb_function *f;
+		int j;
+
+		f = c->interface[i];
+		for (j = 0; j < f->os_desc_n; ++j) {
+			struct usb_os_desc *d;
+
+			if (i != f->os_desc_table[j].if_id)
+				continue;
+			d = f->os_desc_table[j].os_desc;
+			if (d && d->ext_compat_id)
+				++res;
+		}
+	}
+	BUG_ON(res > 255);
+	return res;
+}
+
+static void fill_ext_compat(struct usb_configuration *c, u8 *buf)
+{
+	int i, count;
+
+	count = 16;
+	for (i = 0; i < c->next_interface_id; ++i) {
+		struct usb_function *f;
+		int j;
+
+		f = c->interface[i];
+		for (j = 0; j < f->os_desc_n; ++j) {
+			struct usb_os_desc *d;
+
+			if (i != f->os_desc_table[j].if_id)
+				continue;
+			d = f->os_desc_table[j].os_desc;
+			if (d && d->ext_compat_id) {
+				*buf++ = i;
+				*buf++ = 0x01;
+				memcpy(buf, d->ext_compat_id, 16);
+				buf += 22;
+			} else {
+				++buf;
+				*buf = 0x01;
+				buf += 23;
+			}
+			count += 24;
+			if (count >= 4096)
+				return;
+		}
+	}
+}
+
+static int count_ext_prop(struct usb_configuration *c, int interface)
+{
+	struct usb_function *f;
+	int j, res;
+
+	res = 0;
+
+	f = c->interface[interface];
+	for (j = 0; j < f->os_desc_n; ++j) {
+		struct usb_os_desc *d;
+
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d && d->ext_compat_id)
+			return d->ext_prop_count;
+	}
+	return res;
+}
+
+static int len_ext_prop(struct usb_configuration *c, int interface)
+{
+	struct usb_function *f;
+	struct usb_os_desc *d;
+	int j, res;
+
+	res = 10; /* header length */
+	f = c->interface[interface];
+	for (j = 0; j < f->os_desc_n; ++j) {
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d)
+			return min(res + d->ext_prop_len, 4096);
+	}
+	return res;
+}
+
+static int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)
+{
+	struct usb_function *f;
+	struct usb_os_desc *d;
+	struct usb_os_desc_ext_prop *ext_prop;
+	int j, count, n, ret;
+	u8 *start = buf;
+
+	f = c->interface[interface];
+	for (j = 0; j < f->os_desc_n; ++j) {
+		if (interface != f->os_desc_table[j].if_id)
+			continue;
+		d = f->os_desc_table[j].os_desc;
+		if (d)
+			list_for_each_entry(ext_prop, &d->ext_prop, entry) {
+				/* 4kB minus header length */
+				n = buf - start;
+				if (n >= 4086)
+					return 0;
+
+				count = ext_prop->data_len +
+					ext_prop->name_len + 14;
+				if (count > 4086 - n)
+					return -EINVAL;
+				usb_ext_prop_put_size(buf, count);
+				usb_ext_prop_put_type(buf, ext_prop->type);
+				ret = usb_ext_prop_put_name(buf, ext_prop->name,
+							    ext_prop->name_len);
+				if (ret < 0)
+					return ret;
+				switch (ext_prop->type) {
+				case USB_EXT_PROP_UNICODE:
+				case USB_EXT_PROP_UNICODE_ENV:
+				case USB_EXT_PROP_UNICODE_LINK:
+					usb_ext_prop_put_unicode(buf, ret,
+							 ext_prop->data,
+							 ext_prop->data_len);
+					break;
+				case USB_EXT_PROP_BINARY:
+					usb_ext_prop_put_binary(buf, ret,
+							ext_prop->data,
+							ext_prop->data_len);
+					break;
+				case USB_EXT_PROP_LE32:
+					/* not implemented */
+				case USB_EXT_PROP_BE32:
+					/* not implemented */
+				default:
+					return -EINVAL;
+				}
+				buf += count;
+			}
+	}
+
+	return 0;
+}
+
 /*
  * The setup() callback implements all the ep0 functionality that's
  * not handled lower down, in hardware or the hardware driver(like
@@ -1445,6 +1613,91 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		break;
 	default:
 unknown:
+		/*
+		 * OS descriptors handling
+		 */
+		if (cdev->use_os_string && cdev->os_desc_config &&
+		    (ctrl->bRequest & USB_TYPE_VENDOR) &&
+		    ctrl->bRequest == cdev->b_vendor_code) {
+			struct usb_request		*req;
+			struct usb_configuration	*os_desc_cfg;
+			u8				*buf;
+			int				interface;
+			int				count = 0;
+
+			req = cdev->os_desc_req;
+			req->complete = composite_setup_complete;
+			buf = req->buf;
+			os_desc_cfg = cdev->os_desc_config;
+			memset(buf, 0, w_length);
+			buf[5] = 0x01;
+			switch (ctrl->bRequestType & USB_RECIP_MASK) {
+			case USB_RECIP_DEVICE:
+				if (w_index != 0x4 || (w_value >> 8))
+					break;
+				buf[6] = w_index;
+				if (w_length == 0x10) {
+					/* Number of ext compat interfaces */
+					count = count_ext_compat(os_desc_cfg);
+					buf[8] = count;
+					count *= 24; /* 24 B/ext compat desc */
+					count += 16; /* header */
+					put_unaligned_le32(count, buf);
+					value = w_length;
+				} else {
+					/* "extended compatibility ID"s */
+					count = count_ext_compat(os_desc_cfg);
+					buf[8] = count;
+					count *= 24; /* 24 B/ext compat desc */
+					count += 16; /* header */
+					put_unaligned_le32(count, buf);
+					buf += 16;
+					fill_ext_compat(os_desc_cfg, buf);
+					value = w_length;
+				}
+				break;
+			case USB_RECIP_INTERFACE:
+				if (w_index != 0x5 || (w_value >> 8))
+					break;
+				interface = w_value & 0xFF;
+				buf[6] = w_index;
+				if (w_length == 0x0A) {
+					count = count_ext_prop(os_desc_cfg,
+						interface);
+					put_unaligned_le16(count, buf + 8);
+					count = len_ext_prop(os_desc_cfg,
+						interface);
+					put_unaligned_le32(count, buf);
+
+					value = w_length;
+				} else {
+					count = count_ext_prop(os_desc_cfg,
+						interface);
+					put_unaligned_le16(count, buf + 8);
+					count = len_ext_prop(os_desc_cfg,
+						interface);
+					put_unaligned_le32(count, buf);
+					buf += 10;
+					value = fill_ext_prop(os_desc_cfg,
+							      interface, buf);
+					if (value < 0)
+						return value;
+
+					value = w_length;
+				}
+				break;
+			}
+			req->length = value;
+			req->zero = value < w_length;
+			value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+			if (value < 0) {
+				DBG(cdev, "ep_queue --> %d\n", value);
+				req->status = 0;
+				composite_setup_complete(gadget->ep0, req);
+			}
+			return value;
+		}
+
 		VDBG(cdev,
 			"non-core control req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
@@ -1668,6 +1921,29 @@ int composite_dev_prepare(struct usb_composite_driver *composite,
 	return ret;
 }
 
+int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,
+				  struct usb_ep *ep0)
+{
+	int ret = 0;
+
+	cdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);
+	if (!cdev->os_desc_req) {
+		ret = PTR_ERR(cdev->os_desc_req);
+		goto end;
+	}
+
+	/* OS feature descriptor length <= 4kB */
+	cdev->os_desc_req->buf = kmalloc(4096, GFP_KERNEL);
+	if (!cdev->os_desc_req->buf) {
+		ret = PTR_ERR(cdev->os_desc_req->buf);
+		kfree(cdev->os_desc_req);
+		goto end;
+	}
+	cdev->os_desc_req->complete = composite_setup_complete;
+end:
+	return ret;
+}
+
 void composite_dev_cleanup(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget_string_container *uc, *tmp;
@@ -1676,6 +1952,10 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 		list_del(&uc->list);
 		kfree(uc);
 	}
+	if (cdev->os_desc_req) {
+		kfree(cdev->os_desc_req->buf);
+		usb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);
+	}
 	if (cdev->req) {
 		kfree(cdev->req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
@@ -1713,6 +1993,12 @@ static int composite_bind(struct usb_gadget *gadget,
 	if (status < 0)
 		goto fail;
 
+	if (cdev->use_os_string) {
+		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
+		if (status)
+			goto fail;
+	}
+
 	update_unchanged_dev_desc(&cdev->desc, composite->dev);
 
 	/* has userspace failed to provide a serial number? */

commit 19824d5eeecedfb46639961da1b7a21ba3179930
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu May 8 14:06:22 2014 +0200

    usb: gadget: OS String support
    
    There is a custom (non-USB IF) extension to the USB standard:
    
    http://msdn.microsoft.com/library/windows/hardware/gg463182
    
    They grant permission to use the specification - there is
    "Microsoft OS Descriptor Specification License Agreement"
    under the link mentioned above, and its Section 2 "Grant
    of License", letter (b) reads:
    
    "Patent license. Microsoft hereby grants to You a nonexclusive,
    royalty-free, nontransferable, worldwide license under Microsofts
    patents embodied solely within the Specification and that are owned
    or licensable by Microsoft to make, use, import, offer to sell,
    sell and distribute directly or indirectly to Your Licensees Your
    Implementation. You may sublicense this patent license to Your
    Licensees under the same terms and conditions."
    
    The said extension is maintained by Microsoft for Microsoft.
    
    Yet it is fairly common for various devices to use it, and a
    popular proprietary operating system expects devices to provide
    "OS descriptors", so Linux-based USB gadgets whishing to be able
    to talk to a variety of operating systems should be able to provide
    the "OS descriptors".
    
    This patch adds optional support for gadgets whishing to expose
    the so called "OS String" under index 0xEE of language 0.
    The contents of the string is generated based on the qw_sign
    array and b_vendor_code.
    
    Interested gadgets need to set the cdev->use_os_string flag,
    fill cdev->qw_sign with appropriate values and fill cdev->b_vendor_code
    with a value of their choice.
    
    This patch does not however implement responding to any vendor-specific
    USB requests.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8060de6562cd..2f87b1697bf5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -21,6 +21,22 @@
 #include <linux/usb/composite.h>
 #include <asm/unaligned.h>
 
+/**
+ * struct usb_os_string - represents OS String to be reported by a gadget
+ * @bLength: total length of the entire descritor, always 0x12
+ * @bDescriptorType: USB_DT_STRING
+ * @qwSignature: the OS String proper
+ * @bMS_VendorCode: code used by the host for subsequent requests
+ * @bPad: not used, must be zero
+ */
+struct usb_os_string {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	qwSignature[OS_STRING_QW_SIGN_LEN];
+	__u8	bMS_VendorCode;
+	__u8	bPad;
+} __packed;
+
 /*
  * The code in this file is utility code, used to build a gadget driver
  * from one or more "function" drivers, one or more "configuration"
@@ -961,6 +977,19 @@ static int get_string(struct usb_composite_dev *cdev,
 		return s->bLength;
 	}
 
+	if (cdev->use_os_string && language == 0 && id == OS_STRING_IDX) {
+		struct usb_os_string *b = buf;
+		b->bLength = sizeof(*b);
+		b->bDescriptorType = USB_DT_STRING;
+		compiletime_assert(
+			sizeof(b->qwSignature) == sizeof(cdev->qw_sign),
+			"qwSignature size must be equal to qw_sign");
+		memcpy(&b->qwSignature, cdev->qw_sign, sizeof(b->qwSignature));
+		b->bMS_VendorCode = cdev->b_vendor_code;
+		b->bPad = 0;
+		return sizeof(*b);
+	}
+
 	list_for_each_entry(uc, &cdev->gstrings, list) {
 		struct usb_gadget_strings **sp;
 

commit 6027f3173e797bf27fc5053aa74c9f40f85538d8
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Apr 29 13:26:28 2014 +0800

    usb: gadget: set gadget state as configured
    
    Set gadget device state as configurated after set configuration
    has finished.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index fab906429b80..8060de6562cd 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -634,6 +634,7 @@ static int set_config(struct usb_composite_dev *cdev,
 	if (!c)
 		goto done;
 
+	usb_gadget_set_state(gadget, USB_STATE_CONFIGURED);
 	cdev->config = c;
 
 	/* Initialize all interfaces by setting them to altsetting zero. */

commit dad4babe419ef2f3e14447a650ce1f760a6ee9e0
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Mar 10 13:30:56 2014 -0500

    usb: gadget: composite: switch over to ERR_CAST()
    
    This patch fixes the following Coccinelle warning:
    
    drivers/usb/gadget/composite.c:1142:9-16: WARNING: \
            ERR_CAST can be used with uc
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d742bed7a5fa..fab906429b80 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1139,7 +1139,7 @@ struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,
 
 	uc = copy_gadget_strings(sp, n_gstrings, n_strings);
 	if (IS_ERR(uc))
-		return ERR_PTR(PTR_ERR(uc));
+		return ERR_CAST(uc);
 
 	n_gs = get_containers_gs(uc);
 	ret = usb_string_ids_tab(cdev, n_gs[0]->strings);

commit 56b1b909d7afa5e0415363fafec3df0fc34b95c5
Author: Du, ChangbinX <changbinx.du@intel.com>
Date:   Tue Dec 17 11:47:42 2013 +0000

    usb: gadget: should use u16 type variable to store MaxPower
    
    From 7e827a0d300e084f74c65122baa5e3193f9a7f18 Mon Sep 17 00:00:00 2001
    From: "Du, Changbin" <changbinx.du@intel.com>
    Date: Mon, 16 Dec 2013 20:32:13 +0800
    Subject: [PATCH] usb/gadget: should use u16 type variable to store MaxPower
    
    The MaxPower field is of u16 type. So using u8 type variable can break
    data (high byte lost).
    
    Signed-off-by: Du, Changbin <changbinx.du@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 43cbd76fca06..d742bed7a5fa 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1728,7 +1728,7 @@ composite_resume(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
-	u8				maxpower;
+	u16				maxpower;
 
 	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?

commit c139e1425ff7bec7ac22ed90acbadb1b7aa091a9
Merge: 4a5ee77caad2 319e2e3f63c3
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 19 09:18:53 2013 -0600

    Merge tag 'v3.13-rc4' into next
    
    Linux 3.13-rc4
    
    * tag 'v3.13-rc4': (1001 commits)
      Linux 3.13-rc4
      null_blk: mem garbage on NUMA systems during init
      radeon_pm: fix oops in hwmon_attributes_visible() and radeon_hwmon_show_temp_thresh()
      Revert "selinux: consider filesystem subtype in policies"
      igb: Fix for issue where values could be too high for udelay function.
      i40e: fix null dereference
      ARM: fix asm/memory.h build error
      dm array: fix a reference counting bug in shadow_ablock
      dm space map: disallow decrementing a reference count below zero
      mm: memcg: do not allow task about to OOM kill to bypass the limit
      mm: memcg: fix race condition between memcg teardown and swapin
      thp: move preallocated PTE page table on move_huge_pmd()
      mfd/rtc: s5m: fix register updating by adding regmap for RTC
      rtc: s5m: enable IRQ wake during suspend
      rtc: s5m: limit endless loop waiting for register update
      rtc: s5m: fix unsuccesful IRQ request during probe
      drivers/rtc/rtc-s5m.c: fix info->rtc assignment
      include/linux/kernel.h: make might_fault() a nop for !MMU
      drivers/rtc/rtc-at91rm9200.c: correct alarm over day/month wrap
      procfs: also fix proc_reg_get_unmapped_area() for !MMU case
      ...
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit a01091e5ce866562ea2638a80f2241d8d6bde164
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu Nov 7 08:41:25 2013 +0100

    usb: gadget: composite: redirect setup requests
    
    If there are setup requests not directed to an endpont or an interface,
    current config's setup() has been attempted so far.
    This patch, in case the above fails, adds code which tries the setup() of
    configuration's function if there is only one function in the configuration.
    
    This behavior is required to provide equivalent of gadget zero with configfs.
    
    The gadget zero has a "config driver" for sourcesink, but all it does is
    delegating the request to the function proper. So when the equivalent gadget
    is set up with configfs it needs to handle requests directed to
    "config driver", but with configfs it is not possible to specify
    "config drivers".
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3e7ae707f691..611fe89c3a8b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1451,8 +1451,22 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			struct usb_configuration	*c;
 
 			c = cdev->config;
-			if (c && c->setup)
+			if (!c)
+				goto done;
+
+			/* try current config's setup */
+			if (c->setup) {
 				value = c->setup(c, ctrl);
+				goto done;
+			}
+
+			/* try the only function in the current config */
+			if (!list_is_singular(&c->functions))
+				goto done;
+			f = list_first_entry(&c->functions, struct usb_function,
+					     list);
+			if (f->setup)
+				value = f->setup(f, ctrl);
 		}
 
 		goto done;

commit 2bac51a1827a18821150ed8c9f9752c02f9c2b02
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Mon Nov 11 23:43:32 2013 +0100

    usb: gadget: composite: reset delayed_status on reset_config
    
    The delayed_status value is used to keep track of status response
    packets on ep0. It needs to be reset or the set_config function would
    still delay the answer, if the usb device got unplugged while waiting
    for setup_continue to be called.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3e7ae707f691..2018ba1a2172 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -593,6 +593,7 @@ static void reset_config(struct usb_composite_dev *cdev)
 		bitmap_zero(f->endpoints, 32);
 	}
 	cdev->config = NULL;
+	cdev->delayed_status = 0;
 }
 
 static int set_config(struct usb_composite_dev *cdev,

commit 2b84f92b8141679be6b90396655fa4887589ec28
Author: Joe Perches <joe@perches.com>
Date:   Tue Oct 8 16:01:37 2013 -0700

    usb: Remove unnecessary semicolons
    
    These aren't necessary after switch and if blocks.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d4f0f3305759..3e7ae707f691 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -354,7 +354,7 @@ static u8 encode_bMaxPower(enum usb_device_speed speed,
 		return DIV_ROUND_UP(val, 8);
 	default:
 		return DIV_ROUND_UP(val, 2);
-	};
+	}
 }
 
 static int config_buf(struct usb_configuration *config,

commit ce26bd23d4ad180883f53709f9a2220dc771c030
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 23 16:34:43 2013 -0700

    USB: gadget: audit sysfs attribute permissions
    
    Convert all USB gadget sysfs attributes to use the _RO or _RW variants,
    to make them easier to audit and ensure that the permissions are
    correct.
    
    Note, two are left using the DEVICE_ATTR() macro, as there is no
    DEVICE_ATTR_WO() in Linus's tree, that will happen after 3.12-rc1 is
    out, a follow-on patch will be sent then.
    
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    --
     drivers/usb/gadget/composite.c      |    8 +++-----
     drivers/usb/gadget/dummy_hcd.c      |    8 ++++----
     drivers/usb/gadget/f_mass_storage.c |   14 ++++++--------
     drivers/usb/gadget/net2272.c        |    4 ++--
     drivers/usb/gadget/net2280.c        |   18 +++++++++---------
     drivers/usb/gadget/storage_common.c |   25 ++++++++++++-------------
     drivers/usb/gadget/udc-core.c       |   14 +++++++-------
     7 files changed, 43 insertions(+), 48 deletions(-)

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 55f4df60f327..d4f0f3305759 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1497,17 +1497,15 @@ void composite_disconnect(struct usb_gadget *gadget)
 
 /*-------------------------------------------------------------------------*/
 
-static ssize_t composite_show_suspended(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+static ssize_t suspended_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
 {
 	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
 	struct usb_composite_dev *cdev = get_gadget_data(gadget);
 
 	return sprintf(buf, "%d\n", cdev->suspended);
 }
-
-static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
+static DEVICE_ATTR_RO(suspended);
 
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {

commit 88af8bbe4ef781031ad3370847553f3b42ba0076
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:24 2012 +0100

    usb: gadget: the start of the configfs interface
    
    |# modprobe dummy_hcd num=2
    |# modprobe libcomposite
    
    |# lsmod
    |Module                  Size  Used by
    |libcomposite           31648  0
    |dummy_hcd              19871  0
    
    |# mkdir /sys/kernel/config/usb_gadget/oha
    |# cd /sys/kernel/config/usb_gadget/oha
    |# mkdir configs/def.1
    |# mkdir configs/def.2
    |# mkdir functions/acm.ttyS1
    |# mkdir strings/0x1
    |mkdir: cannot create directory `strings/0x1': Invalid argument
    |# mkdir strings/0x409
    |# mkdir strings/1033
    |mkdir: cannot create directory `strings/1033': File exists
    |# mkdir strings/1032
    |# mkdir configs/def.1/strings/0x409
    |# mkdir configs/def.2/strings/0x409
    
    |#find . -ls
    |   975    0 drwxr-xr-x   5 root     root            0 Dec 23 17:40 .
    |   978    0 drwxr-xr-x   4 root     root            0 Dec 23 17:43 ./strings
    |  4100    0 drwxr-xr-x   2 root     root            0 Dec 23 17:43 ./strings/1032
    |   995    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/1032/serialnumber
    |   996    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/1032/product
    |   997    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/1032/manufacturer
    |  2002    0 drwxr-xr-x   2 root     root            0 Dec 23 17:41 ./strings/0x409
    |   998    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/0x409/serialnumber
    |   999    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/0x409/product
    |  1000    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./strings/0x409/manufacturer
    |   977    0 drwxr-xr-x   4 root     root            0 Dec 23 17:41 ./configs
    |  4081    0 drwxr-xr-x   3 root     root            0 Dec 23 17:41 ./configs/def.2
    |  4082    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./configs/def.2/strings
    |  2016    0 drwxr-xr-x   2 root     root            0 Dec 23 17:42 ./configs/def.2/strings/0x409
    |  1001    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.2/strings/0x409/configuration
    |  1002    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.2/bmAttributes
    |  1003    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.2/MaxPower
    |   979    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./configs/def.1
    |   980    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 ./configs/def.1/strings
    |  5122    0 drwxr-xr-x   2 root     root            0 Dec 23 17:42 ./configs/def.1/strings/0x409
    |  1004    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.1/strings/0x409/configuration
    |  1005    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.1/bmAttributes
    |  1006    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./configs/def.1/MaxPower
    |   976    0 drwxr-xr-x   3 root     root            0 Dec 23 17:41 ./functions
    |   981    0 drwxr-xr-x   2 root     root            0 Dec 23 17:41 ./functions/acm.ttyS1
    |  1007    0 -r--r--r--   1 root     root         4096 Dec 23 17:43 ./functions/acm.ttyS1/port_num
    |  1008    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./UDC
    |  1009    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bcdUSB
    |  1010    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bcdDevice
    |  1011    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./idProduct
    |  1012    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./idVendor
    |  1013    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bMaxPacketSize0
    |  1014    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDeviceProtocol
    |  1015    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDeviceSubClass
    |  1016    0 -rw-r--r--   1 root     root         4096 Dec 23 17:43 ./bDeviceClass
    
    |# cat functions/acm.ttyS1/port_num
    |0
    |# ls -lah /dev/ttyGS*
    |crw-rw---T 1 root dialout 252, 0 Dec 23 17:41 /dev/ttyGS0
    |
    |# echo 0x1234 > idProduct
    |# echo 0xabcd > idVendor
    |# echo 1122 > strings/0x409/serialnumber
    |# echo "The manufacturer" > strings/0x409/manufacturer
    |# echo 1 > strings/1032/manufacturer
    |# echo 1sa > strings/1032/product
    |# echo tada > strings/1032/serialnumber
    |echo "Primary configuration" > configs/def.1/strings/0x409/configuration
    |# echo "Secondary configuration" > configs/def.2/strings/0x409/configuration
    |# ln -s functions/acm.ttyS1 configs/def.1/
    |# ln -s functions/acm.ttyS1 configs/def.2/
    |find configs/def.1/ -ls
    |   979    0 drwxr-xr-x   3 root     root            0 Dec 23 17:49 configs/def.1/
    |  6264    0 lrwxrwxrwx   1 root     root            0 Dec 23 17:48 configs/def.1/acm.ttyS1 -> ../../../../usb_gadget/oha/functions/acm.ttyS1
    |   980    0 drwxr-xr-x   3 root     root            0 Dec 23 17:42 configs/def.1/strings
    |  5122    0 drwxr-xr-x   2 root     root            0 Dec 23 17:49 configs/def.1/strings/0x409
    |  6284    0 -rw-r--r--   1 root     root         4096 Dec 23 17:47 configs/def.1/strings/0x409/configuration
    |  6285    0 -rw-r--r--   1 root     root         4096 Dec 23 17:49 configs/def.1/bmAttributes
    |  6286    0 -rw-r--r--   1 root     root         4096 Dec 23 17:49 configs/def.1/MaxPower
    |
    |echo 120 > configs/def.1/MaxPower
    |
    |# ls -lh /sys/class/udc/
    |total 0
    |lrwxrwxrwx 1 root root 0 Dec 23 17:50 dummy_udc.0 -> ../../devices/platform/dummy_udc.0/udc/dummy_udc.0
    |lrwxrwxrwx 1 root root 0 Dec 23 17:50 dummy_udc.1 -> ../../devices/platform/dummy_udc.1/udc/dummy_udc.1
    |# echo dummy_udc.0 > UDC
    |# lsusb
    |Bus 001 Device 002: ID abcd:1234 Unknown
    |
    |lsusb -d abcd:1234 -v
    |Device Descriptor:
    
    |  idVendor           0xabcd Unknown
    |  idProduct          0x1234
    |  bcdDevice            3.06
    |  iManufacturer           1 The manufacturer
    |  iProduct                2
    |  iSerial                 3 1122
    |  bNumConfigurations      2
    
    |echo "" > UDC
    
    v5v6
    - wired up strings with usb_gstrings_attach()
    - add UDC attribe. Write "udc-name" will bind the gadget. Write an empty
      string (it should contain \n since 0 bytes write get optimzed away)
      will unbind the UDC from the gadget. The name of available UDCs can be
      obtained from /sys/class/udc/
    
    v4v5
    - string rework. This will add a strings folder incl. language code like
        strings/409/manufacturer
      as suggested by Alan.
    - rebased ontop reworked functions.c which has usb_function_instance
      which is used prior after "mkdir acm.instance" and can be directly
      used for configuration via configfs.
    
    v3v4
     - moved functions from the root folde down to the gadget as suggested
       by Micha
     - configs have now their own configs folder as suggested by Micha.
       The folder is still name.bConfigurationValue where name becomes the
       sConfiguration. Is this usefull should we just stilc
       configs/bConfigurationValue/ ?
     - added configfs support to the ACM function. The port_num attribute is
       exported by f_acm. An argument has been added to the USB alloc
       function to distinguish between "old" (use facm_configure() to
       configure and configfs interface (expose a config_node).
       The port_num is currently a dumb counter. It will
       require some function re-work to make it work.
    
    scheduled for v5:
    - sym linking function into config.
    
    v2v3
    - replaced one ifndef by ifdef as suggested by Micaha
    - strstr()/strchr() function_make as suggested by Micah
    - replace [iSerialNumber|iProduct|iManufacturer] with
      [sSerialNumber|sProduct|sManufacturer] as suggested by Alan
    - added creation of config descriptors
    
    v1v2
    - moved gadgets from configfs' root directory into /udcs/ within our
      "usb_gadget" folder. Requested by Andrzej & Micha
    - use a dot as a delimiter between function's name and its instance's name
      as suggested by Micha
    - renamed all config_item_type, configfs_group_operations, make_group,
      drop_item as suggested by suggested by Andrzej to remain consisten
      within this file and within other configfs users
    - Since configfs.c and functions.c are now part of the udc-core module,
      the module itself is now called udc. Also added a tiny ifdef around
      init code becuase udc-core is subsys init and this is too early for
      configfs in the built-in case. In the module case, we can only have
      one init function.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c0d62b278610..55f4df60f327 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1637,6 +1637,7 @@ void composite_dev_cleanup(struct usb_composite_dev *cdev)
 		kfree(cdev->req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
+	cdev->next_string_id = 0;
 	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
 }
 

commit 43febb27dcdaf9a15e2f362a6d09b0f191c4dcea
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Mar 4 16:52:38 2013 -0600

    usb: gadget: composite: fix kernel-doc warnings
    
    A few trivial fixes for composite driver:
    
    Warning(include/linux/usb/composite.h:165): No description found for parameter
            'fs_descriptors'
    Warning(include/linux/usb/composite.h:165): Excess struct/union/enum/typedef
            member 'descriptors' description in 'usb_function'
    Warning(include/linux/usb/composite.h:321): No description found for parameter
            'gadget_driver'
    Warning(drivers/usb/gadget/composite.c:1777): Excess function parameter 'bind'
            description in 'usb_composite_probe'
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: linux-usb@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 7c821de8ce3d..c0d62b278610 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1757,10 +1757,7 @@ static const struct usb_gadget_driver composite_driver_template = {
 /**
  * usb_composite_probe() - register a composite driver
  * @driver: the driver to register
- * @bind: the callback used to allocate resources that are shared across the
- *	whole device, such as string IDs, and add its configurations using
- *	@usb_add_config().  This may fail by returning a negative errno
- *	value; it should return zero on successful initialization.
+ *
  * Context: single threaded during gadget setup
  *
  * This function is used to register drivers using the composite driver

commit 27a4663397302976869571ae7e175fc90ec22017
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:23 2012 +0100

    usb: gadget: f_acm: use usb_gstrings_attach()
    
    Use usb_gstrings_attach() to assign strings in f_acm to assign strings
    ids.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9d7a1fabc482..7c821de8ce3d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -943,6 +943,12 @@ static int get_string(struct usb_composite_dev *cdev,
 					collect_langs(sp, s->wData);
 			}
 		}
+		list_for_each_entry(uc, &cdev->gstrings, list) {
+			struct usb_gadget_strings **sp;
+
+			sp = get_containers_gs(uc);
+			collect_langs(sp, s->wData);
+		}
 
 		for (len = 0; len <= 126 && s->wData[len]; len++)
 			continue;
@@ -1506,7 +1512,6 @@ static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
-	struct usb_gadget_string_container *uc, *tmp;
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
@@ -1521,10 +1526,6 @@ static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 				struct usb_configuration, list);
 		remove_config(cdev, c);
 	}
-	list_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {
-		list_del(&uc->list);
-		kfree(uc);
-	}
 	if (cdev->driver->unbind && unbind_driver)
 		cdev->driver->unbind(cdev);
 
@@ -1626,6 +1627,12 @@ int composite_dev_prepare(struct usb_composite_driver *composite,
 
 void composite_dev_cleanup(struct usb_composite_dev *cdev)
 {
+	struct usb_gadget_string_container *uc, *tmp;
+
+	list_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {
+		list_del(&uc->list);
+		kfree(uc);
+	}
 	if (cdev->req) {
 		kfree(cdev->req->buf);
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);

commit 9bb2859f8a8dbc9b42f3100641dd0ae80cfbe86a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:22 2012 +0100

    usb: gadget: composite: introduce usb_gstrings_attach()
    
    The USB strings don't (yet) fully work in multiple configs/gadget
    environment. The string id is assigned to the descriptor and the struct
    usb_strings. We create a copy of the individual descriptor so we don't
    clash if we use a function more than once. However, we have only one
    struct usb_string for each string.
    
    Currently each function which is used multiple times checks for
    "id != 0" and only assigns string ids if it did not happen yet. This
    works well if we use the same function multiple times as long as we do
    it within the "one" gadget we have. Trouble starts once we use the same
    function in a second gadget.
    
    In order to solve this I introduce usb_gstrings_attach(). This function will
    crate a copy all structs except for the strings which are not copied.
    After the copy it will assign USB ids and attach it to cdev.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8a1c3752f75f..9d7a1fabc482 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -28,6 +28,12 @@
  * with the relevant device-wide data.
  */
 
+static struct usb_gadget_strings **get_containers_gs(
+		struct usb_gadget_string_container *uc)
+{
+	return (struct usb_gadget_strings **)uc->stash;
+}
+
 /**
  * next_ep_desc() - advance to the next EP descriptor
  * @t: currect pointer within descriptor array
@@ -904,6 +910,7 @@ static int get_string(struct usb_composite_dev *cdev,
 		void *buf, u16 language, int id)
 {
 	struct usb_composite_driver	*composite = cdev->driver;
+	struct usb_gadget_string_container *uc;
 	struct usb_configuration	*c;
 	struct usb_function		*f;
 	int				len;
@@ -946,6 +953,15 @@ static int get_string(struct usb_composite_dev *cdev,
 		return s->bLength;
 	}
 
+	list_for_each_entry(uc, &cdev->gstrings, list) {
+		struct usb_gadget_strings **sp;
+
+		sp = get_containers_gs(uc);
+		len = lookup_string(sp, buf, language, id);
+		if (len > 0)
+			return len;
+	}
+
 	/* String IDs are device-scoped, so we look up each string
 	 * table we're told about.  These lookups are infrequent;
 	 * simpler-is-better here.
@@ -1031,6 +1047,119 @@ int usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)
 }
 EXPORT_SYMBOL_GPL(usb_string_ids_tab);
 
+static struct usb_gadget_string_container *copy_gadget_strings(
+		struct usb_gadget_strings **sp, unsigned n_gstrings,
+		unsigned n_strings)
+{
+	struct usb_gadget_string_container *uc;
+	struct usb_gadget_strings **gs_array;
+	struct usb_gadget_strings *gs;
+	struct usb_string *s;
+	unsigned mem;
+	unsigned n_gs;
+	unsigned n_s;
+	void *stash;
+
+	mem = sizeof(*uc);
+	mem += sizeof(void *) * (n_gstrings + 1);
+	mem += sizeof(struct usb_gadget_strings) * n_gstrings;
+	mem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);
+	uc = kmalloc(mem, GFP_KERNEL);
+	if (!uc)
+		return ERR_PTR(-ENOMEM);
+	gs_array = get_containers_gs(uc);
+	stash = uc->stash;
+	stash += sizeof(void *) * (n_gstrings + 1);
+	for (n_gs = 0; n_gs < n_gstrings; n_gs++) {
+		struct usb_string *org_s;
+
+		gs_array[n_gs] = stash;
+		gs = gs_array[n_gs];
+		stash += sizeof(struct usb_gadget_strings);
+		gs->language = sp[n_gs]->language;
+		gs->strings = stash;
+		org_s = sp[n_gs]->strings;
+
+		for (n_s = 0; n_s < n_strings; n_s++) {
+			s = stash;
+			stash += sizeof(struct usb_string);
+			if (org_s->s)
+				s->s = org_s->s;
+			else
+				s->s = "";
+			org_s++;
+		}
+		s = stash;
+		s->s = NULL;
+		stash += sizeof(struct usb_string);
+
+	}
+	gs_array[n_gs] = NULL;
+	return uc;
+}
+
+/**
+ * usb_gstrings_attach() - attach gadget strings to a cdev and assign ids
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * and attached.
+ * @sp: an array of usb_gadget_strings to attach.
+ * @n_strings: number of entries in each usb_strings array (sp[]->strings)
+ *
+ * This function will create a deep copy of usb_gadget_strings and usb_string
+ * and attach it to the cdev. The actual string (usb_string.s) will not be
+ * copied but only a referenced will be made. The struct usb_gadget_strings
+ * array may contain multiple languges and should be NULL terminated.
+ * The ->language pointer of each struct usb_gadget_strings has to contain the
+ * same amount of entries.
+ * For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
+ * usb_string entry of es-ES containts the translation of the first usb_string
+ * entry of en-US. Therefore both entries become the same id assign.
+ */
+struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,
+		struct usb_gadget_strings **sp, unsigned n_strings)
+{
+	struct usb_gadget_string_container *uc;
+	struct usb_gadget_strings **n_gs;
+	unsigned n_gstrings = 0;
+	unsigned i;
+	int ret;
+
+	for (i = 0; sp[i]; i++)
+		n_gstrings++;
+
+	if (!n_gstrings)
+		return ERR_PTR(-EINVAL);
+
+	uc = copy_gadget_strings(sp, n_gstrings, n_strings);
+	if (IS_ERR(uc))
+		return ERR_PTR(PTR_ERR(uc));
+
+	n_gs = get_containers_gs(uc);
+	ret = usb_string_ids_tab(cdev, n_gs[0]->strings);
+	if (ret)
+		goto err;
+
+	for (i = 1; i < n_gstrings; i++) {
+		struct usb_string *m_s;
+		struct usb_string *s;
+		unsigned n;
+
+		m_s = n_gs[0]->strings;
+		s = n_gs[i]->strings;
+		for (n = 0; n < n_strings; n++) {
+			s->id = m_s->id;
+			s++;
+			m_s++;
+		}
+	}
+	list_add_tail(&uc->list, &cdev->gstrings);
+	return n_gs[0]->strings;
+err:
+	kfree(uc);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(usb_gstrings_attach);
+
 /**
  * usb_string_ids_n() - allocate unused string IDs in batch
  * @c: the device whose string descriptor IDs are being allocated
@@ -1377,6 +1506,7 @@ static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_gadget_string_container *uc, *tmp;
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
@@ -1391,6 +1521,10 @@ static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 				struct usb_configuration, list);
 		remove_config(cdev, c);
 	}
+	list_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {
+		list_del(&uc->list);
+		kfree(uc);
+	}
 	if (cdev->driver->unbind && unbind_driver)
 		cdev->driver->unbind(cdev);
 
@@ -1514,6 +1648,7 @@ static int composite_bind(struct usb_gadget *gadget,
 	cdev->gadget = gadget;
 	set_gadget_data(gadget, cdev);
 	INIT_LIST_HEAD(&cdev->configs);
+	INIT_LIST_HEAD(&cdev->gstrings);
 
 	status = composite_dev_prepare(composite, cdev);
 	if (status)

commit 2d5a88990260d226a69acddf22c04f47c267b33a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:21 2012 +0100

    usb: gadget: export composite's setup & disconnect function
    
    The configfs can't use all of composite's hooks because ->bind() and
    ->unbind() has to be done a little differently. ->disconnect() and
    ->setup() on the hand can be recycled.
    This patch exports them both so configfs can use them.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9083ec93f38e..8a1c3752f75f 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1077,7 +1077,7 @@ static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
  * housekeeping for the gadget function we're implementing.  Most of
  * the work is in config and function specific setup.
  */
-static int
+int
 composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
@@ -1344,7 +1344,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	return value;
 }
 
-static void composite_disconnect(struct usb_gadget *gadget)
+void composite_disconnect(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	unsigned long			flags;

commit a59233407aed54b8a9121cea75d9c6a2a470d8d3
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:20 2012 +0100

    usb: gadget: factor out two helper functions from composite_bind()
    
    This patch factors out two helper functions from composite_bind()
    that is composite_dev_prepare() and its counterpart
    composite_dev_cleanup().
    
    This will be used by the configfs which requries a slightly different
    bind/setup code because part of its configurations (i.e. config
    descripts, cdev, ) are setup in advance and VID/PID and so one should
    not be overwritten. Also the setup of ep0 endpoint can be delayed until
    the UDC is assigned.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 366facccf4f6..9083ec93f38e 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1394,11 +1394,8 @@ static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 	if (cdev->driver->unbind && unbind_driver)
 		cdev->driver->unbind(cdev);
 
-	if (cdev->req) {
-		kfree(cdev->req->buf);
-		usb_ep_free_request(gadget->ep0, cdev->req);
-	}
-	device_remove_file(&gadget->dev, &dev_attr_suspended);
+	composite_dev_cleanup(cdev);
+
 	kfree(cdev->def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
@@ -1447,34 +1444,25 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		new->iProduct = iProduct;
 }
 
-static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
+int composite_dev_prepare(struct usb_composite_driver *composite,
+		struct usb_composite_dev *cdev)
 {
-	return container_of(gdrv, struct usb_composite_driver, gadget_driver);
-}
-
-static int composite_bind(struct usb_gadget *gadget,
-		struct usb_gadget_driver *gdriver)
-{
-	struct usb_composite_dev	*cdev;
-	struct usb_composite_driver	*composite = to_cdriver(gdriver);
-	int				status = -ENOMEM;
-
-	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
-	if (!cdev)
-		return status;
-
-	spin_lock_init(&cdev->lock);
-	cdev->gadget = gadget;
-	set_gadget_data(gadget, cdev);
-	INIT_LIST_HEAD(&cdev->configs);
+	struct usb_gadget *gadget = cdev->gadget;
+	int ret = -ENOMEM;
 
 	/* preallocate control response and buffer */
 	cdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
 	if (!cdev->req)
-		goto fail;
+		return -ENOMEM;
+
 	cdev->req->buf = kmalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);
 	if (!cdev->req->buf)
 		goto fail;
+
+	ret = device_create_file(&gadget->dev, &dev_attr_suspended);
+	if (ret)
+		goto fail_dev;
+
 	cdev->req->complete = composite_setup_complete;
 	gadget->ep0->driver_data = cdev;
 
@@ -1492,7 +1480,44 @@ static int composite_bind(struct usb_gadget *gadget,
 	 * we force endpoints to start unassigned; few controller
 	 * drivers will zero ep->driver_data.
 	 */
-	usb_ep_autoconfig_reset(cdev->gadget);
+	usb_ep_autoconfig_reset(gadget);
+	return 0;
+fail_dev:
+	kfree(cdev->req->buf);
+fail:
+	usb_ep_free_request(gadget->ep0, cdev->req);
+	cdev->req = NULL;
+	return ret;
+}
+
+void composite_dev_cleanup(struct usb_composite_dev *cdev)
+{
+	if (cdev->req) {
+		kfree(cdev->req->buf);
+		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
+	}
+	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
+}
+
+static int composite_bind(struct usb_gadget *gadget,
+		struct usb_gadget_driver *gdriver)
+{
+	struct usb_composite_dev	*cdev;
+	struct usb_composite_driver	*composite = to_cdriver(gdriver);
+	int				status = -ENOMEM;
+
+	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
+	if (!cdev)
+		return status;
+
+	spin_lock_init(&cdev->lock);
+	cdev->gadget = gadget;
+	set_gadget_data(gadget, cdev);
+	INIT_LIST_HEAD(&cdev->configs);
+
+	status = composite_dev_prepare(composite, cdev);
+	if (status)
+		goto fail;
 
 	/* composite gadget needs to assign strings for whole device (like
 	 * serial number), register function drivers, potentially update
@@ -1508,11 +1533,6 @@ static int composite_bind(struct usb_gadget *gadget,
 	if (composite->needs_serial && !cdev->desc.iSerialNumber)
 		WARNING(cdev, "userspace failed to provide iSerialNumber\n");
 
-	/* finish up */
-	status = device_create_file(&gadget->dev, &dev_attr_suspended);
-	if (status)
-		goto fail;
-
 	INFO(cdev, "%s ready\n", composite->name);
 	return 0;
 

commit b473577854fea63055ff9ab84f0f52a3e8aed15e
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:05 2012 +0100

    usb: gadget: composite: add usb_remove_function()
    
    This will be used to remove a single function from a given config. Right
    now "ignore" that an error at ->bind() time and cleanup later during
    composite_unbind() / remove_config().
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 4aa0e4652228..366facccf4f6 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -215,6 +215,18 @@ int usb_add_function(struct usb_configuration *config,
 }
 EXPORT_SYMBOL_GPL(usb_add_function);
 
+void usb_remove_function(struct usb_configuration *c, struct usb_function *f)
+{
+	if (f->disable)
+		f->disable(f);
+
+	bitmap_zero(f->endpoints, 32);
+	list_del(&f->list);
+	if (f->unbind)
+		f->unbind(c, f);
+}
+EXPORT_SYMBOL_GPL(usb_remove_function);
+
 /**
  * usb_function_deactivate - prevent function and gadget enumeration
  * @function: the function that isn't yet ready to respond

commit de53c25447117eae6b3f8952f663f08a09e0dbb7
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:10:00 2012 +0100

    usb: gadget: add some infracture to register/unregister functions
    
    This patch provides an infrastructure to register & unregister a USB
    function. This allows to turn a function into a module and avoid the
    '#include "f_.*.c"' magic and we get a clear API / cut between the bare
    gadget and its functions.
    The concept is simple:
    Each function defines the DECLARE_USB_FUNCTION_INIT macro whith an unique
    name of the function and two allocation functions.
    - one to create an "instance". The instance holds the current configuration
      set. In case there are two usb_configudations with one function there will
      be one instance and two usb_functions
    - one to create an "function" from the instance.
    
    The name of the instance is used to automaticaly load the module if it the
    instance is not yet available.
    The usb_function callbacks are slightly modified and extended:
    - usb_get_function()
      creates a struct usb_function inclunding all pointers (bind,
      unbind,). It uses the "instance" to map its configuration. So we can
      have _two_ struct usb_function, one for each usb_configuration.
    - ->unbind()
      Since the struct usb_function was not allocated in ->bind() it should
      not kfree()d here. This function should only reverse what happens in
      ->bind() that is request cleanup and the cleanup of allocated
      descriptors.
    - ->free_func()
      a simple kfree() of the struct usb_function
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 9db000013f5d..4aa0e4652228 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -683,6 +683,31 @@ static int set_config(struct usb_composite_dev *cdev,
 	return result;
 }
 
+int usb_add_config_only(struct usb_composite_dev *cdev,
+		struct usb_configuration *config)
+{
+	struct usb_configuration *c;
+
+	if (!config->bConfigurationValue)
+		return -EINVAL;
+
+	/* Prevent duplicate configuration identifiers */
+	list_for_each_entry(c, &cdev->configs, list) {
+		if (c->bConfigurationValue == config->bConfigurationValue)
+			return -EBUSY;
+	}
+
+	config->cdev = cdev;
+	list_add_tail(&config->list, &cdev->configs);
+
+	INIT_LIST_HEAD(&config->functions);
+	config->next_interface_id = 0;
+	memset(config->interface, 0, sizeof(config->interface));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_add_config_only);
+
 /**
  * usb_add_config() - add a configuration to a device.
  * @cdev: wraps the USB gadget
@@ -703,30 +728,18 @@ int usb_add_config(struct usb_composite_dev *cdev,
 		int (*bind)(struct usb_configuration *))
 {
 	int				status = -EINVAL;
-	struct usb_configuration	*c;
+
+	if (!bind)
+		goto done;
 
 	DBG(cdev, "adding config #%u '%s'/%p\n",
 			config->bConfigurationValue,
 			config->label, config);
 
-	if (!config->bConfigurationValue || !bind)
+	status = usb_add_config_only(cdev, config);
+	if (status)
 		goto done;
 
-	/* Prevent duplicate configuration identifiers */
-	list_for_each_entry(c, &cdev->configs, list) {
-		if (c->bConfigurationValue == config->bConfigurationValue) {
-			status = -EBUSY;
-			goto done;
-		}
-	}
-
-	config->cdev = cdev;
-	list_add_tail(&config->list, &cdev->configs);
-
-	INIT_LIST_HEAD(&config->functions);
-	config->next_interface_id = 0;
-	memset(config->interface, 0, sizeof(config->interface));
-
 	status = bind(config);
 	if (status < 0) {
 		while (!list_empty(&config->functions)) {

commit 779d516ca91d796cb37bd0760282d08f90661ee2
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Dec 23 21:09:55 2012 +0100

    usb: gadget: composite: don't call driver's unbind() if bind() failed
    
    Lets assume nokia_bind() starts with "return -EINVAL". After loading the
    gadget we end up with:
    
    |udc dummy_udc.0: registering UDC driver [g_nokia]
    |BUG: unable to handle kernel NULL pointer dereference at 00000040
    |IP: [<c11f9555>] __list_add+0x25/0xf0
    |Call Trace:
    | [<c12d4e21>] rollback_registered+0x21/0x40
    | [<c12d513f>] unregister_netdevice_queue+0x4f/0xa0
    | [<c12d5259>] unregister_netdev+0x19/0x30
    | [<f81335b2>] gphonet_cleanup+0x32/0x50 [g_nokia]
    | [<f8133f1c>] nokia_unbind+0x1c/0x2a [g_nokia]
    | [<f802509f>] __composite_unbind.constprop.10+0x4f/0xb0 [libcomposite]
    | [<f80255be>] composite_bind+0x1ae/0x230 [libcomposite]
    | [<c129e576>] usb_gadget_probe_driver+0xc6/0x1b0
    | [<f8024aba>] usb_composite_probe+0x7a/0xa0 [libcomposite]
    
    That is crash from nokia_unbind() invoked via nokia_bind(). This crash
    will look different we if make it until usb_string_ids_tab() before we
    enter an error condition in the probe function.
    nokia_bind_config() tries to clean up which is IMHO the right thing to
    do. Leaving things as-is and hoping that its unbind() will clean it up
    is kinda backwards. Especially since the bind function never succeeded so
    it can't know how much it needs to clean up.
    This fixes the behaviour by not calling the driver's unbind function if
    its bind function failed.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 71475b6d8568..9db000013f5d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1349,8 +1349,7 @@ static ssize_t composite_show_suspended(struct device *dev,
 
 static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
 
-static void
-composite_unbind(struct usb_gadget *gadget)
+static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 
@@ -1367,7 +1366,7 @@ composite_unbind(struct usb_gadget *gadget)
 				struct usb_configuration, list);
 		remove_config(cdev, c);
 	}
-	if (cdev->driver->unbind)
+	if (cdev->driver->unbind && unbind_driver)
 		cdev->driver->unbind(cdev);
 
 	if (cdev->req) {
@@ -1380,6 +1379,11 @@ composite_unbind(struct usb_gadget *gadget)
 	set_gadget_data(gadget, NULL);
 }
 
+static void composite_unbind(struct usb_gadget *gadget)
+{
+	__composite_unbind(gadget, true);
+}
+
 static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		const struct usb_device_descriptor *old)
 {
@@ -1488,7 +1492,7 @@ static int composite_bind(struct usb_gadget *gadget,
 	return 0;
 
 fail:
-	composite_unbind(gadget);
+	__composite_unbind(gadget, false);
 	return status;
 }
 

commit 8f900a9a6e2691441ad763952d640ac44220e5dc
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Dec 3 20:07:05 2012 +0100

    usb: gadget: consider link speed for bMaxPower
    
    The USB 2.0 specification says that bMaxPower is the maximum power
    consumption expressed in 2 mA units and the USB 3.0 specification says
    that it is expressed in 8 mA units.
    
    This patch renames bMaxPower to MaxPower and the various /2 and *2 are
    removed. Before reporting the config descriptor, the proper value is
    computer based on the speed, all in-tree users are updated. MaxPower is
    also increased to u16 so we can store the nokia gadget value which is
    larger than the max value allowed for u8.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2a6bfe759c29..71475b6d8568 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -320,6 +320,25 @@ int usb_interface_id(struct usb_configuration *config,
 }
 EXPORT_SYMBOL_GPL(usb_interface_id);
 
+static u8 encode_bMaxPower(enum usb_device_speed speed,
+		struct usb_configuration *c)
+{
+	unsigned val;
+
+	if (c->MaxPower)
+		val = c->MaxPower;
+	else
+		val = CONFIG_USB_GADGET_VBUS_DRAW;
+	if (!val)
+		return 0;
+	switch (speed) {
+	case USB_SPEED_SUPER:
+		return DIV_ROUND_UP(val, 8);
+	default:
+		return DIV_ROUND_UP(val, 2);
+	};
+}
+
 static int config_buf(struct usb_configuration *config,
 		enum usb_device_speed speed, void *buf, u8 type)
 {
@@ -339,7 +358,7 @@ static int config_buf(struct usb_configuration *config,
 	c->bConfigurationValue = config->bConfigurationValue;
 	c->iConfiguration = config->iConfiguration;
 	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
-	c->bMaxPower = config->bMaxPower ? : (CONFIG_USB_GADGET_VBUS_DRAW / 2);
+	c->bMaxPower = encode_bMaxPower(speed, config);
 
 	/* There may be e.g. OTG descriptors */
 	if (config->descriptors) {
@@ -656,7 +675,7 @@ static int set_config(struct usb_composite_dev *cdev,
 	}
 
 	/* when we return, be sure our power usage is valid */
-	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
+	power = c->MaxPower ? c->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;
 done:
 	usb_gadget_vbus_draw(gadget, power);
 	if (result >= 0 && cdev->delayed_status)
@@ -1518,10 +1537,10 @@ composite_resume(struct usb_gadget *gadget)
 				f->resume(f);
 		}
 
-		maxpower = cdev->config->bMaxPower;
+		maxpower = cdev->config->MaxPower;
 
 		usb_gadget_vbus_draw(gadget, maxpower ?
-			(2 * maxpower) : CONFIG_USB_GADGET_VBUS_DRAW);
+			maxpower : CONFIG_USB_GADGET_VBUS_DRAW);
 	}
 
 	cdev->suspended = 0;

commit 10287baec761d33f0a82d84b46e37a44030350d8
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Oct 22 22:15:06 2012 +0200

    usb: gadget: always update HS/SS descriptors and create a copy of them
    
    HS and SS descriptors are staticaly created. They are updated during the
    bind process with the endpoint address, string id or interface numbers.
    
    After that, the descriptor chain is linked to struct usb_function which
    is used by composite in order to serve the GET_DESCRIPTOR requests,
    number of available configs and so on.
    
    There is no need to assign the HS descriptor only if the UDC supports
    HS speed because composite won't report those to the host if HS support
    has not been reached. The same reasoning is valid for SS.
    
    This patch makes sure each function updates HS/SS descriptors
    unconditionally and uses the newly introduced helper function to create a
    copy the descriptors for the speed which is supported by the UDC.
    
    While at that, also rename f->descriptors to f->fs_descriptors in order
    to make it more explicit what that means.
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 957f973dd96a..2a6bfe759c29 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -107,7 +107,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 		}
 		/* else: fall through */
 	default:
-		speed_desc = f->descriptors;
+		speed_desc = f->fs_descriptors;
 	}
 	/* find descriptors */
 	for_each_ep_desc(speed_desc, d_spd) {
@@ -200,7 +200,7 @@ int usb_add_function(struct usb_configuration *config,
 	 * as full speed ... it's the function drivers that will need
 	 * to avoid bulk and ISO transfers.
 	 */
-	if (!config->fullspeed && function->descriptors)
+	if (!config->fullspeed && function->fs_descriptors)
 		config->fullspeed = true;
 	if (!config->highspeed && function->hs_descriptors)
 		config->highspeed = true;
@@ -363,7 +363,7 @@ static int config_buf(struct usb_configuration *config,
 			descriptors = f->hs_descriptors;
 			break;
 		default:
-			descriptors = f->descriptors;
+			descriptors = f->fs_descriptors;
 		}
 
 		if (!descriptors)
@@ -620,7 +620,7 @@ static int set_config(struct usb_composite_dev *cdev,
 			descriptors = f->hs_descriptors;
 			break;
 		default:
-			descriptors = f->descriptors;
+			descriptors = f->fs_descriptors;
 		}
 
 		for (; *descriptors; ++descriptors) {

commit ed9cbda63d45638b69ce62412e3a3c7b00644835
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 09:16:07 2012 +0200

    usb: gadget: remove usb_gadget_controller_number()
    
    The bcdDevice field is defined as
    |Device release number in binary-coded decimal
    in the USB 2.0 specification. We use this field to distinguish the UDCs
    from each other. In theory this could be used on the host side to apply
    certain quirks if the "special" UDC in combination with this gadget is
    used. This hasn't been done as far as I am aware. In practice it would
    be better to fix the UDC driver before shipping since a later release
    might not need this quirk anymore.
    
    There are some driver in tree (on the host side) which use the bcdDevice
    field to figure out special workarounds for a given firmware revision.
    This seems to make sense. Therefore this patch converts all gadgets
    (except a few) to use the kernel version instead a random 2 or 3 plus
    the UDC number. The few that don't report kernel's version are:
    - webcam
      This one reports always a version 0x10 so allow it to do so in future.
    - nokia
      This one reports always 0x211. The comment says that this gadget works
      only if the UDC supports altsettings so I added a check for this.
    - serial
      This one reports 0x2400 + UDC number. Since the gadget version is 2.4
      this could make sense. Therefore bcdDevice is 0x2400 here.
    
    I also remove various gadget_is_<name> macros which are unused. The
    remaining few macros should be moved to feature / bug bitfield.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index cacb273ba708..957f973dd96a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1389,6 +1389,8 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		new->idProduct = idProduct;
 	if (bcdDevice)
 		new->bcdDevice = bcdDevice;
+	else
+		new->bcdDevice = cpu_to_le16(get_default_bcdDevice());
 	if (iSerialNumber)
 		new->iSerialNumber = iSerialNumber;
 	if (iManufacturer)

commit d80c304bcacaf340efa29364ed0107f5c30378c8
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:28 2012 +0200

    usb: gadget: libcomposite: move MODULE_VERSION to composite.c
    
    MODULE_VERSION and AUTHOR looks better in composite.c than in
    usbstrings.c so I move it there.
    I put David Brownell as the module Author as I belive he wrote most of
    it.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 27ac36638827..cacb273ba708 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1684,3 +1684,6 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 	}
 }
 EXPORT_SYMBOL_GPL(usb_composite_overwrite_options);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");

commit 721e2e91945bc2520d57d795dfe1b502ecec567c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:27 2012 +0200

    usb: gadget: libcomposite: move composite.c into libcomposite
    
    This moves composite.c into libcomposite and updates all gadgets.
    Finally!
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c7066cd4c95a..27ac36638827 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -154,6 +154,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(config_ep_by_speed);
 
 /**
  * usb_add_function() - add a function to a configuration
@@ -212,6 +213,7 @@ int usb_add_function(struct usb_configuration *config,
 				function->name, function, value);
 	return value;
 }
+EXPORT_SYMBOL_GPL(usb_add_function);
 
 /**
  * usb_function_deactivate - prevent function and gadget enumeration
@@ -248,6 +250,7 @@ int usb_function_deactivate(struct usb_function *function)
 	spin_unlock_irqrestore(&cdev->lock, flags);
 	return status;
 }
+EXPORT_SYMBOL_GPL(usb_function_deactivate);
 
 /**
  * usb_function_activate - allow function and gadget enumeration
@@ -278,6 +281,7 @@ int usb_function_activate(struct usb_function *function)
 	spin_unlock_irqrestore(&cdev->lock, flags);
 	return status;
 }
+EXPORT_SYMBOL_GPL(usb_function_activate);
 
 /**
  * usb_interface_id() - allocate an unused interface ID
@@ -314,6 +318,7 @@ int usb_interface_id(struct usb_configuration *config,
 	}
 	return -ENODEV;
 }
+EXPORT_SYMBOL_GPL(usb_interface_id);
 
 static int config_buf(struct usb_configuration *config,
 		enum usb_device_speed speed, void *buf, u8 type)
@@ -754,6 +759,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 				config->bConfigurationValue, status);
 	return status;
 }
+EXPORT_SYMBOL_GPL(usb_add_config);
 
 static void remove_config(struct usb_composite_dev *cdev,
 			      struct usb_configuration *config)
@@ -947,6 +953,7 @@ int usb_string_id(struct usb_composite_dev *cdev)
 	}
 	return -ENODEV;
 }
+EXPORT_SYMBOL_GPL(usb_string_id);
 
 /**
  * usb_string_ids() - allocate unused string IDs in batch
@@ -978,6 +985,7 @@ int usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(usb_string_ids_tab);
 
 /**
  * usb_string_ids_n() - allocate unused string IDs in batch
@@ -1006,7 +1014,7 @@ int usb_string_ids_n(struct usb_composite_dev *c, unsigned n)
 	c->next_string_id += n;
 	return next + 1;
 }
-
+EXPORT_SYMBOL_GPL(usb_string_ids_n);
 
 /*-------------------------------------------------------------------------*/
 
@@ -1572,6 +1580,7 @@ int usb_composite_probe(struct usb_composite_driver *driver)
 
 	return usb_gadget_probe_driver(gadget_driver);
 }
+EXPORT_SYMBOL_GPL(usb_composite_probe);
 
 /**
  * usb_composite_unregister() - unregister a composite driver
@@ -1584,6 +1593,7 @@ void usb_composite_unregister(struct usb_composite_driver *driver)
 {
 	usb_gadget_unregister_driver(&driver->gadget_driver);
 }
+EXPORT_SYMBOL_GPL(usb_composite_unregister);
 
 /**
  * usb_composite_setup_continue() - Continue with the control transfer
@@ -1620,6 +1630,7 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
+EXPORT_SYMBOL_GPL(usb_composite_setup_continue);
 
 static char *composite_default_mfr(struct usb_gadget *gadget)
 {
@@ -1672,3 +1683,4 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 		dev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;
 	}
 }
+EXPORT_SYMBOL_GPL(usb_composite_overwrite_options);

commit cc2683c318a5bf192b75cd5c343b51009db0cf6c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:58 2012 +0200

    usb: gadget: Provide a default implementation of default manufacturer string
    
    Some gadgets provide custom entry here. Some may override it with an
    etntry that is also created by composite if there was no value sumbitted
    at all.
    This patch removes all "custom manufacturer" strings which are the same
    as these which are created by composite. Then it moves the creation of
    the default manufacturer string to usb_composite_overwrite_options() in
    case no command line argument has been used and the entry is still an
    empty string.
    By doing this we get rid of the global variable "composite_manufacturer"
    in composite.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f3689e1bf4b2..c7066cd4c95a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -28,9 +28,6 @@
  * with the relevant device-wide data.
  */
 
-static char composite_manufacturer[50];
-
-/*-------------------------------------------------------------------------*/
 /**
  * next_ep_desc() - advance to the next EP descriptor
  * @t: currect pointer within descriptor array
@@ -860,7 +857,6 @@ static int get_string(struct usb_composite_dev *cdev,
 	struct usb_configuration	*c;
 	struct usb_function		*f;
 	int				len;
-	const char			*str;
 
 	/* Yes, not only is USB's I18N support probably more than most
 	 * folk will ever care about ... also, it's all supported here.
@@ -900,21 +896,6 @@ static int get_string(struct usb_composite_dev *cdev,
 		return s->bLength;
 	}
 
-	/* Otherwise, look up and return a specified string.  First
-	 * check if the string has not been overridden.
-	 */
-	if (cdev->manufacturer_override == id)
-		str = composite_manufacturer;
-	else
-		str = NULL;
-	if (str) {
-		struct usb_gadget_strings strings = {
-			.language = language,
-			.strings  = &(struct usb_string) { 0xff, str }
-		};
-		return usb_gadget_get_string(&strings, 0xff, buf);
-	}
-
 	/* String IDs are device-scoped, so we look up each string
 	 * table we're told about.  These lookups are infrequent;
 	 * simpler-is-better here.
@@ -1367,23 +1348,11 @@ composite_unbind(struct usb_gadget *gadget)
 		usb_ep_free_request(gadget->ep0, cdev->req);
 	}
 	device_remove_file(&gadget->dev, &dev_attr_suspended);
+	kfree(cdev->def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
 }
 
-static u8 override_id(struct usb_composite_dev *cdev, u8 *desc)
-{
-	if (!*desc) {
-		int ret = usb_string_id(cdev);
-		if (unlikely(ret < 0))
-			WARNING(cdev, "failed to override string ID\n");
-		else
-			*desc = ret;
-	}
-
-	return *desc;
-}
-
 static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		const struct usb_device_descriptor *old)
 {
@@ -1477,19 +1446,6 @@ static int composite_bind(struct usb_gadget *gadget,
 
 	update_unchanged_dev_desc(&cdev->desc, composite->dev);
 
-	/* string overrides */
-	if (!cdev->desc.iManufacturer) {
-		snprintf(composite_manufacturer,
-				sizeof composite_manufacturer,
-				"%s %s with %s",
-				init_utsname()->sysname,
-				init_utsname()->release,
-				gadget->name);
-
-		cdev->manufacturer_override =
-			override_id(cdev, &cdev->desc.iManufacturer);
-	}
-
 	/* has userspace failed to provide a serial number? */
 	if (composite->needs_serial && !cdev->desc.iSerialNumber)
 		WARNING(cdev, "userspace failed to provide iSerialNumber\n");
@@ -1665,6 +1621,22 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
+static char *composite_default_mfr(struct usb_gadget *gadget)
+{
+	char *mfr;
+	int len;
+
+	len = snprintf(NULL, 0, "%s %s with %s", init_utsname()->sysname,
+			init_utsname()->release, gadget->name);
+	len++;
+	mfr = kmalloc(len, GFP_KERNEL);
+	if (!mfr)
+		return NULL;
+	snprintf(mfr, len, "%s %s with %s", init_utsname()->sysname,
+			init_utsname()->release, gadget->name);
+	return mfr;
+}
+
 void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 		struct usb_composite_overwrite *covr)
 {
@@ -1688,6 +1660,11 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 	if (covr->manufacturer) {
 		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
 		dev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;
+
+	} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {
+		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
+		cdev->def_manufacturer = composite_default_mfr(cdev->gadget);
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;
 	}
 
 	if (covr->product) {

commit d33f74fce3756d51a0203cec3d0d278e3b48d827
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:57 2012 +0200

    usb: gadget: remove string override from struct usb_composite_driver
    
    The struct usb_composite_driver members iProduct, iSerial and
    iManufacturer can be entered directly via the string array. There is no
    need for them to appear here.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 47b9130968bc..f3689e1bf4b2 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -904,11 +904,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	 * check if the string has not been overridden.
 	 */
 	if (cdev->manufacturer_override == id)
-		str = composite->iManufacturer ?: composite_manufacturer;
-	else if (cdev->product_override == id)
-		str = composite->iProduct;
-	else if (cdev->serial_override == id)
-		str = composite->iSerialNumber;
+		str = composite_manufacturer;
 	else
 		str = NULL;
 	if (str) {
@@ -1483,26 +1479,17 @@ static int composite_bind(struct usb_gadget *gadget,
 
 	/* string overrides */
 	if (!cdev->desc.iManufacturer) {
-		if (!composite->iManufacturer)
-			snprintf(composite_manufacturer,
-				 sizeof composite_manufacturer,
-				 "%s %s with %s",
-				 init_utsname()->sysname,
-				 init_utsname()->release,
-				 gadget->name);
+		snprintf(composite_manufacturer,
+				sizeof composite_manufacturer,
+				"%s %s with %s",
+				init_utsname()->sysname,
+				init_utsname()->release,
+				gadget->name);
 
 		cdev->manufacturer_override =
 			override_id(cdev, &cdev->desc.iManufacturer);
 	}
 
-	if (!cdev->desc.iProduct && composite->iProduct)
-		cdev->product_override =
-			override_id(cdev, &cdev->desc.iProduct);
-
-	if (composite->iSerialNumber)
-		cdev->serial_override =
-			override_id(cdev, &cdev->desc.iSerialNumber);
-
 	/* has userspace failed to provide a serial number? */
 	if (composite->needs_serial && !cdev->desc.iSerialNumber)
 		WARNING(cdev, "userspace failed to provide iSerialNumber\n");
@@ -1619,8 +1606,6 @@ int usb_composite_probe(struct usb_composite_driver *driver)
 
 	if (!driver->name)
 		driver->name = "composite";
-	if (!driver->iProduct)
-		driver->iProduct = driver->name;
 
 	driver->gadget_driver = composite_driver_template;
 	gadget_driver = &driver->gadget_driver;

commit 2d35ee47aaafac152bc4bc5020660ffa1753ab02
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:56 2012 +0200

    usb: gadget: push iProduct into gadgets
    
    This patch pushes the iProduct module argument from composite
    into each gadget.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 482cf8cf301d..47b9130968bc 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -28,14 +28,6 @@
  * with the relevant device-wide data.
  */
 
-/* Some systems will need runtime overrides for the  product identifiers
- * published in the device descriptor, either numbers or strings or both.
- * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
- */
-static char *iProduct;
-module_param(iProduct, charp, S_IRUGO);
-MODULE_PARM_DESC(iProduct, "USB Product string");
-
 static char composite_manufacturer[50];
 
 /*-------------------------------------------------------------------------*/
@@ -914,7 +906,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	if (cdev->manufacturer_override == id)
 		str = composite->iManufacturer ?: composite_manufacturer;
 	else if (cdev->product_override == id)
-		str = iProduct ?: composite->iProduct;
+		str = composite->iProduct;
 	else if (cdev->serial_override == id)
 		str = composite->iSerialNumber;
 	else
@@ -1404,6 +1396,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	__le16 bcdDevice;
 	u8 iSerialNumber;
 	u8 iManufacturer;
+	u8 iProduct;
 
 	/*
 	 * these variables may have been set in
@@ -1414,6 +1407,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	bcdDevice = new->bcdDevice;
 	iSerialNumber = new->iSerialNumber;
 	iManufacturer = new->iManufacturer;
+	iProduct = new->iProduct;
 
 	*new = *old;
 	if (idVendor)
@@ -1426,6 +1420,8 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		new->iSerialNumber = iSerialNumber;
 	if (iManufacturer)
 		new->iManufacturer = iManufacturer;
+	if (iProduct)
+		new->iProduct = iProduct;
 }
 
 static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
@@ -1499,7 +1495,7 @@ static int composite_bind(struct usb_gadget *gadget,
 			override_id(cdev, &cdev->desc.iManufacturer);
 	}
 
-	if (iProduct || (!cdev->desc.iProduct && composite->iProduct))
+	if (!cdev->desc.iProduct && composite->iProduct)
 		cdev->product_override =
 			override_id(cdev, &cdev->desc.iProduct);
 
@@ -1708,4 +1704,9 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
 		dev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;
 	}
+
+	if (covr->product) {
+		desc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;
+		dev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;
+	}
 }

commit 03de9bf69c589b71c43aa52b838690cb477903c9
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:55 2012 +0200

    usb: gadget: push iManufacturer into gadgets
    
    This patch pushes the iManufacturer module argument from composite into
    each gadget. Once the user uses the module paramter, the string is
    overwritten with the final value.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5642b2170541..482cf8cf301d 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -32,10 +32,6 @@
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
-static char *iManufacturer;
-module_param(iManufacturer, charp, S_IRUGO);
-MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
-
 static char *iProduct;
 module_param(iProduct, charp, S_IRUGO);
 MODULE_PARM_DESC(iProduct, "USB Product string");
@@ -916,8 +912,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	 * check if the string has not been overridden.
 	 */
 	if (cdev->manufacturer_override == id)
-		str = iManufacturer ?: composite->iManufacturer ?:
-			composite_manufacturer;
+		str = composite->iManufacturer ?: composite_manufacturer;
 	else if (cdev->product_override == id)
 		str = iProduct ?: composite->iProduct;
 	else if (cdev->serial_override == id)
@@ -1408,6 +1403,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	__le16 idProduct;
 	__le16 bcdDevice;
 	u8 iSerialNumber;
+	u8 iManufacturer;
 
 	/*
 	 * these variables may have been set in
@@ -1417,6 +1413,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	idProduct = new->idProduct;
 	bcdDevice = new->bcdDevice;
 	iSerialNumber = new->iSerialNumber;
+	iManufacturer = new->iManufacturer;
 
 	*new = *old;
 	if (idVendor)
@@ -1427,6 +1424,8 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		new->bcdDevice = bcdDevice;
 	if (iSerialNumber)
 		new->iSerialNumber = iSerialNumber;
+	if (iManufacturer)
+		new->iManufacturer = iManufacturer;
 }
 
 static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
@@ -1487,9 +1486,8 @@ static int composite_bind(struct usb_gadget *gadget,
 	update_unchanged_dev_desc(&cdev->desc, composite->dev);
 
 	/* string overrides */
-	if (iManufacturer || !cdev->desc.iManufacturer) {
-		if (!iManufacturer && !composite->iManufacturer &&
-		    !*composite_manufacturer)
+	if (!cdev->desc.iManufacturer) {
+		if (!composite->iManufacturer)
 			snprintf(composite_manufacturer,
 				 sizeof composite_manufacturer,
 				 "%s %s with %s",
@@ -1706,4 +1704,8 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 		desc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;
 		dev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;
 	}
+	if (covr->manufacturer) {
+		desc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;
+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;
+	}
 }

commit 1cf0d264088907038be560ba2dd472d5e432a3dc
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:54 2012 +0200

    usb: gadget: push iSerialNumber into gadgets
    
    This patch pushes the iSerialNumber module argument from composite into
    each gadget. Once the user uses the module paramter, the string is
    overwritten with the final value.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 317a5ece3bd2..5642b2170541 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -40,10 +40,6 @@ static char *iProduct;
 module_param(iProduct, charp, S_IRUGO);
 MODULE_PARM_DESC(iProduct, "USB Product string");
 
-static char *iSerialNumber;
-module_param(iSerialNumber, charp, S_IRUGO);
-MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
-
 static char composite_manufacturer[50];
 
 /*-------------------------------------------------------------------------*/
@@ -925,7 +921,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	else if (cdev->product_override == id)
 		str = iProduct ?: composite->iProduct;
 	else if (cdev->serial_override == id)
-		str = iSerialNumber ?: composite->iSerialNumber;
+		str = composite->iSerialNumber;
 	else
 		str = NULL;
 	if (str) {
@@ -1411,6 +1407,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	__le16 idVendor;
 	__le16 idProduct;
 	__le16 bcdDevice;
+	u8 iSerialNumber;
 
 	/*
 	 * these variables may have been set in
@@ -1419,6 +1416,7 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 	idVendor = new->idVendor;
 	idProduct = new->idProduct;
 	bcdDevice = new->bcdDevice;
+	iSerialNumber = new->iSerialNumber;
 
 	*new = *old;
 	if (idVendor)
@@ -1427,6 +1425,8 @@ static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
 		new->idProduct = idProduct;
 	if (bcdDevice)
 		new->bcdDevice = bcdDevice;
+	if (iSerialNumber)
+		new->iSerialNumber = iSerialNumber;
 }
 
 static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
@@ -1505,8 +1505,7 @@ static int composite_bind(struct usb_gadget *gadget,
 		cdev->product_override =
 			override_id(cdev, &cdev->desc.iProduct);
 
-	if (iSerialNumber ||
-	    (!cdev->desc.iSerialNumber && composite->iSerialNumber))
+	if (composite->iSerialNumber)
 		cdev->serial_override =
 			override_id(cdev, &cdev->desc.iSerialNumber);
 
@@ -1691,6 +1690,8 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 		struct usb_composite_overwrite *covr)
 {
 	struct usb_device_descriptor	*desc = &cdev->desc;
+	struct usb_gadget_strings	*gstr = cdev->driver->strings[0];
+	struct usb_string		*dev_str = gstr->strings;
 
 	if (covr->idVendor)
 		desc->idVendor = cpu_to_le16(covr->idVendor);
@@ -1700,4 +1701,9 @@ void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
 
 	if (covr->bcdDevice)
 		desc->bcdDevice = cpu_to_le16(covr->bcdDevice);
+
+	if (covr->serial_number) {
+		desc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;
+		dev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;
+	}
 }

commit 7d16e8d3eb704f5f6eb5a271d5758b495634e8e6
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:53 2012 +0200

    usb: gadget: push VID/PID/USB BCD module option into gadgets
    
    This patch moves the module options idVendor, idProduct and bcdDevice
    from composite.c into each gadgets. This ensures compatibility with
    current gadgets and removes the global variable which brings me step
    closer towards composite.c in libcomposite
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8d81a5ccfa03..317a5ece3bd2 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -32,19 +32,6 @@
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
-
-static ushort idVendor;
-module_param(idVendor, ushort, S_IRUGO);
-MODULE_PARM_DESC(idVendor, "USB Vendor ID");
-
-static ushort idProduct;
-module_param(idProduct, ushort, S_IRUGO);
-MODULE_PARM_DESC(idProduct, "USB Product ID");
-
-static ushort bcdDevice;
-module_param(bcdDevice, ushort, S_IRUGO);
-MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
-
 static char *iManufacturer;
 module_param(iManufacturer, charp, S_IRUGO);
 MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
@@ -1418,6 +1405,30 @@ static u8 override_id(struct usb_composite_dev *cdev, u8 *desc)
 	return *desc;
 }
 
+static void update_unchanged_dev_desc(struct usb_device_descriptor *new,
+		const struct usb_device_descriptor *old)
+{
+	__le16 idVendor;
+	__le16 idProduct;
+	__le16 bcdDevice;
+
+	/*
+	 * these variables may have been set in
+	 * usb_composite_overwrite_options()
+	 */
+	idVendor = new->idVendor;
+	idProduct = new->idProduct;
+	bcdDevice = new->bcdDevice;
+
+	*new = *old;
+	if (idVendor)
+		new->idVendor = idVendor;
+	if (idProduct)
+		new->idProduct = idProduct;
+	if (bcdDevice)
+		new->bcdDevice = bcdDevice;
+}
+
 static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
 {
 	return container_of(gdrv, struct usb_composite_driver, gadget_driver);
@@ -1473,17 +1484,7 @@ static int composite_bind(struct usb_gadget *gadget,
 	if (status < 0)
 		goto fail;
 
-	cdev->desc = *composite->dev;
-
-	/* standardized runtime overrides for device ID data */
-	if (idVendor)
-		cdev->desc.idVendor = cpu_to_le16(idVendor);
-
-	if (idProduct)
-		cdev->desc.idProduct = cpu_to_le16(idProduct);
-
-	if (bcdDevice)
-		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+	update_unchanged_dev_desc(&cdev->desc, composite->dev);
 
 	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {
@@ -1686,3 +1687,17 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
+void usb_composite_overwrite_options(struct usb_composite_dev *cdev,
+		struct usb_composite_overwrite *covr)
+{
+	struct usb_device_descriptor	*desc = &cdev->desc;
+
+	if (covr->idVendor)
+		desc->idVendor = cpu_to_le16(covr->idVendor);
+
+	if (covr->idProduct)
+		desc->idProduct = cpu_to_le16(covr->idProduct);
+
+	if (covr->bcdDevice)
+		desc->bcdDevice = cpu_to_le16(covr->bcdDevice);
+}

commit 72258493ec4f77a772d05a8df5ee663e1e24154b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:15 2012 +0200

    usb: gadget: make composite module options readonly only
    
    This is a partly revert of 4fffd6e5 ("usb: gadget: composite: make
    module parameters accessible at runtime").
    It is not possible to change the VID or other property for a gadget
    right now. This change has been made for Anrdoid gadget which has this
    functionality in its copy of the file. This function is executed currently
    only once and most caller in tree are __init.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 16b353fa160a..8d81a5ccfa03 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -34,27 +34,27 @@
  */
 
 static ushort idVendor;
-module_param(idVendor, ushort, 0644);
+module_param(idVendor, ushort, S_IRUGO);
 MODULE_PARM_DESC(idVendor, "USB Vendor ID");
 
 static ushort idProduct;
-module_param(idProduct, ushort, 0644);
+module_param(idProduct, ushort, S_IRUGO);
 MODULE_PARM_DESC(idProduct, "USB Product ID");
 
 static ushort bcdDevice;
-module_param(bcdDevice, ushort, 0644);
+module_param(bcdDevice, ushort, S_IRUGO);
 MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
 
 static char *iManufacturer;
-module_param(iManufacturer, charp, 0644);
+module_param(iManufacturer, charp, S_IRUGO);
 MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
 
 static char *iProduct;
-module_param(iProduct, charp, 0644);
+module_param(iProduct, charp, S_IRUGO);
 MODULE_PARM_DESC(iProduct, "USB Product string");
 
 static char *iSerialNumber;
-module_param(iSerialNumber, charp, 0644);
+module_param(iSerialNumber, charp, S_IRUGO);
 MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
 static char composite_manufacturer[50];
@@ -1478,16 +1478,12 @@ static int composite_bind(struct usb_gadget *gadget,
 	/* standardized runtime overrides for device ID data */
 	if (idVendor)
 		cdev->desc.idVendor = cpu_to_le16(idVendor);
-	else
-		idVendor = le16_to_cpu(cdev->desc.idVendor);
+
 	if (idProduct)
 		cdev->desc.idProduct = cpu_to_le16(idProduct);
-	else
-		idProduct = le16_to_cpu(cdev->desc.idProduct);
+
 	if (bcdDevice)
 		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
-	else
-		bcdDevice = le16_to_cpu(cdev->desc.bcdDevice);
 
 	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {

commit 40bfef0535e8a10486c9d81fd2f55e3b9dc71db6
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:52 2012 +0200

    usb: gadget: remove bufsiz from struct usb_composite_dev
    
    there is no read user of bufsiz, its content is available via
    USB_COMP_EP0_BUFSIZ. Remove it.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 52689ee9db12..16b353fa160a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1449,7 +1449,6 @@ static int composite_bind(struct usb_gadget *gadget,
 	cdev->req->complete = composite_setup_complete;
 	gadget->ep0->driver_data = cdev;
 
-	cdev->bufsiz = USB_COMP_EP0_BUFSIZ;
 	cdev->driver = composite;
 
 	/*

commit e13f17ff8854e04cfc6b9f981a974f55d8da9b92
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 15:01:51 2012 +0200

    usb: gadget: move USB_BUFSIZ into global composite.h
    
    This patch moves USB_BUFSIZ into global header file as
    USB_COMP_EP0_BUFSIZ. There is currently only one user (f_sourcesink)
    besides composite which need it. Ideally f_sourcesink would have its
    own ep0 buffer. Lets keep it that way it was for now.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 0b6ee2012af1..52689ee9db12 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -28,9 +28,6 @@
  * with the relevant device-wide data.
  */
 
-/* big enough to hold our biggest descriptor */
-#define USB_BUFSIZ	1024
-
 /* Some systems will need runtime overrides for the  product identifiers
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
@@ -355,10 +352,11 @@ static int config_buf(struct usb_configuration *config,
 {
 	struct usb_config_descriptor	*c = buf;
 	void				*next = buf + USB_DT_CONFIG_SIZE;
-	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
+	int				len;
 	struct usb_function		*f;
 	int				status;
 
+	len = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;
 	/* write the config descriptor */
 	c = buf;
 	c->bLength = USB_DT_CONFIG_SIZE;
@@ -1445,13 +1443,13 @@ static int composite_bind(struct usb_gadget *gadget,
 	cdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
 	if (!cdev->req)
 		goto fail;
-	cdev->req->buf = kmalloc(USB_BUFSIZ, GFP_KERNEL);
+	cdev->req->buf = kmalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);
 	if (!cdev->req->buf)
 		goto fail;
 	cdev->req->complete = composite_setup_complete;
 	gadget->ep0->driver_data = cdev;
 
-	cdev->bufsiz = USB_BUFSIZ;
+	cdev->bufsiz = USB_COMP_EP0_BUFSIZ;
 	cdev->driver = composite;
 
 	/*

commit ffe0b335062505a98d7296dae2c2a197713f87e0
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 7 09:53:17 2012 +0200

    usb: gadget: remove global variable composite in composite.c
    
    This patch removes the global variable composite in composite.c.
    The private data which was saved there is now passed via an additional
    argument to the bind() function in struct usb_gadget_driver.
    
    Only the "old-style" UDC drivers have to be touched here, new style are
    doing it right because this change is made in udc-core.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2a345f28b9ae..0b6ee2012af1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -31,8 +31,6 @@
 /* big enough to hold our biggest descriptor */
 #define USB_BUFSIZ	1024
 
-static struct usb_composite_driver *composite;
-
 /* Some systems will need runtime overrides for the  product identifiers
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
@@ -889,6 +887,7 @@ static int lookup_string(
 static int get_string(struct usb_composite_dev *cdev,
 		void *buf, u16 language, int id)
 {
+	struct usb_composite_driver	*composite = cdev->driver;
 	struct usb_configuration	*c;
 	struct usb_function		*f;
 	int				len;
@@ -1359,8 +1358,8 @@ static void composite_disconnect(struct usb_gadget *gadget)
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (cdev->config)
 		reset_config(cdev);
-	if (composite->disconnect)
-		composite->disconnect(cdev);
+	if (cdev->driver->disconnect)
+		cdev->driver->disconnect(cdev);
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
@@ -1396,8 +1395,8 @@ composite_unbind(struct usb_gadget *gadget)
 				struct usb_configuration, list);
 		remove_config(cdev, c);
 	}
-	if (composite->unbind)
-		composite->unbind(cdev);
+	if (cdev->driver->unbind)
+		cdev->driver->unbind(cdev);
 
 	if (cdev->req) {
 		kfree(cdev->req->buf);
@@ -1406,7 +1405,6 @@ composite_unbind(struct usb_gadget *gadget)
 	device_remove_file(&gadget->dev, &dev_attr_suspended);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
-	composite = NULL;
 }
 
 static u8 override_id(struct usb_composite_dev *cdev, u8 *desc)
@@ -1422,9 +1420,16 @@ static u8 override_id(struct usb_composite_dev *cdev, u8 *desc)
 	return *desc;
 }
 
-static int composite_bind(struct usb_gadget *gadget)
+static struct usb_composite_driver *to_cdriver(struct usb_gadget_driver *gdrv)
+{
+	return container_of(gdrv, struct usb_composite_driver, gadget_driver);
+}
+
+static int composite_bind(struct usb_gadget *gadget,
+		struct usb_gadget_driver *gdriver)
 {
 	struct usb_composite_dev	*cdev;
+	struct usb_composite_driver	*composite = to_cdriver(gdriver);
 	int				status = -ENOMEM;
 
 	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
@@ -1546,8 +1551,8 @@ composite_suspend(struct usb_gadget *gadget)
 				f->suspend(f);
 		}
 	}
-	if (composite->suspend)
-		composite->suspend(cdev);
+	if (cdev->driver->suspend)
+		cdev->driver->suspend(cdev);
 
 	cdev->suspended = 1;
 
@@ -1565,8 +1570,8 @@ composite_resume(struct usb_gadget *gadget)
 	 * suspend/resume callbacks?
 	 */
 	DBG(cdev, "resume\n");
-	if (composite->resume)
-		composite->resume(cdev);
+	if (cdev->driver->resume)
+		cdev->driver->resume(cdev);
 	if (cdev->config) {
 		list_for_each_entry(f, &cdev->config->functions, list) {
 			if (f->resume)
@@ -1584,7 +1589,7 @@ composite_resume(struct usb_gadget *gadget)
 
 /*-------------------------------------------------------------------------*/
 
-static struct usb_gadget_driver composite_driver = {
+static const struct usb_gadget_driver composite_driver_template = {
 	.bind		= composite_bind,
 	.unbind		= composite_unbind,
 
@@ -1620,19 +1625,24 @@ static struct usb_gadget_driver composite_driver = {
  */
 int usb_composite_probe(struct usb_composite_driver *driver)
 {
-	if (!driver || !driver->dev || composite || !driver->bind)
+	struct usb_gadget_driver *gadget_driver;
+
+	if (!driver || !driver->dev || !driver->bind)
 		return -EINVAL;
 
 	if (!driver->name)
 		driver->name = "composite";
 	if (!driver->iProduct)
 		driver->iProduct = driver->name;
-	composite_driver.function =  (char *) driver->name;
-	composite_driver.driver.name = driver->name;
-	composite_driver.max_speed = driver->max_speed;
-	composite = driver;
 
-	return usb_gadget_probe_driver(&composite_driver);
+	driver->gadget_driver = composite_driver_template;
+	gadget_driver = &driver->gadget_driver;
+
+	gadget_driver->function =  (char *) driver->name;
+	gadget_driver->driver.name = driver->name;
+	gadget_driver->max_speed = driver->max_speed;
+
+	return usb_gadget_probe_driver(gadget_driver);
 }
 
 /**
@@ -1644,9 +1654,7 @@ int usb_composite_probe(struct usb_composite_driver *driver)
  */
 void usb_composite_unregister(struct usb_composite_driver *driver)
 {
-	if (composite != driver)
-		return;
-	usb_gadget_unregister_driver(&composite_driver);
+	usb_gadget_unregister_driver(&driver->gadget_driver);
 }
 
 /**

commit 93952956c7078eb41058c5ccc5b34ae6cf59bb64
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:05 2012 +0200

    usb: gadget: move bind() callback back to struct usb_gadget_driver
    
    This partly reverts 07a18bd7 ("usb gadget: don't save bind callback in
    struct usb_composite_driver") and fixes new drivers. The section missmatch
    problems was solved by whitelisting bind callback in modpost.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 071d15c44116..2a345f28b9ae 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1585,6 +1585,7 @@ composite_resume(struct usb_gadget *gadget)
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver composite_driver = {
+	.bind		= composite_bind,
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
@@ -1631,7 +1632,7 @@ int usb_composite_probe(struct usb_composite_driver *driver)
 	composite_driver.max_speed = driver->max_speed;
 	composite = driver;
 
-	return usb_gadget_probe_driver(&composite_driver, composite_bind);
+	return usb_gadget_probe_driver(&composite_driver);
 }
 
 /**

commit 03e42bd5937c4c24e411690ab165627e93c258b5
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:04 2012 +0200

    usb: gadget: move bind() callback back to struct usb_composite_driver
    
    This partly reverts 07a18bd7 ("usb gadget: don't save bind callback in
    struct usb_composite_driver") and fixes new drivers. The section missmatch
    problems was solved by whitelisting structs in question via __ref.
    
    Cc: devel@driverdev.osuosl.org
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 402e5bd8b3e5..071d15c44116 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1617,12 +1617,9 @@ static struct usb_gadget_driver composite_driver = {
  * while it was binding.  That would usually be done in order to wait for
  * some userspace participation.
  */
-int usb_composite_probe(struct usb_composite_driver *driver,
-			       int (*bind)(struct usb_composite_dev *cdev))
+int usb_composite_probe(struct usb_composite_driver *driver)
 {
-	if (!driver || !driver->dev || composite)
-		return -EINVAL;
-	if (!bind && !driver->bind)
+	if (!driver || !driver->dev || composite || !driver->bind)
 		return -EINVAL;
 
 	if (!driver->name)
@@ -1633,8 +1630,6 @@ int usb_composite_probe(struct usb_composite_driver *driver,
 	composite_driver.driver.name = driver->name;
 	composite_driver.max_speed = driver->max_speed;
 	composite = driver;
-	if (!driver->bind)
-		driver->bind = bind;
 
 	return usb_gadget_probe_driver(&composite_driver, composite_bind);
 }

commit fac3a43e0ab20dbf5e845c6221ead0d073984f41
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:01 2012 +0200

    usb: gadget: move bind callback into driver struct usb_composite_driver
    
    It was moved to be an argument in 07a18bd716ed5 ("usb gadget: don't
    save bind callback in struct usb_composite_driver"). The reason was to
    avoid the section missmatch. The warning was shown because ->bind is
    marked as __init becuase it is a one time init. The warning can be also
    suppresed by whitelisting the variable i.e. rename it to lets say _probe.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 91411a6d741b..402e5bd8b3e5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -32,7 +32,6 @@
 #define USB_BUFSIZ	1024
 
 static struct usb_composite_driver *composite;
-static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
 
 /* Some systems will need runtime overrides for the  product identifiers
  * published in the device descriptor, either numbers or strings or both.
@@ -1468,7 +1467,7 @@ static int composite_bind(struct usb_gadget *gadget)
 	 * serial number), register function drivers, potentially update
 	 * power state and consumption, etc
 	 */
-	status = composite_gadget_bind(cdev);
+	status = composite->bind(cdev);
 	if (status < 0)
 		goto fail;
 
@@ -1621,7 +1620,9 @@ static struct usb_gadget_driver composite_driver = {
 int usb_composite_probe(struct usb_composite_driver *driver,
 			       int (*bind)(struct usb_composite_dev *cdev))
 {
-	if (!driver || !driver->dev || !bind || composite)
+	if (!driver || !driver->dev || composite)
+		return -EINVAL;
+	if (!bind && !driver->bind)
 		return -EINVAL;
 
 	if (!driver->name)
@@ -1632,7 +1633,8 @@ int usb_composite_probe(struct usb_composite_driver *driver,
 	composite_driver.driver.name = driver->name;
 	composite_driver.max_speed = driver->max_speed;
 	composite = driver;
-	composite_gadget_bind = bind;
+	if (!driver->bind)
+		driver->bind = bind;
 
 	return usb_gadget_probe_driver(&composite_driver, composite_bind);
 }

commit 85b8614d722389202af298e1bf8a599c431fef19
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Fri Aug 24 20:46:18 2012 +0200

    usb: gadget: get rid of USB_GADGET_{DUAL,SUPER}SPEED
    
    This commit removes USB_GADGET_DUALSPEED and USB_GADGET_SUPERSPEED
    Kconfig options.  Since now kernel allows many UDC drivers to be
    compiled, those options may turn to no longer be valid.  For
    instance, if someone decides to build UDC that supports super
    speed and UDC that supports high speed only, the latter will be
    "assumed" to support super speed since USB_GADGET_SUPERSPEED will
    be selected by the former.
    
    The test of whether CONFIG_USB_GADGET_*SPEED was defined was just
    an optimisation which removed otherwise dead code (ie. if UDC is
    not dual speed, there is no need to handle cases that can happen
    if speed is high).  This commit removes those checks.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2cb1030203b5..91411a6d741b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1586,12 +1586,6 @@ composite_resume(struct usb_gadget *gadget)
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver composite_driver = {
-#ifdef CONFIG_USB_GADGET_SUPERSPEED
-	.max_speed	= USB_SPEED_SUPER,
-#else
-	.max_speed	= USB_SPEED_HIGH,
-#endif
-
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
@@ -1636,8 +1630,7 @@ int usb_composite_probe(struct usb_composite_driver *driver,
 		driver->iProduct = driver->name;
 	composite_driver.function =  (char *) driver->name;
 	composite_driver.driver.name = driver->name;
-	composite_driver.max_speed =
-		min_t(u8, composite_driver.max_speed, driver->max_speed);
+	composite_driver.max_speed = driver->max_speed;
 	composite = driver;
 	composite_gadget_bind = bind;
 

commit 4fefe9f6de3d6e0b5e58b17cbab9c47c74f88cb6
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Thu Jul 19 00:20:11 2012 +0200

    usb composite: fix locking in usb_function_activate
    
    The lockdep hunter mentions a non consistent usage of spin_lock and
    spin_lock_irqsafe in the composite_disconnect and usb_function_activate
    function:
    
    [   15.700897] =================================
    [   15.705255] [ INFO: inconsistent lock state ]
    [   15.709617] 3.5.0-rc5+ #413 Not tainted
    [   15.713453] ---------------------------------
    [   15.717812] inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-W} usage.
    [   15.723822] uvc-gadget/116 [HC1[1]:SC0[0]:HE0:SE1] takes:
    [   15.729222]  (&(&cdev->lock)->rlock){?.+...}, at: [<7f0049e8>] composite_disconnect+0x2c/0x74 [g_webcam]
    [   15.738797] {HARDIRQ-ON-W} state was registered at:
    [   15.743677]   [<8006de3c>] mark_lock+0x148/0x688
    [   15.748325]   [<8006ecb0>] __lock_acquire+0x934/0x1b74
    [   15.753481]   [<8007047c>] lock_acquire+0x98/0x138
    [   15.758288]   [<804c776c>] _raw_spin_lock+0x4c/0x84
    [   15.763188]   [<7f006ae4>] usb_function_activate+0x28/0x94 [g_webcam]
    [   15.769652]   [<7f00820c>] usb_ep_autoconfig_reset+0x78/0x98 [g_webcam]
    [   15.776287]   [<7f0082a4>] uvc_v4l2_open+0x78/0x94 [g_webcam]
    [   15.782054]   [<80366a38>] v4l2_open+0x104/0x130
    [   15.786697]   [<800efd30>] chrdev_open+0xa0/0x170
    [   15.791423]   [<800e9718>] do_dentry_open.isra.13+0x1e8/0x264
    [   15.797186]   [<800ea5d4>] nameidata_to_filp+0x58/0x94
    [   15.802340]   [<800fa29c>] do_last.isra.31+0x2a0/0x808
    [   15.807497]   [<800faa40>] path_openat+0xc8/0x3e8
    [   15.812216]   [<800fae90>] do_filp_open+0x3c/0x90
    [   15.816936]   [<800ea6fc>] do_sys_open+0xec/0x184
    [   15.821655]   [<800ea7c4>] sys_open+0x30/0x34
    [   15.826027]   [<8000e5c0>] ret_fast_syscall+0x0/0x48
    [   15.831015] irq event stamp: 6048
    [   15.834330] hardirqs last  enabled at (6047): [<804c81b8>] _raw_spin_unlock_irqrestore+0x40/0x54
    [   15.843132] hardirqs last disabled at (6048): [<8000e174>] __irq_svc+0x34/0x60
    [   15.850370] softirqs last  enabled at (5940): [<80028380>] __do_softirq+0x188/0x270
    [   15.858043] softirqs last disabled at (5935): [<80028944>] irq_exit+0xa0/0xa8
    [   15.865195]
    [   15.865195] other info that might help us debug this:
    [   15.871724]  Possible unsafe locking scenario:
    [   15.871724]
    [   15.877645]        CPU0
    [   15.880091]        ----
    [   15.882537]   lock(&(&cdev->lock)->rlock);
    [   15.886659]   <Interrupt>
    [   15.889278]     lock(&(&cdev->lock)->rlock);
    [   15.893573]
    [   15.893573]  *** DEADLOCK ***
    [   15.893573]
    [   15.899496] no locks held by uvc-gadget/116.
    [   15.903765]
    [   15.903765] stack backtrace:
    [   15.908125] Backtrace:
    [   15.910604] [<80012038>] (dump_backtrace+0x0/0x114) from [<804bf8a4>] (dump_stack+0x20/0x24)
    [   15.919043]  r6:dfb8e6f0 r5:dfb8e400 r4:809717ec r3:60000193
    [   15.924766] [<804bf884>] (dump_stack+0x0/0x24) from [<804c0c0c>] (print_usage_bug+0x258/0x2c0)
    [   15.933388] [<804c09b4>] (print_usage_bug+0x0/0x2c0) from [<8006e240>] (mark_lock+0x54c/0x688)
    [   15.942006] [<8006dcf4>] (mark_lock+0x0/0x688) from [<8006edb8>] (__lock_acquire+0xa3c/0x1b74)
    [   15.950625] [<8006e37c>] (__lock_acquire+0x0/0x1b74) from [<8007047c>] (lock_acquire+0x98/0x138)
    [   15.959418] [<800703e4>] (lock_acquire+0x0/0x138) from [<804c78fc>] (_raw_spin_lock_irqsave+0x58/0x94)
    [   15.968736] [<804c78a4>] (_raw_spin_lock_irqsave+0x0/0x94) from [<7f0049e8>] (composite_disconnect+0x2c/0x74 [g_webcam])
    [   15.979605]  r7:00000012 r6:df82b0c4 r5:ded755bc r4:ded75580
    [   15.985331] [<7f0049bc>] (composite_disconnect+0x0/0x74 [g_webcam]) from [<8033c170>] (_gadget_stop_activity+0xc4/0x120)
    [   15.996200]  r6:df82b0c4 r5:df82b0c8 r4:df82b0d0 r3:7f0049bc
    [   16.001919] [<8033c0ac>] (_gadget_stop_activity+0x0/0x120) from [<8033e390>] (udc_irq+0x724/0xcb8)
    [   16.010877]  r6:df82b010 r5:00000000 r4:df82b010 r3:00000000
    [   16.016595] [<8033dc6c>] (udc_irq+0x0/0xcb8) from [<8033baec>] (ci_irq+0x64/0xdc)
    [   16.024086] [<8033ba88>] (ci_irq+0x0/0xdc) from [<80086538>] (handle_irq_event_percpu+0x74/0x298)
    [   16.032958]  r5:807fd414 r4:df38fdc0
    [   16.036566] [<800864c4>] (handle_irq_event_percpu+0x0/0x298) from [<800867a8>] (handle_irq_event+0x4c/0x6c)
    [   16.046315] [<8008675c>] (handle_irq_event+0x0/0x6c) from [<80089318>] (handle_level_irq+0xbc/0x11c)
    [   16.055447]  r6:def04000 r5:807fd414 r4:807fd3c0 r3:00020000
    [   16.061166] [<8008925c>] (handle_level_irq+0x0/0x11c) from [<80085cc8>] (generic_handle_irq+0x38/0x4c)
    [   16.070472]  r5:807f7f64 r4:8081e9f8
    [   16.074082] [<80085c90>] (generic_handle_irq+0x0/0x4c) from [<8000ef98>] (handle_IRQ+0x5c/0xbc)
    [   16.082788] [<8000ef3c>] (handle_IRQ+0x0/0xbc) from [<800085cc>] (tzic_handle_irq+0x6c/0x9c)
    [   16.091225]  r8:00000000 r7:def059b0 r6:00000001 r5:00000000 r4:00000000
    r3:00000012
    [   16.099141] [<80008560>] (tzic_handle_irq+0x0/0x9c) from [<8000e184>] (__irq_svc+0x44/0x60)
    [   16.107494] Exception stack(0xdef059b0 to 0xdef059f8)
    [   16.112550] 59a0:                                     00000001 00000001 00000000 dfb8e400
    [   16.120732] 59c0: 40000013 81a2e500 00000000 81a2e500 00000000 00000000 80862418 def05a0c
    [   16.128912] 59e0: def059c8 def059f8 80070e24 804c81bc 20000013 ffffffff
    [   16.135542] [<804c8178>] (_raw_spin_unlock_irqrestore+0x0/0x54) from [<8003d0ec>] (__queue_work+0x108/0x470)
    [   16.145369]  r5:dfb1a30c r4:81b93c00
    [   16.148978] [<8003cfe4>] (__queue_work+0x0/0x470) from [<8003d4e0>] (queue_work_on+0x4c/0x54)
    [   16.157511] [<8003d494>] (queue_work_on+0x0/0x54) from [<8003d544>] (queue_work+0x30/0x34)
    [   16.165774]  r6:df2e6900 r5:80e0c2f8 r4:dfb1a2c8 r3:def04000
    [   16.171495] [<8003d514>] (queue_work+0x0/0x34) from [<80493284>] (rpc_make_runnable+0x9c/0xac)
    [   16.180113] [<804931e8>] (rpc_make_runnable+0x0/0xac) from [<80493c88>] (rpc_execute+0x40/0xa8)
    [   16.188811]  r5:def05ad4 r4:dfb1a2c8
    [   16.192426] [<80493c48>] (rpc_execute+0x0/0xa8) from [<8048c734>] (rpc_run_task+0xa8/0xb4)
    [   16.200690]  r8:00000001 r7:df74f520 r6:ded75700 r5:def05ad4 r4:dfb1a2c8
    r3:00000002
    [   16.208618] [<8048c68c>] (rpc_run_task+0x0/0xb4) from [<801f1608>] (nfs_initiate_read+0xb4/0xd4)
    [   16.217403]  r5:df3e86c0 r4:00000000
    [   16.221015] [<801f1554>] (nfs_initiate_read+0x0/0xd4) from [<801f1c64>] (nfs_generic_pg_readpages+0x9c/0x114)
    [   16.230937] [<801f1bc8>] (nfs_generic_pg_readpages+0x0/0x114) from [<801f0744>] (__nfs_pageio_add_request+0xe8/0x214)
    [   16.241545]  r8:000bf000 r7:00000000 r6:00000000 r5:deef4640 r4:def05c1c
    r3:801f1bc8
    [   16.249463] [<801f065c>] (__nfs_pageio_add_request+0x0/0x214) from [<801f0e3c>] (nfs_pageio_add_request+0x28/0x54)
    [   16.259818] [<801f0e14>] (nfs_pageio_add_request+0x0/0x54) from [<801f1394>] (readpage_async_filler+0x114/0x170)
    [   16.269992]  r5:def05c58 r4:80fd7300
    [   16.273607] [<801f1280>] (readpage_async_filler+0x0/0x170) from [<800bb418>] (read_cache_pages+0xa0/0x108)
    [   16.283259]  r8:00200200 r7:00100100 r6:df74f654 r5:def05cd0 r4:80fd7300
    [   16.290034] [<800bb378>] (read_cache_pages+0x0/0x108) from [<801f218c>] (nfs_readpages+0xc4/0x168)
    [   16.298999] [<801f20c8>] (nfs_readpages+0x0/0x168) from [<800bb1d0>] (__do_page_cache_readahead+0x254/0x354)
    [   16.308833] [<800baf7c>] (__do_page_cache_readahead+0x0/0x354) from [<800bb5d0>] (ra_submit+0x38/0x40)
    [   16.318145] [<800bb598>] (ra_submit+0x0/0x40) from [<800bb6b0>] (ondemand_readahead+0xd8/0x3b0)
    [   16.326851] [<800bb5d8>] (ondemand_readahead+0x0/0x3b0) from [<800bba20>] (page_cache_async_readahead+0x98/0xa8)
    [   16.337043] [<800bb988>] (page_cache_async_readahead+0x0/0xa8) from [<800b2118>] (generic_file_aio_read+0x5b4/0x7c4)
    [   16.347565]  r6:00000000 r5:df74f654 r4:80fd70a0
    [   16.352231] [<800b1b64>] (generic_file_aio_read+0x0/0x7c4) from [<801e82c0>] (nfs_file_read+0x7c/0xcc)
    [   16.361544] [<801e8244>] (nfs_file_read+0x0/0xcc) from [<800eab80>] (do_sync_read+0xb4/0xf4)
    [   16.369981]  r9:00000000 r8:def05f70 r7:00000000 r6:00000000 r5:dec34900
    r4:fffffdee
    [   16.377896] [<800eaacc>] (do_sync_read+0x0/0xf4) from [<800eb548>] (vfs_read+0xb4/0x144)
    [   16.385987]  r8:00000000 r7:def05f70 r6:76a95008 r5:003e3dd6 r4:dec34900
    [   16.392761] [<800eb494>] (vfs_read+0x0/0x144) from [<800eb624>] (sys_read+0x4c/0x78)
    [   16.400504]  r8:00000000 r7:00000003 r6:003e3dd6 r5:76a95008 r4:dec34900
    [   16.407279] [<800eb5d8>] (sys_read+0x0/0x78) from [<8000e5c0>] (ret_fast_syscall+0x0/0x48)
    [   16.415543]  r9:def04000 r8:8000e864 r6:000086b4 r5:00000000 r4:00000000
    [   20.872729]  gadget: high-speed config #1: Video
    [   20.877368]  gadget: uvc_function_set_alt(0, 0)
    [   20.881908]  gadget: uvc_function_set_alt(1, 0)
    [   20.891464]  gadget: uvc_function_set_alt(1, 0)
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 3f72110da1b0..2cb1030203b5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -300,9 +300,10 @@ int usb_function_deactivate(struct usb_function *function)
 int usb_function_activate(struct usb_function *function)
 {
 	struct usb_composite_dev	*cdev = function->config->cdev;
+	unsigned long			flags;
 	int				status = 0;
 
-	spin_lock(&cdev->lock);
+	spin_lock_irqsave(&cdev->lock, flags);
 
 	if (WARN_ON(cdev->deactivations == 0))
 		status = -EINVAL;
@@ -312,7 +313,7 @@ int usb_function_activate(struct usb_function *function)
 			status = usb_gadget_connect(cdev->gadget);
 	}
 
-	spin_unlock(&cdev->lock);
+	spin_unlock_irqrestore(&cdev->lock, flags);
 	return status;
 }
 

commit b785ea7ce662c47f6208071320638a4813722803
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Jun 6 10:20:23 2012 +0300

    usb: gadget: composite: fix ep->maxburst initialization
    
    bMaxBurst field on endpoint companion descriptor
    is supposed to contain the number of burst minus
    1. When passing that to controller drivers, we
    should be passing the real number instead (by
    incrementing 1).
    
    While doing that, also fix the assumption on
    dwc3 that value comes decremented by one.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 390749bbb0c3..3f72110da1b0 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -117,6 +117,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 			struct usb_function *f,
 			struct usb_ep *_ep)
 {
+	struct usb_composite_dev	*cdev = get_gadget_data(g);
 	struct usb_endpoint_descriptor *chosen_desc = NULL;
 	struct usb_descriptor_header **speed_desc = NULL;
 
@@ -180,10 +181,12 @@ int config_ep_by_speed(struct usb_gadget *g,
 			_ep->mult = comp_desc->bmAttributes & 0x3;
 		case USB_ENDPOINT_XFER_BULK:
 		case USB_ENDPOINT_XFER_INT:
-			_ep->maxburst = comp_desc->bMaxBurst;
+			_ep->maxburst = comp_desc->bMaxBurst + 1;
 			break;
 		default:
-			/* Do nothing for control endpoints */
+			if (comp_desc->bMaxBurst != 0)
+				ERROR(cdev, "ep0 bMaxBurst must be 0\n");
+			_ep->maxburst = 1;
 			break;
 		}
 	}

commit cad4cd8fbde6b2f45b51711260343b3195615c79
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu May 10 10:08:00 2012 +0200

    usb: gadget: composite: add iSerialNumber to usb_composite_driver
    
    Add iSerialNumber to usb_composite_driver to allow setting a default value.
    This is useful when the module is compiled-in. Then the composite_bind
    is executed at kernel boot and string id for iSerialNumber can be overridden
    even if there is no iSerialNumber kernel commandline parameter.
    If the string id is not overridden, then get_string will never attempt to
    look for the alternative string contents using cdev->serial_override.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index df2749052e2c..390749bbb0c3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -938,7 +938,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	else if (cdev->product_override == id)
 		str = iProduct ?: composite->iProduct;
 	else if (cdev->serial_override == id)
-		str = iSerialNumber;
+		str = iSerialNumber ?: composite->iSerialNumber;
 	else
 		str = NULL;
 	if (str) {
@@ -1503,7 +1503,8 @@ static int composite_bind(struct usb_gadget *gadget)
 		cdev->product_override =
 			override_id(cdev, &cdev->desc.iProduct);
 
-	if (iSerialNumber)
+	if (iSerialNumber ||
+	    (!cdev->desc.iSerialNumber && composite->iSerialNumber))
 		cdev->serial_override =
 			override_id(cdev, &cdev->desc.iSerialNumber);
 

commit 4fffd6e5a24c4df3341d404446e3672bef8cffb7
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu May 10 10:07:59 2012 +0200

    usb: gadget: composite: make module parameters accessible at runtime
    
    Enable module parameters to be modified at runtime, especially
    if the module is compiled-in.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a8b8ab80bc77..df2749052e2c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -40,27 +40,27 @@ static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
  */
 
 static ushort idVendor;
-module_param(idVendor, ushort, 0);
+module_param(idVendor, ushort, 0644);
 MODULE_PARM_DESC(idVendor, "USB Vendor ID");
 
 static ushort idProduct;
-module_param(idProduct, ushort, 0);
+module_param(idProduct, ushort, 0644);
 MODULE_PARM_DESC(idProduct, "USB Product ID");
 
 static ushort bcdDevice;
-module_param(bcdDevice, ushort, 0);
+module_param(bcdDevice, ushort, 0644);
 MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
 
 static char *iManufacturer;
-module_param(iManufacturer, charp, 0);
+module_param(iManufacturer, charp, 0644);
 MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
 
 static char *iProduct;
-module_param(iProduct, charp, 0);
+module_param(iProduct, charp, 0644);
 MODULE_PARM_DESC(iProduct, "USB Product string");
 
 static char *iSerialNumber;
-module_param(iSerialNumber, charp, 0);
+module_param(iSerialNumber, charp, 0644);
 MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
 static char composite_manufacturer[50];
@@ -1473,10 +1473,16 @@ static int composite_bind(struct usb_gadget *gadget)
 	/* standardized runtime overrides for device ID data */
 	if (idVendor)
 		cdev->desc.idVendor = cpu_to_le16(idVendor);
+	else
+		idVendor = le16_to_cpu(cdev->desc.idVendor);
 	if (idProduct)
 		cdev->desc.idProduct = cpu_to_le16(idProduct);
+	else
+		idProduct = le16_to_cpu(cdev->desc.idProduct);
 	if (bcdDevice)
 		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+	else
+		bcdDevice = le16_to_cpu(cdev->desc.bcdDevice);
 
 	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {

commit 02e8161e341b4e54a4a36233f98b79763bfa3f48
Author: Benoit Goby <benoit@android.com>
Date:   Thu May 10 10:07:58 2012 +0200

    usb: gadget: composite: Initialize config->interface
    
    Reset config->interface in usb_add_config, as it may contain pointers to
    functions from a previous session if config is removed and re-added.
    
    Signed-off-by: Benoit Goby <benoit@android.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index e51b2314f5c9..a8b8ab80bc77 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -734,6 +734,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 
 	INIT_LIST_HEAD(&config->functions);
 	config->next_interface_id = 0;
+	memset(config->interface, 0, sizeof(config->interface));
 
 	status = bind(config);
 	if (status < 0) {

commit 51cce6fc155c4d7eea2ff975ee7c82b89332c6d9
Author: Benoit Goby <benoit@android.com>
Date:   Thu May 10 10:07:57 2012 +0200

    usb: gadget: composite: Add usb_remove_config
    
    Add usb_remove_config to unbind a configuration and remove it from
    the configs list. This allows implementing composite gadget drivers that
    can disconnect themself from the bus and that will later be re-enumerated
    with a different configuration.
    
    Gadget drivers must call usb_gadget_disconnect before calling this
    function to disable the pullup, disconnect the device from the host,
    and prevent the host from enumerating the device while we are changing
    the gadget configuration.
    
    Signed-off-by: Benoit Goby <benoit@android.com>
            [change return type of [usb_]remove_config]
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a3b19fe37f53..e51b2314f5c9 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -787,6 +787,53 @@ int usb_add_config(struct usb_composite_dev *cdev,
 	return status;
 }
 
+static void remove_config(struct usb_composite_dev *cdev,
+			      struct usb_configuration *config)
+{
+	while (!list_empty(&config->functions)) {
+		struct usb_function		*f;
+
+		f = list_first_entry(&config->functions,
+				struct usb_function, list);
+		list_del(&f->list);
+		if (f->unbind) {
+			DBG(cdev, "unbind function '%s'/%p\n", f->name, f);
+			f->unbind(config, f);
+			/* may free memory for "f" */
+		}
+	}
+	list_del(&config->list);
+	if (config->unbind) {
+		DBG(cdev, "unbind config '%s'/%p\n", config->label, config);
+		config->unbind(config);
+			/* may free memory for "c" */
+	}
+}
+
+/**
+ * usb_remove_config() - remove a configuration from a device.
+ * @cdev: wraps the USB gadget
+ * @config: the configuration
+ *
+ * Drivers must call usb_gadget_disconnect before calling this function
+ * to disconnect the device from the host and make sure the host will not
+ * try to enumerate the device while we are changing the config list.
+ */
+void usb_remove_config(struct usb_composite_dev *cdev,
+		      struct usb_configuration *config)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->config == config)
+		reset_config(cdev);
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	remove_config(cdev, config);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* We support strings in multiple languages ... string descriptor zero
@@ -1341,28 +1388,9 @@ composite_unbind(struct usb_gadget *gadget)
 
 	while (!list_empty(&cdev->configs)) {
 		struct usb_configuration	*c;
-
 		c = list_first_entry(&cdev->configs,
 				struct usb_configuration, list);
-		while (!list_empty(&c->functions)) {
-			struct usb_function		*f;
-
-			f = list_first_entry(&c->functions,
-					struct usb_function, list);
-			list_del(&f->list);
-			if (f->unbind) {
-				DBG(cdev, "unbind function '%s'/%p\n",
-						f->name, f);
-				f->unbind(c, f);
-				/* may free memory for "f" */
-			}
-		}
-		list_del(&c->list);
-		if (c->unbind) {
-			DBG(cdev, "unbind config '%s'/%p\n", c->label, c);
-			c->unbind(c);
-			/* may free memory for "c" */
-		}
+		remove_config(cdev, c);
 	}
 	if (composite->unbind)
 		composite->unbind(cdev);

commit 20c5e74c7b47cefaf2cd0f84bdb4830b66452384
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Apr 17 09:30:22 2012 +0300

    usb: gadget: add a sparse endian notation
    
    The original code works fine, but Sparse complains because it isn't
    annotated properly.
    
    drivers/usb/gadget/composite.c:793:26: warning: incorrect type in assignment (different base types)
    drivers/usb/gadget/composite.c:793:26:    expected unsigned short [unsigned] [usertype] language
    devel/drivers/usb/gadget/composite.c:793:26:    got restricted __le16 [usertype] <noident>
    devel/drivers/usb/gadget/composite.c:795:29: warning: restricted __le16 degrades to integer
    drivers/usb/gadget/composite.c:798:24: warning: incorrect type in assignment (different base types)
    drivers/usb/gadget/composite.c:798:24:    expected restricted __le16 [usertype] <noident>
    devel/drivers/usb/gadget/composite.c:798:24:    got unsigned short [unsigned] [usertype] language
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 4cb1801539a6..a3b19fe37f53 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -798,7 +798,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 static void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)
 {
 	const struct usb_gadget_strings	*s;
-	u16				language;
+	__le16				language;
 	__le16				*tmp;
 
 	while (*sp) {

commit 124ef389256f71042ab5dedde98dee5e9999a635
Author: Yongsul Oh <yongsul96.oh@samsung.com>
Date:   Tue Mar 20 10:38:38 2012 +0900

    usb: gadget: composite: prevent a memory leak when configuration bind fails
    
    In some USB composite gadget drivers, the configuration's bind function called
    by the usb_add_config() calls multiple bind config functions. (for example cdc2
    configuration bind function in the cdc_do_config() of the cdc2.c has two
    functionality bind config functions.
      - the ecm_bind_config() & the acm_bind_config())
    
    In each functionality bind config function, new instance is allocated and
    finally added by the usb_add_function().
    
    So if an error occurred during the second functionality bind config (for
    example an error occurred at the acm_bind_config() after succeeding of the
    ecm_bind_function()), the instance created by the acm_bind_config() cannot be
    freed creating a memory leak.
    
    This patch fixes this issue.
    
    Signed-off-by: Yongsul Oh <yongsul96.oh@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index baaebf2830fc..4cb1801539a6 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -737,6 +737,19 @@ int usb_add_config(struct usb_composite_dev *cdev,
 
 	status = bind(config);
 	if (status < 0) {
+		while (!list_empty(&config->functions)) {
+			struct usb_function		*f;
+
+			f = list_first_entry(&config->functions,
+					struct usb_function, list);
+			list_del(&f->list);
+			if (f->unbind) {
+				DBG(cdev, "unbind function '%s'/%p\n",
+					f->name, f);
+				f->unbind(config, f);
+				/* may free memory for "f" */
+			}
+		}
 		list_del(&config->list);
 		config->cdev = NULL;
 	} else {

commit 9e878a6bfa9e1cf70cf77caeca60a0465d77954b
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Mon Jan 16 13:24:38 2012 -0800

    usb: gadget: SS Isoc endpoints use comp_desc->bMaxBurst too
    
    SuperSpeed Isoc endpoints also use the bMaxBurst value from the
    companion descriptor. See section 9.6.7 in the USB 3.0 spec.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a95de6a4a134..baaebf2830fc 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -175,13 +175,12 @@ int config_ep_by_speed(struct usb_gadget *g,
 	_ep->comp_desc = comp_desc;
 	if (g->speed == USB_SPEED_SUPER) {
 		switch (usb_endpoint_type(_ep->desc)) {
-		case USB_ENDPOINT_XFER_BULK:
-		case USB_ENDPOINT_XFER_INT:
-			_ep->maxburst = comp_desc->bMaxBurst;
-			break;
 		case USB_ENDPOINT_XFER_ISOC:
 			/* mult: bits 1:0 of bmAttributes */
 			_ep->mult = comp_desc->bmAttributes & 0x3;
+		case USB_ENDPOINT_XFER_BULK:
+		case USB_ENDPOINT_XFER_INT:
+			_ep->maxburst = comp_desc->bMaxBurst;
 			break;
 		default:
 			/* Do nothing for control endpoints */

commit 7177aed44f515d949f587170e0e177ce17e74793
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sat Nov 19 18:27:38 2011 +0100

    usb: gadget: rename usb_gadget_driver::speed to max_speed
    
    This commit renames the speedfield of the usb_gadget_driver
    structure to max_speed.  This is so that to make it more
    apparent that the field represents the maximum speed gadget
    driver can support.
    
    This also make the field look more like fields with the same
    name in usb_gadget and usb_composite_driver structures.  All
    of those represent the *maximal* speed given entity supports.
    
    After this commit, there are the following fields in various
    structures:
    * usb_gadget::speed - the current connection speed,
    * usb_gadget::max_speed - maximal speed UDC supports,
    * usb_gadget_driver::max_speed - maximal speed gadget driver
      supports, and
    * usb_composite_driver::max_speed - maximal speed composite
      gadget supports.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f71b0787983f..a95de6a4a134 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1535,9 +1535,9 @@ composite_resume(struct usb_gadget *gadget)
 
 static struct usb_gadget_driver composite_driver = {
 #ifdef CONFIG_USB_GADGET_SUPERSPEED
-	.speed		= USB_SPEED_SUPER,
+	.max_speed	= USB_SPEED_SUPER,
 #else
-	.speed		= USB_SPEED_HIGH,
+	.max_speed	= USB_SPEED_HIGH,
 #endif
 
 	.unbind		= composite_unbind,
@@ -1584,8 +1584,8 @@ int usb_composite_probe(struct usb_composite_driver *driver,
 		driver->iProduct = driver->name;
 	composite_driver.function =  (char *) driver->name;
 	composite_driver.driver.name = driver->name;
-	composite_driver.speed = min((u8)composite_driver.speed,
-				     (u8)driver->max_speed);
+	composite_driver.max_speed =
+		min_t(u8, composite_driver.max_speed, driver->max_speed);
 	composite = driver;
 	composite_gadget_bind = bind;
 

commit 6eb0de827084060e6607c8f8542d9e9566214538
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 16:09:31 2011 -0400

    usb: Add module.h to drivers/usb consumers who really use it.
    
    The situation up to this point meant that module.h was pretty
    much everywhere, regardless of whether you asked for it or not.
    We are fixing that, so give the USB folks who want it an actual
    include of it.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8a5529d214fb..f71b0787983f 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -14,6 +14,7 @@
 #include <linux/kallsyms.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/utsname.h>
 

commit 089b837a39552ee49a4ea4c188e8c3517473f10c
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Oct 10 09:43:44 2011 +0300

    usb: gadget: fix typo for default U1/U2 exit latencies
    
    s/DEFULT/DEFAULT/, no functional changes.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index e74fd55c33d9..8a5529d214fb 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -542,9 +542,9 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	if (cdev->gadget->ops->get_config_params)
 		cdev->gadget->ops->get_config_params(&dcd_config_params);
 	else {
-		dcd_config_params.bU1devExitLat = USB_DEFULT_U1_DEV_EXIT_LAT;
+		dcd_config_params.bU1devExitLat = USB_DEFAULT_U1_DEV_EXIT_LAT;
 		dcd_config_params.bU2DevExitLat =
-			cpu_to_le16(USB_DEFULT_U2_DEV_EXIT_LAT);
+			cpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);
 	}
 	ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
 	ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;

commit e538dfdae85244fd2c4231725d82cc1f1bc4942c
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Tue Aug 30 17:11:19 2011 +0200

    usb: Provide usb_speed_string() function
    
    In a few places in the kernel, the code prints
    a human-readable USB device speed (eg. "high speed").
    This involves a switch statement sometimes wrapped
    around in ({ ... }) block leading to code repetition.
    
    To mitigate this issue, this commit introduces
    usb_speed_string() function, which returns
    a human-readable name of provided speed.
    
    It also changes a few places switch was used to use
    this new function.  This changes a bit the way the
    speed is printed in few instances at the same time
    standardising it.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c77aca11ad53..e74fd55c33d9 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -617,25 +617,9 @@ static int set_config(struct usb_composite_dev *cdev,
 		result = 0;
 	}
 
-	INFO(cdev, "%s speed config #%d: %s\n",
-		({ char *speed;
-		switch (gadget->speed) {
-		case USB_SPEED_LOW:
-			speed = "low";
-			break;
-		case USB_SPEED_FULL:
-			speed = "full";
-			break;
-		case USB_SPEED_HIGH:
-			speed = "high";
-			break;
-		case USB_SPEED_SUPER:
-			speed = "super";
-			break;
-		default:
-			speed = "?";
-			break;
-		} ; speed; }), number, c ? c->label : "unconfigured");
+	INFO(cdev, "%s config #%d: %s\n",
+	     usb_speed_string(gadget->speed),
+	     number, c ? c->label : "unconfigured");
 
 	if (!c)
 		goto done;

commit 28c9fc68ebd32d473a8787d05c74e3f39c6c866b
Author: Klaus Schwarzkopf <schwarzkopf@sensortherm.de>
Date:   Fri Sep 9 16:10:44 2011 +0200

    usb gadget: clean up FSF boilerplate text
    
    remove the following two paragraphs as they are not needed:
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
    
    You should have received a copy of the GNU General Public License along with
    this program; if not, write to the Free Software Foundation, Inc.,59
    Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    
    Signed-off-by: Klaus Schwarzkopf <schwarzkopf@sensortherm.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8065464523b1..c77aca11ad53 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -7,15 +7,6 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 /* #define VERBOSE_DEBUG */

commit 29cc88979a8818cd8c5019426e945aed118b400e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 23 03:12:03 2011 -0700

    USB: use usb_endpoint_maxp() instead of le16_to_cpu()
    
    Now ${LINUX}/drivers/usb/* can use usb_endpoint_maxp(desc) to get maximum packet size
    instead of le16_to_cpu(desc->wMaxPacketSize).
    This patch fix it up
    
    Cc: Armin Fuerst <fuerst@in.tum.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Erdfelt <johannes@erdfelt.com>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: David Kubicek <dave@awk.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Brad Hards <bhards@bigpond.net.au>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Dahlmann <dahlmann.thomas@arcor.de>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: David Lopo <dlopo@chipidea.mips.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Xie Xiaobo <X.Xie@freescale.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Jiang Bo <tanya.jiang@freescale.com>
    Cc: Yuan-hsin Chen <yhchen@faraday-tech.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: OKI SEMICONDUCTOR, <toshiharu-linux@dsn.okisemi.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Herbert Ptzl <herbert@13thfloor.at>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Roman Weissgaerber <weissg@vienna.at>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: Florian Floe Echtler <echtler@fs.tum.de>
    Cc: Christian Lucht <lucht@codemercs.com>
    Cc: Juergen Stuber <starblue@sourceforge.net>
    Cc: Georges Toth <g.toth@e-biz.lu>
    Cc: Bill Ryder <bryder@sgi.com>
    Cc: Kuba Ober <kuba@mareimbrium.org>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index aef47414f5d5..8065464523b1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -164,7 +164,7 @@ int config_ep_by_speed(struct usb_gadget *g,
 
 ep_found:
 	/* commit results */
-	_ep->maxpacket = le16_to_cpu(chosen_desc->wMaxPacketSize);
+	_ep->maxpacket = usb_endpoint_maxp(chosen_desc);
 	_ep->desc = chosen_desc;
 	_ep->comp_desc = NULL;
 	_ep->maxburst = 0;

commit a8f21156a07cb0b11fddeab771e11ec7c08283c9
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Jul 19 20:21:52 2011 +0200

    usb: gadget: composite: fix bMaxPacketSize for SuperSpeed
    
    For bMaxPacketSize0 we usually take what is specified in ep0->maxpacket.
    This is fine in most cases, however on SuperSpeed bMaxPacketSize0
    specifies the exponent instead of the actual size in bytes. The only
    valid value on SS is 9 which denotes 512 bytes.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5ef87794fd32..aef47414f5d5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1079,10 +1079,12 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			cdev->desc.bMaxPacketSize0 =
 				cdev->gadget->ep0->maxpacket;
 			if (gadget_is_superspeed(gadget)) {
-				if (gadget->speed >= USB_SPEED_SUPER)
+				if (gadget->speed >= USB_SPEED_SUPER) {
 					cdev->desc.bcdUSB = cpu_to_le16(0x0300);
-				else
+					cdev->desc.bMaxPacketSize0 = 9;
+				} else {
 					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
+				}
 			}
 
 			value = min(w_length, (u16) sizeof cdev->desc);

commit 765f5b830e547229bb752e7b232ee83e2b3d49d5
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Jun 23 14:26:11 2011 +0200

    usb: gadget: defer setting maxpacket till ->setup()
    
    maxpacket is set by the udc driver for ep0 very early. This value is
    copied by the function gadget used later for the USB_DT_DEVICE and
    USB_DT_DEVICE_QUALIFIER query. This seems to work fine so far. For USB3
    we need set a different value here. In SS speed it is 2^x with x=9 and
    in HS we set something <= 64. If the UDC starts in SS and continues in
    HS after the cable has been plugged it will report a too small value.
    There setting of this value is defered and taken automaticly from the
    ep0 pointer where the UDC driver can update it according to the speed it
    detected _after_ a cable has been plugged.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c5abe270970a..5ef87794fd32 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -573,7 +573,7 @@ static void device_qual(struct usb_composite_dev *cdev)
 	qual->bDeviceSubClass = cdev->desc.bDeviceSubClass;
 	qual->bDeviceProtocol = cdev->desc.bDeviceProtocol;
 	/* ASSUME same EP0 fifo size at both speeds */
-	qual->bMaxPacketSize0 = cdev->desc.bMaxPacketSize0;
+	qual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;
 	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
 	qual->bRESERVED = 0;
 }
@@ -1450,7 +1450,6 @@ static int composite_bind(struct usb_gadget *gadget)
 		goto fail;
 
 	cdev->desc = *composite->dev;
-	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
 	/* standardized runtime overrides for device ID data */
 	if (idVendor)

commit bdb64d727216b49a18c2b8337658adc6b2db82ea
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Wed Jun 29 16:41:50 2011 +0300

    usb: gadget: add SuperSpeed support to the Gadget Framework
    
    SuperSpeed USB has defined a new descriptor, called
    the Binary Device Object Store (BOS) Descriptor. It
    has also changed a bit the definition of SET_FEATURE
    and GET_STATUS requests to add USB3-specific details.
    
    This patch implements both changes to the Composite
    Gadget Framework.
    
    [ balbi@ti.com : slight changes to commit log
                     fixed a compile error on ARM ]
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 897e4f57422f..c5abe270970a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -27,7 +27,7 @@
 #include <linux/utsname.h>
 
 #include <linux/usb/composite.h>
-
+#include <asm/unaligned.h>
 
 /*
  * The code in this file is utility code, used to build a gadget driver
@@ -128,6 +128,9 @@ int config_ep_by_speed(struct usb_gadget *g,
 	struct usb_endpoint_descriptor *chosen_desc = NULL;
 	struct usb_descriptor_header **speed_desc = NULL;
 
+	struct usb_ss_ep_comp_descriptor *comp_desc = NULL;
+	int want_comp_desc = 0;
+
 	struct usb_descriptor_header **d_spd; /* cursor for speed desc */
 
 	if (!g || !f || !_ep)
@@ -135,6 +138,13 @@ int config_ep_by_speed(struct usb_gadget *g,
 
 	/* select desired speed */
 	switch (g->speed) {
+	case USB_SPEED_SUPER:
+		if (gadget_is_superspeed(g)) {
+			speed_desc = f->ss_descriptors;
+			want_comp_desc = 1;
+			break;
+		}
+		/* else: Fall trough */
 	case USB_SPEED_HIGH:
 		if (gadget_is_dualspeed(g)) {
 			speed_desc = f->hs_descriptors;
@@ -156,7 +166,36 @@ int config_ep_by_speed(struct usb_gadget *g,
 	/* commit results */
 	_ep->maxpacket = le16_to_cpu(chosen_desc->wMaxPacketSize);
 	_ep->desc = chosen_desc;
+	_ep->comp_desc = NULL;
+	_ep->maxburst = 0;
+	_ep->mult = 0;
+	if (!want_comp_desc)
+		return 0;
 
+	/*
+	 * Companion descriptor should follow EP descriptor
+	 * USB 3.0 spec, #9.6.7
+	 */
+	comp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);
+	if (!comp_desc ||
+	    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))
+		return -EIO;
+	_ep->comp_desc = comp_desc;
+	if (g->speed == USB_SPEED_SUPER) {
+		switch (usb_endpoint_type(_ep->desc)) {
+		case USB_ENDPOINT_XFER_BULK:
+		case USB_ENDPOINT_XFER_INT:
+			_ep->maxburst = comp_desc->bMaxBurst;
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			/* mult: bits 1:0 of bmAttributes */
+			_ep->mult = comp_desc->bmAttributes & 0x3;
+			break;
+		default:
+			/* Do nothing for control endpoints */
+			break;
+		}
+	}
 	return 0;
 }
 
@@ -208,6 +247,8 @@ int usb_add_function(struct usb_configuration *config,
 		config->fullspeed = true;
 	if (!config->highspeed && function->hs_descriptors)
 		config->highspeed = true;
+	if (!config->superspeed && function->ss_descriptors)
+		config->superspeed = true;
 
 done:
 	if (value)
@@ -351,10 +392,17 @@ static int config_buf(struct usb_configuration *config,
 	list_for_each_entry(f, &config->functions, list) {
 		struct usb_descriptor_header **descriptors;
 
-		if (speed == USB_SPEED_HIGH)
+		switch (speed) {
+		case USB_SPEED_SUPER:
+			descriptors = f->ss_descriptors;
+			break;
+		case USB_SPEED_HIGH:
 			descriptors = f->hs_descriptors;
-		else
+			break;
+		default:
 			descriptors = f->descriptors;
+		}
+
 		if (!descriptors)
 			continue;
 		status = usb_descriptor_fillbuf(next, len,
@@ -377,9 +425,10 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 	u8				type = w_value >> 8;
 	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
 
-	if (gadget_is_dualspeed(gadget)) {
-		int			hs = 0;
-
+	if (gadget->speed == USB_SPEED_SUPER)
+		speed = gadget->speed;
+	else if (gadget_is_dualspeed(gadget)) {
+		int	hs = 0;
 		if (gadget->speed == USB_SPEED_HIGH)
 			hs = 1;
 		if (type == USB_DT_OTHER_SPEED_CONFIG)
@@ -393,13 +442,20 @@ static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 	w_value &= 0xff;
 	list_for_each_entry(c, &cdev->configs, list) {
 		/* ignore configs that won't work at this speed */
-		if (speed == USB_SPEED_HIGH) {
+		switch (speed) {
+		case USB_SPEED_SUPER:
+			if (!c->superspeed)
+				continue;
+			break;
+		case USB_SPEED_HIGH:
 			if (!c->highspeed)
 				continue;
-		} else {
+			break;
+		default:
 			if (!c->fullspeed)
 				continue;
 		}
+
 		if (w_value == 0)
 			return config_buf(c, speed, cdev->req->buf, type);
 		w_value--;
@@ -413,16 +469,22 @@ static int count_configs(struct usb_composite_dev *cdev, unsigned type)
 	struct usb_configuration	*c;
 	unsigned			count = 0;
 	int				hs = 0;
+	int				ss = 0;
 
 	if (gadget_is_dualspeed(gadget)) {
 		if (gadget->speed == USB_SPEED_HIGH)
 			hs = 1;
+		if (gadget->speed == USB_SPEED_SUPER)
+			ss = 1;
 		if (type == USB_DT_DEVICE_QUALIFIER)
 			hs = !hs;
 	}
 	list_for_each_entry(c, &cdev->configs, list) {
 		/* ignore configs that won't work at this speed */
-		if (hs) {
+		if (ss) {
+			if (!c->superspeed)
+				continue;
+		} else if (hs) {
 			if (!c->highspeed)
 				continue;
 		} else {
@@ -434,6 +496,71 @@ static int count_configs(struct usb_composite_dev *cdev, unsigned type)
 	return count;
 }
 
+/**
+ * bos_desc() - prepares the BOS descriptor.
+ * @cdev: pointer to usb_composite device to generate the bos
+ *	descriptor for
+ *
+ * This function generates the BOS (Binary Device Object)
+ * descriptor and its device capabilities descriptors. The BOS
+ * descriptor should be supported by a SuperSpeed device.
+ */
+static int bos_desc(struct usb_composite_dev *cdev)
+{
+	struct usb_ext_cap_descriptor	*usb_ext;
+	struct usb_ss_cap_descriptor	*ss_cap;
+	struct usb_dcd_config_params	dcd_config_params;
+	struct usb_bos_descriptor	*bos = cdev->req->buf;
+
+	bos->bLength = USB_DT_BOS_SIZE;
+	bos->bDescriptorType = USB_DT_BOS;
+
+	bos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);
+	bos->bNumDeviceCaps = 0;
+
+	/*
+	 * A SuperSpeed device shall include the USB2.0 extension descriptor
+	 * and shall support LPM when operating in USB2.0 HS mode.
+	 */
+	usb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+	bos->bNumDeviceCaps++;
+	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);
+	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
+	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
+	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);
+
+	/*
+	 * The Superspeed USB Capability descriptor shall be implemented by all
+	 * SuperSpeed devices.
+	 */
+	ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
+	bos->bNumDeviceCaps++;
+	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);
+	ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
+	ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
+	ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
+	ss_cap->bmAttributes = 0; /* LTM is not supported yet */
+	ss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |
+				USB_FULL_SPEED_OPERATION |
+				USB_HIGH_SPEED_OPERATION |
+				USB_5GBPS_OPERATION);
+	ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
+
+	/* Get Controller configuration */
+	if (cdev->gadget->ops->get_config_params)
+		cdev->gadget->ops->get_config_params(&dcd_config_params);
+	else {
+		dcd_config_params.bU1devExitLat = USB_DEFULT_U1_DEV_EXIT_LAT;
+		dcd_config_params.bU2DevExitLat =
+			cpu_to_le16(USB_DEFULT_U2_DEV_EXIT_LAT);
+	}
+	ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
+	ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
+
+	return le16_to_cpu(bos->wTotalLength);
+}
+
 static void device_qual(struct usb_composite_dev *cdev)
 {
 	struct usb_qualifier_descriptor	*qual = cdev->req->buf;
@@ -477,20 +604,27 @@ static int set_config(struct usb_composite_dev *cdev,
 	unsigned		power = gadget_is_otg(gadget) ? 8 : 100;
 	int			tmp;
 
-	if (cdev->config)
-		reset_config(cdev);
-
 	if (number) {
 		list_for_each_entry(c, &cdev->configs, list) {
 			if (c->bConfigurationValue == number) {
+				/*
+				 * We disable the FDs of the previous
+				 * configuration only if the new configuration
+				 * is a valid one
+				 */
+				if (cdev->config)
+					reset_config(cdev);
 				result = 0;
 				break;
 			}
 		}
 		if (result < 0)
 			goto done;
-	} else
+	} else { /* Zero configuration value - need to reset the config */
+		if (cdev->config)
+			reset_config(cdev);
 		result = 0;
+	}
 
 	INFO(cdev, "%s speed config #%d: %s\n",
 		({ char *speed;
@@ -504,6 +638,9 @@ static int set_config(struct usb_composite_dev *cdev,
 		case USB_SPEED_HIGH:
 			speed = "high";
 			break;
+		case USB_SPEED_SUPER:
+			speed = "super";
+			break;
 		default:
 			speed = "?";
 			break;
@@ -528,10 +665,16 @@ static int set_config(struct usb_composite_dev *cdev,
 		 * function's setup callback instead of the current
 		 * configuration's setup callback.
 		 */
-		if (gadget->speed == USB_SPEED_HIGH)
+		switch (gadget->speed) {
+		case USB_SPEED_SUPER:
+			descriptors = f->ss_descriptors;
+			break;
+		case USB_SPEED_HIGH:
 			descriptors = f->hs_descriptors;
-		else
+			break;
+		default:
 			descriptors = f->descriptors;
+		}
 
 		for (; *descriptors; ++descriptors) {
 			struct usb_endpoint_descriptor *ep;
@@ -624,8 +767,9 @@ int usb_add_config(struct usb_composite_dev *cdev,
 	} else {
 		unsigned	i;
 
-		DBG(cdev, "cfg %d/%p speeds:%s%s\n",
+		DBG(cdev, "cfg %d/%p speeds:%s%s%s\n",
 			config->bConfigurationValue, config,
+			config->superspeed ? " super" : "",
 			config->highspeed ? " high" : "",
 			config->fullspeed
 				? (gadget_is_dualspeed(cdev->gadget)
@@ -904,6 +1048,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_request		*req = cdev->req;
 	int				value = -EOPNOTSUPP;
+	int				status = 0;
 	u16				w_index = le16_to_cpu(ctrl->wIndex);
 	u8				intf = w_index & 0xFF;
 	u16				w_value = le16_to_cpu(ctrl->wValue);
@@ -931,18 +1076,29 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		case USB_DT_DEVICE:
 			cdev->desc.bNumConfigurations =
 				count_configs(cdev, USB_DT_DEVICE);
+			cdev->desc.bMaxPacketSize0 =
+				cdev->gadget->ep0->maxpacket;
+			if (gadget_is_superspeed(gadget)) {
+				if (gadget->speed >= USB_SPEED_SUPER)
+					cdev->desc.bcdUSB = cpu_to_le16(0x0300);
+				else
+					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
+			}
+
 			value = min(w_length, (u16) sizeof cdev->desc);
 			memcpy(req->buf, &cdev->desc, value);
 			break;
 		case USB_DT_DEVICE_QUALIFIER:
-			if (!gadget_is_dualspeed(gadget))
+			if (!gadget_is_dualspeed(gadget) ||
+			    gadget->speed >= USB_SPEED_SUPER)
 				break;
 			device_qual(cdev);
 			value = min_t(int, w_length,
 				sizeof(struct usb_qualifier_descriptor));
 			break;
 		case USB_DT_OTHER_SPEED_CONFIG:
-			if (!gadget_is_dualspeed(gadget))
+			if (!gadget_is_dualspeed(gadget) ||
+			    gadget->speed >= USB_SPEED_SUPER)
 				break;
 			/* FALLTHROUGH */
 		case USB_DT_CONFIG:
@@ -956,6 +1112,12 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			if (value >= 0)
 				value = min(w_length, (u16) value);
 			break;
+		case USB_DT_BOS:
+			if (gadget_is_superspeed(gadget)) {
+				value = bos_desc(cdev);
+				value = min(w_length, (u16) value);
+			}
+			break;
 		}
 		break;
 
@@ -1023,6 +1185,61 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		*((u8 *)req->buf) = value;
 		value = min(w_length, (u16) 1);
 		break;
+
+	/*
+	 * USB 3.0 additions:
+	 * Function driver should handle get_status request. If such cb
+	 * wasn't supplied we respond with default value = 0
+	 * Note: function driver should supply such cb only for the first
+	 * interface of the function
+	 */
+	case USB_REQ_GET_STATUS:
+		if (!gadget_is_superspeed(gadget))
+			goto unknown;
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))
+			goto unknown;
+		value = 2;	/* This is the length of the get_status reply */
+		put_unaligned_le16(0, req->buf);
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[intf];
+		if (!f)
+			break;
+		status = f->get_status ? f->get_status(f) : 0;
+		if (status < 0)
+			break;
+		put_unaligned_le16(status & 0x0000ffff, req->buf);
+		break;
+	/*
+	 * Function drivers should handle SetFeature/ClearFeature
+	 * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied
+	 * only for the first interface of the function
+	 */
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		if (!gadget_is_superspeed(gadget))
+			goto unknown;
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))
+			goto unknown;
+		switch (w_value) {
+		case USB_INTRF_FUNC_SUSPEND:
+			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
+				break;
+			f = cdev->config->interface[intf];
+			if (!f)
+				break;
+			value = 0;
+			if (f->func_suspend)
+				value = f->func_suspend(f, w_index >> 8);
+			if (value < 0) {
+				ERROR(cdev,
+				      "func_suspend() returned error %d\n",
+				      value);
+				value = 0;
+			}
+			break;
+		}
+		break;
 	default:
 unknown:
 		VDBG(cdev,
@@ -1340,7 +1557,11 @@ composite_resume(struct usb_gadget *gadget)
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver composite_driver = {
+#ifdef CONFIG_USB_GADGET_SUPERSPEED
+	.speed		= USB_SPEED_SUPER,
+#else
 	.speed		= USB_SPEED_HIGH,
+#endif
 
 	.unbind		= composite_unbind,
 

commit 35a0e0bf6f6b2b900d461e9f35c286953b2b1afc
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Wed Jun 29 16:41:49 2011 +0300

    usb: gadget: add max_speed to usb_composite_driver
    
    This field is used by the Gadget drivers to specify
    the maximum speed they support, meaning: the maximum
    speed they can provide descriptors for.
    
    The driver speed will be set in consideration of this
    value.
    
    [ balbi@ti.com : dropped the ifdeffery ]
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index ed8a70f271f4..897e4f57422f 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1386,6 +1386,8 @@ int usb_composite_probe(struct usb_composite_driver *driver,
 		driver->iProduct = driver->name;
 	composite_driver.function =  (char *) driver->name;
 	composite_driver.driver.name = driver->name;
+	composite_driver.speed = min((u8)composite_driver.speed,
+				     (u8)driver->max_speed);
 	composite = driver;
 	composite_gadget_bind = bind;
 

commit 7c884fe4d74d17efc83b19f3dc898a75f03859e9
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Tue Jun 28 16:33:52 2011 +0300

    usb: gadget: coding style fix
    
    fix the coding style of a few switches on the
    gadget framework.
    
    [ balbi@ti.com : add a commit log ]
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1c6bd666150a..ed8a70f271f4 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -495,10 +495,18 @@ static int set_config(struct usb_composite_dev *cdev,
 	INFO(cdev, "%s speed config #%d: %s\n",
 		({ char *speed;
 		switch (gadget->speed) {
-		case USB_SPEED_LOW:	speed = "low"; break;
-		case USB_SPEED_FULL:	speed = "full"; break;
-		case USB_SPEED_HIGH:	speed = "high"; break;
-		default:		speed = "?"; break;
+		case USB_SPEED_LOW:
+			speed = "low";
+			break;
+		case USB_SPEED_FULL:
+			speed = "full";
+			break;
+		case USB_SPEED_HIGH:
+			speed = "high";
+			break;
+		default:
+			speed = "?";
+			break;
 		} ; speed; }), number, c ? c->label : "unconfigured");
 
 	if (!c)

commit 48767a4e8263620c347c3fa17812c943dd0fc2fa
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Tue Jun 28 16:33:49 2011 +0300

    usb: gadget: configure endpoint according to gadget speed
    
    Add config_ep_by_speed() to configure the endpoint
    according to the gadget speed.
    
    Using this function will spare the FDs from handling
    the endpoint chosen descriptor.
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5cbb1a41c223..1c6bd666150a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -74,6 +74,91 @@ MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 static char composite_manufacturer[50];
 
 /*-------------------------------------------------------------------------*/
+/**
+ * next_ep_desc() - advance to the next EP descriptor
+ * @t: currect pointer within descriptor array
+ *
+ * Return: next EP descriptor or NULL
+ *
+ * Iterate over @t until either EP descriptor found or
+ * NULL (that indicates end of list) encountered
+ */
+static struct usb_descriptor_header**
+next_ep_desc(struct usb_descriptor_header **t)
+{
+	for (; *t; t++) {
+		if ((*t)->bDescriptorType == USB_DT_ENDPOINT)
+			return t;
+	}
+	return NULL;
+}
+
+/*
+ * for_each_ep_desc()- iterate over endpoint descriptors in the
+ *		descriptors list
+ * @start:	pointer within descriptor array.
+ * @ep_desc:	endpoint descriptor to use as the loop cursor
+ */
+#define for_each_ep_desc(start, ep_desc) \
+	for (ep_desc = next_ep_desc(start); \
+	      ep_desc; ep_desc = next_ep_desc(ep_desc+1))
+
+/**
+ * config_ep_by_speed() - configures the given endpoint
+ * according to gadget speed.
+ * @g: pointer to the gadget
+ * @f: usb function
+ * @_ep: the endpoint to configure
+ *
+ * Return: error code, 0 on success
+ *
+ * This function chooses the right descriptors for a given
+ * endpoint according to gadget speed and saves it in the
+ * endpoint desc field. If the endpoint already has a descriptor
+ * assigned to it - overwrites it with currently corresponding
+ * descriptor. The endpoint maxpacket field is updated according
+ * to the chosen descriptor.
+ * Note: the supplied function should hold all the descriptors
+ * for supported speeds
+ */
+int config_ep_by_speed(struct usb_gadget *g,
+			struct usb_function *f,
+			struct usb_ep *_ep)
+{
+	struct usb_endpoint_descriptor *chosen_desc = NULL;
+	struct usb_descriptor_header **speed_desc = NULL;
+
+	struct usb_descriptor_header **d_spd; /* cursor for speed desc */
+
+	if (!g || !f || !_ep)
+		return -EIO;
+
+	/* select desired speed */
+	switch (g->speed) {
+	case USB_SPEED_HIGH:
+		if (gadget_is_dualspeed(g)) {
+			speed_desc = f->hs_descriptors;
+			break;
+		}
+		/* else: fall through */
+	default:
+		speed_desc = f->descriptors;
+	}
+	/* find descriptors */
+	for_each_ep_desc(speed_desc, d_spd) {
+		chosen_desc = (struct usb_endpoint_descriptor *)*d_spd;
+		if (chosen_desc->bEndpointAddress == _ep->address)
+			goto ep_found;
+	}
+	return -EIO;
+
+ep_found:
+	/* commit results */
+	_ep->maxpacket = le16_to_cpu(chosen_desc->wMaxPacketSize);
+	_ep->desc = chosen_desc;
+
+	return 0;
+}
 
 /**
  * usb_add_function() - add a function to a configuration

commit 1b9ba000177ee47bcc5b44c7c34e48e735f5f9b1
Author: Roger Quadros <roger.quadros@nokia.com>
Date:   Mon May 9 13:08:06 2011 +0300

    usb: gadget: composite: Allow function drivers to pause control transfers
    
    Some USB function drivers (e.g. f_mass_storage.c) need to delay or defer the
    data/status stages of standard control requests like SET_CONFIGURATION or
    SET_INTERFACE till they are done with their bookkeeping and are actually ready
    for accepting new commands to their interface.
    
    They can now achieve this functionality by returning USB_GADGET_DELAYED_STATUS
    in their setup handlers (e.g. set_alt()). The composite framework will then
    defer completion of the control transfer by not completing the data/status stages.
    
    This ensures that the host does not send new packets to the interface till the
    function driver is ready to take them.
    
    When the function driver that requested for USB_GADGET_DELAYED_STATUS is done
    with its bookkeeping, it should signal the composite framework to continue with
    the data/status stages of the control transfer. It can do so by invoking
    the new API usb_composite_setup_continue(). This is where the control transfer's
    data/status stages are completed and host can initiate new transfers.
    
    The DELAYED_STATUS mechanism is currently only supported if the expected data phase
    is 0 bytes (i.e. w_length == 0). Since SET_CONFIGURATION and SET_INTERFACE are the
    only cases that will use this mechanism, this is not a limitation.
    
    Signed-off-by: Roger Quadros <roger.quadros@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 82314ed22506..5cbb1a41c223 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -461,12 +461,23 @@ static int set_config(struct usb_composite_dev *cdev,
 			reset_config(cdev);
 			goto done;
 		}
+
+		if (result == USB_GADGET_DELAYED_STATUS) {
+			DBG(cdev,
+			 "%s: interface %d (%s) requested delayed status\n",
+					__func__, tmp, f->name);
+			cdev->delayed_status++;
+			DBG(cdev, "delayed_status count %d\n",
+					cdev->delayed_status);
+		}
 	}
 
 	/* when we return, be sure our power usage is valid */
 	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
 done:
 	usb_gadget_vbus_draw(gadget, power);
+	if (result >= 0 && cdev->delayed_status)
+		result = USB_GADGET_DELAYED_STATUS;
 	return result;
 }
 
@@ -895,6 +906,14 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		if (w_value && !f->set_alt)
 			break;
 		value = f->set_alt(f, w_index, w_value);
+		if (value == USB_GADGET_DELAYED_STATUS) {
+			DBG(cdev,
+			 "%s: interface %d (%s) requested delayed status\n",
+					__func__, intf, f->name);
+			cdev->delayed_status++;
+			DBG(cdev, "delayed_status count %d\n",
+					cdev->delayed_status);
+		}
 		break;
 	case USB_REQ_GET_INTERFACE:
 		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
@@ -958,7 +977,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	}
 
 	/* respond with data transfer before status phase? */
-	if (value >= 0) {
+	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
 		req->length = value;
 		req->zero = value < w_length;
 		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
@@ -967,6 +986,10 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			req->status = 0;
 			composite_setup_complete(gadget->ep0, req);
 		}
+	} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {
+		WARN(cdev,
+			"%s: Delayed status not supported for w_length != 0",
+			__func__);
 	}
 
 done:
@@ -1289,3 +1312,40 @@ void usb_composite_unregister(struct usb_composite_driver *driver)
 		return;
 	usb_gadget_unregister_driver(&composite_driver);
 }
+
+/**
+ * usb_composite_setup_continue() - Continue with the control transfer
+ * @cdev: the composite device who's control transfer was kept waiting
+ *
+ * This function must be called by the USB function driver to continue
+ * with the control transfer's data/status stage in case it had requested to
+ * delay the data/status stages. A USB function's setup handler (e.g. set_alt())
+ * can request the composite framework to delay the setup request's data/status
+ * stages by returning USB_GADGET_DELAYED_STATUS.
+ */
+void usb_composite_setup_continue(struct usb_composite_dev *cdev)
+{
+	int			value;
+	struct usb_request	*req = cdev->req;
+	unsigned long		flags;
+
+	DBG(cdev, "%s\n", __func__);
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->delayed_status == 0) {
+		WARN(cdev, "%s: Unexpected call\n", __func__);
+
+	} else if (--cdev->delayed_status == 0) {
+		DBG(cdev, "%s: Completing delayed status\n", __func__);
+		req->length = 0;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0) {
+			DBG(cdev, "ep_queue --> %d\n", value);
+			req->status = 0;
+			composite_setup_complete(cdev->gadget->ep0, req);
+		}
+	}
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+}
+

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c2251c40a205..82314ed22506 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -42,7 +42,7 @@
 static struct usb_composite_driver *composite;
 static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
 
-/* Some systems will need runtime overrides for the  product identifers
+/* Some systems will need runtime overrides for the  product identifiers
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
@@ -205,14 +205,14 @@ int usb_function_activate(struct usb_function *function)
  * usb_interface_id() is called from usb_function.bind() callbacks to
  * allocate new interface IDs.  The function driver will then store that
  * ID in interface, association, CDC union, and other descriptors.  It
- * will also handle any control requests targetted at that interface,
+ * will also handle any control requests targeted at that interface,
  * particularly changing its altsetting via set_alt().  There may
  * also be class-specific or vendor-specific requests to handle.
  *
  * All interface identifier should be allocated using this routine, to
  * ensure that for example different functions don't wrongly assign
  * different meanings to the same identifier.  Note that since interface
- * identifers are configuration-specific, functions used in more than
+ * identifiers are configuration-specific, functions used in more than
  * one configuration (or more than once in a given configuration) need
  * multiple versions of the relevant descriptors.
  *

commit 2edb11cbac95231f66f1239b3ca26bdc0967183a
Author: Maulik Mankad <maulik@ti.com>
Date:   Tue Feb 22 19:08:42 2011 +0530

    usb: gadget: composite: fix req->length in composite_setup()
    
    When USB CV MSC tests are run on f_mass_storage gadget
    Bulk Only Mass Storage Reset fails since req->length
    is set to USB_BUFSIZ=1024 in composite_setup().
    
    Initialize req->length to zero to fix this.
    
    Signed-off-by: Maulik Mankad <maulik@ti.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 53e0496c71b5..c2251c40a205 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -813,7 +813,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	 */
 	req->zero = 0;
 	req->complete = composite_setup_complete;
-	req->length = USB_BUFSIZ;
+	req->length = 0;
 	gadget->ep0->driver_data = cdev;
 
 	switch (ctrl->bRequest) {

commit 05c3eebd50ad831c462ec264f82a87654d0ee974
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Sun Feb 6 18:47:18 2011 +0900

    USB: Gadget: Reorder driver name assignment
    
    Reorder the driver->name assignment so the 'iProduct' could be initialized
    as well if both 'name' and 'iProduct' come as NULL by default.
    
    Also, remove the misplaced 'extern' keyword.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index bbbbfb707504..53e0496c71b5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1258,16 +1258,16 @@ static struct usb_gadget_driver composite_driver = {
  * while it was binding.  That would usually be done in order to wait for
  * some userspace participation.
  */
-extern int usb_composite_probe(struct usb_composite_driver *driver,
+int usb_composite_probe(struct usb_composite_driver *driver,
 			       int (*bind)(struct usb_composite_dev *cdev))
 {
 	if (!driver || !driver->dev || !bind || composite)
 		return -EINVAL;
 
-	if (!driver->iProduct)
-		driver->iProduct = driver->name;
 	if (!driver->name)
 		driver->name = "composite";
+	if (!driver->iProduct)
+		driver->iProduct = driver->name;
 	composite_driver.function =  (char *) driver->name;
 	composite_driver.driver.name = driver->name;
 	composite = driver;

commit ff085de758ebcb2309dd013fecb7cbb3cb6c7a43
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Sun Feb 6 17:39:17 2011 +0900

    USB: Gadget: Composite: Debug interface comparison
    
    While checking valid interface number we should compare MAX_CONFIG_INTERFACES
    with the variable 'intf' (which holds the lower 8bits of w_index) rather than
    'w_index'
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1ba4befe336b..bbbbfb707504 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -887,7 +887,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	case USB_REQ_SET_INTERFACE:
 		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
 			goto unknown;
-		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
 			break;
 		f = cdev->config->interface[intf];
 		if (!f)
@@ -899,7 +899,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	case USB_REQ_GET_INTERFACE:
 		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
 			goto unknown;
-		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
 			break;
 		f = cdev->config->interface[intf];
 		if (!f)
@@ -928,7 +928,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 */
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
-			if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
 				break;
 			f = cdev->config->interface[intf];
 			break;

commit 3c47eb06f08eb970ea9d696bcdb57a175d37b470
Author: Maulik Mankad <maulik@ti.com>
Date:   Thu Jan 13 18:19:56 2011 +0530

    usb: gadget: composite: avoid access beyond array max length
    
    One of the USB CV MSC tests issues Get Max LUN request with
    invalid wIndex (wIndex = 65535) parameter.
    
    Add proper handling to prevent array index out of bounds issue.
    
    Signed-off-by: Maulik Mankad <maulik@ti.com>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f6ff8456d52d..1ba4befe336b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -928,8 +928,9 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 */
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
-			if (cdev->config)
-				f = cdev->config->interface[intf];
+			if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+				break;
+			f = cdev->config->interface[intf];
 			break;
 
 		case USB_RECIP_ENDPOINT:

commit 2af10844eb6ed104f9505bf3a7ba3ceb02264f31
Merge: 73bc7d315f56 90a8a73c06cc
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Dec 22 12:25:34 2010 -0800

    USB: Merge 2.6.37-rc5 into usb-next
    
    This is to resolve the conflict in the file,
    drivers/usb/gadget/composite.c that was due to a revert in Linus's tree
    needed for the 2.6.37 release.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit dbb442b85a1d82f91cfe0524c4f9b3a5196a10ca
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 16 15:52:30 2010 -0800

    Revert "USB: gadget: Allow function access to device ID data during bind()"
    
    This reverts commit 1ab83238740ff1e1773d5c13ecac43c60cf4aec4.
    
    Turns out this doesn't allow for the device ids to be overridden
    properly, so we need to revert the thing.
    
    Reported-by: Jef Driesen <jefdriesen@telenet.be>
    Cc: Robert Lukassen <Robert.Lukassen@tomtom.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 96413a240fdf..8572dad5ecbb 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1107,14 +1107,6 @@ static int composite_bind(struct usb_gadget *gadget)
 	 */
 	usb_ep_autoconfig_reset(cdev->gadget);
 
-	/* standardized runtime overrides for device ID data */
-	if (idVendor)
-		cdev->desc.idVendor = cpu_to_le16(idVendor);
-	if (idProduct)
-		cdev->desc.idProduct = cpu_to_le16(idProduct);
-	if (bcdDevice)
-		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
-
 	/* composite gadget needs to assign strings for whole device (like
 	 * serial number), register function drivers, potentially update
 	 * power state and consumption, etc
@@ -1126,6 +1118,14 @@ static int composite_bind(struct usb_gadget *gadget)
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
+	/* standardized runtime overrides for device ID data */
+	if (idVendor)
+		cdev->desc.idVendor = cpu_to_le16(idVendor);
+	if (idProduct)
+		cdev->desc.idProduct = cpu_to_le16(idProduct);
+	if (bcdDevice)
+		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+
 	/* stirng overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {
 		if (!iManufacturer && !composite->iManufacturer &&

commit daba58035a044cae75488175a96cc18362a64518
Author: Pavankumar Kondeti <pkondeti@codeaurora.org>
Date:   Thu Dec 16 14:32:25 2010 +0530

    USB: gadget: Remove suspended sysfs file before freeing cdev
    
    cdev struct is accessed in suspended sysfs show function.  So
    remove sysfs file before freeing the cdev in composite_unbind.
    
    Signed-off-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 7b5cc16e4a0b..96413a240fdf 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1047,9 +1047,9 @@ composite_unbind(struct usb_gadget *gadget)
 		kfree(cdev->req->buf);
 		usb_ep_free_request(gadget->ep0, cdev->req);
 	}
+	device_remove_file(&gadget->dev, &dev_attr_suspended);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
-	device_remove_file(&gadget->dev, &dev_attr_suspended);
 	composite = NULL;
 }
 

commit b23f2f94136884ebeb1b5e2196f4a53086444afa
Author: Hao Wu <hao.wu@intel.com>
Date:   Mon Nov 29 15:17:03 2010 +0800

    usb: composite gadget: set vbus_draw current limitation during suspend
    
    This patch modifies the composite gadget to set vbus_draw current limitation
    during suspend state. This current limitation in suspend state shouldn't be
    more than 2.5mA
    
    Signed-off-by: Hao Wu <hao.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d3493fede64a..21dc0da36ab7 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1188,6 +1188,8 @@ composite_suspend(struct usb_gadget *gadget)
 		composite->suspend(cdev);
 
 	cdev->suspended = 1;
+
+	usb_gadget_vbus_draw(gadget, 2);
 }
 
 static void
@@ -1195,6 +1197,7 @@ composite_resume(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
+	u8				maxpower;
 
 	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?
@@ -1207,6 +1210,11 @@ composite_resume(struct usb_gadget *gadget)
 			if (f->resume)
 				f->resume(f);
 		}
+
+		maxpower = cdev->config->bMaxPower;
+
+		usb_gadget_vbus_draw(gadget, maxpower ?
+			(2 * maxpower) : CONFIG_USB_GADGET_VBUS_DRAW);
 	}
 
 	cdev->suspended = 0;

commit 78bff3c65df33da47e93736bd8847b694084e5a9
Author: Marek Belisko <marek.belisko@gmail.com>
Date:   Wed Oct 27 10:19:01 2010 +0200

    USB: gadget: composite: Typo fix.
    
    Signed-off-by: Marek Belisko <marek.belisko@gmail.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 7b5cc16e4a0b..d3493fede64a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1126,7 +1126,7 @@ static int composite_bind(struct usb_gadget *gadget)
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
-	/* stirng overrides */
+	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {
 		if (!iManufacturer && !composite->iManufacturer &&
 		    !*composite_manufacturer)

commit 5c836e4d583701a5eecb288b5f131da39115f5ec
Author: Roger Quadros <roger.quadros@nokia.com>
Date:   Wed Sep 8 13:48:44 2010 +0300

    usb gadget: composite: prevent OOPS for non-standard control request
    
    The composite gadget will OOPS if the host sends a control request
    targetted to an interface of an un-configured composite device. This patch
    prevents this.
    
    The OOPS was observed during WHQL USB CV tests. With this patch, the device
    STALLs as per requirement.
    
    Failing test case: From host do the following. I used libusb-1.0
    
    1) Set configuration to zero.
            libusb_control_transfer(device_handle,
                    0, /* standard OUT */
                    0x9, /* setConfiguration */
                    0, 0, NULL, 0, 0);
    
    2) Query current configuratioan.
            libusb_control_transfer(device_handle,
                    0x80, /* standard IN*/
                    0x8, /* getConfiguration */
                    0, 0, data, 1, 0);
    
    3) Send the non-standard ctrl transfer targetted to interface
            libusb_control_transfer(device_handle,
                    0x81, /* standard IN to interface*/
                    0x6, /* getDescriptor */
                    0x2300, 0, data, 0x12, 0);
    
    Signed-off-by: Roger Quadros <roger.quadros@nokia.com>
    Cc: stable <stable@kernel.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Robert Lukassen <robert.lukassen@tomtom.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5e2bd7428424..7b5cc16e4a0b 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -928,7 +928,8 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 */
 		switch (ctrl->bRequestType & USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
-			f = cdev->config->interface[intf];
+			if (cdev->config)
+				f = cdev->config->interface[intf];
 			break;
 
 		case USB_RECIP_ENDPOINT:

commit c9bfff9c98671ad50e4abbfe1ab606a9957f7539
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Thu Aug 12 17:43:55 2010 +0200

    usb gadget: don't save bind callback in struct usb_configuration
    
    The bind function is most of the time only called at init time so there
    is no need to save a pointer to it in the configuration structure.
    
    This fixes many section mismatches reported by modpost.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    [m.nazarewicz@samsung.com: updated for -next]
    Signed-off-by: Micha Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c531a7e05f1e..5e2bd7428424 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -474,18 +474,20 @@ static int set_config(struct usb_composite_dev *cdev,
  * usb_add_config() - add a configuration to a device.
  * @cdev: wraps the USB gadget
  * @config: the configuration, with bConfigurationValue assigned
+ * @bind: the configuration's bind function
  * Context: single threaded during gadget setup
  *
- * One of the main tasks of a composite driver's bind() routine is to
+ * One of the main tasks of a composite @bind() routine is to
  * add each of the configurations it supports, using this routine.
  *
- * This function returns the value of the configuration's bind(), which
+ * This function returns the value of the configuration's @bind(), which
  * is zero for success else a negative errno value.  Binding configurations
  * assigns global resources including string IDs, and per-configuration
  * resources such as interface IDs and endpoints.
  */
 int usb_add_config(struct usb_composite_dev *cdev,
-		struct usb_configuration *config)
+		struct usb_configuration *config,
+		int (*bind)(struct usb_configuration *))
 {
 	int				status = -EINVAL;
 	struct usb_configuration	*c;
@@ -494,7 +496,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 			config->bConfigurationValue,
 			config->label, config);
 
-	if (!config->bConfigurationValue || !config->bind)
+	if (!config->bConfigurationValue || !bind)
 		goto done;
 
 	/* Prevent duplicate configuration identifiers */
@@ -511,7 +513,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 	INIT_LIST_HEAD(&config->functions);
 	config->next_interface_id = 0;
 
-	status = config->bind(config);
+	status = bind(config);
 	if (status < 0) {
 		list_del(&config->list);
 		config->cdev = NULL;
@@ -537,7 +539,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 		}
 	}
 
-	/* set_alt(), or next config->bind(), sets up
+	/* set_alt(), or next bind(), sets up
 	 * ep->driver_data as needed.
 	 */
 	usb_ep_autoconfig_reset(cdev->gadget);

commit 07a18bd716ed5dea336429404b132568cfaaef95
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Thu Aug 12 17:43:54 2010 +0200

    usb gadget: don't save bind callback in struct usb_composite_driver
    
    The bind function is most of the time only called at init time so there
    is no need to save a pointer to it in the composite driver structure.
    
    This fixes many section mismatches reported by modpost.
    
    Signed-off-by: Micha Nazarewicz <m.nazarewicz@samsung.com>
    Acked-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index a3009bf01229..c531a7e05f1e 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -40,6 +40,7 @@
 #define USB_BUFSIZ	1024
 
 static struct usb_composite_driver *composite;
+static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
 
 /* Some systems will need runtime overrides for the  product identifers
  * published in the device descriptor, either numbers or strings or both.
@@ -1115,7 +1116,7 @@ static int composite_bind(struct usb_gadget *gadget)
 	 * serial number), register function drivers, potentially update
 	 * power state and consumption, etc
 	 */
-	status = composite->bind(cdev);
+	status = composite_gadget_bind(cdev);
 	if (status < 0)
 		goto fail;
 
@@ -1227,8 +1228,12 @@ static struct usb_gadget_driver composite_driver = {
 };
 
 /**
- * usb_composite_register() - register a composite driver
+ * usb_composite_probe() - register a composite driver
  * @driver: the driver to register
+ * @bind: the callback used to allocate resources that are shared across the
+ *	whole device, such as string IDs, and add its configurations using
+ *	@usb_add_config().  This may fail by returning a negative errno
+ *	value; it should return zero on successful initialization.
  * Context: single threaded during gadget setup
  *
  * This function is used to register drivers using the composite driver
@@ -1241,9 +1246,10 @@ static struct usb_gadget_driver composite_driver = {
  * while it was binding.  That would usually be done in order to wait for
  * some userspace participation.
  */
-int usb_composite_register(struct usb_composite_driver *driver)
+extern int usb_composite_probe(struct usb_composite_driver *driver,
+			       int (*bind)(struct usb_composite_dev *cdev))
 {
-	if (!driver || !driver->dev || !driver->bind || composite)
+	if (!driver || !driver->dev || !bind || composite)
 		return -EINVAL;
 
 	if (!driver->iProduct)
@@ -1253,6 +1259,7 @@ int usb_composite_register(struct usb_composite_driver *driver)
 	composite_driver.function =  (char *) driver->name;
 	composite_driver.driver.name = driver->name;
 	composite = driver;
+	composite_gadget_bind = bind;
 
 	return usb_gadget_probe_driver(&composite_driver, composite_bind);
 }

commit b0fca50f5a94a268ed02cfddf44448051ed9343f
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Thu Aug 12 17:43:53 2010 +0200

    usb gadget: don't save bind callback in struct usb_gadget_driver
    
    To accomplish this the function to register a gadget driver takes the bind
    function as a second argument.  To make things clearer rename the function
    to resemble platform_driver_probe.
    
    This fixes many section mismatches like
    
            WARNING: drivers/usb/gadget/g_printer.o(.data+0xc): Section mismatch in
            reference from the variable printer_driver to the function
            .init.text:printer_bind()
            The variable printer_driver references
            the function __init printer_bind()
    
    All callers are fixed.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    [m.nazarewicz@samsung.com: added dbgp]
    Signed-off-by: Micha Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 717de39627c7..a3009bf01229 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1213,7 +1213,6 @@ composite_resume(struct usb_gadget *gadget)
 static struct usb_gadget_driver composite_driver = {
 	.speed		= USB_SPEED_HIGH,
 
-	.bind		= composite_bind,
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
@@ -1255,7 +1254,7 @@ int usb_composite_register(struct usb_composite_driver *driver)
 	composite_driver.driver.name = driver->name;
 	composite = driver;
 
-	return usb_gadget_register_driver(&composite_driver);
+	return usb_gadget_probe_driver(&composite_driver, composite_bind);
 }
 
 /**

commit ad1a8102f957f4d25fc58cdc10736c5ade7557e1
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Thu Aug 12 17:43:46 2010 +0200

    USB: gadget: composite: Better string override handling
    
    The iManufatcurer, iProduct and iSerialNumber composite module
    parameters were only used when the gadget driver registers
    strings for manufacturer, product and serial number.  If the
    gadget never bothered to set corresponding fields in USB device
    descriptors those module parameters are ignored.
    
    This commit makes the parameters work even if the strings ID
    have not been assigned.  It also changes the way IDs are
    overridden -- what IDs are overridden is now saved in
    usb_composite_dev structure -- which makes it unnecessary to
    modify the string tables the way previous code did.
    
    The commit also adds a iProduct and iManufatcurer fields to the
    usb_composite_device structure.  If they are set, appropriate
    strings are reserved and added to device descriptor.  This makes
    it unnecessary for gadget drivers to maintain code for setting
    those.  If iProduct is not set it defaults to
    usb_composite_device::name; if iManufatcurer is not set
    a default "<system> <release> with <gadget-name>" is used.
    
    The last thing is that if needs_serial field of
    usb_composite_device is set and user failed to provided
    iSerialNumber parameter a warning is issued.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index eaa9a599df63..717de39627c7 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/utsname.h>
 
 #include <linux/usb/composite.h>
 
@@ -69,6 +70,8 @@ static char *iSerialNumber;
 module_param(iSerialNumber, charp, 0);
 MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
+static char composite_manufacturer[50];
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -599,6 +602,7 @@ static int get_string(struct usb_composite_dev *cdev,
 	struct usb_configuration	*c;
 	struct usb_function		*f;
 	int				len;
+	const char			*str;
 
 	/* Yes, not only is USB's I18N support probably more than most
 	 * folk will ever care about ... also, it's all supported here.
@@ -638,9 +642,29 @@ static int get_string(struct usb_composite_dev *cdev,
 		return s->bLength;
 	}
 
-	/* Otherwise, look up and return a specified string.  String IDs
-	 * are device-scoped, so we look up each string table we're told
-	 * about.  These lookups are infrequent; simpler-is-better here.
+	/* Otherwise, look up and return a specified string.  First
+	 * check if the string has not been overridden.
+	 */
+	if (cdev->manufacturer_override == id)
+		str = iManufacturer ?: composite->iManufacturer ?:
+			composite_manufacturer;
+	else if (cdev->product_override == id)
+		str = iProduct ?: composite->iProduct;
+	else if (cdev->serial_override == id)
+		str = iSerialNumber;
+	else
+		str = NULL;
+	if (str) {
+		struct usb_gadget_strings strings = {
+			.language = language,
+			.strings  = &(struct usb_string) { 0xff, str }
+		};
+		return usb_gadget_get_string(&strings, 0xff, buf);
+	}
+
+	/* String IDs are device-scoped, so we look up each string
+	 * table we're told about.  These lookups are infrequent;
+	 * simpler-is-better here.
 	 */
 	if (composite->strings) {
 		len = lookup_string(composite->strings, buf, language, id);
@@ -1025,26 +1049,17 @@ composite_unbind(struct usb_gadget *gadget)
 	composite = NULL;
 }
 
-static void
-string_override_one(struct usb_gadget_strings *tab, u8 id, const char *s)
+static u8 override_id(struct usb_composite_dev *cdev, u8 *desc)
 {
-	struct usb_string		*str = tab->strings;
-
-	for (str = tab->strings; str->s; str++) {
-		if (str->id == id) {
-			str->s = s;
-			return;
-		}
+	if (!*desc) {
+		int ret = usb_string_id(cdev);
+		if (unlikely(ret < 0))
+			WARNING(cdev, "failed to override string ID\n");
+		else
+			*desc = ret;
 	}
-}
 
-static void
-string_override(struct usb_gadget_strings **tab, u8 id, const char *s)
-{
-	while (*tab) {
-		string_override_one(*tab, id, s);
-		tab++;
-	}
+	return *desc;
 }
 
 static int composite_bind(struct usb_gadget *gadget)
@@ -1107,19 +1122,34 @@ static int composite_bind(struct usb_gadget *gadget)
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
-	/* strings can't be assigned before bind() allocates the
-	 * releavnt identifiers
-	 */
-	if (cdev->desc.iManufacturer && iManufacturer)
-		string_override(composite->strings,
-			cdev->desc.iManufacturer, iManufacturer);
-	if (cdev->desc.iProduct && iProduct)
-		string_override(composite->strings,
-			cdev->desc.iProduct, iProduct);
-	if (cdev->desc.iSerialNumber && iSerialNumber)
-		string_override(composite->strings,
-			cdev->desc.iSerialNumber, iSerialNumber);
+	/* stirng overrides */
+	if (iManufacturer || !cdev->desc.iManufacturer) {
+		if (!iManufacturer && !composite->iManufacturer &&
+		    !*composite_manufacturer)
+			snprintf(composite_manufacturer,
+				 sizeof composite_manufacturer,
+				 "%s %s with %s",
+				 init_utsname()->sysname,
+				 init_utsname()->release,
+				 gadget->name);
+
+		cdev->manufacturer_override =
+			override_id(cdev, &cdev->desc.iManufacturer);
+	}
+
+	if (iProduct || (!cdev->desc.iProduct && composite->iProduct))
+		cdev->product_override =
+			override_id(cdev, &cdev->desc.iProduct);
+
+	if (iSerialNumber)
+		cdev->serial_override =
+			override_id(cdev, &cdev->desc.iSerialNumber);
+
+	/* has userspace failed to provide a serial number? */
+	if (composite->needs_serial && !cdev->desc.iSerialNumber)
+		WARNING(cdev, "userspace failed to provide iSerialNumber\n");
 
+	/* finish up */
 	status = device_create_file(&gadget->dev, &dev_attr_suspended);
 	if (status)
 		goto fail;
@@ -1217,6 +1247,8 @@ int usb_composite_register(struct usb_composite_driver *driver)
 	if (!driver || !driver->dev || !driver->bind || composite)
 		return -EINVAL;
 
+	if (!driver->iProduct)
+		driver->iProduct = driver->name;
 	if (!driver->name)
 		driver->name = "composite";
 	composite_driver.function =  (char *) driver->name;

commit 37b5801e16d2e192fe2b20f4af33aa8c6e8786f3
Author: Parirajan Muthalagu <parirajan.muthalagu@stericsson.com>
Date:   Wed Aug 25 16:33:26 2010 +0530

    USB Gadget: Verify VBUS current before setting the device self-powered bit
    
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Praveena Nadahally <praveen.nadahally@stericsson.com>
    Signed-off-by: Parirajan Muthalagu <parirajan.muthalagu@stericsson.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1160c55de7f2..eaa9a599df63 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1074,7 +1074,13 @@ static int composite_bind(struct usb_gadget *gadget)
 	cdev->bufsiz = USB_BUFSIZ;
 	cdev->driver = composite;
 
-	usb_gadget_set_selfpowered(gadget);
+	/*
+	 * As per USB compliance update, a device that is actively drawing
+	 * more than 100mA from USB must report itself as bus-powered in
+	 * the GetStatus(DEVICE) call.
+	 */
+	if (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)
+		usb_gadget_set_selfpowered(gadget);
 
 	/* interface and string IDs start at zero via kzalloc.
 	 * we force endpoints to start unassigned; few controller

commit d187abb9a83e6c6b6e9f2ca17962bdeafb4bc903
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Aug 11 12:07:13 2010 -0700

    USB: gadget: fix composite kernel-doc warnings
    
    Warning(include/linux/usb/composite.h:284): No description found for parameter 'disconnect'
    Warning(drivers/usb/gadget/composite.c:744): No description found for parameter 'c'
    Warning(drivers/usb/gadget/composite.c:744): Excess function parameter 'cdev' description in 'usb_string_ids_n'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index e483f80822d2..1160c55de7f2 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -723,12 +723,12 @@ int usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)
 
 /**
  * usb_string_ids_n() - allocate unused string IDs in batch
- * @cdev: the device whose string descriptor IDs are being allocated
+ * @c: the device whose string descriptor IDs are being allocated
  * @n: number of string IDs to allocate
  * Context: single threaded during gadget setup
  *
  * Returns the first requested ID.  This ID and next @n-1 IDs are now
- * valid IDs.  At least providind that @n is non zore because if it
+ * valid IDs.  At least provided that @n is non-zero because if it
  * is, returns last requested ID which is now very useful information.
  *
  * @usb_string_ids_n() is called from bind() callbacks to allocate

commit 3f3e12d050052032a51f75e72e540322e2a7da2b
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Mon Jun 21 13:57:08 2010 +0200

    USB: gadget: composite: added disconnect callback
    
    Added a disconnect() callback to composite devices which
    is called by composite glue when its disconnect callback
    is called by gadget.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 125167e17ce5..e483f80822d2 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -956,6 +956,8 @@ static void composite_disconnect(struct usb_gadget *gadget)
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (cdev->config)
 		reset_config(cdev);
+	if (composite->disconnect)
+		composite->disconnect(cdev);
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 

commit f2adc4f8aaf272de9ac71dcb18d95ebe05fc3f94
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Wed Jun 16 12:07:59 2010 +0200

    USB: gadget: composite: usb_string_ids_*() functions added
    
    usb_string_ids_tab() and usb_string_ids_n() functions added to
    the composite framework.  The first accepts an array of
    usb_string object and for each registeres a string id and the
    second registeres a given number of ids and returns the first.
    
    This may simplify string ids registration since gadgets and
    composite functions won't have to call usb_string_id() several
    times and each time check for errer status -- all this will be
    done with a single call.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 391d169f8d07..125167e17ce5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -673,20 +673,83 @@ static int get_string(struct usb_composite_dev *cdev,
  * string IDs.  Drivers for functions, configurations, or gadgets will
  * then store that ID in the appropriate descriptors and string table.
  *
- * All string identifier should be allocated using this routine, to
- * ensure that for example different functions don't wrongly assign
- * different meanings to the same identifier.
+ * All string identifier should be allocated using this,
+ * @usb_string_ids_tab() or @usb_string_ids_n() routine, to ensure
+ * that for example different functions don't wrongly assign different
+ * meanings to the same identifier.
  */
 int usb_string_id(struct usb_composite_dev *cdev)
 {
 	if (cdev->next_string_id < 254) {
-		/* string id 0 is reserved */
+		/* string id 0 is reserved by USB spec for list of
+		 * supported languages */
+		/* 255 reserved as well? -- mina86 */
 		cdev->next_string_id++;
 		return cdev->next_string_id;
 	}
 	return -ENODEV;
 }
 
+/**
+ * usb_string_ids() - allocate unused string IDs in batch
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * @str: an array of usb_string objects to assign numbers to
+ * Context: single threaded during gadget setup
+ *
+ * @usb_string_ids() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then copy IDs from the string table to the appropriate descriptors
+ * and string table for other languages.
+ *
+ * All string identifier should be allocated using this,
+ * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
+ * example different functions don't wrongly assign different meanings
+ * to the same identifier.
+ */
+int usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)
+{
+	int next = cdev->next_string_id;
+
+	for (; str->s; ++str) {
+		if (unlikely(next >= 254))
+			return -ENODEV;
+		str->id = ++next;
+	}
+
+	cdev->next_string_id = next;
+
+	return 0;
+}
+
+/**
+ * usb_string_ids_n() - allocate unused string IDs in batch
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * @n: number of string IDs to allocate
+ * Context: single threaded during gadget setup
+ *
+ * Returns the first requested ID.  This ID and next @n-1 IDs are now
+ * valid IDs.  At least providind that @n is non zore because if it
+ * is, returns last requested ID which is now very useful information.
+ *
+ * @usb_string_ids_n() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then store that ID in the appropriate descriptors and string table.
+ *
+ * All string identifier should be allocated using this,
+ * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for
+ * example different functions don't wrongly assign different meanings
+ * to the same identifier.
+ */
+int usb_string_ids_n(struct usb_composite_dev *c, unsigned n)
+{
+	unsigned next = c->next_string_id;
+	if (unlikely(n > 254 || (unsigned)next + n > 254))
+		return -ENODEV;
+	c->next_string_id += n;
+	return next + 1;
+}
+
+
 /*-------------------------------------------------------------------------*/
 
 static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)

commit 1ab83238740ff1e1773d5c13ecac43c60cf4aec4
Author: Robert Lukassen <Robert.Lukassen@tomtom.com>
Date:   Fri May 7 09:19:53 2010 +0200

    USB: gadget: Allow function access to device ID data during bind()
    
    This is a patch that makes sure that the device ID data (idVendor,
    idProduct and bcdDevice) are assigned to the descriptor in the cdev
    structure *before* the composite gadget starts binding. This allows the
    composite driver, and all the composite functions it uses, access to
    that data.
    
    In one of the composite functions we created, we needed to register an
    input device and wanted to use the idVendor, idProduct and bcdDevice
    codes to properly initialize the id field of the input device. We could
    not do that because the idVendor, idProduct and bcdDevice values were
    only set in the cdec structure *after* the composite->bind(cdev) call.
    
    Signed-off-by: Robert Lukassen <robert.lukassen@tomtom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index dd6d1905c148..391d169f8d07 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1017,6 +1017,14 @@ static int composite_bind(struct usb_gadget *gadget)
 	 */
 	usb_ep_autoconfig_reset(cdev->gadget);
 
+	/* standardized runtime overrides for device ID data */
+	if (idVendor)
+		cdev->desc.idVendor = cpu_to_le16(idVendor);
+	if (idProduct)
+		cdev->desc.idProduct = cpu_to_le16(idProduct);
+	if (bcdDevice)
+		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+
 	/* composite gadget needs to assign strings for whole device (like
 	 * serial number), register function drivers, potentially update
 	 * power state and consumption, etc
@@ -1028,14 +1036,6 @@ static int composite_bind(struct usb_gadget *gadget)
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
-	/* standardized runtime overrides for device ID data */
-	if (idVendor)
-		cdev->desc.idVendor = cpu_to_le16(idVendor);
-	if (idProduct)
-		cdev->desc.idProduct = cpu_to_le16(idProduct);
-	if (bcdDevice)
-		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
-
 	/* strings can't be assigned before bind() allocates the
 	 * releavnt identifiers
 	 */

commit 28824b18ac4705e876a282a15ea0de8fc957551f
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Wed May 5 12:53:13 2010 +0200

    USB: gadget: __init and __exit tags removed
    
    __init, __initdata and __exit tags have have been removed from
    various files to make it possible for gadgets that do not use
    the __init/__exit tags to use those.
    
    Files in question are related to:
    * the core composite framework,
    * the mass storage function (fixing a section mismatch) and
    * ethernet driver (ACM, ECM, RNDIS).
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f9aff1bbcb3e..dd6d1905c148 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -85,7 +85,7 @@ MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
  * This function returns the value of the function's bind(), which is
  * zero for success else a negative errno value.
  */
-int __init usb_add_function(struct usb_configuration *config,
+int usb_add_function(struct usb_configuration *config,
 		struct usb_function *function)
 {
 	int	value = -EINVAL;
@@ -215,7 +215,7 @@ int usb_function_activate(struct usb_function *function)
  * Returns the interface ID which was allocated; or -ENODEV if no
  * more interface IDs can be allocated.
  */
-int __init usb_interface_id(struct usb_configuration *config,
+int usb_interface_id(struct usb_configuration *config,
 		struct usb_function *function)
 {
 	unsigned id = config->next_interface_id;
@@ -480,7 +480,7 @@ static int set_config(struct usb_composite_dev *cdev,
  * assigns global resources including string IDs, and per-configuration
  * resources such as interface IDs and endpoints.
  */
-int __init usb_add_config(struct usb_composite_dev *cdev,
+int usb_add_config(struct usb_composite_dev *cdev,
 		struct usb_configuration *config)
 {
 	int				status = -EINVAL;
@@ -677,7 +677,7 @@ static int get_string(struct usb_composite_dev *cdev,
  * ensure that for example different functions don't wrongly assign
  * different meanings to the same identifier.
  */
-int __init usb_string_id(struct usb_composite_dev *cdev)
+int usb_string_id(struct usb_composite_dev *cdev)
 {
 	if (cdev->next_string_id < 254) {
 		/* string id 0 is reserved */
@@ -910,7 +910,7 @@ static ssize_t composite_show_suspended(struct device *dev,
 
 static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
 
-static void /* __init_or_exit */
+static void
 composite_unbind(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
@@ -960,7 +960,7 @@ composite_unbind(struct usb_gadget *gadget)
 	composite = NULL;
 }
 
-static void __init
+static void
 string_override_one(struct usb_gadget_strings *tab, u8 id, const char *s)
 {
 	struct usb_string		*str = tab->strings;
@@ -973,7 +973,7 @@ string_override_one(struct usb_gadget_strings *tab, u8 id, const char *s)
 	}
 }
 
-static void __init
+static void
 string_override(struct usb_gadget_strings **tab, u8 id, const char *s)
 {
 	while (*tab) {
@@ -982,7 +982,7 @@ string_override(struct usb_gadget_strings **tab, u8 id, const char *s)
 	}
 }
 
-static int __init composite_bind(struct usb_gadget *gadget)
+static int composite_bind(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev;
 	int				status = -ENOMEM;
@@ -1113,7 +1113,6 @@ static struct usb_gadget_driver composite_driver = {
 	.speed		= USB_SPEED_HIGH,
 
 	.bind		= composite_bind,
-	/* .unbind		= __exit_p(composite_unbind), */
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
@@ -1142,7 +1141,7 @@ static struct usb_gadget_driver composite_driver = {
  * while it was binding.  That would usually be done in order to wait for
  * some userspace participation.
  */
-int __init usb_composite_register(struct usb_composite_driver *driver)
+int usb_composite_register(struct usb_composite_driver *driver)
 {
 	if (!driver || !driver->dev || !driver->bind || composite)
 		return -EINVAL;
@@ -1163,7 +1162,7 @@ int __init usb_composite_register(struct usb_composite_driver *driver)
  * This function is used to unregister drivers using the composite
  * driver framework.
  */
-void /* __exit */ usb_composite_unregister(struct usb_composite_driver *driver)
+void usb_composite_unregister(struct usb_composite_driver *driver)
 {
 	if (composite != driver)
 		return;

commit f48cf80f93ba974eb3201ab2d0f2c4cef950f3fc
Author: Fabien Chouteau <fabien.chouteau@barco.com>
Date:   Fri Apr 23 14:21:26 2010 +0200

    USB: Composite framework: Add suspended sysfs entry
    
    This patch adds a sysfs entry (/sys/devices/platform/_UDC_/gadget/suspended) to
    show the suspend state of an USB composite gadget.
    
    Signed-off-by: Fabien Chouteau <fabien.chouteau@barco.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5465d8767f9a..f9aff1bbcb3e 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -898,6 +898,18 @@ static void composite_disconnect(struct usb_gadget *gadget)
 
 /*-------------------------------------------------------------------------*/
 
+static ssize_t composite_show_suspended(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+
+	return sprintf(buf, "%d\n", cdev->suspended);
+}
+
+static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
+
 static void /* __init_or_exit */
 composite_unbind(struct usb_gadget *gadget)
 {
@@ -944,6 +956,7 @@ composite_unbind(struct usb_gadget *gadget)
 	}
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
+	device_remove_file(&gadget->dev, &dev_attr_suspended);
 	composite = NULL;
 }
 
@@ -1036,6 +1049,10 @@ static int __init composite_bind(struct usb_gadget *gadget)
 		string_override(composite->strings,
 			cdev->desc.iSerialNumber, iSerialNumber);
 
+	status = device_create_file(&gadget->dev, &dev_attr_suspended);
+	if (status)
+		goto fail;
+
 	INFO(cdev, "%s ready\n", composite->name);
 	return 0;
 
@@ -1064,6 +1081,8 @@ composite_suspend(struct usb_gadget *gadget)
 	}
 	if (composite->suspend)
 		composite->suspend(cdev);
+
+	cdev->suspended = 1;
 }
 
 static void
@@ -1084,6 +1103,8 @@ composite_resume(struct usb_gadget *gadget)
 				f->resume(f);
 		}
 	}
+
+	cdev->suspended = 0;
 }
 
 /*-------------------------------------------------------------------------*/

commit dd0543ecc638947d67bdd3a8a41b95ed3c7b885e
Author: Robert Lukassen <Robert.Lukassen@tomtom.com>
Date:   Tue Mar 30 14:14:01 2010 +0200

    usb: gadget: Allow larger configuration descriptors
    
    The composite framework allows gadgets with more than one function. This
    can lead to situations where the configuration descriptor is larger than
    the maximum of 512 bytes currently allowed by the composite framework.
    This patch proposes to double that limit to 1024.
    
    Signed-off-by: Robert Lukassen <robert.lukassen@tomtom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 09289bb1e20f..5465d8767f9a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -36,7 +36,7 @@
  */
 
 /* big enough to hold our biggest descriptor */
-#define USB_BUFSIZ	512
+#define USB_BUFSIZ	1024
 
 static struct usb_composite_driver *composite;
 

commit 915c8befccbe5d81d441b53ab7a9a98caf0c67d4
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Mon Nov 9 14:15:25 2009 +0100

    USB: composite: usb_composite_unregister() no longer __exit
    
    Changed definition of usb_composite_unregister() function
    removing __exit declaration.  This way, the function is
    included even if the whole code was not compiled as module.
    This is required if a compiled-in code would like to
    unregister a composite gadget.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 8498f1a114d5..09289bb1e20f 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1092,7 +1092,8 @@ static struct usb_gadget_driver composite_driver = {
 	.speed		= USB_SPEED_HIGH,
 
 	.bind		= composite_bind,
-	.unbind		= __exit_p(composite_unbind),
+	/* .unbind		= __exit_p(composite_unbind), */
+	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
 	.disconnect	= composite_disconnect,
@@ -1141,7 +1142,7 @@ int __init usb_composite_register(struct usb_composite_driver *driver)
  * This function is used to unregister drivers using the composite
  * driver framework.
  */
-void __exit usb_composite_unregister(struct usb_composite_driver *driver)
+void /* __exit */ usb_composite_unregister(struct usb_composite_driver *driver)
 {
 	if (composite != driver)
 		return;

commit 5242658d1b97771d658991cf29be32bcf81d5859
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Oct 21 00:03:38 2009 +0200

    USB gadget: Handle endpoint requests at the function level
    
    Control requests targeted at an endpoint (that is sent to EP0 but
    specifying the target endpoint address in wIndex) are dispatched to the
    current configuration's setup callback, requiring all gadget drivers to
    dispatch the requests to the correct function driver.
    
    To avoid this, record which endpoints are used by each function in the
    composite driver SET CONFIGURATION handler and dispatch requests
    targeted at endpoints to the correct function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index d05397ec8a18..8498f1a114d5 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -373,6 +373,8 @@ static void reset_config(struct usb_composite_dev *cdev)
 	list_for_each_entry(f, &cdev->config->functions, list) {
 		if (f->disable)
 			f->disable(f);
+
+		bitmap_zero(f->endpoints, 32);
 	}
 	cdev->config = NULL;
 }
@@ -418,10 +420,35 @@ static int set_config(struct usb_composite_dev *cdev,
 	/* Initialize all interfaces by setting them to altsetting zero. */
 	for (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {
 		struct usb_function	*f = c->interface[tmp];
+		struct usb_descriptor_header **descriptors;
 
 		if (!f)
 			break;
 
+		/*
+		 * Record which endpoints are used by the function. This is used
+		 * to dispatch control requests targeted at that endpoint to the
+		 * function's setup callback instead of the current
+		 * configuration's setup callback.
+		 */
+		if (gadget->speed == USB_SPEED_HIGH)
+			descriptors = f->hs_descriptors;
+		else
+			descriptors = f->descriptors;
+
+		for (; *descriptors; ++descriptors) {
+			struct usb_endpoint_descriptor *ep;
+			int addr;
+
+			if ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)
+				continue;
+
+			ep = (struct usb_endpoint_descriptor *)*descriptors;
+			addr = ((ep->bEndpointAddress & 0x80) >> 3)
+			     |  (ep->bEndpointAddress & 0x0f);
+			set_bit(addr, f->endpoints);
+		}
+
 		result = f->set_alt(f, tmp, 0);
 		if (result < 0) {
 			DBG(cdev, "interface %d (%s/%p) alt 0 --> %d\n",
@@ -688,6 +715,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	u16				w_value = le16_to_cpu(ctrl->wValue);
 	u16				w_length = le16_to_cpu(ctrl->wLength);
 	struct usb_function		*f = NULL;
+	u8				endp;
 
 	/* partial re-init of the response message; the function or the
 	 * gadget might need to intercept e.g. a control-OUT completion
@@ -800,23 +828,33 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
 
-		/* functions always handle their interfaces ... punt other
-		 * recipients (endpoint, other, WUSB, ...) to the current
+		/* functions always handle their interfaces and endpoints...
+		 * punt other recipients (other, WUSB, ...) to the current
 		 * configuration code.
 		 *
 		 * REVISIT it could make sense to let the composite device
 		 * take such requests too, if that's ever needed:  to work
 		 * in config 0, etc.
 		 */
-		if ((ctrl->bRequestType & USB_RECIP_MASK)
-				== USB_RECIP_INTERFACE) {
+		switch (ctrl->bRequestType & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
 			f = cdev->config->interface[intf];
-			if (f && f->setup)
-				value = f->setup(f, ctrl);
-			else
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			endp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);
+			list_for_each_entry(f, &cdev->config->functions, list) {
+				if (test_bit(endp, f->endpoints))
+					break;
+			}
+			if (&f->list == &cdev->config->functions)
 				f = NULL;
+			break;
 		}
-		if (value < 0 && !f) {
+
+		if (f && f->setup)
+			value = f->setup(f, ctrl);
+		else {
 			struct usb_configuration	*c;
 
 			c = cdev->config;

commit 417b57b3e4e34df07a2aceaf75baffeacdd9385f
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu Aug 6 16:09:51 2009 -0700

    USB: gadget: Read buffer overflow
    
    Check whether index is within bounds before testing the element.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 59e85234fa0a..d05397ec8a18 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -602,7 +602,7 @@ static int get_string(struct usb_composite_dev *cdev,
 			}
 		}
 
-		for (len = 0; s->wData[len] && len <= 126; len++)
+		for (len = 0; len <= 126 && s->wData[len]; len++)
 			continue;
 		if (!len)
 			return -EINVAL;

commit 8942939a6c83f34615de5ae041cc9ca846923f94
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Mar 19 14:14:17 2009 -0700

    USB: gadget: composite device-level suspend/resume hooks
    
    Address one open question in the composite gadget framework:
    Yes, we should have device-level suspend/resume callbacks
    in addition to the function-level ones.  We have at least one
    scenario (with gadget zero in OTG test mode) that's awkward
    to handle without it.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 40f1da77a006..59e85234fa0a 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1014,7 +1014,7 @@ composite_suspend(struct usb_gadget *gadget)
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
 
-	/* REVISIT:  should we have config and device level
+	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?
 	 */
 	DBG(cdev, "suspend\n");
@@ -1024,6 +1024,8 @@ composite_suspend(struct usb_gadget *gadget)
 				f->suspend(f);
 		}
 	}
+	if (composite->suspend)
+		composite->suspend(cdev);
 }
 
 static void
@@ -1032,10 +1034,12 @@ composite_resume(struct usb_gadget *gadget)
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
 
-	/* REVISIT:  should we have config and device level
+	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?
 	 */
 	DBG(cdev, "resume\n");
+	if (composite->resume)
+		composite->resume(cdev);
 	if (cdev->config) {
 		list_for_each_entry(f, &cdev->config->functions, list) {
 			if (f->resume)

commit b2bdf3a789162aa6ff9c6f139bee9cc7954bc5b4
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Feb 12 15:09:47 2009 +0200

    USB: composite: avoid inconsistent lock state
    
    Avoid the following INFO from lock debugging:
    
    [  369.126112] =================================
    [  369.132063] [ INFO: inconsistent lock state ]
    [  369.136457] 2.6.28-maemo1 #1
    [  369.139387] ---------------------------------
    [  369.143782] inconsistent {hardirq-on-W} -> {in-hardirq-W} usage.
    [  369.149855] swapper/0 [HC1[1]:SC0[0]:HE0:SE1] takes:
    [  369.154890]  (&cdev->lock){+-..}, at: [<bf1979f0>] composite_disconnect+0x1c/0]
    [  369.163404] {hardirq-on-W} state was registered at:
    [  369.168348]   [<c00788a8>] __lock_acquire+0x5d0/0x7d8
    [  369.173506]   [<c0078b14>] lock_acquire+0x64/0x78
    [  369.178266]   [<c0263a34>] _spin_lock+0x4c/0x80
    [  369.182905]   [<bf19597c>] usb_function_deactivate+0x20/0x70 [g_nokia]
    [  369.189527]   [<bf1a0a88>] 0xbf1a0a88
    [  369.193281]   [<bf19f450>] 0xbf19f450
    [  369.197004]   [<bf19fa3c>] 0xbf19fa3c
    [  369.200758]   [<bf1a03a0>] 0xbf1a03a0
    [  369.204481]   [<bf19f254>] 0xbf19f254
    [  369.208204]   [<bf1a0158>] 0xbf1a0158
    [  369.211927]   [<bf1a130c>] 0xbf1a130c
    [  369.215650]   [<c01c21f0>] usb_gadget_register_driver+0x12c/0x28c
    [  369.221846]   [<bf1a06bc>] 0xbf1a06bc
    [  369.225569]   [<bf1a06e8>] 0xbf1a06e8
    [  369.229322]   [<c002c2dc>] __exception_text_end+0x64/0x19c
    [  369.234877]   [<c0081628>] sys_init_module+0x9c/0x194
    [  369.240004]   [<c002c8e0>] ret_fast_syscall+0x0/0x2c
    [  369.245039]   [<ffffffff>] 0xffffffff
    [  369.248793] irq event stamp: 218356
    [  369.252302] hardirqs last  enabled at (218355): [<c003a77c>] omap3_enter_idle+8
    [  369.260420] hardirqs last disabled at (218356): [<c0264774>] __irq_svc+0x34/0x0
    [  369.267927] softirqs last  enabled at (218348): [<c00585a4>] __do_softirq+0x134
    [  369.275892] softirqs last disabled at (218335): [<c005899c>] irq_exit+0x60/0xb0
    [  369.283308]
    [  369.283308] other info that might help us debug this:
    [  369.289930] no locks held by swapper/0.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 5d11c291f1ad..40f1da77a006 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -149,16 +149,17 @@ int __init usb_add_function(struct usb_configuration *config,
 int usb_function_deactivate(struct usb_function *function)
 {
 	struct usb_composite_dev	*cdev = function->config->cdev;
+	unsigned long			flags;
 	int				status = 0;
 
-	spin_lock(&cdev->lock);
+	spin_lock_irqsave(&cdev->lock, flags);
 
 	if (cdev->deactivations == 0)
 		status = usb_gadget_disconnect(cdev->gadget);
 	if (status == 0)
 		cdev->deactivations++;
 
-	spin_unlock(&cdev->lock);
+	spin_unlock_irqrestore(&cdev->lock, flags);
 	return status;
 }
 

commit 08889517b3713926169d79d99782192e86acdc67
Author: Bryan Wu <cooloney@kernel.org>
Date:   Thu Jan 8 00:21:19 2009 +0800

    USB: composite: Fix bug: low byte of w_index is the usb interface number not the whole 2 bytes of w_index
    
    In some usb gadget driver, for example usb audio class device, the high
    byte of w_index is the entity id and low byte is the interface number.
    If we use the 2 bytes of w_index as the array number, we will get a
    wrong pointer or NULL pointer.
    
    This patch fixes this issue.
    
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 363951eb333c..5d11c291f1ad 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -683,6 +683,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	struct usb_request		*req = cdev->req;
 	int				value = -EOPNOTSUPP;
 	u16				w_index = le16_to_cpu(ctrl->wIndex);
+	u8				intf = w_index & 0xFF;
 	u16				w_value = le16_to_cpu(ctrl->wValue);
 	u16				w_length = le16_to_cpu(ctrl->wLength);
 	struct usb_function		*f = NULL;
@@ -769,7 +770,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			goto unknown;
 		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
 			break;
-		f = cdev->config->interface[w_index];
+		f = cdev->config->interface[intf];
 		if (!f)
 			break;
 		if (w_value && !f->set_alt)
@@ -781,7 +782,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			goto unknown;
 		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
 			break;
-		f = cdev->config->interface[w_index];
+		f = cdev->config->interface[intf];
 		if (!f)
 			break;
 		/* lots of interfaces only need altsetting zero... */
@@ -808,7 +809,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		 */
 		if ((ctrl->bRequestType & USB_RECIP_MASK)
 				== USB_RECIP_INTERFACE) {
-			f = cdev->config->interface[w_index];
+			f = cdev->config->interface[intf];
 			if (f && f->setup)
 				value = f->setup(f, ctrl);
 			else

commit dd4dff8b035f6dda69ece98e20d4c2d76b9f97d1
Author: Bryan Wu <cooloney@kernel.org>
Date:   Thu Jan 8 00:21:18 2009 +0800

    USB: composite: Fix bug: should test set_alt function pointer before use it
    
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f2da0269e1b1..363951eb333c 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -772,7 +772,7 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		f = cdev->config->interface[w_index];
 		if (!f)
 			break;
-		if (w_value && !f->get_alt)
+		if (w_value && !f->set_alt)
 			break;
 		value = f->set_alt(f, w_index, w_value);
 		break;

commit 36e893d25aa2abcae0f11ef263de0e8322641386
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Fri Sep 12 09:39:06 2008 -0700

    usb gadget: USB_GADGET_VBUS_DRAW Kconfig option
    
    Offer a "how much VBUS power to request" configuration option
    for USB gadgets that aren't using board-specific customization
    of their gadget or (composite) configuration drivers.
    
    Also remove a couple pointless "depends on USB_GADGET" bits
    from the Kconfig text; booleans inside an "if USB_GADGET" will
    already have that dependency.
    
    Based on a patch from Justin Clacherty.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Justin Clacherty <justin@redfish-group.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index f79fdb839cb8..f2da0269e1b1 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -245,7 +245,7 @@ static int config_buf(struct usb_configuration *config,
 	c->bConfigurationValue = config->bConfigurationValue;
 	c->iConfiguration = config->iConfiguration;
 	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
-	c->bMaxPower = config->bMaxPower;
+	c->bMaxPower = config->bMaxPower ? : (CONFIG_USB_GADGET_VBUS_DRAW / 2);
 
 	/* There may be e.g. OTG descriptors */
 	if (config->descriptors) {
@@ -432,7 +432,7 @@ static int set_config(struct usb_composite_dev *cdev,
 	}
 
 	/* when we return, be sure our power usage is valid */
-	power = 2 * c->bMaxPower;
+	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
 done:
 	usb_gadget_vbus_draw(gadget, power);
 	return result;

commit 60beed95e38793c0baff7f94433c1f639d8d5efd
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Aug 18 17:38:22 2008 -0700

    usb gadget: function activation/deactivation
    
    Add a new mechanism to the composite gadget framework, letting
    functions deactivate (and reactivate) themselves.  Think of it
    as a refcounted wrapper for the software pullup control.
    
    A key example of why to use this mechanism involves functions that
    require a userspace daemon.  Those functions shuld use this new
    mechanism to prevent the gadget from enumerating until those daemons
    are activated.  Without this mechanism, hosts would see devices that
    malfunction until the relevant daemons start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 85c876c1f150..f79fdb839cb8 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -127,6 +127,70 @@ int __init usb_add_function(struct usb_configuration *config,
 	return value;
 }
 
+/**
+ * usb_function_deactivate - prevent function and gadget enumeration
+ * @function: the function that isn't yet ready to respond
+ *
+ * Blocks response of the gadget driver to host enumeration by
+ * preventing the data line pullup from being activated.  This is
+ * normally called during @bind() processing to change from the
+ * initial "ready to respond" state, or when a required resource
+ * becomes available.
+ *
+ * For example, drivers that serve as a passthrough to a userspace
+ * daemon can block enumeration unless that daemon (such as an OBEX,
+ * MTP, or print server) is ready to handle host requests.
+ *
+ * Not all systems support software control of their USB peripheral
+ * data pullups.
+ *
+ * Returns zero on success, else negative errno.
+ */
+int usb_function_deactivate(struct usb_function *function)
+{
+	struct usb_composite_dev	*cdev = function->config->cdev;
+	int				status = 0;
+
+	spin_lock(&cdev->lock);
+
+	if (cdev->deactivations == 0)
+		status = usb_gadget_disconnect(cdev->gadget);
+	if (status == 0)
+		cdev->deactivations++;
+
+	spin_unlock(&cdev->lock);
+	return status;
+}
+
+/**
+ * usb_function_activate - allow function and gadget enumeration
+ * @function: function on which usb_function_activate() was called
+ *
+ * Reverses effect of usb_function_deactivate().  If no more functions
+ * are delaying their activation, the gadget driver will respond to
+ * host enumeration procedures.
+ *
+ * Returns zero on success, else negative errno.
+ */
+int usb_function_activate(struct usb_function *function)
+{
+	struct usb_composite_dev	*cdev = function->config->cdev;
+	int				status = 0;
+
+	spin_lock(&cdev->lock);
+
+	if (WARN_ON(cdev->deactivations == 0))
+		status = -EINVAL;
+	else {
+		cdev->deactivations--;
+		if (cdev->deactivations == 0)
+			status = usb_gadget_connect(cdev->gadget);
+	}
+
+	spin_unlock(&cdev->lock);
+	return status;
+}
+
 /**
  * usb_interface_id() - allocate an unused interface ID
  * @config: configuration associated with the interface

commit c24f42276b4c4467e82cdd5a941fb7f9400aeea0
Author: David Lopo <dlopo@chipidea.mips.com>
Date:   Tue Jul 1 13:14:17 2008 -0700

    usb gadget: minor USBCV fix for composite framework
    
    Fill in a reserved/unused device qualifier field to ensure that
    the USBCV tests will always pass.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index b3d302a6a081..85c876c1f150 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -294,6 +294,7 @@ static void device_qual(struct usb_composite_dev *cdev)
 	/* ASSUME same EP0 fifo size at both speeds */
 	qual->bMaxPacketSize0 = cdev->desc.bMaxPacketSize0;
 	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
+	qual->bRESERVED = 0;
 }
 
 /*-------------------------------------------------------------------------*/

commit 40982be52d8f64c3e10adce17e66ab755a4fa26b
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Jun 19 17:52:58 2008 -0700

    usb gadget: composite gadget core
    
    Add <linux/usb/composite.h> interfaces for composite gadget drivers, and
    basic implementation support behind it:
    
      - struct usb_function ... groups one or more interfaces into a function
        managed as one unit within a configuration, to which it's added by
        usb_add_function().
    
      - struct usb_configuration ... groups one or more such functions into
        a configuration managed as one unit by a driver, to which it's added
        by usb_add_config().  These operate at either high or full/low speeds
        and at a given bMaxPower.
    
      - struct usb_composite_driver ... groups one or more such configurations
        into a gadget driver, which may be registered or unregistered.
    
      - struct usb_composite_dev ... a usb_composite_driver manages this; it
        wraps the usb_gadget exposed by the controller driver.
    
    This also includes some basic kerneldoc.
    
    How to use it (the short version):  provide a usb_composite_driver with a
    bind() that calls usb_add_config() for each of the needed configurations.
    The configurations in turn have bind() calls, which will usb_add_function()
    for each function required.  Each function's bind() allocates resources
    needed to perform its tasks, like endpoints; sometimes configurations will
    allocate resources too.
    
    Separate patches will convert most gadget drivers to this infrastructure.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
new file mode 100644
index 000000000000..b3d302a6a081
--- /dev/null
+++ b/drivers/usb/gadget/composite.c
@@ -0,0 +1,1040 @@
+/*
+ * composite.c - infrastructure for Composite USB Gadgets
+ *
+ * Copyright (C) 2006-2008 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kallsyms.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+#include <linux/usb/composite.h>
+
+
+/*
+ * The code in this file is utility code, used to build a gadget driver
+ * from one or more "function" drivers, one or more "configuration"
+ * objects, and a "usb_composite_driver" by gluing them together along
+ * with the relevant device-wide data.
+ */
+
+/* big enough to hold our biggest descriptor */
+#define USB_BUFSIZ	512
+
+static struct usb_composite_driver *composite;
+
+/* Some systems will need runtime overrides for the  product identifers
+ * published in the device descriptor, either numbers or strings or both.
+ * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
+ */
+
+static ushort idVendor;
+module_param(idVendor, ushort, 0);
+MODULE_PARM_DESC(idVendor, "USB Vendor ID");
+
+static ushort idProduct;
+module_param(idProduct, ushort, 0);
+MODULE_PARM_DESC(idProduct, "USB Product ID");
+
+static ushort bcdDevice;
+module_param(bcdDevice, ushort, 0);
+MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
+
+static char *iManufacturer;
+module_param(iManufacturer, charp, 0);
+MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
+
+static char *iProduct;
+module_param(iProduct, charp, 0);
+MODULE_PARM_DESC(iProduct, "USB Product string");
+
+static char *iSerialNumber;
+module_param(iSerialNumber, charp, 0);
+MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * usb_add_function() - add a function to a configuration
+ * @config: the configuration
+ * @function: the function being added
+ * Context: single threaded during gadget setup
+ *
+ * After initialization, each configuration must have one or more
+ * functions added to it.  Adding a function involves calling its @bind()
+ * method to allocate resources such as interface and string identifiers
+ * and endpoints.
+ *
+ * This function returns the value of the function's bind(), which is
+ * zero for success else a negative errno value.
+ */
+int __init usb_add_function(struct usb_configuration *config,
+		struct usb_function *function)
+{
+	int	value = -EINVAL;
+
+	DBG(config->cdev, "adding '%s'/%p to config '%s'/%p\n",
+			function->name, function,
+			config->label, config);
+
+	if (!function->set_alt || !function->disable)
+		goto done;
+
+	function->config = config;
+	list_add_tail(&function->list, &config->functions);
+
+	/* REVISIT *require* function->bind? */
+	if (function->bind) {
+		value = function->bind(config, function);
+		if (value < 0) {
+			list_del(&function->list);
+			function->config = NULL;
+		}
+	} else
+		value = 0;
+
+	/* We allow configurations that don't work at both speeds.
+	 * If we run into a lowspeed Linux system, treat it the same
+	 * as full speed ... it's the function drivers that will need
+	 * to avoid bulk and ISO transfers.
+	 */
+	if (!config->fullspeed && function->descriptors)
+		config->fullspeed = true;
+	if (!config->highspeed && function->hs_descriptors)
+		config->highspeed = true;
+
+done:
+	if (value)
+		DBG(config->cdev, "adding '%s'/%p --> %d\n",
+				function->name, function, value);
+	return value;
+}
+
+/**
+ * usb_interface_id() - allocate an unused interface ID
+ * @config: configuration associated with the interface
+ * @function: function handling the interface
+ * Context: single threaded during gadget setup
+ *
+ * usb_interface_id() is called from usb_function.bind() callbacks to
+ * allocate new interface IDs.  The function driver will then store that
+ * ID in interface, association, CDC union, and other descriptors.  It
+ * will also handle any control requests targetted at that interface,
+ * particularly changing its altsetting via set_alt().  There may
+ * also be class-specific or vendor-specific requests to handle.
+ *
+ * All interface identifier should be allocated using this routine, to
+ * ensure that for example different functions don't wrongly assign
+ * different meanings to the same identifier.  Note that since interface
+ * identifers are configuration-specific, functions used in more than
+ * one configuration (or more than once in a given configuration) need
+ * multiple versions of the relevant descriptors.
+ *
+ * Returns the interface ID which was allocated; or -ENODEV if no
+ * more interface IDs can be allocated.
+ */
+int __init usb_interface_id(struct usb_configuration *config,
+		struct usb_function *function)
+{
+	unsigned id = config->next_interface_id;
+
+	if (id < MAX_CONFIG_INTERFACES) {
+		config->interface[id] = function;
+		config->next_interface_id = id + 1;
+		return id;
+	}
+	return -ENODEV;
+}
+
+static int config_buf(struct usb_configuration *config,
+		enum usb_device_speed speed, void *buf, u8 type)
+{
+	struct usb_config_descriptor	*c = buf;
+	void				*next = buf + USB_DT_CONFIG_SIZE;
+	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
+	struct usb_function		*f;
+	int				status;
+
+	/* write the config descriptor */
+	c = buf;
+	c->bLength = USB_DT_CONFIG_SIZE;
+	c->bDescriptorType = type;
+	/* wTotalLength is written later */
+	c->bNumInterfaces = config->next_interface_id;
+	c->bConfigurationValue = config->bConfigurationValue;
+	c->iConfiguration = config->iConfiguration;
+	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
+	c->bMaxPower = config->bMaxPower;
+
+	/* There may be e.g. OTG descriptors */
+	if (config->descriptors) {
+		status = usb_descriptor_fillbuf(next, len,
+				config->descriptors);
+		if (status < 0)
+			return status;
+		len -= status;
+		next += status;
+	}
+
+	/* add each function's descriptors */
+	list_for_each_entry(f, &config->functions, list) {
+		struct usb_descriptor_header **descriptors;
+
+		if (speed == USB_SPEED_HIGH)
+			descriptors = f->hs_descriptors;
+		else
+			descriptors = f->descriptors;
+		if (!descriptors)
+			continue;
+		status = usb_descriptor_fillbuf(next, len,
+			(const struct usb_descriptor_header **) descriptors);
+		if (status < 0)
+			return status;
+		len -= status;
+		next += status;
+	}
+
+	len = next - buf;
+	c->wTotalLength = cpu_to_le16(len);
+	return len;
+}
+
+static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
+{
+	struct usb_gadget		*gadget = cdev->gadget;
+	struct usb_configuration	*c;
+	u8				type = w_value >> 8;
+	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
+
+	if (gadget_is_dualspeed(gadget)) {
+		int			hs = 0;
+
+		if (gadget->speed == USB_SPEED_HIGH)
+			hs = 1;
+		if (type == USB_DT_OTHER_SPEED_CONFIG)
+			hs = !hs;
+		if (hs)
+			speed = USB_SPEED_HIGH;
+
+	}
+
+	/* This is a lookup by config *INDEX* */
+	w_value &= 0xff;
+	list_for_each_entry(c, &cdev->configs, list) {
+		/* ignore configs that won't work at this speed */
+		if (speed == USB_SPEED_HIGH) {
+			if (!c->highspeed)
+				continue;
+		} else {
+			if (!c->fullspeed)
+				continue;
+		}
+		if (w_value == 0)
+			return config_buf(c, speed, cdev->req->buf, type);
+		w_value--;
+	}
+	return -EINVAL;
+}
+
+static int count_configs(struct usb_composite_dev *cdev, unsigned type)
+{
+	struct usb_gadget		*gadget = cdev->gadget;
+	struct usb_configuration	*c;
+	unsigned			count = 0;
+	int				hs = 0;
+
+	if (gadget_is_dualspeed(gadget)) {
+		if (gadget->speed == USB_SPEED_HIGH)
+			hs = 1;
+		if (type == USB_DT_DEVICE_QUALIFIER)
+			hs = !hs;
+	}
+	list_for_each_entry(c, &cdev->configs, list) {
+		/* ignore configs that won't work at this speed */
+		if (hs) {
+			if (!c->highspeed)
+				continue;
+		} else {
+			if (!c->fullspeed)
+				continue;
+		}
+		count++;
+	}
+	return count;
+}
+
+static void device_qual(struct usb_composite_dev *cdev)
+{
+	struct usb_qualifier_descriptor	*qual = cdev->req->buf;
+
+	qual->bLength = sizeof(*qual);
+	qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
+	/* POLICY: same bcdUSB and device type info at both speeds */
+	qual->bcdUSB = cdev->desc.bcdUSB;
+	qual->bDeviceClass = cdev->desc.bDeviceClass;
+	qual->bDeviceSubClass = cdev->desc.bDeviceSubClass;
+	qual->bDeviceProtocol = cdev->desc.bDeviceProtocol;
+	/* ASSUME same EP0 fifo size at both speeds */
+	qual->bMaxPacketSize0 = cdev->desc.bMaxPacketSize0;
+	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void reset_config(struct usb_composite_dev *cdev)
+{
+	struct usb_function		*f;
+
+	DBG(cdev, "reset config\n");
+
+	list_for_each_entry(f, &cdev->config->functions, list) {
+		if (f->disable)
+			f->disable(f);
+	}
+	cdev->config = NULL;
+}
+
+static int set_config(struct usb_composite_dev *cdev,
+		const struct usb_ctrlrequest *ctrl, unsigned number)
+{
+	struct usb_gadget	*gadget = cdev->gadget;
+	struct usb_configuration *c = NULL;
+	int			result = -EINVAL;
+	unsigned		power = gadget_is_otg(gadget) ? 8 : 100;
+	int			tmp;
+
+	if (cdev->config)
+		reset_config(cdev);
+
+	if (number) {
+		list_for_each_entry(c, &cdev->configs, list) {
+			if (c->bConfigurationValue == number) {
+				result = 0;
+				break;
+			}
+		}
+		if (result < 0)
+			goto done;
+	} else
+		result = 0;
+
+	INFO(cdev, "%s speed config #%d: %s\n",
+		({ char *speed;
+		switch (gadget->speed) {
+		case USB_SPEED_LOW:	speed = "low"; break;
+		case USB_SPEED_FULL:	speed = "full"; break;
+		case USB_SPEED_HIGH:	speed = "high"; break;
+		default:		speed = "?"; break;
+		} ; speed; }), number, c ? c->label : "unconfigured");
+
+	if (!c)
+		goto done;
+
+	cdev->config = c;
+
+	/* Initialize all interfaces by setting them to altsetting zero. */
+	for (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {
+		struct usb_function	*f = c->interface[tmp];
+
+		if (!f)
+			break;
+
+		result = f->set_alt(f, tmp, 0);
+		if (result < 0) {
+			DBG(cdev, "interface %d (%s/%p) alt 0 --> %d\n",
+					tmp, f->name, f, result);
+
+			reset_config(cdev);
+			goto done;
+		}
+	}
+
+	/* when we return, be sure our power usage is valid */
+	power = 2 * c->bMaxPower;
+done:
+	usb_gadget_vbus_draw(gadget, power);
+	return result;
+}
+
+/**
+ * usb_add_config() - add a configuration to a device.
+ * @cdev: wraps the USB gadget
+ * @config: the configuration, with bConfigurationValue assigned
+ * Context: single threaded during gadget setup
+ *
+ * One of the main tasks of a composite driver's bind() routine is to
+ * add each of the configurations it supports, using this routine.
+ *
+ * This function returns the value of the configuration's bind(), which
+ * is zero for success else a negative errno value.  Binding configurations
+ * assigns global resources including string IDs, and per-configuration
+ * resources such as interface IDs and endpoints.
+ */
+int __init usb_add_config(struct usb_composite_dev *cdev,
+		struct usb_configuration *config)
+{
+	int				status = -EINVAL;
+	struct usb_configuration	*c;
+
+	DBG(cdev, "adding config #%u '%s'/%p\n",
+			config->bConfigurationValue,
+			config->label, config);
+
+	if (!config->bConfigurationValue || !config->bind)
+		goto done;
+
+	/* Prevent duplicate configuration identifiers */
+	list_for_each_entry(c, &cdev->configs, list) {
+		if (c->bConfigurationValue == config->bConfigurationValue) {
+			status = -EBUSY;
+			goto done;
+		}
+	}
+
+	config->cdev = cdev;
+	list_add_tail(&config->list, &cdev->configs);
+
+	INIT_LIST_HEAD(&config->functions);
+	config->next_interface_id = 0;
+
+	status = config->bind(config);
+	if (status < 0) {
+		list_del(&config->list);
+		config->cdev = NULL;
+	} else {
+		unsigned	i;
+
+		DBG(cdev, "cfg %d/%p speeds:%s%s\n",
+			config->bConfigurationValue, config,
+			config->highspeed ? " high" : "",
+			config->fullspeed
+				? (gadget_is_dualspeed(cdev->gadget)
+					? " full"
+					: " full/low")
+				: "");
+
+		for (i = 0; i < MAX_CONFIG_INTERFACES; i++) {
+			struct usb_function	*f = config->interface[i];
+
+			if (!f)
+				continue;
+			DBG(cdev, "  interface %d = %s/%p\n",
+				i, f->name, f);
+		}
+	}
+
+	/* set_alt(), or next config->bind(), sets up
+	 * ep->driver_data as needed.
+	 */
+	usb_ep_autoconfig_reset(cdev->gadget);
+
+done:
+	if (status)
+		DBG(cdev, "added config '%s'/%u --> %d\n", config->label,
+				config->bConfigurationValue, status);
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* We support strings in multiple languages ... string descriptor zero
+ * says which languages are supported.  The typical case will be that
+ * only one language (probably English) is used, with I18N handled on
+ * the host side.
+ */
+
+static void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)
+{
+	const struct usb_gadget_strings	*s;
+	u16				language;
+	__le16				*tmp;
+
+	while (*sp) {
+		s = *sp;
+		language = cpu_to_le16(s->language);
+		for (tmp = buf; *tmp && tmp < &buf[126]; tmp++) {
+			if (*tmp == language)
+				goto repeat;
+		}
+		*tmp++ = language;
+repeat:
+		sp++;
+	}
+}
+
+static int lookup_string(
+	struct usb_gadget_strings	**sp,
+	void				*buf,
+	u16				language,
+	int				id
+)
+{
+	struct usb_gadget_strings	*s;
+	int				value;
+
+	while (*sp) {
+		s = *sp++;
+		if (s->language != language)
+			continue;
+		value = usb_gadget_get_string(s, id, buf);
+		if (value > 0)
+			return value;
+	}
+	return -EINVAL;
+}
+
+static int get_string(struct usb_composite_dev *cdev,
+		void *buf, u16 language, int id)
+{
+	struct usb_configuration	*c;
+	struct usb_function		*f;
+	int				len;
+
+	/* Yes, not only is USB's I18N support probably more than most
+	 * folk will ever care about ... also, it's all supported here.
+	 * (Except for UTF8 support for Unicode's "Astral Planes".)
+	 */
+
+	/* 0 == report all available language codes */
+	if (id == 0) {
+		struct usb_string_descriptor	*s = buf;
+		struct usb_gadget_strings	**sp;
+
+		memset(s, 0, 256);
+		s->bDescriptorType = USB_DT_STRING;
+
+		sp = composite->strings;
+		if (sp)
+			collect_langs(sp, s->wData);
+
+		list_for_each_entry(c, &cdev->configs, list) {
+			sp = c->strings;
+			if (sp)
+				collect_langs(sp, s->wData);
+
+			list_for_each_entry(f, &c->functions, list) {
+				sp = f->strings;
+				if (sp)
+					collect_langs(sp, s->wData);
+			}
+		}
+
+		for (len = 0; s->wData[len] && len <= 126; len++)
+			continue;
+		if (!len)
+			return -EINVAL;
+
+		s->bLength = 2 * (len + 1);
+		return s->bLength;
+	}
+
+	/* Otherwise, look up and return a specified string.  String IDs
+	 * are device-scoped, so we look up each string table we're told
+	 * about.  These lookups are infrequent; simpler-is-better here.
+	 */
+	if (composite->strings) {
+		len = lookup_string(composite->strings, buf, language, id);
+		if (len > 0)
+			return len;
+	}
+	list_for_each_entry(c, &cdev->configs, list) {
+		if (c->strings) {
+			len = lookup_string(c->strings, buf, language, id);
+			if (len > 0)
+				return len;
+		}
+		list_for_each_entry(f, &c->functions, list) {
+			if (!f->strings)
+				continue;
+			len = lookup_string(f->strings, buf, language, id);
+			if (len > 0)
+				return len;
+		}
+	}
+	return -EINVAL;
+}
+
+/**
+ * usb_string_id() - allocate an unused string ID
+ * @cdev: the device whose string descriptor IDs are being allocated
+ * Context: single threaded during gadget setup
+ *
+ * @usb_string_id() is called from bind() callbacks to allocate
+ * string IDs.  Drivers for functions, configurations, or gadgets will
+ * then store that ID in the appropriate descriptors and string table.
+ *
+ * All string identifier should be allocated using this routine, to
+ * ensure that for example different functions don't wrongly assign
+ * different meanings to the same identifier.
+ */
+int __init usb_string_id(struct usb_composite_dev *cdev)
+{
+	if (cdev->next_string_id < 254) {
+		/* string id 0 is reserved */
+		cdev->next_string_id++;
+		return cdev->next_string_id;
+	}
+	return -ENODEV;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	if (req->status || req->actual != req->length)
+		DBG((struct usb_composite_dev *) ep->driver_data,
+				"setup complete --> %d, %d/%d\n",
+				req->status, req->actual, req->length);
+}
+
+/*
+ * The setup() callback implements all the ep0 functionality that's
+ * not handled lower down, in hardware or the hardware driver(like
+ * device and endpoint feature flags, and their status).  It's all
+ * housekeeping for the gadget function we're implementing.  Most of
+ * the work is in config and function specific setup.
+ */
+static int
+composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_request		*req = cdev->req;
+	int				value = -EOPNOTSUPP;
+	u16				w_index = le16_to_cpu(ctrl->wIndex);
+	u16				w_value = le16_to_cpu(ctrl->wValue);
+	u16				w_length = le16_to_cpu(ctrl->wLength);
+	struct usb_function		*f = NULL;
+
+	/* partial re-init of the response message; the function or the
+	 * gadget might need to intercept e.g. a control-OUT completion
+	 * when we delegate to it.
+	 */
+	req->zero = 0;
+	req->complete = composite_setup_complete;
+	req->length = USB_BUFSIZ;
+	gadget->ep0->driver_data = cdev;
+
+	switch (ctrl->bRequest) {
+
+	/* we handle all standard USB descriptors */
+	case USB_REQ_GET_DESCRIPTOR:
+		if (ctrl->bRequestType != USB_DIR_IN)
+			goto unknown;
+		switch (w_value >> 8) {
+
+		case USB_DT_DEVICE:
+			cdev->desc.bNumConfigurations =
+				count_configs(cdev, USB_DT_DEVICE);
+			value = min(w_length, (u16) sizeof cdev->desc);
+			memcpy(req->buf, &cdev->desc, value);
+			break;
+		case USB_DT_DEVICE_QUALIFIER:
+			if (!gadget_is_dualspeed(gadget))
+				break;
+			device_qual(cdev);
+			value = min_t(int, w_length,
+				sizeof(struct usb_qualifier_descriptor));
+			break;
+		case USB_DT_OTHER_SPEED_CONFIG:
+			if (!gadget_is_dualspeed(gadget))
+				break;
+			/* FALLTHROUGH */
+		case USB_DT_CONFIG:
+			value = config_desc(cdev, w_value);
+			if (value >= 0)
+				value = min(w_length, (u16) value);
+			break;
+		case USB_DT_STRING:
+			value = get_string(cdev, req->buf,
+					w_index, w_value & 0xff);
+			if (value >= 0)
+				value = min(w_length, (u16) value);
+			break;
+		}
+		break;
+
+	/* any number of configs can work */
+	case USB_REQ_SET_CONFIGURATION:
+		if (ctrl->bRequestType != 0)
+			goto unknown;
+		if (gadget_is_otg(gadget)) {
+			if (gadget->a_hnp_support)
+				DBG(cdev, "HNP available\n");
+			else if (gadget->a_alt_hnp_support)
+				DBG(cdev, "HNP on another port\n");
+			else
+				VDBG(cdev, "HNP inactive\n");
+		}
+		spin_lock(&cdev->lock);
+		value = set_config(cdev, ctrl, w_value);
+		spin_unlock(&cdev->lock);
+		break;
+	case USB_REQ_GET_CONFIGURATION:
+		if (ctrl->bRequestType != USB_DIR_IN)
+			goto unknown;
+		if (cdev->config)
+			*(u8 *)req->buf = cdev->config->bConfigurationValue;
+		else
+			*(u8 *)req->buf = 0;
+		value = min(w_length, (u16) 1);
+		break;
+
+	/* function drivers must handle get/set altsetting; if there's
+	 * no get() method, we know only altsetting zero works.
+	 */
+	case USB_REQ_SET_INTERFACE:
+		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
+			goto unknown;
+		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[w_index];
+		if (!f)
+			break;
+		if (w_value && !f->get_alt)
+			break;
+		value = f->set_alt(f, w_index, w_value);
+		break;
+	case USB_REQ_GET_INTERFACE:
+		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
+			goto unknown;
+		if (!cdev->config || w_index >= MAX_CONFIG_INTERFACES)
+			break;
+		f = cdev->config->interface[w_index];
+		if (!f)
+			break;
+		/* lots of interfaces only need altsetting zero... */
+		value = f->get_alt ? f->get_alt(f, w_index) : 0;
+		if (value < 0)
+			break;
+		*((u8 *)req->buf) = value;
+		value = min(w_length, (u16) 1);
+		break;
+	default:
+unknown:
+		VDBG(cdev,
+			"non-core control req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+		/* functions always handle their interfaces ... punt other
+		 * recipients (endpoint, other, WUSB, ...) to the current
+		 * configuration code.
+		 *
+		 * REVISIT it could make sense to let the composite device
+		 * take such requests too, if that's ever needed:  to work
+		 * in config 0, etc.
+		 */
+		if ((ctrl->bRequestType & USB_RECIP_MASK)
+				== USB_RECIP_INTERFACE) {
+			f = cdev->config->interface[w_index];
+			if (f && f->setup)
+				value = f->setup(f, ctrl);
+			else
+				f = NULL;
+		}
+		if (value < 0 && !f) {
+			struct usb_configuration	*c;
+
+			c = cdev->config;
+			if (c && c->setup)
+				value = c->setup(c, ctrl);
+		}
+
+		goto done;
+	}
+
+	/* respond with data transfer before status phase? */
+	if (value >= 0) {
+		req->length = value;
+		req->zero = value < w_length;
+		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0) {
+			DBG(cdev, "ep_queue --> %d\n", value);
+			req->status = 0;
+			composite_setup_complete(gadget->ep0, req);
+		}
+	}
+
+done:
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static void composite_disconnect(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	unsigned long			flags;
+
+	/* REVISIT:  should we have config and device level
+	 * disconnect callbacks?
+	 */
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		reset_config(cdev);
+	spin_unlock_irqrestore(&cdev->lock, flags);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void /* __init_or_exit */
+composite_unbind(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+
+	/* composite_disconnect() must already have been called
+	 * by the underlying peripheral controller driver!
+	 * so there's no i/o concurrency that could affect the
+	 * state protected by cdev->lock.
+	 */
+	WARN_ON(cdev->config);
+
+	while (!list_empty(&cdev->configs)) {
+		struct usb_configuration	*c;
+
+		c = list_first_entry(&cdev->configs,
+				struct usb_configuration, list);
+		while (!list_empty(&c->functions)) {
+			struct usb_function		*f;
+
+			f = list_first_entry(&c->functions,
+					struct usb_function, list);
+			list_del(&f->list);
+			if (f->unbind) {
+				DBG(cdev, "unbind function '%s'/%p\n",
+						f->name, f);
+				f->unbind(c, f);
+				/* may free memory for "f" */
+			}
+		}
+		list_del(&c->list);
+		if (c->unbind) {
+			DBG(cdev, "unbind config '%s'/%p\n", c->label, c);
+			c->unbind(c);
+			/* may free memory for "c" */
+		}
+	}
+	if (composite->unbind)
+		composite->unbind(cdev);
+
+	if (cdev->req) {
+		kfree(cdev->req->buf);
+		usb_ep_free_request(gadget->ep0, cdev->req);
+	}
+	kfree(cdev);
+	set_gadget_data(gadget, NULL);
+	composite = NULL;
+}
+
+static void __init
+string_override_one(struct usb_gadget_strings *tab, u8 id, const char *s)
+{
+	struct usb_string		*str = tab->strings;
+
+	for (str = tab->strings; str->s; str++) {
+		if (str->id == id) {
+			str->s = s;
+			return;
+		}
+	}
+}
+
+static void __init
+string_override(struct usb_gadget_strings **tab, u8 id, const char *s)
+{
+	while (*tab) {
+		string_override_one(*tab, id, s);
+		tab++;
+	}
+}
+
+static int __init composite_bind(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev;
+	int				status = -ENOMEM;
+
+	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
+	if (!cdev)
+		return status;
+
+	spin_lock_init(&cdev->lock);
+	cdev->gadget = gadget;
+	set_gadget_data(gadget, cdev);
+	INIT_LIST_HEAD(&cdev->configs);
+
+	/* preallocate control response and buffer */
+	cdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
+	if (!cdev->req)
+		goto fail;
+	cdev->req->buf = kmalloc(USB_BUFSIZ, GFP_KERNEL);
+	if (!cdev->req->buf)
+		goto fail;
+	cdev->req->complete = composite_setup_complete;
+	gadget->ep0->driver_data = cdev;
+
+	cdev->bufsiz = USB_BUFSIZ;
+	cdev->driver = composite;
+
+	usb_gadget_set_selfpowered(gadget);
+
+	/* interface and string IDs start at zero via kzalloc.
+	 * we force endpoints to start unassigned; few controller
+	 * drivers will zero ep->driver_data.
+	 */
+	usb_ep_autoconfig_reset(cdev->gadget);
+
+	/* composite gadget needs to assign strings for whole device (like
+	 * serial number), register function drivers, potentially update
+	 * power state and consumption, etc
+	 */
+	status = composite->bind(cdev);
+	if (status < 0)
+		goto fail;
+
+	cdev->desc = *composite->dev;
+	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
+
+	/* standardized runtime overrides for device ID data */
+	if (idVendor)
+		cdev->desc.idVendor = cpu_to_le16(idVendor);
+	if (idProduct)
+		cdev->desc.idProduct = cpu_to_le16(idProduct);
+	if (bcdDevice)
+		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+
+	/* strings can't be assigned before bind() allocates the
+	 * releavnt identifiers
+	 */
+	if (cdev->desc.iManufacturer && iManufacturer)
+		string_override(composite->strings,
+			cdev->desc.iManufacturer, iManufacturer);
+	if (cdev->desc.iProduct && iProduct)
+		string_override(composite->strings,
+			cdev->desc.iProduct, iProduct);
+	if (cdev->desc.iSerialNumber && iSerialNumber)
+		string_override(composite->strings,
+			cdev->desc.iSerialNumber, iSerialNumber);
+
+	INFO(cdev, "%s ready\n", composite->name);
+	return 0;
+
+fail:
+	composite_unbind(gadget);
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void
+composite_suspend(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_function		*f;
+
+	/* REVISIT:  should we have config and device level
+	 * suspend/resume callbacks?
+	 */
+	DBG(cdev, "suspend\n");
+	if (cdev->config) {
+		list_for_each_entry(f, &cdev->config->functions, list) {
+			if (f->suspend)
+				f->suspend(f);
+		}
+	}
+}
+
+static void
+composite_resume(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_function		*f;
+
+	/* REVISIT:  should we have config and device level
+	 * suspend/resume callbacks?
+	 */
+	DBG(cdev, "resume\n");
+	if (cdev->config) {
+		list_for_each_entry(f, &cdev->config->functions, list) {
+			if (f->resume)
+				f->resume(f);
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_gadget_driver composite_driver = {
+	.speed		= USB_SPEED_HIGH,
+
+	.bind		= composite_bind,
+	.unbind		= __exit_p(composite_unbind),
+
+	.setup		= composite_setup,
+	.disconnect	= composite_disconnect,
+
+	.suspend	= composite_suspend,
+	.resume		= composite_resume,
+
+	.driver	= {
+		.owner		= THIS_MODULE,
+	},
+};
+
+/**
+ * usb_composite_register() - register a composite driver
+ * @driver: the driver to register
+ * Context: single threaded during gadget setup
+ *
+ * This function is used to register drivers using the composite driver
+ * framework.  The return value is zero, or a negative errno value.
+ * Those values normally come from the driver's @bind method, which does
+ * all the work of setting up the driver to match the hardware.
+ *
+ * On successful return, the gadget is ready to respond to requests from
+ * the host, unless one of its components invokes usb_gadget_disconnect()
+ * while it was binding.  That would usually be done in order to wait for
+ * some userspace participation.
+ */
+int __init usb_composite_register(struct usb_composite_driver *driver)
+{
+	if (!driver || !driver->dev || !driver->bind || composite)
+		return -EINVAL;
+
+	if (!driver->name)
+		driver->name = "composite";
+	composite_driver.function =  (char *) driver->name;
+	composite_driver.driver.name = driver->name;
+	composite = driver;
+
+	return usb_gadget_register_driver(&composite_driver);
+}
+
+/**
+ * usb_composite_unregister() - unregister a composite driver
+ * @driver: the driver to unregister
+ *
+ * This function is used to unregister drivers using the composite
+ * driver framework.
+ */
+void __exit usb_composite_unregister(struct usb_composite_driver *driver)
+{
+	if (composite != driver)
+		return;
+	usb_gadget_unregister_driver(&composite_driver);
+}
