commit dffe2d7fc45017d7afdb6fc226ff34a537cc285c
Author: Andrzej Pietrasiewicz <andrzej.p@collabora.com>
Date:   Thu Jan 31 15:53:39 2019 +0100

    usb: gadget: move non-super speed code out of usb_ep_autoconfig_ss()
    
    The moved code refers to non-super speed endpoints only. This patch also
    makes the comment stress the fact, that autoconfigured descriptor might
    need some adjustments.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@collabora.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 71b15c65b90f..1eb4fa2e623f 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -67,9 +67,6 @@ struct usb_ep *usb_ep_autoconfig_ss(
 )
 {
 	struct usb_ep	*ep;
-	u8		type;
-
-	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	if (gadget->ops->match_ep) {
 		ep = gadget->ops->match_ep(gadget, desc, ep_comp);
@@ -109,16 +106,6 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		desc->bEndpointAddress |= gadget->out_epnum;
 	}
 
-	/* report (variable) full speed bulk maxpacket */
-	if ((type == USB_ENDPOINT_XFER_BULK) && !ep_comp) {
-		int size = ep->maxpacket_limit;
-
-		/* min() doesn't work on bitfields with gcc-3.5 */
-		if (size > 64)
-			size = 64;
-		desc->wMaxPacketSize = cpu_to_le16(size);
-	}
-
 	ep->address = desc->bEndpointAddress;
 	ep->desc = NULL;
 	ep->comp_desc = NULL;
@@ -152,9 +139,10 @@ EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
  *
  * On success, this returns an claimed usb_ep, and modifies the endpoint
  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
- * is initialized as if the endpoint were used at full speed.  To prevent
- * the endpoint from being returned by a later autoconfig call, claims it
- * by assigning ep->claimed to true.
+ * is initialized as if the endpoint were used at full speed. Because of
+ * that the users must consider adjusting the autoconfigured descriptor.
+ * To prevent the endpoint from being returned by a later autoconfig call,
+ * claims it by assigning ep->claimed to true.
  *
  * On failure, this returns a null endpoint descriptor.
  */
@@ -163,7 +151,26 @@ struct usb_ep *usb_ep_autoconfig(
 	struct usb_endpoint_descriptor	*desc
 )
 {
-	return usb_ep_autoconfig_ss(gadget, desc, NULL);
+	struct usb_ep	*ep;
+	u8		type;
+
+	ep = usb_ep_autoconfig_ss(gadget, desc, NULL);
+	if (!ep)
+		return NULL;
+
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+	/* report (variable) full speed bulk maxpacket */
+	if (type == USB_ENDPOINT_XFER_BULK) {
+		int size = ep->maxpacket_limit;
+
+		/* min() doesn't work on bitfields with gcc-3.5 */
+		if (size > 64)
+			size = 64;
+		desc->wMaxPacketSize = cpu_to_le16(size);
+	}
+
+	return ep;
 }
 EXPORT_SYMBOL_GPL(usb_ep_autoconfig);
 

commit e79bfcb795f9cabc7d5903eb779bed3f4d14b364
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:33 2017 +0100

    USB: gadget: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 3a3b3027f234..71b15c65b90f 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -3,11 +3,6 @@
  * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
  *
  * Copyright (C) 2004 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 30fdab0ae383..3a3b3027f234 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
  *

commit b67f628c84329a9ce82dbff5fde196dc4624e7c2
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Wed Sep 16 12:10:41 2015 +0200

    usb: gadget: epautoconf: add usb_ep_autoconfig_release() function
    
    This patch introduces usb_ep_autoconfig_release() function which allows
    to release endpoint previously obtained from usb_ep_autoconfig() during
    USB function bind.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0f4ece44d703..30fdab0ae383 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -171,6 +171,23 @@ struct usb_ep *usb_ep_autoconfig(
 }
 EXPORT_SYMBOL_GPL(usb_ep_autoconfig);
 
+/**
+ * usb_ep_autoconfig_release - releases endpoint and set it to initial state
+ * @ep: endpoint which should be released
+ *
+ * This function can be used during function bind for endpoints obtained
+ * from usb_ep_autoconfig(). It unclaims endpoint claimed by
+ * usb_ep_autoconfig() to make it available for other functions. Endpoint
+ * which was released is no longer invalid and shouldn't be used in
+ * context of function which released it.
+ */
+void usb_ep_autoconfig_release(struct usb_ep *ep)
+{
+	ep->claimed = false;
+	ep->driver_data = NULL;
+}
+EXPORT_SYMBOL_GPL(usb_ep_autoconfig_release);
+
 /**
  * usb_ep_autoconfig_reset - reset endpoint autoconfig state
  * @gadget: device for which autoconfig state will be reset

commit f871cb9b2e178667a351a6fae9d930826ec10e95
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Wed Sep 16 12:10:39 2015 +0200

    usb: gadget: fix few outdated comments
    
    Fix comments in code to make them up to date.
    
    composite: claiming endpoint is now done by setting ep->claimed flag,
    not ep->driver_data.
    
    epautoconf: usb_ep_autoconfig() and usb_ep_autoconfig_ss() return
    claimed endpoint with ep->claimed flag already set.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 6399c106a3a5..0f4ece44d703 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -53,13 +53,13 @@
  * the restrictions that may apply. Some combinations of driver
  * and hardware won't be able to autoconfigure.
  *
- * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+ * On success, this returns an claimed usb_ep, and modifies the endpoint
  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
  * is initialized as if the endpoint were used at full speed and
  * the bmAttribute field in the ep companion descriptor is
  * updated with the assigned number of streams if it is
  * different from the original value. To prevent the endpoint
- * from being returned by a later autoconfig call, claim it by
+ * from being returned by a later autoconfig call, claims it by
  * assigning ep->claimed to true.
  *
  * On failure, this returns a null endpoint descriptor.
@@ -154,10 +154,10 @@ EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
  * USB controller, and it can't know all the restrictions that may apply.
  * Some combinations of driver and hardware won't be able to autoconfigure.
  *
- * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+ * On success, this returns an claimed usb_ep, and modifies the endpoint
  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
  * is initialized as if the endpoint were used at full speed.  To prevent
- * the endpoint from being returned by a later autoconfig call, claim it
+ * the endpoint from being returned by a later autoconfig call, claims it
  * by assigning ep->claimed to true.
  *
  * On failure, this returns a null endpoint descriptor.

commit e4c1b1ba7f663fd77204201eef83baf58e2e5777
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Aug 21 11:01:29 2015 +0200

    usb: gadget: fix possible regression introduced with ep->claimed
    
    This patch fixes possible regression introduced by
    patch reworking endpoint claiming mechanism. It restores
    setring ep->driver_data to NULL in usb_ep_autoconfig_reset(),
    which was removed by patch commit cc476b42a39d.
    
    Fixes: cc476b42a39d ("usb: gadget: encapsulate endpoint
            claiming mechanism")
    Reported-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 978435a51038..6399c106a3a5 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -186,6 +186,7 @@ void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		ep->claimed = false;
+		ep->driver_data = NULL;
 	}
 	gadget->in_epnum = 0;
 	gadget->out_epnum = 0;

commit adab43396ed4830c7cee29837e8cedcddb2b5315
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:16 2015 +0200

    usb: gadget: remove gadget_chips.h
    
    This header file contains helpers for quirks based on UDC controller name.
    Since we have generic quirk bitfields in usb_gadget structure for all of
    these quirks we don't need to have this header any longer.
    
    This patch removes gadget_chips.h file and makes sure that it's no longer
    included anywhere in kernel sources.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 16c1cc90c406..978435a51038 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -20,8 +20,6 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
-#include "gadget_chips.h"
-
 /**
  * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
  * descriptor and ep companion descriptor

commit 26b8aa458c7d99181ceb07f27da9bd7d94185e35
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:15 2015 +0200

    usb: musb: gadget: add musb_match_ep() function
    
    Add 'match_ep' callback to utilize chip-specific knowledge in endpoint matching
    process. Function does the same that was done by chip-specific code inside
    of epautoconf. Now this code can be removed from there to separate generic code
    from platform specific logic.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 574b6a4df646..16c1cc90c406 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -83,29 +83,6 @@ struct usb_ep *usb_ep_autoconfig_ss(
 			goto found_ep;
 	}
 
-	/* First, apply chip-specific "best usage" knowledge.
-	 * This might make a good usb_gadget_ops hook ...
-	 */
-#ifdef CONFIG_BLACKFIN
-	if (gadget_is_musbhdrc(gadget)) {
-		if ((USB_ENDPOINT_XFER_BULK == type) ||
-		    (USB_ENDPOINT_XFER_ISOC == type)) {
-			if (USB_DIR_IN & desc->bEndpointAddress)
-				ep = gadget_find_ep_by_name(gadget, "ep5in");
-			else
-				ep = gadget_find_ep_by_name(gadget, "ep6out");
-		} else if (USB_ENDPOINT_XFER_INT == type) {
-			if (USB_DIR_IN & desc->bEndpointAddress)
-				ep = gadget_find_ep_by_name(gadget, "ep1in");
-			else
-				ep = gadget_find_ep_by_name(gadget, "ep2out");
-		} else
-			ep = NULL;
-		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
-			goto found_ep;
-	}
-#endif
-
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))

commit 8cc67b7bff2fc1adfd080233d35aacba4411cf87
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:14 2015 +0200

    usb: gadget: goku_udc: add goku_match_ep() function
    
    Add 'match_ep' callback to utilize chip-specific knowledge in endpoint matching
    process. Function does the same that was done by chip-specific code inside
    of epautoconf. Now this code can be removed from there to separate generic code
    from platform specific logic.
    
    [ balbi@ti.com : fix build breakage ]
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0ff513400ecf..574b6a4df646 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -86,24 +86,8 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	/* First, apply chip-specific "best usage" knowledge.
 	 * This might make a good usb_gadget_ops hook ...
 	 */
-	if (gadget_is_goku(gadget)) {
-		if (USB_ENDPOINT_XFER_INT == type) {
-			/* single buffering is enough */
-			ep = gadget_find_ep_by_name(gadget, "ep3-bulk");
-			if (ep && usb_gadget_ep_match_desc(gadget,
-					ep, desc, ep_comp))
-				goto found_ep;
-		} else if (USB_ENDPOINT_XFER_BULK == type
-				&& (USB_DIR_IN & desc->bEndpointAddress)) {
-			/* DMA may be available */
-			ep = gadget_find_ep_by_name(gadget, "ep2-bulk");
-			if (ep && usb_gadget_ep_match_desc(gadget,
-					ep, desc, ep_comp))
-				goto found_ep;
-		}
-
 #ifdef CONFIG_BLACKFIN
-	} else if (gadget_is_musbhdrc(gadget)) {
+	if (gadget_is_musbhdrc(gadget)) {
 		if ((USB_ENDPOINT_XFER_BULK == type) ||
 		    (USB_ENDPOINT_XFER_ISOC == type)) {
 			if (USB_DIR_IN & desc->bEndpointAddress)
@@ -119,8 +103,8 @@ struct usb_ep *usb_ep_autoconfig_ss(
 			ep = NULL;
 		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
 			goto found_ep;
-#endif
 	}
+#endif
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {

commit 3e8b231818c25a250c36f8bfb944aa1fd2b13396
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:13 2015 +0200

    usb: gadget: net2280: add net2280_match_ep() function
    
    Add 'match_ep' callback to utilize chip-specific knowledge in endpoint matching
    process. Function does the same that was done by chip-specific code inside
    of epautoconf. Now this code can be removed from there to separate generic code
    from platform specific logic.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index a39ca033b9ce..0ff513400ecf 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -86,28 +86,7 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	/* First, apply chip-specific "best usage" knowledge.
 	 * This might make a good usb_gadget_ops hook ...
 	 */
-	if (gadget_is_net2280(gadget)) {
-		char name[8];
-
-		if (type == USB_ENDPOINT_XFER_INT) {
-			/* ep-e, ep-f are PIO with only 64 byte fifos */
-			ep = gadget_find_ep_by_name(gadget, "ep-e");
-			if (ep && usb_gadget_ep_match_desc(gadget,
-					ep, desc, ep_comp))
-				goto found_ep;
-			ep = gadget_find_ep_by_name(gadget, "ep-f");
-			if (ep && usb_gadget_ep_match_desc(gadget,
-					ep, desc, ep_comp))
-				goto found_ep;
-		}
-
-		/* USB3380: use same address for usb and hardware endpoints */
-		snprintf(name, sizeof(name), "ep%d%s", usb_endpoint_num(desc),
-				usb_endpoint_dir_in(desc) ? "in" : "out");
-		ep = gadget_find_ep_by_name(gadget, name);
-		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
-			goto found_ep;
-	} else if (gadget_is_goku (gadget)) {
+	if (gadget_is_goku(gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */
 			ep = gadget_find_ep_by_name(gadget, "ep3-bulk");

commit b0aea0037c8896b8e69cad3f6e828782789c1edf
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:12 2015 +0200

    usb: gadget: move find_ep() from epautoconf to udc-core
    
    Move find_ep() to udc-core and rename it to gadget_find_ep_by_name().
    It can be used in UDC drivers, especially in 'match_ep' callback after
    moving chip-specific endpoint matching logic from epautoconf to UDC
    drivers.
    
    Replace all calls of find_ep() function with gadget_find_ep_by_name().
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index d49af4fc8667..a39ca033b9ce 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -22,18 +22,6 @@
 
 #include "gadget_chips.h"
 
-static struct usb_ep *
-find_ep (struct usb_gadget *gadget, const char *name)
-{
-	struct usb_ep	*ep;
-
-	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (0 == strcmp (ep->name, name))
-			return ep;
-	}
-	return NULL;
-}
-
 /**
  * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
  * descriptor and ep companion descriptor
@@ -103,11 +91,11 @@ struct usb_ep *usb_ep_autoconfig_ss(
 
 		if (type == USB_ENDPOINT_XFER_INT) {
 			/* ep-e, ep-f are PIO with only 64 byte fifos */
-			ep = find_ep(gadget, "ep-e");
+			ep = gadget_find_ep_by_name(gadget, "ep-e");
 			if (ep && usb_gadget_ep_match_desc(gadget,
 					ep, desc, ep_comp))
 				goto found_ep;
-			ep = find_ep(gadget, "ep-f");
+			ep = gadget_find_ep_by_name(gadget, "ep-f");
 			if (ep && usb_gadget_ep_match_desc(gadget,
 					ep, desc, ep_comp))
 				goto found_ep;
@@ -116,20 +104,20 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		/* USB3380: use same address for usb and hardware endpoints */
 		snprintf(name, sizeof(name), "ep%d%s", usb_endpoint_num(desc),
 				usb_endpoint_dir_in(desc) ? "in" : "out");
-		ep = find_ep(gadget, name);
+		ep = gadget_find_ep_by_name(gadget, name);
 		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	} else if (gadget_is_goku (gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */
-			ep = find_ep(gadget, "ep3-bulk");
+			ep = gadget_find_ep_by_name(gadget, "ep3-bulk");
 			if (ep && usb_gadget_ep_match_desc(gadget,
 					ep, desc, ep_comp))
 				goto found_ep;
 		} else if (USB_ENDPOINT_XFER_BULK == type
 				&& (USB_DIR_IN & desc->bEndpointAddress)) {
 			/* DMA may be available */
-			ep = find_ep(gadget, "ep2-bulk");
+			ep = gadget_find_ep_by_name(gadget, "ep2-bulk");
 			if (ep && usb_gadget_ep_match_desc(gadget,
 					ep, desc, ep_comp))
 				goto found_ep;
@@ -140,14 +128,14 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		if ((USB_ENDPOINT_XFER_BULK == type) ||
 		    (USB_ENDPOINT_XFER_ISOC == type)) {
 			if (USB_DIR_IN & desc->bEndpointAddress)
-				ep = find_ep (gadget, "ep5in");
+				ep = gadget_find_ep_by_name(gadget, "ep5in");
 			else
-				ep = find_ep (gadget, "ep6out");
+				ep = gadget_find_ep_by_name(gadget, "ep6out");
 		} else if (USB_ENDPOINT_XFER_INT == type) {
 			if (USB_DIR_IN & desc->bEndpointAddress)
-				ep = find_ep(gadget, "ep1in");
+				ep = gadget_find_ep_by_name(gadget, "ep1in");
 			else
-				ep = find_ep(gadget, "ep2out");
+				ep = gadget_find_ep_by_name(gadget, "ep2out");
 		} else
 			ep = NULL;
 		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))

commit 4278c687f697b651ab0c771114564da5ed006f22
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:11 2015 +0200

    usb: gadget: move ep_matches() from epautoconf to udc-core
    
    Move ep_matches() function to udc-core and rename it to
    usb_gadget_ep_match_desc(). This function can be used by UDC drivers
    in 'match_ep' callback to avoid writing lots of repetitive code.
    
    Replace all calls of ep_matches() with usb_gadget_ep_match_desc().
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index f000c73319f4..d49af4fc8667 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -22,82 +22,6 @@
 
 #include "gadget_chips.h"
 
-static int
-ep_matches (
-	struct usb_gadget		*gadget,
-	struct usb_ep			*ep,
-	struct usb_endpoint_descriptor	*desc,
-	struct usb_ss_ep_comp_descriptor *ep_comp
-)
-{
-	u8		type;
-	u16		max;
-	int		num_req_streams = 0;
-
-	/* endpoint already claimed? */
-	if (ep->claimed)
-		return 0;
-
-	type = usb_endpoint_type(desc);
-	max = 0x7ff & usb_endpoint_maxp(desc);
-
-	if (usb_endpoint_dir_in(desc) && !ep->caps.dir_in)
-		return 0;
-	if (usb_endpoint_dir_out(desc) && !ep->caps.dir_out)
-		return 0;
-
-	if (max > ep->maxpacket_limit)
-		return 0;
-
-	/* "high bandwidth" works only at high speed */
-	if (!gadget_is_dualspeed(gadget) && usb_endpoint_maxp(desc) & (3<<11))
-		return 0;
-
-	switch (type) {
-	case USB_ENDPOINT_XFER_CONTROL:
-		/* only support ep0 for portable CONTROL traffic */
-		return 0;
-	case USB_ENDPOINT_XFER_ISOC:
-		if (!ep->caps.type_iso)
-			return 0;
-		/* ISO:  limit 1023 bytes full speed,
-		 * 1024 high/super speed
-		 */
-		if (!gadget_is_dualspeed(gadget) && max > 1023)
-			return 0;
-		break;
-	case USB_ENDPOINT_XFER_BULK:
-		if (!ep->caps.type_bulk)
-			return 0;
-		if (ep_comp && gadget_is_superspeed(gadget)) {
-			/* Get the number of required streams from the
-			 * EP companion descriptor and see if the EP
-			 * matches it
-			 */
-			num_req_streams = ep_comp->bmAttributes & 0x1f;
-			if (num_req_streams > ep->max_streams)
-				return 0;
-		}
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		/* Bulk endpoints handle interrupt transfers,
-		 * except the toggle-quirky iso-synch kind
-		 */
-		if (!ep->caps.type_int && !ep->caps.type_bulk)
-			return 0;
-		/* INT:  limit 64 bytes full speed,
-		 * 1024 high/super speed
-		 */
-		if (!gadget_is_dualspeed(gadget) && max > 64)
-			return 0;
-		break;
-	}
-
-	/* MATCH!! */
-
-	return 1;
-}
-
 static struct usb_ep *
 find_ep (struct usb_gadget *gadget, const char *name)
 {
@@ -180,10 +104,12 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		if (type == USB_ENDPOINT_XFER_INT) {
 			/* ep-e, ep-f are PIO with only 64 byte fifos */
 			ep = find_ep(gadget, "ep-e");
-			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			if (ep && usb_gadget_ep_match_desc(gadget,
+					ep, desc, ep_comp))
 				goto found_ep;
 			ep = find_ep(gadget, "ep-f");
-			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			if (ep && usb_gadget_ep_match_desc(gadget,
+					ep, desc, ep_comp))
 				goto found_ep;
 		}
 
@@ -191,20 +117,21 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		snprintf(name, sizeof(name), "ep%d%s", usb_endpoint_num(desc),
 				usb_endpoint_dir_in(desc) ? "in" : "out");
 		ep = find_ep(gadget, name);
-		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	} else if (gadget_is_goku (gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */
 			ep = find_ep(gadget, "ep3-bulk");
-			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			if (ep && usb_gadget_ep_match_desc(gadget,
+					ep, desc, ep_comp))
 				goto found_ep;
 		} else if (USB_ENDPOINT_XFER_BULK == type
 				&& (USB_DIR_IN & desc->bEndpointAddress)) {
 			/* DMA may be available */
 			ep = find_ep(gadget, "ep2-bulk");
-			if (ep && ep_matches(gadget, ep, desc,
-					      ep_comp))
+			if (ep && usb_gadget_ep_match_desc(gadget,
+					ep, desc, ep_comp))
 				goto found_ep;
 		}
 
@@ -223,14 +150,14 @@ struct usb_ep *usb_ep_autoconfig_ss(
 				ep = find_ep(gadget, "ep2out");
 		} else
 			ep = NULL;
-		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+		if (ep && usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
 			goto found_ep;
 #endif
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (ep_matches(gadget, ep, desc, ep_comp))
+		if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	}
 

commit 596c154d62330ea0bb4e3c3e50afa3682e50b617
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:10 2015 +0200

    usb: gadget: add 'ep_match' callback to usb_gadget_ops
    
    Add callback that is called by epautoconf to allow UDC driver match the
    best endpoint for specific descriptor. It's intended to supply mechanism
    which allows to get rid of chip-specific endpoint matching code from
    epautoconf.
    
    If gadget has set 'ep_match' callback we prefer to call it first, and
    if it fails to find matching endpoint, then we try to use default matching
    algorithm.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 95e12759af4d..f000c73319f4 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -165,6 +165,12 @@ struct usb_ep *usb_ep_autoconfig_ss(
 
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
+	if (gadget->ops->match_ep) {
+		ep = gadget->ops->match_ep(gadget, desc, ep_comp);
+		if (ep)
+			goto found_ep;
+	}
+
 	/* First, apply chip-specific "best usage" knowledge.
 	 * This might make a good usb_gadget_ops hook ...
 	 */

commit 26bf956aa9952a8141a12f314df70dcd020572d6
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:09 2015 +0200

    usb: gadget: epautoconf: rework ep_matches() function
    
    Rework ep_matches() function to make it shorter and more readable.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 52658fe761d4..95e12759af4d 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -32,7 +32,6 @@ ep_matches (
 {
 	u8		type;
 	u16		max;
-
 	int		num_req_streams = 0;
 
 	/* endpoint already claimed? */
@@ -40,6 +39,20 @@ ep_matches (
 		return 0;
 
 	type = usb_endpoint_type(desc);
+	max = 0x7ff & usb_endpoint_maxp(desc);
+
+	if (usb_endpoint_dir_in(desc) && !ep->caps.dir_in)
+		return 0;
+	if (usb_endpoint_dir_out(desc) && !ep->caps.dir_out)
+		return 0;
+
+	if (max > ep->maxpacket_limit)
+		return 0;
+
+	/* "high bandwidth" works only at high speed */
+	if (!gadget_is_dualspeed(gadget) && usb_endpoint_maxp(desc) & (3<<11))
+		return 0;
+
 	switch (type) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		/* only support ep0 for portable CONTROL traffic */
@@ -47,66 +60,36 @@ ep_matches (
 	case USB_ENDPOINT_XFER_ISOC:
 		if (!ep->caps.type_iso)
 			return 0;
+		/* ISO:  limit 1023 bytes full speed,
+		 * 1024 high/super speed
+		 */
+		if (!gadget_is_dualspeed(gadget) && max > 1023)
+			return 0;
 		break;
 	case USB_ENDPOINT_XFER_BULK:
 		if (!ep->caps.type_bulk)
 			return 0;
+		if (ep_comp && gadget_is_superspeed(gadget)) {
+			/* Get the number of required streams from the
+			 * EP companion descriptor and see if the EP
+			 * matches it
+			 */
+			num_req_streams = ep_comp->bmAttributes & 0x1f;
+			if (num_req_streams > ep->max_streams)
+				return 0;
+		}
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		/* bulk endpoints handle interrupt transfers,
+		/* Bulk endpoints handle interrupt transfers,
 		 * except the toggle-quirky iso-synch kind
 		 */
 		if (!ep->caps.type_int && !ep->caps.type_bulk)
 			return 0;
-		break;
-	}
-
-	if (usb_endpoint_dir_in(desc)) {
-		if (!ep->caps.dir_in)
-			return 0;
-	} else {
-		if (!ep->caps.dir_out)
-			return 0;
-	}
-
-	/*
-	 * Get the number of required streams from the EP companion
-	 * descriptor and see if the EP matches it
-	 */
-	if (usb_endpoint_xfer_bulk(desc)) {
-		if (ep_comp && gadget->max_speed >= USB_SPEED_SUPER) {
-			num_req_streams = ep_comp->bmAttributes & 0x1f;
-			if (num_req_streams > ep->max_streams)
-				return 0;
-		}
-
-	}
-
-	/* endpoint maxpacket size is an input parameter, except for bulk
-	 * where it's an output parameter representing the full speed limit.
-	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
-	 */
-	max = 0x7ff & usb_endpoint_maxp(desc);
-	switch (type) {
-	case USB_ENDPOINT_XFER_INT:
-		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
+		/* INT:  limit 64 bytes full speed,
+		 * 1024 high/super speed
+		 */
 		if (!gadget_is_dualspeed(gadget) && max > 64)
 			return 0;
-		/* FALLTHROUGH */
-
-	case USB_ENDPOINT_XFER_ISOC:
-		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
-		if (ep->maxpacket_limit < max)
-			return 0;
-		if (!gadget_is_dualspeed(gadget) && max > 1023)
-			return 0;
-
-		/* BOTH:  "high bandwidth" works only at high speed */
-		if ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {
-			if (!gadget_is_dualspeed(gadget))
-				return 0;
-			/* configure your hardware with enough buffering!! */
-		}
 		break;
 	}
 

commit 5dbe135a153837ce9367bdfacf7aabfc6fb76f4b
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jul 31 16:00:51 2015 +0200

    usb: gadget: epautoconf: remove ep and desc configuration from ep_matches()
    
    As function ep_matches() is used to match endpoint with usb descriptor it's
    highly unintuitive that it modifies endpoint and descriptor structures fields.
    This patch moves code configuring ep and desc from ep_matches() to
    usb_ep_autoconfig_ss(), so now function ep_matches() does nothing more than
    its name suggests.
    
    [ balbi@ti.com : fix build warning ]
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 4f66e9d733cd..52658fe761d4 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -82,13 +82,6 @@ ep_matches (
 
 	}
 
-	/*
-	 * If the protocol driver hasn't yet decided on wMaxPacketSize
-	 * and wants to know the maximum possible, provide the info.
-	 */
-	if (desc->wMaxPacketSize == 0)
-		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
-
 	/* endpoint maxpacket size is an input parameter, except for bulk
 	 * where it's an output parameter representing the full speed limit.
 	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
@@ -119,31 +112,6 @@ ep_matches (
 
 	/* MATCH!! */
 
-	/* report address */
-	desc->bEndpointAddress &= USB_DIR_IN;
-	if (isdigit (ep->name [2])) {
-		u8	num = simple_strtoul (&ep->name [2], NULL, 10);
-		desc->bEndpointAddress |= num;
-	} else if (desc->bEndpointAddress & USB_DIR_IN) {
-		if (++gadget->in_epnum > 15)
-			return 0;
-		desc->bEndpointAddress = USB_DIR_IN | gadget->in_epnum;
-	} else {
-		if (++gadget->out_epnum > 15)
-			return 0;
-		desc->bEndpointAddress |= gadget->out_epnum;
-	}
-
-	/* report (variable) full speed bulk maxpacket */
-	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
-		int size = ep->maxpacket_limit;
-
-		/* min() doesn't work on bitfields with gcc-3.5 */
-		if (size > 64)
-			size = 64;
-		desc->wMaxPacketSize = cpu_to_le16(size);
-	}
-	ep->address = desc->bEndpointAddress;
 	return 1;
 }
 
@@ -280,6 +248,40 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	/* Fail */
 	return NULL;
 found_ep:
+
+	/*
+	 * If the protocol driver hasn't yet decided on wMaxPacketSize
+	 * and wants to know the maximum possible, provide the info.
+	 */
+	if (desc->wMaxPacketSize == 0)
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
+
+	/* report address */
+	desc->bEndpointAddress &= USB_DIR_IN;
+	if (isdigit(ep->name[2])) {
+		u8 num = simple_strtoul(&ep->name[2], NULL, 10);
+		desc->bEndpointAddress |= num;
+	} else if (desc->bEndpointAddress & USB_DIR_IN) {
+		if (++gadget->in_epnum > 15)
+			return NULL;
+		desc->bEndpointAddress = USB_DIR_IN | gadget->in_epnum;
+	} else {
+		if (++gadget->out_epnum > 15)
+			return NULL;
+		desc->bEndpointAddress |= gadget->out_epnum;
+	}
+
+	/* report (variable) full speed bulk maxpacket */
+	if ((type == USB_ENDPOINT_XFER_BULK) && !ep_comp) {
+		int size = ep->maxpacket_limit;
+
+		/* min() doesn't work on bitfields with gcc-3.5 */
+		if (size > 64)
+			size = 64;
+		desc->wMaxPacketSize = cpu_to_le16(size);
+	}
+
+	ep->address = desc->bEndpointAddress;
 	ep->desc = NULL;
 	ep->comp_desc = NULL;
 	ep->claimed = true;

commit b58713d53a8f41d57b24c93de0b1c7e9550ba70f
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jul 31 16:00:50 2015 +0200

    usb: gadget: epautoconf: remove pxa quirk from ep_matches()
    
    The same effect can be achieved by using capabilities flags, so now we can
    get rid of handling of hardware specific limitations in generic code.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index af4b10a9068e..4f66e9d733cd 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -58,11 +58,6 @@ ep_matches (
 		 */
 		if (!ep->caps.type_int && !ep->caps.type_bulk)
 			return 0;
-		/* for now, avoid PXA "interrupt-in";
-		 * it's documented as never using DATA1.
-		 */
-		if (gadget_is_pxa(gadget) && ep->caps.type_int)
-			return 0;
 		break;
 	}
 

commit b86f33a3a371a4c3aa8dbb2f4125634a4e0d09dc
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jul 31 16:00:49 2015 +0200

    usb: gadget: epautoconf: add endpoint capabilities flags verification
    
    Introduce endpoint matching mechanism basing on endpoint capabilities
    flags. We check if endpoint supports transfer type and direction requested
    in ep descriptor. Since we have this new endpoint matching mechanism
    there is no need to have old code guessing endpoint capabilities basing
    on its name, so we are getting rid of it. Remove also the obsolete comment.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 8e00ca765549..af4b10a9068e 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -22,22 +22,6 @@
 
 #include "gadget_chips.h"
 
-/*
- * This should work with endpoints from controller drivers sharing the
- * same endpoint naming convention.  By example:
- *
- *	- ep1, ep2, ... address is fixed, not direction or type
- *	- ep1in, ep2out, ... address and direction are fixed, not type
- *	- ep1-bulk, ep2-bulk, ... address and type are fixed, not direction
- *	- ep1in-bulk, ep2out-iso, ... all three are fixed
- *	- ep-* ... no functionality restrictions
- *
- * Type suffixes are "-bulk", "-iso", or "-int".  Numbers are decimal.
- * Less common restrictions are implied by gadget_is_*().
- *
- * NOTE:  each endpoint is unidirectional, as specified by its USB
- * descriptor; and isn't specific to a configuration or altsetting.
- */
 static int
 ep_matches (
 	struct usb_gadget		*gadget,
@@ -47,7 +31,6 @@ ep_matches (
 )
 {
 	u8		type;
-	const char	*tmp;
 	u16		max;
 
 	int		num_req_streams = 0;
@@ -56,58 +39,39 @@ ep_matches (
 	if (ep->claimed)
 		return 0;
 
-	/* only support ep0 for portable CONTROL traffic */
 	type = usb_endpoint_type(desc);
-	if (USB_ENDPOINT_XFER_CONTROL == type)
-		return 0;
-
-	/* some other naming convention */
-	if ('e' != ep->name[0])
+	switch (type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		/* only support ep0 for portable CONTROL traffic */
 		return 0;
+	case USB_ENDPOINT_XFER_ISOC:
+		if (!ep->caps.type_iso)
+			return 0;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		if (!ep->caps.type_bulk)
+			return 0;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		/* bulk endpoints handle interrupt transfers,
+		 * except the toggle-quirky iso-synch kind
+		 */
+		if (!ep->caps.type_int && !ep->caps.type_bulk)
+			return 0;
+		/* for now, avoid PXA "interrupt-in";
+		 * it's documented as never using DATA1.
+		 */
+		if (gadget_is_pxa(gadget) && ep->caps.type_int)
+			return 0;
+		break;
+	}
 
-	/* type-restriction:  "-iso", "-bulk", or "-int".
-	 * direction-restriction:  "in", "out".
-	 */
-	if ('-' != ep->name[2]) {
-		tmp = strrchr (ep->name, '-');
-		if (tmp) {
-			switch (type) {
-			case USB_ENDPOINT_XFER_INT:
-				/* bulk endpoints handle interrupt transfers,
-				 * except the toggle-quirky iso-synch kind
-				 */
-				if ('s' == tmp[2])	// == "-iso"
-					return 0;
-				/* for now, avoid PXA "interrupt-in";
-				 * it's documented as never using DATA1.
-				 */
-				if (gadget_is_pxa (gadget)
-						&& 'i' == tmp [1])
-					return 0;
-				break;
-			case USB_ENDPOINT_XFER_BULK:
-				if ('b' != tmp[1])	// != "-bulk"
-					return 0;
-				break;
-			case USB_ENDPOINT_XFER_ISOC:
-				if ('s' != tmp[2])	// != "-iso"
-					return 0;
-			}
-		} else {
-			tmp = ep->name + strlen (ep->name);
-		}
-
-		/* direction-restriction:  "..in-..", "out-.." */
-		tmp--;
-		if (!isdigit (*tmp)) {
-			if (desc->bEndpointAddress & USB_DIR_IN) {
-				if ('n' != *tmp)
-					return 0;
-			} else {
-				if ('t' != *tmp)
-					return 0;
-			}
-		}
+	if (usb_endpoint_dir_in(desc)) {
+		if (!ep->caps.dir_in)
+			return 0;
+	} else {
+		if (!ep->caps.dir_out)
+			return 0;
 	}
 
 	/*

commit cc476b42a39d5a66d94f46cade972dcb8ee278df
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jul 31 16:00:13 2015 +0200

    usb: gadget: encapsulate endpoint claiming mechanism
    
    So far it was necessary for usb functions to set ep->driver_data in
    endpoint obtained from autoconfig to non-null value, to indicate that
    endpoint is claimed by function (in autoconfig it was checked if endpoint
    has set this field to non-null value, and if it has, it was assumed that
    it is claimed). It could cause bugs because if some function doesn't
    set this field autoconfig could return the same endpoint more than one
    time.
    
    To help to avoid such bugs this patch adds claimed flag to struct usb_ep,
    and  encapsulates endpoint claiming mechanism inside usb_ep_autoconfig_ss()
    and usb_ep_autoconfig_reset(), so now usb functions don't need to perform
    any additional actions to mark endpoint obtained from autoconfig as claimed.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 919cdfdda78b..8e00ca765549 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -53,7 +53,7 @@ ep_matches (
 	int		num_req_streams = 0;
 
 	/* endpoint already claimed? */
-	if (NULL != ep->driver_data)
+	if (ep->claimed)
 		return 0;
 
 	/* only support ep0 for portable CONTROL traffic */
@@ -240,7 +240,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
  * updated with the assigned number of streams if it is
  * different from the original value. To prevent the endpoint
  * from being returned by a later autoconfig call, claim it by
- * assigning ep->driver_data to some non-null value.
+ * assigning ep->claimed to true.
  *
  * On failure, this returns a null endpoint descriptor.
  */
@@ -323,6 +323,7 @@ struct usb_ep *usb_ep_autoconfig_ss(
 found_ep:
 	ep->desc = NULL;
 	ep->comp_desc = NULL;
+	ep->claimed = true;
 	return ep;
 }
 EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
@@ -354,7 +355,7 @@ EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
  * is initialized as if the endpoint were used at full speed.  To prevent
  * the endpoint from being returned by a later autoconfig call, claim it
- * by assigning ep->driver_data to some non-null value.
+ * by assigning ep->claimed to true.
  *
  * On failure, this returns a null endpoint descriptor.
  */
@@ -373,7 +374,7 @@ EXPORT_SYMBOL_GPL(usb_ep_autoconfig);
  *
  * Use this for devices where one configuration may need to assign
  * endpoint resources very differently from the next one.  It clears
- * state such as ep->driver_data and the record of assigned endpoints
+ * state such as ep->claimed and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
 void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
@@ -381,7 +382,7 @@ void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 	struct usb_ep	*ep;
 
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		ep->driver_data = NULL;
+		ep->claimed = false;
 	}
 	gadget->in_epnum = 0;
 	gadget->out_epnum = 0;

commit e9ab4d0ab8f5b1159558b9ab236e408d50962a00
Author: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
Date:   Sat May 16 22:33:37 2015 +0200

    usb: gadget: autoconf: net2280: match hardware and usb ep address
    
    USB3380 GPEP can be used in IN and OUT directions however, both
    directions should use same endpoint address. Fulfil this requirement
    by mapping usb endpoint to hardware endpoint with the same address.
    
    Tested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0567cca1465e..919cdfdda78b 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -258,15 +258,25 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	/* First, apply chip-specific "best usage" knowledge.
 	 * This might make a good usb_gadget_ops hook ...
 	 */
-	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
-		/* ep-e, ep-f are PIO with only 64 byte fifos */
-		ep = find_ep (gadget, "ep-e");
-		if (ep && ep_matches(gadget, ep, desc, ep_comp))
-			goto found_ep;
-		ep = find_ep (gadget, "ep-f");
+	if (gadget_is_net2280(gadget)) {
+		char name[8];
+
+		if (type == USB_ENDPOINT_XFER_INT) {
+			/* ep-e, ep-f are PIO with only 64 byte fifos */
+			ep = find_ep(gadget, "ep-e");
+			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+				goto found_ep;
+			ep = find_ep(gadget, "ep-f");
+			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+				goto found_ep;
+		}
+
+		/* USB3380: use same address for usb and hardware endpoints */
+		snprintf(name, sizeof(name), "ep%d%s", usb_endpoint_num(desc),
+				usb_endpoint_dir_in(desc) ? "in" : "out");
+		ep = find_ep(gadget, name);
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
-
 	} else if (gadget_is_goku (gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 358de320afb0..0567cca1465e 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -11,7 +11,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/types.h>
 #include <linux/device.h>
 

commit e117e742d310683b410951faeab4b13b6c3c609f
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Dec 13 12:23:38 2013 +0100

    usb: gadget: add "maxpacket_limit" field to struct usb_ep
    
    This patch adds "maxpacket_limit" to struct usb_ep. This field contains
    maximum value of maxpacket supported by driver, and is set in driver probe.
    This value should be used by autoconfig() function, because value of field
    "maxpacket" is set to value from endpoint descriptor when endpoint becomes
    enabled. So when autoconfig() function will be called again for this endpoint,
    "maxpacket" value will contain wMaxPacketSize from descriptior instead of
    maximum packet size for this endpoint.
    
    For this reason this patch adds new field "maxpacket_limit" which contains
    value of maximum packet size (which defines maximum endpoint capabilities).
    This value is used in ep_matches() function used by autoconfig().
    
    Value of "maxpacket_limit" should be set in UDC driver probe function, using
    usb_ep_set_maxpacket_limit() function, defined in gadget.h. This function
    set choosen value to both "maxpacket_limit" and "maxpacket" fields.
    
    This patch modifies UDC drivers by adding support for maxpacket_limit.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index feaaa7b72ee3..358de320afb0 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -129,7 +129,7 @@ ep_matches (
 	 * and wants to know the maximum possible, provide the info.
 	 */
 	if (desc->wMaxPacketSize == 0)
-		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket);
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
 
 	/* endpoint maxpacket size is an input parameter, except for bulk
 	 * where it's an output parameter representing the full speed limit.
@@ -145,7 +145,7 @@ ep_matches (
 
 	case USB_ENDPOINT_XFER_ISOC:
 		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
-		if (ep->maxpacket < max)
+		if (ep->maxpacket_limit < max)
 			return 0;
 		if (!gadget_is_dualspeed(gadget) && max > 1023)
 			return 0;
@@ -178,7 +178,7 @@ ep_matches (
 
 	/* report (variable) full speed bulk maxpacket */
 	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
-		int size = ep->maxpacket;
+		int size = ep->maxpacket_limit;
 
 		/* min() doesn't work on bitfields with gcc-3.5 */
 		if (size > 64)

commit c3505f04582f3fee1452613c7d36a1811e524ab4
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Nov 8 12:39:29 2013 -0600

    usb: gadget: epautoconf: switch over to usb_endpoint_type()
    
    we have a helper to fetch endpoint type out of
    a descriptor, let's use it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index a777f7bd11b4..feaaa7b72ee3 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -58,7 +58,7 @@ ep_matches (
 		return 0;
 
 	/* only support ep0 for portable CONTROL traffic */
-	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	type = usb_endpoint_type(desc);
 	if (USB_ENDPOINT_XFER_CONTROL == type)
 		return 0;
 

commit dc995fc27c2e1c8edebfb2405ede23bd38153f7f
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:12 2012 +0200

    usb: gadget: libcomposite: add epautoconf.c to libcomposite
    
    This patch adds epautoconf.c into libcomposite and updates all gadgets.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index d5a905dbed00..a777f7bd11b4 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/device.h>
@@ -315,6 +316,7 @@ struct usb_ep *usb_ep_autoconfig_ss(
 	ep->comp_desc = NULL;
 	return ep;
 }
+EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
 
 /**
  * usb_ep_autoconfig() - choose an endpoint matching the
@@ -354,7 +356,7 @@ struct usb_ep *usb_ep_autoconfig(
 {
 	return usb_ep_autoconfig_ss(gadget, desc, NULL);
 }
-
+EXPORT_SYMBOL_GPL(usb_ep_autoconfig);
 
 /**
  * usb_ep_autoconfig_reset - reset endpoint autoconfig state
@@ -375,4 +377,4 @@ void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 	gadget->in_epnum = 0;
 	gadget->out_epnum = 0;
 }
-
+EXPORT_SYMBOL_GPL(usb_ep_autoconfig_reset);

commit e87bb7118c4f752de4616a7ab56c51ed3e7f6f53
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 6 20:11:11 2012 +0200

    usb: gadget: move global vars from epautoconf into struct usb_gadget
    
    epautoconf has two global variables which count the endpoint number of
    last assigned endpoint.
    This patch removes the global variable and keeps it as per (UDC) gadget.
    While here, the ifdef is removed and now the in and outpoint are
    enumerated unconditionally. The dwc3 for instance supports 32 endpoints
    in total.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 51f3d42f5a64..d5a905dbed00 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -22,17 +22,6 @@
 
 #include "gadget_chips.h"
 
-
-/* we must assign addresses for configurable endpoints (like net2280) */
-static unsigned epnum;
-
-// #define MANY_ENDPOINTS
-#ifdef MANY_ENDPOINTS
-/* more than 15 configurable endpoints */
-static unsigned in_epnum;
-#endif
-
-
 /*
  * This should work with endpoints from controller drivers sharing the
  * same endpoint naming convention.  By example:
@@ -176,16 +165,14 @@ ep_matches (
 	if (isdigit (ep->name [2])) {
 		u8	num = simple_strtoul (&ep->name [2], NULL, 10);
 		desc->bEndpointAddress |= num;
-#ifdef	MANY_ENDPOINTS
 	} else if (desc->bEndpointAddress & USB_DIR_IN) {
-		if (++in_epnum > 15)
+		if (++gadget->in_epnum > 15)
 			return 0;
-		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
-#endif
+		desc->bEndpointAddress = USB_DIR_IN | gadget->in_epnum;
 	} else {
-		if (++epnum > 15)
+		if (++gadget->out_epnum > 15)
 			return 0;
-		desc->bEndpointAddress |= epnum;
+		desc->bEndpointAddress |= gadget->out_epnum;
 	}
 
 	/* report (variable) full speed bulk maxpacket */
@@ -385,9 +372,7 @@ void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		ep->driver_data = NULL;
 	}
-#ifdef	MANY_ENDPOINTS
-	in_epnum = 0;
-#endif
-	epnum = 0;
+	gadget->in_epnum = 0;
+	gadget->out_epnum = 0;
 }
 

commit f9b0f5170918695891f42645737682ccb452ee13
Merge: 8062d94a5454 6440093f5eae
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 1 09:20:28 2012 -0800

    Merge tag 'gadget-for-v3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    USB: Gadget: changes for 3.4
    
    This merge is rather big. Here's what it contains:
    
    For am5536udc we have just simple coding style fixes. Nothing that has any
    potential to cause any issues going forward.
    
    With mv_udc, there's only one single change removing an unneeded NULL check.
    
    at91_udc also only saw a single change this merge window, and that's only
    removing a duplicated header.
    
    The Renesas controller has a few more involved changes. Support for SUDMAC was
    added, there's now a special handling of IRQ resources for when the IRQ line is
    shared between Renesas controller and SUDMAC, we also had a bug fix where
    Renesas controller would sleep in atomic context while doing DMA transfers from
    a tasklet. There were also a set of minor cleanups.
    
    The FSL UDC also had a scheduling in atomic context bug fix, but that's all.
    
    Thanks to Sebastian, the dummy_hcd now works better than ever with support for
    scatterlists and streams. Sebastian also added SuperSpeed descriptors to the
    serial gadgets.
    
    The highlight on this merge is the addition of a generic API for mapping and
    unmapping usb_requests. This will avoid code duplication on all UDC controllers
    and also kills all the defines for DMA_ADDR_INVALID which UDC controllers
    sprinkled around. A few of the UDC controllers were already converted to use
    this new API.
    
    Conflicts:
            drivers/usb/dwc3/gadget.c

commit 609ca228073ae06c5513474d2cdf0af7ee5766ec
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Feb 6 18:46:35 2012 +0100

    usb: gadget: clean the ep in autoconf before returning it.
    
    Since commit 72c973dd aka ("usb: gadget: add usb_endpoint_descriptor to
    struct usb_ep) the descriptor is part of the ep. Most gadgets like
    g_zero or masstorage call config_ep_by_speed() to grab an available
    endpoint which may be used for FS/HS/SS bulk/iso/intr and in a second
    they assign the proper descriptor by calling config_ep_by_speed(). This
    is good so far. A few of them like ncm call config_ep_by_speed() only if
    ep->desc not assigned earlier. That means ep->desc is never assigned if
    the endpoint was used by another gadget before it was removed.
    
    Some of those gadgets also assign ep->driver_data to NULL on reset or
    ep_disable part _but_ keep a reference to this endpoint. At ep_enable
    time they assign driver_data to their private data. This probably needs
    a clean up of its own.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 753aa0683ac1..f59f7e367b5a 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -275,24 +275,24 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		/* ep-e, ep-f are PIO with only 64 byte fifos */
 		ep = find_ep (gadget, "ep-e");
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
-			return ep;
+			goto found_ep;
 		ep = find_ep (gadget, "ep-f");
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
-			return ep;
+			goto found_ep;
 
 	} else if (gadget_is_goku (gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */
 			ep = find_ep(gadget, "ep3-bulk");
 			if (ep && ep_matches(gadget, ep, desc, ep_comp))
-				return ep;
+				goto found_ep;
 		} else if (USB_ENDPOINT_XFER_BULK == type
 				&& (USB_DIR_IN & desc->bEndpointAddress)) {
 			/* DMA may be available */
 			ep = find_ep(gadget, "ep2-bulk");
 			if (ep && ep_matches(gadget, ep, desc,
 					      ep_comp))
-				return ep;
+				goto found_ep;
 		}
 
 #ifdef CONFIG_BLACKFIN
@@ -311,18 +311,22 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		} else
 			ep = NULL;
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
-			return ep;
+			goto found_ep;
 #endif
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		if (ep_matches(gadget, ep, desc, ep_comp))
-			return ep;
+			goto found_ep;
 	}
 
 	/* Fail */
 	return NULL;
+found_ep:
+	ep->desc = NULL;
+	ep->comp_desc = NULL;
+	return ep;
 }
 
 /**

commit c74c930082fd407e3b9e503d855d78777a8e5a84
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Jan 11 21:42:44 2012 +0100

    usb: gadget: check for streams only for SS udcs
    
    Currently the UASP gadget fails to bind on an UDC which does not provide
    stream support. This is true for all udc in tree except for dummy and
    dwc3 since they don't support SuperSpeed.
    There is no need to test for the availability of stream support on those
    UDCs because we will never even try to use them. I think it is sane to
    assume that StreamSupport is always available on SuperSpeed since it is
    one of the key features.
    The host side will only allocate on SS so this part is also fine.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 753aa0683ac1..e0e6375ef5dd 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -126,7 +126,7 @@ ep_matches (
 	 * descriptor and see if the EP matches it
 	 */
 	if (usb_endpoint_xfer_bulk(desc)) {
-		if (ep_comp) {
+		if (ep_comp && gadget->max_speed >= USB_SPEED_SUPER) {
 			num_req_streams = ep_comp->bmAttributes & 0x1f;
 			if (num_req_streams > ep->max_streams)
 				return 0;

commit 55b81e6f2795484ea8edf5805c95c007cacfa736
Merge: 5983faf942f2 08e87d0d773d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 12:09:47 2012 -0800

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (232 commits)
      USB: Add USB-ID for Multiplex RC serial adapter to cp210x.c
      xhci: Clean up 32-bit build warnings.
      USB: update documentation for usbmon
      usb: usb-storage doesn't support dynamic id currently, the patch disables the feature to fix an oops
      drivers/usb/class/cdc-acm.c: clear dangling pointer
      drivers/usb/dwc3/dwc3-pci.c: introduce missing kfree
      drivers/usb/host/isp1760-if.c: introduce missing kfree
      usb: option: add ZD Incorporated HSPA modem
      usb: ch9: fix up MaxStreams helper
      USB: usb-skeleton.c: cleanup open_count
      USB: usb-skeleton.c: fix open/disconnect race
      xhci: Properly handle COMP_2ND_BW_ERR
      USB: remove dead code from suspend/resume path
      USB: add quirk for another camera
      drivers: usb: wusbcore: Fix dependency for USB_WUSB
      xhci: Better debugging for critical host errors.
      xhci: Be less verbose during URB cancellation.
      xhci: Remove debugging about ring structure allocation.
      xhci: Remove debugging about toggling cycle bits.
      xhci: Remove debugging for individual transfers.
      ...

commit 7422ba5343b8c1dbe1a517d0fcc15e7d671ca960
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Dec 19 13:45:01 2011 +0200

    usb: gadget: epautoconf: do not change number of streams
    
    We should not change gadget driver's descriptors just
    because we think it's right to do so.
    
    There are several of reasons which would support this
    statement but it suffices to say that this was probably
    never tested because it updates bmAttributes without
    asking the driver if it's ok to do so.
    
    This means that e.g. on UASP gadget it would enable
    stream support even for the command endpoint which must
    not have stream support enabled.
    
    In fact, this change is fixing the bug introduced by
    commit a59d6b9 (usb: gadget: add streams support to
    the gadget framework) which was caught when testing
    UASP gadget with dwc3 driver.
    
    Cc: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 596a0b464e61..4dff83d2f265 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -130,9 +130,6 @@ ep_matches (
 			num_req_streams = ep_comp->bmAttributes & 0x1f;
 			if (num_req_streams > ep->max_streams)
 				return 0;
-			/* Update the ep_comp descriptor if needed */
-			if (num_req_streams != ep->max_streams)
-				ep_comp->bmAttributes = ep->max_streams;
 		}
 
 	}

commit d327ab5b6d660d6fe22b073b743fde1668e593bb
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sat Nov 19 18:27:37 2011 +0100

    usb: gadget: replace usb_gadget::is_dualspeed with max_speed
    
    This commit replaces usb_gadget's is_dualspeed field with
    a max_speed field.
    
    [ balbi@ti.com : Fixed DWC3 driver ]
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 596a0b464e61..38bcbfb91f62 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -152,7 +152,7 @@ ep_matches (
 	switch (type) {
 	case USB_ENDPOINT_XFER_INT:
 		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
-		if (!gadget->is_dualspeed && max > 64)
+		if (!gadget_is_dualspeed(gadget) && max > 64)
 			return 0;
 		/* FALLTHROUGH */
 
@@ -160,12 +160,12 @@ ep_matches (
 		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
 		if (ep->maxpacket < max)
 			return 0;
-		if (!gadget->is_dualspeed && max > 1023)
+		if (!gadget_is_dualspeed(gadget) && max > 1023)
 			return 0;
 
 		/* BOTH:  "high bandwidth" works only at high speed */
 		if ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {
-			if (!gadget->is_dualspeed)
+			if (!gadget_is_dualspeed(gadget))
 				return 0;
 			/* configure your hardware with enough buffering!! */
 		}

commit 28c9fc68ebd32d473a8787d05c74e3f39c6c866b
Author: Klaus Schwarzkopf <schwarzkopf@sensortherm.de>
Date:   Fri Sep 9 16:10:44 2011 +0200

    usb gadget: clean up FSF boilerplate text
    
    remove the following two paragraphs as they are not needed:
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
    
    You should have received a copy of the GNU General Public License along with
    this program; if not, write to the Free Software Foundation, Inc.,59
    Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    
    Signed-off-by: Klaus Schwarzkopf <schwarzkopf@sensortherm.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index cdca7ebb7b48..596a0b464e61 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -7,16 +7,6 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  */
 
 #include <linux/kernel.h>

commit 29cc88979a8818cd8c5019426e945aed118b400e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 23 03:12:03 2011 -0700

    USB: use usb_endpoint_maxp() instead of le16_to_cpu()
    
    Now ${LINUX}/drivers/usb/* can use usb_endpoint_maxp(desc) to get maximum packet size
    instead of le16_to_cpu(desc->wMaxPacketSize).
    This patch fix it up
    
    Cc: Armin Fuerst <fuerst@in.tum.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Erdfelt <johannes@erdfelt.com>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: David Kubicek <dave@awk.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Brad Hards <bhards@bigpond.net.au>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Dahlmann <dahlmann.thomas@arcor.de>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: David Lopo <dlopo@chipidea.mips.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Xie Xiaobo <X.Xie@freescale.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Jiang Bo <tanya.jiang@freescale.com>
    Cc: Yuan-hsin Chen <yhchen@faraday-tech.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: OKI SEMICONDUCTOR, <toshiharu-linux@dsn.okisemi.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Herbert Ptzl <herbert@13thfloor.at>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Roman Weissgaerber <weissg@vienna.at>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: Florian Floe Echtler <echtler@fs.tum.de>
    Cc: Christian Lucht <lucht@codemercs.com>
    Cc: Juergen Stuber <starblue@sourceforge.net>
    Cc: Georges Toth <g.toth@e-biz.lu>
    Cc: Bill Ryder <bryder@sgi.com>
    Cc: Kuba Ober <kuba@mareimbrium.org>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 7a7e6b7e1fd6..cdca7ebb7b48 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -158,7 +158,7 @@ ep_matches (
 	 * where it's an output parameter representing the full speed limit.
 	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
 	 */
-	max = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
+	max = 0x7ff & usb_endpoint_maxp(desc);
 	switch (type) {
 	case USB_ENDPOINT_XFER_INT:
 		/* INT:  limit 64 bytes full speed, 1024 high/super speed */

commit bdb64d727216b49a18c2b8337658adc6b2db82ea
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Wed Jun 29 16:41:50 2011 +0300

    usb: gadget: add SuperSpeed support to the Gadget Framework
    
    SuperSpeed USB has defined a new descriptor, called
    the Binary Device Object Store (BOS) Descriptor. It
    has also changed a bit the definition of SET_FEATURE
    and GET_STATUS requests to add USB3-specific details.
    
    This patch implements both changes to the Composite
    Gadget Framework.
    
    [ balbi@ti.com : slight changes to commit log
                     fixed a compile error on ARM ]
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 91c032fbdf1c..7a7e6b7e1fd6 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -161,13 +161,13 @@ ep_matches (
 	max = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
 	switch (type) {
 	case USB_ENDPOINT_XFER_INT:
-		/* INT:  limit 64 bytes full speed, 1024 high speed */
+		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
 		if (!gadget->is_dualspeed && max > 64)
 			return 0;
 		/* FALLTHROUGH */
 
 	case USB_ENDPOINT_XFER_ISOC:
-		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
+		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
 		if (ep->maxpacket < max)
 			return 0;
 		if (!gadget->is_dualspeed && max > 1023)
@@ -202,7 +202,7 @@ ep_matches (
 	}
 
 	/* report (variable) full speed bulk maxpacket */
-	if (USB_ENDPOINT_XFER_BULK == type) {
+	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
 		int size = ep->maxpacket;
 
 		/* min() doesn't work on bitfields with gcc-3.5 */

commit a59d6b91cbca52235e3ed9f7f9e34c4f2f3e1996
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Tue Jun 28 16:33:53 2011 +0300

    usb: gadget: add streams support to the gadget framework
    
    This patch defines necessary fields to support
    streaming for USB3.0.
    
    It implements a new function, called
    usb_ep_autoconfig_ss(), to be used instead of the
    existing usb_ep_autoconfig() when working in
    SuperSpeed mode and there is a need to search for
    an endpoint according to the number of required
    streams.
    
    [ balbi@ti.com : slight changes to commit log ]
    
    Signed-off-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0022d44060ae..91c032fbdf1c 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -63,13 +63,16 @@ static int
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
-	struct usb_endpoint_descriptor	*desc
+	struct usb_endpoint_descriptor	*desc,
+	struct usb_ss_ep_comp_descriptor *ep_comp
 )
 {
 	u8		type;
 	const char	*tmp;
 	u16		max;
 
+	int		num_req_streams = 0;
+
 	/* endpoint already claimed? */
 	if (NULL != ep->driver_data)
 		return 0;
@@ -128,6 +131,22 @@ ep_matches (
 		}
 	}
 
+	/*
+	 * Get the number of required streams from the EP companion
+	 * descriptor and see if the EP matches it
+	 */
+	if (usb_endpoint_xfer_bulk(desc)) {
+		if (ep_comp) {
+			num_req_streams = ep_comp->bmAttributes & 0x1f;
+			if (num_req_streams > ep->max_streams)
+				return 0;
+			/* Update the ep_comp descriptor if needed */
+			if (num_req_streams != ep->max_streams)
+				ep_comp->bmAttributes = ep->max_streams;
+		}
+
+	}
+
 	/*
 	 * If the protocol driver hasn't yet decided on wMaxPacketSize
 	 * and wants to know the maximum possible, provide the info.
@@ -208,38 +227,53 @@ find_ep (struct usb_gadget *gadget, const char *name)
 }
 
 /**
- * usb_ep_autoconfig - choose an endpoint matching the descriptor
+ * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
+ * descriptor and ep companion descriptor
  * @gadget: The device to which the endpoint must belong.
  * @desc: Endpoint descriptor, with endpoint direction and transfer mode
- *	initialized.  For periodic transfers, the maximum packet
- *	size must also be initialized.  This is modified on success.
+ *    initialized.  For periodic transfers, the maximum packet
+ *    size must also be initialized.  This is modified on
+ *    success.
+ * @ep_comp: Endpoint companion descriptor, with the required
+ *    number of streams. Will be modified when the chosen EP
+ *    supports a different number of streams.
  *
- * By choosing an endpoint to use with the specified descriptor, this
- * routine simplifies writing gadget drivers that work with multiple
- * USB device controllers.  The endpoint would be passed later to
- * usb_ep_enable(), along with some descriptor.
+ * This routine replaces the usb_ep_autoconfig when needed
+ * superspeed enhancments. If such enhancemnets are required,
+ * the FD should call usb_ep_autoconfig_ss directly and provide
+ * the additional ep_comp parameter.
+ *
+ * By choosing an endpoint to use with the specified descriptor,
+ * this routine simplifies writing gadget drivers that work with
+ * multiple USB device controllers.  The endpoint would be
+ * passed later to usb_ep_enable(), along with some descriptor.
  *
  * That second descriptor won't always be the same as the first one.
  * For example, isochronous endpoints can be autoconfigured for high
  * bandwidth, and then used in several lower bandwidth altsettings.
  * Also, high and full speed descriptors will be different.
  *
- * Be sure to examine and test the results of autoconfiguration on your
- * hardware.  This code may not make the best choices about how to use the
- * USB controller, and it can't know all the restrictions that may apply.
- * Some combinations of driver and hardware won't be able to autoconfigure.
+ * Be sure to examine and test the results of autoconfiguration
+ * on your hardware.  This code may not make the best choices
+ * about how to use the USB controller, and it can't know all
+ * the restrictions that may apply. Some combinations of driver
+ * and hardware won't be able to autoconfigure.
  *
  * On success, this returns an un-claimed usb_ep, and modifies the endpoint
  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
- * is initialized as if the endpoint were used at full speed.  To prevent
- * the endpoint from being returned by a later autoconfig call, claim it
- * by assigning ep->driver_data to some non-null value.
+ * is initialized as if the endpoint were used at full speed and
+ * the bmAttribute field in the ep companion descriptor is
+ * updated with the assigned number of streams if it is
+ * different from the original value. To prevent the endpoint
+ * from being returned by a later autoconfig call, claim it by
+ * assigning ep->driver_data to some non-null value.
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep *usb_ep_autoconfig (
+struct usb_ep *usb_ep_autoconfig_ss(
 	struct usb_gadget		*gadget,
-	struct usb_endpoint_descriptor	*desc
+	struct usb_endpoint_descriptor	*desc,
+	struct usb_ss_ep_comp_descriptor *ep_comp
 )
 {
 	struct usb_ep	*ep;
@@ -253,23 +287,24 @@ struct usb_ep *usb_ep_autoconfig (
 	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
 		/* ep-e, ep-f are PIO with only 64 byte fifos */
 		ep = find_ep (gadget, "ep-e");
-		if (ep && ep_matches (gadget, ep, desc))
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			return ep;
 		ep = find_ep (gadget, "ep-f");
-		if (ep && ep_matches (gadget, ep, desc))
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			return ep;
 
 	} else if (gadget_is_goku (gadget)) {
 		if (USB_ENDPOINT_XFER_INT == type) {
 			/* single buffering is enough */
-			ep = find_ep (gadget, "ep3-bulk");
-			if (ep && ep_matches (gadget, ep, desc))
+			ep = find_ep(gadget, "ep3-bulk");
+			if (ep && ep_matches(gadget, ep, desc, ep_comp))
 				return ep;
 		} else if (USB_ENDPOINT_XFER_BULK == type
 				&& (USB_DIR_IN & desc->bEndpointAddress)) {
 			/* DMA may be available */
-			ep = find_ep (gadget, "ep2-bulk");
-			if (ep && ep_matches (gadget, ep, desc))
+			ep = find_ep(gadget, "ep2-bulk");
+			if (ep && ep_matches(gadget, ep, desc,
+					      ep_comp))
 				return ep;
 		}
 
@@ -288,14 +323,14 @@ struct usb_ep *usb_ep_autoconfig (
 				ep = find_ep(gadget, "ep2out");
 		} else
 			ep = NULL;
-		if (ep && ep_matches (gadget, ep, desc))
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			return ep;
 #endif
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (ep_matches (gadget, ep, desc))
+		if (ep_matches(gadget, ep, desc, ep_comp))
 			return ep;
 	}
 
@@ -303,6 +338,46 @@ struct usb_ep *usb_ep_autoconfig (
 	return NULL;
 }
 
+/**
+ * usb_ep_autoconfig() - choose an endpoint matching the
+ * descriptor
+ * @gadget: The device to which the endpoint must belong.
+ * @desc: Endpoint descriptor, with endpoint direction and transfer mode
+ *	initialized.  For periodic transfers, the maximum packet
+ *	size must also be initialized.  This is modified on success.
+ *
+ * By choosing an endpoint to use with the specified descriptor, this
+ * routine simplifies writing gadget drivers that work with multiple
+ * USB device controllers.  The endpoint would be passed later to
+ * usb_ep_enable(), along with some descriptor.
+ *
+ * That second descriptor won't always be the same as the first one.
+ * For example, isochronous endpoints can be autoconfigured for high
+ * bandwidth, and then used in several lower bandwidth altsettings.
+ * Also, high and full speed descriptors will be different.
+ *
+ * Be sure to examine and test the results of autoconfiguration on your
+ * hardware.  This code may not make the best choices about how to use the
+ * USB controller, and it can't know all the restrictions that may apply.
+ * Some combinations of driver and hardware won't be able to autoconfigure.
+ *
+ * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+ * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
+ * is initialized as if the endpoint were used at full speed.  To prevent
+ * the endpoint from being returned by a later autoconfig call, claim it
+ * by assigning ep->driver_data to some non-null value.
+ *
+ * On failure, this returns a null endpoint descriptor.
+ */
+struct usb_ep *usb_ep_autoconfig(
+	struct usb_gadget		*gadget,
+	struct usb_endpoint_descriptor	*desc
+)
+{
+	return usb_ep_autoconfig_ss(gadget, desc, NULL);
+}
+
+
 /**
  * usb_ep_autoconfig_reset - reset endpoint autoconfig state
  * @gadget: device for which autoconfig state will be reset

commit 48767a4e8263620c347c3fa17812c943dd0fc2fa
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Tue Jun 28 16:33:49 2011 +0300

    usb: gadget: configure endpoint according to gadget speed
    
    Add config_ep_by_speed() to configure the endpoint
    according to the gadget speed.
    
    Using this function will spare the FDs from handling
    the endpoint chosen descriptor.
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 9b7360ff5aa7..0022d44060ae 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -191,6 +191,7 @@ ep_matches (
 			size = 64;
 		desc->wMaxPacketSize = cpu_to_le16(size);
 	}
+	ep->address = desc->bEndpointAddress;
 	return 1;
 }
 

commit 553fbcde3481c98a076c9744a59ad08dbc61c099
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Fri Jan 14 11:55:53 2011 +0900

    USB: Gadget: Initialize wMaxPacketSize if not already set
    
    Currently, for ISO and INT, a protocol driver must chose the value for
    wMaxPacketSize arbitrarily. The value may be too low, resulting in lesser
    than efficient operation or high enough to not work with all UDC drivers.
    
    Take un-initialized wMaxPacketSize as a hint to provide maximum
    possible packetsize for the selected endpoint. The protocol may
    then choose a value not bigger than that.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 8a832488ccdd..9b7360ff5aa7 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -128,6 +128,13 @@ ep_matches (
 		}
 	}
 
+	/*
+	 * If the protocol driver hasn't yet decided on wMaxPacketSize
+	 * and wants to know the maximum possible, provide the info.
+	 */
+	if (desc->wMaxPacketSize == 0)
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket);
+
 	/* endpoint maxpacket size is an input parameter, except for bulk
 	 * where it's an output parameter representing the full speed limit.
 	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.

commit 28824b18ac4705e876a282a15ea0de8fc957551f
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Wed May 5 12:53:13 2010 +0200

    USB: gadget: __init and __exit tags removed
    
    __init, __initdata and __exit tags have have been removed from
    various files to make it possible for gadgets that do not use
    the __init/__exit tags to use those.
    
    Files in question are related to:
    * the core composite framework,
    * the mass storage function (fixing a section mismatch) and
    * ethernet driver (ACM, ECM, RNDIS).
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 3568de210f79..8a832488ccdd 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -34,12 +34,12 @@
 
 
 /* we must assign addresses for configurable endpoints (like net2280) */
-static __initdata unsigned epnum;
+static unsigned epnum;
 
 // #define MANY_ENDPOINTS
 #ifdef MANY_ENDPOINTS
 /* more than 15 configurable endpoints */
-static __initdata unsigned in_epnum;
+static unsigned in_epnum;
 #endif
 
 
@@ -59,7 +59,7 @@ static __initdata unsigned in_epnum;
  * NOTE:  each endpoint is unidirectional, as specified by its USB
  * descriptor; and isn't specific to a configuration or altsetting.
  */
-static int __init
+static int
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
@@ -187,7 +187,7 @@ ep_matches (
 	return 1;
 }
 
-static struct usb_ep * __init
+static struct usb_ep *
 find_ep (struct usb_gadget *gadget, const char *name)
 {
 	struct usb_ep	*ep;
@@ -229,7 +229,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep * __init usb_ep_autoconfig (
+struct usb_ep *usb_ep_autoconfig (
 	struct usb_gadget		*gadget,
 	struct usb_endpoint_descriptor	*desc
 )
@@ -304,7 +304,7 @@ struct usb_ep * __init usb_ep_autoconfig (
  * state such as ep->driver_data and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
-void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+void usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 {
 	struct usb_ep	*ep;
 

commit f2984a333fb5e325d478950c9d8af3693869e69c
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Tue Mar 9 00:35:22 2010 -0500

    USB: gadget: fix Blackfin builds after gadget cleansing
    
    The recent change to clean out dead gadget drivers (90f7976880bbbf99)
    missed the call to gadget_is_musbhsfc() behind CONFIG_BLACKFIN.  This
    causes Blackfin gadget builds to fail since the function no longer
    exists anywhere.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 65a5f94cbc04..3568de210f79 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -266,7 +266,7 @@ struct usb_ep * __init usb_ep_autoconfig (
 		}
 
 #ifdef CONFIG_BLACKFIN
-	} else if (gadget_is_musbhsfc(gadget) || gadget_is_musbhdrc(gadget)) {
+	} else if (gadget_is_musbhdrc(gadget)) {
 		if ((USB_ENDPOINT_XFER_BULK == type) ||
 		    (USB_ENDPOINT_XFER_ISOC == type)) {
 			if (USB_DIR_IN & desc->bEndpointAddress)

commit 90f7976880bbbf9968629500972f8e2f80401217
Author: Christoph Egger <siccegge@stud.informatik.uni-erlangen.de>
Date:   Fri Feb 5 13:24:12 2010 +0100

    USB: Remove unsupported usb gadget drivers
    
    A bunch of USB gadget drivers where never ported from the linux 2.4
    series to 2.6 kernels. However there's some code still in the tree for
    them which isn't used and is probably untested for ages.
    
    As the chance of these drivers being forward ported is probably quite
    small now it might be time to get rid of them.
    
    Signed-off-by: Christoph Egger <siccegge@stud.informatik.uni-erlangen.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 949ebe5e4c8d..65a5f94cbc04 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -265,17 +265,6 @@ struct usb_ep * __init usb_ep_autoconfig (
 				return ep;
 		}
 
-	} else if (gadget_is_sh (gadget) && USB_ENDPOINT_XFER_INT == type) {
-		/* single buffering is enough; maybe 8 byte fifo is too */
-		ep = find_ep (gadget, "ep3in-bulk");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-
-	} else if (gadget_is_mq11xx (gadget) && USB_ENDPOINT_XFER_INT == type) {
-		ep = find_ep (gadget, "ep1-bulk");
-		if (ep && ep_matches (gadget, ep, desc))
-			return ep;
-
 #ifdef CONFIG_BLACKFIN
 	} else if (gadget_is_musbhsfc(gadget) || gadget_is_musbhdrc(gadget)) {
 		if ((USB_ENDPOINT_XFER_BULK == type) ||

commit 767ffec15e25b34c7194e47f0ad1fbf63a568d44
Author: Cliff Cai <cliff.cai@analog.com>
Date:   Mon Dec 21 10:42:39 2009 -0500

    USB: gadget: add INT support for Blackfin musb
    
    Signed-off-by: Cliff Cai <cliff.cai@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 4671d5d7973d..949ebe5e4c8d 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -284,6 +284,11 @@ struct usb_ep * __init usb_ep_autoconfig (
 				ep = find_ep (gadget, "ep5in");
 			else
 				ep = find_ep (gadget, "ep6out");
+		} else if (USB_ENDPOINT_XFER_INT == type) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep(gadget, "ep1in");
+			else
+				ep = find_ep(gadget, "ep2out");
 		} else
 			ep = NULL;
 		if (ep && ep_matches (gadget, ep, desc))

commit 3a8a3b1cee6c525661732b8bcf29ac63d42945ed
Author: Bryan Wu <cooloney@kernel.org>
Date:   Mon Dec 21 10:43:06 2009 -0500

    USB: gadget: use ep5 for bulk-in and ep6 for bulk-out for Blackfin MUSB
    
    Normally, the musb uses ep1 as the bidirectional bulk endpoint.  This won't
    work on the Blackfin musb as all endpoints (except ep0) are unidirectional.
    Further, ep1-ep4 have a small 128 byte FIFO which makes them undesirable
    for bulk endpoints (which need more like a 512 byte FIFO).  This leaves us
    with ep5-ep7 which have 1024 byte FIFOs and can be configured as either
    in/out and bulk/interrupt/iso on the fly.
    
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Signed-off-by: Cliff Cai <cliff.cai@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index cd0914ec898e..4671d5d7973d 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -275,6 +275,20 @@ struct usb_ep * __init usb_ep_autoconfig (
 		ep = find_ep (gadget, "ep1-bulk");
 		if (ep && ep_matches (gadget, ep, desc))
 			return ep;
+
+#ifdef CONFIG_BLACKFIN
+	} else if (gadget_is_musbhsfc(gadget) || gadget_is_musbhdrc(gadget)) {
+		if ((USB_ENDPOINT_XFER_BULK == type) ||
+		    (USB_ENDPOINT_XFER_ISOC == type)) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep (gadget, "ep5in");
+			else
+				ep = find_ep (gadget, "ep6out");
+		} else
+			ep = NULL;
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+#endif
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */

commit 551509d267905705f6d723e51ec706916f06b859
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Feb 11 14:11:36 2009 -0800

    USB: replace uses of __constant_{endian}
    
    The base versions handle constant folding now.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index a36b1175b18d..cd0914ec898e 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -148,7 +148,7 @@ ep_matches (
 			return 0;
 
 		/* BOTH:  "high bandwidth" works only at high speed */
-		if ((desc->wMaxPacketSize & __constant_cpu_to_le16(3<<11))) {
+		if ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {
 			if (!gadget->is_dualspeed)
 				return 0;
 			/* configure your hardware with enough buffering!! */

commit bb9496c6f7e853e5d4edd5397c9d45f1968d623c
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Nov 25 14:15:19 2008 +0100

    USB: gadget: change simple_strtol to simple_strtoul
    
    Since num is unsigned, it would seem better to use simple_strtoul that
    simple_strtol.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r2@
    long e;
    position p;
    @@
    
    e = simple_strtol@p(...)
    
    @@
    position p != r2.p;
    type T;
    T e;
    @@
    
    e =
    - simple_strtol@p
    + simple_strtoul
      (...)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 9462e30192d8..a36b1175b18d 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -161,7 +161,7 @@ ep_matches (
 	/* report address */
 	desc->bEndpointAddress &= USB_DIR_IN;
 	if (isdigit (ep->name [2])) {
-		u8	num = simple_strtol (&ep->name [2], NULL, 10);
+		u8	num = simple_strtoul (&ep->name [2], NULL, 10);
 		desc->bEndpointAddress |= num;
 #ifdef	MANY_ENDPOINTS
 	} else if (desc->bEndpointAddress & USB_DIR_IN) {

commit a4c39c41bf3592684e36fa0dbbd4ab1a31f969b9
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Jun 19 17:52:25 2008 -0700

    usb gadget: descriptor copying support
    
    Define three new descriptor manipulation utilities, for use when
    setting up functions that may have multiple instances:
    
            usb_copy_descriptors() to copy a vector of descriptors
            usb_free_descriptors() to free the copy
            usb_find_endpoint() to find a copied version
    
    These will be used as follows.  Functions will continue to have static
    tables of descriptors they update, now used as __initdata templates.
    
    When a function creates a new instance, it patches those tables with
    relevant interface and string IDs, plus endpoint assignments.  Then it
    copies those morphed descriptors, associates the copies with the new
    function instance, and records the endpoint descriptors to use when
    activating the endpoints.  When initialization is done, only the copies
    remain in memory.  The copies are freed on driver removal.
    
    This ensures that each instance has descriptors which hold the right
    instance-specific data.  Two instances in the same configuration will
    obviously never share the same interface IDs or use the same endpoints.
    Instances in different configurations won't do so either, which means
    this is slightly less memory-efficient in some cases.
    
    This also includes a bugfix to the epautoconf code that shows up with
    this usage model.  It must replace the previous endpoint number when
    updating the template descriptors, not just mask in a few more bits.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 8bdad221fa91..9462e30192d8 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -159,6 +159,7 @@ ep_matches (
 	/* MATCH!! */
 
 	/* report address */
+	desc->bEndpointAddress &= USB_DIR_IN;
 	if (isdigit (ep->name [2])) {
 		u8	num = simple_strtol (&ep->name [2], NULL, 10);
 		desc->bEndpointAddress |= num;

commit 0e530b45783f75a29bde20bbf9e287c915a4f68b
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Apr 5 14:17:14 2008 -0700

    USB: gadget section fixes
    
    Restore some section annotations:  they were switched to "__devinit"
    while they should have been "__init", because of bogus warnings.  The
    warnings are now fixed, so the runtime footprint of various drivers
    can now shrink a bit.  On ARMv5, it's about 600 bytes except for the
    Ethernet gadget, where it can save a bit more.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index f9d07108bc30..8bdad221fa91 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -34,12 +34,12 @@
 
 
 /* we must assign addresses for configurable endpoints (like net2280) */
-static __devinitdata unsigned epnum;
+static __initdata unsigned epnum;
 
 // #define MANY_ENDPOINTS
 #ifdef MANY_ENDPOINTS
 /* more than 15 configurable endpoints */
-static __devinitdata unsigned in_epnum;
+static __initdata unsigned in_epnum;
 #endif
 
 
@@ -59,7 +59,7 @@ static __devinitdata unsigned in_epnum;
  * NOTE:  each endpoint is unidirectional, as specified by its USB
  * descriptor; and isn't specific to a configuration or altsetting.
  */
-static int __devinit
+static int __init
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
@@ -186,7 +186,7 @@ ep_matches (
 	return 1;
 }
 
-static struct usb_ep * __devinit
+static struct usb_ep * __init
 find_ep (struct usb_gadget *gadget, const char *name)
 {
 	struct usb_ep	*ep;
@@ -228,7 +228,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep * __devinit usb_ep_autoconfig (
+struct usb_ep * __init usb_ep_autoconfig (
 	struct usb_gadget		*gadget,
 	struct usb_endpoint_descriptor	*desc
 )
@@ -295,7 +295,7 @@ struct usb_ep * __devinit usb_ep_autoconfig (
  * state such as ep->driver_data and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
-void __devinit usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 {
 	struct usb_ep	*ep;
 

commit 9454a57ab5922e5cd25321cae9d1a8cbeb3e2e85
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Oct 4 18:05:17 2007 -0700

    USB: move <linux/usb_gadget.h> to <linux/usb/gadget.h>
    
    Move <linux/usb_gadget.h> to <linux/usb/gadget.h>, reducing
    some of the clutter in the main include directory.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 3aa46cfa66ba..f9d07108bc30 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -28,7 +28,7 @@
 #include <linux/string.h>
 
 #include <linux/usb/ch9.h>
-#include <linux/usb_gadget.h>
+#include <linux/usb/gadget.h>
 
 #include "gadget_chips.h"
 

commit a9475226977917afd5a85621f8a3d7f380a9da31
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Jul 30 12:31:07 2007 -0700

    USB: "sparse" cleanups for usb gadgets
    
    This removes complaints about the gadget stack which are generated by
    the currrent "sparse":  it doesn't like the fact that zero is the null
    pointer.  (Last I checked, C guarantees that's correct ...)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 6042364402b8..3aa46cfa66ba 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -71,7 +71,7 @@ ep_matches (
 	u16		max;
 
 	/* endpoint already claimed? */
-	if (0 != ep->driver_data)
+	if (NULL != ep->driver_data)
 		return 0;
 
 	/* only support ep0 for portable CONTROL traffic */

commit 01ee7d7032204b383b2fba73021e7acbc776184b
Author: David Brownell <david-b@pacbell.net>
Date:   Fri May 25 20:40:14 2007 -0700

    USB: usb gadgets avoid le{16,32}_to_cpup()
    
    It turns out that le16_to_cpup() and le32_to_cpup() aren't always safe
    to call with pointers into packed structures, since those are inlined
    functions and GCC may lose the "packed" attribute.  So those references
    can become unaligned kernel accesses, which are evil on some hardware.
    
    This patch updates uses of those routines in the gadget stack.  The
    references into packed structures can just use leXX_to_cpu(*x), which
    in most cases is more natural.  Some other uses in RNDIS, mostly in
    debug code, were wrong in the first place; those use get_unaligned().
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index f28af06905a5..6042364402b8 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -132,7 +132,7 @@ ep_matches (
 	 * where it's an output parameter representing the full speed limit.
 	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
 	 */
-	max = 0x7ff & le16_to_cpup (&desc->wMaxPacketSize);
+	max = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
 	switch (type) {
 	case USB_ENDPOINT_XFER_INT:
 		/* INT:  limit 64 bytes full speed, 1024 high speed */

commit 5f848137744106ee737f559454ce5adfceb38347
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Dec 16 15:34:53 2006 -0800

    USB: <linux/usb_ch9.h> becomes <linux/usb/ch9.h>
    
    This moves <linux/usb_ch9.h> to <linux/usb/ch9.h> to reduce some of the
    clutter of usb header files.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 53d584589c26..f28af06905a5 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -27,7 +27,7 @@
 #include <linux/ctype.h>
 #include <linux/string.h>
 
-#include <linux/usb_ch9.h>
+#include <linux/usb/ch9.h>
 #include <linux/usb_gadget.h>
 
 #include "gadget_chips.h"

commit a353678d3136306c1d00f0d2319de1dac8a6b1db
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Jul 6 15:48:53 2006 -0700

    [PATCH] USB: gadget section fixups
    
    Recent section changes broke gadget builds on some platforms.  This patch
    is the best fix that's available until better section markings exist:
    
     - There's a lot of cleanup code that gets used in both init and exit paths;
       stop marking it as "__exit".
    
       (Best fix for this would be an "__init_or_exit" section marking, putting
       the cleanup in __init when __exit sections get discarded else in __exit.)
    
     - Stop marking the use-once probe routines as "__init" since references
       to those routines are not allowed from driver structures.  They're now
       marked "__devinit", which in practice is a net lose.
    
       (Best fix for this is likely to separate such use-once probe routines
       from the driver structure ... but in general, all busses that aren't
       hotpluggable will be forced to waste memory for all probe-only code.)
    
    In general these broken section rules waste an average of two to four kBytes
    per driver of code bloat ... because none of the relevant code can ever be
    reused after module initialization.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index f7c6d758e1b0..53d584589c26 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -34,12 +34,12 @@
 
 
 /* we must assign addresses for configurable endpoints (like net2280) */
-static __initdata unsigned epnum;
+static __devinitdata unsigned epnum;
 
 // #define MANY_ENDPOINTS
 #ifdef MANY_ENDPOINTS
 /* more than 15 configurable endpoints */
-static __initdata unsigned in_epnum;
+static __devinitdata unsigned in_epnum;
 #endif
 
 
@@ -59,7 +59,7 @@ static __initdata unsigned in_epnum;
  * NOTE:  each endpoint is unidirectional, as specified by its USB
  * descriptor; and isn't specific to a configuration or altsetting.
  */
-static int __init
+static int __devinit
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
@@ -73,7 +73,7 @@ ep_matches (
 	/* endpoint already claimed? */
 	if (0 != ep->driver_data)
 		return 0;
-		
+
 	/* only support ep0 for portable CONTROL traffic */
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 	if (USB_ENDPOINT_XFER_CONTROL == type)
@@ -186,7 +186,7 @@ ep_matches (
 	return 1;
 }
 
-static struct usb_ep * __init
+static struct usb_ep * __devinit
 find_ep (struct usb_gadget *gadget, const char *name)
 {
 	struct usb_ep	*ep;
@@ -228,7 +228,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep * __init usb_ep_autoconfig (
+struct usb_ep * __devinit usb_ep_autoconfig (
 	struct usb_gadget		*gadget,
 	struct usb_endpoint_descriptor	*desc
 )
@@ -276,7 +276,7 @@ struct usb_ep * __init usb_ep_autoconfig (
 			return ep;
 	}
 
-	/* Second, look at endpoints until an unclaimed one looks usable */ 
+	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
 		if (ep_matches (gadget, ep, desc))
 			return ep;
@@ -295,7 +295,7 @@ struct usb_ep * __init usb_ep_autoconfig (
  * state such as ep->driver_data and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
-void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+void __devinit usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 {
 	struct usb_ep	*ep;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
new file mode 100644
index 000000000000..f7c6d758e1b0
--- /dev/null
+++ b/drivers/usb/gadget/epautoconf.c
@@ -0,0 +1,310 @@
+/*
+ * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers
+ *
+ * Copyright (C) 2004 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+
+#include <linux/ctype.h>
+#include <linux/string.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+#include "gadget_chips.h"
+
+
+/* we must assign addresses for configurable endpoints (like net2280) */
+static __initdata unsigned epnum;
+
+// #define MANY_ENDPOINTS
+#ifdef MANY_ENDPOINTS
+/* more than 15 configurable endpoints */
+static __initdata unsigned in_epnum;
+#endif
+
+
+/*
+ * This should work with endpoints from controller drivers sharing the
+ * same endpoint naming convention.  By example:
+ *
+ *	- ep1, ep2, ... address is fixed, not direction or type
+ *	- ep1in, ep2out, ... address and direction are fixed, not type
+ *	- ep1-bulk, ep2-bulk, ... address and type are fixed, not direction
+ *	- ep1in-bulk, ep2out-iso, ... all three are fixed
+ *	- ep-* ... no functionality restrictions
+ *
+ * Type suffixes are "-bulk", "-iso", or "-int".  Numbers are decimal.
+ * Less common restrictions are implied by gadget_is_*().
+ *
+ * NOTE:  each endpoint is unidirectional, as specified by its USB
+ * descriptor; and isn't specific to a configuration or altsetting.
+ */
+static int __init
+ep_matches (
+	struct usb_gadget		*gadget,
+	struct usb_ep			*ep,
+	struct usb_endpoint_descriptor	*desc
+)
+{
+	u8		type;
+	const char	*tmp;
+	u16		max;
+
+	/* endpoint already claimed? */
+	if (0 != ep->driver_data)
+		return 0;
+		
+	/* only support ep0 for portable CONTROL traffic */
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	if (USB_ENDPOINT_XFER_CONTROL == type)
+		return 0;
+
+	/* some other naming convention */
+	if ('e' != ep->name[0])
+		return 0;
+
+	/* type-restriction:  "-iso", "-bulk", or "-int".
+	 * direction-restriction:  "in", "out".
+	 */
+	if ('-' != ep->name[2]) {
+		tmp = strrchr (ep->name, '-');
+		if (tmp) {
+			switch (type) {
+			case USB_ENDPOINT_XFER_INT:
+				/* bulk endpoints handle interrupt transfers,
+				 * except the toggle-quirky iso-synch kind
+				 */
+				if ('s' == tmp[2])	// == "-iso"
+					return 0;
+				/* for now, avoid PXA "interrupt-in";
+				 * it's documented as never using DATA1.
+				 */
+				if (gadget_is_pxa (gadget)
+						&& 'i' == tmp [1])
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_BULK:
+				if ('b' != tmp[1])	// != "-bulk"
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_ISOC:
+				if ('s' != tmp[2])	// != "-iso"
+					return 0;
+			}
+		} else {
+			tmp = ep->name + strlen (ep->name);
+		}
+
+		/* direction-restriction:  "..in-..", "out-.." */
+		tmp--;
+		if (!isdigit (*tmp)) {
+			if (desc->bEndpointAddress & USB_DIR_IN) {
+				if ('n' != *tmp)
+					return 0;
+			} else {
+				if ('t' != *tmp)
+					return 0;
+			}
+		}
+	}
+
+	/* endpoint maxpacket size is an input parameter, except for bulk
+	 * where it's an output parameter representing the full speed limit.
+	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
+	 */
+	max = 0x7ff & le16_to_cpup (&desc->wMaxPacketSize);
+	switch (type) {
+	case USB_ENDPOINT_XFER_INT:
+		/* INT:  limit 64 bytes full speed, 1024 high speed */
+		if (!gadget->is_dualspeed && max > 64)
+			return 0;
+		/* FALLTHROUGH */
+
+	case USB_ENDPOINT_XFER_ISOC:
+		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
+		if (ep->maxpacket < max)
+			return 0;
+		if (!gadget->is_dualspeed && max > 1023)
+			return 0;
+
+		/* BOTH:  "high bandwidth" works only at high speed */
+		if ((desc->wMaxPacketSize & __constant_cpu_to_le16(3<<11))) {
+			if (!gadget->is_dualspeed)
+				return 0;
+			/* configure your hardware with enough buffering!! */
+		}
+		break;
+	}
+
+	/* MATCH!! */
+
+	/* report address */
+	if (isdigit (ep->name [2])) {
+		u8	num = simple_strtol (&ep->name [2], NULL, 10);
+		desc->bEndpointAddress |= num;
+#ifdef	MANY_ENDPOINTS
+	} else if (desc->bEndpointAddress & USB_DIR_IN) {
+		if (++in_epnum > 15)
+			return 0;
+		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
+#endif
+	} else {
+		if (++epnum > 15)
+			return 0;
+		desc->bEndpointAddress |= epnum;
+	}
+
+	/* report (variable) full speed bulk maxpacket */
+	if (USB_ENDPOINT_XFER_BULK == type) {
+		int size = ep->maxpacket;
+
+		/* min() doesn't work on bitfields with gcc-3.5 */
+		if (size > 64)
+			size = 64;
+		desc->wMaxPacketSize = cpu_to_le16(size);
+	}
+	return 1;
+}
+
+static struct usb_ep * __init
+find_ep (struct usb_gadget *gadget, const char *name)
+{
+	struct usb_ep	*ep;
+
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		if (0 == strcmp (ep->name, name))
+			return ep;
+	}
+	return NULL;
+}
+
+/**
+ * usb_ep_autoconfig - choose an endpoint matching the descriptor
+ * @gadget: The device to which the endpoint must belong.
+ * @desc: Endpoint descriptor, with endpoint direction and transfer mode
+ *	initialized.  For periodic transfers, the maximum packet
+ *	size must also be initialized.  This is modified on success.
+ *
+ * By choosing an endpoint to use with the specified descriptor, this
+ * routine simplifies writing gadget drivers that work with multiple
+ * USB device controllers.  The endpoint would be passed later to
+ * usb_ep_enable(), along with some descriptor.
+ *
+ * That second descriptor won't always be the same as the first one.
+ * For example, isochronous endpoints can be autoconfigured for high
+ * bandwidth, and then used in several lower bandwidth altsettings.
+ * Also, high and full speed descriptors will be different.
+ *
+ * Be sure to examine and test the results of autoconfiguration on your
+ * hardware.  This code may not make the best choices about how to use the
+ * USB controller, and it can't know all the restrictions that may apply.
+ * Some combinations of driver and hardware won't be able to autoconfigure.
+ *
+ * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+ * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
+ * is initialized as if the endpoint were used at full speed.  To prevent
+ * the endpoint from being returned by a later autoconfig call, claim it
+ * by assigning ep->driver_data to some non-null value.
+ *
+ * On failure, this returns a null endpoint descriptor.
+ */
+struct usb_ep * __init usb_ep_autoconfig (
+	struct usb_gadget		*gadget,
+	struct usb_endpoint_descriptor	*desc
+)
+{
+	struct usb_ep	*ep;
+	u8		type;
+
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+	/* First, apply chip-specific "best usage" knowledge.
+	 * This might make a good usb_gadget_ops hook ...
+	 */
+	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
+		/* ep-e, ep-f are PIO with only 64 byte fifos */
+		ep = find_ep (gadget, "ep-e");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+		ep = find_ep (gadget, "ep-f");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+
+	} else if (gadget_is_goku (gadget)) {
+		if (USB_ENDPOINT_XFER_INT == type) {
+			/* single buffering is enough */
+			ep = find_ep (gadget, "ep3-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		} else if (USB_ENDPOINT_XFER_BULK == type
+				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+			/* DMA may be available */
+			ep = find_ep (gadget, "ep2-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		}
+
+	} else if (gadget_is_sh (gadget) && USB_ENDPOINT_XFER_INT == type) {
+		/* single buffering is enough; maybe 8 byte fifo is too */
+		ep = find_ep (gadget, "ep3in-bulk");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+
+	} else if (gadget_is_mq11xx (gadget) && USB_ENDPOINT_XFER_INT == type) {
+		ep = find_ep (gadget, "ep1-bulk");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+	}
+
+	/* Second, look at endpoints until an unclaimed one looks usable */ 
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		if (ep_matches (gadget, ep, desc))
+			return ep;
+	}
+
+	/* Fail */
+	return NULL;
+}
+
+/**
+ * usb_ep_autoconfig_reset - reset endpoint autoconfig state
+ * @gadget: device for which autoconfig state will be reset
+ *
+ * Use this for devices where one configuration may need to assign
+ * endpoint resources very differently from the next one.  It clears
+ * state such as ep->driver_data and the record of assigned endpoints
+ * used by usb_ep_autoconfig().
+ */
+void __init usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+{
+	struct usb_ep	*ep;
+
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		ep->driver_data = NULL;
+	}
+#ifdef	MANY_ENDPOINTS
+	in_epnum = 0;
+#endif
+	epnum = 0;
+}
+
