commit 2e75973832abe0c5230fd40ca886d03dc975d1d3
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Mar 28 16:41:15 2020 +0530

    USB: gadget: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to USB peripheral controller drivers.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index f9b0cf67360d..f102ec23f3af 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * u_fs.h
  *

commit 1b4a3b517157aab6ef86b79b87a38c7fafae0f43
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Thu Dec 13 14:24:57 2018 +0100

    usb: gadget: Change Andrzej Pietrasiewicz's e-mail address
    
    My @samusung.com address is going to cease existing soon, so change it to
    an address which can actually be used to contact me.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index c3aba4dfa958..f9b0cf67360d 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -7,7 +7,7 @@
  * Copyright (c) 2013 Samsung Electronics Co., Ltd.
  *		http://www.samsung.com
  *
- * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ * Author: Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>
  */
 
 #ifndef U_FFS_H

commit 24ceb9c669bc18c7de3ae38863ffed8b68ceae9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:32 2017 +0100

    USB: gadget: function: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Oliver Neukum <oneukum@suse.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Jerry Zhang <zhangjerry@google.com>
    Cc: John Keeping <john@metanate.com>
    Cc: Krzysztof Opasiak <k.opasiak@samsung.com>
    Cc: Abdulhadi Mohamed <abdulahhadi2@gmail.com>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Janusz Dziedzic <januszx.dziedzic@linux.intel.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 79a585ce51c1..c3aba4dfa958 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -8,10 +8,6 @@
  *		http://www.samsung.com
  *
  * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef U_FFS_H

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 79f70ebf85dc..79a585ce51c1 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * u_fs.h
  *

commit addfc5823dbf3e6ed400e98e49c7e64b10e191d6
Author: John Keeping <john@metanate.com>
Date:   Tue Sep 12 10:24:40 2017 +0100

    usb: gadget: ffs: handle I/O completion in-order
    
    By submitting completed transfers to the system workqueue there is no
    guarantee that completion events will be queued up in the correct order,
    as in multi-processor systems there is a thread running for each
    processor and the work items are not bound to a particular core.
    
    This means that several completions are in the queue at the same time,
    they may be processed in parallel and complete out of order, resulting
    in data appearing corrupt when read by userspace.
    
    Create a single-threaded workqueue for FunctionFS so that data completed
    requests is passed to userspace in the order in which they complete.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: John Keeping <john@metanate.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 540f1c48c1a8..79f70ebf85dc 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -279,6 +279,7 @@ struct ffs_data {
 	}				file_perms;
 
 	struct eventfd_ctx *ffs_eventfd;
+	struct workqueue_struct *io_completion_wq;
 	bool no_disconnect;
 	struct work_struct reset_work;
 

commit e16828cf945ca11b05df1cc755af8e4b669f6dd3
Author: Jerry Zhang <zhangjerry@google.com>
Date:   Tue Apr 18 16:11:48 2017 -0700

    usb: gadget: function: f_fs: Move epfile waitqueue to ffs_data.
    
    There were individual waitqueues for each epfile but eps_enable
    would iterate through all of them, resulting in essentially the
    same wakeup time.
    
    The waitqueue represents the function being enabled, so a central
    waitqueue in ffs_data makes more sense and is less redundant.
    
    Also use wake_up_interruptible to reflect use of
    wait_event_interruptible.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Jerry Zhang <zhangjerry@google.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 4378cc2fcac3..540f1c48c1a8 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -216,6 +216,9 @@ struct ffs_data {
 #define FFS_FL_CALL_CLOSED_CALLBACK 0
 #define FFS_FL_BOUND                1
 
+	/* For waking up blocked threads when function is enabled. */
+	wait_queue_head_t		wait;
+
 	/* Active function */
 	struct ffs_function		*func;
 

commit ba7756d08212f71a009a4ac7439b8e661e469f7d
Merge: a6308d700b9b 48eab1f28d49
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 11 16:47:26 2017 +0200

    Merge tag 'usb-for-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: changes for v4.12
    
    With 51 non-merge commits, this is one of the smallest USB Gadget pull
    requests. Apart from your expected set of non-critical fixes, and
    other miscellaneous items, we have most of the changes in dwc3 (52.5%)
    with all other UDCs following with 34.8%.
    
    As for the actual changes, the most important of them are all the
    recent changes to reduce memory footprint of dwc3, bare minimum
    dual-role support on dwc3 and reworked endpoint count and
    initialization routines.

commit ea920bb42dcd179da10af0825396e0abf84d8110
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Fri Mar 10 22:45:58 2017 +0100

    usb: gadget: f_fs: simplify ffs_dev name handling
    
    Currently ffs_dev::name can be either allocated by the client of
    the ffs_dev structure or by the f_fs.c core itself.  The former
    is used by g_ffs while the latter happens with configfs.
    
    Historically, g_ffs did not need to allocate separate buffer for
    the name so what is now f_fs.c core never cared about freeing
    that space.  With configfs the name needs to be copied since the
    memory is not guaranteed to be availeble after ffs_set_inst_name
    finishes.
    
    The complication is therefore here to avoid allocations in the
    g_ffs case but it complicates the code inproportinally to
    benefits it provides.  In particular, g_ffs is considered
    ‘legacy’ so optimising for its sake is unlikely to be worth the
    effort.
    
    With that observation in mind, simplify the code by unifying the
    code paths in g_ffs and configfs paths.  Furthermore, instead of
    allocating a new buffer for the name, simply embed it in the
    ffs_dev structure.  This further makes the memory management
    less convoluted and error-prone.
    
    The configfs interface for functionfs imposed a limit of 40
    characters for the name so this results in a 41-byte buffer
    added to the structure.  (For short names this may lead to
    wasted memory but the actual amount is not immediately obvious
    and depends on pointer size and which slab buckets the structure
    and name would fall into).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 4b6969451cdc..7ff485af3bee 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -39,15 +39,16 @@
 struct f_fs_opts;
 
 struct ffs_dev {
-	const char *name;
-	bool name_allocated;
-	bool mounted;
-	bool desc_ready;
-	bool single;
 	struct ffs_data *ffs_data;
 	struct f_fs_opts *opts;
 	struct list_head entry;
 
+	char name[41];
+
+	bool mounted;
+	bool desc_ready;
+	bool single;
+
 	int (*ffs_ready_callback)(struct ffs_data *ffs);
 	void (*ffs_closed_callback)(struct ffs_data *ffs);
 	void *(*ffs_acquire_dev_callback)(struct ffs_dev *dev);

commit 43938613c6fd2e58a0be212c832e1878bedefe5a
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Mon Mar 6 16:21:12 2017 +0200

    drivers, usb: convert ffs_data.ref from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 4b6969451cdc..abfca4854433 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -20,6 +20,7 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
+#include <linux/refcount.h>
 
 #ifdef VERBOSE_DEBUG
 #ifndef pr_vdebug
@@ -177,7 +178,7 @@ struct ffs_data {
 	struct completion		ep0req_completion;	/* P: mutex */
 
 	/* reference counter */
-	atomic_t			ref;
+	refcount_t			ref;
 	/* how many files are opened (EP0 and others) */
 	atomic_t			opened;
 

commit 41dc9ac163e76718d445a8149f8ce635375c8c38
Author: Vincent Pelletier <plr.vincent@gmail.com>
Date:   Mon Jan 23 14:41:04 2017 +0000

    usb: gadget: f_fs: Accept up to 30 endpoints.
    
    It is allowed by the USB specification to enabled same-address, opposite-
    direction endpoints simultaneously, which means 30 non-zero endpoints
    are allowed. So double eps_addrmap length to 30.
    The original code only accepted 14 descriptors out of a likely intended 15
    (as there are 15 endpoint addresses, ignoring direction), because the first
    eps_addrmap entry is unused (it is a placeholder for endpoint zero). So
    increase eps_addrmap length by one to 31.
    
    Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 60139854e0b1..4b6969451cdc 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -247,7 +247,8 @@ struct ffs_data {
 
 	unsigned			user_flags;
 
-	u8				eps_addrmap[15];
+#define FFS_MAX_EPS_COUNT 31
+	u8				eps_addrmap[FFS_MAX_EPS_COUNT];
 
 	unsigned short			strings_count;
 	unsigned short			interfaces_count;

commit 5e33f6fdf735cda1d4580fe6f1878da05718fe73
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jan 23 13:41:01 2015 +0100

    usb: gadget: ffs: add eventfd notification about ffs events
    
    Add eventfd which notifies userspace about ep0 events and AIO completion
    events. It simplifies using of FunctionFS with event loop, because now
    we need to poll on single file (instead of polling on ep0 and eventfd's
    supplied to AIO layer).
    
    FunctionFS eventfd is not triggered if another eventfd is supplied to
    AIO layer (in AIO request). It can be useful, for example, when we want
    to handle AIO transations for chosen endpoint in separate thread.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 284a1f00a980..60139854e0b1 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -272,6 +272,7 @@ struct ffs_data {
 		kgid_t				gid;
 	}				file_perms;
 
+	struct eventfd_ctx *ffs_eventfd;
 	bool no_disconnect;
 	struct work_struct reset_work;
 

commit 18d6b32fca3841f7cd9479b4024abd8a9b299281
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Dec 18 09:55:10 2014 +0100

    usb: gadget: f_fs: add "no_disconnect" mode
    
    Since we can compose gadgets from many functions, there is the problem
    related to gadget breakage while FunctionFS daemon being closed. FFS
    function is userspace code so there is no way to know when it will close
    files (it doesn't matter what is the reason of this situation, it can
    be daemon logic, program breakage, process kill or any other). So when
    we have another function in gadget which, for example, sends some amount
    of data, does some software update or implements some real-time functionality,
    we may want to keep the gadget connected despite FFS function is no longer
    functional.
    
    We can't just remove one of functions from gadget since it has been
    enumerated, so the only way to keep entire gadget working is to make
    broken FFS function deactivated but still visible to host. For this
    purpose this patch introduces "no_disconnect" mode. It can be enabled
    by setting mount option "no_disconnect=1", and results with defering
    function disconnect to the moment of reopen ep0 file or filesystem
    unmount. After closing all endpoint files, FunctionFS is set to state
    FFS_DEACTIVATED.
    
    When ffs->state == FFS_DEACTIVATED:
    - function is still bound and visible to host,
    - setup requests are automatically stalled,
    - transfers on other endpoints are refused,
    - epfiles, except ep0, are deleted from the filesystem,
    - opening ep0 causes the function to be closed, and then FunctionFS
      is ready for descriptors and string write,
    - altsetting change causes the function to be closed - we want to keep
      function alive until another functions are potentialy used, altsetting
      change means that another configuration is being selected or USB cable
      was unplugged, which indicates that we don't need to stay longer in
      FFS_DEACTIVATED state
    - unmounting of the FunctionFS instance causes the function to be closed.
    
    Tested-by: David Cohen <david.a.cohen@linux.intel.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index cd128e31f808..284a1f00a980 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -19,6 +19,7 @@
 #include <linux/usb/composite.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
+#include <linux/workqueue.h>
 
 #ifdef VERBOSE_DEBUG
 #ifndef pr_vdebug
@@ -92,6 +93,26 @@ enum ffs_state {
 	 */
 	FFS_ACTIVE,
 
+	/*
+	 * Function is visible to host, but it's not functional. All
+	 * setup requests are stalled and transfers on another endpoints
+	 * are refused. All epfiles, except ep0, are deleted so there
+	 * is no way to perform any operations on them.
+	 *
+	 * This state is set after closing all functionfs files, when
+	 * mount parameter "no_disconnect=1" has been set. Function will
+	 * remain in deactivated state until filesystem is umounted or
+	 * ep0 is opened again. In the second case functionfs state will
+	 * be reset, and it will be ready for descriptors and strings
+	 * writing.
+	 *
+	 * This is useful only when functionfs is composed to gadget
+	 * with another function which can perform some critical
+	 * operations, and it's strongly desired to have this operations
+	 * completed, even after functionfs files closure.
+	 */
+	FFS_DEACTIVATED,
+
 	/*
 	 * All endpoints have been closed.  This state is also set if
 	 * we encounter an unrecoverable error.  The only
@@ -251,6 +272,9 @@ struct ffs_data {
 		kgid_t				gid;
 	}				file_perms;
 
+	bool no_disconnect;
+	struct work_struct reset_work;
+
 	/*
 	 * The endpoint files, filled by ffs_epfiles_create(),
 	 * destroyed by ffs_epfiles_destroy().

commit 1b0bf88fd8b845aef4300c7c0feca774265dd1c4
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Tue Sep 9 08:23:17 2014 +0200

    usb: gadget: f_fs: virtual endpoint address mapping
    
    This patch introduces virtual endpoint address mapping. It separates
    function logic form physical endpoint addresses making it more hardware
    independent.
    
    Following modifications changes user space API, so to enable them user
    have to switch on the FUNCTIONFS_VIRTUAL_ADDR flag in descriptors.
    
    Endpoints are now refered using virtual endpoint addresses chosen by
    user in endpoint descpriptors. This applies to each context when endpoint
    address can be used:
    - when accessing endpoint files in FunctionFS filesystemi (in file name),
    - in setup requests directed to specific endpoint (in wIndex field),
    - in descriptors returned by FUNCTIONFS_ENDPOINT_DESC ioctl.
    
    In endpoint file names the endpoint address number is formatted as
    double-digit hexadecimal value ("ep%02x") which has few advantages -
    it is easy to parse, allows to easly recognize endpoint direction basing
    on its name (IN endpoint number starts with digit 8, and OUT with 0)
    which can be useful for debugging purpose, and it makes easier to introduce
    further features allowing to use each endpoint number in both directions
    to have more endpoints available for function if hardware supports this
    (for example we could have ep01 which is endpoint 1 with OUT direction,
    and ep81 which is endpoint 1 with IN direction).
    
    Physical endpoint address can be still obtained using ioctl named
    FUNCTIONFS_ENDPOINT_REVMAP, but now it's not neccesary to handle
    USB transactions properly.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index d48897e8ffeb..cd128e31f808 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -224,6 +224,8 @@ struct ffs_data {
 	void				*ms_os_descs_ext_prop_name_avail;
 	void				*ms_os_descs_ext_prop_data_avail;
 
+	unsigned			user_flags;
+
 	u8				eps_addrmap[15];
 
 	unsigned short			strings_count;

commit 6d5c1c77bbf98b2cc5373af02bb7b3b27584ee4a
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Mon Aug 25 11:16:27 2014 +0200

    usb: gadget: f_fs: fix the redundant ep files problem
    
    Up to now, when endpoint addresses in descriptors were non-consecutive,
    there were created redundant files, which could cause problems in kernel,
    when user tried to read/write to them. It was result of fact that maximum
    endpoint address was taken as total number of endpoints in function.
    
    This patch adds endpoint descriptors counting and storing their addresses
    in eps_addrmap to verify their cohesion in each speed.
    
    Endpoint address map would be also useful for further features, just like
    vitual endpoint address mapping.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
index 63d6e71569c1..d48897e8ffeb 100644
--- a/drivers/usb/gadget/function/u_fs.h
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -224,6 +224,8 @@ struct ffs_data {
 	void				*ms_os_descs_ext_prop_name_avail;
 	void				*ms_os_descs_ext_prop_data_avail;
 
+	u8				eps_addrmap[15];
+
 	unsigned short			strings_count;
 	unsigned short			interfaces_count;
 	unsigned short			eps_count;

commit 00a2430ff07d4e0e0e7e24e02fd8adede333b797
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 15 13:09:46 2014 +0200

    usb: gadget: Gadget directory cleanup - group usb functions
    
    The drivers/usb/gadget directory contains many files.
    Files which are related can be distributed into separate directories.
    This patch moves the USB functions implementations into a separate directory.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/function/u_fs.h b/drivers/usb/gadget/function/u_fs.h
new file mode 100644
index 000000000000..63d6e71569c1
--- /dev/null
+++ b/drivers/usb/gadget/function/u_fs.h
@@ -0,0 +1,270 @@
+/*
+ * u_fs.h
+ *
+ * Utility definitions for the FunctionFS
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef U_FFS_H
+#define U_FFS_H
+
+#include <linux/usb/composite.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+
+#ifdef VERBOSE_DEBUG
+#ifndef pr_vdebug
+#  define pr_vdebug pr_debug
+#endif /* pr_vdebug */
+#  define ffs_dump_mem(prefix, ptr, len) \
+	print_hex_dump_bytes(pr_fmt(prefix ": "), DUMP_PREFIX_NONE, ptr, len)
+#else
+#ifndef pr_vdebug
+#  define pr_vdebug(...)                 do { } while (0)
+#endif /* pr_vdebug */
+#  define ffs_dump_mem(prefix, ptr, len) do { } while (0)
+#endif /* VERBOSE_DEBUG */
+
+#define ENTER()    pr_vdebug("%s()\n", __func__)
+
+struct f_fs_opts;
+
+struct ffs_dev {
+	const char *name;
+	bool name_allocated;
+	bool mounted;
+	bool desc_ready;
+	bool single;
+	struct ffs_data *ffs_data;
+	struct f_fs_opts *opts;
+	struct list_head entry;
+
+	int (*ffs_ready_callback)(struct ffs_data *ffs);
+	void (*ffs_closed_callback)(struct ffs_data *ffs);
+	void *(*ffs_acquire_dev_callback)(struct ffs_dev *dev);
+	void (*ffs_release_dev_callback)(struct ffs_dev *dev);
+};
+
+extern struct mutex ffs_lock;
+
+static inline void ffs_dev_lock(void)
+{
+	mutex_lock(&ffs_lock);
+}
+
+static inline void ffs_dev_unlock(void)
+{
+	mutex_unlock(&ffs_lock);
+}
+
+int ffs_name_dev(struct ffs_dev *dev, const char *name);
+int ffs_single_dev(struct ffs_dev *dev);
+
+struct ffs_epfile;
+struct ffs_function;
+
+enum ffs_state {
+	/*
+	 * Waiting for descriptors and strings.
+	 *
+	 * In this state no open(2), read(2) or write(2) on epfiles
+	 * may succeed (which should not be the problem as there
+	 * should be no such files opened in the first place).
+	 */
+	FFS_READ_DESCRIPTORS,
+	FFS_READ_STRINGS,
+
+	/*
+	 * We've got descriptors and strings.  We are or have called
+	 * functionfs_ready_callback().  functionfs_bind() may have
+	 * been called but we don't know.
+	 *
+	 * This is the only state in which operations on epfiles may
+	 * succeed.
+	 */
+	FFS_ACTIVE,
+
+	/*
+	 * All endpoints have been closed.  This state is also set if
+	 * we encounter an unrecoverable error.  The only
+	 * unrecoverable error is situation when after reading strings
+	 * from user space we fail to initialise epfiles or
+	 * functionfs_ready_callback() returns with error (<0).
+	 *
+	 * In this state no open(2), read(2) or write(2) (both on ep0
+	 * as well as epfile) may succeed (at this point epfiles are
+	 * unlinked and all closed so this is not a problem; ep0 is
+	 * also closed but ep0 file exists and so open(2) on ep0 must
+	 * fail).
+	 */
+	FFS_CLOSING
+};
+
+enum ffs_setup_state {
+	/* There is no setup request pending. */
+	FFS_NO_SETUP,
+	/*
+	 * User has read events and there was a setup request event
+	 * there.  The next read/write on ep0 will handle the
+	 * request.
+	 */
+	FFS_SETUP_PENDING,
+	/*
+	 * There was event pending but before user space handled it
+	 * some other event was introduced which canceled existing
+	 * setup.  If this state is set read/write on ep0 return
+	 * -EIDRM.  This state is only set when adding event.
+	 */
+	FFS_SETUP_CANCELLED
+};
+
+struct ffs_data {
+	struct usb_gadget		*gadget;
+
+	/*
+	 * Protect access read/write operations, only one read/write
+	 * at a time.  As a consequence protects ep0req and company.
+	 * While setup request is being processed (queued) this is
+	 * held.
+	 */
+	struct mutex			mutex;
+
+	/*
+	 * Protect access to endpoint related structures (basically
+	 * usb_ep_queue(), usb_ep_dequeue(), etc. calls) except for
+	 * endpoint zero.
+	 */
+	spinlock_t			eps_lock;
+
+	/*
+	 * XXX REVISIT do we need our own request? Since we are not
+	 * handling setup requests immediately user space may be so
+	 * slow that another setup will be sent to the gadget but this
+	 * time not to us but another function and then there could be
+	 * a race.  Is that the case? Or maybe we can use cdev->req
+	 * after all, maybe we just need some spinlock for that?
+	 */
+	struct usb_request		*ep0req;		/* P: mutex */
+	struct completion		ep0req_completion;	/* P: mutex */
+
+	/* reference counter */
+	atomic_t			ref;
+	/* how many files are opened (EP0 and others) */
+	atomic_t			opened;
+
+	/* EP0 state */
+	enum ffs_state			state;
+
+	/*
+	 * Possible transitions:
+	 * + FFS_NO_SETUP        -> FFS_SETUP_PENDING  -- P: ev.waitq.lock
+	 *               happens only in ep0 read which is P: mutex
+	 * + FFS_SETUP_PENDING   -> FFS_NO_SETUP       -- P: ev.waitq.lock
+	 *               happens only in ep0 i/o  which is P: mutex
+	 * + FFS_SETUP_PENDING   -> FFS_SETUP_CANCELLED -- P: ev.waitq.lock
+	 * + FFS_SETUP_CANCELLED -> FFS_NO_SETUP        -- cmpxchg
+	 *
+	 * This field should never be accessed directly and instead
+	 * ffs_setup_state_clear_cancelled function should be used.
+	 */
+	enum ffs_setup_state		setup_state;
+
+	/* Events & such. */
+	struct {
+		u8				types[4];
+		unsigned short			count;
+		/* XXX REVISIT need to update it in some places, or do we? */
+		unsigned short			can_stall;
+		struct usb_ctrlrequest		setup;
+
+		wait_queue_head_t		waitq;
+	} ev; /* the whole structure, P: ev.waitq.lock */
+
+	/* Flags */
+	unsigned long			flags;
+#define FFS_FL_CALL_CLOSED_CALLBACK 0
+#define FFS_FL_BOUND                1
+
+	/* Active function */
+	struct ffs_function		*func;
+
+	/*
+	 * Device name, write once when file system is mounted.
+	 * Intended for user to read if she wants.
+	 */
+	const char			*dev_name;
+	/* Private data for our user (ie. gadget).  Managed by user. */
+	void				*private_data;
+
+	/* filled by __ffs_data_got_descs() */
+	/*
+	 * raw_descs is what you kfree, real_descs points inside of raw_descs,
+	 * where full speed, high speed and super speed descriptors start.
+	 * real_descs_length is the length of all those descriptors.
+	 */
+	const void			*raw_descs_data;
+	const void			*raw_descs;
+	unsigned			raw_descs_length;
+	unsigned			fs_descs_count;
+	unsigned			hs_descs_count;
+	unsigned			ss_descs_count;
+	unsigned			ms_os_descs_count;
+	unsigned			ms_os_descs_ext_prop_count;
+	unsigned			ms_os_descs_ext_prop_name_len;
+	unsigned			ms_os_descs_ext_prop_data_len;
+	void				*ms_os_descs_ext_prop_avail;
+	void				*ms_os_descs_ext_prop_name_avail;
+	void				*ms_os_descs_ext_prop_data_avail;
+
+	unsigned short			strings_count;
+	unsigned short			interfaces_count;
+	unsigned short			eps_count;
+	unsigned short			_pad1;
+
+	/* filled by __ffs_data_got_strings() */
+	/* ids in stringtabs are set in functionfs_bind() */
+	const void			*raw_strings;
+	struct usb_gadget_strings	**stringtabs;
+
+	/*
+	 * File system's super block, write once when file system is
+	 * mounted.
+	 */
+	struct super_block		*sb;
+
+	/* File permissions, written once when fs is mounted */
+	struct ffs_file_perms {
+		umode_t				mode;
+		kuid_t				uid;
+		kgid_t				gid;
+	}				file_perms;
+
+	/*
+	 * The endpoint files, filled by ffs_epfiles_create(),
+	 * destroyed by ffs_epfiles_destroy().
+	 */
+	struct ffs_epfile		*epfiles;
+};
+
+
+struct f_fs_opts {
+	struct usb_function_instance	func_inst;
+	struct ffs_dev			*dev;
+	unsigned			refcnt;
+	bool				no_configfs;
+};
+
+static inline struct f_fs_opts *to_f_fs_opts(struct usb_function_instance *fi)
+{
+	return container_of(fi, struct f_fs_opts, func_inst);
+}
+
+#endif /* U_FFS_H */
