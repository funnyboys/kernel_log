commit 65dc2e725286106f99c6f6b78e3d9c52c15f3a9c
Author: Minas Harutyunyan <Minas.Harutyunyan@synopsys.com>
Date:   Thu May 21 10:05:44 2020 +0400

    usb: dwc2: Update Core Reset programming flow.
    
    Starting from core version 4.20a Core Reset flow is changed.
    Introduced new bit in GRSTCTL register - GRSTCTL_CSFTRST_DONE.
    Core Reset new programming flow steps are follow:
    1. Set GRSTCTL_CSFTRST bit.
    2. Wait for bit GRSTCTL_CSFTRST_DONE is set.
    3. Clear GRSTCTL_CSFTRST and GRSTCTL_CSFTRST_DONE bits.
    
    Check core version functionality separated from dwc2_get_hwparams() to
    new dwc2_check_core_version() function because Core Reset flow depend
    on SNPSID.
    
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 8ccc83f7eb3f..ce736d67c7c3 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -782,25 +782,6 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	u32 hwcfg1, hwcfg2, hwcfg3, hwcfg4;
 	u32 grxfsiz;
 
-	/*
-	 * Attempt to ensure this device is really a DWC_otg Controller.
-	 * Read and verify the GSNPSID register contents. The value should be
-	 * 0x45f4xxxx, 0x5531xxxx or 0x5532xxxx
-	 */
-
-	hw->snpsid = dwc2_readl(hsotg, GSNPSID);
-	if ((hw->snpsid & GSNPSID_ID_MASK) != DWC2_OTG_ID &&
-	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_FS_IOT_ID &&
-	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_HS_IOT_ID) {
-		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
-			hw->snpsid);
-		return -ENODEV;
-	}
-
-	dev_dbg(hsotg->dev, "Core Release: %1x.%1x%1x%1x (snpsid=%x)\n",
-		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
-		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
-
 	hwcfg1 = dwc2_readl(hsotg, GHWCFG1);
 	hwcfg2 = dwc2_readl(hsotg, GHWCFG2);
 	hwcfg3 = dwc2_readl(hsotg, GHWCFG3);

commit a415083a11cc76f85322406fb91e2eb917c6cef9
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Fri Jan 24 09:41:31 2020 +0100

    usb: dwc2: add support for STM32MP15 SoCs USB OTG HS and FS
    
    This patch introduces a new parameter to activate external ID pin and valid
    vbus level detection, required on STM32MP15 SoC to support dual role,
    either in HS or FS.
    The STM32MP15 SoC uses the GGPIO register to enable the level detection.
    The level detector requires to be powered.
    Also adds the params structures for STM32MP15 OTG HS and STM32MP1 OTG FS.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 31e090ac9f1e..8ccc83f7eb3f 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -163,6 +163,35 @@ static void dwc2_set_stm32f7_hsotg_params(struct dwc2_hsotg *hsotg)
 	p->host_perio_tx_fifo_size = 256;
 }
 
+static void dwc2_set_stm32mp15_fsotg_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->speed = DWC2_SPEED_PARAM_FULL;
+	p->host_rx_fifo_size = 128;
+	p->host_nperio_tx_fifo_size = 96;
+	p->host_perio_tx_fifo_size = 96;
+	p->max_packet_count = 256;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_FS;
+	p->i2c_enable = false;
+	p->activate_stm_fs_transceiver = true;
+	p->activate_stm_id_vb_detection = true;
+	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
+}
+
+static void dwc2_set_stm32mp15_hsotg_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->activate_stm_id_vb_detection = true;
+	p->host_rx_fifo_size = 440;
+	p->host_nperio_tx_fifo_size = 256;
+	p->host_perio_tx_fifo_size = 256;
+	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
+}
+
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
 	{ .compatible = "hisilicon,hi6220-usb", .data = dwc2_set_his_params  },
@@ -186,6 +215,10 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "st,stm32f4x9-hsotg" },
 	{ .compatible = "st,stm32f7-hsotg",
 	  .data = dwc2_set_stm32f7_hsotg_params },
+	{ .compatible = "st,stm32mp15-fsotg",
+	  .data = dwc2_set_stm32mp15_fsotg_params },
+	{ .compatible = "st,stm32mp15-hsotg",
+	  .data = dwc2_set_stm32mp15_hsotg_params },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 07e803ec9f6be4b216b89f8530ea30d2a397696d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 23 22:16:39 2019 +0300

    usb: dwc2: Switch to use device_property_count_u32()
    
    Use use device_property_count_u32() directly, that makes code neater.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Link: https://lore.kernel.org/r/20190723191639.67883-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 55f841a54015..31e090ac9f1e 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -404,10 +404,7 @@ static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
 		device_property_read_u32(hsotg->dev, "g-np-tx-fifo-size",
 					 &p->g_np_tx_fifo_size);
 
-		num = device_property_read_u32_array(hsotg->dev,
-						     "g-tx-fifo-size",
-						     NULL, 0);
-
+		num = device_property_count_u32(hsotg->dev, "g-tx-fifo-size");
 		if (num > 0) {
 			num = min(num, 15);
 			memset(p->g_tx_fifo_size, 0,

commit f254e65ad694a9189163f5a60707a06225f5db25
Merge: 426d3ff2f5ab aa23ce847dda
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 12:01:33 2019 +0200

    Merge tag 'usb-for-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: changes for v5.3 merge window
    
    The biggest part here is a set of patches removing unnecesary variables
    from several drivers.
    
    Meson-g12a's dwc3 glue implemented IRQ-based OTG/DRD role swap.
    
    Qcom's dwc3 glue added support for ACPI, mainly for the AArch64-based
    SoCs.
    
    DWC3 also got support for Intel Elkhart Lake platforms.
    
    * tag 'usb-for-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (30 commits)
      usb: dwc3: remove unused @lock member of dwc3_ep struct
      usb: dwc3: pci: Add Support for Intel Elkhart Lake Devices
      usb: Replace snprintf with scnprintf in gether_get_ifname
      usb: gadget: ether: Fix race between gether_disconnect and rx_submit
      usb: gadget: storage: Remove warning message
      usb: dwc3: gadget: Add support for disabling U1 and U2 entries
      usb: gadget: send usb_gadget as an argument in get_config_params
      doc: dt: bindings: usb: dwc3: Update entries for disabling U1 and U2
      usb: dwc3: qcom: Use of_clk_get_parent_count()
      usb: dwc3: Fix core validation in probe, move after clocks are enabled
      usb: dwc3: qcom: Improve error handling
      usb: dwc3: qcom: Start USB in 'host mode' on the SDM845
      usb: dwc3: qcom: Add support for booting with ACPI
      soc: qcom: geni: Add support for ACPI
      Revert "usb: dwc2: host: Setting qtd to NULL after freeing it"
      usb: gadget: net2272: remove redundant assignments to pointer 's'
      usb: gadget: Zero ffs_io_data
      USB: omap_udc: Remove unneeded variable
      fotg210-udc: Remove unneeded variable
      usb: gadget: at91_udc: Remove unneeded variable
      ...

commit 1112cf4c4109473fd8a30a4678d25f9321ef5d67
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Jun 14 08:52:53 2019 +0200

    usb: dwc2: Force 8bit UTMI width for Samsung Exynos SoCs
    
    Samsung Exynos SoCs require to force UTMI width to 8bit, otherwise the
    host side of the shared USB2 PHY doesn't work.
    
    Reported-by: Krzysztof Kozlowski <krzk@kernel.org>
    Fixes: 707d80f0a3c5 ("usb: dwc2: gadget: Replace phyif with phy_utmi_width")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Tested-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6900eea57526..9ece4affb9d4 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -76,6 +76,7 @@ static void dwc2_set_s3c6400_params(struct dwc2_hsotg *hsotg)
 	struct dwc2_core_params *p = &hsotg->params;
 
 	p->power_down = 0;
+	p->phy_utmi_width = 8;
 }
 
 static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)

commit 42de8afc40c97002fceb500e2331f6a722be3c14
Author: Jules Maselbas <jmaselbas@kalray.eu>
Date:   Thu May 9 11:15:28 2019 +0200

    usb: dwc2: Use generic PHY width in params setup
    
    Setting params.phy_utmi_width in dwc2_lowlevel_hw_init() is pointless since
    it's value will be overwritten by dwc2_init_params().
    
    This change make sure to take in account the generic PHY width information
    during paraminitialisation, done in dwc2_set_param_phy_utmi_width().
    
    By doing so, the phy_utmi_width params can still be overrided by
    devicetree specific params and will also be checked against hardware
    capabilities.
    
    Fixes: 707d80f0a3c5 ("usb: dwc2: gadget: Replace phyif with phy_utmi_width")
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Jules Maselbas <jmaselbas@kalray.eu>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6900eea57526..5949262ff669 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -253,6 +253,15 @@ static void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
 	val = (hsotg->hw_params.utmi_phy_data_width ==
 	       GHWCFG4_UTMI_PHY_DATA_WIDTH_8) ? 8 : 16;
 
+	if (hsotg->phy) {
+		/*
+		 * If using the generic PHY framework, check if the PHY bus
+		 * width is 8-bit and set the phyif appropriately.
+		 */
+		if (phy_get_bus_width(hsotg->phy) == 8)
+			val = 8;
+	}
+
 	hsotg->params.phy_utmi_width = val;
 }
 

commit 28b5c129ca6e585ec95c160ec4297bc6c6360b6f
Author: Minas Harutyunyan <minas.harutyunyan@synopsys.com>
Date:   Mon Mar 4 17:08:07 2019 +0400

    usb: dwc2: Set lpm mode parameters depend on HW configuration
    
    If core not supported lpm, i.e. BCM2835 then confusing warnings seen
    in log.
    
    To avoid these warnings, added function dwc2_set_param_lpm() to set
    lpm and other lpm related parameters based on lpm support by core.
    
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 442113246cba..6900eea57526 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -285,6 +285,23 @@ static void dwc2_set_param_power_down(struct dwc2_hsotg *hsotg)
 	hsotg->params.power_down = val;
 }
 
+static void dwc2_set_param_lpm(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->lpm = hsotg->hw_params.lpm_mode;
+	if (p->lpm) {
+		p->lpm_clock_gating = true;
+		p->besl = true;
+		p->hird_threshold_en = true;
+		p->hird_threshold = 4;
+	} else {
+		p->lpm_clock_gating = false;
+		p->besl = false;
+		p->hird_threshold_en = false;
+	}
+}
+
 /**
  * dwc2_set_default_params() - Set all core parameters to their
  * auto-detected default values.
@@ -303,6 +320,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	dwc2_set_param_speed(hsotg);
 	dwc2_set_param_phy_utmi_width(hsotg);
 	dwc2_set_param_power_down(hsotg);
+	dwc2_set_param_lpm(hsotg);
 	p->phy_ulpi_ddr = false;
 	p->phy_ulpi_ext_vbus = false;
 
@@ -315,11 +333,6 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
 	p->uframe_sched = true;
 	p->external_id_pin_ctl = false;
-	p->lpm = true;
-	p->lpm_clock_gating = true;
-	p->besl = true;
-	p->hird_threshold_en = true;
-	p->hird_threshold = 4;
 	p->ipg_isoc_en = false;
 	p->service_interval = false;
 	p->max_packet_count = hw->max_packet_count;

commit fc4e326ee72cc36c942333c65d851247b31c567b
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Tue Apr 23 10:51:26 2019 +0200

    usb: dwc2: Add Amlogic G12A DWC2 Params
    
    This patchs sets the params for the DWC2 Controller found in the
    Amlogic G12A SoC family.
    
    It mainly sets the settings reported incorrect by the driver,
    leaving the remaining detected automatically by the driver and
    provided by the DT node.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 24ff5f21cb25..442113246cba 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -121,6 +121,16 @@ static void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)
 	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
 }
 
+static void dwc2_set_amlogic_g12a_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->lpm = false;
+	p->lpm_clock_gating = false;
+	p->besl = false;
+	p->hird_threshold_en = false;
+}
+
 static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
@@ -167,6 +177,8 @@ const struct of_device_id dwc2_of_match_table[] = {
 	  .data = dwc2_set_amlogic_params },
 	{ .compatible = "amlogic,meson-gxbb-usb",
 	  .data = dwc2_set_amlogic_params },
+	{ .compatible = "amlogic,meson-g12a-usb",
+	  .data = dwc2_set_amlogic_g12a_params },
 	{ .compatible = "amcc,dwc-otg", .data = dwc2_set_amcc_params },
 	{ .compatible = "st,stm32f4x9-fsotg",
 	  .data = dwc2_set_stm32f4x9_fsotg_params },

commit cc10ce0c51b13d1566d0ec1dcb472fb86330b391
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sun Dec 9 20:01:29 2018 +0100

    usb: dwc2: disable power_down on Amlogic devices
    
    Disable power_down by setting the parameter to
    DWC2_POWER_DOWN_PARAM_NONE. This fixes a problem on various Amlogic
    Meson SoCs where USB devices are only recognized when plugged in before
    booting Linux. A hot-plugged USB device was not detected even though the
    device got power (my USB thumb drive for example has an LED which lit
    up).
    
    A similar fix was implemented for Rockchip SoCs in commit c216765d3a1def
    ("usb: dwc2: disable power_down on rockchip devices"). That commit
    suggests that a change in the dwc2 driver is the cause because the
    default value for the "hibernate" parameter (which then got renamed to
    "power_down" to support other modes) was changed in the v4.17 merge
    window with:
    commit 6d23ee9caa6790 ("Merge tag 'usb-for-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-testing").
    
    Cc: <stable@vger.kernel.org> # 4.19
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Suggested-by: Christian Hewitt <christianshewitt@gmail.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 266157ae179a..24ff5f21cb25 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -118,6 +118,7 @@ static void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)
 	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR8 <<
 		GAHBCFG_HBSTLEN_SHIFT;
+	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
 }
 
 static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)

commit 35a6054132286a4ab92b536595093b82e6bdfcbc
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Nov 20 16:38:15 2018 +0100

    usb: dwc2: Disable power down feature on Samsung SoCs
    
    Power down feature of DWC2 module integrated in Samsung SoCs doesn't work
    properly or needs some additional handling in PHY or SoC glue layer, so
    disable it for now. Without disabling power down, DWC2 causes random memory
    trashes and fails enumeration if there is no USB link to host on driver
    probe.
    
    Fixes: 03ea6d6e9e1ff1 ("usb: dwc2: Enable power down")
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 7c1b6938f212..266157ae179a 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -71,6 +71,13 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 	p->power_down = false;
 }
 
+static void dwc2_set_s3c6400_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->power_down = 0;
+}
+
 static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
@@ -151,7 +158,8 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "lantiq,arx100-usb", .data = dwc2_set_ltq_params },
 	{ .compatible = "lantiq,xrx200-usb", .data = dwc2_set_ltq_params },
 	{ .compatible = "snps,dwc2" },
-	{ .compatible = "samsung,s3c6400-hsotg" },
+	{ .compatible = "samsung,s3c6400-hsotg",
+	  .data = dwc2_set_s3c6400_params },
 	{ .compatible = "amlogic,meson8-usb",
 	  .data = dwc2_set_amlogic_params },
 	{ .compatible = "amlogic,meson8b-usb",

commit c216765d3a1defda5e7e2dabd878f99f0cd2ebf2
Author: SolidHal <hal@halemmerich.com>
Date:   Tue Oct 2 20:58:16 2018 -0500

    usb: dwc2: disable power_down on rockchip devices
    
     The bug would let the usb controller enter partial power down,
     which was formally known as hibernate, upon boot if nothing was plugged
     in to the port. Partial power down couldn't be exited properly, so any
     usb devices plugged in after boot would not be usable.
    
     Before the name change, params.hibernation was false by default, so
     _dwc2_hcd_suspend() would skip entering hibernation. With the
     rename, _dwc2_hcd_suspend() was changed to use  params.power_down
     to decide whether or not to enter partial power down.
    
     Since params.power_down is non-zero by default, it needs to be set
     to 0 for rockchip devices to restore functionality.
    
     This bug was reported in the linux-usb thread:
     REGRESSION: usb: dwc2: USB device not seen after boot
    
     The commit that caused this regression is:
    6d23ee9caa6790aea047f9aca7f3c03cb8d96eb6
    
    Signed-off-by: SolidHal <hal@halemmerich.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index d150984406ee..7c1b6938f212 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -81,6 +81,7 @@ static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)
 	p->host_perio_tx_fifo_size = 256;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
 		GAHBCFG_HBSTLEN_SHIFT;
+	p->power_down = 0;
 }
 
 static void dwc2_set_ltq_params(struct dwc2_hsotg *hsotg)

commit f3a61e4e033e808e7ac1239b151ec46f833fff4a
Author: Grigor Tovmasyan <Grigor.Tovmasyan@synopsys.com>
Date:   Wed Aug 29 21:01:31 2018 +0400

    usb: dwc2: gadget: Add parameters for GREFCLK register
    
    Added ref_clk_per and sof_cnt_wkup_alert parameters in
    dwc2_core_params struct and set default values.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index dd3c10d537e2..d150984406ee 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -303,6 +303,8 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->max_packet_count = hw->max_packet_count;
 	p->max_transfer_size = hw->max_transfer_size;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;
+	p->ref_clk_per = 33333;
+	p->sof_cnt_wkup_alert = 100;
 
 	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {

commit ca531bc2bfa655a1a0acaac4f7a6ea4b2111cc43
Author: Grigor Tovmasyan <Grigor.Tovmasyan@synopsys.com>
Date:   Wed Aug 29 20:59:34 2018 +0400

    usb: dwc2: Add core parameter for service interval support
    
    Added core parameter for service interval based scheduling.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index bf7052e037d6..dd3c10d537e2 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -299,6 +299,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->hird_threshold_en = true;
 	p->hird_threshold = 4;
 	p->ipg_isoc_en = false;
+	p->service_interval = false;
 	p->max_packet_count = hw->max_packet_count;
 	p->max_transfer_size = hw->max_transfer_size;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;
@@ -592,6 +593,7 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 	CHECK_BOOL(besl, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a));
 	CHECK_BOOL(hird_threshold_en, hsotg->params.lpm);
 	CHECK_RANGE(hird_threshold, 0, hsotg->params.besl ? 12 : 7, 0);
+	CHECK_BOOL(service_interval, hw->service_interval_mode);
 	CHECK_RANGE(max_packet_count,
 		    15, hw->max_packet_count,
 		    hw->max_packet_count);
@@ -780,6 +782,8 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
 	hw->acg_enable = !!(hwcfg4 & GHWCFG4_ACG_SUPPORTED);
 	hw->ipg_isoc_en = !!(hwcfg4 & GHWCFG4_IPG_ISOC_SUPPORTED);
+	hw->service_interval_mode = !!(hwcfg4 &
+				       GHWCFG4_SERVICE_INTERVAL_SUPPORTED);
 
 	/* fifo sizes */
 	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>

commit f8781d55099026061f8b03f2636c0b192f5093e2
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jul 26 13:07:30 2018 -0700

    usb: dwc2: Turn on uframe_sched on "stm32f4x9_fsotg" platforms
    
    There's no reason to have the uframe scheduler off on dwc2.  Running
    with uframe_sched = False is equivalent to saying "I don't want to run
    the correct code, I want to run the old and incorrect code".
    
    The uframe scheduler has been off on stm32f4x9_fsotg since commit
    e35b135055e2 ("usb: dwc2: Add support for STM32F429/439/469 USB OTG
    HS/FS in FS mode (internal PHY)").  That commit is pretty recent, so
    it's unclear to me why the uframe scheduler was left off.  Hopefully
    it's because someone copied it from other parameters and didn't think
    to try it?
    
    Presumably if everyone is good w/ the uframe_sched turned back on we
    can kill all the old and crufty non-uframe sched code.
    
    Reviewed-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 3ac84a3837af..bf7052e037d6 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -131,7 +131,6 @@ static void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)
 	p->max_packet_count = 256;
 	p->phy_type = DWC2_PHY_TYPE_PARAM_FS;
 	p->i2c_enable = false;
-	p->uframe_sched = false;
 	p->activate_stm_fs_transceiver = true;
 }
 

commit 3af0540ad39e0f4935c572ad94f57d5408e95cec
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jul 26 13:07:29 2018 -0700

    usb: dwc2: Turn on uframe_sched on "amlogic" platforms
    
    There's no reason to have the uframe scheduler off on dwc2.  Running
    with uframe_sched = False is equivalent to saying "I don't want to run
    the correct code, I want to run the old and incorrect code".
    
    The uframe scheduler has been off on Amlogic since commit f94310ac076e
    ("usb: dwc2: add support for Meson8b and GXBB SoCs").  While this was
    after most of the recent improvements, notably the commit 9f9f09b048f5
    ("usb: dwc2: host: Totally redo the microframe scheduler"), presumably
    the parameters were copied from another platform and the uframe
    scheduler wasn't tried.
    
    Presumably if everyone is good w/ the uframe_sched turned back on we
    can kill all the old and crufty non-uframe sched code.
    
    Reviewed-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 388c9605602a..3ac84a3837af 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -110,7 +110,6 @@ static void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)
 	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR8 <<
 		GAHBCFG_HBSTLEN_SHIFT;
-	p->uframe_sched = false;
 }
 
 static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)

commit aea8916702eecc76db3d8c111d61d8c78955fe92
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jul 26 13:07:28 2018 -0700

    usb: dwc2: Turn on uframe_sched on "his" platforms
    
    There's no reason to have the uframe scheduler off on dwc2.  Running
    with uframe_sched = False is equivalent to saying "I don't want to run
    the correct code, I want to run the old and incorrect code".
    
    The uframe scheduler has been off on HiSilicon since commit
    37dd9d65cc41 ("usb: dwc2: add support of hi6220").  Since then there
    have been many many improvements, notably the commit 9f9f09b048f5
    ("usb: dwc2: host: Totally redo the microframe scheduler")
    
    Presumably if everyone is good w/ the uframe_sched turned back on we
    can kill all the old and crufty non-uframe sched code.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Reviewed-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index f8a74f504285..388c9605602a 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -67,7 +67,6 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 	p->reload_ctl = false;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
 		GAHBCFG_HBSTLEN_SHIFT;
-	p->uframe_sched = false;
 	p->change_speed_quirk = true;
 	p->power_down = false;
 }

commit b6de7b8c38e99eee5d5ef673f2ff63c982ef608c
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jul 26 13:07:27 2018 -0700

    usb: dwc2: Turn on uframe_sched on "bcm" platforms
    
    There's no reason to have the uframe scheduler off on dwc2.  Running
    with uframe_sched = False is equivalent to saying "I don't want to run
    the correct code, I want to run the old and incorrect code".
    
    The uframe scheduler has been off on Broadcom since commit
    58b179dcf28c ("staging: dwc2: disable uframe_sched on the bcm2835").
    Since then there have been many many improvements, notably the commit
    9f9f09b048f5 ("usb: dwc2: host: Totally redo the microframe
    scheduler")
    
    Presumably if everyone is good w/ the uframe_sched turned back on we
    can kill all the old and crufty non-uframe sched code.
    
    Reviewed-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index f66d0dd5db1c..f8a74f504285 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -47,7 +47,6 @@ static void dwc2_set_bcm_params(struct dwc2_hsotg *hsotg)
 	p->max_transfer_size = 65535;
 	p->max_packet_count = 511;
 	p->ahbcfg = 0x10;
-	p->uframe_sched = false;
 }
 
 static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)

commit f25c42b8d604fbca6d8d3eff2365a73bbef076d3
Author: Gevorg Sahakyan <Gevorg.Sahakyan@synopsys.com>
Date:   Thu Jul 26 18:00:13 2018 +0400

    usb: dwc2: Modify dwc2_readl/writel functions prototype
    
    Added hsotg argument to dwc2_readl/writel function prototype,
    and also instead of address pass offset of register.
    hsotg will contain flag field for endianness.
    
    Also customized dwc2_set_bit and dwc2_clear_bit function for
    dwc2_readl/writel functions.
    
    Signed-off-by: Gevorg Sahakyan <sahakyan@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index af075d4da895..f66d0dd5db1c 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -654,8 +654,8 @@ static void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)
 
 	dwc2_force_mode(hsotg, true);
 
-	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
-	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
+	gnptxfsiz = dwc2_readl(hsotg, GNPTXFSIZ);
+	hptxfsiz = dwc2_readl(hsotg, HPTXFSIZ);
 
 	hw->host_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>
 				       FIFOSIZE_DEPTH_SHIFT;
@@ -679,13 +679,13 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 
 	dwc2_force_mode(hsotg, false);
 
-	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
+	gnptxfsiz = dwc2_readl(hsotg, GNPTXFSIZ);
 
 	fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);
 
 	for (fifo = 1; fifo <= fifo_count; fifo++) {
 		hw->g_tx_fifo_size[fifo] =
-			(dwc2_readl(hsotg->regs + DPTXFSIZN(fifo)) &
+			(dwc2_readl(hsotg, DPTXFSIZN(fifo)) &
 			 FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;
 	}
 
@@ -713,7 +713,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	 * 0x45f4xxxx, 0x5531xxxx or 0x5532xxxx
 	 */
 
-	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
+	hw->snpsid = dwc2_readl(hsotg, GSNPSID);
 	if ((hw->snpsid & GSNPSID_ID_MASK) != DWC2_OTG_ID &&
 	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_FS_IOT_ID &&
 	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_HS_IOT_ID) {
@@ -726,11 +726,11 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
 		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
 
-	hwcfg1 = dwc2_readl(hsotg->regs + GHWCFG1);
-	hwcfg2 = dwc2_readl(hsotg->regs + GHWCFG2);
-	hwcfg3 = dwc2_readl(hsotg->regs + GHWCFG3);
-	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
-	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
+	hwcfg1 = dwc2_readl(hsotg, GHWCFG1);
+	hwcfg2 = dwc2_readl(hsotg, GHWCFG2);
+	hwcfg3 = dwc2_readl(hsotg, GHWCFG3);
+	hwcfg4 = dwc2_readl(hsotg, GHWCFG4);
+	grxfsiz = dwc2_readl(hsotg, GRXFSIZ);
 
 	/* hwcfg1 */
 	hw->dev_ep_dirs = hwcfg1;

commit 47265c067c0d129f3a0e94bc221293a780af9d78
Author: Grigor Tovmasyan <Grigor.Tovmasyan@synopsys.com>
Date:   Tue Apr 3 15:22:25 2018 +0400

    usb: dwc2: gadget: Fix coverity issue
    
    When _param is unsigned and the minimum value of range is 0, it gives
    the following warning:
    COVERITY NO_EFFECT: This less-than-zero comparison of an unsigned value
    is never true.
    
    Converting ._param to int to avoid this warning.
    
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index a24ba13a2f15..af075d4da895 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -556,7 +556,7 @@ static void dwc2_check_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 }
 
 #define CHECK_RANGE(_param, _min, _max, _def) do {			\
-		if ((hsotg->params._param) < (_min) ||			\
+		if ((int)(hsotg->params._param) < (_min) ||		\
 		    (hsotg->params._param) > (_max)) {			\
 			dev_warn(hsotg->dev, "%s: Invalid parameter %s=%d\n", \
 				 __func__, #_param, hsotg->params._param); \

commit d98c624ab3bf9c3c988c3b7d0f24e703061a172f
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri May 18 17:49:03 2018 -0700

    usb: dwc2: Fix HiKey regression caused by power_down feature
    
    In 4.17-rc, commit 03ea6d6e9e1f ("usb: dwc2: Enable power down")
    caused the HiKey board to not correctly handle switching between
    usb-gadget and usb-host mode.
    
    Unplugging the OTG port would result in:
    [   42.240973] dwc2 f72c0000.usb: dwc2_restore_host_registers: no host registers to restore
    [   42.249066] dwc2 f72c0000.usb: dwc2_host_exit_hibernation: failed to restore host registers
    
    And the USB-host ports would not function.
    
    And plugging in the OTG port, we would see:
    [   46.046557] WARNING: CPU: 3 PID: 6 at drivers/usb/dwc2/gadget.c:260 dwc2_hsotg_init_fifo+0x194/0x1a0
    [   46.055761] CPU: 3 PID: 6 Comm: kworker/u16:0 Not tainted 4.17.0-rc5-00030-ge67da8c #231
    [   46.055767] Hardware name: HiKey Development Board (DT)
    [   46.055784] Workqueue: dwc2 dwc2_conn_id_status_change
    ...
    
    Thus, this patch sets the hisi params to disable the power_down
    flag by default, and gets thing working again.
    
    Cc: John Youn <johnyoun@synopsys.com>
    Cc: Vardan Mikayelyan <mvardan@synopsys.com>
    Cc: Artur Petrosyan <arturp@synopsys.com>
    Cc: Grigor Tovmasyan <tovmasya@synopsys.com>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index b43d8c6a749d..a24ba13a2f15 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -70,6 +70,7 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 		GAHBCFG_HBSTLEN_SHIFT;
 	p->uframe_sched = false;
 	p->change_speed_quirk = true;
+	p->power_down = false;
 }
 
 static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)

commit 6fb914d788133fd2298af87c50aefe1863cf1445
Author: Grigor Tovmasyan <Grigor.Tovmasyan@synopsys.com>
Date:   Wed May 16 12:04:24 2018 +0400

    usb: dwc2: Fix kernel doc's warnings.
    
    Added descriptions for all not described parameters.
    Fix all kernel doc's warnings.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2700f5279285..b43d8c6a749d 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -269,6 +269,9 @@ static void dwc2_set_param_power_down(struct dwc2_hsotg *hsotg)
 /**
  * dwc2_set_default_params() - Set all core parameters to their
  * auto-detected default values.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
  */
 static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 {
@@ -339,6 +342,8 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 /**
  * dwc2_get_device_properties() - Read in device properties.
  *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
  * Read in the device properties and adjust core parameters if needed.
  */
 static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
@@ -690,6 +695,9 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 /**
  * During device initialization, read various hardware configuration
  * registers and interpret the contents.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
  */
 int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 {

commit b43ebc96e985fed9417c6aff769a6839bdaa6cdf
Author: Grigor Tovmasyan <Grigor.Tovmasyan@synopsys.com>
Date:   Sat May 5 12:17:58 2018 +0400

    usb: dwc2: Add Interpacket Gap(IPG) feature support
    
    Added GHWCFG4_IPG_ISOC_SUPPORTED and DCFG_IPG_ISOC_SUPPORDED
    bits definitions to enable/disable IPG feature.
    
    Added ipg_isoc_en core parameter which will indicate IPG support
    enable/disable and initialize it.
    
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index f03e41879224..2700f5279285 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -298,6 +298,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->besl = true;
 	p->hird_threshold_en = true;
 	p->hird_threshold = 4;
+	p->ipg_isoc_en = false;
 	p->max_packet_count = hw->max_packet_count;
 	p->max_transfer_size = hw->max_transfer_size;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;
@@ -579,6 +580,7 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 	CHECK_BOOL(enable_dynamic_fifo, hw->enable_dynamic_fifo);
 	CHECK_BOOL(en_multiple_tx_fifo, hw->en_multiple_tx_fifo);
 	CHECK_BOOL(i2c_enable, hw->i2c_enable);
+	CHECK_BOOL(ipg_isoc_en, hw->ipg_isoc_en);
 	CHECK_BOOL(acg_enable, hw->acg_enable);
 	CHECK_BOOL(reload_ctl, (hsotg->hw_params.snpsid > DWC2_CORE_REV_2_92a));
 	CHECK_BOOL(lpm, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_80a));
@@ -772,6 +774,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>
 				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
 	hw->acg_enable = !!(hwcfg4 & GHWCFG4_ACG_SUPPORTED);
+	hw->ipg_isoc_en = !!(hwcfg4 & GHWCFG4_IPG_ISOC_SUPPORTED);
 
 	/* fifo sizes */
 	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>

commit 6d23ee9caa6790aea047f9aca7f3c03cb8d96eb6
Merge: 6555ad13a019 aaeab02ddcc8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Mar 23 13:33:09 2018 +0100

    Merge tag 'usb-for-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-testing
    
    Felipe writes:
    
    usb: changes for v4.17 merge window
    
    Quite a lot happened in this cycle, with a total of 95 non-merge
    commits. The most interesting parts are listed below:
    
    Synopsys has been adding better support for USB 3.1 to dwc3. The same
    series also sets g_mass_storage's max speed to SSP.
    
    Roger Quadros (TI) added support for dual-role using the OTG block
    available in some dwc3 implementations, this makes sure that AM437x
    can swap roles in runtime.
    
    We have a new SoC supported in dwc3 now - Amlogic Meson GX - thanks to
    the work of Martin Blumenstingl.
    
    We also have a ton of changes in dwc2 (51% of all changes, in
    fact). The most interesting part there is the support for
    Hibernation (a Synopsys PM feature).
    
    Apart from these, we have our regular set of non-critical fixes all
    over the place.

commit 13b1f8e25bfd1d6b96278421f934efdd35be9d5b
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Fri Feb 16 12:56:03 2018 +0400

    usb: dwc2: Force mode optimizations
    
    If the dr_mode is USB_DR_MODE_OTG, forcing the mode is needed during
    driver probe to get the host and device specific HW parameters. Then we
    clear the force mode bits so that the core operates in OTG mode.
    
    The force mode bits should not be touched at any other time during the
    driver lifetime and they should be preserved whenever the GUSBCFG
    register is written to. The force mode bit values will persist across
    soft resets of the core.
    
    If the dr_mode is either USB_DR_MODE_HOST or USB_DR_MODE_PERIPHERAL, the
    force mode is set just once at probe to configure the core as either a
    host or peripheral.
    
    Given the above, we no longer need any other reset delays, force delays,
    or any forced modes anywhere else in the driver. So replace all calls to
    dwc2_core_reset_and_force_dr_mode() with dwc2_core_reset() and remove
    all other unnecessary delays.
    
    Also remove the dwc2_force_mode_if_needed() function since the "if
    needed" part is already taken care of by the polling in
    dwc2_force_mode().
    
    Finally, remove all other calls to dwc2_clear_force_mode().
    
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6c7588a2f485..b3871fcafe1e 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -640,19 +640,15 @@ static void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)
 	struct dwc2_hw_params *hw = &hsotg->hw_params;
 	u32 gnptxfsiz;
 	u32 hptxfsiz;
-	bool forced;
 
 	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
 		return;
 
-	forced = dwc2_force_mode_if_needed(hsotg, true);
+	dwc2_force_mode(hsotg, true);
 
 	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
 	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
 
-	if (forced)
-		dwc2_clear_force_mode(hsotg);
-
 	hw->host_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>
 				       FIFOSIZE_DEPTH_SHIFT;
 	hw->host_perio_tx_fifo_size = (hptxfsiz & FIFOSIZE_DEPTH_MASK) >>
@@ -667,14 +663,13 @@ static void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)
 static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_hw_params *hw = &hsotg->hw_params;
-	bool forced;
 	u32 gnptxfsiz;
 	int fifo, fifo_count;
 
 	if (hsotg->dr_mode == USB_DR_MODE_HOST)
 		return;
 
-	forced = dwc2_force_mode_if_needed(hsotg, false);
+	dwc2_force_mode(hsotg, false);
 
 	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
 
@@ -686,9 +681,6 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 			 FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;
 	}
 
-	if (forced)
-		dwc2_clear_force_mode(hsotg);
-
 	hw->dev_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>
 				       FIFOSIZE_DEPTH_SHIFT;
 }

commit 03ea6d6e9e1ff1b0222eb723eee5990d3511cc4d
Author: John Youn <johnyoun@synopsys.com>
Date:   Fri Feb 16 14:12:28 2018 +0400

    usb: dwc2: Enable power down
    
    Enable the power down option based on the core capability.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: Artur Petrosyan <arturp@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index daf0f9ac7149..6c7588a2f485 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -252,6 +252,20 @@ static void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 		p->g_tx_fifo_size[i] = depth_average;
 }
 
+static void dwc2_set_param_power_down(struct dwc2_hsotg *hsotg)
+{
+	int val;
+
+	if (hsotg->hw_params.hibernation)
+		val = 2;
+	else if (hsotg->hw_params.power_optimized)
+		val = 1;
+	else
+		val = 0;
+
+	hsotg->params.power_down = val;
+}
+
 /**
  * dwc2_set_default_params() - Set all core parameters to their
  * auto-detected default values.
@@ -266,6 +280,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	dwc2_set_param_phy_type(hsotg);
 	dwc2_set_param_speed(hsotg);
 	dwc2_set_param_phy_utmi_width(hsotg);
+	dwc2_set_param_power_down(hsotg);
 	p->phy_ulpi_ddr = false;
 	p->phy_ulpi_ext_vbus = false;
 
@@ -278,7 +293,6 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
 	p->uframe_sched = true;
 	p->external_id_pin_ctl = false;
-	p->power_down = false;
 	p->lpm = true;
 	p->lpm_clock_gating = true;
 	p->besl = true;

commit 631a23108c1a90b726ca99f1f90d48a91737f43d
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Fri Feb 16 14:07:05 2018 +0400

    usb: dwc2: Add hibernation field into dwc2_hw_params
    
    Add parameter and it's initialization, needed for hibernation.
    
    Reimplement dwc2_set_param_power_down() to support hibernation too.
    Now 'power_down' parameter can be initialized with 0, 1 or 2.
    0 - No
    1 - Partial power down
    2 - Hibernation
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index c64b1ad50712..daf0f9ac7149 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -469,6 +469,38 @@ static void dwc2_check_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
 		dwc2_set_param_phy_utmi_width(hsotg);
 }
 
+static void dwc2_check_param_power_down(struct dwc2_hsotg *hsotg)
+{
+	int param = hsotg->params.power_down;
+
+	switch (param) {
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		break;
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		if (hsotg->hw_params.power_optimized)
+			break;
+		dev_dbg(hsotg->dev,
+			"Partial power down isn't supported by HW\n");
+		param = DWC2_POWER_DOWN_PARAM_NONE;
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		if (hsotg->hw_params.hibernation)
+			break;
+		dev_dbg(hsotg->dev,
+			"Hibernation isn't supported by HW\n");
+		param = DWC2_POWER_DOWN_PARAM_NONE;
+		break;
+	default:
+		dev_err(hsotg->dev,
+			"%s: Invalid parameter power_down=%d\n",
+			__func__, param);
+		param = DWC2_POWER_DOWN_PARAM_NONE;
+		break;
+	}
+
+	hsotg->params.power_down = param;
+}
+
 static void dwc2_check_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 {
 	int fifo_count;
@@ -529,6 +561,7 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 	dwc2_check_param_phy_type(hsotg);
 	dwc2_check_param_speed(hsotg);
 	dwc2_check_param_phy_utmi_width(hsotg);
+	dwc2_check_param_power_down(hsotg);
 	CHECK_BOOL(enable_dynamic_fifo, hw->enable_dynamic_fifo);
 	CHECK_BOOL(en_multiple_tx_fifo, hw->en_multiple_tx_fifo);
 	CHECK_BOOL(i2c_enable, hw->i2c_enable);
@@ -729,6 +762,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 			     GHWCFG4_NUM_IN_EPS_SHIFT;
 	hw->dma_desc_enable = !!(hwcfg4 & GHWCFG4_DESC_DMA);
 	hw->power_optimized = !!(hwcfg4 & GHWCFG4_POWER_OPTIMIZ);
+	hw->hibernation = !!(hwcfg4 & GHWCFG4_HIBER);
 	hw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>
 				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
 	hw->acg_enable = !!(hwcfg4 & GHWCFG4_ACG_SUPPORTED);

commit 41ba9b9b95beb8bb101a40c6badbbe49da6af9cd
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Fri Feb 16 14:06:36 2018 +0400

    usb: dwc2: Rename hibernation to partial_power_down
    
    No-op change, only rename.
    
    This code was misnamed originally. It was only responsible for partial
    power down and not for hibernation.
    
    Rename core_params->hibernation to core_params->power_down,
    dwc2_set_param_hibernation() to dwc2_set_param_power_down().
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 827f7f81a27c..c64b1ad50712 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -278,7 +278,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
 	p->uframe_sched = true;
 	p->external_id_pin_ctl = false;
-	p->hibernation = false;
+	p->power_down = false;
 	p->lpm = true;
 	p->lpm_clock_gating = true;
 	p->besl = true;

commit 6f80b6de0ecf65077b53c86967c714d42f4299e0
Author: Sevak Arakelyan <sevaka@synopsys.com>
Date:   Wed Jan 24 17:41:48 2018 +0400

    usb: dwc2: Add core parameters for LPM support
    
    Add lpm, lpm_clock_gating, besl, hird_threshold_en and hird_threshold
    core parameters. These will indicate LPM and LPM Errata support
    as well as chosen L1 sleeping mode for the core and PHY.
    
    Signed-off-by: Sevak Arakelyan <sevaka@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index f0f877c4528d..827f7f81a27c 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -279,6 +279,11 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->uframe_sched = true;
 	p->external_id_pin_ctl = false;
 	p->hibernation = false;
+	p->lpm = true;
+	p->lpm_clock_gating = true;
+	p->besl = true;
+	p->hird_threshold_en = true;
+	p->hird_threshold = 4;
 	p->max_packet_count = hw->max_packet_count;
 	p->max_transfer_size = hw->max_transfer_size;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;
@@ -529,6 +534,13 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 	CHECK_BOOL(i2c_enable, hw->i2c_enable);
 	CHECK_BOOL(acg_enable, hw->acg_enable);
 	CHECK_BOOL(reload_ctl, (hsotg->hw_params.snpsid > DWC2_CORE_REV_2_92a));
+	CHECK_BOOL(lpm, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_80a));
+	CHECK_BOOL(lpm, hw->lpm_mode);
+	CHECK_BOOL(lpm_clock_gating, hsotg->params.lpm);
+	CHECK_BOOL(besl, hsotg->params.lpm);
+	CHECK_BOOL(besl, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a));
+	CHECK_BOOL(hird_threshold_en, hsotg->params.lpm);
+	CHECK_RANGE(hird_threshold, 0, hsotg->params.besl ? 12 : 7, 0);
 	CHECK_RANGE(max_packet_count,
 		    15, hw->max_packet_count,
 		    hw->max_packet_count);
@@ -707,6 +719,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hw->i2c_enable = !!(hwcfg3 & GHWCFG3_I2C);
 	hw->total_fifo_size = (hwcfg3 & GHWCFG3_DFIFO_DEPTH_MASK) >>
 			      GHWCFG3_DFIFO_DEPTH_SHIFT;
+	hw->lpm_mode = !!(hwcfg3 & GHWCFG3_OTG_LPM_EN);
 
 	/* hwcfg4 */
 	hw->en_multiple_tx_fifo = !!(hwcfg4 & GHWCFG4_DED_FIFO_EN);

commit 66e77a24a8c36ff83f0a12f44d23d8141e82fa3b
Author: Razmik Karapetyan <razmik@synopsys.com>
Date:   Wed Jan 24 17:40:29 2018 +0400

    usb: dwc2: Add ACG support to the driver
    
    Added function for supporting Active Clock Gating functionality
    in the driver.
    
    PCGCCTL1 (Power and Clock Control) register will be used
    for controlling the core`s active clock gating feature, and
    the previously reserved 12th bit in GHWCFG4 now indicates that the
    controller supports the Dynamic Power Reduction (Active Clock Gating)
    during no traffic scenarios such as L0, idle, resume and suspend
    states.
    
    dwc2_enable_acg() function sets GATEEN bit in PCGCCTL1 register
    and enables ACG, if it supported.
    
    According to ACG functional specification, enabling of ACG feature
    in host mode done in host initialization, before turning Vbus on,
    specifically in dwc2_core_host_init function.
    
    Enabling of ACG feature in device mode done in device initialization,
    before clearing the SftDiscon bit in DCTL.
    This bit was cleared in dwc2_hsotg_core_connect() function.So
    dwc2_enable_acg() called before dwc2_core_connect() calls.
    
    Signed-off-by: Razmik Karapetyan <razmik@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 430325510812..f0f877c4528d 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -272,6 +272,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->enable_dynamic_fifo = hw->enable_dynamic_fifo;
 	p->en_multiple_tx_fifo = hw->en_multiple_tx_fifo;
 	p->i2c_enable = hw->i2c_enable;
+	p->acg_enable = hw->acg_enable;
 	p->ulpi_fs_ls = false;
 	p->ts_dline = false;
 	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
@@ -526,6 +527,7 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 	CHECK_BOOL(enable_dynamic_fifo, hw->enable_dynamic_fifo);
 	CHECK_BOOL(en_multiple_tx_fifo, hw->en_multiple_tx_fifo);
 	CHECK_BOOL(i2c_enable, hw->i2c_enable);
+	CHECK_BOOL(acg_enable, hw->acg_enable);
 	CHECK_BOOL(reload_ctl, (hsotg->hw_params.snpsid > DWC2_CORE_REV_2_92a));
 	CHECK_RANGE(max_packet_count,
 		    15, hw->max_packet_count,
@@ -716,6 +718,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hw->power_optimized = !!(hwcfg4 & GHWCFG4_POWER_OPTIMIZ);
 	hw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>
 				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
+	hw->acg_enable = !!(hwcfg4 & GHWCFG4_ACG_SUPPORTED);
 
 	/* fifo sizes */
 	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>

commit 1b52d2fac4075e8e32a95ad81b521fdab1e1678c
Author: Razmik Karapetyan <razmik@synopsys.com>
Date:   Fri Jan 19 14:40:23 2018 +0400

    usb: dwc2: Set AHB burst size to INCR
    
    Changed AHB burst size from INCR4 to INCR by default.
    With this value driver shows excellent DMA performance.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Razmik Karapetyan <razmik@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 82f5846d7671..430325510812 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -280,7 +280,7 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	p->hibernation = false;
 	p->max_packet_count = hw->max_packet_count;
 	p->max_transfer_size = hw->max_transfer_size;
-	p->ahbcfg = GAHBCFG_HBSTLEN_INCR4 << GAHBCFG_HBSTLEN_SHIFT;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;
 
 	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {

commit d14ccaba8dc7aa1f137ef93349b08196ce0f0347
Author: Gevorg Sahakyan <sahakyan@synopsys.com>
Date:   Tue Jan 16 16:21:46 2018 +0400

    usb: dwc2: Remove version check in GSNPSID
    
    Only check the ID portion of the GSNPSID register and dont check
    the version. This will allow the driver to work with version 4.00a
    and later of the DWC_hsotg IP.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Gevorg Sahakyan <sahakyan@synopsys.com>
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 03fd20f0b496..82f5846d7671 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -646,14 +646,13 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	/*
 	 * Attempt to ensure this device is really a DWC_otg Controller.
 	 * Read and verify the GSNPSID register contents. The value should be
-	 * 0x45f42xxx or 0x45f43xxx, which corresponds to either "OT2" or "OT3",
-	 * as in "OTG version 2.xx" or "OTG version 3.xx".
+	 * 0x45f4xxxx, 0x5531xxxx or 0x5532xxxx
 	 */
+
 	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
-	if ((hw->snpsid & 0xfffff000) != 0x4f542000 &&
-	    (hw->snpsid & 0xfffff000) != 0x4f543000 &&
-	    (hw->snpsid & 0xffff0000) != 0x55310000 &&
-	    (hw->snpsid & 0xffff0000) != 0x55320000) {
+	if ((hw->snpsid & GSNPSID_ID_MASK) != DWC2_OTG_ID &&
+	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_FS_IOT_ID &&
+	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_HS_IOT_ID) {
 		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
 			hw->snpsid);
 		return -ENODEV;

commit 1a149e3554e0324a3d551dfb327bdb67b150a320
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Thu Mar 1 11:05:35 2018 +0100

    usb: dwc2: fix STM32F7 USB OTG HS compatible
    
    This patch fixes compatible for STM32F7 USB OTG HS and consistently rename
    dw2_set_params function.
    The v2 former patch [1] had been acked by Paul Young, but v1 was merged.
    
    [1] https://patchwork.kernel.org/patch/9925573/
    
    Fixes: d8fae8b93682 ("usb: dwc2: add support for STM32F7xx USB OTG HS")
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 03fd20f0b496..c4a47496d2fb 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -137,7 +137,7 @@ static void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)
 	p->activate_stm_fs_transceiver = true;
 }
 
-static void dwc2_set_stm32f7xx_hsotg_params(struct dwc2_hsotg *hsotg)
+static void dwc2_set_stm32f7_hsotg_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
@@ -164,8 +164,8 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "st,stm32f4x9-fsotg",
 	  .data = dwc2_set_stm32f4x9_fsotg_params },
 	{ .compatible = "st,stm32f4x9-hsotg" },
-	{ .compatible = "st,stm32f7xx-hsotg",
-	  .data = dwc2_set_stm32f7xx_hsotg_params },
+	{ .compatible = "st,stm32f7-hsotg",
+	  .data = dwc2_set_stm32f7_hsotg_params },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 9273083a1530891360e9fe4fad26ae96810db499
Author: Minas Harutyunyan <Minas.Harutyunyan@synopsys.com>
Date:   Thu Nov 30 12:16:37 2017 +0400

    usb: dwc2: Fix TxFIFOn sizes and total TxFIFO size issues
    
    In host mode reading from DPTXSIZn returning invalid value in
    dwc2_check_param_tx_fifo_sizes function.
    
    In total TxFIFO size calculations unnecessarily reducing by ep_info.
    hw->total_fifo_size can be fully allocated for FIFO's.
    
    Added num_dev_in_eps member in dwc2_hw_params structure to save number
    of IN EPs.
    
    Added g_tx_fifo_size array in dwc2_hw_params structure to store power
    on reset values of DPTXSIZn registers in forced device mode.
    
    Updated dwc2_hsotg_tx_fifo_count() function to get TxFIFO count from
    num_dev_in_eps.
    
    Updated dwc2_get_dev_hwparams() function to store DPTXFSIZn in
    g_tx_fifo_size array.
    
    dwc2_get_host/dev_hwparams() functions call moved after num_dev_in_eps
    set from hwcfg4.
    
    Modified dwc2_check_param_tx_fifo_sizes() function to check TxFIFOn
    sizes based on g_tx_fifo_size array.
    
    Removed ep_info subtraction during calculation of tx_addr_max in
    dwc2_hsotg_tx_fifo_total_depth() function. Also removed
    dwc2_hsotg_ep_info_size() function as no more need.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Gevorg Sahakyan <sahakyan@synopsys.com>
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index ef73af6e03a9..03fd20f0b496 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -484,8 +484,7 @@ static void dwc2_check_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 	}
 
 	for (fifo = 1; fifo <= fifo_count; fifo++) {
-		dptxfszn = (dwc2_readl(hsotg->regs + DPTXFSIZN(fifo)) &
-			FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;
+		dptxfszn = hsotg->hw_params.g_tx_fifo_size[fifo];
 
 		if (hsotg->params.g_tx_fifo_size[fifo] < min ||
 		    hsotg->params.g_tx_fifo_size[fifo] >  dptxfszn) {
@@ -609,6 +608,7 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 	struct dwc2_hw_params *hw = &hsotg->hw_params;
 	bool forced;
 	u32 gnptxfsiz;
+	int fifo, fifo_count;
 
 	if (hsotg->dr_mode == USB_DR_MODE_HOST)
 		return;
@@ -617,6 +617,14 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 
 	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
 
+	fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);
+
+	for (fifo = 1; fifo <= fifo_count; fifo++) {
+		hw->g_tx_fifo_size[fifo] =
+			(dwc2_readl(hsotg->regs + DPTXFSIZN(fifo)) &
+			 FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;
+	}
+
 	if (forced)
 		dwc2_clear_force_mode(hsotg);
 
@@ -661,14 +669,6 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
 	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
 
-	/*
-	 * Host specific hardware parameters. Reading these parameters
-	 * requires the controller to be in host mode. The mode will
-	 * be forced, if necessary, to read these values.
-	 */
-	dwc2_get_host_hwparams(hsotg);
-	dwc2_get_dev_hwparams(hsotg);
-
 	/* hwcfg1 */
 	hw->dev_ep_dirs = hwcfg1;
 
@@ -711,6 +711,8 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hw->en_multiple_tx_fifo = !!(hwcfg4 & GHWCFG4_DED_FIFO_EN);
 	hw->num_dev_perio_in_ep = (hwcfg4 & GHWCFG4_NUM_DEV_PERIO_IN_EP_MASK) >>
 				  GHWCFG4_NUM_DEV_PERIO_IN_EP_SHIFT;
+	hw->num_dev_in_eps = (hwcfg4 & GHWCFG4_NUM_IN_EPS_MASK) >>
+			     GHWCFG4_NUM_IN_EPS_SHIFT;
 	hw->dma_desc_enable = !!(hwcfg4 & GHWCFG4_DESC_DMA);
 	hw->power_optimized = !!(hwcfg4 & GHWCFG4_POWER_OPTIMIZ);
 	hw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>
@@ -719,6 +721,13 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	/* fifo sizes */
 	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>
 				GRXFSIZ_DEPTH_SHIFT;
+	/*
+	 * Host specific hardware parameters. Reading these parameters
+	 * requires the controller to be in host mode. The mode will
+	 * be forced, if necessary, to read these values.
+	 */
+	dwc2_get_host_hwparams(hsotg);
+	dwc2_get_dev_hwparams(hsotg);
 
 	return 0;
 }

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index fe770a2834d2..ef73af6e03a9 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
  * Copyright (C) 2004-2016 Synopsys, Inc.
  *

commit b11633c42a766cb3c824e3583163b9adf67501fe
Author: Dinh Nguyen <dinguyen@kernel.org>
Date:   Mon Oct 16 08:57:18 2017 -0500

    usb: dwc2: disable erroneous overcurrent condition
    
    For the case where an external VBUS is used, we should enable the external
    VBUS comparator in the driver. This would prevent an unnecessary
    overcurrent error which would then disable the host port.
    
    This patch uses the standard 'disable-over-current' binding to allow of the
    option of disabling the over-current condition.
    
    Reviewed-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Dinh Nguyen <dinguyen@kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 015d23ebcf5a..fe770a2834d2 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -346,6 +346,9 @@ static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
 						       num);
 		}
 	}
+
+	if (of_find_property(hsotg->dev->of_node, "disable-over-current", NULL))
+		p->oc_disable = true;
 }
 
 static void dwc2_check_param_otg_cap(struct dwc2_hsotg *hsotg)

commit d8fae8b936824b3ffe55a0408b84022244603a32
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Thu Aug 17 11:33:01 2017 +0200

    usb: dwc2: add support for STM32F7xx USB OTG HS
    
    This patch adds the dwc2_set_params function for STM32F7xx USB OTG HS.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index a3ffe97170ff..015d23ebcf5a 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -136,6 +136,15 @@ static void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)
 	p->activate_stm_fs_transceiver = true;
 }
 
+static void dwc2_set_stm32f7xx_hsotg_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->host_rx_fifo_size = 622;
+	p->host_nperio_tx_fifo_size = 128;
+	p->host_perio_tx_fifo_size = 256;
+}
+
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
 	{ .compatible = "hisilicon,hi6220-usb", .data = dwc2_set_his_params  },
@@ -154,6 +163,8 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "st,stm32f4x9-fsotg",
 	  .data = dwc2_set_stm32f4x9_fsotg_params },
 	{ .compatible = "st,stm32f4x9-hsotg" },
+	{ .compatible = "st,stm32f7xx-hsotg",
+	  .data = dwc2_set_stm32f7xx_hsotg_params },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 55b644fd2431cfd28d04cc28f092d49e7bea3433
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat May 6 19:37:45 2017 +0200

    usb: dwc2: add support for the DWC2 controller on Meson8 SoCs
    
    USB support in the Meson8 SoCs is provided by a DWC2 controller which
    works with the same settings as Meson8b and GXBB. Using the generic
    "snps,dwc2" binding results in an endless stream of "Overcurrent change
    detected" messages.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 9cd8722f24f6..a3ffe97170ff 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -144,6 +144,8 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "lantiq,xrx200-usb", .data = dwc2_set_ltq_params },
 	{ .compatible = "snps,dwc2" },
 	{ .compatible = "samsung,s3c6400-hsotg" },
+	{ .compatible = "amlogic,meson8-usb",
+	  .data = dwc2_set_amlogic_params },
 	{ .compatible = "amlogic,meson8b-usb",
 	  .data = dwc2_set_amlogic_params },
 	{ .compatible = "amlogic,meson-gxbb-usb",

commit e35b135055e24d705736fd98c975afc46a793a09
Author: Bruno Herrera <bruherrera@gmail.com>
Date:   Tue Jan 31 23:25:43 2017 -0200

    usb: dwc2: Add support for STM32F429/439/469 USB OTG HS/FS in FS mode (internal PHY)
    
    This patch introduces a new parameter to activate USB OTG HS/FS core
    embedded phy transceiver. The STM32F4x9 SoC uses the GGPIO register
    to enable the transceiver.
    Also add the dwc2_set_params function for stm32f4 otg fs.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Bruno Herrera <bruherrera@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2990c347289f..9cd8722f24f6 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -120,6 +120,22 @@ static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;
 }
 
+static void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->speed = DWC2_SPEED_PARAM_FULL;
+	p->host_rx_fifo_size = 128;
+	p->host_nperio_tx_fifo_size = 96;
+	p->host_perio_tx_fifo_size = 96;
+	p->max_packet_count = 256;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_FS;
+	p->i2c_enable = false;
+	p->uframe_sched = false;
+	p->activate_stm_fs_transceiver = true;
+}
+
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
 	{ .compatible = "hisilicon,hi6220-usb", .data = dwc2_set_his_params  },
@@ -133,6 +149,9 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "amlogic,meson-gxbb-usb",
 	  .data = dwc2_set_amlogic_params },
 	{ .compatible = "amcc,dwc-otg", .data = dwc2_set_amcc_params },
+	{ .compatible = "st,stm32f4x9-fsotg",
+	  .data = dwc2_set_stm32f4x9_fsotg_params },
+	{ .compatible = "st,stm32f4x9-hsotg" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 3c6aea7344c363f298bfb9952e2906b9574f59dc
Author: Sevak Arakelyan <sevaka@synopsys.com>
Date:   Mon Jan 23 15:01:45 2017 -0800

    usb: dwc2: gadget: Add checking for g-tx-fifo-size parameter
    
    Add dwc2_check_param_tx_fifo_sizes function which validates
    the members of g_tx_fifo_size array and sets to average or
    default values if it is needed.
    
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Sevak Arakelyan <sevaka@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 016fff0cb887..2990c347289f 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -427,6 +427,40 @@ static void dwc2_check_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
 		dwc2_set_param_phy_utmi_width(hsotg);
 }
 
+static void dwc2_check_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
+{
+	int fifo_count;
+	int fifo;
+	int min;
+	u32 total = 0;
+	u32 dptxfszn;
+
+	fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);
+	min = hsotg->hw_params.en_multiple_tx_fifo ? 16 : 4;
+
+	for (fifo = 1; fifo <= fifo_count; fifo++)
+		total += hsotg->params.g_tx_fifo_size[fifo];
+
+	if (total > dwc2_hsotg_tx_fifo_total_depth(hsotg) || !total) {
+		dev_warn(hsotg->dev, "%s: Invalid parameter g-tx-fifo-size, setting to default average\n",
+			 __func__);
+		dwc2_set_param_tx_fifo_sizes(hsotg);
+	}
+
+	for (fifo = 1; fifo <= fifo_count; fifo++) {
+		dptxfszn = (dwc2_readl(hsotg->regs + DPTXFSIZN(fifo)) &
+			FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;
+
+		if (hsotg->params.g_tx_fifo_size[fifo] < min ||
+		    hsotg->params.g_tx_fifo_size[fifo] >  dptxfszn) {
+			dev_warn(hsotg->dev, "%s: Invalid parameter g_tx_fifo_size[%d]=%d\n",
+				 __func__, fifo,
+				 hsotg->params.g_tx_fifo_size[fifo]);
+			hsotg->params.g_tx_fifo_size[fifo] = dptxfszn;
+		}
+	}
+}
+
 #define CHECK_RANGE(_param, _min, _max, _def) do {			\
 		if ((hsotg->params._param) < (_min) ||			\
 		    (hsotg->params._param) > (_max)) {			\
@@ -496,6 +530,7 @@ static void dwc2_check_params(struct dwc2_hsotg *hsotg)
 		CHECK_RANGE(g_np_tx_fifo_size,
 			    16, hw->dev_nperio_tx_fifo_size,
 			    hw->dev_nperio_tx_fifo_size);
+		dwc2_check_param_tx_fifo_sizes(hsotg);
 	}
 }
 

commit c138ecfa6108edee17fabfa56285b00f66641659
Author: Sevak Arakelyan <sevaka@synopsys.com>
Date:   Mon Jan 23 15:01:23 2017 -0800

    usb: dwc2: gadget: Set TX FIFO depths to calculated defaults
    
    Remove legacy DWC2_G_P_LEGACY_TX_FIFO_SIZE array for TX FIFOs.
    Update dwc2_set_param_tx_fifo_sizes function to calculate
    and assign default average FIFO depth to each member of
    g_tx_fifo_size array. Total FIFO size, EP Info block's size,
    FIFO operation mode and device operation mode are taken into
    consideration during the calculation.
    
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Sevak Arakelyan <sevaka@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 8e5039e2d3fc..016fff0cb887 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -207,12 +207,16 @@ static void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
 static void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
-	u32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;
+	int depth_average;
+	int fifo_count;
+	int i;
+
+	fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);
 
 	memset(p->g_tx_fifo_size, 0, sizeof(p->g_tx_fifo_size));
-	memcpy(&p->g_tx_fifo_size[1],
-	       p_tx_fifo,
-	       sizeof(p_tx_fifo));
+	depth_average = dwc2_hsotg_tx_fifo_average_depth(hsotg);
+	for (i = 1; i <= fifo_count; i++)
+		p->g_tx_fifo_size[i] = depth_average;
 }
 
 /**

commit ca8b03324877e1804161fd4e0100d49f03ad9fce
Author: Chen Yu <chenyu56@huawei.com>
Date:   Mon Jan 23 15:00:18 2017 -0800

    usb: dwc2: Add a quirk to allow speed negotiation for Hisilicon Hi6220
    
    The Hi6220's usb controller is limited in that it does not
    support "Split Transactions", so it does not support communicating
    with low-speed and full-speed devices behind a high-speed hub.
    
    Thus it requires a quirk so that we can manually drop the usb
    speed when low/full-speed are attached, and bump back to high
    speed when they are removed.
    
    Cc: Wei Xu <xuwei5@hisilicon.com>
    Cc: Guodong Xu <guodong.xu@linaro.org>
    Cc: Amit Pundir <amit.pundir@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: John Youn <johnyoun@synopsys.com>
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Chen Yu <chenyu56@huawei.com>
    Cc: Vardan Mikayelyan <mvardan@synopsys.com>
    Cc: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Chen Yu <chenyu56@huawei.com>
    [jstultz: Reworked to simplify the patch, and made
     commit log to be more specific about the issue]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 620b02723f0d..8e5039e2d3fc 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -68,6 +68,7 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
 		GAHBCFG_HBSTLEN_SHIFT;
 	p->uframe_sched = false;
+	p->change_speed_quirk = true;
 }
 
 static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)

commit 5dc6422564b3f6ab8f87611ca1ade3adb369770b
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:58:31 2017 -0800

    usb: dwc2: Remove debug prints in params.c
    
    Remove debugging prints to show params.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 0e7f0f92c18f..620b02723f0d 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -513,8 +513,6 @@ static void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)
 
 	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
 	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
-	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
-	dev_dbg(hsotg->dev, "hptxfsiz=%08x\n", hptxfsiz);
 
 	if (forced)
 		dwc2_clear_force_mode(hsotg);
@@ -542,7 +540,6 @@ static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
 	forced = dwc2_force_mode_if_needed(hsotg, false);
 
 	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
-	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
 
 	if (forced)
 		dwc2_clear_force_mode(hsotg);
@@ -588,12 +585,6 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
 	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
 
-	dev_dbg(hsotg->dev, "hwcfg1=%08x\n", hwcfg1);
-	dev_dbg(hsotg->dev, "hwcfg2=%08x\n", hwcfg2);
-	dev_dbg(hsotg->dev, "hwcfg3=%08x\n", hwcfg3);
-	dev_dbg(hsotg->dev, "hwcfg4=%08x\n", hwcfg4);
-	dev_dbg(hsotg->dev, "grxfsiz=%08x\n", grxfsiz);
-
 	/*
 	 * Host specific hardware parameters. Reading these parameters
 	 * requires the controller to be in host mode. The mode will
@@ -653,53 +644,6 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>
 				GRXFSIZ_DEPTH_SHIFT;
 
-	dev_dbg(hsotg->dev, "Detected values from hardware:\n");
-	dev_dbg(hsotg->dev, "  op_mode=%d\n",
-		hw->op_mode);
-	dev_dbg(hsotg->dev, "  arch=%d\n",
-		hw->arch);
-	dev_dbg(hsotg->dev, "  dma_desc_enable=%d\n",
-		hw->dma_desc_enable);
-	dev_dbg(hsotg->dev, "  power_optimized=%d\n",
-		hw->power_optimized);
-	dev_dbg(hsotg->dev, "  i2c_enable=%d\n",
-		hw->i2c_enable);
-	dev_dbg(hsotg->dev, "  hs_phy_type=%d\n",
-		hw->hs_phy_type);
-	dev_dbg(hsotg->dev, "  fs_phy_type=%d\n",
-		hw->fs_phy_type);
-	dev_dbg(hsotg->dev, "  utmi_phy_data_width=%d\n",
-		hw->utmi_phy_data_width);
-	dev_dbg(hsotg->dev, "  num_dev_ep=%d\n",
-		hw->num_dev_ep);
-	dev_dbg(hsotg->dev, "  num_dev_perio_in_ep=%d\n",
-		hw->num_dev_perio_in_ep);
-	dev_dbg(hsotg->dev, "  host_channels=%d\n",
-		hw->host_channels);
-	dev_dbg(hsotg->dev, "  max_transfer_size=%d\n",
-		hw->max_transfer_size);
-	dev_dbg(hsotg->dev, "  max_packet_count=%d\n",
-		hw->max_packet_count);
-	dev_dbg(hsotg->dev, "  nperio_tx_q_depth=0x%0x\n",
-		hw->nperio_tx_q_depth);
-	dev_dbg(hsotg->dev, "  host_perio_tx_q_depth=0x%0x\n",
-		hw->host_perio_tx_q_depth);
-	dev_dbg(hsotg->dev, "  dev_token_q_depth=0x%0x\n",
-		hw->dev_token_q_depth);
-	dev_dbg(hsotg->dev, "  enable_dynamic_fifo=%d\n",
-		hw->enable_dynamic_fifo);
-	dev_dbg(hsotg->dev, "  en_multiple_tx_fifo=%d\n",
-		hw->en_multiple_tx_fifo);
-	dev_dbg(hsotg->dev, "  total_fifo_size=%d\n",
-		hw->total_fifo_size);
-	dev_dbg(hsotg->dev, "  rx_fifo_size=%d\n",
-		hw->rx_fifo_size);
-	dev_dbg(hsotg->dev, "  host_nperio_tx_fifo_size=%d\n",
-		hw->host_nperio_tx_fifo_size);
-	dev_dbg(hsotg->dev, "  host_perio_tx_fifo_size=%d\n",
-		hw->host_perio_tx_fifo_size);
-	dev_dbg(hsotg->dev, "\n");
-
 	return 0;
 }
 

commit 06e75df1b98eda998ec693e7eaa79f61cdf2d4b3
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:57:48 2017 -0800

    usb: dwc2: Remove unnecessary parameters
    
    Further reduce the set of parameters set by platforms. Many of them are
    unnecessary as they should be reported by hardware. They should only
    need to be overridden if there is a problem.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index b872f6128cc2..0e7f0f92c18f 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -42,19 +42,9 @@ static void dwc2_set_bcm_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
-	p->otg_cap = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
-	p->speed = DWC2_SPEED_PARAM_HIGH;
 	p->host_rx_fifo_size = 774;
-	p->host_nperio_tx_fifo_size = 256;
-	p->host_perio_tx_fifo_size = 512;
 	p->max_transfer_size = 65535;
 	p->max_packet_count = 511;
-	p->host_channels = 8;
-	p->phy_type = 1;
-	p->phy_utmi_width = 8;
-	p->i2c_enable = false;
-	p->host_ls_low_power_phy_clk = false;
-	p->reload_ctl = false;
 	p->ahbcfg = 0x10;
 	p->uframe_sched = false;
 }
@@ -74,7 +64,6 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
 	p->phy_utmi_width = 8;
 	p->i2c_enable = false;
-	p->host_ls_low_power_phy_clk = false;
 	p->reload_ctl = false;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
 		GAHBCFG_HBSTLEN_SHIFT;

commit 95832c00bc5ce3ed140f5f9b669803f75ac1431e
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:57:26 2017 -0800

    usb: dwc2: Fix usage of bool params
    
    Check these parameters only for true or false. There is no need to check
    for greater or less than 0.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 949d988f13cc..b872f6128cc2 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -53,7 +53,7 @@ static void dwc2_set_bcm_params(struct dwc2_hsotg *hsotg)
 	p->phy_type = 1;
 	p->phy_utmi_width = 8;
 	p->i2c_enable = false;
-	p->host_ls_low_power_phy_clk = 0;
+	p->host_ls_low_power_phy_clk = false;
 	p->reload_ctl = false;
 	p->ahbcfg = 0x10;
 	p->uframe_sched = false;
@@ -74,7 +74,7 @@ static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
 	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
 	p->phy_utmi_width = 8;
 	p->i2c_enable = false;
-	p->host_ls_low_power_phy_clk = 0;
+	p->host_ls_low_power_phy_clk = false;
 	p->reload_ctl = false;
 	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
 		GAHBCFG_HBSTLEN_SHIFT;

commit 7de1debcd2de17c6dc2471f0f57fb0fd456d2b41
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:57:04 2017 -0800

    usb: dwc2: Remove platform static params
    
    Remove the platform-specific static param structs and set only those
    params that are necessary for each platform.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6ea9d2dafd74..949d988f13cc 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -38,166 +38,111 @@
 
 #include "core.h"
 
-static const struct dwc2_core_params params_hi6220 = {
-	.otg_cap			= 2,	/* No HNP/SRP capable */
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= 0,	/* High Speed */
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= 1,
-	.host_rx_fifo_size		= 512,
-	.host_nperio_tx_fifo_size	= 512,
-	.host_perio_tx_fifo_size	= 512,
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= 16,
-	.phy_type			= 1,	/* UTMI */
-	.phy_utmi_width			= 8,
-	.phy_ulpi_ddr			= 0,	/* Single */
-	.phy_ulpi_ext_vbus		= 0,
-	.i2c_enable			= 0,
-	.ulpi_fs_ls			= 0,
-	.host_support_fs_ls_low_power	= 0,
-	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
-	.ts_dline			= 0,
-	.reload_ctl			= 0,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
+static void dwc2_set_bcm_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
 
-static const struct dwc2_core_params params_bcm2835 = {
-	.otg_cap			= 0,	/* HNP/SRP capable */
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= 0,	/* High Speed */
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= 1,
-	.host_rx_fifo_size		= 774,	/* 774 DWORDs */
-	.host_nperio_tx_fifo_size	= 256,	/* 256 DWORDs */
-	.host_perio_tx_fifo_size	= 512,	/* 512 DWORDs */
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= 8,
-	.phy_type			= 1,	/* UTMI */
-	.phy_utmi_width			= 8,	/* 8 bits */
-	.phy_ulpi_ddr			= 0,	/* Single */
-	.phy_ulpi_ext_vbus		= 0,
-	.i2c_enable			= 0,
-	.ulpi_fs_ls			= 0,
-	.host_support_fs_ls_low_power	= 0,
-	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
-	.ts_dline			= 0,
-	.reload_ctl			= 0,
-	.ahbcfg				= 0x10,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
+	p->otg_cap = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
+	p->speed = DWC2_SPEED_PARAM_HIGH;
+	p->host_rx_fifo_size = 774;
+	p->host_nperio_tx_fifo_size = 256;
+	p->host_perio_tx_fifo_size = 512;
+	p->max_transfer_size = 65535;
+	p->max_packet_count = 511;
+	p->host_channels = 8;
+	p->phy_type = 1;
+	p->phy_utmi_width = 8;
+	p->i2c_enable = false;
+	p->host_ls_low_power_phy_clk = 0;
+	p->reload_ctl = false;
+	p->ahbcfg = 0x10;
+	p->uframe_sched = false;
+}
 
-static const struct dwc2_core_params params_rk3066 = {
-	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= -1,
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 525,	/* 525 DWORDs */
-	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
-	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
-	.max_transfer_size		= -1,
-	.max_packet_count		= -1,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= -1,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
+static void dwc2_set_his_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
 
-static const struct dwc2_core_params params_ltq = {
-	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.dma_desc_enable		= -1,
-	.dma_desc_fs_enable		= -1,
-	.speed				= -1,
-	.enable_dynamic_fifo		= -1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 288,	/* 288 DWORDs */
-	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
-	.host_perio_tx_fifo_size	= 96,	/* 96 DWORDs */
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= -1,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->speed = DWC2_SPEED_PARAM_HIGH;
+	p->host_rx_fifo_size = 512;
+	p->host_nperio_tx_fifo_size = 512;
+	p->host_perio_tx_fifo_size = 512;
+	p->max_transfer_size = 65535;
+	p->max_packet_count = 511;
+	p->host_channels = 16;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
+	p->phy_utmi_width = 8;
+	p->i2c_enable = false;
+	p->host_ls_low_power_phy_clk = 0;
+	p->reload_ctl = false;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
+		GAHBCFG_HBSTLEN_SHIFT;
+	p->uframe_sched = false;
+}
 
-static const struct dwc2_core_params params_amlogic = {
-	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= DWC2_SPEED_PARAM_HIGH,
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 512,
-	.host_nperio_tx_fifo_size	= 500,
-	.host_perio_tx_fifo_size	= 500,
-	.max_transfer_size		= -1,
-	.max_packet_count		= -1,
-	.host_channels			= 16,
-	.phy_type			= DWC2_PHY_TYPE_PARAM_UTMI,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= 1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR8 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
+static void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->host_rx_fifo_size = 525;
+	p->host_nperio_tx_fifo_size = 128;
+	p->host_perio_tx_fifo_size = 256;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
+		GAHBCFG_HBSTLEN_SHIFT;
+}
+
+static void dwc2_set_ltq_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = 2;
+	p->host_rx_fifo_size = 288;
+	p->host_nperio_tx_fifo_size = 128;
+	p->host_perio_tx_fifo_size = 96;
+	p->max_transfer_size = 65535;
+	p->max_packet_count = 511;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<
+		GAHBCFG_HBSTLEN_SHIFT;
+}
+
+static void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+	p->speed = DWC2_SPEED_PARAM_HIGH;
+	p->host_rx_fifo_size = 512;
+	p->host_nperio_tx_fifo_size = 500;
+	p->host_perio_tx_fifo_size = 500;
+	p->host_channels = 16;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR8 <<
+		GAHBCFG_HBSTLEN_SHIFT;
+	p->uframe_sched = false;
+}
+
+static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;
+}
 
 const struct of_device_id dwc2_of_match_table[] = {
-	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
-	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
-	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
-	{ .compatible = "lantiq,arx100-usb", .data = &params_ltq },
-	{ .compatible = "lantiq,xrx200-usb", .data = &params_ltq },
-	{ .compatible = "snps,dwc2", .data = NULL },
-	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
-	{ .compatible = "amlogic,meson8b-usb", .data = &params_amlogic },
-	{ .compatible = "amlogic,meson-gxbb-usb", .data = &params_amlogic },
-	{ .compatible = "amcc,dwc-otg", .data = NULL },
+	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
+	{ .compatible = "hisilicon,hi6220-usb", .data = dwc2_set_his_params  },
+	{ .compatible = "rockchip,rk3066-usb", .data = dwc2_set_rk_params },
+	{ .compatible = "lantiq,arx100-usb", .data = dwc2_set_ltq_params },
+	{ .compatible = "lantiq,xrx200-usb", .data = dwc2_set_ltq_params },
+	{ .compatible = "snps,dwc2" },
+	{ .compatible = "samsung,s3c6400-hsotg" },
+	{ .compatible = "amlogic,meson8b-usb",
+	  .data = dwc2_set_amlogic_params },
+	{ .compatible = "amlogic,meson-gxbb-usb",
+	  .data = dwc2_set_amlogic_params },
+	{ .compatible = "amcc,dwc-otg", .data = dwc2_set_amcc_params },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
@@ -771,9 +716,18 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
+	const struct of_device_id *match;
+	void (*set_params)(void *data);
+
 	dwc2_set_default_params(hsotg);
 	dwc2_get_device_properties(hsotg);
 
+	match = of_match_device(dwc2_of_match_table, hsotg->dev);
+	if (match && match->data) {
+		set_params = match->data;
+		set_params(hsotg);
+	}
+
 	dwc2_check_params(hsotg);
 
 	return 0;

commit d936e666aea157a6c552334cce30bce2ae4576b3
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:56:43 2017 -0800

    usb: dwc2: Check core parameters
    
    Check that core parameters have valid values and adjust them if they
    aren't.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 4416eae09647..6ea9d2dafd74 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -377,6 +377,189 @@ static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
 	}
 }
 
+static void dwc2_check_param_otg_cap(struct dwc2_hsotg *hsotg)
+{
+	int valid = 1;
+
+	switch (hsotg->params.otg_cap) {
+	case DWC2_CAP_PARAM_HNP_SRP_CAPABLE:
+		if (hsotg->hw_params.op_mode != GHWCFG2_OP_MODE_HNP_SRP_CAPABLE)
+			valid = 0;
+		break;
+	case DWC2_CAP_PARAM_SRP_ONLY_CAPABLE:
+		switch (hsotg->hw_params.op_mode) {
+		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
+		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
+			break;
+		default:
+			valid = 0;
+			break;
+		}
+		break;
+	case DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE:
+		/* always valid */
+		break;
+	default:
+		valid = 0;
+		break;
+	}
+
+	if (!valid)
+		dwc2_set_param_otg_cap(hsotg);
+}
+
+static void dwc2_check_param_phy_type(struct dwc2_hsotg *hsotg)
+{
+	int valid = 0;
+	u32 hs_phy_type;
+	u32 fs_phy_type;
+
+	hs_phy_type = hsotg->hw_params.hs_phy_type;
+	fs_phy_type = hsotg->hw_params.fs_phy_type;
+
+	switch (hsotg->params.phy_type) {
+	case DWC2_PHY_TYPE_PARAM_FS:
+		if (fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED)
+			valid = 1;
+		break;
+	case DWC2_PHY_TYPE_PARAM_UTMI:
+		if ((hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI) ||
+		    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
+			valid = 1;
+		break;
+	case DWC2_PHY_TYPE_PARAM_ULPI:
+		if ((hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI) ||
+		    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
+			valid = 1;
+		break;
+	default:
+		break;
+	}
+
+	if (!valid)
+		dwc2_set_param_phy_type(hsotg);
+}
+
+static void dwc2_check_param_speed(struct dwc2_hsotg *hsotg)
+{
+	int valid = 1;
+	int phy_type = hsotg->params.phy_type;
+	int speed = hsotg->params.speed;
+
+	switch (speed) {
+	case DWC2_SPEED_PARAM_HIGH:
+		if ((hsotg->params.speed == DWC2_SPEED_PARAM_HIGH) &&
+		    (phy_type == DWC2_PHY_TYPE_PARAM_FS))
+			valid = 0;
+		break;
+	case DWC2_SPEED_PARAM_FULL:
+	case DWC2_SPEED_PARAM_LOW:
+		break;
+	default:
+		valid = 0;
+		break;
+	}
+
+	if (!valid)
+		dwc2_set_param_speed(hsotg);
+}
+
+static void dwc2_check_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
+{
+	int valid = 0;
+	int param = hsotg->params.phy_utmi_width;
+	int width = hsotg->hw_params.utmi_phy_data_width;
+
+	switch (width) {
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8:
+		valid = (param == 8);
+		break;
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_16:
+		valid = (param == 16);
+		break;
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8_OR_16:
+		valid = (param == 8 || param == 16);
+		break;
+	}
+
+	if (!valid)
+		dwc2_set_param_phy_utmi_width(hsotg);
+}
+
+#define CHECK_RANGE(_param, _min, _max, _def) do {			\
+		if ((hsotg->params._param) < (_min) ||			\
+		    (hsotg->params._param) > (_max)) {			\
+			dev_warn(hsotg->dev, "%s: Invalid parameter %s=%d\n", \
+				 __func__, #_param, hsotg->params._param); \
+			hsotg->params._param = (_def);			\
+		}							\
+	} while (0)
+
+#define CHECK_BOOL(_param, _check) do {					\
+		if (hsotg->params._param && !(_check)) {		\
+			dev_warn(hsotg->dev, "%s: Invalid parameter %s=%d\n", \
+				 __func__, #_param, hsotg->params._param); \
+			hsotg->params._param = false;			\
+		}							\
+	} while (0)
+
+static void dwc2_check_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	struct dwc2_core_params *p = &hsotg->params;
+	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
+
+	dwc2_check_param_otg_cap(hsotg);
+	dwc2_check_param_phy_type(hsotg);
+	dwc2_check_param_speed(hsotg);
+	dwc2_check_param_phy_utmi_width(hsotg);
+	CHECK_BOOL(enable_dynamic_fifo, hw->enable_dynamic_fifo);
+	CHECK_BOOL(en_multiple_tx_fifo, hw->en_multiple_tx_fifo);
+	CHECK_BOOL(i2c_enable, hw->i2c_enable);
+	CHECK_BOOL(reload_ctl, (hsotg->hw_params.snpsid > DWC2_CORE_REV_2_92a));
+	CHECK_RANGE(max_packet_count,
+		    15, hw->max_packet_count,
+		    hw->max_packet_count);
+	CHECK_RANGE(max_transfer_size,
+		    2047, hw->max_transfer_size,
+		    hw->max_transfer_size);
+
+	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
+	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
+		CHECK_BOOL(host_dma, dma_capable);
+		CHECK_BOOL(dma_desc_enable, p->host_dma);
+		CHECK_BOOL(dma_desc_fs_enable, p->dma_desc_enable);
+		CHECK_BOOL(host_ls_low_power_phy_clk,
+			   p->phy_type == DWC2_PHY_TYPE_PARAM_FS);
+		CHECK_RANGE(host_channels,
+			    1, hw->host_channels,
+			    hw->host_channels);
+		CHECK_RANGE(host_rx_fifo_size,
+			    16, hw->rx_fifo_size,
+			    hw->rx_fifo_size);
+		CHECK_RANGE(host_nperio_tx_fifo_size,
+			    16, hw->host_nperio_tx_fifo_size,
+			    hw->host_nperio_tx_fifo_size);
+		CHECK_RANGE(host_perio_tx_fifo_size,
+			    16, hw->host_perio_tx_fifo_size,
+			    hw->host_perio_tx_fifo_size);
+	}
+
+	if ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||
+	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
+		CHECK_BOOL(g_dma, dma_capable);
+		CHECK_BOOL(g_dma_desc, (p->g_dma && hw->dma_desc_enable));
+		CHECK_RANGE(g_rx_fifo_size,
+			    16, hw->rx_fifo_size,
+			    hw->rx_fifo_size);
+		CHECK_RANGE(g_np_tx_fifo_size,
+			    16, hw->dev_nperio_tx_fifo_size,
+			    hw->dev_nperio_tx_fifo_size);
+	}
+}
+
 /*
  * Gets host hardware parameters. Forces host mode if not currently in
  * host mode. Should be called immediately after a core soft reset in
@@ -591,5 +774,7 @@ int dwc2_init_params(struct dwc2_hsotg *hsotg)
 	dwc2_set_default_params(hsotg);
 	dwc2_get_device_properties(hsotg);
 
+	dwc2_check_params(hsotg);
+
 	return 0;
 }

commit f9f93cbb3c11e56d500fd77beb8eac6ded534d6c
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:55:35 2017 -0800

    usb: dwc2: Get device properties
    
    After setting the default core parameter values, read in the device
    properties and modify core parameter values if needed.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6729f14d25de..4416eae09647 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -343,6 +343,40 @@ static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 	}
 }
 
+/**
+ * dwc2_get_device_properties() - Read in device properties.
+ *
+ * Read in the device properties and adjust core parameters if needed.
+ */
+static void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+	int num;
+
+	if ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||
+	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
+		device_property_read_u32(hsotg->dev, "g-rx-fifo-size",
+					 &p->g_rx_fifo_size);
+
+		device_property_read_u32(hsotg->dev, "g-np-tx-fifo-size",
+					 &p->g_np_tx_fifo_size);
+
+		num = device_property_read_u32_array(hsotg->dev,
+						     "g-tx-fifo-size",
+						     NULL, 0);
+
+		if (num > 0) {
+			num = min(num, 15);
+			memset(p->g_tx_fifo_size, 0,
+			       sizeof(p->g_tx_fifo_size));
+			device_property_read_u32_array(hsotg->dev,
+						       "g-tx-fifo-size",
+						       &p->g_tx_fifo_size[1],
+						       num);
+		}
+	}
+}
+
 /*
  * Gets host hardware parameters. Forces host mode if not currently in
  * host mode. Should be called immediately after a core soft reset in
@@ -555,6 +589,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
 	dwc2_set_default_params(hsotg);
+	dwc2_get_device_properties(hsotg);
 
 	return 0;
 }

commit 245977c967eee19de4d5e95ec67227dcfe57b0e2
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:55:14 2017 -0800

    usb: dwc2: Set core parameters to default values
    
    Initialize the core parameters to their default, auto-detected values.
    
    Remove all the previous dwc2_set_param* methods. Most of what this code
    is doing is handling defaults for "not set" values and other trivial
    checks. The checking can be simplified and will be done in a later
    commit.
    
    This allows us to change only those parameters that won't work with
    default settings. It also allows us to use non-int parameters.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 074f4061206a..6729f14d25de 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -187,42 +187,6 @@ static const struct dwc2_core_params params_amlogic = {
 	.hibernation			= -1,
 };
 
-static const struct dwc2_core_params params_default = {
-	.otg_cap			= -1,
-
-	/*
-	 * Disable descriptor dma mode by default as the HW can support
-	 * it, but does not support it for SPLIT transactions.
-	 * Disable it for FS devices as well.
-	 */
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-
-	.speed				= -1,
-	.enable_dynamic_fifo		= -1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= -1,
-	.host_nperio_tx_fifo_size	= -1,
-	.host_perio_tx_fifo_size	= -1,
-	.max_transfer_size		= -1,
-	.max_packet_count		= -1,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= -1,
-	.uframe_sched			= -1,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
@@ -238,913 +202,131 @@ const struct of_device_id dwc2_of_match_table[] = {
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
 
-static void dwc2_get_device_property(struct dwc2_hsotg *hsotg,
-				     char *property, u8 size, u64 *value)
+static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg)
 {
-	u32 val32;
+	u8 val;
 
-	switch (size) {
-	case 0:
-		*value = device_property_read_bool(hsotg->dev, property);
+	switch (hsotg->hw_params.op_mode) {
+	case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
+		val = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
 		break;
-	case 1:
-	case 2:
-	case 4:
-		if (device_property_read_u32(hsotg->dev, property, &val32))
-			return;
-
-		*value = val32;
-		break;
-	case 8:
-		if (device_property_read_u64(hsotg->dev, property, value))
-			return;
-
+	case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
+	case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
+	case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
+		val = DWC2_CAP_PARAM_SRP_ONLY_CAPABLE;
 		break;
 	default:
-		/*
-		 * The size is checked by the only function that calls
-		 * this so this should never happen.
-		 */
-		WARN_ON(1);
-		return;
-	}
-}
-
-static void dwc2_set_core_param(void *param, u8 size, u64 value)
-{
-	switch (size) {
-	case 0:
-		*((bool *)param) = !!value;
-		break;
-	case 1:
-		*((u8 *)param) = (u8)value;
-		break;
-	case 2:
-		*((u16 *)param) = (u16)value;
-		break;
-	case 4:
-		*((u32 *)param) = (u32)value;
-		break;
-	case 8:
-		*((u64 *)param) = (u64)value;
+		val = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
 		break;
-	default:
-		/*
-		 * The size is checked by the only function that calls
-		 * this so this should never happen.
-		 */
-		WARN_ON(1);
-		return;
-	}
-}
-
-/**
- * dwc2_set_param() - Set a core parameter
- *
- * @hsotg: Programming view of the DWC_otg controller
- * @param: Pointer to the parameter to set
- * @lookup: True if the property should be looked up
- * @property: The device property to read
- * @legacy: The param value to set if @property is not available. This
- *          will typically be the legacy value set in the static
- *          params structure.
- * @def: The default value
- * @min: The minimum value
- * @max: The maximum value
- * @size: The size of the core parameter in bytes, or 0 for bool.
- *
- * This function looks up @property and sets the @param to that value.
- * If the property doesn't exist it uses the passed-in @value. It will
- * verify that the value falls between @min and @max. If it doesn't,
- * it will output an error and set the parameter to either @def or,
- * failing that, to @min.
- *
- * The @size is used to write to @param and to query the device
- * properties so that this same function can be used with different
- * types of parameters.
- */
-static void dwc2_set_param(struct dwc2_hsotg *hsotg, void *param,
-			   bool lookup, char *property, u64 legacy,
-			   u64 def, u64 min, u64 max, u8 size)
-{
-	u64 sizemax;
-	u64 value;
-
-	if (WARN_ON(!hsotg || !param || !property))
-		return;
-
-	if (WARN((size > 8) || ((size & (size - 1)) != 0),
-		 "Invalid size %d for %s\n", size, property))
-		return;
-
-	dev_vdbg(hsotg->dev, "%s: Setting %s: legacy=%llu, def=%llu, min=%llu, max=%llu, size=%d\n",
-		 __func__, property, legacy, def, min, max, size);
-
-	sizemax = (1ULL << (size * 8)) - 1;
-	value = legacy;
-
-	/* Override legacy settings. */
-	if (lookup)
-		dwc2_get_device_property(hsotg, property, size, &value);
-
-	/*
-	 * While the value is not valid, try setting it to the default
-	 * value, and failing that, set it to the minimum.
-	 */
-	while ((value < min) || (value > max)) {
-		/* Print an error unless the value is set to auto. */
-		if (value != sizemax)
-			dev_err(hsotg->dev, "Invalid value %llu for param %s\n",
-				value, property);
-
-		/*
-		 * If we are already the default, just set it to the
-		 * minimum.
-		 */
-		if (value == def) {
-			dev_vdbg(hsotg->dev, "%s: setting value to min=%llu\n",
-				 __func__, min);
-			value = min;
-			break;
-		}
-
-		/* Try the default value */
-		dev_vdbg(hsotg->dev, "%s: setting value to default=%llu\n",
-			 __func__, def);
-		value = def;
-	}
-
-	dev_dbg(hsotg->dev, "Setting %s to %llu\n", property, value);
-	dwc2_set_core_param(param, size, value);
-}
-
-/**
- * dwc2_set_param_u32() - Set a u32 parameter
- *
- * See dwc2_set_param().
- */
-static void dwc2_set_param_u32(struct dwc2_hsotg *hsotg, u32 *param,
-			       bool lookup, char *property, u16 legacy,
-			       u16 def, u16 min, u16 max)
-{
-	dwc2_set_param(hsotg, param, lookup, property,
-		       legacy, def, min, max, 4);
-}
-
-/**
- * dwc2_set_param_bool() - Set a bool parameter
- *
- * See dwc2_set_param().
- *
- * Note: there is no 'legacy' argument here because there is no legacy
- * source of bool params.
- */
-static void dwc2_set_param_bool(struct dwc2_hsotg *hsotg, bool *param,
-				bool lookup, char *property,
-				bool def, bool min, bool max)
-{
-	dwc2_set_param(hsotg, param, lookup, property,
-		       def, def, min, max, 0);
-}
-
-#define DWC2_OUT_OF_BOUNDS(a, b, c)	((a) < (b) || (a) > (c))
-
-/* Parameter access functions */
-static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	switch (val) {
-	case DWC2_CAP_PARAM_HNP_SRP_CAPABLE:
-		if (hsotg->hw_params.op_mode != GHWCFG2_OP_MODE_HNP_SRP_CAPABLE)
-			valid = 0;
-		break;
-	case DWC2_CAP_PARAM_SRP_ONLY_CAPABLE:
-		switch (hsotg->hw_params.op_mode) {
-		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
-		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
-			break;
-		default:
-			valid = 0;
-			break;
-		}
-		break;
-	case DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE:
-		/* always valid */
-		break;
-	default:
-		valid = 0;
-		break;
-	}
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for otg_cap parameter. Check HW configuration.\n",
-				val);
-		switch (hsotg->hw_params.op_mode) {
-		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
-			val = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
-			break;
-		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
-		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
-			val = DWC2_CAP_PARAM_SRP_ONLY_CAPABLE;
-			break;
-		default:
-			val = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
-			break;
-		}
-		dev_dbg(hsotg->dev, "Setting otg_cap to %d\n", val);
 	}
 
 	hsotg->params.otg_cap = val;
 }
 
-static void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val > 0 && (hsotg->params.host_dma <= 0 ||
-			!hsotg->hw_params.dma_desc_enable))
-		valid = 0;
-	if (val < 0)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for dma_desc_enable parameter. Check HW configuration.\n",
-				val);
-		val = (hsotg->params.host_dma > 0 &&
-			hsotg->hw_params.dma_desc_enable);
-		dev_dbg(hsotg->dev, "Setting dma_desc_enable to %d\n", val);
-	}
-
-	hsotg->params.dma_desc_enable = val;
-}
-
-static void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val > 0 && (hsotg->params.host_dma <= 0 ||
-			!hsotg->hw_params.dma_desc_enable))
-		valid = 0;
-	if (val < 0)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for dma_desc_fs_enable parameter. Check HW configuration.\n",
-				val);
-		val = (hsotg->params.host_dma > 0 &&
-			hsotg->hw_params.dma_desc_enable);
-	}
-
-	hsotg->params.dma_desc_fs_enable = val;
-	dev_dbg(hsotg->dev, "Setting dma_desc_fs_enable to %d\n", val);
-}
-
-static void
-dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
-					    int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"Wrong value for host_support_fs_low_power\n");
-			dev_err(hsotg->dev,
-				"host_support_fs_low_power must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev,
-			"Setting host_support_fs_low_power to %d\n", val);
-	}
-
-	hsotg->params.host_support_fs_ls_low_power = val;
-}
-
-static void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg,
-					       int val)
-{
-	int valid = 1;
-
-	if (val > 0 && !hsotg->hw_params.enable_dynamic_fifo)
-		valid = 0;
-	if (val < 0)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for enable_dynamic_fifo parameter. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.enable_dynamic_fifo;
-		dev_dbg(hsotg->dev, "Setting enable_dynamic_fifo to %d\n", val);
-	}
-
-	hsotg->params.enable_dynamic_fifo = val;
-}
-
-static void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val < 16 || val > hsotg->hw_params.rx_fifo_size)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_rx_fifo_size. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.rx_fifo_size;
-		dev_dbg(hsotg->dev, "Setting host_rx_fifo_size to %d\n", val);
-	}
-
-	hsotg->params.host_rx_fifo_size = val;
-}
-
-static void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg,
-						    int val)
-{
-	int valid = 1;
-
-	if (val < 16 || val > hsotg->hw_params.host_nperio_tx_fifo_size)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_nperio_tx_fifo_size. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.host_nperio_tx_fifo_size;
-		dev_dbg(hsotg->dev, "Setting host_nperio_tx_fifo_size to %d\n",
-			val);
-	}
-
-	hsotg->params.host_nperio_tx_fifo_size = val;
-}
-
-static void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg,
-						   int val)
-{
-	int valid = 1;
-
-	if (val < 16 || val > hsotg->hw_params.host_perio_tx_fifo_size)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_perio_tx_fifo_size. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.host_perio_tx_fifo_size;
-		dev_dbg(hsotg->dev, "Setting host_perio_tx_fifo_size to %d\n",
-			val);
-	}
-
-	hsotg->params.host_perio_tx_fifo_size = val;
-}
-
-static void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val < 2047 || val > hsotg->hw_params.max_transfer_size)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for max_transfer_size. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.max_transfer_size;
-		dev_dbg(hsotg->dev, "Setting max_transfer_size to %d\n", val);
-	}
-
-	hsotg->params.max_transfer_size = val;
-}
-
-static void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val < 15 || val > hsotg->hw_params.max_packet_count)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for max_packet_count. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.max_packet_count;
-		dev_dbg(hsotg->dev, "Setting max_packet_count to %d\n", val);
-	}
-
-	hsotg->params.max_packet_count = val;
-}
-
-static void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val < 1 || val > hsotg->hw_params.host_channels)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_channels. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.host_channels;
-		dev_dbg(hsotg->dev, "Setting host_channels to %d\n", val);
-	}
-
-	hsotg->params.host_channels = val;
-}
-
-static void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg)
 {
-	int valid = 0;
-	u32 hs_phy_type, fs_phy_type;
-
-	if (DWC2_OUT_OF_BOUNDS(val, DWC2_PHY_TYPE_PARAM_FS,
-			       DWC2_PHY_TYPE_PARAM_ULPI)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for phy_type\n");
-			dev_err(hsotg->dev, "phy_type must be 0, 1 or 2\n");
-		}
+	int val;
+	u32 hs_phy_type = hsotg->hw_params.hs_phy_type;
 
-		valid = 0;
+	val = DWC2_PHY_TYPE_PARAM_FS;
+	if (hs_phy_type != GHWCFG2_HS_PHY_TYPE_NOT_SUPPORTED) {
+		if (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||
+		    hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI)
+			val = DWC2_PHY_TYPE_PARAM_UTMI;
+		else
+			val = DWC2_PHY_TYPE_PARAM_ULPI;
 	}
 
-	hs_phy_type = hsotg->hw_params.hs_phy_type;
-	fs_phy_type = hsotg->hw_params.fs_phy_type;
-	if (val == DWC2_PHY_TYPE_PARAM_UTMI &&
-	    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||
-	     hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
-		valid = 1;
-	else if (val == DWC2_PHY_TYPE_PARAM_ULPI &&
-		 (hs_phy_type == GHWCFG2_HS_PHY_TYPE_ULPI ||
-		  hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
-		valid = 1;
-	else if (val == DWC2_PHY_TYPE_PARAM_FS &&
-		 fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED)
-		valid = 1;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for phy_type. Check HW configuration.\n",
-				val);
-		val = DWC2_PHY_TYPE_PARAM_FS;
-		if (hs_phy_type != GHWCFG2_HS_PHY_TYPE_NOT_SUPPORTED) {
-			if (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||
-			    hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI)
-				val = DWC2_PHY_TYPE_PARAM_UTMI;
-			else
-				val = DWC2_PHY_TYPE_PARAM_ULPI;
-		}
-		dev_dbg(hsotg->dev, "Setting phy_type to %d\n", val);
-	}
+	if (dwc2_is_fs_iot(hsotg))
+		hsotg->params.phy_type = DWC2_PHY_TYPE_PARAM_FS;
 
 	hsotg->params.phy_type = val;
 }
 
-static int dwc2_get_param_phy_type(struct dwc2_hsotg *hsotg)
-{
-	return hsotg->params.phy_type;
-}
-
-static void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_speed(struct dwc2_hsotg *hsotg)
 {
-	int valid = 1;
+	int val;
 
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 2)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for speed parameter\n");
-			dev_err(hsotg->dev, "max_speed parameter must be 0, 1, or 2\n");
-		}
-		valid = 0;
-	}
+	val = hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS ?
+		DWC2_SPEED_PARAM_FULL : DWC2_SPEED_PARAM_HIGH;
 
-	if (dwc2_is_hs_iot(hsotg) &&
-	    val == DWC2_SPEED_PARAM_LOW)
-		valid = 0;
+	if (dwc2_is_fs_iot(hsotg))
+		val = DWC2_SPEED_PARAM_FULL;
 
-	if (val == DWC2_SPEED_PARAM_HIGH &&
-	    dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for speed parameter. Check HW configuration.\n",
-				val);
-		val = dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS ?
-				DWC2_SPEED_PARAM_FULL : DWC2_SPEED_PARAM_HIGH;
-		dev_dbg(hsotg->dev, "Setting speed to %d\n", val);
-	}
+	if (dwc2_is_hs_iot(hsotg))
+		val = DWC2_SPEED_PARAM_HIGH;
 
 	hsotg->params.speed = val;
 }
 
-static void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg,
-						     int val)
+static void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg)
 {
-	int valid = 1;
+	int val;
 
-	if (DWC2_OUT_OF_BOUNDS(val, DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ,
-			       DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"Wrong value for host_ls_low_power_phy_clk parameter\n");
-			dev_err(hsotg->dev,
-				"host_ls_low_power_phy_clk must be 0 or 1\n");
-		}
-		valid = 0;
-	}
-
-	if (val == DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ &&
-	    dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_ls_low_power_phy_clk. Check HW configuration.\n",
-				val);
-		val = dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS
-			? DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ
-			: DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ;
-		dev_dbg(hsotg->dev, "Setting host_ls_low_power_phy_clk to %d\n",
-			val);
-	}
-
-	hsotg->params.host_ls_low_power_phy_clk = val;
-}
-
-static void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for phy_ulpi_ddr\n");
-			dev_err(hsotg->dev, "phy_upli_ddr must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting phy_upli_ddr to %d\n", val);
-	}
-
-	hsotg->params.phy_ulpi_ddr = val;
-}
-
-static void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"Wrong value for phy_ulpi_ext_vbus\n");
-			dev_err(hsotg->dev,
-				"phy_ulpi_ext_vbus must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting phy_ulpi_ext_vbus to %d\n", val);
-	}
-
-	hsotg->params.phy_ulpi_ext_vbus = val;
-}
-
-static void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 0;
-
-	switch (hsotg->hw_params.utmi_phy_data_width) {
-	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8:
-		valid = (val == 8);
-		break;
-	case GHWCFG4_UTMI_PHY_DATA_WIDTH_16:
-		valid = (val == 16);
-		break;
-	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8_OR_16:
-		valid = (val == 8 || val == 16);
-		break;
-	}
-
-	if (!valid) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"%d invalid for phy_utmi_width. Check HW configuration.\n",
-				val);
-		}
-		val = (hsotg->hw_params.utmi_phy_data_width ==
-		       GHWCFG4_UTMI_PHY_DATA_WIDTH_8) ? 8 : 16;
-		dev_dbg(hsotg->dev, "Setting phy_utmi_width to %d\n", val);
-	}
+	val = (hsotg->hw_params.utmi_phy_data_width ==
+	       GHWCFG4_UTMI_PHY_DATA_WIDTH_8) ? 8 : 16;
 
 	hsotg->params.phy_utmi_width = val;
 }
 
-static void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for ulpi_fs_ls\n");
-			dev_err(hsotg->dev, "ulpi_fs_ls must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting ulpi_fs_ls to %d\n", val);
-	}
-
-	hsotg->params.ulpi_fs_ls = val;
-}
-
-static void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for ts_dline\n");
-			dev_err(hsotg->dev, "ts_dline must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting ts_dline to %d\n", val);
-	}
-
-	hsotg->params.ts_dline = val;
-}
-
-static void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev, "Wrong value for i2c_enable\n");
-			dev_err(hsotg->dev, "i2c_enable must be 0 or 1\n");
-		}
-
-		valid = 0;
-	}
-
-	if (val == 1 && !(hsotg->hw_params.i2c_enable))
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for i2c_enable. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.i2c_enable;
-		dev_dbg(hsotg->dev, "Setting i2c_enable to %d\n", val);
-	}
-
-	hsotg->params.i2c_enable = val;
-}
-
-static void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg,
-					       int val)
-{
-	int valid = 1;
-
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"Wrong value for en_multiple_tx_fifo,\n");
-			dev_err(hsotg->dev,
-				"en_multiple_tx_fifo must be 0 or 1\n");
-		}
-		valid = 0;
-	}
-
-	if (val == 1 && !hsotg->hw_params.en_multiple_tx_fifo)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for parameter en_multiple_tx_fifo. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.en_multiple_tx_fifo;
-		dev_dbg(hsotg->dev, "Setting en_multiple_tx_fifo to %d\n", val);
-	}
-
-	hsotg->params.en_multiple_tx_fifo = val;
-}
-
-static void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"'%d' invalid for parameter reload_ctl\n", val);
-			dev_err(hsotg->dev, "reload_ctl must be 0 or 1\n");
-		}
-		valid = 0;
-	}
-
-	if (val == 1 && hsotg->hw_params.snpsid < DWC2_CORE_REV_2_92a)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for parameter reload_ctl. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_92a;
-		dev_dbg(hsotg->dev, "Setting reload_ctl to %d\n", val);
-	}
-
-	hsotg->params.reload_ctl = val;
-}
-
-static void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
-{
-	if (val != -1)
-		hsotg->params.ahbcfg = val;
-	else
-		hsotg->params.ahbcfg = GAHBCFG_HBSTLEN_INCR4 <<
-						GAHBCFG_HBSTLEN_SHIFT;
-}
-
-static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"'%d' invalid for parameter uframe_sched\n",
-				val);
-			dev_err(hsotg->dev, "uframe_sched must be 0 or 1\n");
-		}
-		val = 1;
-		dev_dbg(hsotg->dev, "Setting uframe_sched to %d\n", val);
-	}
-
-	hsotg->params.uframe_sched = val;
-}
-
-static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg,
-					       int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"'%d' invalid for parameter external_id_pin_ctl\n",
-				val);
-			dev_err(hsotg->dev, "external_id_pin_ctl must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting external_id_pin_ctl to %d\n", val);
-	}
-
-	hsotg->params.external_id_pin_ctl = val;
-}
-
-static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
-				       int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"'%d' invalid for parameter hibernation\n",
-				val);
-			dev_err(hsotg->dev, "hibernation must be 0 or 1\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting hibernation to %d\n", val);
-	}
-
-	hsotg->params.hibernation = val;
-}
-
 static void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 {
-	int i;
-	int num;
-	char *property = "g-tx-fifo-size";
 	struct dwc2_core_params *p = &hsotg->params;
+	u32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;
 
 	memset(p->g_tx_fifo_size, 0, sizeof(p->g_tx_fifo_size));
-
-	/* Read tx fifo sizes */
-	num = device_property_read_u32_array(hsotg->dev, property, NULL, 0);
-
-	if (num > 0) {
-		device_property_read_u32_array(hsotg->dev, property,
-					       &p->g_tx_fifo_size[1],
-					       num);
-	} else {
-		u32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;
-
-		memcpy(&p->g_tx_fifo_size[1],
-		       p_tx_fifo,
-		       sizeof(p_tx_fifo));
-
-		num = ARRAY_SIZE(p_tx_fifo);
-	}
-
-	for (i = 0; i < num; i++) {
-		if ((i + 1) >= ARRAY_SIZE(p->g_tx_fifo_size))
-			break;
-
-		dev_dbg(hsotg->dev, "Setting %s[%d] to %d\n",
-			property, i + 1, p->g_tx_fifo_size[i + 1]);
-	}
-}
-
-static void dwc2_set_gadget_dma(struct dwc2_hsotg *hsotg)
-{
-	struct dwc2_hw_params *hw = &hsotg->hw_params;
-	struct dwc2_core_params *p = &hsotg->params;
-	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
-
-	/* Buffer DMA */
-	dwc2_set_param_bool(hsotg, &p->g_dma,
-			    false, "gadget-dma",
-			    dma_capable, false,
-			    dma_capable);
-
-	/* DMA Descriptor */
-	dwc2_set_param_bool(hsotg, &p->g_dma_desc, false,
-			    "gadget-dma-desc",
-			    !!hw->dma_desc_enable, false,
-			    !!hw->dma_desc_enable);
+	memcpy(&p->g_tx_fifo_size[1],
+	       p_tx_fifo,
+	       sizeof(p_tx_fifo));
 }
 
 /**
- * dwc2_set_parameters() - Set all core parameters.
- *
- * @hsotg: Programming view of the DWC_otg controller
- * @params: The parameters to set
+ * dwc2_set_default_params() - Set all core parameters to their
+ * auto-detected default values.
  */
-static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
-				const struct dwc2_core_params *params)
+static void dwc2_set_default_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_hw_params *hw = &hsotg->hw_params;
 	struct dwc2_core_params *p = &hsotg->params;
 	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
 
-	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
+	dwc2_set_param_otg_cap(hsotg);
+	dwc2_set_param_phy_type(hsotg);
+	dwc2_set_param_speed(hsotg);
+	dwc2_set_param_phy_utmi_width(hsotg);
+	p->phy_ulpi_ddr = false;
+	p->phy_ulpi_ext_vbus = false;
+
+	p->enable_dynamic_fifo = hw->enable_dynamic_fifo;
+	p->en_multiple_tx_fifo = hw->en_multiple_tx_fifo;
+	p->i2c_enable = hw->i2c_enable;
+	p->ulpi_fs_ls = false;
+	p->ts_dline = false;
+	p->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);
+	p->uframe_sched = true;
+	p->external_id_pin_ctl = false;
+	p->hibernation = false;
+	p->max_packet_count = hw->max_packet_count;
+	p->max_transfer_size = hw->max_transfer_size;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR4 << GAHBCFG_HBSTLEN_SHIFT;
+
 	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
-		dev_dbg(hsotg->dev, "Setting HOST parameters\n");
-
-		dwc2_set_param_bool(hsotg, &p->host_dma,
-				    false, "host-dma",
-				    dma_capable, false,
-				    dma_capable);
-		dwc2_set_param_host_rx_fifo_size(hsotg,
-				params->host_rx_fifo_size);
-		dwc2_set_param_host_nperio_tx_fifo_size(hsotg,
-				params->host_nperio_tx_fifo_size);
-		dwc2_set_param_host_perio_tx_fifo_size(hsotg,
-				params->host_perio_tx_fifo_size);
+		p->host_dma = dma_capable;
+		p->dma_desc_enable = false;
+		p->dma_desc_fs_enable = false;
+		p->host_support_fs_ls_low_power = false;
+		p->host_ls_low_power_phy_clk = false;
+		p->host_channels = hw->host_channels;
+		p->host_rx_fifo_size = hw->rx_fifo_size;
+		p->host_nperio_tx_fifo_size = hw->host_nperio_tx_fifo_size;
+		p->host_perio_tx_fifo_size = hw->host_perio_tx_fifo_size;
 	}
-	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
-	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
 
-	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
-			params->host_support_fs_ls_low_power);
-	dwc2_set_param_enable_dynamic_fifo(hsotg,
-			params->enable_dynamic_fifo);
-	dwc2_set_param_max_transfer_size(hsotg,
-			params->max_transfer_size);
-	dwc2_set_param_max_packet_count(hsotg,
-			params->max_packet_count);
-	dwc2_set_param_host_channels(hsotg, params->host_channels);
-	dwc2_set_param_phy_type(hsotg, params->phy_type);
-	dwc2_set_param_speed(hsotg, params->speed);
-	dwc2_set_param_host_ls_low_power_phy_clk(hsotg,
-			params->host_ls_low_power_phy_clk);
-	dwc2_set_param_phy_ulpi_ddr(hsotg, params->phy_ulpi_ddr);
-	dwc2_set_param_phy_ulpi_ext_vbus(hsotg,
-			params->phy_ulpi_ext_vbus);
-	dwc2_set_param_phy_utmi_width(hsotg, params->phy_utmi_width);
-	dwc2_set_param_ulpi_fs_ls(hsotg, params->ulpi_fs_ls);
-	dwc2_set_param_ts_dline(hsotg, params->ts_dline);
-	dwc2_set_param_i2c_enable(hsotg, params->i2c_enable);
-	dwc2_set_param_en_multiple_tx_fifo(hsotg,
-			params->en_multiple_tx_fifo);
-	dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
-	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
-	dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
-	dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
-	dwc2_set_param_hibernation(hsotg, params->hibernation);
-
-	/*
-	 * Set devicetree-only parameters. These parameters do not
-	 * take any values from @params.
-	 */
 	if ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
-		dev_dbg(hsotg->dev, "Setting peripheral device properties\n");
-
-		dwc2_set_gadget_dma(hsotg);
+		p->g_dma = dma_capable;
+		p->g_dma_desc = hw->dma_desc_enable;
 
 		/*
 		 * The values for g_rx_fifo_size (2048) and
@@ -1155,16 +337,8 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 		 * auto-detect if the hardware does not support the
 		 * default.
 		 */
-		dwc2_set_param_u32(hsotg, &p->g_rx_fifo_size,
-				   true, "g-rx-fifo-size", 2048,
-				   hw->rx_fifo_size,
-				   16, hw->rx_fifo_size);
-
-		dwc2_set_param_u32(hsotg, &p->g_np_tx_fifo_size,
-				   true, "g-np-tx-fifo-size", 1024,
-				   hw->dev_nperio_tx_fifo_size,
-				   16, hw->dev_nperio_tx_fifo_size);
-
+		p->g_rx_fifo_size = 2048;
+		p->g_np_tx_fifo_size = 1024;
 		dwc2_set_param_tx_fifo_sizes(hsotg);
 	}
 }
@@ -1380,21 +554,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
-	const struct of_device_id *match;
-	struct dwc2_core_params params;
-
-	match = of_match_device(dwc2_of_match_table, hsotg->dev);
-	if (match && match->data)
-		params = *((struct dwc2_core_params *)match->data);
-	else
-		params = params_default;
-
-	if (dwc2_is_fs_iot(hsotg)) {
-		params.speed = DWC2_SPEED_PARAM_FULL;
-		params.phy_type = DWC2_PHY_TYPE_PARAM_FS;
-	}
-
-	dwc2_set_parameters(hsotg, &params);
+	dwc2_set_default_params(hsotg);
 
 	return 0;
 }

commit 0f3a7459ae2fd47cce099735ea3260979729cbfd
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 23 14:54:52 2017 -0800

    usb: dwc2: Remove unused otg_ver parameter
    
    The otg_ver parameter only controls the SRP pulsing method and defaults
    to the 1.3 behavior. It is unused and can be removed.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index bcd1e19b4076..074f4061206a 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -40,7 +40,6 @@
 
 static const struct dwc2_core_params params_hi6220 = {
 	.otg_cap			= 2,	/* No HNP/SRP capable */
-	.otg_ver			= 0,	/* 1.3 */
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -71,7 +70,6 @@ static const struct dwc2_core_params params_hi6220 = {
 
 static const struct dwc2_core_params params_bcm2835 = {
 	.otg_cap			= 0,	/* HNP/SRP capable */
-	.otg_ver			= 0,	/* 1.3 */
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -101,7 +99,6 @@ static const struct dwc2_core_params params_bcm2835 = {
 
 static const struct dwc2_core_params params_rk3066 = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.otg_ver			= -1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= -1,
@@ -132,7 +129,6 @@ static const struct dwc2_core_params params_rk3066 = {
 
 static const struct dwc2_core_params params_ltq = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.otg_ver			= -1,
 	.dma_desc_enable		= -1,
 	.dma_desc_fs_enable		= -1,
 	.speed				= -1,
@@ -163,7 +159,6 @@ static const struct dwc2_core_params params_ltq = {
 
 static const struct dwc2_core_params params_amlogic = {
 	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
-	.otg_ver			= -1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= DWC2_SPEED_PARAM_HIGH,
@@ -194,7 +189,6 @@ static const struct dwc2_core_params params_amlogic = {
 
 static const struct dwc2_core_params params_default = {
 	.otg_cap			= -1,
-	.otg_ver			= -1,
 
 	/*
 	 * Disable descriptor dma mode by default as the HW can support
@@ -978,22 +972,6 @@ static void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
 						GAHBCFG_HBSTLEN_SHIFT;
 }
 
-static void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val)
-{
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
-		if (val >= 0) {
-			dev_err(hsotg->dev,
-				"'%d' invalid for parameter otg_ver\n", val);
-			dev_err(hsotg->dev,
-				"otg_ver must be 0 (for OTG 1.3 support) or 1 (for OTG 2.0 support)\n");
-		}
-		val = 0;
-		dev_dbg(hsotg->dev, "Setting otg_ver to %d\n", val);
-	}
-
-	hsotg->params.otg_ver = val;
-}
-
 static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
@@ -1154,7 +1132,6 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 			params->en_multiple_tx_fifo);
 	dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
 	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
-	dwc2_set_param_otg_ver(hsotg, params->otg_ver);
 	dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
 	dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
 	dwc2_set_param_hibernation(hsotg, params->hibernation);

commit b98866c25aecac30f447e45b7d410e8fa009156e
Author: John Youn <John.Youn@synopsys.com>
Date:   Tue Jan 17 20:31:58 2017 -0800

    usb: dwc2: Fix lines over 80 characters
    
    Fix lines over 80 characters.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 1efabdc24f64..bcd1e19b4076 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1131,27 +1131,27 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
 
 	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
-						    params->host_support_fs_ls_low_power);
+			params->host_support_fs_ls_low_power);
 	dwc2_set_param_enable_dynamic_fifo(hsotg,
-					   params->enable_dynamic_fifo);
+			params->enable_dynamic_fifo);
 	dwc2_set_param_max_transfer_size(hsotg,
-					 params->max_transfer_size);
+			params->max_transfer_size);
 	dwc2_set_param_max_packet_count(hsotg,
-					params->max_packet_count);
+			params->max_packet_count);
 	dwc2_set_param_host_channels(hsotg, params->host_channels);
 	dwc2_set_param_phy_type(hsotg, params->phy_type);
 	dwc2_set_param_speed(hsotg, params->speed);
 	dwc2_set_param_host_ls_low_power_phy_clk(hsotg,
-						 params->host_ls_low_power_phy_clk);
+			params->host_ls_low_power_phy_clk);
 	dwc2_set_param_phy_ulpi_ddr(hsotg, params->phy_ulpi_ddr);
 	dwc2_set_param_phy_ulpi_ext_vbus(hsotg,
-					 params->phy_ulpi_ext_vbus);
+			params->phy_ulpi_ext_vbus);
 	dwc2_set_param_phy_utmi_width(hsotg, params->phy_utmi_width);
 	dwc2_set_param_ulpi_fs_ls(hsotg, params->ulpi_fs_ls);
 	dwc2_set_param_ts_dline(hsotg, params->ts_dline);
 	dwc2_set_param_i2c_enable(hsotg, params->i2c_enable);
 	dwc2_set_param_en_multiple_tx_fifo(hsotg,
-					   params->en_multiple_tx_fifo);
+			params->en_multiple_tx_fifo);
 	dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
 	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
 	dwc2_set_param_otg_ver(hsotg, params->otg_ver);

commit 9da5197475a09e51a467388308f14dcbdcee8ba9
Author: John Youn <John.Youn@synopsys.com>
Date:   Tue Jan 17 20:30:27 2017 -0800

    usb: dwc2: Cleanup some checkpatch issues
    
    This commmit is the result of running checkpatch --fix.
    
    The results were verified for correctness. Some of the fixes result in
    line over 80 char which we will fix manually later.
    
    The following is a summary of what was done by checkpatch:
    * Remove externs on function prototypes.
    * Replace symbolic permissions with octal.
    * Align code to open parens.
    * Replace 'unsigned' with 'unsigned int'.
    * Remove unneccessary blank lines.
    * Add blank lines after declarations.
    * Add spaces around operators.
    * Remove unnecessary spaces after casts.
    * Replace 'x == NULL' with '!x'.
    * Replace kzalloc() with kcalloc().
    * Concatenate multi-line strings.
    * Use the BIT() macro.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index bcd1e19b4076..1efabdc24f64 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1131,27 +1131,27 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
 
 	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
-			params->host_support_fs_ls_low_power);
+						    params->host_support_fs_ls_low_power);
 	dwc2_set_param_enable_dynamic_fifo(hsotg,
-			params->enable_dynamic_fifo);
+					   params->enable_dynamic_fifo);
 	dwc2_set_param_max_transfer_size(hsotg,
-			params->max_transfer_size);
+					 params->max_transfer_size);
 	dwc2_set_param_max_packet_count(hsotg,
-			params->max_packet_count);
+					params->max_packet_count);
 	dwc2_set_param_host_channels(hsotg, params->host_channels);
 	dwc2_set_param_phy_type(hsotg, params->phy_type);
 	dwc2_set_param_speed(hsotg, params->speed);
 	dwc2_set_param_host_ls_low_power_phy_clk(hsotg,
-			params->host_ls_low_power_phy_clk);
+						 params->host_ls_low_power_phy_clk);
 	dwc2_set_param_phy_ulpi_ddr(hsotg, params->phy_ulpi_ddr);
 	dwc2_set_param_phy_ulpi_ext_vbus(hsotg,
-			params->phy_ulpi_ext_vbus);
+					 params->phy_ulpi_ext_vbus);
 	dwc2_set_param_phy_utmi_width(hsotg, params->phy_utmi_width);
 	dwc2_set_param_ulpi_fs_ls(hsotg, params->ulpi_fs_ls);
 	dwc2_set_param_ts_dline(hsotg, params->ts_dline);
 	dwc2_set_param_i2c_enable(hsotg, params->i2c_enable);
 	dwc2_set_param_en_multiple_tx_fifo(hsotg,
-			params->en_multiple_tx_fifo);
+					   params->en_multiple_tx_fifo);
 	dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
 	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
 	dwc2_set_param_otg_ver(hsotg, params->otg_ver);

commit 00c704ccb5b375859908caf5049eba5c08bd580d
Author: Leo Yan <leo.yan@linaro.org>
Date:   Fri Jan 6 19:28:26 2017 -0800

    usb: dwc2: use u32 for DT binding parameters
    
    Commit 05ee799f2021 ("usb: dwc2: Move gadget settings into core_params")
    changes to type u16 for DT binding "g-rx-fifo-size" and
    "g-np-tx-fifo-size" but use type u32 for "g-tx-fifo-size". Finally the
    the first two parameters cannot be passed successfully with wrong data
    format. This is found the data transferring broken on 96boards Hikey.
    
    This patch is to change all parameters to u32 type, and verified on
    Hikey board the DT parameters can pass successfully.
    
    [johnyoun: minor rebase]
    
    Signed-off-by: Leo Yan <leo.yan@linaro.org>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 11fe68a4627b..bcd1e19b4076 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -385,16 +385,16 @@ static void dwc2_set_param(struct dwc2_hsotg *hsotg, void *param,
 }
 
 /**
- * dwc2_set_param_u16() - Set a u16 parameter
+ * dwc2_set_param_u32() - Set a u32 parameter
  *
  * See dwc2_set_param().
  */
-static void dwc2_set_param_u16(struct dwc2_hsotg *hsotg, u16 *param,
+static void dwc2_set_param_u32(struct dwc2_hsotg *hsotg, u32 *param,
 			       bool lookup, char *property, u16 legacy,
 			       u16 def, u16 min, u16 max)
 {
 	dwc2_set_param(hsotg, param, lookup, property,
-		       legacy, def, min, max, 2);
+		       legacy, def, min, max, 4);
 }
 
 /**
@@ -1178,12 +1178,12 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 		 * auto-detect if the hardware does not support the
 		 * default.
 		 */
-		dwc2_set_param_u16(hsotg, &p->g_rx_fifo_size,
+		dwc2_set_param_u32(hsotg, &p->g_rx_fifo_size,
 				   true, "g-rx-fifo-size", 2048,
 				   hw->rx_fifo_size,
 				   16, hw->rx_fifo_size);
 
-		dwc2_set_param_u16(hsotg, &p->g_np_tx_fifo_size,
+		dwc2_set_param_u32(hsotg, &p->g_np_tx_fifo_size,
 				   true, "g-np-tx-fifo-size", 1024,
 				   hw->dev_nperio_tx_fifo_size,
 				   16, hw->dev_nperio_tx_fifo_size);

commit efc95b2ca42424de222119a3a260624f3a050f8e
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sun Nov 20 21:26:05 2016 +0000

    usb: dwc2: gadget: fix default value for gadget-dma-desc
    
    The current default for gadget DMA descriptor results on bcm2835 in a
    unnecessary error message:
    
      Invalid value 1 for param gadget-dma-desc
    
    So fix this by using hw->dma_desc_enable as default value.
    
    Fixes: dec4b55677e ("usb: dwc2: gadget: Add descriptor DMA parameter")
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 30b954e148ed..11fe68a4627b 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1094,7 +1094,7 @@ static void dwc2_set_gadget_dma(struct dwc2_hsotg *hsotg)
 	/* DMA Descriptor */
 	dwc2_set_param_bool(hsotg, &p->g_dma_desc, false,
 			    "gadget-dma-desc",
-			    p->g_dma, false,
+			    !!hw->dma_desc_enable, false,
 			    !!hw->dma_desc_enable);
 }
 

commit 6118d0647b10eaca06b278dee2022602d8f2f07a
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sun Nov 20 21:26:04 2016 +0000

    usb: dwc2: fix default value for DMA support
    
    The current defaults for DMA results on a non-DMA platform in a unnecessary
    error message:
    
      Invalid value 0 for param gadget-dma
    
    So fix this by using dma_capable as default value.
    
    Fixes: 9962b62f1be ("usb: dwc2: Deprecate g-use-dma binding")
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2c7b6243734c..30b954e148ed 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1088,7 +1088,7 @@ static void dwc2_set_gadget_dma(struct dwc2_hsotg *hsotg)
 	/* Buffer DMA */
 	dwc2_set_param_bool(hsotg, &p->g_dma,
 			    false, "gadget-dma",
-			    true, false,
+			    dma_capable, false,
 			    dma_capable);
 
 	/* DMA Descriptor */
@@ -1118,7 +1118,7 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 
 		dwc2_set_param_bool(hsotg, &p->host_dma,
 				    false, "host-dma",
-				    true, false,
+				    dma_capable, false,
 				    dma_capable);
 		dwc2_set_param_host_rx_fifo_size(hsotg,
 				params->host_rx_fifo_size);

commit de02238d6a7982a71682fe8da2996993a5a5eee7
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sun Nov 20 21:26:03 2016 +0000

    usb: dwc2: fix dwc2_get_device_property for u8 and u16
    
    According to the Devicetree ePAPR [1] the datatypes u8 and u16 are
    not defined. So using device_property_read_u16() would result in
    a partial read of a 32-bit big-endian integer which is not intended.
    So we better read the complete 32-bit value. This fixes a regression
    on bcm2835 where the values for g-rx-fifo-size and g-np-tx-fifo-size
    always read as zero:
    
      Invalid value 0 for param g-rx-fifo-size
      Invalid value 0 for param g-np-tx-fifo-size
    
    [1] - http://elinux.org/images/c/cf/Power_ePAPR_APPROVED_v1.1.pdf
    
    Fixes: 05ee799f202 ("usb: dwc2: Move gadget settings into core_params")
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index fd5f7f83843d..2c7b6243734c 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -247,8 +247,6 @@ MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
 static void dwc2_get_device_property(struct dwc2_hsotg *hsotg,
 				     char *property, u8 size, u64 *value)
 {
-	u8 val8;
-	u16 val16;
 	u32 val32;
 
 	switch (size) {
@@ -256,17 +254,7 @@ static void dwc2_get_device_property(struct dwc2_hsotg *hsotg,
 		*value = device_property_read_bool(hsotg->dev, property);
 		break;
 	case 1:
-		if (device_property_read_u8(hsotg->dev, property, &val8))
-			return;
-
-		*value = val8;
-		break;
 	case 2:
-		if (device_property_read_u16(hsotg->dev, property, &val16))
-			return;
-
-		*value = val16;
-		break;
 	case 4:
 		if (device_property_read_u32(hsotg->dev, property, &val32))
 			return;

commit f3419735279564d40467ebe4147d8a41cef00685
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sun Nov 20 21:26:02 2016 +0000

    usb: dwc2: Do not set host parameter in peripheral mode
    
    Since commit "usb: dwc2: Improve handling of host and device hwparams" the
    host mode specific hardware parameter aren't initialized in peripheral mode
    from the register settings anymore. So we better do not set them in this
    case which avoids the following warnings on bcm2835:
    
      256 invalid for host_nperio_tx_fifo_size. Check HW configuration.
      512 invalid for host_perio_tx_fifo_size. Check HW configuration.
    
    Fixes: 55e1040e424b ("usb: dwc2: Improve handling of host and device hwparams")
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index a786256535b6..fd5f7f83843d 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1132,6 +1132,12 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 				    false, "host-dma",
 				    true, false,
 				    dma_capable);
+		dwc2_set_param_host_rx_fifo_size(hsotg,
+				params->host_rx_fifo_size);
+		dwc2_set_param_host_nperio_tx_fifo_size(hsotg,
+				params->host_nperio_tx_fifo_size);
+		dwc2_set_param_host_perio_tx_fifo_size(hsotg,
+				params->host_perio_tx_fifo_size);
 	}
 	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
 	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
@@ -1140,12 +1146,6 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 			params->host_support_fs_ls_low_power);
 	dwc2_set_param_enable_dynamic_fifo(hsotg,
 			params->enable_dynamic_fifo);
-	dwc2_set_param_host_rx_fifo_size(hsotg,
-			params->host_rx_fifo_size);
-	dwc2_set_param_host_nperio_tx_fifo_size(hsotg,
-			params->host_nperio_tx_fifo_size);
-	dwc2_set_param_host_perio_tx_fifo_size(hsotg,
-			params->host_perio_tx_fifo_size);
 	dwc2_set_param_max_transfer_size(hsotg,
 			params->max_transfer_size);
 	dwc2_set_param_max_packet_count(hsotg,

commit 3922fb46f06035a246d31d25869a3276f1a1afa3
Author: Christian Lamparter <chunkeey@googlemail.com>
Date:   Tue Nov 15 15:03:40 2016 -0800

    usb: dwc2: add amcc,dwc-otg support
    
    This patch adds support for the "amcc,usb-otg" device
    which is found in the PowerPC Canyonlands' dts.
    
    The device definition was added by:
    
    commit c89b3458d8cc ("powerpc/44x: Add USB DWC DTS entry to Canyonlands
    board")
    
    but without any driver support as the dwc2 driver wasn't available at
    that time.
    
    Note: The system can't use the generic "snps,dwc2" compatible
    because of the special ahbcfg configuration. The default
    GAHBCFG_HBSTLEN_INCR4 of snps,dwc2 can cause a system hang
    when the USB and SATA is used concurrently.
    
    Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 513556a59f38..a786256535b6 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -239,6 +239,7 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
 	{ .compatible = "amlogic,meson8b-usb", .data = &params_amlogic },
 	{ .compatible = "amlogic,meson-gxbb-usb", .data = &params_amlogic },
+	{ .compatible = "amcc,dwc-otg", .data = NULL },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 4be0080c18fb41a95ab47ba7caff8359582457f9
Author: Christian Lamparter <chunkeey@googlemail.com>
Date:   Tue Nov 15 14:11:55 2016 +0200

    usb: dwc2: fixes host_dma logic
    
    This patch moves the the host_dma initialization
    before dwc2_set_param_dma_desc_enable() and
    dwc2_set_param_dma_desc_fs_enable(). The reason being
    that both function need it.
    
    Fixes: 1205489cee75bf39 ("usb: dwc2: Get host DMA device properties")
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 1bf3b0936d87..513556a59f38 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1123,9 +1123,6 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
 
 	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
-	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
-	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
-
 	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
 		dev_dbg(hsotg->dev, "Setting HOST parameters\n");
@@ -1135,6 +1132,8 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 				    true, false,
 				    dma_capable);
 	}
+	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
+	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
 
 	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
 			params->host_support_fs_ls_low_power);

commit 38e9002b85672352f8693c82192c8029586dd86d
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Mon Nov 14 19:17:03 2016 -0800

    usb: dwc2: gadget: Add new core parameter for low speed
    
    Added new core param for low speed, which can be used only when SNPSID
    is equal to DWC2_CORE_FS_IOT. When LS mode is enabled, we are
    restricting ep types and providing to upper layer only INTR and CTRL
    endpoints.
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2fd461de63a8..1bf3b0936d87 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -742,14 +742,18 @@ static void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 2)) {
 		if (val >= 0) {
 			dev_err(hsotg->dev, "Wrong value for speed parameter\n");
-			dev_err(hsotg->dev, "max_speed parameter must be 0 or 1\n");
+			dev_err(hsotg->dev, "max_speed parameter must be 0, 1, or 2\n");
 		}
 		valid = 0;
 	}
 
+	if (dwc2_is_hs_iot(hsotg) &&
+	    val == DWC2_SPEED_PARAM_LOW)
+		valid = 0;
+
 	if (val == DWC2_SPEED_PARAM_HIGH &&
 	    dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS)
 		valid = 0;

commit 1e6b98ebd458e63b9effda2feb696e36644d4eed
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Mon Nov 14 19:16:58 2016 -0800

    usb: dwc2: gadget: Add IOT device IDs, configure core accordingly
    
    Add new device IDs for IOT gadget. Done changes in probe to
    configure core accordingly depending on device ID value.
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 7152dbf4bb9f..2fd461de63a8 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1276,7 +1276,9 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	 */
 	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
 	if ((hw->snpsid & 0xfffff000) != 0x4f542000 &&
-	    (hw->snpsid & 0xfffff000) != 0x4f543000) {
+	    (hw->snpsid & 0xfffff000) != 0x4f543000 &&
+	    (hw->snpsid & 0xffff0000) != 0x55310000 &&
+	    (hw->snpsid & 0xffff0000) != 0x55320000) {
 		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
 			hw->snpsid);
 		return -ENODEV;
@@ -1418,6 +1420,11 @@ int dwc2_init_params(struct dwc2_hsotg *hsotg)
 	else
 		params = params_default;
 
+	if (dwc2_is_fs_iot(hsotg)) {
+		params.speed = DWC2_SPEED_PARAM_FULL;
+		params.phy_type = DWC2_PHY_TYPE_PARAM_FS;
+	}
+
 	dwc2_set_parameters(hsotg, &params);
 
 	return 0;

commit 8ad07335e81183bacdabf080efa5120d573d6f94
Author: John Youn <johnyoun@synopsys.com>
Date:   Mon Nov 14 18:29:57 2016 -0800

    usb: dwc2: Remove reading in of invalid property
    
    This property was mistakenly added, then removed, so don't read it in.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2f18a7b4c08c..7152dbf4bb9f 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1124,16 +1124,11 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 
 	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
-		bool disable;
-
 		dev_dbg(hsotg->dev, "Setting HOST parameters\n");
 
-		disable = device_property_read_bool(hsotg->dev,
-						    "snps,host-dma-disable");
-
 		dwc2_set_param_bool(hsotg, &p->host_dma,
 				    false, "host-dma",
-				    !disable, false,
+				    true, false,
 				    dma_capable);
 	}
 

commit dec4b55677edbd9f5e4c86d020ba44bd3f3f319d
Author: Vahram Aharonyan <vahrama@synopsys.com>
Date:   Wed Nov 9 19:27:48 2016 -0800

    usb: dwc2: gadget: Add descriptor DMA parameter
    
    Add a parameter for descriptor DMA and set it based on hardware
    capabilities. This won't actually be used by the gadget until later,
    when the descriptor DMA code is in place.
    
    Signed-off-by: Vahram Aharonyan <vahrama@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 74c3728f77d9..2f18a7b4c08c 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1097,6 +1097,12 @@ static void dwc2_set_gadget_dma(struct dwc2_hsotg *hsotg)
 			    false, "gadget-dma",
 			    true, false,
 			    dma_capable);
+
+	/* DMA Descriptor */
+	dwc2_set_param_bool(hsotg, &p->g_dma_desc, false,
+			    "gadget-dma-desc",
+			    p->g_dma, false,
+			    !!hw->dma_desc_enable);
 }
 
 /**

commit 9962b62f1be95c981c4d9307921f15e232f4d603
Author: John Youn <johnyoun@synopsys.com>
Date:   Wed Nov 9 19:27:40 2016 -0800

    usb: dwc2: Deprecate g-use-dma binding
    
    This is not needed as the gadget now fully supports DMA and it can
    autodetect it. This was initially added because gadget DMA mode was only
    partially implemented so could not be automatically enabled.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2eb79e8bee7f..74c3728f77d9 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1086,6 +1086,19 @@ static void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
 	}
 }
 
+static void dwc2_set_gadget_dma(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	struct dwc2_core_params *p = &hsotg->params;
+	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
+
+	/* Buffer DMA */
+	dwc2_set_param_bool(hsotg, &p->g_dma,
+			    false, "gadget-dma",
+			    true, false,
+			    dma_capable);
+}
+
 /**
  * dwc2_set_parameters() - Set all core parameters.
  *
@@ -1161,9 +1174,7 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
 		dev_dbg(hsotg->dev, "Setting peripheral device properties\n");
 
-		dwc2_set_param_bool(hsotg, &p->g_dma, true, "g-use-dma",
-				    false, false,
-				    dma_capable);
+		dwc2_set_gadget_dma(hsotg);
 
 		/*
 		 * The values for g_rx_fifo_size (2048) and

commit 6b66ce51e212da3efe293a99541d850708b65ed3
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:56:12 2016 -0700

    usb: dwc2: Get host DMA device properties
    
    The driver will automatically enable host DMA and use it if available.
    This is consistent with the behavior of all existing platforms.
    
    Read in the "snps,host-dma-disable" device property to disable it.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 08b00ca04e6b..2eb79e8bee7f 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -41,7 +41,6 @@
 static const struct dwc2_core_params params_hi6220 = {
 	.otg_cap			= 2,	/* No HNP/SRP capable */
 	.otg_ver			= 0,	/* 1.3 */
-	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -73,7 +72,6 @@ static const struct dwc2_core_params params_hi6220 = {
 static const struct dwc2_core_params params_bcm2835 = {
 	.otg_cap			= 0,	/* HNP/SRP capable */
 	.otg_ver			= 0,	/* 1.3 */
-	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -104,7 +102,6 @@ static const struct dwc2_core_params params_bcm2835 = {
 static const struct dwc2_core_params params_rk3066 = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
 	.otg_ver			= -1,
-	.host_dma			= -1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= -1,
@@ -136,7 +133,6 @@ static const struct dwc2_core_params params_rk3066 = {
 static const struct dwc2_core_params params_ltq = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
 	.otg_ver			= -1,
-	.host_dma			= -1,
 	.dma_desc_enable		= -1,
 	.dma_desc_fs_enable		= -1,
 	.speed				= -1,
@@ -168,7 +164,6 @@ static const struct dwc2_core_params params_ltq = {
 static const struct dwc2_core_params params_amlogic = {
 	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
 	.otg_ver			= -1,
-	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= DWC2_SPEED_PARAM_HIGH,
@@ -200,7 +195,6 @@ static const struct dwc2_core_params params_amlogic = {
 static const struct dwc2_core_params params_default = {
 	.otg_cap			= -1,
 	.otg_ver			= -1,
-	.host_dma			= -1,
 
 	/*
 	 * Disable descriptor dma mode by default as the HW can support
@@ -486,27 +480,6 @@ static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.otg_cap = val;
 }
 
-static void dwc2_set_param_host_dma(struct dwc2_hsotg *hsotg, int val)
-{
-	int valid = 1;
-
-	if (val > 0 && hsotg->hw_params.arch == GHWCFG2_SLAVE_ONLY_ARCH)
-		valid = 0;
-	if (val < 0)
-		valid = 0;
-
-	if (!valid) {
-		if (val >= 0)
-			dev_err(hsotg->dev,
-				"%d invalid for host_dma parameter. Check HW configuration.\n",
-				val);
-		val = hsotg->hw_params.arch != GHWCFG2_SLAVE_ONLY_ARCH;
-		dev_dbg(hsotg->dev, "Setting host_dma to %d\n", val);
-	}
-
-	hsotg->params.host_dma = val;
-}
-
 static void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
@@ -1124,11 +1097,27 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 {
 	struct dwc2_hw_params *hw = &hsotg->hw_params;
 	struct dwc2_core_params *p = &hsotg->params;
+	bool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);
 
 	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
-	dwc2_set_param_host_dma(hsotg, params->host_dma);
 	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
 	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
+
+	if ((hsotg->dr_mode == USB_DR_MODE_HOST) ||
+	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
+		bool disable;
+
+		dev_dbg(hsotg->dev, "Setting HOST parameters\n");
+
+		disable = device_property_read_bool(hsotg->dev,
+						    "snps,host-dma-disable");
+
+		dwc2_set_param_bool(hsotg, &p->host_dma,
+				    false, "host-dma",
+				    !disable, false,
+				    dma_capable);
+	}
+
 	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
 			params->host_support_fs_ls_low_power);
 	dwc2_set_param_enable_dynamic_fifo(hsotg,
@@ -1174,8 +1163,7 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 
 		dwc2_set_param_bool(hsotg, &p->g_dma, true, "g-use-dma",
 				    false, false,
-				    hsotg->hw_params.arch !=
-				    GHWCFG2_SLAVE_ONLY_ARCH);
+				    dma_capable);
 
 		/*
 		 * The values for g_rx_fifo_size (2048) and

commit e7839f99b7dab1d161e39391855788ef2bbfb106
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:56:07 2016 -0700

    usb: dwc2: Rename the dma_enable parameter to host_dma
    
    Rename it so that it is more consistent with the gadget dma parameter.
    It only affects host-mode operation so prefix it with "host".
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index c96ae72f4f0e..08b00ca04e6b 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -41,7 +41,7 @@
 static const struct dwc2_core_params params_hi6220 = {
 	.otg_cap			= 2,	/* No HNP/SRP capable */
 	.otg_ver			= 0,	/* 1.3 */
-	.dma_enable			= 1,
+	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -73,7 +73,7 @@ static const struct dwc2_core_params params_hi6220 = {
 static const struct dwc2_core_params params_bcm2835 = {
 	.otg_cap			= 0,	/* HNP/SRP capable */
 	.otg_ver			= 0,	/* 1.3 */
-	.dma_enable			= 1,
+	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
@@ -104,7 +104,7 @@ static const struct dwc2_core_params params_bcm2835 = {
 static const struct dwc2_core_params params_rk3066 = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
 	.otg_ver			= -1,
-	.dma_enable			= -1,
+	.host_dma			= -1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= -1,
@@ -136,7 +136,7 @@ static const struct dwc2_core_params params_rk3066 = {
 static const struct dwc2_core_params params_ltq = {
 	.otg_cap			= 2,	/* non-HNP/non-SRP */
 	.otg_ver			= -1,
-	.dma_enable			= -1,
+	.host_dma			= -1,
 	.dma_desc_enable		= -1,
 	.dma_desc_fs_enable		= -1,
 	.speed				= -1,
@@ -168,7 +168,7 @@ static const struct dwc2_core_params params_ltq = {
 static const struct dwc2_core_params params_amlogic = {
 	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
 	.otg_ver			= -1,
-	.dma_enable			= 1,
+	.host_dma			= 1,
 	.dma_desc_enable		= 0,
 	.dma_desc_fs_enable		= 0,
 	.speed				= DWC2_SPEED_PARAM_HIGH,
@@ -200,7 +200,7 @@ static const struct dwc2_core_params params_amlogic = {
 static const struct dwc2_core_params params_default = {
 	.otg_cap			= -1,
 	.otg_ver			= -1,
-	.dma_enable			= -1,
+	.host_dma			= -1,
 
 	/*
 	 * Disable descriptor dma mode by default as the HW can support
@@ -486,7 +486,7 @@ static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.otg_cap = val;
 }
 
-static void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_dma(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -498,20 +498,20 @@ static void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
 	if (!valid) {
 		if (val >= 0)
 			dev_err(hsotg->dev,
-				"%d invalid for dma_enable parameter. Check HW configuration.\n",
+				"%d invalid for host_dma parameter. Check HW configuration.\n",
 				val);
 		val = hsotg->hw_params.arch != GHWCFG2_SLAVE_ONLY_ARCH;
-		dev_dbg(hsotg->dev, "Setting dma_enable to %d\n", val);
+		dev_dbg(hsotg->dev, "Setting host_dma to %d\n", val);
 	}
 
-	hsotg->params.dma_enable = val;
+	hsotg->params.host_dma = val;
 }
 
 static void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (val > 0 && (hsotg->params.dma_enable <= 0 ||
+	if (val > 0 && (hsotg->params.host_dma <= 0 ||
 			!hsotg->hw_params.dma_desc_enable))
 		valid = 0;
 	if (val < 0)
@@ -522,7 +522,7 @@ static void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 			dev_err(hsotg->dev,
 				"%d invalid for dma_desc_enable parameter. Check HW configuration.\n",
 				val);
-		val = (hsotg->params.dma_enable > 0 &&
+		val = (hsotg->params.host_dma > 0 &&
 			hsotg->hw_params.dma_desc_enable);
 		dev_dbg(hsotg->dev, "Setting dma_desc_enable to %d\n", val);
 	}
@@ -534,7 +534,7 @@ static void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (val > 0 && (hsotg->params.dma_enable <= 0 ||
+	if (val > 0 && (hsotg->params.host_dma <= 0 ||
 			!hsotg->hw_params.dma_desc_enable))
 		valid = 0;
 	if (val < 0)
@@ -545,7 +545,7 @@ static void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 			dev_err(hsotg->dev,
 				"%d invalid for dma_desc_fs_enable parameter. Check HW configuration.\n",
 				val);
-		val = (hsotg->params.dma_enable > 0 &&
+		val = (hsotg->params.host_dma > 0 &&
 			hsotg->hw_params.dma_desc_enable);
 	}
 
@@ -1126,7 +1126,7 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	struct dwc2_core_params *p = &hsotg->params;
 
 	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
-	dwc2_set_param_dma_enable(hsotg, params->dma_enable);
+	dwc2_set_param_host_dma(hsotg, params->host_dma);
 	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
 	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
 	dwc2_set_param_host_support_fs_ls_low_power(hsotg,

commit 05ee799f2021658cc0fc64c1f05c940877b90724
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:56:05 2016 -0700

    usb: dwc2: Move gadget settings into core_params
    
    Move the gadget devicetree settings into the core_params structure and
    document them. Then set and check them in params.c, with the addition of
    some helper functions, and remove the equivalent code in gadget.c.
    
    Because these parameters came from the standalone s3c driver, they have
    a fixed default value rather than an autodetected one. Preserve and
    document this behavior to avoid any compatibility issues.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 719205ab09a2..c96ae72f4f0e 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -249,6 +249,187 @@ const struct of_device_id dwc2_of_match_table[] = {
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
 
+static void dwc2_get_device_property(struct dwc2_hsotg *hsotg,
+				     char *property, u8 size, u64 *value)
+{
+	u8 val8;
+	u16 val16;
+	u32 val32;
+
+	switch (size) {
+	case 0:
+		*value = device_property_read_bool(hsotg->dev, property);
+		break;
+	case 1:
+		if (device_property_read_u8(hsotg->dev, property, &val8))
+			return;
+
+		*value = val8;
+		break;
+	case 2:
+		if (device_property_read_u16(hsotg->dev, property, &val16))
+			return;
+
+		*value = val16;
+		break;
+	case 4:
+		if (device_property_read_u32(hsotg->dev, property, &val32))
+			return;
+
+		*value = val32;
+		break;
+	case 8:
+		if (device_property_read_u64(hsotg->dev, property, value))
+			return;
+
+		break;
+	default:
+		/*
+		 * The size is checked by the only function that calls
+		 * this so this should never happen.
+		 */
+		WARN_ON(1);
+		return;
+	}
+}
+
+static void dwc2_set_core_param(void *param, u8 size, u64 value)
+{
+	switch (size) {
+	case 0:
+		*((bool *)param) = !!value;
+		break;
+	case 1:
+		*((u8 *)param) = (u8)value;
+		break;
+	case 2:
+		*((u16 *)param) = (u16)value;
+		break;
+	case 4:
+		*((u32 *)param) = (u32)value;
+		break;
+	case 8:
+		*((u64 *)param) = (u64)value;
+		break;
+	default:
+		/*
+		 * The size is checked by the only function that calls
+		 * this so this should never happen.
+		 */
+		WARN_ON(1);
+		return;
+	}
+}
+
+/**
+ * dwc2_set_param() - Set a core parameter
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @param: Pointer to the parameter to set
+ * @lookup: True if the property should be looked up
+ * @property: The device property to read
+ * @legacy: The param value to set if @property is not available. This
+ *          will typically be the legacy value set in the static
+ *          params structure.
+ * @def: The default value
+ * @min: The minimum value
+ * @max: The maximum value
+ * @size: The size of the core parameter in bytes, or 0 for bool.
+ *
+ * This function looks up @property and sets the @param to that value.
+ * If the property doesn't exist it uses the passed-in @value. It will
+ * verify that the value falls between @min and @max. If it doesn't,
+ * it will output an error and set the parameter to either @def or,
+ * failing that, to @min.
+ *
+ * The @size is used to write to @param and to query the device
+ * properties so that this same function can be used with different
+ * types of parameters.
+ */
+static void dwc2_set_param(struct dwc2_hsotg *hsotg, void *param,
+			   bool lookup, char *property, u64 legacy,
+			   u64 def, u64 min, u64 max, u8 size)
+{
+	u64 sizemax;
+	u64 value;
+
+	if (WARN_ON(!hsotg || !param || !property))
+		return;
+
+	if (WARN((size > 8) || ((size & (size - 1)) != 0),
+		 "Invalid size %d for %s\n", size, property))
+		return;
+
+	dev_vdbg(hsotg->dev, "%s: Setting %s: legacy=%llu, def=%llu, min=%llu, max=%llu, size=%d\n",
+		 __func__, property, legacy, def, min, max, size);
+
+	sizemax = (1ULL << (size * 8)) - 1;
+	value = legacy;
+
+	/* Override legacy settings. */
+	if (lookup)
+		dwc2_get_device_property(hsotg, property, size, &value);
+
+	/*
+	 * While the value is not valid, try setting it to the default
+	 * value, and failing that, set it to the minimum.
+	 */
+	while ((value < min) || (value > max)) {
+		/* Print an error unless the value is set to auto. */
+		if (value != sizemax)
+			dev_err(hsotg->dev, "Invalid value %llu for param %s\n",
+				value, property);
+
+		/*
+		 * If we are already the default, just set it to the
+		 * minimum.
+		 */
+		if (value == def) {
+			dev_vdbg(hsotg->dev, "%s: setting value to min=%llu\n",
+				 __func__, min);
+			value = min;
+			break;
+		}
+
+		/* Try the default value */
+		dev_vdbg(hsotg->dev, "%s: setting value to default=%llu\n",
+			 __func__, def);
+		value = def;
+	}
+
+	dev_dbg(hsotg->dev, "Setting %s to %llu\n", property, value);
+	dwc2_set_core_param(param, size, value);
+}
+
+/**
+ * dwc2_set_param_u16() - Set a u16 parameter
+ *
+ * See dwc2_set_param().
+ */
+static void dwc2_set_param_u16(struct dwc2_hsotg *hsotg, u16 *param,
+			       bool lookup, char *property, u16 legacy,
+			       u16 def, u16 min, u16 max)
+{
+	dwc2_set_param(hsotg, param, lookup, property,
+		       legacy, def, min, max, 2);
+}
+
+/**
+ * dwc2_set_param_bool() - Set a bool parameter
+ *
+ * See dwc2_set_param().
+ *
+ * Note: there is no 'legacy' argument here because there is no legacy
+ * source of bool params.
+ */
+static void dwc2_set_param_bool(struct dwc2_hsotg *hsotg, bool *param,
+				bool lookup, char *property,
+				bool def, bool min, bool max)
+{
+	dwc2_set_param(hsotg, param, lookup, property,
+		       def, def, min, max, 0);
+}
+
 #define DWC2_OUT_OF_BOUNDS(a, b, c)	((a) < (b) || (a) > (c))
 
 /* Parameter access functions */
@@ -897,14 +1078,52 @@ static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
 	hsotg->params.hibernation = val;
 }
 
-/*
- * This function is called during module intialization to pass module parameters
- * for the DWC_otg core.
+static void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)
+{
+	int i;
+	int num;
+	char *property = "g-tx-fifo-size";
+	struct dwc2_core_params *p = &hsotg->params;
+
+	memset(p->g_tx_fifo_size, 0, sizeof(p->g_tx_fifo_size));
+
+	/* Read tx fifo sizes */
+	num = device_property_read_u32_array(hsotg->dev, property, NULL, 0);
+
+	if (num > 0) {
+		device_property_read_u32_array(hsotg->dev, property,
+					       &p->g_tx_fifo_size[1],
+					       num);
+	} else {
+		u32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;
+
+		memcpy(&p->g_tx_fifo_size[1],
+		       p_tx_fifo,
+		       sizeof(p_tx_fifo));
+
+		num = ARRAY_SIZE(p_tx_fifo);
+	}
+
+	for (i = 0; i < num; i++) {
+		if ((i + 1) >= ARRAY_SIZE(p->g_tx_fifo_size))
+			break;
+
+		dev_dbg(hsotg->dev, "Setting %s[%d] to %d\n",
+			property, i + 1, p->g_tx_fifo_size[i + 1]);
+	}
+}
+
+/**
+ * dwc2_set_parameters() - Set all core parameters.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @params: The parameters to set
  */
 static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 				const struct dwc2_core_params *params)
 {
-	dev_dbg(hsotg->dev, "%s()\n", __func__);
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	struct dwc2_core_params *p = &hsotg->params;
 
 	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
 	dwc2_set_param_dma_enable(hsotg, params->dma_enable);
@@ -944,6 +1163,41 @@ static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
 	dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
 	dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
 	dwc2_set_param_hibernation(hsotg, params->hibernation);
+
+	/*
+	 * Set devicetree-only parameters. These parameters do not
+	 * take any values from @params.
+	 */
+	if ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||
+	    (hsotg->dr_mode == USB_DR_MODE_OTG)) {
+		dev_dbg(hsotg->dev, "Setting peripheral device properties\n");
+
+		dwc2_set_param_bool(hsotg, &p->g_dma, true, "g-use-dma",
+				    false, false,
+				    hsotg->hw_params.arch !=
+				    GHWCFG2_SLAVE_ONLY_ARCH);
+
+		/*
+		 * The values for g_rx_fifo_size (2048) and
+		 * g_np_tx_fifo_size (1024) come from the legacy s3c
+		 * gadget driver. These defaults have been hard-coded
+		 * for some time so many platforms depend on these
+		 * values. Leave them as defaults for now and only
+		 * auto-detect if the hardware does not support the
+		 * default.
+		 */
+		dwc2_set_param_u16(hsotg, &p->g_rx_fifo_size,
+				   true, "g-rx-fifo-size", 2048,
+				   hw->rx_fifo_size,
+				   16, hw->rx_fifo_size);
+
+		dwc2_set_param_u16(hsotg, &p->g_np_tx_fifo_size,
+				   true, "g-np-tx-fifo-size", 1024,
+				   hw->dev_nperio_tx_fifo_size,
+				   16, hw->dev_nperio_tx_fifo_size);
+
+		dwc2_set_param_tx_fifo_sizes(hsotg);
+	}
 }
 
 /*

commit d1531319dddc588d5e5c3045c55313203555f5be
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:56:02 2016 -0700

    usb: dwc2: Rename host_rx_fifo_size hardware parameter
    
    This hardware parameter is not host specific. It also applies to device
    mode. Drop the "host" from the name to make that clear.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 2c6bc3a6c697..719205ab09a2 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -417,7 +417,7 @@ static void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (val < 16 || val > hsotg->hw_params.host_rx_fifo_size)
+	if (val < 16 || val > hsotg->hw_params.rx_fifo_size)
 		valid = 0;
 
 	if (!valid) {
@@ -425,7 +425,7 @@ static void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 			dev_err(hsotg->dev,
 				"%d invalid for host_rx_fifo_size. Check HW configuration.\n",
 				val);
-		val = hsotg->hw_params.host_rx_fifo_size;
+		val = hsotg->hw_params.rx_fifo_size;
 		dev_dbg(hsotg->dev, "Setting host_rx_fifo_size to %d\n", val);
 	}
 
@@ -1100,7 +1100,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
 
 	/* fifo sizes */
-	hw->host_rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>
+	hw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>
 				GRXFSIZ_DEPTH_SHIFT;
 
 	dev_dbg(hsotg->dev, "Detected values from hardware:\n");
@@ -1142,8 +1142,8 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 		hw->en_multiple_tx_fifo);
 	dev_dbg(hsotg->dev, "  total_fifo_size=%d\n",
 		hw->total_fifo_size);
-	dev_dbg(hsotg->dev, "  host_rx_fifo_size=%d\n",
-		hw->host_rx_fifo_size);
+	dev_dbg(hsotg->dev, "  rx_fifo_size=%d\n",
+		hw->rx_fifo_size);
 	dev_dbg(hsotg->dev, "  host_nperio_tx_fifo_size=%d\n",
 		hw->host_nperio_tx_fifo_size);
 	dev_dbg(hsotg->dev, "  host_perio_tx_fifo_size=%d\n",

commit c1d286cfb0be5eaa8d4e1b749d9e5c9de9768889
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:56:00 2016 -0700

    usb: dwc2: Remove unnecessary prototypes
    
    Remove the unnecessary prototypes for all the parameter setting
    functions and declare those functions 'static' in the params.c file.
    
    Also remove the duplicate documentation that went along with them. They
    are already documented as part of the params structure definition.
    
    Then move the constants that went along with the prototype into the
    structure.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 360f2941de3c..2c6bc3a6c697 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -252,7 +252,7 @@ MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
 #define DWC2_OUT_OF_BOUNDS(a, b, c)	((a) < (b) || (a) > (c))
 
 /* Parameter access functions */
-void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -305,7 +305,7 @@ void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.otg_cap = val;
 }
 
-void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -326,7 +326,7 @@ void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.dma_enable = val;
 }
 
-void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -349,7 +349,7 @@ void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.dma_desc_enable = val;
 }
 
-void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -372,8 +372,9 @@ void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 	dev_dbg(hsotg->dev, "Setting dma_desc_fs_enable to %d\n", val);
 }
 
-void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
-						 int val)
+static void
+dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
+					    int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -390,7 +391,8 @@ void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
 	hsotg->params.host_support_fs_ls_low_power = val;
 }
 
-void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg,
+					       int val)
 {
 	int valid = 1;
 
@@ -411,7 +413,7 @@ void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.enable_dynamic_fifo = val;
 }
 
-void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -430,7 +432,8 @@ void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.host_rx_fifo_size = val;
 }
 
-void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg,
+						    int val)
 {
 	int valid = 1;
 
@@ -450,7 +453,8 @@ void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.host_nperio_tx_fifo_size = val;
 }
 
-void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg,
+						   int val)
 {
 	int valid = 1;
 
@@ -470,7 +474,7 @@ void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.host_perio_tx_fifo_size = val;
 }
 
-void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -489,7 +493,7 @@ void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.max_transfer_size = val;
 }
 
-void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -508,7 +512,7 @@ void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.max_packet_count = val;
 }
 
-void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -527,7 +531,7 @@ void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.host_channels = val;
 }
 
-void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 0;
 	u32 hs_phy_type, fs_phy_type;
@@ -580,7 +584,7 @@ static int dwc2_get_param_phy_type(struct dwc2_hsotg *hsotg)
 	return hsotg->params.phy_type;
 }
 
-void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -609,7 +613,8 @@ void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.speed = val;
 }
 
-void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg,
+						     int val)
 {
 	int valid = 1;
 
@@ -643,7 +648,7 @@ void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.host_ls_low_power_phy_clk = val;
 }
 
-void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -657,7 +662,7 @@ void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.phy_ulpi_ddr = val;
 }
 
-void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -673,7 +678,7 @@ void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.phy_ulpi_ext_vbus = val;
 }
 
-void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 0;
 
@@ -703,7 +708,7 @@ void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.phy_utmi_width = val;
 }
 
-void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -717,7 +722,7 @@ void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.ulpi_fs_ls = val;
 }
 
-void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -731,7 +736,7 @@ void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.ts_dline = val;
 }
 
-void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -759,7 +764,8 @@ void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.i2c_enable = val;
 }
 
-void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg,
+					       int val)
 {
 	int valid = 1;
 
@@ -788,7 +794,7 @@ void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.en_multiple_tx_fifo = val;
 }
 
-void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
@@ -816,7 +822,7 @@ void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
 	hsotg->params.reload_ctl = val;
 }
 
-void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
 {
 	if (val != -1)
 		hsotg->params.ahbcfg = val;
@@ -825,7 +831,7 @@ void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
 						GAHBCFG_HBSTLEN_SHIFT;
 }
 
-void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val)
+static void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val)
 {
 	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
 		if (val >= 0) {
@@ -895,8 +901,8 @@ static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
  * This function is called during module intialization to pass module parameters
  * for the DWC_otg core.
  */
-void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
-			 const struct dwc2_core_params *params)
+static void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
+				const struct dwc2_core_params *params)
 {
 	dev_dbg(hsotg->dev, "%s()\n", __func__);
 

commit 0a7d0d7fa820e4281370795ef43c6aaa8b91a07e
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:57 2016 -0700

    usb: dwc2: Remove dwc2_set_all_params function
    
    Replace this by statically defining a function with defaults, and just
    assigning it. This will allow us to use parameters of any type and any
    default value.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index d6c92d4f53ce..360f2941de3c 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -197,6 +197,44 @@ static const struct dwc2_core_params params_amlogic = {
 	.hibernation			= -1,
 };
 
+static const struct dwc2_core_params params_default = {
+	.otg_cap			= -1,
+	.otg_ver			= -1,
+	.dma_enable			= -1,
+
+	/*
+	 * Disable descriptor dma mode by default as the HW can support
+	 * it, but does not support it for SPLIT transactions.
+	 * Disable it for FS devices as well.
+	 */
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+
+	.speed				= -1,
+	.enable_dynamic_fifo		= -1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= -1,
+	.host_nperio_tx_fifo_size	= -1,
+	.host_perio_tx_fifo_size	= -1,
+	.max_transfer_size		= -1,
+	.max_packet_count		= -1,
+	.host_channels			= -1,
+	.phy_type			= -1,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= -1,
+	.ahbcfg				= -1,
+	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
@@ -1109,46 +1147,18 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	return 0;
 }
 
-/*
- * Sets all parameters to the given value.
- *
- * Assumes that the dwc2_core_params struct contains only integers.
- */
-void dwc2_set_all_params(struct dwc2_core_params *params, int value)
-{
-	int *p = (int *)params;
-	size_t size = sizeof(*params) / sizeof(*p);
-	int i;
-
-	for (i = 0; i < size; i++)
-		p[i] = value;
-}
-
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
 	const struct of_device_id *match;
-	const struct dwc2_core_params *params;
-	struct dwc2_core_params defparams;
+	struct dwc2_core_params params;
 
 	match = of_match_device(dwc2_of_match_table, hsotg->dev);
-	if (match && match->data) {
-		params = match->data;
-	} else {
-		/* Default all params to autodetect */
-		dwc2_set_all_params(&defparams, -1);
-		params = &defparams;
-
-		/*
-		 * Disable descriptor dma mode by default as the HW can support
-		 * it, but does not support it for SPLIT transactions.
-		 * Disable it for FS devices as well.
-		 */
-		defparams.dma_desc_enable = 0;
-		defparams.dma_desc_fs_enable = 0;
-	}
+	if (match && match->data)
+		params = *((struct dwc2_core_params *)match->data);
+	else
+		params = params_default;
 
-	/* Validate parameter values */
-	dwc2_set_parameters(hsotg, params);
+	dwc2_set_parameters(hsotg, &params);
 
 	return 0;
 }

commit 334bbd4ebe1b34e1640118a5bfcd48f65d96242f
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:55 2016 -0700

    usb: dwc2: Move parameter initialization into params.c
    
    Consolidate and move all the parameter initialization code from the
    probe function to params.c.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index ff7c844382eb..d6c92d4f53ce 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -1123,3 +1123,32 @@ void dwc2_set_all_params(struct dwc2_core_params *params, int value)
 	for (i = 0; i < size; i++)
 		p[i] = value;
 }
+
+int dwc2_init_params(struct dwc2_hsotg *hsotg)
+{
+	const struct of_device_id *match;
+	const struct dwc2_core_params *params;
+	struct dwc2_core_params defparams;
+
+	match = of_match_device(dwc2_of_match_table, hsotg->dev);
+	if (match && match->data) {
+		params = match->data;
+	} else {
+		/* Default all params to autodetect */
+		dwc2_set_all_params(&defparams, -1);
+		params = &defparams;
+
+		/*
+		 * Disable descriptor dma mode by default as the HW can support
+		 * it, but does not support it for SPLIT transactions.
+		 * Disable it for FS devices as well.
+		 */
+		defparams.dma_desc_enable = 0;
+		defparams.dma_desc_fs_enable = 0;
+	}
+
+	/* Validate parameter values */
+	dwc2_set_parameters(hsotg, params);
+
+	return 0;
+}

commit bea8e86c51cf9cf637e5bf0610d14674e9115783
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:53 2016 -0700

    usb: dwc2: Declare the core params struct statically
    
    This makes it consistent with the hw_params struct and simplifies the
    memory management for future refactoring. Fix up usage in all files.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 66a827a25103..ff7c844382eb 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -264,7 +264,7 @@ void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting otg_cap to %d\n", val);
 	}
 
-	hsotg->core_params->otg_cap = val;
+	hsotg->params.otg_cap = val;
 }
 
 void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
@@ -285,14 +285,14 @@ void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting dma_enable to %d\n", val);
 	}
 
-	hsotg->core_params->dma_enable = val;
+	hsotg->params.dma_enable = val;
 }
 
 void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (val > 0 && (hsotg->core_params->dma_enable <= 0 ||
+	if (val > 0 && (hsotg->params.dma_enable <= 0 ||
 			!hsotg->hw_params.dma_desc_enable))
 		valid = 0;
 	if (val < 0)
@@ -303,19 +303,19 @@ void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
 			dev_err(hsotg->dev,
 				"%d invalid for dma_desc_enable parameter. Check HW configuration.\n",
 				val);
-		val = (hsotg->core_params->dma_enable > 0 &&
+		val = (hsotg->params.dma_enable > 0 &&
 			hsotg->hw_params.dma_desc_enable);
 		dev_dbg(hsotg->dev, "Setting dma_desc_enable to %d\n", val);
 	}
 
-	hsotg->core_params->dma_desc_enable = val;
+	hsotg->params.dma_desc_enable = val;
 }
 
 void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 {
 	int valid = 1;
 
-	if (val > 0 && (hsotg->core_params->dma_enable <= 0 ||
+	if (val > 0 && (hsotg->params.dma_enable <= 0 ||
 			!hsotg->hw_params.dma_desc_enable))
 		valid = 0;
 	if (val < 0)
@@ -326,11 +326,11 @@ void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
 			dev_err(hsotg->dev,
 				"%d invalid for dma_desc_fs_enable parameter. Check HW configuration.\n",
 				val);
-		val = (hsotg->core_params->dma_enable > 0 &&
+		val = (hsotg->params.dma_enable > 0 &&
 			hsotg->hw_params.dma_desc_enable);
 	}
 
-	hsotg->core_params->dma_desc_fs_enable = val;
+	hsotg->params.dma_desc_fs_enable = val;
 	dev_dbg(hsotg->dev, "Setting dma_desc_fs_enable to %d\n", val);
 }
 
@@ -349,7 +349,7 @@ void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
 			"Setting host_support_fs_low_power to %d\n", val);
 	}
 
-	hsotg->core_params->host_support_fs_ls_low_power = val;
+	hsotg->params.host_support_fs_ls_low_power = val;
 }
 
 void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg, int val)
@@ -370,7 +370,7 @@ void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting enable_dynamic_fifo to %d\n", val);
 	}
 
-	hsotg->core_params->enable_dynamic_fifo = val;
+	hsotg->params.enable_dynamic_fifo = val;
 }
 
 void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
@@ -389,7 +389,7 @@ void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting host_rx_fifo_size to %d\n", val);
 	}
 
-	hsotg->core_params->host_rx_fifo_size = val;
+	hsotg->params.host_rx_fifo_size = val;
 }
 
 void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
@@ -409,7 +409,7 @@ void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 			val);
 	}
 
-	hsotg->core_params->host_nperio_tx_fifo_size = val;
+	hsotg->params.host_nperio_tx_fifo_size = val;
 }
 
 void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
@@ -429,7 +429,7 @@ void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
 			val);
 	}
 
-	hsotg->core_params->host_perio_tx_fifo_size = val;
+	hsotg->params.host_perio_tx_fifo_size = val;
 }
 
 void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
@@ -448,7 +448,7 @@ void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting max_transfer_size to %d\n", val);
 	}
 
-	hsotg->core_params->max_transfer_size = val;
+	hsotg->params.max_transfer_size = val;
 }
 
 void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
@@ -467,7 +467,7 @@ void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting max_packet_count to %d\n", val);
 	}
 
-	hsotg->core_params->max_packet_count = val;
+	hsotg->params.max_packet_count = val;
 }
 
 void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
@@ -486,7 +486,7 @@ void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting host_channels to %d\n", val);
 	}
 
-	hsotg->core_params->host_channels = val;
+	hsotg->params.host_channels = val;
 }
 
 void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
@@ -534,12 +534,12 @@ void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting phy_type to %d\n", val);
 	}
 
-	hsotg->core_params->phy_type = val;
+	hsotg->params.phy_type = val;
 }
 
 static int dwc2_get_param_phy_type(struct dwc2_hsotg *hsotg)
 {
-	return hsotg->core_params->phy_type;
+	return hsotg->params.phy_type;
 }
 
 void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
@@ -568,7 +568,7 @@ void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting speed to %d\n", val);
 	}
 
-	hsotg->core_params->speed = val;
+	hsotg->params.speed = val;
 }
 
 void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg, int val)
@@ -602,7 +602,7 @@ void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg, int val)
 			val);
 	}
 
-	hsotg->core_params->host_ls_low_power_phy_clk = val;
+	hsotg->params.host_ls_low_power_phy_clk = val;
 }
 
 void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
@@ -616,7 +616,7 @@ void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting phy_upli_ddr to %d\n", val);
 	}
 
-	hsotg->core_params->phy_ulpi_ddr = val;
+	hsotg->params.phy_ulpi_ddr = val;
 }
 
 void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
@@ -632,7 +632,7 @@ void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting phy_ulpi_ext_vbus to %d\n", val);
 	}
 
-	hsotg->core_params->phy_ulpi_ext_vbus = val;
+	hsotg->params.phy_ulpi_ext_vbus = val;
 }
 
 void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
@@ -662,7 +662,7 @@ void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting phy_utmi_width to %d\n", val);
 	}
 
-	hsotg->core_params->phy_utmi_width = val;
+	hsotg->params.phy_utmi_width = val;
 }
 
 void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
@@ -676,7 +676,7 @@ void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting ulpi_fs_ls to %d\n", val);
 	}
 
-	hsotg->core_params->ulpi_fs_ls = val;
+	hsotg->params.ulpi_fs_ls = val;
 }
 
 void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
@@ -690,7 +690,7 @@ void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting ts_dline to %d\n", val);
 	}
 
-	hsotg->core_params->ts_dline = val;
+	hsotg->params.ts_dline = val;
 }
 
 void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
@@ -718,7 +718,7 @@ void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting i2c_enable to %d\n", val);
 	}
 
-	hsotg->core_params->i2c_enable = val;
+	hsotg->params.i2c_enable = val;
 }
 
 void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg, int val)
@@ -747,7 +747,7 @@ void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting en_multiple_tx_fifo to %d\n", val);
 	}
 
-	hsotg->core_params->en_multiple_tx_fifo = val;
+	hsotg->params.en_multiple_tx_fifo = val;
 }
 
 void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
@@ -775,15 +775,15 @@ void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting reload_ctl to %d\n", val);
 	}
 
-	hsotg->core_params->reload_ctl = val;
+	hsotg->params.reload_ctl = val;
 }
 
 void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
 {
 	if (val != -1)
-		hsotg->core_params->ahbcfg = val;
+		hsotg->params.ahbcfg = val;
 	else
-		hsotg->core_params->ahbcfg = GAHBCFG_HBSTLEN_INCR4 <<
+		hsotg->params.ahbcfg = GAHBCFG_HBSTLEN_INCR4 <<
 						GAHBCFG_HBSTLEN_SHIFT;
 }
 
@@ -800,7 +800,7 @@ void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting otg_ver to %d\n", val);
 	}
 
-	hsotg->core_params->otg_ver = val;
+	hsotg->params.otg_ver = val;
 }
 
 static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg, int val)
@@ -816,7 +816,7 @@ static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg, int val)
 		dev_dbg(hsotg->dev, "Setting uframe_sched to %d\n", val);
 	}
 
-	hsotg->core_params->uframe_sched = val;
+	hsotg->params.uframe_sched = val;
 }
 
 static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg,
@@ -833,7 +833,7 @@ static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg,
 		dev_dbg(hsotg->dev, "Setting external_id_pin_ctl to %d\n", val);
 	}
 
-	hsotg->core_params->external_id_pin_ctl = val;
+	hsotg->params.external_id_pin_ctl = val;
 }
 
 static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
@@ -850,7 +850,7 @@ static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
 		dev_dbg(hsotg->dev, "Setting hibernation to %d\n", val);
 	}
 
-	hsotg->core_params->hibernation = val;
+	hsotg->params.hibernation = val;
 }
 
 /*

commit 323230ef4ef17512007c22898b008e9fb87b372e
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:50 2016 -0700

    usb: dwc2: Add params.c file
    
    Add a params.c file and move all driver parameter code there, including
    all the static parameter definitions.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
new file mode 100644
index 000000000000..66a827a25103
--- /dev/null
+++ b/drivers/usb/dwc2/params.c
@@ -0,0 +1,1125 @@
+/*
+ * Copyright (C) 2004-2016 Synopsys, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include "core.h"
+
+static const struct dwc2_core_params params_hi6220 = {
+	.otg_cap			= 2,	/* No HNP/SRP capable */
+	.otg_ver			= 0,	/* 1.3 */
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= 0,	/* High Speed */
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= 1,
+	.host_rx_fifo_size		= 512,
+	.host_nperio_tx_fifo_size	= 512,
+	.host_perio_tx_fifo_size	= 512,
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= 16,
+	.phy_type			= 1,	/* UTMI */
+	.phy_utmi_width			= 8,
+	.phy_ulpi_ddr			= 0,	/* Single */
+	.phy_ulpi_ext_vbus		= 0,
+	.i2c_enable			= 0,
+	.ulpi_fs_ls			= 0,
+	.host_support_fs_ls_low_power	= 0,
+	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
+	.ts_dline			= 0,
+	.reload_ctl			= 0,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
+static const struct dwc2_core_params params_bcm2835 = {
+	.otg_cap			= 0,	/* HNP/SRP capable */
+	.otg_ver			= 0,	/* 1.3 */
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= 0,	/* High Speed */
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= 1,
+	.host_rx_fifo_size		= 774,	/* 774 DWORDs */
+	.host_nperio_tx_fifo_size	= 256,	/* 256 DWORDs */
+	.host_perio_tx_fifo_size	= 512,	/* 512 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= 8,
+	.phy_type			= 1,	/* UTMI */
+	.phy_utmi_width			= 8,	/* 8 bits */
+	.phy_ulpi_ddr			= 0,	/* Single */
+	.phy_ulpi_ext_vbus		= 0,
+	.i2c_enable			= 0,
+	.ulpi_fs_ls			= 0,
+	.host_support_fs_ls_low_power	= 0,
+	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
+	.ts_dline			= 0,
+	.reload_ctl			= 0,
+	.ahbcfg				= 0x10,
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
+static const struct dwc2_core_params params_rk3066 = {
+	.otg_cap			= 2,	/* non-HNP/non-SRP */
+	.otg_ver			= -1,
+	.dma_enable			= -1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= -1,
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 525,	/* 525 DWORDs */
+	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
+	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
+	.max_transfer_size		= -1,
+	.max_packet_count		= -1,
+	.host_channels			= -1,
+	.phy_type			= -1,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= -1,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
+static const struct dwc2_core_params params_ltq = {
+	.otg_cap			= 2,	/* non-HNP/non-SRP */
+	.otg_ver			= -1,
+	.dma_enable			= -1,
+	.dma_desc_enable		= -1,
+	.dma_desc_fs_enable		= -1,
+	.speed				= -1,
+	.enable_dynamic_fifo		= -1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 288,	/* 288 DWORDs */
+	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
+	.host_perio_tx_fifo_size	= 96,	/* 96 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= -1,
+	.phy_type			= -1,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= -1,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
+static const struct dwc2_core_params params_amlogic = {
+	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
+	.otg_ver			= -1,
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= DWC2_SPEED_PARAM_HIGH,
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 512,
+	.host_nperio_tx_fifo_size	= 500,
+	.host_perio_tx_fifo_size	= 500,
+	.max_transfer_size		= -1,
+	.max_packet_count		= -1,
+	.host_channels			= 16,
+	.phy_type			= DWC2_PHY_TYPE_PARAM_UTMI,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= 1,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR8 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
+const struct of_device_id dwc2_of_match_table[] = {
+	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
+	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
+	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
+	{ .compatible = "lantiq,arx100-usb", .data = &params_ltq },
+	{ .compatible = "lantiq,xrx200-usb", .data = &params_ltq },
+	{ .compatible = "snps,dwc2", .data = NULL },
+	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
+	{ .compatible = "amlogic,meson8b-usb", .data = &params_amlogic },
+	{ .compatible = "amlogic,meson-gxbb-usb", .data = &params_amlogic },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
+
+#define DWC2_OUT_OF_BOUNDS(a, b, c)	((a) < (b) || (a) > (c))
+
+/* Parameter access functions */
+void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	switch (val) {
+	case DWC2_CAP_PARAM_HNP_SRP_CAPABLE:
+		if (hsotg->hw_params.op_mode != GHWCFG2_OP_MODE_HNP_SRP_CAPABLE)
+			valid = 0;
+		break;
+	case DWC2_CAP_PARAM_SRP_ONLY_CAPABLE:
+		switch (hsotg->hw_params.op_mode) {
+		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
+		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
+			break;
+		default:
+			valid = 0;
+			break;
+		}
+		break;
+	case DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE:
+		/* always valid */
+		break;
+	default:
+		valid = 0;
+		break;
+	}
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for otg_cap parameter. Check HW configuration.\n",
+				val);
+		switch (hsotg->hw_params.op_mode) {
+		case GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:
+			val = DWC2_CAP_PARAM_HNP_SRP_CAPABLE;
+			break;
+		case GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:
+		case GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:
+			val = DWC2_CAP_PARAM_SRP_ONLY_CAPABLE;
+			break;
+		default:
+			val = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
+			break;
+		}
+		dev_dbg(hsotg->dev, "Setting otg_cap to %d\n", val);
+	}
+
+	hsotg->core_params->otg_cap = val;
+}
+
+void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val > 0 && hsotg->hw_params.arch == GHWCFG2_SLAVE_ONLY_ARCH)
+		valid = 0;
+	if (val < 0)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for dma_enable parameter. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.arch != GHWCFG2_SLAVE_ONLY_ARCH;
+		dev_dbg(hsotg->dev, "Setting dma_enable to %d\n", val);
+	}
+
+	hsotg->core_params->dma_enable = val;
+}
+
+void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val > 0 && (hsotg->core_params->dma_enable <= 0 ||
+			!hsotg->hw_params.dma_desc_enable))
+		valid = 0;
+	if (val < 0)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for dma_desc_enable parameter. Check HW configuration.\n",
+				val);
+		val = (hsotg->core_params->dma_enable > 0 &&
+			hsotg->hw_params.dma_desc_enable);
+		dev_dbg(hsotg->dev, "Setting dma_desc_enable to %d\n", val);
+	}
+
+	hsotg->core_params->dma_desc_enable = val;
+}
+
+void dwc2_set_param_dma_desc_fs_enable(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val > 0 && (hsotg->core_params->dma_enable <= 0 ||
+			!hsotg->hw_params.dma_desc_enable))
+		valid = 0;
+	if (val < 0)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for dma_desc_fs_enable parameter. Check HW configuration.\n",
+				val);
+		val = (hsotg->core_params->dma_enable > 0 &&
+			hsotg->hw_params.dma_desc_enable);
+	}
+
+	hsotg->core_params->dma_desc_fs_enable = val;
+	dev_dbg(hsotg->dev, "Setting dma_desc_fs_enable to %d\n", val);
+}
+
+void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg,
+						 int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"Wrong value for host_support_fs_low_power\n");
+			dev_err(hsotg->dev,
+				"host_support_fs_low_power must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev,
+			"Setting host_support_fs_low_power to %d\n", val);
+	}
+
+	hsotg->core_params->host_support_fs_ls_low_power = val;
+}
+
+void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val > 0 && !hsotg->hw_params.enable_dynamic_fifo)
+		valid = 0;
+	if (val < 0)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for enable_dynamic_fifo parameter. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.enable_dynamic_fifo;
+		dev_dbg(hsotg->dev, "Setting enable_dynamic_fifo to %d\n", val);
+	}
+
+	hsotg->core_params->enable_dynamic_fifo = val;
+}
+
+void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 16 || val > hsotg->hw_params.host_rx_fifo_size)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for host_rx_fifo_size. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.host_rx_fifo_size;
+		dev_dbg(hsotg->dev, "Setting host_rx_fifo_size to %d\n", val);
+	}
+
+	hsotg->core_params->host_rx_fifo_size = val;
+}
+
+void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 16 || val > hsotg->hw_params.host_nperio_tx_fifo_size)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for host_nperio_tx_fifo_size. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.host_nperio_tx_fifo_size;
+		dev_dbg(hsotg->dev, "Setting host_nperio_tx_fifo_size to %d\n",
+			val);
+	}
+
+	hsotg->core_params->host_nperio_tx_fifo_size = val;
+}
+
+void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 16 || val > hsotg->hw_params.host_perio_tx_fifo_size)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for host_perio_tx_fifo_size. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.host_perio_tx_fifo_size;
+		dev_dbg(hsotg->dev, "Setting host_perio_tx_fifo_size to %d\n",
+			val);
+	}
+
+	hsotg->core_params->host_perio_tx_fifo_size = val;
+}
+
+void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 2047 || val > hsotg->hw_params.max_transfer_size)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for max_transfer_size. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.max_transfer_size;
+		dev_dbg(hsotg->dev, "Setting max_transfer_size to %d\n", val);
+	}
+
+	hsotg->core_params->max_transfer_size = val;
+}
+
+void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 15 || val > hsotg->hw_params.max_packet_count)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for max_packet_count. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.max_packet_count;
+		dev_dbg(hsotg->dev, "Setting max_packet_count to %d\n", val);
+	}
+
+	hsotg->core_params->max_packet_count = val;
+}
+
+void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (val < 1 || val > hsotg->hw_params.host_channels)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for host_channels. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.host_channels;
+		dev_dbg(hsotg->dev, "Setting host_channels to %d\n", val);
+	}
+
+	hsotg->core_params->host_channels = val;
+}
+
+void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 0;
+	u32 hs_phy_type, fs_phy_type;
+
+	if (DWC2_OUT_OF_BOUNDS(val, DWC2_PHY_TYPE_PARAM_FS,
+			       DWC2_PHY_TYPE_PARAM_ULPI)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for phy_type\n");
+			dev_err(hsotg->dev, "phy_type must be 0, 1 or 2\n");
+		}
+
+		valid = 0;
+	}
+
+	hs_phy_type = hsotg->hw_params.hs_phy_type;
+	fs_phy_type = hsotg->hw_params.fs_phy_type;
+	if (val == DWC2_PHY_TYPE_PARAM_UTMI &&
+	    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||
+	     hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
+		valid = 1;
+	else if (val == DWC2_PHY_TYPE_PARAM_ULPI &&
+		 (hs_phy_type == GHWCFG2_HS_PHY_TYPE_ULPI ||
+		  hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))
+		valid = 1;
+	else if (val == DWC2_PHY_TYPE_PARAM_FS &&
+		 fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED)
+		valid = 1;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for phy_type. Check HW configuration.\n",
+				val);
+		val = DWC2_PHY_TYPE_PARAM_FS;
+		if (hs_phy_type != GHWCFG2_HS_PHY_TYPE_NOT_SUPPORTED) {
+			if (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||
+			    hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI)
+				val = DWC2_PHY_TYPE_PARAM_UTMI;
+			else
+				val = DWC2_PHY_TYPE_PARAM_ULPI;
+		}
+		dev_dbg(hsotg->dev, "Setting phy_type to %d\n", val);
+	}
+
+	hsotg->core_params->phy_type = val;
+}
+
+static int dwc2_get_param_phy_type(struct dwc2_hsotg *hsotg)
+{
+	return hsotg->core_params->phy_type;
+}
+
+void dwc2_set_param_speed(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for speed parameter\n");
+			dev_err(hsotg->dev, "max_speed parameter must be 0 or 1\n");
+		}
+		valid = 0;
+	}
+
+	if (val == DWC2_SPEED_PARAM_HIGH &&
+	    dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for speed parameter. Check HW configuration.\n",
+				val);
+		val = dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS ?
+				DWC2_SPEED_PARAM_FULL : DWC2_SPEED_PARAM_HIGH;
+		dev_dbg(hsotg->dev, "Setting speed to %d\n", val);
+	}
+
+	hsotg->core_params->speed = val;
+}
+
+void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (DWC2_OUT_OF_BOUNDS(val, DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ,
+			       DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"Wrong value for host_ls_low_power_phy_clk parameter\n");
+			dev_err(hsotg->dev,
+				"host_ls_low_power_phy_clk must be 0 or 1\n");
+		}
+		valid = 0;
+	}
+
+	if (val == DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ &&
+	    dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for host_ls_low_power_phy_clk. Check HW configuration.\n",
+				val);
+		val = dwc2_get_param_phy_type(hsotg) == DWC2_PHY_TYPE_PARAM_FS
+			? DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ
+			: DWC2_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ;
+		dev_dbg(hsotg->dev, "Setting host_ls_low_power_phy_clk to %d\n",
+			val);
+	}
+
+	hsotg->core_params->host_ls_low_power_phy_clk = val;
+}
+
+void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for phy_ulpi_ddr\n");
+			dev_err(hsotg->dev, "phy_upli_ddr must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting phy_upli_ddr to %d\n", val);
+	}
+
+	hsotg->core_params->phy_ulpi_ddr = val;
+}
+
+void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"Wrong value for phy_ulpi_ext_vbus\n");
+			dev_err(hsotg->dev,
+				"phy_ulpi_ext_vbus must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting phy_ulpi_ext_vbus to %d\n", val);
+	}
+
+	hsotg->core_params->phy_ulpi_ext_vbus = val;
+}
+
+void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 0;
+
+	switch (hsotg->hw_params.utmi_phy_data_width) {
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8:
+		valid = (val == 8);
+		break;
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_16:
+		valid = (val == 16);
+		break;
+	case GHWCFG4_UTMI_PHY_DATA_WIDTH_8_OR_16:
+		valid = (val == 8 || val == 16);
+		break;
+	}
+
+	if (!valid) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"%d invalid for phy_utmi_width. Check HW configuration.\n",
+				val);
+		}
+		val = (hsotg->hw_params.utmi_phy_data_width ==
+		       GHWCFG4_UTMI_PHY_DATA_WIDTH_8) ? 8 : 16;
+		dev_dbg(hsotg->dev, "Setting phy_utmi_width to %d\n", val);
+	}
+
+	hsotg->core_params->phy_utmi_width = val;
+}
+
+void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for ulpi_fs_ls\n");
+			dev_err(hsotg->dev, "ulpi_fs_ls must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting ulpi_fs_ls to %d\n", val);
+	}
+
+	hsotg->core_params->ulpi_fs_ls = val;
+}
+
+void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for ts_dline\n");
+			dev_err(hsotg->dev, "ts_dline must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting ts_dline to %d\n", val);
+	}
+
+	hsotg->core_params->ts_dline = val;
+}
+
+void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev, "Wrong value for i2c_enable\n");
+			dev_err(hsotg->dev, "i2c_enable must be 0 or 1\n");
+		}
+
+		valid = 0;
+	}
+
+	if (val == 1 && !(hsotg->hw_params.i2c_enable))
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for i2c_enable. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.i2c_enable;
+		dev_dbg(hsotg->dev, "Setting i2c_enable to %d\n", val);
+	}
+
+	hsotg->core_params->i2c_enable = val;
+}
+
+void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"Wrong value for en_multiple_tx_fifo,\n");
+			dev_err(hsotg->dev,
+				"en_multiple_tx_fifo must be 0 or 1\n");
+		}
+		valid = 0;
+	}
+
+	if (val == 1 && !hsotg->hw_params.en_multiple_tx_fifo)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for parameter en_multiple_tx_fifo. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.en_multiple_tx_fifo;
+		dev_dbg(hsotg->dev, "Setting en_multiple_tx_fifo to %d\n", val);
+	}
+
+	hsotg->core_params->en_multiple_tx_fifo = val;
+}
+
+void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg, int val)
+{
+	int valid = 1;
+
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter reload_ctl\n", val);
+			dev_err(hsotg->dev, "reload_ctl must be 0 or 1\n");
+		}
+		valid = 0;
+	}
+
+	if (val == 1 && hsotg->hw_params.snpsid < DWC2_CORE_REV_2_92a)
+		valid = 0;
+
+	if (!valid) {
+		if (val >= 0)
+			dev_err(hsotg->dev,
+				"%d invalid for parameter reload_ctl. Check HW configuration.\n",
+				val);
+		val = hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_92a;
+		dev_dbg(hsotg->dev, "Setting reload_ctl to %d\n", val);
+	}
+
+	hsotg->core_params->reload_ctl = val;
+}
+
+void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg, int val)
+{
+	if (val != -1)
+		hsotg->core_params->ahbcfg = val;
+	else
+		hsotg->core_params->ahbcfg = GAHBCFG_HBSTLEN_INCR4 <<
+						GAHBCFG_HBSTLEN_SHIFT;
+}
+
+void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter otg_ver\n", val);
+			dev_err(hsotg->dev,
+				"otg_ver must be 0 (for OTG 1.3 support) or 1 (for OTG 2.0 support)\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting otg_ver to %d\n", val);
+	}
+
+	hsotg->core_params->otg_ver = val;
+}
+
+static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg, int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter uframe_sched\n",
+				val);
+			dev_err(hsotg->dev, "uframe_sched must be 0 or 1\n");
+		}
+		val = 1;
+		dev_dbg(hsotg->dev, "Setting uframe_sched to %d\n", val);
+	}
+
+	hsotg->core_params->uframe_sched = val;
+}
+
+static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg,
+					       int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter external_id_pin_ctl\n",
+				val);
+			dev_err(hsotg->dev, "external_id_pin_ctl must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting external_id_pin_ctl to %d\n", val);
+	}
+
+	hsotg->core_params->external_id_pin_ctl = val;
+}
+
+static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg,
+				       int val)
+{
+	if (DWC2_OUT_OF_BOUNDS(val, 0, 1)) {
+		if (val >= 0) {
+			dev_err(hsotg->dev,
+				"'%d' invalid for parameter hibernation\n",
+				val);
+			dev_err(hsotg->dev, "hibernation must be 0 or 1\n");
+		}
+		val = 0;
+		dev_dbg(hsotg->dev, "Setting hibernation to %d\n", val);
+	}
+
+	hsotg->core_params->hibernation = val;
+}
+
+/*
+ * This function is called during module intialization to pass module parameters
+ * for the DWC_otg core.
+ */
+void dwc2_set_parameters(struct dwc2_hsotg *hsotg,
+			 const struct dwc2_core_params *params)
+{
+	dev_dbg(hsotg->dev, "%s()\n", __func__);
+
+	dwc2_set_param_otg_cap(hsotg, params->otg_cap);
+	dwc2_set_param_dma_enable(hsotg, params->dma_enable);
+	dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
+	dwc2_set_param_dma_desc_fs_enable(hsotg, params->dma_desc_fs_enable);
+	dwc2_set_param_host_support_fs_ls_low_power(hsotg,
+			params->host_support_fs_ls_low_power);
+	dwc2_set_param_enable_dynamic_fifo(hsotg,
+			params->enable_dynamic_fifo);
+	dwc2_set_param_host_rx_fifo_size(hsotg,
+			params->host_rx_fifo_size);
+	dwc2_set_param_host_nperio_tx_fifo_size(hsotg,
+			params->host_nperio_tx_fifo_size);
+	dwc2_set_param_host_perio_tx_fifo_size(hsotg,
+			params->host_perio_tx_fifo_size);
+	dwc2_set_param_max_transfer_size(hsotg,
+			params->max_transfer_size);
+	dwc2_set_param_max_packet_count(hsotg,
+			params->max_packet_count);
+	dwc2_set_param_host_channels(hsotg, params->host_channels);
+	dwc2_set_param_phy_type(hsotg, params->phy_type);
+	dwc2_set_param_speed(hsotg, params->speed);
+	dwc2_set_param_host_ls_low_power_phy_clk(hsotg,
+			params->host_ls_low_power_phy_clk);
+	dwc2_set_param_phy_ulpi_ddr(hsotg, params->phy_ulpi_ddr);
+	dwc2_set_param_phy_ulpi_ext_vbus(hsotg,
+			params->phy_ulpi_ext_vbus);
+	dwc2_set_param_phy_utmi_width(hsotg, params->phy_utmi_width);
+	dwc2_set_param_ulpi_fs_ls(hsotg, params->ulpi_fs_ls);
+	dwc2_set_param_ts_dline(hsotg, params->ts_dline);
+	dwc2_set_param_i2c_enable(hsotg, params->i2c_enable);
+	dwc2_set_param_en_multiple_tx_fifo(hsotg,
+			params->en_multiple_tx_fifo);
+	dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
+	dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
+	dwc2_set_param_otg_ver(hsotg, params->otg_ver);
+	dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
+	dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
+	dwc2_set_param_hibernation(hsotg, params->hibernation);
+}
+
+/*
+ * Gets host hardware parameters. Forces host mode if not currently in
+ * host mode. Should be called immediately after a core soft reset in
+ * order to get the reset values.
+ */
+static void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	u32 gnptxfsiz;
+	u32 hptxfsiz;
+	bool forced;
+
+	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
+		return;
+
+	forced = dwc2_force_mode_if_needed(hsotg, true);
+
+	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
+	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
+	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
+	dev_dbg(hsotg->dev, "hptxfsiz=%08x\n", hptxfsiz);
+
+	if (forced)
+		dwc2_clear_force_mode(hsotg);
+
+	hw->host_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>
+				       FIFOSIZE_DEPTH_SHIFT;
+	hw->host_perio_tx_fifo_size = (hptxfsiz & FIFOSIZE_DEPTH_MASK) >>
+				      FIFOSIZE_DEPTH_SHIFT;
+}
+
+/*
+ * Gets device hardware parameters. Forces device mode if not
+ * currently in device mode. Should be called immediately after a core
+ * soft reset in order to get the reset values.
+ */
+static void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	bool forced;
+	u32 gnptxfsiz;
+
+	if (hsotg->dr_mode == USB_DR_MODE_HOST)
+		return;
+
+	forced = dwc2_force_mode_if_needed(hsotg, false);
+
+	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
+	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
+
+	if (forced)
+		dwc2_clear_force_mode(hsotg);
+
+	hw->dev_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>
+				       FIFOSIZE_DEPTH_SHIFT;
+}
+
+/**
+ * During device initialization, read various hardware configuration
+ * registers and interpret the contents.
+ */
+int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+	unsigned int width;
+	u32 hwcfg1, hwcfg2, hwcfg3, hwcfg4;
+	u32 grxfsiz;
+
+	/*
+	 * Attempt to ensure this device is really a DWC_otg Controller.
+	 * Read and verify the GSNPSID register contents. The value should be
+	 * 0x45f42xxx or 0x45f43xxx, which corresponds to either "OT2" or "OT3",
+	 * as in "OTG version 2.xx" or "OTG version 3.xx".
+	 */
+	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
+	if ((hw->snpsid & 0xfffff000) != 0x4f542000 &&
+	    (hw->snpsid & 0xfffff000) != 0x4f543000) {
+		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
+			hw->snpsid);
+		return -ENODEV;
+	}
+
+	dev_dbg(hsotg->dev, "Core Release: %1x.%1x%1x%1x (snpsid=%x)\n",
+		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
+		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
+
+	hwcfg1 = dwc2_readl(hsotg->regs + GHWCFG1);
+	hwcfg2 = dwc2_readl(hsotg->regs + GHWCFG2);
+	hwcfg3 = dwc2_readl(hsotg->regs + GHWCFG3);
+	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
+	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
+
+	dev_dbg(hsotg->dev, "hwcfg1=%08x\n", hwcfg1);
+	dev_dbg(hsotg->dev, "hwcfg2=%08x\n", hwcfg2);
+	dev_dbg(hsotg->dev, "hwcfg3=%08x\n", hwcfg3);
+	dev_dbg(hsotg->dev, "hwcfg4=%08x\n", hwcfg4);
+	dev_dbg(hsotg->dev, "grxfsiz=%08x\n", grxfsiz);
+
+	/*
+	 * Host specific hardware parameters. Reading these parameters
+	 * requires the controller to be in host mode. The mode will
+	 * be forced, if necessary, to read these values.
+	 */
+	dwc2_get_host_hwparams(hsotg);
+	dwc2_get_dev_hwparams(hsotg);
+
+	/* hwcfg1 */
+	hw->dev_ep_dirs = hwcfg1;
+
+	/* hwcfg2 */
+	hw->op_mode = (hwcfg2 & GHWCFG2_OP_MODE_MASK) >>
+		      GHWCFG2_OP_MODE_SHIFT;
+	hw->arch = (hwcfg2 & GHWCFG2_ARCHITECTURE_MASK) >>
+		   GHWCFG2_ARCHITECTURE_SHIFT;
+	hw->enable_dynamic_fifo = !!(hwcfg2 & GHWCFG2_DYNAMIC_FIFO);
+	hw->host_channels = 1 + ((hwcfg2 & GHWCFG2_NUM_HOST_CHAN_MASK) >>
+				GHWCFG2_NUM_HOST_CHAN_SHIFT);
+	hw->hs_phy_type = (hwcfg2 & GHWCFG2_HS_PHY_TYPE_MASK) >>
+			  GHWCFG2_HS_PHY_TYPE_SHIFT;
+	hw->fs_phy_type = (hwcfg2 & GHWCFG2_FS_PHY_TYPE_MASK) >>
+			  GHWCFG2_FS_PHY_TYPE_SHIFT;
+	hw->num_dev_ep = (hwcfg2 & GHWCFG2_NUM_DEV_EP_MASK) >>
+			 GHWCFG2_NUM_DEV_EP_SHIFT;
+	hw->nperio_tx_q_depth =
+		(hwcfg2 & GHWCFG2_NONPERIO_TX_Q_DEPTH_MASK) >>
+		GHWCFG2_NONPERIO_TX_Q_DEPTH_SHIFT << 1;
+	hw->host_perio_tx_q_depth =
+		(hwcfg2 & GHWCFG2_HOST_PERIO_TX_Q_DEPTH_MASK) >>
+		GHWCFG2_HOST_PERIO_TX_Q_DEPTH_SHIFT << 1;
+	hw->dev_token_q_depth =
+		(hwcfg2 & GHWCFG2_DEV_TOKEN_Q_DEPTH_MASK) >>
+		GHWCFG2_DEV_TOKEN_Q_DEPTH_SHIFT;
+
+	/* hwcfg3 */
+	width = (hwcfg3 & GHWCFG3_XFER_SIZE_CNTR_WIDTH_MASK) >>
+		GHWCFG3_XFER_SIZE_CNTR_WIDTH_SHIFT;
+	hw->max_transfer_size = (1 << (width + 11)) - 1;
+	width = (hwcfg3 & GHWCFG3_PACKET_SIZE_CNTR_WIDTH_MASK) >>
+		GHWCFG3_PACKET_SIZE_CNTR_WIDTH_SHIFT;
+	hw->max_packet_count = (1 << (width + 4)) - 1;
+	hw->i2c_enable = !!(hwcfg3 & GHWCFG3_I2C);
+	hw->total_fifo_size = (hwcfg3 & GHWCFG3_DFIFO_DEPTH_MASK) >>
+			      GHWCFG3_DFIFO_DEPTH_SHIFT;
+
+	/* hwcfg4 */
+	hw->en_multiple_tx_fifo = !!(hwcfg4 & GHWCFG4_DED_FIFO_EN);
+	hw->num_dev_perio_in_ep = (hwcfg4 & GHWCFG4_NUM_DEV_PERIO_IN_EP_MASK) >>
+				  GHWCFG4_NUM_DEV_PERIO_IN_EP_SHIFT;
+	hw->dma_desc_enable = !!(hwcfg4 & GHWCFG4_DESC_DMA);
+	hw->power_optimized = !!(hwcfg4 & GHWCFG4_POWER_OPTIMIZ);
+	hw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>
+				  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;
+
+	/* fifo sizes */
+	hw->host_rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>
+				GRXFSIZ_DEPTH_SHIFT;
+
+	dev_dbg(hsotg->dev, "Detected values from hardware:\n");
+	dev_dbg(hsotg->dev, "  op_mode=%d\n",
+		hw->op_mode);
+	dev_dbg(hsotg->dev, "  arch=%d\n",
+		hw->arch);
+	dev_dbg(hsotg->dev, "  dma_desc_enable=%d\n",
+		hw->dma_desc_enable);
+	dev_dbg(hsotg->dev, "  power_optimized=%d\n",
+		hw->power_optimized);
+	dev_dbg(hsotg->dev, "  i2c_enable=%d\n",
+		hw->i2c_enable);
+	dev_dbg(hsotg->dev, "  hs_phy_type=%d\n",
+		hw->hs_phy_type);
+	dev_dbg(hsotg->dev, "  fs_phy_type=%d\n",
+		hw->fs_phy_type);
+	dev_dbg(hsotg->dev, "  utmi_phy_data_width=%d\n",
+		hw->utmi_phy_data_width);
+	dev_dbg(hsotg->dev, "  num_dev_ep=%d\n",
+		hw->num_dev_ep);
+	dev_dbg(hsotg->dev, "  num_dev_perio_in_ep=%d\n",
+		hw->num_dev_perio_in_ep);
+	dev_dbg(hsotg->dev, "  host_channels=%d\n",
+		hw->host_channels);
+	dev_dbg(hsotg->dev, "  max_transfer_size=%d\n",
+		hw->max_transfer_size);
+	dev_dbg(hsotg->dev, "  max_packet_count=%d\n",
+		hw->max_packet_count);
+	dev_dbg(hsotg->dev, "  nperio_tx_q_depth=0x%0x\n",
+		hw->nperio_tx_q_depth);
+	dev_dbg(hsotg->dev, "  host_perio_tx_q_depth=0x%0x\n",
+		hw->host_perio_tx_q_depth);
+	dev_dbg(hsotg->dev, "  dev_token_q_depth=0x%0x\n",
+		hw->dev_token_q_depth);
+	dev_dbg(hsotg->dev, "  enable_dynamic_fifo=%d\n",
+		hw->enable_dynamic_fifo);
+	dev_dbg(hsotg->dev, "  en_multiple_tx_fifo=%d\n",
+		hw->en_multiple_tx_fifo);
+	dev_dbg(hsotg->dev, "  total_fifo_size=%d\n",
+		hw->total_fifo_size);
+	dev_dbg(hsotg->dev, "  host_rx_fifo_size=%d\n",
+		hw->host_rx_fifo_size);
+	dev_dbg(hsotg->dev, "  host_nperio_tx_fifo_size=%d\n",
+		hw->host_nperio_tx_fifo_size);
+	dev_dbg(hsotg->dev, "  host_perio_tx_fifo_size=%d\n",
+		hw->host_perio_tx_fifo_size);
+	dev_dbg(hsotg->dev, "\n");
+
+	return 0;
+}
+
+/*
+ * Sets all parameters to the given value.
+ *
+ * Assumes that the dwc2_core_params struct contains only integers.
+ */
+void dwc2_set_all_params(struct dwc2_core_params *params, int value)
+{
+	int *p = (int *)params;
+	size_t size = sizeof(*params) / sizeof(*p);
+	int i;
+
+	for (i = 0; i < size; i++)
+		p[i] = value;
+}
