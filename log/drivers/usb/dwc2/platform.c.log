commit 4fdf228cdf6925af45a2066d403821e0977bfddb
Author: Minas Harutyunyan <Minas.Harutyunyan@synopsys.com>
Date:   Sat May 30 11:41:50 2020 +0400

    usb: dwc2: Fix shutdown callback in platform
    
    To avoid lot of interrupts from dwc2 core, which can be asserted in
    specific conditions need to disable interrupts on HW level instead of
    disable IRQs on Kernel level, because of IRQ can be shared between
    drivers.
    
    Cc: stable@vger.kernel.org
    Fixes: a40a00318c7fc ("usb: dwc2: add shutdown callback to platform variant")
    Tested-by: Frank Mori Hess <fmh6jj@gmail.com>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Frank Mori Hess <fmh6jj@gmail.com>
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index c347d93eae64..cb8ddbd53718 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -342,7 +342,8 @@ static void dwc2_driver_shutdown(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
-	disable_irq(hsotg->irq);
+	dwc2_disable_global_interrupts(hsotg);
+	synchronize_irq(hsotg->irq);
 }
 
 /**

commit 207324a321a866401b098cadf19e4a2dd6584622
Author: Minas Harutyunyan <Minas.Harutyunyan@synopsys.com>
Date:   Tue Jun 9 12:28:11 2020 +0400

    usb: dwc2: Postponed gadget registration to the udc class driver
    
    During dwc2 driver probe, after gadget registration to the udc class
    driver, if exist any builtin function driver it immediately bound to
    dwc2 and after init host side (dwc2_hcd_init()) stucked in host mode.
    Patch postpone gadget registration after host side initialization done.
    
    Fixes: 117777b2c3bb9 ("usb: dwc2: Move gadget probe function into platform code")
    Reported-by: kbuild test robot <lkp@intel.com>
    Tested-by: Marek Vasut <marex@denx.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Link: https://lore.kernel.org/r/f21cb38fecc72a230b86155d94c7e60c9cb66f58.1591690938.git.hminas@synopsys.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index e571c8ae65ec..c347d93eae64 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -575,6 +575,17 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
 		dwc2_lowlevel_hw_disable(hsotg);
 
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+	/* Postponed adding a new gadget to the udc class driver list */
+	if (hsotg->gadget_enabled) {
+		retval = usb_add_gadget_udc(hsotg->dev, &hsotg->gadget);
+		if (retval) {
+			dwc2_hsotg_remove(hsotg);
+			goto error_init;
+		}
+	}
+#endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
 	return 0;
 
 error_init:

commit 65dc2e725286106f99c6f6b78e3d9c52c15f3a9c
Author: Minas Harutyunyan <Minas.Harutyunyan@synopsys.com>
Date:   Thu May 21 10:05:44 2020 +0400

    usb: dwc2: Update Core Reset programming flow.
    
    Starting from core version 4.20a Core Reset flow is changed.
    Introduced new bit in GRSTCTL register - GRSTCTL_CSFTRST_DONE.
    Core Reset new programming flow steps are follow:
    1. Set GRSTCTL_CSFTRST bit.
    2. Wait for bit GRSTCTL_CSFTRST_DONE is set.
    3. Clear GRSTCTL_CSFTRST and GRSTCTL_CSFTRST_DONE bits.
    
    Check core version functionality separated from dwc2_get_hwparams() to
    new dwc2_check_core_version() function because Core Reset flow depend
    on SNPSID.
    
    Signed-off-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 69972750e161..e571c8ae65ec 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -362,6 +362,37 @@ static bool dwc2_check_core_endianness(struct dwc2_hsotg *hsotg)
 	return true;
 }
 
+/**
+ * Check core version
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ */
+int dwc2_check_core_version(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_hw_params *hw = &hsotg->hw_params;
+
+	/*
+	 * Attempt to ensure this device is really a DWC_otg Controller.
+	 * Read and verify the GSNPSID register contents. The value should be
+	 * 0x45f4xxxx, 0x5531xxxx or 0x5532xxxx
+	 */
+
+	hw->snpsid = dwc2_readl(hsotg, GSNPSID);
+	if ((hw->snpsid & GSNPSID_ID_MASK) != DWC2_OTG_ID &&
+	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_FS_IOT_ID &&
+	    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_HS_IOT_ID) {
+		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
+			hw->snpsid);
+		return -ENODEV;
+	}
+
+	dev_dbg(hsotg->dev, "Core Release: %1x.%1x%1x%1x (snpsid=%x)\n",
+		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
+		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
+	return 0;
+}
+
 /**
  * dwc2_driver_probe() - Called when the DWC_otg core is bound to the DWC_otg
  * driver
@@ -444,6 +475,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		of_property_read_bool(dev->dev.of_node,
 				      "snps,need-phy-for-wake");
 
+	/*
+	 * Before performing any core related operations
+	 * check core version.
+	 */
+	retval = dwc2_check_core_version(hsotg);
+	if (retval)
+		goto error;
+
 	/*
 	 * Reset before dwc2_get_hwparams() then it could get power-on real
 	 * reset value form registers.

commit 5bf7e2883f1242d056538af4500d4ff81542a48b
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Tue Mar 24 00:06:11 2020 +0800

    usb: dwc2: convert to devm_platform_get_and_ioremap_resource
    
    Use devm_platform_get_and_ioremap_resource() to simplify code, which
    contains platform_get_resource() and devm_ioremap_resource(), it also
    get the resource for use by the following code.
    
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Link: https://lore.kernel.org/r/20200323160612.17277-5-zhengdejin5@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 8ea4a24637fa..69972750e161 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -397,8 +397,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		return retval;
 	}
 
-	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	hsotg->regs = devm_ioremap_resource(&dev->dev, res);
+	hsotg->regs = devm_platform_get_and_ioremap_resource(dev, 0, &res);
 	if (IS_ERR(hsotg->regs))
 		return PTR_ERR(hsotg->regs);
 

commit 8e11a977c8eb02aa06604b11cfb4e43eb8287537
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Feb 28 10:25:57 2020 +0100

    usb: dwc2: Silence warning about supplies during deferred probe
    
    Don't confuse user with meaningless warning about the failure in getting
    supplies in case of deferred probe.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 8368d6d66d64..8ea4a24637fa 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -285,7 +285,9 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	ret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),
 				      hsotg->supplies);
 	if (ret) {
-		dev_err(hsotg->dev, "failed to request supplies: %d\n", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(hsotg->dev, "failed to request supplies: %d\n",
+				ret);
 		return ret;
 	}
 	return 0;

commit a415083a11cc76f85322406fb91e2eb917c6cef9
Author: Amelie Delaunay <amelie.delaunay@st.com>
Date:   Fri Jan 24 09:41:31 2020 +0100

    usb: dwc2: add support for STM32MP15 SoCs USB OTG HS and FS
    
    This patch introduces a new parameter to activate external ID pin and valid
    vbus level detection, required on STM32MP15 SoC to support dual role,
    either in HS or FS.
    The STM32MP15 SoC uses the GGPIO register to enable the level detection.
    The level detector requires to be powered.
    Also adds the params structures for STM32MP15 OTG HS and STM32MP1 OTG FS.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3c6ce09a6db5..8368d6d66d64 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -312,6 +312,9 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->gadget_enabled)
 		dwc2_hsotg_remove(hsotg);
 
+	if (hsotg->params.activate_stm_id_vb_detection)
+		regulator_disable(hsotg->usb33d);
+
 	if (hsotg->ll_hw_enabled)
 		dwc2_lowlevel_hw_disable(hsotg);
 
@@ -464,10 +467,35 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		goto error;
 
+	if (hsotg->params.activate_stm_id_vb_detection) {
+		u32 ggpio;
+
+		hsotg->usb33d = devm_regulator_get(hsotg->dev, "usb33d");
+		if (IS_ERR(hsotg->usb33d)) {
+			retval = PTR_ERR(hsotg->usb33d);
+			if (retval != -EPROBE_DEFER)
+				dev_err(hsotg->dev,
+					"failed to request usb33d supply: %d\n",
+					retval);
+			goto error;
+		}
+		retval = regulator_enable(hsotg->usb33d);
+		if (retval) {
+			dev_err(hsotg->dev,
+				"failed to enable usb33d supply: %d\n", retval);
+			goto error;
+		}
+
+		ggpio = dwc2_readl(hsotg, GGPIO);
+		ggpio |= GGPIO_STM32_OTG_GCCFG_IDEN;
+		ggpio |= GGPIO_STM32_OTG_GCCFG_VBDEN;
+		dwc2_writel(hsotg, ggpio, GGPIO);
+	}
+
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg);
 		if (retval)
-			goto error;
+			goto error_init;
 		hsotg->gadget_enabled = 1;
 	}
 
@@ -493,7 +521,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		if (retval) {
 			if (hsotg->gadget_enabled)
 				dwc2_hsotg_remove(hsotg);
-			goto error;
+			goto error_init;
 		}
 		hsotg->hcd_enabled = 1;
 	}
@@ -509,6 +537,9 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	return 0;
 
+error_init:
+	if (hsotg->params.activate_stm_id_vb_detection)
+		regulator_disable(hsotg->usb33d);
 error:
 	dwc2_lowlevel_hw_disable(hsotg);
 	return retval;
@@ -523,6 +554,37 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	if (is_device_mode)
 		dwc2_hsotg_suspend(dwc2);
 
+	if (dwc2->params.activate_stm_id_vb_detection) {
+		unsigned long flags;
+		u32 ggpio, gotgctl;
+
+		/*
+		 * Need to force the mode to the current mode to avoid Mode
+		 * Mismatch Interrupt when ID detection will be disabled.
+		 */
+		dwc2_force_mode(dwc2, !is_device_mode);
+
+		spin_lock_irqsave(&dwc2->lock, flags);
+		gotgctl = dwc2_readl(dwc2, GOTGCTL);
+		/* bypass debounce filter, enable overrides */
+		gotgctl |= GOTGCTL_DBNCE_FLTR_BYPASS;
+		gotgctl |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN;
+		/* Force A / B session if needed */
+		if (gotgctl & GOTGCTL_ASESVLD)
+			gotgctl |= GOTGCTL_AVALOVAL;
+		if (gotgctl & GOTGCTL_BSESVLD)
+			gotgctl |= GOTGCTL_BVALOVAL;
+		dwc2_writel(dwc2, gotgctl, GOTGCTL);
+		spin_unlock_irqrestore(&dwc2->lock, flags);
+
+		ggpio = dwc2_readl(dwc2, GGPIO);
+		ggpio &= ~GGPIO_STM32_OTG_GCCFG_IDEN;
+		ggpio &= ~GGPIO_STM32_OTG_GCCFG_VBDEN;
+		dwc2_writel(dwc2, ggpio, GGPIO);
+
+		regulator_disable(dwc2->usb33d);
+	}
+
 	if (dwc2->ll_hw_enabled &&
 	    (is_device_mode || dwc2_host_can_poweroff_phy(dwc2))) {
 		ret = __dwc2_lowlevel_hw_disable(dwc2);
@@ -544,6 +606,34 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	}
 	dwc2->phy_off_for_suspend = false;
 
+	if (dwc2->params.activate_stm_id_vb_detection) {
+		unsigned long flags;
+		u32 ggpio, gotgctl;
+
+		ret = regulator_enable(dwc2->usb33d);
+		if (ret)
+			return ret;
+
+		ggpio = dwc2_readl(dwc2, GGPIO);
+		ggpio |= GGPIO_STM32_OTG_GCCFG_IDEN;
+		ggpio |= GGPIO_STM32_OTG_GCCFG_VBDEN;
+		dwc2_writel(dwc2, ggpio, GGPIO);
+
+		/* ID/VBUS detection startup time */
+		usleep_range(5000, 7000);
+
+		spin_lock_irqsave(&dwc2->lock, flags);
+		gotgctl = dwc2_readl(dwc2, GOTGCTL);
+		gotgctl &= ~GOTGCTL_DBNCE_FLTR_BYPASS;
+		gotgctl &= ~(GOTGCTL_BVALOEN | GOTGCTL_AVALOEN |
+			     GOTGCTL_BVALOVAL | GOTGCTL_AVALOVAL);
+		dwc2_writel(dwc2, gotgctl, GOTGCTL);
+		spin_unlock_irqrestore(&dwc2->lock, flags);
+	}
+
+	/* Need to restore FORCEDEVMODE/FORCEHOSTMODE */
+	dwc2_force_dr_mode(dwc2);
+
 	if (dwc2_is_device_mode(dwc2))
 		ret = dwc2_hsotg_resume(dwc2);
 

commit b33f37064b743d4c5771d3bfc65976790b7396cc
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:46 2019 -0700

    usb: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-47-swboyd@chromium.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 80fd3c6dcd1c..3c6ce09a6db5 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -407,10 +407,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	spin_lock_init(&hsotg->lock);
 
 	hsotg->irq = platform_get_irq(dev, 0);
-	if (hsotg->irq < 0) {
-		dev_err(&dev->dev, "missing IRQ resource\n");
+	if (hsotg->irq < 0)
 		return hsotg->irq;
-	}
 
 	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
 		hsotg->irq);

commit f254e65ad694a9189163f5a60707a06225f5db25
Merge: 426d3ff2f5ab aa23ce847dda
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 12:01:33 2019 +0200

    Merge tag 'usb-for-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: changes for v5.3 merge window
    
    The biggest part here is a set of patches removing unnecesary variables
    from several drivers.
    
    Meson-g12a's dwc3 glue implemented IRQ-based OTG/DRD role swap.
    
    Qcom's dwc3 glue added support for ACPI, mainly for the AArch64-based
    SoCs.
    
    DWC3 also got support for Intel Elkhart Lake platforms.
    
    * tag 'usb-for-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (30 commits)
      usb: dwc3: remove unused @lock member of dwc3_ep struct
      usb: dwc3: pci: Add Support for Intel Elkhart Lake Devices
      usb: Replace snprintf with scnprintf in gether_get_ifname
      usb: gadget: ether: Fix race between gether_disconnect and rx_submit
      usb: gadget: storage: Remove warning message
      usb: dwc3: gadget: Add support for disabling U1 and U2 entries
      usb: gadget: send usb_gadget as an argument in get_config_params
      doc: dt: bindings: usb: dwc3: Update entries for disabling U1 and U2
      usb: dwc3: qcom: Use of_clk_get_parent_count()
      usb: dwc3: Fix core validation in probe, move after clocks are enabled
      usb: dwc3: qcom: Improve error handling
      usb: dwc3: qcom: Start USB in 'host mode' on the SDM845
      usb: dwc3: qcom: Add support for booting with ACPI
      soc: qcom: geni: Add support for ACPI
      Revert "usb: dwc2: host: Setting qtd to NULL after freeing it"
      usb: gadget: net2272: remove redundant assignments to pointer 's'
      usb: gadget: Zero ffs_io_data
      USB: omap_udc: Remove unneeded variable
      fotg210-udc: Remove unneeded variable
      usb: gadget: at91_udc: Remove unneeded variable
      ...

commit c846b03ff767149d75d4d8dca6d3d4945a21074a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon May 20 10:56:04 2019 -0700

    USB: dwc2: Don't turn off the usbphy in suspend if wakeup is enabled
    
    If the 'snps,need-phy-for-wake' is set in the device tree then:
    
    - We know that we can wakeup, so call device_set_wakeup_capable().
      The USB core will use this knowledge to enable wakeup by default.
    - We know that we should keep the PHY on during suspend if something
      on our root hub needs remote wakeup.  This requires the patch (USB:
      Export usb_wakeup_enabled_descendants()).  Note that we don't keep
      the PHY on at suspend time if it's not needed because it would be a
      power draw.
    
    If we later find some users of dwc2 that can support wakeup without
    keeping the PHY on we may want to add a way to call
    device_set_wakeup_capable() without keeping the PHY on at suspend
    time.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Chris Zhong <zyw@rock-chips.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d10a7f8daec3..3e6c3c8a32ff 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -447,6 +447,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		goto error;
 
+	hsotg->need_phy_for_wake =
+		of_property_read_bool(dev->dev.of_node,
+				      "snps,need-phy-for-wake");
+
 	/*
 	 * Reset before dwc2_get_hwparams() then it could get power-on real
 	 * reset value form registers.
@@ -478,6 +482,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		hsotg->gadget_enabled = 1;
 	}
 
+	/*
+	 * If we need PHY for wakeup we must be wakeup capable.
+	 * When we have a device that can wake without the PHY we
+	 * can adjust this condition.
+	 */
+	if (hsotg->need_phy_for_wake)
+		device_set_wakeup_capable(&dev->dev, true);
+
 	hsotg->reset_phy_on_wake =
 		of_property_read_bool(dev->dev.of_node,
 				      "snps,reset-phy-on-wake");
@@ -516,13 +528,17 @@ static int dwc2_driver_probe(struct platform_device *dev)
 static int __maybe_unused dwc2_suspend(struct device *dev)
 {
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
+	bool is_device_mode = dwc2_is_device_mode(dwc2);
 	int ret = 0;
 
-	if (dwc2_is_device_mode(dwc2))
+	if (is_device_mode)
 		dwc2_hsotg_suspend(dwc2);
 
-	if (dwc2->ll_hw_enabled)
+	if (dwc2->ll_hw_enabled &&
+	    (is_device_mode || dwc2_host_can_poweroff_phy(dwc2))) {
 		ret = __dwc2_lowlevel_hw_disable(dwc2);
+		dwc2->phy_off_for_suspend = true;
+	}
 
 	return ret;
 }
@@ -532,11 +548,12 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
-	if (dwc2->ll_hw_enabled) {
+	if (dwc2->phy_off_for_suspend && dwc2->ll_hw_enabled) {
 		ret = __dwc2_lowlevel_hw_enable(dwc2);
 		if (ret)
 			return ret;
 	}
+	dwc2->phy_off_for_suspend = false;
 
 	if (dwc2_is_device_mode(dwc2))
 		ret = dwc2_hsotg_resume(dwc2);

commit 42de8afc40c97002fceb500e2331f6a722be3c14
Author: Jules Maselbas <jmaselbas@kalray.eu>
Date:   Thu May 9 11:15:28 2019 +0200

    usb: dwc2: Use generic PHY width in params setup
    
    Setting params.phy_utmi_width in dwc2_lowlevel_hw_init() is pointless since
    it's value will be overwritten by dwc2_init_params().
    
    This change make sure to take in account the generic PHY width information
    during paraminitialisation, done in dwc2_set_param_phy_utmi_width().
    
    By doing so, the phy_utmi_width params can still be overrided by
    devicetree specific params and will also be checked against hardware
    capabilities.
    
    Fixes: 707d80f0a3c5 ("usb: dwc2: gadget: Replace phyif with phy_utmi_width")
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Jules Maselbas <jmaselbas@kalray.eu>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d10a7f8daec3..e98d7812da2d 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -271,15 +271,6 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	hsotg->plat = dev_get_platdata(hsotg->dev);
 
-	if (hsotg->phy) {
-		/*
-		 * If using the generic PHY framework, check if the PHY bus
-		 * width is 8-bit and set the phyif appropriately.
-		 */
-		if (phy_get_bus_width(hsotg->phy) == 8)
-			hsotg->params.phy_utmi_width = 8;
-	}
-
 	/* Clock */
 	hsotg->clk = devm_clk_get_optional(hsotg->dev, "otg");
 	if (IS_ERR(hsotg->clk)) {

commit 707d80f0a3c5fb58e61404277f6b103955fac294
Author: Jules Maselbas <jmaselbas@kalray.eu>
Date:   Fri Apr 5 15:35:31 2019 +0200

    usb: dwc2: gadget: Replace phyif with phy_utmi_width
    
    The phy utmi width information is already set in hsotg params,
    phyif is only used in few places and I don't see any reason to
    not use hsotg's params.
    
    Moreover the utmi width was being forced to 16 bits by platform
    initialization which doesn't take in account HW configuration.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Jules Maselbas <jmaselbas@kalray.eu>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index c01fa8ffc0c8..d10a7f8daec3 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -230,9 +230,6 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	reset_control_deassert(hsotg->reset_ecc);
 
-	/* Set default UTMI width */
-	hsotg->phyif = GUSBCFG_PHYIF16;
-
 	/*
 	 * Attempt to find a generic PHY, then look for an old style
 	 * USB PHY and then fall back to pdata
@@ -280,7 +277,7 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 		 * width is 8-bit and set the phyif appropriately.
 		 */
 		if (phy_get_bus_width(hsotg->phy) == 8)
-			hsotg->phyif = GUSBCFG_PHYIF8;
+			hsotg->params.phy_utmi_width = 8;
 	}
 
 	/* Clock */

commit c40cf7705e13d288d900e044c0a2f756e9e4909a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Apr 16 14:53:49 2019 -0700

    usb: dwc2: optionally assert phy reset when waking up
    
    On the rk3288 USB host-only port (the one that's not the OTG-enabled
    port) the PHY can get into a bad state when a wakeup is asserted (not
    just a wakeup from full system suspend but also a wakeup from
    autosuspend).
    
    We can get the PHY out of its bad state by asserting its "port reset",
    but unfortunately that seems to assert a reset onto the USB bus so it
    could confuse things if we don't actually deenumerate / reenumerate the
    device.
    
    We can also get the PHY out of its bad state by fully resetting it using
    the reset from the CRU (clock reset unit), which does a more full
    reset.  The CRU-based reset appears to actually cause devices on the bus
    to be removed and reinserted, which fixes the problem (albeit in a hacky
    way).
    
    It's unfortunate that we need to do a full re-enumeration of devices at
    wakeup time, but this is better than alternative of letting the bus get
    wedged.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Yunzhi Li <lyz@rock-chips.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 9aa9682a5cd2..c01fa8ffc0c8 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -481,6 +481,15 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		hsotg->gadget_enabled = 1;
 	}
 
+	hsotg->reset_phy_on_wake =
+		of_property_read_bool(dev->dev.of_node,
+				      "snps,reset-phy-on-wake");
+	if (hsotg->reset_phy_on_wake && !hsotg->phy) {
+		dev_warn(hsotg->dev,
+			 "Quirk reset-phy-on-wake only supports generic PHYs\n");
+		hsotg->reset_phy_on_wake = false;
+	}
+
 	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
 		retval = dwc2_hcd_init(hsotg);
 		if (retval) {

commit 60722c4eefbc9acddaf5e641f6dfb24bce930f9a
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Wed Apr 17 16:28:19 2019 +0800

    usb: dwc2: get optional clock by devm_clk_get_optional()
    
    When the driver tries to get optional clock, it ignores all errors,
    but if only ignores -ENOENT, it will cover some real errors, such as
    -EPROBE_DEFER, so use devm_clk_get_optional() to get optional clock.
    
    Cc: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index c0b64d483552..9aa9682a5cd2 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -284,10 +284,10 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	}
 
 	/* Clock */
-	hsotg->clk = devm_clk_get(hsotg->dev, "otg");
+	hsotg->clk = devm_clk_get_optional(hsotg->dev, "otg");
 	if (IS_ERR(hsotg->clk)) {
-		hsotg->clk = NULL;
-		dev_dbg(hsotg->dev, "cannot get otg clock\n");
+		dev_err(hsotg->dev, "cannot get otg clock\n");
+		return PTR_ERR(hsotg->clk);
 	}
 
 	/* Regulators */

commit e0f681c2c11a25b76626cea77deb819a4754375d
Author: Fabrice Gasnier <fabrice.gasnier@st.com>
Date:   Wed Sep 5 13:40:02 2018 +0200

    usb: dwc2: get optional vbus-supply regulator once
    
    Move devm_regulator_get_optional() call to probe routine. This avoids
    'vbus-supply' regulator to be requested lots of times, upon each call
    to dwc2_vbus_supply_init(), e.g. like with runtime pm.
    
    Fixes: 531ef5ebea96 ("usb: dwc2: add support for host mode external
    vbus supply")
    
    Tested-by: Artur Petrosyan <arturp@synopsys.com>
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Signed-off-by: Fabrice Gasnier <fabrice.gasnier@st.com>
    Signed-off-by: Amelie Delaunay <amelie.delaunay@st.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 577642895b57..c0b64d483552 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -432,6 +432,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
+	hsotg->vbus_supply = devm_regulator_get_optional(hsotg->dev, "vbus");
+	if (IS_ERR(hsotg->vbus_supply)) {
+		retval = PTR_ERR(hsotg->vbus_supply);
+		hsotg->vbus_supply = NULL;
+		if (retval != -ENODEV)
+			return retval;
+	}
+
 	retval = dwc2_lowlevel_hw_enable(hsotg);
 	if (retval)
 		return retval;

commit d9707490077bee0c7060ef5665a90656e1078b66
Author: Bruno Meirelles Herrera <bmh@certi.org.br>
Date:   Mon Aug 27 18:36:38 2018 -0300

    usb: dwc2: Fix call location of dwc2_check_core_endianness
    
    Some SoC/IP as STM32F469, the snpsid can only be read after clock is
    enabled, otherwise it will read as 0, and the dwc2_check_core_endianness
    will assume the core and AHB have opposite endianness, leading to the
    following error:
    
    [    1.976339] dwc2 50000000.usb: 50000000.usb supply vusb_d not found, using dummy regulator
    [    1.986124] dwc2 50000000.usb: Linked as a consumer to regulator.0
    [    1.992711] dwc2 50000000.usb: 50000000.usb supply vusb_a not found, using dummy regulator
    [    2.003672] dwc2 50000000.usb: dwc2_core_reset: HANG! AHB Idle timeout GRSTCTL GRSTCTL_AHBIDLE
    [    2.015176] dwc2: probe of 50000000.usb failed with error -16
    
    The proposed patch changes the location where dwc2_check_core_endianness
    is called, allowing the clock peripheral to be enabled first.
    
    Acked-by: Minas Harutyunyan <hminas@synopsys.com>
    Tested-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Bruno Meirelles Herrera <bmh@certi.org.br>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 9a53a58e676e..577642895b57 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -412,8 +412,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
-	hsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);
-
 	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;
@@ -438,6 +436,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
+	hsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);
+
 	retval = dwc2_get_dr_mode(hsotg);
 	if (retval)
 		goto error;

commit fe369e1826b3efae11012ad07d1713223c37ec5d
Author: Gevorg Sahakyan <Gevorg.Sahakyan@synopsys.com>
Date:   Fri Jul 27 12:26:29 2018 +0400

    usb: dwc2: Make dwc2_readl/writel functions endianness-agnostic.
    
    Declared dwc2_check_core_endianness() function for dynamicly check
    core endianness.
    Added needs_byte_swap flag to hsotg structure, and depending on
    flag swap value inside dwc2_readl/writel functions.
    
    Signed-off-by: Gevorg Sahakyan <sahakyan@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 4c0819554bcd..9a53a58e676e 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -352,6 +352,23 @@ static void dwc2_driver_shutdown(struct platform_device *dev)
 	disable_irq(hsotg->irq);
 }
 
+/**
+ * dwc2_check_core_endianness() - Returns true if core and AHB have
+ * opposite endianness.
+ * @hsotg:	Programming view of the DWC_otg controller.
+ */
+static bool dwc2_check_core_endianness(struct dwc2_hsotg *hsotg)
+{
+	u32 snpsid;
+
+	snpsid = ioread32(hsotg->regs + GSNPSID);
+	if ((snpsid & GSNPSID_ID_MASK) == DWC2_OTG_ID ||
+	    (snpsid & GSNPSID_ID_MASK) == DWC2_FS_IOT_ID ||
+	    (snpsid & GSNPSID_ID_MASK) == DWC2_HS_IOT_ID)
+		return false;
+	return true;
+}
+
 /**
  * dwc2_driver_probe() - Called when the DWC_otg core is bound to the DWC_otg
  * driver
@@ -395,6 +412,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
+	hsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);
+
 	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;

commit 13b1f8e25bfd1d6b96278421f934efdd35be9d5b
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Fri Feb 16 12:56:03 2018 +0400

    usb: dwc2: Force mode optimizations
    
    If the dr_mode is USB_DR_MODE_OTG, forcing the mode is needed during
    driver probe to get the host and device specific HW parameters. Then we
    clear the force mode bits so that the core operates in OTG mode.
    
    The force mode bits should not be touched at any other time during the
    driver lifetime and they should be preserved whenever the GUSBCFG
    register is written to. The force mode bit values will persist across
    soft resets of the core.
    
    If the dr_mode is either USB_DR_MODE_HOST or USB_DR_MODE_PERIPHERAL, the
    force mode is set just once at probe to configure the core as either a
    host or peripheral.
    
    Given the above, we no longer need any other reset delays, force delays,
    or any forced modes anywhere else in the driver. So replace all calls to
    dwc2_core_reset_and_force_dr_mode() with dwc2_core_reset() and remove
    all other unnecessary delays.
    
    Also remove the dwc2_force_mode_if_needed() function since the "if
    needed" part is already taken care of by the polling in
    dwc2_force_mode().
    
    Finally, remove all other calls to dwc2_clear_force_mode().
    
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 7d80e6360a5a..4c0819554bcd 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -427,13 +427,20 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	 * Reset before dwc2_get_hwparams() then it could get power-on real
 	 * reset value form registers.
 	 */
-	dwc2_core_reset_and_force_dr_mode(hsotg);
+	retval = dwc2_core_reset(hsotg, false);
+	if (retval)
+		goto error;
 
 	/* Detect config values from hardware */
 	retval = dwc2_get_hwparams(hsotg);
 	if (retval)
 		goto error;
 
+	/*
+	 * For OTG cores, set the force mode bits to reflect the value
+	 * of dr_mode. Force mode bits should not be touched at any
+	 * other time after this.
+	 */
 	dwc2_force_dr_mode(hsotg);
 
 	retval = dwc2_init_params(hsotg);

commit 20fe440982e72dc6440297d7111d71ac2cda70dd
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Fri Feb 16 14:08:27 2018 +0400

    usb: dwc2: core: Add hibernated flag
    
    Added a flag to indicate that core is in hibernation,
    it is used to determine the hibernation state of the core.
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 65e1af5e491a..7d80e6360a5a 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -458,6 +458,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	}
 
 	platform_set_drvdata(dev, hsotg);
+	hsotg->hibernated = 0;
 
 	dwc2_debugfs_init(hsotg);
 

commit 42c6a25235677ad3568af080b0569e05a9f849fc
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Mon Feb 12 21:20:08 2018 +0100

    usb: dwc2: Print error if unable to set DMA coherent mask
    
    We better print an error in case probing of dwc2 fails on
    setting the DMA coherent mask.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 9f39b15e7605..65e1af5e491a 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -382,8 +382,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (!dev->dev.dma_mask)
 		dev->dev.dma_mask = &dev->dev.coherent_dma_mask;
 	retval = dma_set_coherent_mask(&dev->dev, DMA_BIT_MASK(32));
-	if (retval)
+	if (retval) {
+		dev_err(&dev->dev, "can't set coherent DMA mask: %d\n", retval);
 		return retval;
+	}
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	hsotg->regs = devm_ioremap_resource(&dev->dev, res);

commit f3768997013e1c7d625ca427150644f80eb5900e
Author: Vardan Mikayelyan <mvardan@synopsys.com>
Date:   Mon Dec 25 15:17:45 2017 +0400

    usb: dwc2: eliminate irq parameter from dwc2_gadget_init
    
    The irq is available in hsotg already, so there's no need to pass it as
    separate function parameter.
    
    Signed-off-by: Vardan Mikayelyan <mvardan@synopsys.com>
    Signed-off-by: Grigor Tovmasyan <tovmasya@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 4703478f702f..9f39b15e7605 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -439,7 +439,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		goto error;
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
-		retval = dwc2_gadget_init(hsotg, hsotg->irq);
+		retval = dwc2_gadget_init(hsotg);
 		if (retval)
 			goto error;
 		hsotg->gadget_enabled = 1;

commit f2830ad455ec0fdc386baeb9d654f7095bf849da
Author: Dinh Nguyen <dinguyen@kernel.org>
Date:   Wed Nov 1 10:34:53 2017 -0500

    usb: dwc2: add optional usb ecc reset bit
    
    The dwc2 USB controller in Stratix10 has an additional ECC reset bit that
    needs to get de-asserted in order for the controller to work properly.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Dinh Nguyen <dinguyen@kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3e26550d13dd..4703478f702f 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -221,6 +221,15 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	reset_control_deassert(hsotg->reset);
 
+	hsotg->reset_ecc = devm_reset_control_get_optional(hsotg->dev, "dwc2-ecc");
+	if (IS_ERR(hsotg->reset_ecc)) {
+		ret = PTR_ERR(hsotg->reset_ecc);
+		dev_err(hsotg->dev, "error getting reset control for ecc %d\n", ret);
+		return ret;
+	}
+
+	reset_control_deassert(hsotg->reset_ecc);
+
 	/* Set default UTMI width */
 	hsotg->phyif = GUSBCFG_PHYIF16;
 
@@ -319,6 +328,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 		dwc2_lowlevel_hw_disable(hsotg);
 
 	reset_control_assert(hsotg->reset);
+	reset_control_assert(hsotg->reset_ecc);
 
 	return 0;
 }

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index daf0d37acb37..3e26550d13dd 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
  * platform.c - DesignWare HS OTG Controller platform driver
  *

commit 8ec32c38efa5f9f92b275148ccb247156f0bf04e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Mar 15 12:31:53 2017 +0100

    usb: dwc2: simplify optional reset handling
    
    As of commit bb475230b8e5 ("reset: make optional functions really
    optional"), the reset framework API calls use NULL pointers to describe
    optional, non-present reset controls.
    
    This allows to return errors from devm_reset_control_get_optional and to
    call reset_control_(de)assert unconditionally.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 9564bc76c56f..daf0d37acb37 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -214,20 +214,11 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	hsotg->reset = devm_reset_control_get_optional(hsotg->dev, "dwc2");
 	if (IS_ERR(hsotg->reset)) {
 		ret = PTR_ERR(hsotg->reset);
-		switch (ret) {
-		case -ENOENT:
-		case -ENOTSUPP:
-			hsotg->reset = NULL;
-			break;
-		default:
-			dev_err(hsotg->dev, "error getting reset control %d\n",
-				ret);
-			return ret;
-		}
+		dev_err(hsotg->dev, "error getting reset control %d\n", ret);
+		return ret;
 	}
 
-	if (hsotg->reset)
-		reset_control_deassert(hsotg->reset);
+	reset_control_deassert(hsotg->reset);
 
 	/* Set default UTMI width */
 	hsotg->phyif = GUSBCFG_PHYIF16;
@@ -326,8 +317,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->ll_hw_enabled)
 		dwc2_lowlevel_hw_disable(hsotg);
 
-	if (hsotg->reset)
-		reset_control_assert(hsotg->reset);
+	reset_control_assert(hsotg->reset);
 
 	return 0;
 }

commit 4fe160d51e4226a80f81b3d9b5193e0b8d2ebcbd
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Jan 25 23:13:37 2017 +0100

    usb: dwc2: eliminate irq parameter from dwc2_hcd_init
    
    The irq is available in hsotg already, so there's no need to
    pass it as separate function parameter.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3f59a73de248..9564bc76c56f 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -445,7 +445,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	}
 
 	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
-		retval = dwc2_hcd_init(hsotg, hsotg->irq);
+		retval = dwc2_hcd_init(hsotg);
 		if (retval) {
 			if (hsotg->gadget_enabled)
 				dwc2_hsotg_remove(hsotg);

commit 34c0887fde3489b10fb712ab0312ca735fc85dd4
Author: John Youn <John.Youn@synopsys.com>
Date:   Tue Jan 17 20:31:43 2017 -0800

    usb: dwc2: Fix brace usage
    
    * Remove braces for one-line statements
    * Add missing braces where another arm in if-statement uses braces
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 649d7b9a714b..3f59a73de248 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -136,11 +136,11 @@ static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 			return ret;
 	}
 
-	if (hsotg->uphy)
+	if (hsotg->uphy) {
 		ret = usb_phy_init(hsotg->uphy);
-	else if (hsotg->plat && hsotg->plat->phy_init)
+	} else if (hsotg->plat && hsotg->plat->phy_init) {
 		ret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);
-	else {
+	} else {
 		ret = phy_power_on(hsotg->phy);
 		if (ret == 0)
 			ret = phy_init(hsotg->phy);
@@ -170,11 +170,11 @@ static int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
 	struct platform_device *pdev = to_platform_device(hsotg->dev);
 	int ret = 0;
 
-	if (hsotg->uphy)
+	if (hsotg->uphy) {
 		usb_phy_shutdown(hsotg->uphy);
-	else if (hsotg->plat && hsotg->plat->phy_exit)
+	} else if (hsotg->plat && hsotg->plat->phy_exit) {
 		ret = hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);
-	else {
+	} else {
 		ret = phy_exit(hsotg->phy);
 		if (ret == 0)
 			ret = phy_power_off(hsotg->phy);

commit 9da5197475a09e51a467388308f14dcbdcee8ba9
Author: John Youn <John.Youn@synopsys.com>
Date:   Tue Jan 17 20:30:27 2017 -0800

    usb: dwc2: Cleanup some checkpatch issues
    
    This commmit is the result of running checkpatch --fix.
    
    The results were verified for correctness. Some of the fixes result in
    line over 80 char which we will fix manually later.
    
    The following is a summary of what was done by checkpatch:
    * Remove externs on function prototypes.
    * Replace symbolic permissions with octal.
    * Align code to open parens.
    * Replace 'unsigned' with 'unsigned int'.
    * Remove unneccessary blank lines.
    * Add blank lines after declarations.
    * Add spaces around operators.
    * Remove unnecessary spaces after casts.
    * Replace 'x == NULL' with '!x'.
    * Replace kzalloc() with kcalloc().
    * Concatenate multi-line strings.
    * Use the BIT() macro.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 4fc8c603afb8..649d7b9a714b 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -111,7 +111,7 @@ static int dwc2_get_dr_mode(struct dwc2_hsotg *hsotg)
 
 	if (mode != hsotg->dr_mode) {
 		dev_warn(hsotg->dev,
-			"Configuration mismatch. dr_mode forced to %s\n",
+			 "Configuration mismatch. dr_mode forced to %s\n",
 			mode == USB_DR_MODE_HOST ? "host" : "device");
 
 		hsotg->dr_mode = mode;

commit 0a7d0d7fa820e4281370795ef43c6aaa8b91a07e
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:57 2016 -0700

    usb: dwc2: Remove dwc2_set_all_params function
    
    Replace this by statically defining a function with defaults, and just
    assigning it. This will allow us to use parameters of any type and any
    default value.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 4fbfe099b991..4fc8c603afb8 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -398,8 +398,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	spin_lock_init(&hsotg->lock);
 
-	dwc2_set_all_params(&hsotg->params, -1);
-
 	hsotg->irq = platform_get_irq(dev, 0);
 	if (hsotg->irq < 0) {
 		dev_err(&dev->dev, "missing IRQ resource\n");

commit 334bbd4ebe1b34e1640118a5bfcd48f65d96242f
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:55 2016 -0700

    usb: dwc2: Move parameter initialization into params.c
    
    Consolidate and move all the parameter initialization code from the
    probe function to params.c.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d335e3644c6f..4fbfe099b991 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -365,30 +365,10 @@ static void dwc2_driver_shutdown(struct platform_device *dev)
  */
 static int dwc2_driver_probe(struct platform_device *dev)
 {
-	const struct of_device_id *match;
-	const struct dwc2_core_params *params;
-	struct dwc2_core_params defparams;
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
 	int retval;
 
-	match = of_match_device(dwc2_of_match_table, &dev->dev);
-	if (match && match->data) {
-		params = match->data;
-	} else {
-		/* Default all params to autodetect */
-		dwc2_set_all_params(&defparams, -1);
-		params = &defparams;
-
-		/*
-		 * Disable descriptor dma mode by default as the HW can support
-		 * it, but does not support it for SPLIT transactions.
-		 * Disable it for FS devices as well.
-		 */
-		defparams.dma_desc_enable = 0;
-		defparams.dma_desc_fs_enable = 0;
-	}
-
 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
 	if (!hsotg)
 		return -ENOMEM;
@@ -453,11 +433,12 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		goto error;
 
-	/* Validate parameter values */
-	dwc2_set_parameters(hsotg, params);
-
 	dwc2_force_dr_mode(hsotg);
 
+	retval = dwc2_init_params(hsotg);
+	if (retval)
+		goto error;
+
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg, hsotg->irq);
 		if (retval)

commit bea8e86c51cf9cf637e5bf0610d14674e9115783
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:53 2016 -0700

    usb: dwc2: Declare the core params struct statically
    
    This makes it consistent with the hw_params struct and simplifies the
    memory management for future refactoring. Fix up usage in all files.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index c4b855b4e783..d335e3644c6f 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -418,12 +418,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	spin_lock_init(&hsotg->lock);
 
-	hsotg->core_params = devm_kzalloc(&dev->dev,
-				sizeof(*hsotg->core_params), GFP_KERNEL);
-	if (!hsotg->core_params)
-		return -ENOMEM;
-
-	dwc2_set_all_params(hsotg->core_params, -1);
+	dwc2_set_all_params(&hsotg->params, -1);
 
 	hsotg->irq = platform_get_irq(dev, 0);
 	if (hsotg->irq < 0) {

commit 323230ef4ef17512007c22898b008e9fb87b372e
Author: John Youn <johnyoun@synopsys.com>
Date:   Thu Nov 3 17:55:50 2016 -0700

    usb: dwc2: Add params.c file
    
    Add a params.c file and move all driver parameter code there, including
    all the static parameter definitions.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 8e1728b39a49..c4b855b4e783 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -55,165 +55,6 @@
 
 static const char dwc2_driver_name[] = "dwc2";
 
-static const struct dwc2_core_params params_hi6220 = {
-	.otg_cap			= 2,	/* No HNP/SRP capable */
-	.otg_ver			= 0,	/* 1.3 */
-	.dma_enable			= 1,
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= 0,	/* High Speed */
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= 1,
-	.host_rx_fifo_size		= 512,
-	.host_nperio_tx_fifo_size	= 512,
-	.host_perio_tx_fifo_size	= 512,
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= 16,
-	.phy_type			= 1,	/* UTMI */
-	.phy_utmi_width			= 8,
-	.phy_ulpi_ddr			= 0,	/* Single */
-	.phy_ulpi_ext_vbus		= 0,
-	.i2c_enable			= 0,
-	.ulpi_fs_ls			= 0,
-	.host_support_fs_ls_low_power	= 0,
-	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
-	.ts_dline			= 0,
-	.reload_ctl			= 0,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
-static const struct dwc2_core_params params_bcm2835 = {
-	.otg_cap			= 0,	/* HNP/SRP capable */
-	.otg_ver			= 0,	/* 1.3 */
-	.dma_enable			= 1,
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= 0,	/* High Speed */
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= 1,
-	.host_rx_fifo_size		= 774,	/* 774 DWORDs */
-	.host_nperio_tx_fifo_size	= 256,	/* 256 DWORDs */
-	.host_perio_tx_fifo_size	= 512,	/* 512 DWORDs */
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= 8,
-	.phy_type			= 1,	/* UTMI */
-	.phy_utmi_width			= 8,	/* 8 bits */
-	.phy_ulpi_ddr			= 0,	/* Single */
-	.phy_ulpi_ext_vbus		= 0,
-	.i2c_enable			= 0,
-	.ulpi_fs_ls			= 0,
-	.host_support_fs_ls_low_power	= 0,
-	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
-	.ts_dline			= 0,
-	.reload_ctl			= 0,
-	.ahbcfg				= 0x10,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
-static const struct dwc2_core_params params_rk3066 = {
-	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.otg_ver			= -1,
-	.dma_enable			= -1,
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= -1,
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 525,	/* 525 DWORDs */
-	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
-	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
-	.max_transfer_size		= -1,
-	.max_packet_count		= -1,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= -1,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
-static const struct dwc2_core_params params_ltq = {
-	.otg_cap			= 2,	/* non-HNP/non-SRP */
-	.otg_ver			= -1,
-	.dma_enable			= -1,
-	.dma_desc_enable		= -1,
-	.dma_desc_fs_enable		= -1,
-	.speed				= -1,
-	.enable_dynamic_fifo		= -1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 288,	/* 288 DWORDs */
-	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
-	.host_perio_tx_fifo_size	= 96,	/* 96 DWORDs */
-	.max_transfer_size		= 65535,
-	.max_packet_count		= 511,
-	.host_channels			= -1,
-	.phy_type			= -1,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= -1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= -1,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
-static const struct dwc2_core_params params_amlogic = {
-	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
-	.otg_ver			= -1,
-	.dma_enable			= 1,
-	.dma_desc_enable		= 0,
-	.dma_desc_fs_enable		= 0,
-	.speed				= DWC2_SPEED_PARAM_HIGH,
-	.enable_dynamic_fifo		= 1,
-	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 512,
-	.host_nperio_tx_fifo_size	= 500,
-	.host_perio_tx_fifo_size	= 500,
-	.max_transfer_size		= -1,
-	.max_packet_count		= -1,
-	.host_channels			= 16,
-	.phy_type			= DWC2_PHY_TYPE_PARAM_UTMI,
-	.phy_utmi_width			= -1,
-	.phy_ulpi_ddr			= -1,
-	.phy_ulpi_ext_vbus		= -1,
-	.i2c_enable			= -1,
-	.ulpi_fs_ls			= -1,
-	.host_support_fs_ls_low_power	= -1,
-	.host_ls_low_power_phy_clk	= -1,
-	.ts_dline			= -1,
-	.reload_ctl			= 1,
-	.ahbcfg				= GAHBCFG_HBSTLEN_INCR8 <<
-					  GAHBCFG_HBSTLEN_SHIFT,
-	.uframe_sched			= 0,
-	.external_id_pin_ctl		= -1,
-	.hibernation			= -1,
-};
-
 /*
  * Check the dr_mode against the module configuration and hardware
  * capabilities.
@@ -510,20 +351,6 @@ static void dwc2_driver_shutdown(struct platform_device *dev)
 	disable_irq(hsotg->irq);
 }
 
-static const struct of_device_id dwc2_of_match_table[] = {
-	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
-	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
-	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
-	{ .compatible = "lantiq,arx100-usb", .data = &params_ltq },
-	{ .compatible = "lantiq,xrx200-usb", .data = &params_ltq },
-	{ .compatible = "snps,dwc2", .data = NULL },
-	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
-	{ .compatible = "amlogic,meson8b-usb", .data = &params_amlogic },
-	{ .compatible = "amlogic,meson-gxbb-usb", .data = &params_amlogic },
-	{},
-};
-MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
-
 /**
  * dwc2_driver_probe() - Called when the DWC_otg core is bound to the DWC_otg
  * driver

commit c913fc4146ba7c280e074558d0a461e5c6f07c8a
Merge: a439f8f2879c 8185041f5fa6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 7 21:34:49 2016 -0700

    Merge tag 'armsoc-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC late DT updates from Arnd Bergmann:
     "These updates have been kept in a separate branch mostly because they
      rely on updates to the respective clk drivers to keep the shared
      header files in sync.
    
       - The Renesas r8a7796 (R-Car M3-W) platform gets added, this is an
         automotive SoC similar to the 8a7795 chip we already support, but
         the dts changes rely on a clock driver change that has been merged
         for v4.9 through the clk tree.
    
       - The Amlogic meson-gxbb (S905) platform gains support for a few
         drivers merged through our tree, in particular the network and usb
         driver changes are required and included here, and also the clk
         tree changes.
    
       - The Allwinner platforms have seen a large-scale change to their clk
         drivers and the dts file updates must come after that. This
         includes the newly added Nextthing GR8 platform, which is derived
         from sun5i/A13.
    
       - Some integrator (arm32) changes rely on clk driver changes.
    
       - A single patch for lpc32xx has no such dependency but wasn't added
         until just before the merge window"
    
    * tag 'armsoc-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (99 commits)
      ARM: dts: lpc32xx: add device node for IRAM on-chip memory
      ARM: dts: sun8i: Add accelerometer to polaroid-mid2407pxe03
      ARM: dts: sun8i: enable UART1 for iNet D978 Rev2 board
      ARM: dts: sun8i: add pinmux for UART1 at PG
      dts: sun8i-h3: add I2C0-2 peripherals to H3 SOC
      dts: sun8i-h3: add pinmux definitions for I2C0-2
      dts: sun8i-h3: associate exposed UARTs on Orange Pi Boards
      dts: sun8i-h3: split off RTS/CTS for UART1 in seperate pinmux
      dts: sun8i-h3: add pinmux definitions for UART2-3
      ARM: dts: sun9i: a80-optimus: Disable EHCI1
      ARM: dts: sun9i: cubieboard4: Add AXP806 PMIC device node and regulators
      ARM: dts: sun9i: a80-optimus: Add AXP806 PMIC device node and regulators
      ARM: dts: sun9i: cubieboard4: Declare AXP809 SW regulator as unused
      ARM: dts: sun9i: a80-optimus: Declare AXP809 SW regulator as unused
      ARM: dts: sun8i: Add touchscreen node for sun8i-a33-ga10h
      ARM: dts: sun8i: Add touchscreen node for sun8i-a23-polaroid-mid2809pxe04
      ARM: dts: sun8i: Add touchscreen node for sun8i-a23-polaroid-mid2407pxe03
      ARM: dts: sun8i: Add touchscreen node for sun8i-a23-inet86dz
      ARM: dts: sun8i: Add touchscreen node for sun8i-a23-gt90h
      ARM64: dts: meson-gxbb-vega-s95: Enable USB Nodes
      ...

commit f94310ac076ea2cd84ff42c901e7a17382ad75f8
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Sun Sep 11 15:41:06 2016 +0200

    usb: dwc2: add support for Meson8b and GXBB SoCs
    
    Add compatible strings for amlogic Meson8b and GXBB SoCs with the
    corresponding configuration parameters.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Kevin Hilman <khilman@baylibre.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index fc6f5251de5d..8f7b34c8a5d4 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -181,6 +181,38 @@ static const struct dwc2_core_params params_ltq = {
 	.hibernation			= -1,
 };
 
+static const struct dwc2_core_params params_amlogic = {
+	.otg_cap			= DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE,
+	.otg_ver			= -1,
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= DWC2_SPEED_PARAM_HIGH,
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 512,
+	.host_nperio_tx_fifo_size	= 500,
+	.host_perio_tx_fifo_size	= 500,
+	.max_transfer_size		= -1,
+	.max_packet_count		= -1,
+	.host_channels			= 16,
+	.phy_type			= DWC2_PHY_TYPE_PARAM_UTMI,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= 1,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR8 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
 /*
  * Check the dr_mode against the module configuration and hardware
  * capabilities.
@@ -464,6 +496,8 @@ static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "lantiq,xrx200-usb", .data = &params_ltq },
 	{ .compatible = "snps,dwc2", .data = NULL },
 	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
+	{ .compatible = "amlogic,meson8b-usb", .data = &params_amlogic },
+	{ .compatible = "amlogic,meson-gxbb-usb", .data = &params_amlogic },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 83f8da562f8b5275fa1095b45762996971f7c607
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Wed Aug 10 08:53:34 2016 -0500

    usb: dwc2: Add reset control to dwc2
    
    Allow for platforms that have a reset controller driver in place to bring
    the USB IP out of reset.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index fc6f5251de5d..530959a8a6d1 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -45,6 +45,7 @@
 #include <linux/platform_device.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_data/s3c-hsotg.h>
+#include <linux/reset.h>
 
 #include <linux/usb/of.h>
 
@@ -337,6 +338,24 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 {
 	int i, ret;
 
+	hsotg->reset = devm_reset_control_get_optional(hsotg->dev, "dwc2");
+	if (IS_ERR(hsotg->reset)) {
+		ret = PTR_ERR(hsotg->reset);
+		switch (ret) {
+		case -ENOENT:
+		case -ENOTSUPP:
+			hsotg->reset = NULL;
+			break;
+		default:
+			dev_err(hsotg->dev, "error getting reset control %d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	if (hsotg->reset)
+		reset_control_deassert(hsotg->reset);
+
 	/* Set default UTMI width */
 	hsotg->phyif = GUSBCFG_PHYIF16;
 
@@ -434,6 +453,9 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->ll_hw_enabled)
 		dwc2_lowlevel_hw_disable(hsotg);
 
+	if (hsotg->reset)
+		reset_control_assert(hsotg->reset);
+
 	return 0;
 }
 

commit a6ef3e02542a33fb705e6977221deb0292b27398
Author: John Youn <johnyoun@synopsys.com>
Date:   Wed Apr 27 20:20:56 2016 -0700

    usb: dwc2: Proper cleanup on dr_mode failure
    
    Cleanup in probe if we fail to get dr_mode.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 88629bed6614..fc6f5251de5d 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -562,7 +562,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	retval = dwc2_get_dr_mode(hsotg);
 	if (retval)
-		return retval;
+		goto error;
 
 	/*
 	 * Reset before dwc2_get_hwparams() then it could get power-on real

commit 6c0c0951bbf8c2c216675fe277fba4c42aa0a2bf
Author: Antti Seppl <a.seppala@gmail.com>
Date:   Sat Feb 27 12:31:24 2016 +0200

    usb: dwc2: Add support for Lantiq ARX and XRX SoCs
    
    Add support for Lantiq ARX and XRX SoC families to the dwc2 driver.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Antti Seppl <a.seppala@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index bc3f2a45a2bc..88629bed6614 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -149,6 +149,38 @@ static const struct dwc2_core_params params_rk3066 = {
 	.hibernation			= -1,
 };
 
+static const struct dwc2_core_params params_ltq = {
+	.otg_cap			= 2,	/* non-HNP/non-SRP */
+	.otg_ver			= -1,
+	.dma_enable			= -1,
+	.dma_desc_enable		= -1,
+	.dma_desc_fs_enable		= -1,
+	.speed				= -1,
+	.enable_dynamic_fifo		= -1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 288,	/* 288 DWORDs */
+	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
+	.host_perio_tx_fifo_size	= 96,	/* 96 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= -1,
+	.phy_type			= -1,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= -1,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
 /*
  * Check the dr_mode against the module configuration and hardware
  * capabilities.
@@ -428,6 +460,8 @@ static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
+	{ .compatible = "lantiq,arx100-usb", .data = &params_ltq },
+	{ .compatible = "lantiq,xrx200-usb", .data = &params_ltq },
 	{ .compatible = "snps,dwc2", .data = NULL },
 	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
 	{},

commit 098c1ef8fe6bcdfed7905cea1debdd3a0ff9a16f
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jan 28 18:19:54 2016 -0800

    usb: dwc2: host: Set host_rx_fifo_size to 525 for rk3066
    
    As documented in dwc2_calculate_dynamic_fifo(), host_rx_fifo_size should
    really be:
     2 * ((Largest Packet size / 4) + 1 + 1) + n
     with n = number of host channel.
    
    We have 9 host channels, so
     2 * ((1024/4) + 2) + 9 = 516 + 9 = 525
    
    We've got 960 / 972 total_fifo_size on rk3288 (and presumably on
    rk3066) and 525 + 128 + 256 = 909 so we're still under on both ports
    even when we increment by 5.
    
    In the future, it would be nice if dwc2_calculate_dynamic_fifo() could
    handle the "too small" FIFO case and come up with something more
    dynamically.  When we do that we can figure out how to allocate the
    extra 48 / 60 bytes of FIFO that we're currently wasting.
    
    NOTE: no known bugs are fixed by this patch, but it seems like a simple
    fix and ought to fix someone.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Kever Yang <kever.yang@rock-chips.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index ecaa3d20e135..bc3f2a45a2bc 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -126,7 +126,7 @@ static const struct dwc2_core_params params_rk3066 = {
 	.speed				= -1,
 	.enable_dynamic_fifo		= 1,
 	.en_multiple_tx_fifo		= -1,
-	.host_rx_fifo_size		= 520,	/* 520 DWORDs */
+	.host_rx_fifo_size		= 525,	/* 525 DWORDs */
 	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
 	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
 	.max_transfer_size		= -1,

commit 40eed7d78378f1f609680a8a891a50cce12ed612
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Jan 28 18:19:52 2016 -0800

    usb: dwc2: rockchip: Make the max_transfer_size automatic
    
    Previously we needed to set the max_transfer_size to explicitly be 65535
    because the old driver would detect that our hardware could support much
    bigger transfers and then would try to do them.  This wouldn't work
    since the DMA alignment code couldn't support it.
    
    Later in commit e8f8c14d9da7 ("usb: dwc2: clip max_transfer_size to
    65535") upstream added support for clipping this automatically.  Since
    that commit it has been OK to just use "-1" (default), but nobody
    bothered to change it.
    
    Let's change it to default now for two reasons:
    - It's nice to use autodetected params.
    - If we can remove the 65535 limit, we can transfer more!
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 690b9fd98b55..ecaa3d20e135 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -129,7 +129,7 @@ static const struct dwc2_core_params params_rk3066 = {
 	.host_rx_fifo_size		= 520,	/* 520 DWORDs */
 	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
 	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
-	.max_transfer_size		= 65535,
+	.max_transfer_size		= -1,
 	.max_packet_count		= -1,
 	.host_channels			= -1,
 	.phy_type			= -1,

commit 03b32e4c9bd1b52fcf1e4304e7a704aa0315e398
Author: John Youn <John.Youn@synopsys.com>
Date:   Mon Jan 11 16:32:14 2016 -0800

    Revert "usb: dwc2: Move reset into dwc2_get_hwparams()"
    
    This reverts commit 263b7fb557f7 ("usb: dwc2: Move reset into
    dwc2_get_hwparams()") due to regression found on bcm2835 platform. USB
    ethernet fails, due to being unable to pick up proper parameters when
    performing a plain reset before reading hw params.
    
    Below shows the results of the gnptxfsiz and hptxfsiz with and before
    and after reverting this (from Stefan Wahren):
    
    So here is the probe result before Patch 1 is applied:
    
    [    1.283148] dwc2 20980000.usb: Configuration mismatch. dr_mode forced to host
    [    1.313894] dwc2 20980000.usb: gnptxfsiz=00201000
    [    1.314104] dwc2 20980000.usb: hptxfsiz=00000000
    [    1.353908] dwc2 20980000.usb: 256 invalid for host_nperio_tx_fifo_size. Check HW configuration.
    [    1.354262] dwc2 20980000.usb: 512 invalid for host_perio_tx_fifo_size. Check HW configuration.
    [    1.394249] dwc2 20980000.usb: DWC OTG Controller
    [    1.394561] dwc2 20980000.usb: new USB bus registered, assigned bus number 1
    [    1.394917] dwc2 20980000.usb: irq 33, io mem 0x00000000
    
    And here is the probe result after Patch 1 is applied:
    
    [    1.280107] dwc2 20980000.usb: Configuration mismatch. dr_mode forced to host
    [    1.353949] dwc2 20980000.usb: gnptxfsiz=01001000
    [    1.354166] dwc2 20980000.usb: hptxfsiz=02002000
    [    1.434301] dwc2 20980000.usb: DWC OTG Controller
    [    1.434616] dwc2 20980000.usb: new USB bus registered, assigned bus number 1
    [    1.434973] dwc2 20980000.usb: irq 33, io mem 0x00000000
    
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Reported-by: Remi Pommarel <repk@triplefau.lt>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Remi Pommarel <repk@triplefau.lt>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 510f787434b3..690b9fd98b55 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -530,7 +530,13 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
-	/* Reset the controller and detect hardware config values */
+	/*
+	 * Reset before dwc2_get_hwparams() then it could get power-on real
+	 * reset value form registers.
+	 */
+	dwc2_core_reset_and_force_dr_mode(hsotg);
+
+	/* Detect config values from hardware */
 	retval = dwc2_get_hwparams(hsotg);
 	if (retval)
 		goto error;

commit a40a00318c7fcdd23e73cfffac0e33430a43a3e3
Author: Heiko Stbner <heiko.stuebner@collabora.com>
Date:   Fri Dec 18 19:30:59 2015 +0100

    usb: dwc2: add shutdown callback to platform variant
    
    In specific conditions (involving usb hubs) dwc2 devices can create a
    lot of interrupts, even to the point of overwhelming devices running
    at low frequencies. Some devices need to do special clock handling
    at shutdown-time which may bring the system clock below the threshold
    of being able to handle the dwc2 interrupts. Disabling dwc2-irqs
    in a shutdown callbacks prevents reboots/poweroffs from getting stuck
    in such cases.
    
    The hsotg struct already contains an unused irq element, so we can
    just use it to store the irq number for the shutdown callback.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Heiko Stuebner <heiko.stuebner@collabora.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 1e7cb99d2100..510f787434b3 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -405,6 +405,25 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	return 0;
 }
 
+/**
+ * dwc2_driver_shutdown() - Called on device shutdown
+ *
+ * @dev: Platform device
+ *
+ * In specific conditions (involving usb hubs) dwc2 devices can create a
+ * lot of interrupts, even to the point of overwhelming devices running
+ * at low frequencies. Some devices need to do special clock handling
+ * at shutdown-time which may bring the system clock below the threshold
+ * of being able to handle the dwc2 interrupts. Disabling dwc2-irqs
+ * prevents reboots/poweroffs from getting stuck in such cases.
+ */
+static void dwc2_driver_shutdown(struct platform_device *dev)
+{
+	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
+
+	disable_irq(hsotg->irq);
+}
+
 static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
@@ -435,7 +454,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
 	int retval;
-	int irq;
 
 	match = of_match_device(dwc2_of_match_table, &dev->dev);
 	if (match && match->data) {
@@ -490,15 +508,15 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	dwc2_set_all_params(hsotg->core_params, -1);
 
-	irq = platform_get_irq(dev, 0);
-	if (irq < 0) {
+	hsotg->irq = platform_get_irq(dev, 0);
+	if (hsotg->irq < 0) {
 		dev_err(&dev->dev, "missing IRQ resource\n");
-		return irq;
+		return hsotg->irq;
 	}
 
 	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
-		irq);
-	retval = devm_request_irq(hsotg->dev, irq,
+		hsotg->irq);
+	retval = devm_request_irq(hsotg->dev, hsotg->irq,
 				  dwc2_handle_common_intr, IRQF_SHARED,
 				  dev_name(hsotg->dev), hsotg);
 	if (retval)
@@ -523,14 +541,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dwc2_force_dr_mode(hsotg);
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
-		retval = dwc2_gadget_init(hsotg, irq);
+		retval = dwc2_gadget_init(hsotg, hsotg->irq);
 		if (retval)
 			goto error;
 		hsotg->gadget_enabled = 1;
 	}
 
 	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
-		retval = dwc2_hcd_init(hsotg, irq);
+		retval = dwc2_hcd_init(hsotg, hsotg->irq);
 		if (retval) {
 			if (hsotg->gadget_enabled)
 				dwc2_hsotg_remove(hsotg);
@@ -597,6 +615,7 @@ static struct platform_driver dwc2_platform_driver = {
 	},
 	.probe = dwc2_driver_probe,
 	.remove = dwc2_driver_remove,
+	.shutdown = dwc2_driver_shutdown,
 };
 
 module_platform_driver(dwc2_platform_driver);

commit 25362d318371e1e271dda24995ceabb8457b3b7c
Author: John Youn <John.Youn@synopsys.com>
Date:   Thu Dec 17 11:18:27 2015 -0800

    usb: dwc2: Remove redundant reset in probe
    
    Reset already happens before this so just force the dr_mode.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index bfa4a6a8a1f3..1e7cb99d2100 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -520,7 +520,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	/* Validate parameter values */
 	dwc2_set_parameters(hsotg, params);
 
-	dwc2_core_reset_and_force_dr_mode(hsotg);
+	dwc2_force_dr_mode(hsotg);
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg, irq);

commit 263b7fb557f797d9d4d1dcf93fb6bb2efc3f1d46
Author: John Youn <John.Youn@synopsys.com>
Date:   Thu Dec 17 11:16:58 2015 -0800

    usb: dwc2: Move reset into dwc2_get_hwparams()
    
    The reset is required to get reset values of the hardware parameters but
    the force mode is not. Move the base reset into dwc2_get_hwparams() and
    do the reset and force mode afterwards.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index f4366513acb6..bfa4a6a8a1f3 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -512,13 +512,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
-	/*
-	 * Reset before dwc2_get_hwparams() then it could get power-on real
-	 * reset value form registers.
-	 */
-	dwc2_core_reset_and_force_dr_mode(hsotg);
-
-	/* Detect config values from hardware */
+	/* Reset the controller and detect hardware config values */
 	retval = dwc2_get_hwparams(hsotg);
 	if (retval)
 		goto error;
@@ -526,6 +520,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	/* Validate parameter values */
 	dwc2_set_parameters(hsotg, params);
 
+	dwc2_core_reset_and_force_dr_mode(hsotg);
+
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg, irq);
 		if (retval)

commit 5268ed9d2e3b52f703f3661eef14cecbb2b572d4
Author: John Youn <John.Youn@synopsys.com>
Date:   Thu Dec 17 11:16:31 2015 -0800

    usb: dwc2: Fix dr_mode validation
    
    The dr_mode parameter was being checked against how the dwc2 module
    was being configured at compile time. But it wasn't checked against
    the hardware capabilities, nor were the hardware capabilities checked
    against the compilation parameters.
    
    This commit adds those checks and adjusts dr_mode to an appropriate
    value, if needed. If the hardware capabilities and module compilation
    do not match then we fail as it wouldn't be possible to run properly.
    
    The hardware, module, and dr_mode, can each be set to host, device,
    or otg. Check that all these values are compatible and adjust the
    value of dr_mode if possible.
    
    The following table summarizes the behavior:
    
                         actual
       HW  MOD dr_mode   dr_mode
     ------------------------------
      HST  HST  any    :  HST
      HST  DEV  any    :  ---
      HST  OTG  any    :  HST
    
      DEV  HST  any    :  ---
      DEV  DEV  any    :  DEV
      DEV  OTG  any    :  DEV
    
      OTG  HST  any    :  HST
      OTG  DEV  any    :  DEV
      OTG  OTG  any    :  dr_mode
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 8bd7315a06c9..f4366513acb6 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -149,6 +149,71 @@ static const struct dwc2_core_params params_rk3066 = {
 	.hibernation			= -1,
 };
 
+/*
+ * Check the dr_mode against the module configuration and hardware
+ * capabilities.
+ *
+ * The hardware, module, and dr_mode, can each be set to host, device,
+ * or otg. Check that all these values are compatible and adjust the
+ * value of dr_mode if possible.
+ *
+ *                      actual
+ *    HW  MOD dr_mode   dr_mode
+ *  ------------------------------
+ *   HST  HST  any    :  HST
+ *   HST  DEV  any    :  ---
+ *   HST  OTG  any    :  HST
+ *
+ *   DEV  HST  any    :  ---
+ *   DEV  DEV  any    :  DEV
+ *   DEV  OTG  any    :  DEV
+ *
+ *   OTG  HST  any    :  HST
+ *   OTG  DEV  any    :  DEV
+ *   OTG  OTG  any    :  dr_mode
+ */
+static int dwc2_get_dr_mode(struct dwc2_hsotg *hsotg)
+{
+	enum usb_dr_mode mode;
+
+	hsotg->dr_mode = usb_get_dr_mode(hsotg->dev);
+	if (hsotg->dr_mode == USB_DR_MODE_UNKNOWN)
+		hsotg->dr_mode = USB_DR_MODE_OTG;
+
+	mode = hsotg->dr_mode;
+
+	if (dwc2_hw_is_device(hsotg)) {
+		if (IS_ENABLED(CONFIG_USB_DWC2_HOST)) {
+			dev_err(hsotg->dev,
+				"Controller does not support host mode.\n");
+			return -EINVAL;
+		}
+		mode = USB_DR_MODE_PERIPHERAL;
+	} else if (dwc2_hw_is_host(hsotg)) {
+		if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL)) {
+			dev_err(hsotg->dev,
+				"Controller does not support device mode.\n");
+			return -EINVAL;
+		}
+		mode = USB_DR_MODE_HOST;
+	} else {
+		if (IS_ENABLED(CONFIG_USB_DWC2_HOST))
+			mode = USB_DR_MODE_HOST;
+		else if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL))
+			mode = USB_DR_MODE_PERIPHERAL;
+	}
+
+	if (mode != hsotg->dr_mode) {
+		dev_warn(hsotg->dev,
+			"Configuration mismatch. dr_mode forced to %s\n",
+			mode == USB_DR_MODE_HOST ? "host" : "device");
+
+		hsotg->dr_mode = mode;
+	}
+
+	return 0;
+}
+
 static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 {
 	struct platform_device *pdev = to_platform_device(hsotg->dev);
@@ -412,19 +477,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
-	hsotg->dr_mode = usb_get_dr_mode(&dev->dev);
-	if (IS_ENABLED(CONFIG_USB_DWC2_HOST) &&
-			hsotg->dr_mode != USB_DR_MODE_HOST) {
-		hsotg->dr_mode = USB_DR_MODE_HOST;
-		dev_warn(hsotg->dev,
-			"Configuration mismatch. Forcing host mode\n");
-	} else if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) &&
-			hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
-		hsotg->dr_mode = USB_DR_MODE_PERIPHERAL;
-		dev_warn(hsotg->dev,
-			"Configuration mismatch. Forcing peripheral mode\n");
-	}
-
 	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;
@@ -456,6 +508,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
+	retval = dwc2_get_dr_mode(hsotg);
+	if (retval)
+		return retval;
+
 	/*
 	 * Reset before dwc2_get_hwparams() then it could get power-on real
 	 * reset value form registers.

commit 6d58f346a61ff50eda740e6216e9829e572d75c8
Author: John Youn <John.Youn@synopsys.com>
Date:   Thu Dec 17 11:15:49 2015 -0800

    usb: dwc2: Rename dwc2_core_reset()
    
    Renamed dwc2_core_reset() to dwc2_core_reset_and_force_dr_mode(). This
    describes what it is doing more accurately. This is in preparation of
    introducing a plain dwc2_core_reset() function that only performs the
    reset and doesn't force the mode.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index a72302d740dd..8bd7315a06c9 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -460,7 +460,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	 * Reset before dwc2_get_hwparams() then it could get power-on real
 	 * reset value form registers.
 	 */
-	dwc2_core_reset(hsotg);
+	dwc2_core_reset_and_force_dr_mode(hsotg);
 
 	/* Detect config values from hardware */
 	retval = dwc2_get_hwparams(hsotg);

commit cebfdbf329ae929ccb71632888a7c2100c3d1eeb
Author: Yunzhi Li <lyz@rock-chips.com>
Date:   Thu Dec 17 11:14:26 2015 -0800

    usb: dwc2: reset dwc2 core before dwc2_get_hwparams()
    
    We initiate dwc2 usb controller in BIOS, dwc2_core_reset() should
    be called before dwc2_get_hwparams() to reset core registers to
    default value. Without this the FIFO setting might be incorrect
    because calculating FIFO size need power-on value of
    GRXFSIZ/GNPTXFSIZ/HPTXFSIZ registers.
    
    This patch could avoid warnning massage like in rk3288 platform:
    [    2.074764] dwc2 ff580000.usb: 256 invalid for
    host_perio_tx_fifo_size. Check HW configuration.
    
    Signed-off-by: Yunzhi Li <lyz@rock-chips.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 5df2adf6f4e7..a72302d740dd 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -456,6 +456,12 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
+	/*
+	 * Reset before dwc2_get_hwparams() then it could get power-on real
+	 * reset value form registers.
+	 */
+	dwc2_core_reset(hsotg);
+
 	/* Detect config values from hardware */
 	retval = dwc2_get_hwparams(hsotg);
 	if (retval)

commit 37dd9d65cc41fcc7e77645a1cdf2659472809b96
Author: Zhangfei Gao <zhangfei.gao@linaro.org>
Date:   Wed Nov 18 15:39:47 2015 +0800

    usb: dwc2: add support of hi6220
    
    Support hisilicon,hi6220-usb for HiKey board
    
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Zhangfei Gao <zhangfei.gao@linaro.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 095bc05f76ca..5df2adf6f4e7 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -54,6 +54,38 @@
 
 static const char dwc2_driver_name[] = "dwc2";
 
+static const struct dwc2_core_params params_hi6220 = {
+	.otg_cap			= 2,	/* No HNP/SRP capable */
+	.otg_ver			= 0,	/* 1.3 */
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
+	.speed				= 0,	/* High Speed */
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= 1,
+	.host_rx_fifo_size		= 512,
+	.host_nperio_tx_fifo_size	= 512,
+	.host_perio_tx_fifo_size	= 512,
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= 16,
+	.phy_type			= 1,	/* UTMI */
+	.phy_utmi_width			= 8,
+	.phy_ulpi_ddr			= 0,	/* Single */
+	.phy_ulpi_ext_vbus		= 0,
+	.i2c_enable			= 0,
+	.ulpi_fs_ls			= 0,
+	.host_support_fs_ls_low_power	= 0,
+	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
+	.ts_dline			= 0,
+	.reload_ctl			= 0,
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
+	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
+};
+
 static const struct dwc2_core_params params_bcm2835 = {
 	.otg_cap			= 0,	/* HNP/SRP capable */
 	.otg_ver			= 0,	/* 1.3 */
@@ -310,6 +342,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 
 static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
+	{ .compatible = "hisilicon,hi6220-usb", .data = &params_hi6220 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
 	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},

commit fbb9e22b15ad3c9a98c66bad801b4d1366e8bf20
Author: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
Date:   Fri Nov 20 11:49:28 2015 +0100

    usb: dwc2: host: enable descriptor dma for fs devices
    
    As descriptor dma mode does not support split transfers, it can't be
    enabled for high speed devices. Add a core parameter to enable it for
    full speed devices.
    
    Ensure frame list and descriptor list are correctly freed during
    disconnect.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
    Signed-off-by: Gregory Herrero <gregory.herrero@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 39c1cbf0e75d..095bc05f76ca 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -59,6 +59,7 @@ static const struct dwc2_core_params params_bcm2835 = {
 	.otg_ver			= 0,	/* 1.3 */
 	.dma_enable			= 1,
 	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
 	.speed				= 0,	/* High Speed */
 	.enable_dynamic_fifo		= 1,
 	.en_multiple_tx_fifo		= 1,
@@ -89,6 +90,7 @@ static const struct dwc2_core_params params_rk3066 = {
 	.otg_ver			= -1,
 	.dma_enable			= -1,
 	.dma_desc_enable		= 0,
+	.dma_desc_fs_enable		= 0,
 	.speed				= -1,
 	.enable_dynamic_fifo		= 1,
 	.en_multiple_tx_fifo		= -1,
@@ -348,8 +350,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		/*
 		 * Disable descriptor dma mode by default as the HW can support
 		 * it, but does not support it for SPLIT transactions.
+		 * Disable it for FS devices as well.
 		 */
 		defparams.dma_desc_enable = 0;
+		defparams.dma_desc_fs_enable = 0;
 	}
 
 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);

commit f74875dc36135ebae82a8e005f4b7f52289d2c40
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Thu Nov 12 21:08:34 2015 +0000

    usb: dwc2: fix kernel oops during driver probe
    
    This patch make sure that all necessary members of dwc2_hsotg
    are initialized before the irq handler is requested. So
    the kernel oops triggered by dwc2_handle_common_intr has
    been fixed.
    
      dwc2 20980000.usb: Configuration mismatch. Forcing host mode
      dwc2 20980000.usb: no platform data or transceiver defined
      Unable to handle kernel paging request at virtual address cc860040
      pgd = c0004000
      [cc860040] *pgd=0b41e811, *pte=00000000, *ppte=00000000
      Internal error: Oops: 7 [#1] ARM
      CPU: 0 PID: 1 Comm: swapper Not tainted 4.3.0-rc3+ #19
      Hardware name: BCM2835
      task: cb494000 ti: cb4d0000 task.ti: cb4d0000
      PC is at dwc2_is_controller_alive+0x18/0x34
      LR is at dwc2_handle_common_intr+0x24/0xb60
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 91e2e6b86c7c..39c1cbf0e75d 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -367,20 +367,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
-	irq = platform_get_irq(dev, 0);
-	if (irq < 0) {
-		dev_err(&dev->dev, "missing IRQ resource\n");
-		return irq;
-	}
-
-	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
-		irq);
-	retval = devm_request_irq(hsotg->dev, irq,
-				  dwc2_handle_common_intr, IRQF_SHARED,
-				  dev_name(hsotg->dev), hsotg);
-	if (retval)
-		return retval;
-
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	hsotg->regs = devm_ioremap_resource(&dev->dev, res);
 	if (IS_ERR(hsotg->regs))
@@ -415,6 +401,20 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	dwc2_set_all_params(hsotg->core_params, -1);
 
+	irq = platform_get_irq(dev, 0);
+	if (irq < 0) {
+		dev_err(&dev->dev, "missing IRQ resource\n");
+		return irq;
+	}
+
+	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
+		irq);
+	retval = devm_request_irq(hsotg->dev, irq,
+				  dwc2_handle_common_intr, IRQF_SHARED,
+				  dev_name(hsotg->dev), hsotg);
+	if (retval)
+		return retval;
+
 	retval = dwc2_lowlevel_hw_enable(hsotg);
 	if (retval)
 		return retval;

commit 8aa90cf2a28645c6733f8879c5fe1848c5d510b7
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Fri Nov 13 17:02:12 2015 +0000

    usb: dwc2: make otg clk optional
    
    Fixes commit 09a75e857790
    ("usb: dwc2: refactor common low-level hw code to platform.c")
    
    The above commit consolidated the low-level phy access into a common
    location. This change made the otg clk a requirement and broke some
    platforms when it was moved into platform.c.
    
    So make clk handling optional again.
    
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Fixes: 09a75e857790 ("usb: dwc2: refactor common low-level hw code to platform.c")
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d28f72e87389..91e2e6b86c7c 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -125,9 +125,11 @@ static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 	if (ret)
 		return ret;
 
-	ret = clk_prepare_enable(hsotg->clk);
-	if (ret)
-		return ret;
+	if (hsotg->clk) {
+		ret = clk_prepare_enable(hsotg->clk);
+		if (ret)
+			return ret;
+	}
 
 	if (hsotg->uphy)
 		ret = usb_phy_init(hsotg->uphy);
@@ -175,7 +177,8 @@ static int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
 	if (ret)
 		return ret;
 
-	clk_disable_unprepare(hsotg->clk);
+	if (hsotg->clk)
+		clk_disable_unprepare(hsotg->clk);
 
 	ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
 				     hsotg->supplies);

commit 6c2dad69163fdb4ea82344dcba360fc00b4adda4
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Fri Nov 13 17:02:11 2015 +0000

    usb: dwc2: Return errors from PHY
    
    When searching for PHYs, any error was treated as if the PHY did not
    exist or was not specified. Thus the probe function did not
    correctly return error conditions such as -EPROBE_DEFER.
    
    Fixed so that only a non-existing PHY is ignored and any other error
    is returned.
    
    Acked-by: Eric Anholt <eric@anholt.net>
    Reported-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 60b12a4a11c8..d28f72e87389 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -212,14 +212,41 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	 */
 	hsotg->phy = devm_phy_get(hsotg->dev, "usb2-phy");
 	if (IS_ERR(hsotg->phy)) {
-		hsotg->phy = NULL;
+		ret = PTR_ERR(hsotg->phy);
+		switch (ret) {
+		case -ENODEV:
+		case -ENOSYS:
+			hsotg->phy = NULL;
+			break;
+		case -EPROBE_DEFER:
+			return ret;
+		default:
+			dev_err(hsotg->dev, "error getting phy %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!hsotg->phy) {
 		hsotg->uphy = devm_usb_get_phy(hsotg->dev, USB_PHY_TYPE_USB2);
-		if (IS_ERR(hsotg->uphy))
-			hsotg->uphy = NULL;
-		else
-			hsotg->plat = dev_get_platdata(hsotg->dev);
+		if (IS_ERR(hsotg->uphy)) {
+			ret = PTR_ERR(hsotg->uphy);
+			switch (ret) {
+			case -ENODEV:
+			case -ENXIO:
+				hsotg->uphy = NULL;
+				break;
+			case -EPROBE_DEFER:
+				return ret;
+			default:
+				dev_err(hsotg->dev, "error getting usb phy %d\n",
+					ret);
+				return ret;
+			}
+		}
 	}
 
+	hsotg->plat = dev_get_platdata(hsotg->dev);
+
 	if (hsotg->phy) {
 		/*
 		 * If using the generic PHY framework, check if the PHY bus

commit d0464bcf12af54bafe02dd23ac5bd75d825f9fdd
Author: John Youn <John.Youn@synopsys.com>
Date:   Fri Nov 13 17:02:10 2015 +0000

    usb: dwc2: Make PHY optional
    
    Fixes commit 09a75e857790
    ("usb: dwc2: refactor common low-level hw code to platform.c")
    
    The above commit consolidated the low-level phy access into a common
    location. This change introduced a check from the gadget requiring
    that a PHY is specified. This requirement never existed on the host
    side and broke some platforms when it was moved into platform.c.
    
    The gadget doesn't require the PHY either so remove the check.
    
    Acked-by: Eric Anholt <eric@anholt.net>
    Reported-by: Stefan Wahren <info@lategoodbye.de>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Fixes: 09a75e857790 ("usb: dwc2: refactor common low-level hw code to platform.c")
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index e61d773cf65e..60b12a4a11c8 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -229,11 +229,6 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 			hsotg->phyif = GUSBCFG_PHYIF8;
 	}
 
-	if (!hsotg->phy && !hsotg->uphy && !hsotg->plat) {
-		dev_err(hsotg->dev, "no platform data or transceiver defined\n");
-		return -EPROBE_DEFER;
-	}
-
 	/* Clock */
 	hsotg->clk = devm_clk_get(hsotg->dev, "otg");
 	if (IS_ERR(hsotg->clk)) {

commit f16593034a30bcbef8f63c37d0f2b9e1a0902c2d
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 20 16:33:53 2015 -0700

    usb: dwc2: host: Fix ahbcfg for rk3066
    
    The comment for ahbcfg for rk3066 parameters (also used for rk3288)
    claimed that ahbcfg was INCR16, but it wasn't.  Since the bits weren't
    shifted properly, the 0x7 ended up being masked and we ended up
    programming 0x3 for the HBstLen.  Let's set it to INCR16 properly.
    
    As per Wu Liang Feng at Rockchip this may increase transmission
    efficiency.  I did blackbox tests with writing 0s to a USB-based SD
    reader (forcefully capping CPU Freq to try to measure efficiency):
      cd /sys/devices/system/cpu/cpu0/cpufreq
      echo userspace > scaling_governor
      echo 126000 > scaling_setspeed
      for i in $(seq 10); do
        dd if=/dev/zero of=/dev/sdb bs=1M count=750
      done
    
    With the above tests I found that speeds went from ~15MB/s to ~18MB/s.
    Note that most other tests I did (including reading from the same USB
    reader) didn't show any difference in performance.
    
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Reviewed-by: Liangfeng Wu <wulf@rock-chips.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 5859b0fa19ee..e61d773cf65e 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -108,7 +108,8 @@ static const struct dwc2_core_params params_rk3066 = {
 	.host_ls_low_power_phy_clk	= -1,
 	.ts_dline			= -1,
 	.reload_ctl			= -1,
-	.ahbcfg				= 0x7, /* INCR16 */
+	.ahbcfg				= GAHBCFG_HBSTLEN_INCR16 <<
+					  GAHBCFG_HBSTLEN_SHIFT,
 	.uframe_sched			= -1,
 	.external_id_pin_ctl		= -1,
 	.hibernation			= -1,

commit 09a75e8577901489f77a14a3b305a9a1f67bf25b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Oct 14 08:52:29 2015 +0200

    usb: dwc2: refactor common low-level hw code to platform.c
    
    DWC2 module on some platforms needs three additional hardware
    resources: phy controller, clock and power supply. All of them must be
    enabled/activated to properly initialize and operate. This was initially
    handled in s3c-hsotg driver, which has been converted to 'gadget' part
    of dwc2 driver. Unfortunately, not all of this code got moved to common
    platform code, what resulted in accessing DWC2 registers without
    enabling low-level hardware resources. This fails for example on Exynos
    SoCs. This patch moves all the code for managing those resources to
    common platform.c file and provides convenient wrappers for controlling
    them.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 581e9cad6800..5859b0fa19ee 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -37,11 +37,14 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/of_device.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_data/s3c-hsotg.h>
 
 #include <linux/usb/of.h>
 
@@ -111,6 +114,145 @@ static const struct dwc2_core_params params_rk3066 = {
 	.hibernation			= -1,
 };
 
+static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
+				    hsotg->supplies);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(hsotg->clk);
+	if (ret)
+		return ret;
+
+	if (hsotg->uphy)
+		ret = usb_phy_init(hsotg->uphy);
+	else if (hsotg->plat && hsotg->plat->phy_init)
+		ret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);
+	else {
+		ret = phy_power_on(hsotg->phy);
+		if (ret == 0)
+			ret = phy_init(hsotg->phy);
+	}
+
+	return ret;
+}
+
+/**
+ * dwc2_lowlevel_hw_enable - enable platform lowlevel hw resources
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB platform resources (phy, clock, regulators)
+ */
+int dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
+{
+	int ret = __dwc2_lowlevel_hw_enable(hsotg);
+
+	if (ret == 0)
+		hsotg->ll_hw_enabled = true;
+	return ret;
+}
+
+static int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	int ret = 0;
+
+	if (hsotg->uphy)
+		usb_phy_shutdown(hsotg->uphy);
+	else if (hsotg->plat && hsotg->plat->phy_exit)
+		ret = hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);
+	else {
+		ret = phy_exit(hsotg->phy);
+		if (ret == 0)
+			ret = phy_power_off(hsotg->phy);
+	}
+	if (ret)
+		return ret;
+
+	clk_disable_unprepare(hsotg->clk);
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
+				     hsotg->supplies);
+
+	return ret;
+}
+
+/**
+ * dwc2_lowlevel_hw_disable - disable platform lowlevel hw resources
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB platform resources (phy, clock, regulators)
+ */
+int dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
+{
+	int ret = __dwc2_lowlevel_hw_disable(hsotg);
+
+	if (ret == 0)
+		hsotg->ll_hw_enabled = false;
+	return ret;
+}
+
+static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
+{
+	int i, ret;
+
+	/* Set default UTMI width */
+	hsotg->phyif = GUSBCFG_PHYIF16;
+
+	/*
+	 * Attempt to find a generic PHY, then look for an old style
+	 * USB PHY and then fall back to pdata
+	 */
+	hsotg->phy = devm_phy_get(hsotg->dev, "usb2-phy");
+	if (IS_ERR(hsotg->phy)) {
+		hsotg->phy = NULL;
+		hsotg->uphy = devm_usb_get_phy(hsotg->dev, USB_PHY_TYPE_USB2);
+		if (IS_ERR(hsotg->uphy))
+			hsotg->uphy = NULL;
+		else
+			hsotg->plat = dev_get_platdata(hsotg->dev);
+	}
+
+	if (hsotg->phy) {
+		/*
+		 * If using the generic PHY framework, check if the PHY bus
+		 * width is 8-bit and set the phyif appropriately.
+		 */
+		if (phy_get_bus_width(hsotg->phy) == 8)
+			hsotg->phyif = GUSBCFG_PHYIF8;
+	}
+
+	if (!hsotg->phy && !hsotg->uphy && !hsotg->plat) {
+		dev_err(hsotg->dev, "no platform data or transceiver defined\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* Clock */
+	hsotg->clk = devm_clk_get(hsotg->dev, "otg");
+	if (IS_ERR(hsotg->clk)) {
+		hsotg->clk = NULL;
+		dev_dbg(hsotg->dev, "cannot get otg clock\n");
+	}
+
+	/* Regulators */
+	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
+		hsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];
+
+	ret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),
+				      hsotg->supplies);
+	if (ret) {
+		dev_err(hsotg->dev, "failed to request supplies: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
 /**
  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
  * DWC_otg driver
@@ -132,6 +274,9 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->gadget_enabled)
 		dwc2_hsotg_remove(hsotg);
 
+	if (hsotg->ll_hw_enabled)
+		dwc2_lowlevel_hw_disable(hsotg);
+
 	return 0;
 }
 
@@ -163,8 +308,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	struct dwc2_core_params defparams;
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
-	struct phy *phy;
-	struct usb_phy *uphy;
 	int retval;
 	int irq;
 
@@ -233,31 +376,12 @@ static int dwc2_driver_probe(struct platform_device *dev)
 			"Configuration mismatch. Forcing peripheral mode\n");
 	}
 
-	/*
-	 * Attempt to find a generic PHY, then look for an old style
-	 * USB PHY
-	 */
-	phy = devm_phy_get(&dev->dev, "usb2-phy");
-	if (IS_ERR(phy)) {
-		hsotg->phy = NULL;
-		uphy = devm_usb_get_phy(&dev->dev, USB_PHY_TYPE_USB2);
-		if (IS_ERR(uphy))
-			hsotg->uphy = NULL;
-		else
-			hsotg->uphy = uphy;
-	} else {
-		hsotg->phy = phy;
-		phy_power_on(hsotg->phy);
-		phy_init(hsotg->phy);
-	}
-
-	spin_lock_init(&hsotg->lock);
-
-	/* Detect config values from hardware */
-	retval = dwc2_get_hwparams(hsotg);
+	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;
 
+	spin_lock_init(&hsotg->lock);
+
 	hsotg->core_params = devm_kzalloc(&dev->dev,
 				sizeof(*hsotg->core_params), GFP_KERNEL);
 	if (!hsotg->core_params)
@@ -265,13 +389,22 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	dwc2_set_all_params(hsotg->core_params, -1);
 
+	retval = dwc2_lowlevel_hw_enable(hsotg);
+	if (retval)
+		return retval;
+
+	/* Detect config values from hardware */
+	retval = dwc2_get_hwparams(hsotg);
+	if (retval)
+		goto error;
+
 	/* Validate parameter values */
 	dwc2_set_parameters(hsotg, params);
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg, irq);
 		if (retval)
-			return retval;
+			goto error;
 		hsotg->gadget_enabled = 1;
 	}
 
@@ -280,7 +413,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		if (retval) {
 			if (hsotg->gadget_enabled)
 				dwc2_hsotg_remove(hsotg);
-			return retval;
+			goto error;
 		}
 		hsotg->hcd_enabled = 1;
 	}
@@ -289,6 +422,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	dwc2_debugfs_init(hsotg);
 
+	/* Gadget code manages lowlevel hw on its own */
+	if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
+		dwc2_lowlevel_hw_disable(hsotg);
+
+	return 0;
+
+error:
+	dwc2_lowlevel_hw_disable(hsotg);
 	return retval;
 }
 
@@ -297,13 +438,12 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
-	if (dwc2_is_device_mode(dwc2)) {
-		ret = dwc2_hsotg_suspend(dwc2);
-	} else {
-		phy_exit(dwc2->phy);
-		phy_power_off(dwc2->phy);
+	if (dwc2_is_device_mode(dwc2))
+		dwc2_hsotg_suspend(dwc2);
+
+	if (dwc2->ll_hw_enabled)
+		ret = __dwc2_lowlevel_hw_disable(dwc2);
 
-	}
 	return ret;
 }
 
@@ -312,13 +452,15 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
-	if (dwc2_is_device_mode(dwc2)) {
+	if (dwc2->ll_hw_enabled) {
+		ret = __dwc2_lowlevel_hw_enable(dwc2);
+		if (ret)
+			return ret;
+	}
+
+	if (dwc2_is_device_mode(dwc2))
 		ret = dwc2_hsotg_resume(dwc2);
-	} else {
-		phy_power_on(dwc2->phy);
-		phy_init(dwc2->phy);
 
-	}
 	return ret;
 }
 

commit 758ed196fcc4373a129fd661875af52d7e7d4e73
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Oct 14 08:52:28 2015 +0200

    usb: dwc2: remove no longer needed init_mutex
    
    init_mutex is a leftover from the time, when s3c-hsotg driver did not
    implement proper pull up/down control and emulated it by enabling
    enabling/disabling usb phy. Proper pull up/down control has been added
    by commit 5b9451f8c4fbaf0549139755fb45ff2b57975b7f ("usb: dwc2: gadget:
    use soft-disconnect udc feature in pullup() method"), so init_muxtex can
    be removed now to avoid potential deadlocks with other locks.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index b920e438cd49..581e9cad6800 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -252,7 +252,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	}
 
 	spin_lock_init(&hsotg->lock);
-	mutex_init(&hsotg->init_mutex);
 
 	/* Detect config values from hardware */
 	retval = dwc2_get_hwparams(hsotg);

commit 5ee2a003e8622d51e865ffa5547a5708e592a1a5
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Sep 21 12:16:11 2015 +0200

    usb: dwc2: fix unbalanced phy control
    
    Even when DWC2 is in (internal) suspended state, it should disable PHY
    in suspend and then enable it in resume. This patch fixes unbalanced PHY
    control sequence.
    
    Tested-by: John Youn <johnyoun@synopsys.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index a013ea9f2c9c..b920e438cd49 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -301,8 +301,6 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	if (dwc2_is_device_mode(dwc2)) {
 		ret = dwc2_hsotg_suspend(dwc2);
 	} else {
-		if (dwc2->lx_state == DWC2_L0)
-			return 0;
 		phy_exit(dwc2->phy);
 		phy_power_off(dwc2->phy);
 

commit 857512d0ebf838d8a2b600234debdbfc1e97f919
Author: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
Date:   Tue Sep 29 12:08:18 2015 +0200

    usb: dwc2: force dr_mode in case of configuration mismatch
    
    If dual role configuration is not selected, check and force dr_mode
    based on the selected configuration.
    
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
    Tested-by: Robert Baldyga <r.baldyga@samsung.com>
    Tested-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Tested-by: John Youn <johnyoun@synopsys.com>
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 28abd1f90900..a013ea9f2c9c 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -221,6 +221,17 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		(unsigned long)res->start, hsotg->regs);
 
 	hsotg->dr_mode = usb_get_dr_mode(&dev->dev);
+	if (IS_ENABLED(CONFIG_USB_DWC2_HOST) &&
+			hsotg->dr_mode != USB_DR_MODE_HOST) {
+		hsotg->dr_mode = USB_DR_MODE_HOST;
+		dev_warn(hsotg->dev,
+			"Configuration mismatch. Forcing host mode\n");
+	} else if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) &&
+			hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
+		hsotg->dr_mode = USB_DR_MODE_PERIPHERAL;
+		dev_warn(hsotg->dev,
+			"Configuration mismatch. Forcing peripheral mode\n");
+	}
 
 	/*
 	 * Attempt to find a generic PHY, then look for an old style

commit 06e7114f0d8297278eb24f4e9bee3393a94bd8ce
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Sep 21 11:14:34 2015 +0300

    usb: common: of_usb_get_dr_mode to usb_get_dr_mode
    
    By using the unified device property interface, the function
    can be made available for all platforms and not just the
    ones using DT.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3d1f82def2f3..28abd1f90900 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -220,7 +220,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
-	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
+	hsotg->dr_mode = usb_get_dr_mode(&dev->dev);
 
 	/*
 	 * Attempt to find a generic PHY, then look for an old style

commit 1f91b4cc03556ba0d43ac80621dac8263cda3880
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Aug 6 18:11:54 2015 -0500

    usb: dwc2: rename all s3c_* to dwc2_*
    
    this driver has long ago became dwc2.ko with
    both peripheral and host roles, there's no point
    in keeping the old function names.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Tested-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 90935304185a..3d1f82def2f3 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -130,7 +130,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->hcd_enabled)
 		dwc2_hcd_remove(hsotg);
 	if (hsotg->gadget_enabled)
-		s3c_hsotg_remove(hsotg);
+		dwc2_hsotg_remove(hsotg);
 
 	return 0;
 }
@@ -269,7 +269,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		retval = dwc2_hcd_init(hsotg, irq);
 		if (retval) {
 			if (hsotg->gadget_enabled)
-				s3c_hsotg_remove(hsotg);
+				dwc2_hsotg_remove(hsotg);
 			return retval;
 		}
 		hsotg->hcd_enabled = 1;
@@ -288,7 +288,7 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	int ret = 0;
 
 	if (dwc2_is_device_mode(dwc2)) {
-		ret = s3c_hsotg_suspend(dwc2);
+		ret = dwc2_hsotg_suspend(dwc2);
 	} else {
 		if (dwc2->lx_state == DWC2_L0)
 			return 0;
@@ -305,7 +305,7 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	int ret = 0;
 
 	if (dwc2_is_device_mode(dwc2)) {
-		ret = s3c_hsotg_resume(dwc2);
+		ret = dwc2_hsotg_resume(dwc2);
 	} else {
 		phy_power_on(dwc2->phy);
 		phy_init(dwc2->phy);

commit 285046aa11ad85a4de24891f5458d45f50d1bcc5
Author: Gregory Herrero <gregory.herrero@intel.com>
Date:   Wed Apr 29 22:09:19 2015 +0200

    usb: dwc2: add hibernation core parameter
    
    dwc2 may not be able to exit from hibernation if the hardware
    does not provide a way to detect resume signalling in this state.
    Thus, add the possibility to disable hibernation feature.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Gregory Herrero <gregory.herrero@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 2562c9019955..90935304185a 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -78,6 +78,7 @@ static const struct dwc2_core_params params_bcm2835 = {
 	.ahbcfg				= 0x10,
 	.uframe_sched			= 0,
 	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
 };
 
 static const struct dwc2_core_params params_rk3066 = {
@@ -107,6 +108,7 @@ static const struct dwc2_core_params params_rk3066 = {
 	.ahbcfg				= 0x7, /* INCR16 */
 	.uframe_sched			= -1,
 	.external_id_pin_ctl		= -1,
+	.hibernation			= -1,
 };
 
 /**

commit ecb176c63ac49ddcea83b0171ead1372bb78c165
Author: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
Date:   Wed Apr 29 22:09:05 2015 +0200

    usb: dwc2: set parameter values in probe function
    
    So the parameters can be used in both host and gadget modes.
    Also consolidate param functions in the core.h
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index ce39e8a01844..2562c9019955 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -241,6 +241,21 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	spin_lock_init(&hsotg->lock);
 	mutex_init(&hsotg->init_mutex);
 
+	/* Detect config values from hardware */
+	retval = dwc2_get_hwparams(hsotg);
+	if (retval)
+		return retval;
+
+	hsotg->core_params = devm_kzalloc(&dev->dev,
+				sizeof(*hsotg->core_params), GFP_KERNEL);
+	if (!hsotg->core_params)
+		return -ENOMEM;
+
+	dwc2_set_all_params(hsotg->core_params, -1);
+
+	/* Validate parameter values */
+	dwc2_set_parameters(hsotg, params);
+
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg, irq);
 		if (retval)
@@ -249,7 +264,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	}
 
 	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
-		retval = dwc2_hcd_init(hsotg, irq, params);
+		retval = dwc2_hcd_init(hsotg, irq);
 		if (retval) {
 			if (hsotg->gadget_enabled)
 				s3c_hsotg_remove(hsotg);

commit a6d249d8373343749f9ae55f5581f3b21e178471
Author: Gregory Herrero <gregory.herrero@intel.com>
Date:   Wed Apr 29 22:09:04 2015 +0200

    usb: dwc2: add external_id_pin_ctl core parameter
    
    This is required due to an Intel specific hardware issue. Where id-
    pin setup causes glitches on the interrupt line when CONIDSTSCHG
    interrupt is enabled.
    
    Specify external_id_pin_ctl when an external driver (for example phy)
    can handle id change, so that CONIDSTSCHG interrupt can be disabled
    from the controller.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Gregory Herrero <gregory.herrero@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 4fb058b03eaf..ce39e8a01844 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -77,6 +77,7 @@ static const struct dwc2_core_params params_bcm2835 = {
 	.reload_ctl			= 0,
 	.ahbcfg				= 0x10,
 	.uframe_sched			= 0,
+	.external_id_pin_ctl		= -1,
 };
 
 static const struct dwc2_core_params params_rk3066 = {
@@ -105,6 +106,7 @@ static const struct dwc2_core_params params_rk3066 = {
 	.reload_ctl			= -1,
 	.ahbcfg				= 0x7, /* INCR16 */
 	.uframe_sched			= -1,
+	.external_id_pin_ctl		= -1,
 };
 
 /**

commit f91eea447ac32ddc24eaf1cafeb3830b44b6ceeb
Author: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
Date:   Wed Apr 29 22:08:59 2015 +0200

    usb: dwc2: move debugfs code to a separate file
    
    Prepare to add more debug code. Moreover, don't save dentry * for
    each file in struct dwc2_hsotg as clean up is done with
    debugfs_remove_recursive(). s3c_hsotg_delete_debug() is removed
    altogether for the same reason.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 185663e0b5f4..4fb058b03eaf 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -47,6 +47,7 @@
 
 #include "core.h"
 #include "hcd.h"
+#include "debug.h"
 
 static const char dwc2_driver_name[] = "dwc2";
 
@@ -121,6 +122,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
+	dwc2_debugfs_exit(hsotg);
 	if (hsotg->hcd_enabled)
 		dwc2_hcd_remove(hsotg);
 	if (hsotg->gadget_enabled)
@@ -256,6 +258,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	platform_set_drvdata(dev, hsotg);
 
+	dwc2_debugfs_init(hsotg);
+
 	return retval;
 }
 

commit e39af88f18dfe9a7938765c97ce9ed448915e6d5
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Mar 10 13:41:10 2015 +0100

    usb: dwc2: rework initialization of host and gadget in dual-role mode
    
    If device is configured to work only in HOST or DEVICE mode, there is
    no point in initializing both subdrivers. This patch also fixes
    resource leakage if host subdriver fails to initialize.
    
    Acked-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index ae095f009b4f..185663e0b5f4 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -121,8 +121,10 @@ static int dwc2_driver_remove(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
-	dwc2_hcd_remove(hsotg);
-	s3c_hsotg_remove(hsotg);
+	if (hsotg->hcd_enabled)
+		dwc2_hcd_remove(hsotg);
+	if (hsotg->gadget_enabled)
+		s3c_hsotg_remove(hsotg);
 
 	return 0;
 }
@@ -234,12 +236,23 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	spin_lock_init(&hsotg->lock);
 	mutex_init(&hsotg->init_mutex);
-	retval = dwc2_gadget_init(hsotg, irq);
-	if (retval)
-		return retval;
-	retval = dwc2_hcd_init(hsotg, irq, params);
-	if (retval)
-		return retval;
+
+	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
+		retval = dwc2_gadget_init(hsotg, irq);
+		if (retval)
+			return retval;
+		hsotg->gadget_enabled = 1;
+	}
+
+	if (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {
+		retval = dwc2_hcd_init(hsotg, irq, params);
+		if (retval) {
+			if (hsotg->gadget_enabled)
+				s3c_hsotg_remove(hsotg);
+			return retval;
+		}
+		hsotg->hcd_enabled = 1;
+	}
 
 	platform_set_drvdata(dev, hsotg);
 

commit 135b3c4304dacd8bb01f1aa6fe4165126bee3812
Author: Yunzhi Li <lyz@rock-chips.com>
Date:   Mon Dec 8 17:46:26 2014 +0800

    usb: dwc2: platform: add generic PHY framework support
    
    Get PHY parameters from devicetree and power off usb PHY during
    system suspend.
    
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Yunzhi Li <lyz@rock-chips.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 6a795aa2ff05..ae095f009b4f 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -155,6 +155,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	struct dwc2_core_params defparams;
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
+	struct phy *phy;
+	struct usb_phy *uphy;
 	int retval;
 	int irq;
 
@@ -212,6 +214,24 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
 
+	/*
+	 * Attempt to find a generic PHY, then look for an old style
+	 * USB PHY
+	 */
+	phy = devm_phy_get(&dev->dev, "usb2-phy");
+	if (IS_ERR(phy)) {
+		hsotg->phy = NULL;
+		uphy = devm_usb_get_phy(&dev->dev, USB_PHY_TYPE_USB2);
+		if (IS_ERR(uphy))
+			hsotg->uphy = NULL;
+		else
+			hsotg->uphy = uphy;
+	} else {
+		hsotg->phy = phy;
+		phy_power_on(hsotg->phy);
+		phy_init(hsotg->phy);
+	}
+
 	spin_lock_init(&hsotg->lock);
 	mutex_init(&hsotg->init_mutex);
 	retval = dwc2_gadget_init(hsotg, irq);
@@ -231,8 +251,15 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
-	if (dwc2_is_device_mode(dwc2))
+	if (dwc2_is_device_mode(dwc2)) {
 		ret = s3c_hsotg_suspend(dwc2);
+	} else {
+		if (dwc2->lx_state == DWC2_L0)
+			return 0;
+		phy_exit(dwc2->phy);
+		phy_power_off(dwc2->phy);
+
+	}
 	return ret;
 }
 
@@ -241,8 +268,13 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
-	if (dwc2_is_device_mode(dwc2))
+	if (dwc2_is_device_mode(dwc2)) {
 		ret = s3c_hsotg_resume(dwc2);
+	} else {
+		phy_power_on(dwc2->phy);
+		phy_init(dwc2->phy);
+
+	}
 	return ret;
 }
 

commit da9f3289c74f93b63c5ca741caa4e2d728ccafba
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Nov 19 12:37:53 2014 -0200

    usb: dwc2: Fix build warning when CONFIG_PM_SLEEP=n
    
    Building with bcm2835_defconfig, which has CONFIG_PM_SLEEP=n causes the
    following build warning:
    
    drivers/usb/dwc2/platform.c:227:12: warning: 'dwc2_suspend' defined but not used [-Wunused-function]
    drivers/usb/dwc2/platform.c:237:12: warning: 'dwc2_resume' defined but not used [-Wunused-function]
    
    Annotate these functions with '__maybe_unused' to prevent the warnings.
    
    Reported-by: Olof's autobuilder <build@lixom.net>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index ec5658ac52ba..6a795aa2ff05 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -226,7 +226,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	return retval;
 }
 
-static int dwc2_suspend(struct device *dev)
+static int __maybe_unused dwc2_suspend(struct device *dev)
 {
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
@@ -236,7 +236,7 @@ static int dwc2_suspend(struct device *dev)
 	return ret;
 }
 
-static int dwc2_resume(struct device *dev)
+static int __maybe_unused dwc2_resume(struct device *dev)
 {
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;

commit 7ad8096edfe0529eabb3ad466184c8fbd6134e1a
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Nov 21 15:14:48 2014 +0100

    usb: dwc2: gadget: add mutex to serialize init/deinit calls
    
    This patch adds mutex, which protects initialization and
    deinitialization procedures against suspend/resume methods. This mutex
    will be needed by the updated suspend/resume calls, which tracks gadget
    state.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 57eb8a3e022b..ec5658ac52ba 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -40,6 +40,7 @@
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/of_device.h>
+#include <linux/mutex.h>
 #include <linux/platform_device.h>
 
 #include <linux/usb/of.h>
@@ -212,6 +213,7 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
 
 	spin_lock_init(&hsotg->lock);
+	mutex_init(&hsotg->init_mutex);
 	retval = dwc2_gadget_init(hsotg, irq);
 	if (retval)
 		return retval;

commit f5500ecc90a887d7e65274817733fbe477070559
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Tue Nov 11 11:13:39 2014 -0600

    usb: dwc2: move usb_disabled() call to host driver only
    
    Since platform.c will get built for both Host and Gadget, if we leave the
    usb_disabled() call in platform.c, it results in the following build error
    when (!USB && USB_GADGET) condition is met.
    
    ERROR: "usb_disabled" [drivers/usb/dwc2/dwc2_platform.ko] undefined!
    
    Since usb_disabled() is mostly used to disable USB host functionality, move
    the call the host portion for the DWC2 driver.
    
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3552602ddbf6..57eb8a3e022b 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -157,9 +157,6 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	int retval;
 	int irq;
 
-	if (usb_disabled())
-		return -ENODEV;
-
 	match = of_match_device(dwc2_of_match_table, &dev->dev);
 	if (match && match->data) {
 		params = match->data;

commit db8178c33dbe9aba5e2c5d323625f9e6da55d7e6
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Tue Nov 11 11:13:37 2014 -0600

    usb: dwc2: Update common interrupt handler to call gadget interrupt handler
    
    Make dwc2_handle_common_intr call the gadget interrupt function when operating
    in peripheral mode. Remove the spinlock functions in s3c_hsotg_irq as
    dwc2_handle_common_intr() already has the spinlocks.
    
    Move the registeration of the IRQ to common code for platform and PCI.
    
    Remove duplicate interrupt conditions that was in gadget, as those are handled
    by dwc2 common interrupt handler.
    
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index b94867ba9ccf..3552602ddbf6 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -196,6 +196,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		return irq;
 	}
 
+	dev_dbg(hsotg->dev, "registering common handler for irq%d\n",
+		irq);
+	retval = devm_request_irq(hsotg->dev, irq,
+				  dwc2_handle_common_intr, IRQF_SHARED,
+				  dev_name(hsotg->dev), hsotg);
+	if (retval)
+		return retval;
+
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
 	hsotg->regs = devm_ioremap_resource(&dev->dev, res);
 	if (IS_ERR(hsotg->regs))

commit bcc06078ba4da9a8b92342e7005c65ba4c06bdb9
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Tue Nov 11 11:13:35 2014 -0600

    usb: dwc2: convert to use dev_pm_ops API
    
    Update suspend/resume to use dev_pm_ops API.
    
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index eeba8a44f799..b94867ba9ccf 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -219,9 +219,9 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	return retval;
 }
 
-static int dwc2_suspend(struct platform_device *dev, pm_message_t state)
+static int dwc2_suspend(struct device *dev)
 {
-	struct dwc2_hsotg *dwc2 = platform_get_drvdata(dev);
+	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
 	if (dwc2_is_device_mode(dwc2))
@@ -229,9 +229,9 @@ static int dwc2_suspend(struct platform_device *dev, pm_message_t state)
 	return ret;
 }
 
-static int dwc2_resume(struct platform_device *dev)
+static int dwc2_resume(struct device *dev)
 {
-	struct dwc2_hsotg *dwc2 = platform_get_drvdata(dev);
+	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
 	if (dwc2_is_device_mode(dwc2))
@@ -239,15 +239,18 @@ static int dwc2_resume(struct platform_device *dev)
 	return ret;
 }
 
+static const struct dev_pm_ops dwc2_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc2_suspend, dwc2_resume)
+};
+
 static struct platform_driver dwc2_platform_driver = {
 	.driver = {
 		.name = dwc2_driver_name,
 		.of_match_table = dwc2_of_match_table,
+		.pm = &dwc2_dev_pm_ops,
 	},
 	.probe = dwc2_driver_probe,
 	.remove = dwc2_driver_remove,
-	.suspend = dwc2_suspend,
-	.resume = dwc2_resume,
 };
 
 module_platform_driver(dwc2_platform_driver);

commit 117777b2c3bb961ba1cb9943dee93f192d7a3abd
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Tue Nov 11 11:13:34 2014 -0600

    usb: dwc2: Move gadget probe function into platform code
    
    This patch will aggregate the probing of gadget/hcd driver into platform.c.
    The gadget probe funtion is converted into gadget_init that is now only
    responsible for gadget only initialization. All the gadget resources are now
    handled by platform.c
    
    Since the host workqueue will not get initialized if the driver is configured
    for peripheral mode only. Thus we need to check for wq_otg before calling
    queue_work().
    
    Also, we move spin_lock_init to common location for both host and gadget that
    is either in platform.c or pci.c.
    
    We also move suspend/resume code to common platform code.
    
    Lastly, move the "samsung,s3c6400-hsotg" binding into dwc2_of_match_table.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 121dbdafc06b..eeba8a44f799 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -121,6 +121,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
 	dwc2_hcd_remove(hsotg);
+	s3c_hsotg_remove(hsotg);
 
 	return 0;
 }
@@ -129,6 +130,7 @@ static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
+	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
@@ -204,6 +206,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
 
+	spin_lock_init(&hsotg->lock);
+	retval = dwc2_gadget_init(hsotg, irq);
+	if (retval)
+		return retval;
 	retval = dwc2_hcd_init(hsotg, irq, params);
 	if (retval)
 		return retval;
@@ -213,6 +219,26 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	return retval;
 }
 
+static int dwc2_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct dwc2_hsotg *dwc2 = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (dwc2_is_device_mode(dwc2))
+		ret = s3c_hsotg_suspend(dwc2);
+	return ret;
+}
+
+static int dwc2_resume(struct platform_device *dev)
+{
+	struct dwc2_hsotg *dwc2 = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (dwc2_is_device_mode(dwc2))
+		ret = s3c_hsotg_resume(dwc2);
+	return ret;
+}
+
 static struct platform_driver dwc2_platform_driver = {
 	.driver = {
 		.name = dwc2_driver_name,
@@ -220,6 +246,8 @@ static struct platform_driver dwc2_platform_driver = {
 	},
 	.probe = dwc2_driver_probe,
 	.remove = dwc2_driver_remove,
+	.suspend = dwc2_suspend,
+	.resume = dwc2_resume,
 };
 
 module_platform_driver(dwc2_platform_driver);

commit 87df8ac3d2e4f47f3d24e6038110feebbe8954cf
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Sep 11 14:53:31 2014 +0200

    Revert "usb: dwc2: move "samsung,s3c6400-hsotg" into common platform"
    
    This reverts commit 8df438571cdbd5c4fcd1b25b19eea1ad5c3cf777.
    
    This patch breaks building dwc2 driver in gadget mode at samsung
    platforms.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 544a13ef6836..121dbdafc06b 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -129,7 +129,6 @@ static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
-	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit 8df438571cdbd5c4fcd1b25b19eea1ad5c3cf777
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Tue Aug 26 11:19:53 2014 -0500

    usb: dwc2: move "samsung,s3c6400-hsotg" into common platform
    
    Move the "samsung,s3c6400-hsotg" binding as the probe function in the gadget
    driver will get removed when the dual-role driver is implemented.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 121dbdafc06b..544a13ef6836 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -129,6 +129,7 @@ static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
+	{ .compatible = "samsung,s3c6400-hsotg", .data = NULL},
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);

commit c0155b9d5ef29092d39502ec57b0454b2b3c7cc9
Author: Kever Yang <kever.yang@rock-chips.com>
Date:   Wed Aug 6 09:01:50 2014 +0800

    usb: dwc2: add 'mode' which based on Kconfig select or dts setting
    
    According to the "dr_mode", the otg controller can work as
    device role and host role. Some boards always want to use host mode
    and some other boards want to use gadget mode. We use the dts setting
    to set dwc2's mode, rather than fixing it to whatever hardware says.
    
    Signed-off-by: Kever Yang <kever.yang@rock-chips.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Tested-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 2f859bdd1fc4..121dbdafc06b 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -42,6 +42,8 @@
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 
+#include <linux/usb/of.h>
+
 #include "core.h"
 #include "hcd.h"
 
@@ -200,6 +202,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
 
+	hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
+
 	retval = dwc2_hcd_init(hsotg, irq, params);
 	if (retval)
 		return retval;

commit 9508314655ba3f730c6290f5a7683e3a0c9e351d
Author: Kever Yang <kever.yang@rock-chips.com>
Date:   Fri Aug 8 11:55:57 2014 +0800

    usb: dwc2: add compatible data for rockchip soc
    
    This patch add compatible data for dwc2 controller found on
    rk3066, rk3188 and rk3288 processors from rockchip.
    
    Signed-off-by: Kever Yang <kever.yang@rock-chips.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Tested-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index a10e7a353576..2f859bdd1fc4 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -75,6 +75,34 @@ static const struct dwc2_core_params params_bcm2835 = {
 	.uframe_sched			= 0,
 };
 
+static const struct dwc2_core_params params_rk3066 = {
+	.otg_cap			= 2,	/* non-HNP/non-SRP */
+	.otg_ver			= -1,
+	.dma_enable			= -1,
+	.dma_desc_enable		= 0,
+	.speed				= -1,
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= -1,
+	.host_rx_fifo_size		= 520,	/* 520 DWORDs */
+	.host_nperio_tx_fifo_size	= 128,	/* 128 DWORDs */
+	.host_perio_tx_fifo_size	= 256,	/* 256 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= -1,
+	.host_channels			= -1,
+	.phy_type			= -1,
+	.phy_utmi_width			= -1,
+	.phy_ulpi_ddr			= -1,
+	.phy_ulpi_ext_vbus		= -1,
+	.i2c_enable			= -1,
+	.ulpi_fs_ls			= -1,
+	.host_support_fs_ls_low_power	= -1,
+	.host_ls_low_power_phy_clk	= -1,
+	.ts_dline			= -1,
+	.reload_ctl			= -1,
+	.ahbcfg				= 0x7, /* INCR16 */
+	.uframe_sched			= -1,
+};
+
 /**
  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
  * DWC_otg driver
@@ -97,6 +125,7 @@ static int dwc2_driver_remove(struct platform_device *dev)
 
 static const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
+	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
 	{ .compatible = "snps,dwc2", .data = NULL },
 	{},
 };

commit 8b3e233e8121d241a93f27a093c1440673d3a7ff
Author: Dinh Nguyen <dinguyen@altera.com>
Date:   Wed May 7 08:30:33 2014 -0500

    usb: dwc2: Disable descriptor dma mode by default
    
    Even though the IP supports Descriptor DMA mode, it does not support SPLIT
    transactions in this mode. So the driver, in its currently form, will not
    support LS/FS devices when connected to a HS Hub if Descriptor DMA mode is
    enabled.
    
    So we should just default to disable descriptor dma mode.
    
    Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index eaba547ce26b..a10e7a353576 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -134,6 +134,12 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		/* Default all params to autodetect */
 		dwc2_set_all_params(&defparams, -1);
 		params = &defparams;
+
+		/*
+		 * Disable descriptor dma mode by default as the HW can support
+		 * it, but does not support it for SPLIT transactions.
+		 */
+		defparams.dma_desc_enable = 0;
 	}
 
 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);

commit 861e0f5bae1c4f4026b58ca10fa3b0fc02f1540c
Author: Andre Heider <a.heider@gmail.com>
Date:   Tue Feb 4 21:27:44 2014 +0100

    usb: dwc2: bail out early when booting with "nousb"
    
    Add usb_disabled() check to prevent kernel oops when booting with "nousb"
    in the cmdline:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000030
    ...
    PC is at bus_add_device+0xe0/0x18c
    LR is at device_add_groups+0x1c/0x20
    ...
    [<c02191c0>] (bus_add_device) from [<c0217130>] (device_add+0x41c/0x538)
    [<c0217130>] (device_add) from [<c023b1d4>] (usb_new_device+0x270/0x35c)
    [<c023b1d4>] (usb_new_device) from [<c0241174>] (usb_add_hcd+0x4fc/0x760)
    [<c0241174>] (usb_add_hcd) from [<c0254ce0>] (dwc2_hcd_init+0x434/0x510)
    [<c0254ce0>] (dwc2_hcd_init) from [<c02594f4>] (dwc2_driver_probe+0x130/0x170)
    [<c02594f4>] (dwc2_driver_probe) from [<c021bbd0>] (platform_drv_probe+0x28/0x58)
    
    Signed-off-by: Andre Heider <a.heider@gmail.com>
    Acked-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d01d0d3f2cf0..eaba547ce26b 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -124,6 +124,9 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	int retval;
 	int irq;
 
+	if (usb_disabled())
+		return -ENODEV;
+
 	match = of_match_device(dwc2_of_match_table, &dev->dev);
 	if (match && match->data) {
 		params = match->data;

commit 197ba5f406cc29000c70de98eb40d7243b9f9f03
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Mon Jan 13 13:50:09 2014 -0800

    Move DWC2 driver out of staging
    
    The DWC2 driver should now be in good enough shape to move out of
    staging. I have stress tested it overnight on RPI running mass
    storage and Ethernet transfers in parallel, and for several days
    on our proprietary PCI-based platform.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
new file mode 100644
index 000000000000..d01d0d3f2cf0
--- /dev/null
+++ b/drivers/usb/dwc2/platform.c
@@ -0,0 +1,187 @@
+/*
+ * platform.c - DesignWare HS OTG Controller platform driver
+ *
+ * Copyright (C) Matthijs Kooijman <matthijs@stdin.nl>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include "core.h"
+#include "hcd.h"
+
+static const char dwc2_driver_name[] = "dwc2";
+
+static const struct dwc2_core_params params_bcm2835 = {
+	.otg_cap			= 0,	/* HNP/SRP capable */
+	.otg_ver			= 0,	/* 1.3 */
+	.dma_enable			= 1,
+	.dma_desc_enable		= 0,
+	.speed				= 0,	/* High Speed */
+	.enable_dynamic_fifo		= 1,
+	.en_multiple_tx_fifo		= 1,
+	.host_rx_fifo_size		= 774,	/* 774 DWORDs */
+	.host_nperio_tx_fifo_size	= 256,	/* 256 DWORDs */
+	.host_perio_tx_fifo_size	= 512,	/* 512 DWORDs */
+	.max_transfer_size		= 65535,
+	.max_packet_count		= 511,
+	.host_channels			= 8,
+	.phy_type			= 1,	/* UTMI */
+	.phy_utmi_width			= 8,	/* 8 bits */
+	.phy_ulpi_ddr			= 0,	/* Single */
+	.phy_ulpi_ext_vbus		= 0,
+	.i2c_enable			= 0,
+	.ulpi_fs_ls			= 0,
+	.host_support_fs_ls_low_power	= 0,
+	.host_ls_low_power_phy_clk	= 0,	/* 48 MHz */
+	.ts_dline			= 0,
+	.reload_ctl			= 0,
+	.ahbcfg				= 0x10,
+	.uframe_sched			= 0,
+};
+
+/**
+ * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
+ * DWC_otg driver
+ *
+ * @dev: Platform device
+ *
+ * This routine is called, for example, when the rmmod command is executed. The
+ * device may or may not be electrically present. If it is present, the driver
+ * stops device processing. Any resources used on behalf of this device are
+ * freed.
+ */
+static int dwc2_driver_remove(struct platform_device *dev)
+{
+	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
+
+	dwc2_hcd_remove(hsotg);
+
+	return 0;
+}
+
+static const struct of_device_id dwc2_of_match_table[] = {
+	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
+	{ .compatible = "snps,dwc2", .data = NULL },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
+
+/**
+ * dwc2_driver_probe() - Called when the DWC_otg core is bound to the DWC_otg
+ * driver
+ *
+ * @dev: Platform device
+ *
+ * This routine creates the driver components required to control the device
+ * (core, HCD, and PCD) and initializes the device. The driver components are
+ * stored in a dwc2_hsotg structure. A reference to the dwc2_hsotg is saved
+ * in the device private data. This allows the driver to access the dwc2_hsotg
+ * structure on subsequent calls to driver methods for this device.
+ */
+static int dwc2_driver_probe(struct platform_device *dev)
+{
+	const struct of_device_id *match;
+	const struct dwc2_core_params *params;
+	struct dwc2_core_params defparams;
+	struct dwc2_hsotg *hsotg;
+	struct resource *res;
+	int retval;
+	int irq;
+
+	match = of_match_device(dwc2_of_match_table, &dev->dev);
+	if (match && match->data) {
+		params = match->data;
+	} else {
+		/* Default all params to autodetect */
+		dwc2_set_all_params(&defparams, -1);
+		params = &defparams;
+	}
+
+	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
+	if (!hsotg)
+		return -ENOMEM;
+
+	hsotg->dev = &dev->dev;
+
+	/*
+	 * Use reasonable defaults so platforms don't have to provide these.
+	 */
+	if (!dev->dev.dma_mask)
+		dev->dev.dma_mask = &dev->dev.coherent_dma_mask;
+	retval = dma_set_coherent_mask(&dev->dev, DMA_BIT_MASK(32));
+	if (retval)
+		return retval;
+
+	irq = platform_get_irq(dev, 0);
+	if (irq < 0) {
+		dev_err(&dev->dev, "missing IRQ resource\n");
+		return irq;
+	}
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	hsotg->regs = devm_ioremap_resource(&dev->dev, res);
+	if (IS_ERR(hsotg->regs))
+		return PTR_ERR(hsotg->regs);
+
+	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
+		(unsigned long)res->start, hsotg->regs);
+
+	retval = dwc2_hcd_init(hsotg, irq, params);
+	if (retval)
+		return retval;
+
+	platform_set_drvdata(dev, hsotg);
+
+	return retval;
+}
+
+static struct platform_driver dwc2_platform_driver = {
+	.driver = {
+		.name = dwc2_driver_name,
+		.of_match_table = dwc2_of_match_table,
+	},
+	.probe = dwc2_driver_probe,
+	.remove = dwc2_driver_remove,
+};
+
+module_platform_driver(dwc2_platform_driver);
+
+MODULE_DESCRIPTION("DESIGNWARE HS OTG Platform Glue");
+MODULE_AUTHOR("Matthijs Kooijman <matthijs@stdin.nl>");
+MODULE_LICENSE("Dual BSD/GPL");
