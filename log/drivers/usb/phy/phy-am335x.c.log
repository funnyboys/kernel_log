commit b267ddf6a5abecad100e7139617ffb12415f9156
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 31 18:42:35 2019 +0100

    usb: phy-generic: Delete unused platform data
    
    The last user of the phy generic platform data was
    deleted in commit 1e041b6f313aaa966612a7e415cfc09c90d6b829
    ("usb: dwc3: exynos: Remove dead code"). So get rid of
    the platform data, which rids us of another consumer of
    the legacy GPIO API at the same time. Make sure we
    only inlcude <linux/gpio/consumer.h> which is all we use.
    
    Alter the usb_phy_gen_create_phy() function prototype to
    not pass any platform data as this is just hardcoded to
    NULL at all locations calling it in the kernel.
    
    Move the devm_gpiod_get* calls out of the if (of_node)
    parenthesis, as these calls are generic and do not depend
    on device tree, they are used by any hardware description.
    
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index f5f0568d8533..8524475d942d 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -57,7 +57,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 
 	am_phy->dr_mode = of_usb_get_dr_mode_by_phy(pdev->dev.of_node, -1);
 
-	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen, NULL);
+	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen);
 	if (ret)
 		return ret;
 

commit a53469a68eb886e84dd8b69a1458a623d3591793
Author: Bin Liu <b-liu@ti.com>
Date:   Wed Jan 16 11:54:07 2019 -0600

    usb: phy: am335x: fix race condition in _probe
    
    power off the phy should be done before populate the phy. Otherwise,
    am335x_init() could be called by the phy owner to power on the phy first,
    then am335x_phy_probe() turns off the phy again without the caller knowing
    it.
    
    Fixes: 2fc711d76352 ("usb: phy: am335x: Enable USB remote wakeup using PHY wakeup")
    Cc: stable@vger.kernel.org # v3.18+
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 27bdb7222527..f5f0568d8533 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -61,9 +61,6 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret = usb_add_phy_dev(&am_phy->usb_phy_gen.phy);
-	if (ret)
-		return ret;
 	am_phy->usb_phy_gen.phy.init = am335x_init;
 	am_phy->usb_phy_gen.phy.shutdown = am335x_shutdown;
 
@@ -82,7 +79,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	device_set_wakeup_enable(dev, false);
 	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, false);
 
-	return 0;
+	return usb_add_phy_dev(&am_phy->usb_phy_gen.phy);
 }
 
 static int am335x_phy_remove(struct platform_device *pdev)

commit 8bffbdb6d829b9d69ffb21abb50e15e0c0938c77
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 19 16:06:26 2018 +0200

    usb: phy: simplify getting .drvdata
    
    We should get drvdata from struct device directly. Going via
    platform_device is an unneeded step back and forth.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index b36fa8b953d0..27bdb7222527 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -96,8 +96,7 @@ static int am335x_phy_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM_SLEEP
 static int am335x_phy_suspend(struct device *dev)
 {
-	struct platform_device	*pdev = to_platform_device(dev);
-	struct am335x_phy *am_phy = platform_get_drvdata(pdev);
+	struct am335x_phy *am_phy = dev_get_drvdata(dev);
 
 	/*
 	 * Enable phy wakeup only if dev->power.can_wakeup is true.
@@ -117,8 +116,7 @@ static int am335x_phy_suspend(struct device *dev)
 
 static int am335x_phy_resume(struct device *dev)
 {
-	struct platform_device	*pdev = to_platform_device(dev);
-	struct am335x_phy	*am_phy = platform_get_drvdata(pdev);
+	struct am335x_phy	*am_phy = dev_get_drvdata(dev);
 
 	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, true);
 

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 7e5aece769da..b36fa8b953d0 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>

commit ce15ed4c5dfb3f7757e6611902aed5db253af977
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jun 10 11:46:25 2016 +0200

    USB: Fix of_usb_get_dr_mode_by_phy with a shared phy block
    
    Some SoCs have a single phy-hw-block with multiple phys, this is
    modelled by a single phy dts node, so we end up with multiple
    controller nodes with a phys property pointing to the phy-node
    of the otg-phy.
    
    Only one of these controllers typically is an otg controller, yet we
    were checking the first controller who uses a phy from the block and
    then end up looking for a dr_mode property in e.g. the ehci controller.
    
    This commit fixes this by adding an arg0 parameter to
    of_usb_get_dr_mode_by_phy and make of_usb_get_dr_mode_by_phy
    check that this matches the phandle args[0] value when looking for
    the otg controller.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index a262a4343f29..7e5aece769da 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -54,7 +54,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 		return am_phy->id;
 	}
 
-	am_phy->dr_mode = of_usb_get_dr_mode_by_phy(pdev->dev.of_node);
+	am_phy->dr_mode = of_usb_get_dr_mode_by_phy(pdev->dev.of_node, -1);
 
 	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen, NULL);
 	if (ret)

commit 12496785a414593ff25fd271f37d3a95d2a8058b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 2 14:02:51 2016 -0600

    usb: phy: phy-am335x: remove include of regulator/consumer.h
    
    phy-am335x.c doesn't use any interfaces from linux/regulator/consumer.h, so
    stop including it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 39b424f7f629..a262a4343f29 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -5,7 +5,6 @@
 #include <linux/usb/usb_phy_generic.h>
 #include <linux/slab.h>
 #include <linux/clk.h>
-#include <linux/regulator/consumer.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/usb/of.h>

commit 59f042f644c5aa10b65b7881966bed78c5c82923
Author: Bin Liu <b-liu@ti.com>
Date:   Tue Dec 8 10:31:50 2015 -0600

    usb: phy: phy-am335x: bypass first VBUS sensing for host-only mode
    
    To prevent VBUS contention, the am335x MUSB phy senses VBUS first before
    transitioning to host mode. However, for host-only mode, VBUS could be
    directly tied to 5V power rail which could prevent MUSB transitions to
    host mode.
    
    This change receives dr_mode of the controller then bypass the first
    VBUS sensing for host-only mode, so that MUSB can work in host mode
    event if VBUS is tied to 5V.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 8b6139dec5eb..39b424f7f629 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -8,6 +8,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/usb/of.h>
 
 #include "phy-am335x-control.h"
 #include "phy-generic.h"
@@ -16,13 +17,14 @@ struct am335x_phy {
 	struct usb_phy_generic usb_phy_gen;
 	struct phy_control *phy_ctrl;
 	int id;
+	enum usb_dr_mode dr_mode;
 };
 
 static int am335x_init(struct usb_phy *phy)
 {
 	struct am335x_phy *am_phy = dev_get_drvdata(phy->dev);
 
-	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, true);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, true);
 	return 0;
 }
 
@@ -30,7 +32,7 @@ static void am335x_shutdown(struct usb_phy *phy)
 {
 	struct am335x_phy *am_phy = dev_get_drvdata(phy->dev);
 
-	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, false);
 }
 
 static int am335x_phy_probe(struct platform_device *pdev)
@@ -46,12 +48,15 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	am_phy->phy_ctrl = am335x_get_phy_control(dev);
 	if (!am_phy->phy_ctrl)
 		return -EPROBE_DEFER;
+
 	am_phy->id = of_alias_get_id(pdev->dev.of_node, "phy");
 	if (am_phy->id < 0) {
 		dev_err(&pdev->dev, "Missing PHY id: %d\n", am_phy->id);
 		return am_phy->id;
 	}
 
+	am_phy->dr_mode = of_usb_get_dr_mode_by_phy(pdev->dev.of_node);
+
 	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen, NULL);
 	if (ret)
 		return ret;
@@ -75,7 +80,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	 */
 
 	device_set_wakeup_enable(dev, false);
-	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, false);
 
 	return 0;
 }
@@ -105,7 +110,7 @@ static int am335x_phy_suspend(struct device *dev)
 	if (device_may_wakeup(dev))
 		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, true);
 
-	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, false);
 
 	return 0;
 }
@@ -115,7 +120,7 @@ static int am335x_phy_resume(struct device *dev)
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct am335x_phy	*am_phy = platform_get_drvdata(pdev);
 
-	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, true);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, am_phy->dr_mode, true);
 
 	if (device_may_wakeup(dev))
 		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, false);

commit 5306661eff1a70f99456340eddf8e0cf85c2e8af
Author: Bin Liu <b-liu@ti.com>
Date:   Fri Nov 20 16:13:07 2015 -0600

    usb: phy: correct the am335x phy header filename
    
    The filename of am35x-phy-control.h is confusing. The header is used
    by the am335x phy driver, but the filename refers to am35x. Even worse
    there is indeed another device called am35x but it does not use this
    header at all.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 90b67a4ca221..8b6139dec5eb 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -9,7 +9,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 
-#include "am35x-phy-control.h"
+#include "phy-am335x-control.h"
 #include "phy-generic.h"
 
 struct am335x_phy {

commit a25f10c27c1cbdd5dafaa9018136aaba2fd53bcf
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:50 2014 +0200

    usb: phy: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index b70e05537180..90b67a4ca221 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -137,7 +137,6 @@ static struct platform_driver am335x_phy_driver = {
 	.remove         = am335x_phy_remove,
 	.driver         = {
 		.name   = "am335x-phy-driver",
-		.owner  = THIS_MODULE,
 		.pm = &am335x_pm_ops,
 		.of_match_table = am335x_phy_ids,
 	},

commit 1e32cda86d360ade35d2b3328b46ecf6ef5836db
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 8 20:51:34 2014 +0900

    usb: phy: am335x: Use SIMPLE_DEV_PM_OPS macro
    
    Use SIMPLE_DEV_PM_OPS macro and remove DEV_PM_OPS macro, in order
    to make the code simpler.
    
    Acked-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 585e50cb1980..b70e05537180 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -122,16 +122,10 @@ static int am335x_phy_resume(struct device *dev)
 
 	return 0;
 }
-
-static const struct dev_pm_ops am335x_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(am335x_phy_suspend, am335x_phy_resume)
-};
-
-#define DEV_PM_OPS     (&am335x_pm_ops)
-#else
-#define DEV_PM_OPS     NULL
 #endif
 
+static SIMPLE_DEV_PM_OPS(am335x_pm_ops, am335x_phy_suspend, am335x_phy_resume);
+
 static const struct of_device_id am335x_phy_ids[] = {
 	{ .compatible = "ti,am335x-usb-phy" },
 	{ }
@@ -144,7 +138,7 @@ static struct platform_driver am335x_phy_driver = {
 	.driver         = {
 		.name   = "am335x-phy-driver",
 		.owner  = THIS_MODULE,
-		.pm = DEV_PM_OPS,
+		.pm = &am335x_pm_ops,
 		.of_match_table = am335x_phy_ids,
 	},
 };

commit d7078df6be6e9e5e3ac354859f5b8d60114391b4
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Apr 16 15:28:32 2014 -0500

    usb: phy: rename <linux/usb/usb_phy_gen_xceiv.h> to <linux/usb/usb_phy_generic.h>
    
    now that all functions match the driver name,
    the only missing piece is to rename the header
    file itself.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index bb866e466051..585e50cb1980 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -2,7 +2,7 @@
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/usb/otg.h>
-#include <linux/usb/usb_phy_gen_xceiv.h>
+#include <linux/usb/usb_phy_generic.h>
 #include <linux/slab.h>
 #include <linux/clk.h>
 #include <linux/regulator/consumer.h>

commit 4525beeb9aadbb9e1cb3e9e135f4371553f26a70
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Apr 16 15:20:44 2014 -0500

    usb: phy: rename usb_nop_xceiv to usb_phy_generic
    
    no functional changes, just renaming the function
    in order to make it slightly clearer what it should
    be used for, also matching the driver name.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 12fc3468a01e..bb866e466051 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -13,7 +13,7 @@
 #include "phy-generic.h"
 
 struct am335x_phy {
-	struct usb_phy_gen_xceiv usb_phy_gen;
+	struct usb_phy_generic usb_phy_gen;
 	struct phy_control *phy_ctrl;
 	int id;
 };

commit 515610011edbec518e26b8222a16886cb66a4946
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Dec 20 15:04:09 2013 -0600

    usb: phy: am335x: fix randconfig errors
    
    by using SET_SYSTEM_SLEEP_PM_OPS, we will make
    sure that we don't use undefined functions.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index e8088fa7f05c..12fc3468a01e 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -122,17 +122,16 @@ static int am335x_phy_resume(struct device *dev)
 
 	return 0;
 }
+
+static const struct dev_pm_ops am335x_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(am335x_phy_suspend, am335x_phy_resume)
+};
+
 #define DEV_PM_OPS     (&am335x_pm_ops)
 #else
 #define DEV_PM_OPS     NULL
 #endif
 
-
-static const struct dev_pm_ops am335x_pm_ops = {
-	.suspend = am335x_phy_suspend,
-	.resume = am335x_phy_resume,
-};
-
 static const struct of_device_id am335x_phy_ids[] = {
 	{ .compatible = "ti,am335x-usb-phy" },
 	{ }

commit 2fc711d763520fa4ec2f15b204efc61585817a39
Author: George Cherian <george.cherian@ti.com>
Date:   Wed Dec 18 18:52:09 2013 +0530

    usb: phy: am335x: Enable USB remote wakeup using PHY wakeup
    
    USB remote wakeup using PHY wakeup is supported only in standby mode.
    Enabling the PHY_WKUP will break DS0 mode of system suspend.
    If the same is enabled while entering DS0, AM33xx never stays in DS0,
    it returns immediately from DS0. By default make the PHY wakeup
    disabled, using sysfs entry enable the same manually to get
    the remote wakeup working from standby.
    
    echo enabled > /sys/bus/platform/device/<usb phy id>/power/wakeup
    This will enable the PHY wakeup while going to standby.
    
    PHY wakeup feature is required to wakeup  the system from standby
    state. Since AM33xx has a bug in which PHY wakeup should not
    be enabled while entering DS0, disable the same by default.
    A user wishing to use USB wakeup from standby mode need to enable
    the same using the sysfs entries.
    
    Also remove am335x_phy_runtime_(suspend/resume) this driver doesnot really
    enable/disable the clocks to the PHY.
    Add am335x_phy_(suspend/resume) and use the same for enabling the PHY_WKUP.
    
    Signed-off-by: George Cherian <george.cherian@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 0e3c60cb669a..e8088fa7f05c 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -63,6 +63,19 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	am_phy->usb_phy_gen.phy.shutdown = am335x_shutdown;
 
 	platform_set_drvdata(pdev, am_phy);
+	device_init_wakeup(dev, true);
+
+	/*
+	 * If we leave PHY wakeup enabled then AM33XX wakes up
+	 * immediately from DS0. To avoid this we mark dev->power.can_wakeup
+	 * to false. The same is checked in suspend routine to decide
+	 * on whether to enable PHY wakeup or not.
+	 * PHY wakeup works fine in standby mode, there by allowing us to
+	 * handle remote wakeup, wakeup on disconnect and connect.
+	 */
+
+	device_set_wakeup_enable(dev, false);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
 
 	return 0;
 }
@@ -75,40 +88,51 @@ static int am335x_phy_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
-
-static int am335x_phy_runtime_suspend(struct device *dev)
+#ifdef CONFIG_PM_SLEEP
+static int am335x_phy_suspend(struct device *dev)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct am335x_phy *am_phy = platform_get_drvdata(pdev);
 
+	/*
+	 * Enable phy wakeup only if dev->power.can_wakeup is true.
+	 * Make sure to enable wakeup to support remote wakeup	in
+	 * standby mode ( same is not supported in OFF(DS0) mode).
+	 * Enable it by doing
+	 * echo enabled > /sys/bus/platform/devices/<usb-phy-id>/power/wakeup
+	 */
+
 	if (device_may_wakeup(dev))
 		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, true);
+
 	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+
 	return 0;
 }
 
-static int am335x_phy_runtime_resume(struct device *dev)
+static int am335x_phy_resume(struct device *dev)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct am335x_phy	*am_phy = platform_get_drvdata(pdev);
 
 	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, true);
+
 	if (device_may_wakeup(dev))
 		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, false);
+
 	return 0;
 }
+#define DEV_PM_OPS     (&am335x_pm_ops)
+#else
+#define DEV_PM_OPS     NULL
+#endif
+
 
 static const struct dev_pm_ops am335x_pm_ops = {
-	SET_RUNTIME_PM_OPS(am335x_phy_runtime_suspend,
-			am335x_phy_runtime_resume, NULL)
+	.suspend = am335x_phy_suspend,
+	.resume = am335x_phy_resume,
 };
 
-#define DEV_PM_OPS	(&am335x_pm_ops)
-#else
-#define DEV_PM_OPS	NULL
-#endif
-
 static const struct of_device_id am335x_phy_ids[] = {
 	{ .compatible = "ti,am335x-usb-phy" },
 	{ }

commit af9f51c5512f9d55972603dd5dd90d0fa300b200
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Oct 24 09:45:29 2013 -0500

    usb: phy: generic: fix how we find out about our resources
    
    instead of having each user of generic phy find
    out about its own resources and pass it to the
    core layer, have th core layer itself figure that
    out. It's as simple as moving a piece of code
    around. This fixes a big regression caused during
    the merge window where am335x-based platforms
    wouldn't be able to probe their PHY driver.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 48d41abd1b6b..0e3c60cb669a 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -52,8 +52,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 		return am_phy->id;
 	}
 
-	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen,
-			USB_PHY_TYPE_USB2, 0, false);
+	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen, NULL);
 	if (ret)
 		return ret;
 

commit 39189c98d161c292e7f80fe50da00d33193362b9
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sun Nov 10 19:37:37 2013 +0100

    usb: phy: remove dead code
    
    Commit [4d175f34: usb: phy: nop: Defer clock prepare until PHY init]
    removed a goto reaching behind a “return ret” at the end of the function
    thus removing the only possible way that statement could be reached, and
    so rendering it a dead code.  This commit cleans it up by removing said
    dead code.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 6370e50649d7..48d41abd1b6b 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -66,8 +66,6 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, am_phy);
 
 	return 0;
-
-	return ret;
 }
 
 static int am335x_phy_remove(struct platform_device *pdev)

commit bd27fa44e13830d2baa278d5702e766380659cb3
Author: Roger Quadros <rogerq@ti.com>
Date:   Tue Sep 24 11:53:48 2013 +0300

    usb: phy: generic: Don't use regulator framework for RESET line
    
    Modelling the RESET line as a regulator supply wasn't a good idea
    as it kind of abuses the regulator framework and also makes adaptation
    code more complex.
    
    Instead, manage the RESET gpio line directly in the driver. Update
    the device tree binding information.
    
    This also makes us easy to migrate to a dedicated GPIO RESET controller
    whenever it becomes available.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index 1495cdc751ad..6370e50649d7 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -53,7 +53,7 @@ static int am335x_phy_probe(struct platform_device *pdev)
 	}
 
 	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen,
-			USB_PHY_TYPE_USB2, 0, false, false);
+			USB_PHY_TYPE_USB2, 0, false);
 	if (ret)
 		return ret;
 

commit b99fffca7ddd46b78322757cfd77e9d2cdcdc7ad
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Sep 30 09:44:46 2013 +0530

    usb: phy: am335x: Remove redundant of_match_ptr
    
    The data structure of_match_ptr() protects is always compiled in.
    Hence of_match_ptr() is not needed.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index f3478a856edb..1495cdc751ad 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -125,7 +125,7 @@ static struct platform_driver am335x_phy_driver = {
 		.name   = "am335x-phy-driver",
 		.owner  = THIS_MODULE,
 		.pm = DEV_PM_OPS,
-		.of_match_table = of_match_ptr(am335x_phy_ids),
+		.of_match_table = am335x_phy_ids,
 	},
 };
 

commit a12226394e7d19734d129766676a5668efd50d5c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Aug 19 12:39:44 2013 +0200

    usb: phy: am335x: add wakeup support
    
    This is based on George Cherian's patch which added power & wakeup
    support to am335x and does no longer apply since I took some if the code
    apart in favor of the multi instance support.
    This compiles and I boots and later it detects a device after I plug it in :)
    Could somebody please test it so it does what it should?
    
    Cc: George Cherian <george.cherian@ti.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index f836dc68104c..f3478a856edb 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -78,6 +78,40 @@ static int am335x_phy_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+
+static int am335x_phy_runtime_suspend(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct am335x_phy *am_phy = platform_get_drvdata(pdev);
+
+	if (device_may_wakeup(dev))
+		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, true);
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+	return 0;
+}
+
+static int am335x_phy_runtime_resume(struct device *dev)
+{
+	struct platform_device	*pdev = to_platform_device(dev);
+	struct am335x_phy	*am_phy = platform_get_drvdata(pdev);
+
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, true);
+	if (device_may_wakeup(dev))
+		phy_ctrl_wkup(am_phy->phy_ctrl, am_phy->id, false);
+	return 0;
+}
+
+static const struct dev_pm_ops am335x_pm_ops = {
+	SET_RUNTIME_PM_OPS(am335x_phy_runtime_suspend,
+			am335x_phy_runtime_resume, NULL)
+};
+
+#define DEV_PM_OPS	(&am335x_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif
+
 static const struct of_device_id am335x_phy_ids[] = {
 	{ .compatible = "ti,am335x-usb-phy" },
 	{ }
@@ -90,6 +124,7 @@ static struct platform_driver am335x_phy_driver = {
 	.driver         = {
 		.name   = "am335x-phy-driver",
 		.owner  = THIS_MODULE,
+		.pm = DEV_PM_OPS,
 		.of_match_table = of_match_ptr(am335x_phy_ids),
 	},
 };

commit 4d175f340c9c055482688d2205038413dc7b6f1e
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Aug 11 15:26:04 2013 +0100

    usb: phy: nop: Defer clock prepare until PHY init
    
    Since we only enable the PHY clock on init and the PHY init and shutdown
    does not occur in atomitc context there is no need to prepare the clock
    before it is enabled.  Move the clk_prepare() operations to go along
    with the enables, allowing the clock to be fully idle when not in use.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
index c4d614d1f173..f836dc68104c 100644
--- a/drivers/usb/phy/phy-am335x.c
+++ b/drivers/usb/phy/phy-am335x.c
@@ -59,15 +59,14 @@ static int am335x_phy_probe(struct platform_device *pdev)
 
 	ret = usb_add_phy_dev(&am_phy->usb_phy_gen.phy);
 	if (ret)
-		goto err_add;
+		return ret;
 	am_phy->usb_phy_gen.phy.init = am335x_init;
 	am_phy->usb_phy_gen.phy.shutdown = am335x_shutdown;
 
 	platform_set_drvdata(pdev, am_phy);
+
 	return 0;
 
-err_add:
-	usb_phy_gen_cleanup_phy(&am_phy->usb_phy_gen);
 	return ret;
 }
 

commit 3bb869c8b3f1a11f1854cd74ebdeb60753614cf8
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Jul 30 21:43:45 2013 +0200

    usb: phy: Add AM335x PHY driver
    
    This driver is a redo of my earlier attempt. It uses parts of the
    generic PHY driver and uses the new control driver for the register
    the phy needs to power on/off the phy. It also enables easy access for
    the wakeup register which is not yet implemented.
    The difference between the omap attempt is:
    - no static holding variable
    - one global visible function which exports a struct with callbacks to
      access the "control" registers.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/phy/phy-am335x.c b/drivers/usb/phy/phy-am335x.c
new file mode 100644
index 000000000000..c4d614d1f173
--- /dev/null
+++ b/drivers/usb/phy/phy-am335x.c
@@ -0,0 +1,99 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/usb_phy_gen_xceiv.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include "am35x-phy-control.h"
+#include "phy-generic.h"
+
+struct am335x_phy {
+	struct usb_phy_gen_xceiv usb_phy_gen;
+	struct phy_control *phy_ctrl;
+	int id;
+};
+
+static int am335x_init(struct usb_phy *phy)
+{
+	struct am335x_phy *am_phy = dev_get_drvdata(phy->dev);
+
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, true);
+	return 0;
+}
+
+static void am335x_shutdown(struct usb_phy *phy)
+{
+	struct am335x_phy *am_phy = dev_get_drvdata(phy->dev);
+
+	phy_ctrl_power(am_phy->phy_ctrl, am_phy->id, false);
+}
+
+static int am335x_phy_probe(struct platform_device *pdev)
+{
+	struct am335x_phy *am_phy;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	am_phy = devm_kzalloc(dev, sizeof(*am_phy), GFP_KERNEL);
+	if (!am_phy)
+		return -ENOMEM;
+
+	am_phy->phy_ctrl = am335x_get_phy_control(dev);
+	if (!am_phy->phy_ctrl)
+		return -EPROBE_DEFER;
+	am_phy->id = of_alias_get_id(pdev->dev.of_node, "phy");
+	if (am_phy->id < 0) {
+		dev_err(&pdev->dev, "Missing PHY id: %d\n", am_phy->id);
+		return am_phy->id;
+	}
+
+	ret = usb_phy_gen_create_phy(dev, &am_phy->usb_phy_gen,
+			USB_PHY_TYPE_USB2, 0, false, false);
+	if (ret)
+		return ret;
+
+	ret = usb_add_phy_dev(&am_phy->usb_phy_gen.phy);
+	if (ret)
+		goto err_add;
+	am_phy->usb_phy_gen.phy.init = am335x_init;
+	am_phy->usb_phy_gen.phy.shutdown = am335x_shutdown;
+
+	platform_set_drvdata(pdev, am_phy);
+	return 0;
+
+err_add:
+	usb_phy_gen_cleanup_phy(&am_phy->usb_phy_gen);
+	return ret;
+}
+
+static int am335x_phy_remove(struct platform_device *pdev)
+{
+	struct am335x_phy *am_phy = platform_get_drvdata(pdev);
+
+	usb_remove_phy(&am_phy->usb_phy_gen.phy);
+	return 0;
+}
+
+static const struct of_device_id am335x_phy_ids[] = {
+	{ .compatible = "ti,am335x-usb-phy" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, am335x_phy_ids);
+
+static struct platform_driver am335x_phy_driver = {
+	.probe          = am335x_phy_probe,
+	.remove         = am335x_phy_remove,
+	.driver         = {
+		.name   = "am335x-phy-driver",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(am335x_phy_ids),
+	},
+};
+
+module_platform_driver(am335x_phy_driver);
+MODULE_LICENSE("GPL v2");
