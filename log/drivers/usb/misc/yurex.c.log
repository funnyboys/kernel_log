commit aafb00a977cf7d81821f7c9d12e04c558c22dc3c
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Oct 9 17:38:48 2019 +0200

    USB: yurex: fix NULL-derefs on disconnect
    
    The driver was using its struct usb_interface pointer as an inverted
    disconnected flag, but was setting it to NULL without making sure all
    code paths that used it were done with it.
    
    Before commit ef61eb43ada6 ("USB: yurex: Fix protection fault after
    device removal") this included the interrupt-in completion handler, but
    there are further accesses in dev_err and dev_dbg statements in
    yurex_write() and the driver-data destructor (sic!).
    
    Fix this by unconditionally stopping also the control URB at disconnect
    and by using a dedicated disconnected flag.
    
    Note that we need to take a reference to the struct usb_interface to
    avoid a use-after-free in the destructor whenever the device was
    disconnected while the character device was still open.
    
    Fixes: aadd6472d904 ("USB: yurex.c: remove dbg() usage")
    Fixes: 45714104b9e8 ("USB: yurex.c: remove err() usage")
    Cc: stable <stable@vger.kernel.org>     # 3.5: ef61eb43ada6
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20191009153848.8664-6-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 8d52d4336c29..be0505b8b5d4 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -60,6 +60,7 @@ struct usb_yurex {
 
 	struct kref		kref;
 	struct mutex		io_mutex;
+	unsigned long		disconnected:1;
 	struct fasync_struct	*async_queue;
 	wait_queue_head_t	waitq;
 
@@ -107,6 +108,7 @@ static void yurex_delete(struct kref *kref)
 				dev->int_buffer, dev->urb->transfer_dma);
 		usb_free_urb(dev->urb);
 	}
+	usb_put_intf(dev->interface);
 	usb_put_dev(dev->udev);
 	kfree(dev);
 }
@@ -205,7 +207,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	init_waitqueue_head(&dev->waitq);
 
 	dev->udev = usb_get_dev(interface_to_usbdev(interface));
-	dev->interface = interface;
+	dev->interface = usb_get_intf(interface);
 
 	/* set up the endpoint information */
 	iface_desc = interface->cur_altsetting;
@@ -316,8 +318,9 @@ static void yurex_disconnect(struct usb_interface *interface)
 
 	/* prevent more I/O from starting */
 	usb_poison_urb(dev->urb);
+	usb_poison_urb(dev->cntl_urb);
 	mutex_lock(&dev->io_mutex);
-	dev->interface = NULL;
+	dev->disconnected = 1;
 	mutex_unlock(&dev->io_mutex);
 
 	/* wakeup waiters */
@@ -405,7 +408,7 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 	dev = file->private_data;
 
 	mutex_lock(&dev->io_mutex);
-	if (!dev->interface) {		/* already disconnected */
+	if (dev->disconnected) {		/* already disconnected */
 		mutex_unlock(&dev->io_mutex);
 		return -ENODEV;
 	}
@@ -440,7 +443,7 @@ static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
 		goto error;
 
 	mutex_lock(&dev->io_mutex);
-	if (!dev->interface) {		/* already disconnected */
+	if (dev->disconnected) {		/* already disconnected */
 		mutex_unlock(&dev->io_mutex);
 		retval = -ENODEV;
 		goto error;

commit 32a0721c6620b77504916dac0cea8ad497c4878a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 17 12:47:23 2019 -0400

    USB: yurex: Don't retry on unexpected errors
    
    According to Greg KH, it has been generally agreed that when a USB
    driver encounters an unknown error (or one it can't handle directly),
    it should just give up instead of going into a potentially infinite
    retry loop.
    
    The three codes -EPROTO, -EILSEQ, and -ETIME fall into this category.
    They can be caused by bus errors such as packet loss or corruption,
    attempting to communicate with a disconnected device, or by malicious
    firmware.  Nowadays the extent of packet loss or corruption is
    negligible, so it should be safe for a driver to give up whenever one
    of these errors occurs.
    
    Although the yurex driver handles -EILSEQ errors in this way, it
    doesn't do the same for -EPROTO (as discovered by the syzbot fuzzer)
    or other unrecognized errors.  This patch adjusts the driver so that
    it doesn't log an error message for -EPROTO or -ETIME, and it doesn't
    retry after any errors.
    
    Reported-and-tested-by: syzbot+b24d736f18a1541ad550@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    CC: <stable@vger.kernel.org>
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1909171245410.1590-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6715a128e6c8..8d52d4336c29 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -132,6 +132,7 @@ static void yurex_interrupt(struct urb *urb)
 	switch (status) {
 	case 0: /*success*/
 		break;
+	/* The device is terminated or messed up, give up */
 	case -EOVERFLOW:
 		dev_err(&dev->interface->dev,
 			"%s - overflow with length %d, actual length is %d\n",
@@ -140,12 +141,13 @@ static void yurex_interrupt(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -EILSEQ:
-		/* The device is terminated, clean up */
+	case -EPROTO:
+	case -ETIME:
 		return;
 	default:
 		dev_err(&dev->interface->dev,
 			"%s - unknown status received: %d\n", __func__, status);
-		goto exit;
+		return;
 	}
 
 	/* handle received message */
@@ -177,7 +179,6 @@ static void yurex_interrupt(struct urb *urb)
 		break;
 	}
 
-exit:
 	retval = usb_submit_urb(dev->urb, GFP_ATOMIC);
 	if (retval) {
 		dev_err(&dev->interface->dev, "%s - usb_submit_urb failed: %d\n",

commit fc05481b2fcabaaeccf63e32ac1baab54e5b6963
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Mon Aug 5 12:15:28 2019 +0100

    usb: yurex: Fix use-after-free in yurex_delete
    
    syzbot reported the following crash [0]:
    
    BUG: KASAN: use-after-free in usb_free_coherent+0x79/0x80
    drivers/usb/core/usb.c:928
    Read of size 8 at addr ffff8881b18599c8 by task syz-executor.4/16007
    
    CPU: 0 PID: 16007 Comm: syz-executor.4 Not tainted 5.3.0-rc2+ #23
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0xca/0x13e lib/dump_stack.c:113
      print_address_description+0x6a/0x32c mm/kasan/report.c:351
      __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482
      kasan_report+0xe/0x12 mm/kasan/common.c:612
      usb_free_coherent+0x79/0x80 drivers/usb/core/usb.c:928
      yurex_delete+0x138/0x330 drivers/usb/misc/yurex.c:100
      kref_put include/linux/kref.h:65 [inline]
      yurex_release+0x66/0x90 drivers/usb/misc/yurex.c:392
      __fput+0x2d7/0x840 fs/file_table.c:280
      task_work_run+0x13f/0x1c0 kernel/task_work.c:113
      tracehook_notify_resume include/linux/tracehook.h:188 [inline]
      exit_to_usermode_loop+0x1d2/0x200 arch/x86/entry/common.c:163
      prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
      syscall_return_slowpath arch/x86/entry/common.c:274 [inline]
      do_syscall_64+0x45f/0x580 arch/x86/entry/common.c:299
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x413511
    Code: 75 14 b8 03 00 00 00 0f 05 48 3d 01 f0 ff ff 0f 83 04 1b 00 00 c3 48
    83 ec 08 e8 0a fc ff ff 48 89 04 24 b8 03 00 00 00 0f 05 <48> 8b 3c 24 48
    89 c2 e8 53 fc ff ff 48 89 d0 48 83 c4 08 48 3d 01
    RSP: 002b:00007ffc424ea2e0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
    RAX: 0000000000000000 RBX: 0000000000000007 RCX: 0000000000413511
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000006
    RBP: 0000000000000001 R08: 0000000029a2fc22 R09: 0000000029a2fc26
    R10: 00007ffc424ea3c0 R11: 0000000000000293 R12: 000000000075c9a0
    R13: 000000000075c9a0 R14: 0000000000761938 R15: ffffffffffffffff
    
    Allocated by task 2776:
      save_stack+0x1b/0x80 mm/kasan/common.c:69
      set_track mm/kasan/common.c:77 [inline]
      __kasan_kmalloc mm/kasan/common.c:487 [inline]
      __kasan_kmalloc.constprop.0+0xbf/0xd0 mm/kasan/common.c:460
      kmalloc include/linux/slab.h:552 [inline]
      kzalloc include/linux/slab.h:748 [inline]
      usb_alloc_dev+0x51/0xf95 drivers/usb/core/usb.c:583
      hub_port_connect drivers/usb/core/hub.c:5004 [inline]
      hub_port_connect_change drivers/usb/core/hub.c:5213 [inline]
      port_event drivers/usb/core/hub.c:5359 [inline]
      hub_event+0x15c0/0x3640 drivers/usb/core/hub.c:5441
      process_one_work+0x92b/0x1530 kernel/workqueue.c:2269
      worker_thread+0x96/0xe20 kernel/workqueue.c:2415
      kthread+0x318/0x420 kernel/kthread.c:255
      ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352
    
    Freed by task 16007:
      save_stack+0x1b/0x80 mm/kasan/common.c:69
      set_track mm/kasan/common.c:77 [inline]
      __kasan_slab_free+0x130/0x180 mm/kasan/common.c:449
      slab_free_hook mm/slub.c:1423 [inline]
      slab_free_freelist_hook mm/slub.c:1470 [inline]
      slab_free mm/slub.c:3012 [inline]
      kfree+0xe4/0x2f0 mm/slub.c:3953
      device_release+0x71/0x200 drivers/base/core.c:1064
      kobject_cleanup lib/kobject.c:693 [inline]
      kobject_release lib/kobject.c:722 [inline]
      kref_put include/linux/kref.h:65 [inline]
      kobject_put+0x171/0x280 lib/kobject.c:739
      put_device+0x1b/0x30 drivers/base/core.c:2213
      usb_put_dev+0x1f/0x30 drivers/usb/core/usb.c:725
      yurex_delete+0x40/0x330 drivers/usb/misc/yurex.c:95
      kref_put include/linux/kref.h:65 [inline]
      yurex_release+0x66/0x90 drivers/usb/misc/yurex.c:392
      __fput+0x2d7/0x840 fs/file_table.c:280
      task_work_run+0x13f/0x1c0 kernel/task_work.c:113
      tracehook_notify_resume include/linux/tracehook.h:188 [inline]
      exit_to_usermode_loop+0x1d2/0x200 arch/x86/entry/common.c:163
      prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
      syscall_return_slowpath arch/x86/entry/common.c:274 [inline]
      do_syscall_64+0x45f/0x580 arch/x86/entry/common.c:299
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    The buggy address belongs to the object at ffff8881b1859980
      which belongs to the cache kmalloc-2k of size 2048
    The buggy address is located 72 bytes inside of
      2048-byte region [ffff8881b1859980, ffff8881b185a180)
    The buggy address belongs to the page:
    page:ffffea0006c61600 refcount:1 mapcount:0 mapping:ffff8881da00c000
    index:0x0 compound_mapcount: 0
    flags: 0x200000000010200(slab|head)
    raw: 0200000000010200 0000000000000000 0000000100000001 ffff8881da00c000
    raw: 0000000000000000 00000000000f000f 00000001ffffffff 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
      ffff8881b1859880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff8881b1859900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    > ffff8881b1859980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                   ^
      ffff8881b1859a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8881b1859a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    ==================================================================
    
    A quick look at the yurex_delete() shows that we drop the reference
    to the usb_device before releasing any buffers associated with the
    device. Delay the reference drop until we have finished the cleanup.
    
    [0] https://lore.kernel.org/lkml/0000000000003f86d8058f0bd671@google.com/
    
    Fixes: 6bc235a2e24a5e ("USB: add driver for Meywa-Denki & Kayac YUREX")
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: Oliver Neukum <oneukum@suse.com>
    Cc: andreyknvl@google.com
    Cc: gregkh@linuxfoundation.org
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: syzkaller-bugs@googlegroups.com
    Cc: dtor@chromium.org
    Reported-by: syzbot+d1fedb1c1fdb07fca507@syzkaller.appspotmail.com
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20190805111528.6758-1-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 7b306aa22d25..6715a128e6c8 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -92,7 +92,6 @@ static void yurex_delete(struct kref *kref)
 
 	dev_dbg(&dev->interface->dev, "%s\n", __func__);
 
-	usb_put_dev(dev->udev);
 	if (dev->cntl_urb) {
 		usb_kill_urb(dev->cntl_urb);
 		kfree(dev->cntl_req);
@@ -108,6 +107,7 @@ static void yurex_delete(struct kref *kref)
 				dev->int_buffer, dev->urb->transfer_dma);
 		usb_free_urb(dev->urb);
 	}
+	usb_put_dev(dev->udev);
 	kfree(dev);
 }
 

commit ef61eb43ada6c1d6b94668f0f514e4c268093ff3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 23 14:48:29 2019 -0400

    USB: yurex: Fix protection fault after device removal
    
    The syzkaller USB fuzzer found a general-protection-fault bug in the
    yurex driver.  The fault occurs when a device has been unplugged; the
    driver's interrupt-URB handler logs an error message referring to the
    device by name, after the device has been unregistered and its name
    deallocated.
    
    This problem is caused by the fact that the interrupt URB isn't
    cancelled until the driver's private data structure is released, which
    can happen long after the device is gone.  The cure is to make sure
    that the interrupt URB is killed before yurex_disconnect() returns;
    this is exactly the sort of thing that usb_poison_urb() was meant for.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: syzbot+2eb9121678bdb36e6d57@syzkaller.appspotmail.com
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6d9fd5f64903..7b306aa22d25 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -314,6 +314,7 @@ static void yurex_disconnect(struct usb_interface *interface)
 	usb_deregister_dev(interface, &yurex_class);
 
 	/* prevent more I/O from starting */
+	usb_poison_urb(dev->urb);
 	mutex_lock(&dev->io_mutex);
 	dev->interface = NULL;
 	mutex_unlock(&dev->io_mutex);

commit 14427b86837a4baf1c121934c6599bdb67dfa9fc
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Wed Aug 15 21:45:37 2018 +0100

    USB: yurex: Check for truncation in yurex_read()
    
    snprintf() always returns the full length of the string it could have
    printed, even if it was truncated because the buffer was too small.
    So in case the counter value is truncated, we will over-read from
    in_buffer and over-write to the caller's buffer.
    
    I don't think it's actually possible for this to happen, but in case
    truncation occurs, WARN and return -EIO.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 1232dd49556d..6d9fd5f64903 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -413,6 +413,9 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 	spin_unlock_irqrestore(&dev->lock, flags);
 	mutex_unlock(&dev->io_mutex);
 
+	if (WARN_ON_ONCE(len >= sizeof(in_buffer)))
+		return -EIO;
+
 	return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);
 }
 

commit 7e10f14ebface44a48275c8d6dc1caae3668d5a9
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Wed Aug 15 21:44:25 2018 +0100

    USB: yurex: Fix buffer over-read in yurex_write()
    
    If the written data starts with a digit, yurex_write() tries to parse
    it as an integer using simple_strtoull().  This requires a null-
    terminator, and currently there's no guarantee that there is one.
    
    (The sample program at
    https://github.com/NeoCat/YUREX-driver-for-Linux/blob/master/sample/yurex_clock.pl
    writes an integer without a null terminator.  It seems like it must
    have worked by chance!)
    
    Always add a null byte after the written data.  Enlarge the buffer
    to allow for this.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 3be40eaa1ac9..1232dd49556d 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -421,13 +421,13 @@ static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
 {
 	struct usb_yurex *dev;
 	int i, set = 0, retval = 0;
-	char buffer[16];
+	char buffer[16 + 1];
 	char *data = buffer;
 	unsigned long long c, c2 = 0;
 	signed long timeout = 0;
 	DEFINE_WAIT(wait);
 
-	count = min(sizeof(buffer), count);
+	count = min(sizeof(buffer) - 1, count);
 	dev = file->private_data;
 
 	/* verify that we actually have some data to write */
@@ -446,6 +446,7 @@ static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
 		retval = -EFAULT;
 		goto error;
 	}
+	buffer[count] = 0;
 	memset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);
 
 	switch (buffer[0]) {

commit f1e255d60ae66a9f672ff9a207ee6cd8e33d2679
Author: Jann Horn <jannh@google.com>
Date:   Fri Jul 6 17:12:56 2018 +0200

    USB: yurex: fix out-of-bounds uaccess in read handler
    
    In general, accessing userspace memory beyond the length of the supplied
    buffer in VFS read/write handlers can lead to both kernel memory corruption
    (via kernel_read()/kernel_write(), which can e.g. be triggered via
    sys_splice()) and privilege escalation inside userspace.
    
    Fix it by using simple_read_from_buffer() instead of custom logic.
    
    Fixes: 6bc235a2e24a ("USB: add driver for Meywa-Denki & Kayac YUREX")
    Signed-off-by: Jann Horn <jannh@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 8abb6cbbd98a..3be40eaa1ac9 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -396,8 +396,7 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 			  loff_t *ppos)
 {
 	struct usb_yurex *dev;
-	int retval = 0;
-	int bytes_read = 0;
+	int len = 0;
 	char in_buffer[20];
 	unsigned long flags;
 
@@ -405,26 +404,16 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 
 	mutex_lock(&dev->io_mutex);
 	if (!dev->interface) {		/* already disconnected */
-		retval = -ENODEV;
-		goto exit;
+		mutex_unlock(&dev->io_mutex);
+		return -ENODEV;
 	}
 
 	spin_lock_irqsave(&dev->lock, flags);
-	bytes_read = snprintf(in_buffer, 20, "%lld\n", dev->bbu);
+	len = snprintf(in_buffer, 20, "%lld\n", dev->bbu);
 	spin_unlock_irqrestore(&dev->lock, flags);
-
-	if (*ppos < bytes_read) {
-		if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
-			retval = -EFAULT;
-		else {
-			retval = bytes_read - *ppos;
-			*ppos += bytes_read;
-		}
-	}
-
-exit:
 	mutex_unlock(&dev->io_mutex);
-	return retval;
+
+	return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);
 }
 
 static ssize_t yurex_write(struct file *file, const char __user *user_buffer,

commit 5d62afbe9572138a25d67b8468d27ec65777824d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:58 2017 +0100

    USB: misc: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 1aec1d25ee44..8abb6cbbd98a 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -3,11 +3,6 @@
  * Driver for Meywa-Denki & KAYAC YUREX
  *
  * Copyright (C) 2010 Tomoki Sekiyama (tomoki.sekiyama@gmail.com)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation, version 2.
- *
  */
 
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 58abdf28620a..1aec1d25ee44 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Driver for Meywa-Denki & KAYAC YUREX
  *

commit 499841e678f911f894b2ef0cc4a6350bf11b15c6
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Mar 17 11:35:45 2017 +0100

    USB: yurex: refactor endpoint retrieval
    
    Use the new endpoint helpers to lookup the required interrupt-in
    endpoint.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 54e53ac4c08f..58abdf28620a 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -195,8 +195,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor *endpoint;
 	int retval = -ENOMEM;
-	int i;
 	DEFINE_WAIT(wait);
+	int res;
 
 	/* allocate memory for our device state and initialize it */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
@@ -212,20 +212,14 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* set up the endpoint information */
 	iface_desc = interface->cur_altsetting;
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
-		endpoint = &iface_desc->endpoint[i].desc;
-
-		if (usb_endpoint_is_int_in(endpoint)) {
-			dev->int_in_endpointAddr = endpoint->bEndpointAddress;
-			break;
-		}
-	}
-	if (!dev->int_in_endpointAddr) {
-		retval = -ENODEV;
+	res = usb_find_int_in_endpoint(iface_desc, &endpoint);
+	if (res) {
 		dev_err(&interface->dev, "Could not find endpoints\n");
+		retval = res;
 		goto error;
 	}
 
+	dev->int_in_endpointAddr = endpoint->bEndpointAddress;
 
 	/* allocate control URB */
 	dev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);

commit 0c2bc5c2cb267c41f073132d1817df917ab8ba47
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 25 19:39:25 2016 +0200

    usb: misc: yurex: don't print on ENOMEM
    
    All kmalloc-based functions print enough information on failures.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index bb606bdc25e5..54e53ac4c08f 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -200,10 +200,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* allocate memory for our device state and initialize it */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		dev_err(&interface->dev, "Out of memory\n");
+	if (!dev)
 		goto error;
-	}
 	kref_init(&dev->kref);
 	mutex_init(&dev->io_mutex);
 	spin_lock_init(&dev->lock);
@@ -236,10 +234,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* allocate buffer for control req */
 	dev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);
-	if (!dev->cntl_req) {
-		dev_err(&interface->dev, "Could not allocate cntl_req\n");
+	if (!dev->cntl_req)
 		goto error;
-	}
 
 	/* allocate buffer for control msg */
 	dev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,

commit 0450ba4069226a16b2fb979fdb24a3ad60634933
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 11 23:14:45 2016 +0200

    usb: misc: yurex: don't print error when allocating urb fails
    
    kmalloc will print enough information in case of failure.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 343fa6ff9f4b..bb606bdc25e5 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -231,10 +231,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* allocate control URB */
 	dev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!dev->cntl_urb) {
-		dev_err(&interface->dev, "Could not allocate control URB\n");
+	if (!dev->cntl_urb)
 		goto error;
-	}
 
 	/* allocate buffer for control req */
 	dev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);
@@ -269,10 +267,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* allocate interrupt URB */
 	dev->urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!dev->urb) {
-		dev_err(&interface->dev, "Could not allocate URB\n");
+	if (!dev->urb)
 		goto error;
-	}
 
 	/* allocate buffer for interrupt in */
 	dev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,

commit 1cc373c654acde47d78da9cccb5732dab2cc584f
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Oct 10 18:19:45 2014 +0530

    usb: yurex: fixed sparse warning of incorrect type
    
    fixed sparse warning of
            1) incorrect type (different address spaces)
            2) incorrect type in initializer
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index c3a45da11610..343fa6ff9f4b 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -410,7 +410,8 @@ static int yurex_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static ssize_t yurex_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
+			  loff_t *ppos)
 {
 	struct usb_yurex *dev;
 	int retval = 0;
@@ -444,7 +445,8 @@ static ssize_t yurex_read(struct file *file, char *buffer, size_t count, loff_t
 	return retval;
 }
 
-static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t count, loff_t *ppos)
+static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
+			   size_t count, loff_t *ppos)
 {
 	struct usb_yurex *dev;
 	int i, set = 0, retval = 0;

commit 113ad911ad4a1ccbd0eaf6926b75b0ec77510c14
Author: Arjun Sreedharan <arjun024@gmail.com>
Date:   Tue Aug 19 04:23:34 2014 +0530

    usb: misc: yurex: remove useless casting of private_data
    
    Signed-off-by: Arjun Sreedharan <arjun024@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 1472805083de..c3a45da11610 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -358,7 +358,7 @@ static int yurex_fasync(int fd, struct file *file, int on)
 {
 	struct usb_yurex *dev;
 
-	dev = (struct usb_yurex *)file->private_data;
+	dev = file->private_data;
 	return fasync_helper(fd, file, on, &dev->async_queue);
 }
 
@@ -401,7 +401,7 @@ static int yurex_release(struct inode *inode, struct file *file)
 {
 	struct usb_yurex *dev;
 
-	dev = (struct usb_yurex *)file->private_data;
+	dev = file->private_data;
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -418,7 +418,7 @@ static ssize_t yurex_read(struct file *file, char *buffer, size_t count, loff_t
 	char in_buffer[20];
 	unsigned long flags;
 
-	dev = (struct usb_yurex *)file->private_data;
+	dev = file->private_data;
 
 	mutex_lock(&dev->io_mutex);
 	if (!dev->interface) {		/* already disconnected */
@@ -455,7 +455,7 @@ static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t co
 	DEFINE_WAIT(wait);
 
 	count = min(sizeof(buffer), count);
-	dev = (struct usb_yurex *)file->private_data;
+	dev = file->private_data;
 
 	/* verify that we actually have some data to write */
 	if (count == 0)

commit c78d1ecfd7e639f21c7a809f4df6de1a644a91f0
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon May 19 13:52:20 2014 +0200

    USB: yurex: fix race between probe() and read()
    
    There's a window during which read() would return 0 instead
    of a correct error for no data yet. Reorder initialization
    to fix the race.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 24278208bf74..1472805083de 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -296,6 +296,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 
 	/* save our data pointer in this interface device */
 	usb_set_intfdata(interface, dev);
+	dev->bbu = -1;
 
 	/* we can register the device now, as it is ready */
 	retval = usb_register_dev(interface, &yurex_class);
@@ -306,8 +307,6 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 		goto error;
 	}
 
-	dev->bbu = -1;
-
 	dev_info(&interface->dev,
 		 "USB YUREX device now attached to Yurex #%d\n",
 		 interface->minor);

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 0609114c48a7..24278208bf74 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -11,7 +11,6 @@
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/kref.h>

commit 3fb4c07a52d7d0bf7d880538c11629e69fc8be2e
Author: Rahul Bedarkar <rahulbedarkar89@gmail.com>
Date:   Mon Dec 30 20:49:19 2013 +0530

    USB: yurex: fix spelling mistake in comment
    
    fix spelling mistake in comment
    
    Signed-off-by: Rahul Bedarkar <rahulbedarkar89@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index b6ab515bfc6c..0609114c48a7 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -464,7 +464,7 @@ static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t co
 		goto error;
 
 	mutex_lock(&dev->io_mutex);
-	if (!dev->interface) {		/* alreaday disconnected */
+	if (!dev->interface) {		/* already disconnected */
 		mutex_unlock(&dev->io_mutex);
 		retval = -ENODEV;
 		goto error;

commit 3dce1891f3e4c334046b32c355b9e5cef50c18d9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 14 21:23:06 2013 -0400

    yurex: don't wank with fasync on ->release()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 42ad2e6d86c4..b6ab515bfc6c 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -407,8 +407,6 @@ static int yurex_release(struct inode *inode, struct file *file)
 	if (dev == NULL)
 		return -ENODEV;
 
-	yurex_fasync(-1, file, 0);
-
 	/* decrement the count on our device */
 	kref_put(&dev->kref, yurex_delete);
 	return 0;

commit aadd6472d904c374e31c952fbf634e21e28807e0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 1 21:34:11 2012 -0700

    USB: yurex.c: remove dbg() usage
    
    dbg() was a very old USB-specific macro that should no longer
    be used. This patch removes it from being used in the driver
    and uses dev_dbg() instead.
    
    CC: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 1d8ad4c5b99e..42ad2e6d86c4 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -95,7 +95,7 @@ static void yurex_delete(struct kref *kref)
 {
 	struct usb_yurex *dev = to_yurex_dev(kref);
 
-	dbg("yurex_delete");
+	dev_dbg(&dev->interface->dev, "%s\n", __func__);
 
 	usb_put_dev(dev->udev);
 	if (dev->cntl_urb) {
@@ -165,16 +165,19 @@ static void yurex_interrupt(struct urb *urb)
 				if (i != 5)
 					dev->bbu <<= 8;
 			}
-			dbg("%s count: %lld", __func__, dev->bbu);
+			dev_dbg(&dev->interface->dev, "%s count: %lld\n",
+				__func__, dev->bbu);
 			spin_unlock_irqrestore(&dev->lock, flags);
 
 			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
 		}
 		else
-			dbg("data format error - no EOF");
+			dev_dbg(&dev->interface->dev,
+				"data format error - no EOF\n");
 		break;
 	case CMD_ACK:
-		dbg("%s ack: %c", __func__, buf[1]);
+		dev_dbg(&dev->interface->dev, "%s ack: %c\n",
+			__func__, buf[1]);
 		wake_up_interruptible(&dev->waitq);
 		break;
 	}
@@ -509,7 +512,8 @@ static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t co
 
 	/* send the data as the control msg */
 	prepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);
-	dbg("%s - submit %c", __func__, dev->cntl_buffer[0]);
+	dev_dbg(&dev->interface->dev, "%s - submit %c\n", __func__,
+		dev->cntl_buffer[0]);
 	retval = usb_submit_urb(dev->cntl_urb, GFP_KERNEL);
 	if (retval >= 0)
 		timeout = schedule_timeout(YUREX_WRITE_TIMEOUT);

commit 09091a4d5f2dd378dcf71de50b48cdacc58a8ac0
Merge: 66f75a5d028b 3a1c2a82204f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 22 15:25:26 2012 -0700

    Merge 3.4-rc4 into usb-next.
    
    This resolves the conflict in:
            drivers/usb/host/ehci-fsl.c
    And picks up loads of xhci bugfixes to make it easier for others to test
    with.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 45714104b9e85ffa199c5622e227657e99d92fb5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 20 16:53:56 2012 -0700

    USB: yurex.c: remove err() usage
    
    err() was a very old USB-specific macro that I thought had
    gone away.  This patch removes it from being used in the
    driver and uses dev_err() instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 897edda42270..e0388dc0a55e 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -83,7 +83,8 @@ static void yurex_control_callback(struct urb *urb)
 	int status = urb->status;
 
 	if (status) {
-		err("%s - control failed: %d\n", __func__, status);
+		dev_err(&urb->dev->dev, "%s - control failed: %d\n",
+			__func__, status);
 		wake_up_interruptible(&dev->waitq);
 		return;
 	}
@@ -139,8 +140,9 @@ static void yurex_interrupt(struct urb *urb)
 	case 0: /*success*/
 		break;
 	case -EOVERFLOW:
-		err("%s - overflow with length %d, actual length is %d",
-		    __func__, YUREX_BUF_SIZE, dev->urb->actual_length);
+		dev_err(&dev->interface->dev,
+			"%s - overflow with length %d, actual length is %d\n",
+			__func__, YUREX_BUF_SIZE, dev->urb->actual_length);
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
@@ -148,7 +150,8 @@ static void yurex_interrupt(struct urb *urb)
 		/* The device is terminated, clean up */
 		return;
 	default:
-		err("%s - unknown status received: %d", __func__, status);
+		dev_err(&dev->interface->dev,
+			"%s - unknown status received: %d\n", __func__, status);
 		goto exit;
 	}
 
@@ -181,7 +184,7 @@ static void yurex_interrupt(struct urb *urb)
 exit:
 	retval = usb_submit_urb(dev->urb, GFP_ATOMIC);
 	if (retval) {
-		err("%s - usb_submit_urb failed: %d",
+		dev_err(&dev->interface->dev, "%s - usb_submit_urb failed: %d\n",
 			__func__, retval);
 	}
 }
@@ -198,7 +201,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	/* allocate memory for our device state and initialize it */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
-		err("Out of memory");
+		dev_err(&interface->dev, "Out of memory\n");
 		goto error;
 	}
 	kref_init(&dev->kref);
@@ -221,7 +224,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	}
 	if (!dev->int_in_endpointAddr) {
 		retval = -ENODEV;
-		err("Could not find endpoints");
+		dev_err(&interface->dev, "Could not find endpoints\n");
 		goto error;
 	}
 
@@ -229,7 +232,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	/* allocate control URB */
 	dev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!dev->cntl_urb) {
-		err("Could not allocate control URB");
+		dev_err(&interface->dev, "Could not allocate control URB\n");
 		goto error;
 	}
 
@@ -238,7 +241,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 					   GFP_KERNEL,
 					   &dev->cntl_urb->setup_dma);
 	if (!dev->cntl_req) {
-		err("Could not allocate cntl_req");
+		dev_err(&interface->dev, "Could not allocate cntl_req\n");
 		goto error;
 	}
 
@@ -247,7 +250,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 					      GFP_KERNEL,
 					      &dev->cntl_urb->transfer_dma);
 	if (!dev->cntl_buffer) {
-		err("Could not allocate cntl_buffer");
+		dev_err(&interface->dev, "Could not allocate cntl_buffer\n");
 		goto error;
 	}
 
@@ -269,7 +272,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	/* allocate interrupt URB */
 	dev->urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!dev->urb) {
-		err("Could not allocate URB");
+		dev_err(&interface->dev, "Could not allocate URB\n");
 		goto error;
 	}
 
@@ -277,7 +280,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	dev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,
 					GFP_KERNEL, &dev->urb->transfer_dma);
 	if (!dev->int_buffer) {
-		err("Could not allocate int_buffer");
+		dev_err(&interface->dev, "Could not allocate int_buffer\n");
 		goto error;
 	}
 
@@ -289,7 +292,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	dev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	if (usb_submit_urb(dev->urb, GFP_KERNEL)) {
 		retval = -EIO;
-		err("Could not submitting URB");
+		dev_err(&interface->dev, "Could not submitting URB\n");
 		goto error;
 	}
 
@@ -299,7 +302,8 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	/* we can register the device now, as it is ready */
 	retval = usb_register_dev(interface, &yurex_class);
 	if (retval) {
-		err("Not able to get a minor for this device.");
+		dev_err(&interface->dev,
+			"Not able to get a minor for this device.\n");
 		usb_set_intfdata(interface, NULL);
 		goto error;
 	}
@@ -372,8 +376,8 @@ static int yurex_open(struct inode *inode, struct file *file)
 
 	interface = usb_find_interface(&yurex_driver, subminor);
 	if (!interface) {
-		err("%s - error, can't find device for minor %d",
-		    __func__, subminor);
+		printk(KERN_ERR "%s - error, can't find device for minor %d",
+		       __func__, subminor);
 		retval = -ENODEV;
 		goto exit;
 	}
@@ -518,7 +522,9 @@ static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t co
 	mutex_unlock(&dev->io_mutex);
 
 	if (retval < 0) {
-		err("%s - failed to send bulk msg, error %d", __func__, retval);
+		dev_err(&dev->interface->dev,
+			"%s - failed to send bulk msg, error %d\n",
+			__func__, retval);
 		goto error;
 	}
 	if (set && timeout)

commit 532f17b5d59bf0deb6f1ff9bc1fb27d5b5011c09
Author: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
Date:   Fri Mar 30 08:51:36 2012 +0900

    USB: yurex: Fix missing URB_NO_TRANSFER_DMA_MAP flag in urb
    
    Current probing code is setting URB_NO_TRANSFER_DMA_MAP flag into a wrong urb
    structure, and this causes BUG_ON with some USB host implementations.
    This patch fixes the issue.
    
    Signed-off-by: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index a4a76fcd41cd..70201462e19c 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -282,7 +282,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 			 usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),
 			 dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,
 			 dev, 1);
-	dev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+	dev->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	if (usb_submit_urb(dev->urb, GFP_KERNEL)) {
 		retval = -EIO;
 		err("Could not submitting URB");

commit 523fc5c14f6cad283e5a266eba0e343aed6e73d5
Author: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
Date:   Fri Mar 30 08:51:28 2012 +0900

    USB: yurex: Remove allocation of coherent buffer for setup-packet buffer
    
    Removes allocation of coherent buffer for the control-request setup-packet
    buffer from the yurex driver. Using coherent buffers for setup-packet is
    obsolete and does not work with some USB host implementations.
    
    Signed-off-by: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 897edda42270..a4a76fcd41cd 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -99,9 +99,7 @@ static void yurex_delete(struct kref *kref)
 	usb_put_dev(dev->udev);
 	if (dev->cntl_urb) {
 		usb_kill_urb(dev->cntl_urb);
-		if (dev->cntl_req)
-			usb_free_coherent(dev->udev, YUREX_BUF_SIZE,
-				dev->cntl_req, dev->cntl_urb->setup_dma);
+		kfree(dev->cntl_req);
 		if (dev->cntl_buffer)
 			usb_free_coherent(dev->udev, YUREX_BUF_SIZE,
 				dev->cntl_buffer, dev->cntl_urb->transfer_dma);
@@ -234,9 +232,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	}
 
 	/* allocate buffer for control req */
-	dev->cntl_req = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,
-					   GFP_KERNEL,
-					   &dev->cntl_urb->setup_dma);
+	dev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);
 	if (!dev->cntl_req) {
 		err("Could not allocate cntl_req");
 		goto error;

commit 65db43054065790a75291b0834657445fea2cf56
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 18 09:34:02 2011 -0800

    USB: convert drivers/usb/* to use module_usb_driver()
    
    This converts the drivers in drivers/usb/* to use the
    module_usb_driver() macro which makes the code smaller and a bit
    simpler.
    
    Added bonus is that it removes some unneeded kernel log messages about
    drivers loading and/or unloading.
    
    Cc: Simon Arlott <cxacru@fire.lp0.eu>
    Cc: Duncan Sands <duncan.sands@free.fr>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Stanislaw Gruszka <stf_xl@wp.pl>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Michael Hund <mhund@ld-didactic.de>
    Cc: Zack Parsons <k3bacon@gmail.com>
    Cc: Melchior FRANZ <mfranz@aon.at>
    Cc: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index ac5bfd619e62..897edda42270 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -539,26 +539,6 @@ static const struct file_operations yurex_fops = {
 	.llseek =	default_llseek,
 };
 
-
-static int __init usb_yurex_init(void)
-{
-	int result;
-
-	/* register this driver with the USB subsystem */
-	result = usb_register(&yurex_driver);
-	if (result)
-		err("usb_register failed. Error number %d", result);
-
-	return result;
-}
-
-static void __exit usb_yurex_exit(void)
-{
-	/* deregister this driver with the USB subsystem */
-	usb_deregister(&yurex_driver);
-}
-
-module_init(usb_yurex_init);
-module_exit(usb_yurex_exit);
+module_usb_driver(yurex_driver);
 
 MODULE_LICENSE("GPL");

commit 27f485b5b27926878ffc8f528bdefeb25e6bd3d3
Author: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
Date:   Mon Nov 22 19:29:23 2010 +0900

    USB: yurex: add .llseek fop to file_operations
    
    Default llseek operation behavior was changed by the patch named
    "vfs: make no_llseek the default" after the yurex driver had been merged,
    so the llseek to yurex is now ignored.
    
    This patch add llseek fop with default_llseek to yurex driver
    to catch up to the change.
    
    Signed-off-by: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 719c6180b31f..ac5bfd619e62 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -536,6 +536,7 @@ static const struct file_operations yurex_fops = {
 	.open =		yurex_open,
 	.release =	yurex_release,
 	.fasync	=	yurex_fasync,
+	.llseek =	default_llseek,
 };
 
 

commit e06ea97fa47611992a5a61058729cf8e83bf6fda
Author: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
Date:   Sun Oct 3 06:59:06 2010 +0900

    USB: yurex: fix memory leak and corrupted messages
    
    This fixes the memory leak on disconnecting the device.
    In addition, it fixes some messages corrupted by incorrect encoding.
    
    Signed-off-by: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 5f6443bc6142..719c6180b31f 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -37,7 +37,7 @@
 #define CMD_PADDING	0xff
 
 #define YUREX_BUF_SIZE		8
-#define YUREX_WRITE_TIMEOUT	(HZ)
+#define YUREX_WRITE_TIMEOUT	(HZ*2)
 
 /* table of devices that work with this driver */
 static struct usb_device_id yurex_table[] = {
@@ -83,7 +83,7 @@ static void yurex_control_callback(struct urb *urb)
 	int status = urb->status;
 
 	if (status) {
-		err("%s - control failed: %d¥n", __func__, status);
+		err("%s - control failed: %d\n", __func__, status);
 		wake_up_interruptible(&dev->waitq);
 		return;
 	}
@@ -97,6 +97,16 @@ static void yurex_delete(struct kref *kref)
 	dbg("yurex_delete");
 
 	usb_put_dev(dev->udev);
+	if (dev->cntl_urb) {
+		usb_kill_urb(dev->cntl_urb);
+		if (dev->cntl_req)
+			usb_free_coherent(dev->udev, YUREX_BUF_SIZE,
+				dev->cntl_req, dev->cntl_urb->setup_dma);
+		if (dev->cntl_buffer)
+			usb_free_coherent(dev->udev, YUREX_BUF_SIZE,
+				dev->cntl_buffer, dev->cntl_urb->transfer_dma);
+		usb_free_urb(dev->cntl_urb);
+	}
 	if (dev->urb) {
 		usb_kill_urb(dev->urb);
 		if (dev->int_buffer)
@@ -253,7 +263,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 			     usb_sndctrlpipe(dev->udev, 0),
 			     (void *)dev->cntl_req, dev->cntl_buffer,
 			     YUREX_BUF_SIZE, yurex_control_callback, dev);
-	dev->cntl_urb->transfer_flags	|= URB_NO_TRANSFER_DMA_MAP;
+	dev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 
 	/* allocate interrupt URB */
@@ -276,6 +286,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 			 usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),
 			 dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,
 			 dev, 1);
+	dev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	if (usb_submit_urb(dev->urb, GFP_KERNEL)) {
 		retval = -EIO;
 		err("Could not submitting URB");
@@ -296,7 +307,7 @@ static int yurex_probe(struct usb_interface *interface, const struct usb_device_
 	dev->bbu = -1;
 
 	dev_info(&interface->dev,
-		 "USB Yurex device now attached to Yurex-%d¥n",
+		 "USB YUREX device now attached to Yurex #%d\n",
 		 interface->minor);
 
 	return 0;
@@ -331,7 +342,7 @@ static void yurex_disconnect(struct usb_interface *interface)
 	/* decrement our usage count */
 	kref_put(&dev->kref, yurex_delete);
 
-	dev_info(&interface->dev, "USB Yurex #%d now disconnected", minor);
+	dev_info(&interface->dev, "USB YUREX #%d now disconnected\n", minor);
 }
 
 static struct usb_driver yurex_driver = {
@@ -417,7 +428,7 @@ static ssize_t yurex_read(struct file *file, char *buffer, size_t count, loff_t
 	}
 
 	spin_lock_irqsave(&dev->lock, flags);
-	bytes_read = snprintf(in_buffer, 20, "%lld¥n", dev->bbu);
+	bytes_read = snprintf(in_buffer, 20, "%lld\n", dev->bbu);
 	spin_unlock_irqrestore(&dev->lock, flags);
 
 	if (*ppos < bytes_read) {

commit 1b62d2583963d5974974aa923214bada7aa7b5d1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 30 05:01:22 2010 -0700

    USB: yurex: assign a real minor number to the driver
    
    This assigns the minor number 192 to the yurex driver.
    
    We also fix up the previous usb minor number entry, it was wrong.
    
    Cc: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 76b8ab47fe04..5f6443bc6142 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -47,9 +47,9 @@ static struct usb_device_id yurex_table[] = {
 MODULE_DEVICE_TABLE(usb, yurex_table);
 
 #ifdef CONFIG_USB_DYNAMIC_MINORS
-#define YUREX_MINOR_BASE       0
+#define YUREX_MINOR_BASE	0
 #else
-#define YUREX_MINOR_BASE       224  /* not official yet */
+#define YUREX_MINOR_BASE	192
 #endif
 
 /* Structure to hold all of our device specific stuff */

commit 6bc235a2e24a5ef677daee3fd4f74f6cd643e23c
Author: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
Date:   Wed Sep 29 12:16:50 2010 +0900

    USB: add driver for Meywa-Denki & Kayac YUREX
    
    Meywa-Denki/Kayac YUREX is a leg-shakes sensor device.
    See http://bbu.kayac.com/en/about/ for further information.
    This driver support read/write the leg-shakes counter in the device
    via a device file /dev/yurex[0-9]*.
    
    [minor coding style cleanups fixed by gregkh]
    
    Signed-off-by: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
new file mode 100644
index 000000000000..76b8ab47fe04
--- /dev/null
+++ b/drivers/usb/misc/yurex.c
@@ -0,0 +1,552 @@
+/*
+ * Driver for Meywa-Denki & KAYAC YUREX
+ *
+ * Copyright (C) 2010 Tomoki Sekiyama (tomoki.sekiyama@gmail.com)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/hid.h>
+
+#define DRIVER_AUTHOR "Tomoki Sekiyama"
+#define DRIVER_DESC "Driver for Meywa-Denki & KAYAC YUREX"
+
+#define YUREX_VENDOR_ID		0x0c45
+#define YUREX_PRODUCT_ID	0x1010
+
+#define CMD_ACK		'!'
+#define CMD_ANIMATE	'A'
+#define CMD_COUNT	'C'
+#define CMD_LED		'L'
+#define CMD_READ	'R'
+#define CMD_SET		'S'
+#define CMD_VERSION	'V'
+#define CMD_EOF		0x0d
+#define CMD_PADDING	0xff
+
+#define YUREX_BUF_SIZE		8
+#define YUREX_WRITE_TIMEOUT	(HZ)
+
+/* table of devices that work with this driver */
+static struct usb_device_id yurex_table[] = {
+	{ USB_DEVICE(YUREX_VENDOR_ID, YUREX_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, yurex_table);
+
+#ifdef CONFIG_USB_DYNAMIC_MINORS
+#define YUREX_MINOR_BASE       0
+#else
+#define YUREX_MINOR_BASE       224  /* not official yet */
+#endif
+
+/* Structure to hold all of our device specific stuff */
+struct usb_yurex {
+	struct usb_device	*udev;
+	struct usb_interface	*interface;
+	__u8			int_in_endpointAddr;
+	struct urb		*urb;		/* URB for interrupt in */
+	unsigned char           *int_buffer;	/* buffer for intterupt in */
+	struct urb		*cntl_urb;	/* URB for control msg */
+	struct usb_ctrlrequest	*cntl_req;	/* req for control msg */
+	unsigned char		*cntl_buffer;	/* buffer for control msg */
+
+	struct kref		kref;
+	struct mutex		io_mutex;
+	struct fasync_struct	*async_queue;
+	wait_queue_head_t	waitq;
+
+	spinlock_t		lock;
+	__s64			bbu;		/* BBU from device */
+};
+#define to_yurex_dev(d) container_of(d, struct usb_yurex, kref)
+
+static struct usb_driver yurex_driver;
+static const struct file_operations yurex_fops;
+
+
+static void yurex_control_callback(struct urb *urb)
+{
+	struct usb_yurex *dev = urb->context;
+	int status = urb->status;
+
+	if (status) {
+		err("%s - control failed: %d¥n", __func__, status);
+		wake_up_interruptible(&dev->waitq);
+		return;
+	}
+	/* on success, sender woken up by CMD_ACK int in, or timeout */
+}
+
+static void yurex_delete(struct kref *kref)
+{
+	struct usb_yurex *dev = to_yurex_dev(kref);
+
+	dbg("yurex_delete");
+
+	usb_put_dev(dev->udev);
+	if (dev->urb) {
+		usb_kill_urb(dev->urb);
+		if (dev->int_buffer)
+			usb_free_coherent(dev->udev, YUREX_BUF_SIZE,
+				dev->int_buffer, dev->urb->transfer_dma);
+		usb_free_urb(dev->urb);
+	}
+	kfree(dev);
+}
+
+/*
+ * usb class driver info in order to get a minor number from the usb core,
+ * and to have the device registered with the driver core
+ */
+static struct usb_class_driver yurex_class = {
+	.name =		"yurex%d",
+	.fops =		&yurex_fops,
+	.minor_base =	YUREX_MINOR_BASE,
+};
+
+static void yurex_interrupt(struct urb *urb)
+{
+	struct usb_yurex *dev = urb->context;
+	unsigned char *buf = dev->int_buffer;
+	int status = urb->status;
+	unsigned long flags;
+	int retval, i;
+
+	switch (status) {
+	case 0: /*success*/
+		break;
+	case -EOVERFLOW:
+		err("%s - overflow with length %d, actual length is %d",
+		    __func__, YUREX_BUF_SIZE, dev->urb->actual_length);
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EILSEQ:
+		/* The device is terminated, clean up */
+		return;
+	default:
+		err("%s - unknown status received: %d", __func__, status);
+		goto exit;
+	}
+
+	/* handle received message */
+	switch (buf[0]) {
+	case CMD_COUNT:
+	case CMD_READ:
+		if (buf[6] == CMD_EOF) {
+			spin_lock_irqsave(&dev->lock, flags);
+			dev->bbu = 0;
+			for (i = 1; i < 6; i++) {
+				dev->bbu += buf[i];
+				if (i != 5)
+					dev->bbu <<= 8;
+			}
+			dbg("%s count: %lld", __func__, dev->bbu);
+			spin_unlock_irqrestore(&dev->lock, flags);
+
+			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+		}
+		else
+			dbg("data format error - no EOF");
+		break;
+	case CMD_ACK:
+		dbg("%s ack: %c", __func__, buf[1]);
+		wake_up_interruptible(&dev->waitq);
+		break;
+	}
+
+exit:
+	retval = usb_submit_urb(dev->urb, GFP_ATOMIC);
+	if (retval) {
+		err("%s - usb_submit_urb failed: %d",
+			__func__, retval);
+	}
+}
+
+static int yurex_probe(struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_yurex *dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	int retval = -ENOMEM;
+	int i;
+	DEFINE_WAIT(wait);
+
+	/* allocate memory for our device state and initialize it */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		err("Out of memory");
+		goto error;
+	}
+	kref_init(&dev->kref);
+	mutex_init(&dev->io_mutex);
+	spin_lock_init(&dev->lock);
+	init_waitqueue_head(&dev->waitq);
+
+	dev->udev = usb_get_dev(interface_to_usbdev(interface));
+	dev->interface = interface;
+
+	/* set up the endpoint information */
+	iface_desc = interface->cur_altsetting;
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		if (usb_endpoint_is_int_in(endpoint)) {
+			dev->int_in_endpointAddr = endpoint->bEndpointAddress;
+			break;
+		}
+	}
+	if (!dev->int_in_endpointAddr) {
+		retval = -ENODEV;
+		err("Could not find endpoints");
+		goto error;
+	}
+
+
+	/* allocate control URB */
+	dev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->cntl_urb) {
+		err("Could not allocate control URB");
+		goto error;
+	}
+
+	/* allocate buffer for control req */
+	dev->cntl_req = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,
+					   GFP_KERNEL,
+					   &dev->cntl_urb->setup_dma);
+	if (!dev->cntl_req) {
+		err("Could not allocate cntl_req");
+		goto error;
+	}
+
+	/* allocate buffer for control msg */
+	dev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,
+					      GFP_KERNEL,
+					      &dev->cntl_urb->transfer_dma);
+	if (!dev->cntl_buffer) {
+		err("Could not allocate cntl_buffer");
+		goto error;
+	}
+
+	/* configure control URB */
+	dev->cntl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |
+				      USB_RECIP_INTERFACE;
+	dev->cntl_req->bRequest	= HID_REQ_SET_REPORT;
+	dev->cntl_req->wValue	= cpu_to_le16((HID_OUTPUT_REPORT + 1) << 8);
+	dev->cntl_req->wIndex	= cpu_to_le16(iface_desc->desc.bInterfaceNumber);
+	dev->cntl_req->wLength	= cpu_to_le16(YUREX_BUF_SIZE);
+
+	usb_fill_control_urb(dev->cntl_urb, dev->udev,
+			     usb_sndctrlpipe(dev->udev, 0),
+			     (void *)dev->cntl_req, dev->cntl_buffer,
+			     YUREX_BUF_SIZE, yurex_control_callback, dev);
+	dev->cntl_urb->transfer_flags	|= URB_NO_TRANSFER_DMA_MAP;
+
+
+	/* allocate interrupt URB */
+	dev->urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->urb) {
+		err("Could not allocate URB");
+		goto error;
+	}
+
+	/* allocate buffer for interrupt in */
+	dev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,
+					GFP_KERNEL, &dev->urb->transfer_dma);
+	if (!dev->int_buffer) {
+		err("Could not allocate int_buffer");
+		goto error;
+	}
+
+	/* configure interrupt URB */
+	usb_fill_int_urb(dev->urb, dev->udev,
+			 usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),
+			 dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,
+			 dev, 1);
+	if (usb_submit_urb(dev->urb, GFP_KERNEL)) {
+		retval = -EIO;
+		err("Could not submitting URB");
+		goto error;
+	}
+
+	/* save our data pointer in this interface device */
+	usb_set_intfdata(interface, dev);
+
+	/* we can register the device now, as it is ready */
+	retval = usb_register_dev(interface, &yurex_class);
+	if (retval) {
+		err("Not able to get a minor for this device.");
+		usb_set_intfdata(interface, NULL);
+		goto error;
+	}
+
+	dev->bbu = -1;
+
+	dev_info(&interface->dev,
+		 "USB Yurex device now attached to Yurex-%d¥n",
+		 interface->minor);
+
+	return 0;
+
+error:
+	if (dev)
+		/* this frees allocated memory */
+		kref_put(&dev->kref, yurex_delete);
+	return retval;
+}
+
+static void yurex_disconnect(struct usb_interface *interface)
+{
+	struct usb_yurex *dev;
+	int minor = interface->minor;
+
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+
+	/* give back our minor */
+	usb_deregister_dev(interface, &yurex_class);
+
+	/* prevent more I/O from starting */
+	mutex_lock(&dev->io_mutex);
+	dev->interface = NULL;
+	mutex_unlock(&dev->io_mutex);
+
+	/* wakeup waiters */
+	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+	wake_up_interruptible(&dev->waitq);
+
+	/* decrement our usage count */
+	kref_put(&dev->kref, yurex_delete);
+
+	dev_info(&interface->dev, "USB Yurex #%d now disconnected", minor);
+}
+
+static struct usb_driver yurex_driver = {
+	.name =		"yurex",
+	.probe =	yurex_probe,
+	.disconnect =	yurex_disconnect,
+	.id_table =	yurex_table,
+};
+
+
+static int yurex_fasync(int fd, struct file *file, int on)
+{
+	struct usb_yurex *dev;
+
+	dev = (struct usb_yurex *)file->private_data;
+	return fasync_helper(fd, file, on, &dev->async_queue);
+}
+
+static int yurex_open(struct inode *inode, struct file *file)
+{
+	struct usb_yurex *dev;
+	struct usb_interface *interface;
+	int subminor;
+	int retval = 0;
+
+	subminor = iminor(inode);
+
+	interface = usb_find_interface(&yurex_driver, subminor);
+	if (!interface) {
+		err("%s - error, can't find device for minor %d",
+		    __func__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	dev = usb_get_intfdata(interface);
+	if (!dev) {
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	/* increment our usage count for the device */
+	kref_get(&dev->kref);
+
+	/* save our object in the file's private structure */
+	mutex_lock(&dev->io_mutex);
+	file->private_data = dev;
+	mutex_unlock(&dev->io_mutex);
+
+exit:
+	return retval;
+}
+
+static int yurex_release(struct inode *inode, struct file *file)
+{
+	struct usb_yurex *dev;
+
+	dev = (struct usb_yurex *)file->private_data;
+	if (dev == NULL)
+		return -ENODEV;
+
+	yurex_fasync(-1, file, 0);
+
+	/* decrement the count on our device */
+	kref_put(&dev->kref, yurex_delete);
+	return 0;
+}
+
+static ssize_t yurex_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct usb_yurex *dev;
+	int retval = 0;
+	int bytes_read = 0;
+	char in_buffer[20];
+	unsigned long flags;
+
+	dev = (struct usb_yurex *)file->private_data;
+
+	mutex_lock(&dev->io_mutex);
+	if (!dev->interface) {		/* already disconnected */
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	bytes_read = snprintf(in_buffer, 20, "%lld¥n", dev->bbu);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (*ppos < bytes_read) {
+		if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
+			retval = -EFAULT;
+		else {
+			retval = bytes_read - *ppos;
+			*ppos += bytes_read;
+		}
+	}
+
+exit:
+	mutex_unlock(&dev->io_mutex);
+	return retval;
+}
+
+static ssize_t yurex_write(struct file *file, const char *user_buffer, size_t count, loff_t *ppos)
+{
+	struct usb_yurex *dev;
+	int i, set = 0, retval = 0;
+	char buffer[16];
+	char *data = buffer;
+	unsigned long long c, c2 = 0;
+	signed long timeout = 0;
+	DEFINE_WAIT(wait);
+
+	count = min(sizeof(buffer), count);
+	dev = (struct usb_yurex *)file->private_data;
+
+	/* verify that we actually have some data to write */
+	if (count == 0)
+		goto error;
+
+	mutex_lock(&dev->io_mutex);
+	if (!dev->interface) {		/* alreaday disconnected */
+		mutex_unlock(&dev->io_mutex);
+		retval = -ENODEV;
+		goto error;
+	}
+
+	if (copy_from_user(buffer, user_buffer, count)) {
+		mutex_unlock(&dev->io_mutex);
+		retval = -EFAULT;
+		goto error;
+	}
+	memset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);
+
+	switch (buffer[0]) {
+	case CMD_ANIMATE:
+	case CMD_LED:
+		dev->cntl_buffer[0] = buffer[0];
+		dev->cntl_buffer[1] = buffer[1];
+		dev->cntl_buffer[2] = CMD_EOF;
+		break;
+	case CMD_READ:
+	case CMD_VERSION:
+		dev->cntl_buffer[0] = buffer[0];
+		dev->cntl_buffer[1] = 0x00;
+		dev->cntl_buffer[2] = CMD_EOF;
+		break;
+	case CMD_SET:
+		data++;
+		/* FALL THROUGH */
+	case '0' ... '9':
+		set = 1;
+		c = c2 = simple_strtoull(data, NULL, 0);
+		dev->cntl_buffer[0] = CMD_SET;
+		for (i = 1; i < 6; i++) {
+			dev->cntl_buffer[i] = (c>>32) & 0xff;
+			c <<= 8;
+		}
+		buffer[6] = CMD_EOF;
+		break;
+	default:
+		mutex_unlock(&dev->io_mutex);
+		return -EINVAL;
+	}
+
+	/* send the data as the control msg */
+	prepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);
+	dbg("%s - submit %c", __func__, dev->cntl_buffer[0]);
+	retval = usb_submit_urb(dev->cntl_urb, GFP_KERNEL);
+	if (retval >= 0)
+		timeout = schedule_timeout(YUREX_WRITE_TIMEOUT);
+	finish_wait(&dev->waitq, &wait);
+
+	mutex_unlock(&dev->io_mutex);
+
+	if (retval < 0) {
+		err("%s - failed to send bulk msg, error %d", __func__, retval);
+		goto error;
+	}
+	if (set && timeout)
+		dev->bbu = c2;
+	return timeout ? count : -EIO;
+
+error:
+	return retval;
+}
+
+static const struct file_operations yurex_fops = {
+	.owner =	THIS_MODULE,
+	.read =		yurex_read,
+	.write =	yurex_write,
+	.open =		yurex_open,
+	.release =	yurex_release,
+	.fasync	=	yurex_fasync,
+};
+
+
+static int __init usb_yurex_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&yurex_driver);
+	if (result)
+		err("usb_register failed. Error number %d", result);
+
+	return result;
+}
+
+static void __exit usb_yurex_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&yurex_driver);
+}
+
+module_init(usb_yurex_init);
+module_exit(usb_yurex_exit);
+
+MODULE_LICENSE("GPL");
