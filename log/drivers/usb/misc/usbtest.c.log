commit 28ebeb8db77035e058a510ce9bd17c2b9a009dba
Author: Zqiang <qiang.zhang@windriver.com>
Date:   Fri Jun 12 11:52:10 2020 +0800

    usb: usbtest: fix missing kfree(dev->buf) in usbtest_disconnect
    
    BUG: memory leak
    unreferenced object 0xffff888055046e00 (size 256):
      comm "kworker/2:9", pid 2570, jiffies 4294942129 (age 1095.500s)
      hex dump (first 32 bytes):
        00 70 04 55 80 88 ff ff 18 bb 5a 81 ff ff ff ff  .p.U......Z.....
        f5 96 78 81 ff ff ff ff 37 de 8e 81 ff ff ff ff  ..x.....7.......
      backtrace:
        [<00000000d121dccf>] kmemleak_alloc_recursive
    include/linux/kmemleak.h:43 [inline]
        [<00000000d121dccf>] slab_post_alloc_hook mm/slab.h:586 [inline]
        [<00000000d121dccf>] slab_alloc_node mm/slub.c:2786 [inline]
        [<00000000d121dccf>] slab_alloc mm/slub.c:2794 [inline]
        [<00000000d121dccf>] kmem_cache_alloc_trace+0x15e/0x2d0 mm/slub.c:2811
        [<000000005c3c3381>] kmalloc include/linux/slab.h:555 [inline]
        [<000000005c3c3381>] usbtest_probe+0x286/0x19d0
    drivers/usb/misc/usbtest.c:2790
        [<000000001cec6910>] usb_probe_interface+0x2bd/0x870
    drivers/usb/core/driver.c:361
        [<000000007806c118>] really_probe+0x48d/0x8f0 drivers/base/dd.c:551
        [<00000000a3308c3e>] driver_probe_device+0xfc/0x2a0 drivers/base/dd.c:724
        [<000000003ef66004>] __device_attach_driver+0x1b6/0x240
    drivers/base/dd.c:831
        [<00000000eee53e97>] bus_for_each_drv+0x14e/0x1e0 drivers/base/bus.c:431
        [<00000000bb0648d0>] __device_attach+0x1f9/0x350 drivers/base/dd.c:897
        [<00000000838b324a>] device_initial_probe+0x1a/0x20 drivers/base/dd.c:944
        [<0000000030d501c1>] bus_probe_device+0x1e1/0x280 drivers/base/bus.c:491
        [<000000005bd7adef>] device_add+0x131d/0x1c40 drivers/base/core.c:2504
        [<00000000a0937814>] usb_set_configuration+0xe84/0x1ab0
    drivers/usb/core/message.c:2030
        [<00000000e3934741>] generic_probe+0x6a/0xe0 drivers/usb/core/generic.c:210
        [<0000000098ade0f1>] usb_probe_device+0x90/0xd0
    drivers/usb/core/driver.c:266
        [<000000007806c118>] really_probe+0x48d/0x8f0 drivers/base/dd.c:551
        [<00000000a3308c3e>] driver_probe_device+0xfc/0x2a0 drivers/base/dd.c:724
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Kyungtae Kim <kt0755@gmail.com>
    Signed-off-by: Zqiang <qiang.zhang@windriver.com>
    Link: https://lore.kernel.org/r/20200612035210.20494-1-qiang.zhang@windriver.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 98ada1a3425c..bae88893ee8e 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2873,6 +2873,7 @@ static void usbtest_disconnect(struct usb_interface *intf)
 
 	usb_set_intfdata(intf, NULL);
 	dev_dbg(&intf->dev, "disconnect\n");
+	kfree(dev->buf);
 	kfree(dev);
 }
 

commit 0d1ec194721f844a6b20f7f4854332adcebc6fb9
Author: Peter Chen <peter.chen@nxp.com>
Date:   Tue Feb 12 08:57:27 2019 +0000

    usb: misc: usbtest: add super-speed isoc support
    
    The calculation of packet number within microframe is different between
    high-speed and super-speed endpoint, we add support for super-speed
    in this patch.
    
    Cc: Pawel Laszczak <pawell@cadence.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index c7f82310e73e..98ada1a3425c 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -347,6 +347,14 @@ static unsigned get_maxpacket(struct usb_device *udev, int pipe)
 	return le16_to_cpup(&ep->desc.wMaxPacketSize);
 }
 
+static int ss_isoc_get_packet_num(struct usb_device *udev, int pipe)
+{
+	struct usb_host_endpoint *ep = usb_pipe_endpoint(udev, pipe);
+
+	return USB_SS_MULT(ep->ss_ep_comp.bmAttributes)
+		* (1 + ep->ss_ep_comp.bMaxBurst);
+}
+
 static void simple_fill_buf(struct urb *urb)
 {
 	unsigned	i;
@@ -1976,8 +1984,13 @@ static struct urb *iso_alloc_urb(
 
 	if (bytes < 0 || !desc)
 		return NULL;
+
 	maxp = usb_endpoint_maxp(desc);
-	maxp *= usb_endpoint_maxp_mult(desc);
+	if (udev->speed >= USB_SPEED_SUPER)
+		maxp *= ss_isoc_get_packet_num(udev, pipe);
+	else
+		maxp *= usb_endpoint_maxp_mult(desc);
+
 	packets = DIV_ROUND_UP(bytes, maxp);
 
 	urb = usb_alloc_urb(packets, GFP_KERNEL);
@@ -2065,17 +2078,24 @@ test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 	packets *= param->iterations;
 
 	if (context.is_iso) {
+		int transaction_num;
+
+		if (udev->speed >= USB_SPEED_SUPER)
+			transaction_num = ss_isoc_get_packet_num(udev, pipe);
+		else
+			transaction_num = usb_endpoint_maxp_mult(desc);
+
 		dev_info(&dev->intf->dev,
 			"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",
 			1 << (desc->bInterval - 1),
-			(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
+			(udev->speed >= USB_SPEED_HIGH) ? "micro" : "",
 			usb_endpoint_maxp(desc),
-			usb_endpoint_maxp_mult(desc));
+			transaction_num);
 
 		dev_info(&dev->intf->dev,
 			"total %lu msec (%lu packets)\n",
 			(packets * (1 << (desc->bInterval - 1)))
-				/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
+				/ ((udev->speed >= USB_SPEED_HIGH) ? 8 : 1),
 			packets);
 	}
 

commit 6f3fde684d0232e66ada3410f016a58e09a87689
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Jul 1 17:35:44 2018 +0200

    usb: usbtest: use irqsave() in USB's complete callback
    
    The USB completion callback does not disable interrupts while acquiring
    the lock. We want to remove the local_irq_disable() invocation from
    __usb_hcd_giveback_urb() and therefore it is required for the callback
    handler to disable the interrupts while acquiring the lock.
    The callback may be invoked either in IRQ or BH context depending on the
    USB host controller.
    Use the _irqsave() variant of the locking primitives.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 9e1142b8b91b..c7f82310e73e 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1082,11 +1082,12 @@ static void ctrl_complete(struct urb *urb)
 	struct usb_ctrlrequest	*reqp;
 	struct subcase		*subcase;
 	int			status = urb->status;
+	unsigned long		flags;
 
 	reqp = (struct usb_ctrlrequest *)urb->setup_packet;
 	subcase = container_of(reqp, struct subcase, setup);
 
-	spin_lock(&ctx->lock);
+	spin_lock_irqsave(&ctx->lock, flags);
 	ctx->count--;
 	ctx->pending--;
 
@@ -1185,7 +1186,7 @@ static void ctrl_complete(struct urb *urb)
 	/* signal completion when nothing's queued */
 	if (ctx->pending == 0)
 		complete(&ctx->complete);
-	spin_unlock(&ctx->lock);
+	spin_unlock_irqrestore(&ctx->lock, flags);
 }
 
 static int
@@ -1917,8 +1918,9 @@ struct transfer_context {
 static void complicated_callback(struct urb *urb)
 {
 	struct transfer_context	*ctx = urb->context;
+	unsigned long flags;
 
-	spin_lock(&ctx->lock);
+	spin_lock_irqsave(&ctx->lock, flags);
 	ctx->count--;
 
 	ctx->packet_count += urb->number_of_packets;
@@ -1958,7 +1960,7 @@ static void complicated_callback(struct urb *urb)
 		complete(&ctx->done);
 	}
 done:
-	spin_unlock(&ctx->lock);
+	spin_unlock_irqrestore(&ctx->lock, flags);
 }
 
 static struct urb *iso_alloc_urb(

commit c53439fbd15600ecd48bfec446c2018e4fa6e241
Author: Tobin C. Harding <me@tobin.cc>
Date:   Fri Mar 9 17:11:14 2018 +1100

    usb: usbtest: Remove stack VLA usage
    
    The kernel would like to have all stack VLA usage removed[1].  We
    already have a pre-processor constant defined MAX_SGLEN.  We can use
    this instead of the variable param-sglen.
    
    [1]: https://lkml.org/lkml/2018/3/7/621
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 90028ef541e3..9e1142b8b91b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2028,11 +2028,14 @@ test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 	unsigned		i;
 	unsigned long		packets = 0;
 	int			status = 0;
-	struct urb		*urbs[param->sglen];
+	struct urb		*urbs[MAX_SGLEN];
 
 	if (!param->sglen || param->iterations > UINT_MAX / param->sglen)
 		return -EINVAL;
 
+	if (param->sglen > MAX_SGLEN)
+		return -EINVAL;
+
 	memset(&context, 0, sizeof(context));
 	context.count = param->iterations * param->sglen;
 	context.dev = dev;

commit cc2e60dfa6ba4ff2c054bca932b9afc8702a2f9a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 15 15:11:38 2017 +0200

    usb: usbtest: Add TEST 29, toggle sync, Clear toggle between bulk writes
    
    Clear Feature Endpoint Halt should reset the data toggle even if the
    endpoint isn't halted. Host should manage to clear the host side data
    toggle to keep in sync with the device.
    
    Test by sending a "3 data packet URB" before and after clearing the halt.
    this should create a toggle sequence with two consecutive DATA0 packets.
    
    A successful test sequence looks like this
        ClearFeature(ENDPOINT_HALT) - initial toggle clear
      DATA0 (max packet sized)
      DATA1 (max packet sized)
      DATA0 (zero length packet)
        ClearFeature(ENDPOINT_HALT) - resets toggle
      DATA0 (max packet sized), if clear halt fails then toggle is DATA1
      DATA1 (max packet sized)
      DATA0 (zero length packet)
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index aedc9a7f149e..90028ef541e3 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1710,6 +1710,35 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	return 0;
 }
 
+static int test_toggle_sync(struct usbtest_dev *tdev, int ep, struct urb *urb)
+{
+	int	retval;
+
+	/* clear initial data toggle to DATA0 */
+	retval = usb_clear_halt(urb->dev, urb->pipe);
+	if (retval < 0) {
+		ERROR(tdev, "ep %02x couldn't clear halt, %d\n", ep, retval);
+		return retval;
+	}
+
+	/* transfer 3 data packets, should be DATA0, DATA1, DATA0 */
+	retval = simple_io(tdev, urb, 1, 0, 0, __func__);
+	if (retval != 0)
+		return -EINVAL;
+
+	/* clear halt resets device side data toggle, host should react to it */
+	retval = usb_clear_halt(urb->dev, urb->pipe);
+	if (retval < 0) {
+		ERROR(tdev, "ep %02x couldn't clear halt, %d\n", ep, retval);
+		return retval;
+	}
+
+	/* host should use DATA0 again after clear halt */
+	retval = simple_io(tdev, urb, 1, 0, 0, __func__);
+
+	return retval;
+}
+
 static int halt_simple(struct usbtest_dev *dev)
 {
 	int			ep;
@@ -1742,6 +1771,33 @@ static int halt_simple(struct usbtest_dev *dev)
 	return retval;
 }
 
+static int toggle_sync_simple(struct usbtest_dev *dev)
+{
+	int			ep;
+	int			retval = 0;
+	struct urb		*urb;
+	struct usb_device	*udev = testdev_to_usbdev(dev);
+	unsigned		maxp = get_maxpacket(udev, dev->out_pipe);
+
+	/*
+	 * Create a URB that causes a transfer of uneven amount of data packets
+	 * This way the clear toggle has an impact on the data toggle sequence.
+	 * Use 2 maxpacket length packets and one zero packet.
+	 */
+	urb = simple_alloc_urb(udev, 0,  2 * maxp, 0);
+	if (urb == NULL)
+		return -ENOMEM;
+
+	urb->transfer_flags |= URB_ZERO_PACKET;
+
+	ep = usb_pipeendpoint(dev->out_pipe);
+	urb->pipe = dev->out_pipe;
+	retval = test_toggle_sync(dev, ep, urb);
+
+	simple_free_urb(urb);
+	return retval;
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* Control OUT tests use the vendor control requests from Intel's
@@ -2524,6 +2580,20 @@ usbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)
 		retval = test_queue(dev, param,
 				dev->in_pipe, NULL, 0);
 		break;
+	/* Test data Toggle/seq_nr clear between bulk out transfers */
+	case 29:
+		if (dev->out_pipe == 0)
+			break;
+		retval = 0;
+		dev_info(&intf->dev, "TEST 29: Clear toggle between bulk writes %d times\n",
+				param->iterations);
+		for (i = param->iterations; retval == 0 && i > 0; --i)
+			retval = toggle_sync_simple(dev);
+
+		if (retval)
+			ERROR(dev, "toggle sync failed, iterations left %d\n",
+			      i);
+		break;
 	}
 	return retval;
 }

commit 894025f24bd028942da3e602b87d9f7223109b14
Merge: fb0255fb2941 cdafb6d8b8da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:14:07 2017 -0800

    Merge tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB/PHY updates from Greg KH:
     "Here is the big set of USB and PHY driver updates for 4.15-rc1.
    
      There is the usual amount of gadget and xhci driver updates, along
      with phy and chipidea enhancements. There's also a lot of SPDX tags
      and license boilerplate cleanups as well, which provide some churn in
      the diffstat.
    
      Other major thing is the typec code that moved out of staging and into
      the "real" part of the drivers/usb/ tree, which was nice to see
      happen.
    
      All of these have been in linux-next with no reported issues for a
      while"
    
    * tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (263 commits)
      usb: gadget: f_fs: Fix use-after-free in ffs_free_inst
      USB: usbfs: compute urb->actual_length for isochronous
      usb: core: message: remember to reset 'ret' to 0 when necessary
      USB: typec: Remove remaining redundant license text
      USB: typec: add SPDX identifiers to some files
      USB: renesas_usbhs: rcar?.h: add SPDX tags
      USB: chipidea: ci_hdrc_tegra.c: add SPDX line
      USB: host: xhci-debugfs: add SPDX lines
      USB: add SPDX identifiers to all remaining Makefiles
      usb: host: isp1362-hcd: remove a couple of redundant assignments
      USB: adutux: remove redundant variable minor
      usb: core: add a new usb_get_ptm_status() helper
      usb: core: add a 'type' parameter to usb_get_status()
      usb: core: introduce a new usb_get_std_status() helper
      usb: core: rename usb_get_status() 'type' argument to 'recip'
      usb: core: add Status Type definitions
      USB: gadget: Remove redundant license text
      USB: gadget: function: Remove redundant license text
      USB: gadget: udc: Remove redundant license text
      USB: gadget: legacy: Remove redundant license text
      ...

commit 2bcc673101268dc50e52b83226c5bbf38391e16d
Merge: 670310dfbae0 b24591e2fcf8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:56:58 2017 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Yet another big pile of changes:
    
       - More year 2038 work from Arnd slowly reaching the point where we
         need to think about the syscalls themself.
    
       - A new timer function which allows to conditionally (re)arm a timer
         only when it's either not running or the new expiry time is sooner
         than the armed expiry time. This allows to use a single timer for
         multiple timeout requirements w/o caring about the first expiry
         time at the call site.
    
       - A new NMI safe accessor to clock real time for the printk timestamp
         work. Can be used by tracing, perf as well if required.
    
       - A large number of timer setup conversions from Kees which got
         collected here because either maintainers requested so or they
         simply got ignored. As Kees pointed out already there are a few
         trivial merge conflicts and some redundant commits which was
         unavoidable due to the size of this conversion effort.
    
       - Avoid a redundant iteration in the timer wheel softirq processing.
    
       - Provide a mechanism to treat RTC implementations depending on their
         hardware properties, i.e. don't inflict the write at the 0.5
         seconds boundary which originates from the PC CMOS RTC to all RTCs.
         No functional change as drivers need to be updated separately.
    
       - The usual small updates to core code clocksource drivers. Nothing
         really exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (111 commits)
      timers: Add a function to start/reduce a timer
      pstore: Use ktime_get_real_fast_ns() instead of __getnstimeofday()
      timer: Prepare to change all DEFINE_TIMER() callbacks
      netfilter: ipvs: Convert timers to use timer_setup()
      scsi: qla2xxx: Convert timers to use timer_setup()
      block/aoe: discover_timer: Convert timers to use timer_setup()
      ide: Convert timers to use timer_setup()
      drbd: Convert timers to use timer_setup()
      mailbox: Convert timers to use timer_setup()
      crypto: Convert timers to use timer_setup()
      drivers/pcmcia: omap1: Fix error in automated timer conversion
      ARM: footbridge: Fix typo in timer conversion
      drivers/sgi-xp: Convert timers to use timer_setup()
      drivers/pcmcia: Convert timers to use timer_setup()
      drivers/memstick: Convert timers to use timer_setup()
      drivers/macintosh: Convert timers to use timer_setup()
      hwrng/xgene-rng: Convert timers to use timer_setup()
      auxdisplay: Convert timers to use timer_setup()
      sparc/led: Convert timers to use timer_setup()
      mips: ip22/32: Convert timers to use timer_setup()
      ...

commit d9e1e1484ade396b3a979ba6c68798dbaceed1b9
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:40 2017 +0200

    usb: core: introduce a new usb_get_std_status() helper
    
    This new helper is a simple wrapper around usb_get_status(). This
    patch is in preparation to adding support for fetching PTM_STATUS
    types. No functional changes.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index aeda01f037c1..203f29894bce 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1016,7 +1016,7 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 	/* FIXME fetch strings from at least the device descriptor */
 
 	/* [9.4.5] get_status always works */
-	retval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev->buf);
+	retval = usb_get_std_status(udev, USB_RECIP_DEVICE, 0, dev->buf);
 	if (retval) {
 		dev_err(&iface->dev, "get dev status --> %d\n", retval);
 		return retval;
@@ -1026,7 +1026,7 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 	 * the device's remote wakeup feature ... if we can, test that here
 	 */
 
-	retval = usb_get_status(udev, USB_RECIP_INTERFACE,
+	retval = usb_get_std_status(udev, USB_RECIP_INTERFACE,
 			iface->altsetting[0].desc.bInterfaceNumber, dev->buf);
 	if (retval) {
 		dev_err(&iface->dev, "get interface status --> %d\n", retval);
@@ -1615,7 +1615,7 @@ static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	u16	status;
 
 	/* shouldn't look or act halted */
-	retval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	retval = usb_get_std_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
 		ERROR(tdev, "ep %02x couldn't get no-halt status, %d\n",
 				ep, retval);
@@ -1637,7 +1637,7 @@ static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	u16	status;
 
 	/* should look and act halted */
-	retval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	retval = usb_get_std_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
 		ERROR(tdev, "ep %02x couldn't get halt status, %d\n",
 				ep, retval);

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3639e00a51a0..aeda01f037c1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 7d221856add016ef6cc0f4c0cad8e5d2612feedb
Author: Kees Cook <keescook@chromium.org>
Date:   Sun Oct 22 17:57:22 2017 -0700

    usb: usbtest: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. Also adds missing call to
    destroy_timer_on_stack();
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: "Gustavo A. R. Silva" <garsilva@embeddedor.com>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index eee82ca55b7b..b1ad69edf839 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -575,11 +575,16 @@ alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 	return sg;
 }
 
-static void sg_timeout(unsigned long _req)
+struct sg_timeout {
+	struct timer_list timer;
+	struct usb_sg_request *req;
+};
+
+static void sg_timeout(struct timer_list *t)
 {
-	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
+	struct sg_timeout *timeout = from_timer(timeout, t, timer);
 
-	usb_sg_cancel(req);
+	usb_sg_cancel(timeout->req);
 }
 
 static int perform_sglist(
@@ -593,9 +598,11 @@ static int perform_sglist(
 {
 	struct usb_device	*udev = testdev_to_usbdev(tdev);
 	int			retval = 0;
-	struct timer_list	sg_timer;
+	struct sg_timeout	timeout = {
+		.req = req,
+	};
 
-	setup_timer_on_stack(&sg_timer, sg_timeout, (unsigned long) req);
+	timer_setup_on_stack(&timeout.timer, sg_timeout, 0);
 
 	while (retval == 0 && iterations-- > 0) {
 		retval = usb_sg_init(req, udev, pipe,
@@ -606,13 +613,14 @@ static int perform_sglist(
 
 		if (retval)
 			break;
-		mod_timer(&sg_timer, jiffies +
+		mod_timer(&timeout.timer, jiffies +
 				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
-		if (!del_timer_sync(&sg_timer))
+		if (!del_timer_sync(&timeout.timer))
 			retval = -ETIMEDOUT;
 		else
 			retval = req->status;
+		destroy_timer_on_stack(&timeout.timer);
 
 		/* FIXME check resulting data pattern */
 

commit 9f8e32dfca2aab9dea8a9db335e3a783b0035507
Author: Jaejoong Kim <climbbb.kim@gmail.com>
Date:   Fri Oct 20 16:29:15 2017 +0900

    usb: misc: usbtest: remove duplicate & operation
    
    usb_endpoint_maxp() has an inline keyword and searches for bits[10:0]
    by & operation with 0x7ff. So, we can remove the duplicate & operation
    with 0x7ff.
    
    Signed-off-by: Jaejoong Kim <climbbb.kim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b3fc602b2e24..3639e00a51a0 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1909,7 +1909,7 @@ static struct urb *iso_alloc_urb(
 
 	if (bytes < 0 || !desc)
 		return NULL;
-	maxp = 0x7ff & usb_endpoint_maxp(desc);
+	maxp = usb_endpoint_maxp(desc);
 	maxp *= usb_endpoint_maxp_mult(desc);
 	packets = DIV_ROUND_UP(bytes, maxp);
 

commit 7c80f9e4a588f1925b07134bb2e3689335f6c6d8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Sep 29 10:54:24 2017 -0400

    usb: usbtest: fix NULL pointer dereference
    
    If the usbtest driver encounters a device with an IN bulk endpoint but
    no OUT bulk endpoint, it will try to dereference a NULL pointer
    (out->desc.bEndpointAddress).  The problem can be solved by adding a
    missing test.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 113e38bfe0ef..b3fc602b2e24 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			return tmp;
 	}
 
-	if (in) {
+	if (in)
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	if (out)
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-	}
+
 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,

commit cb84f56861eb333af0a5bab475d741b13067c05c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat Sep 30 11:15:29 2017 +0300

    usb: misc: usbtest: Fix overflow in usbtest_do_ioctl()
    
    There used to be a test against "if (param->sglen > MAX_SGLEN)" but it
    was removed during a refactor.  It leads to an integer overflow and a
    stack overflow in test_queue() if we try to create a too large urbs[]
    array on the stack.
    
    There is a second integer overflow in test_queue() as well if
    "param->iterations" is too high.  I don't immediately see that it's
    harmful but I've added a check to prevent it and silence the static
    checker warning.
    
    Fixes: 18fc4ebdc705 ("usb: misc: usbtest: Remove timeval usage")
    Acked-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index eee82ca55b7b..113e38bfe0ef 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1964,6 +1964,9 @@ test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 	int			status = 0;
 	struct urb		*urbs[param->sglen];
 
+	if (!param->sglen || param->iterations > UINT_MAX / param->sglen)
+		return -EINVAL;
+
 	memset(&context, 0, sizeof(context));
 	context.count = param->iterations * param->sglen;
 	context.dev = dev;
@@ -2087,6 +2090,8 @@ usbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)
 
 	if (param->iterations <= 0)
 		return -EINVAL;
+	if (param->sglen > MAX_SGLEN)
+		return -EINVAL;
 	/*
 	 * Just a bunch of test cases that every HCD is expected to handle.
 	 *

commit 65c7843c942d0990e8b5f40aa4fdc755bbc15034
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Mon Apr 3 22:51:54 2017 -0500

    usb: misc: refactor code
    
    Code refactoring to make the flow easier to follow.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 26ae5d1a2a4e..eee82ca55b7b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -124,6 +124,20 @@ static struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)
 
 /*-------------------------------------------------------------------------*/
 
+static inline void endpoint_update(int edi,
+				   struct usb_host_endpoint **in,
+				   struct usb_host_endpoint **out,
+				   struct usb_host_endpoint *e)
+{
+	if (edi) {
+		if (!*in)
+			*in = e;
+	} else {
+		if (!*out)
+			*out = e;
+	}
+}
+
 static int
 get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 {
@@ -151,47 +165,26 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 		 */
 		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
 			struct usb_host_endpoint	*e;
+			int edi;
 
 			e = alt->endpoint + ep;
+			edi = usb_endpoint_dir_in(&e->desc);
+
 			switch (usb_endpoint_type(&e->desc)) {
 			case USB_ENDPOINT_XFER_BULK:
-				break;
+				endpoint_update(edi, &in, &out, e);
+				continue;
 			case USB_ENDPOINT_XFER_INT:
 				if (dev->info->intr)
-					goto try_intr;
+					endpoint_update(edi, &int_in, &int_out, e);
 				continue;
 			case USB_ENDPOINT_XFER_ISOC:
 				if (dev->info->iso)
-					goto try_iso;
+					endpoint_update(edi, &iso_in, &iso_out, e);
 				/* FALLTHROUGH */
 			default:
 				continue;
 			}
-			if (usb_endpoint_dir_in(&e->desc)) {
-				if (!in)
-					in = e;
-			} else {
-				if (!out)
-					out = e;
-			}
-			continue;
-try_intr:
-			if (usb_endpoint_dir_in(&e->desc)) {
-				if (!int_in)
-					int_in = e;
-			} else {
-				if (!int_out)
-					int_out = e;
-			}
-			continue;
-try_iso:
-			if (usb_endpoint_dir_in(&e->desc)) {
-				if (!iso_in)
-					iso_in = e;
-			} else {
-				if (!iso_out)
-					iso_out = e;
-			}
 		}
 		if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
 			goto found;

commit 2c930e3d0aed1505e86e0928d323df5027817740
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Mon Apr 3 22:48:40 2017 -0500

    usb: misc: add missing continue in switch
    
    Add missing continue in switch.
    
    Addresses-Coverity-ID: 1248733
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 17c081068257..26ae5d1a2a4e 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -159,6 +159,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			case USB_ENDPOINT_XFER_INT:
 				if (dev->info->intr)
 					goto try_intr;
+				continue;
 			case USB_ENDPOINT_XFER_ISOC:
 				if (dev->info->iso)
 					goto try_iso;

commit ef5ec7f08d6750b4786efe8dc76184fd86f85d4c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Feb 12 18:35:18 2017 +0000

    usb: misc: usbtest: remove redundant check on retval < 0
    
    The check for retval being less than zero is always true since
    retval equal to -EPIPE at that point.  Replace the existing
    conditional with just return retval.
    
    Detected with CoverityScan, CID#114349 ("Logically dead code")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3525626bf086..17c081068257 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -992,7 +992,7 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 				dev_err(&iface->dev,
 						"hs dev qualifier --> %d\n",
 						retval);
-				return (retval < 0) ? retval : -EDOM;
+				return retval;
 			}
 			/* usb2.0 but not high-speed capable; fine */
 		} else if (retval != sizeof(struct usb_qualifier_descriptor)) {

commit efdd17e66718306c58cd8bab3a50cf8cfa645e8e
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 14:17:38 2016 +0300

    usb: misc: usbtest: remove unnecessary & operation
    
    Now that usb_endpoint_maxp() only returns the lowest
    11 bits from wMaxPacketSize, we can remove the &
    operation from this driver.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 8edfbc8bf345..3525626bf086 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2001,7 +2001,7 @@ test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 			"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",
 			1 << (desc->bInterval - 1),
 			(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
-			usb_endpoint_maxp(desc) & 0x7ff,
+			usb_endpoint_maxp(desc),
 			usb_endpoint_maxp_mult(desc));
 
 		dev_info(&dev->intf->dev,

commit 131e19b9e3a5a463ab790db737c72040a918967c
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 13:40:03 2016 +0300

    usb: misc: usbtest: make use of new usb_endpoint_maxp_mult()
    
    We have introduced a helper to calculate multiplier
    value from wMaxPacketSize. Start using it.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 5c8210dc6fd9..8edfbc8bf345 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1915,7 +1915,7 @@ static struct urb *iso_alloc_urb(
 	if (bytes < 0 || !desc)
 		return NULL;
 	maxp = 0x7ff & usb_endpoint_maxp(desc);
-	maxp *= 1 + (0x3 & (usb_endpoint_maxp(desc) >> 11));
+	maxp *= usb_endpoint_maxp_mult(desc);
 	packets = DIV_ROUND_UP(bytes, maxp);
 
 	urb = usb_alloc_urb(packets, GFP_KERNEL);
@@ -2002,7 +2002,7 @@ test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 			1 << (desc->bInterval - 1),
 			(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
 			usb_endpoint_maxp(desc) & 0x7ff,
-			1 + (0x3 & (usb_endpoint_maxp(desc) >> 11)));
+			usb_endpoint_maxp_mult(desc));
 
 		dev_info(&dev->intf->dev,
 			"total %lu msec (%lu packets)\n",

commit 539587511835ea12d8daa444cbed766cf2bc3612
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Aug 11 10:31:14 2016 +0800

    usb: misc: usbtest: add fix for driver hang
    
    In sg_timeout(), req->status is set to "-ETIMEDOUT" before calling
    into usb_sg_cancel(). usb_sg_cancel() will do nothing and return
    directly if req->status has been set to a non-zero value. This will
    cause driver hang whenever transfer time out is triggered.
    
    This patch fixes this issue. It could be backported to stable kernel
    with version later than v3.15.
    
    Cc: stable@vger.kernel.org # 3.15+
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 5e3464e8d4e5..5c8210dc6fd9 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -585,7 +585,6 @@ static void sg_timeout(unsigned long _req)
 {
 	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
 
-	req->status = -ETIMEDOUT;
 	usb_sg_cancel(req);
 }
 
@@ -616,8 +615,10 @@ static int perform_sglist(
 		mod_timer(&sg_timer, jiffies +
 				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
-		del_timer_sync(&sg_timer);
-		retval = req->status;
+		if (!del_timer_sync(&sg_timer))
+			retval = -ETIMEDOUT;
+		else
+			retval = req->status;
 
 		/* FIXME check resulting data pattern */
 

commit 28324936f3d672bbf83472fece8f36a158a52276
Author: Peter Chen <peter.chen@nxp.com>
Date:   Tue Jul 26 16:01:30 2016 +0800

    usb: misc: usbtest: usbtest_do_ioctl may return positive integer
    
    For case 14 and case 21, their correct return value is the number
    of bytes transferred, so it is a positive integer. But in usbtest_ioctl,
    it takes non-zero as false return value for usbtest_do_ioctl, so
    it will treat the correct test as wrong test, then the time on
    tests will be the minus value.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Cc: stable <stable@vger.kernel.org>
    Fixes: 18fc4ebdc705 ("usb: misc: usbtest: Remove timeval usage")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 6b978f04b8d7..5e3464e8d4e5 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2602,7 +2602,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 	ktime_get_ts64(&start);
 
 	retval = usbtest_do_ioctl(intf, param_32);
-	if (retval)
+	if (retval < 0)
 		goto free_mutex;
 
 	ktime_get_ts64(&end);

commit cdc77c82a8286b1181b81b6e5ef60c8e83ded7bc
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 2 11:39:03 2016 +0300

    usb: misc: usbtest: fix pattern tests for scatterlists.
    
    The current implemenentation restart the sent pattern for each entry in
    the sg list. The receiving end expects a continuous pattern, and test
    will fail unless scatterilst entries happen to be aligned with the
    pattern
    
    Fix this by calculating the pattern byte based on total sent size
    instead of just the current sg entry.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Fixes: 8b5249019352 ("[PATCH] USB: usbtest: scatterlist OUT data pattern testing")
    Cc: <stable@vger.kernel.org> # v2.6.18+
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index de485d8a5beb..6b978f04b8d7 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -532,6 +532,7 @@ static struct scatterlist *
 alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 {
 	struct scatterlist	*sg;
+	unsigned int		n_size = 0;
 	unsigned		i;
 	unsigned		size = max;
 	unsigned		maxpacket =
@@ -564,7 +565,8 @@ alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 			break;
 		case 1:
 			for (j = 0; j < size; j++)
-				*buf++ = (u8) ((j % maxpacket) % 63);
+				*buf++ = (u8) (((j + n_size) % maxpacket) % 63);
+			n_size += size;
 			break;
 		}
 

commit 26186e5f2c1a6d1c244a3052f02e46ae29d823f2
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Thu Apr 28 11:42:21 2016 +0800

    usb: misc: usbtest: fix error of urb allocation
    
    urb allocation will fail when usbtest_alloc_urb() tries to
    allocate zero length buffer, but it doesn't need it in fact,
    so just skips buffer allocation in the case.
    
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 92fdb6e9faff..de485d8a5beb 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -287,6 +287,9 @@ static struct urb *usbtest_alloc_urb(
 	if (usb_pipein(pipe))
 		urb->transfer_flags |= URB_SHORT_NOT_OK;
 
+	if ((bytes + offset) == 0)
+		return urb;
+
 	if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
 		urb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,
 			GFP_KERNEL, &urb->transfer_dma);

commit 18fc4ebdc7057478497682047db5acfb25b35c49
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Nov 4 15:29:11 2015 -0800

    usb: misc: usbtest: Remove timeval usage
    
    timeval is deprecated and not y2038 safe.  Its size also changes according
    to 32 bit/ 64 bit compilation.  Replace it with 32 and 64 bit versions of
    its individual fields, giving two ioctls with different code values.
    The two ioctls are necessary to maintain the 32 bit and 64 bit userspace
    compatibility with a 64/32 bit kernel.
    
    Change unsigned to __u32 types for a definitive userspace interface.
    This is in accordance with the psABI that the unsigned type is always
    32 bits.
    
    Also use motonic timer instead of real time to ensure positive delta
    values.
    
    Refactor usbtest_ioctl for readability to isolate the handling of the
    testing timing measurement.
    
    The official testusb userspace tool can be changed in a separate patch
    to reflect the __u32 changes as well. It can use the usbtest_param_32
    struct, since 32 bit seconds is long enough for test durations.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index c1bd1eb548bb..92fdb6e9faff 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -22,18 +22,42 @@ static void complicated_callback(struct urb *urb);
 /*-------------------------------------------------------------------------*/
 
 /* FIXME make these public somewhere; usbdevfs.h? */
-struct usbtest_param {
+
+/* Parameter for usbtest driver. */
+struct usbtest_param_32 {
 	/* inputs */
-	unsigned		test_num;	/* 0..(TEST_CASES-1) */
-	unsigned		iterations;
-	unsigned		length;
-	unsigned		vary;
-	unsigned		sglen;
+	__u32		test_num;	/* 0..(TEST_CASES-1) */
+	__u32		iterations;
+	__u32		length;
+	__u32		vary;
+	__u32		sglen;
 
 	/* outputs */
-	struct timeval		duration;
+	__s32		duration_sec;
+	__s32		duration_usec;
 };
-#define USBTEST_REQUEST	_IOWR('U', 100, struct usbtest_param)
+
+/*
+ * Compat parameter to the usbtest driver.
+ * This supports older user space binaries compiled with 64 bit compiler.
+ */
+struct usbtest_param_64 {
+	/* inputs */
+	__u32		test_num;	/* 0..(TEST_CASES-1) */
+	__u32		iterations;
+	__u32		length;
+	__u32		vary;
+	__u32		sglen;
+
+	/* outputs */
+	__s64		duration_sec;
+	__s64		duration_usec;
+};
+
+/* IOCTL interface to the driver. */
+#define USBTEST_REQUEST_32    _IOWR('U', 100, struct usbtest_param_32)
+/* COMPAT IOCTL interface to the driver. */
+#define USBTEST_REQUEST_64    _IOWR('U', 100, struct usbtest_param_64)
 
 /*-------------------------------------------------------------------------*/
 
@@ -1030,7 +1054,7 @@ struct ctrl_ctx {
 	unsigned		pending;
 	int			status;
 	struct urb		**urb;
-	struct usbtest_param	*param;
+	struct usbtest_param_32	*param;
 	int			last;
 };
 
@@ -1155,7 +1179,7 @@ static void ctrl_complete(struct urb *urb)
 }
 
 static int
-test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
+test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param)
 {
 	struct usb_device	*udev = testdev_to_usbdev(dev);
 	struct urb		**urb;
@@ -1930,7 +1954,7 @@ static struct urb *iso_alloc_urb(
 }
 
 static int
-test_queue(struct usbtest_dev *dev, struct usbtest_param *param,
+test_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,
 		int pipe, struct usb_endpoint_descriptor *desc, unsigned offset)
 {
 	struct transfer_context	context;
@@ -2049,81 +2073,20 @@ static int test_unaligned_bulk(
 	return retval;
 }
 
-/*-------------------------------------------------------------------------*/
-
-/* We only have this one interface to user space, through usbfs.
- * User mode code can scan usbfs to find N different devices (maybe on
- * different busses) to use when testing, and allocate one thread per
- * test.  So discovery is simplified, and we have no device naming issues.
- *
- * Don't use these only as stress/load tests.  Use them along with with
- * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,
- * video capture, and so on.  Run different tests at different times, in
- * different sequences.  Nothing here should interact with other devices,
- * except indirectly by consuming USB bandwidth and CPU resources for test
- * threads and request completion.  But the only way to know that for sure
- * is to test when HC queues are in use by many devices.
- *
- * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),
- * it locks out usbcore in certain code paths.  Notably, if you disconnect
- * the device-under-test, hub_wq will wait block forever waiting for the
- * ioctl to complete ... so that usb_disconnect() can abort the pending
- * urbs and then call usbtest_disconnect().  To abort a test, you're best
- * off just killing the userspace task and waiting for it to exit.
- */
-
+/* Run tests. */
 static int
-usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
+usbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)
 {
 	struct usbtest_dev	*dev = usb_get_intfdata(intf);
 	struct usb_device	*udev = testdev_to_usbdev(dev);
-	struct usbtest_param	*param = buf;
-	int			retval = -EOPNOTSUPP;
 	struct urb		*urb;
 	struct scatterlist	*sg;
 	struct usb_sg_request	req;
-	struct timeval		start;
 	unsigned		i;
-
-	/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */
-
-	pattern = mod_pattern;
-
-	if (code != USBTEST_REQUEST)
-		return -EOPNOTSUPP;
+	int	retval = -EOPNOTSUPP;
 
 	if (param->iterations <= 0)
 		return -EINVAL;
-
-	if (param->sglen > MAX_SGLEN)
-		return -EINVAL;
-
-	if (mutex_lock_interruptible(&dev->lock))
-		return -ERESTARTSYS;
-
-	/* FIXME: What if a system sleep starts while a test is running? */
-
-	/* some devices, like ez-usb default devices, need a non-default
-	 * altsetting to have any active endpoints.  some tests change
-	 * altsettings; force a default so most tests don't need to check.
-	 */
-	if (dev->info->alt >= 0) {
-		int	res;
-
-		if (intf->altsetting->desc.bInterfaceNumber) {
-			mutex_unlock(&dev->lock);
-			return -ENODEV;
-		}
-		res = set_altsetting(dev, dev->info->alt);
-		if (res) {
-			dev_err(&intf->dev,
-					"set altsetting to %d failed, %d\n",
-					dev->info->alt, res);
-			mutex_unlock(&dev->lock);
-			return res;
-		}
-	}
-
 	/*
 	 * Just a bunch of test cases that every HCD is expected to handle.
 	 *
@@ -2133,7 +2096,6 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 	 * FIXME add more tests!  cancel requests, verify the data, control
 	 * queueing, concurrent read+write threads, and so on.
 	 */
-	do_gettimeofday(&start);
 	switch (param->test_num) {
 
 	case 0:
@@ -2548,13 +2510,116 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev->in_pipe, NULL, 0);
 		break;
 	}
-	do_gettimeofday(&param->duration);
-	param->duration.tv_sec -= start.tv_sec;
-	param->duration.tv_usec -= start.tv_usec;
-	if (param->duration.tv_usec < 0) {
-		param->duration.tv_usec += 1000 * 1000;
-		param->duration.tv_sec -= 1;
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* We only have this one interface to user space, through usbfs.
+ * User mode code can scan usbfs to find N different devices (maybe on
+ * different busses) to use when testing, and allocate one thread per
+ * test.  So discovery is simplified, and we have no device naming issues.
+ *
+ * Don't use these only as stress/load tests.  Use them along with with
+ * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,
+ * video capture, and so on.  Run different tests at different times, in
+ * different sequences.  Nothing here should interact with other devices,
+ * except indirectly by consuming USB bandwidth and CPU resources for test
+ * threads and request completion.  But the only way to know that for sure
+ * is to test when HC queues are in use by many devices.
+ *
+ * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),
+ * it locks out usbcore in certain code paths.  Notably, if you disconnect
+ * the device-under-test, hub_wq will wait block forever waiting for the
+ * ioctl to complete ... so that usb_disconnect() can abort the pending
+ * urbs and then call usbtest_disconnect().  To abort a test, you're best
+ * off just killing the userspace task and waiting for it to exit.
+ */
+
+static int
+usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
+{
+
+	struct usbtest_dev	*dev = usb_get_intfdata(intf);
+	struct usbtest_param_64 *param_64 = buf;
+	struct usbtest_param_32 temp;
+	struct usbtest_param_32 *param_32 = buf;
+	struct timespec64 start;
+	struct timespec64 end;
+	struct timespec64 duration;
+	int retval = -EOPNOTSUPP;
+
+	/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */
+
+	pattern = mod_pattern;
+
+	if (mutex_lock_interruptible(&dev->lock))
+		return -ERESTARTSYS;
+
+	/* FIXME: What if a system sleep starts while a test is running? */
+
+	/* some devices, like ez-usb default devices, need a non-default
+	 * altsetting to have any active endpoints.  some tests change
+	 * altsettings; force a default so most tests don't need to check.
+	 */
+	if (dev->info->alt >= 0) {
+		if (intf->altsetting->desc.bInterfaceNumber) {
+			retval = -ENODEV;
+			goto free_mutex;
+		}
+		retval = set_altsetting(dev, dev->info->alt);
+		if (retval) {
+			dev_err(&intf->dev,
+					"set altsetting to %d failed, %d\n",
+					dev->info->alt, retval);
+			goto free_mutex;
+		}
+	}
+
+	switch (code) {
+	case USBTEST_REQUEST_64:
+		temp.test_num = param_64->test_num;
+		temp.iterations = param_64->iterations;
+		temp.length = param_64->length;
+		temp.sglen = param_64->sglen;
+		temp.vary = param_64->vary;
+		param_32 = &temp;
+		break;
+
+	case USBTEST_REQUEST_32:
+		break;
+
+	default:
+		retval = -EOPNOTSUPP;
+		goto free_mutex;
+	}
+
+	ktime_get_ts64(&start);
+
+	retval = usbtest_do_ioctl(intf, param_32);
+	if (retval)
+		goto free_mutex;
+
+	ktime_get_ts64(&end);
+
+	duration = timespec64_sub(end, start);
+
+	temp.duration_sec = duration.tv_sec;
+	temp.duration_usec = duration.tv_nsec/NSEC_PER_USEC;
+
+	switch (code) {
+	case USBTEST_REQUEST_32:
+		param_32->duration_sec = temp.duration_sec;
+		param_32->duration_usec = temp.duration_usec;
+		break;
+
+	case USBTEST_REQUEST_64:
+		param_64->duration_sec = temp.duration_sec;
+		param_64->duration_usec = temp.duration_usec;
+		break;
 	}
+
+free_mutex:
 	mutex_unlock(&dev->lock);
 	return retval;
 }

commit c7c7806700e15ca9c48d880f8c65071f041cd890
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Nov 18 17:40:23 2015 +0800

    usb: misc: usbtest: improve the description for error message
    
    Now the function of complicated_callback is not only used for iso
    transfer, improve the error message to reflect it.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 637f3f7cfce8..c1bd1eb548bb 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1849,7 +1849,7 @@ static void complicated_callback(struct urb *urb)
 			goto done;
 		default:
 			dev_err(&ctx->dev->intf->dev,
-					"iso resubmit err %d\n",
+					"resubmit err %d\n",
 					status);
 			/* FALLTHROUGH */
 		case -ENODEV:			/* disconnected */
@@ -1863,7 +1863,7 @@ static void complicated_callback(struct urb *urb)
 	if (ctx->pending == 0) {
 		if (ctx->errors)
 			dev_err(&ctx->dev->intf->dev,
-				"iso test, %lu errors out of %lu\n",
+				"during the test, %lu errors out of %lu\n",
 				ctx->errors, ctx->packet_count);
 		complete(&ctx->done);
 	}

commit 145f48c518edb945ea5b689a1d21052597f9d64b
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Oct 13 15:18:21 2015 +0800

    usb: misc: usbtest: add bulk queue test
    
    The bulk queue tests are used to show 'best performance' for bulk
    transfer, we are often asked this question by users. The implementation
    is the same with iso test, that is queue request at interrupt completion,
    so we reuse the iso structures, and rename them as common one.
    
    It's result should be very close to IC simulation, in order
    to get that, the device side should also need to prepare enough
    queue.
    
    We have got the 'best performance' (IN: 41MB, OUT: 39MB) at i.mx platform
    (USB2, ARM Cortex A9, stream mode need to enable) with below command:
    
    Host side:
    modprobe usbtest
    ./testusb -a -t 27 -g 64 -s 16384
    ./testusb -a -t 28 -g 64 -s 16384
    Gadget side:
    modprobe g_zero loopdefault=1 qlen=64 buflen=16384
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index ad6dd4a1de6c..637f3f7cfce8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -17,6 +17,7 @@
 static int override_alt = -1;
 module_param_named(alt, override_alt, int, 0644);
 MODULE_PARM_DESC(alt, ">= 0 to override altsetting selection");
+static void complicated_callback(struct urb *urb);
 
 /*-------------------------------------------------------------------------*/
 
@@ -239,7 +240,8 @@ static struct urb *usbtest_alloc_urb(
 	unsigned long		bytes,
 	unsigned		transfer_flags,
 	unsigned		offset,
-	u8			bInterval)
+	u8			bInterval,
+	usb_complete_t		complete_fn)
 {
 	struct urb		*urb;
 
@@ -248,10 +250,10 @@ static struct urb *usbtest_alloc_urb(
 		return urb;
 
 	if (bInterval)
-		usb_fill_int_urb(urb, udev, pipe, NULL, bytes, simple_callback,
+		usb_fill_int_urb(urb, udev, pipe, NULL, bytes, complete_fn,
 				NULL, bInterval);
 	else
-		usb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, simple_callback,
+		usb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, complete_fn,
 				NULL);
 
 	urb->interval = (udev->speed == USB_SPEED_HIGH)
@@ -296,7 +298,17 @@ static struct urb *simple_alloc_urb(
 	u8			bInterval)
 {
 	return usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,
-			bInterval);
+			bInterval, simple_callback);
+}
+
+static struct urb *complicated_alloc_urb(
+	struct usb_device	*udev,
+	int			pipe,
+	unsigned long		bytes,
+	u8			bInterval)
+{
+	return usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,
+			bInterval, complicated_callback);
 }
 
 static unsigned pattern;
@@ -1795,12 +1807,12 @@ static int ctrl_out(struct usbtest_dev *dev,
 
 /*-------------------------------------------------------------------------*/
 
-/* ISO tests ... mimics common usage
+/* ISO/BULK tests ... mimics common usage
  *  - buffer length is split into N packets (mostly maxpacket sized)
  *  - multi-buffers according to sglen
  */
 
-struct iso_context {
+struct transfer_context {
 	unsigned		count;
 	unsigned		pending;
 	spinlock_t		lock;
@@ -1809,11 +1821,12 @@ struct iso_context {
 	unsigned long		errors;
 	unsigned long		packet_count;
 	struct usbtest_dev	*dev;
+	bool			is_iso;
 };
 
-static void iso_callback(struct urb *urb)
+static void complicated_callback(struct urb *urb)
 {
-	struct iso_context	*ctx = urb->context;
+	struct transfer_context	*ctx = urb->context;
 
 	spin_lock(&ctx->lock);
 	ctx->count--;
@@ -1822,7 +1835,7 @@ static void iso_callback(struct urb *urb)
 	if (urb->error_count > 0)
 		ctx->errors += urb->error_count;
 	else if (urb->status != 0)
-		ctx->errors += urb->number_of_packets;
+		ctx->errors += (ctx->is_iso ? urb->number_of_packets : 1);
 	else if (urb->actual_length != urb->transfer_buffer_length)
 		ctx->errors++;
 	else if (check_guard_bytes(ctx->dev, urb) != 0)
@@ -1909,7 +1922,7 @@ static struct urb *iso_alloc_urb(
 		urb->iso_frame_desc[i].offset = maxp * i;
 	}
 
-	urb->complete = iso_callback;
+	urb->complete = complicated_callback;
 	/* urb->context = SET BY CALLER */
 	urb->interval = 1 << (desc->bInterval - 1);
 	urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
@@ -1917,10 +1930,10 @@ static struct urb *iso_alloc_urb(
 }
 
 static int
-test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
+test_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 		int pipe, struct usb_endpoint_descriptor *desc, unsigned offset)
 {
-	struct iso_context	context;
+	struct transfer_context	context;
 	struct usb_device	*udev;
 	unsigned		i;
 	unsigned long		packets = 0;
@@ -1930,20 +1943,20 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	memset(&context, 0, sizeof(context));
 	context.count = param->iterations * param->sglen;
 	context.dev = dev;
+	context.is_iso = !!desc;
 	init_completion(&context.done);
 	spin_lock_init(&context.lock);
 
 	udev = testdev_to_usbdev(dev);
-	dev_info(&dev->intf->dev,
-		"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",
-		1 << (desc->bInterval - 1),
-		(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
-		usb_endpoint_maxp(desc) & 0x7ff,
-		1 + (0x3 & (usb_endpoint_maxp(desc) >> 11)));
 
 	for (i = 0; i < param->sglen; i++) {
-		urbs[i] = iso_alloc_urb(udev, pipe, desc,
+		if (context.is_iso)
+			urbs[i] = iso_alloc_urb(udev, pipe, desc,
 					param->length, offset);
+		else
+			urbs[i] = complicated_alloc_urb(udev, pipe,
+					param->length, 0);
+
 		if (!urbs[i]) {
 			status = -ENOMEM;
 			goto fail;
@@ -1952,11 +1965,21 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 		urbs[i]->context = &context;
 	}
 	packets *= param->iterations;
-	dev_info(&dev->intf->dev,
-		"total %lu msec (%lu packets)\n",
-		(packets * (1 << (desc->bInterval - 1)))
-			/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
-		packets);
+
+	if (context.is_iso) {
+		dev_info(&dev->intf->dev,
+			"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",
+			1 << (desc->bInterval - 1),
+			(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
+			usb_endpoint_maxp(desc) & 0x7ff,
+			1 + (0x3 & (usb_endpoint_maxp(desc) >> 11)));
+
+		dev_info(&dev->intf->dev,
+			"total %lu msec (%lu packets)\n",
+			(packets * (1 << (desc->bInterval - 1)))
+				/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
+			packets);
+	}
 
 	spin_lock_irq(&context.lock);
 	for (i = 0; i < param->sglen; i++) {
@@ -1993,7 +2016,8 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 		;
 	else if (context.submit_error)
 		status = -EACCES;
-	else if (context.errors > context.packet_count / 10)
+	else if (context.errors >
+			(context.is_iso ? context.packet_count / 10 : 0))
 		status = -EIO;
 	return status;
 
@@ -2014,8 +2038,8 @@ static int test_unaligned_bulk(
 	const char *label)
 {
 	int retval;
-	struct urb *urb = usbtest_alloc_urb(
-		testdev_to_usbdev(tdev), pipe, length, transfer_flags, 1, 0);
+	struct urb *urb = usbtest_alloc_urb(testdev_to_usbdev(tdev),
+			pipe, length, transfer_flags, 1, 0, simple_callback);
 
 	if (!urb)
 		return -ENOMEM;
@@ -2342,7 +2366,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				param->iterations,
 				param->sglen, param->length);
 		/* FIRMWARE:  iso sink */
-		retval = test_iso_queue(dev, param,
+		retval = test_queue(dev, param,
 				dev->out_iso_pipe, dev->iso_out, 0);
 		break;
 
@@ -2355,7 +2379,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				param->iterations,
 				param->sglen, param->length);
 		/* FIRMWARE:  iso source */
-		retval = test_iso_queue(dev, param,
+		retval = test_queue(dev, param,
 				dev->in_iso_pipe, dev->iso_in, 0);
 		break;
 
@@ -2436,7 +2460,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 22:  write %d iso odd, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		retval = test_iso_queue(dev, param,
+		retval = test_queue(dev, param,
 				dev->out_iso_pipe, dev->iso_out, 1);
 		break;
 
@@ -2447,7 +2471,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 23:  read %d iso odd, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		retval = test_iso_queue(dev, param,
+		retval = test_queue(dev, param,
 				dev->in_iso_pipe, dev->iso_in, 1);
 		break;
 
@@ -2504,6 +2528,25 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		retval = simple_io(dev, urb, param->iterations, 0, 0, "test26");
 		simple_free_urb(urb);
 		break;
+	case 27:
+		/* We do performance test, so ignore data compare */
+		if (dev->out_pipe == 0 || param->sglen == 0 || pattern != 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 27: bulk write %dMbytes\n", (param->iterations *
+			param->sglen * param->length) / (1024 * 1024));
+		retval = test_queue(dev, param,
+				dev->out_pipe, NULL, 0);
+		break;
+	case 28:
+		if (dev->in_pipe == 0 || param->sglen == 0 || pattern != 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 28: bulk read %dMbytes\n", (param->iterations *
+			param->sglen * param->length) / (1024 * 1024));
+		retval = test_queue(dev, param,
+				dev->in_pipe, NULL, 0);
+		break;
 	}
 	do_gettimeofday(&param->duration);
 	param->duration.tv_sec -= start.tv_sec;

commit b9a6e8e1001e28fecbd74c073f5503dac2790563
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 1 09:48:01 2015 +0800

    usb: misc: usbtest: format the data pattern according to max packet size
    
    With this change, the host and gadget doesn't need to agree with transfer
    length for comparing the data, since they doesn't know each other's
    transfer size, but know max packet size.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    (Fixed the 'line over 80 characters warning' by Peter Chen)
    Tested-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index cac93b77f9a7..ad6dd4a1de6c 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -304,11 +304,20 @@ static unsigned mod_pattern;
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(mod_pattern, "i/o pattern (0 == zeroes)");
 
-static inline void simple_fill_buf(struct urb *urb)
+static unsigned get_maxpacket(struct usb_device *udev, int pipe)
+{
+	struct usb_host_endpoint	*ep;
+
+	ep = usb_pipe_endpoint(udev, pipe);
+	return le16_to_cpup(&ep->desc.wMaxPacketSize);
+}
+
+static void simple_fill_buf(struct urb *urb)
 {
 	unsigned	i;
 	u8		*buf = urb->transfer_buffer;
 	unsigned	len = urb->transfer_buffer_length;
+	unsigned	maxpacket;
 
 	switch (pattern) {
 	default:
@@ -317,8 +326,9 @@ static inline void simple_fill_buf(struct urb *urb)
 		memset(buf, 0, len);
 		break;
 	case 1:			/* mod63 */
+		maxpacket = get_maxpacket(urb->dev, urb->pipe);
 		for (i = 0; i < len; i++)
-			*buf++ = (u8) (i % 63);
+			*buf++ = (u8) ((i % maxpacket) % 63);
 		break;
 	}
 }
@@ -350,6 +360,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 	u8		expected;
 	u8		*buf = urb->transfer_buffer;
 	unsigned	len = urb->actual_length;
+	unsigned	maxpacket = get_maxpacket(urb->dev, urb->pipe);
 
 	int ret = check_guard_bytes(tdev, urb);
 	if (ret)
@@ -367,7 +378,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 		 * with set_interface or set_config.
 		 */
 		case 1:			/* mod63 */
-			expected = i % 63;
+			expected = (i % maxpacket) % 63;
 			break;
 		/* always fail unsupported patterns */
 		default:
@@ -479,11 +490,13 @@ static void free_sglist(struct scatterlist *sg, int nents)
 }
 
 static struct scatterlist *
-alloc_sglist(int nents, int max, int vary)
+alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 {
 	struct scatterlist	*sg;
 	unsigned		i;
 	unsigned		size = max;
+	unsigned		maxpacket =
+		get_maxpacket(interface_to_usbdev(dev->intf), pipe);
 
 	if (max == 0)
 		return NULL;
@@ -512,7 +525,7 @@ alloc_sglist(int nents, int max, int vary)
 			break;
 		case 1:
 			for (j = 0; j < size; j++)
-				*buf++ = (u8) (j % 63);
+				*buf++ = (u8) ((j % maxpacket) % 63);
 			break;
 		}
 
@@ -2176,7 +2189,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 5:  write %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist(param->sglen, param->length, 0);
+		sg = alloc_sglist(param->sglen, param->length,
+				0, dev, dev->out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2194,7 +2208,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 6:  read %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist(param->sglen, param->length, 0);
+		sg = alloc_sglist(param->sglen, param->length,
+				0, dev, dev->in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2211,7 +2226,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist(param->sglen, param->length, param->vary);
+		sg = alloc_sglist(param->sglen, param->length,
+				param->vary, dev, dev->out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2228,7 +2244,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist(param->sglen, param->length, param->vary);
+		sg = alloc_sglist(param->sglen, param->length,
+				param->vary, dev, dev->in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;

commit 169900f96792c11a5435773dd379046bc8036704
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 1 09:48:00 2015 +0800

    usb: misc: usbtest: using the same data format among write/compare/output
    
    Using the same data format "buf[j] = (u8)(i + j)" among
    write, compare buf, and console output stage.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 819b4b1f327b..cac93b77f9a7 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1720,7 +1720,7 @@ static int ctrl_out(struct usbtest_dev *dev,
 	for (i = 0; i < count; i++) {
 		/* write patterned data */
 		for (j = 0; j < len; j++)
-			buf[j] = i + j;
+			buf[j] = (u8)(i + j);
 		retval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,
 				0, 0, buf, len, USB_CTRL_SET_TIMEOUT);
@@ -1750,9 +1750,9 @@ static int ctrl_out(struct usbtest_dev *dev,
 
 		/* fail if we can't verify */
 		for (j = 0; j < len; j++) {
-			if (buf[j] != (u8) (i + j)) {
+			if (buf[j] != (u8)(i + j)) {
 				ERROR(dev, "ctrl_out, byte %d is %d not %d\n",
-					j, buf[j], (u8) i + j);
+					j, buf[j], (u8)(i + j));
 				retval = -EBADMSG;
 				break;
 			}

commit a724ddfb17e0519d2c2b6e09a96b1b94eff6b801
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 1 09:47:59 2015 +0800

    usb: misc: usbtest: delete useless memset for urbs array
    
    The element of urbs array will be initialized at below code
    at once.
    
            for (i = 0; i < param->sglen; i++) {
                    urbs[i] = iso_alloc_urb(udev, pipe, desc,
                                            param->length, offset);
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 8f294d716369..819b4b1f327b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1920,7 +1920,6 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	init_completion(&context.done);
 	spin_lock_init(&context.lock);
 
-	memset(urbs, 0, sizeof(urbs));
 	udev = testdev_to_usbdev(dev);
 	dev_info(&dev->intf->dev,
 		"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",

commit 41d3c0b84d6e084865c429b1b6825256c0169319
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 1 09:47:58 2015 +0800

    usb: misc: usbtest: allocate size of urb array according to user parameter
    
    Allocate the size of urb pointer array according to testusb's
    parameter sglen, and limits the length of sglen as MAX_SGLEN
    (128 currently).
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 9517812a50e2..8f294d716369 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -95,6 +95,7 @@ static struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)
 	dev_warn(&(tdev)->intf->dev , fmt , ## args)
 
 #define GUARD_BYTE	0xA5
+#define MAX_SGLEN	128
 
 /*-------------------------------------------------------------------------*/
 
@@ -1911,10 +1912,7 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	unsigned		i;
 	unsigned long		packets = 0;
 	int			status = 0;
-	struct urb		*urbs[10];	/* FIXME no limit */
-
-	if (param->sglen > 10)
-		return -EDOM;
+	struct urb		*urbs[param->sglen];
 
 	memset(&context, 0, sizeof(context));
 	context.count = param->iterations * param->sglen;
@@ -2061,6 +2059,9 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 	if (param->iterations <= 0)
 		return -EINVAL;
 
+	if (param->sglen > MAX_SGLEN)
+		return -EINVAL;
+
 	if (mutex_lock_interruptible(&dev->lock))
 		return -ERESTARTSYS;
 

commit a0c9d0defcdadd31ab111b1616f60cf919c6a020
Author: Peter Chen <peter.chen@freescale.com>
Date:   Mon Aug 17 16:36:53 2015 +0800

    usb: misc: usbtest: format max packet size for iso transfer
    
    The current code prints all wMaxPacketSize content at endpoint
    descriptor, if there is a high speed, high bandwidth endpoint,
    it may confuse the users, eg, if there are 3 transactions during
    microframe, it will print "wMaxPacket 1400" for packet content.
    This commit splits wMaxpacketSize and transaction numbers for
    output messages.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 0bbafe795a72..9517812a50e2 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1925,10 +1925,11 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	memset(urbs, 0, sizeof(urbs));
 	udev = testdev_to_usbdev(dev);
 	dev_info(&dev->intf->dev,
-		"... iso period %d %sframes, wMaxPacket %04x\n",
+		"iso period %d %sframes, wMaxPacket %d, transactions: %d\n",
 		1 << (desc->bInterval - 1),
 		(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
-		usb_endpoint_maxp(desc));
+		usb_endpoint_maxp(desc) & 0x7ff,
+		1 + (0x3 & (usb_endpoint_maxp(desc) >> 11)));
 
 	for (i = 0; i < param->sglen; i++) {
 		urbs[i] = iso_alloc_urb(udev, pipe, desc,
@@ -1942,7 +1943,7 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	}
 	packets *= param->iterations;
 	dev_info(&dev->intf->dev,
-		"... total %lu msec (%lu packets)\n",
+		"total %lu msec (%lu packets)\n",
 		(packets * (1 << (desc->bInterval - 1)))
 			/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
 		packets);

commit 37ebb54915dc42944f6ae92fe53b9531c3903801
Author: Petr Mladek <pmladek@suse.cz>
Date:   Fri Sep 19 17:32:23 2014 +0200

    usb: hub: rename khubd to hub_wq in documentation and comments
    
    USB hub has started to use a workqueue instead of kthread. Let's update
    the documentation and comments here and there.
    
    This patch mostly just replaces "khubd" with "hub_wq". There are only few
    exceptions where the whole sentence was updated. These more complicated
    changes can be found in the following files:
    
               Documentation/usb/hotplug.txt
               drivers/net/usb/usbnet.c
               drivers/usb/core/hcd.c
               drivers/usb/host/ohci-hcd.c
               drivers/usb/host/xhci.c
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 90e6644dc886..0bbafe795a72 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2031,7 +2031,7 @@ static int test_unaligned_bulk(
  *
  * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),
  * it locks out usbcore in certain code paths.  Notably, if you disconnect
- * the device-under-test, khubd will wait block forever waiting for the
+ * the device-under-test, hub_wq will wait block forever waiting for the
  * ioctl to complete ... so that usb_disconnect() can abort the pending
  * urbs and then call usbtest_disconnect().  To abort a test, you're best
  * off just killing the userspace task and waiting for it to exit.

commit 457a0955e152ac3b0de46ecbe7a8b434856fda67
Author: Amit Virdi <amit.virdi@st.com>
Date:   Fri Aug 22 14:36:37 2014 +0530

    usbtest: Add interrupt EP testcases
    
    Two simple test cases for interrupt endpoints are added to the usbtest.c file.
    These are simple non-queued interrupt IN and interrupt OUT transfers. Currently,
    only gadget zero is capable of executing the interrupt EP test cases. However,
    extending the same to other gadgets is extremely simple and can be done
    on-demand.
    
    The two new tests added are
      - Test 25: To verify Interrupt OUT transfer
      - Test 26: To verify Interrupt IN transfer
    
    Since the default value of wMaxPacketSize is set as 1024, so interrupt
    IN transfers must be specified with the size parameter = multiple of
    1024. Otherwise the default value (512) in the usbtest application fails
    the transfer. See [RUN 4] for sample logs
    
    The application logs (usbtest) and corresponding kernel logs are as
    following:
    
    [Run 1]
    ./testusb -a -c 10 -s 2048 -t 26 -v 511
    usbtest 7-1:3.0: TEST 26: read 2048 bytes 10 times
    
    [Run 2]
    ./testusb -a -c 10 -s 1024 -t 25 -v 511
    usbtest 7-1:3.0: TEST 25: write 1024 bytes 10 times
    
    [Run 3]
    ./testusb -a -c 10 -s 1098 -t 25 -v 511
    usbtest 7-1:3.0: TEST 25: write 1098 bytes 10 times
    
    [Run 4 - Failure case scenario]
    ./testusb -a  -t 26
    unknown speed   /dev/bus/usb/007/004    0
    /dev/bus/usb/007/004 test 26 --> 75 (Value too large for defined data type)
    
    usbtest 7-1:3.0: TEST 26: read 512 bytes 1000 times
    usb 7-1: test26 failed, iterations left 999, status -75 (not 0)
    
    Signed-off-by: Amit Virdi <amit.virdi@st.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 829f446064ea..90e6644dc886 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -54,6 +54,7 @@ struct usbtest_info {
 	unsigned		autoconf:1;
 	unsigned		ctrl_out:1;
 	unsigned		iso:1;		/* try iso in/out */
+	unsigned		intr:1;		/* try interrupt in/out */
 	int			alt;
 };
 
@@ -70,7 +71,10 @@ struct usbtest_dev {
 	int			out_pipe;
 	int			in_iso_pipe;
 	int			out_iso_pipe;
+	int			in_int_pipe;
+	int			out_int_pipe;
 	struct usb_endpoint_descriptor	*iso_in, *iso_out;
+	struct usb_endpoint_descriptor	*int_in, *int_out;
 	struct mutex		lock;
 
 #define TBUF_SIZE	256
@@ -101,6 +105,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 	struct usb_host_interface	*alt;
 	struct usb_host_endpoint	*in, *out;
 	struct usb_host_endpoint	*iso_in, *iso_out;
+	struct usb_host_endpoint	*int_in, *int_out;
 	struct usb_device		*udev;
 
 	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
@@ -108,6 +113,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 
 		in = out = NULL;
 		iso_in = iso_out = NULL;
+		int_in = int_out = NULL;
 		alt = intf->altsetting + tmp;
 
 		if (override_alt >= 0 &&
@@ -124,6 +130,9 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			switch (usb_endpoint_type(&e->desc)) {
 			case USB_ENDPOINT_XFER_BULK:
 				break;
+			case USB_ENDPOINT_XFER_INT:
+				if (dev->info->intr)
+					goto try_intr;
 			case USB_ENDPOINT_XFER_ISOC:
 				if (dev->info->iso)
 					goto try_iso;
@@ -139,6 +148,15 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 					out = e;
 			}
 			continue;
+try_intr:
+			if (usb_endpoint_dir_in(&e->desc)) {
+				if (!int_in)
+					int_in = e;
+			} else {
+				if (!int_out)
+					int_out = e;
+			}
+			continue;
 try_iso:
 			if (usb_endpoint_dir_in(&e->desc)) {
 				if (!iso_in)
@@ -148,7 +166,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 					iso_out = e;
 			}
 		}
-		if ((in && out)  ||  iso_in || iso_out)
+		if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
 			goto found;
 	}
 	return -EINVAL;
@@ -183,6 +201,20 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 				iso_out->desc.bEndpointAddress
 					& USB_ENDPOINT_NUMBER_MASK);
 	}
+
+	if (int_in) {
+		dev->int_in = &int_in->desc;
+		dev->in_int_pipe = usb_rcvintpipe(udev,
+				int_in->desc.bEndpointAddress
+					& USB_ENDPOINT_NUMBER_MASK);
+	}
+
+	if (int_out) {
+		dev->int_out = &int_out->desc;
+		dev->out_int_pipe = usb_sndintpipe(udev,
+				int_out->desc.bEndpointAddress
+					& USB_ENDPOINT_NUMBER_MASK);
+	}
 	return 0;
 }
 
@@ -205,14 +237,22 @@ static struct urb *usbtest_alloc_urb(
 	int			pipe,
 	unsigned long		bytes,
 	unsigned		transfer_flags,
-	unsigned		offset)
+	unsigned		offset,
+	u8			bInterval)
 {
 	struct urb		*urb;
 
 	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb)
 		return urb;
-	usb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, simple_callback, NULL);
+
+	if (bInterval)
+		usb_fill_int_urb(urb, udev, pipe, NULL, bytes, simple_callback,
+				NULL, bInterval);
+	else
+		usb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, simple_callback,
+				NULL);
+
 	urb->interval = (udev->speed == USB_SPEED_HIGH)
 			? (INTERRUPT_RATE << 3)
 			: INTERRUPT_RATE;
@@ -251,9 +291,11 @@ static struct urb *usbtest_alloc_urb(
 static struct urb *simple_alloc_urb(
 	struct usb_device	*udev,
 	int			pipe,
-	unsigned long		bytes)
+	unsigned long		bytes,
+	u8			bInterval)
 {
-	return usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0);
+	return usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,
+			bInterval);
 }
 
 static unsigned pattern;
@@ -1255,7 +1297,7 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 			goto cleanup;
 		}
 		req.wLength = cpu_to_le16(len);
-		urb[i] = u = simple_alloc_urb(udev, pipe, len);
+		urb[i] = u = simple_alloc_urb(udev, pipe, len, 0);
 		if (!u)
 			goto cleanup;
 
@@ -1328,7 +1370,7 @@ static int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)
 	int			retval = 0;
 
 	init_completion(&completion);
-	urb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size);
+	urb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size, 0);
 	if (!urb)
 		return -ENOMEM;
 	urb->context = &completion;
@@ -1616,9 +1658,9 @@ static int halt_simple(struct usbtest_dev *dev)
 	struct usb_device	*udev = testdev_to_usbdev(dev);
 
 	if (udev->speed == USB_SPEED_SUPER)
-		urb = simple_alloc_urb(udev, 0, 1024);
+		urb = simple_alloc_urb(udev, 0, 1024, 0);
 	else
-		urb = simple_alloc_urb(udev, 0, 512);
+		urb = simple_alloc_urb(udev, 0, 512, 0);
 	if (urb == NULL)
 		return -ENOMEM;
 
@@ -1962,7 +2004,7 @@ static int test_unaligned_bulk(
 {
 	int retval;
 	struct urb *urb = usbtest_alloc_urb(
-		testdev_to_usbdev(tdev), pipe, length, transfer_flags, 1);
+		testdev_to_usbdev(tdev), pipe, length, transfer_flags, 1, 0);
 
 	if (!urb)
 		return -ENOMEM;
@@ -2068,7 +2110,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 1:  write %d bytes %u times\n",
 				param->length, param->iterations);
-		urb = simple_alloc_urb(udev, dev->out_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
@@ -2083,7 +2125,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 2:  read %d bytes %u times\n",
 				param->length, param->iterations);
-		urb = simple_alloc_urb(udev, dev->in_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
@@ -2098,7 +2140,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 3:  write/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
-		urb = simple_alloc_urb(udev, dev->out_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
@@ -2114,7 +2156,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 4:  read/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
-		urb = simple_alloc_urb(udev, dev->in_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
@@ -2411,6 +2453,39 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		}
 		break;
 
+	/* Simple non-queued interrupt I/O tests */
+	case 25:
+		if (dev->out_int_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+				"TEST 25: write %d bytes %u times\n",
+				param->length, param->iterations);
+		urb = simple_alloc_urb(udev, dev->out_int_pipe, param->length,
+				dev->int_out->bInterval);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		/* FIRMWARE: interrupt sink (maybe accepts short writes) */
+		retval = simple_io(dev, urb, param->iterations, 0, 0, "test25");
+		simple_free_urb(urb);
+		break;
+	case 26:
+		if (dev->in_int_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+				"TEST 26: read %d bytes %u times\n",
+				param->length, param->iterations);
+		urb = simple_alloc_urb(udev, dev->in_int_pipe, param->length,
+				dev->int_in->bInterval);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		/* FIRMWARE: interrupt source (maybe generates short writes) */
+		retval = simple_io(dev, urb, param->iterations, 0, 0, "test26");
+		simple_free_urb(urb);
+		break;
 	}
 	do_gettimeofday(&param->duration);
 	param->duration.tv_sec -= start.tv_sec;
@@ -2447,6 +2522,7 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	struct usbtest_info	*info;
 	char			*rtest, *wtest;
 	char			*irtest, *iwtest;
+	char			*intrtest, *intwtest;
 
 	udev = interface_to_usbdev(intf);
 
@@ -2487,6 +2563,7 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 */
 	rtest = wtest = "";
 	irtest = iwtest = "";
+	intrtest = intwtest = "";
 	if (force_interrupt || udev->speed == USB_SPEED_LOW) {
 		if (info->ep_in) {
 			dev->in_pipe = usb_rcvintpipe(udev, info->ep_in);
@@ -2525,15 +2602,20 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			irtest = " iso-in";
 		if (dev->out_iso_pipe)
 			iwtest = " iso-out";
+		if (dev->in_int_pipe)
+			intrtest = " int-in";
+		if (dev->out_int_pipe)
+			intwtest = " int-out";
 	}
 
 	usb_set_intfdata(intf, dev);
 	dev_info(&intf->dev, "%s\n", info->name);
-	dev_info(&intf->dev, "%s {control%s%s%s%s%s} tests%s\n",
+	dev_info(&intf->dev, "%s {control%s%s%s%s%s%s%s} tests%s\n",
 			usb_speed_string(udev->speed),
 			info->ctrl_out ? " in/out" : "",
 			rtest, wtest,
 			irtest, iwtest,
+			intrtest, intwtest,
 			info->alt >= 0 ? " (+alt)" : "");
 	return 0;
 }
@@ -2607,6 +2689,7 @@ static struct usbtest_info gz_info = {
 	.autoconf	= 1,
 	.ctrl_out	= 1,
 	.iso		= 1,
+	.intr		= 1,
 	.alt		= 0,
 };
 

commit 32b36eeae6a859670d2939a7d6136cb5e9ed64f8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 3 11:11:34 2014 -0400

    USB: usbtest: add a timeout for scatter-gather tests
    
    In usbtest, tests 5 - 8 use the scatter-gather library in usbcore
    without any sort of timeout.  If there's a problem in the gadget or
    host controller being tested, the test can hang.
    
    This patch adds a 10-second timeout to the tests, so that they will
    fail gracefully with an ETIMEDOUT error instead of hanging.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Huang Rui <ray.huang@amd.com>
    Tested-by: Huang Rui <ray.huang@amd.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 51a6da256772..829f446064ea 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -7,7 +7,7 @@
 #include <linux/moduleparam.h>
 #include <linux/scatterlist.h>
 #include <linux/mutex.h>
-
+#include <linux/timer.h>
 #include <linux/usb.h>
 
 #define SIMPLE_IO_TIMEOUT	10000	/* in milliseconds */
@@ -484,6 +484,14 @@ alloc_sglist(int nents, int max, int vary)
 	return sg;
 }
 
+static void sg_timeout(unsigned long _req)
+{
+	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
+
+	req->status = -ETIMEDOUT;
+	usb_sg_cancel(req);
+}
+
 static int perform_sglist(
 	struct usbtest_dev	*tdev,
 	unsigned		iterations,
@@ -495,6 +503,9 @@ static int perform_sglist(
 {
 	struct usb_device	*udev = testdev_to_usbdev(tdev);
 	int			retval = 0;
+	struct timer_list	sg_timer;
+
+	setup_timer_on_stack(&sg_timer, sg_timeout, (unsigned long) req);
 
 	while (retval == 0 && iterations-- > 0) {
 		retval = usb_sg_init(req, udev, pipe,
@@ -505,7 +516,10 @@ static int perform_sglist(
 
 		if (retval)
 			break;
+		mod_timer(&sg_timer, jiffies +
+				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
+		del_timer_sync(&sg_timer);
 		retval = req->status;
 
 		/* FIXME check resulting data pattern */

commit a7683eb3af6df30e3a3f3666d834e9abba8f5c22
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu May 22 18:06:14 2014 +0800

    usb: usbtest: add pattern check on pipe in phase of unlink read
    
    TEST 11 unlinks the URB read request for N times. When host and gadget
    both initialize pattern 1 (mod 63) data series to do IN transfer, the
    host side function should check the data buffer if it is as mod 63
    series, because the data packet which host receivced will follow
    pattern 1. So this patch adds this checking action.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 4ed457edde23..51a6da256772 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1345,6 +1345,9 @@ static int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)
 		while (!completion_done(&completion)) {
 			retval = usb_unlink_urb(urb);
 
+			if (retval == 0 && usb_pipein(urb->pipe))
+				retval = simple_check_buf(dev, urb);
+
 			switch (retval) {
 			case -EBUSY:
 			case -EIDRM:

commit e4d58f5dcb7d7be45df8def31881ebfae99c75da
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon May 26 10:55:36 2014 +0800

    usb: usbtest: fix unlink write error with pattern 1
    
    TEST 12 and TEST 24 unlinks the URB write request for N times. When
    host and gadget both initialize pattern 1 (mod 63) data series to
    transfer, the gadget side will complain the wrong data which is not
    expected.  Because in host side, usbtest doesn't fill the data buffer
    as mod 63 and this patch fixed it.
    
    [20285.488974] dwc3 dwc3.0.auto: ep1out-bulk: Transfer Not Ready
    [20285.489181] dwc3 dwc3.0.auto: ep1out-bulk: reason Transfer Not Active
    [20285.489423] dwc3 dwc3.0.auto: ep1out-bulk: req ffff8800aa6cb480 dma aeb50800 length 512 last
    [20285.489727] dwc3 dwc3.0.auto: ep1out-bulk: cmd 'Start Transfer' params 00000000 a9eaf000 00000000
    [20285.490055] dwc3 dwc3.0.auto: Command Complete --> 0
    [20285.490281] dwc3 dwc3.0.auto: ep1out-bulk: Transfer Not Ready
    [20285.490492] dwc3 dwc3.0.auto: ep1out-bulk: reason Transfer Active
    [20285.490713] dwc3 dwc3.0.auto: ep1out-bulk: endpoint busy
    [20285.490909] dwc3 dwc3.0.auto: ep1out-bulk: Transfer Complete
    [20285.491117] dwc3 dwc3.0.auto: request ffff8800aa6cb480 from ep1out-bulk completed 512/512 ===> 0
    [20285.491431] zero gadget: bad OUT byte, buf[1] = 0
    [20285.491605] dwc3 dwc3.0.auto: ep1out-bulk: cmd 'Set Stall' params 00000000 00000000 00000000
    [20285.491915] dwc3 dwc3.0.auto: Command Complete --> 0
    [20285.492099] dwc3 dwc3.0.auto: queing request ffff8800aa6cb480 to ep1out-bulk length 512
    [20285.492387] dwc3 dwc3.0.auto: ep1out-bulk: Transfer Not Ready
    [20285.492595] dwc3 dwc3.0.auto: ep1out-bulk: reason Transfer Not Active
    [20285.492830] dwc3 dwc3.0.auto: ep1out-bulk: req ffff8800aa6cb480 dma aeb51000 length 512 last
    [20285.493135] dwc3 dwc3.0.auto: ep1out-bulk: cmd 'Start Transfer' params 00000000 a9eaf000 00000000
    [20285.493465] dwc3 dwc3.0.auto: Command Complete --> 0
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index f6568b5e9b06..4ed457edde23 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1320,6 +1320,11 @@ static int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)
 	urb->context = &completion;
 	urb->complete = unlink1_callback;
 
+	if (usb_pipeout(urb->pipe)) {
+		simple_fill_buf(urb);
+		urb->transfer_flags |= URB_ZERO_PACKET;
+	}
+
 	/* keep the endpoint busy.  there are lots of hc/hcd-internal
 	 * states, and testing should get to all of them over time.
 	 *
@@ -1450,6 +1455,11 @@ static int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,
 				unlink_queued_callback, &ctx);
 		ctx.urbs[i]->transfer_dma = buf_dma;
 		ctx.urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+
+		if (usb_pipeout(ctx.urbs[i]->pipe)) {
+			simple_fill_buf(ctx.urbs[i]);
+			ctx.urbs[i]->transfer_flags |= URB_ZERO_PACKET;
+		}
 	}
 
 	/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */

commit e2a3a64855f2f906e0ba9056a3a57aeb73b1a968
Merge: 1fc671b3be8f 9005355af238
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Dec 21 15:58:40 2013 -0800

    Merge tag 'for-usb-next-2013-12-20' of git://git.kernel.org/pub/scm/linux/kernel/git/sarah/xhci into usb-next
    
    Sarah writes:
    
    xhci: Cleanups, non-urgent fixes for 3.14.
    
    Happy Holidays, Greg!
    
    Here's four patches to be queued to usb-next for 3.14.
    
    One adds a module parameter to the xHCI driver to allow users to enable
    xHCI quirks without recompiling their kernel, which you've already said
    is fine.  The second patch is a bug fix for new usbtest code that's only
    in usb-next.  The third patch is simple cleanup.
    
    The last patch is a non-urgent bug fix for xHCI platform devices.  The
    bug has been in the code since 3.9.  You've been asking me to hold off
    on non-urgent bug fixes after -rc4/-rc5, so it can go into usb-next, and
    be backported to stable once 3.14 is out.
    
    These have all been tested over the past week.  I did run across one
    oops, but it turned out to be a bug in 3.12, and therefore not related
    to any of these patches.
    
    Please queue these for usb-next and 3.14.
    
    Thanks,
    Sarah Sharp

commit 824d752b04765fc513fe17666a539f6c73960c4e
Author: Roger Quadros <rogerq@ti.com>
Date:   Wed Dec 18 15:40:11 2013 +0530

    usb: usbtest: Always clear halt else further tests will fail
    
    In test_halt() we set an endpoint halt condition and return on halt verification
    failure, then the enpoint will remain halted and all further tests related
    to that enpoint will fail. This is because we don't tackle endpoint halt error condition
    in any of the tests. To avoid that situation, make sure to clear the
    halt condition before exiting test_halt().
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 6265c549732b..0317f10823dd 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1554,8 +1554,17 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 		return retval;
 	}
 	retval = verify_halted(tdev, ep, urb);
-	if (retval < 0)
+	if (retval < 0) {
+		int ret;
+
+		/* clear halt anyways, else further tests will fail */
+		ret = usb_clear_halt(urb->dev, urb->pipe);
+		if (ret)
+			ERROR(tdev, "ep %02x couldn't clear halt, %d\n",
+			      ep, ret);
+
 		return retval;
+	}
 
 	/* clear halt (tests API + protocol), verify it worked */
 	retval = usb_clear_halt(urb->dev, urb->pipe);

commit e5e4746510d140261918aecce2e5e3aa4456f7e9
Author: Roger Quadros <rogerq@ti.com>
Date:   Wed Dec 18 15:40:10 2013 +0530

    usb: usbtest: Add timetout to simple_io()
    
    Without a timetout some tests e.g. test_halt() can remain stuck forever.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bff058ea222e..6265c549732b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -10,6 +10,7 @@
 
 #include <linux/usb.h>
 
+#define SIMPLE_IO_TIMEOUT	10000	/* in milliseconds */
 
 /*-------------------------------------------------------------------------*/
 
@@ -366,6 +367,7 @@ static int simple_io(
 	int			max = urb->transfer_buffer_length;
 	struct completion	completion;
 	int			retval = 0;
+	unsigned long		expire;
 
 	urb->context = &completion;
 	while (retval == 0 && iterations-- > 0) {
@@ -378,9 +380,15 @@ static int simple_io(
 		if (retval != 0)
 			break;
 
-		/* NOTE:  no timeouts; can't be broken out of by interrupt */
-		wait_for_completion(&completion);
-		retval = urb->status;
+		expire = msecs_to_jiffies(SIMPLE_IO_TIMEOUT);
+		if (!wait_for_completion_timeout(&completion, expire)) {
+			usb_kill_urb(urb);
+			retval = (urb->status == -ENOENT ?
+				  -ETIMEDOUT : urb->status);
+		} else {
+			retval = urb->status;
+		}
+
 		urb->dev = udev;
 		if (retval == 0 && usb_pipein(urb->pipe))
 			retval = simple_check_buf(tdev, urb);

commit 8cf4328569acc37ac5c5b4eb27ae86c3758f627b
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Dec 13 13:44:17 2013 -0800

    usbtest: Fix BOS control test for USB 2.01 devices.
    
    Commit c952a8ba7136505cd1ca01735cc748ddc08c7d2f "usb: usbtest: add a
    test case to support bos for queue control" will cause USB 2.01 and USB
    2.10 devices with a BOS descriptor to fail case 15 of the control test.
    
    The Link PM errata (released in 2007, updated in 2011) says:
    
    "The value of the bcdUSB field in the standard USB 2.0 Device Descriptor
    is used to indicate that the device supports the request to read the BOS
    Descriptor (i.e.  GetDescriptor(BOS)). Devices that support the BOS
    descriptor must have a bcdUSB value of 0201H or larger."
    
    The current code says that non-SuperSpeed devices *must* return -EPIPE,
    as this comment shows:
    
                    /* sign of this variable means:
                     *  -: tested code must return this (negative) error code
                     *  +: tested code may return this (negative too) error code
                     */
                    int                     expected = 0;
    
    This means the test will fail with USB 2.01 and USB 2.10 devices that
    provide a BOS descriptor.  Change it to only require a stall response if
    the USB device bcdUSB is less than 2.01.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Huang Rui <ray.huang@amd.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bff058ea222e..446ff55e3c58 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1224,7 +1224,7 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 				len = le16_to_cpu(udev->bos->desc->wTotalLength);
 			else
 				len = sizeof(struct usb_bos_descriptor);
-			if (udev->speed != USB_SPEED_SUPER)
+			if (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0201)
 				expected = -EPIPE;
 			break;
 		default:

commit f625099f1a504742aef4c6ab20ba0ca981847e3c
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Nov 13 22:35:13 2013 +0800

    usb: usbtest: update bos test coverage to usb 2.1 device
    
    The commit "usb: usbtest: support bos descriptor test for usb 3.0"
    introduced a test for bos descriptor. And USB 2.1 device also can be
    checked. So this patch extends the test coverage to support USB 2.1 device.
    
    Reported-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 0b5c3b157530..bff058ea222e 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -763,7 +763,7 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 	 * there's always [9.4.3] a bos device descriptor [9.6.2] in USB
 	 * 3.0 spec
 	 */
-	if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0300) {
+	if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0210) {
 		struct usb_bos_descriptor *bos = NULL;
 		struct usb_dev_cap_header *header = NULL;
 		unsigned total, num, length;

commit 875bc23ac041519b24bd2c1faf71822e4b3e4322
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Nov 13 22:35:14 2013 +0800

    usb: usbtest: fix the bit mask of usb 2.0 extension descriptor
    
    USB 2.1 Link PM adds to use bits[1:15] according to USB 2.0 ECN Errata for
    Link Power Management spec.
    
    Bit     Encoding
    0       Reserved
    1       LPM
    2       BESL & Altemate HIRD definitions supported
    3       Recommended Baseline BESL valid
    4       Recommended Deep BESL valid
    11:8    Recommended Baseline BESL value
    15:12   Recommended Deep BESL value
    31:16   Reserved
    
    So fix the bit mask from 0x1e to 0xfffe.
    
    Reported-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index f3c31363c40a..0b5c3b157530 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -619,8 +619,8 @@ static int is_good_ext(struct usbtest_dev *tdev, u8 *buf)
 	}
 
 	attr = le32_to_cpu(ext->bmAttributes);
-	/* bits[1:4] is used and others are reserved */
-	if (attr & ~0x1e) {	/* reserved == 0 */
+	/* bits[1:15] is used and others are reserved */
+	if (attr & ~0xfffe) {	/* reserved == 0 */
 		ERROR(tdev, "reserved bits set\n");
 		return 0;
 	}

commit c952a8ba7136505cd1ca01735cc748ddc08c7d2f
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Nov 4 21:11:53 2013 +0800

    usb: usbtest: add a test case to support bos for queue control
    
    In Test 10 of usbtest module, it queues multiple control messages and
    thereby tests control message queuing, protocol stalls, short reads, and
    fault handling. And this patch add a test case to support queue BOS control
    request for USB 3.0 SPEC.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b4152820d655..f3c31363c40a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -944,7 +944,7 @@ struct ctrl_ctx {
 	int			last;
 };
 
-#define NUM_SUBCASES	15		/* how many test subcases here? */
+#define NUM_SUBCASES	16		/* how many test subcases here? */
 
 struct subcase {
 	struct usb_ctrlrequest	setup;
@@ -1218,6 +1218,15 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 			}
 			expected = -EREMOTEIO;
 			break;
+		case 15:
+			req.wValue = cpu_to_le16(USB_DT_BOS << 8);
+			if (udev->bos)
+				len = le16_to_cpu(udev->bos->desc->wTotalLength);
+			else
+				len = sizeof(struct usb_bos_descriptor);
+			if (udev->speed != USB_SPEED_SUPER)
+				expected = -EPIPE;
+			break;
 		default:
 			ERROR(dev, "bogus number of ctrl queue testcases!\n");
 			context.status = -EINVAL;

commit 8e29217f931dd8a76cdb8c88aa0975fa15f0f684
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Oct 30 11:27:40 2013 +0800

    usb: usbtest: support container id descriptor test
    
    In Test 9 of usbtest module, it is used for performing chapter 9 tests N
    times.
    
    Container ID descriptor is one of the generic device-level capbility
    descriptors which added in section 9.6.2.3 of USB 3.0 spec.
    
    This patch adds to support getting Container ID descriptor test scenario
    for USB 3.0.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index d6fcbc477fc5..b4152820d655 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -657,6 +657,25 @@ static int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)
 	return 1;
 }
 
+static int is_good_con_id(struct usbtest_dev *tdev, u8 *buf)
+{
+	struct usb_ss_container_id_descriptor *con_id;
+
+	con_id = (struct usb_ss_container_id_descriptor *) buf;
+
+	if (con_id->bLength != USB_DT_USB_SS_CONTN_ID_SIZE) {
+		ERROR(tdev, "bogus container id descriptor length\n");
+		return 0;
+	}
+
+	if (con_id->bReserved) {	/* reserved == 0 */
+		ERROR(tdev, "reserved bits set\n");
+		return 0;
+	}
+
+	return 1;
+}
+
 /* sanity test for standard requests working with usb_control_mesg() and some
  * of the utility functions which use it.
  *
@@ -810,6 +829,14 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 					return -EDOM;
 				}
 				break;
+			case CONTAINER_ID_TYPE:
+				if (buf + USB_DT_USB_SS_CONTN_ID_SIZE >
+						dev->buf + total ||
+						!is_good_con_id(dev, buf)) {
+					dev_err(&iface->dev, "bogus container id descriptor\n");
+					return -EDOM;
+				}
+				break;
 			default:
 				break;
 			}

commit b8fef79518f6a6843e53a4d578c20873ce742a1f
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Oct 30 11:27:39 2013 +0800

    usb: usbtest: support superspeed device capbility descriptor test
    
    In Test 9 of usbtest module, it is used for performing chapter 9 tests N
    times.
    
    SuperSpeed USB Device Capability descriptor is one of the generic
    device-level capbility descriptors which added in section 9.6.2.2 of USB
    3.0 spec.
    
    This patch adds to support getting SuperSpeed USB Device Capability
    descriptor test scenario for USB 3.0.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 1c78e747f72b..d6fcbc477fc5 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -628,6 +628,35 @@ static int is_good_ext(struct usbtest_dev *tdev, u8 *buf)
 	return 1;
 }
 
+static int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)
+{
+	struct usb_ss_cap_descriptor *ss;
+
+	ss = (struct usb_ss_cap_descriptor *) buf;
+
+	if (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {
+		ERROR(tdev, "bogus superspeed device capability descriptor length\n");
+		return 0;
+	}
+
+	/*
+	 * only bit[1] of bmAttributes is used for LTM and others are
+	 * reserved
+	 */
+	if (ss->bmAttributes & ~0x02) {	/* reserved == 0 */
+		ERROR(tdev, "reserved bits set in bmAttributes\n");
+		return 0;
+	}
+
+	/* bits[0:3] of wSpeedSupported is used and others are reserved */
+	if (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {	/* reserved == 0 */
+		ERROR(tdev, "reserved bits set in wSpeedSupported\n");
+		return 0;
+	}
+
+	return 1;
+}
+
 /* sanity test for standard requests working with usb_control_mesg() and some
  * of the utility functions which use it.
  *
@@ -773,6 +802,14 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 					return -EDOM;
 				}
 				break;
+			case USB_SS_CAP_TYPE:
+				if (buf + USB_DT_USB_SS_CAP_SIZE >
+						dev->buf + total ||
+						!is_good_ss_cap(dev, buf)) {
+					dev_err(&iface->dev, "bogus superspeed device capability descriptor\n");
+					return -EDOM;
+				}
+				break;
 			default:
 				break;
 			}

commit 82f92672ac3e36458fdb298f798913da8460fce9
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Oct 30 11:27:38 2013 +0800

    usb: usbtest: support usb2 extension descriptor test
    
    In Test 9 of usbtest module, it is used for performing chapter 9 tests N
    times.
    
    USB2.0 Extension descriptor is one of the generic device-level capbility
    descriptors which added in section 9.6.2.1 of USB 3.0 spec.
    
    This patch adds to support getting usb2.0 extension descriptor test
    scenario for USB 3.0.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index e7235d5cce85..1c78e747f72b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -606,6 +606,28 @@ static int is_good_config(struct usbtest_dev *tdev, int len)
 	return 0;
 }
 
+static int is_good_ext(struct usbtest_dev *tdev, u8 *buf)
+{
+	struct usb_ext_cap_descriptor *ext;
+	u32 attr;
+
+	ext = (struct usb_ext_cap_descriptor *) buf;
+
+	if (ext->bLength != USB_DT_USB_EXT_CAP_SIZE) {
+		ERROR(tdev, "bogus usb 2.0 extension descriptor length\n");
+		return 0;
+	}
+
+	attr = le32_to_cpu(ext->bmAttributes);
+	/* bits[1:4] is used and others are reserved */
+	if (attr & ~0x1e) {	/* reserved == 0 */
+		ERROR(tdev, "reserved bits set\n");
+		return 0;
+	}
+
+	return 1;
+}
+
 /* sanity test for standard requests working with usb_control_mesg() and some
  * of the utility functions which use it.
  *
@@ -694,12 +716,67 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 	 * 3.0 spec
 	 */
 	if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0300) {
+		struct usb_bos_descriptor *bos = NULL;
+		struct usb_dev_cap_header *header = NULL;
+		unsigned total, num, length;
+		u8 *buf;
+
 		retval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,
 				sizeof(*udev->bos->desc));
 		if (retval != sizeof(*udev->bos->desc)) {
 			dev_err(&iface->dev, "bos descriptor --> %d\n", retval);
 			return (retval < 0) ? retval : -EDOM;
 		}
+
+		bos = (struct usb_bos_descriptor *)dev->buf;
+		total = le16_to_cpu(bos->wTotalLength);
+		num = bos->bNumDeviceCaps;
+
+		if (total > TBUF_SIZE)
+			total = TBUF_SIZE;
+
+		/*
+		 * get generic device-level capability descriptors [9.6.2]
+		 * in USB 3.0 spec
+		 */
+		retval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,
+				total);
+		if (retval != total) {
+			dev_err(&iface->dev, "bos descriptor set --> %d\n",
+					retval);
+			return (retval < 0) ? retval : -EDOM;
+		}
+
+		length = sizeof(*udev->bos->desc);
+		buf = dev->buf;
+		for (i = 0; i < num; i++) {
+			buf += length;
+			if (buf + sizeof(struct usb_dev_cap_header) >
+					dev->buf + total)
+				break;
+
+			header = (struct usb_dev_cap_header *)buf;
+			length = header->bLength;
+
+			if (header->bDescriptorType !=
+					USB_DT_DEVICE_CAPABILITY) {
+				dev_warn(&udev->dev, "not device capability descriptor, skip\n");
+				continue;
+			}
+
+			switch (header->bDevCapabilityType) {
+			case USB_CAP_TYPE_EXT:
+				if (buf + USB_DT_USB_EXT_CAP_SIZE >
+						dev->buf + total ||
+						!is_good_ext(dev, buf)) {
+					dev_err(&iface->dev, "bogus usb 2.0 extension descriptor\n");
+					return -EDOM;
+				}
+				break;
+			default:
+				break;
+			}
+		}
 	}
 
 	/* there's always [9.4.3] at least one config descriptor [9.6.3] */

commit 9d3bd7684645834ede59d285af1d70ccabee9bf3
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Oct 28 23:31:32 2013 +0800

    usb: usbtest: support bos descriptor test for usb 3.0
    
    In Test 9 of usbtest module, it is used for performing chapter 9 tests N
    times. This patch adds to support getting bos descriptor test scenario for
    USB 3.0.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 1fdd88f382cc..e7235d5cce85 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -689,6 +689,19 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 		return (retval < 0) ? retval : -EDOM;
 	}
 
+	/*
+	 * there's always [9.4.3] a bos device descriptor [9.6.2] in USB
+	 * 3.0 spec
+	 */
+	if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0300) {
+		retval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,
+				sizeof(*udev->bos->desc));
+		if (retval != sizeof(*udev->bos->desc)) {
+			dev_err(&iface->dev, "bos descriptor --> %d\n", retval);
+			return (retval < 0) ? retval : -EDOM;
+		}
+	}
+
 	/* there's always [9.4.3] at least one config descriptor [9.6.3] */
 	for (i = 0; i < udev->descriptor.bNumConfigurations; i++) {
 		retval = usb_get_descriptor(udev, USB_DT_CONFIG, i,

commit f55055b4648416a9d31e5666a5425d406c05f626
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Oct 21 23:15:30 2013 +0800

    usb: usbtest: fix checkpatch warning as sizeof code style
    
    Script checkpatch.pl always complains incorrect code style like below:
    
    WARNING: sizeof *udev->bos->desc should be sizeof(*udev->bos->desc)
    
    This patch fixes the warning for usbtest module.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3e91d3e98ee8..1fdd88f382cc 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -437,7 +437,7 @@ alloc_sglist(int nents, int max, int vary)
 	if (max == 0)
 		return NULL;
 
-	sg = kmalloc_array(nents, sizeof *sg, GFP_KERNEL);
+	sg = kmalloc_array(nents, sizeof(*sg), GFP_KERNEL);
 	if (!sg)
 		return NULL;
 	sg_init_table(sg, nents);
@@ -573,7 +573,7 @@ static int is_good_config(struct usbtest_dev *tdev, int len)
 {
 	struct usb_config_descriptor	*config;
 
-	if (len < sizeof *config)
+	if (len < sizeof(*config))
 		return 0;
 	config = (struct usb_config_descriptor *) tdev->buf;
 
@@ -683,8 +683,8 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	/* there's always [9.4.3] a device descriptor [9.6.1] */
 	retval = usb_get_descriptor(udev, USB_DT_DEVICE, 0,
-			dev->buf, sizeof udev->descriptor);
-	if (retval != sizeof udev->descriptor) {
+			dev->buf, sizeof(udev->descriptor));
+	if (retval != sizeof(udev->descriptor)) {
 		dev_err(&iface->dev, "dev descriptor --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
@@ -954,7 +954,7 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 		 * device, but some are chosen to trigger protocol stalls
 		 * or short reads.
 		 */
-		memset(&req, 0, sizeof req);
+		memset(&req, 0, sizeof(req));
 		req.bRequest = USB_REQ_GET_DESCRIPTOR;
 		req.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;
 
@@ -1074,7 +1074,7 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!u)
 			goto cleanup;
 
-		reqp = kmalloc(sizeof *reqp, GFP_KERNEL);
+		reqp = kmalloc(sizeof(*reqp), GFP_KERNEL);
 		if (!reqp)
 			goto cleanup;
 		reqp->setup = req;
@@ -1667,13 +1667,13 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	if (param->sglen > 10)
 		return -EDOM;
 
-	memset(&context, 0, sizeof context);
+	memset(&context, 0, sizeof(context));
 	context.count = param->iterations * param->sglen;
 	context.dev = dev;
 	init_completion(&context.done);
 	spin_lock_init(&context.lock);
 
-	memset(urbs, 0, sizeof urbs);
+	memset(urbs, 0, sizeof(urbs));
 	udev = testdev_to_usbdev(dev);
 	dev_info(&dev->intf->dev,
 		"... iso period %d %sframes, wMaxPacket %04x\n",

commit 9a37a50349c8d6a7adcee21cefae407fb2f8c623
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Sep 24 00:03:43 2013 +0800

    usb: usbtest: bmAttributes would better be masked
    
    When transfer type is isochronous, the other bits (bits 5..2) of
    bmAttributes in endpoint descriptor might not be set zero. So it's better
    to use usb_endpoint_type routine to mask bmAttributes with
    USB_ENDPOINT_XFERTYPE_MASK to judge the transfter type later.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index aa28ac8c7607..3e91d3e98ee8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -120,7 +120,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			struct usb_host_endpoint	*e;
 
 			e = alt->endpoint + ep;
-			switch (e->desc.bmAttributes) {
+			switch (usb_endpoint_type(&e->desc)) {
 			case USB_ENDPOINT_XFER_BULK:
 				break;
 			case USB_ENDPOINT_XFER_ISOC:

commit 15b7336e02d998720c5ace47036f7e539365bb05
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jul 30 15:35:40 2013 -0400

    USB: simplify the interface of usb_get_status()
    
    This patch simplifies the interface presented by usb_get_status().
    Instead of forcing callers to check for the proper data length and
    convert the status value to host byte order, the function will now
    do these things itself.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 8b4ca1cb450a..aa28ac8c7607 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -747,9 +747,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	/* [9.4.5] get_status always works */
 	retval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev->buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&iface->dev, "get dev status --> %d\n", retval);
-		return (retval < 0) ? retval : -EDOM;
+		return retval;
 	}
 
 	/* FIXME configuration.bmAttributes says if we could try to set/clear
@@ -758,9 +758,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	retval = usb_get_status(udev, USB_RECIP_INTERFACE,
 			iface->altsetting[0].desc.bInterfaceNumber, dev->buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&iface->dev, "get interface status --> %d\n", retval);
-		return (retval < 0) ? retval : -EDOM;
+		return retval;
 	}
 	/* FIXME get status for each endpoint in the interface */
 
@@ -1351,7 +1351,6 @@ static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 				ep, retval);
 		return retval;
 	}
-	le16_to_cpus(&status);
 	if (status != 1) {
 		ERROR(tdev, "ep %02x bogus status: %04x != 1\n", ep, status);
 		return -EINVAL;

commit d0b4652f80c3276a57ede3b6b6d8159fa26c091f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jan 30 16:38:11 2013 -0500

    USB: altsetting overrides for usbtest
    
    The usbtest driver includes some rather simple-minded logic for
    selecting an altsetting to test.  It doesn't work well for the g_zero
    gadget, because it selects altsetting 0 (which doesn't have
    isochronous endpoints) rather than altsetting 1 (which does have them,
    if the gadget's hardware supports them).  This prevents usbtest's
    isochronous tests (15, 16, 22, and 23) from working with g_zero.
    
    Since g_zero is one of the most common gadget drivers used for USB
    testing, usbtest should do a better job of supporting it.  But since
    some programs may rely on the current scheme for selecting
    altsettings, I didn't want to change it.
    
    Instead, this patch (as1655) adds a module parameter to usbtest, which
    can be used to override the default altsetting.  Since usbtest is
    never used by normal users (most distributions probably don't even
    build it), the new module parameter won't inconvenience anybody.  In
    any case, it is entirely optional -- leaving it unset preserves the
    existing behavior.
    
    The patch also fixes a related bug in usbtest: After selecting an
    altsetting, the driver neglects to store its selection.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 268148de9714..8b4ca1cb450a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -11,6 +11,12 @@
 #include <linux/usb.h>
 
 
+/*-------------------------------------------------------------------------*/
+
+static int override_alt = -1;
+module_param_named(alt, override_alt, int, 0644);
+MODULE_PARM_DESC(alt, ">= 0 to override altsetting selection");
+
 /*-------------------------------------------------------------------------*/
 
 /* FIXME make these public somewhere; usbdevfs.h? */
@@ -103,6 +109,10 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 		iso_in = iso_out = NULL;
 		alt = intf->altsetting + tmp;
 
+		if (override_alt >= 0 &&
+				override_alt != alt->desc.bAlternateSetting)
+			continue;
+
 		/* take the first altsetting with in-bulk + out-bulk;
 		 * ignore other endpoints and altsettings.
 		 */
@@ -144,6 +154,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 
 found:
 	udev = testdev_to_usbdev(dev);
+	dev->info->alt = alt->desc.bAlternateSetting;
 	if (alt->desc.bAlternateSetting != 0) {
 		tmp = usb_set_interface(udev,
 				alt->desc.bInterfaceNumber,
@@ -2280,7 +2291,7 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			wtest = " intr-out";
 		}
 	} else {
-		if (info->autoconf) {
+		if (override_alt >= 0 || info->autoconf) {
 			int status;
 
 			status = get_endpoints(dev, intf);

commit 2cb5000057fbd2237c19b8b8bd4f6948fd11f5f8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jan 2 13:58:18 2013 -0500

    USB: usbtest: fix test number in log message
    
    This patch (as1639) fixes a minor bug in the usbtest driver.  Due to
    concurrent changes, a test originally written as number 17 got changed
    to number 24, but the corresponding change was not made in the log
    message.  This updates the log message.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 7667b12f2ff5..268148de9714 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2179,7 +2179,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		if (dev->out_pipe == 0 || !param->length || param->sglen < 4)
 			break;
 		retval = 0;
-		dev_info(&intf->dev, "TEST 17:  unlink from %d queues of "
+		dev_info(&intf->dev, "TEST 24:  unlink from %d queues of "
 				"%d %d-byte writes\n",
 				param->iterations, param->sglen, param->length);
 		for (i = param->iterations; retval == 0 && i > 0; --i) {

commit 564e69893c63cefe4bcbdeda4f940bf68b6b4491
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat Nov 17 18:06:11 2012 +0300

    USB: usbtest: prevent a divide by zero bug
    
    If param->length is zero, then this could lead to a divide by zero bug
    later in the function when we do: size %= max;
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index f10bd970d50a..7667b12f2ff5 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -423,6 +423,9 @@ alloc_sglist(int nents, int max, int vary)
 	unsigned		i;
 	unsigned		size = max;
 
+	if (max == 0)
+		return NULL;
+
 	sg = kmalloc_array(nents, sizeof *sg, GFP_KERNEL);
 	if (!sg)
 		return NULL;

commit 4b85c62411f7a95db33025b3aba29f7525c214d5
Author: Boyan Nedeltchev <boyan@ti.com>
Date:   Mon Nov 12 13:06:06 2012 +0200

    usb: misc: usbtest: send ISO packets for g_zero
    
    since commit b4036cc (usb: gadget: add
    isochronous support to gadget zero), g_zero
    has learned about isochronous transfers, which
    allows us to use usbtest.ko to exercise
    isochronous pipes.
    
    All we need to do to enable that functionality
    on usbtest.ko, is set the "iso" to 1 on
    struct usbtest_info
    
    Signed-off-by: Boyan Nedeltchev <boyan@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 055b84adedac..f10bd970d50a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2386,6 +2386,7 @@ static struct usbtest_info gz_info = {
 	.name		= "Linux gadget zero",
 	.autoconf	= 1,
 	.ctrl_out	= 1,
+	.iso		= 1,
 	.alt		= 0,
 };
 

commit 6a23ccd216b6a8ba2c67a9f9d8969b4431ad2920
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Mon Apr 16 14:19:07 2012 -0700

    usb: usbtest: two super speed fixes for usbtest
    
    bMaxPacketSize0 field for super speed is a power of 2, not a count.
    The size itself is always 512.
    
    Max packet size for a super speed bulk endpoint is 1024, so
    allocate the urb size in halt_simple() accordingly.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 9dcb68f04f03..055b84adedac 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1028,7 +1028,10 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 		case 13:	/* short read, resembling case 10 */
 			req.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);
 			/* last data packet "should" be DATA1, not DATA0 */
-			len = 1024 - udev->descriptor.bMaxPacketSize0;
+			if (udev->speed == USB_SPEED_SUPER)
+				len = 1024 - 512;
+			else
+				len = 1024 - udev->descriptor.bMaxPacketSize0;
 			expected = -EREMOTEIO;
 			break;
 		case 14:	/* short read; try to fill the last packet */
@@ -1387,11 +1390,15 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 
 static int halt_simple(struct usbtest_dev *dev)
 {
-	int		ep;
-	int		retval = 0;
-	struct urb	*urb;
+	int			ep;
+	int			retval = 0;
+	struct urb		*urb;
+	struct usb_device	*udev = testdev_to_usbdev(dev);
 
-	urb = simple_alloc_urb(testdev_to_usbdev(dev), 0, 512);
+	if (udev->speed == USB_SPEED_SUPER)
+		urb = simple_alloc_urb(udev, 0, 1024);
+	else
+		urb = simple_alloc_urb(udev, 0, 512);
 	if (urb == NULL)
 		return -ENOMEM;
 

commit f4a728d09a96d6a83d9c3f39035b1aa7726892ea
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Mar 25 21:08:32 2012 +0200

    drivers/usb/misc/usbtest.c: add kfrees
    
    Free the two previously allocated buffers before exiting the function in an
    error case.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index cac67dea2bac..9dcb68f04f03 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2277,6 +2277,8 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			if (status < 0) {
 				WARNING(dev, "couldn't get endpoints, %d\n",
 						status);
+				kfree(dev->buf);
+				kfree(dev);
 				return status;
 			}
 			/* may find bulk or ISO pipes */

commit 8bde9a62ee74afa89f593c563e926d163b1f6ada
Author: Xi Wang <xi.wang@gmail.com>
Date:   Mon Apr 9 15:48:45 2012 -0400

    usb: usbtest: avoid integer overflow in alloc_sglist()
    
    A large `nents' from userspace could overflow the allocation size,
    leading to memory corruption.
    
    | alloc_sglist()
    | usbtest_ioctl()
    
    Use kmalloc_array() to avoid the overflow.
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 967254afb6e8..cac67dea2bac 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -423,7 +423,7 @@ alloc_sglist(int nents, int max, int vary)
 	unsigned		i;
 	unsigned		size = max;
 
-	sg = kmalloc(nents * sizeof *sg, GFP_KERNEL);
+	sg = kmalloc_array(nents, sizeof *sg, GFP_KERNEL);
 	if (!sg)
 		return NULL;
 	sg_init_table(sg, nents);

commit e65cdfae71cecec0fcd43a3f9ac8b5e4ae52db08
Author: Xi Wang <xi.wang@gmail.com>
Date:   Mon Apr 9 15:48:55 2012 -0400

    usb: usbtest: avoid integer overflow in test_ctrl_queue()
    
    Avoid overflowing context.count = param->sglen * param->iterations,
    where both `sglen' and `iterations' are from userspace.
    
    | test_ctrl_queue()
    | usbtest_ioctl()
    
    Keep -EOPNOTSUPP for error code.
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 959145baf3cf..967254afb6e8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -904,6 +904,9 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 	struct ctrl_ctx		context;
 	int			i;
 
+	if (param->sglen == 0 || param->iterations > UINT_MAX / param->sglen)
+		return -EOPNOTSUPP;
+
 	spin_lock_init(&context.lock);
 	context.dev = dev;
 	init_completion(&context.complete);
@@ -1981,8 +1984,6 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 
 	/* queued control messaging */
 	case 10:
-		if (param->sglen == 0)
-			break;
 		retval = 0;
 		dev_info(&intf->dev,
 				"TEST 10:  queue %d control calls, %d times\n",

commit 568987116ed5fce7e9e9c731ffe5f5af193ab2e3
Author: Davidlohr Bueso <dave@gnu.org>
Date:   Thu Nov 24 16:23:44 2011 +0100

    USB: remove BKL comments
    
    The BKL is a gonner.
    
    Signed-off-by: Davidlohr Bueso <dave@gnu.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bd6d00802eab..959145baf3cf 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1765,7 +1765,6 @@ static int test_unaligned_bulk(
  * off just killing the userspace task and waiting for it to exit.
  */
 
-/* No BKL needed */
 static int
 usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 {

commit e538dfdae85244fd2c4231725d82cc1f1bc4942c
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Tue Aug 30 17:11:19 2011 +0200

    usb: Provide usb_speed_string() function
    
    In a few places in the kernel, the code prints
    a human-readable USB device speed (eg. "high speed").
    This involves a switch statement sometimes wrapped
    around in ({ ... }) block leading to code repetition.
    
    To mitigate this issue, this commit introduces
    usb_speed_string() function, which returns
    a human-readable name of provided speed.
    
    It also changes a few places switch was used to use
    this new function.  This changes a bit the way the
    speed is printed in few instances at the same time
    standardising it.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 930962f49276..bd6d00802eab 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2300,25 +2300,8 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	usb_set_intfdata(intf, dev);
 	dev_info(&intf->dev, "%s\n", info->name);
-	dev_info(&intf->dev, "%s speed {control%s%s%s%s%s} tests%s\n",
-			({ char *tmp;
-			switch (udev->speed) {
-			case USB_SPEED_LOW:
-				tmp = "low";
-				break;
-			case USB_SPEED_FULL:
-				tmp = "full";
-				break;
-			case USB_SPEED_HIGH:
-				tmp = "high";
-				break;
-			case USB_SPEED_SUPER:
-				tmp = "super";
-				break;
-			default:
-				tmp = "unknown";
-				break;
-			}; tmp; }),
+	dev_info(&intf->dev, "%s {control%s%s%s%s%s} tests%s\n",
+			usb_speed_string(udev->speed),
 			info->ctrl_out ? " in/out" : "",
 			rtest, wtest,
 			irtest, iwtest,

commit 29cc88979a8818cd8c5019426e945aed118b400e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 23 03:12:03 2011 -0700

    USB: use usb_endpoint_maxp() instead of le16_to_cpu()
    
    Now ${LINUX}/drivers/usb/* can use usb_endpoint_maxp(desc) to get maximum packet size
    instead of le16_to_cpu(desc->wMaxPacketSize).
    This patch fix it up
    
    Cc: Armin Fuerst <fuerst@in.tum.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Erdfelt <johannes@erdfelt.com>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: David Kubicek <dave@awk.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Brad Hards <bhards@bigpond.net.au>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Dahlmann <dahlmann.thomas@arcor.de>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: David Lopo <dlopo@chipidea.mips.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Xie Xiaobo <X.Xie@freescale.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Jiang Bo <tanya.jiang@freescale.com>
    Cc: Yuan-hsin Chen <yhchen@faraday-tech.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: OKI SEMICONDUCTOR, <toshiharu-linux@dsn.okisemi.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Herbert Pötzl <herbert@13thfloor.at>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Roman Weissgaerber <weissg@vienna.at>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: Florian Floe Echtler <echtler@fs.tum.de>
    Cc: Christian Lucht <lucht@codemercs.com>
    Cc: Juergen Stuber <starblue@sourceforge.net>
    Cc: Georges Toth <g.toth@e-biz.lu>
    Cc: Bill Ryder <bryder@sgi.com>
    Cc: Kuba Ober <kuba@mareimbrium.org>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bd715006b056..930962f49276 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1585,8 +1585,8 @@ static struct urb *iso_alloc_urb(
 
 	if (bytes < 0 || !desc)
 		return NULL;
-	maxp = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
-	maxp *= 1 + (0x3 & (le16_to_cpu(desc->wMaxPacketSize) >> 11));
+	maxp = 0x7ff & usb_endpoint_maxp(desc);
+	maxp *= 1 + (0x3 & (usb_endpoint_maxp(desc) >> 11));
 	packets = DIV_ROUND_UP(bytes, maxp);
 
 	urb = usb_alloc_urb(packets, GFP_KERNEL);
@@ -1656,7 +1656,7 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 		"... iso period %d %sframes, wMaxPacket %04x\n",
 		1 << (desc->bInterval - 1),
 		(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
-		le16_to_cpu(desc->wMaxPacketSize));
+		usb_endpoint_maxp(desc));
 
 	for (i = 0; i < param->sglen; i++) {
 		urbs[i] = iso_alloc_urb(udev, pipe, desc,

commit 7c79d094358326132693279bfb22e4f8454cc652
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Aug 23 10:44:54 2011 +0200

    USB: usbtest: use URB_ZERO_PACKET for BULK-OUT transfers
    
    Executing
    | testusb -a -c 1 -t 3 -v 421 -s 2048
    
    does not complete on the gadget side.
    g_zero enqueues a 4096 bytes long buffer. The host sends 2048bytes which
    is a multiple of wMaxPacketSize (either 64 or 512 bytes). The host is
    done with sending data but the gadget waits for more.
    Since the protocol does not include transfer-length-field sending a
    terminating zero packet seems the only way out.
    
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bb10846affc3..bd715006b056 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -359,8 +359,10 @@ static int simple_io(
 	urb->context = &completion;
 	while (retval == 0 && iterations-- > 0) {
 		init_completion(&completion);
-		if (usb_pipeout(urb->pipe))
+		if (usb_pipeout(urb->pipe)) {
 			simple_fill_buf(urb);
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		}
 		retval = usb_submit_urb(urb, GFP_KERNEL);
 		if (retval != 0)
 			break;

commit c44dead70a841d90ddc01968012f323c33217c9e
Merge: 99dff5856220 d5f6db9e1aff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 12:33:02 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (205 commits)
      USB: EHCI: Remove SPARC_LEON {read,write}_be definitions from ehci.h
      USB: UHCI: Support big endian GRUSBHC HC
      sparc: add {read,write}*_be routines
      USB: UHCI: Add support for big endian descriptors
      USB: UHCI: Use ACCESS_ONCE rather than using a full compiler barrier
      USB: UHCI: Add support for big endian mmio
      usb-storage: Correct adjust_quirks to include latest flags
      usb/isp1760: Fix possible unlink problems
      usb/isp1760: Move function isp1760_endpoint_disable() within file.
      USB: remove remaining usages of hcd->state from usbcore and fix regression
      usb: musb: ux500: add configuration and build options for ux500 dma
      usb: musb: ux500: add dma glue layer for ux500
      usb: musb: ux500: add dma name for ux500
      usb: musb: ux500: add ux500 specific code for gadget side
      usb: musb: fix compile error
      usb-storage: fix up the unusual_realtek device list
      USB: gadget: f_audio: Fix invalid dereference of initdata
      EHCI: don't rescan interrupt QHs needlessly
      OHCI: fix regression caused by nVidia shutdown workaround
      USB: OTG: msm: Free VCCCX regulator even if we can't set the voltage
      ...

commit 304b0b572c66bcd89df13e856db16503609c1a24
Author: Greg Dietsche <Gregory.Dietsche@cuw.edu>
Date:   Sun May 8 22:51:43 2011 -0500

    usb: fix warning in usbtest module v2
    
    On amd64 unsigned is not as wide as pointer and this causes a compiler
    warning. Switching to unsigned long corrects the problem.
    
    Signed-off-by: Greg Dietsche <Gregory.Dietsche@cuw.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 7e0bb2af8e63..c5676202d74a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -268,9 +268,9 @@ static inline void simple_fill_buf(struct urb *urb)
 	}
 }
 
-static inline unsigned buffer_offset(void *buf)
+static inline unsigned long buffer_offset(void *buf)
 {
-	return (unsigned)buf & (ARCH_KMALLOC_MINALIGN - 1);
+	return (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);
 }
 
 static int check_guard_bytes(struct usbtest_dev *tdev, struct urb *urb)
@@ -329,7 +329,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 
 static void simple_free_urb(struct urb *urb)
 {
-	unsigned offset = buffer_offset(urb->transfer_buffer);
+	unsigned long offset = buffer_offset(urb->transfer_buffer);
 
 	if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
 		usb_free_coherent(

commit 70f23fd66bc821a0e99647f70a809e277cc93c4c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Tue May 10 10:16:21 2011 +0200

    treewide: fix a few typos in comments
    
    - kenrel -> kernel
    - whetehr -> whether
    - ttt -> tt
    - sss -> ss
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 388cc128072a..ff9a01f8d405 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -104,7 +104,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 		alt = intf->altsetting + tmp;
 
 		/* take the first altsetting with in-bulk + out-bulk;
-		 * ignore other endpoints and altsetttings.
+		 * ignore other endpoints and altsettings.
 		 */
 		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
 			struct usb_host_endpoint	*e;

commit 67e7d64bcece93c84fd6e3832e7c6d91e57c06dc
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Apr 14 16:17:21 2011 +0200

    usb/usbtest: fix test10 on superpseed
    
    dummy_hcd + g_zero:
    
    |./testusb -a -s 1024 -v 1024 -t 10
    | usbtest 2-1:3.0: subtest 14 error, status 0
    
    with patch:
      ./testusb -a -t 10
    |unknown speed   /proc/bus/usb/001/002
    | dummy_udc dummy_udc: disabled ep-a
    | dummy_udc dummy_udc: disabled ep-b
    | dummy_udc dummy_udc: enabled ep-a (ep1in-bulk) maxpacket 1024
    | dummy_udc dummy_udc: enabled ep-b (ep2out-bulk) maxpacket 1024
    | zero gadget: source/sink enabled
    | usbtest 1-1:3.0: TEST 10:  queue 32 control calls, 1000 times
    | dummy_hcd dummy_hcd: timer fired with no URBs pending?
    |/proc/bus/usb/001/002 test 10,    0.022370 secs
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 7e74741ddf7b..7e0bb2af8e63 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1030,6 +1030,8 @@ test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 			req.wValue = cpu_to_le16((USB_DT_DEVICE << 8) | 0);
 			/* device descriptor size == 18 bytes */
 			len = udev->descriptor.bMaxPacketSize0;
+			if (udev->speed == USB_SPEED_SUPER)
+				len = 512;
 			switch (len) {
 			case 8:
 				len = 24;

commit 14b76ed9e613965e02603c31febd85c96e32e094
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Apr 14 15:45:42 2011 +0200

    usb/usbtest: print super on super speed
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 58a5685fb7d1..7e74741ddf7b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2308,6 +2308,9 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			case USB_SPEED_HIGH:
 				tmp = "high";
 				break;
+			case USB_SPEED_SUPER:
+				tmp = "super";
+				break;
 			default:
 				tmp = "unknown";
 				break;

commit 869410f82cbbb1464772046d87de8d18a916e706
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 14 11:21:04 2011 -0400

    USB: add queued-unlinks test case to usbtest driver
    
    This patch (as1452b) adds a new test case to the usbtest driver.  Test
    24 exercises the unlink-from-queue pathways in the host.  It queues a
    user-specified number of bulk-OUT URBs of user-specified size, unlinks
    the fourth- and second-from-last URBs in the queue, and then waits to
    see if all the URBs complete in the expected way (except of course
    that the unlinked URBs might complete normally, if they weren't
    unlinked soon enough).
    
    This new test has confirmed the existence of a bug in the ehci-hcd
    driver, to be fixed by a separate patch.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 388cc128072a..58a5685fb7d1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1195,6 +1195,104 @@ static int unlink_simple(struct usbtest_dev *dev, int pipe, int len)
 
 /*-------------------------------------------------------------------------*/
 
+struct queued_ctx {
+	struct completion	complete;
+	atomic_t		pending;
+	unsigned		num;
+	int			status;
+	struct urb		**urbs;
+};
+
+static void unlink_queued_callback(struct urb *urb)
+{
+	int			status = urb->status;
+	struct queued_ctx	*ctx = urb->context;
+
+	if (ctx->status)
+		goto done;
+	if (urb == ctx->urbs[ctx->num - 4] || urb == ctx->urbs[ctx->num - 2]) {
+		if (status == -ECONNRESET)
+			goto done;
+		/* What error should we report if the URB completed normally? */
+	}
+	if (status != 0)
+		ctx->status = status;
+
+ done:
+	if (atomic_dec_and_test(&ctx->pending))
+		complete(&ctx->complete);
+}
+
+static int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,
+		unsigned size)
+{
+	struct queued_ctx	ctx;
+	struct usb_device	*udev = testdev_to_usbdev(dev);
+	void			*buf;
+	dma_addr_t		buf_dma;
+	int			i;
+	int			retval = -ENOMEM;
+
+	init_completion(&ctx.complete);
+	atomic_set(&ctx.pending, 1);	/* One more than the actual value */
+	ctx.num = num;
+	ctx.status = 0;
+
+	buf = usb_alloc_coherent(udev, size, GFP_KERNEL, &buf_dma);
+	if (!buf)
+		return retval;
+	memset(buf, 0, size);
+
+	/* Allocate and init the urbs we'll queue */
+	ctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);
+	if (!ctx.urbs)
+		goto free_buf;
+	for (i = 0; i < num; i++) {
+		ctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ctx.urbs[i])
+			goto free_urbs;
+		usb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,
+				unlink_queued_callback, &ctx);
+		ctx.urbs[i]->transfer_dma = buf_dma;
+		ctx.urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	}
+
+	/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */
+	for (i = 0; i < num; i++) {
+		atomic_inc(&ctx.pending);
+		retval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);
+		if (retval != 0) {
+			dev_err(&dev->intf->dev, "submit urbs[%d] fail %d\n",
+					i, retval);
+			atomic_dec(&ctx.pending);
+			ctx.status = retval;
+			break;
+		}
+	}
+	if (i == num) {
+		usb_unlink_urb(ctx.urbs[num - 4]);
+		usb_unlink_urb(ctx.urbs[num - 2]);
+	} else {
+		while (--i >= 0)
+			usb_unlink_urb(ctx.urbs[i]);
+	}
+
+	if (atomic_dec_and_test(&ctx.pending))		/* The extra count */
+		complete(&ctx.complete);
+	wait_for_completion(&ctx.complete);
+	retval = ctx.status;
+
+ free_urbs:
+	for (i = 0; i < num; i++)
+		usb_free_urb(ctx.urbs[i]);
+	kfree(ctx.urbs);
+ free_buf:
+	usb_free_coherent(udev, size, buf, buf_dma);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
 static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
@@ -1970,8 +2068,6 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev->in_iso_pipe, dev->iso_in, 0);
 		break;
 
-	/* FIXME unlink from queue (ring with N urbs) */
-
 	/* FIXME scatterlist cancel (needs helper thread) */
 
 	/* Tests for bulk I/O using DMA mapping by core and odd address */
@@ -2064,6 +2160,26 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev->in_iso_pipe, dev->iso_in, 1);
 		break;
 
+	/* unlink URBs from a bulk-OUT queue */
+	case 24:
+		if (dev->out_pipe == 0 || !param->length || param->sglen < 4)
+			break;
+		retval = 0;
+		dev_info(&intf->dev, "TEST 17:  unlink from %d queues of "
+				"%d %d-byte writes\n",
+				param->iterations, param->sglen, param->length);
+		for (i = param->iterations; retval == 0 && i > 0; --i) {
+			retval = unlink_queued(dev, dev->out_pipe,
+						param->sglen, param->length);
+			if (retval) {
+				dev_err(&intf->dev,
+					"unlink queued writes failed %d, "
+					"iterations left %d\n", retval, i);
+				break;
+			}
+		}
+		break;
+
 	}
 	do_gettimeofday(&param->duration);
 	param->duration.tv_sec -= start.tv_sec;

commit 084fb206a91f72b22c4e2f41709730a81e3e0de6
Author: Martin Fuzzey <mfuzzey@gmail.com>
Date:   Sun Jan 16 19:17:11 2011 +0100

    USB: usbtest - Add tests to ensure HCDs can accept byte aligned buffers.
    
    Add a set of new tests similar to the existing ones but using
    transfer buffers at an "odd" address [ie offset of +1 from
    the buffer obtained by kmalloc() or usb_alloc_coherent()]
    
    The new tests are:
    #17 : bulk out (like #1) using kmalloc and DMA mapping by USB core.
    #18 : bulk in (like #2) using kmalloc and DMA mapping by USB core.
    #19 : bulk out (like #1) using usb_alloc_coherent()
    #20 : bulk in (like #2) using usb_alloc_coherent()
    #21 : control write (like #14)
    #22 : isochonous out (like #15)
    #23 : isochonous in (like #16)
    
    Signed-off-by: Martin Fuzzey <mfuzzey@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index a35b427c0bac..388cc128072a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -83,6 +83,8 @@ static struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)
 #define WARNING(tdev, fmt, args...) \
 	dev_warn(&(tdev)->intf->dev , fmt , ## args)
 
+#define GUARD_BYTE	0xA5
+
 /*-------------------------------------------------------------------------*/
 
 static int
@@ -186,11 +188,12 @@ static void simple_callback(struct urb *urb)
 	complete(urb->context);
 }
 
-static struct urb *simple_alloc_urb(
+static struct urb *usbtest_alloc_urb(
 	struct usb_device	*udev,
 	int			pipe,
-	unsigned long		bytes
-)
+	unsigned long		bytes,
+	unsigned		transfer_flags,
+	unsigned		offset)
 {
 	struct urb		*urb;
 
@@ -201,19 +204,46 @@ static struct urb *simple_alloc_urb(
 	urb->interval = (udev->speed == USB_SPEED_HIGH)
 			? (INTERRUPT_RATE << 3)
 			: INTERRUPT_RATE;
-	urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	urb->transfer_flags = transfer_flags;
 	if (usb_pipein(pipe))
 		urb->transfer_flags |= URB_SHORT_NOT_OK;
-	urb->transfer_buffer = usb_alloc_coherent(udev, bytes, GFP_KERNEL,
-			&urb->transfer_dma);
+
+	if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
+		urb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,
+			GFP_KERNEL, &urb->transfer_dma);
+	else
+		urb->transfer_buffer = kmalloc(bytes + offset, GFP_KERNEL);
+
 	if (!urb->transfer_buffer) {
 		usb_free_urb(urb);
-		urb = NULL;
-	} else
-		memset(urb->transfer_buffer, 0, bytes);
+		return NULL;
+	}
+
+	/* To test unaligned transfers add an offset and fill the
+		unused memory with a guard value */
+	if (offset) {
+		memset(urb->transfer_buffer, GUARD_BYTE, offset);
+		urb->transfer_buffer += offset;
+		if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
+			urb->transfer_dma += offset;
+	}
+
+	/* For inbound transfers use guard byte so that test fails if
+		data not correctly copied */
+	memset(urb->transfer_buffer,
+			usb_pipein(urb->pipe) ? GUARD_BYTE : 0,
+			bytes);
 	return urb;
 }
 
+static struct urb *simple_alloc_urb(
+	struct usb_device	*udev,
+	int			pipe,
+	unsigned long		bytes)
+{
+	return usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0);
+}
+
 static unsigned pattern;
 static unsigned mod_pattern;
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
@@ -238,13 +268,38 @@ static inline void simple_fill_buf(struct urb *urb)
 	}
 }
 
-static inline int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
+static inline unsigned buffer_offset(void *buf)
+{
+	return (unsigned)buf & (ARCH_KMALLOC_MINALIGN - 1);
+}
+
+static int check_guard_bytes(struct usbtest_dev *tdev, struct urb *urb)
+{
+	u8 *buf = urb->transfer_buffer;
+	u8 *guard = buf - buffer_offset(buf);
+	unsigned i;
+
+	for (i = 0; guard < buf; i++, guard++) {
+		if (*guard != GUARD_BYTE) {
+			ERROR(tdev, "guard byte[%d] %d (not %d)\n",
+				i, *guard, GUARD_BYTE);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 {
 	unsigned	i;
 	u8		expected;
 	u8		*buf = urb->transfer_buffer;
 	unsigned	len = urb->actual_length;
 
+	int ret = check_guard_bytes(tdev, urb);
+	if (ret)
+		return ret;
+
 	for (i = 0; i < len; i++, buf++) {
 		switch (pattern) {
 		/* all-zeroes has no synchronization issues */
@@ -274,8 +329,16 @@ static inline int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 
 static void simple_free_urb(struct urb *urb)
 {
-	usb_free_coherent(urb->dev, urb->transfer_buffer_length,
-			  urb->transfer_buffer, urb->transfer_dma);
+	unsigned offset = buffer_offset(urb->transfer_buffer);
+
+	if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
+		usb_free_coherent(
+			urb->dev,
+			urb->transfer_buffer_length + offset,
+			urb->transfer_buffer - offset,
+			urb->transfer_dma - offset);
+	else
+		kfree(urb->transfer_buffer - offset);
 	usb_free_urb(urb);
 }
 
@@ -1256,7 +1319,7 @@ static int halt_simple(struct usbtest_dev *dev)
  * try whatever we're told to try.
  */
 static int ctrl_out(struct usbtest_dev *dev,
-		unsigned count, unsigned length, unsigned vary)
+		unsigned count, unsigned length, unsigned vary, unsigned offset)
 {
 	unsigned		i, j, len;
 	int			retval;
@@ -1267,10 +1330,11 @@ static int ctrl_out(struct usbtest_dev *dev,
 	if (length < 1 || length > 0xffff || vary >= length)
 		return -EINVAL;
 
-	buf = kmalloc(length, GFP_KERNEL);
+	buf = kmalloc(length + offset, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
+	buf += offset;
 	udev = testdev_to_usbdev(dev);
 	len = length;
 	retval = 0;
@@ -1337,7 +1401,7 @@ static int ctrl_out(struct usbtest_dev *dev,
 		ERROR(dev, "ctrl_out %s failed, code %d, count %d\n",
 			what, retval, i);
 
-	kfree(buf);
+	kfree(buf - offset);
 	return retval;
 }
 
@@ -1373,6 +1437,8 @@ static void iso_callback(struct urb *urb)
 		ctx->errors += urb->number_of_packets;
 	else if (urb->actual_length != urb->transfer_buffer_length)
 		ctx->errors++;
+	else if (check_guard_bytes(ctx->dev, urb) != 0)
+		ctx->errors++;
 
 	if (urb->status == 0 && ctx->count > (ctx->pending - 1)
 			&& !ctx->submit_error) {
@@ -1408,7 +1474,8 @@ static struct urb *iso_alloc_urb(
 	struct usb_device	*udev,
 	int			pipe,
 	struct usb_endpoint_descriptor	*desc,
-	long			bytes
+	long			bytes,
+	unsigned offset
 )
 {
 	struct urb		*urb;
@@ -1428,13 +1495,24 @@ static struct urb *iso_alloc_urb(
 
 	urb->number_of_packets = packets;
 	urb->transfer_buffer_length = bytes;
-	urb->transfer_buffer = usb_alloc_coherent(udev, bytes, GFP_KERNEL,
-			&urb->transfer_dma);
+	urb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,
+							GFP_KERNEL,
+							&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb(urb);
 		return NULL;
 	}
-	memset(urb->transfer_buffer, 0, bytes);
+	if (offset) {
+		memset(urb->transfer_buffer, GUARD_BYTE, offset);
+		urb->transfer_buffer += offset;
+		urb->transfer_dma += offset;
+	}
+	/* For inbound transfers use guard byte so that test fails if
+		data not correctly copied */
+	memset(urb->transfer_buffer,
+			usb_pipein(urb->pipe) ? GUARD_BYTE : 0,
+			bytes);
+
 	for (i = 0; i < packets; i++) {
 		/* here, only the last packet will be short */
 		urb->iso_frame_desc[i].length = min((unsigned) bytes, maxp);
@@ -1452,7 +1530,7 @@ static struct urb *iso_alloc_urb(
 
 static int
 test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
-		int pipe, struct usb_endpoint_descriptor *desc)
+		int pipe, struct usb_endpoint_descriptor *desc, unsigned offset)
 {
 	struct iso_context	context;
 	struct usb_device	*udev;
@@ -1480,7 +1558,7 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 
 	for (i = 0; i < param->sglen; i++) {
 		urbs[i] = iso_alloc_urb(udev, pipe, desc,
-				param->length);
+					param->length, offset);
 		if (!urbs[i]) {
 			status = -ENOMEM;
 			goto fail;
@@ -1542,6 +1620,26 @@ test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 	return status;
 }
 
+static int test_unaligned_bulk(
+	struct usbtest_dev *tdev,
+	int pipe,
+	unsigned length,
+	int iterations,
+	unsigned transfer_flags,
+	const char *label)
+{
+	int retval;
+	struct urb *urb = usbtest_alloc_urb(
+		testdev_to_usbdev(tdev), pipe, length, transfer_flags, 1);
+
+	if (!urb)
+		return -ENOMEM;
+
+	retval = simple_io(tdev, urb, iterations, 0, 0, label);
+	simple_free_urb(urb);
+	return retval;
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* We only have this one interface to user space, through usbfs.
@@ -1843,7 +1941,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				realworld ? 1 : 0, param->length,
 				param->vary);
 		retval = ctrl_out(dev, param->iterations,
-				param->length, param->vary);
+				param->length, param->vary, 0);
 		break;
 
 	/* iso write tests */
@@ -1856,7 +1954,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				param->sglen, param->length);
 		/* FIRMWARE:  iso sink */
 		retval = test_iso_queue(dev, param,
-				dev->out_iso_pipe, dev->iso_out);
+				dev->out_iso_pipe, dev->iso_out, 0);
 		break;
 
 	/* iso read tests */
@@ -1869,13 +1967,103 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				param->sglen, param->length);
 		/* FIRMWARE:  iso source */
 		retval = test_iso_queue(dev, param,
-				dev->in_iso_pipe, dev->iso_in);
+				dev->in_iso_pipe, dev->iso_in, 0);
 		break;
 
 	/* FIXME unlink from queue (ring with N urbs) */
 
 	/* FIXME scatterlist cancel (needs helper thread) */
 
+	/* Tests for bulk I/O using DMA mapping by core and odd address */
+	case 17:
+		if (dev->out_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 17:  write odd addr %d bytes %u times core map\n",
+			param->length, param->iterations);
+
+		retval = test_unaligned_bulk(
+				dev, dev->out_pipe,
+				param->length, param->iterations,
+				0, "test17");
+		break;
+
+	case 18:
+		if (dev->in_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 18:  read odd addr %d bytes %u times core map\n",
+			param->length, param->iterations);
+
+		retval = test_unaligned_bulk(
+				dev, dev->in_pipe,
+				param->length, param->iterations,
+				0, "test18");
+		break;
+
+	/* Tests for bulk I/O using premapped coherent buffer and odd address */
+	case 19:
+		if (dev->out_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 19:  write odd addr %d bytes %u times premapped\n",
+			param->length, param->iterations);
+
+		retval = test_unaligned_bulk(
+				dev, dev->out_pipe,
+				param->length, param->iterations,
+				URB_NO_TRANSFER_DMA_MAP, "test19");
+		break;
+
+	case 20:
+		if (dev->in_pipe == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 20:  read odd addr %d bytes %u times premapped\n",
+			param->length, param->iterations);
+
+		retval = test_unaligned_bulk(
+				dev, dev->in_pipe,
+				param->length, param->iterations,
+				URB_NO_TRANSFER_DMA_MAP, "test20");
+		break;
+
+	/* control write tests with unaligned buffer */
+	case 21:
+		if (!dev->info->ctrl_out)
+			break;
+		dev_info(&intf->dev,
+				"TEST 21:  %d ep0out odd addr, %d..%d vary %d\n",
+				param->iterations,
+				realworld ? 1 : 0, param->length,
+				param->vary);
+		retval = ctrl_out(dev, param->iterations,
+				param->length, param->vary, 1);
+		break;
+
+	/* unaligned iso tests */
+	case 22:
+		if (dev->out_iso_pipe == 0 || param->sglen == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 22:  write %d iso odd, %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		retval = test_iso_queue(dev, param,
+				dev->out_iso_pipe, dev->iso_out, 1);
+		break;
+
+	case 23:
+		if (dev->in_iso_pipe == 0 || param->sglen == 0)
+			break;
+		dev_info(&intf->dev,
+			"TEST 23:  read %d iso odd, %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		retval = test_iso_queue(dev, param,
+				dev->in_iso_pipe, dev->iso_in, 1);
+		break;
+
 	}
 	do_gettimeofday(&param->duration);
 	param->duration.tv_sec -= start.tv_sec;

commit 40aed5241e4e5363c11acc841f6ef794b2c25668
Author: Martin Fuzzey <mfuzzey@gmail.com>
Date:   Fri Oct 1 00:20:48 2010 +0200

    USB: usbtest - ensure correct isoc data length
    
    Check the data length of isochronous transfers is
    as expected.
    
    With this test #16 will now fail if the device side
    sends no data.
    
    Signed-off-by: Martin Fuzzey <mfuzzey@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index bb078ebb8e81..a35b427c0bac 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1371,6 +1371,8 @@ static void iso_callback(struct urb *urb)
 		ctx->errors += urb->error_count;
 	else if (urb->status != 0)
 		ctx->errors += urb->number_of_packets;
+	else if (urb->actual_length != urb->transfer_buffer_length)
+		ctx->errors++;
 
 	if (urb->status == 0 && ctx->count > (ctx->pending - 1)
 			&& !ctx->submit_error) {

commit fabbf2196d0db0b4d175456dcb373aa2440f5728
Author: Martin Fuzzey <mfuzzey@gmail.com>
Date:   Fri Oct 1 00:20:42 2010 +0200

    USB: usbtest fix coding style
    
    Signed-off-by: Martin Fuzzey <mfuzzey@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index eef370eb7a54..bb078ebb8e81 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -13,17 +13,16 @@
 
 /*-------------------------------------------------------------------------*/
 
-// FIXME make these public somewhere; usbdevfs.h?
-//
+/* FIXME make these public somewhere; usbdevfs.h? */
 struct usbtest_param {
-	// inputs
+	/* inputs */
 	unsigned		test_num;	/* 0..(TEST_CASES-1) */
 	unsigned		iterations;
 	unsigned		length;
 	unsigned		vary;
 	unsigned		sglen;
 
-	// outputs
+	/* outputs */
 	struct timeval		duration;
 };
 #define USBTEST_REQUEST	_IOWR('U', 100, struct usbtest_param)
@@ -45,9 +44,9 @@ struct usbtest_info {
 	const char		*name;
 	u8			ep_in;		/* bulk/intr source */
 	u8			ep_out;		/* bulk/intr sink */
-	unsigned		autoconf : 1;
-	unsigned		ctrl_out : 1;
-	unsigned		iso : 1;	/* try iso in/out */
+	unsigned		autoconf:1;
+	unsigned		ctrl_out:1;
+	unsigned		iso:1;		/* try iso in/out */
 	int			alt;
 };
 
@@ -71,9 +70,9 @@ struct usbtest_dev {
 	u8			*buf;
 };
 
-static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
+static struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)
 {
-	return interface_to_usbdev (test->intf);
+	return interface_to_usbdev(test->intf);
 }
 
 /* set up all urbs so they can be used with either bulk or interrupt */
@@ -87,7 +86,7 @@ static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
 /*-------------------------------------------------------------------------*/
 
 static int
-get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
+get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 {
 	int				tmp;
 	struct usb_host_interface	*alt;
@@ -115,7 +114,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 			case USB_ENDPOINT_XFER_ISOC:
 				if (dev->info->iso)
 					goto try_iso;
-				// FALLTHROUGH
+				/* FALLTHROUGH */
 			default:
 				continue;
 			}
@@ -142,9 +141,9 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 	return -EINVAL;
 
 found:
-	udev = testdev_to_usbdev (dev);
+	udev = testdev_to_usbdev(dev);
 	if (alt->desc.bAlternateSetting != 0) {
-		tmp = usb_set_interface (udev,
+		tmp = usb_set_interface(udev,
 				alt->desc.bInterfaceNumber,
 				alt->desc.bAlternateSetting);
 		if (tmp < 0)
@@ -152,21 +151,21 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 	}
 
 	if (in) {
-		dev->in_pipe = usb_rcvbulkpipe (udev,
+		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-		dev->out_pipe = usb_sndbulkpipe (udev,
+		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
 	}
 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
-		dev->in_iso_pipe = usb_rcvisocpipe (udev,
+		dev->in_iso_pipe = usb_rcvisocpipe(udev,
 				iso_in->desc.bEndpointAddress
 					& USB_ENDPOINT_NUMBER_MASK);
 	}
 
 	if (iso_out) {
 		dev->iso_out = &iso_out->desc;
-		dev->out_iso_pipe = usb_sndisocpipe (udev,
+		dev->out_iso_pipe = usb_sndisocpipe(udev,
 				iso_out->desc.bEndpointAddress
 					& USB_ENDPOINT_NUMBER_MASK);
 	}
@@ -182,12 +181,12 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
  * them with non-zero test data (or test for it) when appropriate.
  */
 
-static void simple_callback (struct urb *urb)
+static void simple_callback(struct urb *urb)
 {
 	complete(urb->context);
 }
 
-static struct urb *simple_alloc_urb (
+static struct urb *simple_alloc_urb(
 	struct usb_device	*udev,
 	int			pipe,
 	unsigned long		bytes
@@ -195,32 +194,32 @@ static struct urb *simple_alloc_urb (
 {
 	struct urb		*urb;
 
-	urb = usb_alloc_urb (0, GFP_KERNEL);
+	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb)
 		return urb;
-	usb_fill_bulk_urb (urb, udev, pipe, NULL, bytes, simple_callback, NULL);
+	usb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, simple_callback, NULL);
 	urb->interval = (udev->speed == USB_SPEED_HIGH)
 			? (INTERRUPT_RATE << 3)
 			: INTERRUPT_RATE;
 	urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
-	if (usb_pipein (pipe))
+	if (usb_pipein(pipe))
 		urb->transfer_flags |= URB_SHORT_NOT_OK;
-	urb->transfer_buffer = usb_alloc_coherent (udev, bytes, GFP_KERNEL,
+	urb->transfer_buffer = usb_alloc_coherent(udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
-		usb_free_urb (urb);
+		usb_free_urb(urb);
 		urb = NULL;
 	} else
-		memset (urb->transfer_buffer, 0, bytes);
+		memset(urb->transfer_buffer, 0, bytes);
 	return urb;
 }
 
-static unsigned pattern = 0;
+static unsigned pattern;
 static unsigned mod_pattern;
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(mod_pattern, "i/o pattern (0 == zeroes)");
 
-static inline void simple_fill_buf (struct urb *urb)
+static inline void simple_fill_buf(struct urb *urb)
 {
 	unsigned	i;
 	u8		*buf = urb->transfer_buffer;
@@ -228,9 +227,9 @@ static inline void simple_fill_buf (struct urb *urb)
 
 	switch (pattern) {
 	default:
-		// FALLTHROUGH
+		/* FALLTHROUGH */
 	case 0:
-		memset (buf, 0, len);
+		memset(buf, 0, len);
 		break;
 	case 1:			/* mod63 */
 		for (i = 0; i < len; i++)
@@ -273,14 +272,14 @@ static inline int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 	return 0;
 }
 
-static void simple_free_urb (struct urb *urb)
+static void simple_free_urb(struct urb *urb)
 {
 	usb_free_coherent(urb->dev, urb->transfer_buffer_length,
 			  urb->transfer_buffer, urb->transfer_dma);
-	usb_free_urb (urb);
+	usb_free_urb(urb);
 }
 
-static int simple_io (
+static int simple_io(
 	struct usbtest_dev	*tdev,
 	struct urb		*urb,
 	int			iterations,
@@ -296,17 +295,18 @@ static int simple_io (
 
 	urb->context = &completion;
 	while (retval == 0 && iterations-- > 0) {
-		init_completion (&completion);
-		if (usb_pipeout (urb->pipe))
-			simple_fill_buf (urb);
-		if ((retval = usb_submit_urb (urb, GFP_KERNEL)) != 0)
+		init_completion(&completion);
+		if (usb_pipeout(urb->pipe))
+			simple_fill_buf(urb);
+		retval = usb_submit_urb(urb, GFP_KERNEL);
+		if (retval != 0)
 			break;
 
 		/* NOTE:  no timeouts; can't be broken out of by interrupt */
-		wait_for_completion (&completion);
+		wait_for_completion(&completion);
 		retval = urb->status;
 		urb->dev = udev;
-		if (retval == 0 && usb_pipein (urb->pipe))
+		if (retval == 0 && usb_pipein(urb->pipe))
 			retval = simple_check_buf(tdev, urb);
 
 		if (vary) {
@@ -337,7 +337,7 @@ static int simple_io (
  * Yes, this also tests the scatterlist primitives.
  */
 
-static void free_sglist (struct scatterlist *sg, int nents)
+static void free_sglist(struct scatterlist *sg, int nents)
 {
 	unsigned		i;
 
@@ -346,19 +346,19 @@ static void free_sglist (struct scatterlist *sg, int nents)
 	for (i = 0; i < nents; i++) {
 		if (!sg_page(&sg[i]))
 			continue;
-		kfree (sg_virt(&sg[i]));
+		kfree(sg_virt(&sg[i]));
 	}
-	kfree (sg);
+	kfree(sg);
 }
 
 static struct scatterlist *
-alloc_sglist (int nents, int max, int vary)
+alloc_sglist(int nents, int max, int vary)
 {
 	struct scatterlist	*sg;
 	unsigned		i;
 	unsigned		size = max;
 
-	sg = kmalloc (nents * sizeof *sg, GFP_KERNEL);
+	sg = kmalloc(nents * sizeof *sg, GFP_KERNEL);
 	if (!sg)
 		return NULL;
 	sg_init_table(sg, nents);
@@ -367,9 +367,9 @@ alloc_sglist (int nents, int max, int vary)
 		char		*buf;
 		unsigned	j;
 
-		buf = kzalloc (size, GFP_KERNEL);
+		buf = kzalloc(size, GFP_KERNEL);
 		if (!buf) {
-			free_sglist (sg, i);
+			free_sglist(sg, i);
 			return NULL;
 		}
 
@@ -397,7 +397,7 @@ alloc_sglist (int nents, int max, int vary)
 	return sg;
 }
 
-static int perform_sglist (
+static int perform_sglist(
 	struct usbtest_dev	*tdev,
 	unsigned		iterations,
 	int			pipe,
@@ -410,7 +410,7 @@ static int perform_sglist (
 	int			retval = 0;
 
 	while (retval == 0 && iterations-- > 0) {
-		retval = usb_sg_init (req, udev, pipe,
+		retval = usb_sg_init(req, udev, pipe,
 				(udev->speed == USB_SPEED_HIGH)
 					? (INTERRUPT_RATE << 3)
 					: INTERRUPT_RATE,
@@ -418,7 +418,7 @@ static int perform_sglist (
 
 		if (retval)
 			break;
-		usb_sg_wait (req);
+		usb_sg_wait(req);
 		retval = req->status;
 
 		/* FIXME check resulting data pattern */
@@ -426,9 +426,9 @@ static int perform_sglist (
 		/* FIXME if endpoint halted, clear halt (and log) */
 	}
 
-	// FIXME for unlink or fault handling tests, don't report
-	// failure if retval is as we expected ...
-
+	/* FIXME for unlink or fault handling tests, don't report
+	 * failure if retval is as we expected ...
+	 */
 	if (retval)
 		ERROR(tdev, "perform_sglist failed, "
 				"iterations left %d, status %d\n",
@@ -452,31 +452,31 @@ static int perform_sglist (
  */
 
 static unsigned realworld = 1;
-module_param (realworld, uint, 0);
-MODULE_PARM_DESC (realworld, "clear to demand stricter spec compliance");
+module_param(realworld, uint, 0);
+MODULE_PARM_DESC(realworld, "clear to demand stricter spec compliance");
 
-static int get_altsetting (struct usbtest_dev *dev)
+static int get_altsetting(struct usbtest_dev *dev)
 {
 	struct usb_interface	*iface = dev->intf;
-	struct usb_device	*udev = interface_to_usbdev (iface);
+	struct usb_device	*udev = interface_to_usbdev(iface);
 	int			retval;
 
-	retval = usb_control_msg (udev, usb_rcvctrlpipe (udev, 0),
+	retval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			USB_REQ_GET_INTERFACE, USB_DIR_IN|USB_RECIP_INTERFACE,
-			0, iface->altsetting [0].desc.bInterfaceNumber,
+			0, iface->altsetting[0].desc.bInterfaceNumber,
 			dev->buf, 1, USB_CTRL_GET_TIMEOUT);
 	switch (retval) {
 	case 1:
-		return dev->buf [0];
+		return dev->buf[0];
 	case 0:
 		retval = -ERANGE;
-		// FALLTHROUGH
+		/* FALLTHROUGH */
 	default:
 		return retval;
 	}
 }
 
-static int set_altsetting (struct usbtest_dev *dev, int alternate)
+static int set_altsetting(struct usbtest_dev *dev, int alternate)
 {
 	struct usb_interface		*iface = dev->intf;
 	struct usb_device		*udev;
@@ -484,9 +484,9 @@ static int set_altsetting (struct usbtest_dev *dev, int alternate)
 	if (alternate < 0 || alternate >= 256)
 		return -EINVAL;
 
-	udev = interface_to_usbdev (iface);
-	return usb_set_interface (udev,
-			iface->altsetting [0].desc.bInterfaceNumber,
+	udev = interface_to_usbdev(iface);
+	return usb_set_interface(udev,
+			iface->altsetting[0].desc.bInterfaceNumber,
 			alternate);
 }
 
@@ -519,9 +519,9 @@ static int is_good_config(struct usbtest_dev *tdev, int len)
 		return 0;
 	}
 
-	if (le16_to_cpu(config->wTotalLength) == len)		/* read it all */
+	if (le16_to_cpu(config->wTotalLength) == len)	/* read it all */
 		return 1;
-	if (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)		/* max partial read */
+	if (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)	/* max partial read */
 		return 1;
 	ERROR(tdev, "bogus config descriptor read size\n");
 	return 0;
@@ -542,10 +542,10 @@ static int is_good_config(struct usbtest_dev *tdev, int len)
  * to see if usbcore, hcd, and device all behave right.  such testing would
  * involve varied read sizes and other operation sequences.
  */
-static int ch9_postconfig (struct usbtest_dev *dev)
+static int ch9_postconfig(struct usbtest_dev *dev)
 {
 	struct usb_interface	*iface = dev->intf;
-	struct usb_device	*udev = interface_to_usbdev (iface);
+	struct usb_device	*udev = interface_to_usbdev(iface);
 	int			i, alt, retval;
 
 	/* [9.2.3] if there's more than one altsetting, we need to be able to
@@ -554,7 +554,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	for (i = 0; i < iface->num_altsetting; i++) {
 
 		/* 9.2.3 constrains the range here */
-		alt = iface->altsetting [i].desc.bAlternateSetting;
+		alt = iface->altsetting[i].desc.bAlternateSetting;
 		if (alt < 0 || alt >= iface->num_altsetting) {
 			dev_err(&iface->dev,
 					"invalid alt [%d].bAltSetting = %d\n",
@@ -566,7 +566,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 			continue;
 
 		/* [9.4.10] set_interface */
-		retval = set_altsetting (dev, alt);
+		retval = set_altsetting(dev, alt);
 		if (retval) {
 			dev_err(&iface->dev, "can't set_interface = %d, %d\n",
 					alt, retval);
@@ -574,7 +574,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		}
 
 		/* [9.4.4] get_interface always works */
-		retval = get_altsetting (dev);
+		retval = get_altsetting(dev);
 		if (retval != alt) {
 			dev_err(&iface->dev, "get alt should be %d, was %d\n",
 					alt, retval);
@@ -591,11 +591,11 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		 * ... although some cheap devices (like one TI Hub I've got)
 		 * won't return config descriptors except before set_config.
 		 */
-		retval = usb_control_msg (udev, usb_rcvctrlpipe (udev, 0),
+		retval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 				USB_REQ_GET_CONFIGURATION,
 				USB_DIR_IN | USB_RECIP_DEVICE,
 				0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);
-		if (retval != 1 || dev->buf [0] != expected) {
+		if (retval != 1 || dev->buf[0] != expected) {
 			dev_err(&iface->dev, "get config --> %d %d (1 %d)\n",
 				retval, dev->buf[0], expected);
 			return (retval < 0) ? retval : -EDOM;
@@ -603,7 +603,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	}
 
 	/* there's always [9.4.3] a device descriptor [9.6.1] */
-	retval = usb_get_descriptor (udev, USB_DT_DEVICE, 0,
+	retval = usb_get_descriptor(udev, USB_DT_DEVICE, 0,
 			dev->buf, sizeof udev->descriptor);
 	if (retval != sizeof udev->descriptor) {
 		dev_err(&iface->dev, "dev descriptor --> %d\n", retval);
@@ -612,7 +612,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 
 	/* there's always [9.4.3] at least one config descriptor [9.6.3] */
 	for (i = 0; i < udev->descriptor.bNumConfigurations; i++) {
-		retval = usb_get_descriptor (udev, USB_DT_CONFIG, i,
+		retval = usb_get_descriptor(udev, USB_DT_CONFIG, i,
 				dev->buf, TBUF_SIZE);
 		if (!is_good_config(dev, retval)) {
 			dev_err(&iface->dev,
@@ -621,18 +621,19 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 			return (retval < 0) ? retval : -EDOM;
 		}
 
-		// FIXME cross-checking udev->config[i] to make sure usbcore
-		// parsed it right (etc) would be good testing paranoia
+		/* FIXME cross-checking udev->config[i] to make sure usbcore
+		 * parsed it right (etc) would be good testing paranoia
+		 */
 	}
 
 	/* and sometimes [9.2.6.6] speed dependent descriptors */
 	if (le16_to_cpu(udev->descriptor.bcdUSB) == 0x0200) {
-		struct usb_qualifier_descriptor		*d = NULL;
+		struct usb_qualifier_descriptor *d = NULL;
 
 		/* device qualifier [9.6.2] */
-		retval = usb_get_descriptor (udev,
+		retval = usb_get_descriptor(udev,
 				USB_DT_DEVICE_QUALIFIER, 0, dev->buf,
-				sizeof (struct usb_qualifier_descriptor));
+				sizeof(struct usb_qualifier_descriptor));
 		if (retval == -EPIPE) {
 			if (udev->speed == USB_SPEED_HIGH) {
 				dev_err(&iface->dev,
@@ -641,7 +642,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 				return (retval < 0) ? retval : -EDOM;
 			}
 			/* usb2.0 but not high-speed capable; fine */
-		} else if (retval != sizeof (struct usb_qualifier_descriptor)) {
+		} else if (retval != sizeof(struct usb_qualifier_descriptor)) {
 			dev_err(&iface->dev, "dev qualifier --> %d\n", retval);
 			return (retval < 0) ? retval : -EDOM;
 		} else
@@ -651,7 +652,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		if (d) {
 			unsigned max = d->bNumConfigurations;
 			for (i = 0; i < max; i++) {
-				retval = usb_get_descriptor (udev,
+				retval = usb_get_descriptor(udev,
 					USB_DT_OTHER_SPEED_CONFIG, i,
 					dev->buf, TBUF_SIZE);
 				if (!is_good_config(dev, retval)) {
@@ -663,25 +664,26 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 			}
 		}
 	}
-	// FIXME fetch strings from at least the device descriptor
+	/* FIXME fetch strings from at least the device descriptor */
 
 	/* [9.4.5] get_status always works */
-	retval = usb_get_status (udev, USB_RECIP_DEVICE, 0, dev->buf);
+	retval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev->buf);
 	if (retval != 2) {
 		dev_err(&iface->dev, "get dev status --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
 
-	// FIXME configuration.bmAttributes says if we could try to set/clear
-	// the device's remote wakeup feature ... if we can, test that here
+	/* FIXME configuration.bmAttributes says if we could try to set/clear
+	 * the device's remote wakeup feature ... if we can, test that here
+	 */
 
-	retval = usb_get_status (udev, USB_RECIP_INTERFACE,
-			iface->altsetting [0].desc.bInterfaceNumber, dev->buf);
+	retval = usb_get_status(udev, USB_RECIP_INTERFACE,
+			iface->altsetting[0].desc.bInterfaceNumber, dev->buf);
 	if (retval != 2) {
 		dev_err(&iface->dev, "get interface status --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
-	// FIXME get status for each endpoint in the interface
+	/* FIXME get status for each endpoint in the interface */
 
 	return 0;
 }
@@ -717,7 +719,7 @@ struct subcase {
 	int			expected;
 };
 
-static void ctrl_complete (struct urb *urb)
+static void ctrl_complete(struct urb *urb)
 {
 	struct ctrl_ctx		*ctx = urb->context;
 	struct usb_ctrlrequest	*reqp;
@@ -725,9 +727,9 @@ static void ctrl_complete (struct urb *urb)
 	int			status = urb->status;
 
 	reqp = (struct usb_ctrlrequest *)urb->setup_packet;
-	subcase = container_of (reqp, struct subcase, setup);
+	subcase = container_of(reqp, struct subcase, setup);
 
-	spin_lock (&ctx->lock);
+	spin_lock(&ctx->lock);
 	ctx->count--;
 	ctx->pending--;
 
@@ -787,14 +789,14 @@ static void ctrl_complete (struct urb *urb)
 
 			/* unlink whatever's still pending */
 			for (i = 1; i < ctx->param->sglen; i++) {
-				struct urb	*u = ctx->urb [
-						(i + subcase->number)
-						% ctx->param->sglen];
+				struct urb *u = ctx->urb[
+							(i + subcase->number)
+							% ctx->param->sglen];
 
 				if (u == urb || !u->dev)
 					continue;
 				spin_unlock(&ctx->lock);
-				status = usb_unlink_urb (u);
+				status = usb_unlink_urb(u);
 				spin_lock(&ctx->lock);
 				switch (status) {
 				case -EINPROGRESS:
@@ -812,7 +814,8 @@ static void ctrl_complete (struct urb *urb)
 
 	/* resubmit if we need to, else mark this as done */
 	if ((status == 0) && (ctx->pending < ctx->count)) {
-		if ((status = usb_submit_urb (urb, GFP_ATOMIC)) != 0) {
+		status = usb_submit_urb(urb, GFP_ATOMIC);
+		if (status != 0) {
 			ERROR(ctx->dev,
 				"can't resubmit ctrl %02x.%02x, err %d\n",
 				reqp->bRequestType, reqp->bRequest, status);
@@ -824,21 +827,21 @@ static void ctrl_complete (struct urb *urb)
 
 	/* signal completion when nothing's queued */
 	if (ctx->pending == 0)
-		complete (&ctx->complete);
-	spin_unlock (&ctx->lock);
+		complete(&ctx->complete);
+	spin_unlock(&ctx->lock);
 }
 
 static int
-test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
+test_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param *param)
 {
-	struct usb_device	*udev = testdev_to_usbdev (dev);
+	struct usb_device	*udev = testdev_to_usbdev(dev);
 	struct urb		**urb;
 	struct ctrl_ctx		context;
 	int			i;
 
-	spin_lock_init (&context.lock);
+	spin_lock_init(&context.lock);
 	context.dev = dev;
-	init_completion (&context.complete);
+	init_completion(&context.complete);
 	context.count = param->sglen * param->iterations;
 	context.pending = 0;
 	context.status = -ENOMEM;
@@ -853,7 +856,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 	if (!urb)
 		return -ENOMEM;
 	for (i = 0; i < param->sglen; i++) {
-		int			pipe = usb_rcvctrlpipe (udev, 0);
+		int			pipe = usb_rcvctrlpipe(udev, 0);
 		unsigned		len;
 		struct urb		*u;
 		struct usb_ctrlrequest	req;
@@ -869,104 +872,108 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		 * device, but some are chosen to trigger protocol stalls
 		 * or short reads.
 		 */
-		memset (&req, 0, sizeof req);
+		memset(&req, 0, sizeof req);
 		req.bRequest = USB_REQ_GET_DESCRIPTOR;
 		req.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;
 
 		switch (i % NUM_SUBCASES) {
-		case 0:		// get device descriptor
-			req.wValue = cpu_to_le16 (USB_DT_DEVICE << 8);
-			len = sizeof (struct usb_device_descriptor);
+		case 0:		/* get device descriptor */
+			req.wValue = cpu_to_le16(USB_DT_DEVICE << 8);
+			len = sizeof(struct usb_device_descriptor);
 			break;
-		case 1:		// get first config descriptor (only)
-			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
-			len = sizeof (struct usb_config_descriptor);
+		case 1:		/* get first config descriptor (only) */
+			req.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);
+			len = sizeof(struct usb_config_descriptor);
 			break;
-		case 2:		// get altsetting (OFTEN STALLS)
+		case 2:		/* get altsetting (OFTEN STALLS) */
 			req.bRequest = USB_REQ_GET_INTERFACE;
 			req.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;
-			// index = 0 means first interface
+			/* index = 0 means first interface */
 			len = 1;
 			expected = EPIPE;
 			break;
-		case 3:		// get interface status
+		case 3:		/* get interface status */
 			req.bRequest = USB_REQ_GET_STATUS;
 			req.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;
-			// interface 0
+			/* interface 0 */
 			len = 2;
 			break;
-		case 4:		// get device status
+		case 4:		/* get device status */
 			req.bRequest = USB_REQ_GET_STATUS;
 			req.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;
 			len = 2;
 			break;
-		case 5:		// get device qualifier (MAY STALL)
+		case 5:		/* get device qualifier (MAY STALL) */
 			req.wValue = cpu_to_le16 (USB_DT_DEVICE_QUALIFIER << 8);
-			len = sizeof (struct usb_qualifier_descriptor);
+			len = sizeof(struct usb_qualifier_descriptor);
 			if (udev->speed != USB_SPEED_HIGH)
 				expected = EPIPE;
 			break;
-		case 6:		// get first config descriptor, plus interface
-			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
-			len = sizeof (struct usb_config_descriptor);
-			len += sizeof (struct usb_interface_descriptor);
+		case 6:		/* get first config descriptor, plus interface */
+			req.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);
+			len = sizeof(struct usb_config_descriptor);
+			len += sizeof(struct usb_interface_descriptor);
 			break;
-		case 7:		// get interface descriptor (ALWAYS STALLS)
+		case 7:		/* get interface descriptor (ALWAYS STALLS) */
 			req.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);
-			// interface == 0
-			len = sizeof (struct usb_interface_descriptor);
+			/* interface == 0 */
+			len = sizeof(struct usb_interface_descriptor);
 			expected = -EPIPE;
 			break;
-		// NOTE: two consecutive stalls in the queue here.
-		// that tests fault recovery a bit more aggressively.
-		case 8:		// clear endpoint halt (MAY STALL)
+		/* NOTE: two consecutive stalls in the queue here.
+		 *  that tests fault recovery a bit more aggressively. */
+		case 8:		/* clear endpoint halt (MAY STALL) */
 			req.bRequest = USB_REQ_CLEAR_FEATURE;
 			req.bRequestType = USB_RECIP_ENDPOINT;
-			// wValue 0 == ep halt
-			// wIndex 0 == ep0 (shouldn't halt!)
+			/* wValue 0 == ep halt */
+			/* wIndex 0 == ep0 (shouldn't halt!) */
 			len = 0;
-			pipe = usb_sndctrlpipe (udev, 0);
+			pipe = usb_sndctrlpipe(udev, 0);
 			expected = EPIPE;
 			break;
-		case 9:		// get endpoint status
+		case 9:		/* get endpoint status */
 			req.bRequest = USB_REQ_GET_STATUS;
 			req.bRequestType = USB_DIR_IN|USB_RECIP_ENDPOINT;
-			// endpoint 0
+			/* endpoint 0 */
 			len = 2;
 			break;
-		case 10:	// trigger short read (EREMOTEIO)
-			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
+		case 10:	/* trigger short read (EREMOTEIO) */
+			req.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);
 			len = 1024;
 			expected = -EREMOTEIO;
 			break;
-		// NOTE: two consecutive _different_ faults in the queue.
-		case 11:	// get endpoint descriptor (ALWAYS STALLS)
-			req.wValue = cpu_to_le16 (USB_DT_ENDPOINT << 8);
-			// endpoint == 0
-			len = sizeof (struct usb_interface_descriptor);
+		/* NOTE: two consecutive _different_ faults in the queue. */
+		case 11:	/* get endpoint descriptor (ALWAYS STALLS) */
+			req.wValue = cpu_to_le16(USB_DT_ENDPOINT << 8);
+			/* endpoint == 0 */
+			len = sizeof(struct usb_interface_descriptor);
 			expected = EPIPE;
 			break;
-		// NOTE: sometimes even a third fault in the queue!
-		case 12:	// get string 0 descriptor (MAY STALL)
-			req.wValue = cpu_to_le16 (USB_DT_STRING << 8);
-			// string == 0, for language IDs
-			len = sizeof (struct usb_interface_descriptor);
-			// may succeed when > 4 languages
-			expected = EREMOTEIO;	// or EPIPE, if no strings
+		/* NOTE: sometimes even a third fault in the queue! */
+		case 12:	/* get string 0 descriptor (MAY STALL) */
+			req.wValue = cpu_to_le16(USB_DT_STRING << 8);
+			/* string == 0, for language IDs */
+			len = sizeof(struct usb_interface_descriptor);
+			/* may succeed when > 4 languages */
+			expected = EREMOTEIO;	/* or EPIPE, if no strings */
 			break;
-		case 13:	// short read, resembling case 10
-			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
-			// last data packet "should" be DATA1, not DATA0
+		case 13:	/* short read, resembling case 10 */
+			req.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);
+			/* last data packet "should" be DATA1, not DATA0 */
 			len = 1024 - udev->descriptor.bMaxPacketSize0;
 			expected = -EREMOTEIO;
 			break;
-		case 14:	// short read; try to fill the last packet
-			req.wValue = cpu_to_le16 ((USB_DT_DEVICE << 8) | 0);
+		case 14:	/* short read; try to fill the last packet */
+			req.wValue = cpu_to_le16((USB_DT_DEVICE << 8) | 0);
 			/* device descriptor size == 18 bytes */
 			len = udev->descriptor.bMaxPacketSize0;
 			switch (len) {
-			case 8:		len = 24; break;
-			case 16:	len = 32; break;
+			case 8:
+				len = 24;
+				break;
+			case 16:
+				len = 32;
+				break;
 			}
 			expected = -EREMOTEIO;
 			break;
@@ -975,8 +982,8 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 			context.status = -EINVAL;
 			goto cleanup;
 		}
-		req.wLength = cpu_to_le16 (len);
-		urb [i] = u = simple_alloc_urb (udev, pipe, len);
+		req.wLength = cpu_to_le16(len);
+		urb[i] = u = simple_alloc_urb(udev, pipe, len);
 		if (!u)
 			goto cleanup;
 
@@ -994,9 +1001,9 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 	/* queue the urbs */
 	context.urb = urb;
-	spin_lock_irq (&context.lock);
+	spin_lock_irq(&context.lock);
 	for (i = 0; i < param->sglen; i++) {
-		context.status = usb_submit_urb (urb [i], GFP_ATOMIC);
+		context.status = usb_submit_urb(urb[i], GFP_ATOMIC);
 		if (context.status != 0) {
 			ERROR(dev, "can't submit urb[%d], status %d\n",
 					i, context.status);
@@ -1005,23 +1012,23 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		}
 		context.pending++;
 	}
-	spin_unlock_irq (&context.lock);
+	spin_unlock_irq(&context.lock);
 
 	/* FIXME  set timer and time out; provide a disconnect hook */
 
 	/* wait for the last one to complete */
 	if (context.pending > 0)
-		wait_for_completion (&context.complete);
+		wait_for_completion(&context.complete);
 
 cleanup:
 	for (i = 0; i < param->sglen; i++) {
-		if (!urb [i])
+		if (!urb[i])
 			continue;
-		urb [i]->dev = udev;
+		urb[i]->dev = udev;
 		kfree(urb[i]->setup_packet);
-		simple_free_urb (urb [i]);
+		simple_free_urb(urb[i]);
 	}
-	kfree (urb);
+	kfree(urb);
 	return context.status;
 }
 #undef NUM_SUBCASES
@@ -1029,27 +1036,27 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 /*-------------------------------------------------------------------------*/
 
-static void unlink1_callback (struct urb *urb)
+static void unlink1_callback(struct urb *urb)
 {
 	int	status = urb->status;
 
-	// we "know" -EPIPE (stall) never happens
+	/* we "know" -EPIPE (stall) never happens */
 	if (!status)
-		status = usb_submit_urb (urb, GFP_ATOMIC);
+		status = usb_submit_urb(urb, GFP_ATOMIC);
 	if (status) {
 		urb->status = status;
 		complete(urb->context);
 	}
 }
 
-static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
+static int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)
 {
 	struct urb		*urb;
 	struct completion	completion;
 	int			retval = 0;
 
-	init_completion (&completion);
-	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
+	init_completion(&completion);
+	urb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size);
 	if (!urb)
 		return -ENOMEM;
 	urb->context = &completion;
@@ -1061,7 +1068,8 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	 * FIXME want additional tests for when endpoint is STALLing
 	 * due to errors, or is just NAKing requests.
 	 */
-	if ((retval = usb_submit_urb (urb, GFP_KERNEL)) != 0) {
+	retval = usb_submit_urb(urb, GFP_KERNEL);
+	if (retval != 0) {
 		dev_err(&dev->intf->dev, "submit fail %d\n", retval);
 		return retval;
 	}
@@ -1069,7 +1077,7 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	/* unlinking that should always work.  variable delay tests more
 	 * hcd states and code paths, even with little other system load.
 	 */
-	msleep (jiffies % (2 * INTERRUPT_RATE));
+	msleep(jiffies % (2 * INTERRUPT_RATE));
 	if (async) {
 		while (!completion_done(&completion)) {
 			retval = usb_unlink_urb(urb);
@@ -1098,11 +1106,11 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 			break;
 		}
 	} else
-		usb_kill_urb (urb);
+		usb_kill_urb(urb);
 
-	wait_for_completion (&completion);
+	wait_for_completion(&completion);
 	retval = urb->status;
-	simple_free_urb (urb);
+	simple_free_urb(urb);
 
 	if (async)
 		return (retval == -ECONNRESET) ? 0 : retval - 1000;
@@ -1111,14 +1119,14 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 				0 : retval - 2000;
 }
 
-static int unlink_simple (struct usbtest_dev *dev, int pipe, int len)
+static int unlink_simple(struct usbtest_dev *dev, int pipe, int len)
 {
 	int			retval = 0;
 
 	/* test sync and async paths */
-	retval = unlink1 (dev, pipe, len, 1);
+	retval = unlink1(dev, pipe, len, 1);
 	if (!retval)
-		retval = unlink1 (dev, pipe, len, 0);
+		retval = unlink1(dev, pipe, len, 0);
 	return retval;
 }
 
@@ -1130,7 +1138,7 @@ static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	u16	status;
 
 	/* shouldn't look or act halted */
-	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	retval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
 		ERROR(tdev, "ep %02x couldn't get no-halt status, %d\n",
 				ep, retval);
@@ -1152,7 +1160,7 @@ static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	u16	status;
 
 	/* should look and act halted */
-	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	retval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
 		ERROR(tdev, "ep %02x couldn't get halt status, %d\n",
 				ep, retval);
@@ -1182,7 +1190,7 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 		return retval;
 
 	/* set halt (protocol test only), verify it worked */
-	retval = usb_control_msg (urb->dev, usb_sndctrlpipe (urb->dev, 0),
+	retval = usb_control_msg(urb->dev, usb_sndctrlpipe(urb->dev, 0),
 			USB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,
 			USB_ENDPOINT_HALT, ep,
 			NULL, 0, USB_CTRL_SET_TIMEOUT);
@@ -1195,7 +1203,7 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 		return retval;
 
 	/* clear halt (tests API + protocol), verify it worked */
-	retval = usb_clear_halt (urb->dev, urb->pipe);
+	retval = usb_clear_halt(urb->dev, urb->pipe);
 	if (retval < 0) {
 		ERROR(tdev, "ep %02x couldn't clear halt, %d\n", ep, retval);
 		return retval;
@@ -1209,18 +1217,18 @@ static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 	return 0;
 }
 
-static int halt_simple (struct usbtest_dev *dev)
+static int halt_simple(struct usbtest_dev *dev)
 {
 	int		ep;
 	int		retval = 0;
 	struct urb	*urb;
 
-	urb = simple_alloc_urb (testdev_to_usbdev (dev), 0, 512);
+	urb = simple_alloc_urb(testdev_to_usbdev(dev), 0, 512);
 	if (urb == NULL)
 		return -ENOMEM;
 
 	if (dev->in_pipe) {
-		ep = usb_pipeendpoint (dev->in_pipe) | USB_DIR_IN;
+		ep = usb_pipeendpoint(dev->in_pipe) | USB_DIR_IN;
 		urb->pipe = dev->in_pipe;
 		retval = test_halt(dev, ep, urb);
 		if (retval < 0)
@@ -1228,12 +1236,12 @@ static int halt_simple (struct usbtest_dev *dev)
 	}
 
 	if (dev->out_pipe) {
-		ep = usb_pipeendpoint (dev->out_pipe);
+		ep = usb_pipeendpoint(dev->out_pipe);
 		urb->pipe = dev->out_pipe;
 		retval = test_halt(dev, ep, urb);
 	}
 done:
-	simple_free_urb (urb);
+	simple_free_urb(urb);
 	return retval;
 }
 
@@ -1247,7 +1255,7 @@ static int halt_simple (struct usbtest_dev *dev)
  * need to be able to handle more than one OUT data packet.  We'll
  * try whatever we're told to try.
  */
-static int ctrl_out (struct usbtest_dev *dev,
+static int ctrl_out(struct usbtest_dev *dev,
 		unsigned count, unsigned length, unsigned vary)
 {
 	unsigned		i, j, len;
@@ -1263,7 +1271,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 	if (!buf)
 		return -ENOMEM;
 
-	udev = testdev_to_usbdev (dev);
+	udev = testdev_to_usbdev(dev);
 	len = length;
 	retval = 0;
 
@@ -1273,8 +1281,8 @@ static int ctrl_out (struct usbtest_dev *dev,
 	for (i = 0; i < count; i++) {
 		/* write patterned data */
 		for (j = 0; j < len; j++)
-			buf [j] = i + j;
-		retval = usb_control_msg (udev, usb_sndctrlpipe (udev,0),
+			buf[j] = i + j;
+		retval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,
 				0, 0, buf, len, USB_CTRL_SET_TIMEOUT);
 		if (retval != len) {
@@ -1288,7 +1296,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 		}
 
 		/* read it back -- assuming nothing intervened!!  */
-		retval = usb_control_msg (udev, usb_rcvctrlpipe (udev,0),
+		retval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 				0x5c, USB_DIR_IN|USB_TYPE_VENDOR,
 				0, 0, buf, len, USB_CTRL_GET_TIMEOUT);
 		if (retval != len) {
@@ -1303,9 +1311,9 @@ static int ctrl_out (struct usbtest_dev *dev,
 
 		/* fail if we can't verify */
 		for (j = 0; j < len; j++) {
-			if (buf [j] != (u8) (i + j)) {
+			if (buf[j] != (u8) (i + j)) {
 				ERROR(dev, "ctrl_out, byte %d is %d not %d\n",
-					j, buf [j], (u8) i + j);
+					j, buf[j], (u8) i + j);
 				retval = -EBADMSG;
 				break;
 			}
@@ -1326,10 +1334,10 @@ static int ctrl_out (struct usbtest_dev *dev,
 	}
 
 	if (retval < 0)
-		ERROR (dev, "ctrl_out %s failed, code %d, count %d\n",
+		ERROR(dev, "ctrl_out %s failed, code %d, count %d\n",
 			what, retval, i);
 
-	kfree (buf);
+	kfree(buf);
 	return retval;
 }
 
@@ -1351,7 +1359,7 @@ struct iso_context {
 	struct usbtest_dev	*dev;
 };
 
-static void iso_callback (struct urb *urb)
+static void iso_callback(struct urb *urb)
 {
 	struct iso_context	*ctx = urb->context;
 
@@ -1366,7 +1374,7 @@ static void iso_callback (struct urb *urb)
 
 	if (urb->status == 0 && ctx->count > (ctx->pending - 1)
 			&& !ctx->submit_error) {
-		int status = usb_submit_urb (urb, GFP_ATOMIC);
+		int status = usb_submit_urb(urb, GFP_ATOMIC);
 		switch (status) {
 		case 0:
 			goto done;
@@ -1388,13 +1396,13 @@ static void iso_callback (struct urb *urb)
 			dev_err(&ctx->dev->intf->dev,
 				"iso test, %lu errors out of %lu\n",
 				ctx->errors, ctx->packet_count);
-		complete (&ctx->done);
+		complete(&ctx->done);
 	}
 done:
 	spin_unlock(&ctx->lock);
 }
 
-static struct urb *iso_alloc_urb (
+static struct urb *iso_alloc_urb(
 	struct usb_device	*udev,
 	int			pipe,
 	struct usb_endpoint_descriptor	*desc,
@@ -1410,7 +1418,7 @@ static struct urb *iso_alloc_urb (
 	maxp *= 1 + (0x3 & (le16_to_cpu(desc->wMaxPacketSize) >> 11));
 	packets = DIV_ROUND_UP(bytes, maxp);
 
-	urb = usb_alloc_urb (packets, GFP_KERNEL);
+	urb = usb_alloc_urb(packets, GFP_KERNEL);
 	if (!urb)
 		return urb;
 	urb->dev = udev;
@@ -1418,30 +1426,30 @@ static struct urb *iso_alloc_urb (
 
 	urb->number_of_packets = packets;
 	urb->transfer_buffer_length = bytes;
-	urb->transfer_buffer = usb_alloc_coherent (udev, bytes, GFP_KERNEL,
+	urb->transfer_buffer = usb_alloc_coherent(udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
-		usb_free_urb (urb);
+		usb_free_urb(urb);
 		return NULL;
 	}
-	memset (urb->transfer_buffer, 0, bytes);
+	memset(urb->transfer_buffer, 0, bytes);
 	for (i = 0; i < packets; i++) {
 		/* here, only the last packet will be short */
-		urb->iso_frame_desc[i].length = min ((unsigned) bytes, maxp);
+		urb->iso_frame_desc[i].length = min((unsigned) bytes, maxp);
 		bytes -= urb->iso_frame_desc[i].length;
 
 		urb->iso_frame_desc[i].offset = maxp * i;
 	}
 
 	urb->complete = iso_callback;
-	// urb->context = SET BY CALLER
+	/* urb->context = SET BY CALLER */
 	urb->interval = 1 << (desc->bInterval - 1);
 	urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
 	return urb;
 }
 
 static int
-test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
+test_iso_queue(struct usbtest_dev *dev, struct usbtest_param *param,
 		int pipe, struct usb_endpoint_descriptor *desc)
 {
 	struct iso_context	context;
@@ -1457,11 +1465,11 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 	memset(&context, 0, sizeof context);
 	context.count = param->iterations * param->sglen;
 	context.dev = dev;
-	init_completion (&context.done);
-	spin_lock_init (&context.lock);
+	init_completion(&context.done);
+	spin_lock_init(&context.lock);
 
-	memset (urbs, 0, sizeof urbs);
-	udev = testdev_to_usbdev (dev);
+	memset(urbs, 0, sizeof urbs);
+	udev = testdev_to_usbdev(dev);
 	dev_info(&dev->intf->dev,
 		"... iso period %d %sframes, wMaxPacket %04x\n",
 		1 << (desc->bInterval - 1),
@@ -1469,14 +1477,14 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 		le16_to_cpu(desc->wMaxPacketSize));
 
 	for (i = 0; i < param->sglen; i++) {
-		urbs [i] = iso_alloc_urb (udev, pipe, desc,
+		urbs[i] = iso_alloc_urb(udev, pipe, desc,
 				param->length);
-		if (!urbs [i]) {
+		if (!urbs[i]) {
 			status = -ENOMEM;
 			goto fail;
 		}
 		packets += urbs[i]->number_of_packets;
-		urbs [i]->context = &context;
+		urbs[i]->context = &context;
 	}
 	packets *= param->iterations;
 	dev_info(&dev->intf->dev,
@@ -1485,27 +1493,27 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 			/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
 		packets);
 
-	spin_lock_irq (&context.lock);
+	spin_lock_irq(&context.lock);
 	for (i = 0; i < param->sglen; i++) {
 		++context.pending;
-		status = usb_submit_urb (urbs [i], GFP_ATOMIC);
+		status = usb_submit_urb(urbs[i], GFP_ATOMIC);
 		if (status < 0) {
-			ERROR (dev, "submit iso[%d], error %d\n", i, status);
+			ERROR(dev, "submit iso[%d], error %d\n", i, status);
 			if (i == 0) {
-				spin_unlock_irq (&context.lock);
+				spin_unlock_irq(&context.lock);
 				goto fail;
 			}
 
-			simple_free_urb (urbs [i]);
+			simple_free_urb(urbs[i]);
 			urbs[i] = NULL;
 			context.pending--;
 			context.submit_error = 1;
 			break;
 		}
 	}
-	spin_unlock_irq (&context.lock);
+	spin_unlock_irq(&context.lock);
 
-	wait_for_completion (&context.done);
+	wait_for_completion(&context.done);
 
 	for (i = 0; i < param->sglen; i++) {
 		if (urbs[i])
@@ -1526,8 +1534,8 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 fail:
 	for (i = 0; i < param->sglen; i++) {
-		if (urbs [i])
-			simple_free_urb (urbs [i]);
+		if (urbs[i])
+			simple_free_urb(urbs[i]);
 	}
 	return status;
 }
@@ -1557,10 +1565,10 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 /* No BKL needed */
 static int
-usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
+usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 {
-	struct usbtest_dev	*dev = usb_get_intfdata (intf);
-	struct usb_device	*udev = testdev_to_usbdev (dev);
+	struct usbtest_dev	*dev = usb_get_intfdata(intf);
+	struct usb_device	*udev = testdev_to_usbdev(dev);
 	struct usbtest_param	*param = buf;
 	int			retval = -EOPNOTSUPP;
 	struct urb		*urb;
@@ -1569,7 +1577,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	struct timeval		start;
 	unsigned		i;
 
-	// FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is.
+	/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */
 
 	pattern = mod_pattern;
 
@@ -1595,9 +1603,9 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			mutex_unlock(&dev->lock);
 			return -ENODEV;
 		}
-		res = set_altsetting (dev, dev->info->alt);
+		res = set_altsetting(dev, dev->info->alt);
 		if (res) {
-			dev_err (&intf->dev,
+			dev_err(&intf->dev,
 					"set altsetting to %d failed, %d\n",
 					dev->info->alt, res);
 			mutex_unlock(&dev->lock);
@@ -1614,7 +1622,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	 * FIXME add more tests!  cancel requests, verify the data, control
 	 * queueing, concurrent read+write threads, and so on.
 	 */
-	do_gettimeofday (&start);
+	do_gettimeofday(&start);
 	switch (param->test_num) {
 
 	case 0:
@@ -1629,14 +1637,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 1:  write %d bytes %u times\n",
 				param->length, param->iterations);
-		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->out_pipe, param->length);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		/* FIRMWARE:  bulk sink (maybe accepts short writes) */
 		retval = simple_io(dev, urb, param->iterations, 0, 0, "test1");
-		simple_free_urb (urb);
+		simple_free_urb(urb);
 		break;
 	case 2:
 		if (dev->in_pipe == 0)
@@ -1644,14 +1652,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 2:  read %d bytes %u times\n",
 				param->length, param->iterations);
-		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->in_pipe, param->length);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk source (maybe generates short writes)
+		/* FIRMWARE:  bulk source (maybe generates short writes) */
 		retval = simple_io(dev, urb, param->iterations, 0, 0, "test2");
-		simple_free_urb (urb);
+		simple_free_urb(urb);
 		break;
 	case 3:
 		if (dev->out_pipe == 0 || param->vary == 0)
@@ -1659,15 +1667,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 3:  write/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
-		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->out_pipe, param->length);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		/* FIRMWARE:  bulk sink (maybe accepts short writes) */
 		retval = simple_io(dev, urb, param->iterations, param->vary,
 					0, "test3");
-		simple_free_urb (urb);
+		simple_free_urb(urb);
 		break;
 	case 4:
 		if (dev->in_pipe == 0 || param->vary == 0)
@@ -1675,15 +1683,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev,
 				"TEST 4:  read/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
-		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
+		urb = simple_alloc_urb(udev, dev->in_pipe, param->length);
 		if (!urb) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk source (maybe generates short writes)
+		/* FIRMWARE:  bulk source (maybe generates short writes) */
 		retval = simple_io(dev, urb, param->iterations, param->vary,
 					0, "test4");
-		simple_free_urb (urb);
+		simple_free_urb(urb);
 		break;
 
 	/* Queued bulk I/O tests */
@@ -1694,15 +1702,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 5:  write %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist (param->sglen, param->length, 0);
+		sg = alloc_sglist(param->sglen, param->length, 0);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		/* FIRMWARE:  bulk sink (maybe accepts short writes) */
 		retval = perform_sglist(dev, param->iterations, dev->out_pipe,
 				&req, sg, param->sglen);
-		free_sglist (sg, param->sglen);
+		free_sglist(sg, param->sglen);
 		break;
 
 	case 6:
@@ -1712,15 +1720,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 6:  read %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist (param->sglen, param->length, 0);
+		sg = alloc_sglist(param->sglen, param->length, 0);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk source (maybe generates short writes)
+		/* FIRMWARE:  bulk source (maybe generates short writes) */
 		retval = perform_sglist(dev, param->iterations, dev->in_pipe,
 				&req, sg, param->sglen);
-		free_sglist (sg, param->sglen);
+		free_sglist(sg, param->sglen);
 		break;
 	case 7:
 		if (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)
@@ -1729,15 +1737,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist (param->sglen, param->length, param->vary);
+		sg = alloc_sglist(param->sglen, param->length, param->vary);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		/* FIRMWARE:  bulk sink (maybe accepts short writes) */
 		retval = perform_sglist(dev, param->iterations, dev->out_pipe,
 				&req, sg, param->sglen);
-		free_sglist (sg, param->sglen);
+		free_sglist(sg, param->sglen);
 		break;
 	case 8:
 		if (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)
@@ -1746,15 +1754,15 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
-		sg = alloc_sglist (param->sglen, param->length, param->vary);
+		sg = alloc_sglist(param->sglen, param->length, param->vary);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
 		}
-		// FIRMWARE:  bulk source (maybe generates short writes)
+		/* FIRMWARE:  bulk source (maybe generates short writes) */
 		retval = perform_sglist(dev, param->iterations, dev->in_pipe,
 				&req, sg, param->sglen);
-		free_sglist (sg, param->sglen);
+		free_sglist(sg, param->sglen);
 		break;
 
 	/* non-queued sanity tests for control (chapter 9 subset) */
@@ -1764,7 +1772,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 9:  ch9 (subset) control tests, %d times\n",
 				param->iterations);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
-			retval = ch9_postconfig (dev);
+			retval = ch9_postconfig(dev);
 		if (retval)
 			dev_err(&intf->dev, "ch9 subset failed, "
 					"iterations left %d\n", i);
@@ -1779,7 +1787,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 				"TEST 10:  queue %d control calls, %d times\n",
 				param->sglen,
 				param->iterations);
-		retval = test_ctrl_queue (dev, param);
+		retval = test_ctrl_queue(dev, param);
 		break;
 
 	/* simple non-queued unlinks (ring with one urb) */
@@ -1790,7 +1798,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev, "TEST 11:  unlink %d reads of %d\n",
 				param->iterations, param->length);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
-			retval = unlink_simple (dev, dev->in_pipe,
+			retval = unlink_simple(dev, dev->in_pipe,
 						param->length);
 		if (retval)
 			dev_err(&intf->dev, "unlink reads failed %d, "
@@ -1803,7 +1811,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev, "TEST 12:  unlink %d writes of %d\n",
 				param->iterations, param->length);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
-			retval = unlink_simple (dev, dev->out_pipe,
+			retval = unlink_simple(dev, dev->out_pipe,
 						param->length);
 		if (retval)
 			dev_err(&intf->dev, "unlink writes failed %d, "
@@ -1818,7 +1826,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		dev_info(&intf->dev, "TEST 13:  set/clear %d halts\n",
 				param->iterations);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
-			retval = halt_simple (dev);
+			retval = halt_simple(dev);
 
 		if (retval)
 			ERROR(dev, "halts failed, iterations left %d\n", i);
@@ -1844,8 +1852,8 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 15:  write %d iso, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		// FIRMWARE:  iso sink
-		retval = test_iso_queue (dev, param,
+		/* FIRMWARE:  iso sink */
+		retval = test_iso_queue(dev, param,
 				dev->out_iso_pipe, dev->iso_out);
 		break;
 
@@ -1857,17 +1865,17 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 16:  read %d iso, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
-		// FIRMWARE:  iso source
-		retval = test_iso_queue (dev, param,
+		/* FIRMWARE:  iso source */
+		retval = test_iso_queue(dev, param,
 				dev->in_iso_pipe, dev->iso_in);
 		break;
 
-	// FIXME unlink from queue (ring with N urbs)
+	/* FIXME unlink from queue (ring with N urbs) */
 
-	// FIXME scatterlist cancel (needs helper thread)
+	/* FIXME scatterlist cancel (needs helper thread) */
 
 	}
-	do_gettimeofday (&param->duration);
+	do_gettimeofday(&param->duration);
 	param->duration.tv_sec -= start.tv_sec;
 	param->duration.tv_usec -= start.tv_usec;
 	if (param->duration.tv_usec < 0) {
@@ -1880,22 +1888,22 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 
 /*-------------------------------------------------------------------------*/
 
-static unsigned force_interrupt = 0;
-module_param (force_interrupt, uint, 0);
-MODULE_PARM_DESC (force_interrupt, "0 = test default; else interrupt");
+static unsigned force_interrupt;
+module_param(force_interrupt, uint, 0);
+MODULE_PARM_DESC(force_interrupt, "0 = test default; else interrupt");
 
 #ifdef	GENERIC
 static unsigned short vendor;
 module_param(vendor, ushort, 0);
-MODULE_PARM_DESC (vendor, "vendor code (from usb-if)");
+MODULE_PARM_DESC(vendor, "vendor code (from usb-if)");
 
 static unsigned short product;
 module_param(product, ushort, 0);
-MODULE_PARM_DESC (product, "product code (from vendor)");
+MODULE_PARM_DESC(product, "product code (from vendor)");
 #endif
 
 static int
-usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
+usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct usb_device	*udev;
 	struct usbtest_dev	*dev;
@@ -1903,7 +1911,7 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	char			*rtest, *wtest;
 	char			*irtest, *iwtest;
 
-	udev = interface_to_usbdev (intf);
+	udev = interface_to_usbdev(intf);
 
 #ifdef	GENERIC
 	/* specify devices by module parameters? */
@@ -1930,8 +1938,9 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	dev->intf = intf;
 
 	/* cacheline-aligned scratch for i/o */
-	if ((dev->buf = kmalloc (TBUF_SIZE, GFP_KERNEL)) == NULL) {
-		kfree (dev);
+	dev->buf = kmalloc(TBUF_SIZE, GFP_KERNEL);
+	if (dev->buf == NULL) {
+		kfree(dev);
 		return -ENOMEM;
 	}
 
@@ -1943,18 +1952,18 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	irtest = iwtest = "";
 	if (force_interrupt || udev->speed == USB_SPEED_LOW) {
 		if (info->ep_in) {
-			dev->in_pipe = usb_rcvintpipe (udev, info->ep_in);
+			dev->in_pipe = usb_rcvintpipe(udev, info->ep_in);
 			rtest = " intr-in";
 		}
 		if (info->ep_out) {
-			dev->out_pipe = usb_sndintpipe (udev, info->ep_out);
+			dev->out_pipe = usb_sndintpipe(udev, info->ep_out);
 			wtest = " intr-out";
 		}
 	} else {
 		if (info->autoconf) {
 			int status;
 
-			status = get_endpoints (dev, intf);
+			status = get_endpoints(dev, intf);
 			if (status < 0) {
 				WARNING(dev, "couldn't get endpoints, %d\n",
 						status);
@@ -1963,10 +1972,10 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 			/* may find bulk or ISO pipes */
 		} else {
 			if (info->ep_in)
-				dev->in_pipe = usb_rcvbulkpipe (udev,
+				dev->in_pipe = usb_rcvbulkpipe(udev,
 							info->ep_in);
 			if (info->ep_out)
-				dev->out_pipe = usb_sndbulkpipe (udev,
+				dev->out_pipe = usb_sndbulkpipe(udev,
 							info->ep_out);
 		}
 		if (dev->in_pipe)
@@ -1979,15 +1988,23 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 			iwtest = " iso-out";
 	}
 
-	usb_set_intfdata (intf, dev);
-	dev_info (&intf->dev, "%s\n", info->name);
-	dev_info (&intf->dev, "%s speed {control%s%s%s%s%s} tests%s\n",
+	usb_set_intfdata(intf, dev);
+	dev_info(&intf->dev, "%s\n", info->name);
+	dev_info(&intf->dev, "%s speed {control%s%s%s%s%s} tests%s\n",
 			({ char *tmp;
 			switch (udev->speed) {
-			case USB_SPEED_LOW: tmp = "low"; break;
-			case USB_SPEED_FULL: tmp = "full"; break;
-			case USB_SPEED_HIGH: tmp = "high"; break;
-			default: tmp = "unknown"; break;
+			case USB_SPEED_LOW:
+				tmp = "low";
+				break;
+			case USB_SPEED_FULL:
+				tmp = "full";
+				break;
+			case USB_SPEED_HIGH:
+				tmp = "high";
+				break;
+			default:
+				tmp = "unknown";
+				break;
 			}; tmp; }),
 			info->ctrl_out ? " in/out" : "",
 			rtest, wtest,
@@ -1996,24 +2013,24 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	return 0;
 }
 
-static int usbtest_suspend (struct usb_interface *intf, pm_message_t message)
+static int usbtest_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	return 0;
 }
 
-static int usbtest_resume (struct usb_interface *intf)
+static int usbtest_resume(struct usb_interface *intf)
 {
 	return 0;
 }
 
 
-static void usbtest_disconnect (struct usb_interface *intf)
+static void usbtest_disconnect(struct usb_interface *intf)
 {
-	struct usbtest_dev	*dev = usb_get_intfdata (intf);
+	struct usbtest_dev	*dev = usb_get_intfdata(intf);
 
-	usb_set_intfdata (intf, NULL);
-	dev_dbg (&intf->dev, "disconnect\n");
-	kfree (dev);
+	usb_set_intfdata(intf, NULL);
+	dev_dbg(&intf->dev, "disconnect\n");
+	kfree(dev);
 }
 
 /* Basic testing only needs a device that can source or sink bulk traffic.
@@ -2050,9 +2067,9 @@ static struct usbtest_info fw_info = {
 	.ep_in		= 2,
 	.ep_out		= 2,
 	.alt		= 1,
-	.autoconf	= 1,		// iso and ctrl_out need autoconf
+	.autoconf	= 1,		/* iso and ctrl_out need autoconf */
 	.ctrl_out	= 1,
-	.iso		= 1,		// iso_ep's are #8 in/out
+	.iso		= 1,		/* iso_ep's are #8 in/out */
 };
 
 /* peripheral running Linux and 'zero.c' test firmware, or
@@ -2109,56 +2126,56 @@ static const struct usb_device_id id_table[] = {
 	 */
 
 	/* generic EZ-USB FX controller */
-	{ USB_DEVICE (0x0547, 0x2235),
+	{ USB_DEVICE(0x0547, 0x2235),
 		.driver_info = (unsigned long) &ez1_info,
-		},
+	},
 
 	/* CY3671 development board with EZ-USB FX */
-	{ USB_DEVICE (0x0547, 0x0080),
+	{ USB_DEVICE(0x0547, 0x0080),
 		.driver_info = (unsigned long) &ez1_info,
-		},
+	},
 
 	/* generic EZ-USB FX2 controller (or development board) */
-	{ USB_DEVICE (0x04b4, 0x8613),
+	{ USB_DEVICE(0x04b4, 0x8613),
 		.driver_info = (unsigned long) &ez2_info,
-		},
+	},
 
 	/* re-enumerated usb test device firmware */
-	{ USB_DEVICE (0xfff0, 0xfff0),
+	{ USB_DEVICE(0xfff0, 0xfff0),
 		.driver_info = (unsigned long) &fw_info,
-		},
+	},
 
 	/* "Gadget Zero" firmware runs under Linux */
-	{ USB_DEVICE (0x0525, 0xa4a0),
+	{ USB_DEVICE(0x0525, 0xa4a0),
 		.driver_info = (unsigned long) &gz_info,
-		},
+	},
 
 	/* so does a user-mode variant */
-	{ USB_DEVICE (0x0525, 0xa4a4),
+	{ USB_DEVICE(0x0525, 0xa4a4),
 		.driver_info = (unsigned long) &um_info,
-		},
+	},
 
 	/* ... and a user-mode variant that talks iso */
-	{ USB_DEVICE (0x0525, 0xa4a3),
+	{ USB_DEVICE(0x0525, 0xa4a3),
 		.driver_info = (unsigned long) &um2_info,
-		},
+	},
 
 #ifdef KEYSPAN_19Qi
 	/* Keyspan 19qi uses an21xx (original EZ-USB) */
-	// this does not coexist with the real Keyspan 19qi driver!
-	{ USB_DEVICE (0x06cd, 0x010b),
+	/* this does not coexist with the real Keyspan 19qi driver! */
+	{ USB_DEVICE(0x06cd, 0x010b),
 		.driver_info = (unsigned long) &ez1_info,
-		},
+	},
 #endif
 
 	/*-------------------------------------------------------------*/
 
 #ifdef IBOT2
 	/* iBOT2 makes a nice source of high speed bulk-in data */
-	// this does not coexist with a real iBOT2 driver!
-	{ USB_DEVICE (0x0b62, 0x0059),
+	/* this does not coexist with a real iBOT2 driver! */
+	{ USB_DEVICE(0x0b62, 0x0059),
 		.driver_info = (unsigned long) &ibot2_info,
-		},
+	},
 #endif
 
 	/*-------------------------------------------------------------*/
@@ -2172,7 +2189,7 @@ static const struct usb_device_id id_table[] = {
 
 	{ }
 };
-MODULE_DEVICE_TABLE (usb, id_table);
+MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver usbtest_driver = {
 	.name =		"usbtest",
@@ -2186,22 +2203,22 @@ static struct usb_driver usbtest_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-static int __init usbtest_init (void)
+static int __init usbtest_init(void)
 {
 #ifdef GENERIC
 	if (vendor)
 		pr_debug("params: vend=0x%04x prod=0x%04x\n", vendor, product);
 #endif
-	return usb_register (&usbtest_driver);
+	return usb_register(&usbtest_driver);
 }
-module_init (usbtest_init);
+module_init(usbtest_init);
 
-static void __exit usbtest_exit (void)
+static void __exit usbtest_exit(void)
 {
-	usb_deregister (&usbtest_driver);
+	usb_deregister(&usbtest_driver);
 }
-module_exit (usbtest_exit);
+module_exit(usbtest_exit);
 
-MODULE_DESCRIPTION ("USB Core/HCD Testing Driver");
-MODULE_LICENSE ("GPL");
+MODULE_DESCRIPTION("USB Core/HCD Testing Driver");
+MODULE_LICENSE("GPL");
 

commit 951fd8ee6a9493f80bc5bccf2c8cfa1535c6ce15
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Mon Aug 2 22:09:17 2010 +0800

    USB: usbtest: support test device with only one iso-in or iso-out endpoint
    
    It is very common that one altsetting may include only one iso-in or iso-out
    single endpoint, especially for high bandwidth endpoint, so support it.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index d92b7ec9a230..eef370eb7a54 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -136,7 +136,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 					iso_out = e;
 			}
 		}
-		if ((in && out)  ||  (iso_in && iso_out))
+		if ((in && out)  ||  iso_in || iso_out)
 			goto found;
 	}
 	return -EINVAL;
@@ -162,6 +162,9 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 		dev->in_iso_pipe = usb_rcvisocpipe (udev,
 				iso_in->desc.bEndpointAddress
 					& USB_ENDPOINT_NUMBER_MASK);
+	}
+
+	if (iso_out) {
 		dev->iso_out = &iso_out->desc;
 		dev->out_iso_pipe = usb_sndisocpipe (udev,
 				iso_out->desc.bEndpointAddress

commit e10e1bec8e6654de4591ef45ddd6a6d1e5b2591c
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Mon Aug 2 22:09:01 2010 +0800

    USB: usbtest: avoid to free coherent buffer in atomic context
    
    This patch fixes the warning below:
    [30753.755998] ------------[ cut here ]------------
    [30753.755998] WARNING: at /home/tom/git/linux-2.6/linux-2.6-next/arch/x86/include/asm/dma-mapping.h:155 hcd_buffer_free+0xb1/0xd4 [usbcore]()
    [30753.755998] Hardware name: 6475EK2
    [30753.755998] Modules linked in: uvcvideo ehci_hcd usbtest cdc_ether usbnet vfat fat usb_storage nfsd lockd nfs_acl auth_rpcgss exportfs mii tun videodev v4l1_compat v4l2_compat_ioctl32 fuse bridge stp llc sunrpc ipv6 cpufreq_ondemand acpi_cpufreq freq_table mperf kvm_intel kvm arc4 ecb ath5k usbhid mac80211 snd_hda_codec_conexant ch341 usbserial ath cfg80211 thinkpad_acpi snd_hda_intel pcspkr wmi hwmon yenta_socket iTCO_wdt iTCO_vendor_support i2c_i801 e1000e snd_hda_codec snd_hwdep snd_pcm snd_timer snd soundcore snd_page_alloc pata_acpi uhci_hcd ohci_hcd usbcore i915 drm_kms_helper drm i2c_algo_bit i2c_core video output [last unloaded: uvcvideo]
    [30753.755998] Pid: 0, comm: swapper Tainted: G        W   2.6.35-rc6-gkh-wl+ #49
    [30753.755998] Call Trace:
    [30753.755998]  <IRQ>  [<ffffffff8104478a>] warn_slowpath_common+0x80/0x98
    [30753.755998]  [<ffffffff810447b7>] warn_slowpath_null+0x15/0x17
    [30753.755998]  [<ffffffffa00ce02d>] hcd_buffer_free+0xb1/0xd4 [usbcore]
    [30753.755998]  [<ffffffffa00c1345>] usb_free_coherent+0x1c/0x1e [usbcore]
    [30753.755998]  [<ffffffffa00b13e4>] simple_free_urb+0x23/0x2f [usbtest]
    [30753.755998]  [<ffffffffa00b210b>] iso_callback+0xbb/0x10f [usbtest]
    [30753.755998]  [<ffffffffa00c7390>] usb_hcd_giveback_urb+0x8c/0xc0 [usbcore]
    [30753.755998]  [<ffffffffa0449b35>] ehci_urb_done+0x84/0x95 [ehci_hcd]
    [30753.755998]  [<ffffffffa044b5a5>] ehci_work+0x41a/0x7dd [ehci_hcd]
    [30753.755998]  [<ffffffffa044e298>] ehci_irq+0x33b/0x370 [ehci_hcd]
    [30753.755998]  [<ffffffff8100fb05>] ? sched_clock+0x9/0xd
    [30753.755998]  [<ffffffff8105e641>] ? sched_clock_local+0x1c/0x82
    [30753.755998]  [<ffffffff8105e76a>] ? sched_clock_cpu+0xc3/0xce
    [30753.755998]  [<ffffffff81067c7e>] ? trace_hardirqs_off+0xd/0xf
    [30753.755998]  [<ffffffff8105e7b8>] ? cpu_clock+0x43/0x5e
    [30753.755998]  [<ffffffffa00c6999>] usb_hcd_irq+0x45/0xa1 [usbcore]
    [30753.755998]  [<ffffffff81092e02>] handle_IRQ_event+0x20/0xa5
    [30753.755998]  [<ffffffff81094cea>] handle_fasteoi_irq+0x92/0xd2
    [30753.755998]  [<ffffffff8100c0ed>] handle_irq+0x1f/0x2a
    [30753.755998]  [<ffffffff8100b75d>] do_IRQ+0x57/0xbe
    [30753.755998]  [<ffffffff8136a693>] ret_from_intr+0x0/0x16
    [30753.755998]  <EOI>  [<ffffffff81223baa>] ? acpi_idle_enter_bm+0x231/0x269
    [30753.755998]  [<ffffffff81223ba3>] ? acpi_idle_enter_bm+0x22a/0x269
    [30753.755998]  [<ffffffff812c4b6b>] cpuidle_idle_call+0x99/0xce
    [30753.755998]  [<ffffffff81008dd5>] cpu_idle+0x61/0xaa
    [30753.755998]  [<ffffffff8136374b>] start_secondary+0x1c2/0x1c6
    [30753.755998] ---[ end trace 904cfaf7ab4cb1a2 ]---
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 0cfbd789ddf2..d92b7ec9a230 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1378,7 +1378,6 @@ static void iso_callback (struct urb *urb)
 			break;
 		}
 	}
-	simple_free_urb (urb);
 
 	ctx->pending--;
 	if (ctx->pending == 0) {
@@ -1495,6 +1494,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 			}
 
 			simple_free_urb (urbs [i]);
+			urbs[i] = NULL;
 			context.pending--;
 			context.submit_error = 1;
 			break;
@@ -1504,6 +1504,10 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 	wait_for_completion (&context.done);
 
+	for (i = 0; i < param->sglen; i++) {
+		if (urbs[i])
+			simple_free_urb(urbs[i]);
+	}
 	/*
 	 * Isochronous transfers are expected to fail sometimes.  As an
 	 * arbitrary limit, we will report an error if any submissions

commit c532b29a6f6d31e84a7c88f995eebdc75ebd4248
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Jun 1 23:04:41 2010 +0200

    USB-BKL: Convert usb_driver ioctl to unlocked_ioctl
    
    And audit all the users. None needed the BKL.  That was easy
    because there was only very few around.
    
    Tested with allmodconfig build on x86-64
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    From: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 16dffe99d9f1..0cfbd789ddf2 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1548,6 +1548,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
  * off just killing the userspace task and waiting for it to exit.
  */
 
+/* No BKL needed */
 static int
 usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 {
@@ -2170,7 +2171,7 @@ static struct usb_driver usbtest_driver = {
 	.name =		"usbtest",
 	.id_table =	id_table,
 	.probe =	usbtest_probe,
-	.ioctl =	usbtest_ioctl,
+	.unlocked_ioctl = usbtest_ioctl,
 	.disconnect =	usbtest_disconnect,
 	.suspend =	usbtest_suspend,
 	.resume =	usbtest_resume,

commit 997ea58eb92f9970b8af7aae48800d0ef43b9423
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Apr 12 13:17:25 2010 +0200

    USB: rename usb_buffer_alloc() and usb_buffer_free() users
    
    For more clearance what the functions actually do,
    
      usb_buffer_alloc() is renamed to usb_alloc_coherent()
      usb_buffer_free()  is renamed to usb_free_coherent()
    
    They should only be used in code which really needs DMA coherency.
    
    All call sites have been changed accordingly, except for staging
    drivers.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Pedro Ribeiro <pedrib@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 9dcc82337ced..16dffe99d9f1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -202,7 +202,7 @@ static struct urb *simple_alloc_urb (
 	urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
 	if (usb_pipein (pipe))
 		urb->transfer_flags |= URB_SHORT_NOT_OK;
-	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, GFP_KERNEL,
+	urb->transfer_buffer = usb_alloc_coherent (udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);
@@ -272,8 +272,8 @@ static inline int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 
 static void simple_free_urb (struct urb *urb)
 {
-	usb_buffer_free (urb->dev, urb->transfer_buffer_length,
-			urb->transfer_buffer, urb->transfer_dma);
+	usb_free_coherent(urb->dev, urb->transfer_buffer_length,
+			  urb->transfer_buffer, urb->transfer_dma);
 	usb_free_urb (urb);
 }
 
@@ -1416,7 +1416,7 @@ static struct urb *iso_alloc_urb (
 
 	urb->number_of_packets = packets;
 	urb->transfer_buffer_length = bytes;
-	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, GFP_KERNEL,
+	urb->transfer_buffer = usb_alloc_coherent (udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);

commit 0ede76fcec5415ef82a423a95120286895822e2d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 5 15:10:17 2010 -0500

    USB: remove uses of URB_NO_SETUP_DMA_MAP
    
    This patch (as1350) removes all usages of coherent buffers for USB
    control-request setup-packet buffers.  There's no good reason to
    reserve coherent memory for these things; control requests are hardly
    ever used in large quantity (the major exception is firmware
    transfers, and they aren't time-critical).  Furthermore, only seven
    drivers used it.  We might as well always use streaming DMA mappings
    for setup-packet buffers, and remove some extra complexity from
    usbcore.
    
    The DMA-mapping portion of hcd.c is currently in flux.  A separate
    patch will be submitted to remove support for URB_NO_SETUP_DMA_MAP
    after everything else settles down.  The removal should go smoothly,
    as by then nobody will be using it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index a21cce6f7403..9dcc82337ced 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -977,15 +977,13 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!u)
 			goto cleanup;
 
-		reqp = usb_buffer_alloc (udev, sizeof *reqp, GFP_KERNEL,
-				&u->setup_dma);
+		reqp = kmalloc(sizeof *reqp, GFP_KERNEL);
 		if (!reqp)
 			goto cleanup;
 		reqp->setup = req;
 		reqp->number = i % NUM_SUBCASES;
 		reqp->expected = expected;
 		u->setup_packet = (char *) &reqp->setup;
-		u->transfer_flags |= URB_NO_SETUP_DMA_MAP;
 
 		u->context = &context;
 		u->complete = ctrl_complete;
@@ -1017,10 +1015,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!urb [i])
 			continue;
 		urb [i]->dev = udev;
-		if (urb [i]->setup_packet)
-			usb_buffer_free (udev, sizeof (struct usb_ctrlrequest),
-					urb [i]->setup_packet,
-					urb [i]->setup_dma);
+		kfree(urb[i]->setup_packet);
 		simple_free_urb (urb [i]);
 	}
 	kfree (urb);

commit 33b9e16243fd69493be3ddda7be73226c8be586a
Author: Németh Márton <nm127@freemail.hu>
Date:   Sun Jan 10 15:34:45 2010 +0100

    USB misc: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Németh Márton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 707a87da77f8..a21cce6f7403 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2097,7 +2097,7 @@ static struct usbtest_info generic_info = {
 #endif
 
 
-static struct usb_device_id id_table [] = {
+static const struct usb_device_id id_table[] = {
 
 	/*-------------------------------------------------------------*/
 

commit 9bbdf1e0afe771ca7650f9f476769310bee9d8f3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 12:57:28 2010 -0500

    USB: convert to the runtime PM framework
    
    This patch (as1329) converts the USB stack over to the PM core's
    runtime PM framework.  This involves numerous changes throughout
    usbcore, especially to hub.c and driver.c.  Perhaps the most notable
    change is that CONFIG_USB_SUSPEND now depends on CONFIG_PM_RUNTIME
    instead of CONFIG_PM.
    
    Several fields in the usb_device and usb_interface structures are no
    longer needed.  Some code which used to depend on CONFIG_USB_PM now
    depends on CONFIG_USB_SUSPEND (requiring some rearrangement of header
    files).
    
    The only visible change in behavior should be that following a system
    sleep (resume from RAM or resume from hibernation), autosuspended USB
    devices will be resumed just like everything else.  They won't remain
    suspended.  But if they aren't in use then they will naturally
    autosuspend again in a few seconds.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3dab0c0b196f..707a87da77f8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1580,10 +1580,6 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		return -ERESTARTSYS;
 
 	/* FIXME: What if a system sleep starts while a test is running? */
-	if (!intf->is_active) {
-		mutex_unlock(&dev->lock);
-		return -EHOSTUNREACH;
-	}
 
 	/* some devices, like ez-usb default devices, need a non-default
 	 * altsetting to have any active endpoints.  some tests change

commit 7f4e985448e82fe4a1cc0ae4fcecaf7e0301c07b
Author: Vikram Pandita <vikram.pandita@ti.com>
Date:   Mon Nov 9 21:24:32 2009 -0600

    usbtest: make module param pattern writeable
    
    Allow module_param to be writeable. This allows us to change
    the parameter if usbtest is built-in in the kernel.
    
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index a9f06d76960f..3dab0c0b196f 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -213,8 +213,9 @@ static struct urb *simple_alloc_urb (
 }
 
 static unsigned pattern = 0;
-module_param (pattern, uint, S_IRUGO);
-MODULE_PARM_DESC(pattern, "i/o pattern (0 == zeroes)");
+static unsigned mod_pattern;
+module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(mod_pattern, "i/o pattern (0 == zeroes)");
 
 static inline void simple_fill_buf (struct urb *urb)
 {
@@ -1567,6 +1568,8 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 
 	// FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is.
 
+	pattern = mod_pattern;
+
 	if (code != USBTEST_REQUEST)
 		return -EOPNOTSUPP;
 

commit 3b6c023f831e3179c42bbcff189c73628cd5ea4c
Author: Martin Fuzzey <mfuzzey@gmail.com>
Date:   Thu Jun 4 23:20:38 2009 +0200

    USB: usbtest fix endless loop in unlink tests.
    
    In tests 11 and 12 if the URB completes with an error status (eg babble)
    the asynchrous unlink entered an endless loop trying to unlink
    a non resubmitted URB.
    
    Signed-off-by: Martin Fuzzey <mfuzzey@gmail.com>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 5f1a19d1497d..a9f06d76960f 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1072,23 +1072,34 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	 */
 	msleep (jiffies % (2 * INTERRUPT_RATE));
 	if (async) {
-retry:
-		retval = usb_unlink_urb (urb);
-		if (retval == -EBUSY || retval == -EIDRM) {
-			/* we can't unlink urbs while they're completing.
-			 * or if they've completed, and we haven't resubmitted.
-			 * "normal" drivers would prevent resubmission, but
-			 * since we're testing unlink paths, we can't.
-			 */
-			ERROR(dev,  "unlink retry\n");
-			goto retry;
+		while (!completion_done(&completion)) {
+			retval = usb_unlink_urb(urb);
+
+			switch (retval) {
+			case -EBUSY:
+			case -EIDRM:
+				/* we can't unlink urbs while they're completing
+				 * or if they've completed, and we haven't
+				 * resubmitted. "normal" drivers would prevent
+				 * resubmission, but since we're testing unlink
+				 * paths, we can't.
+				 */
+				ERROR(dev, "unlink retry\n");
+				continue;
+			case 0:
+			case -EINPROGRESS:
+				break;
+
+			default:
+				dev_err(&dev->intf->dev,
+					"unlink fail %d\n", retval);
+				return retval;
+			}
+
+			break;
 		}
 	} else
 		usb_kill_urb (urb);
-	if (!(retval == 0 || retval == -EINPROGRESS)) {
-		dev_err(&dev->intf->dev, "unlink fail %d\n", retval);
-		return retval;
-	}
 
 	wait_for_completion (&completion);
 	retval = urb->status;

commit e64a5219296fff11a0da0322b43012265cd3b327
Author: roel kluin <roel.kluin@gmail.com>
Date:   Tue Oct 21 00:47:23 2008 -0400

    USB: clean up redundant tests on unsigned
    
    temp, bytes and param->{length,sglen,vary} are unsigned so
    these tests do nothing.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 444c69c447be..5f1a19d1497d 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -192,8 +192,6 @@ static struct urb *simple_alloc_urb (
 {
 	struct urb		*urb;
 
-	if (bytes < 0)
-		return NULL;
 	urb = usb_alloc_urb (0, GFP_KERNEL);
 	if (!urb)
 		return urb;

commit 8aafdf6a1528b0672a0527be473d9be5a12289d3
Author: roel kluin <roel.kluin@gmail.com>
Date:   Tue Oct 21 00:36:44 2008 -0400

    USB: usbtest.c: length, sglen and vary are unsigned, so cannot be negative
    
    length, sglen and vary are unsigned, so cannot be negative
    
    see
    vi drivers/usb/misc/usbtest.c +18
    struct usbtest_param {
    ...
            unsigned                iterations;
            unsigned                length;
            unsigned                vary;
            unsigned                sglen;
    ...
    };
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b358c4e1cf21..444c69c447be 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1561,8 +1561,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (code != USBTEST_REQUEST)
 		return -EOPNOTSUPP;
 
-	if (param->iterations <= 0 || param->length < 0
-			|| param->sglen < 0 || param->vary < 0)
+	if (param->iterations <= 0)
 		return -EINVAL;
 
 	if (mutex_lock_interruptible(&dev->lock))

commit b6c63937001889af6fe431aaba97e59d04e028e7
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Jul 25 01:45:52 2008 -0700

    Rename WARN() to WARNING() to clear the namespace
    
    We want to use WARN() as a variant of WARN_ON(), however a few drivers are
    using WARN() internally.  This patch renames these to WARNING() to avoid the
    namespace clash.  A few cases were defining but not using the thing, for those
    cases I just deleted the definition.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: Karsten Keil <kkeil@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 054dedd28127..b358c4e1cf21 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -81,7 +81,7 @@ static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
 
 #define ERROR(tdev, fmt, args...) \
 	dev_err(&(tdev)->intf->dev , fmt , ## args)
-#define WARN(tdev, fmt, args...) \
+#define WARNING(tdev, fmt, args...) \
 	dev_warn(&(tdev)->intf->dev , fmt , ## args)
 
 /*-------------------------------------------------------------------------*/
@@ -1946,7 +1946,7 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 
 			status = get_endpoints (dev, intf);
 			if (status < 0) {
-				WARN(dev, "couldn't get endpoints, %d\n",
+				WARNING(dev, "couldn't get endpoints, %d\n",
 						status);
 				return status;
 			}

commit 6def755320a214ae149ad6bc69eb8c1d7887e678
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Mon May 12 20:17:25 2008 +0200

    usbtest: comment on why this code "expects" negative and positive errnos
    
    On Mon, May 12, 2008 at 01:02:22AM -0700, David Brownell wrote:
    > On Sunday 11 May 2008, Marcin Slusarz wrote:
    > >
    > > test_ctrl_queue expects (?) positive and negative errnos.
    > > what is going on here?
    >
    > The sign is just a way to flag something:
    >
    >                 /* some faults are allowed, not required */
    >
    > The negative ones are required.  Positive codes are optional,
    > in the sense that, depending on how the peripheral happens
    > to be implemented, they won't necessarily be triggered.
    >
    > For example, the test to fetch a device qualifier desriptor
    > must succeed if the device is running at high speed.  So that
    > test is marked as negative.  But when it's full speed, it
    > could legitimately fail; marked as positive.  And so on for
    > other tests.
    >
    > Look at how the codes are *interpreted* to see it work.
    
    Lets document it.
    
    Based on comment from David Brownell <david-b@pacbell.net>.
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 742be3c35947..054dedd28127 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -856,6 +856,11 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		struct urb		*u;
 		struct usb_ctrlrequest	req;
 		struct subcase		*reqp;
+
+		/* sign of this variable means:
+		 *  -: tested code must return this (negative) error code
+		 *  +: tested code may return this (negative too) error code
+		 */
 		int			expected = 0;
 
 		/* requests here are mostly expected to succeed on any

commit 28ffd79c31a7bed6f610511a4d104d1255cd1d95
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Apr 25 18:51:10 2008 -0700

    USB: usbtest displays diagnostics again
    
    Minor cleanup to the "usbtest" driver, mostly to resolve a regression:
    all the important diagnostics were at KERN_DEBUG, so that when the
    "#define DEBUG" was removed from the top of that file it stopped
    providing diagnostics.  Fix by using KERN_ERROR.  Also:
    
     - Stop using the legacy dbg() calls
     - Simplify the internal debug macros
     - Correct some test descriptions:
            * Test #10 subcase 7 should *always* stall
            * Test #10 subcase 8 *may* stall
     - Diagnostic about control queue test failures is more informative
     - Fix some whitespace "bugs"
    
    And add a warning about the rude interaction between usbfs ioctl()
    and khubd during device disconnect ... don't unplug a device under
    test, that will wedge.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index a51983854ca0..742be3c35947 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -79,30 +79,10 @@ static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
 /* set up all urbs so they can be used with either bulk or interrupt */
 #define	INTERRUPT_RATE		1	/* msec/transfer */
 
-#define xprintk(tdev,level,fmt,args...) \
-	dev_printk(level ,  &(tdev)->intf->dev ,  fmt ,  ## args)
-
-#ifdef DEBUG
-#define DBG(dev,fmt,args...) \
-	xprintk(dev , KERN_DEBUG , fmt , ## args)
-#else
-#define DBG(dev,fmt,args...) \
-	do { } while (0)
-#endif /* DEBUG */
-
-#ifdef VERBOSE
-#define VDBG DBG
-#else
-#define VDBG(dev,fmt,args...) \
-	do { } while (0)
-#endif	/* VERBOSE */
-
-#define ERROR(dev,fmt,args...) \
-	xprintk(dev , KERN_ERR , fmt , ## args)
-#define WARN(dev,fmt,args...) \
-	xprintk(dev , KERN_WARNING , fmt , ## args)
-#define INFO(dev,fmt,args...) \
-	xprintk(dev , KERN_INFO , fmt , ## args)
+#define ERROR(tdev, fmt, args...) \
+	dev_err(&(tdev)->intf->dev , fmt , ## args)
+#define WARN(tdev, fmt, args...) \
+	dev_warn(&(tdev)->intf->dev , fmt , ## args)
 
 /*-------------------------------------------------------------------------*/
 
@@ -236,7 +216,7 @@ static struct urb *simple_alloc_urb (
 
 static unsigned pattern = 0;
 module_param (pattern, uint, S_IRUGO);
-// MODULE_PARM_DESC (pattern, "i/o pattern (0 == zeroes)");
+MODULE_PARM_DESC(pattern, "i/o pattern (0 == zeroes)");
 
 static inline void simple_fill_buf (struct urb *urb)
 {
@@ -257,7 +237,7 @@ static inline void simple_fill_buf (struct urb *urb)
 	}
 }
 
-static inline int simple_check_buf (struct urb *urb)
+static inline int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 {
 	unsigned	i;
 	u8		expected;
@@ -285,7 +265,7 @@ static inline int simple_check_buf (struct urb *urb)
 		}
 		if (*buf == expected)
 			continue;
-		dbg ("buf[%d] = %d (not %d)", i, *buf, expected);
+		ERROR(tdev, "buf[%d] = %d (not %d)\n", i, *buf, expected);
 		return -EINVAL;
 	}
 	return 0;
@@ -299,6 +279,7 @@ static void simple_free_urb (struct urb *urb)
 }
 
 static int simple_io (
+	struct usbtest_dev	*tdev,
 	struct urb		*urb,
 	int			iterations,
 	int			vary,
@@ -324,7 +305,7 @@ static int simple_io (
 		retval = urb->status;
 		urb->dev = udev;
 		if (retval == 0 && usb_pipein (urb->pipe))
-			retval = simple_check_buf (urb);
+			retval = simple_check_buf(tdev, urb);
 
 		if (vary) {
 			int	len = urb->transfer_buffer_length;
@@ -341,7 +322,7 @@ static int simple_io (
 	urb->transfer_buffer_length = max;
 
 	if (expected != retval)
-		dev_dbg (&udev->dev,
+		dev_err(&udev->dev,
 			"%s failed, iterations left %d, status %d (not %d)\n",
 				label, iterations, retval, expected);
 	return retval;
@@ -357,7 +338,7 @@ static int simple_io (
 static void free_sglist (struct scatterlist *sg, int nents)
 {
 	unsigned		i;
-	
+
 	if (!sg)
 		return;
 	for (i = 0; i < nents; i++) {
@@ -415,7 +396,7 @@ alloc_sglist (int nents, int max, int vary)
 }
 
 static int perform_sglist (
-	struct usb_device	*udev,
+	struct usbtest_dev	*tdev,
 	unsigned		iterations,
 	int			pipe,
 	struct usb_sg_request	*req,
@@ -423,6 +404,7 @@ static int perform_sglist (
 	int			nents
 )
 {
+	struct usb_device	*udev = testdev_to_usbdev(tdev);
 	int			retval = 0;
 
 	while (retval == 0 && iterations-- > 0) {
@@ -431,7 +413,7 @@ static int perform_sglist (
 					? (INTERRUPT_RATE << 3)
 					: INTERRUPT_RATE,
 				sg, nents, 0, GFP_KERNEL);
-		
+
 		if (retval)
 			break;
 		usb_sg_wait (req);
@@ -446,7 +428,8 @@ static int perform_sglist (
 	// failure if retval is as we expected ...
 
 	if (retval)
-		dbg ("perform_sglist failed, iterations left %d, status %d",
+		ERROR(tdev, "perform_sglist failed, "
+				"iterations left %d, status %d\n",
 				iterations, retval);
 	return retval;
 }
@@ -505,28 +488,28 @@ static int set_altsetting (struct usbtest_dev *dev, int alternate)
 			alternate);
 }
 
-static int is_good_config (char *buf, int len)
+static int is_good_config(struct usbtest_dev *tdev, int len)
 {
 	struct usb_config_descriptor	*config;
-	
+
 	if (len < sizeof *config)
 		return 0;
-	config = (struct usb_config_descriptor *) buf;
+	config = (struct usb_config_descriptor *) tdev->buf;
 
 	switch (config->bDescriptorType) {
 	case USB_DT_CONFIG:
 	case USB_DT_OTHER_SPEED_CONFIG:
 		if (config->bLength != 9) {
-			dbg ("bogus config descriptor length");
+			ERROR(tdev, "bogus config descriptor length\n");
 			return 0;
 		}
 		/* this bit 'must be 1' but often isn't */
 		if (!realworld && !(config->bmAttributes & 0x80)) {
-			dbg ("high bit of config attributes not set");
+			ERROR(tdev, "high bit of config attributes not set\n");
 			return 0;
 		}
 		if (config->bmAttributes & 0x1f) {	/* reserved == 0 */
-			dbg ("reserved config bits set");
+			ERROR(tdev, "reserved config bits set\n");
 			return 0;
 		}
 		break;
@@ -538,7 +521,7 @@ static int is_good_config (char *buf, int len)
 		return 1;
 	if (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)		/* max partial read */
 		return 1;
-	dbg ("bogus config descriptor read size");
+	ERROR(tdev, "bogus config descriptor read size\n");
 	return 0;
 }
 
@@ -571,7 +554,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		/* 9.2.3 constrains the range here */
 		alt = iface->altsetting [i].desc.bAlternateSetting;
 		if (alt < 0 || alt >= iface->num_altsetting) {
-			dev_dbg (&iface->dev,
+			dev_err(&iface->dev,
 					"invalid alt [%d].bAltSetting = %d\n",
 					i, alt);
 		}
@@ -583,7 +566,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		/* [9.4.10] set_interface */
 		retval = set_altsetting (dev, alt);
 		if (retval) {
-			dev_dbg (&iface->dev, "can't set_interface = %d, %d\n",
+			dev_err(&iface->dev, "can't set_interface = %d, %d\n",
 					alt, retval);
 			return retval;
 		}
@@ -591,7 +574,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 		/* [9.4.4] get_interface always works */
 		retval = get_altsetting (dev);
 		if (retval != alt) {
-			dev_dbg (&iface->dev, "get alt should be %d, was %d\n",
+			dev_err(&iface->dev, "get alt should be %d, was %d\n",
 					alt, retval);
 			return (retval < 0) ? retval : -EDOM;
 		}
@@ -611,7 +594,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 				USB_DIR_IN | USB_RECIP_DEVICE,
 				0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);
 		if (retval != 1 || dev->buf [0] != expected) {
-			dev_dbg (&iface->dev, "get config --> %d %d (1 %d)\n",
+			dev_err(&iface->dev, "get config --> %d %d (1 %d)\n",
 				retval, dev->buf[0], expected);
 			return (retval < 0) ? retval : -EDOM;
 		}
@@ -621,7 +604,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	retval = usb_get_descriptor (udev, USB_DT_DEVICE, 0,
 			dev->buf, sizeof udev->descriptor);
 	if (retval != sizeof udev->descriptor) {
-		dev_dbg (&iface->dev, "dev descriptor --> %d\n", retval);
+		dev_err(&iface->dev, "dev descriptor --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
 
@@ -629,8 +612,8 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	for (i = 0; i < udev->descriptor.bNumConfigurations; i++) {
 		retval = usb_get_descriptor (udev, USB_DT_CONFIG, i,
 				dev->buf, TBUF_SIZE);
-		if (!is_good_config (dev->buf, retval)) {
-			dev_dbg (&iface->dev,
+		if (!is_good_config(dev, retval)) {
+			dev_err(&iface->dev,
 					"config [%d] descriptor --> %d\n",
 					i, retval);
 			return (retval < 0) ? retval : -EDOM;
@@ -650,14 +633,14 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 				sizeof (struct usb_qualifier_descriptor));
 		if (retval == -EPIPE) {
 			if (udev->speed == USB_SPEED_HIGH) {
-				dev_dbg (&iface->dev,
+				dev_err(&iface->dev,
 						"hs dev qualifier --> %d\n",
 						retval);
 				return (retval < 0) ? retval : -EDOM;
 			}
 			/* usb2.0 but not high-speed capable; fine */
 		} else if (retval != sizeof (struct usb_qualifier_descriptor)) {
-			dev_dbg (&iface->dev, "dev qualifier --> %d\n", retval);
+			dev_err(&iface->dev, "dev qualifier --> %d\n", retval);
 			return (retval < 0) ? retval : -EDOM;
 		} else
 			d = (struct usb_qualifier_descriptor *) dev->buf;
@@ -669,8 +652,8 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 				retval = usb_get_descriptor (udev,
 					USB_DT_OTHER_SPEED_CONFIG, i,
 					dev->buf, TBUF_SIZE);
-				if (!is_good_config (dev->buf, retval)) {
-					dev_dbg (&iface->dev,
+				if (!is_good_config(dev, retval)) {
+					dev_err(&iface->dev,
 						"other speed config --> %d\n",
 						retval);
 					return (retval < 0) ? retval : -EDOM;
@@ -683,7 +666,7 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	/* [9.4.5] get_status always works */
 	retval = usb_get_status (udev, USB_RECIP_DEVICE, 0, dev->buf);
 	if (retval != 2) {
-		dev_dbg (&iface->dev, "get dev status --> %d\n", retval);
+		dev_err(&iface->dev, "get dev status --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
 
@@ -693,11 +676,11 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 	retval = usb_get_status (udev, USB_RECIP_INTERFACE,
 			iface->altsetting [0].desc.bInterfaceNumber, dev->buf);
 	if (retval != 2) {
-		dev_dbg (&iface->dev, "get interface status --> %d\n", retval);
+		dev_err(&iface->dev, "get interface status --> %d\n", retval);
 		return (retval < 0) ? retval : -EDOM;
 	}
 	// FIXME get status for each endpoint in the interface
-	
+
 	return 0;
 }
 
@@ -752,8 +735,9 @@ static void ctrl_complete (struct urb *urb)
 	 */
 	if (subcase->number > 0) {
 		if ((subcase->number - ctx->last) != 1) {
-			dbg ("subcase %d completed out of order, last %d",
-					subcase->number, ctx->last);
+			ERROR(ctx->dev,
+				"subcase %d completed out of order, last %d\n",
+				subcase->number, ctx->last);
 			status = -EDOM;
 			ctx->last = subcase->number;
 			goto error;
@@ -777,7 +761,7 @@ static void ctrl_complete (struct urb *urb)
 		else if (subcase->number == 12 && status == -EPIPE)
 			status = 0;
 		else
-			dbg ("subtest %d error, status %d",
+			ERROR(ctx->dev, "subtest %d error, status %d\n",
 					subcase->number, status);
 	}
 
@@ -788,9 +772,12 @@ static void ctrl_complete (struct urb *urb)
 			int		i;
 
 			ctx->status = status;
-			info ("control queue %02x.%02x, err %d, %d left",
+			ERROR(ctx->dev, "control queue %02x.%02x, err %d, "
+					"%d left, subcase %d, len %d/%d\n",
 					reqp->bRequestType, reqp->bRequest,
-					status, ctx->count);
+					status, ctx->count, subcase->number,
+					urb->actual_length,
+					urb->transfer_buffer_length);
 
 			/* FIXME this "unlink everything" exit route should
 			 * be a separate test case.
@@ -799,7 +786,8 @@ static void ctrl_complete (struct urb *urb)
 			/* unlink whatever's still pending */
 			for (i = 1; i < ctx->param->sglen; i++) {
 				struct urb	*u = ctx->urb [
-	(i + subcase->number) % ctx->param->sglen];
+						(i + subcase->number)
+						% ctx->param->sglen];
 
 				if (u == urb || !u->dev)
 					continue;
@@ -812,7 +800,8 @@ static void ctrl_complete (struct urb *urb)
 				case -EIDRM:
 					continue;
 				default:
-					dbg ("urb unlink --> %d", status);
+					ERROR(ctx->dev, "urb unlink --> %d\n",
+							status);
 				}
 			}
 			status = ctx->status;
@@ -822,14 +811,15 @@ static void ctrl_complete (struct urb *urb)
 	/* resubmit if we need to, else mark this as done */
 	if ((status == 0) && (ctx->pending < ctx->count)) {
 		if ((status = usb_submit_urb (urb, GFP_ATOMIC)) != 0) {
-			dbg ("can't resubmit ctrl %02x.%02x, err %d",
+			ERROR(ctx->dev,
+				"can't resubmit ctrl %02x.%02x, err %d\n",
 				reqp->bRequestType, reqp->bRequest, status);
 			urb->dev = NULL;
 		} else
 			ctx->pending++;
 	} else
 		urb->dev = NULL;
-	
+
 	/* signal completion when nothing's queued */
 	if (ctx->pending == 0)
 		complete (&ctx->complete);
@@ -918,11 +908,11 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 			req.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);
 			// interface == 0
 			len = sizeof (struct usb_interface_descriptor);
-			expected = EPIPE;
+			expected = -EPIPE;
 			break;
 		// NOTE: two consecutive stalls in the queue here.
 		// that tests fault recovery a bit more aggressively.
-		case 8:		// clear endpoint halt (USUALLY STALLS)
+		case 8:		// clear endpoint halt (MAY STALL)
 			req.bRequest = USB_REQ_CLEAR_FEATURE;
 			req.bRequestType = USB_RECIP_ENDPOINT;
 			// wValue 0 == ep halt
@@ -965,7 +955,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 			break;
 		case 14:	// short read; try to fill the last packet
 			req.wValue = cpu_to_le16 ((USB_DT_DEVICE << 8) | 0);
-			// device descriptor size == 18 bytes 
+			/* device descriptor size == 18 bytes */
 			len = udev->descriptor.bMaxPacketSize0;
 			switch (len) {
 			case 8:		len = 24; break;
@@ -974,7 +964,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 			expected = -EREMOTEIO;
 			break;
 		default:
-			err ("bogus number of ctrl queue testcases!");
+			ERROR(dev, "bogus number of ctrl queue testcases!\n");
 			context.status = -EINVAL;
 			goto cleanup;
 		}
@@ -1003,7 +993,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 	for (i = 0; i < param->sglen; i++) {
 		context.status = usb_submit_urb (urb [i], GFP_ATOMIC);
 		if (context.status != 0) {
-			dbg ("can't submit urb[%d], status %d",
+			ERROR(dev, "can't submit urb[%d], status %d\n",
 					i, context.status);
 			context.count = context.pending;
 			break;
@@ -1070,7 +1060,7 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	 * due to errors, or is just NAKing requests.
 	 */
 	if ((retval = usb_submit_urb (urb, GFP_KERNEL)) != 0) {
-		dev_dbg (&dev->intf->dev, "submit fail %d\n", retval);
+		dev_err(&dev->intf->dev, "submit fail %d\n", retval);
 		return retval;
 	}
 
@@ -1087,13 +1077,13 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 			 * "normal" drivers would prevent resubmission, but
 			 * since we're testing unlink paths, we can't.
 			 */
-			dev_dbg (&dev->intf->dev, "unlink retry\n");
+			ERROR(dev,  "unlink retry\n");
 			goto retry;
 		}
 	} else
 		usb_kill_urb (urb);
 	if (!(retval == 0 || retval == -EINPROGRESS)) {
-		dev_dbg (&dev->intf->dev, "unlink fail %d\n", retval);
+		dev_err(&dev->intf->dev, "unlink fail %d\n", retval);
 		return retval;
 	}
 
@@ -1121,7 +1111,7 @@ static int unlink_simple (struct usbtest_dev *dev, int pipe, int len)
 
 /*-------------------------------------------------------------------------*/
 
-static int verify_not_halted (int ep, struct urb *urb)
+static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
 	u16	status;
@@ -1129,20 +1119,21 @@ static int verify_not_halted (int ep, struct urb *urb)
 	/* shouldn't look or act halted */
 	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
-		dbg ("ep %02x couldn't get no-halt status, %d", ep, retval);
+		ERROR(tdev, "ep %02x couldn't get no-halt status, %d\n",
+				ep, retval);
 		return retval;
 	}
 	if (status != 0) {
-		dbg ("ep %02x bogus status: %04x != 0", ep, status);
+		ERROR(tdev, "ep %02x bogus status: %04x != 0\n", ep, status);
 		return -EINVAL;
 	}
-	retval = simple_io (urb, 1, 0, 0, __func__);
+	retval = simple_io(tdev, urb, 1, 0, 0, __func__);
 	if (retval != 0)
 		return -EINVAL;
 	return 0;
 }
 
-static int verify_halted (int ep, struct urb *urb)
+static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
 	u16	status;
@@ -1150,29 +1141,30 @@ static int verify_halted (int ep, struct urb *urb)
 	/* should look and act halted */
 	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
 	if (retval < 0) {
-		dbg ("ep %02x couldn't get halt status, %d", ep, retval);
+		ERROR(tdev, "ep %02x couldn't get halt status, %d\n",
+				ep, retval);
 		return retval;
 	}
 	le16_to_cpus(&status);
 	if (status != 1) {
-		dbg ("ep %02x bogus status: %04x != 1", ep, status);
+		ERROR(tdev, "ep %02x bogus status: %04x != 1\n", ep, status);
 		return -EINVAL;
 	}
-	retval = simple_io (urb, 1, 0, -EPIPE, __func__);
+	retval = simple_io(tdev, urb, 1, 0, -EPIPE, __func__);
 	if (retval != -EPIPE)
 		return -EINVAL;
-	retval = simple_io (urb, 1, 0, -EPIPE, "verify_still_halted");
+	retval = simple_io(tdev, urb, 1, 0, -EPIPE, "verify_still_halted");
 	if (retval != -EPIPE)
 		return -EINVAL;
 	return 0;
 }
 
-static int test_halt (int ep, struct urb *urb)
+static int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
 
 	/* shouldn't look or act halted now */
-	retval = verify_not_halted (ep, urb);
+	retval = verify_not_halted(tdev, ep, urb);
 	if (retval < 0)
 		return retval;
 
@@ -1182,20 +1174,20 @@ static int test_halt (int ep, struct urb *urb)
 			USB_ENDPOINT_HALT, ep,
 			NULL, 0, USB_CTRL_SET_TIMEOUT);
 	if (retval < 0) {
-		dbg ("ep %02x couldn't set halt, %d", ep, retval);
+		ERROR(tdev, "ep %02x couldn't set halt, %d\n", ep, retval);
 		return retval;
 	}
-	retval = verify_halted (ep, urb);
+	retval = verify_halted(tdev, ep, urb);
 	if (retval < 0)
 		return retval;
 
 	/* clear halt (tests API + protocol), verify it worked */
 	retval = usb_clear_halt (urb->dev, urb->pipe);
 	if (retval < 0) {
-		dbg ("ep %02x couldn't clear halt, %d", ep, retval);
+		ERROR(tdev, "ep %02x couldn't clear halt, %d\n", ep, retval);
 		return retval;
 	}
-	retval = verify_not_halted (ep, urb);
+	retval = verify_not_halted(tdev, ep, urb);
 	if (retval < 0)
 		return retval;
 
@@ -1217,7 +1209,7 @@ static int halt_simple (struct usbtest_dev *dev)
 	if (dev->in_pipe) {
 		ep = usb_pipeendpoint (dev->in_pipe) | USB_DIR_IN;
 		urb->pipe = dev->in_pipe;
-		retval = test_halt (ep, urb);
+		retval = test_halt(dev, ep, urb);
 		if (retval < 0)
 			goto done;
 	}
@@ -1225,7 +1217,7 @@ static int halt_simple (struct usbtest_dev *dev)
 	if (dev->out_pipe) {
 		ep = usb_pipeendpoint (dev->out_pipe);
 		urb->pipe = dev->out_pipe;
-		retval = test_halt (ep, urb);
+		retval = test_halt(dev, ep, urb);
 	}
 done:
 	simple_free_urb (urb);
@@ -1275,7 +1267,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 		if (retval != len) {
 			what = "write";
 			if (retval >= 0) {
-				INFO(dev, "ctrl_out, wlen %d (expected %d)\n",
+				ERROR(dev, "ctrl_out, wlen %d (expected %d)\n",
 						retval, len);
 				retval = -EBADMSG;
 			}
@@ -1289,7 +1281,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 		if (retval != len) {
 			what = "read";
 			if (retval >= 0) {
-				INFO(dev, "ctrl_out, rlen %d (expected %d)\n",
+				ERROR(dev, "ctrl_out, rlen %d (expected %d)\n",
 						retval, len);
 				retval = -EBADMSG;
 			}
@@ -1299,7 +1291,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 		/* fail if we can't verify */
 		for (j = 0; j < len; j++) {
 			if (buf [j] != (u8) (i + j)) {
-				INFO (dev, "ctrl_out, byte %d is %d not %d\n",
+				ERROR(dev, "ctrl_out, byte %d is %d not %d\n",
 					j, buf [j], (u8) i + j);
 				retval = -EBADMSG;
 				break;
@@ -1321,7 +1313,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 	}
 
 	if (retval < 0)
-		INFO (dev, "ctrl_out %s failed, code %d, count %d\n",
+		ERROR (dev, "ctrl_out %s failed, code %d, count %d\n",
 			what, retval, i);
 
 	kfree (buf);
@@ -1366,7 +1358,7 @@ static void iso_callback (struct urb *urb)
 		case 0:
 			goto done;
 		default:
-			dev_dbg (&ctx->dev->intf->dev,
+			dev_err(&ctx->dev->intf->dev,
 					"iso resubmit err %d\n",
 					status);
 			/* FALLTHROUGH */
@@ -1381,7 +1373,7 @@ static void iso_callback (struct urb *urb)
 	ctx->pending--;
 	if (ctx->pending == 0) {
 		if (ctx->errors)
-			dev_dbg (&ctx->dev->intf->dev,
+			dev_err(&ctx->dev->intf->dev,
 				"iso test, %lu errors out of %lu\n",
 				ctx->errors, ctx->packet_count);
 		complete (&ctx->done);
@@ -1458,7 +1450,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 	memset (urbs, 0, sizeof urbs);
 	udev = testdev_to_usbdev (dev);
-	dev_dbg (&dev->intf->dev,
+	dev_info(&dev->intf->dev,
 		"... iso period %d %sframes, wMaxPacket %04x\n",
 		1 << (desc->bInterval - 1),
 		(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
@@ -1475,7 +1467,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 		urbs [i]->context = &context;
 	}
 	packets *= param->iterations;
-	dev_dbg (&dev->intf->dev,
+	dev_info(&dev->intf->dev,
 		"... total %lu msec (%lu packets)\n",
 		(packets * (1 << (desc->bInterval - 1)))
 			/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
@@ -1537,6 +1529,13 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
  * except indirectly by consuming USB bandwidth and CPU resources for test
  * threads and request completion.  But the only way to know that for sure
  * is to test when HC queues are in use by many devices.
+ *
+ * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),
+ * it locks out usbcore in certain code paths.  Notably, if you disconnect
+ * the device-under-test, khubd will wait block forever waiting for the
+ * ioctl to complete ... so that usb_disconnect() can abort the pending
+ * urbs and then call usbtest_disconnect().  To abort a test, you're best
+ * off just killing the userspace task and waiting for it to exit.
  */
 
 static int
@@ -1575,7 +1574,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	 * altsettings; force a default so most tests don't need to check.
 	 */
 	if (dev->info->alt >= 0) {
-	    	int	res;
+		int	res;
 
 		if (intf->altsetting->desc.bInterfaceNumber) {
 			mutex_unlock(&dev->lock);
@@ -1604,7 +1603,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	switch (param->test_num) {
 
 	case 0:
-		dev_dbg (&intf->dev, "TEST 0:  NOP\n");
+		dev_info(&intf->dev, "TEST 0:  NOP\n");
 		retval = 0;
 		break;
 
@@ -1612,7 +1611,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 1:
 		if (dev->out_pipe == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 				"TEST 1:  write %d bytes %u times\n",
 				param->length, param->iterations);
 		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
@@ -1621,13 +1620,13 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk sink (maybe accepts short writes)
-		retval = simple_io (urb, param->iterations, 0, 0, "test1");
+		retval = simple_io(dev, urb, param->iterations, 0, 0, "test1");
 		simple_free_urb (urb);
 		break;
 	case 2:
 		if (dev->in_pipe == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 				"TEST 2:  read %d bytes %u times\n",
 				param->length, param->iterations);
 		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
@@ -1636,13 +1635,13 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk source (maybe generates short writes)
-		retval = simple_io (urb, param->iterations, 0, 0, "test2");
+		retval = simple_io(dev, urb, param->iterations, 0, 0, "test2");
 		simple_free_urb (urb);
 		break;
 	case 3:
 		if (dev->out_pipe == 0 || param->vary == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 				"TEST 3:  write/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
 		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
@@ -1651,14 +1650,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk sink (maybe accepts short writes)
-		retval = simple_io (urb, param->iterations, param->vary,
+		retval = simple_io(dev, urb, param->iterations, param->vary,
 					0, "test3");
 		simple_free_urb (urb);
 		break;
 	case 4:
 		if (dev->in_pipe == 0 || param->vary == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 				"TEST 4:  read/%d 0..%d bytes %u times\n",
 				param->vary, param->length, param->iterations);
 		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
@@ -1667,7 +1666,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk source (maybe generates short writes)
-		retval = simple_io (urb, param->iterations, param->vary,
+		retval = simple_io(dev, urb, param->iterations, param->vary,
 					0, "test4");
 		simple_free_urb (urb);
 		break;
@@ -1676,7 +1675,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 5:
 		if (dev->out_pipe == 0 || param->sglen == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 5:  write %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
@@ -1686,7 +1685,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk sink (maybe accepts short writes)
-		retval = perform_sglist (udev, param->iterations, dev->out_pipe,
+		retval = perform_sglist(dev, param->iterations, dev->out_pipe,
 				&req, sg, param->sglen);
 		free_sglist (sg, param->sglen);
 		break;
@@ -1694,7 +1693,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 6:
 		if (dev->in_pipe == 0 || param->sglen == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 6:  read %d sglists %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
@@ -1704,14 +1703,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk source (maybe generates short writes)
-		retval = perform_sglist (udev, param->iterations, dev->in_pipe,
+		retval = perform_sglist(dev, param->iterations, dev->in_pipe,
 				&req, sg, param->sglen);
 		free_sglist (sg, param->sglen);
 		break;
 	case 7:
 		if (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
@@ -1721,14 +1720,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk sink (maybe accepts short writes)
-		retval = perform_sglist (udev, param->iterations, dev->out_pipe,
+		retval = perform_sglist(dev, param->iterations, dev->out_pipe,
 				&req, sg, param->sglen);
 		free_sglist (sg, param->sglen);
 		break;
 	case 8:
 		if (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
 				param->vary, param->iterations,
 				param->sglen, param->length);
@@ -1738,7 +1737,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			break;
 		}
 		// FIRMWARE:  bulk source (maybe generates short writes)
-		retval = perform_sglist (udev, param->iterations, dev->in_pipe,
+		retval = perform_sglist(dev, param->iterations, dev->in_pipe,
 				&req, sg, param->sglen);
 		free_sglist (sg, param->sglen);
 		break;
@@ -1746,13 +1745,14 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	/* non-queued sanity tests for control (chapter 9 subset) */
 	case 9:
 		retval = 0;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 9:  ch9 (subset) control tests, %d times\n",
 				param->iterations);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
 			retval = ch9_postconfig (dev);
 		if (retval)
-			dbg ("ch9 subset failed, iterations left %d", i);
+			dev_err(&intf->dev, "ch9 subset failed, "
+					"iterations left %d\n", i);
 		break;
 
 	/* queued control messaging */
@@ -1760,7 +1760,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		if (param->sglen == 0)
 			break;
 		retval = 0;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 				"TEST 10:  queue %d control calls, %d times\n",
 				param->sglen,
 				param->iterations);
@@ -1772,26 +1772,26 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		if (dev->in_pipe == 0 || !param->length)
 			break;
 		retval = 0;
-		dev_dbg (&intf->dev, "TEST 11:  unlink %d reads of %d\n",
+		dev_info(&intf->dev, "TEST 11:  unlink %d reads of %d\n",
 				param->iterations, param->length);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
 			retval = unlink_simple (dev, dev->in_pipe,
 						param->length);
 		if (retval)
-			dev_dbg (&intf->dev, "unlink reads failed %d, "
+			dev_err(&intf->dev, "unlink reads failed %d, "
 				"iterations left %d\n", retval, i);
 		break;
 	case 12:
 		if (dev->out_pipe == 0 || !param->length)
 			break;
 		retval = 0;
-		dev_dbg (&intf->dev, "TEST 12:  unlink %d writes of %d\n",
+		dev_info(&intf->dev, "TEST 12:  unlink %d writes of %d\n",
 				param->iterations, param->length);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
 			retval = unlink_simple (dev, dev->out_pipe,
 						param->length);
 		if (retval)
-			dev_dbg (&intf->dev, "unlink writes failed %d, "
+			dev_err(&intf->dev, "unlink writes failed %d, "
 				"iterations left %d\n", retval, i);
 		break;
 
@@ -1800,24 +1800,24 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		if (dev->out_pipe == 0 && dev->in_pipe == 0)
 			break;
 		retval = 0;
-		dev_dbg (&intf->dev, "TEST 13:  set/clear %d halts\n",
+		dev_info(&intf->dev, "TEST 13:  set/clear %d halts\n",
 				param->iterations);
 		for (i = param->iterations; retval == 0 && i--; /* NOP */)
 			retval = halt_simple (dev);
-		
+
 		if (retval)
-			DBG (dev, "halts failed, iterations left %d\n", i);
+			ERROR(dev, "halts failed, iterations left %d\n", i);
 		break;
 
 	/* control write tests */
 	case 14:
 		if (!dev->info->ctrl_out)
 			break;
-		dev_dbg (&intf->dev, "TEST 14:  %d ep0out, %d..%d vary %d\n",
+		dev_info(&intf->dev, "TEST 14:  %d ep0out, %d..%d vary %d\n",
 				param->iterations,
 				realworld ? 1 : 0, param->length,
 				param->vary);
-		retval = ctrl_out (dev, param->iterations, 
+		retval = ctrl_out(dev, param->iterations,
 				param->length, param->vary);
 		break;
 
@@ -1825,7 +1825,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 15:
 		if (dev->out_iso_pipe == 0 || param->sglen == 0)
 			break;
-		dev_dbg (&intf->dev, 
+		dev_info(&intf->dev,
 			"TEST 15:  write %d iso, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
@@ -1838,7 +1838,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 16:
 		if (dev->in_iso_pipe == 0 || param->sglen == 0)
 			break;
-		dev_dbg (&intf->dev,
+		dev_info(&intf->dev,
 			"TEST 16:  read %d iso, %d entries of %d bytes\n",
 				param->iterations,
 				param->sglen, param->length);
@@ -1898,7 +1898,8 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 			return -ENODEV;
 		if (product && le16_to_cpu(udev->descriptor.idProduct) != (u16)product)
 			return -ENODEV;
-		dbg ("matched module params, vend=0x%04x prod=0x%04x",
+		dev_info(&intf->dev, "matched module params, "
+					"vend=0x%04x prod=0x%04x\n",
 				le16_to_cpu(udev->descriptor.idVendor),
 				le16_to_cpu(udev->descriptor.idProduct));
 	}
@@ -1940,7 +1941,8 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 
 			status = get_endpoints (dev, intf);
 			if (status < 0) {
-				dbg ("couldn't get endpoints, %d\n", status);
+				WARN(dev, "couldn't get endpoints, %d\n",
+						status);
 				return status;
 			}
 			/* may find bulk or ISO pipes */
@@ -2082,21 +2084,9 @@ static struct usbtest_info generic_info = {
 };
 #endif
 
-// FIXME remove this 
-static struct usbtest_info hact_info = {
-	.name		= "FX2/hact",
-	//.ep_in		= 6,
-	.ep_out		= 2,
-	.alt		= -1,
-};
-
 
 static struct usb_device_id id_table [] = {
 
-	{ USB_DEVICE (0x0547, 0x1002),
-		.driver_info = (unsigned long) &hact_info,
-		},
-
 	/*-------------------------------------------------------------*/
 
 	/* EZ-USB devices which download firmware to replace (or in our
@@ -2185,7 +2175,7 @@ static int __init usbtest_init (void)
 {
 #ifdef GENERIC
 	if (vendor)
-		dbg ("params: vend=0x%04x prod=0x%04x", vendor, product);
+		pr_debug("params: vend=0x%04x prod=0x%04x\n", vendor, product);
 #endif
 	return usb_register (&usbtest_driver);
 }

commit cdc97792289179974af6dda781c855696358d307
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Feb 24 18:41:47 2008 +0800

    USB: remove unnecessary type casting of urb->context
    
    urb->context code cleanup
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 678fac86c467..a51983854ca0 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -201,7 +201,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 
 static void simple_callback (struct urb *urb)
 {
-	complete ((struct completion *) urb->context);
+	complete(urb->context);
 }
 
 static struct urb *simple_alloc_urb (
@@ -1046,7 +1046,7 @@ static void unlink1_callback (struct urb *urb)
 		status = usb_submit_urb (urb, GFP_ATOMIC);
 	if (status) {
 		urb->status = status;
-		complete ((struct completion *) urb->context);
+		complete(urb->context);
 	}
 }
 

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 2c4fd4d6df95..678fac86c467 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1136,7 +1136,7 @@ static int verify_not_halted (int ep, struct urb *urb)
 		dbg ("ep %02x bogus status: %04x != 0", ep, status);
 		return -EINVAL;
 	}
-	retval = simple_io (urb, 1, 0, 0, __FUNCTION__);
+	retval = simple_io (urb, 1, 0, 0, __func__);
 	if (retval != 0)
 		return -EINVAL;
 	return 0;
@@ -1158,7 +1158,7 @@ static int verify_halted (int ep, struct urb *urb)
 		dbg ("ep %02x bogus status: %04x != 1", ep, status);
 		return -EINVAL;
 	}
-	retval = simple_io (urb, 1, 0, -EPIPE, __FUNCTION__);
+	retval = simple_io (urb, 1, 0, -EPIPE, __func__);
 	if (retval != -EPIPE)
 		return -EINVAL;
 	retval = simple_io (urb, 1, 0, -EPIPE, "verify_still_halted");

commit 70a1c9e086c2e267fbc4533cb870f34999b531d6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 6 17:00:58 2008 -0500

    USB: remove dev->power.power_state
    
    power.power_state is scheduled for removal.  This patch (as1053)
    removes all uses of that field from drivers/usb.  Almost all of them
    were write-only, the most significant exceptions being sl811-hcd.c and
    u132-hcd.c.
    
    Part of this patch was written by Pavel Machek.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 17100471e461..2c4fd4d6df95 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1564,7 +1564,8 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (mutex_lock_interruptible(&dev->lock))
 		return -ERESTARTSYS;
 
-	if (intf->dev.power.power_state.event != PM_EVENT_ON) {
+	/* FIXME: What if a system sleep starts while a test is running? */
+	if (!intf->is_active) {
 		mutex_unlock(&dev->lock);
 		return -EHOSTUNREACH;
 	}

commit dfa5ec79d28300b0d1fdeafbeebf0a6b721edc38
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Mar 4 15:25:11 2008 -0800

    USB: use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    An extract of the semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @haskernel@
    @@
    
    #include <linux/kernel.h>
    
    @depends on haskernel@
    expression n,d;
    @@
    
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    
    @depends on haskernel@
    expression n,d;
    @@
    
    - DIV_ROUND_UP((n),d)
    + DIV_ROUND_UP(n,d)
    
    @depends on haskernel@
    expression n,d;
    @@
    
    - DIV_ROUND_UP(n,(d))
    + DIV_ROUND_UP(n,d)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b6b5b2affad1..17100471e461 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1404,7 +1404,7 @@ static struct urb *iso_alloc_urb (
 		return NULL;
 	maxp = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
 	maxp *= 1 + (0x3 & (le16_to_cpu(desc->wMaxPacketSize) >> 11));
-	packets = (bytes + maxp - 1) / maxp;
+	packets = DIV_ROUND_UP(bytes, maxp);
 
 	urb = usb_alloc_urb (packets, GFP_KERNEL);
 	if (!urb)

commit 4756febb10d96104e08661031ba835771075419c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 27 10:15:22 2008 -0400

    USB: fix bug in sg initialization in usbtest
    
    This patch (as1062) fixes a bug in the scatter-gather initialization
    code in the usbtest driver.  When the sg-helper conversion was
    performed, it wasn't done correctly.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index da922dfc0dcc..b6b5b2affad1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -378,6 +378,7 @@ alloc_sglist (int nents, int max, int vary)
 	sg = kmalloc (nents * sizeof *sg, GFP_KERNEL);
 	if (!sg)
 		return NULL;
+	sg_init_table(sg, nents);
 
 	for (i = 0; i < nents; i++) {
 		char		*buf;
@@ -390,7 +391,7 @@ alloc_sglist (int nents, int max, int vary)
 		}
 
 		/* kmalloc pages are always physically contiguous! */
-		sg_init_one(&sg[i], buf, size);
+		sg_set_buf(&sg[i], buf, size);
 
 		switch (pattern) {
 		case 0:

commit dc0d5c1e5c7532e800fff6e313cd4af44af99976
Author: Joe Perches <joe@perches.com>
Date:   Mon Dec 17 11:40:18 2007 -0800

    USB: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index f1b886c204c0..da922dfc0dcc 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1312,7 +1312,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 		len += vary;
 
 		/* [real world] the "zero bytes IN" case isn't really used.
-		 * hardware can easily trip up in this wierd case, since its
+		 * hardware can easily trip up in this weird case, since its
 		 * status stage is IN, not OUT like other ep0in transfers.
 		 */
 		if (len > length)

commit 26e109b0a90b5ef7b025e44a969836ab9a598ffc
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Dec 13 16:15:34 2007 -0800

    USB: testing driver: don't free a locked mutex
    
    Dopey thing to do and lockdep will (or should) warn.
    
    Spotted by Daniel Walker.
    
    Cc: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Cc: Daniel Walker <dwalker@mvista.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index e3851359d653..f1b886c204c0 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1992,8 +1992,6 @@ static void usbtest_disconnect (struct usb_interface *intf)
 {
 	struct usbtest_dev	*dev = usb_get_intfdata (intf);
 
-	mutex_lock(&dev->lock);
-
 	usb_set_intfdata (intf, NULL);
 	dev_dbg (&intf->dev, "disconnect\n");
 	kfree (dev);

commit 1cfab028afe5827433195c57b6f36d61a79beb50
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Thu Dec 13 16:15:33 2007 -0800

    USB: testing driver: convert dev->sem to mutex
    
    USB testing driver: convert semaphore dev->sem to the mutex API
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 81755d06a419..e3851359d653 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -6,6 +6,7 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/scatterlist.h>
+#include <linux/mutex.h>
 
 #include <linux/usb.h>
 
@@ -64,7 +65,7 @@ struct usbtest_dev {
 	int			in_iso_pipe;
 	int			out_iso_pipe;
 	struct usb_endpoint_descriptor	*iso_in, *iso_out;
-	struct semaphore	sem;
+	struct mutex		lock;
 
 #define TBUF_SIZE	256
 	u8			*buf;
@@ -1559,11 +1560,11 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			|| param->sglen < 0 || param->vary < 0)
 		return -EINVAL;
 
-	if (down_interruptible (&dev->sem))
+	if (mutex_lock_interruptible(&dev->lock))
 		return -ERESTARTSYS;
 
 	if (intf->dev.power.power_state.event != PM_EVENT_ON) {
-		up (&dev->sem);
+		mutex_unlock(&dev->lock);
 		return -EHOSTUNREACH;
 	}
 
@@ -1575,7 +1576,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	    	int	res;
 
 		if (intf->altsetting->desc.bInterfaceNumber) {
-			up (&dev->sem);
+			mutex_unlock(&dev->lock);
 			return -ENODEV;
 		}
 		res = set_altsetting (dev, dev->info->alt);
@@ -1583,7 +1584,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 			dev_err (&intf->dev,
 					"set altsetting to %d failed, %d\n",
 					dev->info->alt, res);
-			up (&dev->sem);
+			mutex_unlock(&dev->lock);
 			return res;
 		}
 	}
@@ -1856,7 +1857,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		param->duration.tv_usec += 1000 * 1000;
 		param->duration.tv_sec -= 1;
 	}
-	up (&dev->sem);
+	mutex_unlock(&dev->lock);
 	return retval;
 }
 
@@ -1906,7 +1907,7 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 		return -ENOMEM;
 	info = (struct usbtest_info *) id->driver_info;
 	dev->info = info;
-	init_MUTEX (&dev->sem);
+	mutex_init(&dev->lock);
 
 	dev->intf = intf;
 
@@ -1991,7 +1992,7 @@ static void usbtest_disconnect (struct usb_interface *intf)
 {
 	struct usbtest_dev	*dev = usb_get_intfdata (intf);
 
-	down (&dev->sem);
+	mutex_lock(&dev->lock);
 
 	usb_set_intfdata (intf, NULL);
 	dev_dbg (&intf->dev, "disconnect\n");

commit 6ce4560a39f72e45a273c652ee116f8b0fc6386f
Author: Jan Andersson <jan@gaisler.com>
Date:   Tue Jan 8 16:39:49 2008 +0100

    usb: fix usbtest halt check on big endian systems
    
    usbtest did not swap the received status information when checking for
    a non-zero value and failed to discover halted endpoints on big endian
    systems.
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Jan Andersson <jan@gaisler.com>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index ea3162146481..81755d06a419 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1151,6 +1151,7 @@ static int verify_halted (int ep, struct urb *urb)
 		dbg ("ep %02x couldn't get halt status, %d", ep, retval);
 		return retval;
 	}
+	le16_to_cpus(&status);
 	if (status != 1) {
 		dbg ("ep %02x bogus status: %04x != 1", ep, status);
 		return -EINVAL;

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index e901d31e051b..ea3162146481 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -360,9 +360,9 @@ static void free_sglist (struct scatterlist *sg, int nents)
 	if (!sg)
 		return;
 	for (i = 0; i < nents; i++) {
-		if (!sg [i].page)
+		if (!sg_page(&sg[i]))
 			continue;
-		kfree (page_address (sg [i].page) + sg [i].offset);
+		kfree (sg_virt(&sg[i]));
 	}
 	kfree (sg);
 }

commit 59d99785a9f8294f9e38ac677df8526e44462f66
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jul 18 10:58:02 2007 -0700

    USB: misc: usbtest: clean up urb->status usage
    
    This done in anticipation of removal of urb->status, which will make
    that patch easier to review and apply in the future.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index fb321864a92d..e901d31e051b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -768,8 +768,8 @@ static void ctrl_complete (struct urb *urb)
 
 		/* some faults are allowed, not required */
 		if (subcase->expected > 0 && (
-			  ((urb->status == -subcase->expected	/* happened */
-			   || urb->status == 0))))		/* didn't */
+			  ((status == -subcase->expected	/* happened */
+			   || status == 0))))			/* didn't */
 			status = 0;
 		/* sometimes more than one fault is allowed */
 		else if (subcase->number == 12 && status == -EPIPE)

commit e94b1766097d53e6f3ccfb36c8baa562ffeda3fc
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:17 2006 -0800

    [PATCH] slab: remove SLAB_KERNEL
    
    SLAB_KERNEL is an alias of GFP_KERNEL.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index ea04dccdc651..fb321864a92d 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -213,7 +213,7 @@ static struct urb *simple_alloc_urb (
 
 	if (bytes < 0)
 		return NULL;
-	urb = usb_alloc_urb (0, SLAB_KERNEL);
+	urb = usb_alloc_urb (0, GFP_KERNEL);
 	if (!urb)
 		return urb;
 	usb_fill_bulk_urb (urb, udev, pipe, NULL, bytes, simple_callback, NULL);
@@ -223,7 +223,7 @@ static struct urb *simple_alloc_urb (
 	urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
 	if (usb_pipein (pipe))
 		urb->transfer_flags |= URB_SHORT_NOT_OK;
-	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, SLAB_KERNEL,
+	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);
@@ -315,7 +315,7 @@ static int simple_io (
 		init_completion (&completion);
 		if (usb_pipeout (urb->pipe))
 			simple_fill_buf (urb);
-		if ((retval = usb_submit_urb (urb, SLAB_KERNEL)) != 0)
+		if ((retval = usb_submit_urb (urb, GFP_KERNEL)) != 0)
 			break;
 
 		/* NOTE:  no timeouts; can't be broken out of by interrupt */
@@ -374,7 +374,7 @@ alloc_sglist (int nents, int max, int vary)
 	unsigned		i;
 	unsigned		size = max;
 
-	sg = kmalloc (nents * sizeof *sg, SLAB_KERNEL);
+	sg = kmalloc (nents * sizeof *sg, GFP_KERNEL);
 	if (!sg)
 		return NULL;
 
@@ -382,7 +382,7 @@ alloc_sglist (int nents, int max, int vary)
 		char		*buf;
 		unsigned	j;
 
-		buf = kzalloc (size, SLAB_KERNEL);
+		buf = kzalloc (size, GFP_KERNEL);
 		if (!buf) {
 			free_sglist (sg, i);
 			return NULL;
@@ -428,7 +428,7 @@ static int perform_sglist (
 				(udev->speed == USB_SPEED_HIGH)
 					? (INTERRUPT_RATE << 3)
 					: INTERRUPT_RATE,
-				sg, nents, 0, SLAB_KERNEL);
+				sg, nents, 0, GFP_KERNEL);
 		
 		if (retval)
 			break;
@@ -855,7 +855,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 	 * as with bulk/intr sglists, sglen is the queue depth; it also
 	 * controls which subtests run (more tests than sglen) or rerun.
 	 */
-	urb = kcalloc(param->sglen, sizeof(struct urb *), SLAB_KERNEL);
+	urb = kcalloc(param->sglen, sizeof(struct urb *), GFP_KERNEL);
 	if (!urb)
 		return -ENOMEM;
 	for (i = 0; i < param->sglen; i++) {
@@ -981,7 +981,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!u)
 			goto cleanup;
 
-		reqp = usb_buffer_alloc (udev, sizeof *reqp, SLAB_KERNEL,
+		reqp = usb_buffer_alloc (udev, sizeof *reqp, GFP_KERNEL,
 				&u->setup_dma);
 		if (!reqp)
 			goto cleanup;
@@ -1067,7 +1067,7 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	 * FIXME want additional tests for when endpoint is STALLing
 	 * due to errors, or is just NAKing requests.
 	 */
-	if ((retval = usb_submit_urb (urb, SLAB_KERNEL)) != 0) {
+	if ((retval = usb_submit_urb (urb, GFP_KERNEL)) != 0) {
 		dev_dbg (&dev->intf->dev, "submit fail %d\n", retval);
 		return retval;
 	}
@@ -1251,7 +1251,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 	if (length < 1 || length > 0xffff || vary >= length)
 		return -EINVAL;
 
-	buf = kmalloc(length, SLAB_KERNEL);
+	buf = kmalloc(length, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -1403,7 +1403,7 @@ static struct urb *iso_alloc_urb (
 	maxp *= 1 + (0x3 & (le16_to_cpu(desc->wMaxPacketSize) >> 11));
 	packets = (bytes + maxp - 1) / maxp;
 
-	urb = usb_alloc_urb (packets, SLAB_KERNEL);
+	urb = usb_alloc_urb (packets, GFP_KERNEL);
 	if (!urb)
 		return urb;
 	urb->dev = udev;
@@ -1411,7 +1411,7 @@ static struct urb *iso_alloc_urb (
 
 	urb->number_of_packets = packets;
 	urb->transfer_buffer_length = bytes;
-	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, SLAB_KERNEL,
+	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, GFP_KERNEL,
 			&urb->transfer_dma);
 	if (!urb->transfer_buffer) {
 		usb_free_urb (urb);
@@ -1900,7 +1900,7 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	}
 #endif
 
-	dev = kzalloc(sizeof(*dev), SLAB_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
 	info = (struct usbtest_info *) id->driver_info;
@@ -1910,7 +1910,7 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	dev->intf = intf;
 
 	/* cacheline-aligned scratch for i/o */
-	if ((dev->buf = kmalloc (TBUF_SIZE, SLAB_KERNEL)) == NULL) {
+	if ((dev->buf = kmalloc (TBUF_SIZE, GFP_KERNEL)) == NULL) {
 		kfree (dev);
 		return -ENOMEM;
 	}

commit 54e6ecb23951b195d02433a741c7f7cb0b796c78
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:16 2006 -0800

    [PATCH] slab: remove SLAB_ATOMIC
    
    SLAB_ATOMIC is an alias of GFP_ATOMIC
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 194065dbb51f..ea04dccdc651 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -819,7 +819,7 @@ static void ctrl_complete (struct urb *urb)
 
 	/* resubmit if we need to, else mark this as done */
 	if ((status == 0) && (ctx->pending < ctx->count)) {
-		if ((status = usb_submit_urb (urb, SLAB_ATOMIC)) != 0) {
+		if ((status = usb_submit_urb (urb, GFP_ATOMIC)) != 0) {
 			dbg ("can't resubmit ctrl %02x.%02x, err %d",
 				reqp->bRequestType, reqp->bRequest, status);
 			urb->dev = NULL;
@@ -999,7 +999,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 	context.urb = urb;
 	spin_lock_irq (&context.lock);
 	for (i = 0; i < param->sglen; i++) {
-		context.status = usb_submit_urb (urb [i], SLAB_ATOMIC);
+		context.status = usb_submit_urb (urb [i], GFP_ATOMIC);
 		if (context.status != 0) {
 			dbg ("can't submit urb[%d], status %d",
 					i, context.status);
@@ -1041,7 +1041,7 @@ static void unlink1_callback (struct urb *urb)
 
 	// we "know" -EPIPE (stall) never happens
 	if (!status)
-		status = usb_submit_urb (urb, SLAB_ATOMIC);
+		status = usb_submit_urb (urb, GFP_ATOMIC);
 	if (status) {
 		urb->status = status;
 		complete ((struct completion *) urb->context);
@@ -1481,7 +1481,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 	spin_lock_irq (&context.lock);
 	for (i = 0; i < param->sglen; i++) {
 		++context.pending;
-		status = usb_submit_urb (urbs [i], SLAB_ATOMIC);
+		status = usb_submit_urb (urbs [i], GFP_ATOMIC);
 		if (status < 0) {
 			ERROR (dev, "submit iso[%d], error %d\n", i, status);
 			if (i == 0) {

commit 4d823dd21d81c29a83a4672ac92e449fc5fa5cca
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Thu Oct 26 13:03:02 2006 -0300

    USB: usbtest: Use usb_endpoint_* functions
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 7c2cbdf81d20..194065dbb51f 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -138,7 +138,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 			default:
 				continue;
 			}
-			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+			if (usb_endpoint_dir_in(&e->desc)) {
 				if (!in)
 					in = e;
 			} else {
@@ -147,7 +147,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
 			}
 			continue;
 try_iso:
-			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+			if (usb_endpoint_dir_in(&e->desc)) {
 				if (!iso_in)
 					iso_in = e;
 			} else {

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 983e104dd452..7c2cbdf81d20 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -198,7 +198,7 @@ get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
  * them with non-zero test data (or test for it) when appropriate.
  */
 
-static void simple_callback (struct urb *urb, struct pt_regs *regs)
+static void simple_callback (struct urb *urb)
 {
 	complete ((struct completion *) urb->context);
 }
@@ -730,7 +730,7 @@ struct subcase {
 	int			expected;
 };
 
-static void ctrl_complete (struct urb *urb, struct pt_regs *regs)
+static void ctrl_complete (struct urb *urb)
 {
 	struct ctrl_ctx		*ctx = urb->context;
 	struct usb_ctrlrequest	*reqp;
@@ -1035,7 +1035,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 /*-------------------------------------------------------------------------*/
 
-static void unlink1_callback (struct urb *urb, struct pt_regs *regs)
+static void unlink1_callback (struct urb *urb)
 {
 	int	status = urb->status;
 
@@ -1343,7 +1343,7 @@ struct iso_context {
 	struct usbtest_dev	*dev;
 };
 
-static void iso_callback (struct urb *urb, struct pt_regs *regs)
+static void iso_callback (struct urb *urb)
 {
 	struct iso_context	*ctx = urb->context;
 

commit f54fa84dda211f68f65002efa44142207c886c79
Author: Orjan Friberg <orjan.friberg@axis.com>
Date:   Tue Aug 8 23:31:40 2006 -0700

    USB: usbtest.c: unsigned retval makes ctrl_out return 0 in case of error
    
    In my quest to try and figure out why test 14 (control write) doesn't
    work with my EZ-USB board, I noticed that sometimes testusb reported
    no error even though the kernel log complained "byte 0 is 0 not 2" etc.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 786e1dbe88ec..983e104dd452 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1242,11 +1242,12 @@ static int halt_simple (struct usbtest_dev *dev)
 static int ctrl_out (struct usbtest_dev *dev,
 		unsigned count, unsigned length, unsigned vary)
 {
-	unsigned		i, j, len, retval;
+	unsigned		i, j, len;
+	int			retval;
 	u8			*buf;
 	char			*what = "?";
 	struct usb_device	*udev;
-	
+
 	if (length < 1 || length > 0xffff || vary >= length)
 		return -EINVAL;
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 81ba14c73dc7..786e1dbe88ec 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1,4 +1,3 @@
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 9da2150f59e885d88b9eabe0a677f0fa4962f7b4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 22 16:47:13 2006 -0400

    [PATCH] usbtest: report errors in iso tests
    
    This patch (as693b) makes the usbtest driver report errors in the
    isochronous bulk transfer tests instead of always returning 0.  As an
    arbitrary cutoff, an error is returned if more than 10% of the packet
    transfers fail.  It also stops a test immediately upon receiving an URB
    submission error.
    
    For a test harness, it's especially important to report when errors occur!
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b42ae6bfb12b..81ba14c73dc7 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1337,7 +1337,9 @@ struct iso_context {
 	unsigned		pending;
 	spinlock_t		lock;
 	struct completion	done;
+	int			submit_error;
 	unsigned long		errors;
+	unsigned long		packet_count;
 	struct usbtest_dev	*dev;
 };
 
@@ -1348,10 +1350,14 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	spin_lock(&ctx->lock);
 	ctx->count--;
 
+	ctx->packet_count += urb->number_of_packets;
 	if (urb->error_count > 0)
 		ctx->errors += urb->error_count;
+	else if (urb->status != 0)
+		ctx->errors += urb->number_of_packets;
 
-	if (urb->status == 0 && ctx->count > (ctx->pending - 1)) {
+	if (urb->status == 0 && ctx->count > (ctx->pending - 1)
+			&& !ctx->submit_error) {
 		int status = usb_submit_urb (urb, GFP_ATOMIC);
 		switch (status) {
 		case 0:
@@ -1362,6 +1368,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 					status);
 			/* FALLTHROUGH */
 		case -ENODEV:			/* disconnected */
+		case -ESHUTDOWN:		/* endpoint disabled */
+			ctx->submit_error = 1;
 			break;
 		}
 	}
@@ -1371,8 +1379,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	if (ctx->pending == 0) {
 		if (ctx->errors)
 			dev_dbg (&ctx->dev->intf->dev,
-				"iso test, %lu errors\n",
-				ctx->errors);
+				"iso test, %lu errors out of %lu\n",
+				ctx->errors, ctx->packet_count);
 		complete (&ctx->done);
 	}
 done:
@@ -1433,15 +1441,14 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 	struct usb_device	*udev;
 	unsigned		i;
 	unsigned long		packets = 0;
-	int			status;
+	int			status = 0;
 	struct urb		*urbs[10];	/* FIXME no limit */
 
 	if (param->sglen > 10)
 		return -EDOM;
 
+	memset(&context, 0, sizeof context);
 	context.count = param->iterations * param->sglen;
-	context.pending = param->sglen;
-	context.errors = 0;
 	context.dev = dev;
 	init_completion (&context.done);
 	spin_lock_init (&context.lock);
@@ -1473,6 +1480,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 	spin_lock_irq (&context.lock);
 	for (i = 0; i < param->sglen; i++) {
+		++context.pending;
 		status = usb_submit_urb (urbs [i], SLAB_ATOMIC);
 		if (status < 0) {
 			ERROR (dev, "submit iso[%d], error %d\n", i, status);
@@ -1483,12 +1491,26 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 			simple_free_urb (urbs [i]);
 			context.pending--;
+			context.submit_error = 1;
+			break;
 		}
 	}
 	spin_unlock_irq (&context.lock);
 
 	wait_for_completion (&context.done);
-	return 0;
+
+	/*
+	 * Isochronous transfers are expected to fail sometimes.  As an
+	 * arbitrary limit, we will report an error if any submissions
+	 * fail or if the transfer failure rate is > 10%.
+	 */
+	if (status != 0)
+		;
+	else if (context.submit_error)
+		status = -EACCES;
+	else if (context.errors > context.packet_count / 10)
+		status = -EIO;
+	return status;
 
 fail:
 	for (i = 0; i < param->sglen; i++) {

commit caa2a1226741e023a103e091a7f6dce7c42e82ee
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Mon May 15 19:23:53 2006 +0200

    [PATCH] Fix a deadlock in usbtest
    
    ctrl_complete functions acquires ctx->lock and tries to unlink
    all queued urbs in case of errors through usb_unlink_urb func.
    In its turn usb_unlink_urb calls, through the hcd driver,
    usb_hcd_giveback_urb which calls ctrl_complete again. At this
    time, ctx->lock is already taken by the same function.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index ccc5e8238bd8..b42ae6bfb12b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -802,7 +802,9 @@ static void ctrl_complete (struct urb *urb, struct pt_regs *regs)
 
 				if (u == urb || !u->dev)
 					continue;
+				spin_unlock(&ctx->lock);
 				status = usb_unlink_urb (u);
+				spin_lock(&ctx->lock);
 				switch (status) {
 				case -EINPROGRESS:
 				case -EBUSY:

commit 8b5249019352eecd49fb00004d583904e891e7b1
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Apr 2 10:20:15 2006 -0800

    [PATCH] USB: usbtest: scatterlist OUT data pattern testing
    
    Previously, scatterlist tests didn't write patterned data.  Given how many
    corner cases are addresed by them, this was a significant gap in Linux-USB
    test coverage.  Moreover, when peripherals checked for correct data patterns,
    false error reports would drown out the true ones.
    
    This adds the pattern on the way OUT from the host, so scatterlist tests can
    now be used to uncover bugs like host TX or peripheral RX paths failing for
    back-to-back short packets.  It's easy enough to get an error there with at
    least one of the {DMA,PIO}{RX,TX} code paths, or run into hardware races
    that need to be defended against.
    
    Note this patch doesn't add checking for correct data patterns on the way
    IN from peripherals, just a FIXME for later.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 9d59b901841c..ccc5e8238bd8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -381,6 +381,7 @@ alloc_sglist (int nents, int max, int vary)
 
 	for (i = 0; i < nents; i++) {
 		char		*buf;
+		unsigned	j;
 
 		buf = kzalloc (size, SLAB_KERNEL);
 		if (!buf) {
@@ -391,6 +392,16 @@ alloc_sglist (int nents, int max, int vary)
 		/* kmalloc pages are always physically contiguous! */
 		sg_init_one(&sg[i], buf, size);
 
+		switch (pattern) {
+		case 0:
+			/* already zeroed */
+			break;
+		case 1:
+			for (j = 0; j < size; j++)
+				*buf++ = (u8) (j % 63);
+			break;
+		}
+
 		if (vary) {
 			size += vary;
 			size %= max;
@@ -425,6 +436,8 @@ static int perform_sglist (
 		usb_sg_wait (req);
 		retval = req->status;
 
+		/* FIXME check resulting data pattern */
+
 		/* FIXME if endpoint halted, clear halt (and log) */
 	}
 

commit 80b6ca48321974a6566a1c9048ba34f60420bca6
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Mon Feb 27 21:29:43 2006 +0100

    [PATCH] USB: kzalloc() conversion for rest of drivers/usb
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 84fa1728f052..9d59b901841c 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -382,12 +382,11 @@ alloc_sglist (int nents, int max, int vary)
 	for (i = 0; i < nents; i++) {
 		char		*buf;
 
-		buf = kmalloc (size, SLAB_KERNEL);
+		buf = kzalloc (size, SLAB_KERNEL);
 		if (!buf) {
 			free_sglist (sg, i);
 			return NULL;
 		}
-		memset (buf, 0, size);
 
 		/* kmalloc pages are always physically contiguous! */
 		sg_init_one(&sg[i], buf, size);
@@ -842,10 +841,9 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 	 * as with bulk/intr sglists, sglen is the queue depth; it also
 	 * controls which subtests run (more tests than sglen) or rerun.
 	 */
-	urb = kmalloc (param->sglen * sizeof (struct urb *), SLAB_KERNEL);
+	urb = kcalloc(param->sglen, sizeof(struct urb *), SLAB_KERNEL);
 	if (!urb)
 		return -ENOMEM;
-	memset (urb, 0, param->sglen * sizeof (struct urb *));
 	for (i = 0; i < param->sglen; i++) {
 		int			pipe = usb_rcvctrlpipe (udev, 0);
 		unsigned		len;
@@ -1865,10 +1863,9 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	}
 #endif
 
-	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
+	dev = kzalloc(sizeof(*dev), SLAB_KERNEL);
 	if (!dev)
 		return -ENOMEM;
-	memset (dev, 0, sizeof *dev);
 	info = (struct usbtest_info *) id->driver_info;
 	dev->info = info;
 	init_MUTEX (&dev->sem);

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 605a2afe34ed..84fa1728f052 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2134,7 +2134,6 @@ static struct usb_device_id id_table [] = {
 MODULE_DEVICE_TABLE (usb, id_table);
 
 static struct usb_driver usbtest_driver = {
-	.owner =	THIS_MODULE,
 	.name =		"usbtest",
 	.id_table =	id_table,
 	.probe =	usbtest_probe,

commit 654f31189e550cd5924b786487a5d93d9feaada9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 17 09:48:09 2005 -0800

    [PATCH] USB: move CONFIG_USB_DEBUG checks into the Makefile
    
    This lets us remove a lot of code in the drivers that were all checking
    the same thing.  It also found some bugs in a few of the drivers, which
    has been fixed up.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 2997f558159b..605a2afe34ed 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1,7 +1,4 @@
 #include <linux/config.h>
-#if !defined (DEBUG) && defined (CONFIG_USB_DEBUG)
-#   define DEBUG
-#endif
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 378f058cc49bcda7fa63d3cd86d2f9a0a5188b1c
Author: David Hardeman <david@2gen.com>
Date:   Sat Sep 17 17:55:31 2005 +1000

    [PATCH] Use sg_set_buf/sg_init_one where applicable
    
    This patch uses sg_set_buf/sg_init_one in some places where it was
    duplicated.
    
    Signed-off-by: David Hardeman <david@2gen.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 90a96257d6ce..2997f558159b 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -9,7 +9,7 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <asm/scatterlist.h>
+#include <linux/scatterlist.h>
 
 #include <linux/usb.h>
 
@@ -381,7 +381,6 @@ alloc_sglist (int nents, int max, int vary)
 	sg = kmalloc (nents * sizeof *sg, SLAB_KERNEL);
 	if (!sg)
 		return NULL;
-	memset (sg, 0, nents * sizeof *sg);
 
 	for (i = 0; i < nents; i++) {
 		char		*buf;
@@ -394,9 +393,7 @@ alloc_sglist (int nents, int max, int vary)
 		memset (buf, 0, size);
 
 		/* kmalloc pages are always physically contiguous! */
-		sg [i].page = virt_to_page (buf);
-		sg [i].offset = offset_in_page (buf);
-		sg [i].length = size;
+		sg_init_one(&sg[i], buf, size);
 
 		if (vary) {
 			size += vary;

commit 3e8a556a02d5aa16375d4d74aad0f67cd844c047
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Oct 18 10:08:31 2005 -0400

    [PATCH] Missing transfer_flags setting in usbtest
    
    This patch (as582) adds a missing transfer_flags setting to the usbtest
    driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index d055196533af..90a96257d6ce 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -983,6 +983,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		reqp->number = i % NUM_SUBCASES;
 		reqp->expected = expected;
 		u->setup_packet = (char *) &reqp->setup;
+		u->transfer_flags |= URB_NO_SETUP_DMA_MAP;
 
 		u->context = &context;
 		u->complete = ctrl_complete;

commit db69087437dd5135a9362da1c37fe072070e8f60
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:56:33 2005 -0700

    [PATCH] usb_interface power state
    
    This updates the handling of power state for USB interfaces.
    
      - Formalizes an existing invariant:  interface "power state" is a boolean:
        ON when I/O is allowed, and FREEZE otherwise.  It does so by defining
        some inlined helpers, then using them.
    
      - Adds a useful invariant:  the only interfaces marked active are those
        bound to non-suspended drivers.  Later patches build on this invariant.
    
      - Simplifies the interface driver API (and removes some error paths) by
        removing the requirement that they record power state changes during
        suspend and resume callbacks.  Now usbcore does that.
    
    A few drivers were simplified to address that last change.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c       |   33 +++++++++------------
     drivers/usb/core/message.c   |    1
     drivers/usb/core/usb.c       |   65 +++++++++++++++++++++++++++++++++----------
     drivers/usb/core/usb.h       |   18 +++++++++++
     drivers/usb/input/hid-core.c |    2 -
     drivers/usb/misc/usbtest.c   |   10 ------
     drivers/usb/net/pegasus.c    |    2 -
     drivers/usb/net/usbnet.c     |    2 -
     8 files changed, 85 insertions(+), 48 deletions(-)

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 54799eb0bc60..d055196533af 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1948,21 +1948,11 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 
 static int usbtest_suspend (struct usb_interface *intf, pm_message_t message)
 {
-	struct usbtest_dev	*dev = usb_get_intfdata (intf);
-
-	down (&dev->sem);
-	intf->dev.power.power_state = PMSG_SUSPEND;
-	up (&dev->sem);
 	return 0;
 }
 
 static int usbtest_resume (struct usb_interface *intf)
 {
-	struct usbtest_dev	*dev = usb_get_intfdata (intf);
-
-	down (&dev->sem);
-	intf->dev.power.power_state = PMSG_ON;
-	up (&dev->sem);
 	return 0;
 }
 

commit b375a0495fd622037560c73c05f23ae6f127bb0c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 29 16:11:07 2005 -0400

    [PATCH] USB: URB_ASYNC_UNLINK flag removed from the kernel
    
    29 July 2005, Cambridge, MA:
    
    This afternoon Alan Stern submitted a patch to remove the URB_ASYNC_UNLINK
    flag from the Linux kernel.  Mr. Stern explained, "This flag is a relic
    from an earlier, less-well-designed system.  For over a year it hasn't
    been used for anything other than printing warning messages."
    
    An anonymous spokesman for the Linux kernel development community
    commented, "This is exactly the sort of thing we see happening all the
    time.  As the kernel evolves, support for old techniques and old code can
    be jettisoned and replaced by newer, better approaches.  Proprietary
    operating systems do not have the freedom or flexibility to change so
    quickly."
    
    Mr. Stern, a staff member at Harvard University's Rowland Institute who
    works on Linux only as a hobby, noted that the patch (labelled as548) did
    not update two files, keyspan.c and option.c, in the USB drivers' "serial"
    subdirectory.  "Those files need more extensive changes," he remarked.
    "They examine the status field of several URBs at times when they're not
    supposed to.  That will need to be fixed before the URB_ASYNC_UNLINK flag
    is removed."
    
    Greg Kroah-Hartman, the kernel maintainer responsible for overseeing all
    of Linux's USB drivers, did not respond to our inquiries or return our
    calls.  His only comment was "Applied, thanks."
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index fd7fb98e4b20..54799eb0bc60 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -986,7 +986,6 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 		u->context = &context;
 		u->complete = ctrl_complete;
-		u->transfer_flags |= URB_ASYNC_UNLINK;
 	}
 
 	/* queue the urbs */
@@ -1052,7 +1051,6 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
 	if (!urb)
 		return -ENOMEM;
-	urb->transfer_flags |= URB_ASYNC_UNLINK;
 	urb->context = &completion;
 	urb->complete = unlink1_callback;
 

commit ca078bae813dd46c0f9b102fdfb4a3384641ff48
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:56:57 2005 -0700

    [PATCH] swsusp: switch pm_message_t to struct
    
    This adds type-checking to pm_message_t, so that people can't confuse it
    with int or u32.  It also allows us to fix "disk yoyo" during suspend (disk
    spinning down/up/down).
    
    [We've tried that before; since that cpufreq problems were fixed and I've
    tried make allyes config and fixed resulting damage.]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index cda7249a90b2..fd7fb98e4b20 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1533,7 +1533,7 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (down_interruptible (&dev->sem))
 		return -ERESTARTSYS;
 
-	if (intf->dev.power.power_state != PMSG_ON) {
+	if (intf->dev.power.power_state.event != PM_EVENT_ON) {
 		up (&dev->sem);
 		return -EHOSTUNREACH;
 	}

commit ff7c79e4f37821235b51fb8e19088c08938cc8fc
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Apr 22 13:17:00 2005 -0700

    [PATCH] USB: usbtest updates
    
    Updates to "usbtest" driver:
    
      * Improve some diagnostics.  One path that never generated diagnostics
        before should now generate two ... unless you hit a GCC bug that
        all my compilers seem to have, go figure.
    
      * Add suspend/resume support, so this behaves when the Linux host
        being used for testing suspends.
    
      * Don't test the "zero byte ep0 read" case unless real-world relevance
        for the testing is is irrelevant.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3104f28f6aa8..cda7249a90b2 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -461,7 +461,7 @@ static int perform_sglist (
 
 static unsigned realworld = 1;
 module_param (realworld, uint, 0);
-MODULE_PARM_DESC (realworld, "clear to demand stricter ch9 compliance");
+MODULE_PARM_DESC (realworld, "clear to demand stricter spec compliance");
 
 static int get_altsetting (struct usbtest_dev *dev)
 {
@@ -604,9 +604,8 @@ static int ch9_postconfig (struct usbtest_dev *dev)
 				USB_DIR_IN | USB_RECIP_DEVICE,
 				0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);
 		if (retval != 1 || dev->buf [0] != expected) {
-			dev_dbg (&iface->dev,
-				"get config --> %d (%d)\n", retval,
-				expected);
+			dev_dbg (&iface->dev, "get config --> %d %d (1 %d)\n",
+				retval, dev->buf[0], expected);
 			return (retval < 0) ? retval : -EDOM;
 		}
 	}
@@ -1243,7 +1242,7 @@ static int ctrl_out (struct usbtest_dev *dev,
 	char			*what = "?";
 	struct usb_device	*udev;
 	
-	if (length > 0xffff || vary >= length)
+	if (length < 1 || length > 0xffff || vary >= length)
 		return -EINVAL;
 
 	buf = kmalloc(length, SLAB_KERNEL);
@@ -1266,6 +1265,11 @@ static int ctrl_out (struct usbtest_dev *dev,
 				0, 0, buf, len, USB_CTRL_SET_TIMEOUT);
 		if (retval != len) {
 			what = "write";
+			if (retval >= 0) {
+				INFO(dev, "ctrl_out, wlen %d (expected %d)\n",
+						retval, len);
+				retval = -EBADMSG;
+			}
 			break;
 		}
 
@@ -1275,6 +1279,11 @@ static int ctrl_out (struct usbtest_dev *dev,
 				0, 0, buf, len, USB_CTRL_GET_TIMEOUT);
 		if (retval != len) {
 			what = "read";
+			if (retval >= 0) {
+				INFO(dev, "ctrl_out, rlen %d (expected %d)\n",
+						retval, len);
+				retval = -EBADMSG;
+			}
 			break;
 		}
 
@@ -1293,8 +1302,13 @@ static int ctrl_out (struct usbtest_dev *dev,
 		}
 
 		len += vary;
+
+		/* [real world] the "zero bytes IN" case isn't really used.
+		 * hardware can easily trip up in this wierd case, since its
+		 * status stage is IN, not OUT like other ep0in transfers.
+		 */
 		if (len > length)
-			len = 0;
+			len = realworld ? 1 : 0;
 	}
 
 	if (retval < 0)
@@ -1519,6 +1533,11 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (down_interruptible (&dev->sem))
 		return -ERESTARTSYS;
 
+	if (intf->dev.power.power_state != PMSG_ON) {
+		up (&dev->sem);
+		return -EHOSTUNREACH;
+	}
+
 	/* some devices, like ez-usb default devices, need a non-default
 	 * altsetting to have any active endpoints.  some tests change
 	 * altsettings; force a default so most tests don't need to check.
@@ -1762,8 +1781,10 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	case 14:
 		if (!dev->info->ctrl_out)
 			break;
-		dev_dbg (&intf->dev, "TEST 14:  %d ep0out, 0..%d vary %d\n",
-				param->iterations, param->length, param->vary);
+		dev_dbg (&intf->dev, "TEST 14:  %d ep0out, %d..%d vary %d\n",
+				param->iterations,
+				realworld ? 1 : 0, param->length,
+				param->vary);
 		retval = ctrl_out (dev, param->iterations, 
 				param->length, param->vary);
 		break;
@@ -1927,6 +1948,27 @@ usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
 	return 0;
 }
 
+static int usbtest_suspend (struct usb_interface *intf, pm_message_t message)
+{
+	struct usbtest_dev	*dev = usb_get_intfdata (intf);
+
+	down (&dev->sem);
+	intf->dev.power.power_state = PMSG_SUSPEND;
+	up (&dev->sem);
+	return 0;
+}
+
+static int usbtest_resume (struct usb_interface *intf)
+{
+	struct usbtest_dev	*dev = usb_get_intfdata (intf);
+
+	down (&dev->sem);
+	intf->dev.power.power_state = PMSG_ON;
+	up (&dev->sem);
+	return 0;
+}
+
+
 static void usbtest_disconnect (struct usb_interface *intf)
 {
 	struct usbtest_dev	*dev = usb_get_intfdata (intf);
@@ -2115,6 +2157,8 @@ static struct usb_driver usbtest_driver = {
 	.probe =	usbtest_probe,
 	.ioctl =	usbtest_ioctl,
 	.disconnect =	usbtest_disconnect,
+	.suspend =	usbtest_suspend,
+	.resume =	usbtest_resume,
 };
 
 /*-------------------------------------------------------------------------*/

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
new file mode 100644
index 000000000000..3104f28f6aa8
--- /dev/null
+++ b/drivers/usb/misc/usbtest.c
@@ -0,0 +1,2140 @@
+#include <linux/config.h>
+#if !defined (DEBUG) && defined (CONFIG_USB_DEBUG)
+#   define DEBUG
+#endif
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <asm/scatterlist.h>
+
+#include <linux/usb.h>
+
+
+/*-------------------------------------------------------------------------*/
+
+// FIXME make these public somewhere; usbdevfs.h?
+//
+struct usbtest_param {
+	// inputs
+	unsigned		test_num;	/* 0..(TEST_CASES-1) */
+	unsigned		iterations;
+	unsigned		length;
+	unsigned		vary;
+	unsigned		sglen;
+
+	// outputs
+	struct timeval		duration;
+};
+#define USBTEST_REQUEST	_IOWR('U', 100, struct usbtest_param)
+
+/*-------------------------------------------------------------------------*/
+
+#define	GENERIC		/* let probe() bind using module params */
+
+/* Some devices that can be used for testing will have "real" drivers.
+ * Entries for those need to be enabled here by hand, after disabling
+ * that "real" driver.
+ */
+//#define	IBOT2		/* grab iBOT2 webcams */
+//#define	KEYSPAN_19Qi	/* grab un-renumerated serial adapter */
+
+/*-------------------------------------------------------------------------*/
+
+struct usbtest_info {
+	const char		*name;
+	u8			ep_in;		/* bulk/intr source */
+	u8			ep_out;		/* bulk/intr sink */
+	unsigned		autoconf : 1;
+	unsigned		ctrl_out : 1;
+	unsigned		iso : 1;	/* try iso in/out */
+	int			alt;
+};
+
+/* this is accessed only through usbfs ioctl calls.
+ * one ioctl to issue a test ... one lock per device.
+ * tests create other threads if they need them.
+ * urbs and buffers are allocated dynamically,
+ * and data generated deterministically.
+ */
+struct usbtest_dev {
+	struct usb_interface	*intf;
+	struct usbtest_info	*info;
+	int			in_pipe;
+	int			out_pipe;
+	int			in_iso_pipe;
+	int			out_iso_pipe;
+	struct usb_endpoint_descriptor	*iso_in, *iso_out;
+	struct semaphore	sem;
+
+#define TBUF_SIZE	256
+	u8			*buf;
+};
+
+static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
+{
+	return interface_to_usbdev (test->intf);
+}
+
+/* set up all urbs so they can be used with either bulk or interrupt */
+#define	INTERRUPT_RATE		1	/* msec/transfer */
+
+#define xprintk(tdev,level,fmt,args...) \
+	dev_printk(level ,  &(tdev)->intf->dev ,  fmt ,  ## args)
+
+#ifdef DEBUG
+#define DBG(dev,fmt,args...) \
+	xprintk(dev , KERN_DEBUG , fmt , ## args)
+#else
+#define DBG(dev,fmt,args...) \
+	do { } while (0)
+#endif /* DEBUG */
+
+#ifdef VERBOSE
+#define VDBG DBG
+#else
+#define VDBG(dev,fmt,args...) \
+	do { } while (0)
+#endif	/* VERBOSE */
+
+#define ERROR(dev,fmt,args...) \
+	xprintk(dev , KERN_ERR , fmt , ## args)
+#define WARN(dev,fmt,args...) \
+	xprintk(dev , KERN_WARNING , fmt , ## args)
+#define INFO(dev,fmt,args...) \
+	xprintk(dev , KERN_INFO , fmt , ## args)
+
+/*-------------------------------------------------------------------------*/
+
+static int
+get_endpoints (struct usbtest_dev *dev, struct usb_interface *intf)
+{
+	int				tmp;
+	struct usb_host_interface	*alt;
+	struct usb_host_endpoint	*in, *out;
+	struct usb_host_endpoint	*iso_in, *iso_out;
+	struct usb_device		*udev;
+
+	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
+		unsigned	ep;
+
+		in = out = NULL;
+		iso_in = iso_out = NULL;
+		alt = intf->altsetting + tmp;
+
+		/* take the first altsetting with in-bulk + out-bulk;
+		 * ignore other endpoints and altsetttings.
+		 */
+		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
+			struct usb_host_endpoint	*e;
+
+			e = alt->endpoint + ep;
+			switch (e->desc.bmAttributes) {
+			case USB_ENDPOINT_XFER_BULK:
+				break;
+			case USB_ENDPOINT_XFER_ISOC:
+				if (dev->info->iso)
+					goto try_iso;
+				// FALLTHROUGH
+			default:
+				continue;
+			}
+			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+				if (!in)
+					in = e;
+			} else {
+				if (!out)
+					out = e;
+			}
+			continue;
+try_iso:
+			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+				if (!iso_in)
+					iso_in = e;
+			} else {
+				if (!iso_out)
+					iso_out = e;
+			}
+		}
+		if ((in && out)  ||  (iso_in && iso_out))
+			goto found;
+	}
+	return -EINVAL;
+
+found:
+	udev = testdev_to_usbdev (dev);
+	if (alt->desc.bAlternateSetting != 0) {
+		tmp = usb_set_interface (udev,
+				alt->desc.bInterfaceNumber,
+				alt->desc.bAlternateSetting);
+		if (tmp < 0)
+			return tmp;
+	}
+
+	if (in) {
+		dev->in_pipe = usb_rcvbulkpipe (udev,
+			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+		dev->out_pipe = usb_sndbulkpipe (udev,
+			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	}
+	if (iso_in) {
+		dev->iso_in = &iso_in->desc;
+		dev->in_iso_pipe = usb_rcvisocpipe (udev,
+				iso_in->desc.bEndpointAddress
+					& USB_ENDPOINT_NUMBER_MASK);
+		dev->iso_out = &iso_out->desc;
+		dev->out_iso_pipe = usb_sndisocpipe (udev,
+				iso_out->desc.bEndpointAddress
+					& USB_ENDPOINT_NUMBER_MASK);
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Support for testing basic non-queued I/O streams.
+ *
+ * These just package urbs as requests that can be easily canceled.
+ * Each urb's data buffer is dynamically allocated; callers can fill
+ * them with non-zero test data (or test for it) when appropriate.
+ */
+
+static void simple_callback (struct urb *urb, struct pt_regs *regs)
+{
+	complete ((struct completion *) urb->context);
+}
+
+static struct urb *simple_alloc_urb (
+	struct usb_device	*udev,
+	int			pipe,
+	unsigned long		bytes
+)
+{
+	struct urb		*urb;
+
+	if (bytes < 0)
+		return NULL;
+	urb = usb_alloc_urb (0, SLAB_KERNEL);
+	if (!urb)
+		return urb;
+	usb_fill_bulk_urb (urb, udev, pipe, NULL, bytes, simple_callback, NULL);
+	urb->interval = (udev->speed == USB_SPEED_HIGH)
+			? (INTERRUPT_RATE << 3)
+			: INTERRUPT_RATE;
+	urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	if (usb_pipein (pipe))
+		urb->transfer_flags |= URB_SHORT_NOT_OK;
+	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, SLAB_KERNEL,
+			&urb->transfer_dma);
+	if (!urb->transfer_buffer) {
+		usb_free_urb (urb);
+		urb = NULL;
+	} else
+		memset (urb->transfer_buffer, 0, bytes);
+	return urb;
+}
+
+static unsigned pattern = 0;
+module_param (pattern, uint, S_IRUGO);
+// MODULE_PARM_DESC (pattern, "i/o pattern (0 == zeroes)");
+
+static inline void simple_fill_buf (struct urb *urb)
+{
+	unsigned	i;
+	u8		*buf = urb->transfer_buffer;
+	unsigned	len = urb->transfer_buffer_length;
+
+	switch (pattern) {
+	default:
+		// FALLTHROUGH
+	case 0:
+		memset (buf, 0, len);
+		break;
+	case 1:			/* mod63 */
+		for (i = 0; i < len; i++)
+			*buf++ = (u8) (i % 63);
+		break;
+	}
+}
+
+static inline int simple_check_buf (struct urb *urb)
+{
+	unsigned	i;
+	u8		expected;
+	u8		*buf = urb->transfer_buffer;
+	unsigned	len = urb->actual_length;
+
+	for (i = 0; i < len; i++, buf++) {
+		switch (pattern) {
+		/* all-zeroes has no synchronization issues */
+		case 0:
+			expected = 0;
+			break;
+		/* mod63 stays in sync with short-terminated transfers,
+		 * or otherwise when host and gadget agree on how large
+		 * each usb transfer request should be.  resync is done
+		 * with set_interface or set_config.
+		 */
+		case 1:			/* mod63 */
+			expected = i % 63;
+			break;
+		/* always fail unsupported patterns */
+		default:
+			expected = !*buf;
+			break;
+		}
+		if (*buf == expected)
+			continue;
+		dbg ("buf[%d] = %d (not %d)", i, *buf, expected);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void simple_free_urb (struct urb *urb)
+{
+	usb_buffer_free (urb->dev, urb->transfer_buffer_length,
+			urb->transfer_buffer, urb->transfer_dma);
+	usb_free_urb (urb);
+}
+
+static int simple_io (
+	struct urb		*urb,
+	int			iterations,
+	int			vary,
+	int			expected,
+	const char		*label
+)
+{
+	struct usb_device	*udev = urb->dev;
+	int			max = urb->transfer_buffer_length;
+	struct completion	completion;
+	int			retval = 0;
+
+	urb->context = &completion;
+	while (retval == 0 && iterations-- > 0) {
+		init_completion (&completion);
+		if (usb_pipeout (urb->pipe))
+			simple_fill_buf (urb);
+		if ((retval = usb_submit_urb (urb, SLAB_KERNEL)) != 0)
+			break;
+
+		/* NOTE:  no timeouts; can't be broken out of by interrupt */
+		wait_for_completion (&completion);
+		retval = urb->status;
+		urb->dev = udev;
+		if (retval == 0 && usb_pipein (urb->pipe))
+			retval = simple_check_buf (urb);
+
+		if (vary) {
+			int	len = urb->transfer_buffer_length;
+
+			len += vary;
+			len %= max;
+			if (len == 0)
+				len = (vary < max) ? vary : max;
+			urb->transfer_buffer_length = len;
+		}
+
+		/* FIXME if endpoint halted, clear halt (and log) */
+	}
+	urb->transfer_buffer_length = max;
+
+	if (expected != retval)
+		dev_dbg (&udev->dev,
+			"%s failed, iterations left %d, status %d (not %d)\n",
+				label, iterations, retval, expected);
+	return retval;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* We use scatterlist primitives to test queued I/O.
+ * Yes, this also tests the scatterlist primitives.
+ */
+
+static void free_sglist (struct scatterlist *sg, int nents)
+{
+	unsigned		i;
+	
+	if (!sg)
+		return;
+	for (i = 0; i < nents; i++) {
+		if (!sg [i].page)
+			continue;
+		kfree (page_address (sg [i].page) + sg [i].offset);
+	}
+	kfree (sg);
+}
+
+static struct scatterlist *
+alloc_sglist (int nents, int max, int vary)
+{
+	struct scatterlist	*sg;
+	unsigned		i;
+	unsigned		size = max;
+
+	sg = kmalloc (nents * sizeof *sg, SLAB_KERNEL);
+	if (!sg)
+		return NULL;
+	memset (sg, 0, nents * sizeof *sg);
+
+	for (i = 0; i < nents; i++) {
+		char		*buf;
+
+		buf = kmalloc (size, SLAB_KERNEL);
+		if (!buf) {
+			free_sglist (sg, i);
+			return NULL;
+		}
+		memset (buf, 0, size);
+
+		/* kmalloc pages are always physically contiguous! */
+		sg [i].page = virt_to_page (buf);
+		sg [i].offset = offset_in_page (buf);
+		sg [i].length = size;
+
+		if (vary) {
+			size += vary;
+			size %= max;
+			if (size == 0)
+				size = (vary < max) ? vary : max;
+		}
+	}
+
+	return sg;
+}
+
+static int perform_sglist (
+	struct usb_device	*udev,
+	unsigned		iterations,
+	int			pipe,
+	struct usb_sg_request	*req,
+	struct scatterlist	*sg,
+	int			nents
+)
+{
+	int			retval = 0;
+
+	while (retval == 0 && iterations-- > 0) {
+		retval = usb_sg_init (req, udev, pipe,
+				(udev->speed == USB_SPEED_HIGH)
+					? (INTERRUPT_RATE << 3)
+					: INTERRUPT_RATE,
+				sg, nents, 0, SLAB_KERNEL);
+		
+		if (retval)
+			break;
+		usb_sg_wait (req);
+		retval = req->status;
+
+		/* FIXME if endpoint halted, clear halt (and log) */
+	}
+
+	// FIXME for unlink or fault handling tests, don't report
+	// failure if retval is as we expected ...
+
+	if (retval)
+		dbg ("perform_sglist failed, iterations left %d, status %d",
+				iterations, retval);
+	return retval;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* unqueued control message testing
+ *
+ * there's a nice set of device functional requirements in chapter 9 of the
+ * usb 2.0 spec, which we can apply to ANY device, even ones that don't use
+ * special test firmware.
+ *
+ * we know the device is configured (or suspended) by the time it's visible
+ * through usbfs.  we can't change that, so we won't test enumeration (which
+ * worked 'well enough' to get here, this time), power management (ditto),
+ * or remote wakeup (which needs human interaction).
+ */
+
+static unsigned realworld = 1;
+module_param (realworld, uint, 0);
+MODULE_PARM_DESC (realworld, "clear to demand stricter ch9 compliance");
+
+static int get_altsetting (struct usbtest_dev *dev)
+{
+	struct usb_interface	*iface = dev->intf;
+	struct usb_device	*udev = interface_to_usbdev (iface);
+	int			retval;
+
+	retval = usb_control_msg (udev, usb_rcvctrlpipe (udev, 0),
+			USB_REQ_GET_INTERFACE, USB_DIR_IN|USB_RECIP_INTERFACE,
+			0, iface->altsetting [0].desc.bInterfaceNumber,
+			dev->buf, 1, USB_CTRL_GET_TIMEOUT);
+	switch (retval) {
+	case 1:
+		return dev->buf [0];
+	case 0:
+		retval = -ERANGE;
+		// FALLTHROUGH
+	default:
+		return retval;
+	}
+}
+
+static int set_altsetting (struct usbtest_dev *dev, int alternate)
+{
+	struct usb_interface		*iface = dev->intf;
+	struct usb_device		*udev;
+
+	if (alternate < 0 || alternate >= 256)
+		return -EINVAL;
+
+	udev = interface_to_usbdev (iface);
+	return usb_set_interface (udev,
+			iface->altsetting [0].desc.bInterfaceNumber,
+			alternate);
+}
+
+static int is_good_config (char *buf, int len)
+{
+	struct usb_config_descriptor	*config;
+	
+	if (len < sizeof *config)
+		return 0;
+	config = (struct usb_config_descriptor *) buf;
+
+	switch (config->bDescriptorType) {
+	case USB_DT_CONFIG:
+	case USB_DT_OTHER_SPEED_CONFIG:
+		if (config->bLength != 9) {
+			dbg ("bogus config descriptor length");
+			return 0;
+		}
+		/* this bit 'must be 1' but often isn't */
+		if (!realworld && !(config->bmAttributes & 0x80)) {
+			dbg ("high bit of config attributes not set");
+			return 0;
+		}
+		if (config->bmAttributes & 0x1f) {	/* reserved == 0 */
+			dbg ("reserved config bits set");
+			return 0;
+		}
+		break;
+	default:
+		return 0;
+	}
+
+	if (le16_to_cpu(config->wTotalLength) == len)		/* read it all */
+		return 1;
+	if (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)		/* max partial read */
+		return 1;
+	dbg ("bogus config descriptor read size");
+	return 0;
+}
+
+/* sanity test for standard requests working with usb_control_mesg() and some
+ * of the utility functions which use it.
+ *
+ * this doesn't test how endpoint halts behave or data toggles get set, since
+ * we won't do I/O to bulk/interrupt endpoints here (which is how to change
+ * halt or toggle).  toggle testing is impractical without support from hcds.
+ *
+ * this avoids failing devices linux would normally work with, by not testing
+ * config/altsetting operations for devices that only support their defaults.
+ * such devices rarely support those needless operations.
+ *
+ * NOTE that since this is a sanity test, it's not examining boundary cases
+ * to see if usbcore, hcd, and device all behave right.  such testing would
+ * involve varied read sizes and other operation sequences.
+ */
+static int ch9_postconfig (struct usbtest_dev *dev)
+{
+	struct usb_interface	*iface = dev->intf;
+	struct usb_device	*udev = interface_to_usbdev (iface);
+	int			i, alt, retval;
+
+	/* [9.2.3] if there's more than one altsetting, we need to be able to
+	 * set and get each one.  mostly trusts the descriptors from usbcore.
+	 */
+	for (i = 0; i < iface->num_altsetting; i++) {
+
+		/* 9.2.3 constrains the range here */
+		alt = iface->altsetting [i].desc.bAlternateSetting;
+		if (alt < 0 || alt >= iface->num_altsetting) {
+			dev_dbg (&iface->dev,
+					"invalid alt [%d].bAltSetting = %d\n",
+					i, alt);
+		}
+
+		/* [real world] get/set unimplemented if there's only one */
+		if (realworld && iface->num_altsetting == 1)
+			continue;
+
+		/* [9.4.10] set_interface */
+		retval = set_altsetting (dev, alt);
+		if (retval) {
+			dev_dbg (&iface->dev, "can't set_interface = %d, %d\n",
+					alt, retval);
+			return retval;
+		}
+
+		/* [9.4.4] get_interface always works */
+		retval = get_altsetting (dev);
+		if (retval != alt) {
+			dev_dbg (&iface->dev, "get alt should be %d, was %d\n",
+					alt, retval);
+			return (retval < 0) ? retval : -EDOM;
+		}
+
+	}
+
+	/* [real world] get_config unimplemented if there's only one */
+	if (!realworld || udev->descriptor.bNumConfigurations != 1) {
+		int	expected = udev->actconfig->desc.bConfigurationValue;
+
+		/* [9.4.2] get_configuration always works
+		 * ... although some cheap devices (like one TI Hub I've got)
+		 * won't return config descriptors except before set_config.
+		 */
+		retval = usb_control_msg (udev, usb_rcvctrlpipe (udev, 0),
+				USB_REQ_GET_CONFIGURATION,
+				USB_DIR_IN | USB_RECIP_DEVICE,
+				0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);
+		if (retval != 1 || dev->buf [0] != expected) {
+			dev_dbg (&iface->dev,
+				"get config --> %d (%d)\n", retval,
+				expected);
+			return (retval < 0) ? retval : -EDOM;
+		}
+	}
+
+	/* there's always [9.4.3] a device descriptor [9.6.1] */
+	retval = usb_get_descriptor (udev, USB_DT_DEVICE, 0,
+			dev->buf, sizeof udev->descriptor);
+	if (retval != sizeof udev->descriptor) {
+		dev_dbg (&iface->dev, "dev descriptor --> %d\n", retval);
+		return (retval < 0) ? retval : -EDOM;
+	}
+
+	/* there's always [9.4.3] at least one config descriptor [9.6.3] */
+	for (i = 0; i < udev->descriptor.bNumConfigurations; i++) {
+		retval = usb_get_descriptor (udev, USB_DT_CONFIG, i,
+				dev->buf, TBUF_SIZE);
+		if (!is_good_config (dev->buf, retval)) {
+			dev_dbg (&iface->dev,
+					"config [%d] descriptor --> %d\n",
+					i, retval);
+			return (retval < 0) ? retval : -EDOM;
+		}
+
+		// FIXME cross-checking udev->config[i] to make sure usbcore
+		// parsed it right (etc) would be good testing paranoia
+	}
+
+	/* and sometimes [9.2.6.6] speed dependent descriptors */
+	if (le16_to_cpu(udev->descriptor.bcdUSB) == 0x0200) {
+		struct usb_qualifier_descriptor		*d = NULL;
+
+		/* device qualifier [9.6.2] */
+		retval = usb_get_descriptor (udev,
+				USB_DT_DEVICE_QUALIFIER, 0, dev->buf,
+				sizeof (struct usb_qualifier_descriptor));
+		if (retval == -EPIPE) {
+			if (udev->speed == USB_SPEED_HIGH) {
+				dev_dbg (&iface->dev,
+						"hs dev qualifier --> %d\n",
+						retval);
+				return (retval < 0) ? retval : -EDOM;
+			}
+			/* usb2.0 but not high-speed capable; fine */
+		} else if (retval != sizeof (struct usb_qualifier_descriptor)) {
+			dev_dbg (&iface->dev, "dev qualifier --> %d\n", retval);
+			return (retval < 0) ? retval : -EDOM;
+		} else
+			d = (struct usb_qualifier_descriptor *) dev->buf;
+
+		/* might not have [9.6.2] any other-speed configs [9.6.4] */
+		if (d) {
+			unsigned max = d->bNumConfigurations;
+			for (i = 0; i < max; i++) {
+				retval = usb_get_descriptor (udev,
+					USB_DT_OTHER_SPEED_CONFIG, i,
+					dev->buf, TBUF_SIZE);
+				if (!is_good_config (dev->buf, retval)) {
+					dev_dbg (&iface->dev,
+						"other speed config --> %d\n",
+						retval);
+					return (retval < 0) ? retval : -EDOM;
+				}
+			}
+		}
+	}
+	// FIXME fetch strings from at least the device descriptor
+
+	/* [9.4.5] get_status always works */
+	retval = usb_get_status (udev, USB_RECIP_DEVICE, 0, dev->buf);
+	if (retval != 2) {
+		dev_dbg (&iface->dev, "get dev status --> %d\n", retval);
+		return (retval < 0) ? retval : -EDOM;
+	}
+
+	// FIXME configuration.bmAttributes says if we could try to set/clear
+	// the device's remote wakeup feature ... if we can, test that here
+
+	retval = usb_get_status (udev, USB_RECIP_INTERFACE,
+			iface->altsetting [0].desc.bInterfaceNumber, dev->buf);
+	if (retval != 2) {
+		dev_dbg (&iface->dev, "get interface status --> %d\n", retval);
+		return (retval < 0) ? retval : -EDOM;
+	}
+	// FIXME get status for each endpoint in the interface
+	
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* use ch9 requests to test whether:
+ *   (a) queues work for control, keeping N subtests queued and
+ *       active (auto-resubmit) for M loops through the queue.
+ *   (b) protocol stalls (control-only) will autorecover.
+ *       it's not like bulk/intr; no halt clearing.
+ *   (c) short control reads are reported and handled.
+ *   (d) queues are always processed in-order
+ */
+
+struct ctrl_ctx {
+	spinlock_t		lock;
+	struct usbtest_dev	*dev;
+	struct completion	complete;
+	unsigned		count;
+	unsigned		pending;
+	int			status;
+	struct urb		**urb;
+	struct usbtest_param	*param;
+	int			last;
+};
+
+#define NUM_SUBCASES	15		/* how many test subcases here? */
+
+struct subcase {
+	struct usb_ctrlrequest	setup;
+	int			number;
+	int			expected;
+};
+
+static void ctrl_complete (struct urb *urb, struct pt_regs *regs)
+{
+	struct ctrl_ctx		*ctx = urb->context;
+	struct usb_ctrlrequest	*reqp;
+	struct subcase		*subcase;
+	int			status = urb->status;
+
+	reqp = (struct usb_ctrlrequest *)urb->setup_packet;
+	subcase = container_of (reqp, struct subcase, setup);
+
+	spin_lock (&ctx->lock);
+	ctx->count--;
+	ctx->pending--;
+
+	/* queue must transfer and complete in fifo order, unless
+	 * usb_unlink_urb() is used to unlink something not at the
+	 * physical queue head (not tested).
+	 */
+	if (subcase->number > 0) {
+		if ((subcase->number - ctx->last) != 1) {
+			dbg ("subcase %d completed out of order, last %d",
+					subcase->number, ctx->last);
+			status = -EDOM;
+			ctx->last = subcase->number;
+			goto error;
+		}
+	}
+	ctx->last = subcase->number;
+
+	/* succeed or fault in only one way? */
+	if (status == subcase->expected)
+		status = 0;
+
+	/* async unlink for cleanup? */
+	else if (status != -ECONNRESET) {
+
+		/* some faults are allowed, not required */
+		if (subcase->expected > 0 && (
+			  ((urb->status == -subcase->expected	/* happened */
+			   || urb->status == 0))))		/* didn't */
+			status = 0;
+		/* sometimes more than one fault is allowed */
+		else if (subcase->number == 12 && status == -EPIPE)
+			status = 0;
+		else
+			dbg ("subtest %d error, status %d",
+					subcase->number, status);
+	}
+
+	/* unexpected status codes mean errors; ideally, in hardware */
+	if (status) {
+error:
+		if (ctx->status == 0) {
+			int		i;
+
+			ctx->status = status;
+			info ("control queue %02x.%02x, err %d, %d left",
+					reqp->bRequestType, reqp->bRequest,
+					status, ctx->count);
+
+			/* FIXME this "unlink everything" exit route should
+			 * be a separate test case.
+			 */
+
+			/* unlink whatever's still pending */
+			for (i = 1; i < ctx->param->sglen; i++) {
+				struct urb	*u = ctx->urb [
+	(i + subcase->number) % ctx->param->sglen];
+
+				if (u == urb || !u->dev)
+					continue;
+				status = usb_unlink_urb (u);
+				switch (status) {
+				case -EINPROGRESS:
+				case -EBUSY:
+				case -EIDRM:
+					continue;
+				default:
+					dbg ("urb unlink --> %d", status);
+				}
+			}
+			status = ctx->status;
+		}
+	}
+
+	/* resubmit if we need to, else mark this as done */
+	if ((status == 0) && (ctx->pending < ctx->count)) {
+		if ((status = usb_submit_urb (urb, SLAB_ATOMIC)) != 0) {
+			dbg ("can't resubmit ctrl %02x.%02x, err %d",
+				reqp->bRequestType, reqp->bRequest, status);
+			urb->dev = NULL;
+		} else
+			ctx->pending++;
+	} else
+		urb->dev = NULL;
+	
+	/* signal completion when nothing's queued */
+	if (ctx->pending == 0)
+		complete (&ctx->complete);
+	spin_unlock (&ctx->lock);
+}
+
+static int
+test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
+{
+	struct usb_device	*udev = testdev_to_usbdev (dev);
+	struct urb		**urb;
+	struct ctrl_ctx		context;
+	int			i;
+
+	spin_lock_init (&context.lock);
+	context.dev = dev;
+	init_completion (&context.complete);
+	context.count = param->sglen * param->iterations;
+	context.pending = 0;
+	context.status = -ENOMEM;
+	context.param = param;
+	context.last = -1;
+
+	/* allocate and init the urbs we'll queue.
+	 * as with bulk/intr sglists, sglen is the queue depth; it also
+	 * controls which subtests run (more tests than sglen) or rerun.
+	 */
+	urb = kmalloc (param->sglen * sizeof (struct urb *), SLAB_KERNEL);
+	if (!urb)
+		return -ENOMEM;
+	memset (urb, 0, param->sglen * sizeof (struct urb *));
+	for (i = 0; i < param->sglen; i++) {
+		int			pipe = usb_rcvctrlpipe (udev, 0);
+		unsigned		len;
+		struct urb		*u;
+		struct usb_ctrlrequest	req;
+		struct subcase		*reqp;
+		int			expected = 0;
+
+		/* requests here are mostly expected to succeed on any
+		 * device, but some are chosen to trigger protocol stalls
+		 * or short reads.
+		 */
+		memset (&req, 0, sizeof req);
+		req.bRequest = USB_REQ_GET_DESCRIPTOR;
+		req.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;
+
+		switch (i % NUM_SUBCASES) {
+		case 0:		// get device descriptor
+			req.wValue = cpu_to_le16 (USB_DT_DEVICE << 8);
+			len = sizeof (struct usb_device_descriptor);
+			break;
+		case 1:		// get first config descriptor (only)
+			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
+			len = sizeof (struct usb_config_descriptor);
+			break;
+		case 2:		// get altsetting (OFTEN STALLS)
+			req.bRequest = USB_REQ_GET_INTERFACE;
+			req.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;
+			// index = 0 means first interface
+			len = 1;
+			expected = EPIPE;
+			break;
+		case 3:		// get interface status
+			req.bRequest = USB_REQ_GET_STATUS;
+			req.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;
+			// interface 0
+			len = 2;
+			break;
+		case 4:		// get device status
+			req.bRequest = USB_REQ_GET_STATUS;
+			req.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;
+			len = 2;
+			break;
+		case 5:		// get device qualifier (MAY STALL)
+			req.wValue = cpu_to_le16 (USB_DT_DEVICE_QUALIFIER << 8);
+			len = sizeof (struct usb_qualifier_descriptor);
+			if (udev->speed != USB_SPEED_HIGH)
+				expected = EPIPE;
+			break;
+		case 6:		// get first config descriptor, plus interface
+			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
+			len = sizeof (struct usb_config_descriptor);
+			len += sizeof (struct usb_interface_descriptor);
+			break;
+		case 7:		// get interface descriptor (ALWAYS STALLS)
+			req.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);
+			// interface == 0
+			len = sizeof (struct usb_interface_descriptor);
+			expected = EPIPE;
+			break;
+		// NOTE: two consecutive stalls in the queue here.
+		// that tests fault recovery a bit more aggressively.
+		case 8:		// clear endpoint halt (USUALLY STALLS)
+			req.bRequest = USB_REQ_CLEAR_FEATURE;
+			req.bRequestType = USB_RECIP_ENDPOINT;
+			// wValue 0 == ep halt
+			// wIndex 0 == ep0 (shouldn't halt!)
+			len = 0;
+			pipe = usb_sndctrlpipe (udev, 0);
+			expected = EPIPE;
+			break;
+		case 9:		// get endpoint status
+			req.bRequest = USB_REQ_GET_STATUS;
+			req.bRequestType = USB_DIR_IN|USB_RECIP_ENDPOINT;
+			// endpoint 0
+			len = 2;
+			break;
+		case 10:	// trigger short read (EREMOTEIO)
+			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
+			len = 1024;
+			expected = -EREMOTEIO;
+			break;
+		// NOTE: two consecutive _different_ faults in the queue.
+		case 11:	// get endpoint descriptor (ALWAYS STALLS)
+			req.wValue = cpu_to_le16 (USB_DT_ENDPOINT << 8);
+			// endpoint == 0
+			len = sizeof (struct usb_interface_descriptor);
+			expected = EPIPE;
+			break;
+		// NOTE: sometimes even a third fault in the queue!
+		case 12:	// get string 0 descriptor (MAY STALL)
+			req.wValue = cpu_to_le16 (USB_DT_STRING << 8);
+			// string == 0, for language IDs
+			len = sizeof (struct usb_interface_descriptor);
+			// may succeed when > 4 languages
+			expected = EREMOTEIO;	// or EPIPE, if no strings
+			break;
+		case 13:	// short read, resembling case 10
+			req.wValue = cpu_to_le16 ((USB_DT_CONFIG << 8) | 0);
+			// last data packet "should" be DATA1, not DATA0
+			len = 1024 - udev->descriptor.bMaxPacketSize0;
+			expected = -EREMOTEIO;
+			break;
+		case 14:	// short read; try to fill the last packet
+			req.wValue = cpu_to_le16 ((USB_DT_DEVICE << 8) | 0);
+			// device descriptor size == 18 bytes 
+			len = udev->descriptor.bMaxPacketSize0;
+			switch (len) {
+			case 8:		len = 24; break;
+			case 16:	len = 32; break;
+			}
+			expected = -EREMOTEIO;
+			break;
+		default:
+			err ("bogus number of ctrl queue testcases!");
+			context.status = -EINVAL;
+			goto cleanup;
+		}
+		req.wLength = cpu_to_le16 (len);
+		urb [i] = u = simple_alloc_urb (udev, pipe, len);
+		if (!u)
+			goto cleanup;
+
+		reqp = usb_buffer_alloc (udev, sizeof *reqp, SLAB_KERNEL,
+				&u->setup_dma);
+		if (!reqp)
+			goto cleanup;
+		reqp->setup = req;
+		reqp->number = i % NUM_SUBCASES;
+		reqp->expected = expected;
+		u->setup_packet = (char *) &reqp->setup;
+
+		u->context = &context;
+		u->complete = ctrl_complete;
+		u->transfer_flags |= URB_ASYNC_UNLINK;
+	}
+
+	/* queue the urbs */
+	context.urb = urb;
+	spin_lock_irq (&context.lock);
+	for (i = 0; i < param->sglen; i++) {
+		context.status = usb_submit_urb (urb [i], SLAB_ATOMIC);
+		if (context.status != 0) {
+			dbg ("can't submit urb[%d], status %d",
+					i, context.status);
+			context.count = context.pending;
+			break;
+		}
+		context.pending++;
+	}
+	spin_unlock_irq (&context.lock);
+
+	/* FIXME  set timer and time out; provide a disconnect hook */
+
+	/* wait for the last one to complete */
+	if (context.pending > 0)
+		wait_for_completion (&context.complete);
+
+cleanup:
+	for (i = 0; i < param->sglen; i++) {
+		if (!urb [i])
+			continue;
+		urb [i]->dev = udev;
+		if (urb [i]->setup_packet)
+			usb_buffer_free (udev, sizeof (struct usb_ctrlrequest),
+					urb [i]->setup_packet,
+					urb [i]->setup_dma);
+		simple_free_urb (urb [i]);
+	}
+	kfree (urb);
+	return context.status;
+}
+#undef NUM_SUBCASES
+
+
+/*-------------------------------------------------------------------------*/
+
+static void unlink1_callback (struct urb *urb, struct pt_regs *regs)
+{
+	int	status = urb->status;
+
+	// we "know" -EPIPE (stall) never happens
+	if (!status)
+		status = usb_submit_urb (urb, SLAB_ATOMIC);
+	if (status) {
+		urb->status = status;
+		complete ((struct completion *) urb->context);
+	}
+}
+
+static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
+{
+	struct urb		*urb;
+	struct completion	completion;
+	int			retval = 0;
+
+	init_completion (&completion);
+	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
+	if (!urb)
+		return -ENOMEM;
+	urb->transfer_flags |= URB_ASYNC_UNLINK;
+	urb->context = &completion;
+	urb->complete = unlink1_callback;
+
+	/* keep the endpoint busy.  there are lots of hc/hcd-internal
+	 * states, and testing should get to all of them over time.
+	 *
+	 * FIXME want additional tests for when endpoint is STALLing
+	 * due to errors, or is just NAKing requests.
+	 */
+	if ((retval = usb_submit_urb (urb, SLAB_KERNEL)) != 0) {
+		dev_dbg (&dev->intf->dev, "submit fail %d\n", retval);
+		return retval;
+	}
+
+	/* unlinking that should always work.  variable delay tests more
+	 * hcd states and code paths, even with little other system load.
+	 */
+	msleep (jiffies % (2 * INTERRUPT_RATE));
+	if (async) {
+retry:
+		retval = usb_unlink_urb (urb);
+		if (retval == -EBUSY || retval == -EIDRM) {
+			/* we can't unlink urbs while they're completing.
+			 * or if they've completed, and we haven't resubmitted.
+			 * "normal" drivers would prevent resubmission, but
+			 * since we're testing unlink paths, we can't.
+			 */
+			dev_dbg (&dev->intf->dev, "unlink retry\n");
+			goto retry;
+		}
+	} else
+		usb_kill_urb (urb);
+	if (!(retval == 0 || retval == -EINPROGRESS)) {
+		dev_dbg (&dev->intf->dev, "unlink fail %d\n", retval);
+		return retval;
+	}
+
+	wait_for_completion (&completion);
+	retval = urb->status;
+	simple_free_urb (urb);
+
+	if (async)
+		return (retval == -ECONNRESET) ? 0 : retval - 1000;
+	else
+		return (retval == -ENOENT || retval == -EPERM) ?
+				0 : retval - 2000;
+}
+
+static int unlink_simple (struct usbtest_dev *dev, int pipe, int len)
+{
+	int			retval = 0;
+
+	/* test sync and async paths */
+	retval = unlink1 (dev, pipe, len, 1);
+	if (!retval)
+		retval = unlink1 (dev, pipe, len, 0);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int verify_not_halted (int ep, struct urb *urb)
+{
+	int	retval;
+	u16	status;
+
+	/* shouldn't look or act halted */
+	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	if (retval < 0) {
+		dbg ("ep %02x couldn't get no-halt status, %d", ep, retval);
+		return retval;
+	}
+	if (status != 0) {
+		dbg ("ep %02x bogus status: %04x != 0", ep, status);
+		return -EINVAL;
+	}
+	retval = simple_io (urb, 1, 0, 0, __FUNCTION__);
+	if (retval != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int verify_halted (int ep, struct urb *urb)
+{
+	int	retval;
+	u16	status;
+
+	/* should look and act halted */
+	retval = usb_get_status (urb->dev, USB_RECIP_ENDPOINT, ep, &status);
+	if (retval < 0) {
+		dbg ("ep %02x couldn't get halt status, %d", ep, retval);
+		return retval;
+	}
+	if (status != 1) {
+		dbg ("ep %02x bogus status: %04x != 1", ep, status);
+		return -EINVAL;
+	}
+	retval = simple_io (urb, 1, 0, -EPIPE, __FUNCTION__);
+	if (retval != -EPIPE)
+		return -EINVAL;
+	retval = simple_io (urb, 1, 0, -EPIPE, "verify_still_halted");
+	if (retval != -EPIPE)
+		return -EINVAL;
+	return 0;
+}
+
+static int test_halt (int ep, struct urb *urb)
+{
+	int	retval;
+
+	/* shouldn't look or act halted now */
+	retval = verify_not_halted (ep, urb);
+	if (retval < 0)
+		return retval;
+
+	/* set halt (protocol test only), verify it worked */
+	retval = usb_control_msg (urb->dev, usb_sndctrlpipe (urb->dev, 0),
+			USB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,
+			USB_ENDPOINT_HALT, ep,
+			NULL, 0, USB_CTRL_SET_TIMEOUT);
+	if (retval < 0) {
+		dbg ("ep %02x couldn't set halt, %d", ep, retval);
+		return retval;
+	}
+	retval = verify_halted (ep, urb);
+	if (retval < 0)
+		return retval;
+
+	/* clear halt (tests API + protocol), verify it worked */
+	retval = usb_clear_halt (urb->dev, urb->pipe);
+	if (retval < 0) {
+		dbg ("ep %02x couldn't clear halt, %d", ep, retval);
+		return retval;
+	}
+	retval = verify_not_halted (ep, urb);
+	if (retval < 0)
+		return retval;
+
+	/* NOTE:  could also verify SET_INTERFACE clear halts ... */
+
+	return 0;
+}
+
+static int halt_simple (struct usbtest_dev *dev)
+{
+	int		ep;
+	int		retval = 0;
+	struct urb	*urb;
+
+	urb = simple_alloc_urb (testdev_to_usbdev (dev), 0, 512);
+	if (urb == NULL)
+		return -ENOMEM;
+
+	if (dev->in_pipe) {
+		ep = usb_pipeendpoint (dev->in_pipe) | USB_DIR_IN;
+		urb->pipe = dev->in_pipe;
+		retval = test_halt (ep, urb);
+		if (retval < 0)
+			goto done;
+	}
+
+	if (dev->out_pipe) {
+		ep = usb_pipeendpoint (dev->out_pipe);
+		urb->pipe = dev->out_pipe;
+		retval = test_halt (ep, urb);
+	}
+done:
+	simple_free_urb (urb);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Control OUT tests use the vendor control requests from Intel's
+ * USB 2.0 compliance test device:  write a buffer, read it back.
+ *
+ * Intel's spec only _requires_ that it work for one packet, which
+ * is pretty weak.   Some HCDs place limits here; most devices will
+ * need to be able to handle more than one OUT data packet.  We'll
+ * try whatever we're told to try.
+ */
+static int ctrl_out (struct usbtest_dev *dev,
+		unsigned count, unsigned length, unsigned vary)
+{
+	unsigned		i, j, len, retval;
+	u8			*buf;
+	char			*what = "?";
+	struct usb_device	*udev;
+	
+	if (length > 0xffff || vary >= length)
+		return -EINVAL;
+
+	buf = kmalloc(length, SLAB_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	udev = testdev_to_usbdev (dev);
+	len = length;
+	retval = 0;
+
+	/* NOTE:  hardware might well act differently if we pushed it
+	 * with lots back-to-back queued requests.
+	 */
+	for (i = 0; i < count; i++) {
+		/* write patterned data */
+		for (j = 0; j < len; j++)
+			buf [j] = i + j;
+		retval = usb_control_msg (udev, usb_sndctrlpipe (udev,0),
+				0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,
+				0, 0, buf, len, USB_CTRL_SET_TIMEOUT);
+		if (retval != len) {
+			what = "write";
+			break;
+		}
+
+		/* read it back -- assuming nothing intervened!!  */
+		retval = usb_control_msg (udev, usb_rcvctrlpipe (udev,0),
+				0x5c, USB_DIR_IN|USB_TYPE_VENDOR,
+				0, 0, buf, len, USB_CTRL_GET_TIMEOUT);
+		if (retval != len) {
+			what = "read";
+			break;
+		}
+
+		/* fail if we can't verify */
+		for (j = 0; j < len; j++) {
+			if (buf [j] != (u8) (i + j)) {
+				INFO (dev, "ctrl_out, byte %d is %d not %d\n",
+					j, buf [j], (u8) i + j);
+				retval = -EBADMSG;
+				break;
+			}
+		}
+		if (retval < 0) {
+			what = "verify";
+			break;
+		}
+
+		len += vary;
+		if (len > length)
+			len = 0;
+	}
+
+	if (retval < 0)
+		INFO (dev, "ctrl_out %s failed, code %d, count %d\n",
+			what, retval, i);
+
+	kfree (buf);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* ISO tests ... mimics common usage
+ *  - buffer length is split into N packets (mostly maxpacket sized)
+ *  - multi-buffers according to sglen
+ */
+
+struct iso_context {
+	unsigned		count;
+	unsigned		pending;
+	spinlock_t		lock;
+	struct completion	done;
+	unsigned long		errors;
+	struct usbtest_dev	*dev;
+};
+
+static void iso_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct iso_context	*ctx = urb->context;
+
+	spin_lock(&ctx->lock);
+	ctx->count--;
+
+	if (urb->error_count > 0)
+		ctx->errors += urb->error_count;
+
+	if (urb->status == 0 && ctx->count > (ctx->pending - 1)) {
+		int status = usb_submit_urb (urb, GFP_ATOMIC);
+		switch (status) {
+		case 0:
+			goto done;
+		default:
+			dev_dbg (&ctx->dev->intf->dev,
+					"iso resubmit err %d\n",
+					status);
+			/* FALLTHROUGH */
+		case -ENODEV:			/* disconnected */
+			break;
+		}
+	}
+	simple_free_urb (urb);
+
+	ctx->pending--;
+	if (ctx->pending == 0) {
+		if (ctx->errors)
+			dev_dbg (&ctx->dev->intf->dev,
+				"iso test, %lu errors\n",
+				ctx->errors);
+		complete (&ctx->done);
+	}
+done:
+	spin_unlock(&ctx->lock);
+}
+
+static struct urb *iso_alloc_urb (
+	struct usb_device	*udev,
+	int			pipe,
+	struct usb_endpoint_descriptor	*desc,
+	long			bytes
+)
+{
+	struct urb		*urb;
+	unsigned		i, maxp, packets;
+
+	if (bytes < 0 || !desc)
+		return NULL;
+	maxp = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
+	maxp *= 1 + (0x3 & (le16_to_cpu(desc->wMaxPacketSize) >> 11));
+	packets = (bytes + maxp - 1) / maxp;
+
+	urb = usb_alloc_urb (packets, SLAB_KERNEL);
+	if (!urb)
+		return urb;
+	urb->dev = udev;
+	urb->pipe = pipe;
+
+	urb->number_of_packets = packets;
+	urb->transfer_buffer_length = bytes;
+	urb->transfer_buffer = usb_buffer_alloc (udev, bytes, SLAB_KERNEL,
+			&urb->transfer_dma);
+	if (!urb->transfer_buffer) {
+		usb_free_urb (urb);
+		return NULL;
+	}
+	memset (urb->transfer_buffer, 0, bytes);
+	for (i = 0; i < packets; i++) {
+		/* here, only the last packet will be short */
+		urb->iso_frame_desc[i].length = min ((unsigned) bytes, maxp);
+		bytes -= urb->iso_frame_desc[i].length;
+
+		urb->iso_frame_desc[i].offset = maxp * i;
+	}
+
+	urb->complete = iso_callback;
+	// urb->context = SET BY CALLER
+	urb->interval = 1 << (desc->bInterval - 1);
+	urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
+	return urb;
+}
+
+static int
+test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
+		int pipe, struct usb_endpoint_descriptor *desc)
+{
+	struct iso_context	context;
+	struct usb_device	*udev;
+	unsigned		i;
+	unsigned long		packets = 0;
+	int			status;
+	struct urb		*urbs[10];	/* FIXME no limit */
+
+	if (param->sglen > 10)
+		return -EDOM;
+
+	context.count = param->iterations * param->sglen;
+	context.pending = param->sglen;
+	context.errors = 0;
+	context.dev = dev;
+	init_completion (&context.done);
+	spin_lock_init (&context.lock);
+
+	memset (urbs, 0, sizeof urbs);
+	udev = testdev_to_usbdev (dev);
+	dev_dbg (&dev->intf->dev,
+		"... iso period %d %sframes, wMaxPacket %04x\n",
+		1 << (desc->bInterval - 1),
+		(udev->speed == USB_SPEED_HIGH) ? "micro" : "",
+		le16_to_cpu(desc->wMaxPacketSize));
+
+	for (i = 0; i < param->sglen; i++) {
+		urbs [i] = iso_alloc_urb (udev, pipe, desc,
+				param->length);
+		if (!urbs [i]) {
+			status = -ENOMEM;
+			goto fail;
+		}
+		packets += urbs[i]->number_of_packets;
+		urbs [i]->context = &context;
+	}
+	packets *= param->iterations;
+	dev_dbg (&dev->intf->dev,
+		"... total %lu msec (%lu packets)\n",
+		(packets * (1 << (desc->bInterval - 1)))
+			/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),
+		packets);
+
+	spin_lock_irq (&context.lock);
+	for (i = 0; i < param->sglen; i++) {
+		status = usb_submit_urb (urbs [i], SLAB_ATOMIC);
+		if (status < 0) {
+			ERROR (dev, "submit iso[%d], error %d\n", i, status);
+			if (i == 0) {
+				spin_unlock_irq (&context.lock);
+				goto fail;
+			}
+
+			simple_free_urb (urbs [i]);
+			context.pending--;
+		}
+	}
+	spin_unlock_irq (&context.lock);
+
+	wait_for_completion (&context.done);
+	return 0;
+
+fail:
+	for (i = 0; i < param->sglen; i++) {
+		if (urbs [i])
+			simple_free_urb (urbs [i]);
+	}
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* We only have this one interface to user space, through usbfs.
+ * User mode code can scan usbfs to find N different devices (maybe on
+ * different busses) to use when testing, and allocate one thread per
+ * test.  So discovery is simplified, and we have no device naming issues.
+ *
+ * Don't use these only as stress/load tests.  Use them along with with
+ * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,
+ * video capture, and so on.  Run different tests at different times, in
+ * different sequences.  Nothing here should interact with other devices,
+ * except indirectly by consuming USB bandwidth and CPU resources for test
+ * threads and request completion.  But the only way to know that for sure
+ * is to test when HC queues are in use by many devices.
+ */
+
+static int
+usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
+{
+	struct usbtest_dev	*dev = usb_get_intfdata (intf);
+	struct usb_device	*udev = testdev_to_usbdev (dev);
+	struct usbtest_param	*param = buf;
+	int			retval = -EOPNOTSUPP;
+	struct urb		*urb;
+	struct scatterlist	*sg;
+	struct usb_sg_request	req;
+	struct timeval		start;
+	unsigned		i;
+
+	// FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is.
+
+	if (code != USBTEST_REQUEST)
+		return -EOPNOTSUPP;
+
+	if (param->iterations <= 0 || param->length < 0
+			|| param->sglen < 0 || param->vary < 0)
+		return -EINVAL;
+
+	if (down_interruptible (&dev->sem))
+		return -ERESTARTSYS;
+
+	/* some devices, like ez-usb default devices, need a non-default
+	 * altsetting to have any active endpoints.  some tests change
+	 * altsettings; force a default so most tests don't need to check.
+	 */
+	if (dev->info->alt >= 0) {
+	    	int	res;
+
+		if (intf->altsetting->desc.bInterfaceNumber) {
+			up (&dev->sem);
+			return -ENODEV;
+		}
+		res = set_altsetting (dev, dev->info->alt);
+		if (res) {
+			dev_err (&intf->dev,
+					"set altsetting to %d failed, %d\n",
+					dev->info->alt, res);
+			up (&dev->sem);
+			return res;
+		}
+	}
+
+	/*
+	 * Just a bunch of test cases that every HCD is expected to handle.
+	 *
+	 * Some may need specific firmware, though it'd be good to have
+	 * one firmware image to handle all the test cases.
+	 *
+	 * FIXME add more tests!  cancel requests, verify the data, control
+	 * queueing, concurrent read+write threads, and so on.
+	 */
+	do_gettimeofday (&start);
+	switch (param->test_num) {
+
+	case 0:
+		dev_dbg (&intf->dev, "TEST 0:  NOP\n");
+		retval = 0;
+		break;
+
+	/* Simple non-queued bulk I/O tests */
+	case 1:
+		if (dev->out_pipe == 0)
+			break;
+		dev_dbg (&intf->dev,
+				"TEST 1:  write %d bytes %u times\n",
+				param->length, param->iterations);
+		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		retval = simple_io (urb, param->iterations, 0, 0, "test1");
+		simple_free_urb (urb);
+		break;
+	case 2:
+		if (dev->in_pipe == 0)
+			break;
+		dev_dbg (&intf->dev,
+				"TEST 2:  read %d bytes %u times\n",
+				param->length, param->iterations);
+		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk source (maybe generates short writes)
+		retval = simple_io (urb, param->iterations, 0, 0, "test2");
+		simple_free_urb (urb);
+		break;
+	case 3:
+		if (dev->out_pipe == 0 || param->vary == 0)
+			break;
+		dev_dbg (&intf->dev,
+				"TEST 3:  write/%d 0..%d bytes %u times\n",
+				param->vary, param->length, param->iterations);
+		urb = simple_alloc_urb (udev, dev->out_pipe, param->length);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		retval = simple_io (urb, param->iterations, param->vary,
+					0, "test3");
+		simple_free_urb (urb);
+		break;
+	case 4:
+		if (dev->in_pipe == 0 || param->vary == 0)
+			break;
+		dev_dbg (&intf->dev,
+				"TEST 4:  read/%d 0..%d bytes %u times\n",
+				param->vary, param->length, param->iterations);
+		urb = simple_alloc_urb (udev, dev->in_pipe, param->length);
+		if (!urb) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk source (maybe generates short writes)
+		retval = simple_io (urb, param->iterations, param->vary,
+					0, "test4");
+		simple_free_urb (urb);
+		break;
+
+	/* Queued bulk I/O tests */
+	case 5:
+		if (dev->out_pipe == 0 || param->sglen == 0)
+			break;
+		dev_dbg (&intf->dev,
+			"TEST 5:  write %d sglists %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		sg = alloc_sglist (param->sglen, param->length, 0);
+		if (!sg) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		retval = perform_sglist (udev, param->iterations, dev->out_pipe,
+				&req, sg, param->sglen);
+		free_sglist (sg, param->sglen);
+		break;
+
+	case 6:
+		if (dev->in_pipe == 0 || param->sglen == 0)
+			break;
+		dev_dbg (&intf->dev,
+			"TEST 6:  read %d sglists %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		sg = alloc_sglist (param->sglen, param->length, 0);
+		if (!sg) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk source (maybe generates short writes)
+		retval = perform_sglist (udev, param->iterations, dev->in_pipe,
+				&req, sg, param->sglen);
+		free_sglist (sg, param->sglen);
+		break;
+	case 7:
+		if (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)
+			break;
+		dev_dbg (&intf->dev,
+			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
+				param->vary, param->iterations,
+				param->sglen, param->length);
+		sg = alloc_sglist (param->sglen, param->length, param->vary);
+		if (!sg) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk sink (maybe accepts short writes)
+		retval = perform_sglist (udev, param->iterations, dev->out_pipe,
+				&req, sg, param->sglen);
+		free_sglist (sg, param->sglen);
+		break;
+	case 8:
+		if (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)
+			break;
+		dev_dbg (&intf->dev,
+			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
+				param->vary, param->iterations,
+				param->sglen, param->length);
+		sg = alloc_sglist (param->sglen, param->length, param->vary);
+		if (!sg) {
+			retval = -ENOMEM;
+			break;
+		}
+		// FIRMWARE:  bulk source (maybe generates short writes)
+		retval = perform_sglist (udev, param->iterations, dev->in_pipe,
+				&req, sg, param->sglen);
+		free_sglist (sg, param->sglen);
+		break;
+
+	/* non-queued sanity tests for control (chapter 9 subset) */
+	case 9:
+		retval = 0;
+		dev_dbg (&intf->dev,
+			"TEST 9:  ch9 (subset) control tests, %d times\n",
+				param->iterations);
+		for (i = param->iterations; retval == 0 && i--; /* NOP */)
+			retval = ch9_postconfig (dev);
+		if (retval)
+			dbg ("ch9 subset failed, iterations left %d", i);
+		break;
+
+	/* queued control messaging */
+	case 10:
+		if (param->sglen == 0)
+			break;
+		retval = 0;
+		dev_dbg (&intf->dev,
+				"TEST 10:  queue %d control calls, %d times\n",
+				param->sglen,
+				param->iterations);
+		retval = test_ctrl_queue (dev, param);
+		break;
+
+	/* simple non-queued unlinks (ring with one urb) */
+	case 11:
+		if (dev->in_pipe == 0 || !param->length)
+			break;
+		retval = 0;
+		dev_dbg (&intf->dev, "TEST 11:  unlink %d reads of %d\n",
+				param->iterations, param->length);
+		for (i = param->iterations; retval == 0 && i--; /* NOP */)
+			retval = unlink_simple (dev, dev->in_pipe,
+						param->length);
+		if (retval)
+			dev_dbg (&intf->dev, "unlink reads failed %d, "
+				"iterations left %d\n", retval, i);
+		break;
+	case 12:
+		if (dev->out_pipe == 0 || !param->length)
+			break;
+		retval = 0;
+		dev_dbg (&intf->dev, "TEST 12:  unlink %d writes of %d\n",
+				param->iterations, param->length);
+		for (i = param->iterations; retval == 0 && i--; /* NOP */)
+			retval = unlink_simple (dev, dev->out_pipe,
+						param->length);
+		if (retval)
+			dev_dbg (&intf->dev, "unlink writes failed %d, "
+				"iterations left %d\n", retval, i);
+		break;
+
+	/* ep halt tests */
+	case 13:
+		if (dev->out_pipe == 0 && dev->in_pipe == 0)
+			break;
+		retval = 0;
+		dev_dbg (&intf->dev, "TEST 13:  set/clear %d halts\n",
+				param->iterations);
+		for (i = param->iterations; retval == 0 && i--; /* NOP */)
+			retval = halt_simple (dev);
+		
+		if (retval)
+			DBG (dev, "halts failed, iterations left %d\n", i);
+		break;
+
+	/* control write tests */
+	case 14:
+		if (!dev->info->ctrl_out)
+			break;
+		dev_dbg (&intf->dev, "TEST 14:  %d ep0out, 0..%d vary %d\n",
+				param->iterations, param->length, param->vary);
+		retval = ctrl_out (dev, param->iterations, 
+				param->length, param->vary);
+		break;
+
+	/* iso write tests */
+	case 15:
+		if (dev->out_iso_pipe == 0 || param->sglen == 0)
+			break;
+		dev_dbg (&intf->dev, 
+			"TEST 15:  write %d iso, %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		// FIRMWARE:  iso sink
+		retval = test_iso_queue (dev, param,
+				dev->out_iso_pipe, dev->iso_out);
+		break;
+
+	/* iso read tests */
+	case 16:
+		if (dev->in_iso_pipe == 0 || param->sglen == 0)
+			break;
+		dev_dbg (&intf->dev,
+			"TEST 16:  read %d iso, %d entries of %d bytes\n",
+				param->iterations,
+				param->sglen, param->length);
+		// FIRMWARE:  iso source
+		retval = test_iso_queue (dev, param,
+				dev->in_iso_pipe, dev->iso_in);
+		break;
+
+	// FIXME unlink from queue (ring with N urbs)
+
+	// FIXME scatterlist cancel (needs helper thread)
+
+	}
+	do_gettimeofday (&param->duration);
+	param->duration.tv_sec -= start.tv_sec;
+	param->duration.tv_usec -= start.tv_usec;
+	if (param->duration.tv_usec < 0) {
+		param->duration.tv_usec += 1000 * 1000;
+		param->duration.tv_sec -= 1;
+	}
+	up (&dev->sem);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static unsigned force_interrupt = 0;
+module_param (force_interrupt, uint, 0);
+MODULE_PARM_DESC (force_interrupt, "0 = test default; else interrupt");
+
+#ifdef	GENERIC
+static unsigned short vendor;
+module_param(vendor, ushort, 0);
+MODULE_PARM_DESC (vendor, "vendor code (from usb-if)");
+
+static unsigned short product;
+module_param(product, ushort, 0);
+MODULE_PARM_DESC (product, "product code (from vendor)");
+#endif
+
+static int
+usbtest_probe (struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device	*udev;
+	struct usbtest_dev	*dev;
+	struct usbtest_info	*info;
+	char			*rtest, *wtest;
+	char			*irtest, *iwtest;
+
+	udev = interface_to_usbdev (intf);
+
+#ifdef	GENERIC
+	/* specify devices by module parameters? */
+	if (id->match_flags == 0) {
+		/* vendor match required, product match optional */
+		if (!vendor || le16_to_cpu(udev->descriptor.idVendor) != (u16)vendor)
+			return -ENODEV;
+		if (product && le16_to_cpu(udev->descriptor.idProduct) != (u16)product)
+			return -ENODEV;
+		dbg ("matched module params, vend=0x%04x prod=0x%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+#endif
+
+	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+	memset (dev, 0, sizeof *dev);
+	info = (struct usbtest_info *) id->driver_info;
+	dev->info = info;
+	init_MUTEX (&dev->sem);
+
+	dev->intf = intf;
+
+	/* cacheline-aligned scratch for i/o */
+	if ((dev->buf = kmalloc (TBUF_SIZE, SLAB_KERNEL)) == NULL) {
+		kfree (dev);
+		return -ENOMEM;
+	}
+
+	/* NOTE this doesn't yet test the handful of difference that are
+	 * visible with high speed interrupts:  bigger maxpacket (1K) and
+	 * "high bandwidth" modes (up to 3 packets/uframe).
+	 */
+	rtest = wtest = "";
+	irtest = iwtest = "";
+	if (force_interrupt || udev->speed == USB_SPEED_LOW) {
+		if (info->ep_in) {
+			dev->in_pipe = usb_rcvintpipe (udev, info->ep_in);
+			rtest = " intr-in";
+		}
+		if (info->ep_out) {
+			dev->out_pipe = usb_sndintpipe (udev, info->ep_out);
+			wtest = " intr-out";
+		}
+	} else {
+		if (info->autoconf) {
+			int status;
+
+			status = get_endpoints (dev, intf);
+			if (status < 0) {
+				dbg ("couldn't get endpoints, %d\n", status);
+				return status;
+			}
+			/* may find bulk or ISO pipes */
+		} else {
+			if (info->ep_in)
+				dev->in_pipe = usb_rcvbulkpipe (udev,
+							info->ep_in);
+			if (info->ep_out)
+				dev->out_pipe = usb_sndbulkpipe (udev,
+							info->ep_out);
+		}
+		if (dev->in_pipe)
+			rtest = " bulk-in";
+		if (dev->out_pipe)
+			wtest = " bulk-out";
+		if (dev->in_iso_pipe)
+			irtest = " iso-in";
+		if (dev->out_iso_pipe)
+			iwtest = " iso-out";
+	}
+
+	usb_set_intfdata (intf, dev);
+	dev_info (&intf->dev, "%s\n", info->name);
+	dev_info (&intf->dev, "%s speed {control%s%s%s%s%s} tests%s\n",
+			({ char *tmp;
+			switch (udev->speed) {
+			case USB_SPEED_LOW: tmp = "low"; break;
+			case USB_SPEED_FULL: tmp = "full"; break;
+			case USB_SPEED_HIGH: tmp = "high"; break;
+			default: tmp = "unknown"; break;
+			}; tmp; }),
+			info->ctrl_out ? " in/out" : "",
+			rtest, wtest,
+			irtest, iwtest,
+			info->alt >= 0 ? " (+alt)" : "");
+	return 0;
+}
+
+static void usbtest_disconnect (struct usb_interface *intf)
+{
+	struct usbtest_dev	*dev = usb_get_intfdata (intf);
+
+	down (&dev->sem);
+
+	usb_set_intfdata (intf, NULL);
+	dev_dbg (&intf->dev, "disconnect\n");
+	kfree (dev);
+}
+
+/* Basic testing only needs a device that can source or sink bulk traffic.
+ * Any device can test control transfers (default with GENERIC binding).
+ *
+ * Several entries work with the default EP0 implementation that's built
+ * into EZ-USB chips.  There's a default vendor ID which can be overridden
+ * by (very) small config EEPROMS, but otherwise all these devices act
+ * identically until firmware is loaded:  only EP0 works.  It turns out
+ * to be easy to make other endpoints work, without modifying that EP0
+ * behavior.  For now, we expect that kind of firmware.
+ */
+
+/* an21xx or fx versions of ez-usb */
+static struct usbtest_info ez1_info = {
+	.name		= "EZ-USB device",
+	.ep_in		= 2,
+	.ep_out		= 2,
+	.alt		= 1,
+};
+
+/* fx2 version of ez-usb */
+static struct usbtest_info ez2_info = {
+	.name		= "FX2 device",
+	.ep_in		= 6,
+	.ep_out		= 2,
+	.alt		= 1,
+};
+
+/* ezusb family device with dedicated usb test firmware,
+ */
+static struct usbtest_info fw_info = {
+	.name		= "usb test device",
+	.ep_in		= 2,
+	.ep_out		= 2,
+	.alt		= 1,
+	.autoconf	= 1,		// iso and ctrl_out need autoconf
+	.ctrl_out	= 1,
+	.iso		= 1,		// iso_ep's are #8 in/out
+};
+
+/* peripheral running Linux and 'zero.c' test firmware, or
+ * its user-mode cousin. different versions of this use
+ * different hardware with the same vendor/product codes.
+ * host side MUST rely on the endpoint descriptors.
+ */
+static struct usbtest_info gz_info = {
+	.name		= "Linux gadget zero",
+	.autoconf	= 1,
+	.ctrl_out	= 1,
+	.alt		= 0,
+};
+
+static struct usbtest_info um_info = {
+	.name		= "Linux user mode test driver",
+	.autoconf	= 1,
+	.alt		= -1,
+};
+
+static struct usbtest_info um2_info = {
+	.name		= "Linux user mode ISO test driver",
+	.autoconf	= 1,
+	.iso		= 1,
+	.alt		= -1,
+};
+
+#ifdef IBOT2
+/* this is a nice source of high speed bulk data;
+ * uses an FX2, with firmware provided in the device
+ */
+static struct usbtest_info ibot2_info = {
+	.name		= "iBOT2 webcam",
+	.ep_in		= 2,
+	.alt		= -1,
+};
+#endif
+
+#ifdef GENERIC
+/* we can use any device to test control traffic */
+static struct usbtest_info generic_info = {
+	.name		= "Generic USB device",
+	.alt		= -1,
+};
+#endif
+
+// FIXME remove this 
+static struct usbtest_info hact_info = {
+	.name		= "FX2/hact",
+	//.ep_in		= 6,
+	.ep_out		= 2,
+	.alt		= -1,
+};
+
+
+static struct usb_device_id id_table [] = {
+
+	{ USB_DEVICE (0x0547, 0x1002),
+		.driver_info = (unsigned long) &hact_info,
+		},
+
+	/*-------------------------------------------------------------*/
+
+	/* EZ-USB devices which download firmware to replace (or in our
+	 * case augment) the default device implementation.
+	 */
+
+	/* generic EZ-USB FX controller */
+	{ USB_DEVICE (0x0547, 0x2235),
+		.driver_info = (unsigned long) &ez1_info,
+		},
+
+	/* CY3671 development board with EZ-USB FX */
+	{ USB_DEVICE (0x0547, 0x0080),
+		.driver_info = (unsigned long) &ez1_info,
+		},
+
+	/* generic EZ-USB FX2 controller (or development board) */
+	{ USB_DEVICE (0x04b4, 0x8613),
+		.driver_info = (unsigned long) &ez2_info,
+		},
+
+	/* re-enumerated usb test device firmware */
+	{ USB_DEVICE (0xfff0, 0xfff0),
+		.driver_info = (unsigned long) &fw_info,
+		},
+
+	/* "Gadget Zero" firmware runs under Linux */
+	{ USB_DEVICE (0x0525, 0xa4a0),
+		.driver_info = (unsigned long) &gz_info,
+		},
+
+	/* so does a user-mode variant */
+	{ USB_DEVICE (0x0525, 0xa4a4),
+		.driver_info = (unsigned long) &um_info,
+		},
+
+	/* ... and a user-mode variant that talks iso */
+	{ USB_DEVICE (0x0525, 0xa4a3),
+		.driver_info = (unsigned long) &um2_info,
+		},
+
+#ifdef KEYSPAN_19Qi
+	/* Keyspan 19qi uses an21xx (original EZ-USB) */
+	// this does not coexist with the real Keyspan 19qi driver!
+	{ USB_DEVICE (0x06cd, 0x010b),
+		.driver_info = (unsigned long) &ez1_info,
+		},
+#endif
+
+	/*-------------------------------------------------------------*/
+
+#ifdef IBOT2
+	/* iBOT2 makes a nice source of high speed bulk-in data */
+	// this does not coexist with a real iBOT2 driver!
+	{ USB_DEVICE (0x0b62, 0x0059),
+		.driver_info = (unsigned long) &ibot2_info,
+		},
+#endif
+
+	/*-------------------------------------------------------------*/
+
+#ifdef GENERIC
+	/* module params can specify devices to use for control tests */
+	{ .driver_info = (unsigned long) &generic_info, },
+#endif
+
+	/*-------------------------------------------------------------*/
+
+	{ }
+};
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static struct usb_driver usbtest_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"usbtest",
+	.id_table =	id_table,
+	.probe =	usbtest_probe,
+	.ioctl =	usbtest_ioctl,
+	.disconnect =	usbtest_disconnect,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init usbtest_init (void)
+{
+#ifdef GENERIC
+	if (vendor)
+		dbg ("params: vend=0x%04x prod=0x%04x", vendor, product);
+#endif
+	return usb_register (&usbtest_driver);
+}
+module_init (usbtest_init);
+
+static void __exit usbtest_exit (void)
+{
+	usb_deregister (&usbtest_driver);
+}
+module_exit (usbtest_exit);
+
+MODULE_DESCRIPTION ("USB Core/HCD Testing Driver");
+MODULE_LICENSE ("GPL");
+
