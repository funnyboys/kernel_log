commit 5d62afbe9572138a25d67b8468d27ec65777824d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:58 2017 +0100

    USB: misc: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index fad894a63c52..3eea60437f56 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -3,10 +3,6 @@
  * Emagic EMI 2|6 usb audio interface firmware loader.
  * Copyright (C) 2002
  * 	Tapio Laxstr√∂m (tapio.laxstrom@iptime.fi)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, as published by
- * the Free Software Foundation, version 2.
  */
 #include <linux/kernel.h>
 #include <linux/errno.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 1d9be4431b72..fad894a63c52 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* 
  * Emagic EMI 2|6 usb audio interface firmware loader.
  * Copyright (C) 2002

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index ae794b90766b..1d9be4431b72 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -10,7 +10,6 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 #include <linux/module.h>
 #include <linux/usb.h>
 #include <linux/delay.h>

commit 83957df21dd94655d2b026e0944a69ff37b83988
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 17 17:48:41 2012 -0700

    USB: emi62: remove __devinit* from the struct usb_device_id table
    
    This structure needs to always stick around, even if CONFIG_HOTPLUG
    is disabled, otherwise we can oops when trying to probe a device that
    was added after the structure is thrown away.
    
    Thanks to Fengguang Wu and Bj√∏rn Mork for tracking this issue down.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Reported-by: Bj√∏rn Mork <bjorn@mork.no>
    Cc: stable <stable@vger.kernel.org>
    CC: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index ff08015b230c..ae794b90766b 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -232,7 +232,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	return err;
 }
 
-static const struct usb_device_id id_table[] __devinitconst = {
+static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(EMI62_VENDOR_ID, EMI62_PRODUCT_ID) },
 	{ }                                             /* Terminating entry */
 };

commit e9a527dae346c0ad56410c3794ba5ec535c66bcc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 20 16:53:40 2012 -0700

    USB: emi62.c: remove err() usage
    
    err() was a very old USB-specific macro that I thought had
    gone away.  This patch removes it from being used in the
    driver and uses dev_err() instead.
    
    CC: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 4e0f167a6c4e..ff08015b230c 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -56,7 +56,7 @@ static int emi62_writememory(struct usb_device *dev, int address,
 	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
 
 	if (!buffer) {
-		err("emi62: kmalloc(%d) failed.", length);
+		dev_err(&dev->dev, "kmalloc(%d) failed.\n", length);
 		return -ENOMEM;
 	}
 	/* Note: usb_control_msg returns negative value on error or length of the
@@ -73,9 +73,8 @@ static int emi62_set_reset (struct usb_device *dev, unsigned char reset_bit)
 	dev_info(&dev->dev, "%s - %d\n", __func__, reset_bit);
 	
 	response = emi62_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
-	if (response < 0) {
-		err("emi62: set_reset (%d) failed", reset_bit);
-	}
+	if (response < 0)
+		dev_err(&dev->dev, "set_reset (%d) failed\n", reset_bit);
 	return response;
 }
 
@@ -87,18 +86,15 @@ static int emi62_load_firmware (struct usb_device *dev)
 	const struct firmware *bitstream_fw = NULL;
 	const struct firmware *firmware_fw = NULL;
 	const struct ihex_binrec *rec;
-	int err;
+	int err = -ENOMEM;
 	int i;
 	__u32 addr;	/* Address to write */
 	__u8 *buf;
 
 	dev_dbg(&dev->dev, "load_firmware\n");
 	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
-	if (!buf) {
-		err( "%s - error loading firmware: error = %d", __func__, -ENOMEM);
-		err = -ENOMEM;
+	if (!buf)
 		goto wraperr;
-	}
 
 	err = request_ihex_firmware(&loader_fw, "emi62/loader.fw", &dev->dev);
 	if (err)
@@ -112,16 +108,13 @@ static int emi62_load_firmware (struct usb_device *dev)
 	err = request_ihex_firmware(&firmware_fw, FIRMWARE_FW, &dev->dev);
 	if (err) {
 	nofw:
-		err( "%s - request_firmware() failed", __func__);
 		goto wraperr;
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	rec = (const struct ihex_binrec *)loader_fw->data;
 
@@ -130,19 +123,15 @@ static int emi62_load_firmware (struct usb_device *dev)
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 		rec = ihex_next_binrec(rec);
 	}
 
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI
@@ -160,18 +149,14 @@ static int emi62_load_firmware (struct usb_device *dev)
 			rec = ihex_next_binrec(rec);
 		}
 		err = emi62_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 	} while (rec);
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
 	for (rec = (const struct ihex_binrec *)loader_fw->data;
@@ -179,18 +164,14 @@ static int emi62_load_firmware (struct usb_device *dev)
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 	}
 
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 	msleep(250);	/* let device settle */
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
@@ -201,19 +182,15 @@ static int emi62_load_firmware (struct usb_device *dev)
 			err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 						rec->data, be16_to_cpu(rec->len),
 						ANCHOR_LOAD_EXTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __func__, err);
+			if (err < 0)
 				goto wraperr;
-			}
 		}
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
@@ -221,19 +198,15 @@ static int emi62_load_firmware (struct usb_device *dev)
 			err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 						rec->data, be16_to_cpu(rec->len),
 						ANCHOR_LOAD_EXTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __func__, err);
+			if (err < 0)
 				goto wraperr;
-			}
 		}
 	}
 
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 	msleep(250);	/* let device settle */
 
 	release_firmware(loader_fw);
@@ -247,6 +220,9 @@ static int emi62_load_firmware (struct usb_device *dev)
 	return 1;
 
 wraperr:
+	if (err < 0)
+		dev_err(&dev->dev,"%s - error loading firmware: error = %d\n",
+			__func__, err);
 	release_firmware(loader_fw);
 	release_firmware(bitstream_fw);
 	release_firmware(firmware_fw);

commit 55305afc30529143bdb5928b2154dccdf073acd5
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Jan 10 15:43:08 2012 -0800

    drivers/usb/misc/emi26.c & emi62.c: fix warnings
    
    drivers/usb/misc/emi26.c:40: warning: 'emi26_init' declared 'static' but never defined
    drivers/usb/misc/emi26.c:41: warning: 'emi26_exit' declared 'static' but never defined
    drivers/usb/misc/emi62.c:49: warning: 'emi62_init' declared 'static' but never defined
    drivers/usb/misc/emi62.c:50: warning: 'emi62_exit' declared 'static' but never defined
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 9f39062ebb08..4e0f167a6c4e 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -46,9 +46,6 @@ static int emi62_set_reset(struct usb_device *dev, unsigned char reset_bit);
 static int emi62_load_firmware (struct usb_device *dev);
 static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *id);
 static void emi62_disconnect(struct usb_interface *intf);
-static int __init emi62_init (void);
-static void __exit emi62_exit (void);
-
 
 /* thanks to drivers/usb/serial/keyspan_pda.c code */
 static int emi62_writememory(struct usb_device *dev, int address,

commit 65db43054065790a75291b0834657445fea2cf56
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 18 09:34:02 2011 -0800

    USB: convert drivers/usb/* to use module_usb_driver()
    
    This converts the drivers in drivers/usb/* to use the
    module_usb_driver() macro which makes the code smaller and a bit
    simpler.
    
    Added bonus is that it removes some unneeded kernel log messages about
    drivers loading and/or unloading.
    
    Cc: Simon Arlott <cxacru@fire.lp0.eu>
    Cc: Duncan Sands <duncan.sands@free.fr>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Stanislaw Gruszka <stf_xl@wp.pl>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Michael Hund <mhund@ld-didactic.de>
    Cc: Zack Parsons <k3bacon@gmail.com>
    Cc: Melchior FRANZ <mfranz@aon.at>
    Cc: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index fc15ad4c3139..9f39062ebb08 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -290,22 +290,7 @@ static struct usb_driver emi62_driver = {
 	.id_table	= id_table,
 };
 
-static int __init emi62_init (void)
-{
-	int retval;
-	retval = usb_register (&emi62_driver);
-	if (retval)
-		printk(KERN_ERR "adi-emi: registration failed\n");
-	return retval;
-}
-
-static void __exit emi62_exit (void)
-{
-	usb_deregister (&emi62_driver);
-}
-
-module_init(emi62_init);
-module_exit(emi62_exit);
+module_usb_driver(emi62_driver);
 
 MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 6|2m firmware loader.");

commit 33b9e16243fd69493be3ddda7be73226c8be586a
Author: N√©meth M√°rton <nm127@freemail.hu>
Date:   Sun Jan 10 15:34:45 2010 +0100

    USB misc: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: N√©meth M√°rton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 59860b328534..fc15ad4c3139 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -259,7 +259,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	return err;
 }
 
-static __devinitdata struct usb_device_id id_table [] = {
+static const struct usb_device_id id_table[] __devinitconst = {
 	{ USB_DEVICE(EMI62_VENDOR_ID, EMI62_PRODUCT_ID) },
 	{ }                                             /* Terminating entry */
 };

commit ac06c06770bb8761b1f1f9bdf2f5420fa6d3e9fa
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 21 15:36:44 2009 -0800

    USB: emi62: fix crash when trying to load EMI 6|2 firmware
    
    While converting emi62 to use request_firmware(), the driver was also
    changed to use the ihex helper functions.  However, this broke the loading
    of the FPGA firmware because the code tries to access the addr field of
    the EOF record which works with a plain array that has an empty last
    record but not with the ihex helper functions where the end of the data is
    signaled with a NULL record pointer, resulting in:
    
    BUG: unable to handle kernel NULL pointer dereference at (null)
    IP: [<f80d248c>] emi62_load_firmware+0x33c/0x740 [emi62]
    
    This can be fixed by changing the loop condition to test the return value
    of ihex_next_binrec() directly (like in emi26.c).
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-and-tested-by: Der Mickster <retroeffective@gmail.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 602ee05ba9ff..59860b328534 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -167,7 +167,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
-	} while (i > 0);
+	} while (rec);
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);

commit 1b29a375fb0b79a11a2d18e7bf5f6da422a35025
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/misc drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 5d859ded5bbf..602ee05ba9ff 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -73,7 +73,7 @@ static int emi62_writememory(struct usb_device *dev, int address,
 static int emi62_set_reset (struct usb_device *dev, unsigned char reset_bit)
 {
 	int response;
-	info("%s - %d", __func__, reset_bit);
+	dev_info(&dev->dev, "%s - %d\n", __func__, reset_bit);
 	
 	response = emi62_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
@@ -271,7 +271,7 @@ static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *i
 	struct usb_device *dev = interface_to_usbdev(intf);
 	dev_dbg(&intf->dev, "emi62_probe\n");
 
-	info("%s start", __func__);
+	dev_info(&intf->dev, "%s start\n", __func__);
 
 	emi62_load_firmware(dev);
 

commit ea05af61a874ffbc158d9cf06df8a9396f299f38
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:00:46 2008 +0300

    USB: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 20886c21e739..5d859ded5bbf 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -6,8 +6,6 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, as published by
  * the Free Software Foundation, version 2.
- * 
- * $Id: emi62.c,v 1.15 2002/04/23 06:13:59 tapio Exp $
  */
 #include <linux/kernel.h>
 #include <linux/errno.h>

commit b8e24bfabb03527d1c876fcaf24cccb05e1cbc65
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri May 30 17:35:47 2008 +0300

    emi62: use request_firmware()
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 1a2b79ac5e10..20886c21e739 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -16,15 +16,8 @@
 #include <linux/module.h>
 #include <linux/usb.h>
 #include <linux/delay.h>
-
-#define MAX_INTEL_HEX_RECORD_LENGTH 16
-typedef struct _INTEL_HEX_RECORD
-{
-	__u32	length;
-	__u32	address;
-	__u32	type;
-	__u8	data[MAX_INTEL_HEX_RECORD_LENGTH];
-} INTEL_HEX_RECORD, *PINTEL_HEX_RECORD;
+#include <linux/firmware.h>
+#include <linux/ihex.h>
 
 /* include firmware (variables)*/
 
@@ -33,9 +26,9 @@ typedef struct _INTEL_HEX_RECORD
 //#undef SPDIF	/* if you want MIDI uncomment this line */ 
 
 #ifdef SPDIF
-#  include "emi62_fw_s.h" /* spdif fw */
+#define FIRMWARE_FW "emi62/spdif.fw"
 #else
-#  include "emi62_fw_m.h" /* midi fw */
+#define FIRMWARE_FW "emi62/midi.fw"
 #endif
 
 #define EMI62_VENDOR_ID 		0x086a  /* Emagic Soft-und Hardware GmBH */
@@ -48,7 +41,9 @@ typedef struct _INTEL_HEX_RECORD
 #define CPUCS_REG		0x7F92  /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */ 
 #define INTERNAL_RAM(address)   (address <= MAX_INTERNAL_ADDRESS)
 
-static int emi62_writememory( struct usb_device *dev, int address, unsigned char *data, int length, __u8 bRequest);
+static int emi62_writememory(struct usb_device *dev, int address,
+			     const unsigned char *data, int length,
+			     __u8 bRequest);
 static int emi62_set_reset(struct usb_device *dev, unsigned char reset_bit);
 static int emi62_load_firmware (struct usb_device *dev);
 static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *id);
@@ -58,7 +53,9 @@ static void __exit emi62_exit (void);
 
 
 /* thanks to drivers/usb/serial/keyspan_pda.c code */
-static int emi62_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
+static int emi62_writememory(struct usb_device *dev, int address,
+			     const unsigned char *data, int length,
+			     __u8 request)
 {
 	int result;
 	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
@@ -91,9 +88,12 @@ static int emi62_set_reset (struct usb_device *dev, unsigned char reset_bit)
 
 static int emi62_load_firmware (struct usb_device *dev)
 {
+	const struct firmware *loader_fw = NULL;
+	const struct firmware *bitstream_fw = NULL;
+	const struct firmware *firmware_fw = NULL;
+	const struct ihex_binrec *rec;
 	int err;
 	int i;
-	int pos = 0;	/* Position in hex record */
 	__u32 addr;	/* Address to write */
 	__u8 *buf;
 
@@ -105,6 +105,22 @@ static int emi62_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
+	err = request_ihex_firmware(&loader_fw, "emi62/loader.fw", &dev->dev);
+	if (err)
+		goto nofw;
+
+	err = request_ihex_firmware(&bitstream_fw, "emi62/bitstream.fw",
+				    &dev->dev);
+	if (err)
+		goto nofw;
+
+	err = request_ihex_firmware(&firmware_fw, FIRMWARE_FW, &dev->dev);
+	if (err) {
+	nofw:
+		err( "%s - request_firmware() failed", __func__);
+		goto wraperr;
+	}
+
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
 	if (err < 0) {
@@ -112,13 +128,18 @@ static int emi62_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
+	rec = (const struct ihex_binrec *)loader_fw->data;
+
 	/* 1. We need to put the loader for the FPGA into the EZ-USB */
-	for (i=0; g_emi62_loader[i].type == 0; i++) {
-		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
+	while (rec) {
+		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
+					rec->data, be16_to_cpu(rec->len),
+					ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		rec = ihex_next_binrec(rec);
 	}
 
 	/* De-assert reset (let the CPU run) */
@@ -132,15 +153,16 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* 2. We upload the FPGA firmware into the EMI
 	 * Note: collect up to 1023 (yes!) bytes and send them with
 	 * a single request. This is _much_ faster! */
+	rec = (const struct ihex_binrec *)bitstream_fw->data;
 	do {
 		i = 0;
-		addr = g_emi62bs[pos].address;
+		addr = be32_to_cpu(rec->addr);
 
 		/* intel hex records are terminated with type 0 element */
-		while ((g_emi62bs[pos].type == 0) && (i + g_emi62bs[pos].length < FW_LOAD_SIZE)) {
-			memcpy(buf + i, g_emi62bs[pos].data, g_emi62bs[pos].length);
-			i += g_emi62bs[pos].length;
-			pos++;
+		while (rec && (i + be16_to_cpu(rec->len) < FW_LOAD_SIZE)) {
+			memcpy(buf + i, rec->data, be16_to_cpu(rec->len));
+			i += be16_to_cpu(rec->len);
+			rec = ihex_next_binrec(rec);
 		}
 		err = emi62_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
 		if (err < 0) {
@@ -157,8 +179,11 @@ static int emi62_load_firmware (struct usb_device *dev)
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (i=0; g_emi62_loader[i].type == 0; i++) {
-		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
+	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
+					rec->data, be16_to_cpu(rec->len),
+					ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
@@ -175,29 +200,19 @@ static int emi62_load_firmware (struct usb_device *dev)
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
-/* FIXME: quick and dirty ifdefs */
-#ifdef SPDIF
-	for (i=0; g_HexSpdifFw62[i].type == 0; i++) {
-		if (!INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
-			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_EXTERNAL);
+	for (rec = (const struct ihex_binrec *)firmware_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
+			err = emi62_writememory(dev, be32_to_cpu(rec->addr),
+						rec->data, be16_to_cpu(rec->len),
+						ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
 				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
 	}
-#else /* MIDI */
-	for (i=0; g_HexMidiFw62[i].type == 0; i++) {
-		if (!INTERNAL_RAM(g_HexMidiFw62[i].address)) {
-			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_EXTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d\n", __func__, err);
-				goto wraperr;
-				return err;
-			}
-		}
-	}
-#endif	
+
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
 	if (err < 0) {
@@ -205,29 +220,19 @@ static int emi62_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
-/* FIXME: quick and dirty ifdefs */
-#ifdef SPDIF
-	for (i=0; g_HexSpdifFw62[i].type == 0; i++) {
-		if (INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
-			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_INTERNAL);
+	for (rec = (const struct ihex_binrec *)firmware_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
+			err = emi62_writememory(dev, be32_to_cpu(rec->addr),
+						rec->data, be16_to_cpu(rec->len),
+						ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
 				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
 	}
-#else /* MIDI */
-	for (i=0; g_HexMidiFw62[i].type == 0; i++) {
-		if (INTERNAL_RAM(g_HexMidiFw62[i].address)) {
-			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_INTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d\n", __func__, err);
-				goto wraperr;
-			}
-		}
-	}
-#endif
-	
+
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
 	if (err < 0) {
@@ -236,6 +241,10 @@ static int emi62_load_firmware (struct usb_device *dev)
 	}
 	msleep(250);	/* let device settle */
 
+	release_firmware(loader_fw);
+	release_firmware(bitstream_fw);
+	release_firmware(firmware_fw);
+
 	kfree(buf);
 
 	/* return 1 to fail the driver inialization
@@ -243,6 +252,10 @@ static int emi62_load_firmware (struct usb_device *dev)
 	return 1;
 
 wraperr:
+	release_firmware(loader_fw);
+	release_firmware(bitstream_fw);
+	release_firmware(firmware_fw);
+
 	kfree(buf);
 	dev_err(&dev->dev, "Error\n");
 	return err;
@@ -300,5 +313,8 @@ MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 6|2m firmware loader.");
 MODULE_LICENSE("GPL");
 
+MODULE_FIRMWARE("emi62/loader.fw");
+MODULE_FIRMWARE("emi62/bitstream.fw");
+MODULE_FIRMWARE(FIRMWARE_FW);
 /* vi:ai:syntax=c:sw=8:ts=8:tw=80
  */

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index d1362415922c..1a2b79ac5e10 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -78,7 +78,7 @@ static int emi62_writememory (struct usb_device *dev, int address, unsigned char
 static int emi62_set_reset (struct usb_device *dev, unsigned char reset_bit)
 {
 	int response;
-	info("%s - %d", __FUNCTION__, reset_bit);
+	info("%s - %d", __func__, reset_bit);
 	
 	response = emi62_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
@@ -100,7 +100,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	dev_dbg(&dev->dev, "load_firmware\n");
 	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
 	if (!buf) {
-		err( "%s - error loading firmware: error = %d", __FUNCTION__, -ENOMEM);
+		err( "%s - error loading firmware: error = %d", __func__, -ENOMEM);
 		err = -ENOMEM;
 		goto wraperr;
 	}
@@ -108,7 +108,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -116,7 +116,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	for (i=0; g_emi62_loader[i].type == 0; i++) {
 		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	}
@@ -124,7 +124,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 	msleep(250);	/* let device settle */
@@ -144,7 +144,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		}
 		err = emi62_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	} while (i > 0);
@@ -152,7 +152,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -160,7 +160,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	for (i=0; g_emi62_loader[i].type == 0; i++) {
 		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	}
@@ -168,7 +168,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 	msleep(250);	/* let device settle */
@@ -181,7 +181,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		if (!INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
 			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
@@ -191,7 +191,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		if (!INTERNAL_RAM(g_HexMidiFw62[i].address)) {
 			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d\n", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d\n", __func__, err);
 				goto wraperr;
 				return err;
 			}
@@ -201,7 +201,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -211,7 +211,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		if (INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
 			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_INTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
@@ -221,7 +221,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		if (INTERNAL_RAM(g_HexMidiFw62[i].address)) {
 			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_INTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d\n", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d\n", __func__, err);
 				goto wraperr;
 			}
 		}
@@ -231,7 +231,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 	msleep(250);	/* let device settle */
@@ -260,7 +260,7 @@ static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *i
 	struct usb_device *dev = interface_to_usbdev(intf);
 	dev_dbg(&intf->dev, "emi62_probe\n");
 
-	info("%s start", __FUNCTION__); 
+	info("%s start", __func__);
 
 	emi62_load_firmware(dev);
 

commit 5919a43bbc649f4770b8b5db33f43136c7ff3153
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Oct 25 15:42:38 2007 +0200

    USB: missing error check in emi62
    
    the emi62 also lacks an error check.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 4758cc5ccebc..d1362415922c 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -123,6 +123,10 @@ static int emi62_load_firmware (struct usb_device *dev)
 
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
 	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI

commit 96de0e252cedffad61b3cb5e05662c591898e69a
Author: Jan Engelhardt <jengelh@gmx.de>
Date:   Fri Oct 19 23:21:04 2007 +0200

    Convert files to UTF-8 and some cleanups
    
    * Convert files to UTF-8.
    
      * Also correct some people's names
        (one example is Ei√üfeldt, which was found in a source file.
        Given that the author used an √ü at all in a source file
        indicates that the real name has in fact a '√ü' and not an 'ss',
        which is commonly used as a substitute for '√ü' when limited to
        7bit.)
    
      * Correct town names (Goettingen -> G√∂ttingen)
    
      * Update Eberhard M√∂nkeberg's address (http://lkml.org/lkml/2007/1/8/313)
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 23153eac0dfa..4758cc5ccebc 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -1,7 +1,7 @@
 /* 
  * Emagic EMI 2|6 usb audio interface firmware loader.
  * Copyright (C) 2002
- * 	Tapio Laxstrˆm (tapio.laxstrom@iptime.fi)
+ * 	Tapio Laxstr√∂m (tapio.laxstrom@iptime.fi)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, as published by
@@ -292,7 +292,7 @@ static void __exit emi62_exit (void)
 module_init(emi62_init);
 module_exit(emi62_exit);
 
-MODULE_AUTHOR("tapio laxstrˆm");
+MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 6|2m firmware loader.");
 MODULE_LICENSE("GPL");
 

commit 5d7efe5b3768bf53df9b87380ea68baacf11f933
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Thu Oct 26 21:06:24 2006 +0200

    USB: kmemdup() cleanup in drivers/usb/
    
    replace open coded kmemdup() to save some screen space,
    and allow inlining/not inlining to be triggered by gcc.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index fe351371f274..23153eac0dfa 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -61,13 +61,12 @@ static void __exit emi62_exit (void);
 static int emi62_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
 {
 	int result;
-	unsigned char *buffer =  kmalloc (length, GFP_KERNEL);
+	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
 
 	if (!buffer) {
 		err("emi62: kmalloc(%d) failed.", length);
 		return -ENOMEM;
 	}
-	memcpy (buffer, data, length);
 	/* Note: usb_control_msg returns negative value on error or length of the
 	 * 		 data that was written! */
 	result = usb_control_msg (dev, usb_sndctrlpipe(dev, 0), request, 0x40, address, 0, buffer, length, 300);

commit 16c23f7d88cbcce491f9370b2846fad66e8ef319
Author: Monty <xiphmont@xiph.org>
Date:   Tue May 9 12:37:22 2006 -0700

    [PATCH] USB: Emagic USB firmware loading fixes
    
    It's become apparent as machines get faster that the emagic kernel firmware
    loaders (based on the ezusb loader) have a reset race.  a 400MHz TiBook
    never tripped it, but a 2GHz Pentium M seems to hit it about 30% of the
    time.  The bug is seen as a hung USB box and the kernel error:
    
    drivers/usb/misc/emi62.c: emi62_load_firmware - error loading firmware:
    error = -110
    
    The patch below inserts a delay after deasserting reset to allow the box to
    settle before a new command is issued.  This affects only device startup.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 52fea2e08db8..fe351371f274 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/usb.h>
+#include <linux/delay.h>
 
 #define MAX_INTEL_HEX_RECORD_LENGTH 16
 typedef struct _INTEL_HEX_RECORD
@@ -123,6 +124,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 
 	/* De-assert reset (let the CPU run) */
 	err = emi62_set_reset(dev,0);
+	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI
 	 * Note: collect up to 1023 (yes!) bytes and send them with
@@ -166,6 +168,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
 		goto wraperr;
 	}
+	msleep(250);	/* let device settle */
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
@@ -228,6 +231,7 @@ static int emi62_load_firmware (struct usb_device *dev)
 		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
 		goto wraperr;
 	}
+	msleep(250);	/* let device settle */
 
 	kfree(buf);
 

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
index 189986af2ac7..52fea2e08db8 100644
--- a/drivers/usb/misc/emi62.c
+++ b/drivers/usb/misc/emi62.c
@@ -266,7 +266,6 @@ static void emi62_disconnect(struct usb_interface *intf)
 }
 
 static struct usb_driver emi62_driver = {
-	.owner		= THIS_MODULE,
 	.name		= "emi62 - firmware loader",
 	.probe		= emi62_probe,
 	.disconnect	= emi62_disconnect,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/misc/emi62.c b/drivers/usb/misc/emi62.c
new file mode 100644
index 000000000000..189986af2ac7
--- /dev/null
+++ b/drivers/usb/misc/emi62.c
@@ -0,0 +1,298 @@
+/* 
+ * Emagic EMI 2|6 usb audio interface firmware loader.
+ * Copyright (C) 2002
+ * 	Tapio Laxstrˆm (tapio.laxstrom@iptime.fi)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, as published by
+ * the Free Software Foundation, version 2.
+ * 
+ * $Id: emi62.c,v 1.15 2002/04/23 06:13:59 tapio Exp $
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+
+#define MAX_INTEL_HEX_RECORD_LENGTH 16
+typedef struct _INTEL_HEX_RECORD
+{
+	__u32	length;
+	__u32	address;
+	__u32	type;
+	__u8	data[MAX_INTEL_HEX_RECORD_LENGTH];
+} INTEL_HEX_RECORD, *PINTEL_HEX_RECORD;
+
+/* include firmware (variables)*/
+
+/* FIXME: This is quick and dirty solution! */
+#define SPDIF	/* if you want SPDIF comment next line */
+//#undef SPDIF	/* if you want MIDI uncomment this line */ 
+
+#ifdef SPDIF
+#  include "emi62_fw_s.h" /* spdif fw */
+#else
+#  include "emi62_fw_m.h" /* midi fw */
+#endif
+
+#define EMI62_VENDOR_ID 		0x086a  /* Emagic Soft-und Hardware GmBH */
+#define EMI62_PRODUCT_ID		0x0110	/* EMI 6|2m without firmware */
+
+#define ANCHOR_LOAD_INTERNAL	0xA0	/* Vendor specific request code for Anchor Upload/Download (This one is implemented in the core) */
+#define ANCHOR_LOAD_EXTERNAL	0xA3	/* This command is not implemented in the core. Requires firmware */
+#define ANCHOR_LOAD_FPGA	0xA5	/* This command is not implemented in the core. Requires firmware. Emagic extension */
+#define MAX_INTERNAL_ADDRESS	0x1B3F	/* This is the highest internal RAM address for the AN2131Q */
+#define CPUCS_REG		0x7F92  /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */ 
+#define INTERNAL_RAM(address)   (address <= MAX_INTERNAL_ADDRESS)
+
+static int emi62_writememory( struct usb_device *dev, int address, unsigned char *data, int length, __u8 bRequest);
+static int emi62_set_reset(struct usb_device *dev, unsigned char reset_bit);
+static int emi62_load_firmware (struct usb_device *dev);
+static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *id);
+static void emi62_disconnect(struct usb_interface *intf);
+static int __init emi62_init (void);
+static void __exit emi62_exit (void);
+
+
+/* thanks to drivers/usb/serial/keyspan_pda.c code */
+static int emi62_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
+{
+	int result;
+	unsigned char *buffer =  kmalloc (length, GFP_KERNEL);
+
+	if (!buffer) {
+		err("emi62: kmalloc(%d) failed.", length);
+		return -ENOMEM;
+	}
+	memcpy (buffer, data, length);
+	/* Note: usb_control_msg returns negative value on error or length of the
+	 * 		 data that was written! */
+	result = usb_control_msg (dev, usb_sndctrlpipe(dev, 0), request, 0x40, address, 0, buffer, length, 300);
+	kfree (buffer);
+	return result;
+}
+
+/* thanks to drivers/usb/serial/keyspan_pda.c code */
+static int emi62_set_reset (struct usb_device *dev, unsigned char reset_bit)
+{
+	int response;
+	info("%s - %d", __FUNCTION__, reset_bit);
+	
+	response = emi62_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
+	if (response < 0) {
+		err("emi62: set_reset (%d) failed", reset_bit);
+	}
+	return response;
+}
+
+#define FW_LOAD_SIZE		1023
+
+static int emi62_load_firmware (struct usb_device *dev)
+{
+	int err;
+	int i;
+	int pos = 0;	/* Position in hex record */
+	__u32 addr;	/* Address to write */
+	__u8 *buf;
+
+	dev_dbg(&dev->dev, "load_firmware\n");
+	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
+	if (!buf) {
+		err( "%s - error loading firmware: error = %d", __FUNCTION__, -ENOMEM);
+		err = -ENOMEM;
+		goto wraperr;
+	}
+
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi62_set_reset(dev,1);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 1. We need to put the loader for the FPGA into the EZ-USB */
+	for (i=0; g_emi62_loader[i].type == 0; i++) {
+		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	}
+
+	/* De-assert reset (let the CPU run) */
+	err = emi62_set_reset(dev,0);
+
+	/* 2. We upload the FPGA firmware into the EMI
+	 * Note: collect up to 1023 (yes!) bytes and send them with
+	 * a single request. This is _much_ faster! */
+	do {
+		i = 0;
+		addr = g_emi62bs[pos].address;
+
+		/* intel hex records are terminated with type 0 element */
+		while ((g_emi62bs[pos].type == 0) && (i + g_emi62bs[pos].length < FW_LOAD_SIZE)) {
+			memcpy(buf + i, g_emi62bs[pos].data, g_emi62bs[pos].length);
+			i += g_emi62bs[pos].length;
+			pos++;
+		}
+		err = emi62_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	} while (i > 0);
+
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi62_set_reset(dev,1);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
+	for (i=0; g_emi62_loader[i].type == 0; i++) {
+		err = emi62_writememory(dev, g_emi62_loader[i].address, g_emi62_loader[i].data, g_emi62_loader[i].length, ANCHOR_LOAD_INTERNAL);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	}
+
+	/* De-assert reset (let the CPU run) */
+	err = emi62_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
+
+/* FIXME: quick and dirty ifdefs */
+#ifdef SPDIF
+	for (i=0; g_HexSpdifFw62[i].type == 0; i++) {
+		if (!INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
+			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_EXTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				goto wraperr;
+			}
+		}
+	}
+#else /* MIDI */
+	for (i=0; g_HexMidiFw62[i].type == 0; i++) {
+		if (!INTERNAL_RAM(g_HexMidiFw62[i].address)) {
+			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_EXTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d\n", __FUNCTION__, err);
+				goto wraperr;
+				return err;
+			}
+		}
+	}
+#endif	
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi62_set_reset(dev,1);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+/* FIXME: quick and dirty ifdefs */
+#ifdef SPDIF
+	for (i=0; g_HexSpdifFw62[i].type == 0; i++) {
+		if (INTERNAL_RAM(g_HexSpdifFw62[i].address)) {
+			err = emi62_writememory(dev, g_HexSpdifFw62[i].address, g_HexSpdifFw62[i].data, g_HexSpdifFw62[i].length, ANCHOR_LOAD_INTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				goto wraperr;
+			}
+		}
+	}
+#else /* MIDI */
+	for (i=0; g_HexMidiFw62[i].type == 0; i++) {
+		if (INTERNAL_RAM(g_HexMidiFw62[i].address)) {
+			err = emi62_writememory(dev, g_HexMidiFw62[i].address, g_HexMidiFw62[i].data, g_HexMidiFw62[i].length, ANCHOR_LOAD_INTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d\n", __FUNCTION__, err);
+				goto wraperr;
+			}
+		}
+	}
+#endif
+	
+	/* De-assert reset (let the CPU run) */
+	err = emi62_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	kfree(buf);
+
+	/* return 1 to fail the driver inialization
+	 * and give real driver change to load */
+	return 1;
+
+wraperr:
+	kfree(buf);
+	dev_err(&dev->dev, "Error\n");
+	return err;
+}
+
+static __devinitdata struct usb_device_id id_table [] = {
+	{ USB_DEVICE(EMI62_VENDOR_ID, EMI62_PRODUCT_ID) },
+	{ }                                             /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static int emi62_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	dev_dbg(&intf->dev, "emi62_probe\n");
+
+	info("%s start", __FUNCTION__); 
+
+	emi62_load_firmware(dev);
+
+	/* do not return the driver context, let real audio driver do that */
+	return -EIO;
+}
+
+static void emi62_disconnect(struct usb_interface *intf)
+{
+}
+
+static struct usb_driver emi62_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "emi62 - firmware loader",
+	.probe		= emi62_probe,
+	.disconnect	= emi62_disconnect,
+	.id_table	= id_table,
+};
+
+static int __init emi62_init (void)
+{
+	int retval;
+	retval = usb_register (&emi62_driver);
+	if (retval)
+		printk(KERN_ERR "adi-emi: registration failed\n");
+	return retval;
+}
+
+static void __exit emi62_exit (void)
+{
+	usb_deregister (&emi62_driver);
+}
+
+module_init(emi62_init);
+module_exit(emi62_exit);
+
+MODULE_AUTHOR("tapio laxstrˆm");
+MODULE_DESCRIPTION("Emagic EMI 6|2m firmware loader.");
+MODULE_LICENSE("GPL");
+
+/* vi:ai:syntax=c:sw=8:ts=8:tw=80
+ */
