commit 5d62afbe9572138a25d67b8468d27ec65777824d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:58 2017 +0100

    USB: misc: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 81836e9d787f..24d841850e05 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -4,10 +4,6 @@
  * Copyright (C) 2002
  * 	Tapio Laxstr√∂m (tapio.laxstrom@iptime.fi)
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, as published by
- * the Free Software Foundation, version 2.
- * 
  * emi26.c,v 1.13 2002/03/08 13:10:26 tapio Exp
  */
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 8950fa5e973d..81836e9d787f 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* 
  * Emagic EMI 2|6 usb audio interface firmware loader.
  * Copyright (C) 2002

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index d65984dee751..8950fa5e973d 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -13,7 +13,6 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/usb.h>
 #include <linux/delay.h>
 #include <linux/firmware.h>

commit b412284b969845615e860001b2f34614ece1d576
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 20 16:53:37 2012 -0700

    USB: emi26.c: remove err() usage
    
    err() was a very old USB-specific macro that I thought had
    gone away.  This patch removes it from being used in the
    driver and uses dev_err() instead.
    
    CC: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index da97dcec1f32..d65984dee751 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -78,18 +78,14 @@ static int emi26_load_firmware (struct usb_device *dev)
 	const struct firmware *bitstream_fw = NULL;
 	const struct firmware *firmware_fw = NULL;
 	const struct ihex_binrec *rec;
-	int err;
+	int err = -ENOMEM;
 	int i;
 	__u32 addr;	/* Address to write */
 	__u8 *buf;
 
 	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
-	if (!buf) {
-		dev_err(&dev->dev, "%s - error loading firmware: error = %d\n",
-			__func__, -ENOMEM);
-		err = -ENOMEM;
+	if (!buf)
 		goto wraperr;
-	}
 
 	err = request_ihex_firmware(&loader_fw, "emi26/loader.fw", &dev->dev);
 	if (err)
@@ -111,11 +107,8 @@ static int emi26_load_firmware (struct usb_device *dev)
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
-	if (err < 0) {
-		dev_err(&dev->dev,"%s - error loading firmware: error = %d\n",
-			__func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	rec = (const struct ihex_binrec *)loader_fw->data;
 	/* 1. We need to put the loader for the FPGA into the EZ-USB */
@@ -123,19 +116,15 @@ static int emi26_load_firmware (struct usb_device *dev)
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 		rec = ihex_next_binrec(rec);
 	}
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI
@@ -153,18 +142,14 @@ static int emi26_load_firmware (struct usb_device *dev)
 			rec = ihex_next_binrec(rec);
 		}
 		err = emi26_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 	} while (rec);
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
 	for (rec = (const struct ihex_binrec *)loader_fw->data;
@@ -172,19 +157,15 @@ static int emi26_load_firmware (struct usb_device *dev)
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
-		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __func__, err);
+		if (err < 0)
 			goto wraperr;
-		}
 	}
 	msleep(250);	/* let device settle */
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
@@ -194,19 +175,15 @@ static int emi26_load_firmware (struct usb_device *dev)
 			err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 						rec->data, be16_to_cpu(rec->len),
 						ANCHOR_LOAD_EXTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __func__, err);
+			if (err < 0)
 				goto wraperr;
-			}
 		}
 	}
-	
+
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
@@ -214,19 +191,15 @@ static int emi26_load_firmware (struct usb_device *dev)
 			err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 						rec->data, be16_to_cpu(rec->len),
 						ANCHOR_LOAD_INTERNAL);
-			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __func__, err);
+			if (err < 0)
 				goto wraperr;
-			}
 		}
 	}
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
-	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __func__, err);
+	if (err < 0)
 		goto wraperr;
-	}
 	msleep(250);	/* let device settle */
 
 	/* return 1 to fail the driver inialization
@@ -234,6 +207,10 @@ static int emi26_load_firmware (struct usb_device *dev)
 	err = 1;
 
 wraperr:
+	if (err < 0)
+		dev_err(&dev->dev,"%s - error loading firmware: error = %d\n",
+			__func__, err);
+
 	release_firmware(loader_fw);
 	release_firmware(bitstream_fw);
 	release_firmware(firmware_fw);

commit 55305afc30529143bdb5928b2154dccdf073acd5
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Jan 10 15:43:08 2012 -0800

    drivers/usb/misc/emi26.c & emi62.c: fix warnings
    
    drivers/usb/misc/emi26.c:40: warning: 'emi26_init' declared 'static' but never defined
    drivers/usb/misc/emi26.c:41: warning: 'emi26_exit' declared 'static' but never defined
    drivers/usb/misc/emi62.c:49: warning: 'emi62_init' declared 'static' but never defined
    drivers/usb/misc/emi62.c:50: warning: 'emi62_exit' declared 'static' but never defined
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index d9b6a0355443..da97dcec1f32 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -37,9 +37,6 @@ static int emi26_set_reset(struct usb_device *dev, unsigned char reset_bit);
 static int emi26_load_firmware (struct usb_device *dev);
 static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id);
 static void emi26_disconnect(struct usb_interface *intf);
-static int __init emi26_init (void);
-static void __exit emi26_exit (void);
-
 
 /* thanks to drivers/usb/serial/keyspan_pda.c code */
 static int emi26_writememory (struct usb_device *dev, int address,

commit 65db43054065790a75291b0834657445fea2cf56
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 18 09:34:02 2011 -0800

    USB: convert drivers/usb/* to use module_usb_driver()
    
    This converts the drivers in drivers/usb/* to use the
    module_usb_driver() macro which makes the code smaller and a bit
    simpler.
    
    Added bonus is that it removes some unneeded kernel log messages about
    drivers loading and/or unloading.
    
    Cc: Simon Arlott <cxacru@fire.lp0.eu>
    Cc: Duncan Sands <duncan.sands@free.fr>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Stanislaw Gruszka <stf_xl@wp.pl>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Juergen Stuber <starblue@users.sourceforge.net>
    Cc: Cesar Miquel <miquel@df.uba.ar>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Michael Hund <mhund@ld-didactic.de>
    Cc: Zack Parsons <k3bacon@gmail.com>
    Cc: Melchior FRANZ <mfranz@aon.at>
    Cc: Tomoki Sekiyama <tomoki.sekiyama@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index a6521c95f683..d9b6a0355443 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -276,18 +276,7 @@ static struct usb_driver emi26_driver = {
 	.id_table	= id_table,
 };
 
-static int __init emi26_init (void)
-{
-	return usb_register(&emi26_driver);
-}
-
-static void __exit emi26_exit (void)
-{
-	usb_deregister (&emi26_driver);
-}
-
-module_init(emi26_init);
-module_exit(emi26_exit);
+module_usb_driver(emi26_driver);
 
 MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 2|6 firmware loader.");

commit 33b9e16243fd69493be3ddda7be73226c8be586a
Author: N√©meth M√°rton <nm127@freemail.hu>
Date:   Sun Jan 10 15:34:45 2010 +0100

    USB misc: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: N√©meth M√°rton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 879a980ca8c4..a6521c95f683 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -245,7 +245,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	return err;
 }
 
-static struct usb_device_id id_table [] = {
+static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(EMI26_VENDOR_ID, EMI26_PRODUCT_ID) },
 	{ USB_DEVICE(EMI26_VENDOR_ID, EMI26B_PRODUCT_ID) },
 	{ }                                             /* Terminating entry */

commit 327d74f6b65ddc8a042c43c11fdd4be0bb354668
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Sun Jan 4 13:25:13 2009 +0100

    USB: emi26: fix oops on load
    
    Fix oops introduced by commit ae93a55bf948753de0bb8e43fa9c027f786abb05
    (emi26: use request_firmware()):
    
    usb 1-1: new full speed USB device using uhci_hcd and address 2
    usb 1-1: configuration #1 chosen from 1 choice
    emi26 - firmware loader 1-1:1.0: emi26_probe start
    usb 1-1: firmware: requesting emi26/loader.fw
    usb 1-1: firmware: requesting emi26/bitstream.fw
    usb 1-1: firmware: requesting emi26/firmware.fw
    usb 1-1: emi26_set_reset - 1
    usb 1-1: emi26_set_reset - 0
    BUG: unable to handle kernel NULL pointer dereference at 00000000
    IP: [<f80dc487>] emi26_probe+0x2f7/0x620 [emi26]
    *pde = 00000000
    Oops: 0000 [#1] SMP
    last sysfs file: /sys/devices/pci0000:00/0000:00:1d.0/usb1/1-1/firmware/1-1/loading
    Modules linked in: emi26(+) ipv6 cpufreq_ondemand coretemp arc4 ecb iwl3945 irtty_sir sir_dev nsc_ircc ehci_hcd uhci_hcd mac80211 irda usbcore snd_hda_intel thinkpad_acpi rfkill hwmon led_class e1000e snd_pcm cfg80211 snd_timer crc_ccitt snd snd_page_alloc aes_generic
    
    Pid: 5082, comm: modprobe Not tainted (2.6.28 #2) 17023QG
    EIP: 0060:[<f80dc487>] EFLAGS: 00010206 CPU: 0
    EIP is at emi26_probe+0x2f7/0x620 [emi26]
    EAX: 0000015c EBX: 00000000 ECX: c1ffd9c0 EDX: 00000000
    ESI: 0000015c EDI: f6bb215c EBP: f6bb0400 ESP: f00ebcfc
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    Process modprobe (pid: 5082, ti=f00ea000 task=f5c7c700 task.ti=f00ea000)
    Stack:
     0000015c 000000a5 f6a67cb8 f80dc7e0 c01c6262 fbef2986 f6bb2000 00008fe0
     0000015c f715f748 f715f740 f715f738 f715f748 f6a67c00 f80dd040 f80dcfc0
     f6bb0400 fbacb290 f6a67c94 fbae0160 c01c70bf 00000000 f6a67c1c 00000000
    Call Trace:
     [<c01c6262>] sysfs_add_one+0x12/0x50
     [<fbacb290>] usb_probe_interface+0xa0/0x140 [usbcore]
     [<c01c70bf>] sysfs_create_link+0xf/0x20
     [<c02dead2>] driver_probe_device+0x82/0x180
     [<fbac9eeb>] usb_match_id+0x3b/0x50 [usbcore]
     [<c02dec4e>] __driver_attach+0x7e/0x80
     [<c02de27a>] bus_for_each_dev+0x3a/0x60
     [<c02de956>] driver_attach+0x16/0x20
     [<c02debd0>] __driver_attach+0x0/0x80
     [<c02de7b1>] bus_add_driver+0x1a1/0x220
     [<c02dee4d>] driver_register+0x4d/0x120
     [<c024e622>] idr_get_empty_slot+0xf2/0x290
     [<fbacab71>] usb_register_driver+0x81/0x100 [usbcore]
     [<f806c000>] emi26_init+0x0/0x14 [emi26]
     [<c0101126>] do_one_initcall+0x36/0x1b0
     [<c01c5e70>] sysfs_ilookup_test+0x0/0x10
     [<c0197a61>] ifind+0x31/0x90
     [<c01c6229>] __sysfs_add_one+0x59/0x80
     [<c01c64e4>] sysfs_addrm_finish+0x14/0x1c0
     [<c0175ca3>] __vunmap+0xa3/0xd0
     [<c014b854>] load_module+0x1544/0x1640
     [<c014b9d7>] sys_init_module+0x87/0x1b0
     [<c0187f41>] sys_read+0x41/0x70
     [<c01032a5>] sysenter_do_call+0x12/0x21
     [<c03d0000>] wait_for_common+0x40/0x110
    Code: 66 c1 e8 08 66 09 d0 75 a5 31 d2 89 e8 e8 72 fc ff ff 85 c0 0f 88 9a 02 00 00 b8 fa 00 00 00 e8 30 46 05 c8 8b 74 24 28 8b 5e 04 <8b> 03 89 44 24 1c 0f c8 89 44 24 1c 0f b7 4b 04 c7 44 24 20 00
    EIP: [<f80dc487>] emi26_probe+0x2f7/0x620 [emi26] SS:ESP 0068:f00ebcfc
    ---[ end trace 2eefa13825431230 ]---
    
    After the last "package" of firmware data is sent to the device, we dereference
    NULL pointer (on access to rec->addr). Fix it.
    
    Reported--by: David Flatz <david@upcs.at>
    Tested-by: David Flatz <david@upcs.at>
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: stable <stable@kernel.org> [2.6.27, 2.6.28]
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index e762beb5f3c6..879a980ca8c4 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -160,7 +160,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
-	} while (i > 0);
+	} while (rec);
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);

commit fd3f1917e345d852ef9ae36178719f4e639f70ae
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 14 09:37:34 2008 -0700

    USB: remove err() macro from usb misc drivers
    
    USB should not be having it's own printk macros, so remove err() and
    use the system-wide standard of dev_err() wherever possible.  In the
    few places that will not work out, use a basic printk().
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 1ee72055f468..e762beb5f3c6 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -50,7 +50,7 @@ static int emi26_writememory (struct usb_device *dev, int address,
 	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
 
 	if (!buffer) {
-		err("emi26: kmalloc(%d) failed.", length);
+		dev_err(&dev->dev, "kmalloc(%d) failed.\n", length);
 		return -ENOMEM;
 	}
 	/* Note: usb_control_msg returns negative value on error or length of the
@@ -68,7 +68,7 @@ static int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)
 	/* printk(KERN_DEBUG "%s - %d", __func__, reset_bit); */
 	response = emi26_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
-		err("emi26: set_reset (%d) failed", reset_bit);
+		dev_err(&dev->dev, "set_reset (%d) failed\n", reset_bit);
 	}
 	return response;
 }
@@ -88,7 +88,8 @@ static int emi26_load_firmware (struct usb_device *dev)
 
 	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
 	if (!buf) {
-		err( "%s - error loading firmware: error = %d", __func__, -ENOMEM);
+		dev_err(&dev->dev, "%s - error loading firmware: error = %d\n",
+			__func__, -ENOMEM);
 		err = -ENOMEM;
 		goto wraperr;
 	}
@@ -106,14 +107,16 @@ static int emi26_load_firmware (struct usb_device *dev)
 				    &dev->dev);
 	if (err) {
 	nofw:
-		err( "%s - request_firmware() failed", __func__);
+		dev_err(&dev->dev, "%s - request_firmware() failed\n",
+			__func__);
 		goto wraperr;
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
 	if (err < 0) {
-		err( "%s - error loading firmware: error = %d", __func__, err);
+		dev_err(&dev->dev,"%s - error loading firmware: error = %d\n",
+			__func__, err);
 		goto wraperr;
 	}
 

commit 1b29a375fb0b79a11a2d18e7bf5f6da422a35025
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/misc drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 4b994a0cd272..1ee72055f468 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -64,7 +64,7 @@ static int emi26_writememory (struct usb_device *dev, int address,
 static int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)
 {
 	int response;
-	info("%s - %d", __func__, reset_bit);
+	dev_info(&dev->dev, "%s - %d\n", __func__, reset_bit);
 	/* printk(KERN_DEBUG "%s - %d", __func__, reset_bit); */
 	response = emi26_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
@@ -254,7 +254,7 @@ static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *i
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 
-	info("%s start", __func__);
+	dev_info(&intf->dev, "%s start\n", __func__);
 
 	emi26_load_firmware(dev);
 

commit ae93a55bf948753de0bb8e43fa9c027f786abb05
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri May 30 16:19:39 2008 +0300

    emi26: use request_firmware()
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 4b9dc81b8453..4b994a0cd272 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -16,18 +16,8 @@
 #include <linux/init.h>
 #include <linux/usb.h>
 #include <linux/delay.h>
-
-#define MAX_INTEL_HEX_RECORD_LENGTH 16
-typedef struct _INTEL_HEX_RECORD
-{
-	__u32	length;
-	__u32	address;
-	__u32	type;
-	__u8	data[MAX_INTEL_HEX_RECORD_LENGTH];
-} INTEL_HEX_RECORD, *PINTEL_HEX_RECORD;
-
-/* include firmware (variables) */
-#include "emi26_fw.h"
+#include <linux/firmware.h>
+#include <linux/ihex.h>
 
 #define EMI26_VENDOR_ID 		0x086a  /* Emagic Soft-und Hardware GmBH */
 #define EMI26_PRODUCT_ID		0x0100	/* EMI 2|6 without firmware */
@@ -40,7 +30,9 @@ typedef struct _INTEL_HEX_RECORD
 #define CPUCS_REG		0x7F92  /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */ 
 #define INTERNAL_RAM(address)   (address <= MAX_INTERNAL_ADDRESS)
 
-static int emi26_writememory( struct usb_device *dev, int address, unsigned char *data, int length, __u8 bRequest);
+static int emi26_writememory( struct usb_device *dev, int address,
+			      const unsigned char *data, int length,
+			      __u8 bRequest);
 static int emi26_set_reset(struct usb_device *dev, unsigned char reset_bit);
 static int emi26_load_firmware (struct usb_device *dev);
 static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id);
@@ -50,7 +42,9 @@ static void __exit emi26_exit (void);
 
 
 /* thanks to drivers/usb/serial/keyspan_pda.c code */
-static int emi26_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
+static int emi26_writememory (struct usb_device *dev, int address,
+			      const unsigned char *data, int length,
+			      __u8 request)
 {
 	int result;
 	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
@@ -83,9 +77,12 @@ static int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)
 
 static int emi26_load_firmware (struct usb_device *dev)
 {
+	const struct firmware *loader_fw = NULL;
+	const struct firmware *bitstream_fw = NULL;
+	const struct firmware *firmware_fw = NULL;
+	const struct ihex_binrec *rec;
 	int err;
 	int i;
-	int pos = 0;	/* Position in hex record */
 	__u32 addr;	/* Address to write */
 	__u8 *buf;
 
@@ -96,6 +93,23 @@ static int emi26_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
+	err = request_ihex_firmware(&loader_fw, "emi26/loader.fw", &dev->dev);
+	if (err)
+		goto nofw;
+
+	err = request_ihex_firmware(&bitstream_fw, "emi26/bitstream.fw",
+				    &dev->dev);
+	if (err)
+		goto nofw;
+
+	err = request_ihex_firmware(&firmware_fw, "emi26/firmware.fw",
+				    &dev->dev);
+	if (err) {
+	nofw:
+		err( "%s - request_firmware() failed", __func__);
+		goto wraperr;
+	}
+
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
 	if (err < 0) {
@@ -103,13 +117,17 @@ static int emi26_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
+	rec = (const struct ihex_binrec *)loader_fw->data;
 	/* 1. We need to put the loader for the FPGA into the EZ-USB */
-	for (i=0; g_Loader[i].type == 0; i++) {
-		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
+	while (rec) {
+		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
+					rec->data, be16_to_cpu(rec->len),
+					ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		rec = ihex_next_binrec(rec);
 	}
 
 	/* De-assert reset (let the CPU run) */
@@ -123,15 +141,16 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* 2. We upload the FPGA firmware into the EMI
 	 * Note: collect up to 1023 (yes!) bytes and send them with
 	 * a single request. This is _much_ faster! */
+	rec = (const struct ihex_binrec *)bitstream_fw->data;
 	do {
 		i = 0;
-		addr = g_bitstream[pos].address;
+		addr = be32_to_cpu(rec->addr);
 
 		/* intel hex records are terminated with type 0 element */
-		while ((g_bitstream[pos].type == 0) && (i + g_bitstream[pos].length < FW_LOAD_SIZE)) {
-			memcpy(buf + i, g_bitstream[pos].data, g_bitstream[pos].length);
-			i += g_bitstream[pos].length;
-			pos++;
+		while (rec && (i + be16_to_cpu(rec->len) < FW_LOAD_SIZE)) {
+			memcpy(buf + i, rec->data, be16_to_cpu(rec->len));
+			i += be16_to_cpu(rec->len);
+			rec = ihex_next_binrec(rec);
 		}
 		err = emi26_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
 		if (err < 0) {
@@ -148,8 +167,11 @@ static int emi26_load_firmware (struct usb_device *dev)
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (i=0; g_Loader[i].type == 0; i++) {
-		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
+	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
+					rec->data, be16_to_cpu(rec->len),
+					ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
@@ -165,9 +187,13 @@ static int emi26_load_firmware (struct usb_device *dev)
 	}
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
-	for (i=0; g_Firmware[i].type == 0; i++) {
-		if (!INTERNAL_RAM(g_Firmware[i].address)) {
-			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_EXTERNAL);
+
+	for (rec = (const struct ihex_binrec *)firmware_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
+			err = emi26_writememory(dev, be32_to_cpu(rec->addr),
+						rec->data, be16_to_cpu(rec->len),
+						ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
 				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
@@ -182,9 +208,12 @@ static int emi26_load_firmware (struct usb_device *dev)
 		goto wraperr;
 	}
 
-	for (i=0; g_Firmware[i].type == 0; i++) {
-		if (INTERNAL_RAM(g_Firmware[i].address)) {
-			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_INTERNAL);
+	for (rec = (const struct ihex_binrec *)firmware_fw->data;
+	     rec; rec = ihex_next_binrec(rec)) {
+		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
+			err = emi26_writememory(dev, be32_to_cpu(rec->addr),
+						rec->data, be16_to_cpu(rec->len),
+						ANCHOR_LOAD_INTERNAL);
 			if (err < 0) {
 				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
@@ -205,6 +234,10 @@ static int emi26_load_firmware (struct usb_device *dev)
 	err = 1;
 
 wraperr:
+	release_firmware(loader_fw);
+	release_firmware(bitstream_fw);
+	release_firmware(firmware_fw);
+
 	kfree(buf);
 	return err;
 }
@@ -257,5 +290,8 @@ MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 2|6 firmware loader.");
 MODULE_LICENSE("GPL");
 
+MODULE_FIRMWARE("emi26/loader.fw");
+MODULE_FIRMWARE("emi26/bitstream.fw");
+MODULE_FIRMWARE("emi26/firmware.fw");
 /* vi:ai:syntax=c:sw=8:ts=8:tw=80
  */

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 4a09b87bdd28..4b9dc81b8453 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -70,8 +70,8 @@ static int emi26_writememory (struct usb_device *dev, int address, unsigned char
 static int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)
 {
 	int response;
-	info("%s - %d", __FUNCTION__, reset_bit);
-	/* printk(KERN_DEBUG "%s - %d", __FUNCTION__, reset_bit); */
+	info("%s - %d", __func__, reset_bit);
+	/* printk(KERN_DEBUG "%s - %d", __func__, reset_bit); */
 	response = emi26_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
 	if (response < 0) {
 		err("emi26: set_reset (%d) failed", reset_bit);
@@ -91,7 +91,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 
 	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
 	if (!buf) {
-		err( "%s - error loading firmware: error = %d", __FUNCTION__, -ENOMEM);
+		err( "%s - error loading firmware: error = %d", __func__, -ENOMEM);
 		err = -ENOMEM;
 		goto wraperr;
 	}
@@ -99,7 +99,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
 	if (err < 0) {
-		err( "%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err( "%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -107,7 +107,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	for (i=0; g_Loader[i].type == 0; i++) {
 		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	}
@@ -115,7 +115,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 	msleep(250);	/* let device settle */
@@ -135,7 +135,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 		}
 		err = emi26_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	} while (i > 0);
@@ -143,7 +143,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -151,7 +151,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	for (i=0; g_Loader[i].type == 0; i++) {
 		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
 		if (err < 0) {
-			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
 	}
@@ -160,7 +160,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -169,7 +169,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 		if (!INTERNAL_RAM(g_Firmware[i].address)) {
 			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_EXTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
@@ -178,7 +178,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi26_set_reset(dev,1);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 
@@ -186,7 +186,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 		if (INTERNAL_RAM(g_Firmware[i].address)) {
 			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_INTERNAL);
 			if (err < 0) {
-				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				err("%s - error loading firmware: error = %d", __func__, err);
 				goto wraperr;
 			}
 		}
@@ -195,7 +195,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
 	if (err < 0) {
-		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		err("%s - error loading firmware: error = %d", __func__, err);
 		goto wraperr;
 	}
 	msleep(250);	/* let device settle */
@@ -221,7 +221,7 @@ static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *i
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 
-	info("%s start", __FUNCTION__); 
+	info("%s start", __func__);
 
 	emi26_load_firmware(dev);
 

commit cf4cf0bb89cbff95c5be8f8d3c68e55f38f94ba7
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Oct 25 15:38:44 2007 +0200

    USB: missing error check in emi26
    
    this drivers lacks an error check.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index cd137577bb2d..4a09b87bdd28 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -114,6 +114,10 @@ static int emi26_load_firmware (struct usb_device *dev)
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
 	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI

commit 96de0e252cedffad61b3cb5e05662c591898e69a
Author: Jan Engelhardt <jengelh@gmx.de>
Date:   Fri Oct 19 23:21:04 2007 +0200

    Convert files to UTF-8 and some cleanups
    
    * Convert files to UTF-8.
    
      * Also correct some people's names
        (one example is Ei√üfeldt, which was found in a source file.
        Given that the author used an √ü at all in a source file
        indicates that the real name has in fact a '√ü' and not an 'ss',
        which is commonly used as a substitute for '√ü' when limited to
        7bit.)
    
      * Correct town names (Goettingen -> G√∂ttingen)
    
      * Update Eberhard M√∂nkeberg's address (http://lkml.org/lkml/2007/1/8/313)
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 5c0a26cbd128..cd137577bb2d 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -1,7 +1,7 @@
 /* 
  * Emagic EMI 2|6 usb audio interface firmware loader.
  * Copyright (C) 2002
- * 	Tapio Laxstrˆm (tapio.laxstrom@iptime.fi)
+ * 	Tapio Laxstr√∂m (tapio.laxstrom@iptime.fi)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, as published by
@@ -249,7 +249,7 @@ static void __exit emi26_exit (void)
 module_init(emi26_init);
 module_exit(emi26_exit);
 
-MODULE_AUTHOR("tapio laxstrˆm");
+MODULE_AUTHOR("Tapio Laxstr√∂m");
 MODULE_DESCRIPTION("Emagic EMI 2|6 firmware loader.");
 MODULE_LICENSE("GPL");
 

commit 5d7efe5b3768bf53df9b87380ea68baacf11f933
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Thu Oct 26 21:06:24 2006 +0200

    USB: kmemdup() cleanup in drivers/usb/
    
    replace open coded kmemdup() to save some screen space,
    and allow inlining/not inlining to be triggered by gcc.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 1fd9cb85f4ca..5c0a26cbd128 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -53,13 +53,12 @@ static void __exit emi26_exit (void);
 static int emi26_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
 {
 	int result;
-	unsigned char *buffer =  kmalloc (length, GFP_KERNEL);
+	unsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);
 
 	if (!buffer) {
 		err("emi26: kmalloc(%d) failed.", length);
 		return -ENOMEM;
 	}
-	memcpy (buffer, data, length);
 	/* Note: usb_control_msg returns negative value on error or length of the
 	 * 		 data that was written! */
 	result = usb_control_msg (dev, usb_sndctrlpipe(dev, 0), request, 0x40, address, 0, buffer, length, 300);

commit 16c23f7d88cbcce491f9370b2846fad66e8ef319
Author: Monty <xiphmont@xiph.org>
Date:   Tue May 9 12:37:22 2006 -0700

    [PATCH] USB: Emagic USB firmware loading fixes
    
    It's become apparent as machines get faster that the emagic kernel firmware
    loaders (based on the ezusb loader) have a reset race.  a 400MHz TiBook
    never tripped it, but a 2GHz Pentium M seems to hit it about 30% of the
    time.  The bug is seen as a hung USB box and the kernel error:
    
    drivers/usb/misc/emi62.c: emi62_load_firmware - error loading firmware:
    error = -110
    
    The patch below inserts a delay after deasserting reset to allow the box to
    settle before a new command is issued.  This affects only device startup.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index 3824df33094e..1fd9cb85f4ca 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/usb.h>
+#include <linux/delay.h>
 
 #define MAX_INTEL_HEX_RECORD_LENGTH 16
 typedef struct _INTEL_HEX_RECORD
@@ -114,6 +115,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
+	msleep(250);	/* let device settle */
 
 	/* 2. We upload the FPGA firmware into the EMI
 	 * Note: collect up to 1023 (yes!) bytes and send them with
@@ -150,6 +152,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 			goto wraperr;
 		}
 	}
+	msleep(250);	/* let device settle */
 
 	/* De-assert reset (let the CPU run) */
 	err = emi26_set_reset(dev,0);
@@ -192,6 +195,7 @@ static int emi26_load_firmware (struct usb_device *dev)
 		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
 		goto wraperr;
 	}
+	msleep(250);	/* let device settle */
 
 	/* return 1 to fail the driver inialization
 	 * and give real driver change to load */

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
index c8155209bf4b..3824df33094e 100644
--- a/drivers/usb/misc/emi26.c
+++ b/drivers/usb/misc/emi26.c
@@ -227,7 +227,6 @@ static void emi26_disconnect(struct usb_interface *intf)
 }
 
 static struct usb_driver emi26_driver = {
-	.owner		= THIS_MODULE,
 	.name		= "emi26 - firmware loader",
 	.probe		= emi26_probe,
 	.disconnect	= emi26_disconnect,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/misc/emi26.c b/drivers/usb/misc/emi26.c
new file mode 100644
index 000000000000..c8155209bf4b
--- /dev/null
+++ b/drivers/usb/misc/emi26.c
@@ -0,0 +1,255 @@
+/* 
+ * Emagic EMI 2|6 usb audio interface firmware loader.
+ * Copyright (C) 2002
+ * 	Tapio Laxstrˆm (tapio.laxstrom@iptime.fi)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, as published by
+ * the Free Software Foundation, version 2.
+ * 
+ * emi26.c,v 1.13 2002/03/08 13:10:26 tapio Exp
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+
+#define MAX_INTEL_HEX_RECORD_LENGTH 16
+typedef struct _INTEL_HEX_RECORD
+{
+	__u32	length;
+	__u32	address;
+	__u32	type;
+	__u8	data[MAX_INTEL_HEX_RECORD_LENGTH];
+} INTEL_HEX_RECORD, *PINTEL_HEX_RECORD;
+
+/* include firmware (variables) */
+#include "emi26_fw.h"
+
+#define EMI26_VENDOR_ID 		0x086a  /* Emagic Soft-und Hardware GmBH */
+#define EMI26_PRODUCT_ID		0x0100	/* EMI 2|6 without firmware */
+#define EMI26B_PRODUCT_ID		0x0102	/* EMI 2|6 without firmware */
+
+#define ANCHOR_LOAD_INTERNAL	0xA0	/* Vendor specific request code for Anchor Upload/Download (This one is implemented in the core) */
+#define ANCHOR_LOAD_EXTERNAL	0xA3	/* This command is not implemented in the core. Requires firmware */
+#define ANCHOR_LOAD_FPGA	0xA5	/* This command is not implemented in the core. Requires firmware. Emagic extension */
+#define MAX_INTERNAL_ADDRESS	0x1B3F	/* This is the highest internal RAM address for the AN2131Q */
+#define CPUCS_REG		0x7F92  /* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */ 
+#define INTERNAL_RAM(address)   (address <= MAX_INTERNAL_ADDRESS)
+
+static int emi26_writememory( struct usb_device *dev, int address, unsigned char *data, int length, __u8 bRequest);
+static int emi26_set_reset(struct usb_device *dev, unsigned char reset_bit);
+static int emi26_load_firmware (struct usb_device *dev);
+static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id);
+static void emi26_disconnect(struct usb_interface *intf);
+static int __init emi26_init (void);
+static void __exit emi26_exit (void);
+
+
+/* thanks to drivers/usb/serial/keyspan_pda.c code */
+static int emi26_writememory (struct usb_device *dev, int address, unsigned char *data, int length, __u8 request)
+{
+	int result;
+	unsigned char *buffer =  kmalloc (length, GFP_KERNEL);
+
+	if (!buffer) {
+		err("emi26: kmalloc(%d) failed.", length);
+		return -ENOMEM;
+	}
+	memcpy (buffer, data, length);
+	/* Note: usb_control_msg returns negative value on error or length of the
+	 * 		 data that was written! */
+	result = usb_control_msg (dev, usb_sndctrlpipe(dev, 0), request, 0x40, address, 0, buffer, length, 300);
+	kfree (buffer);
+	return result;
+}
+
+/* thanks to drivers/usb/serial/keyspan_pda.c code */
+static int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)
+{
+	int response;
+	info("%s - %d", __FUNCTION__, reset_bit);
+	/* printk(KERN_DEBUG "%s - %d", __FUNCTION__, reset_bit); */
+	response = emi26_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);
+	if (response < 0) {
+		err("emi26: set_reset (%d) failed", reset_bit);
+	}
+	return response;
+}
+
+#define FW_LOAD_SIZE		1023
+
+static int emi26_load_firmware (struct usb_device *dev)
+{
+	int err;
+	int i;
+	int pos = 0;	/* Position in hex record */
+	__u32 addr;	/* Address to write */
+	__u8 *buf;
+
+	buf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);
+	if (!buf) {
+		err( "%s - error loading firmware: error = %d", __FUNCTION__, -ENOMEM);
+		err = -ENOMEM;
+		goto wraperr;
+	}
+
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi26_set_reset(dev,1);
+	if (err < 0) {
+		err( "%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 1. We need to put the loader for the FPGA into the EZ-USB */
+	for (i=0; g_Loader[i].type == 0; i++) {
+		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	}
+
+	/* De-assert reset (let the CPU run) */
+	err = emi26_set_reset(dev,0);
+
+	/* 2. We upload the FPGA firmware into the EMI
+	 * Note: collect up to 1023 (yes!) bytes and send them with
+	 * a single request. This is _much_ faster! */
+	do {
+		i = 0;
+		addr = g_bitstream[pos].address;
+
+		/* intel hex records are terminated with type 0 element */
+		while ((g_bitstream[pos].type == 0) && (i + g_bitstream[pos].length < FW_LOAD_SIZE)) {
+			memcpy(buf + i, g_bitstream[pos].data, g_bitstream[pos].length);
+			i += g_bitstream[pos].length;
+			pos++;
+		}
+		err = emi26_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	} while (i > 0);
+
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi26_set_reset(dev,1);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
+	for (i=0; g_Loader[i].type == 0; i++) {
+		err = emi26_writememory(dev, g_Loader[i].address, g_Loader[i].data, g_Loader[i].length, ANCHOR_LOAD_INTERNAL);
+		if (err < 0) {
+			err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+			goto wraperr;
+		}
+	}
+
+	/* De-assert reset (let the CPU run) */
+	err = emi26_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
+	for (i=0; g_Firmware[i].type == 0; i++) {
+		if (!INTERNAL_RAM(g_Firmware[i].address)) {
+			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_EXTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				goto wraperr;
+			}
+		}
+	}
+	
+	/* Assert reset (stop the CPU in the EMI) */
+	err = emi26_set_reset(dev,1);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	for (i=0; g_Firmware[i].type == 0; i++) {
+		if (INTERNAL_RAM(g_Firmware[i].address)) {
+			err = emi26_writememory(dev, g_Firmware[i].address, g_Firmware[i].data, g_Firmware[i].length, ANCHOR_LOAD_INTERNAL);
+			if (err < 0) {
+				err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+				goto wraperr;
+			}
+		}
+	}
+
+	/* De-assert reset (let the CPU run) */
+	err = emi26_set_reset(dev,0);
+	if (err < 0) {
+		err("%s - error loading firmware: error = %d", __FUNCTION__, err);
+		goto wraperr;
+	}
+
+	/* return 1 to fail the driver inialization
+	 * and give real driver change to load */
+	err = 1;
+
+wraperr:
+	kfree(buf);
+	return err;
+}
+
+static struct usb_device_id id_table [] = {
+	{ USB_DEVICE(EMI26_VENDOR_ID, EMI26_PRODUCT_ID) },
+	{ USB_DEVICE(EMI26_VENDOR_ID, EMI26B_PRODUCT_ID) },
+	{ }                                             /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+
+	info("%s start", __FUNCTION__); 
+
+	emi26_load_firmware(dev);
+
+	/* do not return the driver context, let real audio driver do that */
+	return -EIO;
+}
+
+static void emi26_disconnect(struct usb_interface *intf)
+{
+}
+
+static struct usb_driver emi26_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "emi26 - firmware loader",
+	.probe		= emi26_probe,
+	.disconnect	= emi26_disconnect,
+	.id_table	= id_table,
+};
+
+static int __init emi26_init (void)
+{
+	return usb_register(&emi26_driver);
+}
+
+static void __exit emi26_exit (void)
+{
+	usb_deregister (&emi26_driver);
+}
+
+module_init(emi26_init);
+module_exit(emi26_exit);
+
+MODULE_AUTHOR("tapio laxstrˆm");
+MODULE_DESCRIPTION("Emagic EMI 2|6 firmware loader.");
+MODULE_LICENSE("GPL");
+
+/* vi:ai:syntax=c:sw=8:ts=8:tw=80
+ */
