commit 98827105d8c32fffd22d963c493fc3f61388e939
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:32 2020 -0600

    usb: musb: Get rid of omap2430_musb_set_vbus()
    
    Now that we've removed direct calls from interrupt handler to
    omap2430_musb_set_vbus(), let's make things less confusing and
    configure VBUS directly in omap_musb_set_mailbox().
    
    We have omap_musb_set_mailbox() called from the PHYs, and that's
    all we need.
    
    Note that we can now also drop the check for MUSB_INTERFACE_UTMI,
    we've been already calling otg_set_vbus(musb->xceiv->otg, 0)
    unconditionally via omap2430_musb_set_vbus() and we should only
    need to call it once.
    
    And we want to disable VBUS unconditionally on disconnect even
    without musb->gadget_driver, so let's drop that check too.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-11-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index bc5810e14ebb..d62c78b97cad 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -38,42 +38,6 @@ struct omap2430_glue {
 
 static struct omap2430_glue	*_glue;
 
-/*
- * HDRC controls CPEN, but beware current surges during device connect.
- * They can trigger transient overcurrent conditions that must be ignored.
- *
- * Note that we're skipping A_WAIT_VFALL -> A_IDLE and jumping right to B_IDLE
- * as set by musb_set_peripheral().
- */
-static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
-{
-	struct usb_otg *otg = musb->xceiv->otg;
-	int error;
-
-	if (is_on) {
-		switch (musb->xceiv->otg->state) {
-		case OTG_STATE_A_IDLE:
-			error = musb_set_host(musb);
-			if (!error) {
-				musb->xceiv->otg->state =
-						OTG_STATE_A_WAIT_VRISE;
-				otg_set_vbus(otg, 1);
-			}
-			break;
-		default:
-			otg_set_vbus(otg, 1);
-			break;
-		}
-	} else {
-		error = musb_set_peripheral(musb);
-		otg_set_vbus(otg, 0);
-	}
-
-	dev_dbg(musb->controller, "VBUS %s, devctl %02x\n",
-		usb_otg_state_string(musb->xceiv->otg->state),
-		musb_readb(musb->mregs, MUSB_DEVCTL));
-}
-
 static inline void omap2430_low_level_exit(struct musb *musb)
 {
 	u32 l;
@@ -113,27 +77,42 @@ static int omap2430_musb_mailbox(enum musb_vbus_id_status status)
 	return 0;
 }
 
+/*
+ * HDRC controls CPEN, but beware current surges during device connect.
+ * They can trigger transient overcurrent conditions that must be ignored.
+ *
+ * Note that we're skipping A_WAIT_VFALL -> A_IDLE and jumping right to B_IDLE
+ * as set by musb_set_peripheral().
+ */
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
 	struct musb *musb = glue_to_musb(glue);
-	struct musb_hdrc_platform_data *pdata =
-		dev_get_platdata(musb->controller);
-	struct omap_musb_board_data *data = pdata->board_data;
+	int error;
 
 	pm_runtime_get_sync(musb->controller);
+
+	dev_dbg(musb->controller, "VBUS %s, devctl %02x\n",
+		usb_otg_state_string(musb->xceiv->otg->state),
+		musb_readb(musb->mregs, MUSB_DEVCTL));
+
 	switch (glue->status) {
 	case MUSB_ID_GROUND:
 		dev_dbg(musb->controller, "ID GND\n");
 		switch (musb->xceiv->otg->state) {
+		case OTG_STATE_A_IDLE:
+			error = musb_set_host(musb);
+			if (error)
+				break;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
+			/* Fall through */
 		case OTG_STATE_A_WAIT_VRISE:
 		case OTG_STATE_A_WAIT_BCON:
 		case OTG_STATE_A_HOST:
-		case OTG_STATE_A_IDLE:
 			/*
 			 * On multiple ID ground interrupts just keep enabling
 			 * VBUS. At least cpcap VBUS shuts down otherwise.
 			 */
-			omap2430_musb_set_vbus(musb, 1);
+			otg_set_vbus(musb->xceiv->otg, 1);
 			break;
 		default:
 			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
@@ -141,7 +120,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 			if (musb->gadget_driver) {
 				omap_control_usb_set_mode(glue->control_otghs,
 							  USB_MODE_HOST);
-				omap2430_musb_set_vbus(musb, 1);
+				otg_set_vbus(musb->xceiv->otg, 1);
 			}
 			break;
 		}
@@ -160,12 +139,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(musb->controller, "VBUS Disconnect\n");
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
-		if (musb->gadget_driver)
-			omap2430_musb_set_vbus(musb, 0);
-
-		if (data->interface_type == MUSB_INTERFACE_UTMI)
-			otg_set_vbus(musb->xceiv->otg, 0);
-
+		musb_set_peripheral(musb);
+		otg_set_vbus(musb->xceiv->otg, 0);
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
 		break;

commit 8b359cbc3cdeb6145ca096334509df2a49ebaa0e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:31 2020 -0600

    usb: musb: omap2430: Idle musb on init
    
    We want to configure musb state in omap2430_musb_enable() instead of
    omap2430_musb_init(). Otherwise musb may not idle properly until
    USB cable has been connected at least once.
    
    And we already have omap_musb_set_mailbox() configure mode with
    omap_control_usb_set_mode() so we can remove those calls from
    omap2430_musb_enable().
    
    Cc: Jacopo Mondi <jacopo@jmondi.org>
    Cc: Marcel Partap <mpartap@gmx.net>
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Michael Scott <hashcode0f@gmail.com>
    Cc: NeKit <nekit1000@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-10-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2cc54135bb8b..bc5810e14ebb 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -212,7 +212,6 @@ static int omap2430_musb_init(struct musb *musb)
 	u32 l;
 	int status = 0;
 	struct device *dev = musb->controller;
-	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 	struct musb_hdrc_platform_data *plat = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = plat->board_data;
 
@@ -268,9 +267,6 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
-	if (glue->status != MUSB_UNKNOWN)
-		omap_musb_set_mailbox(glue);
-
 	return 0;
 }
 
@@ -279,19 +275,9 @@ static void omap2430_musb_enable(struct musb *musb)
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	switch (glue->status) {
-
-	case MUSB_ID_GROUND:
-		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_HOST);
-		break;
-
-	case MUSB_VBUS_VALID:
-		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
-		break;
-
-	default:
-		break;
-	}
+	if (glue->status == MUSB_UNKNOWN)
+		glue->status = MUSB_VBUS_OFF;
+	omap_musb_set_mailbox(glue);
 }
 
 static void omap2430_musb_disable(struct musb *musb)

commit b769ae4f26e5892df70bf4d3005fe0db35c8ba7b
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:30 2020 -0600

    usb: musb: omap2430: Clean up enable and remove devctl tinkering
    
    There should be no need to tinker with devctl in enable in the SoC glue
    code. We have musb_start() to take care of handling it already.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-9-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 9c1b72a4b12f..2cc54135bb8b 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -276,33 +276,13 @@ static int omap2430_musb_init(struct musb *musb)
 
 static void omap2430_musb_enable(struct musb *musb)
 {
-	u8		devctl;
-	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
-	struct omap_musb_board_data *data = pdata->board_data;
-
 
 	switch (glue->status) {
 
 	case MUSB_ID_GROUND:
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_HOST);
-		if (data->interface_type != MUSB_INTERFACE_UTMI)
-			break;
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		/* start the session */
-		devctl |= MUSB_DEVCTL_SESSION;
-		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-		while (musb_readb(musb->mregs, MUSB_DEVCTL) &
-				MUSB_DEVCTL_BDEVICE) {
-			cpu_relax();
-
-			if (time_after(jiffies, timeout)) {
-				dev_err(dev, "configured as A device timeout");
-				break;
-			}
-		}
 		break;
 
 	case MUSB_VBUS_VALID:

commit 93dc256871297071a24f7f9ce0abfddfff15094d
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:29 2020 -0600

    usb: musb: Add musb_set_host and peripheral and use them for omap2430
    
    At least some revisions of musb core need to set devctl session bit
    in peripheral mode to force musb to host mode. And we have places
    clearing the devctl session bit.
    
    Let's add a generic function to do this, and use it for omap2430.
    This should get us a bit closer to completely removing devctl register
    tinkering in the SoC glue code.
    
    Before making use of this code for the other glue layers, things need
    to be tested carefully as there may be a approximately a 200 ms delay
    needed between powering up musb and calling musb_set_host() to avoid.
    Otherwise the system hangs at least with omap2430 glue layer.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [b-liu@ti.com: fixed "line over 80 characters" warning]
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-8-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e572ee624128..9c1b72a4b12f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -38,65 +38,38 @@ struct omap2430_glue {
 
 static struct omap2430_glue	*_glue;
 
+/*
+ * HDRC controls CPEN, but beware current surges during device connect.
+ * They can trigger transient overcurrent conditions that must be ignored.
+ *
+ * Note that we're skipping A_WAIT_VFALL -> A_IDLE and jumping right to B_IDLE
+ * as set by musb_set_peripheral().
+ */
 static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
-	struct usb_otg	*otg = musb->xceiv->otg;
-	u8		devctl;
-	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	/* HDRC controls CPEN, but beware current surges during device
-	 * connect.  They can trigger transient overcurrent conditions
-	 * that must be ignored.
-	 */
-
-	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+	struct usb_otg *otg = musb->xceiv->otg;
+	int error;
 
 	if (is_on) {
-		if (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {
-			int loops = 100;
-			/* start the session */
-			devctl |= MUSB_DEVCTL_SESSION;
-			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-			/*
-			 * Wait for the musb to set as A device to enable the
-			 * VBUS
-			 */
-			while (musb_readb(musb->mregs, MUSB_DEVCTL) &
-			       MUSB_DEVCTL_BDEVICE) {
-
-				mdelay(5);
-				cpu_relax();
-
-				if (time_after(jiffies, timeout)
-				    || loops-- <= 0) {
-					dev_err(musb->controller,
-					"configured as A device timeout");
-					break;
-				}
+		switch (musb->xceiv->otg->state) {
+		case OTG_STATE_A_IDLE:
+			error = musb_set_host(musb);
+			if (!error) {
+				musb->xceiv->otg->state =
+						OTG_STATE_A_WAIT_VRISE;
+				otg_set_vbus(otg, 1);
 			}
-
+			break;
+		default:
 			otg_set_vbus(otg, 1);
-		} else {
-			musb->is_active = 1;
-			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
-			devctl |= MUSB_DEVCTL_SESSION;
-			MUSB_HST_MODE(musb);
+			break;
 		}
 	} else {
-		musb->is_active = 0;
-
-		/* NOTE:  we're skipping A_WAIT_VFALL -> A_IDLE and
-		 * jumping right to B_IDLE...
-		 */
-
-		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
-		devctl &= ~MUSB_DEVCTL_SESSION;
-
-		MUSB_DEV_MODE(musb);
+		error = musb_set_peripheral(musb);
+		otg_set_vbus(otg, 0);
 	}
-	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
-	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
-		/* otg %3x conf %08x prcm %08x */ "\n",
+	dev_dbg(musb->controller, "VBUS %s, devctl %02x\n",
 		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }

commit 15f1122f92c02f654037d8fb98164b785207b7af
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:28 2020 -0600

    usb: musb: omap2430: Handle multiple ID ground interrupts
    
    We currently get "unhandled DISCONNECT transition" warnings from musb core
    on device disconnect as things are wrongly set to OTG_STATE_A_IDLE in
    host mode when enumerating devices. We can also get "Failed to write reg
    index" errors after enumerating.
    
    This is happening at least with cpcap phy where we get multiple ID ground
    interrupts. Looks like it's VBUS keeps timing out and needs to be kicked
    when the phy sends multiple ID ground interrupts during host mode.
    
    Cc: Jacopo Mondi <jacopo@jmondi.org>
    Cc: Marcel Partap <mpartap@gmx.net>
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Michael Scott <hashcode0f@gmail.com>
    Cc: NeKit <nekit1000@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-7-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 920862c3fc64..e572ee624128 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -151,13 +151,26 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	switch (glue->status) {
 	case MUSB_ID_GROUND:
 		dev_dbg(musb->controller, "ID GND\n");
-
-		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
-		musb->xceiv->last_event = USB_EVENT_ID;
-		if (musb->gadget_driver) {
-			omap_control_usb_set_mode(glue->control_otghs,
-				USB_MODE_HOST);
+		switch (musb->xceiv->otg->state) {
+		case OTG_STATE_A_WAIT_VRISE:
+		case OTG_STATE_A_WAIT_BCON:
+		case OTG_STATE_A_HOST:
+		case OTG_STATE_A_IDLE:
+			/*
+			 * On multiple ID ground interrupts just keep enabling
+			 * VBUS. At least cpcap VBUS shuts down otherwise.
+			 */
 			omap2430_musb_set_vbus(musb, 1);
+			break;
+		default:
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
+			musb->xceiv->last_event = USB_EVENT_ID;
+			if (musb->gadget_driver) {
+				omap_control_usb_set_mode(glue->control_otghs,
+							  USB_MODE_HOST);
+				omap2430_musb_set_vbus(musb, 1);
+			}
+			break;
 		}
 		break;
 

commit ce3ab6503ebaba976405858616d7f6094e364973
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:27 2020 -0600

    usb: musb: omap2430: Wait on enable to avoid babble
    
    We can get babble interrupt if we attempt to switch to USB host mode too
    soon after enabling musb. Let's fix the issue by waiting a bit in
    runtime_resume.
    
    Cc: Jacopo Mondi <jacopo@jmondi.org>
    Cc: Marcel Partap <mpartap@gmx.net>
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Michael Scott <hashcode0f@gmail.com>
    Cc: NeKit <nekit1000@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-6-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5c93226e0e20..920862c3fc64 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -550,6 +550,9 @@ static int omap2430_runtime_resume(struct device *dev)
 	musb_writel(musb->mregs, OTG_INTERFSEL,
 		    musb->context.otg_interfsel);
 
+	/* Wait for musb to get oriented. Otherwise we can get babble */
+	usleep_range(200000, 250000);
+
 	return 0;
 }
 

commit 91b6dec32e5c25fbdbb564d1e5af23764ec17ef1
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:26 2020 -0600

    usb: musb: omap2430: Get rid of musb .set_vbus for omap2430 glue
    
    We currently have musb_set_vbus() called from two different paths. Mostly
    it gets called from the USB PHY via omap_musb_set_mailbox(), but in some
    cases it can get also called from musb_stage0_irq() rather via .set_vbus:
    
    (musb_set_host [musb_hdrc])
    (omap2430_musb_set_vbus [omap2430])
    (musb_stage0_irq [musb_hdrc])
    (musb_interrupt [musb_hdrc])
    (omap2430_musb_interrupt [omap2430])
    
    This is racy and will not work with introducing generic helper functions
    for musb_set_host() and musb_set_peripheral(). We want to get rid of the
    busy loops in favor of usleep_range().
    
    Let's just get rid of .set_vbus for omap2430 glue layer and let the PHY
    code handle VBUS with musb_set_vbus(). Note that in the follow-up patch
    we can completely remove omap2430_musb_set_vbus(), but let's do it in a
    separate patch as this change may actually turn out to be needed as a
    fix.
    
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-5-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a3d2fef67746..5c93226e0e20 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -361,8 +361,6 @@ static const struct musb_platform_ops omap2430_ops = {
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 
-	.set_vbus	= omap2430_musb_set_vbus,
-
 	.enable		= omap2430_musb_enable,
 	.disable	= omap2430_musb_disable,
 

commit 10ac7e7757f5e264599409441362de67760ba787
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Apr 30 09:59:36 2019 -0500

    usb: musb: omap2430: Add support for idling phy when musb is idle
    
    I noticed that musb is blocking core retention for omap4 unlike for
    omap3. This is because for omap3 we have phy-twl4030-usb implement
    it's own PM runtime to handle errata "VUSB3V1 VBUS overvoltage
    debouncer not working when the PHY is powered down". That is done
    in order to keep the USB PHY powered when phy-twl4030-usb is loaded.
    
    For the other USB PHYs, we need to enable and disable the PHY based on
    musb PM runtime. With the session bit based PM runtime for musb core,
    we can now idle the USB PHY always when musb is idle.
    
    Note that adding these calls will not affect the twl4030 driver
    as it's phy functions will just query the PHY state without powering
    the PHY on or off.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b1dd81fb5f55..a3d2fef67746 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -531,6 +531,9 @@ static int omap2430_runtime_suspend(struct device *dev)
 
 	omap2430_low_level_exit(musb);
 
+	phy_power_off(musb->phy);
+	phy_exit(musb->phy);
+
 	return 0;
 }
 
@@ -542,6 +545,9 @@ static int omap2430_runtime_resume(struct device *dev)
 	if (!musb)
 		return 0;
 
+	phy_init(musb->phy);
+	phy_power_on(musb->phy);
+
 	omap2430_low_level_init(musb);
 	musb_writel(musb->mregs, OTG_INTERFSEL,
 		    musb->context.otg_interfsel);

commit d2852f2d3e6d6b9de3739f95b5cd9eab3157af37
Author: Bin Liu <b-liu@ti.com>
Date:   Mon May 21 08:42:18 2018 -0500

    usb: musb: remove references to default_a of struct usb_otg
    
    musb drivers do not use the otg fsm framework, so referencing to
    otg->default_a doesn't have any effect, so remove the references.
    
    But tusb6010 glue driver uses it locally to control the vbus power, so
    keep the references in tusb6010 only.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 3dd6e1c5e04f..b1dd81fb5f55 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -77,7 +77,6 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 			otg_set_vbus(otg, 1);
 		} else {
 			musb->is_active = 1;
-			otg->default_a = 1;
 			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			devctl |= MUSB_DEVCTL_SESSION;
 			MUSB_HST_MODE(musb);
@@ -89,7 +88,6 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		 * jumping right to B_IDLE...
 		 */
 
-		otg->default_a = 0;
 		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		devctl &= ~MUSB_DEVCTL_SESSION;
 
@@ -148,14 +146,12 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	struct musb_hdrc_platform_data *pdata =
 		dev_get_platdata(musb->controller);
 	struct omap_musb_board_data *data = pdata->board_data;
-	struct usb_otg *otg = musb->xceiv->otg;
 
 	pm_runtime_get_sync(musb->controller);
 	switch (glue->status) {
 	case MUSB_ID_GROUND:
 		dev_dbg(musb->controller, "ID GND\n");
 
-		otg->default_a = true;
 		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
@@ -168,7 +164,6 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	case MUSB_VBUS_VALID:
 		dev_dbg(musb->controller, "VBUS Connect\n");
 
-		otg->default_a = false;
 		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);

commit 5ee1787e5efb9bbc11403740df4393587c47ab65
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Apr 18 11:26:22 2018 +0200

    USB: musb: omap2430: drop non-DT support
    
    Drop support for non-DT systems, which hasn't been used by a mainline
    kernel since commit 9080b8dc761a ("ARM: OMAP2+: Remove legacy usb-host.c
    platform init code"). Specifically, since that commit usb_get_phy_dev()
    have always returned -ENODEV when looking up a legacy phy, something
    which in turn would have led to the init callback returning
    -EPROBE_DEFER indefinitely.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5d705930ef47..3dd6e1c5e04f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -239,21 +239,15 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	if (dev->parent->of_node) {
-		musb->phy = devm_phy_get(dev->parent, "usb2-phy");
-
-		/* We can't totally remove musb->xceiv as of now because
-		 * musb core uses xceiv.state and xceiv.otg. Once we have
-		 * a separate state machine to handle otg, these can be moved
-		 * out of xceiv and then we can start using the generic PHY
-		 * framework
-		 */
-		musb->xceiv = devm_usb_get_phy_by_phandle(dev->parent,
-		    "usb-phy", 0);
-	} else {
-		musb->xceiv = devm_usb_get_phy_dev(dev, 0);
-		musb->phy = devm_phy_get(dev, "usb");
-	}
+	musb->phy = devm_phy_get(dev->parent, "usb2-phy");
+
+	/* We can't totally remove musb->xceiv as of now because
+	 * musb core uses xceiv.state and xceiv.otg. Once we have
+	 * a separate state machine to handle otg, these can be moved
+	 * out of xceiv and then we can start using the generic PHY
+	 * framework
+	 */
+	musb->xceiv = devm_usb_get_phy_by_phandle(dev->parent, "usb-phy", 0);
 
 	if (IS_ERR(musb->xceiv)) {
 		status = PTR_ERR(musb->xceiv);
@@ -391,8 +385,13 @@ static int omap2430_probe(struct platform_device *pdev)
 	struct omap2430_glue		*glue;
 	struct device_node		*np = pdev->dev.of_node;
 	struct musb_hdrc_config		*config;
+	struct device_node		*control_node;
+	struct platform_device		*control_pdev;
 	int				ret = -ENOMEM, val;
 
+	if (!np)
+		return -ENODEV;
+
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue)
 		goto err0;
@@ -412,47 +411,43 @@ static int omap2430_probe(struct platform_device *pdev)
 	glue->status			= MUSB_UNKNOWN;
 	glue->control_otghs = ERR_PTR(-ENODEV);
 
-	if (np) {
-		struct device_node *control_node;
-		struct platform_device *control_pdev;
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		goto err2;
 
-		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-		if (!pdata)
-			goto err2;
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		goto err2;
 
-		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
-		if (!data)
-			goto err2;
+	config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
+	if (!config)
+		goto err2;
 
-		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
-		if (!config)
+	of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
+	of_property_read_u32(np, "interface-type",
+			(u32 *)&data->interface_type);
+	of_property_read_u32(np, "num-eps", (u32 *)&config->num_eps);
+	of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);
+	of_property_read_u32(np, "power", (u32 *)&pdata->power);
+
+	ret = of_property_read_u32(np, "multipoint", &val);
+	if (!ret && val)
+		config->multipoint = true;
+
+	pdata->board_data	= data;
+	pdata->config		= config;
+
+	control_node = of_parse_phandle(np, "ctrl-module", 0);
+	if (control_node) {
+		control_pdev = of_find_device_by_node(control_node);
+		if (!control_pdev) {
+			dev_err(&pdev->dev, "Failed to get control device\n");
+			ret = -EINVAL;
 			goto err2;
-
-		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
-		of_property_read_u32(np, "interface-type",
-						(u32 *)&data->interface_type);
-		of_property_read_u32(np, "num-eps", (u32 *)&config->num_eps);
-		of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);
-		of_property_read_u32(np, "power", (u32 *)&pdata->power);
-
-		ret = of_property_read_u32(np, "multipoint", &val);
-		if (!ret && val)
-			config->multipoint = true;
-
-		pdata->board_data	= data;
-		pdata->config		= config;
-
-		control_node = of_parse_phandle(np, "ctrl-module", 0);
-		if (control_node) {
-			control_pdev = of_find_device_by_node(control_node);
-			if (!control_pdev) {
-				dev_err(&pdev->dev, "Failed to get control device\n");
-				ret = -EINVAL;
-				goto err2;
-			}
-			glue->control_otghs = &control_pdev->dev;
 		}
+		glue->control_otghs = &control_pdev->dev;
 	}
+
 	pdata->platform_ops		= &omap2430_ops;
 
 	platform_set_drvdata(pdev, glue);

commit 21b650c23611998ab3a69a401115740b32594d2e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:15 2017 +0100

    USB: musb: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index f68053165b05..5d705930ef47 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -7,23 +7,6 @@
  * Tony Lindgren <tony@atomide.com>
  *
  * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
  */
 #include <linux/module.h>
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 456f3e6ecf03..f68053165b05 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2005-2007 by Texas Instruments
  * Some code has been taken from tusb6010.c

commit c0927fea6ae6529893eeefe2cf97f76877e8929e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Feb 1 21:30:26 2017 -0600

    usb: musb: omap2430: constify dev_pm_ops structures
    
    Declare dev_pm_ops structures as const as they are only stored in the pm
    field of a device_driver structure. This field is of type const, so
    dev_pm_ops structures having similar properties can be declared const
    too.
    
    Size details after cross compiling the .o file for arm
    architecture.
    
    File size before: drivers/usb/musb/omap2430.o
       text    data     bss     dec     hex filename
       4141     400       8    4549    11c5 usb/musb/omap2430.o
    
    File size after: drivers/usb/musb/omap2430.o
       text    data     bss     dec     hex filename
       4333     200       8    4541    11bd usb/musb/omap2430.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    [b-liu@ti.com: added omap2430 in commit subject prefix]
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 8b73214a9ea3..456f3e6ecf03 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -575,7 +575,7 @@ static int omap2430_runtime_resume(struct device *dev)
 	return 0;
 }
 
-static struct dev_pm_ops omap2430_pm_ops = {
+static const struct dev_pm_ops omap2430_pm_ops = {
 	.runtime_suspend = omap2430_runtime_suspend,
 	.runtime_resume = omap2430_runtime_resume,
 };

commit 0edbf9e55295585bbe9df61b646ca5bf80a8e1eb
Merge: eacae5d2b940 e5517c2a5a49
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 28 08:34:10 2016 +0100

    Merge 4.9-rc7 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dc66ba8d9b4832eb23fb5d4b7d3c0a77c749abfc
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Mon Nov 21 08:59:26 2016 -0600

    usb: musb: omap2430: make complain on -EPROBE_DEFER dev_dbg
    
    There is no point having this complaint to be dev_err as it is just adding
    noise to bootlog.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 451b37252604..7c9aa5e78666 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -277,7 +277,7 @@ static int omap2430_musb_init(struct musb *musb)
 		if (status == -ENXIO)
 			return status;
 
-		dev_err(dev, "HS USB OTG: no transceiver configured\n");
+		dev_dbg(dev, "HS USB OTG: no transceiver configured\n");
 		return -EPROBE_DEFER;
 	}
 

commit 71127a7962d2e886ae4f6dca100c19e4e4aedf4e
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Mon Nov 21 08:59:25 2016 -0600

    usb: musb: omap2430: use dev_err
    
    Replace pr_err with dev_err to print also device name.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index cc1225485509..451b37252604 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -277,12 +277,12 @@ static int omap2430_musb_init(struct musb *musb)
 		if (status == -ENXIO)
 			return status;
 
-		pr_err("HS USB OTG: no transceiver configured\n");
+		dev_err(dev, "HS USB OTG: no transceiver configured\n");
 		return -EPROBE_DEFER;
 	}
 
 	if (IS_ERR(musb->phy)) {
-		pr_err("HS USB OTG: no PHY configured\n");
+		dev_err(dev, "HS USB OTG: no PHY configured\n");
 		return PTR_ERR(musb->phy);
 	}
 	musb->isr = omap2430_musb_interrupt;
@@ -301,7 +301,7 @@ static int omap2430_musb_init(struct musb *musb)
 
 	musb_writel(musb->mregs, OTG_INTERFSEL, l);
 
-	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
+	dev_dbg(dev, "HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
 			"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\n",
 			musb_readl(musb->mregs, OTG_REVISION),
 			musb_readl(musb->mregs, OTG_SYSCONFIG),

commit 536d599d4a5104a8f1f771d3a8db97138b0c9ebb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 16 13:21:25 2016 -0600

    usb: musb: Add missing pm_runtime_disable and drop 2430 PM timeout
    
    We are missing pm_runtime_disable() in 2430 glue layer. Further,
    we only need to enable PM runtime and disable it on exit. With
    musb_core.c doing PM, the glue layer as a parent will always be
    active when musb_core.c is active.
    
    This fixes host enumeration issues with some devices as reported
    by Ladislav Michl <ladis@linux-mips.org>.
    
    And holding an RPM reference while deregistering the child would
    lead to a crash in omap2430_runtime_suspend() which dereferences
    the now freed child's driver data on put as pointed out by
    Johan Hovold <johan@kernel.org>:
    
    Unable to handle kernel paging request at virtual address 6b6b6f17
    ...
    [<c05453d4>] (omap2430_runtime_suspend) from [<c0481410>]
     (pm_generic_runtime_suspend+0x3c/0x48)
    [<c0481410>] (pm_generic_runtime_suspend) from [<c0121028>]
     (_od_runtime_suspend+0x1c/0x30)
    [<c0121028>] (_od_runtime_suspend) from [<c04833b0>] (__rpm_callback+0x3c/0x70)
    [<c04833b0>] (__rpm_callback) from [<c0483414>] (rpm_callback+0x30/0x90)
    [<c0483414>] (rpm_callback) from [<c0483984>] (rpm_suspend+0x118/0x6b4)
    [<c0483984>] (rpm_suspend) from [<c04840f4>] (rpm_idle+0x104/0x440)
    [<c04840f4>] (rpm_idle) from [<c04844ac>] (__pm_runtime_idle+0x7c/0xb0)
    [<c04844ac>] (__pm_runtime_idle) from [<c0545458>] (omap2430_remove+0x38/0x58)
    [<c0545458>] (omap2430_remove) from [<c047b2bc>] (platform_drv_remove+0x34/0x4c)
    
    Note that if changes are needed to the autosuspend timeout, it should
    be done in musb_core.c.
    
    Reported-by: Ladislav Michl <ladis@linux-mips.org>
    Fixes: 87326e858448 ("usb: musb: Remove extra PM runtime calls from
    2430 glue layer")
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index cc1225485509..e8be8e39ab8f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -513,17 +513,18 @@ static int omap2430_probe(struct platform_device *pdev)
 	}
 
 	pm_runtime_enable(glue->dev);
-	pm_runtime_use_autosuspend(glue->dev);
-	pm_runtime_set_autosuspend_delay(glue->dev, 100);
 
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err2;
+		goto err3;
 	}
 
 	return 0;
 
+err3:
+	pm_runtime_disable(glue->dev);
+
 err2:
 	platform_device_put(musb);
 
@@ -535,10 +536,7 @@ static int omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue *glue = platform_get_drvdata(pdev);
 
-	pm_runtime_get_sync(glue->dev);
 	platform_device_unregister(glue->musb);
-	pm_runtime_put_sync(glue->dev);
-	pm_runtime_dont_use_autosuspend(glue->dev);
 	pm_runtime_disable(glue->dev);
 
 	return 0;

commit d8e5f0eca1e88215e45aca27115ea747e6164da1
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 19 12:03:39 2016 -0500

    usb: musb: Fix hardirq-safe hardirq-unsafe lock order error
    
    If we configure musb with 2430 glue as a peripheral, and then rmmod
    omap2430 module, we'll get the following error:
    
    [ INFO: HARDIRQ-safe -> HARDIRQ-unsafe lock order detected ]
    ...
    rmmod/413 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:
     (&phy->mutex){+.+.+.}, at: [<c04b9fd0>] phy_power_off+0x1c/0xb8
    [  204.678710]
                   and this task is already holding:
     (&(&musb->lock)->rlock){-.-...}, at: [<bf3a482c>]
     musb_gadget_stop+0x24/0xec [musb_hdrc]
    which would create a new lock dependency:
     (&(&musb->lock)->rlock){-.-...} -> (&phy->mutex){+.+.+.}
    ...
    
    This is because some glue layers expect musb_platform_enable/disable
    to be called with spinlock held, and 2430 glue layer has USB PHY on
    the I2C bus using a mutex.
    
    We could fix the glue layers to take the spinlock, but we still have
    a problem of musb_plaform_enable/disable being called in an unbalanced
    manner. So that would still lead into USB PHY enable/disable related
    problems for omap2430 glue layer.
    
    While it makes sense to only enable USB PHY when needed from PM point
    of view, in this case we just can't do it yet without breaking things.
    So let's just revert phy_enable/disable related changes instead and
    reconsider this after we have fixed musb_platform_enable/disable to
    be balanced.
    
    Fixes: a83e17d0f73b ("usb: musb: Improve PM runtime and phy handling for 2430 glue layer")
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 1ab6973d4f61..cc1225485509 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -287,6 +287,7 @@ static int omap2430_musb_init(struct musb *musb)
 	}
 	musb->isr = omap2430_musb_interrupt;
 	phy_init(musb->phy);
+	phy_power_on(musb->phy);
 
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
@@ -323,8 +324,6 @@ static void omap2430_musb_enable(struct musb *musb)
 	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	if (!WARN_ON(!musb->phy))
-		phy_power_on(musb->phy);
 
 	switch (glue->status) {
 
@@ -361,9 +360,6 @@ static void omap2430_musb_disable(struct musb *musb)
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	if (!WARN_ON(!musb->phy))
-		phy_power_off(musb->phy);
-
 	if (glue->status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
@@ -375,6 +371,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
 	omap2430_low_level_exit(musb);
+	phy_power_off(musb->phy);
 	phy_exit(musb->phy);
 	musb->phy = NULL;
 	cancel_work_sync(&glue->omap_musb_mailbox_work);

commit ae909fe4f4e8718bd0cba6f89c9d19de3ead7a04
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 12 21:48:30 2016 -0500

    usb: musb: Simplify PM runtime for 2430 glue layer
    
    With musb core now blocking PM based on the devctl status
    bit, we can remove related quirks from the 2430 glue layer
    and simplify PM runtime further.
    
    Lets's also use musb->controller instead of dev to make it
    clear we make the PM runtime calls for the core, not the
    glue layer.
    
    And we can now also lower the autoidle timeout.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 0b4cec940386..1ab6973d4f61 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -49,9 +49,6 @@ struct omap2430_glue {
 	enum musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
 	struct device		*control_otghs;
-	bool			cable_connected;
-	bool			enabled;
-	bool			powered;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -141,45 +138,6 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
-/*
- * We can get multiple cable events so we need to keep track
- * of the power state. Only keep power enabled if USB cable is
- * connected and a gadget is started.
- */
-static void omap2430_set_power(struct musb *musb, bool enabled, bool cable)
-{
-	struct device *dev = musb->controller;
-	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	bool power_up;
-	int res;
-
-	if (glue->enabled != enabled)
-		glue->enabled = enabled;
-
-	if (glue->cable_connected != cable)
-		glue->cable_connected = cable;
-
-	power_up = glue->enabled && glue->cable_connected;
-	if (power_up == glue->powered) {
-		dev_warn(musb->controller, "power state already %i\n",
-			 power_up);
-		return;
-	}
-
-	glue->powered = power_up;
-
-	if (power_up) {
-		res = pm_runtime_get_sync(musb->controller);
-		if (res < 0) {
-			dev_err(musb->controller, "could not enable: %i", res);
-			glue->powered = false;
-		}
-	} else {
-		pm_runtime_mark_last_busy(musb->controller);
-		pm_runtime_put_autosuspend(musb->controller);
-	}
-}
-
 static int omap2430_musb_mailbox(enum musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
@@ -203,21 +161,15 @@ static int omap2430_musb_mailbox(enum musb_vbus_id_status status)
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
 	struct musb *musb = glue_to_musb(glue);
-	struct device *dev = musb->controller;
-	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
+	struct musb_hdrc_platform_data *pdata =
+		dev_get_platdata(musb->controller);
 	struct omap_musb_board_data *data = pdata->board_data;
 	struct usb_otg *otg = musb->xceiv->otg;
-	bool cable_connected;
-
-	cable_connected = ((glue->status == MUSB_ID_GROUND) ||
-			   (glue->status == MUSB_VBUS_VALID));
-
-	if (cable_connected)
-		omap2430_set_power(musb, glue->enabled, cable_connected);
 
+	pm_runtime_get_sync(musb->controller);
 	switch (glue->status) {
 	case MUSB_ID_GROUND:
-		dev_dbg(dev, "ID GND\n");
+		dev_dbg(musb->controller, "ID GND\n");
 
 		otg->default_a = true;
 		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
@@ -230,7 +182,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		break;
 
 	case MUSB_VBUS_VALID:
-		dev_dbg(dev, "VBUS Connect\n");
+		dev_dbg(musb->controller, "VBUS Connect\n");
 
 		otg->default_a = false;
 		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
@@ -240,7 +192,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 
 	case MUSB_ID_FLOAT:
 	case MUSB_VBUS_OFF:
-		dev_dbg(dev, "VBUS Disconnect\n");
+		dev_dbg(musb->controller, "VBUS Disconnect\n");
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
 		if (musb->gadget_driver)
@@ -253,12 +205,10 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 			USB_MODE_DISCONNECT);
 		break;
 	default:
-		dev_dbg(dev, "ID float\n");
+		dev_dbg(musb->controller, "ID float\n");
 	}
-
-	if (!cable_connected)
-		omap2430_set_power(musb, glue->enabled, cable_connected);
-
+	pm_runtime_mark_last_busy(musb->controller);
+	pm_runtime_put_autosuspend(musb->controller);
 	atomic_notifier_call_chain(&musb->xceiv->notifier,
 			musb->xceiv->last_event, NULL);
 }
@@ -376,8 +326,6 @@ static void omap2430_musb_enable(struct musb *musb)
 	if (!WARN_ON(!musb->phy))
 		phy_power_on(musb->phy);
 
-	omap2430_set_power(musb, true, glue->cable_connected);
-
 	switch (glue->status) {
 
 	case MUSB_ID_GROUND:
@@ -419,8 +367,6 @@ static void omap2430_musb_disable(struct musb *musb)
 	if (glue->status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
-
-	omap2430_set_power(musb, false, glue->cable_connected);
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -571,7 +517,7 @@ static int omap2430_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(glue->dev);
 	pm_runtime_use_autosuspend(glue->dev);
-	pm_runtime_set_autosuspend_delay(glue->dev, 500);
+	pm_runtime_set_autosuspend_delay(glue->dev, 100);
 
 	ret = platform_device_add(musb);
 	if (ret) {
@@ -591,11 +537,9 @@ static int omap2430_probe(struct platform_device *pdev)
 static int omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue *glue = platform_get_drvdata(pdev);
-	struct musb *musb = glue_to_musb(glue);
 
 	pm_runtime_get_sync(glue->dev);
 	platform_device_unregister(glue->musb);
-	omap2430_set_power(musb, false, false);
 	pm_runtime_put_sync(glue->dev);
 	pm_runtime_dont_use_autosuspend(glue->dev);
 	pm_runtime_disable(glue->dev);

commit aec373c1e5d87d791525a675fe726c11d64b84a8
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:22 2016 -0500

    usb: musb: Use normal module_init for 2430 glue
    
    There's no longer any need for custom initcall level for
    musb.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 22f15b026ab9..0b4cec940386 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -669,18 +669,8 @@ static struct platform_driver omap2430_driver = {
 	},
 };
 
+module_platform_driver(omap2430_driver);
+
 MODULE_DESCRIPTION("OMAP2PLUS MUSB Glue Layer");
 MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
 MODULE_LICENSE("GPL v2");
-
-static int __init omap2430_init(void)
-{
-	return platform_driver_register(&omap2430_driver);
-}
-subsys_initcall(omap2430_init);
-
-static void __exit omap2430_exit(void)
-{
-	platform_driver_unregister(&omap2430_driver);
-}
-module_exit(omap2430_exit);

commit 87326e858448c40e32f142c0b8dcc59d7b27c641
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:20 2016 -0500

    usb: musb: Remove extra PM runtime calls from 2430 glue layer
    
    With PM runtime behaving, these are all now unnecessary.
    Doing pm_runtime_get(musb->controller) will keep the parent
    glue layer also active.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2c54f52ae386..22f15b026ab9 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -268,13 +268,8 @@ static void omap_musb_mailbox_work(struct work_struct *mailbox_work)
 {
 	struct omap2430_glue *glue = container_of(mailbox_work,
 				struct omap2430_glue, omap_musb_mailbox_work);
-	struct musb *musb = glue_to_musb(glue);
-	struct device *dev = musb->controller;
 
-	pm_runtime_get_sync(dev);
 	omap_musb_set_mailbox(glue);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_put_autosuspend(dev);
 }
 
 static irqreturn_t omap2430_musb_interrupt(int irq, void *__hci)
@@ -343,16 +338,6 @@ static int omap2430_musb_init(struct musb *musb)
 	musb->isr = omap2430_musb_interrupt;
 	phy_init(musb->phy);
 
-	/*
-	 * Enable runtime PM for musb parent (this driver). We can't
-	 * do it earlier as struct musb is not yet allocated and we
-	 * need to touch the musb registers for runtime PM.
-	 */
-	pm_runtime_enable(glue->dev);
-	status = pm_runtime_get_sync(glue->dev);
-	if (status < 0)
-		goto err1;
-
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
 	if (data->interface_type == MUSB_INTERFACE_UTMI) {
@@ -376,11 +361,7 @@ static int omap2430_musb_init(struct musb *musb)
 	if (glue->status != MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
-	pm_runtime_put(glue->dev);
 	return 0;
-
-err1:
-	return status;
 }
 
 static void omap2430_musb_enable(struct musb *musb)
@@ -588,11 +569,9 @@ static int omap2430_probe(struct platform_device *pdev)
 		goto err2;
 	}
 
-	/*
-	 * Note that we cannot enable PM runtime yet for this
-	 * driver as we need struct musb initialized first.
-	 * See omap2430_musb_init above.
-	 */
+	pm_runtime_enable(glue->dev);
+	pm_runtime_use_autosuspend(glue->dev);
+	pm_runtime_set_autosuspend_delay(glue->dev, 500);
 
 	ret = platform_device_add(musb);
 	if (ret) {
@@ -618,6 +597,7 @@ static int omap2430_remove(struct platform_device *pdev)
 	platform_device_unregister(glue->musb);
 	omap2430_set_power(musb, false, false);
 	pm_runtime_put_sync(glue->dev);
+	pm_runtime_dont_use_autosuspend(glue->dev);
 	pm_runtime_disable(glue->dev);
 
 	return 0;

commit 12b7db2bf8b88938798c60416172b53225207b1f
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:19 2016 -0500

    usb: musb: Return error value from musb_mailbox
    
    At least on n900 we have phy-twl4030-usb only generating cable
    interrupts, and then have a separate USB PHY.
    
    In order for musb to know the real cable status, we need to
    clear any cached state until musb is ready. Otherwise the cable
    status interrupts will get just ignored if the status does
    not change from the initial state.
    
    To do this, let's add a return value to musb_mailbox(), and
    reset cached linkstat to MUSB_UNKNOWN on error. Sorry to cause
    a bit of churn here, I should have added that already last time
    patching musb_mailbox().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d312d42592d6..2c54f52ae386 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -180,22 +180,24 @@ static void omap2430_set_power(struct musb *musb, bool enabled, bool cable)
 	}
 }
 
-static void omap2430_musb_mailbox(enum musb_vbus_id_status status)
+static int omap2430_musb_mailbox(enum musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
 
 	if (!glue) {
 		pr_err("%s: musb core is not yet initialized\n", __func__);
-		return;
+		return -EPROBE_DEFER;
 	}
 	glue->status = status;
 
 	if (!glue_to_musb(glue)) {
 		pr_err("%s: musb core is not yet ready\n", __func__);
-		return;
+		return -EPROBE_DEFER;
 	}
 
 	schedule_work(&glue->omap_musb_mailbox_work);
+
+	return 0;
 }
 
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)

commit a118df07f5b19e4879fd67e98a69f4644136877f
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:18 2016 -0500

    usb: musb: Don't set d+ high before enable for 2430 glue layer
    
    At least 2430 glue layer pulls d+ high on start up even if there are
    no gadgets configured. This is bad at least for anything using a separate
    battery charger chip as it can confuse the charger detection.
    
    Let's fix the issue by removing the bogus glue layer code tinkering
    with the SESSION bit. As pointed out Bin Liu <b-liu@ti.com> and
    Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>, the SESSION
    bit just starts host mode if ID pin is grounded, and starts the
    srp is ID pin is floating. So without the ID pin changing, it's
    unable to force musb mode to anything. And just for starting a
    host mode, things work fine without this code.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 53653944cf72..d312d42592d6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -122,16 +122,6 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
-static int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)
-{
-	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
-	devctl |= MUSB_DEVCTL_SESSION;
-	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-
-	return 0;
-}
-
 static inline void omap2430_low_level_exit(struct musb *musb)
 {
 	u32 l;
@@ -472,7 +462,6 @@ static const struct musb_platform_ops omap2430_ops = {
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 
-	.set_mode	= omap2430_musb_set_mode,
 	.set_vbus	= omap2430_musb_set_vbus,
 
 	.enable		= omap2430_musb_enable,

commit 4dc2fe7a94d07c6148eea5722e23d4c1dbecc9e3
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:17 2016 -0500

    usb: musb: Remove try_idle for 2430 glue layer
    
    This is no longer needed with PM runtime at least for 2430 glue.
    We can now rely only on PM runtime and cable detection.
    
    The other glue layers can probably remove try_idle too, but that
    needs to be tested for each platform before doing it.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b81216d1380b..53653944cf72 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -57,92 +57,6 @@ struct omap2430_glue {
 
 static struct omap2430_glue	*_glue;
 
-static struct timer_list musb_idle_timer;
-
-static void musb_do_idle(unsigned long _musb)
-{
-	struct musb	*musb = (void *)_musb;
-	unsigned long	flags;
-	u8	power;
-	u8	devctl;
-
-	spin_lock_irqsave(&musb->lock, flags);
-
-	switch (musb->xceiv->otg->state) {
-	case OTG_STATE_A_WAIT_BCON:
-
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
-			MUSB_DEV_MODE(musb);
-		} else {
-			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
-			MUSB_HST_MODE(musb);
-		}
-		break;
-	case OTG_STATE_A_SUSPEND:
-		/* finish RESUME signaling? */
-		if (musb->port1_status & MUSB_PORT_STAT_RESUME) {
-			power = musb_readb(musb->mregs, MUSB_POWER);
-			power &= ~MUSB_POWER_RESUME;
-			dev_dbg(musb->controller, "root port resume stopped, power %02x\n", power);
-			musb_writeb(musb->mregs, MUSB_POWER, power);
-			musb->is_active = 1;
-			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
-						| MUSB_PORT_STAT_RESUME);
-			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
-			usb_hcd_poll_rh_status(musb->hcd);
-			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv->otg->state = OTG_STATE_A_HOST;
-		}
-		break;
-	case OTG_STATE_A_HOST:
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
-		else
-			musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&musb->lock, flags);
-}
-
-
-static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
-{
-	unsigned long		default_timeout = jiffies + msecs_to_jiffies(3);
-	static unsigned long	last_timer;
-
-	if (timeout == 0)
-		timeout = default_timeout;
-
-	/* Never idle if active, or when VBUS timeout is not set as host */
-	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {
-		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->otg->state));
-		del_timer(&musb_idle_timer);
-		last_timer = jiffies;
-		return;
-	}
-
-	if (time_after(last_timer, timeout)) {
-		if (!timer_pending(&musb_idle_timer))
-			last_timer = timeout;
-		else {
-			dev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");
-			return;
-		}
-	}
-	last_timer = timeout;
-
-	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		usb_otg_state_string(musb->xceiv->otg->state),
-		(unsigned long)jiffies_to_msecs(timeout - jiffies));
-	mod_timer(&musb_idle_timer, timeout);
-}
-
 static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
 	struct usb_otg	*otg = musb->xceiv->otg;
@@ -467,8 +381,6 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
-	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
-
 	if (glue->status != MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
@@ -543,7 +455,6 @@ static int omap2430_musb_exit(struct musb *musb)
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	del_timer_sync(&musb_idle_timer);
 	omap2430_low_level_exit(musb);
 	phy_exit(musb->phy);
 	musb->phy = NULL;
@@ -562,8 +473,6 @@ static const struct musb_platform_ops omap2430_ops = {
 	.exit		= omap2430_musb_exit,
 
 	.set_mode	= omap2430_musb_set_mode,
-	.try_idle	= omap2430_musb_try_idle,
-
 	.set_vbus	= omap2430_musb_set_vbus,
 
 	.enable		= omap2430_musb_enable,

commit a83e17d0f73b2c53ffd40773c227bf4b901365d8
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:16 2016 -0500

    usb: musb: Improve PM runtime and phy handling for 2430 glue layer
    
    This simplifies things and allows idling both MUSB and PHY
    when nothing is configured. Let's just return early from PM
    runtime if musb is not yet initialized.
    
    Let's also warn if PHY is not configured.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index fa9932910969..b81216d1380b 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -435,6 +435,7 @@ static int omap2430_musb_init(struct musb *musb)
 		return PTR_ERR(musb->phy);
 	}
 	musb->isr = omap2430_musb_interrupt;
+	phy_init(musb->phy);
 
 	/*
 	 * Enable runtime PM for musb parent (this driver). We can't
@@ -471,8 +472,6 @@ static int omap2430_musb_init(struct musb *musb)
 	if (glue->status != MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
-	phy_init(musb->phy);
-	phy_power_on(musb->phy);
 	pm_runtime_put(glue->dev);
 	return 0;
 
@@ -489,6 +488,9 @@ static void omap2430_musb_enable(struct musb *musb)
 	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 
+	if (!WARN_ON(!musb->phy))
+		phy_power_on(musb->phy);
+
 	omap2430_set_power(musb, true, glue->cable_connected);
 
 	switch (glue->status) {
@@ -526,6 +528,9 @@ static void omap2430_musb_disable(struct musb *musb)
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
+	if (!WARN_ON(!musb->phy))
+		phy_power_off(musb->phy);
+
 	if (glue->status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
@@ -535,11 +540,14 @@ static void omap2430_musb_disable(struct musb *musb)
 
 static int omap2430_musb_exit(struct musb *musb)
 {
-	del_timer_sync(&musb_idle_timer);
+	struct device *dev = musb->controller;
+	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
+	del_timer_sync(&musb_idle_timer);
 	omap2430_low_level_exit(musb);
-	phy_power_off(musb->phy);
 	phy_exit(musb->phy);
+	musb->phy = NULL;
+	cancel_work_sync(&glue->omap_musb_mailbox_work);
 
 	return 0;
 }
@@ -707,7 +715,6 @@ static int omap2430_remove(struct platform_device *pdev)
 	struct musb *musb = glue_to_musb(glue);
 
 	pm_runtime_get_sync(glue->dev);
-	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_unregister(glue->musb);
 	omap2430_set_power(musb, false, false);
 	pm_runtime_put_sync(glue->dev);
@@ -723,12 +730,13 @@ static int omap2430_runtime_suspend(struct device *dev)
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
-	if (musb) {
-		musb->context.otg_interfsel = musb_readl(musb->mregs,
-				OTG_INTERFSEL);
+	if (!musb)
+		return 0;
 
-		omap2430_low_level_exit(musb);
-	}
+	musb->context.otg_interfsel = musb_readl(musb->mregs,
+						 OTG_INTERFSEL);
+
+	omap2430_low_level_exit(musb);
 
 	return 0;
 }
@@ -739,7 +747,7 @@ static int omap2430_runtime_resume(struct device *dev)
 	struct musb			*musb = glue_to_musb(glue);
 
 	if (!musb)
-		return -EPROBE_DEFER;
+		return 0;
 
 	omap2430_low_level_init(musb);
 	musb_writel(musb->mregs, OTG_INTERFSEL,

commit 21f77beece2b6f479648192a87ededd2fb8f1716
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:15 2016 -0500

    usb: musb: Handle cable status better for 2430 glue layer
    
    We may have drivers loaded but no configured gadgets and MUSB may be in
    host mode. If gadgets are configured during host mode, PM runtime will
    get confused.
    
    Disable PM runtime from gadget state, and do it based on the cable
    and last state.
    
    Note that we may get multiple cable events, so we need to keep track
    of the power state.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 3ce94bf3f1c7..fa9932910969 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -49,6 +49,9 @@ struct omap2430_glue {
 	enum musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
 	struct device		*control_otghs;
+	bool			cable_connected;
+	bool			enabled;
+	bool			powered;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -234,6 +237,45 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
+/*
+ * We can get multiple cable events so we need to keep track
+ * of the power state. Only keep power enabled if USB cable is
+ * connected and a gadget is started.
+ */
+static void omap2430_set_power(struct musb *musb, bool enabled, bool cable)
+{
+	struct device *dev = musb->controller;
+	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
+	bool power_up;
+	int res;
+
+	if (glue->enabled != enabled)
+		glue->enabled = enabled;
+
+	if (glue->cable_connected != cable)
+		glue->cable_connected = cable;
+
+	power_up = glue->enabled && glue->cable_connected;
+	if (power_up == glue->powered) {
+		dev_warn(musb->controller, "power state already %i\n",
+			 power_up);
+		return;
+	}
+
+	glue->powered = power_up;
+
+	if (power_up) {
+		res = pm_runtime_get_sync(musb->controller);
+		if (res < 0) {
+			dev_err(musb->controller, "could not enable: %i", res);
+			glue->powered = false;
+		}
+	} else {
+		pm_runtime_mark_last_busy(musb->controller);
+		pm_runtime_put_autosuspend(musb->controller);
+	}
+}
+
 static void omap2430_musb_mailbox(enum musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
@@ -259,6 +301,13 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 	struct usb_otg *otg = musb->xceiv->otg;
+	bool cable_connected;
+
+	cable_connected = ((glue->status == MUSB_ID_GROUND) ||
+			   (glue->status == MUSB_VBUS_VALID));
+
+	if (cable_connected)
+		omap2430_set_power(musb, glue->enabled, cable_connected);
 
 	switch (glue->status) {
 	case MUSB_ID_GROUND:
@@ -268,7 +317,6 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
-			pm_runtime_get_sync(dev);
 			omap_control_usb_set_mode(glue->control_otghs,
 				USB_MODE_HOST);
 			omap2430_musb_set_vbus(musb, 1);
@@ -281,8 +329,6 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		otg->default_a = false;
 		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		musb->xceiv->last_event = USB_EVENT_VBUS;
-		if (musb->gadget_driver)
-			pm_runtime_get_sync(dev);
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
 		break;
 
@@ -291,11 +337,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "VBUS Disconnect\n");
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
-		if (musb->gadget_driver) {
+		if (musb->gadget_driver)
 			omap2430_musb_set_vbus(musb, 0);
-			pm_runtime_mark_last_busy(dev);
-			pm_runtime_put_autosuspend(dev);
-		}
 
 		if (data->interface_type == MUSB_INTERFACE_UTMI)
 			otg_set_vbus(musb->xceiv->otg, 0);
@@ -307,6 +350,9 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "ID float\n");
 	}
 
+	if (!cable_connected)
+		omap2430_set_power(musb, glue->enabled, cable_connected);
+
 	atomic_notifier_call_chain(&musb->xceiv->notifier,
 			musb->xceiv->last_event, NULL);
 }
@@ -443,6 +489,8 @@ static void omap2430_musb_enable(struct musb *musb)
 	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 
+	omap2430_set_power(musb, true, glue->cable_connected);
+
 	switch (glue->status) {
 
 	case MUSB_ID_GROUND:
@@ -481,6 +529,8 @@ static void omap2430_musb_disable(struct musb *musb)
 	if (glue->status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
+
+	omap2430_set_power(musb, false, glue->cable_connected);
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -653,11 +703,13 @@ static int omap2430_probe(struct platform_device *pdev)
 
 static int omap2430_remove(struct platform_device *pdev)
 {
-	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
+	struct omap2430_glue *glue = platform_get_drvdata(pdev);
+	struct musb *musb = glue_to_musb(glue);
 
 	pm_runtime_get_sync(glue->dev);
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_unregister(glue->musb);
+	omap2430_set_power(musb, false, false);
 	pm_runtime_put_sync(glue->dev);
 	pm_runtime_disable(glue->dev);
 

commit f730f205cc5116b6edfedf568fdfbb4935248e8e
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:12 2016 -0500

    usb: musb: Split PM runtime between wrapper IP and musb core
    
    Let's not tinker with the PM runtime of musb core from the omap2430
    wrapper. This allows us to initialize PM runtime for musb core later
    on instead of doing it in stages. And omap2430 wrapper has no need
    to for accessing musb core at this point.
    
    Note that this does not remove all the PM runtime calls from the
    glue layer, those will get removed in a later patch.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 07363d28fbc1..3ce94bf3f1c7 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -400,13 +400,6 @@ static int omap2430_musb_init(struct musb *musb)
 	if (status < 0)
 		goto err1;
 
-	status = pm_runtime_get_sync(dev);
-	if (status < 0) {
-		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
-		pm_runtime_put_sync(glue->dev);
-		goto err1;
-	}
-
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
 	if (data->interface_type == MUSB_INTERFACE_UTMI) {
@@ -434,9 +427,6 @@ static int omap2430_musb_init(struct musb *musb)
 
 	phy_init(musb->phy);
 	phy_power_on(musb->phy);
-
-	pm_runtime_mark_last_busy(musb->controller);
-	pm_runtime_put_autosuspend(musb->controller);
 	pm_runtime_put(glue->dev);
 	return 0;
 

commit 7099dbc5b3eb9f52efdb78406826f7463f07d71c
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:11 2016 -0500

    usb: musb: Update to use PM runtime autosuspend
    
    Let's make the PM runtime use the standard autosuspend calls.
    Commit 5de85b9d57ab ("PM / runtime: Re-init runtime PM states at probe
    error and driver unbind") means we must pair use_autosuspend with
    dont_use_autosuspend and then use put_sync to properly idle the
    device.
    
    Note that we'll be removing the PM runtime calls from the glue
    layer to the MUSB core in the next patch. And we can also remove
    the pointless FIXME comment now.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c84e0322c108..07363d28fbc1 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -435,8 +435,9 @@ static int omap2430_musb_init(struct musb *musb)
 	phy_init(musb->phy);
 	phy_power_on(musb->phy);
 
-	pm_runtime_put_noidle(musb->controller);
-	pm_runtime_put_noidle(glue->dev);
+	pm_runtime_mark_last_busy(musb->controller);
+	pm_runtime_put_autosuspend(musb->controller);
+	pm_runtime_put(glue->dev);
 	return 0;
 
 err1:

commit 03e43528ab68449921201744a731c1bac50bc9d1
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 30 21:37:13 2015 -0800

    usb: musb: Fix unbalanced pm_runtime_enable
    
    When reloading omap2430 kernel module we get a warning about
    unbalanced pm_runtime_enable. Let's fix this. Note that we
    need to do this after the child musb-core platform_device is
    removed because of pm_runtime_irq_safe being set at the child.
    
    Cc: Bin Liu <b-liu@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: NeilBrown <neil@brown.name>
    Reviewed-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index bf05f807729f..c84e0322c108 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -664,8 +664,11 @@ static int omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
+	pm_runtime_get_sync(glue->dev);
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_unregister(glue->musb);
+	pm_runtime_put_sync(glue->dev);
+	pm_runtime_disable(glue->dev);
 
 	return 0;
 }

commit 8055555fc4590fbda32d4bbf7888bdb2cd4b2b74
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 30 21:37:12 2015 -0800

    usb: musb: core: Fix handling of the phy notifications
    
    We currently can't unload omap2430 MUSB platform glue driver module and
    this cause issues for fixing the MUSB code further. The reason we can't
    remove omap2430 is because it uses the PHY functions and also exports the
    omap_musb_mailbox function that some PHY drivers are using.
    
    Let's fix the issue by exporting a more generic musb_mailbox function
    from the MUSB core and allow platform glue layers to register phy_callback
    function as needed.
    
    And now we can now also get rid of the include/linux/musb-omap.h.
    
    Cc: Bin Liu <b-liu@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: NeilBrown <neil@brown.name>
    Reviewed-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 1bd9232ff76f..bf05f807729f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -36,7 +36,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/err.h>
 #include <linux/delay.h>
-#include <linux/usb/musb-omap.h>
+#include <linux/usb/musb.h>
 #include <linux/phy/omap_control_phy.h>
 #include <linux/of_platform.h>
 
@@ -46,7 +46,7 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
-	enum omap_musb_vbus_id_status status;
+	enum musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
 	struct device		*control_otghs;
 };
@@ -234,7 +234,7 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
-void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
+static void omap2430_musb_mailbox(enum musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
 
@@ -251,7 +251,6 @@ void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
 
 	schedule_work(&glue->omap_musb_mailbox_work);
 }
-EXPORT_SYMBOL_GPL(omap_musb_mailbox);
 
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
@@ -262,7 +261,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	struct usb_otg *otg = musb->xceiv->otg;
 
 	switch (glue->status) {
-	case OMAP_MUSB_ID_GROUND:
+	case MUSB_ID_GROUND:
 		dev_dbg(dev, "ID GND\n");
 
 		otg->default_a = true;
@@ -276,7 +275,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		}
 		break;
 
-	case OMAP_MUSB_VBUS_VALID:
+	case MUSB_VBUS_VALID:
 		dev_dbg(dev, "VBUS Connect\n");
 
 		otg->default_a = false;
@@ -287,8 +286,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
 		break;
 
-	case OMAP_MUSB_ID_FLOAT:
-	case OMAP_MUSB_VBUS_OFF:
+	case MUSB_ID_FLOAT:
+	case MUSB_VBUS_OFF:
 		dev_dbg(dev, "VBUS Disconnect\n");
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
@@ -430,7 +429,7 @@ static int omap2430_musb_init(struct musb *musb)
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
-	if (glue->status != OMAP_MUSB_UNKNOWN)
+	if (glue->status != MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
 	phy_init(musb->phy);
@@ -455,7 +454,7 @@ static void omap2430_musb_enable(struct musb *musb)
 
 	switch (glue->status) {
 
-	case OMAP_MUSB_ID_GROUND:
+	case MUSB_ID_GROUND:
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_HOST);
 		if (data->interface_type != MUSB_INTERFACE_UTMI)
 			break;
@@ -474,7 +473,7 @@ static void omap2430_musb_enable(struct musb *musb)
 		}
 		break;
 
-	case OMAP_MUSB_VBUS_VALID:
+	case MUSB_VBUS_VALID:
 		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
 		break;
 
@@ -488,7 +487,7 @@ static void omap2430_musb_disable(struct musb *musb)
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	if (glue->status != OMAP_MUSB_UNKNOWN)
+	if (glue->status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
 }
@@ -520,6 +519,8 @@ static const struct musb_platform_ops omap2430_ops = {
 
 	.enable		= omap2430_musb_enable,
 	.disable	= omap2430_musb_disable,
+
+	.phy_callback	= omap2430_musb_mailbox,
 };
 
 static u64 omap2430_dmamask = DMA_BIT_MASK(32);
@@ -551,7 +552,7 @@ static int omap2430_probe(struct platform_device *pdev)
 
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
-	glue->status			= OMAP_MUSB_UNKNOWN;
+	glue->status			= MUSB_UNKNOWN;
 	glue->control_otghs = ERR_PTR(-ENODEV);
 
 	if (np) {

commit 8f2279d5d908119a08e906be1c6b69c744d0c379
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 28 10:16:04 2015 -0700

    usb: musb: omap2430: Fix regression caused by driver core change
    
    Commit ddef08dd00f5 ("Driver core: wakeup the parent device before trying
    probe") started automatically ensuring the parent device is enabled when
    the child gets probed.
    
    This however caused a regression for MUSB omap2430 interface as the
    runtime PM for the parent device needs the child initialized to access
    the MUSB hardware registers.
    
    Let's delay the enabling of PM runtime for the parent until the child
    has been properly initialized as suggested in an earlier patch by
    Grygorii Strashko <grygorii.strashko@ti.com>.
    
    In addition to delaying pm_runtime_enable, we now also need to make sure
    the parent is enabled during omap2430_musb_init. We also want to propagate
    an error from omap2430_runtime_resume if struct musb is not initialized.
    
    Note that we use pm_runtime_put_noidle here for both the child and parent
    to prevent an extra runtime_suspend/resume cycle.
    
    Let's also add some comments to avoid confusion between the
    two different devices.
    
    Fixes: ddef08dd00f5 ("Driver core: wakeup the parent device before
    trying probe")
    Suggested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Reviewed-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 70f2b8a2e6cf..1bd9232ff76f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -391,9 +391,20 @@ static int omap2430_musb_init(struct musb *musb)
 	}
 	musb->isr = omap2430_musb_interrupt;
 
+	/*
+	 * Enable runtime PM for musb parent (this driver). We can't
+	 * do it earlier as struct musb is not yet allocated and we
+	 * need to touch the musb registers for runtime PM.
+	 */
+	pm_runtime_enable(glue->dev);
+	status = pm_runtime_get_sync(glue->dev);
+	if (status < 0)
+		goto err1;
+
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
 		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
+		pm_runtime_put_sync(glue->dev);
 		goto err1;
 	}
 
@@ -426,6 +437,7 @@ static int omap2430_musb_init(struct musb *musb)
 	phy_power_on(musb->phy);
 
 	pm_runtime_put_noidle(musb->controller);
+	pm_runtime_put_noidle(glue->dev);
 	return 0;
 
 err1:
@@ -626,7 +638,11 @@ static int omap2430_probe(struct platform_device *pdev)
 		goto err2;
 	}
 
-	pm_runtime_enable(&pdev->dev);
+	/*
+	 * Note that we cannot enable PM runtime yet for this
+	 * driver as we need struct musb initialized first.
+	 * See omap2430_musb_init above.
+	 */
 
 	ret = platform_device_add(musb);
 	if (ret) {
@@ -675,11 +691,12 @@ static int omap2430_runtime_resume(struct device *dev)
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
-	if (musb) {
-		omap2430_low_level_init(musb);
-		musb_writel(musb->mregs, OTG_INTERFSEL,
-				musb->context.otg_interfsel);
-	}
+	if (!musb)
+		return -EPROBE_DEFER;
+
+	omap2430_low_level_init(musb);
+	musb_writel(musb->mregs, OTG_INTERFSEL,
+		    musb->context.otg_interfsel);
 
 	return 0;
 }

commit 7f6283ed6fe867ce168ee3eea2ced4f6cdeeb37a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 1 12:29:28 2015 -0700

    usb: musb: Set up function pointers for DMA
    
    Set up function pointers for DMA so get closer to
    being able to build in all the DMA engines.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5546a22db2ed..70f2b8a2e6cf 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -494,6 +494,10 @@ static int omap2430_musb_exit(struct musb *musb)
 
 static const struct musb_platform_ops omap2430_ops = {
 	.quirks		= MUSB_DMA_INVENTRA,
+#ifdef CONFIG_USB_INVENTRA_DMA
+	.dma_init	= musbhs_dma_controller_create,
+	.dma_exit	= musbhs_dma_controller_destroy,
+#endif
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 

commit f8e9f34f80a21540ebf8ba26877568124ca096b0
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 1 12:29:27 2015 -0700

    usb: musb: Fix up DMA related macros
    
    Pass struct musb to tusb_dma_omap() and is_cppi_enabled(),
    and add macros for the other DMA controllers. Populate the
    platform specific quirks with the DMA type and use it during
    runtime.
    
    Note that platform glue layers with no custom DMA code are
    tagged with MUSB_DMA_INVENTRA which may have a chance of
    working. Looks like the defconfigs for these use PIO_ONLY,
    so this should not break existing configs.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index cc752d8c7773..5546a22db2ed 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -493,6 +493,7 @@ static int omap2430_musb_exit(struct musb *musb)
 }
 
 static const struct musb_platform_ops omap2430_ops = {
+	.quirks		= MUSB_DMA_INVENTRA,
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 

commit 606bf4d5d630781c0e626b6811ac3aabb57fdf1b
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Feb 4 06:28:49 2015 -0800

    usb: musb: Fix use for of_property_read_bool for disabled multipoint
    
    The value for the multipoint dts property is ignored when parsing with
    of_property_read_bool, so we currently have multipoint always set as 1
    even if value 0 is specified in the dts file.
    
    Let's fix this to read the value too instead of just the property like
    the binding documentation says as otherwise MUSB will fail to work
    on devices with Mentor configuration that does not support multipoint.
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 763649eb4987..cc752d8c7773 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -516,7 +516,7 @@ static int omap2430_probe(struct platform_device *pdev)
 	struct omap2430_glue		*glue;
 	struct device_node		*np = pdev->dev.of_node;
 	struct musb_hdrc_config		*config;
-	int				ret = -ENOMEM;
+	int				ret = -ENOMEM, val;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue)
@@ -559,7 +559,10 @@ static int omap2430_probe(struct platform_device *pdev)
 		of_property_read_u32(np, "num-eps", (u32 *)&config->num_eps);
 		of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);
 		of_property_read_u32(np, "power", (u32 *)&pdata->power);
-		config->multipoint = of_property_read_bool(np, "multipoint");
+
+		ret = of_property_read_u32(np, "multipoint", &val);
+		if (!ret && val)
+			config->multipoint = true;
 
 		pdata->board_data	= data;
 		pdata->config		= config;

commit e47d92545c2972bcf3711e7db80f481e402163c7
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:13 2014 +0100

    usb: move the OTG state from the USB PHY to the OTG structure
    
    Before using the PHY framework instead of the USB PHY one, we need to
    move the OTG state into another place, since it won't be available when
    USB PHY isn't used. This patch moves the OTG state into the OTG
    structure, and makes all the needed modifications in the drivers
    using the OTG state.
    
    [ balbi@ti.com : fix build regressions with phy-tahvo.c, musb_dsps.c,
                    phy-isp1301-omap, and chipidea's debug.c ]
    
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 20fc2a532a24..763649eb4987 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -65,15 +65,15 @@ static void musb_do_idle(unsigned long _musb)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	switch (musb->xceiv->state) {
+	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		} else {
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
 		break;
@@ -90,15 +90,15 @@ static void musb_do_idle(unsigned long _musb)
 			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
 			usb_hcd_poll_rh_status(musb->hcd);
 			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv->state = OTG_STATE_A_HOST;
+			musb->xceiv->otg->state = OTG_STATE_A_HOST;
 		}
 		break;
 	case OTG_STATE_A_HOST:
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv->state = OTG_STATE_B_IDLE;
+			musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		else
-			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 	default:
 		break;
 	}
@@ -116,9 +116,9 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
+			&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			usb_otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->otg->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
 		return;
@@ -135,7 +135,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
 }
@@ -153,7 +153,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
 	if (is_on) {
-		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
+		if (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {
 			int loops = 100;
 			/* start the session */
 			devctl |= MUSB_DEVCTL_SESSION;
@@ -180,7 +180,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		} else {
 			musb->is_active = 1;
 			otg->default_a = 1;
-			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
 			devctl |= MUSB_DEVCTL_SESSION;
 			MUSB_HST_MODE(musb);
 		}
@@ -192,7 +192,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		 */
 
 		otg->default_a = 0;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		devctl &= ~MUSB_DEVCTL_SESSION;
 
 		MUSB_DEV_MODE(musb);
@@ -201,7 +201,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
-		usb_otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->otg->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
@@ -266,7 +266,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "ID GND\n");
 
 		otg->default_a = true;
-		musb->xceiv->state = OTG_STATE_A_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
@@ -280,7 +280,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "VBUS Connect\n");
 
 		otg->default_a = false;
-		musb->xceiv->state = OTG_STATE_B_IDLE;
+		musb->xceiv->otg->state = OTG_STATE_B_IDLE;
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(dev);

commit 5a8053099c4a3fb47189575be34350ac40fb6080
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Oct 24 00:34:12 2014 +0400

    usb: musb: omap2430: use MUSB_DEVCTL_BDEVICE
    
    The OMAP2+ MUSB glue layer still uses a bare number for the DEVCTL.B-Device bit
    in one place, while there's #define MUSB_DEVCTL_BDEVICE for that.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 6669f2611e91..20fc2a532a24 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -162,7 +162,8 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 			 * Wait for the musb to set as A device to enable the
 			 * VBUS
 			 */
-			while (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {
+			while (musb_readb(musb->mregs, MUSB_DEVCTL) &
+			       MUSB_DEVCTL_BDEVICE) {
 
 				mdelay(5);
 				cpu_relax();

commit af1bdfc999e7690a3b47c75c43a238f6c619a170
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Oct 14 15:56:08 2014 +0800

    usb: musb: omap2430: delete unnecessary 'out of memory' messages
    
    The memory subsystem has already had similar message for it.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d369bf1f3936..6669f2611e91 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -518,10 +518,8 @@ static int omap2430_probe(struct platform_device *pdev)
 	int				ret = -ENOMEM;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
-	if (!glue) {
-		dev_err(&pdev->dev, "failed to allocate glue context\n");
+	if (!glue)
 		goto err0;
-	}
 
 	musb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);
 	if (!musb) {
@@ -543,25 +541,16 @@ static int omap2430_probe(struct platform_device *pdev)
 		struct platform_device *control_pdev;
 
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-		if (!pdata) {
-			dev_err(&pdev->dev,
-				"failed to allocate musb platform data\n");
+		if (!pdata)
 			goto err2;
-		}
 
 		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
-		if (!data) {
-			dev_err(&pdev->dev,
-				"failed to allocate musb board data\n");
+		if (!data)
 			goto err2;
-		}
 
 		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
-		if (!config) {
-			dev_err(&pdev->dev,
-				"failed to allocate musb hdrc config\n");
+		if (!config)
 			goto err2;
-		}
 
 		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
 		of_property_read_u32(np, "interface-type",

commit 8b2bc2c9351b4c09bc3d9096e2a7af3988565dbf
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Apr 7 10:58:01 2014 -0500

    usb: musb: omap2430: make sure clocks are enabled when running mailbox
    
    on early initialization we could fall into
    a situation where the mailbox is called before
    MUSB's clocks are running, in order to avoid
    that, make sure mailbox is always wrapped with
    pm_runtime calls.
    
    Reported-by: Stefan Roese <sr@denx.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 819a7cdcb866..d369bf1f3936 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -316,7 +316,13 @@ static void omap_musb_mailbox_work(struct work_struct *mailbox_work)
 {
 	struct omap2430_glue *glue = container_of(mailbox_work,
 				struct omap2430_glue, omap_musb_mailbox_work);
+	struct musb *musb = glue_to_musb(glue);
+	struct device *dev = musb->controller;
+
+	pm_runtime_get_sync(dev);
 	omap_musb_set_mailbox(glue);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
 }
 
 static irqreturn_t omap2430_musb_interrupt(int irq, void *__hci)

commit 3063a12be2b07c64e9802708a19489342e64c1a3
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Mar 28 14:31:47 2014 -0500

    usb: musb: fix PHY power on/off
    
    commi 30a70b0 (usb: musb: fix obex in g_nokia.ko
    causing kernel panic) removed phy_power_on()
    and phy_power_off() calls from runtime PM callbacks
    but it failed to note that the driver depended
    on pm_runtime_get_sync() calls to power up the PHY,
    thus leaving some platforms without any means to
    have a working PHY.
    
    Fix that by enabling the phy during omap2430_musb_init()
    and killing it in omap2430_musb_exit().
    
    Fixes: 30a70b0 (usb: musb: fix obex in g_nokia.ko causing kernel panic)
    Cc: <stable@vger.kernel.org> # v3.14
    Cc: Pali Rohr <pali.rohar@gmail.com>
    Cc: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Reported-by: Michael Scott <hashcode0f@gmail.com>
    Tested-by: Michael Scott <hashcode0f@gmail.com>
    Tested-by: Stefan Roese <sr@denx.de>
    Reported-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d341c149a2f9..819a7cdcb866 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -416,6 +416,7 @@ static int omap2430_musb_init(struct musb *musb)
 		omap_musb_set_mailbox(glue);
 
 	phy_init(musb->phy);
+	phy_power_on(musb->phy);
 
 	pm_runtime_put_noidle(musb->controller);
 	return 0;
@@ -478,6 +479,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	del_timer_sync(&musb_idle_timer);
 
 	omap2430_low_level_exit(musb);
+	phy_power_off(musb->phy);
 	phy_exit(musb->phy);
 
 	return 0;

commit 14da699bc04212559d5dda19d3f07c807fb58dfd
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Mar 6 16:38:37 2014 +0200

    phy: rename struct omap_control_usb to struct omap_control_phy
    
    Rename struct omap_control_usb to struct omap_control_phy since it can
    be used to control PHY of USB, SATA and PCIE. Also move the driver and
    include files under *phy* and made the corresponding changes in the users
    of phy-omap-control.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 8aa59a2c5eb2..d341c149a2f9 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -37,7 +37,7 @@
 #include <linux/err.h>
 #include <linux/delay.h>
 #include <linux/usb/musb-omap.h>
-#include <linux/usb/omap_control_usb.h>
+#include <linux/phy/omap_control_phy.h>
 #include <linux/of_platform.h>
 
 #include "musb_core.h"

commit 30a70b026b4cde4e51989661ff3bd0ede08d9646
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Feb 6 21:25:37 2014 +0200

    usb: musb: fix obex in g_nokia.ko causing kernel panic
    
    phy_power_off() can, depending on the PHY being used,
    start I2C transactions which shouldn't happen in
    atomic context.
    
    Current call to phy_power_off() inside omap2430_runtime
    callbacks causes the following dump, as a fix, just don't
    power off the PHY in runtime.
    
    [   18.606414] [<c037eac0>] (__schedule+0x5c/0x50c) from [<c037d3bc>] (schedule_timeout+0x1f4/0x25c)
    [   18.623809] [<c037d3bc>] (schedule_timeout+0x1f4/0x25c) from [<c037f12c>] (wait_for_common+0xc8/0x1ac)
    [   18.649291] [<c037f12c>] (wait_for_common+0xc8/0x1ac) from [<c028c1c0>] (omap_i2c_xfer+0x338/0x488)
    [   18.674499] [<c028c1c0>] (omap_i2c_xfer+0x338/0x488) from [<c0288144>] (__i2c_transfer+0x40/0x74)
    [   18.692047] [<c0288144>] (__i2c_transfer+0x40/0x74) from [<c0288a2c>] (i2c_transfer+0x6c/0x90)
    [   18.709320] [<c0288a2c>] (i2c_transfer+0x6c/0x90) from [<c02351c8>] (regmap_i2c_read+0x48/0x68)
    [   18.726715] [<c02351c8>] (regmap_i2c_read+0x48/0x68) from [<c023161c>] (_regmap_raw_read+0x128/0x220)
    [   18.752685] [<c023161c>] (_regmap_raw_read+0x128/0x220) from [<c02317b4>] (regmap_raw_read+0xa0/0x130)
    [   18.779052] [<c02317b4>] (regmap_raw_read+0xa0/0x130) from [<c023193c>] (regmap_bulk_read+0xf8/0x16c)
    [   18.805694] [<c023193c>] (regmap_bulk_read+0xf8/0x16c) from [<c0238ea8>] (twl_i2c_read+0xa4/0xe0)
    [   18.823730] [<c0238ea8>] (twl_i2c_read+0xa4/0xe0) from [<c0274d34>] (__twl4030_phy_power.isra.12+0x1c/0x58)
    [   18.850921] [<c0274d34>] (__twl4030_phy_power.isra.12+0x1c/0x58) from [<c0274df0>]
    (twl4030_phy_power.part.14+0x80/0xc8)
    [   18.879699] [<c0274df0>] (twl4030_phy_power.part.14+0x80/0xc8) from [<c0274f9c>]
    (twl4030_set_suspend+0x54/0x1e8)
    [   18.908325] [<c0274f9c>] (twl4030_set_suspend+0x54/0x1e8) from [<c027c8c4>]
    (omap2430_runtime_resume+0x5c/0x64)
    [   18.937042] [<c027c8c4>] (omap2430_runtime_resume+0x5c/0x64) from [<c0225dd0>]
    (pm_generic_runtime_resume+0x2c/0x38)
    [   18.966461] [<c0225dd0>] (pm_generic_runtime_resume+0x2c/0x38) from [<c0229fe0>] (__rpm_callback+0x54/0x80)
    [   18.995117] [<c0229fe0>] (__rpm_callback+0x54/0x80) from [<c022a04c>] (rpm_callback+0x40/0x74)
    [   19.013610] [<c022a04c>] (rpm_callback+0x40/0x74) from [<c022b3c8>] (rpm_resume+0x448/0x63c)
    [   19.031921] [<c022b3c8>] (rpm_resume+0x448/0x63c) from [<c022b2e4>] (rpm_resume+0x364/0x63c)
    [   19.050140] [<c022b2e4>] (rpm_resume+0x364/0x63c) from [<c022b874>] (__pm_runtime_resume+0x48/0x74)
    [   19.077728] [<c022b874>] (__pm_runtime_resume+0x48/0x74) from [<c027b4fc>] (musb_gadget_pullup+0x1c/0xb4)
    [   19.105895] [<c027b4fc>] (musb_gadget_pullup+0x1c/0xb4) from [<bf025c14>] (usb_function_deactivate+0x54/0xa4
    [libcomposite])
    [   19.135955] [<bf025c14>] (usb_function_deactivate+0x54/0xa4 [libcomposite]) from [<bf05b3b8>]
    (obex_bind+0x124/0x1d8 [usb_f_obex])
    [   19.166870] [<bf05b3b8>] (obex_bind+0x124/0x1d8 [usb_f_obex]) from [<bf025794>] (usb_add_function+0x58/0xf4
    [libcomposite])
    [   19.197143] [<bf025794>] (usb_add_function+0x58/0xf4 [libcomposite]) from [<bf037420>]
    (nokia_bind_config+0x204/0x250 [g_nokia])
    [   19.227905] [<bf037420>] (nokia_bind_config+0x204/0x250 [g_nokia]) from [<bf0263fc>] (usb_add_config+0x28/0xc0
    [libcomposite])
    [   19.258483] [<bf0263fc>] (usb_add_config+0x28/0xc0 [libcomposite]) from [<bf03709c>] (nokia_bind+0x9c/0x21c
    [g_nokia])
    [   19.288421] [<bf03709c>] (nokia_bind+0x9c/0x21c [g_nokia]) from [<bf0275bc>] (composite_bind+0x74/0x180
    [libcomposite])
    [   19.318420] [<bf0275bc>] (composite_bind+0x74/0x180 [libcomposite]) from [<c027d658>]
    (udc_bind_to_driver+0x2c/0xc4)
    [   19.348114] [<c027d658>] (udc_bind_to_driver+0x2c/0xc4) from [<c027d764>] (usb_gadget_probe_driver+0x74/0x94)
    [   19.377166] [<c027d764>] (usb_gadget_probe_driver+0x74/0x94) from [<c00086f8>] (do_one_initcall+0x94/0x138)
    [   19.406005] [<c00086f8>] (do_one_initcall+0x94/0x138) from [<c007a460>] (load_module+0x113c/0x13c4)
    [   19.434051] [<c007a460>] (load_module+0x113c/0x13c4) from [<c007a7b4>] (SyS_init_module+0xcc/0xec)
    [   19.462127] [<c007a7b4>] (SyS_init_module+0xcc/0xec) from [<c000dd40>] (ret_fast_syscall+0x0/0x30)
    [   19.490753] Code: 0a00002e e1a00004 eb001438 e598300c (e5d3202c)
    [   19.506805] ---[ end trace 060b62ec0d68a78b ]---
    [   19.523132] Kernel panic - not syncing: Fatal exception in interrupt
    
    dump is from 3.12-rc5 kernel
    
    Reported-by: Pali Rohr <pali.rohar@gmail.com>
    Signed-off-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2a408cdaf7b2..8aa59a2c5eb2 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -659,7 +659,6 @@ static int omap2430_runtime_suspend(struct device *dev)
 				OTG_INTERFSEL);
 
 		omap2430_low_level_exit(musb);
-		phy_power_off(musb->phy);
 	}
 
 	return 0;
@@ -674,7 +673,6 @@ static int omap2430_runtime_resume(struct device *dev)
 		omap2430_low_level_init(musb);
 		musb_writel(musb->mregs, OTG_INTERFSEL,
 				musb->context.otg_interfsel);
-		phy_power_on(musb->phy);
 	}
 
 	return 0;

commit 5328f35b1584a9849ffe46afa42018946aa43851
Merge: e3967e7b28de 80d7d8a768cd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Oct 24 16:18:40 2013 +0100

    Merge tag 'usb-for-v3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v3.13
    
    Final conversions to configfs for mass storage, acm_ms, and
    multi gadgets.
    
    MUSB should now work out of the box on AM335x-based boards
    (beagle bone white and black) with DMA thanks to Sebastian's
    work.
    
    We can now enable VERBOSE_DEBUG on builds of drivers/usb/gadget/
    by selecting CONFIG_USB_GADGET_VERBOSE.
    
    s3c-hsotg got quite a few non-critical fixes but also learned
    a few new tricks (isochronous transfers, multi count support).
    
    The Marvel USB3 Controller driver got a memory leak fix.
    
    devm_usb_get_phy() learned not to return NULL, ever.
    
    Other than these patches, we have the usual set of cleanups
    ranging from removal of unnecessary *_set_drvdata() to using
    SIMPLE_DEV_PM_OPS.
    
    Signed-of-by: Felipe Balbi <balbi@ti.com>

commit 8934d3e4d0e7aed1bd067529c667984d7929d92d
Author: Roger Quadros <rogerq@ti.com>
Date:   Thu Oct 3 18:12:34 2013 +0300

    usb: musb: omap2430: Don't use omap_get_control_dev()
    
    omap_get_control_dev() is being deprecated as it doesn't support
    multiple instances. As control device is present only from OMAP4
    onwards which supports DT only, we use phandles to get the
    reference to the control device.
    
    Also get rid of "ti,has-mailbox" property as it is redundant and
    we can determine that from whether "ctrl-module" property is present
    or not. Get rid of has_mailbox from musb_hdrc_platform_data as well.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d0fc4d9c7b80..9eab645fed8b 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -38,6 +38,7 @@
 #include <linux/delay.h>
 #include <linux/usb/musb-omap.h>
 #include <linux/usb/omap_control_usb.h>
+#include <linux/of_platform.h>
 
 #include "musb_core.h"
 #include "omap2430.h"
@@ -524,8 +525,12 @@ static int omap2430_probe(struct platform_device *pdev)
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
 	glue->status			= OMAP_MUSB_UNKNOWN;
+	glue->control_otghs = ERR_PTR(-ENODEV);
 
 	if (np) {
+		struct device_node *control_node;
+		struct platform_device *control_pdev;
+
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&pdev->dev,
@@ -554,22 +559,20 @@ static int omap2430_probe(struct platform_device *pdev)
 		of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);
 		of_property_read_u32(np, "power", (u32 *)&pdata->power);
 		config->multipoint = of_property_read_bool(np, "multipoint");
-		pdata->has_mailbox = of_property_read_bool(np,
-		    "ti,has-mailbox");
 
 		pdata->board_data	= data;
 		pdata->config		= config;
-	}
 
-	if (pdata->has_mailbox) {
-		glue->control_otghs = omap_get_control_dev();
-		if (IS_ERR(glue->control_otghs)) {
-			dev_vdbg(&pdev->dev, "Failed to get control device\n");
-			ret = PTR_ERR(glue->control_otghs);
-			goto err2;
+		control_node = of_parse_phandle(np, "ctrl-module", 0);
+		if (control_node) {
+			control_pdev = of_find_device_by_node(control_node);
+			if (!control_pdev) {
+				dev_err(&pdev->dev, "Failed to get control device\n");
+				ret = -EINVAL;
+				goto err2;
+			}
+			glue->control_otghs = &control_pdev->dev;
 		}
-	} else {
-		glue->control_otghs = ERR_PTR(-ENODEV);
 	}
 	pdata->platform_ops		= &omap2430_ops;
 

commit 6fa7178ce72764a564b5f5b7d2826d3697b89e3a
Author: Pali Rohr <pali.rohar@gmail.com>
Date:   Wed Sep 18 19:03:34 2013 +0200

    usb: musb: Call atomic_notifier_call_chain when status is changed
    
    More power supply drivers depends on vbus events and without it they not
    working. Power supply drivers using usb_register_notifier, so to deliver
    events it is needed to call atomic_notifier_call_chain.
    
    So without atomic notifier power supply driver isp1704 not retrieving
    vbus status and reporting bogus values to userspace and also to board
    platform data functions. Without proper data charger drivers trying to
    charge battery also when charger is disconnected or do not start charging
    when wallcharger connects.
    
    Atomic notifier in musb driver was used before v3.5 and was replaced with
    omap mailbox. This patch adding atomic_notifier_call_chain call from
    function omap_musb_set_mailbox.
    
    Signed-off-by: Pali Rohr <pali.rohar@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 59d2245db1c8..cefafdcbe3a6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -305,6 +305,9 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	default:
 		dev_dbg(dev, "ID float\n");
 	}
+
+	atomic_notifier_call_chain(&musb->xceiv->notifier,
+			musb->xceiv->last_event, NULL);
 }
 
 

commit 3e3101d57c50f9e4fa1da947e4bd0bc5cbab4141
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Sep 27 11:53:30 2013 +0530

    usb: musb: omap2430: use the new generic PHY framework
    
    Use the generic PHY framework API to get the PHY. The usb_phy_set_resume
    and usb_phy_set_suspend is replaced with power_on and
    power_off to align with the new PHY framework.
    
    musb->xceiv can't be removed as of now because musb core uses xceiv.state and
    xceiv.otg. Once there is a separate state machine to handle otg, these can be
    moved out of xceiv and then we can start using the generic PHY framework.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 59d2245db1c8..d0fc4d9c7b80 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -348,11 +348,21 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	if (dev->parent->of_node)
+	if (dev->parent->of_node) {
+		musb->phy = devm_phy_get(dev->parent, "usb2-phy");
+
+		/* We can't totally remove musb->xceiv as of now because
+		 * musb core uses xceiv.state and xceiv.otg. Once we have
+		 * a separate state machine to handle otg, these can be moved
+		 * out of xceiv and then we can start using the generic PHY
+		 * framework
+		 */
 		musb->xceiv = devm_usb_get_phy_by_phandle(dev->parent,
 		    "usb-phy", 0);
-	else
+	} else {
 		musb->xceiv = devm_usb_get_phy_dev(dev, 0);
+		musb->phy = devm_phy_get(dev, "usb");
+	}
 
 	if (IS_ERR(musb->xceiv)) {
 		status = PTR_ERR(musb->xceiv);
@@ -364,6 +374,10 @@ static int omap2430_musb_init(struct musb *musb)
 		return -EPROBE_DEFER;
 	}
 
+	if (IS_ERR(musb->phy)) {
+		pr_err("HS USB OTG: no PHY configured\n");
+		return PTR_ERR(musb->phy);
+	}
 	musb->isr = omap2430_musb_interrupt;
 
 	status = pm_runtime_get_sync(dev);
@@ -397,7 +411,7 @@ static int omap2430_musb_init(struct musb *musb)
 	if (glue->status != OMAP_MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
-	usb_phy_init(musb->xceiv);
+	phy_init(musb->phy);
 
 	pm_runtime_put_noidle(musb->controller);
 	return 0;
@@ -460,6 +474,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	del_timer_sync(&musb_idle_timer);
 
 	omap2430_low_level_exit(musb);
+	phy_exit(musb->phy);
 
 	return 0;
 }
@@ -638,7 +653,7 @@ static int omap2430_runtime_suspend(struct device *dev)
 				OTG_INTERFSEL);
 
 		omap2430_low_level_exit(musb);
-		usb_phy_set_suspend(musb->xceiv, 1);
+		phy_power_off(musb->phy);
 	}
 
 	return 0;
@@ -653,8 +668,7 @@ static int omap2430_runtime_resume(struct device *dev)
 		omap2430_low_level_init(musb);
 		musb_writel(musb->mregs, OTG_INTERFSEL,
 				musb->context.otg_interfsel);
-
-		usb_phy_set_suspend(musb->xceiv, 0);
+		phy_power_on(musb->phy);
 	}
 
 	return 0;

commit 165f60642ae988f0b9dcfd4988806e7a938b26c7
Merge: c23bda365dfb 8b841cb217fa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 13 15:28:01 2013 -0700

    Merge tag 'usb-for-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v3.12 merge window
    
    All patches here have been pending on linux-usb
    and sitting in linux-next for a while now.
    
    The biggest things in this tag are:
    
    DWC3 learned proper usage of threaded IRQ
    handlers and now we spend very little time
    in hardirq context.
    
    MUSB now has proper support for BeagleBone and
    Beaglebone Black.
    
    Tegra's USB support also got quite a bit of love
    and is learning to use PHY layer and generic DT
    attributes.
    
    Other than that, the usual pack of cleanups and
    non-critical fixes follow.
    
    Signed-of-by: Felipe Balbi <balbi@ti.com>
    
    Conflicts:
            drivers/usb/gadget/udc-core.c
            drivers/usb/host/ehci-tegra.c
            drivers/usb/musb/omap2430.c
            drivers/usb/musb/tusb6010.c

commit c1a7d67c1901347bdb3d06536cd69d018fbf2c4b
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:03:12 2013 +0900

    usb: musb: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 6708a3b78ad8..ebb46eca1791 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -255,7 +255,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
 	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
-	struct musb_hdrc_platform_data *pdata = dev->platform_data;
+	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 	struct usb_otg *otg = musb->xceiv->otg;
 
@@ -341,7 +341,7 @@ static int omap2430_musb_init(struct musb *musb)
 	int status = 0;
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
+	struct musb_hdrc_platform_data *plat = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = plat->board_data;
 
 	/* We require some kind of external transceiver, hooked
@@ -412,7 +412,7 @@ static void omap2430_musb_enable(struct musb *musb)
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
-	struct musb_hdrc_platform_data *pdata = dev->platform_data;
+	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata->board_data;
 
 	switch (glue->status) {
@@ -482,7 +482,7 @@ static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 static int omap2430_probe(struct platform_device *pdev)
 {
 	struct resource			musb_resources[2];
-	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
+	struct musb_hdrc_platform_data	*pdata = dev_get_platdata(&pdev->dev);
 	struct omap_musb_board_data	*data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;

commit c1f01be4060b6f1932e428c209a6c14d6b22fc1c
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Wed Jul 17 10:51:22 2013 +0300

    usb: musb: fix resource passed from glue layer to musb
    
    some MUSB incarnations, such as those governed by
    omap2430.c and tusb6010.c, have three resources, not
    two.
    
    Fix the bug created by commit 09fc7d2 (usb: musb:
    fix incorrect usage of resource pointer) where only
    two of the three resources would be passed to musb_core.c
    
    [ balbi@ti.com : add tusb6010.c to original patch ]
    
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 6708a3b78ad8..f44e8b5e00c9 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -481,7 +481,7 @@ static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 
 static int omap2430_probe(struct platform_device *pdev)
 {
-	struct resource			musb_resources[2];
+	struct resource			musb_resources[3];
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct omap_musb_board_data	*data;
 	struct platform_device		*musb;
@@ -581,6 +581,11 @@ static int omap2430_probe(struct platform_device *pdev)
 	musb_resources[1].end = pdev->resource[1].end;
 	musb_resources[1].flags = pdev->resource[1].flags;
 
+	musb_resources[2].name = pdev->resource[2].name;
+	musb_resources[2].start = pdev->resource[2].start;
+	musb_resources[2].end = pdev->resource[2].end;
+	musb_resources[2].flags = pdev->resource[2].flags;
+
 	ret = platform_device_add_resources(musb, musb_resources,
 			ARRAY_SIZE(musb_resources));
 	if (ret) {

commit 80cc38b16389849a6e06441ace4530f6b2497c3c
Merge: 3366dd9fa887 83a35e360433
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 4 11:40:58 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina:
     "The usual stuff from trivial tree"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (34 commits)
      treewide: relase -> release
      Documentation/cgroups/memory.txt: fix stat file documentation
      sysctl/net.txt: delete reference to obsolete 2.4.x kernel
      spinlock_api_smp.h: fix preprocessor comments
      treewide: Fix typo in printk
      doc: device tree: clarify stuff in usage-model.txt.
      open firmware: "/aliasas" -> "/aliases"
      md: bcache: Fixed a typo with the word 'arithmetic'
      irq/generic-chip: fix a few kernel-doc entries
      frv: Convert use of typedef ctl_table to struct ctl_table
      sgi: xpc: Convert use of typedef ctl_table to struct ctl_table
      doc: clk: Fix incorrect wording
      Documentation/arm/IXP4xx fix a typo
      Documentation/networking/ieee802154 fix a typo
      Documentation/DocBook/media/v4l fix a typo
      Documentation/video4linux/si476x.txt fix a typo
      Documentation/virtual/kvm/api.txt fix a typo
      Documentation/early-userspace/README fix a typo
      Documentation/video4linux/soc-camera.txt fix a typo
      lguest: fix CONFIG_PAE -> CONFIG_x86_PAE in comment
      ...

commit 3a0ddc714a1b8fcbff24c135a1332a28b4668d78
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Jun 25 09:41:02 2013 +0200

    usb: musb: omap2430: make it compile again
    
    it does not compile since 09fc7d ("usb: musb: fix incorrect usage of
    resource pointer"). What makes me wonder most is if source of the
    Tested-by tag :)
    
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c7c1d7ab5471..4315d351fc7d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -481,7 +481,7 @@ static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 
 static int omap2430_probe(struct platform_device *pdev)
 {
-	struct resource musb_resouces[2];
+	struct resource			musb_resources[2];
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct omap_musb_board_data	*data;
 	struct platform_device		*musb;
@@ -568,7 +568,7 @@ static int omap2430_probe(struct platform_device *pdev)
 
 	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
 
-	memset(musb_resouces, 0x00, sizeof(*musb_resources) *
+	memset(musb_resources, 0x00, sizeof(*musb_resources) *
 			ARRAY_SIZE(musb_resources));
 
 	musb_resources[0].name = pdev->resource[0].name;

commit 8b125df5b24cfb0ec7fa1971e343cc0badc1827d
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 21:55:50 2013 +0200

    usb: musb: eliminate musb_to_hcd
    
    With the hcd is now a direct member of struct musb, we can now simply
    eliminate the musb_to_hcd() macro. There aren't that many users left
    anyway, as some where already fixed up when parts were factored out to
    musb_host.c
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b3e77613e0af..c7c1d7ab5471 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -87,7 +87,7 @@ static void musb_do_idle(unsigned long _musb)
 			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
 						| MUSB_PORT_STAT_RESUME);
 			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
-			usb_hcd_poll_rh_status(musb_to_hcd(musb));
+			usb_hcd_poll_rh_status(musb->hcd);
 			/* NOTE: it might really be A_WAIT_BCON ... */
 			musb->xceiv->state = OTG_STATE_A_HOST;
 		}

commit 09fc7d22b024692b2fe8a943b246de1af307132b
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Apr 24 17:21:42 2013 +0300

    usb: musb: fix incorrect usage of resource pointer
    
    We can't simply pass the resource pointer from our
    device down to our children, otherwise module
    reinsertion will not work as the resource will
    continue to be marked as busy.
    
    Fix it by building a proper struct resource for
    our child musb device.
    
    Tested-by: Dmitry Lifshitz <lifshitz@compulab.co.il>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 628b93fe5ccc..b3e77613e0af 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -481,6 +481,7 @@ static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 
 static int omap2430_probe(struct platform_device *pdev)
 {
+	struct resource musb_resouces[2];
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct omap_musb_board_data	*data;
 	struct platform_device		*musb;
@@ -567,8 +568,21 @@ static int omap2430_probe(struct platform_device *pdev)
 
 	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
 
-	ret = platform_device_add_resources(musb, pdev->resource,
-			pdev->num_resources);
+	memset(musb_resouces, 0x00, sizeof(*musb_resources) *
+			ARRAY_SIZE(musb_resources));
+
+	musb_resources[0].name = pdev->resource[0].name;
+	musb_resources[0].start = pdev->resource[0].start;
+	musb_resources[0].end = pdev->resource[0].end;
+	musb_resources[0].flags = pdev->resource[0].flags;
+
+	musb_resources[1].name = pdev->resource[1].name;
+	musb_resources[1].start = pdev->resource[1].start;
+	musb_resources[1].end = pdev->resource[1].end;
+	musb_resources[1].flags = pdev->resource[1].flags;
+
+	ret = platform_device_add_resources(musb, musb_resources,
+			ARRAY_SIZE(musb_resources));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
 		goto err2;

commit 8b513d0cf603c0a9ccf86a92cb22931f05a7bc86
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue May 21 23:13:12 2013 +0900

    treewide: Fix typo in printk
    
    Correct spelling typo in various part of drivers
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 628b93fe5ccc..2325ef6bdeed 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -513,7 +513,7 @@ static int omap2430_probe(struct platform_device *pdev)
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&pdev->dev,
-				"failed to allocate musb platfrom data\n");
+				"failed to allocate musb platform data\n");
 			goto err2;
 		}
 

commit 4b7e450fb5cefb5865c77999a675330206ab3b8a
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Apr 26 14:27:09 2013 +0800

    usb: musb: omap2430: add missing platform_device_put() on error in omap2430_probe()
    
    Add the missing platform_device_put() before return from
    omap2430_probe() in the error handling case.
    
    Introduced by commit ca784be36cc725bca9b526eba342de7550329731
    (usb: start using the control module driver)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 3551f1a30c65..628b93fe5ccc 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -549,7 +549,8 @@ static int omap2430_probe(struct platform_device *pdev)
 		glue->control_otghs = omap_get_control_dev();
 		if (IS_ERR(glue->control_otghs)) {
 			dev_vdbg(&pdev->dev, "Failed to get control device\n");
-			return -ENODEV;
+			ret = PTR_ERR(glue->control_otghs);
+			goto err2;
 		}
 	} else {
 		glue->control_otghs = ERR_PTR(-ENODEV);

commit 2c1fe89db1cfa9826c94e848c14dc68de0e2b0d5
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Sun Mar 24 17:36:54 2013 +0200

    usb: musb: omap2430: turn off vbus on cable disconnect
    
    On USB_EVENT_ID event the musb glue enables VBUS by calling
    omap2430_musb_set_vbus(musb, 1) that sets the session bit, but on
    USB_EVENT_NONE reverse action is never made, and that breaks PM.
    
    Disable VBUS on USB_EVENT_NONE to be sure musb session is ended
    on cable unplug so that PM works.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 798e029e3db0..3551f1a30c65 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -291,6 +291,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
 		if (musb->gadget_driver) {
+			omap2430_musb_set_vbus(musb, 0);
 			pm_runtime_mark_last_busy(dev);
 			pm_runtime_put_autosuspend(dev);
 		}

commit a90199bb947856c24d7bf78845d24f802e09db0a
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Mar 15 10:57:40 2013 +0200

    usb: musb: omap2430: fix PHY error handling
    
    PHY layer no longer returns NULL. It will
    return -ENXIO when PHY layer isn't enabled
    and we can use that to bail out instead of
    request a probe deferral.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ec460eaed842..798e029e3db0 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -353,7 +353,12 @@ static int omap2430_musb_init(struct musb *musb)
 	else
 		musb->xceiv = devm_usb_get_phy_dev(dev, 0);
 
-	if (IS_ERR_OR_NULL(musb->xceiv)) {
+	if (IS_ERR(musb->xceiv)) {
+		status = PTR_ERR(musb->xceiv);
+
+		if (status == -ENXIO)
+			return status;
+
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -EPROBE_DEFER;
 	}

commit 3bf6db9bbe4ad7b08b714c1857a703c1ef1b1e83
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Mar 14 11:53:58 2013 +0530

    usb: musb: omap: add usb_phy_init in omap2430_musb_init
    
    Some PHYs load too early (twl4030) making omap glue to miss cable connect events
    if the board is booted with cable connected. So adding usb_phy_init in
    omap2430_musb_init lets PHYs to report events once glue is ready.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 018373d1c2c4..ec460eaed842 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -391,6 +391,8 @@ static int omap2430_musb_init(struct musb *musb)
 	if (glue->status != OMAP_MUSB_UNKNOWN)
 		omap_musb_set_mailbox(glue);
 
+	usb_phy_init(musb->xceiv);
+
 	pm_runtime_put_noidle(musb->controller);
 	return 0;
 

commit bb467cf5693b59c76c22b73dd383920a87f37b16
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Mar 14 11:53:56 2013 +0530

    usb: musb: omap: remove the check before calling otg_set_vbus
    
    No functional change. otg_set_vbus is already protected so removed the
    check before calling otg_set_vbus.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e7b5eae5a141..018373d1c2c4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -174,8 +174,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 				}
 			}
 
-			if (otg->set_vbus)
-				otg_set_vbus(otg, 1);
+			otg_set_vbus(otg, 1);
 		} else {
 			musb->is_active = 1;
 			otg->default_a = 1;
@@ -296,10 +295,9 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 			pm_runtime_put_autosuspend(dev);
 		}
 
-		if (data->interface_type == MUSB_INTERFACE_UTMI) {
-			if (musb->xceiv->otg->set_vbus)
-				otg_set_vbus(musb->xceiv->otg, 0);
-		}
+		if (data->interface_type == MUSB_INTERFACE_UTMI)
+			otg_set_vbus(musb->xceiv->otg, 0);
+
 		omap_control_usb_set_mode(glue->control_otghs,
 			USB_MODE_DISCONNECT);
 		break;

commit eee44da0453cfe9125f4297e4244fe1d6fb1c653
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Mar 7 18:51:46 2013 +0530

    usb: musb: omap2430: replace *_* with *-* in property names
    
    No functional change. Replace *_* with *-* in property names of otg to
    follow the general convention.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 8ba9bb2a91a7..e7b5eae5a141 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -526,10 +526,10 @@ static int omap2430_probe(struct platform_device *pdev)
 		}
 
 		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
-		of_property_read_u32(np, "interface_type",
+		of_property_read_u32(np, "interface-type",
 						(u32 *)&data->interface_type);
-		of_property_read_u32(np, "num_eps", (u32 *)&config->num_eps);
-		of_property_read_u32(np, "ram_bits", (u32 *)&config->ram_bits);
+		of_property_read_u32(np, "num-eps", (u32 *)&config->num_eps);
+		of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);
 		of_property_read_u32(np, "power", (u32 *)&pdata->power);
 		config->multipoint = of_property_read_bool(np, "multipoint");
 		pdata->has_mailbox = of_property_read_bool(np,

commit 42c0bf1ce7c067bbc3e77d5626f102a16bc4fb6b
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 7 10:39:57 2013 +0200

    usb: otg: prefix otg_state_string with usb_
    
    all other functions under drivers/usb/ start
    with usb_, let's do the same thing.
    
    This patch is in preparation for moving otg_state_string
    to usb-common.c and deleting otg.c completely.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 1a42a458f2c4..8ba9bb2a91a7 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -117,7 +117,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
 			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
 		dev_dbg(musb->controller, "%s active, deleting timer\n",
-			otg_state_string(musb->xceiv->state));
+			usb_otg_state_string(musb->xceiv->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
 		return;
@@ -134,7 +134,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
-		otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
 }
@@ -200,7 +200,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 
 	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
-		otg_state_string(musb->xceiv->state),
+		usb_otg_state_string(musb->xceiv->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 

commit 4b58ed11c681c0779c330f1aa5307b594943b683
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Mar 5 13:04:24 2013 +0200

    usb: musb: omap2430: fix sparse warning
    
    Fix the following sparse warning:
    
    drivers/usb/musb/omap2430.c:54:33: warning: symbol '_glue' was not \
            declared. Should it be static?
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2a39c110d3d5..1a42a458f2c4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -51,7 +51,7 @@ struct omap2430_glue {
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
-struct omap2430_glue		*_glue;
+static struct omap2430_glue	*_glue;
 
 static struct timer_list musb_idle_timer;
 

commit f8c4b0e73b636fe06e8283f29905c2e60ed66fa1
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Tue Mar 5 13:04:23 2013 +0200

    usb: musb: omap2430: fix omap_musb_mailbox glue check again
    
    Commit 80ab72e1 (usb: musb: omap2430: fix the readiness check
    in omap_musb_mailbox) made the check incorrect, as we will lose the
    glue/link status during the normal built-in probe order (twl4030_usb is
    probed after musb omap2430, but before musb core is ready).
    
    As a result, if you boot with USB cable on and load g_ether, the
    connection does not work as the code thinks the cable is off and the
    phy gets powered down immediately. This is a major regression in 3.9-rc1.
    
    So the proper check should be: exit if _glue is NULL, but if it's
    initialized we memorize the status, and then check if the musb core
    is ready.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 1762354fe793..2a39c110d3d5 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -237,9 +237,13 @@ void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
 
-	if (glue && glue_to_musb(glue)) {
-		glue->status = status;
-	} else {
+	if (!glue) {
+		pr_err("%s: musb core is not yet initialized\n", __func__);
+		return;
+	}
+	glue->status = status;
+
+	if (!glue_to_musb(glue)) {
 		pr_err("%s: musb core is not yet ready\n", __func__);
 		return;
 	}

commit 4811f53fada7f2c6616229cc410e79362818a613
Merge: cba6c8502705 5088b6f5bcf1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 25 09:09:46 2013 -0800

    Merge tag 'xceiv-for-v3.9' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
            usb: xceiv: patches for v3.9 merge window
    
            Two new PHY drivers coming here: one for Samsung,
            one for OMAP. Both architectures are adding USB3
            support to mainline kernel.
    
            The PHY layer now allows us to have mulitple PHYs
            of the same type, which is necessary for platforms
            which provide more than one USB peripheral port.
    
            There's also a few cleanups here: removal of __dev*
            annotations, conversion of a cast to to_delayed_work(),
            and mxs-phy learns about ->set_suspend.

commit b16604f2c1dc3f0a326818b282e6bb5f363f725e
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 08:03:26 2013 +0530

    usb: musb: omap: get phy by phandle for dt boot
    
    The OMAP glue has been modified to get PHY by phandle
    for dt boot.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 23df9d7c99f6..d100360eab7a 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -345,7 +345,12 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = devm_usb_get_phy_dev(dev, 0);
+	if (dev->parent->of_node)
+		musb->xceiv = devm_usb_get_phy_by_phandle(dev->parent,
+		    "usb-phy", 0);
+	else
+		musb->xceiv = devm_usb_get_phy_dev(dev, 0);
+
 	if (IS_ERR_OR_NULL(musb->xceiv)) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;

commit c11747f6ce70253dbf73709bb0a5ff19acc48ec8
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 08:03:24 2013 +0530

    usb: musb: omap: make use of the new PHY lib APIs
    
    New PHY lib APIs like usb_add_phy_dev() and devm_usb_get_phy_dev() are
    used in MUSB (OMAP), in order to make use of the binding information
    provided in the board file (of OMAP platforms).
    
    All the platforms should be modified similar to this to add and get the
    PHY.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 779862d24590..23df9d7c99f6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -345,7 +345,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+	musb->xceiv = devm_usb_get_phy_dev(dev, 0);
 	if (IS_ERR_OR_NULL(musb->xceiv)) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;

commit ca784be36cc725bca9b526eba342de7550329731
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 15:54:00 2013 +0530

    usb: start using the control module driver
    
    Start using the control module driver for powering on the PHY and for
    writing to the mailbox instead of writing to the control module
    registers on their own.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index da00af460794..779862d24590 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -37,6 +37,7 @@
 #include <linux/err.h>
 #include <linux/delay.h>
 #include <linux/usb/musb-omap.h>
+#include <linux/usb/omap_control_usb.h>
 
 #include "musb_core.h"
 #include "omap2430.h"
@@ -46,7 +47,7 @@ struct omap2430_glue {
 	struct platform_device	*musb;
 	enum omap_musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
-	u32 __iomem		*control_otghs;
+	struct device		*control_otghs;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -54,26 +55,6 @@ struct omap2430_glue		*_glue;
 
 static struct timer_list musb_idle_timer;
 
-/**
- * omap4_usb_phy_mailbox - write to usb otg mailbox
- * @glue: struct omap2430_glue *
- * @val: the value to be written to the mailbox
- *
- * On detection of a device (ID pin is grounded), this API should be called
- * to set AVALID, VBUSVALID and ID pin is grounded.
- *
- * When OMAP is connected to a host (OMAP in device mode), this API
- * is called to set AVALID, VBUSVALID and ID pin in high impedance.
- *
- * XXX: This function will be removed once we have a seperate driver for
- * control module
- */
-static void omap4_usb_phy_mailbox(struct omap2430_glue *glue, u32 val)
-{
-	if (glue->control_otghs)
-		writel(val, glue->control_otghs);
-}
-
 static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
@@ -269,7 +250,6 @@ EXPORT_SYMBOL_GPL(omap_musb_mailbox);
 
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
-	u32 val;
 	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
@@ -285,8 +265,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
-			val = AVALID | VBUSVALID;
-			omap4_usb_phy_mailbox(glue, val);
+			omap_control_usb_set_mode(glue->control_otghs,
+				USB_MODE_HOST);
 			omap2430_musb_set_vbus(musb, 1);
 		}
 		break;
@@ -299,8 +279,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(dev);
-		val = IDDIG | AVALID | VBUSVALID;
-		omap4_usb_phy_mailbox(glue, val);
+		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
 		break;
 
 	case OMAP_MUSB_ID_FLOAT:
@@ -317,8 +296,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 			if (musb->xceiv->otg->set_vbus)
 				otg_set_vbus(musb->xceiv->otg, 0);
 		}
-		val = SESSEND | IDDIG;
-		omap4_usb_phy_mailbox(glue, val);
+		omap_control_usb_set_mode(glue->control_otghs,
+			USB_MODE_DISCONNECT);
 		break;
 	default:
 		dev_dbg(dev, "ID float\n");
@@ -415,7 +394,6 @@ static int omap2430_musb_init(struct musb *musb)
 static void omap2430_musb_enable(struct musb *musb)
 {
 	u8		devctl;
-	u32		val;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
@@ -425,8 +403,7 @@ static void omap2430_musb_enable(struct musb *musb)
 	switch (glue->status) {
 
 	case OMAP_MUSB_ID_GROUND:
-		val = AVALID | VBUSVALID;
-		omap4_usb_phy_mailbox(glue, val);
+		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_HOST);
 		if (data->interface_type != MUSB_INTERFACE_UTMI)
 			break;
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
@@ -445,8 +422,7 @@ static void omap2430_musb_enable(struct musb *musb)
 		break;
 
 	case OMAP_MUSB_VBUS_VALID:
-		val = IDDIG | AVALID | VBUSVALID;
-		omap4_usb_phy_mailbox(glue, val);
+		omap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);
 		break;
 
 	default:
@@ -456,14 +432,12 @@ static void omap2430_musb_enable(struct musb *musb)
 
 static void omap2430_musb_disable(struct musb *musb)
 {
-	u32 val;
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	if (glue->status != OMAP_MUSB_UNKNOWN) {
-		val = SESSEND | IDDIG;
-		omap4_usb_phy_mailbox(glue, val);
-	}
+	if (glue->status != OMAP_MUSB_UNKNOWN)
+		omap_control_usb_set_mode(glue->control_otghs,
+			USB_MODE_DISCONNECT);
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -498,7 +472,6 @@ static int omap2430_probe(struct platform_device *pdev)
 	struct omap2430_glue		*glue;
 	struct device_node		*np = pdev->dev.of_node;
 	struct musb_hdrc_config		*config;
-	struct resource			*res;
 	int				ret = -ENOMEM;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
@@ -521,12 +494,6 @@ static int omap2430_probe(struct platform_device *pdev)
 	glue->musb			= musb;
 	glue->status			= OMAP_MUSB_UNKNOWN;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-
-	glue->control_otghs = devm_request_and_ioremap(&pdev->dev, res);
-	if (glue->control_otghs == NULL)
-		dev_dbg(&pdev->dev, "Failed to obtain control memory\n");
-
 	if (np) {
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata) {
@@ -558,11 +525,22 @@ static int omap2430_probe(struct platform_device *pdev)
 		of_property_read_u32(np, "ram_bits", (u32 *)&config->ram_bits);
 		of_property_read_u32(np, "power", (u32 *)&pdata->power);
 		config->multipoint = of_property_read_bool(np, "multipoint");
+		pdata->has_mailbox = of_property_read_bool(np,
+		    "ti,has-mailbox");
 
 		pdata->board_data	= data;
 		pdata->config		= config;
 	}
 
+	if (pdata->has_mailbox) {
+		glue->control_otghs = omap_get_control_dev();
+		if (IS_ERR(glue->control_otghs)) {
+			dev_vdbg(&pdev->dev, "Failed to get control device\n");
+			return -ENODEV;
+		}
+	} else {
+		glue->control_otghs = ERR_PTR(-ENODEV);
+	}
 	pdata->platform_ops		= &omap2430_ops;
 
 	platform_set_drvdata(pdev, glue);

commit b37457d80bc3e2a6bb86a6036c572574614a7631
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Jan 8 22:11:14 2013 +0300

    usb: musb: omap2430: fix wrong devm_kzalloc() result check
    
    Commit 00a0b1d58af873d842580dcac55f3b156c3a4077 (usb: musb: omap: Add device
    tree support for omap musb glue) assigns result of devm_kzalloc() call to
    the 'config' variable but then checks for NULL the 'data' variable (already
    checked after previous call). Thus we risk a kernel oops further when data
    pointed by 'config' is written to by subsequent of_property_read_u32() calls
    iff the allocation happens to fail...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b15bb05dc5e8..bb48796e5213 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -543,7 +543,7 @@ static int omap2430_probe(struct platform_device *pdev)
 		}
 
 		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
-		if (!data) {
+		if (!config) {
 			dev_err(&pdev->dev,
 				"failed to allocate musb hdrc config\n");
 			goto err2;

commit 25736e0c8269e9613aa6036fbc591818daa30d14
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Jan 4 23:13:58 2013 +0800

    usb: musb: fix dependency on transceiver driver
    
    This patch let glue driver return -EPROBE_DEFER if the transceiver
    is not readly, so we can support defer probe on musb to fix the
    below error on 3.7-rc5 if transceiver drivers are built as module:
    
    [   19.052490] unable to find transceiver of type USB2 PHY
    [   19.072052] HS USB OTG: no transceiver configured
    [   19.076995] musb-hdrc musb-hdrc.0.auto: musb_init_controller failed with status -19
    [   19.089355] musb-hdrc: probe of musb-hdrc.0.auto rejects match -19
    [   19.096771] driver: 'musb-omap2430': driver_bound: bound to device 'musb-omap2430'
    [   19.105194] bus: 'platform': really_probe: bound device musb-omap2430 to driver musb-omap2430
    [   19.174407] bus: 'platform': add driver twl4030_usb
    [   19.179656] bus: 'platform': driver_probe_device: matched device twl4030_usb with driver twl4030_usb
    [   19.202270] bus: 'platform': really_probe: probing driver twl4030_usb with device twl4030_usb
    [   19.214172] twl4030_usb twl4030_usb: HW_CONDITIONS 0xc0/192; link 3
    [   19.239624] musb-omap2430 musb-omap2430: musb core is not yet ready
    [   19.246765] twl4030_usb twl4030_usb: Initialized TWL4030 USB module
    [   19.254516] driver: 'twl4030_usb': driver_bound: bound to device 'twl4030_usb'
    [   19.263580] bus: 'platform': really_probe: bound device twl4030_usb to driver twl4030_usb
    
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: <stable@vger.kernel.org> v3.8
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index cd06166affee..b15bb05dc5e8 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -369,7 +369,7 @@ static int omap2430_musb_init(struct musb *musb)
 	musb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
 	if (IS_ERR_OR_NULL(musb->xceiv)) {
 		pr_err("HS USB OTG: no transceiver configured\n");
-		return -ENODEV;
+		return -EPROBE_DEFER;
 	}
 
 	musb->isr = omap2430_musb_interrupt;

commit 8df4ce75189807783c4bb4e4337e0f89283e6ca3
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Jan 8 22:13:40 2013 +0300

    usb: musb: omap2430: kill redundant assignments in omap2430_probe()
    
    Commit 00a0b1d58af873d842580dcac55f3b156c3a4077 (usb: musb: omap: Add device
    tree support for omap musb glue) added assignments of the 'ret' variable to
    -ENOMEM on *some* error paths of the calls to devm_kzalloc(), while that
    variable was already pre-initialized for to that value, so these assignments
    were completely redundant. Kill them, fixing overindented string, while at it.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c293dbeb8b24..cd06166affee 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -532,15 +532,13 @@ static int omap2430_probe(struct platform_device *pdev)
 		if (!pdata) {
 			dev_err(&pdev->dev,
 				"failed to allocate musb platfrom data\n");
-			ret = -ENOMEM;
 			goto err2;
 		}
 
 		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 		if (!data) {
 			dev_err(&pdev->dev,
-					"failed to allocate musb board data\n");
-			ret = -ENOMEM;
+				"failed to allocate musb board data\n");
 			goto err2;
 		}
 

commit 80ab72e176d6691fef30ac59e0b5ad16d4180ec5
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Sun Dec 23 01:24:51 2012 +0200

    usb: musb: omap2430: fix the readiness check in omap_musb_mailbox
    
    The check in omap_musb_mailbox does not properly check if the module has
    been fully initialized. The patch fixes that, and the kernel panic below:
    
    $ modprobe twl4030-usb
    [   13.924743] twl4030_usb twl4030-usb.33: HW_CONDITIONS 0xe0/224; link 3
    [   13.940307] Unable to handle kernel NULL pointer dereference at virtual address 00000004
    [   13.948883] pgd = ef27c000
    [   13.951751] [00000004] *pgd=af256831, *pte=00000000, *ppte=00000000
    [   13.958374] Internal error: Oops: 17 [#1] ARM
    [   13.962921] Modules linked in: twl4030_usb(+) omap2430 libcomposite
    [   13.969543] CPU: 0    Not tainted  (3.8.0-rc1-n9xx-11758-ge37a37c-dirty #6)
    [   13.976867] PC is at omap_musb_mailbox+0x18/0x54 [omap2430]
    [   13.982727] LR is at twl4030_usb_probe+0x240/0x354 [twl4030_usb]
    [   13.989013] pc : [<bf013b6c>]    lr : [<bf018958>]    psr: 60000013
    [   13.989013] sp : ef273cf0  ip : ef273d08  fp : ef273d04
    [   14.001068] r10: bf01b000  r9 : bf0191d8  r8 : 00000001
    [   14.006530] r7 : 00000000  r6 : ef140e10  r5 : 00000003  r4 : 00000000
    [   14.013397] r3 : bf0142dc  r2 : 00000006  r1 : 00000000  r0 : 00000003
    [   14.020233] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [   14.027740] Control: 10c5387d  Table: af27c019  DAC: 00000015
    [   14.033752] Process modprobe (pid: 616, stack limit = 0xef272238)
    [   14.040161] Stack: (0xef273cf0 to 0xef274000)
    [   14.044708] 3ce0:                                     ef254310 00000001 ef273d34 ef273d08
    [   14.053314] 3d00: bf018958 bf013b60 bf0190a4 ef254310 c0101550 c0c3a138 ef140e10 ef140e44
    [   14.061889] 3d20: bf019150 00000001 ef273d44 ef273d38 c019890c bf018724 ef273d64 ef273d48
    [   14.070495] 3d40: c01974fc c01988f8 ef140e10 bf019150 ef140e44 00000000 ef273d84 ef273d68
    [   14.079071] 3d60: c0197728 c019748c c0197694 00000000 bf019150 c0197694 ef273dac ef273d88
    [   14.087677] 3d80: c0195c38 c01976a0 ef03610c ef143eb0 c0128954 ef254780 bf019150 c0b19548
    [   14.096252] 3da0: ef273dbc ef273db0 c0197098 c0195bf0 ef273dec ef273dc0 c0196c98 c0197080
    [   14.104858] 3dc0: bf0190a4 c0b27bc0 ef273dec bf019150 bf019190 c0b27bc0 ef272000 00000001
    [   14.113433] 3de0: ef273e14 ef273df0 c0197c18 c0196b30 ef273f48 bf019190 c0b27bc0 ef272000
    [   14.122039] 3e00: 00000001 bf01b000 ef273e24 ef273e18 c0198b28 c0197ba4 ef273e34 ef273e28
    [   14.130615] 3e20: bf01b014 c0198ae8 ef273e8c ef273e38 c0008918 bf01b00c c004f730 c012ba1c
    [   14.139221] 3e40: ef273e74 00000000 c00505b0 c004f72c 00000000 ef273e60 ef273f48 bf019190
    [   14.147796] 3e60: 00000001 ef273f48 bf019190 00000001 ef286340 00000001 bf0191d8 c0065414
    [   14.156402] 3e80: ef273f44 ef273e90 c0067754 c00087fc bf01919c 00007fff c0064794 00000000
    [   14.164978] 3ea0: ef273ecc f0064000 00000001 ef272000 ef272000 00067f39 bf0192b0 bf01919c
    [   14.173583] 3ec0: ef273f0c ef273ed0 c00a6bf0 c00a53fc ff000000 000000d2 c0067dc8 00000000
    [   14.182159] 3ee0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [   14.190765] 3f00: 00000000 00000000 00000000 00000000 00000000 00000000 ffffffff 00002968
    [   14.199340] 3f20: 00080878 00067f39 00000080 c000e2e8 ef272000 00000000 ef273fa4 ef273f48
    [   14.207946] 3f40: c0067e54 c0066188 f0064000 00002968 f0065530 f0065463 f0065fb0 000012c4
    [   14.216522] 3f60: 00001664 00000000 00000000 00000000 00000014 00000015 0000000c 00000000
    [   14.225128] 3f80: 00000008 00000000 00000000 00080370 00080878 0007422c 00000000 ef273fa8
    [   14.233703] 3fa0: c000e140 c0067d80 00080370 00080878 00080878 00002968 00067f39 00000000
    [   14.242309] 3fc0: 00080370 00080878 0007422c 00000080 00074030 00067f39 bec7aef8 00000000
    [   14.250885] 3fe0: b6f05300 bec7ab68 0000e93c b6f05310 60000010 00080878 af7fe821 af7fec21
    [   14.259460] Backtrace:
    [   14.262054] [<bf013b54>] (omap_musb_mailbox+0x0/0x54 [omap2430]) from [<bf018958>] (twl4030_usb_probe+0x240/0x354 [twl4030_usb])
    [   14.274200]  r5:00000001 r4:ef254310
    [   14.277984] [<bf018718>] (twl4030_usb_probe+0x0/0x354 [twl4030_usb]) from [<c019890c>] (platform_drv_probe+0x20/0x24)
    [   14.289123]  r8:00000001 r7:bf019150 r6:ef140e44 r5:ef140e10 r4:c0c3a138
    [   14.296203] [<c01988ec>] (platform_drv_probe+0x0/0x24) from [<c01974fc>] (driver_probe_device+0x7c/0x214)
    [   14.306243] [<c0197480>] (driver_probe_device+0x0/0x214) from [<c0197728>] (__driver_attach+0x94/0x98)
    [   14.316009]  r7:00000000 r6:ef140e44 r5:bf019150 r4:ef140e10
    [   14.321990] [<c0197694>] (__driver_attach+0x0/0x98) from [<c0195c38>] (bus_for_each_dev+0x54/0x88)
    [   14.331390]  r6:c0197694 r5:bf019150 r4:00000000 r3:c0197694
    [   14.337371] [<c0195be4>] (bus_for_each_dev+0x0/0x88) from [<c0197098>] (driver_attach+0x24/0x28)
    [   14.346588]  r6:c0b19548 r5:bf019150 r4:ef254780
    [   14.351440] [<c0197074>] (driver_attach+0x0/0x28) from [<c0196c98>] (bus_add_driver+0x174/0x244)
    [   14.360687] [<c0196b24>] (bus_add_driver+0x0/0x244) from [<c0197c18>] (driver_register+0x80/0x154)
    [   14.370086]  r8:00000001 r7:ef272000 r6:c0b27bc0 r5:bf019190 r4:bf019150
    [   14.377136] [<c0197b98>] (driver_register+0x0/0x154) from [<c0198b28>] (platform_driver_register+0x4c/0x60)
    [   14.387390] [<c0198adc>] (platform_driver_register+0x0/0x60) from [<bf01b014>] (twl4030_usb_init+0x14/0x1c [twl4030_usb])
    [   14.398895] [<bf01b000>] (twl4030_usb_init+0x0/0x1c [twl4030_usb]) from [<c0008918>] (do_one_initcall+0x128/0x1a8)
    [   14.409790] [<c00087f0>] (do_one_initcall+0x0/0x1a8) from [<c0067754>] (load_module+0x15d8/0x1bf8)
    [   14.419189] [<c006617c>] (load_module+0x0/0x1bf8) from [<c0067e54>] (sys_init_module+0xe0/0xf4)
    [   14.428344] [<c0067d74>] (sys_init_module+0x0/0xf4) from [<c000e140>] (ret_fast_syscall+0x0/0x30)
    [   14.437652]  r6:0007422c r5:00080878 r4:00080370
    [   14.442504] Code: e24cb004 e59f3038 e1a05000 e593401c (e5940004)
    [   14.448944] ---[ end trace dbf47e5bc5ba03c2 ]---
    [   14.453826] Kernel panic - not syncing: Fatal exception
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index da00af460794..c293dbeb8b24 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -255,11 +255,11 @@ static inline void omap2430_low_level_init(struct musb *musb)
 void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
 {
 	struct omap2430_glue	*glue = _glue;
-	struct musb		*musb = glue_to_musb(glue);
 
-	glue->status = status;
-	if (!musb) {
-		dev_err(glue->dev, "musb core is not yet ready\n");
+	if (glue && glue_to_musb(glue)) {
+		glue->status = status;
+	} else {
+		pr_err("%s: musb core is not yet ready\n", __func__);
 		return;
 	}
 

commit fb4e98ab63433c4d3a1588ea91c73f1cd7ebaa00
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:20 2012 -0500

    usb: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 06850f22739f..da00af460794 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -605,7 +605,7 @@ static int omap2430_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit omap2430_remove(struct platform_device *pdev)
+static int omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 

commit 41ac7b3ab7fe1d6175839947a877fdf95cbd2211
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:48 2012 -0500

    usb: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Olav Kongas <ok@artecdesign.ee>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 1150b4b6a090..06850f22739f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -490,7 +490,7 @@ static const struct musb_platform_ops omap2430_ops = {
 
 static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 
-static int __devinit omap2430_probe(struct platform_device *pdev)
+static int omap2430_probe(struct platform_device *pdev)
 {
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct omap_musb_board_data	*data;

commit 7690417db5085f0de03aa70b8ca01b0118e8a1b4
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:08 2012 -0500

    usb: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 32f531e7a2e6..1150b4b6a090 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -674,7 +674,7 @@ MODULE_DEVICE_TABLE(of, omap2430_id_table);
 
 static struct platform_driver omap2430_driver = {
 	.probe		= omap2430_probe,
-	.remove		= __devexit_p(omap2430_remove),
+	.remove		= omap2430_remove,
 	.driver		= {
 		.name	= "musb-omap2430",
 		.pm	= DEV_PM_OPS,

commit baef653a500476ccb2d08cf4bb648c56c0170e21
Author: Philippe De Swert <philippedeswert@gmail.com>
Date:   Tue Nov 6 15:32:13 2012 +0200

    usb: musb: remove generic_interrupt
    
    This patch is based on the discussion of a previous patch to fix an issue
    where the omap2430 musb driver is not working for N9/N950.
    
    Moving all the interrupt handling to the devices. Avoids inclusion of generic
    interrupt and breakage due to sometimes misleading CONFIG options. This makes
    sure usb always works if on of the subdrivers is chosen. Tested on Nokia N9/N950.
    
    Partially clean up CONFIG_SOC_OMAP3430 which is not necessary in the cases
    where I removed it. Also helps with the removal work of those options that
    Tony Lindgren predicted would happen at some point.
    
    Signed-off-by: Philippe De Swert <philippe.deswert@jollamobile.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index dddd8f71a176..32f531e7a2e6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -333,6 +333,26 @@ static void omap_musb_mailbox_work(struct work_struct *mailbox_work)
 	omap_musb_set_mailbox(glue);
 }
 
+static irqreturn_t omap2430_musb_interrupt(int irq, void *__hci)
+{
+	unsigned long   flags;
+	irqreturn_t     retval = IRQ_NONE;
+	struct musb     *musb = __hci;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	musb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);
+	musb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);
+	musb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);
+
+	if (musb->int_usb || musb->int_tx || musb->int_rx)
+		retval = musb_interrupt(musb);
+
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return retval;
+}
+
 static int omap2430_musb_init(struct musb *musb)
 {
 	u32 l;
@@ -352,6 +372,8 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
+	musb->isr = omap2430_musb_interrupt;
+
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
 		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);

commit 2f7711642559851c187d09795a3eb51c2bde36ec
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Oct 31 16:12:43 2012 +0100

    usb: musb: remove hand-crafted id handling
    
    This replaced the handcrafted id handling by the PLATFORM_DEVID_AUTO
    value which should do the same thing.
    
    This patch probably also fixes ux500 because I did not find the "musbid"
    variable to remove. And we close a tiny-unlikely race window becuase the
    old code gave the id back before device was destroyed in the remove
    case.
    
    [ balbi@ti.com : fixed up two failed hunks when applying patch ]
    
    Cc: B, Ravi <ravibabu@ti.com>
    Cc: Santhapuri, Damodar <damodar.santhapuri@ti.com>
    Cc: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
    Cc: Bob Liu <lliubbo@gmail.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a538fe17a966..dddd8f71a176 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -478,7 +478,6 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_config		*config;
 	struct resource			*res;
 	int				ret = -ENOMEM;
-	int				musbid;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue) {
@@ -486,21 +485,12 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 		goto err0;
 	}
 
-	/* get the musb id */
-	musbid = musb_get_id(&pdev->dev, GFP_KERNEL);
-	if (musbid < 0) {
-		dev_err(&pdev->dev, "failed to allocate musb id\n");
-		ret = -ENOMEM;
-		goto err0;
-	}
-
-	musb = platform_device_alloc("musb-hdrc", musbid);
+	musb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);
 	if (!musb) {
 		dev_err(&pdev->dev, "failed to allocate musb device\n");
-		goto err1;
+		goto err0;
 	}
 
-	musb->id			= musbid;
 	musb->dev.parent		= &pdev->dev;
 	musb->dev.dma_mask		= &omap2430_dmamask;
 	musb->dev.coherent_dma_mask	= omap2430_dmamask;
@@ -521,7 +511,7 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev,
 				"failed to allocate musb platfrom data\n");
 			ret = -ENOMEM;
-			goto err1;
+			goto err2;
 		}
 
 		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
@@ -529,14 +519,14 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev,
 					"failed to allocate musb board data\n");
 			ret = -ENOMEM;
-			goto err1;
+			goto err2;
 		}
 
 		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
 		if (!data) {
 			dev_err(&pdev->dev,
 				"failed to allocate musb hdrc config\n");
-			goto err1;
+			goto err2;
 		}
 
 		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
@@ -589,9 +579,6 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 err2:
 	platform_device_put(musb);
 
-err1:
-	musb_put_id(&pdev->dev, musbid);
-
 err0:
 	return ret;
 }
@@ -601,7 +588,6 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
-	musb_put_id(&pdev->dev, glue->musb->id);
 	platform_device_unregister(glue->musb);
 
 	return 0;

commit 65b3d52d02a558fbfe08e43688e15390c5ab3067
Author: B, Ravi <ravibabu@ti.com>
Date:   Fri Aug 31 11:09:49 2012 +0000

    usb: musb: add musb_ida for multi instance support
    
    Added musb_ida in musb_core.c to manage the multi core ids.
    
    Signed-off-by: Ravi Babu <ravibabu@ti.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Santhapuri, Damodar <damodar.santhapuri@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d96873ba97c7..a538fe17a966 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -478,6 +478,7 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_config		*config;
 	struct resource			*res;
 	int				ret = -ENOMEM;
+	int				musbid;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue) {
@@ -485,12 +486,21 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 		goto err0;
 	}
 
-	musb = platform_device_alloc("musb-hdrc", -1);
+	/* get the musb id */
+	musbid = musb_get_id(&pdev->dev, GFP_KERNEL);
+	if (musbid < 0) {
+		dev_err(&pdev->dev, "failed to allocate musb id\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	musb = platform_device_alloc("musb-hdrc", musbid);
 	if (!musb) {
 		dev_err(&pdev->dev, "failed to allocate musb device\n");
-		goto err0;
+		goto err1;
 	}
 
+	musb->id			= musbid;
 	musb->dev.parent		= &pdev->dev;
 	musb->dev.dma_mask		= &omap2430_dmamask;
 	musb->dev.coherent_dma_mask	= omap2430_dmamask;
@@ -557,13 +567,13 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 			pdev->num_resources);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err1;
+		goto err2;
 	}
 
 	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err1;
+		goto err2;
 	}
 
 	pm_runtime_enable(&pdev->dev);
@@ -571,14 +581,17 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err1;
+		goto err2;
 	}
 
 	return 0;
 
-err1:
+err2:
 	platform_device_put(musb);
 
+err1:
+	musb_put_id(&pdev->dev, musbid);
+
 err0:
 	return ret;
 }
@@ -588,6 +601,7 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
+	musb_put_id(&pdev->dev, glue->musb->id);
 	platform_device_unregister(glue->musb);
 
 	return 0;

commit 00a0b1d58af873d842580dcac55f3b156c3a4077
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Tue Sep 11 14:39:40 2012 +0530

    usb: musb: omap: Add device tree support for omap musb glue
    
    Added device tree support for omap musb driver and updated the
    Documentation with device tree binding information.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index f4d95037db5d..d96873ba97c7 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -30,6 +30,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/io.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/pm_runtime.h>
@@ -470,8 +471,11 @@ static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 static int __devinit omap2430_probe(struct platform_device *pdev)
 {
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
+	struct omap_musb_board_data	*data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;
+	struct device_node		*np = pdev->dev.of_node;
+	struct musb_hdrc_config		*config;
 	struct resource			*res;
 	int				ret = -ENOMEM;
 
@@ -501,6 +505,42 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	if (glue->control_otghs == NULL)
 		dev_dbg(&pdev->dev, "Failed to obtain control memory\n");
 
+	if (np) {
+		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&pdev->dev,
+				"failed to allocate musb platfrom data\n");
+			ret = -ENOMEM;
+			goto err1;
+		}
+
+		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+		if (!data) {
+			dev_err(&pdev->dev,
+					"failed to allocate musb board data\n");
+			ret = -ENOMEM;
+			goto err1;
+		}
+
+		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
+		if (!data) {
+			dev_err(&pdev->dev,
+				"failed to allocate musb hdrc config\n");
+			goto err1;
+		}
+
+		of_property_read_u32(np, "mode", (u32 *)&pdata->mode);
+		of_property_read_u32(np, "interface_type",
+						(u32 *)&data->interface_type);
+		of_property_read_u32(np, "num_eps", (u32 *)&config->num_eps);
+		of_property_read_u32(np, "ram_bits", (u32 *)&config->ram_bits);
+		of_property_read_u32(np, "power", (u32 *)&pdata->power);
+		config->multipoint = of_property_read_bool(np, "multipoint");
+
+		pdata->board_data	= data;
+		pdata->config		= config;
+	}
+
 	pdata->platform_ops		= &omap2430_ops;
 
 	platform_set_drvdata(pdev, glue);
@@ -597,12 +637,26 @@ static struct dev_pm_ops omap2430_pm_ops = {
 #define DEV_PM_OPS	NULL
 #endif
 
+#ifdef CONFIG_OF
+static const struct of_device_id omap2430_id_table[] = {
+	{
+		.compatible = "ti,omap4-musb"
+	},
+	{
+		.compatible = "ti,omap3-musb"
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, omap2430_id_table);
+#endif
+
 static struct platform_driver omap2430_driver = {
 	.probe		= omap2430_probe,
 	.remove		= __devexit_p(omap2430_remove),
 	.driver		= {
 		.name	= "musb-omap2430",
 		.pm	= DEV_PM_OPS,
+		.of_match_table = of_match_ptr(omap2430_id_table),
 	},
 };
 

commit 5ec40590765b8571ae6218f1bc421ec63d3e91c2
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Tue Sep 11 14:39:39 2012 +0530

    usb: musb: omap: write directly to mailbox instead of using phy
    
    The glue layer should directly write to mailbox register (present in
    control module) instead of calling phy layer to write to mailbox
    register. Writing to mailbox register notifies the core of events like
    device connect/disconnect.
    
    Currently writing to control module register is taken care in this
    driver which will be removed once the control module driver is in place.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 02c39a72b27e..f4d95037db5d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -45,6 +45,7 @@ struct omap2430_glue {
 	struct platform_device	*musb;
 	enum omap_musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
+	u32 __iomem		*control_otghs;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -52,6 +53,26 @@ struct omap2430_glue		*_glue;
 
 static struct timer_list musb_idle_timer;
 
+/**
+ * omap4_usb_phy_mailbox - write to usb otg mailbox
+ * @glue: struct omap2430_glue *
+ * @val: the value to be written to the mailbox
+ *
+ * On detection of a device (ID pin is grounded), this API should be called
+ * to set AVALID, VBUSVALID and ID pin is grounded.
+ *
+ * When OMAP is connected to a host (OMAP in device mode), this API
+ * is called to set AVALID, VBUSVALID and ID pin in high impedance.
+ *
+ * XXX: This function will be removed once we have a seperate driver for
+ * control module
+ */
+static void omap4_usb_phy_mailbox(struct omap2430_glue *glue, u32 val)
+{
+	if (glue->control_otghs)
+		writel(val, glue->control_otghs);
+}
+
 static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
@@ -247,6 +268,7 @@ EXPORT_SYMBOL_GPL(omap_musb_mailbox);
 
 static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
+	u32 val;
 	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
@@ -262,7 +284,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
-			usb_phy_init(musb->xceiv);
+			val = AVALID | VBUSVALID;
+			omap4_usb_phy_mailbox(glue, val);
 			omap2430_musb_set_vbus(musb, 1);
 		}
 		break;
@@ -275,7 +298,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(dev);
-		usb_phy_init(musb->xceiv);
+		val = IDDIG | AVALID | VBUSVALID;
+		omap4_usb_phy_mailbox(glue, val);
 		break;
 
 	case OMAP_MUSB_ID_FLOAT:
@@ -292,7 +316,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 			if (musb->xceiv->otg->set_vbus)
 				otg_set_vbus(musb->xceiv->otg, 0);
 		}
-		usb_phy_shutdown(musb->xceiv);
+		val = SESSEND | IDDIG;
+		omap4_usb_phy_mailbox(glue, val);
 		break;
 	default:
 		dev_dbg(dev, "ID float\n");
@@ -367,6 +392,7 @@ static int omap2430_musb_init(struct musb *musb)
 static void omap2430_musb_enable(struct musb *musb)
 {
 	u8		devctl;
+	u32		val;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
@@ -376,7 +402,8 @@ static void omap2430_musb_enable(struct musb *musb)
 	switch (glue->status) {
 
 	case OMAP_MUSB_ID_GROUND:
-		usb_phy_init(musb->xceiv);
+		val = AVALID | VBUSVALID;
+		omap4_usb_phy_mailbox(glue, val);
 		if (data->interface_type != MUSB_INTERFACE_UTMI)
 			break;
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
@@ -395,7 +422,8 @@ static void omap2430_musb_enable(struct musb *musb)
 		break;
 
 	case OMAP_MUSB_VBUS_VALID:
-		usb_phy_init(musb->xceiv);
+		val = IDDIG | AVALID | VBUSVALID;
+		omap4_usb_phy_mailbox(glue, val);
 		break;
 
 	default:
@@ -405,11 +433,14 @@ static void omap2430_musb_enable(struct musb *musb)
 
 static void omap2430_musb_disable(struct musb *musb)
 {
+	u32 val;
 	struct device *dev = musb->controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 
-	if (glue->status != OMAP_MUSB_UNKNOWN)
-		usb_phy_shutdown(musb->xceiv);
+	if (glue->status != OMAP_MUSB_UNKNOWN) {
+		val = SESSEND | IDDIG;
+		omap4_usb_phy_mailbox(glue, val);
+	}
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -441,6 +472,7 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;
+	struct resource			*res;
 	int				ret = -ENOMEM;
 
 	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
@@ -463,6 +495,12 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	glue->musb			= musb;
 	glue->status			= OMAP_MUSB_UNKNOWN;
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+
+	glue->control_otghs = devm_request_and_ioremap(&pdev->dev, res);
+	if (glue->control_otghs == NULL)
+		dev_dbg(&pdev->dev, "Failed to obtain control memory\n");
+
 	pdata->platform_ops		= &omap2430_ops;
 
 	platform_set_drvdata(pdev, glue);

commit 10770c5aa0fe686014e9c15906a3ff702a4b0baf
Author: Matthias Brugger <mbrugger@iseebcn.com>
Date:   Thu Aug 16 13:00:25 2012 +0200

    usb: musb: omap2430.c delete unused variable.
    
    Variable ret is always evaluated as true, so we don't need to check it.
    
    Signed-off-by: Matthias Brugger <mbrugger@iseebcn.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index af5f4214673d..02c39a72b27e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -141,7 +141,6 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 	struct usb_otg	*otg = musb->xceiv->otg;
 	u8		devctl;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	int ret = 1;
 	/* HDRC controls CPEN, but beware current surges during device
 	 * connect.  They can trigger transient overcurrent conditions
 	 * that must be ignored.
@@ -168,12 +167,11 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 				    || loops-- <= 0) {
 					dev_err(musb->controller,
 					"configured as A device timeout");
-					ret = -EINVAL;
 					break;
 				}
 			}
 
-			if (ret && otg->set_vbus)
+			if (otg->set_vbus)
 				otg_set_vbus(otg, 1);
 		} else {
 			musb->is_active = 1;

commit 12a19b5f836c1a1b838e668f9aa804d017d8c58b
Author: NeilBrown <neilb@suse.de>
Date:   Mon Aug 13 12:32:58 2012 +1000

    usb: musb: omap2430: don't loop indefinitely in interrupt.
    
    When called during resume_irqs, omap2430_musb_set_vbus() is run with
    interrupts disabled,  In that case 'jiffies' never changes so the loop
    can loop forever.
    
    So impose a maximum loop count and add an 'mdelay' to ensure we wait
    a reasonable amount of time for bit to be cleared.
    
    This fixes a hang on resume.
    
    Signed-of-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e32aff9920f2..af5f4214673d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -34,6 +34,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/pm_runtime.h>
 #include <linux/err.h>
+#include <linux/delay.h>
 #include <linux/usb/musb-omap.h>
 
 #include "musb_core.h"
@@ -150,6 +151,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 
 	if (is_on) {
 		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
+			int loops = 100;
 			/* start the session */
 			devctl |= MUSB_DEVCTL_SESSION;
 			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
@@ -159,9 +161,11 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 			 */
 			while (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {
 
+				mdelay(5);
 				cpu_relax();
 
-				if (time_after(jiffies, timeout)) {
+				if (time_after(jiffies, timeout)
+				    || loops-- <= 0) {
 					dev_err(musb->controller,
 					"configured as A device timeout");
 					ret = -EINVAL;

commit 032ec49f5351e9cb242b1a1c367d14415043ab95
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Nov 24 15:46:26 2011 +0200

    usb: musb: drop useless board_mode usage
    
    we are compiling the driver always with full OTG
    capabilities, so that board_mode trick becomes
    useless.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 392fc7a488f2..e32aff9920f2 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -258,7 +258,7 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		otg->default_a = true;
 		musb->xceiv->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
-		if (!is_otg_enabled(musb) || musb->gadget_driver) {
+		if (musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
 			usb_phy_init(musb->xceiv);
 			omap2430_musb_set_vbus(musb, 1);
@@ -281,11 +281,10 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 		dev_dbg(dev, "VBUS Disconnect\n");
 
 		musb->xceiv->last_event = USB_EVENT_NONE;
-		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
-			if (musb->gadget_driver) {
-				pm_runtime_mark_last_busy(dev);
-				pm_runtime_put_autosuspend(dev);
-			}
+		if (musb->gadget_driver) {
+			pm_runtime_mark_last_busy(dev);
+			pm_runtime_put_autosuspend(dev);
+		}
 
 		if (data->interface_type == MUSB_INTERFACE_UTMI) {
 			if (musb->xceiv->otg->set_vbus)

commit f039df580a518df49abff35fec970268bc3c51e3
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Aug 2 15:30:07 2012 +0530

    usb: musb: cleanup while removing musb omap glue driver
    
    No functional change. Just replaced the call to platform_device_del and
    platform_device_put with platform_device_unregister.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5fdb9da8dd56..392fc7a488f2 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -509,8 +509,7 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
-	platform_device_del(glue->musb);
-	platform_device_put(glue->musb);
+	platform_device_unregister(glue->musb);
 
 	return 0;
 }

commit ded017ee6c7b90f7356bd8488f8af1c10ba90490
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Tue Jun 26 17:40:32 2012 +0530

    usb: phy: fix return value check of usb_get_phy
    
    usb_get_phy will return -ENODEV if it's not able to find the phy. Hence
    fixed all the callers of usb_get_phy to check for this error condition
    instead of relying on a non-zero value as success condition.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2813490ba631..5fdb9da8dd56 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -320,7 +320,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * which needs a driver, drivers aren't always needed.
 	 */
 	musb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
-	if (!musb->xceiv) {
+	if (IS_ERR_OR_NULL(musb->xceiv)) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;
 	}

commit b1183c242a60764afbdfaf39396405b7afa1106c
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:40:54 2012 +0530

    usb: musb: omap: use devres API to allocate resources
    
    used devres API while allocating memory resource and while getting
    usb phy so that these resources are released automatically on driver
    detach.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c4dc92bd7e85..2813490ba631 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -319,7 +319,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);
+	musb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
 	if (!musb->xceiv) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;
@@ -416,7 +416,6 @@ static int omap2430_musb_exit(struct musb *musb)
 	del_timer_sync(&musb_idle_timer);
 
 	omap2430_low_level_exit(musb);
-	usb_put_phy(musb->xceiv);
 
 	return 0;
 }
@@ -443,7 +442,7 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	struct omap2430_glue		*glue;
 	int				ret = -ENOMEM;
 
-	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
+	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue) {
 		dev_err(&pdev->dev, "failed to allocate glue context\n");
 		goto err0;
@@ -452,7 +451,7 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	musb = platform_device_alloc("musb-hdrc", -1);
 	if (!musb) {
 		dev_err(&pdev->dev, "failed to allocate musb device\n");
-		goto err1;
+		goto err0;
 	}
 
 	musb->dev.parent		= &pdev->dev;
@@ -479,13 +478,13 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 			pdev->num_resources);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err2;
+		goto err1;
 	}
 
 	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err2;
+		goto err1;
 	}
 
 	pm_runtime_enable(&pdev->dev);
@@ -493,16 +492,13 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err2;
+		goto err1;
 	}
 
 	return 0;
 
-err2:
-	platform_device_put(musb);
-
 err1:
-	kfree(glue);
+	platform_device_put(musb);
 
 err0:
 	return ret;
@@ -515,7 +511,6 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
-	kfree(glue);
 
 	return 0;
 }

commit c83a8542b5e3c5b30825955a68b1cc8bd24b122a
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:40:53 2012 +0530

    usb: musb: move otg specific initializations from twl to glue
    
    Moved otg specific state(OTG_STATE_B_IDLE, OTG_STATE_A_IDLE) initializations
    from twl to glue. These initializations are removed from twl4030 and
    twl6030 and moved to the mailbox API defined in glue.
    This is part of the cleanup in preparation to make use of usb2 phy
    driver.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 063687085d1e..c4dc92bd7e85 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -249,11 +249,14 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
+	struct usb_otg *otg = musb->xceiv->otg;
 
 	switch (glue->status) {
 	case OMAP_MUSB_ID_GROUND:
 		dev_dbg(dev, "ID GND\n");
 
+		otg->default_a = true;
+		musb->xceiv->state = OTG_STATE_A_IDLE;
 		musb->xceiv->last_event = USB_EVENT_ID;
 		if (!is_otg_enabled(musb) || musb->gadget_driver) {
 			pm_runtime_get_sync(dev);
@@ -265,6 +268,8 @@ static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 	case OMAP_MUSB_VBUS_VALID:
 		dev_dbg(dev, "VBUS Connect\n");
 
+		otg->default_a = false;
+		musb->xceiv->state = OTG_STATE_B_IDLE;
 		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(dev);

commit c9721438c009adf8e81d376839ed037c53b9b8d9
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:40:52 2012 +0530

    usb: musb: twl: use mailbox API to send VBUS or ID events
    
    The atomic notifier from twl4030/twl6030 to notifiy VBUS and ID events,
    is replaced by a direct call to omap musb blue.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index f40c8053a291..063687085d1e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -34,6 +34,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/pm_runtime.h>
 #include <linux/err.h>
+#include <linux/usb/musb-omap.h>
 
 #include "musb_core.h"
 #include "omap2430.h"
@@ -41,11 +42,13 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
-	u8			xceiv_event;
+	enum omap_musb_vbus_id_status status;
 	struct work_struct	omap_musb_mailbox_work;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
+struct omap2430_glue		*_glue;
+
 static struct timer_list musb_idle_timer;
 
 static void musb_do_idle(unsigned long _musb)
@@ -225,54 +228,58 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
-static int musb_otg_notifications(struct notifier_block *nb,
-		unsigned long event, void *unused)
+void omap_musb_mailbox(enum omap_musb_vbus_id_status status)
 {
-	struct musb		*musb = container_of(nb, struct musb, nb);
-	struct device		*dev = musb->controller;
-	struct omap2430_glue	*glue = dev_get_drvdata(dev->parent);
+	struct omap2430_glue	*glue = _glue;
+	struct musb		*musb = glue_to_musb(glue);
 
-	glue->xceiv_event = event;
-	schedule_work(&glue->omap_musb_mailbox_work);
+	glue->status = status;
+	if (!musb) {
+		dev_err(glue->dev, "musb core is not yet ready\n");
+		return;
+	}
 
-	return NOTIFY_OK;
+	schedule_work(&glue->omap_musb_mailbox_work);
 }
+EXPORT_SYMBOL_GPL(omap_musb_mailbox);
 
-static void omap_musb_mailbox_work(struct work_struct *data_notifier_work)
+static void omap_musb_set_mailbox(struct omap2430_glue *glue)
 {
-	struct omap2430_glue *glue = container_of(data_notifier_work,
-		struct omap2430_glue, omap_musb_mailbox_work);
 	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	switch (glue->xceiv_event) {
-	case USB_EVENT_ID:
-		dev_dbg(musb->controller, "ID GND\n");
+	switch (glue->status) {
+	case OMAP_MUSB_ID_GROUND:
+		dev_dbg(dev, "ID GND\n");
 
+		musb->xceiv->last_event = USB_EVENT_ID;
 		if (!is_otg_enabled(musb) || musb->gadget_driver) {
-			pm_runtime_get_sync(musb->controller);
+			pm_runtime_get_sync(dev);
 			usb_phy_init(musb->xceiv);
 			omap2430_musb_set_vbus(musb, 1);
 		}
 		break;
 
-	case USB_EVENT_VBUS:
-		dev_dbg(musb->controller, "VBUS Connect\n");
+	case OMAP_MUSB_VBUS_VALID:
+		dev_dbg(dev, "VBUS Connect\n");
 
+		musb->xceiv->last_event = USB_EVENT_VBUS;
 		if (musb->gadget_driver)
-			pm_runtime_get_sync(musb->controller);
+			pm_runtime_get_sync(dev);
 		usb_phy_init(musb->xceiv);
 		break;
 
-	case USB_EVENT_NONE:
-		dev_dbg(musb->controller, "VBUS Disconnect\n");
+	case OMAP_MUSB_ID_FLOAT:
+	case OMAP_MUSB_VBUS_OFF:
+		dev_dbg(dev, "VBUS Disconnect\n");
 
+		musb->xceiv->last_event = USB_EVENT_NONE;
 		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
 			if (musb->gadget_driver) {
-				pm_runtime_mark_last_busy(musb->controller);
-				pm_runtime_put_autosuspend(musb->controller);
+				pm_runtime_mark_last_busy(dev);
+				pm_runtime_put_autosuspend(dev);
 			}
 
 		if (data->interface_type == MUSB_INTERFACE_UTMI) {
@@ -282,15 +289,24 @@ static void omap_musb_mailbox_work(struct work_struct *data_notifier_work)
 		usb_phy_shutdown(musb->xceiv);
 		break;
 	default:
-		dev_dbg(musb->controller, "ID float\n");
+		dev_dbg(dev, "ID float\n");
 	}
 }
 
+
+static void omap_musb_mailbox_work(struct work_struct *mailbox_work)
+{
+	struct omap2430_glue *glue = container_of(mailbox_work,
+				struct omap2430_glue, omap_musb_mailbox_work);
+	omap_musb_set_mailbox(glue);
+}
+
 static int omap2430_musb_init(struct musb *musb)
 {
 	u32 l;
 	int status = 0;
 	struct device *dev = musb->controller;
+	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 	struct musb_hdrc_platform_data *plat = dev->platform_data;
 	struct omap_musb_board_data *data = plat->board_data;
 
@@ -330,14 +346,11 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
-	musb->nb.notifier_call = musb_otg_notifications;
-	status = usb_register_notifier(musb->xceiv, &musb->nb);
-
-	if (status)
-		dev_dbg(musb->controller, "notification register failed\n");
-
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
+	if (glue->status != OMAP_MUSB_UNKNOWN)
+		omap_musb_set_mailbox(glue);
+
 	pm_runtime_put_noidle(musb->controller);
 	return 0;
 
@@ -350,12 +363,13 @@ static void omap2430_musb_enable(struct musb *musb)
 	u8		devctl;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	struct device *dev = musb->controller;
+	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	switch (musb->xceiv->last_event) {
+	switch (glue->status) {
 
-	case USB_EVENT_ID:
+	case OMAP_MUSB_ID_GROUND:
 		usb_phy_init(musb->xceiv);
 		if (data->interface_type != MUSB_INTERFACE_UTMI)
 			break;
@@ -374,7 +388,7 @@ static void omap2430_musb_enable(struct musb *musb)
 		}
 		break;
 
-	case USB_EVENT_VBUS:
+	case OMAP_MUSB_VBUS_VALID:
 		usb_phy_init(musb->xceiv);
 		break;
 
@@ -385,7 +399,10 @@ static void omap2430_musb_enable(struct musb *musb)
 
 static void omap2430_musb_disable(struct musb *musb)
 {
-	if (musb->xceiv->last_event)
+	struct device *dev = musb->controller;
+	struct omap2430_glue *glue = dev_get_drvdata(dev->parent);
+
+	if (glue->status != OMAP_MUSB_UNKNOWN)
 		usb_phy_shutdown(musb->xceiv);
 }
 
@@ -439,11 +456,18 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
+	glue->status			= OMAP_MUSB_UNKNOWN;
 
 	pdata->platform_ops		= &omap2430_ops;
 
 	platform_set_drvdata(pdev, glue);
 
+	/*
+	 * REVISIT if we ever have two instances of the wrapper, we will be
+	 * in big trouble
+	 */
+	_glue	= glue;
+
 	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
 
 	ret = platform_device_add_resources(musb, pdev->resource,
@@ -552,7 +576,7 @@ static int __init omap2430_init(void)
 {
 	return platform_driver_register(&omap2430_driver);
 }
-module_init(omap2430_init);
+subsys_initcall(omap2430_init);
 
 static void __exit omap2430_exit(void)
 {

commit 1e5acb8d6113a0f159257845e153d5b870ca618a
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:40:51 2012 +0530

    usb: musb: move work_struct(otg_notifier_work) from core to omap glue
    
    Commit 712d8e(fixes pm_runtime calls while atomic by using a work
    queue. musb pm_runtime_get_sync call happens in interrupt context
    on cable attach case. That can result in re-enabling the interrupts and
    cause side affect. To avoid this deferred processing is used)
    
    While the issue and the work queue implementation is specific to omap
    (omap2430.c), the work_struct is defined as a member of struct musb
    (musb_core.h). Hence moved the work_struct from musb_core to omap
    glue.
    
    Cc: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e279cf32772e..f40c8053a291 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -41,6 +41,8 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
+	u8			xceiv_event;
+	struct work_struct	omap_musb_mailbox_work;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -226,22 +228,26 @@ static inline void omap2430_low_level_init(struct musb *musb)
 static int musb_otg_notifications(struct notifier_block *nb,
 		unsigned long event, void *unused)
 {
-	struct musb	*musb = container_of(nb, struct musb, nb);
+	struct musb		*musb = container_of(nb, struct musb, nb);
+	struct device		*dev = musb->controller;
+	struct omap2430_glue	*glue = dev_get_drvdata(dev->parent);
 
-	musb->xceiv_event = event;
-	schedule_work(&musb->otg_notifier_work);
+	glue->xceiv_event = event;
+	schedule_work(&glue->omap_musb_mailbox_work);
 
 	return NOTIFY_OK;
 }
 
-static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
+static void omap_musb_mailbox_work(struct work_struct *data_notifier_work)
 {
-	struct musb *musb = container_of(data_notifier_work, struct musb, otg_notifier_work);
+	struct omap2430_glue *glue = container_of(data_notifier_work,
+		struct omap2430_glue, omap_musb_mailbox_work);
+	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	switch (musb->xceiv_event) {
+	switch (glue->xceiv_event) {
 	case USB_EVENT_ID:
 		dev_dbg(musb->controller, "ID GND\n");
 
@@ -298,8 +304,6 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
-	INIT_WORK(&musb->otg_notifier_work, musb_otg_notifier_work);
-
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
 		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
@@ -388,7 +392,6 @@ static void omap2430_musb_disable(struct musb *musb)
 static int omap2430_musb_exit(struct musb *musb)
 {
 	del_timer_sync(&musb_idle_timer);
-	cancel_work_sync(&musb->otg_notifier_work);
 
 	omap2430_low_level_exit(musb);
 	usb_put_phy(musb->xceiv);
@@ -441,6 +444,8 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, glue);
 
+	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
+
 	ret = platform_device_add_resources(musb, pdev->resource,
 			pdev->num_resources);
 	if (ret) {
@@ -478,6 +483,7 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
+	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
 	kfree(glue);

commit 662dca54ca67c92b7aa14b9a2ec54acacf33ce45
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:02:46 2012 +0530

    usb: otg: support for multiple transceivers by a single controller
    
    Add a linked list for keeping multiple PHY instances with different
    types so that we can have separate USB2 and USB3 PHYs on one single
    board. _get_phy_ has been changed so that the controller gets
    the transceiver by type. _remove_phy_ has been added to let the phy
    be removed from the phy list.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e16dbbf7f305..e279cf32772e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -292,7 +292,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = usb_get_phy();
+	musb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);
 	if (!musb->xceiv) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;

commit 721002ec1dd55a52425455826af49cf8853b2d4f
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:02:45 2012 +0530

    usb: otg: utils: rename function name in OTG utils
    
    _transceiver() in otg.c is replaced with _phy. usb_set_transceiver is
    replaced with usb_add_phy to make it similar to other usb standard
    function names like usb_add_hcd.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c7785e81254c..e16dbbf7f305 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -292,7 +292,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = usb_get_transceiver();
+	musb->xceiv = usb_get_phy();
 	if (!musb->xceiv) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;
@@ -391,7 +391,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	cancel_work_sync(&musb->otg_notifier_work);
 
 	omap2430_low_level_exit(musb);
-	usb_put_transceiver(musb->xceiv);
+	usb_put_phy(musb->xceiv);
 
 	return 0;
 }

commit ad579699c4f0274bf522a9252ff9b20c72197e48
Author: Shubhrajyoti D <shubhrajyoti@ti.com>
Date:   Thu Mar 22 12:48:06 2012 +0530

    usb: musb: omap: fix the error check for pm_runtime_get_sync
    
    pm_runtime_get_sync returns a signed integer. In case of errors
    it returns a negative value. This patch fixes the error check
    by making it signed instead of unsigned thus preventing register
    access if get_sync_fails. Also passes the error cause to the
    debug message.
    
    Cc: stable@vger.kernel.org
    Cc:  Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Shubhrajyoti D <shubhrajyoti@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 0fb4ce84d17e..c7785e81254c 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -282,7 +282,8 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 
 static int omap2430_musb_init(struct musb *musb)
 {
-	u32 l, status = 0;
+	u32 l;
+	int status = 0;
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *plat = dev->platform_data;
 	struct omap_musb_board_data *data = plat->board_data;
@@ -301,7 +302,7 @@ static int omap2430_musb_init(struct musb *musb)
 
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
-		dev_err(dev, "pm_runtime_get_sync FAILED");
+		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
 		goto err1;
 	}
 

commit 3006dc8c627d738693e910c159630e4368c9e86c
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Wed Mar 21 21:30:20 2012 +0530

    usb: musb: omap: fix crash when musb glue (omap) gets initialized
    
    pm_runtime_enable is being called after omap2430_musb_init. Hence
    pm_runtime_get_sync in omap2430_musb_init does not have any effect (does
    not enable clocks) resulting in a crash during register access. It is
    fixed here.
    
    Cc: stable@vger.kernel.org # v3.0, v3.1, v3.2, v3.3
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 3dfd122266f4..0fb4ce84d17e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -453,14 +453,14 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 		goto err2;
 	}
 
+	pm_runtime_enable(&pdev->dev);
+
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
 		goto err2;
 	}
 
-	pm_runtime_enable(&pdev->dev);
-
 	return 0;
 
 err2:

commit c04352a590538123f8c93bd87ef1d4bb9e3a64c7
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Sat Feb 4 19:43:51 2012 +0200

    usb: musb: fix some runtime_pm issues
    
    When runtime_pm was originally added, it was done in rather confusing
    way: omap2430_musb_init() (called from musb_init_controller) would do
    runtime_pm_get_sync() and musb_init_controller() itself would do
    runtime_pm_put to balance it out. This is not only confusing but also
    wrong if non-omap2430 glue layer is used.
    
    This confusion resulted in commit 772aed45b604 "usb: musb: fix
    pm_runtime mismatch", that removed runtime_pm_put() from
    musb_init_controller as that looked unbalanced, and also happened to
    fix unrelated isp1704_charger crash. However this broke runtime PM
    functionality (musb is now always powered, even without gadget active).
    
    Avoid these confusing runtime pm dependences by making
    musb_init_controller() and omap2430_musb_init() do their own runtime
    get/put pairs; also cover error paths. Remove unneeded runtime_pm_put
    in omap2430_remove too. isp1704_charger crash that motivated
    772aed45b604 will be fixed by following patch.
    
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 11b571ec22f2..3dfd122266f4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -333,6 +333,7 @@ static int omap2430_musb_init(struct musb *musb)
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
+	pm_runtime_put_noidle(musb->controller);
 	return 0;
 
 err1:
@@ -478,7 +479,6 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
-	pm_runtime_put(&pdev->dev);
 	kfree(glue);
 
 	return 0;

commit afb76df140823c57738598a876cd1d6568cd57c7
Author: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
Date:   Fri Dec 23 18:37:18 2011 +0200

    usb: musb: fix oops on omap2430 module unload
    
    This change prevents runtime suspend and resume actual execution, if
    omap2430 controller driver is loaded after musb-hdrc, and therefore the
    controller isn't initialized properly.
    
    The problem is reproducible with 3.1.y and 3.2 kernels.
    
    Kernel configuration of musb:
    
      % cat .config | egrep 'MUSB|GADGET'
      CONFIG_USB_MUSB_HDRC=y
      # CONFIG_USB_MUSB_TUSB6010 is not set
      CONFIG_USB_MUSB_OMAP2PLUS=m
      # CONFIG_USB_MUSB_AM35X is not set
      CONFIG_MUSB_PIO_ONLY=y
      CONFIG_USB_GADGET=y
      # CONFIG_USB_GADGET_DEBUG is not set
      # CONFIG_USB_GADGET_DEBUG_FILES is not set
      # CONFIG_USB_GADGET_DEBUG_FS is not set
      CONFIG_USB_GADGET_VBUS_DRAW=2
      CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
      CONFIG_USB_GADGET_MUSB_HDRC=m
      CONFIG_USB_GADGET_DUALSPEED=y
      CONFIG_USB_GADGETFS=m
      # CONFIG_USB_MIDI_GADGET is not set
    
    Fixes the following oops on module unloading:
    
      Unable to handle kernel NULL pointer dereference at virtual address 00000220
      ----8<----
      [<bf162088>] (omap2430_runtime_resume+0x24/0x54 [omap2430]) from [<c0302e34>] (pm_generic_runtime_resume+0x3c/0x50)
      [<c0302e34>] (pm_generic_runtime_resume+0x3c/0x50) from [<c0031a24>] (_od_runtime_resume+0x28/0x2c)
      [<c0031a24>] (_od_runtime_resume+0x28/0x2c) from [<c0306cb0>] (__rpm_callback+0x60/0xa0)
      [<c0306cb0>] (__rpm_callback+0x60/0xa0) from [<c0307f2c>] (rpm_resume+0x3fc/0x6e4)
      [<c0307f2c>] (rpm_resume+0x3fc/0x6e4) from [<c030851c>] (__pm_runtime_resume+0x5c/0x90)
      [<c030851c>] (__pm_runtime_resume+0x5c/0x90) from [<c02fd0dc>] (__device_release_driver+0x2c/0xd0)
      [<c02fd0dc>] (__device_release_driver+0x2c/0xd0) from [<c02fda18>] (driver_detach+0xe8/0xf4)
      [<c02fda18>] (driver_detach+0xe8/0xf4) from [<c02fcf88>] (bus_remove_driver+0xa0/0x104)
      [<c02fcf88>] (bus_remove_driver+0xa0/0x104) from [<c02fde54>] (driver_unregister+0x60/0x80)
      [<c02fde54>] (driver_unregister+0x60/0x80) from [<c02ff2d4>] (platform_driver_unregister+0x1c/0x20)
      [<c02ff2d4>] (platform_driver_unregister+0x1c/0x20) from [<bf162928>] (omap2430_exit+0x14/0x1c [omap2430])
      [<bf162928>] (omap2430_exit+0x14/0x1c [omap2430]) from [<c007d8bc>] (sys_delete_module+0x1f4/0x264)
      [<c007d8bc>] (sys_delete_module+0x1f4/0x264) from [<c000f000>] (ret_fast_syscall+0x0/0x30)
    
    Signed-off-by: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org # 3.1
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2ae0bb309994..11b571ec22f2 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -491,11 +491,13 @@ static int omap2430_runtime_suspend(struct device *dev)
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
-	musb->context.otg_interfsel = musb_readl(musb->mregs,
-						OTG_INTERFSEL);
+	if (musb) {
+		musb->context.otg_interfsel = musb_readl(musb->mregs,
+				OTG_INTERFSEL);
 
-	omap2430_low_level_exit(musb);
-	usb_phy_set_suspend(musb->xceiv, 1);
+		omap2430_low_level_exit(musb);
+		usb_phy_set_suspend(musb->xceiv, 1);
+	}
 
 	return 0;
 }
@@ -505,11 +507,13 @@ static int omap2430_runtime_resume(struct device *dev)
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
-	omap2430_low_level_init(musb);
-	musb_writel(musb->mregs, OTG_INTERFSEL,
-					musb->context.otg_interfsel);
+	if (musb) {
+		omap2430_low_level_init(musb);
+		musb_writel(musb->mregs, OTG_INTERFSEL,
+				musb->context.otg_interfsel);
 
-	usb_phy_set_suspend(musb->xceiv, 0);
+		usb_phy_set_suspend(musb->xceiv, 0);
+	}
 
 	return 0;
 }

commit 8062d94a545457a83d5291bd62c3bfd14200bba0
Merge: 15e68a803573 6e13c6505cdf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 1 08:45:33 2012 -0800

    Merge tag 'xceiv-for-v3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    USB: transceiver changes for 3.4
    
    Here we have a big rework done by Heikki Krogerus (thanks) which
    splits OTG functionality away from transceivers.
    
    We have known for quite a long time that struct otg_transceiver was
    a bad name for the structure, considering transceiver is far from
    being OTG-specific (see 4e67185).

commit 15e68a803573974409972e761d8f08f03fce5bdb
Merge: f7c96f59b4af 39287076e46d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 1 08:44:20 2012 -0800

    Merge tag 'musb-for-v3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    USB: MUSB changes for 3.4
    
    Here are a set of changes to the MUSB driver. In summary we have
    a patch making modules behave better, there's a fix on debugfs'
    error path, a small change removing an unnecessary pm_runtime
    call on musb_shutdown() and a fix to relesect the endpoint in
    Interrupt context.
    
    This last patch is needed because we must drop musb's lock when
    calling request->complete() and that could cause problems if another
    thread queues a request and ends up changing MUSB_INDEX register.

commit 6e13c6505cdff9766d5268ffb8c972c1a2f996e6
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:20 2012 +0200

    usb: otg: Convert all users to pass struct usb_otg for OTG functions
    
    This changes the otg functions so that they receive struct
    otg instead of struct usb_phy as parameter and
    converts all users of these functions to pass the otg member
    of their usb_phy.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    [ balbi@ti.com : fixed a compile warning on ehci-mv.c ]
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 96a3d3763cc4..d8df60a9fc2a 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -164,8 +164,8 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 				}
 			}
 
-			if (ret && musb->xceiv->set_vbus)
-				otg_set_vbus(musb->xceiv, 1);
+			if (ret && otg->set_vbus)
+				otg_set_vbus(otg, 1);
 		} else {
 			musb->is_active = 1;
 			otg->default_a = 1;
@@ -270,8 +270,8 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 			}
 
 		if (data->interface_type == MUSB_INTERFACE_UTMI) {
-			if (musb->xceiv->set_vbus)
-				otg_set_vbus(musb->xceiv, 0);
+			if (musb->xceiv->otg->set_vbus)
+				otg_set_vbus(musb->xceiv->otg, 0);
 		}
 		usb_phy_shutdown(musb->xceiv);
 		break;

commit b96d3b08365f5a9603f50f3aadca6012f7eaffa1
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:18 2012 +0200

    usb: Convert all users to new usb_phy
    
    Use the new usb_phy_* functions with transceiver
    operations instead of the old otg functions.
    
    Includes fixes from Sascha Hauer.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a427fcb13430..96a3d3763cc4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -247,7 +247,7 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 
 		if (!is_otg_enabled(musb) || musb->gadget_driver) {
 			pm_runtime_get_sync(musb->controller);
-			otg_init(musb->xceiv);
+			usb_phy_init(musb->xceiv);
 			omap2430_musb_set_vbus(musb, 1);
 		}
 		break;
@@ -257,7 +257,7 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(musb->controller);
-		otg_init(musb->xceiv);
+		usb_phy_init(musb->xceiv);
 		break;
 
 	case USB_EVENT_NONE:
@@ -273,7 +273,7 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 			if (musb->xceiv->set_vbus)
 				otg_set_vbus(musb->xceiv, 0);
 		}
-		otg_shutdown(musb->xceiv);
+		usb_phy_shutdown(musb->xceiv);
 		break;
 	default:
 		dev_dbg(musb->controller, "ID float\n");
@@ -291,7 +291,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = otg_get_transceiver();
+	musb->xceiv = usb_get_transceiver();
 	if (!musb->xceiv) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;
@@ -326,7 +326,7 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
 	musb->nb.notifier_call = musb_otg_notifications;
-	status = otg_register_notifier(musb->xceiv, &musb->nb);
+	status = usb_register_notifier(musb->xceiv, &musb->nb);
 
 	if (status)
 		dev_dbg(musb->controller, "notification register failed\n");
@@ -350,7 +350,7 @@ static void omap2430_musb_enable(struct musb *musb)
 	switch (musb->xceiv->last_event) {
 
 	case USB_EVENT_ID:
-		otg_init(musb->xceiv);
+		usb_phy_init(musb->xceiv);
 		if (data->interface_type != MUSB_INTERFACE_UTMI)
 			break;
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
@@ -369,7 +369,7 @@ static void omap2430_musb_enable(struct musb *musb)
 		break;
 
 	case USB_EVENT_VBUS:
-		otg_init(musb->xceiv);
+		usb_phy_init(musb->xceiv);
 		break;
 
 	default:
@@ -380,7 +380,7 @@ static void omap2430_musb_enable(struct musb *musb)
 static void omap2430_musb_disable(struct musb *musb)
 {
 	if (musb->xceiv->last_event)
-		otg_shutdown(musb->xceiv);
+		usb_phy_shutdown(musb->xceiv);
 }
 
 static int omap2430_musb_exit(struct musb *musb)
@@ -389,7 +389,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	cancel_work_sync(&musb->otg_notifier_work);
 
 	omap2430_low_level_exit(musb);
-	otg_put_transceiver(musb->xceiv);
+	usb_put_transceiver(musb->xceiv);
 
 	return 0;
 }
@@ -495,7 +495,7 @@ static int omap2430_runtime_suspend(struct device *dev)
 						OTG_INTERFSEL);
 
 	omap2430_low_level_exit(musb);
-	otg_set_suspend(musb->xceiv, 1);
+	usb_phy_set_suspend(musb->xceiv, 1);
 
 	return 0;
 }
@@ -509,7 +509,7 @@ static int omap2430_runtime_resume(struct device *dev)
 	musb_writel(musb->mregs, OTG_INTERFSEL,
 					musb->context.otg_interfsel);
 
-	otg_set_suspend(musb->xceiv, 0);
+	usb_phy_set_suspend(musb->xceiv, 0);
 
 	return 0;
 }

commit d445b6da8da491e025eb60576ce959f6a3a56a4f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:15 2012 +0200

    usb: musb: Start using struct usb_otg
    
    Use struct usb_otg members with OTG specific functions instead
    of usb_phy members.
    
    [ balbi@ti.com: added a missing change on musb_gadget.c to avoid
            a compile error on a later patch ]
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index df719eae3b03..a427fcb13430 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -132,6 +132,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 
 static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
+	struct usb_otg	*otg = musb->xceiv->otg;
 	u8		devctl;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	int ret = 1;
@@ -167,7 +168,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 				otg_set_vbus(musb->xceiv, 1);
 		} else {
 			musb->is_active = 1;
-			musb->xceiv->default_a = 1;
+			otg->default_a = 1;
 			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
 			devctl |= MUSB_DEVCTL_SESSION;
 			MUSB_HST_MODE(musb);
@@ -179,7 +180,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		 * jumping right to B_IDLE...
 		 */
 
-		musb->xceiv->default_a = 0;
+		otg->default_a = 0;
 		musb->xceiv->state = OTG_STATE_B_IDLE;
 		devctl &= ~MUSB_DEVCTL_SESSION;
 

commit e9e8c85e69310141d78daaecd6a56138700ac317
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jan 26 12:40:23 2012 +0200

    usb: musb: make modules behave better
    
    There's really no point in doing all that
    initcall trickery when we can safely let
    udev handle module probing for us.
    
    Remove all of that trickery, by moving everybody
    to module_init() and making proper use of
    platform_device_register() rather than
    platform_device_probe().
    
    Tested-by: Rajashekhara, Sudhakar <sudhakar.raj@ti.com>
    Tested-by: Tasslehoff Kjappfot <tasskjapp@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c27bbbf32b52..b254173e7e85 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -408,7 +408,7 @@ static const struct musb_platform_ops omap2430_ops = {
 
 static u64 omap2430_dmamask = DMA_BIT_MASK(32);
 
-static int __init omap2430_probe(struct platform_device *pdev)
+static int __devinit omap2430_probe(struct platform_device *pdev)
 {
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
@@ -471,7 +471,7 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __exit omap2430_remove(struct platform_device *pdev)
+static int __devexit omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
@@ -524,7 +524,8 @@ static struct dev_pm_ops omap2430_pm_ops = {
 #endif
 
 static struct platform_driver omap2430_driver = {
-	.remove		= __exit_p(omap2430_remove),
+	.probe		= omap2430_probe,
+	.remove		= __devexit_p(omap2430_remove),
 	.driver		= {
 		.name	= "musb-omap2430",
 		.pm	= DEV_PM_OPS,
@@ -537,9 +538,9 @@ MODULE_LICENSE("GPL v2");
 
 static int __init omap2430_init(void)
 {
-	return platform_driver_probe(&omap2430_driver, omap2430_probe);
+	return platform_driver_register(&omap2430_driver);
 }
-subsys_initcall(omap2430_init);
+module_init(omap2430_init);
 
 static void __exit omap2430_exit(void)
 {

commit b30b3c60a25a4afbc49167ecb6210c291178ee5f
Author: NeilBrown <neilb@suse.de>
Date:   Wed Jan 25 10:02:46 2012 +0200

    usb: musb: omap2430: minor cleanups.
    
    1/ remove incorrect comment (it is a non-blocking notifier)
    2/ Use correct symbolic return value for notifier
    3/ Make sure otg_notifier_work is cancelled before module exit.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c27bbbf32b52..df719eae3b03 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -222,7 +222,6 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
-/* blocking notifier support */
 static int musb_otg_notifications(struct notifier_block *nb,
 		unsigned long event, void *unused)
 {
@@ -231,7 +230,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 	musb->xceiv_event = event;
 	schedule_work(&musb->otg_notifier_work);
 
-	return 0;
+	return NOTIFY_OK;
 }
 
 static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
@@ -386,6 +385,7 @@ static void omap2430_musb_disable(struct musb *musb)
 static int omap2430_musb_exit(struct musb *musb)
 {
 	del_timer_sync(&musb_idle_timer);
+	cancel_work_sync(&musb->otg_notifier_work);
 
 	omap2430_low_level_exit(musb);
 	otg_put_transceiver(musb->xceiv);

commit 702ac61c51873ac4b7a66c2518219508ae5fe695
Author: Felipe Contreras <felipe.contreras@gmail.com>
Date:   Mon Dec 19 22:17:51 2011 +0200

    musb: omap2430: avoid pm_runtime_disable()
    
    These are handled by drivers core, and in a way that doesn't wake up the
    devices.
    
    Signed-off-by: Felipe Contreras <felipe.contreras@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 4f31814eebf3..c27bbbf32b52 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -336,7 +336,6 @@ static int omap2430_musb_init(struct musb *musb)
 	return 0;
 
 err1:
-	pm_runtime_disable(dev);
 	return status;
 }
 
@@ -479,7 +478,6 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
 	pm_runtime_put(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
 	kfree(glue);
 
 	return 0;

commit 08dec56ee29f06b4fbdf5f5b1b3d2c2397aabe17
Author: Felipe Contreras <felipe.contreras@gmail.com>
Date:   Mon Dec 19 22:17:50 2011 +0200

    usb: musb: remove a bit of indentation
    
    And use dev instead of musb->controller.
    
    Signed-off-by: Felipe Contreras <felipe.contreras@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 34c169896836..4f31814eebf3 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -352,20 +352,19 @@ static void omap2430_musb_enable(struct musb *musb)
 
 	case USB_EVENT_ID:
 		otg_init(musb->xceiv);
-		if (data->interface_type == MUSB_INTERFACE_UTMI) {
-			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-			/* start the session */
-			devctl |= MUSB_DEVCTL_SESSION;
-			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
-			while (musb_readb(musb->mregs, MUSB_DEVCTL) &
-						MUSB_DEVCTL_BDEVICE) {
-				cpu_relax();
-
-				if (time_after(jiffies, timeout)) {
-					dev_err(musb->controller,
-					"configured as A device timeout");
-					break;
-				}
+		if (data->interface_type != MUSB_INTERFACE_UTMI)
+			break;
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		/* start the session */
+		devctl |= MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		while (musb_readb(musb->mregs, MUSB_DEVCTL) &
+				MUSB_DEVCTL_BDEVICE) {
+			cpu_relax();
+
+			if (time_after(jiffies, timeout)) {
+				dev_err(dev, "configured as A device timeout");
+				break;
 			}
 		}
 		break;

commit b3314d9ac55f4aa13fd339ee16e95828414f51d4
Author: Felipe Contreras <felipe.contreras@gmail.com>
Date:   Mon Dec 19 22:17:49 2011 +0200

    usb: musb: trivial cleanup
    
    enabled && driver || !enabled can be simplified to !enabled || driver.
    
    Signed-off-by: Felipe Contreras <felipe.contreras@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c24dc26b9be2..34c169896836 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -245,13 +245,7 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 	case USB_EVENT_ID:
 		dev_dbg(musb->controller, "ID GND\n");
 
-		if (is_otg_enabled(musb)) {
-			if (musb->gadget_driver) {
-				pm_runtime_get_sync(musb->controller);
-				otg_init(musb->xceiv);
-				omap2430_musb_set_vbus(musb, 1);
-			}
-		} else {
+		if (!is_otg_enabled(musb) || musb->gadget_driver) {
 			pm_runtime_get_sync(musb->controller);
 			otg_init(musb->xceiv);
 			omap2430_musb_set_vbus(musb, 1);

commit e7f4e73287d2915499c821b884f70f42187e2a74
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Nov 24 15:42:10 2011 +0200

    usb: musb: omap2430: fix compile warning
    
    fix the following compile warning:
    
    drivers/usb/musb/omap2430.c: In function 'musb_otg_notifier_work':
    drivers/usb/musb/omap2430.c:279:3: warning: 'return' with a value, in
            function returning void
    drivers/usb/musb/omap2430.c:282:2: warning: 'return' with a value, in
            function returning void
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index fd5dd46039ad..c24dc26b9be2 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -283,10 +283,7 @@ static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
 		break;
 	default:
 		dev_dbg(musb->controller, "ID float\n");
-		return NOTIFY_DONE;
 	}
-
-	return NOTIFY_OK;
 }
 
 static int omap2430_musb_init(struct musb *musb)

commit 712d8efafbbcbe617f9ad706f6ca1ffea4bbf2e8
Author: Vikram Pandita <vikram.pandita@ti.com>
Date:   Fri Aug 12 07:38:51 2011 -0700

    usb: musb: fix pm_runtime calls while atomic
    
    musb pm_runtime_get_sync call happens in intrrupt context on cable attach case
    That can result in re-enabling the interrupts and cause side affects.
    
    So move the code to a work queue.
    
    Following is the error path hit on cable attach:
    
    BUG: sleeping function called from invalid context at drivers/base/power/runtime.c:802
    in_atomic(): 0, irqs_disabled(): 0, pid: 18, name: irq/378-twl6030
    
    Backtrace:
    [<c00520f0>] (dump_backtrace+0x0/0x110) from [<c054f454>] (dump_stack+0x18/0x1c)
    [<c054f43c>] (dump_stack+0x0/0x1c) from [<c007f59c>] (__might_sleep+0x130/0x134)
    [<c007f46c>] (__might_sleep+0x0/0x134) from [<c02c2794>] (__pm_runtime_resume+0x94/0x98)
    [<c02c2700>] (__pm_runtime_resume+0x0/0x98) from [<c033e7e4>] (musb_otg_notifications+0x9c/0x164)
    [<c033e748>] (musb_otg_notifications+0x0/0x164) from [<c00b3df0>] (notifier_call_chain+0x4c/0x8c)
    [<c00b3da4>] (notifier_call_chain+0x0/0x8c) from [<c00b44a8>] (__atomic_notifier_call_chain+0x40/0x54)
    [<c00b4468>] (__atomic_notifier_call_chain+0x0/0x54) from [<c00b44dc>] (atomic_notifier_call_chain+0x20/0x28)
    [<c00b44bc>] (atomic_notifier_call_chain+0x0/0x28) from [<c033f124>] (twl6030_usb_irq+0xc8/0xdc)
    [<c033f05c>] (twl6030_usb_irq+0x0/0xdc) from [<c00d79f8>] (irq_thread_fn+0x24/0x40)
    [<c00d79d4>] (irq_thread_fn+0x0/0x40) from [<c00d7b64>] (irq_thread+0x150/0x1d8)
    [<c00d7a14>] (irq_thread+0x0/0x1d8) from [<c00adf70>] (kthread+0x94/0x98)
    [<c00adedc>] (kthread+0x0/0x98) from [<c0094388>] (do_exit+0x0/0x720)
    
    Tested with:
    MUSB Device mode: Cold boot / Hot plug
    MUSB Host mode: Cold boot / Hot plug
    
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Moiz Sonasath <m-sonasath@ti.com>
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2f6cd431fb1c..fd5dd46039ad 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -227,11 +227,21 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		unsigned long event, void *unused)
 {
 	struct musb	*musb = container_of(nb, struct musb, nb);
+
+	musb->xceiv_event = event;
+	schedule_work(&musb->otg_notifier_work);
+
+	return 0;
+}
+
+static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
+{
+	struct musb *musb = container_of(data_notifier_work, struct musb, otg_notifier_work);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	switch (event) {
+	switch (musb->xceiv_event) {
 	case USB_EVENT_ID:
 		dev_dbg(musb->controller, "ID GND\n");
 
@@ -296,6 +306,8 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
+	INIT_WORK(&musb->otg_notifier_work, musb_otg_notifier_work);
+
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
 		dev_err(dev, "pm_runtime_get_sync FAILED");

commit 7d5b49a202c4201a8afc36f9e55624894aba9fb5
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Oct 14 10:45:15 2011 +0300

    usb: musb: headers cleanup
    
    Remove a few unnecessary headers from a
    few files.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 78eb13a33796..2f6cd431fb1c 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -29,7 +29,6 @@
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/list.h>
-#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>

commit e25bec160158abe86c276d7d206264afc3646281
Author: Hema HK <hemahk@ti.com>
Date:   Wed Sep 7 09:19:24 2011 -0700

    usb: musb: omap2+: save and restore OTG_INTERFSEL
    
    we need to save and restore OTG_INTERFSEL register
    else we will be unable to function on resume after
    OFF mode.
    
    Reported-by: Devaraj Rangasamy <dev@ti.com>
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ba85f273e487..78eb13a33796 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -491,6 +491,9 @@ static int omap2430_runtime_suspend(struct device *dev)
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
+	musb->context.otg_interfsel = musb_readl(musb->mregs,
+						OTG_INTERFSEL);
+
 	omap2430_low_level_exit(musb);
 	otg_set_suspend(musb->xceiv, 1);
 
@@ -503,6 +506,9 @@ static int omap2430_runtime_resume(struct device *dev)
 	struct musb			*musb = glue_to_musb(glue);
 
 	omap2430_low_level_init(musb);
+	musb_writel(musb->mregs, OTG_INTERFSEL,
+					musb->context.otg_interfsel);
+
 	otg_set_suspend(musb->xceiv, 0);
 
 	return 0;

commit 622859634a663c5e55d0e2a2cdbb55ac058d97b3
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Jun 22 17:28:09 2011 +0300

    usb: musb: drop a gigantic amount of ifdeferry
    
    the MUSB IP is always OTG, so there's no point
    in adding so many ifdefs on the code. Drop those
    and always compile the driver for OTG support.
    
    This also allows us to drop the useless "driver
    mode" choice. For doing that, we need to make
    musb depend on both Host and Peripheral side.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c5d4c44d0ffa..ba85f273e487 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -51,9 +51,7 @@ static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
 	unsigned long	flags;
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	u8	power;
-#endif
 	u8	devctl;
 
 	spin_lock_irqsave(&musb->lock, flags);
@@ -70,7 +68,6 @@ static void musb_do_idle(unsigned long _musb)
 			MUSB_HST_MODE(musb);
 		}
 		break;
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case OTG_STATE_A_SUSPEND:
 		/* finish RESUME signaling? */
 		if (musb->port1_status & MUSB_PORT_STAT_RESUME) {
@@ -87,15 +84,12 @@ static void musb_do_idle(unsigned long _musb)
 			musb->xceiv->state = OTG_STATE_A_HOST;
 		}
 		break;
-#endif
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case OTG_STATE_A_HOST:
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl &  MUSB_DEVCTL_BDEVICE)
 			musb->xceiv->state = OTG_STATE_B_IDLE;
 		else
 			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
-#endif
 	default:
 		break;
 	}
@@ -243,13 +237,11 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		dev_dbg(musb->controller, "ID GND\n");
 
 		if (is_otg_enabled(musb)) {
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 			if (musb->gadget_driver) {
 				pm_runtime_get_sync(musb->controller);
 				otg_init(musb->xceiv);
 				omap2430_musb_set_vbus(musb, 1);
 			}
-#endif
 		} else {
 			pm_runtime_get_sync(musb->controller);
 			otg_init(musb->xceiv);
@@ -260,21 +252,16 @@ static int musb_otg_notifications(struct notifier_block *nb,
 	case USB_EVENT_VBUS:
 		dev_dbg(musb->controller, "VBUS Connect\n");
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(musb->controller);
-#endif
 		otg_init(musb->xceiv);
 		break;
 
 	case USB_EVENT_NONE:
 		dev_dbg(musb->controller, "VBUS Disconnect\n");
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
-			if (musb->gadget_driver)
-#endif
-			{
+			if (musb->gadget_driver) {
 				pm_runtime_mark_last_busy(musb->controller);
 				pm_runtime_put_autosuspend(musb->controller);
 			}

commit 5c8a86e10a7c164f44537fabdc169fd8b4e7a440
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed May 11 12:44:08 2011 +0300

    usb: musb: drop unneeded musb_debug trickery
    
    We have a generic way of enabling/disabling
    different debug messages on a driver called
    DYNAMIC_PRINTK. Anyone interested in enabling
    just part of the debug messages, please read
    the documentation under:
    
    Documentation/dynamic-debug-howto.txt
    
    for information on how to use that great
    infrastructure.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b996fec84c29..c5d4c44d0ffa 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -76,7 +76,7 @@ static void musb_do_idle(unsigned long _musb)
 		if (musb->port1_status & MUSB_PORT_STAT_RESUME) {
 			power = musb_readb(musb->mregs, MUSB_POWER);
 			power &= ~MUSB_POWER_RESUME;
-			DBG(1, "root port resume stopped, power %02x\n", power);
+			dev_dbg(musb->controller, "root port resume stopped, power %02x\n", power);
 			musb_writeb(musb->mregs, MUSB_POWER, power);
 			musb->is_active = 1;
 			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
@@ -114,7 +114,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
 			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
-		DBG(4, "%s active, deleting timer\n",
+		dev_dbg(musb->controller, "%s active, deleting timer\n",
 			otg_state_string(musb->xceiv->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
@@ -125,13 +125,13 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 		if (!timer_pending(&musb_idle_timer))
 			last_timer = timeout;
 		else {
-			DBG(4, "Longer idle timer already pending, ignoring\n");
+			dev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");
 			return;
 		}
 	}
 	last_timer = timeout;
 
-	DBG(4, "%s inactive, for idle timer for %lu ms\n",
+	dev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",
 		otg_state_string(musb->xceiv->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
@@ -194,7 +194,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 	}
 	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
-	DBG(1, "VBUS %s, devctl %02x "
+	dev_dbg(musb->controller, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
 		otg_state_string(musb->xceiv->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
@@ -240,7 +240,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 
 	switch (event) {
 	case USB_EVENT_ID:
-		DBG(4, "ID GND\n");
+		dev_dbg(musb->controller, "ID GND\n");
 
 		if (is_otg_enabled(musb)) {
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -258,7 +258,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		break;
 
 	case USB_EVENT_VBUS:
-		DBG(4, "VBUS Connect\n");
+		dev_dbg(musb->controller, "VBUS Connect\n");
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (musb->gadget_driver)
@@ -268,7 +268,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		break;
 
 	case USB_EVENT_NONE:
-		DBG(4, "VBUS Disconnect\n");
+		dev_dbg(musb->controller, "VBUS Disconnect\n");
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
@@ -286,7 +286,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		otg_shutdown(musb->xceiv);
 		break;
 	default:
-		DBG(4, "ID float\n");
+		dev_dbg(musb->controller, "ID float\n");
 		return NOTIFY_DONE;
 	}
 
@@ -340,7 +340,7 @@ static int omap2430_musb_init(struct musb *musb)
 	status = otg_register_notifier(musb->xceiv, &musb->nb);
 
 	if (status)
-		DBG(1, "notification register failed\n");
+		dev_dbg(musb->controller, "notification register failed\n");
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 

commit 8a1629c771b1a60bc6d73394d869fe69b13200dc
Merge: 04aebcbb1b6d 693d92a1bbc9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 10 13:30:45 2011 -0700

    Merge branch 2.6.39-rc7 into usb-linus
    
    This was needed to resolve a conflict in:
            drivers/usb/host/isp1760-hcd.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3df004532582d0cc721da0df28311bcedd639724
Author: Anatolij Gustschin <agust@denx.de>
Date:   Thu May 5 12:11:21 2011 +0200

    usb: fix building musb drivers
    
    Commit 3dacdf11 "usb: factor out state_string() on otg drivers"
    broke building musb drivers since there is already another
    otg_state_string() function in musb drivers, but with different
    prototype. Fix musb drivers to use common otg_state_string(), too.
    
    Also provide a nop for otg_state_string() if CONFIG_USB_OTG_UTILS
    is not defined.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 57a27fa954b4..d51b15adc0b0 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -114,7 +114,8 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
 			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
-		DBG(4, "%s active, deleting timer\n", otg_state_string(musb));
+		DBG(4, "%s active, deleting timer\n",
+			otg_state_string(musb->xceiv->state));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
 		return;
@@ -131,7 +132,7 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	last_timer = timeout;
 
 	DBG(4, "%s inactive, for idle timer for %lu ms\n",
-		otg_state_string(musb),
+		otg_state_string(musb->xceiv->state),
 		(unsigned long)jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&musb_idle_timer, timeout);
 }
@@ -195,7 +196,7 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 
 	DBG(1, "VBUS %s, devctl %02x "
 		/* otg %3x conf %08x prcm %08x */ "\n",
-		otg_state_string(musb),
+		otg_state_string(musb->xceiv->state),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 

commit 383cf4e8d47f902600263191f8f167379c376985
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Wed Apr 27 17:02:37 2011 +0300

    usb: musb: omap2430: Fix retention idle on musb peripheral only boards
    
    Recent runtime pm and hwmod conversions for 2.6.39 broke the musb peripheral
    mode OMAP retention idle on boards where the board mode in struct
    musb_hdrc_platform_data is set to MUSB_PERIPHERAL.
    
    These conversions changed the way how the OTG_SYSCONFIG register is
    configured and used in runtime. Before 2.6.39 smart standby/idle modes were
    activated statically in OTG_SYSCONFIG. Those modes allow that the musb is
    able to idle when peripheral device is not connected to host.
    
    In 2.6.39 the OTG_SYSCONFIG is updated runtime depending on VBUS status.
    No standby/idle modes are used when device is connected and force
    standby/idle when disconnected.
    
    Unfortunately VBUS disconnect event that handles the disconnect case lets
    the peripheral musb to idle only when board mode is MUSB_OTG. Fix this by
    checking the peripheral mode also.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 57a27fa954b4..e9e60b6e0583 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -270,7 +270,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		DBG(4, "VBUS Disconnect\n");
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		if (is_otg_enabled(musb))
+		if (is_otg_enabled(musb) || is_peripheral_enabled(musb))
 			if (musb->gadget_driver)
 #endif
 			{

commit 36a52c009a39049893c9a3a4091f8f8f48585f47
Author: Johan Hovold <jhovold@gmail.com>
Date:   Tue Apr 5 19:50:34 2011 +0200

    usb: musb: omap2430: fix build failure
    
    Fix build failure introduced by commit
    7acc6197b76edd0b932a7cbcc6cfad0a8a87f026 (usb: musb: Idle path retention
    and offmode support for OMAP3) when building without gadget
    support.
    
      CC      drivers/usb/musb/omap2430.o
    drivers/usb/musb/omap2430.c: In function musb_otg_notifications:
    drivers/usb/musb/omap2430.c:262: error: struct musb has no member named gadget_driver
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 25cb8b0003b1..57a27fa954b4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -259,9 +259,10 @@ static int musb_otg_notifications(struct notifier_block *nb,
 	case USB_EVENT_VBUS:
 		DBG(4, "VBUS Connect\n");
 
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (musb->gadget_driver)
 			pm_runtime_get_sync(musb->controller);
-
+#endif
 		otg_init(musb->xceiv);
 		break;
 

commit 971f115a50afbe409825c9f3399d5a3b9aca4381
Merge: 2e270d842232 500132a0f26a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 15:04:26 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (172 commits)
      USB: Add support for SuperSpeed isoc endpoints
      xhci: Clean up cycle bit math used during stalls.
      xhci: Fix cycle bit calculation during stall handling.
      xhci: Update internal dequeue pointers after stalls.
      USB: Disable auto-suspend for USB 3.0 hubs.
      USB: Remove bogus USB_PORT_STAT_SUPER_SPEED symbol.
      xhci: Return canceled URBs immediately when host is halted.
      xhci: Fixes for suspend/resume of shared HCDs.
      xhci: Fix re-init on power loss after resume.
      xhci: Make roothub functions deal with device removal.
      xhci: Limit roothub ports to 15 USB3 & 31 USB2 ports.
      xhci: Return a USB 3.0 hub descriptor for USB3 roothub.
      xhci: Register second xHCI roothub.
      xhci: Change xhci_find_slot_id_by_port() API.
      xhci: Refactor bus suspend state into a struct.
      xhci: Index with a port array instead of PORTSC addresses.
      USB: Set usb_hcd->state and flags for shared roothubs.
      usb: Make core allocate resources per PCI-device.
      usb: Store bus type in usb_hcd, not in driver flags.
      usb: Change usb_hcd->bandwidth_mutex to a pointer.
      ...

commit 70045c57f31f998a7206baa81167c7bc9f452cef
Author: Hema HK <hemahk@ti.com>
Date:   Mon Feb 28 15:05:29 2011 +0530

    usb: musb: OMAP3xxx: Fix device detection in otg & host mode
    
    In OMAP3xxx with OTG mode or host only mode, When the device
    is inserted after the gadget driver loading the enumeration was not
    through. This is because the mentor controller will start sensing the
    ID PIN only after setting the session bit.
    So after ID-GND, need to set the session bit for mentor to get it
    configured as A device.
    
    This is a fix to set the session bit again in ID_GND notification handler.
    Tested with OMAP3630Zoom3 platform.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 47267987077d..f5d4f368be9e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -246,19 +246,13 @@ static int musb_otg_notifications(struct notifier_block *nb,
 			if (musb->gadget_driver) {
 				pm_runtime_get_sync(musb->controller);
 				otg_init(musb->xceiv);
-
-				if (data->interface_type ==
-						MUSB_INTERFACE_UTMI)
-					omap2430_musb_set_vbus(musb, 1);
-
+				omap2430_musb_set_vbus(musb, 1);
 			}
 #endif
 		} else {
 			pm_runtime_get_sync(musb->controller);
 			otg_init(musb->xceiv);
-			if (data->interface_type ==
-					MUSB_INTERFACE_UTMI)
-				omap2430_musb_set_vbus(musb, 1);
+			omap2430_musb_set_vbus(musb, 1);
 		}
 		break;
 

commit 7acc6197b76edd0b932a7cbcc6cfad0a8a87f026
Author: Hema HK <hemahk@ti.com>
Date:   Mon Feb 28 14:19:34 2011 +0530

    usb: musb: Idle path retention and offmode support for OMAP3
    
    This patch supports the retention and offmode support in the idle path for
    musb driver using runtime pm APIs.
    
    This is restricted to support offmode and retention only when device not
    connected.When device/cable connected with gadget driver loaded,configured
    to no idle/standby which will not allow the core transition to retention
    or off.
    
    There is no context save/restore done by hardware for musb in OMAP3
    and OMAP4,driver has to take care of saving and restoring the context
    during offmode.
    
    Musb has a requirement of configuring sysconfig register to force
    idle/standby mode and set the ENFORCE bit in module STANDBY register
    for retention and offmode support.
    
    Runtime pm and hwmod frameworks will take care of configuring to force
    idle/standby when pm_runtime_put_sync is called and back to no
    idle/standby when pm_runeime_get_sync is called.
    
    Compile, boot tested and also tested the retention in the idle path on
    OMAP3630Zoom3. And tested the global suspend/resume with offmode enabled.
    Usb basic functionality tested on OMAP4430SDP.
    
    There is some problem with idle path offmode in mainline, I could not test
    with offmode. But I have tested this patch with resetting the controller
    in the idle path when wakeup from retention just to make sure that the
    context is lost, and restore path is working fine.
    
    Removed .suspend/.resume fnction pointers and functions because there
    is no need of having these functions as all required work is done
    at runtime in the driver.
    
    There is no need to call the runtime pm api with glue driver device
    as glue layer device is the parent of musb core device, when runtime apis
    are called for the child, parent device runtime functionality
    will be invoked.
    
    Design overview:
    
    pm_runtime_get_sync: When called with musb core device takes care of
    enabling the clock, calling runtime callback function of omap2430 glue
    layer, runtime call back of musb driver and configure the musb sysconfig
    to no idle/standby
    
    pm_runtime_put: Takes care of calling runtime callback function of omap2430
    glue layer, runtime call back of musb driver, Configure the musb sysconfig
    to force idle/standby and disable the clock.
    
    During musb driver load: Call pm_runtime_get_sync.
    
    End of musb driver load: Call pm_runtime_put
    
    During gadget driver load: Call pm_runtime_get_sync,
    End of gadget driver load: Call pm_runtime_put if there is no device
    or cable is connected.
    
    During unload of the gadget driver:Call pm_runtime_get_sync if cable/device
    is not connected.
    End of the gadget driver unload : pm_runtime_put
    
    During unload of musb driver : Call pm_runtime_get_sync
    End of unload: Call pm_runtime_put
    
    On connect of usb cable/device -> transceiver notification(VBUS and ID-GND):
    pm_runtime_get_sync only if the gadget driver loaded.
    
    On disconnect of the cable/device -> Disconnect Notification:
    pm_runtime_put if the gadget driver is loaded.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index b6dcc7eaa21f..47267987077d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -244,6 +244,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 		if (is_otg_enabled(musb)) {
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 			if (musb->gadget_driver) {
+				pm_runtime_get_sync(musb->controller);
 				otg_init(musb->xceiv);
 
 				if (data->interface_type ==
@@ -253,6 +254,7 @@ static int musb_otg_notifications(struct notifier_block *nb,
 			}
 #endif
 		} else {
+			pm_runtime_get_sync(musb->controller);
 			otg_init(musb->xceiv);
 			if (data->interface_type ==
 					MUSB_INTERFACE_UTMI)
@@ -263,12 +265,24 @@ static int musb_otg_notifications(struct notifier_block *nb,
 	case USB_EVENT_VBUS:
 		DBG(4, "VBUS Connect\n");
 
+		if (musb->gadget_driver)
+			pm_runtime_get_sync(musb->controller);
+
 		otg_init(musb->xceiv);
 		break;
 
 	case USB_EVENT_NONE:
 		DBG(4, "VBUS Disconnect\n");
 
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+		if (is_otg_enabled(musb))
+			if (musb->gadget_driver)
+#endif
+			{
+				pm_runtime_mark_last_busy(musb->controller);
+				pm_runtime_put_autosuspend(musb->controller);
+			}
+
 		if (data->interface_type == MUSB_INTERFACE_UTMI) {
 			if (musb->xceiv->set_vbus)
 				otg_set_vbus(musb->xceiv, 0);
@@ -300,7 +314,11 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
-	omap2430_low_level_init(musb);
+	status = pm_runtime_get_sync(dev);
+	if (status < 0) {
+		dev_err(dev, "pm_runtime_get_sync FAILED");
+		goto err1;
+	}
 
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
@@ -331,6 +349,10 @@ static int omap2430_musb_init(struct musb *musb)
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
 	return 0;
+
+err1:
+	pm_runtime_disable(dev);
+	return status;
 }
 
 static void omap2430_musb_enable(struct musb *musb)
@@ -407,8 +429,6 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;
-	int				status = 0;
-
 	int				ret = -ENOMEM;
 
 	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
@@ -454,16 +474,9 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	}
 
 	pm_runtime_enable(&pdev->dev);
-	status = pm_runtime_get_sync(&pdev->dev);
-	if (status < 0) {
-		dev_err(&pdev->dev, "pm_runtime_get_sync FAILED");
-		goto err3;
-	}
 
 	return 0;
 
-err3:
-	pm_runtime_disable(&pdev->dev);
 err2:
 	platform_device_put(musb);
 
@@ -489,7 +502,7 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_PM
 
-static int omap2430_suspend(struct device *dev)
+static int omap2430_runtime_suspend(struct device *dev)
 {
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
@@ -497,22 +510,14 @@ static int omap2430_suspend(struct device *dev)
 	omap2430_low_level_exit(musb);
 	otg_set_suspend(musb->xceiv, 1);
 
-	if (!pm_runtime_suspended(dev) && dev->bus && dev->bus->pm &&
-			dev->bus->pm->runtime_suspend)
-		dev->bus->pm->runtime_suspend(dev);
-
 	return 0;
 }
 
-static int omap2430_resume(struct device *dev)
+static int omap2430_runtime_resume(struct device *dev)
 {
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
 
-	if (!pm_runtime_suspended(dev) && dev->bus && dev->bus->pm &&
-			dev->bus->pm->runtime_resume)
-		dev->bus->pm->runtime_resume(dev);
-
 	omap2430_low_level_init(musb);
 	otg_set_suspend(musb->xceiv, 0);
 
@@ -520,8 +525,8 @@ static int omap2430_resume(struct device *dev)
 }
 
 static struct dev_pm_ops omap2430_pm_ops = {
-	.suspend	= omap2430_suspend,
-	.resume		= omap2430_resume,
+	.runtime_suspend = omap2430_runtime_suspend,
+	.runtime_resume = omap2430_runtime_resume,
 };
 
 #define DEV_PM_OPS	(&omap2430_pm_ops)

commit da68ccec210c45eb99e461ad31b499b4e7043c41
Author: Hema HK <hemahk@ti.com>
Date:   Mon Feb 28 14:19:33 2011 +0530

    usb: musb: Remove platform context save/restore API
    
    For OMAP3 and OMAP4 for offmode and retention support, musb
    sysconfig is configured to force idle and standby with ENABLE_FORCE bit
    of OTG_FORCESTNDBY set.
    And on wakeup configure to no ilde/standby with resetting the ENABLE_FORCE
    bit. There is not need to save and restore of this register anymore
    so removed omap2430_save_context/omap2430_restore_context functions.
    and also removed otg_forcestandby member of musb_context_registers
    structure
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 64cf2431c05e..b6dcc7eaa21f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -488,15 +488,6 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static void omap2430_save_context(struct musb *musb)
-{
-	musb->context.otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
-}
-
-static void omap2430_restore_context(struct musb *musb)
-{
-	musb_writel(musb->mregs, OTG_FORCESTDBY, musb->context.otg_forcestandby);
-}
 
 static int omap2430_suspend(struct device *dev)
 {
@@ -505,7 +496,6 @@ static int omap2430_suspend(struct device *dev)
 
 	omap2430_low_level_exit(musb);
 	otg_set_suspend(musb->xceiv, 1);
-	omap2430_save_context(musb);
 
 	if (!pm_runtime_suspended(dev) && dev->bus && dev->bus->pm &&
 			dev->bus->pm->runtime_suspend)
@@ -524,7 +514,6 @@ static int omap2430_resume(struct device *dev)
 		dev->bus->pm->runtime_resume(dev);
 
 	omap2430_low_level_init(musb);
-	omap2430_restore_context(musb);
 	otg_set_suspend(musb->xceiv, 0);
 
 	return 0;

commit 002eda1348788f623dc42231dcda5f591d753124
Author: Hema HK <hemahk@ti.com>
Date:   Thu Feb 17 12:06:10 2011 +0530

    usb: musb: OMAP4430: Fix usb device detection if connected during boot
    
    OMAP4430 is embedded with UTMI PHY. This PHY does not support the
    OTG features like ID pin detection and VBUS detection. This function
    is exported to an external companion chip TWL6030. Software must retrieve
    the OTG HNP and SRP status from the TWL6030 and configure the bits inside
    the control module that drive the related USBOTGHS UTMI interface signals.
    It must also read back the UTMI signals needed to configure the TWL6030
    OTG module.
    
    Can find more details in the TRM[1].
    [1]:http://focus.ti.com/pdfs/wtbu/OMAP4430_ES2.0_Public_TRM_vJ.pdf
    
    In OMAP4430 musb driver VBUS and ID notifications are received from the
    transceiver driver. If the cable/device is connected during boot,
    notifications from transceiver driver will be missed till musb driver
    is loaded.
    Patch to configure the transceiver in the platform_enable/disable
    functions and enable the vbus in the gadget driver based on the
    last_event of the otg_transceiver.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index bb6e6cd330da..64cf2431c05e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -328,16 +328,56 @@ static int omap2430_musb_init(struct musb *musb)
 	if (status)
 		DBG(1, "notification register failed\n");
 
-	/* check whether cable is already connected */
-	if (musb->xceiv->state ==OTG_STATE_B_IDLE)
-		musb_otg_notifications(&musb->nb, 1,
-					musb->xceiv->gadget);
-
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
 	return 0;
 }
 
+static void omap2430_musb_enable(struct musb *musb)
+{
+	u8		devctl;
+	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+	struct device *dev = musb->controller;
+	struct musb_hdrc_platform_data *pdata = dev->platform_data;
+	struct omap_musb_board_data *data = pdata->board_data;
+
+	switch (musb->xceiv->last_event) {
+
+	case USB_EVENT_ID:
+		otg_init(musb->xceiv);
+		if (data->interface_type == MUSB_INTERFACE_UTMI) {
+			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+			/* start the session */
+			devctl |= MUSB_DEVCTL_SESSION;
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+			while (musb_readb(musb->mregs, MUSB_DEVCTL) &
+						MUSB_DEVCTL_BDEVICE) {
+				cpu_relax();
+
+				if (time_after(jiffies, timeout)) {
+					dev_err(musb->controller,
+					"configured as A device timeout");
+					break;
+				}
+			}
+		}
+		break;
+
+	case USB_EVENT_VBUS:
+		otg_init(musb->xceiv);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void omap2430_musb_disable(struct musb *musb)
+{
+	if (musb->xceiv->last_event)
+		otg_shutdown(musb->xceiv);
+}
+
 static int omap2430_musb_exit(struct musb *musb)
 {
 
@@ -355,6 +395,9 @@ static const struct musb_platform_ops omap2430_ops = {
 	.try_idle	= omap2430_musb_try_idle,
 
 	.set_vbus	= omap2430_musb_set_vbus,
+
+	.enable		= omap2430_musb_enable,
+	.disable	= omap2430_musb_disable,
 };
 
 static u64 omap2430_dmamask = DMA_BIT_MASK(32);

commit 207b0e1f1655bd7008b7322cdc3f84fb171c546d
Author: Hema HK <hemahk@ti.com>
Date:   Thu Feb 17 12:07:22 2011 +0530

    usb: musb: Using runtime pm APIs for musb.
    
    Calling runtime pm APIs pm_runtime_put_sync() and pm_runtime_get_sync()
    for enabling/disabling the clocks, sysconfig settings.
    
    Enable clock, configure no-idle/standby when active and configure force idle/standby
    and disable clock when idled. This is taken care by the runtime framework when
    driver calls the pm_runtime_get_sync and pm_runtime_put_sync APIs.
    Need to configure MUSB into force standby and force idle mode when usb not used
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Cousson, Benoit <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a3f12333fc41..bb6e6cd330da 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -33,6 +33,8 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/err.h>
 
 #include "musb_core.h"
 #include "omap2430.h"
@@ -40,7 +42,6 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
-	struct clk		*clk;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -216,20 +217,12 @@ static inline void omap2430_low_level_exit(struct musb *musb)
 	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
 	l |= ENABLEFORCE;	/* enable MSTANDBY */
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
-
-	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	l |= ENABLEWAKEUP;	/* enable wakeup */
-	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 }
 
 static inline void omap2430_low_level_init(struct musb *musb)
 {
 	u32 l;
 
-	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	l &= ~ENABLEWAKEUP;	/* disable wakeup */
-	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
-
 	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
 	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
@@ -309,21 +302,6 @@ static int omap2430_musb_init(struct musb *musb)
 
 	omap2430_low_level_init(musb);
 
-	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	l &= ~ENABLEWAKEUP;	/* disable wakeup */
-	l &= ~NOSTDBY;		/* remove possible nostdby */
-	l |= SMARTSTDBY;	/* enable smart standby */
-	l &= ~AUTOIDLE;		/* disable auto idle */
-	l &= ~NOIDLE;		/* remove possible noidle */
-	l |= SMARTIDLE;		/* enable smart idle */
-	/*
-	 * MUSB AUTOIDLE don't work in 3430.
-	 * Workaround by Richard Woodruff/TI
-	 */
-	if (!cpu_is_omap3430())
-		l |= AUTOIDLE;		/* enable auto idle */
-	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
-
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 
 	if (data->interface_type == MUSB_INTERFACE_UTMI) {
@@ -386,7 +364,7 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;
-	struct clk			*clk;
+	int				status = 0;
 
 	int				ret = -ENOMEM;
 
@@ -402,26 +380,12 @@ static int __init omap2430_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	clk = clk_get(&pdev->dev, "ick");
-	if (IS_ERR(clk)) {
-		dev_err(&pdev->dev, "failed to get clock\n");
-		ret = PTR_ERR(clk);
-		goto err2;
-	}
-
-	ret = clk_enable(clk);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to enable clock\n");
-		goto err3;
-	}
-
 	musb->dev.parent		= &pdev->dev;
 	musb->dev.dma_mask		= &omap2430_dmamask;
 	musb->dev.coherent_dma_mask	= omap2430_dmamask;
 
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
-	glue->clk			= clk;
 
 	pdata->platform_ops		= &omap2430_ops;
 
@@ -431,29 +395,32 @@ static int __init omap2430_probe(struct platform_device *pdev)
 			pdev->num_resources);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err4;
+		goto err2;
 	}
 
 	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err4;
+		goto err2;
 	}
 
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err4;
+		goto err2;
 	}
 
-	return 0;
+	pm_runtime_enable(&pdev->dev);
+	status = pm_runtime_get_sync(&pdev->dev);
+	if (status < 0) {
+		dev_err(&pdev->dev, "pm_runtime_get_sync FAILED");
+		goto err3;
+	}
 
-err4:
-	clk_disable(clk);
+	return 0;
 
 err3:
-	clk_put(clk);
-
+	pm_runtime_disable(&pdev->dev);
 err2:
 	platform_device_put(musb);
 
@@ -470,8 +437,8 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
-	clk_disable(glue->clk);
-	clk_put(glue->clk);
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 	kfree(glue);
 
 	return 0;
@@ -480,13 +447,11 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static void omap2430_save_context(struct musb *musb)
 {
-	musb->context.otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	musb->context.otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
 }
 
 static void omap2430_restore_context(struct musb *musb)
 {
-	musb_writel(musb->mregs, OTG_SYSCONFIG, musb->context.otg_sysconfig);
 	musb_writel(musb->mregs, OTG_FORCESTDBY, musb->context.otg_forcestandby);
 }
 
@@ -498,7 +463,10 @@ static int omap2430_suspend(struct device *dev)
 	omap2430_low_level_exit(musb);
 	otg_set_suspend(musb->xceiv, 1);
 	omap2430_save_context(musb);
-	clk_disable(glue->clk);
+
+	if (!pm_runtime_suspended(dev) && dev->bus && dev->bus->pm &&
+			dev->bus->pm->runtime_suspend)
+		dev->bus->pm->runtime_suspend(dev);
 
 	return 0;
 }
@@ -507,13 +475,10 @@ static int omap2430_resume(struct device *dev)
 {
 	struct omap2430_glue		*glue = dev_get_drvdata(dev);
 	struct musb			*musb = glue_to_musb(glue);
-	int				ret;
 
-	ret = clk_enable(glue->clk);
-	if (ret) {
-		dev_err(dev, "faled to enable clock\n");
-		return ret;
-	}
+	if (!pm_runtime_suspended(dev) && dev->bus && dev->bus->pm &&
+			dev->bus->pm->runtime_resume)
+		dev->bus->pm->runtime_resume(dev);
 
 	omap2430_low_level_init(musb);
 	omap2430_restore_context(musb);

commit 19b9a83e214d3d3ac52a56daca5ea0d033ca47bc
Author: Johan Hovold <jhovold@gmail.com>
Date:   Fri Feb 11 16:57:08 2011 +0100

    USB: musb: omap2430: fix kernel panic on reboot
    
    Cancel idle timer in musb_platform_exit.
    
    The idle timer could trigger after clock had been disabled leading to
    kernel panic when MUSB_DEVCTL is accessed in musb_do_idle on 2.6.37.
    
    The fault below is no longer triggered on 2.6.38-rc4 (clock is disabled
    later, and only if compiled as a module, and the offending memory access
    has moved) but the timer should be cancelled nonetheless.
    
    Rebooting... musb_hdrc musb_hdrc: remove, state 4
    usb usb1: USB disconnect, address 1
    musb_hdrc musb_hdrc: USB bus 1 deregistered
    Unhandled fault: external abort on non-linefetch (0x1028) at 0xfa0ab060
    Internal error: : 1028 [#1] PREEMPT
    last sysfs file: /sys/kernel/uevent_seqnum
    Modules linked in:
    CPU: 0    Not tainted  (2.6.37+ #6)
    PC is at musb_do_idle+0x24/0x138
    LR is at musb_do_idle+0x18/0x138
    pc : [<c02377d8>]    lr : [<c02377cc>]    psr: 80000193
    sp : cf2bdd80  ip : cf2bdd80  fp : c048a20c
    r10: c048a60c  r9 : c048a40c  r8 : cf85e110
    r7 : cf2bc000  r6 : 40000113  r5 : c0489800  r4 : cf85e110
    r3 : 00000004  r2 : 00000006  r1 : fa0ab000  r0 : cf8a7000
    Flags: Nzcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5387d  Table: 8faac019  DAC: 00000015
    Process reboot (pid: 769, stack limit = 0xcf2bc2f0)
    Stack: (0xcf2bdd80 to 0xcf2be000)
    dd80: 00000103 c0489800 c02377b4 c005fa34 00000555 c0071a8c c04a3858 cf2bdda8
    dda0: 00000555 c048a00c cf2bdda8 cf2bdda8 1838beb0 00000103 00000004 cf2bc000
    ddc0: 00000001 00000001 c04896c8 0000000a 00000000 c005ac14 00000001 c003f32c
    dde0: 00000000 00000025 00000000 cf2bc000 00000002 00000001 cf2bc000 00000000
    de00: 00000001 c005ad08 cf2bc000 c002e07c c03ec039 ffffffff fa200000 c0033608
    de20: 00000001 00000000 cf852c14 cf81f200 c045b714 c045b708 cf2bc000 c04a37e8
    de40: c0033c04 cf2bc000 00000000 00000001 cf2bde68 cf2bde68 c01c3abc c004f7d8
    de60: 60000013 ffffffff c0033c04 00000000 01234567 fee1dead 00000000 c006627c
    de80: 00000001 c00662c8 28121969 c00663ec cfa38c40 cf9f6a00 cf2bded0 cf9f6a0c
    dea0: 00000000 cf92f000 00008914 c02cd284 c04a55c8 c028b398 c00715c0 becf24a8
    dec0: 30687465 00000000 00000000 00000000 00000002 1301a8c0 00000000 00000000
    dee0: 00000002 1301a8c0 00000000 00000000 c0450494 cf527920 00011f10 cf2bdf08
    df00: 00011f10 cf2bdf10 00011f10 cf2bdf18 c00f0b44 c004f7e8 cf2bdf18 cf2bdf18
    df20: 00011f10 cf2bdf30 00011f10 cf2bdf38 cf401300 cf486100 00000008 c00d2b28
    df40: 00011f10 cf401300 00200200 c00d3388 00011f10 cfb63a88 cfb63a80 c00c2f08
    df60: 00000000 00000000 cfb63a80 00000000 cf0a3480 00000006 c0033c04 cfb63a80
    df80: 00000000 c00c0104 00000003 cf0a3480 cfb63a80 00000000 00000001 00000004
    dfa0: 00000058 c0033a80 00000000 00000001 fee1dead 28121969 01234567 00000000
    dfc0: 00000000 00000001 00000004 00000058 00000001 00000001 00000000 00000001
    dfe0: 4024d200 becf2cb0 00009210 4024d218 60000010 fee1dead 00000000 00000000
    [<c02377d8>] (musb_do_idle+0x24/0x138) from [<c005fa34>] (run_timer_softirq+0x1a8/0x26)
    [<c005fa34>] (run_timer_softirq+0x1a8/0x26c) from [<c005ac14>] (__do_softirq+0x88/0x13)
    [<c005ac14>] (__do_softirq+0x88/0x138) from [<c005ad08>] (irq_exit+0x44/0x98)
    [<c005ad08>] (irq_exit+0x44/0x98) from [<c002e07c>] (asm_do_IRQ+0x7c/0xa0)
    [<c002e07c>] (asm_do_IRQ+0x7c/0xa0) from [<c0033608>] (__irq_svc+0x48/0xa8)
    Exception stack(0xcf2bde20 to 0xcf2bde68)
    de20: 00000001 00000000 cf852c14 cf81f200 c045b714 c045b708 cf2bc000 c04a37e8
    de40: c0033c04 cf2bc000 00000000 00000001 cf2bde68 cf2bde68 c01c3abc c004f7d8
    de60: 60000013 ffffffff
    [<c0033608>] (__irq_svc+0x48/0xa8) from [<c004f7d8>] (sub_preempt_count+0x0/0xb8)
    Code: ebf86030 e5940098 e594108c e5902010 (e5d13060)
    ---[ end trace 3689c0d808f9bf7c ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a3f12333fc41..bc8badd16897 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -362,6 +362,7 @@ static int omap2430_musb_init(struct musb *musb)
 
 static int omap2430_musb_exit(struct musb *musb)
 {
+	del_timer_sync(&musb_idle_timer);
 
 	omap2430_low_level_exit(musb);
 	otg_put_transceiver(musb->xceiv);

commit 594632efbb9a4ac323cbf8dbf37c608d418ca8c1
Author: Hema HK <hemahk@ti.com>
Date:   Fri Dec 10 18:10:51 2010 +0530

    usb: musb: Adding musb support for OMAP4430
    
    OMAP4430 supports UTMI and ULPI types of transceiver interface.
    
    In UTMI mode: The PHY is embedded within OMAP4430. The transceiver functionality
    is split between the twl6030 PMIC chip and OMAP4430. The VBUS, ID pin
    sensing and OTG SRP generation part is integrated in TWL6030 and UTMI PHY
    functionality is embedded within the OMAP4430.
    
    There is no direct interactions between the MUSB controller and TWL6030
    chip to communicate the session-valid, session-end and ID-GND events.
    It has to be done through a software by setting/resetting bits in
    one of the control module register of OMAP4430 which in turn toggles
    the appropriate signals to MUSB controller.
    
    musb driver is register for blocking notifications from the transceiver
    driver to get the event notifications for connect/disconnect and ID-GND.
    Based on these events call the transceiver init/shutdown function to
    configure the transceiver to toggle the VBUS valid, session end and ID_GND
    signals to musb and power on/off the internal PHY.
    
    For ID_GND event notifications, toggle the ID_GND signal and then wait for
    musb to be configured as "A" device, and then call the transceiver function
    to set the VBUS.
    
    In OTG mode and musb as a host, When the Micro A connector used, VBUS is turned on
    and session bit set. When the device is connected, enumeration goes through.
    When the device disconnected from the other end of the connector(ID is still grounded),
    link will detect the disconnect and end the session. When the device is connected back,
    there are no events generated in the TWL6030-usb, and link is already down.
    So the device is not detected. Removed the session bit disable code which
    will recognize the connect of the device.
    
    Limitation: In OTG host mode, if device is connected during boot, it does not get
    detected. If disconnect and connect it back or connect after boot only it works.
    Fix for this, I will submit seperate patch later.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 0a7e6824eae8..a3f12333fc41 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -57,12 +57,8 @@ static void musb_do_idle(unsigned long _musb)
 
 	spin_lock_irqsave(&musb->lock, flags);
 
-	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
 	switch (musb->xceiv->state) {
 	case OTG_STATE_A_WAIT_BCON:
-		devctl &= ~MUSB_DEVCTL_SESSION;
-		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
@@ -142,6 +138,8 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
 	u8		devctl;
+	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+	int ret = 1;
 	/* HDRC controls CPEN, but beware current surges during device
 	 * connect.  They can trigger transient overcurrent conditions
 	 * that must be ignored.
@@ -150,12 +148,35 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
 	if (is_on) {
-		musb->is_active = 1;
-		musb->xceiv->default_a = 1;
-		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
-		devctl |= MUSB_DEVCTL_SESSION;
-
-		MUSB_HST_MODE(musb);
+		if (musb->xceiv->state == OTG_STATE_A_IDLE) {
+			/* start the session */
+			devctl |= MUSB_DEVCTL_SESSION;
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+			/*
+			 * Wait for the musb to set as A device to enable the
+			 * VBUS
+			 */
+			while (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {
+
+				cpu_relax();
+
+				if (time_after(jiffies, timeout)) {
+					dev_err(musb->controller,
+					"configured as A device timeout");
+					ret = -EINVAL;
+					break;
+				}
+			}
+
+			if (ret && musb->xceiv->set_vbus)
+				otg_set_vbus(musb->xceiv, 1);
+		} else {
+			musb->is_active = 1;
+			musb->xceiv->default_a = 1;
+			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
+			devctl |= MUSB_DEVCTL_SESSION;
+			MUSB_HST_MODE(musb);
+		}
 	} else {
 		musb->is_active = 0;
 
@@ -214,9 +235,64 @@ static inline void omap2430_low_level_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 }
 
+/* blocking notifier support */
+static int musb_otg_notifications(struct notifier_block *nb,
+		unsigned long event, void *unused)
+{
+	struct musb	*musb = container_of(nb, struct musb, nb);
+	struct device *dev = musb->controller;
+	struct musb_hdrc_platform_data *pdata = dev->platform_data;
+	struct omap_musb_board_data *data = pdata->board_data;
+
+	switch (event) {
+	case USB_EVENT_ID:
+		DBG(4, "ID GND\n");
+
+		if (is_otg_enabled(musb)) {
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+			if (musb->gadget_driver) {
+				otg_init(musb->xceiv);
+
+				if (data->interface_type ==
+						MUSB_INTERFACE_UTMI)
+					omap2430_musb_set_vbus(musb, 1);
+
+			}
+#endif
+		} else {
+			otg_init(musb->xceiv);
+			if (data->interface_type ==
+					MUSB_INTERFACE_UTMI)
+				omap2430_musb_set_vbus(musb, 1);
+		}
+		break;
+
+	case USB_EVENT_VBUS:
+		DBG(4, "VBUS Connect\n");
+
+		otg_init(musb->xceiv);
+		break;
+
+	case USB_EVENT_NONE:
+		DBG(4, "VBUS Disconnect\n");
+
+		if (data->interface_type == MUSB_INTERFACE_UTMI) {
+			if (musb->xceiv->set_vbus)
+				otg_set_vbus(musb->xceiv, 0);
+		}
+		otg_shutdown(musb->xceiv);
+		break;
+	default:
+		DBG(4, "ID float\n");
+		return NOTIFY_DONE;
+	}
+
+	return NOTIFY_OK;
+}
+
 static int omap2430_musb_init(struct musb *musb)
 {
-	u32 l;
+	u32 l, status = 0;
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *plat = dev->platform_data;
 	struct omap_musb_board_data *data = plat->board_data;
@@ -268,6 +344,17 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
+	musb->nb.notifier_call = musb_otg_notifications;
+	status = otg_register_notifier(musb->xceiv, &musb->nb);
+
+	if (status)
+		DBG(1, "notification register failed\n");
+
+	/* check whether cable is already connected */
+	if (musb->xceiv->state ==OTG_STATE_B_IDLE)
+		musb_otg_notifications(&musb->nb, 1,
+					musb->xceiv->gadget);
+
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
 	return 0;

commit 92b48df24eec49ed1eb0ec9c5f6165d8282153ea
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 14:30:06 2010 +0200

    usb: musb: drop board_set_vbus
    
    that's not used anymore. So let's drop it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5939823990c9..0a7e6824eae8 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -268,9 +268,6 @@ static int omap2430_musb_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
-	if (is_host_enabled(musb))
-		musb->board_set_vbus = omap2430_musb_set_vbus;
-
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
 	return 0;

commit c20aebb92796cf54ae8171ad7f53a8fa7c61d2d8
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 12:44:40 2010 +0200

    usb: musb: omap2430: use dev_pm_ops structure
    
    instead of using musb_platform_suspend/resume,
    we can use dev_pm_ops and let the platform_device
    core handle when to call musb_core's suspend and
    glue layer's suspend.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ef0f7fe92f13..5939823990c9 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -42,6 +42,7 @@ struct omap2430_glue {
 	struct platform_device	*musb;
 	struct clk		*clk;
 };
+#define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
 static struct timer_list musb_idle_timer;
 
@@ -176,8 +177,6 @@ static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
-static int omap2430_musb_resume(struct musb *musb);
-
 static int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)
 {
 	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
@@ -188,6 +187,33 @@ static int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)
 	return 0;
 }
 
+static inline void omap2430_low_level_exit(struct musb *musb)
+{
+	u32 l;
+
+	/* in any role */
+	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
+	l |= ENABLEFORCE;	/* enable MSTANDBY */
+	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
+
+	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
+	l |= ENABLEWAKEUP;	/* enable wakeup */
+	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
+}
+
+static inline void omap2430_low_level_init(struct musb *musb)
+{
+	u32 l;
+
+	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP;	/* disable wakeup */
+	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
+
+	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
+	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
+	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
+}
+
 static int omap2430_musb_init(struct musb *musb)
 {
 	u32 l;
@@ -205,7 +231,7 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
-	omap2430_musb_resume(musb);
+	omap2430_low_level_init(musb);
 
 	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
@@ -250,63 +276,12 @@ static int omap2430_musb_init(struct musb *musb)
 	return 0;
 }
 
-static void omap2430_save_context(struct musb *musb)
-{
-	musb->context.otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	musb->context.otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
-}
-
-static void omap2430_restore_context(struct musb *musb)
-{
-	musb_writel(musb->mregs, OTG_SYSCONFIG, musb->context.otg_sysconfig);
-	musb_writel(musb->mregs, OTG_FORCESTDBY, musb->context.otg_forcestandby);
-}
-
-static int omap2430_musb_suspend(struct musb *musb)
-{
-	u32 l;
-
-	/* in any role */
-	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
-	l |= ENABLEFORCE;	/* enable MSTANDBY */
-	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
-
-	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	l |= ENABLEWAKEUP;	/* enable wakeup */
-	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
-
-	omap2430_save_context(musb);
-
-	otg_set_suspend(musb->xceiv, 1);
-
-	return 0;
-}
-
-static int omap2430_musb_resume(struct musb *musb)
-{
-	u32 l;
-
-	otg_set_suspend(musb->xceiv, 0);
-
-	omap2430_restore_context(musb);
-
-	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	l &= ~ENABLEWAKEUP;	/* disable wakeup */
-	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
-
-	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
-	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
-	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
-
-	return 0;
-}
-
 static int omap2430_musb_exit(struct musb *musb)
 {
 
-	omap2430_musb_suspend(musb);
-
+	omap2430_low_level_exit(musb);
 	otg_put_transceiver(musb->xceiv);
+
 	return 0;
 }
 
@@ -314,9 +289,6 @@ static const struct musb_platform_ops omap2430_ops = {
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 
-	.suspend	= omap2430_musb_suspend,
-	.resume		= omap2430_musb_resume,
-
 	.set_mode	= omap2430_musb_set_mode,
 	.try_idle	= omap2430_musb_try_idle,
 
@@ -421,10 +393,66 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static void omap2430_save_context(struct musb *musb)
+{
+	musb->context.otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
+	musb->context.otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
+}
+
+static void omap2430_restore_context(struct musb *musb)
+{
+	musb_writel(musb->mregs, OTG_SYSCONFIG, musb->context.otg_sysconfig);
+	musb_writel(musb->mregs, OTG_FORCESTDBY, musb->context.otg_forcestandby);
+}
+
+static int omap2430_suspend(struct device *dev)
+{
+	struct omap2430_glue		*glue = dev_get_drvdata(dev);
+	struct musb			*musb = glue_to_musb(glue);
+
+	omap2430_low_level_exit(musb);
+	otg_set_suspend(musb->xceiv, 1);
+	omap2430_save_context(musb);
+	clk_disable(glue->clk);
+
+	return 0;
+}
+
+static int omap2430_resume(struct device *dev)
+{
+	struct omap2430_glue		*glue = dev_get_drvdata(dev);
+	struct musb			*musb = glue_to_musb(glue);
+	int				ret;
+
+	ret = clk_enable(glue->clk);
+	if (ret) {
+		dev_err(dev, "faled to enable clock\n");
+		return ret;
+	}
+
+	omap2430_low_level_init(musb);
+	omap2430_restore_context(musb);
+	otg_set_suspend(musb->xceiv, 0);
+
+	return 0;
+}
+
+static struct dev_pm_ops omap2430_pm_ops = {
+	.suspend	= omap2430_suspend,
+	.resume		= omap2430_resume,
+};
+
+#define DEV_PM_OPS	(&omap2430_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif
+
 static struct platform_driver omap2430_driver = {
 	.remove		= __exit_p(omap2430_remove),
 	.driver		= {
 		.name	= "musb-omap2430",
+		.pm	= DEV_PM_OPS,
 	},
 };
 

commit e6326358a43a9ac23f6df69ed1f4707c0d1ac473
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 12:35:59 2010 +0200

    usb: musb: omap2430: drop the nops
    
    we don't need those nops, so drop them.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2659667a1994..ef0f7fe92f13 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -138,14 +138,6 @@ static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 	mod_timer(&musb_idle_timer, timeout);
 }
 
-static void omap2430_musb_enable(struct musb *musb)
-{
-}
-
-static void omap2430_musb_disable(struct musb *musb)
-{
-}
-
 static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
 	u8		devctl;
@@ -325,9 +317,6 @@ static const struct musb_platform_ops omap2430_ops = {
 	.suspend	= omap2430_musb_suspend,
 	.resume		= omap2430_musb_resume,
 
-	.enable		= omap2430_musb_enable,
-	.disable	= omap2430_musb_disable,
-
 	.set_mode	= omap2430_musb_set_mode,
 	.try_idle	= omap2430_musb_try_idle,
 

commit 496351413a227a6c0ea1a704d3d4c775d413fd08
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 12:27:35 2010 +0200

    usb: musb: drop musb_platform_save/restore_context
    
    ... that can be easily folded into the
    musb_platform_suspend/resume calls.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index fa3154b03044..2659667a1994 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -258,21 +258,17 @@ static int omap2430_musb_init(struct musb *musb)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-void musb_platform_save_context(struct musb *musb,
-		struct musb_context_registers *musb_context)
+static void omap2430_save_context(struct musb *musb)
 {
-	musb_context->otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
-	musb_context->otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
+	musb->context.otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
+	musb->context.otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
 }
 
-void musb_platform_restore_context(struct musb *musb,
-		struct musb_context_registers *musb_context)
+static void omap2430_restore_context(struct musb *musb)
 {
-	musb_writel(musb->mregs, OTG_SYSCONFIG, musb_context->otg_sysconfig);
-	musb_writel(musb->mregs, OTG_FORCESTDBY, musb_context->otg_forcestandby);
+	musb_writel(musb->mregs, OTG_SYSCONFIG, musb->context.otg_sysconfig);
+	musb_writel(musb->mregs, OTG_FORCESTDBY, musb->context.otg_forcestandby);
 }
-#endif
 
 static int omap2430_musb_suspend(struct musb *musb)
 {
@@ -287,6 +283,8 @@ static int omap2430_musb_suspend(struct musb *musb)
 	l |= ENABLEWAKEUP;	/* enable wakeup */
 	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 
+	omap2430_save_context(musb);
+
 	otg_set_suspend(musb->xceiv, 1);
 
 	return 0;
@@ -298,6 +296,8 @@ static int omap2430_musb_resume(struct musb *musb)
 
 	otg_set_suspend(musb->xceiv, 0);
 
+	omap2430_restore_context(musb);
+
 	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
 	musb_writel(musb->mregs, OTG_SYSCONFIG, l);

commit 0349176120aa3024e96ae4fd7dc0e0181dc55f52
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:57:08 2010 +0200

    usb: musb: move clock handling to glue layer
    
    musb core doesn't need to know about platform
    specific details. So start moving clock
    handling to platform glue layer and make
    musb core agnostic about that.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2eea1703e630..fa3154b03044 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -40,6 +40,7 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
+	struct clk		*clk;
 };
 
 static struct timer_list musb_idle_timer;
@@ -277,9 +278,6 @@ static int omap2430_musb_suspend(struct musb *musb)
 {
 	u32 l;
 
-	if (!musb->clock)
-		return 0;
-
 	/* in any role */
 	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
 	l |= ENABLEFORCE;	/* enable MSTANDBY */
@@ -291,11 +289,6 @@ static int omap2430_musb_suspend(struct musb *musb)
 
 	otg_set_suspend(musb->xceiv, 1);
 
-	if (musb->set_clock)
-		musb->set_clock(musb->clock, 0);
-	else
-		clk_disable(musb->clock);
-
 	return 0;
 }
 
@@ -303,16 +296,8 @@ static int omap2430_musb_resume(struct musb *musb)
 {
 	u32 l;
 
-	if (!musb->clock)
-		return 0;
-
 	otg_set_suspend(musb->xceiv, 0);
 
-	if (musb->set_clock)
-		musb->set_clock(musb->clock, 1);
-	else
-		clk_enable(musb->clock);
-
 	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
 	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
@@ -356,6 +341,7 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
 	struct omap2430_glue		*glue;
+	struct clk			*clk;
 
 	int				ret = -ENOMEM;
 
@@ -371,12 +357,26 @@ static int __init omap2430_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
+	clk = clk_get(&pdev->dev, "ick");
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "failed to get clock\n");
+		ret = PTR_ERR(clk);
+		goto err2;
+	}
+
+	ret = clk_enable(clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable clock\n");
+		goto err3;
+	}
+
 	musb->dev.parent		= &pdev->dev;
 	musb->dev.dma_mask		= &omap2430_dmamask;
 	musb->dev.coherent_dma_mask	= omap2430_dmamask;
 
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
+	glue->clk			= clk;
 
 	pdata->platform_ops		= &omap2430_ops;
 
@@ -386,23 +386,29 @@ static int __init omap2430_probe(struct platform_device *pdev)
 			pdev->num_resources);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err2;
+		goto err4;
 	}
 
 	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err2;
+		goto err4;
 	}
 
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err2;
+		goto err4;
 	}
 
 	return 0;
 
+err4:
+	clk_disable(clk);
+
+err3:
+	clk_put(clk);
+
 err2:
 	platform_device_put(musb);
 
@@ -419,6 +425,8 @@ static int __exit omap2430_remove(struct platform_device *pdev)
 
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
+	clk_disable(glue->clk);
+	clk_put(glue->clk);
 	kfree(glue);
 
 	return 0;

commit f7ec94370f417fedad4db1054228ef958d48b926
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:48:58 2010 +0200

    usb: musb: pass platform_ops via platform_data
    
    ... then we don't need to export any symbols
    from glue layer to musb_core.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index bca9df7557a4..2eea1703e630 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -333,7 +333,7 @@ static int omap2430_musb_exit(struct musb *musb)
 	return 0;
 }
 
-const struct musb_platform_ops musb_ops = {
+static const struct musb_platform_ops omap2430_ops = {
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 
@@ -378,6 +378,8 @@ static int __init omap2430_probe(struct platform_device *pdev)
 	glue->dev			= &pdev->dev;
 	glue->musb			= musb;
 
+	pdata->platform_ops		= &omap2430_ops;
+
 	platform_set_drvdata(pdev, glue);
 
 	ret = platform_device_add_resources(musb, pdev->resource,

commit a3cee12aa9129b576c5403a31e37d0e0113235b3
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:27:29 2010 +0200

    usb: musb: omap2430: give it a context structure
    
    that structure currently only holds a device
    pointer to our own platform_device and musb's
    platform_device, but soon it will hold pointers
    to our clock structures and glue-specific bits
    and pieces.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 78bb1e5cb9f8..bca9df7557a4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -37,6 +37,11 @@
 #include "musb_core.h"
 #include "omap2430.h"
 
+struct omap2430_glue {
+	struct device		*dev;
+	struct platform_device	*musb;
+};
+
 static struct timer_list musb_idle_timer;
 
 static void musb_do_idle(unsigned long _musb)
@@ -350,55 +355,69 @@ static int __init omap2430_probe(struct platform_device *pdev)
 {
 	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
 	struct platform_device		*musb;
+	struct omap2430_glue		*glue;
 
 	int				ret = -ENOMEM;
 
+	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
+	if (!glue) {
+		dev_err(&pdev->dev, "failed to allocate glue context\n");
+		goto err0;
+	}
+
 	musb = platform_device_alloc("musb-hdrc", -1);
 	if (!musb) {
 		dev_err(&pdev->dev, "failed to allocate musb device\n");
-		goto err0;
+		goto err1;
 	}
 
 	musb->dev.parent		= &pdev->dev;
 	musb->dev.dma_mask		= &omap2430_dmamask;
 	musb->dev.coherent_dma_mask	= omap2430_dmamask;
 
-	platform_set_drvdata(pdev, musb);
+	glue->dev			= &pdev->dev;
+	glue->musb			= musb;
+
+	platform_set_drvdata(pdev, glue);
 
 	ret = platform_device_add_resources(musb, pdev->resource,
 			pdev->num_resources);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add resources\n");
-		goto err1;
+		goto err2;
 	}
 
 	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add platform_data\n");
-		goto err1;
+		goto err2;
 	}
 
 	ret = platform_device_add(musb);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register musb device\n");
-		goto err1;
+		goto err2;
 	}
 
 	return 0;
 
-err1:
+err2:
 	platform_device_put(musb);
 
+err1:
+	kfree(glue);
+
 err0:
 	return ret;
 }
 
 static int __exit omap2430_remove(struct platform_device *pdev)
 {
-	struct platform_device		*musb = platform_get_drvdata(pdev);
+	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
-	platform_device_del(musb);
-	platform_device_put(musb);
+	platform_device_del(glue->musb);
+	platform_device_put(glue->musb);
+	kfree(glue);
 
 	return 0;
 }

commit dc09886bfa781e2b442301116c18199519e36f0f
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Dec 1 15:01:11 2010 +0200

    usb: musb: split omap2430 to its own platform_driver
    
    Just adding its own platform_driver, not really
    using it yet.
    
    When all HW glue layers are converted, more patches
    will come to split power management code from musb_core
    and move it completely to HW glue layer.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 5f0d0f105989..78bb1e5cb9f8 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -31,6 +31,8 @@
 #include <linux/list.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 
 #include "musb_core.h"
 #include "omap2430.h"
@@ -341,3 +343,85 @@ const struct musb_platform_ops musb_ops = {
 
 	.set_vbus	= omap2430_musb_set_vbus,
 };
+
+static u64 omap2430_dmamask = DMA_BIT_MASK(32);
+
+static int __init omap2430_probe(struct platform_device *pdev)
+{
+	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
+	struct platform_device		*musb;
+
+	int				ret = -ENOMEM;
+
+	musb = platform_device_alloc("musb-hdrc", -1);
+	if (!musb) {
+		dev_err(&pdev->dev, "failed to allocate musb device\n");
+		goto err0;
+	}
+
+	musb->dev.parent		= &pdev->dev;
+	musb->dev.dma_mask		= &omap2430_dmamask;
+	musb->dev.coherent_dma_mask	= omap2430_dmamask;
+
+	platform_set_drvdata(pdev, musb);
+
+	ret = platform_device_add_resources(musb, pdev->resource,
+			pdev->num_resources);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add resources\n");
+		goto err1;
+	}
+
+	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add platform_data\n");
+		goto err1;
+	}
+
+	ret = platform_device_add(musb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register musb device\n");
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	platform_device_put(musb);
+
+err0:
+	return ret;
+}
+
+static int __exit omap2430_remove(struct platform_device *pdev)
+{
+	struct platform_device		*musb = platform_get_drvdata(pdev);
+
+	platform_device_del(musb);
+	platform_device_put(musb);
+
+	return 0;
+}
+
+static struct platform_driver omap2430_driver = {
+	.remove		= __exit_p(omap2430_remove),
+	.driver		= {
+		.name	= "musb-omap2430",
+	},
+};
+
+MODULE_DESCRIPTION("OMAP2PLUS MUSB Glue Layer");
+MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
+MODULE_LICENSE("GPL v2");
+
+static int __init omap2430_init(void)
+{
+	return platform_driver_probe(&omap2430_driver, omap2430_probe);
+}
+subsys_initcall(omap2430_init);
+
+static void __exit omap2430_exit(void)
+{
+	platform_driver_unregister(&omap2430_driver);
+}
+module_exit(omap2430_exit);

commit 743411b3f3e96e8ac4cae73551a0a95392fed1ea
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Dec 1 13:22:05 2010 +0200

    usb: musb: make all glue layer export struct musb_platform_ops
    
    preparing to a big refactor on musb code. We need
    to be able to compile in all glue layers (or at
    least all ARM-based ones) together and have a
    working binary.
    
    While preparing for that, we move every glue
    layer to export only one symbol, which is
    a struct musb_platform_ops, and make all
    other functions static.
    
    Later patches will come to allow for compiling
    all glue layers together and have a working
    binary.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 27dabcf0a868..5f0d0f105989 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -35,7 +35,6 @@
 #include "musb_core.h"
 #include "omap2430.h"
 
-
 static struct timer_list musb_idle_timer;
 
 static void musb_do_idle(unsigned long _musb)
@@ -98,7 +97,7 @@ static void musb_do_idle(unsigned long _musb)
 }
 
 
-void musb_platform_try_idle(struct musb *musb, unsigned long timeout)
+static void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)
 {
 	unsigned long		default_timeout = jiffies + msecs_to_jiffies(3);
 	static unsigned long	last_timer;
@@ -131,13 +130,15 @@ void musb_platform_try_idle(struct musb *musb, unsigned long timeout)
 	mod_timer(&musb_idle_timer, timeout);
 }
 
-void musb_platform_enable(struct musb *musb)
+static void omap2430_musb_enable(struct musb *musb)
 {
 }
-void musb_platform_disable(struct musb *musb)
+
+static void omap2430_musb_disable(struct musb *musb)
 {
 }
-static void omap_set_vbus(struct musb *musb, int is_on)
+
+static void omap2430_musb_set_vbus(struct musb *musb, int is_on)
 {
 	u8		devctl;
 	/* HDRC controls CPEN, but beware current surges during device
@@ -175,9 +176,9 @@ static void omap_set_vbus(struct musb *musb, int is_on)
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
 
-static int musb_platform_resume(struct musb *musb);
+static int omap2430_musb_resume(struct musb *musb);
 
-int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
+static int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)
 {
 	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
@@ -187,7 +188,7 @@ int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 	return 0;
 }
 
-int __init musb_platform_init(struct musb *musb)
+static int omap2430_musb_init(struct musb *musb)
 {
 	u32 l;
 	struct device *dev = musb->controller;
@@ -204,7 +205,7 @@ int __init musb_platform_init(struct musb *musb)
 		return -ENODEV;
 	}
 
-	musb_platform_resume(musb);
+	omap2430_musb_resume(musb);
 
 	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
@@ -242,7 +243,7 @@ int __init musb_platform_init(struct musb *musb)
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
 	if (is_host_enabled(musb))
-		musb->board_set_vbus = omap_set_vbus;
+		musb->board_set_vbus = omap2430_musb_set_vbus;
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
@@ -265,7 +266,7 @@ void musb_platform_restore_context(struct musb *musb,
 }
 #endif
 
-static int musb_platform_suspend(struct musb *musb)
+static int omap2430_musb_suspend(struct musb *musb)
 {
 	u32 l;
 
@@ -291,7 +292,7 @@ static int musb_platform_suspend(struct musb *musb)
 	return 0;
 }
 
-static int musb_platform_resume(struct musb *musb)
+static int omap2430_musb_resume(struct musb *musb)
 {
 	u32 l;
 
@@ -316,12 +317,27 @@ static int musb_platform_resume(struct musb *musb)
 	return 0;
 }
 
-
-int musb_platform_exit(struct musb *musb)
+static int omap2430_musb_exit(struct musb *musb)
 {
 
-	musb_platform_suspend(musb);
+	omap2430_musb_suspend(musb);
 
 	otg_put_transceiver(musb->xceiv);
 	return 0;
 }
+
+const struct musb_platform_ops musb_ops = {
+	.init		= omap2430_musb_init,
+	.exit		= omap2430_musb_exit,
+
+	.suspend	= omap2430_musb_suspend,
+	.resume		= omap2430_musb_resume,
+
+	.enable		= omap2430_musb_enable,
+	.disable	= omap2430_musb_disable,
+
+	.set_mode	= omap2430_musb_set_mode,
+	.try_idle	= omap2430_musb_try_idle,
+
+	.set_vbus	= omap2430_musb_set_vbus,
+};

commit ea65df57c2eea803535a071752efb030c46a11f5
Author: Hema Kalliguddi <hemahk@ti.com>
Date:   Wed Sep 22 19:27:40 2010 -0500

    usb: musb: remove board_data parameter from musb_platform_init()
    
    Removed the board_data parameter being
    passed to musb_platform_init function
    as board_data can be extracted from
    device structure which is already member
    of musb structure.
    
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ed618bde1eec..27dabcf0a868 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -187,10 +187,12 @@ int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 	return 0;
 }
 
-int __init musb_platform_init(struct musb *musb, void *board_data)
+int __init musb_platform_init(struct musb *musb)
 {
 	u32 l;
-	struct omap_musb_board_data *data = board_data;
+	struct device *dev = musb->controller;
+	struct musb_hdrc_platform_data *plat = dev->platform_data;
+	struct omap_musb_board_data *data = plat->board_data;
 
 	/* We require some kind of external transceiver, hooked
 	 * up through ULPI.  TWL4030-family PMICs include one,

commit f405387435a85a440d1ce16f3ca36e042281643a
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Sep 29 09:54:29 2010 +0300

    USB: MUSB: fix kernel WARNING/oops when unloading module in OTG mode
    
    Since commit 461972d8a4c94bc44f11a13046041c78a7cf18dd (musb_core: don't call
    musb_platform_exit() twice), unloading the driver module results in a WARNING
    "kobject: '(null)' (c73de788): is not initialized, yet kobject_put() is being
    called." (or even kernel oops) on e.g. DaVincis, though only in the OTG mode.
    There exists dubious and unbalanced put_device() call in musb_free() which
    takes place only in the OTG mode.  As this commit caused musb_platform_exit()
    to be called (and so unregister the NOP transceiver) before this put_device()
    call, this function references already freed memory.
    
    On the other hand, all the glue layers miss the otg_put_transceiver() call,
    complementary to the otg_get_transceiver() call that they do.  So, I think
    the solution is to get rid of the strange put_device() call, and instead
    call otg_put_transceiver() in the glue layers...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 2111a241dd03..ed618bde1eec 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -320,5 +320,6 @@ int musb_platform_exit(struct musb *musb)
 
 	musb_platform_suspend(musb);
 
+	otg_put_transceiver(musb->xceiv);
 	return 0;
 }

commit 3f1a9696aed6814601078f3c430a8e432b625c66
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Thu Jul 8 16:34:54 2010 +0530

    USB: musb: Kill board specific pinmux from driver file
    
    This pin-muxing is best done in the board files. The driver should
    not do this explicitly.
    
    Also, this code causes a warning to be thrown when OMAP2430 and OMAP3/4
    support are enabled in the same kernel.
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Acked-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e06d65e36bf7..2111a241dd03 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -32,8 +32,6 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#include <plat/mux.h>
-
 #include "musb_core.h"
 #include "omap2430.h"
 
@@ -194,10 +192,6 @@ int __init musb_platform_init(struct musb *musb, void *board_data)
 	u32 l;
 	struct omap_musb_board_data *data = board_data;
 
-#if defined(CONFIG_ARCH_OMAP2430)
-	omap_cfg_reg(AE5_2430_USB0HS_STP);
-#endif
-
 	/* We require some kind of external transceiver, hooked
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.

commit 82e2af47fe7a494fafb3f6ed39a7856c1307411b
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Thu Mar 25 13:25:25 2010 +0200

    usb: musb: omap2430.c: remove unnecessary includes
    
    We don't need mach-types and hardware.h
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index def37ebe2ff4..e06d65e36bf7 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -32,8 +32,6 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
 #include <plat/mux.h>
 
 #include "musb_core.h"

commit 00ce8eca856bc1e0b943427d2cf76122ae3b1255
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Thu Mar 25 13:25:24 2010 +0200

    usb: musb: omap2430: remove unused define
    
    get_cpu_rev() is unused in this driver. It is probably legacy
    code. So remove it.
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index d05eef2baaaf..def37ebe2ff4 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -39,10 +39,6 @@
 #include "musb_core.h"
 #include "omap2430.h"
 
-#ifdef CONFIG_ARCH_OMAP3430
-#define	get_cpu_rev()	2
-#endif
-
 
 static struct timer_list musb_idle_timer;
 

commit 5b3078b2d789f4bd49006a3633dc106e56c47e28
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Mar 25 13:25:22 2010 +0200

    MUSB: OMAP: make musb_platform_suspend() 'static'
    
    This function is only called inside omap2430.c...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index c2413c76126d..d05eef2baaaf 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -275,7 +275,7 @@ void musb_platform_restore_context(struct musb *musb,
 }
 #endif
 
-int musb_platform_suspend(struct musb *musb)
+static int musb_platform_suspend(struct musb *musb)
 {
 	u32 l;
 

commit ca0d44525060cf852b87c35f64d786b8a2a75c3d
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Mar 25 13:25:20 2010 +0200

    MUSB: OMAP: remove omap_vbus_power()
    
    This function does nothing...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 0e5d0670506b..c2413c76126d 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -145,10 +145,6 @@ void musb_platform_enable(struct musb *musb)
 void musb_platform_disable(struct musb *musb)
 {
 }
-static void omap_vbus_power(struct musb *musb, int is_on, int sleeping)
-{
-}
-
 static void omap_set_vbus(struct musb *musb, int is_on)
 {
 	u8		devctl;
@@ -255,8 +251,6 @@ int __init musb_platform_init(struct musb *musb, void *board_data)
 			musb_readl(musb->mregs, OTG_INTERFSEL),
 			musb_readl(musb->mregs, OTG_SIMENABLE));
 
-	omap_vbus_power(musb, musb->board_mode == MUSB_HOST, 1);
-
 	if (is_host_enabled(musb))
 		musb->board_set_vbus = omap_set_vbus;
 
@@ -336,8 +330,6 @@ static int musb_platform_resume(struct musb *musb)
 int musb_platform_exit(struct musb *musb)
 {
 
-	omap_vbus_power(musb, 0 /*off*/, 1);
-
 	musb_platform_suspend(musb);
 
 	return 0;

commit de2e1b0c988c901989713869a8bea3b3d02bb9ce
Author: Maulik Mankad <x0082077@ti.com>
Date:   Fri Mar 12 10:29:07 2010 +0200

    usb: musb: Set transceiver interface type
    
    Program the OTG_INTERFSEL register based on
    transcevier type passed from board file.
    
    Adapt signature of musb_platform_init() function
    for davinci, blackfin and tusb6010.
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Sergei Shtylyov <sshtylyov@mvista.com>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 82592633502f..0e5d0670506b 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -199,9 +199,10 @@ int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 	return 0;
 }
 
-int __init musb_platform_init(struct musb *musb)
+int __init musb_platform_init(struct musb *musb, void *board_data)
 {
 	u32 l;
+	struct omap_musb_board_data *data = board_data;
 
 #if defined(CONFIG_ARCH_OMAP2430)
 	omap_cfg_reg(AE5_2430_USB0HS_STP);
@@ -235,7 +236,15 @@ int __init musb_platform_init(struct musb *musb)
 	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 
 	l = musb_readl(musb->mregs, OTG_INTERFSEL);
-	l |= ULPI_12PIN;
+
+	if (data->interface_type == MUSB_INTERFACE_UTMI) {
+		/* OMAP4 uses Internal PHY GS70 which uses UTMI interface */
+		l &= ~ULPI_12PIN;       /* Disable ULPI */
+		l |= UTMI_8BIT;         /* Enable UTMI  */
+	} else {
+		l |= ULPI_12PIN;
+	}
+
 	musb_writel(musb->mregs, OTG_INTERFSEL, l);
 
 	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "

commit 7917a9df73c13822cc830f0ead0fb1b44a930616
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Mar 25 13:14:31 2010 +0200

    MUSB: OMAP: don't call clk_put()
    
    Remove duplicate/unbalanced call to clk_put() from musb_platform_exit() --
    clk_put() gets called from musb_core.c anyway...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 490cdf15ccb6..82592633502f 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -331,8 +331,5 @@ int musb_platform_exit(struct musb *musb)
 
 	musb_platform_suspend(musb);
 
-	clk_put(musb->clock);
-	musb->clock = NULL;
-
 	return 0;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 3fe16867b5a8..490cdf15ccb6 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -27,7 +27,6 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/clk.h>

commit 8573e6a673fc99bd89a6c08ef9841d8b52f9d3c5
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Jan 21 15:33:53 2010 +0200

    USB: musb: get rid of omap_readl/writel
    
    we have those addresses already ioremaped, so let's
    use our __raw_readl/writel wrappers.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 15a3f27b5747..3fe16867b5a8 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -220,7 +220,7 @@ int __init musb_platform_init(struct musb *musb)
 
 	musb_platform_resume(musb);
 
-	l = omap_readl(OTG_SYSCONFIG);
+	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
 	l &= ~NOSTDBY;		/* remove possible nostdby */
 	l |= SMARTSTDBY;	/* enable smart standby */
@@ -233,17 +233,19 @@ int __init musb_platform_init(struct musb *musb)
 	 */
 	if (!cpu_is_omap3430())
 		l |= AUTOIDLE;		/* enable auto idle */
-	omap_writel(l, OTG_SYSCONFIG);
+	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 
-	l = omap_readl(OTG_INTERFSEL);
+	l = musb_readl(musb->mregs, OTG_INTERFSEL);
 	l |= ULPI_12PIN;
-	omap_writel(l, OTG_INTERFSEL);
+	musb_writel(musb->mregs, OTG_INTERFSEL, l);
 
 	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
 			"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\n",
-			omap_readl(OTG_REVISION), omap_readl(OTG_SYSCONFIG),
-			omap_readl(OTG_SYSSTATUS), omap_readl(OTG_INTERFSEL),
-			omap_readl(OTG_SIMENABLE));
+			musb_readl(musb->mregs, OTG_REVISION),
+			musb_readl(musb->mregs, OTG_SYSCONFIG),
+			musb_readl(musb->mregs, OTG_SYSSTATUS),
+			musb_readl(musb->mregs, OTG_INTERFSEL),
+			musb_readl(musb->mregs, OTG_SIMENABLE));
 
 	omap_vbus_power(musb, musb->board_mode == MUSB_HOST, 1);
 
@@ -256,18 +258,18 @@ int __init musb_platform_init(struct musb *musb)
 }
 
 #ifdef CONFIG_PM
-void musb_platform_save_context(struct musb_context_registers
-		*musb_context)
+void musb_platform_save_context(struct musb *musb,
+		struct musb_context_registers *musb_context)
 {
-	musb_context->otg_sysconfig = omap_readl(OTG_SYSCONFIG);
-	musb_context->otg_forcestandby = omap_readl(OTG_FORCESTDBY);
+	musb_context->otg_sysconfig = musb_readl(musb->mregs, OTG_SYSCONFIG);
+	musb_context->otg_forcestandby = musb_readl(musb->mregs, OTG_FORCESTDBY);
 }
 
-void musb_platform_restore_context(struct musb_context_registers
-		*musb_context)
+void musb_platform_restore_context(struct musb *musb,
+		struct musb_context_registers *musb_context)
 {
-	omap_writel(musb_context->otg_sysconfig, OTG_SYSCONFIG);
-	omap_writel(musb_context->otg_forcestandby, OTG_FORCESTDBY);
+	musb_writel(musb->mregs, OTG_SYSCONFIG, musb_context->otg_sysconfig);
+	musb_writel(musb->mregs, OTG_FORCESTDBY, musb_context->otg_forcestandby);
 }
 #endif
 
@@ -279,13 +281,13 @@ int musb_platform_suspend(struct musb *musb)
 		return 0;
 
 	/* in any role */
-	l = omap_readl(OTG_FORCESTDBY);
+	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
 	l |= ENABLEFORCE;	/* enable MSTANDBY */
-	omap_writel(l, OTG_FORCESTDBY);
+	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 
-	l = omap_readl(OTG_SYSCONFIG);
+	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l |= ENABLEWAKEUP;	/* enable wakeup */
-	omap_writel(l, OTG_SYSCONFIG);
+	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 
 	otg_set_suspend(musb->xceiv, 1);
 
@@ -311,13 +313,13 @@ static int musb_platform_resume(struct musb *musb)
 	else
 		clk_enable(musb->clock);
 
-	l = omap_readl(OTG_SYSCONFIG);
+	l = musb_readl(musb->mregs, OTG_SYSCONFIG);
 	l &= ~ENABLEWAKEUP;	/* disable wakeup */
-	omap_writel(l, OTG_SYSCONFIG);
+	musb_writel(musb->mregs, OTG_SYSCONFIG, l);
 
-	l = omap_readl(OTG_FORCESTDBY);
+	l = musb_readl(musb->mregs, OTG_FORCESTDBY);
 	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
-	omap_writel(l, OTG_FORCESTDBY);
+	musb_writel(musb->mregs, OTG_FORCESTDBY, l);
 
 	return 0;
 }

commit 4f712e010b2da1cc01c178922f2eb5aaeae461b6
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Thu Jan 21 15:33:52 2010 +0200

    usb: musb: Add context save and restore support
    
    Adding support for MUSB register save and restore during system
    suspend and resume.
    
    Changes:
            - Added musb_save/restore_context() functions
            - Added platform specific musb_platform_save/restore_context()
              to handle platform specific jobs.
            - Maintaining BlackFin compatibility by adding read/write
              functions for registers which are not available in BlackFin
    
    Tested system suspend and resume on OMAP3EVM board.
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 83beeac5e7bf..15a3f27b5747 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -255,6 +255,22 @@ int __init musb_platform_init(struct musb *musb)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+void musb_platform_save_context(struct musb_context_registers
+		*musb_context)
+{
+	musb_context->otg_sysconfig = omap_readl(OTG_SYSCONFIG);
+	musb_context->otg_forcestandby = omap_readl(OTG_FORCESTDBY);
+}
+
+void musb_platform_restore_context(struct musb_context_registers
+		*musb_context)
+{
+	omap_writel(musb_context->otg_sysconfig, OTG_SYSCONFIG);
+	omap_writel(musb_context->otg_forcestandby, OTG_FORCESTDBY);
+}
+#endif
+
 int musb_platform_suspend(struct musb *musb)
 {
 	u32 l;

commit ff85494b3f06a596a3f3b2f71841de0154799918
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Fri Dec 4 15:47:45 2009 +0200

    USB: musb: omap2430: fix sparse warning
    
    Fix the following sparse warning:
    
    drivers/usb/musb/omap2430.c:314:16: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 6761d2088db8..83beeac5e7bf 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -315,7 +315,7 @@ int musb_platform_exit(struct musb *musb)
 	musb_platform_suspend(musb);
 
 	clk_put(musb->clock);
-	musb->clock = 0;
+	musb->clock = NULL;
 
 	return 0;
 }

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 34875201ee04..6761d2088db8 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -35,7 +35,7 @@
 
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
-#include <mach/mux.h>
+#include <plat/mux.h>
 
 #include "musb_core.h"
 #include "omap2430.h"

commit 9a4b5e36ce58febdd2039dd4d129ee7edf4f5536
Author: Niilo Minkkinen <ext-niilo.1.minkkinen@nokia.com>
Date:   Mon May 18 17:54:16 2009 +0300

    usb: musb: disable OTG AUTOIDLE only with omap3430
    
    Omap3 MUSB AUTOIDLE functionality configured through OTG_SYSCONFIG
    register prevents the device from going into retention.
    This is a workaround (by Richard Woodruff/TI), as his comment :
    > A new MUSB bug which is a match to data below was identified very
    > recently (on hardware and in simulation).
    > This bug is in 3430 and not 3630.
    > As a priority test (and as new default) you should have engineers
    > disable autoidle for MUSB block.
    > This is the workaround which will show up in next errata.
    
    Signed-off-by: Niilo Minkkinen <ext-niilo.1.minkkinen@nokia.com>
    Signed-off-by: Richard Woodruff <r-woodruff2@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 48930f25c450..34875201ee04 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -227,7 +227,12 @@ int __init musb_platform_init(struct musb *musb)
 	l &= ~AUTOIDLE;		/* disable auto idle */
 	l &= ~NOIDLE;		/* remove possible noidle */
 	l |= SMARTIDLE;		/* enable smart idle */
-	l |= AUTOIDLE;		/* enable auto idle */
+	/*
+	 * MUSB AUTOIDLE don't work in 3430.
+	 * Workaround by Richard Woodruff/TI
+	 */
+	if (!cpu_is_omap3430())
+		l |= AUTOIDLE;		/* enable auto idle */
 	omap_writel(l, OTG_SYSCONFIG);
 
 	l = omap_readl(OTG_INTERFSEL);

commit f7f9d63eac12b345d6243d1d608b7944a05be921
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Mar 31 12:32:12 2009 -0700

    musb: otg timer cleanup
    
    Minor cleanup of OTG timer handling:
        * unify decls for OTG time constants, in the core header
        * set up and use that timer in a more normal way
        * move to the driver struct, so it's usable outside core
    
    And tighten use and setup of T(a_wait_bcon) so that if it's used,
    it's always valid.  (If that timer expires, the A-device will
    stop powering VBUS.  For non-OTG systems, that will be a surprise.)
    No behavioral changes, other than more consistency when applying
    that core HNP timeout.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index a2f443859358..48930f25c450 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -44,7 +44,6 @@
 #define	get_cpu_rev()	2
 #endif
 
-#define MUSB_TIMEOUT_A_WAIT_BCON	1100
 
 static struct timer_list musb_idle_timer;
 
@@ -245,7 +244,6 @@ int __init musb_platform_init(struct musb *musb)
 
 	if (is_host_enabled(musb))
 		musb->board_set_vbus = omap_set_vbus;
-	musb->a_wait_bcon = MUSB_TIMEOUT_A_WAIT_BCON;
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 

commit 84e250ffa76dddc1bad84e04248a27f442c25986
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Mar 31 12:30:04 2009 -0700

    musb: proper hookup to transceiver drivers
    
    Let the otg_transceiver in MUSB be managed by an external driver;
    don't assume it's integrated.  OMAP3 chips need it to be external,
    and there may be ways to interact with the transceiver which add
    functionality to the system.
    
    Platform init code is responsible for setting up the transeciver,
    probably using the NOP transceiver for integrated transceivers.
    External ones will use whatever the board init code provided,
    such as twl4030 or something more hands-off.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 60924ce08493..a2f443859358 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -61,17 +61,17 @@ static void musb_do_idle(unsigned long _musb)
 
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
-	switch (musb->xceiv.state) {
+	switch (musb->xceiv->state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv.state = OTG_STATE_B_IDLE;
+			musb->xceiv->state = OTG_STATE_B_IDLE;
 			MUSB_DEV_MODE(musb);
 		} else {
-			musb->xceiv.state = OTG_STATE_A_IDLE;
+			musb->xceiv->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
 		}
 		break;
@@ -89,7 +89,7 @@ static void musb_do_idle(unsigned long _musb)
 			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
 			usb_hcd_poll_rh_status(musb_to_hcd(musb));
 			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv.state = OTG_STATE_A_HOST;
+			musb->xceiv->state = OTG_STATE_A_HOST;
 		}
 		break;
 #endif
@@ -97,9 +97,9 @@ static void musb_do_idle(unsigned long _musb)
 	case OTG_STATE_A_HOST:
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl &  MUSB_DEVCTL_BDEVICE)
-			musb->xceiv.state = OTG_STATE_B_IDLE;
+			musb->xceiv->state = OTG_STATE_B_IDLE;
 		else
-			musb->xceiv.state = OTG_STATE_A_WAIT_BCON;
+			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
 #endif
 	default:
 		break;
@@ -118,7 +118,7 @@ void musb_platform_try_idle(struct musb *musb, unsigned long timeout)
 
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || ((musb->a_wait_bcon == 0)
-			&& (musb->xceiv.state == OTG_STATE_A_WAIT_BCON))) {
+			&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {
 		DBG(4, "%s active, deleting timer\n", otg_state_string(musb));
 		del_timer(&musb_idle_timer);
 		last_timer = jiffies;
@@ -163,8 +163,8 @@ static void omap_set_vbus(struct musb *musb, int is_on)
 
 	if (is_on) {
 		musb->is_active = 1;
-		musb->xceiv.default_a = 1;
-		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
+		musb->xceiv->default_a = 1;
+		musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
 		devctl |= MUSB_DEVCTL_SESSION;
 
 		MUSB_HST_MODE(musb);
@@ -175,8 +175,8 @@ static void omap_set_vbus(struct musb *musb, int is_on)
 		 * jumping right to B_IDLE...
 		 */
 
-		musb->xceiv.default_a = 0;
-		musb->xceiv.state = OTG_STATE_B_IDLE;
+		musb->xceiv->default_a = 0;
+		musb->xceiv->state = OTG_STATE_B_IDLE;
 		devctl &= ~MUSB_DEVCTL_SESSION;
 
 		MUSB_DEV_MODE(musb);
@@ -188,10 +188,6 @@ static void omap_set_vbus(struct musb *musb, int is_on)
 		otg_state_string(musb),
 		musb_readb(musb->mregs, MUSB_DEVCTL));
 }
-static int omap_set_power(struct otg_transceiver *x, unsigned mA)
-{
-	return 0;
-}
 
 static int musb_platform_resume(struct musb *musb);
 
@@ -202,24 +198,6 @@ int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 	devctl |= MUSB_DEVCTL_SESSION;
 	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
-	switch (musb_mode) {
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	case MUSB_HOST:
-		otg_set_host(&musb->xceiv, musb->xceiv.host);
-		break;
-#endif
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	case MUSB_PERIPHERAL:
-		otg_set_peripheral(&musb->xceiv, musb->xceiv.gadget);
-		break;
-#endif
-#ifdef CONFIG_USB_MUSB_OTG
-	case MUSB_OTG:
-		break;
-#endif
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
 
@@ -231,6 +209,16 @@ int __init musb_platform_init(struct musb *musb)
 	omap_cfg_reg(AE5_2430_USB0HS_STP);
 #endif
 
+	/* We require some kind of external transceiver, hooked
+	 * up through ULPI.  TWL4030-family PMICs include one,
+	 * which needs a driver, drivers aren't always needed.
+	 */
+	musb->xceiv = otg_get_transceiver();
+	if (!musb->xceiv) {
+		pr_err("HS USB OTG: no transceiver configured\n");
+		return -ENODEV;
+	}
+
 	musb_platform_resume(musb);
 
 	l = omap_readl(OTG_SYSCONFIG);
@@ -257,8 +245,6 @@ int __init musb_platform_init(struct musb *musb)
 
 	if (is_host_enabled(musb))
 		musb->board_set_vbus = omap_set_vbus;
-	if (is_peripheral_enabled(musb))
-		musb->xceiv.set_power = omap_set_power;
 	musb->a_wait_bcon = MUSB_TIMEOUT_A_WAIT_BCON;
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
@@ -282,8 +268,7 @@ int musb_platform_suspend(struct musb *musb)
 	l |= ENABLEWAKEUP;	/* enable wakeup */
 	omap_writel(l, OTG_SYSCONFIG);
 
-	if (musb->xceiv.set_suspend)
-		musb->xceiv.set_suspend(&musb->xceiv, 1);
+	otg_set_suspend(musb->xceiv, 1);
 
 	if (musb->set_clock)
 		musb->set_clock(musb->clock, 0);
@@ -300,8 +285,7 @@ static int musb_platform_resume(struct musb *musb)
 	if (!musb->clock)
 		return 0;
 
-	if (musb->xceiv.set_suspend)
-		musb->xceiv.set_suspend(&musb->xceiv, 0);
+	otg_set_suspend(musb->xceiv, 0);
 
 	if (musb->set_clock)
 		musb->set_clock(musb->clock, 1);

commit 9cceedb8a87f31e341c1bf1bc6c28a13f9632aff
Author: Jarkko Nikula <jarkko.nikula@nokia.com>
Date:   Fri Apr 17 13:52:00 2009 +0300

    USB: musb: Remove my email address from few musb related drivers
    
    This email address is going to expire soon and my contribution to musb
    is next to zero so remove it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@nokia.com>
    Cc: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 901dffdf23b1..60924ce08493 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -3,7 +3,6 @@
  * Some code has been taken from tusb6010.c
  * Copyrights for that are attributable to:
  * Copyright (C) 2006 Nokia Corporation
- * Jarkko Nikula <jarkko.nikula@nokia.com>
  * Tony Lindgren <tony@atomide.com>
  *
  * This file is part of the Inventra Controller Driver for Linux.

commit 71783e0defa16ca5abca7750df98ff8e7767bd2e
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Nov 24 13:06:49 2008 +0200

    USB: musb: minor locking fix
    
    Minor locking fix for musb_hdrc on OMAP3 and OMAP2430:
    don't read DEVCTL without holding the spinlock, since
    an IRQ could come in and corrupt things.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 52988a403b5c..901dffdf23b1 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -58,10 +58,10 @@ static void musb_do_idle(unsigned long _musb)
 #endif
 	u8	devctl;
 
-	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-
 	spin_lock_irqsave(&musb->lock, flags);
 
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
 	switch (musb->xceiv.state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;

commit 96a274d1da950a96cb31ac1bed044e049d770980
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Nov 24 13:06:47 2008 +0200

    USB: musb: sysfs mode updates
    
    Fix three omissions in the "mode" sysfs attribute support:
      (a) inability to report errors;
      (b) no DaVinci support ... just report an error;
      (c) for omap2430, accepting unsupportable values
    
    The 2430 stuff is still odd....
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index ce6c162920f7..52988a403b5c 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -196,7 +196,7 @@ static int omap_set_power(struct otg_transceiver *x, unsigned mA)
 
 static int musb_platform_resume(struct musb *musb);
 
-void musb_platform_set_mode(struct musb *musb, u8 musb_mode)
+int musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 {
 	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
@@ -204,15 +204,24 @@ void musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 	switch (musb_mode) {
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case MUSB_HOST:
 		otg_set_host(&musb->xceiv, musb->xceiv.host);
 		break;
+#endif
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	case MUSB_PERIPHERAL:
 		otg_set_peripheral(&musb->xceiv, musb->xceiv.gadget);
 		break;
+#endif
+#ifdef CONFIG_USB_MUSB_OTG
 	case MUSB_OTG:
 		break;
+#endif
+	default:
+		return -EINVAL;
 	}
+	return 0;
 }
 
 int __init musb_platform_init(struct musb *musb)

commit eef767b761bdd08200fbbfc910ab815d03787326
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Wed Oct 29 15:10:38 2008 +0200

    usb: musb: Removes compilation warning in gadget mode
    
    Fixes compilation warning when musb is configured in gadget mode.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 9d2dcb121c5e..ce6c162920f7 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -53,7 +53,9 @@ static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
 	unsigned long	flags;
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	u8	power;
+#endif
 	u8	devctl;
 
 	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);

commit 0590d5875e3a5dc6586fb16354037f115628896d
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Sat Aug 30 19:42:02 2008 +0300

    usb: musb: fix include path
    
    headers were moved, fixing.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 298b22e6ad0d..9d2dcb121c5e 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -35,8 +35,8 @@
 #include <linux/io.h>
 
 #include <asm/mach-types.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/mux.h>
+#include <mach/hardware.h>
+#include <mach/mux.h>
 
 #include "musb_core.h"
 #include "omap2430.h"

commit 550a7375fe720924241f0eb76e4a5c1a3eb8c32f
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Jul 24 12:27:36 2008 +0300

    USB: Add MUSB and TUSB support
    
    This patch adds support for MUSB and TUSB controllers
    integrated into omap2430 and davinci. It also adds support
    for external tusb6010 controller.
    
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
new file mode 100644
index 000000000000..298b22e6ad0d
--- /dev/null
+++ b/drivers/usb/musb/omap2430.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2005-2007 by Texas Instruments
+ * Some code has been taken from tusb6010.c
+ * Copyrights for that are attributable to:
+ * Copyright (C) 2006 Nokia Corporation
+ * Jarkko Nikula <jarkko.nikula@nokia.com>
+ * Tony Lindgren <tony@atomide.com>
+ *
+ * This file is part of the Inventra Controller Driver for Linux.
+ *
+ * The Inventra Controller Driver for Linux is free software; you
+ * can redistribute it and/or modify it under the terms of the GNU
+ * General Public License version 2 as published by the Free Software
+ * Foundation.
+ *
+ * The Inventra Controller Driver for Linux is distributed in
+ * the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with The Inventra Controller Driver for Linux ; if not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place,
+ * Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/mach-types.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+
+#include "musb_core.h"
+#include "omap2430.h"
+
+#ifdef CONFIG_ARCH_OMAP3430
+#define	get_cpu_rev()	2
+#endif
+
+#define MUSB_TIMEOUT_A_WAIT_BCON	1100
+
+static struct timer_list musb_idle_timer;
+
+static void musb_do_idle(unsigned long _musb)
+{
+	struct musb	*musb = (void *)_musb;
+	unsigned long	flags;
+	u8	power;
+	u8	devctl;
+
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	switch (musb->xceiv.state) {
+	case OTG_STATE_A_WAIT_BCON:
+		devctl &= ~MUSB_DEVCTL_SESSION;
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if (devctl & MUSB_DEVCTL_BDEVICE) {
+			musb->xceiv.state = OTG_STATE_B_IDLE;
+			MUSB_DEV_MODE(musb);
+		} else {
+			musb->xceiv.state = OTG_STATE_A_IDLE;
+			MUSB_HST_MODE(musb);
+		}
+		break;
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	case OTG_STATE_A_SUSPEND:
+		/* finish RESUME signaling? */
+		if (musb->port1_status & MUSB_PORT_STAT_RESUME) {
+			power = musb_readb(musb->mregs, MUSB_POWER);
+			power &= ~MUSB_POWER_RESUME;
+			DBG(1, "root port resume stopped, power %02x\n", power);
+			musb_writeb(musb->mregs, MUSB_POWER, power);
+			musb->is_active = 1;
+			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
+						| MUSB_PORT_STAT_RESUME);
+			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
+			usb_hcd_poll_rh_status(musb_to_hcd(musb));
+			/* NOTE: it might really be A_WAIT_BCON ... */
+			musb->xceiv.state = OTG_STATE_A_HOST;
+		}
+		break;
+#endif
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	case OTG_STATE_A_HOST:
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if (devctl &  MUSB_DEVCTL_BDEVICE)
+			musb->xceiv.state = OTG_STATE_B_IDLE;
+		else
+			musb->xceiv.state = OTG_STATE_A_WAIT_BCON;
+#endif
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&musb->lock, flags);
+}
+
+
+void musb_platform_try_idle(struct musb *musb, unsigned long timeout)
+{
+	unsigned long		default_timeout = jiffies + msecs_to_jiffies(3);
+	static unsigned long	last_timer;
+
+	if (timeout == 0)
+		timeout = default_timeout;
+
+	/* Never idle if active, or when VBUS timeout is not set as host */
+	if (musb->is_active || ((musb->a_wait_bcon == 0)
+			&& (musb->xceiv.state == OTG_STATE_A_WAIT_BCON))) {
+		DBG(4, "%s active, deleting timer\n", otg_state_string(musb));
+		del_timer(&musb_idle_timer);
+		last_timer = jiffies;
+		return;
+	}
+
+	if (time_after(last_timer, timeout)) {
+		if (!timer_pending(&musb_idle_timer))
+			last_timer = timeout;
+		else {
+			DBG(4, "Longer idle timer already pending, ignoring\n");
+			return;
+		}
+	}
+	last_timer = timeout;
+
+	DBG(4, "%s inactive, for idle timer for %lu ms\n",
+		otg_state_string(musb),
+		(unsigned long)jiffies_to_msecs(timeout - jiffies));
+	mod_timer(&musb_idle_timer, timeout);
+}
+
+void musb_platform_enable(struct musb *musb)
+{
+}
+void musb_platform_disable(struct musb *musb)
+{
+}
+static void omap_vbus_power(struct musb *musb, int is_on, int sleeping)
+{
+}
+
+static void omap_set_vbus(struct musb *musb, int is_on)
+{
+	u8		devctl;
+	/* HDRC controls CPEN, but beware current surges during device
+	 * connect.  They can trigger transient overcurrent conditions
+	 * that must be ignored.
+	 */
+
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	if (is_on) {
+		musb->is_active = 1;
+		musb->xceiv.default_a = 1;
+		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
+		devctl |= MUSB_DEVCTL_SESSION;
+
+		MUSB_HST_MODE(musb);
+	} else {
+		musb->is_active = 0;
+
+		/* NOTE:  we're skipping A_WAIT_VFALL -> A_IDLE and
+		 * jumping right to B_IDLE...
+		 */
+
+		musb->xceiv.default_a = 0;
+		musb->xceiv.state = OTG_STATE_B_IDLE;
+		devctl &= ~MUSB_DEVCTL_SESSION;
+
+		MUSB_DEV_MODE(musb);
+	}
+	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+
+	DBG(1, "VBUS %s, devctl %02x "
+		/* otg %3x conf %08x prcm %08x */ "\n",
+		otg_state_string(musb),
+		musb_readb(musb->mregs, MUSB_DEVCTL));
+}
+static int omap_set_power(struct otg_transceiver *x, unsigned mA)
+{
+	return 0;
+}
+
+static int musb_platform_resume(struct musb *musb);
+
+void musb_platform_set_mode(struct musb *musb, u8 musb_mode)
+{
+	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	devctl |= MUSB_DEVCTL_SESSION;
+	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+
+	switch (musb_mode) {
+	case MUSB_HOST:
+		otg_set_host(&musb->xceiv, musb->xceiv.host);
+		break;
+	case MUSB_PERIPHERAL:
+		otg_set_peripheral(&musb->xceiv, musb->xceiv.gadget);
+		break;
+	case MUSB_OTG:
+		break;
+	}
+}
+
+int __init musb_platform_init(struct musb *musb)
+{
+	u32 l;
+
+#if defined(CONFIG_ARCH_OMAP2430)
+	omap_cfg_reg(AE5_2430_USB0HS_STP);
+#endif
+
+	musb_platform_resume(musb);
+
+	l = omap_readl(OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP;	/* disable wakeup */
+	l &= ~NOSTDBY;		/* remove possible nostdby */
+	l |= SMARTSTDBY;	/* enable smart standby */
+	l &= ~AUTOIDLE;		/* disable auto idle */
+	l &= ~NOIDLE;		/* remove possible noidle */
+	l |= SMARTIDLE;		/* enable smart idle */
+	l |= AUTOIDLE;		/* enable auto idle */
+	omap_writel(l, OTG_SYSCONFIG);
+
+	l = omap_readl(OTG_INTERFSEL);
+	l |= ULPI_12PIN;
+	omap_writel(l, OTG_INTERFSEL);
+
+	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
+			"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\n",
+			omap_readl(OTG_REVISION), omap_readl(OTG_SYSCONFIG),
+			omap_readl(OTG_SYSSTATUS), omap_readl(OTG_INTERFSEL),
+			omap_readl(OTG_SIMENABLE));
+
+	omap_vbus_power(musb, musb->board_mode == MUSB_HOST, 1);
+
+	if (is_host_enabled(musb))
+		musb->board_set_vbus = omap_set_vbus;
+	if (is_peripheral_enabled(musb))
+		musb->xceiv.set_power = omap_set_power;
+	musb->a_wait_bcon = MUSB_TIMEOUT_A_WAIT_BCON;
+
+	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
+
+	return 0;
+}
+
+int musb_platform_suspend(struct musb *musb)
+{
+	u32 l;
+
+	if (!musb->clock)
+		return 0;
+
+	/* in any role */
+	l = omap_readl(OTG_FORCESTDBY);
+	l |= ENABLEFORCE;	/* enable MSTANDBY */
+	omap_writel(l, OTG_FORCESTDBY);
+
+	l = omap_readl(OTG_SYSCONFIG);
+	l |= ENABLEWAKEUP;	/* enable wakeup */
+	omap_writel(l, OTG_SYSCONFIG);
+
+	if (musb->xceiv.set_suspend)
+		musb->xceiv.set_suspend(&musb->xceiv, 1);
+
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 0);
+	else
+		clk_disable(musb->clock);
+
+	return 0;
+}
+
+static int musb_platform_resume(struct musb *musb)
+{
+	u32 l;
+
+	if (!musb->clock)
+		return 0;
+
+	if (musb->xceiv.set_suspend)
+		musb->xceiv.set_suspend(&musb->xceiv, 0);
+
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
+	l = omap_readl(OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP;	/* disable wakeup */
+	omap_writel(l, OTG_SYSCONFIG);
+
+	l = omap_readl(OTG_FORCESTDBY);
+	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
+	omap_writel(l, OTG_FORCESTDBY);
+
+	return 0;
+}
+
+
+int musb_platform_exit(struct musb *musb)
+{
+
+	omap_vbus_power(musb, 0 /*off*/, 1);
+
+	musb_platform_suspend(musb);
+
+	clk_put(musb->clock);
+	musb->clock = 0;
+
+	return 0;
+}
