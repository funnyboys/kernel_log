commit 6814c73fdc46cc5d0ece070af507cb95666b3f6a
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Apr 4 16:19:55 2020 +0530

    USB: musb: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to USB Dual Role (OTG-ready) Controller Drivers.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Link: https://lore.kernel.org/r/20200404104952.GA6575@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 290a2bc46606..dbe5623db1e0 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * MUSB OTG driver defines
  *

commit 9c93d7fd464e7aad59c2afc261f80e6e0fbe2ca9
Author: Min Guo <min.guo@mediatek.com>
Date:   Wed Jan 15 07:25:44 2020 -0600

    usb: musb: Add musb_clearb/w() interface
    
    Delete the const attribute of addr parameter in readb/w/l hooks, these
    changes are for implementing clearing W1C registers.
    Replace musb_readb/w with musb_clearb/w to clear the interrupt status.
    
    While at here, change some unsigned type to u32 to fix checkpatch.pl
    warnings.
    
    Signed-off-by: Min Guo <min.guo@mediatek.com>
    [b-liu@ti.com: fix checkpatch.pl warnings.]
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-23-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2e4fcf1a1a5c..290a2bc46606 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -120,8 +120,10 @@ struct musb_io;
  * @fifo_offset: returns the fifo offset
  * @readb:	read 8 bits
  * @writeb:	write 8 bits
+ * @clearb:	could be clear-on-readb or W1C
  * @readw:	read 16 bits
  * @writew:	write 16 bits
+ * @clearw:	could be clear-on-readw or W1C
  * @read_fifo:	reads the fifo
  * @write_fifo:	writes to fifo
  * @get_toggle:	platform specific get toggle function
@@ -164,10 +166,12 @@ struct musb_platform_ops {
 	u16	fifo_mode;
 	u32	(*fifo_offset)(u8 epnum);
 	u32	(*busctl_offset)(u8 epnum, u16 offset);
-	u8	(*readb)(const void __iomem *addr, unsigned offset);
-	void	(*writeb)(void __iomem *addr, unsigned offset, u8 data);
-	u16	(*readw)(const void __iomem *addr, unsigned offset);
-	void	(*writew)(void __iomem *addr, unsigned offset, u16 data);
+	u8	(*readb)(void __iomem *addr, u32 offset);
+	void	(*writeb)(void __iomem *addr, u32 offset, u8 data);
+	u8	(*clearb)(void __iomem *addr, u32 offset);
+	u16	(*readw)(void __iomem *addr, u32 offset);
+	void	(*writew)(void __iomem *addr, u32 offset, u16 data);
+	u16	(*clearw)(void __iomem *addr, u32 offset);
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	u16	(*get_toggle)(struct musb_qh *qh, int is_out);

commit fe3bbd6b383fbc62128fd1fe850105080cb4c9da
Author: Min Guo <min.guo@mediatek.com>
Date:   Wed Jan 15 07:25:42 2020 -0600

    usb: musb: Add get/set toggle hooks
    
    Add get/set toggle hooks in struct musb_io and struct musb_platform_ops
    for special platform; remove function musb_save_toggle, use the set/get
    callback to handle toggle.
    
    Signed-off-by: Min Guo <min.guo@mediatek.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-21-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8a13a46cd891..2e4fcf1a1a5c 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -27,6 +27,7 @@
 struct musb;
 struct musb_hw_ep;
 struct musb_ep;
+struct musb_qh;
 
 /* Helper defines for struct musb->hwvers */
 #define MUSB_HWVERS_MAJOR(x)	((x >> 10) & 0x1f)
@@ -123,6 +124,8 @@ struct musb_io;
  * @writew:	write 16 bits
  * @read_fifo:	reads the fifo
  * @write_fifo:	writes to fifo
+ * @get_toggle:	platform specific get toggle function
+ * @set_toggle:	platform specific set toggle function
  * @dma_init:	platform specific dma init function
  * @dma_exit:	platform specific dma exit function
  * @init:	turns on clocks, sets up platform-specific registers, etc
@@ -167,6 +170,8 @@ struct musb_platform_ops {
 	void	(*writew)(void __iomem *addr, unsigned offset, u16 data);
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
+	u16	(*get_toggle)(struct musb_qh *qh, int is_out);
+	u16	(*set_toggle)(struct musb_qh *qh, int is_out, struct urb *urb);
 	struct dma_controller *
 		(*dma_init) (struct musb *musb, void __iomem *base);
 	void	(*dma_exit)(struct dma_controller *c);

commit 93dc256871297071a24f7f9ce0abfddfff15094d
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 15 07:25:29 2020 -0600

    usb: musb: Add musb_set_host and peripheral and use them for omap2430
    
    At least some revisions of musb core need to set devctl session bit
    in peripheral mode to force musb to host mode. And we have places
    clearing the devctl session bit.
    
    Let's add a generic function to do this, and use it for omap2430.
    This should get us a bit closer to completely removing devctl register
    tinkering in the SoC glue code.
    
    Before making use of this code for the other glue layers, things need
    to be tested carefully as there may be a approximately a 200 ms delay
    needed between powering up musb and calling musb_set_host() to avoid.
    Otherwise the system hangs at least with omap2430 glue layer.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [b-liu@ti.com: fixed "line over 80 characters" warning]
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Link: https://lore.kernel.org/r/20200115132547.364-8-b-liu@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 04203b7126d5..8a13a46cd891 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -487,6 +487,9 @@ extern void musb_start(struct musb *musb);
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
 extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);
 
+extern int musb_set_host(struct musb *musb);
+extern int musb_set_peripheral(struct musb *musb);
+
 extern void musb_load_testpacket(struct musb *);
 
 extern irqreturn_t musb_interrupt(struct musb *);

commit 7ad76955c67b705550a7ba7f632b838486753d65
Author: Bin Liu <b-liu@ti.com>
Date:   Mon May 21 08:42:15 2018 -0500

    usb: musb: remove duplicated port mode enum
    
    include/linux/usb/musb.h already defines enum for musb port mode, so
    remove the duplicate in musb_core.h and use the definition in musb.h.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f57323e50e44..04203b7126d5 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -53,12 +53,6 @@ struct musb_ep;
 #define is_peripheral_active(m)		(!(m)->is_host)
 #define is_host_active(m)		((m)->is_host)
 
-enum {
-	MUSB_PORT_MODE_HOST	= 1,
-	MUSB_PORT_MODE_GADGET,
-	MUSB_PORT_MODE_DUAL_ROLE,
-};
-
 /****************************** CONSTANTS ********************************/
 
 #ifndef MUSB_C_NUM_EPS
@@ -351,7 +345,7 @@ struct musb {
 
 	u8			min_power;	/* vbus for periph, in mA/2 */
 
-	int			port_mode;	/* MUSB_PORT_MODE_* */
+	enum musb_mode		port_mode;
 	bool			session;
 	unsigned long		quirk_retries;
 	bool			is_host;

commit 53e1657a1c94b96a63b8d443c3aeec0c650621e3
Author: Bin Liu <b-liu@ti.com>
Date:   Mon May 21 08:42:11 2018 -0500

    usb: musb: remove adjust_channel_params() callback from musb_platform_ops
    
    Now Blackfin support is removed, nobody uses adjust_channel_params() any
    more, so remove it from struct musb_platform_ops.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index a4bf1e9e2d2c..f57323e50e44 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -138,7 +138,6 @@ struct musb_io;
  * @recover:	platform-specific babble recovery
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
- * @adjust_channel_params: pre check for standard dma channel_program func
  * @pre_root_reset_end: called before the root usb port reset flag gets cleared
  * @post_root_reset_end: called after the root usb port reset flag gets cleared
  * @phy_callback: optional callback function for the phy to call
@@ -184,9 +183,6 @@ struct musb_platform_ops {
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
 
-	int	(*adjust_channel_params)(struct dma_channel *channel,
-				u16 packet_sz, u8 *mode,
-				dma_addr_t *dma_addr, u32 *len);
 	void	(*pre_root_reset_end)(struct musb *musb);
 	void	(*post_root_reset_end)(struct musb *musb);
 	int	(*phy_callback)(enum musb_vbus_id_status status);

commit 42e990ea80f23c58404f24c009da3ae3867a1fec
Author: Bin Liu <b-liu@ti.com>
Date:   Mon May 21 08:42:10 2018 -0500

    usb: musb: remove readl/writel from struct musb_platform_ops
    
    Now Blackfin support is removed, we no longer need function pointers for
    musb_readl() and musb_writel().
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8a74cb2907f8..a4bf1e9e2d2c 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -127,8 +127,6 @@ struct musb_io;
  * @writeb:	write 8 bits
  * @readw:	read 16 bits
  * @writew:	write 16 bits
- * @readl:	read 32 bits
- * @writel:	write 32 bits
  * @read_fifo:	reads the fifo
  * @write_fifo:	writes to fifo
  * @dma_init:	platform specific dma init function
@@ -174,8 +172,6 @@ struct musb_platform_ops {
 	void	(*writeb)(void __iomem *addr, unsigned offset, u8 data);
 	u16	(*readw)(const void __iomem *addr, unsigned offset);
 	void	(*writew)(void __iomem *addr, unsigned offset, u16 data);
-	u32	(*readl)(const void __iomem *addr, unsigned offset);
-	void	(*writel)(void __iomem *addr, unsigned offset, u32 data);
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	struct dma_controller *

commit a9762b704f5d5e167bbc261573621782b90efbc4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 9 17:37:54 2018 +0100

    usb: musb: remove blackfin port
    
    The blackfin architecture is getting removed, so we can clean up
    all the special cases in the musb driver.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Aaron Wu <aaron.wu@analog.com>
    Acked-by: Bin Liu <b-liu@ti.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    [arnd: adding in fixups from Aaron and Stephen]
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 385841ee6f46..8a74cb2907f8 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -414,19 +414,6 @@ struct musb {
 	struct usb_gadget_driver *gadget_driver;	/* its driver */
 	struct usb_hcd		*hcd;			/* the usb hcd */
 
-	/*
-	 * FIXME: Remove this flag.
-	 *
-	 * This is only added to allow Blackfin to work
-	 * with current driver. For some unknown reason
-	 * Blackfin doesn't work with double buffering
-	 * and that's enabled by default.
-	 *
-	 * We added this flag to forcefully disable double
-	 * buffering until we get it working.
-	 */
-	unsigned                double_buffer_not_ok:1;
-
 	const struct musb_hdrc_config *config;
 
 	int			xceiv_old_state;
@@ -467,34 +454,6 @@ static inline char *musb_ep_xfertype_string(u8 type)
 	return s;
 }
 
-#ifdef CONFIG_BLACKFIN
-static inline int musb_read_fifosize(struct musb *musb,
-		struct musb_hw_ep *hw_ep, u8 epnum)
-{
-	musb->nr_endpoints++;
-	musb->epmask |= (1 << epnum);
-
-	if (epnum < 5) {
-		hw_ep->max_packet_sz_tx = 128;
-		hw_ep->max_packet_sz_rx = 128;
-	} else {
-		hw_ep->max_packet_sz_tx = 1024;
-		hw_ep->max_packet_sz_rx = 1024;
-	}
-	hw_ep->is_shared_fifo = false;
-
-	return 0;
-}
-
-static inline void musb_configure_ep0(struct musb *musb)
-{
-	musb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;
-	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
-	musb->endpoints[0].is_shared_fifo = true;
-}
-
-#else
-
 static inline int musb_read_fifosize(struct musb *musb,
 		struct musb_hw_ep *hw_ep, u8 epnum)
 {
@@ -531,8 +490,6 @@ static inline void musb_configure_ep0(struct musb *musb)
 	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
 	musb->endpoints[0].is_shared_fifo = true;
 }
-#endif /* CONFIG_BLACKFIN */
-
 
 /***************************** Glue it together *****************************/
 

commit 21b650c23611998ab3a69a401115740b32594d2e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:15 2017 +0100

    USB: musb: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index ca823231bbb3..385841ee6f46 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -5,32 +5,6 @@
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
  * Copyright (C) 2006-2007 Nokia Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
  */
 
 #ifndef __MUSB_CORE_H__

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index e8573975743d..ca823231bbb3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * MUSB OTG driver defines
  *

commit 05678497276e1ff9394f7f815d80b1f2d47e92f4
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 03:08:35 2017 -0700

    usb: musb: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Instead of a per-device static timer variable, a spare timer "dev_timer"
    is added to the musb structure for devices to use for their per-device
    timer.
    
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 20f4614178d9..e8573975743d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -345,6 +345,7 @@ struct musb {
 	struct list_head	pending_list;	/* pending work list */
 
 	struct timer_list	otg_timer;
+	struct timer_list	dev_timer;
 	struct notifier_block	nb;
 
 	struct dma_controller	*dma_controller;

commit 0c3aae9bd59978fb8c3557d7883380bef0f2cfa1
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Oct 9 22:46:08 2017 -0500

    USB: musb: fix late external abort on suspend
    
    The musb delayed irq work was never flushed on suspend, something which
    since 4.9 can lead to an external abort if the work is scheduled after
    the grandparent's clock has been disabled:
    
    PM: Suspending system (mem)
    PM: suspend of devices complete after 125.224 msecs
    PM: suspend devices took 0.132 seconds
    PM: late suspend of devices complete after 7.423 msecs
    PM: noirq suspend of devices complete after 7.083 msecs
    suspend debug: Waiting for 5 second(s).
    Unhandled fault: external abort on non-linefetch (0x1008) at 0xd0262c60
    ...
    [<c054880c>] (musb_default_readb) from [<c0547b5c>] (musb_irq_work+0x48/0x220)
    [<c0547b5c>] (musb_irq_work) from [<c014f8a4>] (process_one_work+0x1f4/0x758)
    [<c014f8a4>] (process_one_work) from [<c014fe5c>] (worker_thread+0x54/0x514)
    [<c014fe5c>] (worker_thread) from [<c015704c>] (kthread+0x128/0x158)
    [<c015704c>] (kthread) from [<c0109330>] (ret_from_fork+0x14/0x24)
    
    Commit 2bff3916fda9 ("usb: musb: Fix PM for hub disconnect") started
    scheduling musb_irq_work with a delay of up to a second and with
    retries thereby making this easy to trigger, for example, by suspending
    shortly after a disconnect.
    
    Note that we set a flag to prevent the irq work from rescheduling itself
    during suspend and instead process a disconnect immediately. This takes
    care of the case where we are disconnected shortly before suspending.
    
    However, when in host mode, a disconnect while suspended will still
    go unnoticed and thus prevent the controller from runtime suspending
    upon resume as the session bit is always set. This will need to be
    addressed separately.
    
    Fixes: 550a7375fe72 ("USB: Add MUSB and TUSB support")
    Fixes: 467d5c980709 ("usb: musb: Implement session bit based runtime PM for musb-core")
    Fixes: 2bff3916fda9 ("usb: musb: Fix PM for hub disconnect")
    Cc: stable <stable@vger.kernel.org>     # 4.9
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index c748f4ac1154..20f4614178d9 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -428,6 +428,8 @@ struct musb {
 	unsigned		test_mode:1;
 	unsigned		softconnect:1;
 
+	unsigned		flush_irq_work:1;
+
 	u8			address;
 	u8			test_mode_nr;
 	u16			ackpend;		/* ep0 */

commit 0ccbadafb4130407dc594395577e9e40f5b03ad6
Author: Bin Liu <b-liu@ti.com>
Date:   Thu Aug 24 11:38:32 2017 -0500

    usb: musb: add helper function musb_ep_xfertype_string
    
    Add helper function musb_ep_xfertype_string() to return the ep transfer
    type string.
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9f22c5b8ce37..c748f4ac1154 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -465,6 +465,30 @@ static inline struct musb *gadget_to_musb(struct usb_gadget *g)
 	return container_of(g, struct musb, g);
 }
 
+static inline char *musb_ep_xfertype_string(u8 type)
+{
+	char *s;
+
+	switch (type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		s = "ctrl";
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		s = "iso";
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		s = "bulk";
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		s = "int";
+		break;
+	default:
+		s = "";
+		break;
+	}
+	return s;
+}
+
 #ifdef CONFIG_BLACKFIN
 static inline int musb_read_fifosize(struct musb *musb,
 		struct musb_hw_ep *hw_ep, u8 epnum)

commit 1fa07c370bba23aa596ca143b90b64cd35918ec2
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Jun 16 10:40:56 2017 -0500

    usb: musb: Add quirk to avoid skb reserve in gadget mode
    
    For tusb6010 the DMA functionality only possible if the buffer is 32bit
    aligned (SYNC access to FIFO) since with ASYNC access the TX/RX offset
    registers will corrupt eventually.
    The MUSB_G_NO_SKB_RESERVE will set the quirk_avoids_skb_reserve flag in
    usb_gadget struct to provide correctly aligned buffer.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3e98d4268a64..9f22c5b8ce37 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -172,6 +172,7 @@ struct musb_io;
  */
 struct musb_platform_ops {
 
+#define MUSB_G_NO_SKB_RESERVE	BIT(9)
 #define MUSB_DA8XX		BIT(8)
 #define MUSB_PRESERVE_SESSION	BIT(7)
 #define MUSB_DMA_UX500		BIT(6)

commit 593bc4622a98c172dbb939103aef917d1800a663
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Sun Apr 16 23:21:18 2017 -0500

    usb: musb: musb_cppi41: Workaround DMA stall issue during teardown
    
    The DMA may hang up if a teardown is initiated while an endpoint is still
    active (Advisory 2.3.27 of DA8xx errata).
    To workaround this issue, add a delay before to initiate the teardown.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 5b708be6d1d1..3e98d4268a64 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -172,6 +172,7 @@ struct musb_io;
  */
 struct musb_platform_ops {
 
+#define MUSB_DA8XX		BIT(8)
 #define MUSB_PRESERVE_SESSION	BIT(7)
 #define MUSB_DMA_UX500		BIT(6)
 #define MUSB_DMA_CPPI41		BIT(5)

commit 7bddba775026d51dede9d726bd8158574c0ec5a6
Merge: 530b7a3e216e d5adbfcd5f7b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 6 09:32:06 2017 +0100

    Merge 4.10-rc7 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a926ed11e7b4325f0ece739d7188e8bdbb99fb44
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Wed Feb 1 21:30:19 2017 -0600

    usb: musb: Add a quirk to preserve the session during suspend
    
    On da8xx, VBUS is not maintained during suspend when musb is in host mode.
    On resume, all the connected devices will be disconnected and then will
    be enumerated again.
    This happens because MUSB_DEVCTL is cleared during suspend.
    Add a quirk to not clear MUSB_DEVCTL and then preserve the  session during
    a suspend.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index ade902ea1221..ab0c858af9d3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -172,6 +172,7 @@ struct musb_io;
  */
 struct musb_platform_ops {
 
+#define MUSB_PRESERVE_SESSION	BIT(7)
 #define MUSB_DMA_UX500		BIT(6)
 #define MUSB_DMA_CPPI41		BIT(5)
 #define MUSB_DMA_CPPI		BIT(4)

commit 407788b51db6f6aab499d02420082f436abf3238
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 24 09:18:57 2017 -0600

    usb: musb: Fix host mode error -71 regression
    
    Commit 467d5c980709 ("usb: musb: Implement session bit based runtime PM for
    musb-core") started implementing musb generic runtime PM support by
    introducing devctl register session bit based state control.
    
    This caused a regression where if a USB mass storage device is connected
    to a USB hub, we can get:
    
    usb 1-1: reset high-speed USB device number 2 using musb-hdrc
    usb 1-1: device descriptor read/64, error -71
    usb 1-1.1: new high-speed USB device number 4 using musb-hdrc
    
    This is because before the USB storage device is connected, musb is
    in OTG_STATE_A_SUSPEND. And we currently only set need_finish_resume
    in musb_stage0_irq() and the related code calling finish_resume_work
    in musb_resume() and musb_runtime_resume() never gets called.
    
    To fix the issue, we can call schedule_delayed_work() directly in
    musb_stage0_irq() to have finish_resume_work run.
    
    And we should no longer never get interrupts when when suspended.
    We have changed musb to no longer need pm_runtime_irqsafe().
    The need_finish_resume flag was added in commit 9298b4aad37e ("usb:
    musb: fix device hotplug behind hub") and no longer applies as far
    as I can tell. So let's just remove the earlier code that no longer
    is needed.
    
    Fixes: 467d5c980709 ("usb: musb: Implement session bit based runtime PM for musb-core")
    Reported-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index ade902ea1221..ce5a18c98c6d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -410,7 +410,6 @@ struct musb {
 
 	/* is_suspended means USB B_PERIPHERAL suspend */
 	unsigned		is_suspended:1;
-	unsigned		need_finish_resume :1;
 
 	/* may_wakeup means remote wakeup is enabled */
 	unsigned		may_wakeup:1;

commit 6def85a396ce7796bd9f4561c6ae8138833f7a52
Author: Bin Liu <b-liu@ti.com>
Date:   Tue Jan 3 18:13:46 2017 -0600

    usb: musb: core: add clear_ep_rxintr() to musb_platform_ops
    
    During dma teardown for dequque urb, if musb load is high, musb might
    generate bogus rx ep interrupt even when the rx fifo is flushed. In such
    case any of the follow log messages could happen.
    
            musb_host_rx 1853: BOGUS RX2 ready, csr 0000, count 0
    
            musb_host_rx 1936: RX3 dma busy, csr 2020
    
    As mentioned in the current inline comment, clearing ep interrupt in the
    teardown path avoids the bogus interrupt.
    
    Clearing ep interrupt is platform dependent, so this patch adds a
    platform callback to allow glue driver to clear the ep interrupt.
    
    This bug seems to be existing since the initial driver for musb support,
    but I only validated the fix back to v4.1, so only cc stable for v4.1+.
    
    cc: stable@vger.kernel.org # 4.1+
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index a611e2f67bdc..ade902ea1221 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -216,6 +216,7 @@ struct musb_platform_ops {
 	void	(*pre_root_reset_end)(struct musb *musb);
 	void	(*post_root_reset_end)(struct musb *musb);
 	int	(*phy_callback)(enum musb_vbus_id_status status);
+	void	(*clear_ep_rxintr)(struct musb *musb, int epnum);
 };
 
 /*
@@ -626,6 +627,12 @@ static inline void musb_platform_post_root_reset_end(struct musb *musb)
 		musb->ops->post_root_reset_end(musb);
 }
 
+static inline void musb_platform_clear_ep_rxintr(struct musb *musb, int epnum)
+{
+	if (musb->ops->clear_ep_rxintr)
+		musb->ops->clear_ep_rxintr(musb, epnum);
+}
+
 /*
  * gets the "dr_mode" property from DT and converts it into musb_mode
  * if the property is not found or not recognized returns MUSB_OTG

commit 0edbf9e55295585bbe9df61b646ca5bf80a8e1eb
Merge: eacae5d2b940 e5517c2a5a49
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 28 08:34:10 2016 +0100

    Merge 4.9-rc7 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 830fc64ca721101d5f360c1b7d09b8037b2b5b0b
Author: Petr Kulhavy <petr@barix.com>
Date:   Mon Nov 21 08:59:28 2016 -0600

    usb: musb: core: added helper function for parsing DT
    
    This adds the function musb_get_mode() to get the DT property "dr_mode"
    
    Signed-off-by: Petr Kulhavy <petr@barix.com>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Tested-by: David Lechner <david@lechnology.com>
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2cb88a498f8a..76f00f61b874 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -617,4 +617,10 @@ static inline void musb_platform_post_root_reset_end(struct musb *musb)
 		musb->ops->post_root_reset_end(musb);
 }
 
+/*
+ * gets the "dr_mode" property from DT and converts it into musb_mode
+ * if the property is not found or not recognized returns MUSB_OTG
+ */
+extern enum musb_mode musb_get_mode(struct device *dev);
+
 #endif	/* __MUSB_CORE_H__ */

commit 2bff3916fda9145587c0312b6f5c43d82504980c
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 16 13:21:24 2016 -0600

    usb: musb: Fix PM for hub disconnect
    
    With a USB hub disconnected, devctl can be 0x19 for about a second
    on am335x and will stay forever on at least omap3. And we get no
    further interrupts when devctl session bit clears. This keeps
    PM runtime active.
    
    Let's fix the issue by polling devctl until the session bit clears
    or times out. We can do this by making musb->irq_work into
    delayed_work.
    
    And with the polling implemented, we can now also have the quirk
    for invalid VBUS it to avoid disconnecting too early while VBUS
    is ramping up.
    
    Fixes: 467d5c980709 ("usb: musb: Implement session bit based runtime
    PM for musb-core")
    Fixes: 65b3f50ed6fa ("usb: musb: Add PM runtime support for MUSB DSPS
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 15b1f93c7037..91817d77d59c 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -310,7 +310,7 @@ struct musb {
 	struct musb_context_registers context;
 
 	irqreturn_t		(*isr)(int, void *);
-	struct work_struct	irq_work;
+	struct delayed_work	irq_work;
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
 	struct delayed_work	gadget_work;
@@ -381,7 +381,7 @@ struct musb {
 
 	int			port_mode;	/* MUSB_PORT_MODE_* */
 	bool			session;
-	bool			quirk_invalid_vbus;
+	unsigned long		quirk_retries;
 	bool			is_host;
 
 	int			a_wait_bcon;	/* VBUS timeout in msecs */

commit ea2f35c01d5ea72b43b9b4fb4c5b9417a9eb2fb8
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 16 13:21:23 2016 -0600

    usb: musb: Fix sleeping function called from invalid context for hdrc glue
    
    Commit 65b3f50ed6fa ("usb: musb: Add PM runtime support for MUSB DSPS
    glue layer") wrongly added a call for pm_runtime_get_sync to otg_timer
    that runs in softirq context. That causes a "BUG: sleeping function called
    from invalid context" every time when polling the cable status:
    
    [<c015ebb4>] (__might_sleep) from [<c0413d60>] (__pm_runtime_resume+0x9c/0xa0)
    [<c0413d60>] (__pm_runtime_resume) from [<c04d0bc4>] (otg_timer+0x3c/0x254)
    [<c04d0bc4>] (otg_timer) from [<c0191180>] (call_timer_fn+0xfc/0x41c)
    [<c0191180>] (call_timer_fn) from [<c01915c0>] (expire_timers+0x120/0x210)
    [<c01915c0>] (expire_timers) from [<c0191acc>] (run_timer_softirq+0xa4/0xdc)
    [<c0191acc>] (run_timer_softirq) from [<c010168c>] (__do_softirq+0x12c/0x594)
    
    I did not notice that as I did not have CONFIG_DEBUG_ATOMIC_SLEEP enabled.
    And looks like also musb_gadget_queue() suffers from the same problem.
    
    Let's fix the issue by using a list of delayed work then call it on
    resume. Note that we want to do this only when musb core and it's
    parent devices are awake, and we need to make sure the DSPS glue
    timer is stopped as noted by Johan Hovold <johan@kernel.org>.
    Note that we already are re-enabling the timer with mod_timer() in
    dsps_musb_enable().
    
    Later on we may be able to remove other delayed work in the musb driver
    and just do it from pending_resume_work. But this should be done only
    for delayed work that does not have other timing requirements beyond
    just being run on resume.
    
    Fixes: 65b3f50ed6fa ("usb: musb: Add PM runtime support for MUSB DSPS
    glue layer")
    Reported-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index c04abf424c5c..15b1f93c7037 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -303,6 +303,7 @@ struct musb_context_registers {
 struct musb {
 	/* device lock */
 	spinlock_t		lock;
+	spinlock_t		list_lock;	/* resume work list lock */
 
 	struct musb_io		io;
 	const struct musb_platform_ops *ops;
@@ -337,6 +338,7 @@ struct musb {
 	struct list_head	control;	/* of musb_qh */
 	struct list_head	in_bulk;	/* of musb_qh */
 	struct list_head	out_bulk;	/* of musb_qh */
+	struct list_head	pending_list;	/* pending work list */
 
 	struct timer_list	otg_timer;
 	struct notifier_block	nb;
@@ -386,6 +388,7 @@ struct musb {
 	unsigned long		idle_timeout;	/* Next timeout in jiffies */
 
 	unsigned		is_initialized:1;
+	unsigned		is_runtime_suspended:1;
 
 	/* active means connected and not suspended */
 	unsigned		is_active:1;
@@ -542,6 +545,10 @@ extern irqreturn_t musb_interrupt(struct musb *);
 
 extern void musb_hnp_stop(struct musb *musb);
 
+int musb_queue_resume_work(struct musb *musb,
+			   int (*callback)(struct musb *musb, void *data),
+			   void *data);
+
 static inline void musb_platform_set_vbus(struct musb *musb, int is_on)
 {
 	if (musb->ops->set_vbus)

commit c723bd6ec2b50e7c8b3424d9cb8febd8ffa3da1f
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 16 13:21:22 2016 -0600

    usb: musb: Fix broken use of static variable for multiple instances
    
    We can't use static variable first for checking when musb is
    initialized when we have multiple musb instances like on am335x.
    
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2cb88a498f8a..c04abf424c5c 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -385,6 +385,8 @@ struct musb {
 	int			a_wait_bcon;	/* VBUS timeout in msecs */
 	unsigned long		idle_timeout;	/* Next timeout in jiffies */
 
+	unsigned		is_initialized:1;
+
 	/* active means connected and not suspended */
 	unsigned		is_active:1;
 

commit 2b9a8c40836930a45f42f06f98731eb9614ba86b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 22 15:58:30 2016 -0500

    usb: musb: Fix session based PM for first invalid VBUS
    
    With the session bit based PM runtime working on musb, we've
    implemented few quirks to attempt to detect the current state of
    the hardware. One of the quirks is for invalid VBUS as peripheral,
    but it is not working in all cases.
    
    If we start musb on dm3730 as a peripheral with no cable connected,
    we will get the devctl 91 state once and will never idle as there
    are not further interrupts from musb. So we need to ignore the first
    devctl 91 state as there will be more interrupts if we're connected.
    
    The invalid VBUS state also can happen always when connected to
    certain USB hubs. Looks like musb on dm3730 can claim invalid VBUS
    with some hubs while 3717-evm and BeagleBone don't. This causes
    session as peripheral to fail for dm3730 with some hubs.
    
    This too is fixed by ignoring only the first invalid VBUS. When
    connected, we can just look at the session bit as that will clear
    automatically when the session ends.
    
    Fixes: 467d5c980709 ("usb: musb: Implement session bit based runtime PM for musb-core")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 65288a53c19b..2cb88a498f8a 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -379,6 +379,7 @@ struct musb {
 
 	int			port_mode;	/* MUSB_PORT_MODE_* */
 	bool			session;
+	bool			quirk_invalid_vbus;
 	bool			is_host;
 
 	int			a_wait_bcon;	/* VBUS timeout in msecs */

commit 467d5c980709b262df288a0d0e7780f295c56882
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 12 21:48:28 2016 -0500

    usb: musb: Implement session bit based runtime PM for musb-core
    
    We want to keep musb enabled always when the session bit is
    set. This simplifies the PM runtime and allows making it more
    generic across the various glue layers.
    
    So far the only exception to just following the session bit is
    host mode disconnect where the session bit stays set.
    
    In that case, just allow PM and let the PM runtime autoidle
    timeout deal with it.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [b-liu@ti.com: changed using dev_dbg() to musb_dbg()]
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b55a776b03eb..65288a53c19b 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -378,6 +378,7 @@ struct musb {
 	u8			min_power;	/* vbus for periph, in mA/2 */
 
 	int			port_mode;	/* MUSB_PORT_MODE_* */
+	bool			session;
 	bool			is_host;
 
 	int			a_wait_bcon;	/* VBUS timeout in msecs */

commit 12b7db2bf8b88938798c60416172b53225207b1f
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:19 2016 -0500

    usb: musb: Return error value from musb_mailbox
    
    At least on n900 we have phy-twl4030-usb only generating cable
    interrupts, and then have a separate USB PHY.
    
    In order for musb to know the real cable status, we need to
    clear any cached state until musb is ready. Otherwise the cable
    status interrupts will get just ignored if the status does
    not change from the initial state.
    
    To do this, let's add a return value to musb_mailbox(), and
    reset cached linkstat to MUSB_UNKNOWN on error. Sorry to cause
    a bit of churn here, I should have added that already last time
    patching musb_mailbox().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 29473846b098..b55a776b03eb 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -215,7 +215,7 @@ struct musb_platform_ops {
 				dma_addr_t *dma_addr, u32 *len);
 	void	(*pre_root_reset_end)(struct musb *musb);
 	void	(*post_root_reset_end)(struct musb *musb);
-	void	(*phy_callback)(enum musb_vbus_id_status status);
+	int	(*phy_callback)(enum musb_vbus_id_status status);
 };
 
 /*

commit 517bafffcaf8f882299a74e310082e7b6b2288ad
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 31 10:05:14 2016 -0500

    usb: musb: Use delayed for musb_gadget_pullup
    
    We have MUSB setting pm_runtime_irq_safe with the following
    commits:
    
    30a70b026b4c ("usb: musb: fix obex in g_nokia.ko causing kernel panic")
    3e43a0725637 ("usb: musb: core: add pm_runtime_irq_safe()")
    
    Let's fix things to use delayed work so we can remove the
    pm_runtime_irq_safe.
    
    Note that we may want to set this up in a generic way in the
    gadget framework eventually.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b6afe9e43305..29473846b098 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -312,6 +312,7 @@ struct musb {
 	struct work_struct	irq_work;
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
+	struct delayed_work	gadget_work;
 	u16			hwvers;
 
 	u16			intrrxe;

commit ead22caf8507c0533aab6b89e26776414b477b6f
Author: Petr Kulhavy <petr@barix.com>
Date:   Wed Feb 24 16:27:16 2016 +0100

    usb: musb: core: added missing const qualifier to musb_hdrc_platform_data::config
    
    The musb_hdrc_platform_data::config was defined as a non-const pointer.
    However some drivers (e.g. the ux500) set up this pointer to point to a
    static structure, which is potentially dangerous. Since the musb core
    uses the pointer in a read-only manner the const qualifier was added to
    protect the content of the config.
    
    Signed-off-by: Petr Kulhavy <petr@barix.com>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index fd215fb45fd4..b6afe9e43305 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -438,7 +438,7 @@ struct musb {
 	 */
 	unsigned                double_buffer_not_ok:1;
 
-	struct musb_hdrc_config	*config;
+	const struct musb_hdrc_config *config;
 
 	int			xceiv_old_state;
 #ifdef CONFIG_DEBUG_FS

commit 8055555fc4590fbda32d4bbf7888bdb2cd4b2b74
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 30 21:37:12 2015 -0800

    usb: musb: core: Fix handling of the phy notifications
    
    We currently can't unload omap2430 MUSB platform glue driver module and
    this cause issues for fixing the MUSB code further. The reason we can't
    remove omap2430 is because it uses the PHY functions and also exports the
    omap_musb_mailbox function that some PHY drivers are using.
    
    Let's fix the issue by exporting a more generic musb_mailbox function
    from the MUSB core and allow platform glue layers to register phy_callback
    function as needed.
    
    And now we can now also get rid of the include/linux/musb-omap.h.
    
    Cc: Bin Liu <b-liu@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: NeilBrown <neil@brown.name>
    Reviewed-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2337d7a7d62d..fd215fb45fd4 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -168,6 +168,7 @@ struct musb_io;
  * @adjust_channel_params: pre check for standard dma channel_program func
  * @pre_root_reset_end: called before the root usb port reset flag gets cleared
  * @post_root_reset_end: called after the root usb port reset flag gets cleared
+ * @phy_callback: optional callback function for the phy to call
  */
 struct musb_platform_ops {
 
@@ -214,6 +215,7 @@ struct musb_platform_ops {
 				dma_addr_t *dma_addr, u32 *len);
 	void	(*pre_root_reset_end)(struct musb *musb);
 	void	(*post_root_reset_end)(struct musb *musb);
+	void	(*phy_callback)(enum musb_vbus_id_status status);
 };
 
 /*

commit 3bbafac83775425d0abb68cf9837ee3ca36adb42
Author: Roman Alyautdin <ralyautdin@dev.rtsoft.ru>
Date:   Mon Oct 12 17:14:32 2015 +0300

    usb: musb: core: add common method of getting vbus status
    
    Fix musb_platform_get_vbus_status return value in case of platform
    implementation is not defined, bringing expected behaviour of
    musb_platform_get wrapper. Add musb_vbus_show default method to determine
    VBUS status in case platform method is not defined.
    
    Signed-off-by: Roman Alyautdin <ralyautdin@dev.rtsoft.ru>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 4b886d0f6bdf..2337d7a7d62d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -579,7 +579,7 @@ static inline int  musb_platform_recover(struct musb *musb)
 static inline int musb_platform_get_vbus_status(struct musb *musb)
 {
 	if (!musb->ops->vbus_status)
-		return 0;
+		return -EINVAL;
 
 	return musb->ops->vbus_status(musb);
 }

commit 6cc2af6d50204e8a1034ecd162378ceea22b09e8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 20 20:11:12 2015 +0100

    usb: musb: Make busctl_offset an io-op rather then a define
    
    The Allwinner (sunxi) implementation of the musb has its busctl registers
    indexed by the MUSB_INDEX register rather then in a flat address space.
    
    This commit turns MUSB_BUSCTL_OFFSET from a macro into an io-op which can
    be overridden from the platform ops.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b8372f6006e3..4b886d0f6bdf 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -67,7 +67,6 @@ struct musb_ep;
 #include "musb_dma.h"
 
 #include "musb_io.h"
-#include "musb_regs.h"
 
 #include "musb_gadget.h"
 #include <linux/usb/hcd.h>
@@ -191,6 +190,7 @@ struct musb_platform_ops {
 	void	(*ep_select)(void __iomem *mbase, u8 epnum);
 	u16	fifo_mode;
 	u32	(*fifo_offset)(u8 epnum);
+	u32	(*busctl_offset)(u8 epnum, u16 offset);
 	u8	(*readb)(const void __iomem *addr, unsigned offset);
 	void	(*writeb)(void __iomem *addr, unsigned offset, u8 data);
 	u16	(*readw)(const void __iomem *addr, unsigned offset);
@@ -444,6 +444,9 @@ struct musb {
 #endif
 };
 
+/* This must be included after struct musb is defined */
+#include "musb_regs.h"
+
 static inline struct musb *gadget_to_musb(struct usb_gadget *g)
 {
 	return container_of(g, struct musb, g);

commit 0cb74b3dc45a5448161eb481d4709cdda2a889fd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 20 20:11:11 2015 +0100

    usb: musb: Make musb_write_rxfun* and musb_write_rxhub* work like their tx versions
    
    For some reason the musb_write_rxfun* and musb_write_rxhub* functions had
    a different function prototype and some extra magic needed on the caller side
    compared to their tx counterparts, this commit makes them work the same as
    their tx counterparts.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 71172266c65e..b8372f6006e3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -250,8 +250,6 @@ struct musb_hw_ep {
 	void __iomem		*fifo_sync_va;
 #endif
 
-	void __iomem		*target_regs;
-
 	/* currently scheduled peripheral endpoint */
 	struct musb_qh		*in_qh;
 	struct musb_qh		*out_qh;

commit 591fa9dd3fee3de8c729febca395beb75c8ee819
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Mar 29 12:50:47 2015 +0200

    usb: musb: Add pre and post root port reset end callbacks
    
    The sunxi otg phy has a bug where it wrongly detects a high speed squelch
    when reset on the root port gets de-asserted with a lo-speed device.
    
    The workaround for this is to disable squelch detect before de-asserting
    reset, and re-enabling it after the reset de-assert is done.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index c7a0d933eff9..71172266c65e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -167,6 +167,8 @@ struct musb_io;
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
  * @adjust_channel_params: pre check for standard dma channel_program func
+ * @pre_root_reset_end: called before the root usb port reset flag gets cleared
+ * @post_root_reset_end: called after the root usb port reset flag gets cleared
  */
 struct musb_platform_ops {
 
@@ -210,6 +212,8 @@ struct musb_platform_ops {
 	int	(*adjust_channel_params)(struct dma_channel *channel,
 				u16 packet_sz, u8 *mode,
 				dma_addr_t *dma_addr, u32 *len);
+	void	(*pre_root_reset_end)(struct musb *musb);
+	void	(*post_root_reset_end)(struct musb *musb);
 };
 
 /*
@@ -595,4 +599,16 @@ static inline int musb_platform_exit(struct musb *musb)
 	return musb->ops->exit(musb);
 }
 
+static inline void musb_platform_pre_root_reset_end(struct musb *musb)
+{
+	if (musb->ops->pre_root_reset_end)
+		musb->ops->pre_root_reset_end(musb);
+}
+
+static inline void musb_platform_post_root_reset_end(struct musb *musb)
+{
+	if (musb->ops->post_root_reset_end)
+		musb->ops->post_root_reset_end(musb);
+}
+
 #endif	/* __MUSB_CORE_H__ */

commit 7f6283ed6fe867ce168ee3eea2ced4f6cdeeb37a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 1 12:29:28 2015 -0700

    usb: musb: Set up function pointers for DMA
    
    Set up function pointers for DMA so get closer to
    being able to build in all the DMA engines.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3877249a8b2d..c7a0d933eff9 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -157,6 +157,8 @@ struct musb_io;
  * @writel:	write 32 bits
  * @read_fifo:	reads the fifo
  * @write_fifo:	writes to fifo
+ * @dma_init:	platform specific dma init function
+ * @dma_exit:	platform specific dma exit function
  * @init:	turns on clocks, sets up platform-specific registers, etc
  * @exit:	undoes @init
  * @set_mode:	forcefully changes operating mode
@@ -195,6 +197,9 @@ struct musb_platform_ops {
 	void	(*writel)(void __iomem *addr, unsigned offset, u32 data);
 	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
+	struct dma_controller *
+		(*dma_init) (struct musb *musb, void __iomem *base);
+	void	(*dma_exit)(struct dma_controller *c);
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
 	int	(*recover)(struct musb *musb);

commit 83b8f5b8c07c8cbad8c14c7b8767e7219a6c1813
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Feb 26 14:27:12 2015 -0600

    usb: musb: core: drop recover_work
    
    that's not needed anymore. Everything that we
    call is irq-safe, so we might as well not
    have a delayed work for babble recovery.
    
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 1e03c7ec82e4..3877249a8b2d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -301,7 +301,6 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
-	struct delayed_work	recover_work;
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
 	u16			hwvers;

commit b28a6432405ca95b3da25630d79d2463c754a79c
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Feb 26 14:20:58 2015 -0600

    usb: musb: rename ->reset() to ->recover()
    
    recover is a much better name than reset, considering
    we don't really reset the IP, just run platform-specific
    babble recovery algorithm.
    
    while at that, also fix a typo in comment and add kdoc
    for recover memeber of platform_ops.
    
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 5e65958f7915..1e03c7ec82e4 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -160,7 +160,8 @@ struct musb_io;
  * @init:	turns on clocks, sets up platform-specific registers, etc
  * @exit:	undoes @init
  * @set_mode:	forcefully changes operating mode
- * @try_ilde:	tries to idle the IP
+ * @try_idle:	tries to idle the IP
+ * @recover:	platform-specific babble recovery
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
  * @adjust_channel_params: pre check for standard dma channel_program func
@@ -196,7 +197,7 @@ struct musb_platform_ops {
 	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
-	int	(*reset)(struct musb *musb);
+	int	(*recover)(struct musb *musb);
 
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
@@ -558,12 +559,12 @@ static inline void musb_platform_try_idle(struct musb *musb,
 		musb->ops->try_idle(musb, timeout);
 }
 
-static inline int  musb_platform_reset(struct musb *musb)
+static inline int  musb_platform_recover(struct musb *musb)
 {
-	if (!musb->ops->reset)
-		return -EINVAL;
+	if (!musb->ops->recover)
+		return 0;
 
-	return musb->ops->reset(musb);
+	return musb->ops->recover(musb);
 }
 
 static inline int musb_platform_get_vbus_status(struct musb *musb)

commit ebf3992061db1f7b3aa093f37fb308acc74fbc82
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 24 11:05:06 2014 -0800

    usb: musb: Use IS_ENABLED for tusb6010
    
    This removes the ifdef clutter a bit and saves few lines.
    
    It also makes it easier to detect the remaining places
    where we have conditional building of code done based
    on if defined for things like DMA.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d9248fdd9158..5e65958f7915 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -216,8 +216,7 @@ struct musb_hw_ep {
 	void __iomem		*fifo;
 	void __iomem		*regs;
 
-#if defined(CONFIG_USB_MUSB_TUSB6010) || \
-	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
+#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)
 	void __iomem		*conf;
 #endif
 
@@ -234,8 +233,7 @@ struct musb_hw_ep {
 	struct dma_channel	*tx_channel;
 	struct dma_channel	*rx_channel;
 
-#if defined(CONFIG_USB_MUSB_TUSB6010) || \
-	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
+#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)
 	/* TUSB has "asynchronous" and "synchronous" dma modes */
 	dma_addr_t		fifo_async;
 	dma_addr_t		fifo_sync;
@@ -339,8 +337,7 @@ struct musb {
 	void __iomem		*ctrl_base;
 	void __iomem		*mregs;
 
-#if defined(CONFIG_USB_MUSB_TUSB6010) || \
-	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
+#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)
 	dma_addr_t		async;
 	dma_addr_t		sync;
 	void __iomem		*sync_va;

commit d026e9c76aac3632af174cf02d5c94defa5e6026
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 24 11:05:03 2014 -0800

    usb: musb: Change end point selection to use new IO access
    
    This allows the endpoints to work when multiple MUSB glue
    layers are built in.
    
    Cc: Fabio Baltieri <fabio.baltieri@linaro.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Apelete Seketeli <apelete@seketeli.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index e5410bc67df6..d9248fdd9158 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -124,41 +124,6 @@ enum musb_g_ep0_state {
 #define OTG_TIME_A_AIDL_BDIS	200		/* min 200 msec */
 #define OTG_TIME_B_ASE0_BRST	100		/* min 3.125 ms */
 
-
-/*************************** REGISTER ACCESS ********************************/
-
-/* Endpoint registers (other than dynfifo setup) can be accessed either
- * directly with the "flat" model, or after setting up an index register.
- */
-
-#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_SOC_OMAP2430) \
-		|| defined(CONFIG_SOC_OMAP3430) || defined(CONFIG_BLACKFIN) \
-		|| defined(CONFIG_ARCH_OMAP4)
-/* REVISIT indexed access seemed to
- * misbehave (on DaVinci) for at least peripheral IN ...
- */
-#define	MUSB_FLAT_REG
-#endif
-
-/* TUSB mapping: "flat" plus ep0 special cases */
-#if defined(CONFIG_USB_MUSB_TUSB6010) || \
-	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
-#define musb_ep_select(_mbase, _epnum) \
-	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
-#define	MUSB_EP_OFFSET			MUSB_TUSB_OFFSET
-
-/* "flat" mapping: each endpoint has its own i/o address */
-#elif	defined(MUSB_FLAT_REG)
-#define musb_ep_select(_mbase, _epnum)	(((void)(_mbase)), ((void)(_epnum)))
-#define	MUSB_EP_OFFSET			MUSB_FLAT_OFFSET
-
-/* "indexed" mapping: INDEX register controls register bank select */
-#else
-#define musb_ep_select(_mbase, _epnum) \
-	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
-#define	MUSB_EP_OFFSET			MUSB_INDEXED_OFFSET
-#endif
-
 /****************************** FUNCTIONS ********************************/
 
 #define MUSB_HST_MODE(_musb)\
@@ -515,7 +480,7 @@ static inline int musb_read_fifosize(struct musb *musb,
 	u8 reg = 0;
 
 	/* read from core using indexed model */
-	reg = musb_readb(mbase, MUSB_EP_OFFSET(epnum, MUSB_FIFOSIZE));
+	reg = musb_readb(mbase, musb->io.ep_offset(epnum, MUSB_FIFOSIZE));
 	/* 0's returned when no more endpoints */
 	if (!reg)
 		return -ENODEV;

commit 5450ac88dcf09b258d0404b45316583806799ef4
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 24 11:04:59 2014 -0800

    usb: musb: Add function pointers for IO access functions
    
    MUSB currently breaks badly if we try to build in support
    for multiple platforms. This also happens if done as loadable
    modules, which is not nice for distros.
    
    Let's fix the issue by adding new struct musb_io for the IO
    access functions that the platform code can populate. Note
    that we don't want to use the current ops as that's really
    platform_data and and set as a const.
    
    This should allow eventually adding function pointers also
    for the DMA code to struct musb_io, but that's a whole
    different set of patches. For now, let's just fix the PIO
    access.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 803a997e56d2..e5410bc67df6 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -173,8 +173,25 @@ enum musb_g_ep0_state {
 
 /******************************** TYPES *************************************/
 
+struct musb_io;
+
 /**
  * struct musb_platform_ops - Operations passed to musb_core by HW glue layer
+ * @quirks:	flags for platform specific quirks
+ * @enable:	enable device
+ * @disable:	disable device
+ * @ep_offset:	returns the end point offset
+ * @ep_select:	selects the specified end point
+ * @fifo_mode:	sets the fifo mode
+ * @fifo_offset: returns the fifo offset
+ * @readb:	read 8 bits
+ * @writeb:	write 8 bits
+ * @readw:	read 16 bits
+ * @writew:	write 16 bits
+ * @readl:	read 32 bits
+ * @writel:	write 32 bits
+ * @read_fifo:	reads the fifo
+ * @write_fifo:	writes to fifo
  * @init:	turns on clocks, sets up platform-specific registers, etc
  * @exit:	undoes @init
  * @set_mode:	forcefully changes operating mode
@@ -184,12 +201,34 @@ enum musb_g_ep0_state {
  * @adjust_channel_params: pre check for standard dma channel_program func
  */
 struct musb_platform_ops {
+
+#define MUSB_DMA_UX500		BIT(6)
+#define MUSB_DMA_CPPI41		BIT(5)
+#define MUSB_DMA_CPPI		BIT(4)
+#define MUSB_DMA_TUSB_OMAP	BIT(3)
+#define MUSB_DMA_INVENTRA	BIT(2)
+#define MUSB_IN_TUSB		BIT(1)
+#define MUSB_INDEXED_EP		BIT(0)
+	u32	quirks;
+
 	int	(*init)(struct musb *musb);
 	int	(*exit)(struct musb *musb);
 
 	void	(*enable)(struct musb *musb);
 	void	(*disable)(struct musb *musb);
 
+	u32	(*ep_offset)(u8 epnum, u16 offset);
+	void	(*ep_select)(void __iomem *mbase, u8 epnum);
+	u16	fifo_mode;
+	u32	(*fifo_offset)(u8 epnum);
+	u8	(*readb)(const void __iomem *addr, unsigned offset);
+	void	(*writeb)(void __iomem *addr, unsigned offset, u8 data);
+	u16	(*readw)(const void __iomem *addr, unsigned offset);
+	void	(*writew)(void __iomem *addr, unsigned offset, u16 data);
+	u32	(*readl)(const void __iomem *addr, unsigned offset);
+	void	(*writel)(void __iomem *addr, unsigned offset, u32 data);
+	void	(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);
+	void	(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
 	int	(*reset)(struct musb *musb);
@@ -292,6 +331,7 @@ struct musb {
 	/* device lock */
 	spinlock_t		lock;
 
+	struct musb_io		io;
 	const struct musb_platform_ops *ops;
 	struct musb_context_registers context;
 

commit baadd52f0aa7a100192661132299f13e763932df
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Oct 27 19:06:19 2014 +0100

    usb: musb: try a race-free wakeup
    
    Attaching a keyboard, using it as a wakeup via
    |for f in $(find /sys/devices/ocp.3/47400000.usb -name wakeup)
    |do
    |       echo enabled > $f
    |done
    
    going into standby
    |  echo standby >  /sys/power/state
    
    and now a wake up by a pressing a key.
    What happens is that the system wakes up but the USB device is dead. The
    USB stack tries to send a few control URBs but nothing comes back.
    Eventually it gaves up and the device remains dead:
    |[  632.559678] PM: Wakeup source USB1_PHY
    |[  632.581074] PM: noirq resume of devices complete after 21.261 msecs
    |[  632.607521] PM: early resume of devices complete after 10.360 msecs
    |[  632.616854] net eth2: initializing cpsw version 1.12 (0)
    |[  632.704126] net eth2: phy found : id is : 0x4dd074
    |[  636.704048] libphy: 4a101000.mdio:00 - Link is Up - 1000/Full
    |[  638.444620] usb 1-1: reset low-speed USB device number 2 using musb-hdrc
    |[  653.713435] usb 1-1: device descriptor read/64, error -110
    |[  669.093435] usb 1-1: device descriptor read/64, error -110
    |[  669.473424] usb 1-1: reset low-speed USB device number 2 using musb-hdrc
    |[  684.743436] usb 1-1: device descriptor read/64, error -110
    |[  690.065097] PM: resume of devices complete after 57450.744 msecs
    |[  690.076601] PM: Finishing wakeup.
    |[  690.076627] Restarting tasks ...
    
    It seems that since we got woken up via MUSB_INTR_RESUME the
    musb_host_finish_resume() callback is executed before the
    resume-callbacks of the PHY and glue layer are invoked. If I delay it
    until the glue layer resumed then I don't see this problem.
    
    I also move musb_host_resume_root_hub() into that callback since I don't
    see any reason in doing anything resume-link if there are still pieces
    not restored.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 414e57a984bb..803a997e56d2 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -390,6 +390,7 @@ struct musb {
 
 	/* is_suspended means USB B_PERIPHERAL suspend */
 	unsigned		is_suspended:1;
+	unsigned		need_finish_resume :1;
 
 	/* may_wakeup means remote wakeup is enabled */
 	unsigned		may_wakeup:1;

commit d871c622e202efc663f953a4fcbd2cba6a28a24f
Author: George Cherian <george.cherian@ti.com>
Date:   Wed Jul 16 18:22:11 2014 +0530

    usb: musb: core: Convert the musb_platform_reset to have a return value.
    
    Currently musb_platform_reset() is only used by dsps.
    In case of BABBLE interrupt for other platforms the  musb_platform_reset()
    is a NOP. In such situations no need to re-initialize the endpoints.
    Also in the latest silicon revision of AM335x, we do have a babble recovery
    mechanism without resetting the IP block. In preperation to add that support
    its better to have a rest_done return for  musb_platform_reset().
    
    Signed-off-by: George Cherian <george.cherian@ti.com>
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9241025f6965..414e57a984bb 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -192,7 +192,7 @@ struct musb_platform_ops {
 
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
-	void	(*reset)(struct musb *musb);
+	int	(*reset)(struct musb *musb);
 
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
@@ -555,10 +555,12 @@ static inline void musb_platform_try_idle(struct musb *musb,
 		musb->ops->try_idle(musb, timeout);
 }
 
-static inline void musb_platform_reset(struct musb *musb)
+static inline int  musb_platform_reset(struct musb *musb)
 {
-	if (musb->ops->reset)
-		musb->ops->reset(musb);
+	if (!musb->ops->reset)
+		return -EINVAL;
+
+	return musb->ops->reset(musb);
 }
 
 static inline int musb_platform_get_vbus_status(struct musb *musb)

commit 675ae7631150a54eac81806ccb1bf16aba2bead8
Author: George Cherian <george.cherian@ti.com>
Date:   Wed Jul 16 18:22:10 2014 +0530

    usb: musb: core: Convert babble recover work to delayed work
    
    During babble condition both first disconnect of devices are
    initiated. Make sure MUSB controller is reset and re-initialized
    after all disconnects.
    
    To acheive this schedule a delayed work for babble recovery.
    
    While at that convert udelay to usleep_range.
    Refer Documentation/timers/timers-howto.txt
    
    Signed-off-by: George Cherian <george.cherian@ti.com>
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d155a156f240..9241025f6965 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -297,7 +297,7 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
-	struct work_struct	recover_work;
+	struct delayed_work	recover_work;
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
 	u16			hwvers;

commit 8c240dc17d900cc6453b48bdd513f4243a9ec97d
Author: Matwey V. Kornilov <matwey@sai.msu.ru>
Date:   Fri May 16 18:19:54 2014 +0400

    usb: musb: tusb6010: Add tusb_revision to struct musb to store the revision.
    
    Add field to store tusb6010 revision value. Read the revision at
    the startup and store to the variable.
    
    Signed-off-by: Matwey V. Kornilov <matwey@sai.msu.ru>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 47e88747e3a7..d155a156f240 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -339,6 +339,7 @@ struct musb {
 	dma_addr_t		async;
 	dma_addr_t		sync;
 	void __iomem		*sync_va;
+	u8			tusb_revision;
 #endif
 
 	/* passed down from chip/board specific irq handlers */

commit ca88fc2ef0d790a1da37804219102336f7622b97
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 2 13:58:28 2014 +0200

    usb: musb: add a work_struct to recover from babble errors
    
    Handle BABBLE interrupt error conditions from a work struct handler.
    This indirection is necessary as we can't be certain that the phy
    functions don't sleep.
    
    Platform layer implementation may pass a babble error down to the core
    in order to handle it.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 5514e4c82932..47e88747e3a7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -297,6 +297,7 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+	struct work_struct	recover_work;
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
 	u16			hwvers;

commit 1e42d20c88f2f56c0d81363d7b0f1d3762037f53
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 2 13:58:27 2014 +0200

    usb: musb: add reset hook to platform ops
    
    Babble interrupts require us to reset the DSPS glue layer. In order to
    handle all other recovery tasks independently, add a new hook for
    platform-specific implementations of the actual reset.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 7083e82776ff..5514e4c82932 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -192,6 +192,7 @@ struct musb_platform_ops {
 
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
+	void	(*reset)(struct musb *musb);
 
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
@@ -552,6 +553,12 @@ static inline void musb_platform_try_idle(struct musb *musb,
 		musb->ops->try_idle(musb, timeout);
 }
 
+static inline void musb_platform_reset(struct musb *musb)
+{
+	if (musb->ops->reset)
+		musb->ops->reset(musb);
+}
+
 static inline int musb_platform_get_vbus_status(struct musb *musb)
 {
 	if (!musb->ops->vbus_status)

commit 8ed1fb790ea24bb223e3b30e2b22bccf5b0a76c9
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Dec 18 20:23:46 2013 +0100

    usb: musb: finish suspend/reset work independently from musb_hub_control()
    
    Currently, resume and reset is completed when the USB core calls back
    the root hub, asking for the port's state. This results in
    unpredictable timing of state assertion, which in turn renders some
    USB devices unusable after resume.
    
    Fix this by moving the logic to end the reset and suspend state out of
    musb_hub_control() into separate functions called from delayed workers.
    GetPortStatus only reports the current state now, without taking any
    real action.
    
    The rh_timeout variable is kept in order to define a minimum time gap
    between reset and resume only.
    
    FWIW, in my case, a Verbatim "STORE N GO" mass storage device won't
    resume cleanly without this patch.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 29f7cd7c7964..7083e82776ff 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -47,6 +47,7 @@
 #include <linux/usb/otg.h>
 #include <linux/usb/musb.h>
 #include <linux/phy/phy.h>
+#include <linux/workqueue.h>
 
 struct musb;
 struct musb_hw_ep;
@@ -295,6 +296,8 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+	struct delayed_work	deassert_reset_work;
+	struct delayed_work	finish_resume_work;
 	u16			hwvers;
 
 	u16			intrrxe;

commit 5584cfbafc1a4c2a465f4423d351bb918c64cad0
Merge: 1653d2f88f43 31d141e3a666
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Oct 19 13:19:07 2013 -0700

    Merge 3.12-rc6 into usb-next.
    
    We want those USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 001dd84a92a25f8f2bad7d26df8bdb0362302c07
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Oct 11 10:38:13 2013 +0200

    usb: musb: start musb on the udc side, too
    
    I have am335x-evm with one port running in OTG mode. Since commit
    fe4cb09 ("usb: musb: gadget: remove hcd initialization") the loaded
    gadget does non pop up on the host. All I see is
    |usb 4-5: new high-speed USB device number 52 using ehci-pci
    |usb 4-5: device descriptor read/64, error -110
    
    Since a later commit 2cc65fe ("usb: musb: add musb_host_setup() and
    musb_host_cleanup()) the gadget shows up on the host again but only
    in OTG mode (because we have the host init code running). It does not
    work in device only mode.
    If running in OTG mode and the gadget is removed and added back (rmmod
    followed by modprobe of a gadget) then the same error is pops up on the
    host side.
    
    This patch ensures that the gadget side also executes musb_start() which
    puts the chip in "connect accept" mode. With this change the device
    works in OTG & device mode and the gadget can be added & removed
    multiple times.
    A device (if musb is in OTG mode acting as a host) is only recognized if
    it is attached during module load (musb_hdrc module). After the device
    unplugged and plugged again the host does not recognize it. We get a
    buch of errors if musb running in OTG mode, attached to a host and no
    gadget is loaded. Bah.
    This is one step forward. Host & device only mode should work. I will
    look at OTG later. I looked at this before commit fe4cb09 and OTG wasn't
    working there perfectly so I am not sure that it is a regression :)
    
    Cc: <stable@vger.kernel.org> # v3.11
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 65f3917b4fc5..1c5bf75ee8ff 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -503,6 +503,7 @@ static inline void musb_configure_ep0(struct musb *musb)
 extern const char musb_driver_name[];
 
 extern void musb_stop(struct musb *musb);
+extern void musb_start(struct musb *musb);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
 extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);

commit 3e3101d57c50f9e4fa1da947e4bd0bc5cbab4141
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Sep 27 11:53:30 2013 +0530

    usb: musb: omap2430: use the new generic PHY framework
    
    Use the generic PHY framework API to get the PHY. The usb_phy_set_resume
    and usb_phy_set_suspend is replaced with power_on and
    power_off to align with the new PHY framework.
    
    musb->xceiv can't be removed as of now because musb core uses xceiv.state and
    xceiv.otg. Once there is a separate state machine to handle otg, these can be
    moved out of xceiv and then we can start using the generic PHY framework.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 65f3917b4fc5..d408a9962f66 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -46,6 +46,7 @@
 #include <linux/usb.h>
 #include <linux/usb/otg.h>
 #include <linux/usb/musb.h>
+#include <linux/phy/phy.h>
 
 struct musb;
 struct musb_hw_ep;
@@ -341,6 +342,7 @@ struct musb {
 	u16			int_tx;
 
 	struct usb_phy		*xceiv;
+	struct phy		*phy;
 
 	int nIrq;
 	unsigned		irq_wake:1;

commit 24dc3538bcfb353741e653fab550c4bf0a8dc07d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 21:34:58 2013 -0700

    usb: musb: get rid of unused proc_dir_entry
    
    The musb driver no longer uses procfs, so get rid of the proc_dir_entry
    variable in struct musb.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 7d341c387eab..65f3917b4fc5 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -83,11 +83,6 @@ enum {
 	MUSB_PORT_MODE_DUAL_ROLE,
 };
 
-#ifdef CONFIG_PROC_FS
-#include <linux/fs.h>
-#define MUSB_CONFIG_PROC_FS
-#endif
-
 /****************************** CONSTANTS ********************************/
 
 #ifndef MUSB_C_NUM_EPS
@@ -425,9 +420,6 @@ struct musb {
 
 	struct musb_hdrc_config	*config;
 
-#ifdef MUSB_CONFIG_PROC_FS
-	struct proc_dir_entry *proc_entry;
-#endif
 	int			xceiv_old_state;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debugfs_root;

commit 9ad96e694c3d33465d099d0a2db1aae8cb358d1f
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 21:55:48 2013 +0200

    usb: musb: re-introduce musb->port_mode
    
    Define MUSB_PORT_MODE_{HOST,GADGET,DUAL_ROLE} and store the
    platform-specified value in struct musb.
    
    Note that MUSB_PORT_MODE_HOST has to be set to 1 in order to match
    existing device tree bindings which are already documented but in fact
    unusued. For information on the bindings, please refer to
    
      Documentation/devicetree/bindings/usb/omap-usb.txt
      Documentation/devicetree/bindings/usb/am33xx-usb.txt
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index e633fce787fb..7d341c387eab 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -77,6 +77,12 @@ struct musb_ep;
 #define is_peripheral_active(m)		(!(m)->is_host)
 #define is_host_active(m)		((m)->is_host)
 
+enum {
+	MUSB_PORT_MODE_HOST	= 1,
+	MUSB_PORT_MODE_GADGET,
+	MUSB_PORT_MODE_DUAL_ROLE,
+};
+
 #ifdef CONFIG_PROC_FS
 #include <linux/fs.h>
 #define MUSB_CONFIG_PROC_FS
@@ -356,6 +362,7 @@ struct musb {
 
 	u8			min_power;	/* vbus for periph, in mA/2 */
 
+	int			port_mode;	/* MUSB_PORT_MODE_* */
 	bool			is_host;
 
 	int			a_wait_bcon;	/* VBUS timeout in msecs */

commit 74c2e93600581d80695604126a3725a157d0ab72
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 21:55:45 2013 +0200

    usb: musb: factor out hcd initalization
    
    The musb struct is currently allocated along with the hcd, which makes
    it difficult to build a driver that only acts as gadget device.
    
    Fix this by allocating musb directly, and keep the hcd around as
    a pointer in the musb struct.
    
    struct hc_driver musb_hc_driver can now also be static to musb_host.c,
    and the macro musb_to_hcd() is just a pointer dereferencer for now, and
    will be eliminated later.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index e981b9bb3739..e633fce787fb 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -401,6 +401,7 @@ struct musb {
 	enum musb_g_ep0_state	ep0_state;
 	struct usb_gadget	g;			/* the gadget */
 	struct usb_gadget_driver *gadget_driver;	/* its driver */
+	struct usb_hcd		*hcd;			/* the usb hcd */
 
 	/*
 	 * FIXME: Remove this flag.

commit 69ae2a70bfabbd6af6309bf723ec76493512dba1
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 21:55:44 2013 +0200

    usb: musb: move musb_start to musb_virthub.c
    
    This function has its only user in musb_virthub.c, so let's move it
    there and make it static.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 0193dc9f4351..e981b9bb3739 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -502,7 +502,6 @@ static inline void musb_configure_ep0(struct musb *musb)
 
 extern const char musb_driver_name[];
 
-extern void musb_start(struct musb *musb);
 extern void musb_stop(struct musb *musb);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);

commit c2a2759d33787e49b751a446d63dd6af3abe3aeb
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 21:55:41 2013 +0200

    usb: musb: move function declarations to musb_{host,gadget}.h
    
    Let the function declarations live in the header files they belong to,
    which makes it easier to stub them out later.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8013a5f6d3d2..0193dc9f4351 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -82,23 +82,6 @@ struct musb_ep;
 #define MUSB_CONFIG_PROC_FS
 #endif
 
-/****************************** PERIPHERAL ROLE *****************************/
-
-extern irqreturn_t musb_g_ep0_irq(struct musb *);
-extern void musb_g_tx(struct musb *, u8);
-extern void musb_g_rx(struct musb *, u8);
-extern void musb_g_reset(struct musb *);
-extern void musb_g_suspend(struct musb *);
-extern void musb_g_resume(struct musb *);
-extern void musb_g_wakeup(struct musb *);
-extern void musb_g_disconnect(struct musb *);
-
-/****************************** HOST ROLE ***********************************/
-
-extern irqreturn_t musb_h_ep0_irq(struct musb *);
-extern void musb_host_tx(struct musb *, u8);
-extern void musb_host_rx(struct musb *, u8);
-
 /****************************** CONSTANTS ********************************/
 
 #ifndef MUSB_C_NUM_EPS

commit 6d349671174c5da77835dd1b82e874508167f57b
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Apr 29 12:02:24 2013 +0300

    usb: musb: remove 'ignore_disconnect' flag
    
    This was related to an old bug on early versions
    of TUSB6010 which we don't support anymore.
    
    It's known to cause issues on several other
    situations with more recent devices so we
    better remove this flag now and come up
    with a better workaround should one be deemed
    necessary.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 7fb4819a6f11..8013a5f6d3d2 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -382,7 +382,6 @@ struct musb {
 	unsigned		is_active:1;
 
 	unsigned is_multipoint:1;
-	unsigned ignore_disconnect:1;	/* during bus resets */
 
 	unsigned		hb_iso_rx:1;	/* high bandwidth iso rx? */
 	unsigned		hb_iso_tx:1;	/* high bandwidth iso tx? */

commit 2f7711642559851c187d09795a3eb51c2bde36ec
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Oct 31 16:12:43 2012 +0100

    usb: musb: remove hand-crafted id handling
    
    This replaced the handcrafted id handling by the PLATFORM_DEVID_AUTO
    value which should do the same thing.
    
    This patch probably also fixes ux500 because I did not find the "musbid"
    variable to remove. And we close a tiny-unlikely race window becuase the
    old code gave the id back before device was destroyed in the remove
    case.
    
    [ balbi@ti.com : fixed up two failed hunks when applying patch ]
    
    Cc: B, Ravi <ravibabu@ti.com>
    Cc: Santhapuri, Damodar <damodar.santhapuri@ti.com>
    Cc: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
    Cc: Bob Liu <lliubbo@gmail.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 0cef3ceb52c3..7fb4819a6f11 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -522,8 +522,6 @@ extern const char musb_driver_name[];
 
 extern void musb_start(struct musb *musb);
 extern void musb_stop(struct musb *musb);
-extern int musb_get_id(struct device *dev, gfp_t gfp_mask);
-extern void musb_put_id(struct device *dev, int id);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
 extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);

commit b18d26f6ad8f00ea5f7c6a12ea52627ca3c3c6e2
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Oct 30 19:52:26 2012 +0100

    usb: musb: Perform only write access on MUSB_INTRTXE
    
    This is part of the workaround for AM35x advisory Advisory 1.1.20.
    The advisory says that the IPSS bridge can't handle 8 & 16 bit read
    access. An 16bit read access to MUSB_INTRTXE results in an 32bit read
    access which also reads INTRRX and therefore may lose interrupts.
    This patch uses a shadow register of MUSB_INTRTXE so we only perform
    write access to it.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 60b92cbdc7f7..0cef3ceb52c3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -288,7 +288,6 @@ struct musb_csr_regs {
 struct musb_context_registers {
 
 	u8 power;
-	u16 intrtxe;
 	u8 intrusbe;
 	u16 frame;
 	u8 index, testmode;
@@ -314,6 +313,7 @@ struct musb {
 	u16			hwvers;
 
 	u16			intrrxe;
+	u16			intrtxe;
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
 #define MUSB_PORT_STAT_RESUME	(1 << 31)
 

commit af5ec14d40e0da1de17fcca2b41c76fae5c2cb9d
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Oct 30 19:52:25 2012 +0100

    usb: musb: Perform only write access on MUSB_INTRRXE
    
    This is part of the workaround for AM35x advisory Advisory 1.1.20.
    The advisory says that the IPSS bridge can't handle 8 & 16 bit read
    access. An 16bit read access to MUSB_INTRRXE results in an 32bit read
    access which also reads INTRUSB and therefore may lose interrupts.
    This patch uses a shadow register of MUSB_INTRRXE so we only perform
    write access to it.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index c158aacd6de8..60b92cbdc7f7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -288,7 +288,7 @@ struct musb_csr_regs {
 struct musb_context_registers {
 
 	u8 power;
-	u16 intrtxe, intrrxe;
+	u16 intrtxe;
 	u8 intrusbe;
 	u16 frame;
 	u8 index, testmode;
@@ -313,6 +313,7 @@ struct musb {
 	struct work_struct	irq_work;
 	u16			hwvers;
 
+	u16			intrrxe;
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
 #define MUSB_PORT_STAT_RESUME	(1 << 31)
 

commit 8d2421e68cb8a159963641eab72f8f8ba1c7f7b0
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Fri Aug 31 11:09:50 2012 +0000

    usb: musb: kill global and static for multi instance
    
    Moved global variable "musb_debugfs_root" and static variable
    "old_state" to 'struct musb' to help support multi instance of
    musb controller as present on AM335x platform.
    
    Also removed the global variable "orig_dma_mask" and filled the
    dev->dma_mask with parent device's dma_mask.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Santhapuri, Damodar <damodar.santhapuri@ti.com>
    Signed-off-by: Ravi Babu <ravibabu@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index a69ffd68a9e0..c158aacd6de8 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -436,6 +436,10 @@ struct musb {
 
 #ifdef MUSB_CONFIG_PROC_FS
 	struct proc_dir_entry *proc_entry;
+#endif
+	int			xceiv_old_state;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*debugfs_root;
 #endif
 };
 

commit 65b3d52d02a558fbfe08e43688e15390c5ab3067
Author: B, Ravi <ravibabu@ti.com>
Date:   Fri Aug 31 11:09:49 2012 +0000

    usb: musb: add musb_ida for multi instance support
    
    Added musb_ida in musb_core.c to manage the multi core ids.
    
    Signed-off-by: Ravi Babu <ravibabu@ti.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Santhapuri, Damodar <damodar.santhapuri@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index a1a32c6601c7..a69ffd68a9e0 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -517,6 +517,8 @@ extern const char musb_driver_name[];
 
 extern void musb_start(struct musb *musb);
 extern void musb_stop(struct musb *musb);
+extern int musb_get_id(struct device *dev, gfp_t gfp_mask);
+extern void musb_put_id(struct device *dev, int id);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
 extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);

commit a04d46d02e0c511dabb3c0a29286811a00d12b10
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Nov 24 15:46:27 2011 +0200

    usb: musb: drop is_host_capable() and is_peripheral_capable()
    
    those two were defined to 1 anyway, quite useless.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 5dab2daddf7f..a1a32c6601c7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -84,8 +84,6 @@ struct musb_ep;
 
 /****************************** PERIPHERAL ROLE *****************************/
 
-#define	is_peripheral_capable()	(1)
-
 extern irqreturn_t musb_g_ep0_irq(struct musb *);
 extern void musb_g_tx(struct musb *, u8);
 extern void musb_g_rx(struct musb *, u8);
@@ -97,8 +95,6 @@ extern void musb_g_disconnect(struct musb *);
 
 /****************************** HOST ROLE ***********************************/
 
-#define	is_host_capable()	(1)
-
 extern irqreturn_t musb_h_ep0_irq(struct musb *);
 extern void musb_host_tx(struct musb *, u8);
 extern void musb_host_rx(struct musb *, u8);

commit 032ec49f5351e9cb242b1a1c367d14415043ab95
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Nov 24 15:46:26 2011 +0200

    usb: musb: drop useless board_mode usage
    
    we are compiling the driver always with full OTG
    capabilities, so that board_mode trick becomes
    useless.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 8bb324dddd17..5dab2daddf7f 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -71,10 +71,6 @@ struct musb_ep;
 #include <linux/usb/hcd.h>
 #include "musb_host.h"
 
-#define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
-#define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
-#define	is_otg_enabled(musb)		((musb)->board_mode == MUSB_OTG)
-
 /* NOTE:  otg and peripheral-only state machines start at B_IDLE.
  * OTG or host-only go to A_IDLE when ID is sensed.
  */
@@ -376,7 +372,6 @@ struct musb {
 	u16 epmask;
 	u8 nr_endpoints;
 
-	u8 board_mode;		/* enum musb_mode */
 	int			(*board_set_power)(int state);
 
 	u8			min_power;	/* vbus for periph, in mA/2 */

commit a156544bc90e82d61bd7c25e6258e4da32256bea
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Aug 7 14:00:50 2012 +0300

    usb: musb: fix sparse warnings
    
    The following warnings are fixed:
    
    drivers/usb/musb/musb_core.c:357:6: warning: symbol 'musb_otg_timer_func' was not declared. Should it be static?
    drivers/usb/musb/musb_core.c:1339:27: warning: incorrect type in initializer (different address spaces)
    drivers/usb/musb/musb_core.c:1339:27:    expected void *mbase
    drivers/usb/musb/musb_core.c:1339:27:    got void [noderef] <asn:2>*mregs
    drivers/usb/musb/musb_core.c:1347:17: warning: incorrect type in argument 1 (different address spaces)
    drivers/usb/musb/musb_core.c:1347:17:    expected void [noderef] <asn:2>*addr
    drivers/usb/musb/musb_core.c:1347:17:    got void *mbase
    drivers/usb/musb/musb_core.h:487:27: warning: incorrect type in initializer (different address spaces)
    drivers/usb/musb/musb_core.h:487:27:    expected void *mbase
    drivers/usb/musb/musb_core.h:487:27:    got void [noderef] <asn:2>*mregs
    drivers/usb/musb/musb_core.h:491:26: warning: incorrect type in argument 1 (different address spaces)
    drivers/usb/musb/musb_core.h:491:26:    expected void const [noderef] <asn:2>*addr
    drivers/usb/musb/musb_core.h:491:26:    got void *mbase
    drivers/usb/musb/tusb6010.c:270:48: warning: incorrect type in argument 2 (different address spaces)
    drivers/usb/musb/tusb6010.c:270:48:    expected void [noderef] <asn:2>*buf
    drivers/usb/musb/tusb6010.c:270:48:    got unsigned char [usertype] *[assigned] buf
    drivers/usb/musb/tusb6010.c:164:32: warning: incorrect type in argument 1 (different address spaces)
    drivers/usb/musb/tusb6010.c:164:32:    expected void *to
    drivers/usb/musb/tusb6010.c:164:32:    got void [noderef] <asn:2>*buf
    drivers/usb/musb/tusb6010.c:172:24: warning: incorrect type in argument 1 (different address spaces)
    drivers/usb/musb/tusb6010.c:172:24:    expected void *to
    drivers/usb/musb/tusb6010.c:172:24:    got void [noderef] <asn:2>*[assigned] buf
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 586105b55a7c..8bb324dddd17 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -484,7 +484,7 @@ static inline void musb_configure_ep0(struct musb *musb)
 static inline int musb_read_fifosize(struct musb *musb,
 		struct musb_hw_ep *hw_ep, u8 epnum)
 {
-	void *mbase = musb->mregs;
+	void __iomem *mbase = musb->mregs;
 	u8 reg = 0;
 
 	/* read from core using indexed model */

commit 08aff5358207ee80e4fe162845c17ea125295eec
Author: Viresh Kumar <viresh.linux@gmail.com>
Date:   Mon Jul 30 14:39:34 2012 -0700

    usb/musb: remove conditional compilation of clk code
    
    With addition of dummy clk_*() calls for non CONFIG_HAVE_CLK cases in
    clk.h, there is no need to have clk code enclosed in #ifdef
    CONFIG_HAVE_CLK, #endif macros.
    
    musb also has these dummy macros defined locally.  Remove them as they
    aren't required anymore.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: viresh kumar <viresh.linux@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index dbcdeea30f09..586105b55a7c 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -81,14 +81,6 @@ struct musb_ep;
 #define is_peripheral_active(m)		(!(m)->is_host)
 #define is_host_active(m)		((m)->is_host)
 
-#ifndef CONFIG_HAVE_CLK
-/* Dummy stub for clk framework */
-#define clk_get(dev, id)	NULL
-#define clk_put(clock)		do {} while (0)
-#define clk_enable(clock)	do {} while (0)
-#define clk_disable(clock)	do {} while (0)
-#endif
-
 #ifdef CONFIG_PROC_FS
 #include <linux/fs.h>
 #define MUSB_CONFIG_PROC_FS

commit 1e5acb8d6113a0f159257845e153d5b870ca618a
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:40:51 2012 +0530

    usb: musb: move work_struct(otg_notifier_work) from core to omap glue
    
    Commit 712d8e(fixes pm_runtime calls while atomic by using a work
    queue. musb pm_runtime_get_sync call happens in interrupt context
    on cable attach case. That can result in re-enabling the interrupts and
    cause side affect. To avoid this deferred processing is used)
    
    While the issue and the work queue implementation is specific to omap
    (omap2430.c), the work_struct is defined as a member of struct musb
    (musb_core.h). Hence moved the work_struct from musb_core to omap
    glue.
    
    Cc: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f4a40f001c88..dbcdeea30f09 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -327,7 +327,6 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
-	struct work_struct	otg_notifier_work;
 	u16			hwvers;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
@@ -373,7 +372,6 @@ struct musb {
 	u16			int_tx;
 
 	struct usb_phy		*xceiv;
-	u8			xceiv_event;
 
 	int nIrq;
 	unsigned		irq_wake:1;

commit fc87e080e19fdeb1120ce274423fea7b2ec2f63e
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Apr 18 13:49:20 2012 +0300

    usb: musb: drop __deprecated flag
    
    Looks like we cannot live without that double_buffer_not_ok
    flag due to many HW bugs this MUSB core has.
    
    So, let's drop the __deprecated flag to avoid annoying
    compile warnings.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 93de517a32a0..f4a40f001c88 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -449,7 +449,7 @@ struct musb {
 	 * We added this flag to forcefully disable double
 	 * buffering until we get it working.
 	 */
-	unsigned                double_buffer_not_ok:1 __deprecated;
+	unsigned                double_buffer_not_ok:1;
 
 	struct musb_hdrc_config	*config;
 

commit 8675381109b0eb1c948a423c2b35e3f4509cb25e
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:02 2012 +0200

    usb: otg: Rename otg_transceiver to usb_phy
    
    This is the first step in separating USB transceivers from
    USB OTG utilities.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3d28fb8a2dc9..93de517a32a0 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -372,7 +372,7 @@ struct musb {
 	u16			int_rx;
 	u16			int_tx;
 
-	struct otg_transceiver	*xceiv;
+	struct usb_phy		*xceiv;
 	u8			xceiv_event;
 
 	int nIrq;

commit 712d8efafbbcbe617f9ad706f6ca1ffea4bbf2e8
Author: Vikram Pandita <vikram.pandita@ti.com>
Date:   Fri Aug 12 07:38:51 2011 -0700

    usb: musb: fix pm_runtime calls while atomic
    
    musb pm_runtime_get_sync call happens in intrrupt context on cable attach case
    That can result in re-enabling the interrupts and cause side affects.
    
    So move the code to a work queue.
    
    Following is the error path hit on cable attach:
    
    BUG: sleeping function called from invalid context at drivers/base/power/runtime.c:802
    in_atomic(): 0, irqs_disabled(): 0, pid: 18, name: irq/378-twl6030
    
    Backtrace:
    [<c00520f0>] (dump_backtrace+0x0/0x110) from [<c054f454>] (dump_stack+0x18/0x1c)
    [<c054f43c>] (dump_stack+0x0/0x1c) from [<c007f59c>] (__might_sleep+0x130/0x134)
    [<c007f46c>] (__might_sleep+0x0/0x134) from [<c02c2794>] (__pm_runtime_resume+0x94/0x98)
    [<c02c2700>] (__pm_runtime_resume+0x0/0x98) from [<c033e7e4>] (musb_otg_notifications+0x9c/0x164)
    [<c033e748>] (musb_otg_notifications+0x0/0x164) from [<c00b3df0>] (notifier_call_chain+0x4c/0x8c)
    [<c00b3da4>] (notifier_call_chain+0x0/0x8c) from [<c00b44a8>] (__atomic_notifier_call_chain+0x40/0x54)
    [<c00b4468>] (__atomic_notifier_call_chain+0x0/0x54) from [<c00b44dc>] (atomic_notifier_call_chain+0x20/0x28)
    [<c00b44bc>] (atomic_notifier_call_chain+0x0/0x28) from [<c033f124>] (twl6030_usb_irq+0xc8/0xdc)
    [<c033f05c>] (twl6030_usb_irq+0x0/0xdc) from [<c00d79f8>] (irq_thread_fn+0x24/0x40)
    [<c00d79d4>] (irq_thread_fn+0x0/0x40) from [<c00d7b64>] (irq_thread+0x150/0x1d8)
    [<c00d7a14>] (irq_thread+0x0/0x1d8) from [<c00adf70>] (kthread+0x94/0x98)
    [<c00adedc>] (kthread+0x0/0x98) from [<c0094388>] (do_exit+0x0/0x720)
    
    Tested with:
    MUSB Device mode: Cold boot / Hot plug
    MUSB Host mode: Cold boot / Hot plug
    
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Moiz Sonasath <m-sonasath@ti.com>
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index bd2e6b8b814e..3d28fb8a2dc9 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -327,6 +327,7 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+	struct work_struct	otg_notifier_work;
 	u16			hwvers;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
@@ -372,6 +373,7 @@ struct musb {
 	u16			int_tx;
 
 	struct otg_transceiver	*xceiv;
+	u8			xceiv_event;
 
 	int nIrq;
 	unsigned		irq_wake:1;

commit 7d5b49a202c4201a8afc36f9e55624894aba9fb5
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Oct 14 10:45:15 2011 +0300

    usb: musb: headers cleanup
    
    Remove a few unnecessary headers from a
    few files.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3259a6bbaba3..bd2e6b8b814e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -40,7 +40,6 @@
 #include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
-#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>

commit e25bec160158abe86c276d7d206264afc3646281
Author: Hema HK <hemahk@ti.com>
Date:   Wed Sep 7 09:19:24 2011 -0700

    usb: musb: omap2+: save and restore OTG_INTERFSEL
    
    we need to save and restore OTG_INTERFSEL register
    else we will be unable to function on resume after
    OFF mode.
    
    Reported-by: Devaraj Rangasamy <dev@ti.com>
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b3c065ab9dbc..3259a6bbaba3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -311,6 +311,7 @@ struct musb_context_registers {
 	u8 index, testmode;
 
 	u8 devctl, busctl, misc;
+	u32 otg_interfsel;
 
 	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
 };

commit 240a16e2cd831cb25361b1d1797bd04e8faf8b4f
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Aug 5 13:29:49 2011 +0300

    usb: musb: tusb6010: fix compilation
    
    earlier commits have broken compilation of
    tusb6010 glue layer, fix it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 668eeef601ae..b3c065ab9dbc 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -172,7 +172,8 @@ enum musb_g_ep0_state {
 #endif
 
 /* TUSB mapping: "flat" plus ep0 special cases */
-#if	defined(CONFIG_USB_MUSB_TUSB6010)
+#if defined(CONFIG_USB_MUSB_TUSB6010) || \
+	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
 #define musb_ep_select(_mbase, _epnum) \
 	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
 #define	MUSB_EP_OFFSET			MUSB_TUSB_OFFSET
@@ -241,7 +242,8 @@ struct musb_hw_ep {
 	void __iomem		*fifo;
 	void __iomem		*regs;
 
-#ifdef CONFIG_USB_MUSB_TUSB6010
+#if defined(CONFIG_USB_MUSB_TUSB6010) || \
+	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
 	void __iomem		*conf;
 #endif
 
@@ -258,7 +260,8 @@ struct musb_hw_ep {
 	struct dma_channel	*tx_channel;
 	struct dma_channel	*rx_channel;
 
-#ifdef CONFIG_USB_MUSB_TUSB6010
+#if defined(CONFIG_USB_MUSB_TUSB6010) || \
+	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
 	/* TUSB has "asynchronous" and "synchronous" dma modes */
 	dma_addr_t		fifo_async;
 	dma_addr_t		fifo_sync;
@@ -356,7 +359,8 @@ struct musb {
 	void __iomem		*ctrl_base;
 	void __iomem		*mregs;
 
-#ifdef CONFIG_USB_MUSB_TUSB6010
+#if defined(CONFIG_USB_MUSB_TUSB6010) || \
+	defined(CONFIG_USB_MUSB_TUSB6010_MODULE)
 	dma_addr_t		async;
 	dma_addr_t		sync;
 	void __iomem		*sync_va;

commit 622859634a663c5e55d0e2a2cdbb55ac058d97b3
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Jun 22 17:28:09 2011 +0300

    usb: musb: drop a gigantic amount of ifdeferry
    
    the MUSB IP is always OTG, so there's no point
    in adding so many ifdefs on the code. Drop those
    and always compile the driver for OTG support.
    
    This also allows us to drop the useless "driver
    mode" choice. For doing that, we need to make
    musb depend on both Host and Peripheral side.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 12542a48a64e..668eeef601ae 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -72,10 +72,6 @@ struct musb_ep;
 #include <linux/usb/hcd.h>
 #include "musb_host.h"
 
-
-
-#ifdef CONFIG_USB_MUSB_OTG
-
 #define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
 #define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
 #define	is_otg_enabled(musb)		((musb)->board_mode == MUSB_OTG)
@@ -86,24 +82,6 @@ struct musb_ep;
 #define is_peripheral_active(m)		(!(m)->is_host)
 #define is_host_active(m)		((m)->is_host)
 
-#else
-#define	is_peripheral_enabled(musb)	is_peripheral_capable()
-#define	is_host_enabled(musb)		is_host_capable()
-#define	is_otg_enabled(musb)		0
-
-#define	is_peripheral_active(musb)	is_peripheral_capable()
-#define	is_host_active(musb)		is_host_capable()
-#endif
-
-#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_PERIPHERAL)
-/* for some reason, the "select USB_GADGET_MUSB_HDRC" doesn't always
- * override that choice selection (often USB_GADGET_DUMMY_HCD).
- */
-#ifndef CONFIG_USB_GADGET_MUSB_HDRC
-#error bogus Kconfig output ... select CONFIG_USB_GADGET_MUSB_HDRC
-#endif
-#endif	/* need MUSB gadget selection */
-
 #ifndef CONFIG_HAVE_CLK
 /* Dummy stub for clk framework */
 #define clk_get(dev, id)	NULL
@@ -119,8 +97,6 @@ struct musb_ep;
 
 /****************************** PERIPHERAL ROLE *****************************/
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-
 #define	is_peripheral_capable()	(1)
 
 extern irqreturn_t musb_g_ep0_irq(struct musb *);
@@ -132,40 +108,14 @@ extern void musb_g_resume(struct musb *);
 extern void musb_g_wakeup(struct musb *);
 extern void musb_g_disconnect(struct musb *);
 
-#else
-
-#define	is_peripheral_capable()	(0)
-
-static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_g_reset(struct musb *m) {}
-static inline void musb_g_suspend(struct musb *m) {}
-static inline void musb_g_resume(struct musb *m) {}
-static inline void musb_g_wakeup(struct musb *m) {}
-static inline void musb_g_disconnect(struct musb *m) {}
-
-#endif
-
 /****************************** HOST ROLE ***********************************/
 
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-
 #define	is_host_capable()	(1)
 
 extern irqreturn_t musb_h_ep0_irq(struct musb *);
 extern void musb_host_tx(struct musb *, u8);
 extern void musb_host_rx(struct musb *, u8);
 
-#else
-
-#define	is_host_capable()	(0)
-
-static inline irqreturn_t musb_h_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_host_tx(struct musb *m, u8 e) {}
-static inline void musb_host_rx(struct musb *m, u8 e) {}
-
-#endif
-
-
 /****************************** CONSTANTS ********************************/
 
 #ifndef MUSB_C_NUM_EPS
@@ -315,7 +265,6 @@ struct musb_hw_ep {
 	void __iomem		*fifo_sync_va;
 #endif
 
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	void __iomem		*target_regs;
 
 	/* currently scheduled peripheral endpoint */
@@ -324,31 +273,20 @@ struct musb_hw_ep {
 
 	u8			rx_reinit;
 	u8			tx_reinit;
-#endif
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	/* peripheral side */
 	struct musb_ep		ep_in;			/* TX */
 	struct musb_ep		ep_out;			/* RX */
-#endif
 };
 
 static inline struct musb_request *next_in_request(struct musb_hw_ep *hw_ep)
 {
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	return next_request(&hw_ep->ep_in);
-#else
-	return NULL;
-#endif
 }
 
 static inline struct musb_request *next_out_request(struct musb_hw_ep *hw_ep)
 {
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	return next_request(&hw_ep->ep_out);
-#else
-	return NULL;
-#endif
 }
 
 struct musb_csr_regs {
@@ -393,7 +331,6 @@ struct musb {
 
 	u32			port1_status;
 
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	unsigned long		rh_timer;
 
 	enum musb_h_ep0_state	ep0_stage;
@@ -411,7 +348,6 @@ struct musb {
 	struct list_head	out_bulk;	/* of musb_qh */
 
 	struct timer_list	otg_timer;
-#endif
 	struct notifier_block	nb;
 
 	struct dma_controller	*dma_controller;
@@ -472,7 +408,6 @@ struct musb {
 #define	can_bulk_combine(musb,type) \
 	(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	/* is_suspended means USB B_PERIPHERAL suspend */
 	unsigned		is_suspended:1;
 
@@ -496,7 +431,6 @@ struct musb {
 	enum musb_g_ep0_state	ep0_state;
 	struct usb_gadget	g;			/* the gadget */
 	struct usb_gadget_driver *gadget_driver;	/* its driver */
-#endif
 
 	/*
 	 * FIXME: Remove this flag.
@@ -518,12 +452,10 @@ struct musb {
 #endif
 };
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 static inline struct musb *gadget_to_musb(struct usb_gadget *g)
 {
 	return container_of(g, struct musb, g);
 }
-#endif
 
 #ifdef CONFIG_BLACKFIN
 static inline int musb_read_fifosize(struct musb *musb,

commit 9ea35331d052a5af1ba4e6244c52485f82587b60
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Wed Jun 29 16:41:48 2011 +0300

    usb: musb: update musb_platform_ops docs to match code
    
    The "channel_program" member was renamed to "adjust_channel_params",
    but the documentation wasn't updated.
    
    Reported-by: Sergei Shtylyov <sshtylyov@mvista.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 0e053b587960..12542a48a64e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -261,7 +261,7 @@ enum musb_g_ep0_state {
  * @try_ilde:	tries to idle the IP
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
- * @channel_program: pre check for standard dma channel_program func
+ * @adjust_channel_params: pre check for standard dma channel_program func
  */
 struct musb_platform_ops {
 	int	(*init)(struct musb *musb);

commit 132543074af3cf1e94e3608abf162880edbdcbb3
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Wed Mar 30 22:48:54 2011 -0400

    USB: musb: blackfin: work around anomaly 05000450
    
    DMA mode 1 data corruption anomaly on Blackfin systems.  This issue is
    specific to the Blackfin silicon as the bug appears to be related to the
    connection of the musb ip to the bus/dma fabric.
    
    Data corruption when using USB DMA mode 1. (Issue manager 17-01-0105)
    DMA mode 1 allows large size transfers to generate a single interrupt
    at the end of the entire transfer.  The transfer is split up in packets
    of length specified in the Maximum Packet Size field for that endpoint.
    If the transfer size is not an integer multiple of the Maximum Packet
    Size, a short packet will be present at the end of the transfer.
    
    Under certain conditions this packet may be corrupted in the USB FIFO.
    
    Workaround:
    Use DMA mode 1 to transfer (n* Maximum Packet Size) and schedule DMA
    mode 0 to transfer the short packet.
    
    As an example if your transfer size is 33168 bytes and Maximum Packet
    Size equals 512, schedule [33168 - (33168 mod 512)] in DMA mode 1 and
    the remainder (33168 mod 512) in DMA mode 0.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 4bd9e2145ee4..0e053b587960 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -261,6 +261,7 @@ enum musb_g_ep0_state {
  * @try_ilde:	tries to idle the IP
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
+ * @channel_program: pre check for standard dma channel_program func
  */
 struct musb_platform_ops {
 	int	(*init)(struct musb *musb);
@@ -274,6 +275,10 @@ struct musb_platform_ops {
 
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
+
+	int	(*adjust_channel_params)(struct dma_channel *channel,
+				u16 packet_sz, u8 *mode,
+				dma_addr_t *dma_addr, u32 *len);
 };
 
 /*

commit 0df0914d414a504b975f3cc66ace0c16ef55b7f3
Merge: 689960853341 05f689400ea5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 19:28:15 2011 -0700

    Merge branch 'omap-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6
    
    * 'omap-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6: (258 commits)
      omap: zoom: host should not pull up wl1271's irq line
      arm: plat-omap: iommu: fix request_mem_region() error path
      OMAP2+: Common CPU DIE ID reading code reads wrong registers for OMAP4430
      omap4: mux: Remove duplicate mux modes
      omap: iovmm: don't check 'da' to set IOVMF_DA_FIXED flag
      omap: iovmm: disallow mapping NULL address when IOVMF_DA_ANON is set
      omap2+: mux: Fix compile when CONFIG_OMAP_MUX is not selected
      omap4: board-omap4panda: Initialise the serial pads
      omap3: board-3430sdp: Initialise the serial pads
      omap4: board-4430sdp: Initialise the serial pads
      omap2+: mux: Add macro for configuring static with omap_hwmod_mux_init
      omap2+: mux: Remove the use of IDLE flag
      omap2+: Add separate list for dynamic pads to mux
      perf: add OMAP support for the new power events
      OMAP4: Add IVA OPP enteries.
      OMAP4: Update Voltage Rail Values for MPU, IVA and CORE
      OMAP4: Enable 800 MHz and 1 GHz MPU-OPP
      OMAP3+: OPP: Replace voltage values with Macros
      OMAP3: wdtimer: Fix CORE idle transition
      Watchdog: omap_wdt: add fine grain runtime-pm
      ...
    
    Fix up various conflicts in
     - arch/arm/mach-omap2/board-omap3evm.c
     - arch/arm/mach-omap2/clock3xxx_data.c
     - arch/arm/mach-omap2/usb-musb.c
     - arch/arm/plat-omap/include/plat/usb.h
     - drivers/usb/musb/musb_core.h

commit 971f115a50afbe409825c9f3399d5a3b9aca4381
Merge: 2e270d842232 500132a0f26a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 15:04:26 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (172 commits)
      USB: Add support for SuperSpeed isoc endpoints
      xhci: Clean up cycle bit math used during stalls.
      xhci: Fix cycle bit calculation during stall handling.
      xhci: Update internal dequeue pointers after stalls.
      USB: Disable auto-suspend for USB 3.0 hubs.
      USB: Remove bogus USB_PORT_STAT_SUPER_SPEED symbol.
      xhci: Return canceled URBs immediately when host is halted.
      xhci: Fixes for suspend/resume of shared HCDs.
      xhci: Fix re-init on power loss after resume.
      xhci: Make roothub functions deal with device removal.
      xhci: Limit roothub ports to 15 USB3 & 31 USB2 ports.
      xhci: Return a USB 3.0 hub descriptor for USB3 roothub.
      xhci: Register second xHCI roothub.
      xhci: Change xhci_find_slot_id_by_port() API.
      xhci: Refactor bus suspend state into a struct.
      xhci: Index with a port array instead of PORTSC addresses.
      USB: Set usb_hcd->state and flags for shared roothubs.
      usb: Make core allocate resources per PCI-device.
      usb: Store bus type in usb_hcd, not in driver flags.
      usb: Change usb_hcd->bandwidth_mutex to a pointer.
      ...

commit 12d7d4e0ed8fecf7f74c89483b55b300be6e5901
Merge: aca6ad073ea8 790ab7e92bec
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Mar 2 17:07:14 2011 -0800

    Merge branch 'devel-cleanup' into omap-for-linus
    
    Conflicts:
            arch/arm/mach-omap2/timer-gp.c

commit da68ccec210c45eb99e461ad31b499b4e7043c41
Author: Hema HK <hemahk@ti.com>
Date:   Mon Feb 28 14:19:33 2011 +0530

    usb: musb: Remove platform context save/restore API
    
    For OMAP3 and OMAP4 for offmode and retention support, musb
    sysconfig is configured to force idle and standby with ENABLE_FORCE bit
    of OTG_FORCESTNDBY set.
    And on wakeup configure to no ilde/standby with resetting the ENABLE_FORCE
    bit. There is not need to save and restore of this register anymore
    so removed omap2430_save_context/omap2430_restore_context functions.
    and also removed otg_forcestandby member of musb_context_registers
    structure
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 5216729bd4b2..5cb50f8f2907 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -358,10 +358,6 @@ struct musb_csr_regs {
 
 struct musb_context_registers {
 
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-    defined(CONFIG_ARCH_OMAP4)
-	u32 otg_forcestandby;
-#endif
 	u8 power;
 	u16 intrtxe, intrrxe;
 	u8 intrusbe;

commit 207b0e1f1655bd7008b7322cdc3f84fb171c546d
Author: Hema HK <hemahk@ti.com>
Date:   Thu Feb 17 12:07:22 2011 +0530

    usb: musb: Using runtime pm APIs for musb.
    
    Calling runtime pm APIs pm_runtime_put_sync() and pm_runtime_get_sync()
    for enabling/disabling the clocks, sysconfig settings.
    
    Enable clock, configure no-idle/standby when active and configure force idle/standby
    and disable clock when idled. This is taken care by the runtime framework when
    driver calls the pm_runtime_get_sync and pm_runtime_put_sync APIs.
    Need to configure MUSB into force standby and force idle mode when usb not used
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Cousson, Benoit <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2c8dde6d23e0..5216729bd4b2 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -360,7 +360,7 @@ struct musb_context_registers {
 
 #if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
     defined(CONFIG_ARCH_OMAP4)
-	u32 otg_sysconfig, otg_forcestandby;
+	u32 otg_forcestandby;
 #endif
 	u8 power;
 	u16 intrtxe, intrrxe;

commit ad1adb89a0d9410345d573b6995a1fa9f9b7c74a
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Feb 16 12:40:05 2011 +0200

    usb: musb: gadget: do not poke with gadget's list_head
    
    struct usb_request's list_head is supposed to be
    used only by gadget drivers, but musb is abusing
    that. Give struct musb_request its own list_head
    and prevent musb from poking into other driver's
    business.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d74a8113ae74..2c8dde6d23e0 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -328,7 +328,7 @@ struct musb_hw_ep {
 #endif
 };
 
-static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
+static inline struct musb_request *next_in_request(struct musb_hw_ep *hw_ep)
 {
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	return next_request(&hw_ep->ep_in);
@@ -337,7 +337,7 @@ static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
 #endif
 }
 
-static inline struct usb_request *next_out_request(struct musb_hw_ep *hw_ep)
+static inline struct musb_request *next_out_request(struct musb_hw_ep *hw_ep)
 {
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	return next_request(&hw_ep->ep_out);

commit 5990378b393429244559f4750f2ee3a50929b932
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Feb 11 10:00:02 2011 +0200

    usb: musb: fix build breakage
    
    commit 0662481855c389b75a0a54c32870cc90563d80a9
    (usb: musb: disable double buffering when it's broken),
    introduced a compile error when gadget API is disabled.
    
    Fix it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d74a8113ae74..e6400be8a0f8 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -488,6 +488,15 @@ struct musb {
 	unsigned		set_address:1;
 	unsigned		test_mode:1;
 	unsigned		softconnect:1;
+
+	u8			address;
+	u8			test_mode_nr;
+	u16			ackpend;		/* ep0 */
+	enum musb_g_ep0_state	ep0_state;
+	struct usb_gadget	g;			/* the gadget */
+	struct usb_gadget_driver *gadget_driver;	/* its driver */
+#endif
+
 	/*
 	 * FIXME: Remove this flag.
 	 *
@@ -501,14 +510,6 @@ struct musb {
 	 */
 	unsigned                double_buffer_not_ok:1 __deprecated;
 
-	u8			address;
-	u8			test_mode_nr;
-	u16			ackpend;		/* ep0 */
-	enum musb_g_ep0_state	ep0_state;
-	struct usb_gadget	g;			/* the gadget */
-	struct usb_gadget_driver *gadget_driver;	/* its driver */
-#endif
-
 	struct musb_hdrc_config	*config;
 
 #ifdef MUSB_CONFIG_PROC_FS

commit 9238b6d8e800f01f5cb42cc8e3e7b850ca49e83e
Merge: 85e2efbb1db9 37cd4fef6ebf e811d3272dbe
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Feb 16 11:32:38 2011 -0800

    Merge branches 'devel-cleanup', 'devel-board', 'devel-early-init' and 'devel-ti816x' into omap-for-linus

commit 0662481855c389b75a0a54c32870cc90563d80a9
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Jan 21 13:39:20 2011 +0800

    usb: musb: disable double buffering when it's broken
    
    We know that blackfin doesn't support double
    buffering feature as of today. So we add a
    flag set by musb_platform_init() to forcefully
    disable that feature.
    
    Such flag is created and marked as deprecated
    to force us to find a solution for the missing
    double buffering support on blackfin.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d0c236f8e191..d74a8113ae74 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -488,6 +488,18 @@ struct musb {
 	unsigned		set_address:1;
 	unsigned		test_mode:1;
 	unsigned		softconnect:1;
+	/*
+	 * FIXME: Remove this flag.
+	 *
+	 * This is only added to allow Blackfin to work
+	 * with current driver. For some unknown reason
+	 * Blackfin doesn't work with double buffering
+	 * and that's enabled by default.
+	 *
+	 * We added this flag to forcefully disable double
+	 * buffering until we get it working.
+	 */
+	unsigned                double_buffer_not_ok:1 __deprecated;
 
 	u8			address;
 	u8			test_mode_nr;

commit 59b479e0985f0b795d68331d6443a7f89c47768d
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jan 27 16:39:40 2011 -0800

    omap: Start using CONFIG_SOC_OMAP
    
    We want to have just CONFIG_ARCH_OMAP2, 3 and 4. The rest
    are nowadays just subcategories of these.
    
    Search and replace the following:
    
    ARCH_OMAP2420           SOC_OMAP2420
    ARCH_OMAP2430           SOC_OMAP2430
    ARCH_OMAP3430           SOC_OMAP3430
    
    No functional changes.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Thomas Weber <weber@corscience.de>
    Acked-by: Sourav Poddar <sourav.poddar@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d0c236f8e191..64b7fb1583c8 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -212,8 +212,8 @@ enum musb_g_ep0_state {
  * directly with the "flat" model, or after setting up an index register.
  */
 
-#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
-		|| defined(CONFIG_ARCH_OMAP3430) || defined(CONFIG_BLACKFIN) \
+#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_SOC_OMAP2430) \
+		|| defined(CONFIG_SOC_OMAP3430) || defined(CONFIG_BLACKFIN) \
 		|| defined(CONFIG_ARCH_OMAP4)
 /* REVISIT indexed access seemed to
  * misbehave (on DaVinci) for at least peripheral IN ...
@@ -358,7 +358,7 @@ struct musb_csr_regs {
 
 struct musb_context_registers {
 
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+#if defined(CONFIG_SOC_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
     defined(CONFIG_ARCH_OMAP4)
 	u32 otg_sysconfig, otg_forcestandby;
 #endif

commit 594632efbb9a4ac323cbf8dbf37c608d418ca8c1
Author: Hema HK <hemahk@ti.com>
Date:   Fri Dec 10 18:10:51 2010 +0530

    usb: musb: Adding musb support for OMAP4430
    
    OMAP4430 supports UTMI and ULPI types of transceiver interface.
    
    In UTMI mode: The PHY is embedded within OMAP4430. The transceiver functionality
    is split between the twl6030 PMIC chip and OMAP4430. The VBUS, ID pin
    sensing and OTG SRP generation part is integrated in TWL6030 and UTMI PHY
    functionality is embedded within the OMAP4430.
    
    There is no direct interactions between the MUSB controller and TWL6030
    chip to communicate the session-valid, session-end and ID-GND events.
    It has to be done through a software by setting/resetting bits in
    one of the control module register of OMAP4430 which in turn toggles
    the appropriate signals to MUSB controller.
    
    musb driver is register for blocking notifications from the transceiver
    driver to get the event notifications for connect/disconnect and ID-GND.
    Based on these events call the transceiver init/shutdown function to
    configure the transceiver to toggle the VBUS valid, session end and ID_GND
    signals to musb and power on/off the internal PHY.
    
    For ID_GND event notifications, toggle the ID_GND signal and then wait for
    musb to be configured as "A" device, and then call the transceiver function
    to set the VBUS.
    
    In OTG mode and musb as a host, When the Micro A connector used, VBUS is turned on
    and session bit set. When the device is connected, enumeration goes through.
    When the device disconnected from the other end of the connector(ID is still grounded),
    link will detect the disconnect and end the session. When the device is connected back,
    there are no events generated in the TWL6030-usb, and link is already down.
    So the device is not detected. Removed the session bit disable code which
    will recognize the connect of the device.
    
    Limitation: In OTG host mode, if device is connected during boot, it does not get
    detected. If disconnect and connect it back or connect after boot only it works.
    Fix for this, I will submit seperate patch later.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b9ea563d1c8e..d0c236f8e191 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -411,6 +411,7 @@ struct musb {
 
 	struct timer_list	otg_timer;
 #endif
+	struct notifier_block	nb;
 
 	struct dma_controller	*dma_controller;
 

commit 92b48df24eec49ed1eb0ec9c5f6165d8282153ea
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 14:30:06 2010 +0200

    usb: musb: drop board_set_vbus
    
    that's not used anymore. So let's drop it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9a3c71fce2b4..b9ea563d1c8e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -412,11 +412,6 @@ struct musb {
 	struct timer_list	otg_timer;
 #endif
 
-	/* called with IRQs blocked; ON/nonzero implies starting a session,
-	 * and waiting at least a_wait_vrise_tmout.
-	 */
-	void			(*board_set_vbus)(struct musb *, int is_on);
-
 	struct dma_controller	*dma_controller;
 
 	struct device		*controller;

commit 784173723e2fd23332af948a90612950964cd140
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 13:17:53 2010 +0200

    usb: musb: drop musb_platform_suspend/resume
    
    all glue layers are now fully moved to the
    new setup. We are now using dev_pm_ops to
    implement suspend/resume functionality and
    thus, musb_platform_suspend/resume has become
    deprecated and useless.
    
    This patch drops those function pointers and
    its uses.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f8efd543c5f2..9a3c71fce2b4 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -257,8 +257,6 @@ enum musb_g_ep0_state {
  * struct musb_platform_ops - Operations passed to musb_core by HW glue layer
  * @init:	turns on clocks, sets up platform-specific registers, etc
  * @exit:	undoes @init
- * @suspend:	platform-specific suspend, e.g. context save
- * @resume:	platform-specific resume, e.g. context restore
  * @set_mode:	forcefully changes operating mode
  * @try_ilde:	tries to idle the IP
  * @vbus_status: returns vbus status if possible
@@ -268,9 +266,6 @@ struct musb_platform_ops {
 	int	(*init)(struct musb *musb);
 	int	(*exit)(struct musb *musb);
 
-	int	(*suspend)(struct musb *musb);
-	int	(*resume)(struct musb *musb);
-
 	void	(*enable)(struct musb *musb);
 	void	(*disable)(struct musb *musb);
 
@@ -660,20 +655,4 @@ static inline int musb_platform_exit(struct musb *musb)
 	return musb->ops->exit(musb);
 }
 
-static inline int musb_platform_suspend(struct musb *musb)
-{
-	if (!musb->ops->suspend)
-		return 0;
-
-	return musb->ops->suspend(musb);
-}
-
-static inline int musb_platform_resume(struct musb *musb)
-{
-	if (!musb->ops->resume)
-		return 0;
-
-	return musb->ops->resume(musb);
-}
-
 #endif	/* __MUSB_CORE_H__ */

commit 496351413a227a6c0ea1a704d3d4c775d413fd08
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 12:27:35 2010 +0200

    usb: musb: drop musb_platform_save/restore_context
    
    ... that can be easily folded into the
    musb_platform_suspend/resume calls.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 1e538675ab86..f8efd543c5f2 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -603,20 +603,6 @@ extern irqreturn_t musb_interrupt(struct musb *);
 
 extern void musb_hnp_stop(struct musb *musb);
 
-#ifdef CONFIG_PM
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-    defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_BLACKFIN)
-extern void musb_platform_save_context(struct musb *musb,
-		struct musb_context_registers *musb_context);
-extern void musb_platform_restore_context(struct musb *musb,
-		struct musb_context_registers *musb_context);
-#else
-#define musb_platform_save_context(m, x)	do {} while (0)
-#define musb_platform_restore_context(m, x)	do {} while (0)
-#endif
-
-#endif
-
 static inline void musb_platform_set_vbus(struct musb *musb, int is_on)
 {
 	if (musb->ops->set_vbus)

commit fa56df915d101770a495569473b4c13b1904087b
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 10:55:29 2010 +0200

    usb: musb: drop the set_clock magic
    
    now that platform glue layer handles
    clock completely, that function is completely
    useless for us. Drop it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 6c8e9630fb19..1e538675ab86 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -455,8 +455,6 @@ struct musb {
 	u8 board_mode;		/* enum musb_mode */
 	int			(*board_set_power)(int state);
 
-	int			(*set_clock)(struct clk *clk, int is_active);
-
 	u8			min_power;	/* vbus for periph, in mA/2 */
 
 	bool			is_host;

commit 0349176120aa3024e96ae4fd7dc0e0181dc55f52
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:57:08 2010 +0200

    usb: musb: move clock handling to glue layer
    
    musb core doesn't need to know about platform
    specific details. So start moving clock
    handling to platform glue layer and make
    musb core agnostic about that.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index fac1eab3c59f..6c8e9630fb19 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -384,8 +384,6 @@ struct musb_context_registers {
 struct musb {
 	/* device lock */
 	spinlock_t		lock;
-	struct clk		*clock;
-	struct clk		*phy_clock;
 
 	const struct musb_platform_ops *ops;
 	struct musb_context_registers context;

commit f7ec94370f417fedad4db1054228ef958d48b926
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Dec 2 09:48:58 2010 +0200

    usb: musb: pass platform_ops via platform_data
    
    ... then we don't need to export any symbols
    from glue layer to musb_core.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9594b9d1d27b..fac1eab3c59f 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -281,8 +281,6 @@ struct musb_platform_ops {
 	void	(*set_vbus)(struct musb *musb, int on);
 };
 
-extern const struct musb_platform_ops musb_ops;
-
 /*
  * struct musb_hw_ep - endpoint hardware (bidirectional)
  *

commit 7c925546427a0428b84bc5ba1f28b3698e492072
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Dec 1 14:23:48 2010 +0200

    usb: musb: add Kconfig options for each glue layer
    
    This will make things simpler when choosing which
    glue layer to compile. It avoids a lot of magic
    around the "default" Kconfig option and lets the
    user choose what exactly s/he wants to compile.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index cb393e4a3722..9594b9d1d27b 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -222,7 +222,7 @@ enum musb_g_ep0_state {
 #endif
 
 /* TUSB mapping: "flat" plus ep0 special cases */
-#if	defined(CONFIG_USB_TUSB6010)
+#if	defined(CONFIG_USB_MUSB_TUSB6010)
 #define musb_ep_select(_mbase, _epnum) \
 	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
 #define	MUSB_EP_OFFSET			MUSB_TUSB_OFFSET
@@ -293,7 +293,7 @@ struct musb_hw_ep {
 	void __iomem		*fifo;
 	void __iomem		*regs;
 
-#ifdef CONFIG_USB_TUSB6010
+#ifdef CONFIG_USB_MUSB_TUSB6010
 	void __iomem		*conf;
 #endif
 
@@ -310,7 +310,7 @@ struct musb_hw_ep {
 	struct dma_channel	*tx_channel;
 	struct dma_channel	*rx_channel;
 
-#ifdef CONFIG_USB_TUSB6010
+#ifdef CONFIG_USB_MUSB_TUSB6010
 	/* TUSB has "asynchronous" and "synchronous" dma modes */
 	dma_addr_t		fifo_async;
 	dma_addr_t		fifo_sync;
@@ -432,7 +432,7 @@ struct musb {
 	void __iomem		*ctrl_base;
 	void __iomem		*mregs;
 
-#ifdef CONFIG_USB_TUSB6010
+#ifdef CONFIG_USB_MUSB_TUSB6010
 	dma_addr_t		async;
 	dma_addr_t		sync;
 	void __iomem		*sync_va;

commit 7421107b293cace2fc081731306d447ecd8517ab
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Dec 1 13:53:27 2010 +0200

    usb: musb: hold context on musb structure
    
    when we start splitting HW glue layer, it's
    gonna make it easier to re-use that structure.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 68fc76f5e316..cb393e4a3722 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -353,6 +353,33 @@ static inline struct usb_request *next_out_request(struct musb_hw_ep *hw_ep)
 #endif
 }
 
+struct musb_csr_regs {
+	/* FIFO registers */
+	u16 txmaxp, txcsr, rxmaxp, rxcsr;
+	u16 rxfifoadd, txfifoadd;
+	u8 txtype, txinterval, rxtype, rxinterval;
+	u8 rxfifosz, txfifosz;
+	u8 txfunaddr, txhubaddr, txhubport;
+	u8 rxfunaddr, rxhubaddr, rxhubport;
+};
+
+struct musb_context_registers {
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
+	u32 otg_sysconfig, otg_forcestandby;
+#endif
+	u8 power;
+	u16 intrtxe, intrrxe;
+	u8 intrusbe;
+	u16 frame;
+	u8 index, testmode;
+
+	u8 devctl, busctl, misc;
+
+	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
+};
+
 /*
  * struct musb - Driver instance data.
  */
@@ -363,6 +390,7 @@ struct musb {
 	struct clk		*phy_clock;
 
 	const struct musb_platform_ops *ops;
+	struct musb_context_registers context;
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
@@ -582,33 +610,6 @@ extern irqreturn_t musb_interrupt(struct musb *);
 extern void musb_hnp_stop(struct musb *musb);
 
 #ifdef CONFIG_PM
-struct musb_csr_regs {
-	/* FIFO registers */
-	u16 txmaxp, txcsr, rxmaxp, rxcsr;
-	u16 rxfifoadd, txfifoadd;
-	u8 txtype, txinterval, rxtype, rxinterval;
-	u8 rxfifosz, txfifosz;
-	u8 txfunaddr, txhubaddr, txhubport;
-	u8 rxfunaddr, rxhubaddr, rxhubport;
-};
-
-struct musb_context_registers {
-
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-    defined(CONFIG_ARCH_OMAP4)
-	u32 otg_sysconfig, otg_forcestandby;
-#endif
-	u8 power;
-	u16 intrtxe, intrrxe;
-	u8 intrusbe;
-	u16 frame;
-	u8 index, testmode;
-
-	u8 devctl, busctl, misc;
-
-	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
-};
-
 #if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
     defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_BLACKFIN)
 extern void musb_platform_save_context(struct musb *musb,

commit 743411b3f3e96e8ac4cae73551a0a95392fed1ea
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Dec 1 13:22:05 2010 +0200

    usb: musb: make all glue layer export struct musb_platform_ops
    
    preparing to a big refactor on musb code. We need
    to be able to compile in all glue layers (or at
    least all ARM-based ones) together and have a
    working binary.
    
    While preparing for that, we move every glue
    layer to export only one symbol, which is
    a struct musb_platform_ops, and make all
    other functions static.
    
    Later patches will come to allow for compiling
    all glue layers together and have a working
    binary.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 59928a235dc5..68fc76f5e316 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -281,6 +281,8 @@ struct musb_platform_ops {
 	void	(*set_vbus)(struct musb *musb, int on);
 };
 
+extern const struct musb_platform_ops musb_ops;
+
 /*
  * struct musb_hw_ep - endpoint hardware (bidirectional)
  *
@@ -359,6 +361,9 @@ struct musb {
 	spinlock_t		lock;
 	struct clk		*clock;
 	struct clk		*phy_clock;
+
+	const struct musb_platform_ops *ops;
+
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
 	u16			hwvers;
@@ -486,52 +491,6 @@ struct musb {
 #endif
 };
 
-#ifdef CONFIG_PM
-struct musb_csr_regs {
-	/* FIFO registers */
-	u16 txmaxp, txcsr, rxmaxp, rxcsr;
-	u16 rxfifoadd, txfifoadd;
-	u8 txtype, txinterval, rxtype, rxinterval;
-	u8 rxfifosz, txfifosz;
-	u8 txfunaddr, txhubaddr, txhubport;
-	u8 rxfunaddr, rxhubaddr, rxhubport;
-};
-
-struct musb_context_registers {
-
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-    defined(CONFIG_ARCH_OMAP4)
-	u32 otg_sysconfig, otg_forcestandby;
-#endif
-	u8 power;
-	u16 intrtxe, intrrxe;
-	u8 intrusbe;
-	u16 frame;
-	u8 index, testmode;
-
-	u8 devctl, busctl, misc;
-
-	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
-};
-
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-    defined(CONFIG_ARCH_OMAP4)
-extern void musb_platform_save_context(struct musb *musb,
-		struct musb_context_registers *musb_context);
-extern void musb_platform_restore_context(struct musb *musb,
-		struct musb_context_registers *musb_context);
-#else
-#define musb_platform_save_context(m, x)	do {} while (0)
-#define musb_platform_restore_context(m, x)	do {} while (0)
-#endif
-
-#endif
-
-static inline void musb_set_vbus(struct musb *musb, int is_on)
-{
-	musb->board_set_vbus(musb, is_on);
-}
-
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 static inline struct musb *gadget_to_musb(struct usb_gadget *g)
 {
@@ -620,29 +579,120 @@ extern void musb_load_testpacket(struct musb *);
 
 extern irqreturn_t musb_interrupt(struct musb *);
 
-extern void musb_platform_enable(struct musb *musb);
-extern void musb_platform_disable(struct musb *musb);
-
 extern void musb_hnp_stop(struct musb *musb);
 
-extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
+#ifdef CONFIG_PM
+struct musb_csr_regs {
+	/* FIFO registers */
+	u16 txmaxp, txcsr, rxmaxp, rxcsr;
+	u16 rxfifoadd, txfifoadd;
+	u8 txtype, txinterval, rxtype, rxinterval;
+	u8 rxfifosz, txfifosz;
+	u8 txfunaddr, txhubaddr, txhubport;
+	u8 rxfunaddr, rxhubaddr, rxhubport;
+};
 
-#if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN) || \
-	defined(CONFIG_ARCH_DAVINCI_DA8XX) || \
-	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
-	defined(CONFIG_ARCH_OMAP4)
-extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
-#else
-#define musb_platform_try_idle(x, y)		do {} while (0)
+struct musb_context_registers {
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
+	u32 otg_sysconfig, otg_forcestandby;
 #endif
+	u8 power;
+	u16 intrtxe, intrrxe;
+	u8 intrusbe;
+	u16 frame;
+	u8 index, testmode;
 
-#if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN)
-extern int musb_platform_get_vbus_status(struct musb *musb);
+	u8 devctl, busctl, misc;
+
+	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
+};
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_BLACKFIN)
+extern void musb_platform_save_context(struct musb *musb,
+		struct musb_context_registers *musb_context);
+extern void musb_platform_restore_context(struct musb *musb,
+		struct musb_context_registers *musb_context);
 #else
-#define musb_platform_get_vbus_status(x)	0
+#define musb_platform_save_context(m, x)	do {} while (0)
+#define musb_platform_restore_context(m, x)	do {} while (0)
 #endif
 
-extern int __init musb_platform_init(struct musb *musb);
-extern int musb_platform_exit(struct musb *musb);
+#endif
+
+static inline void musb_platform_set_vbus(struct musb *musb, int is_on)
+{
+	if (musb->ops->set_vbus)
+		musb->ops->set_vbus(musb, is_on);
+}
+
+static inline void musb_platform_enable(struct musb *musb)
+{
+	if (musb->ops->enable)
+		musb->ops->enable(musb);
+}
+
+static inline void musb_platform_disable(struct musb *musb)
+{
+	if (musb->ops->disable)
+		musb->ops->disable(musb);
+}
+
+static inline int musb_platform_set_mode(struct musb *musb, u8 mode)
+{
+	if (!musb->ops->set_mode)
+		return 0;
+
+	return musb->ops->set_mode(musb, mode);
+}
+
+static inline void musb_platform_try_idle(struct musb *musb,
+		unsigned long timeout)
+{
+	if (musb->ops->try_idle)
+		musb->ops->try_idle(musb, timeout);
+}
+
+static inline int musb_platform_get_vbus_status(struct musb *musb)
+{
+	if (!musb->ops->vbus_status)
+		return 0;
+
+	return musb->ops->vbus_status(musb);
+}
+
+static inline int musb_platform_init(struct musb *musb)
+{
+	if (!musb->ops->init)
+		return -EINVAL;
+
+	return musb->ops->init(musb);
+}
+
+static inline int musb_platform_exit(struct musb *musb)
+{
+	if (!musb->ops->exit)
+		return -EINVAL;
+
+	return musb->ops->exit(musb);
+}
+
+static inline int musb_platform_suspend(struct musb *musb)
+{
+	if (!musb->ops->suspend)
+		return 0;
+
+	return musb->ops->suspend(musb);
+}
+
+static inline int musb_platform_resume(struct musb *musb)
+{
+	if (!musb->ops->resume)
+		return 0;
+
+	return musb->ops->resume(musb);
+}
 
 #endif	/* __MUSB_CORE_H__ */

commit 3ca8abb84522f4b773678726db6ebd6fc277bc96
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Oct 21 13:56:40 2010 +0300

    usb: musb: introduce struct musb_platform_ops
    
    This will be passed to musb_core by platform glue
    layer in order to make it easier to compile support
    for several HW glue layers.
    
    Later patches will come using this structure and
    also moving HW glue layers to its own platform
    driver; the idea is to be able to handle platform
    peculiarities in a manner which doesn't affect one
    another.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 6ad72f395e28..59928a235dc5 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -253,6 +253,34 @@ enum musb_g_ep0_state {
 
 /******************************** TYPES *************************************/
 
+/**
+ * struct musb_platform_ops - Operations passed to musb_core by HW glue layer
+ * @init:	turns on clocks, sets up platform-specific registers, etc
+ * @exit:	undoes @init
+ * @suspend:	platform-specific suspend, e.g. context save
+ * @resume:	platform-specific resume, e.g. context restore
+ * @set_mode:	forcefully changes operating mode
+ * @try_ilde:	tries to idle the IP
+ * @vbus_status: returns vbus status if possible
+ * @set_vbus:	forces vbus status
+ */
+struct musb_platform_ops {
+	int	(*init)(struct musb *musb);
+	int	(*exit)(struct musb *musb);
+
+	int	(*suspend)(struct musb *musb);
+	int	(*resume)(struct musb *musb);
+
+	void	(*enable)(struct musb *musb);
+	void	(*disable)(struct musb *musb);
+
+	int	(*set_mode)(struct musb *musb, u8 mode);
+	void	(*try_idle)(struct musb *musb, unsigned long timeout);
+
+	int	(*vbus_status)(struct musb *musb);
+	void	(*set_vbus)(struct musb *musb, int on);
+};
+
 /*
  * struct musb_hw_ep - endpoint hardware (bidirectional)
  *

commit ea65df57c2eea803535a071752efb030c46a11f5
Author: Hema Kalliguddi <hemahk@ti.com>
Date:   Wed Sep 22 19:27:40 2010 -0500

    usb: musb: remove board_data parameter from musb_platform_init()
    
    Removed the board_data parameter being
    passed to musb_platform_init function
    as board_data can be extracted from
    device structure which is already member
    of musb structure.
    
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 69797e5b46a7..6ad72f395e28 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -614,7 +614,7 @@ extern int musb_platform_get_vbus_status(struct musb *musb);
 #define musb_platform_get_vbus_status(x)	0
 #endif
 
-extern int __init musb_platform_init(struct musb *musb, void *board_data);
+extern int __init musb_platform_init(struct musb *musb);
 extern int musb_platform_exit(struct musb *musb);
 
 #endif	/* __MUSB_CORE_H__ */

commit eb83092c2b24587719c917a1d6a5b682eeaa03df
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Tue Oct 19 10:08:12 2010 +0300

    USB: musb: add musb support for AM35x
    
    AM35x has musb interface and uses CPPI4.1 DMA engine.
    Current patch supports only PIO mode. DMA support can be
    added later once basic CPPI4.1 DMA patch is accepted.
    
    Also added USB_MUSB_AM35X which is required to differentiate musb ips
    between OMAP3x and AM35x. This config would be used to for below
    purposes,
            - Select am35x.c instead of omap2430.c for compilation
              at drivers/usb/musb directory. Please note there are
              significant differneces in these two files as musb ip
              in quite different on AM35x.
    
              Please note that in multi omap configuration only omap2430.c
              file will get compiled and we would require to select only
              AM35x based board config to compile am35x.c
    
            - Select workaround codes applicable for AM35x musb issues.
              one such workaround is for bytewise read issue on AM35x.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2a8236216dc7..69797e5b46a7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -330,6 +330,7 @@ struct musb {
 	/* device lock */
 	spinlock_t		lock;
 	struct clk		*clock;
+	struct clk		*phy_clock;
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
 	u16			hwvers;

commit 3ee076dea68e11d4685972df7298b80b8e7673e4
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Sep 24 13:44:03 2010 +0300

    usb: musb: introduce DA8xx/OMAP-L1x glue layer
    
    Texas Instruments DA8xx/OMAP-L1x glue layer for the
    MUSBMHRDC driver.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Yadviga Grigorieva <yadviga@ru.mvista.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 91d67794e350..2a8236216dc7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -599,6 +599,7 @@ extern void musb_hnp_stop(struct musb *musb);
 extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
 
 #if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN) || \
+	defined(CONFIG_ARCH_DAVINCI_DA8XX) || \
 	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
 	defined(CONFIG_ARCH_OMAP4)
 extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);

commit 9297688a9257d73956d4bba484d9dd331ca72c25
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Jun 24 23:07:07 2010 +0530

    USB: MUSB: make non-OMAP platforms build with CONFIG_PM=y
    
    Attempt to build MUSB driver with CONFIG_PM=y (e.g. in the OTG mode) on DaVinci
    results in these link errors:
    
    drivers/built-in.o: In function `musb_restore_context':
    led-triggers.c:(.text+0x714d8): undefined reference to
    `musb_platform_restore_context'
    drivers/built-in.o: In function `musb_save_context':
    led-triggers.c:(.text+0x71788): undefined reference to
    `musb_platform_save_context'
    
    This turned out to be caused by commit 9957dd97ec5e98dd334f87ade1d9a0b24d1f86eb
    (usb: musb: Fix compile error for omaps for musb_hdrc). Revert it, taking into
    account the rename of CONFIG_ARCH_OMAP34XX into CONFIG_ARCH_OMAP3 (which that
    commit fixed in a completely inappropriate way) and the recent addition of
    OMAP4 support.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Acked-by: Felipe Balbi <felipe.balbi@nokia.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b22d02dea7d3..91d67794e350 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -470,7 +470,8 @@ struct musb_csr_regs {
 
 struct musb_context_registers {
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
 	u32 otg_sysconfig, otg_forcestandby;
 #endif
 	u8 power;
@@ -484,7 +485,8 @@ struct musb_context_registers {
 	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
 };
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
 extern void musb_platform_save_context(struct musb *musb,
 		struct musb_context_registers *musb_context);
 extern void musb_platform_restore_context(struct musb *musb,

commit fb9c58edf13fc30d160ce52018576a1d7d45d795
Author: Maulik Mankad <x0082077@ti.com>
Date:   Fri Mar 12 10:29:09 2010 +0200

    USB: MUSB: Add OMAP4 support in MUSB driver
    
    This patch adds CONFIG_ARCH_OMAP4 macro within
    MUSB driver.
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Sergei Shtylyov <sshtylyov@mvista.com>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 136f71cbd5e3..b22d02dea7d3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -213,7 +213,8 @@ enum musb_g_ep0_state {
  */
 
 #if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
-		|| defined(CONFIG_ARCH_OMAP3430) || defined(CONFIG_BLACKFIN)
+		|| defined(CONFIG_ARCH_OMAP3430) || defined(CONFIG_BLACKFIN) \
+		|| defined(CONFIG_ARCH_OMAP4)
 /* REVISIT indexed access seemed to
  * misbehave (on DaVinci) for at least peripheral IN ...
  */
@@ -596,7 +597,8 @@ extern void musb_hnp_stop(struct musb *musb);
 extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
 
 #if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN) || \
-	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3)
+	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+	defined(CONFIG_ARCH_OMAP4)
 extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
 #else
 #define musb_platform_try_idle(x, y)		do {} while (0)

commit de2e1b0c988c901989713869a8bea3b3d02bb9ce
Author: Maulik Mankad <x0082077@ti.com>
Date:   Fri Mar 12 10:29:07 2010 +0200

    usb: musb: Set transceiver interface type
    
    Program the OTG_INTERFSEL register based on
    transcevier type passed from board file.
    
    Adapt signature of musb_platform_init() function
    for davinci, blackfin and tusb6010.
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Sergei Shtylyov <sshtylyov@mvista.com>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 1da14bf17a65..136f71cbd5e3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -608,7 +608,7 @@ extern int musb_platform_get_vbus_status(struct musb *musb);
 #define musb_platform_get_vbus_status(x)	0
 #endif
 
-extern int __init musb_platform_init(struct musb *musb);
+extern int __init musb_platform_init(struct musb *musb, void *board_data);
 extern int musb_platform_exit(struct musb *musb);
 
 #endif	/* __MUSB_CORE_H__ */

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index ac17b004909b..1da14bf17a65 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -69,7 +69,7 @@ struct musb_ep;
 #include "musb_regs.h"
 
 #include "musb_gadget.h"
-#include "../core/hcd.h"
+#include <linux/usb/hcd.h>
 #include "musb_host.h"
 
 

commit 5e0e61afa5b342c0197fce2d4fd2a2b515e96b31
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Thu Mar 25 13:14:26 2010 +0200

    musb: save and restore missing bus control register
    
    Added the missing BUS_CONTROL register in musb
    save/restore routines.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index cd9f4a9a06c6..ac17b004909b 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -478,7 +478,7 @@ struct musb_context_registers {
 	u16 frame;
 	u8 index, testmode;
 
-	u8 devctl, misc;
+	u8 devctl, busctl, misc;
 
 	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
 };

commit 9957dd97ec5e98dd334f87ade1d9a0b24d1f86eb
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 12 10:35:20 2010 +0200

    usb: musb: Fix compile error for omaps for musb_hdrc
    
    CONFIG_ARCH_OMAP34XX is now CONFIG_ARCH_OMAP3.
    
    But since drivers/usb/musb/omap2430.c use CONFIG_PM for these
    registers and functions, do the same for the header.
    
    Otherwise we get the following for most omap3 defconfigs:
    
    drivers/usb/musb/omap2430.c:261: error: expected identifier or '(' before 'do'
    drivers/usb/musb/omap2430.c:261: error: expected identifier or '(' before 'while'
    drivers/usb/musb/omap2430.c:268: error: expected identifier or '(' before 'do'
    drivers/usb/musb/omap2430.c:268: error: expected identifier or '(' before 'while'
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d849fb81c131..cd9f4a9a06c6 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -469,7 +469,7 @@ struct musb_csr_regs {
 
 struct musb_context_registers {
 
-#if defined(CONFIG_ARCH_OMAP34XX) || defined(CONFIG_ARCH_OMAP2430)
+#ifdef CONFIG_PM
 	u32 otg_sysconfig, otg_forcestandby;
 #endif
 	u8 power;
@@ -483,7 +483,7 @@ struct musb_context_registers {
 	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
 };
 
-#if defined(CONFIG_ARCH_OMAP34XX) || defined(CONFIG_ARCH_OMAP2430)
+#ifdef CONFIG_PM
 extern void musb_platform_save_context(struct musb *musb,
 		struct musb_context_registers *musb_context);
 extern void musb_platform_restore_context(struct musb *musb,

commit 7f5b09c15ab989ed5ce4adda0be42c1302df70b7
Merge: 944680802201 cedf8a784219
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 3 08:48:58 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (220 commits)
      USB: backlight, appledisplay: fix incomplete registration failure handling
      USB: pl2303: remove unnecessary reset of usb_device in urbs
      USB: ftdi_sio: remove obsolete check in unthrottle
      USB: ftdi_sio: remove unused tx_bytes counter
      USB: qcaux: driver for auxiliary serial ports on Qualcomm devices
      USB: pl2303: initial TIOCGSERIAL support
      USB: option: add Longcheer/Longsung vendor ID
      USB: fix I2C API usage in ohci-pnx4008.
      USB: usbmon: mask seconds properly in text API
      USB: sisusbvga: no unnecessary GFP_ATOMIC
      USB: storage: onetouch: unnecessary GFP_ATOMIC
      USB: serial: ftdi: add CONTEC vendor and product id
      USB: remove references to port->port.count from the serial drivers
      USB: tty: Prune uses of tty_request_room in the USB layer
      USB: tty: Add a function to insert a string of characters with the same flag
      USB: don't read past config->interface[] if usb_control_msg() fails in usb_reset_configuration()
      USB: tty: kill request_room for USB ACM class
      USB: tty: sort out the request_room handling for whiteheat
      USB: storage: fix misplaced parenthesis
      USB: vstusb.c: removal of driver for Vernier Software & Technology, Inc., devices and spectrometers
      ...

commit 0ded2f146acfaf71e5f4c15b80cf89b3af48134c
Author: Cliff Cai <cliff.cai@analog.com>
Date:   Thu Jan 28 20:43:44 2010 -0500

    USB: musb: set version of Blackfin version
    
    All current Blackfin parts are using RTL v1.9, but they don't expose the
    hardware registers to probe this dynamically.  So hardcode the version to
    v1.9 for now.
    
    Need to move the local hwvers related defines higher up in the header so
    that sub-musb headers may utilize them.
    
    Signed-off-by: Cliff Cai <cliff.cai@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 74a55b95ecbb..17e7115493ff 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -52,6 +52,15 @@ struct musb;
 struct musb_hw_ep;
 struct musb_ep;
 
+/* Helper defines for struct musb->hwvers */
+#define MUSB_HWVERS_MAJOR(x)	((x >> 10) & 0x1f)
+#define MUSB_HWVERS_MINOR(x)	(x & 0x3ff)
+#define MUSB_HWVERS_RC		0x8000
+#define MUSB_HWVERS_1300	0x52C
+#define MUSB_HWVERS_1400	0x590
+#define MUSB_HWVERS_1800	0x720
+#define MUSB_HWVERS_1900	0x784
+#define MUSB_HWVERS_2000	0x800
 
 #include "musb_debug.h"
 #include "musb_dma.h"
@@ -322,13 +331,6 @@ struct musb {
 	struct clk		*clock;
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
-#define MUSB_HWVERS_MAJOR(x)	((x >> 10) & 0x1f)
-#define MUSB_HWVERS_MINOR(x)	(x & 0x3ff)
-#define MUSB_HWVERS_RC		0x8000
-#define MUSB_HWVERS_1300	0x52C
-#define MUSB_HWVERS_1400	0x590
-#define MUSB_HWVERS_1800	0x720
-#define MUSB_HWVERS_2000	0x800
 	u16			hwvers;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */

commit 8573e6a673fc99bd89a6c08ef9841d8b52f9d3c5
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Jan 21 15:33:53 2010 +0200

    USB: musb: get rid of omap_readl/writel
    
    we have those addresses already ioremaped, so let's
    use our __raw_readl/writel wrappers.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3d66c3e01dbd..74a55b95ecbb 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -482,13 +482,13 @@ struct musb_context_registers {
 };
 
 #if defined(CONFIG_ARCH_OMAP34XX) || defined(CONFIG_ARCH_OMAP2430)
-extern void musb_platform_save_context(struct musb_context_registers
-		*musb_context);
-extern void musb_platform_restore_context(struct musb_context_registers
-		*musb_context);
+extern void musb_platform_save_context(struct musb *musb,
+		struct musb_context_registers *musb_context);
+extern void musb_platform_restore_context(struct musb *musb,
+		struct musb_context_registers *musb_context);
 #else
-#define musb_platform_save_context(x)		do {} while (0)
-#define musb_platform_restore_context(x)	do {} while (0)
+#define musb_platform_save_context(m, x)	do {} while (0)
+#define musb_platform_restore_context(m, x)	do {} while (0)
 #endif
 
 #endif

commit 4f712e010b2da1cc01c178922f2eb5aaeae461b6
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Thu Jan 21 15:33:52 2010 +0200

    usb: musb: Add context save and restore support
    
    Adding support for MUSB register save and restore during system
    suspend and resume.
    
    Changes:
            - Added musb_save/restore_context() functions
            - Added platform specific musb_platform_save/restore_context()
              to handle platform specific jobs.
            - Maintaining BlackFin compatibility by adding read/write
              functions for registers which are not available in BlackFin
    
    Tested system suspend and resume on OMAP3EVM board.
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index eaa01140183e..3d66c3e01dbd 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -454,6 +454,45 @@ struct musb {
 #endif
 };
 
+#ifdef CONFIG_PM
+struct musb_csr_regs {
+	/* FIFO registers */
+	u16 txmaxp, txcsr, rxmaxp, rxcsr;
+	u16 rxfifoadd, txfifoadd;
+	u8 txtype, txinterval, rxtype, rxinterval;
+	u8 rxfifosz, txfifosz;
+	u8 txfunaddr, txhubaddr, txhubport;
+	u8 rxfunaddr, rxhubaddr, rxhubport;
+};
+
+struct musb_context_registers {
+
+#if defined(CONFIG_ARCH_OMAP34XX) || defined(CONFIG_ARCH_OMAP2430)
+	u32 otg_sysconfig, otg_forcestandby;
+#endif
+	u8 power;
+	u16 intrtxe, intrrxe;
+	u8 intrusbe;
+	u16 frame;
+	u8 index, testmode;
+
+	u8 devctl, misc;
+
+	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
+};
+
+#if defined(CONFIG_ARCH_OMAP34XX) || defined(CONFIG_ARCH_OMAP2430)
+extern void musb_platform_save_context(struct musb_context_registers
+		*musb_context);
+extern void musb_platform_restore_context(struct musb_context_registers
+		*musb_context);
+#else
+#define musb_platform_save_context(x)		do {} while (0)
+#define musb_platform_restore_context(x)	do {} while (0)
+#endif
+
+#endif
+
 static inline void musb_set_vbus(struct musb *musb, int is_on)
 {
 	musb->board_set_vbus(musb, is_on);

commit 51bf0d0e6cc1f9679a973f61d07cb48e71f9c992
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Mon Dec 28 13:40:41 2009 +0200

    usb: musb: save dynfifo in musb struct
    
    Save dynamic FIFO read only information for later uses during
    musb_save/restore_context functions.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2ac0e6f7dd9d..eaa01140183e 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -411,6 +411,7 @@ struct musb {
 
 	unsigned		hb_iso_rx:1;	/* high bandwidth iso rx? */
 	unsigned		hb_iso_tx:1;	/* high bandwidth iso tx? */
+	unsigned		dyn_fifo:1;	/* dynamic FIFO supported? */
 
 	unsigned		bulk_split:1;
 #define	can_bulk_split(musb,type) \

commit 7ed069c12c866c5c06e4e05d26878797e3731829
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Tue Dec 15 11:08:39 2009 +0200

    USB: musb: remove some of the never defined defines
    
    just makes the musb init code a bit cleaner.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 03d50909b078..2ac0e6f7dd9d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -412,21 +412,13 @@ struct musb {
 	unsigned		hb_iso_rx:1;	/* high bandwidth iso rx? */
 	unsigned		hb_iso_tx:1;	/* high bandwidth iso tx? */
 
-#ifdef C_MP_TX
-	unsigned bulk_split:1;
+	unsigned		bulk_split:1;
 #define	can_bulk_split(musb,type) \
-		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_split)
-#else
-#define	can_bulk_split(musb, type)	0
-#endif
+	(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_split)
 
-#ifdef C_MP_RX
-	unsigned bulk_combine:1;
+	unsigned		bulk_combine:1;
 #define	can_bulk_combine(musb,type) \
-		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
-#else
-#define	can_bulk_combine(musb, type)	0
-#endif
+	(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	/* is_suspended means USB B_PERIPHERAL suspend */

commit a8eb7ca0cbb41c9cd379b8d2a2a5efb503aa65e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 12 12:26:48 2010 -0800

    omap3: Replace ARCH_OMAP34XX with ARCH_OMAP3
    
    Replace ARCH_OMAP34XX with ARCH_OMAP3
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 03d50909b078..5514c7ee85bd 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -562,7 +562,7 @@ extern void musb_hnp_stop(struct musb *musb);
 extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
 
 #if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN) || \
-	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP34XX)
+	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3)
 extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
 #else
 #define musb_platform_try_idle(x, y)		do {} while (0)

commit 32c3b94e2b643bfeca5e48b0f7f0b81812c7a1d3
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Mon Nov 16 21:09:21 2009 +0530

    USB: MUSB: save hardware revision at init
    
    MUSB: save hardware revision at init
    
    This can be used later to flag workarounds for issues affecting
    particular revisions. Saving this at init avoids having to
    read the HWVERS register multiple times in code.
    
    While at it, use macros to extract the version information
    instead of using hardcoded values.
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Cc: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Acked-by: Felipe Balbi <felipe.balbi@nokia.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 6aa5f22e5274..03d50909b078 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -322,6 +322,14 @@ struct musb {
 	struct clk		*clock;
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+#define MUSB_HWVERS_MAJOR(x)	((x >> 10) & 0x1f)
+#define MUSB_HWVERS_MINOR(x)	(x & 0x3ff)
+#define MUSB_HWVERS_RC		0x8000
+#define MUSB_HWVERS_1300	0x52C
+#define MUSB_HWVERS_1400	0x590
+#define MUSB_HWVERS_1800	0x720
+#define MUSB_HWVERS_2000	0x800
+	u16			hwvers;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
 #define MUSB_PORT_STAT_RESUME	(1 << 31)

commit b20cf90650badaa5e6ec1bdbe61a63528818e8ce
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Wed Sep 16 21:10:53 2009 -0400

    USB: musb: make HAVE_CLK support optional
    
    The Blackfin port doesn't support HAVE_CLK and the musb driver works fine
    with support stubbed out, so take the existing Blackfin clk stubs and move
    them to common musb code so we can drop the Kconfig dependency.
    
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 381d648a36b8..6aa5f22e5274 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -95,6 +95,13 @@ struct musb_ep;
 #endif
 #endif	/* need MUSB gadget selection */
 
+#ifndef CONFIG_HAVE_CLK
+/* Dummy stub for clk framework */
+#define clk_get(dev, id)	NULL
+#define clk_put(clock)		do {} while (0)
+#define clk_enable(clock)	do {} while (0)
+#define clk_disable(clock)	do {} while (0)
+#endif
 
 #ifdef CONFIG_PROC_FS
 #include <linux/fs.h>

commit 405f55712dfe464b3240d7816cc4fe4174831be2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Jul 11 22:08:37 2009 +0400

    headers: smp_lock.h redux
    
    * Remove smp_lock.h from files which don't need it (including some headers!)
    * Add smp_lock.h to files which do need it
    * Make smp_lock.h include conditional in hardirq.h
      It's needed only for one kernel_locked() usage which is under CONFIG_PREEMPT
    
      This will make hardirq.h inclusion cheaper for every PREEMPT=n config
      (which includes allmodconfig/allyesconfig, BTW)
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f3772ca3b2cf..381d648a36b8 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -38,7 +38,6 @@
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
-#include <linux/smp_lock.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <linux/clk.h>

commit a483d7068f661213e9586d4d132fc0e0287118b4
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Fri Apr 3 16:16:17 2009 -0700

    musb: add high bandwidth ISO support
    
    Tested on OMAP3 host side with Creative (Live! Cam Optia) USB camera
    which uses high bandwidth isochronous IN endpoints.  FIFO mode 4 is
    updated to provide the needed 4K endpoint buffer without breaking
    the g_nokia composite gadget configuration.  (This is the only
    gadget driver known to use enough endpoints to notice the change.)
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 78116fdb5781..f3772ca3b2cf 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -395,6 +395,9 @@ struct musb {
 	unsigned is_multipoint:1;
 	unsigned ignore_disconnect:1;	/* during bus resets */
 
+	unsigned		hb_iso_rx:1;	/* high bandwidth iso rx? */
+	unsigned		hb_iso_tx:1;	/* high bandwidth iso tx? */
+
 #ifdef C_MP_TX
 	unsigned bulk_split:1;
 #define	can_bulk_split(musb,type) \

commit f7f9d63eac12b345d6243d1d608b7944a05be921
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Mar 31 12:32:12 2009 -0700

    musb: otg timer cleanup
    
    Minor cleanup of OTG timer handling:
        * unify decls for OTG time constants, in the core header
        * set up and use that timer in a more normal way
        * move to the driver struct, so it's usable outside core
    
    And tighten use and setup of T(a_wait_bcon) so that if it's used,
    it's always valid.  (If that timer expires, the A-device will
    stop powering VBUS.  For non-OTG systems, that will be a surprise.)
    No behavioral changes, other than more consistency when applying
    that core HNP timeout.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 2b49c989f043..78116fdb5781 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -40,6 +40,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp_lock.h>
 #include <linux/errno.h>
+#include <linux/timer.h>
 #include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/usb/ch9.h>
@@ -180,10 +181,15 @@ enum musb_g_ep0_state {
 	MUSB_EP0_STAGE_ACKWAIT,		/* after zlp, before statusin */
 } __attribute__ ((packed));
 
-/* OTG protocol constants */
+/*
+ * OTG protocol constants.  See USB OTG 1.3 spec,
+ * sections 5.5 "Device Timings" and 6.6.5 "Timers".
+ */
 #define OTG_TIME_A_WAIT_VRISE	100		/* msec (max) */
-#define OTG_TIME_A_WAIT_BCON	0		/* 0=infinite; min 1000 msec */
-#define OTG_TIME_A_IDLE_BDIS	200		/* msec (min) */
+#define OTG_TIME_A_WAIT_BCON	1100		/* min 1 second */
+#define OTG_TIME_A_AIDL_BDIS	200		/* min 200 msec */
+#define OTG_TIME_B_ASE0_BRST	100		/* min 3.125 ms */
+
 
 /*************************** REGISTER ACCESS ********************************/
 
@@ -332,6 +338,8 @@ struct musb {
 	struct list_head	control;	/* of musb_qh */
 	struct list_head	in_bulk;	/* of musb_qh */
 	struct list_head	out_bulk;	/* of musb_qh */
+
+	struct timer_list	otg_timer;
 #endif
 
 	/* called with IRQs blocked; ON/nonzero implies starting a session,

commit 84e250ffa76dddc1bad84e04248a27f442c25986
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Mar 31 12:30:04 2009 -0700

    musb: proper hookup to transceiver drivers
    
    Let the otg_transceiver in MUSB be managed by an external driver;
    don't assume it's integrated.  OMAP3 chips need it to be external,
    and there may be ways to interact with the transceiver which add
    functionality to the system.
    
    Platform init code is responsible for setting up the transeciver,
    probably using the NOP transceiver for integrated transceivers.
    External ones will use whatever the board init code provided,
    such as twl4030 or something more hands-off.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index c2a776ee1947..2b49c989f043 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -356,7 +356,7 @@ struct musb {
 	u16			int_rx;
 	u16			int_tx;
 
-	struct otg_transceiver	xceiv;
+	struct otg_transceiver	*xceiv;
 
 	int nIrq;
 	unsigned		irq_wake:1;

commit a5073b52833e4df8e16c93dc4cbb7e0c558c74a2
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Mar 27 12:52:43 2009 -0700

    musb_gadget: fix unhandled endpoint 0 IRQs
    
    The gadget EP0 code routinely ignores an interrupt at end of
    the data phase because of musb_g_ep0_giveback() resetting the
    state machine to "idle, waiting for SETUP" phase prematurely.
    
    The driver also prematurely leaves the status phase on
    receiving the SetupEnd interrupt.
    
    As there were still unhandled endpoint 0 interrupts happening
    from time to time after fixing these issues, there turned to
    be yet another culprit: two distinct gadget states collapsed
    into one.
    
    The (missing) state that comes after STATUS IN/OUT states was
    typically indiscernible from them since the corresponding
    interrupts tend to happen within too little period of time
    (due to only a zero-length status packet in between) and so
    they got coalesced; yet this state is not the same as the next
    one which is associated with the reception of a SETUP packet.
    
    Adding this extra state seems to have fixed the rest of the
    unhandled interrupts that generic_interrupt() and
    davinci_interrupt() hid by faking their result and only
    emitting a debug message -- so, stop doing that.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index efb39b5e55b5..c2a776ee1947 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -171,7 +171,8 @@ enum musb_h_ep0_state {
 
 /* peripheral side ep0 states */
 enum musb_g_ep0_state {
-	MUSB_EP0_STAGE_SETUP,		/* idle, waiting for setup */
+	MUSB_EP0_STAGE_IDLE,		/* idle, waiting for SETUP */
+	MUSB_EP0_STAGE_SETUP,		/* received SETUP */
 	MUSB_EP0_STAGE_TX,		/* IN data */
 	MUSB_EP0_STAGE_RX,		/* OUT data */
 	MUSB_EP0_STAGE_STATUSIN,	/* (after OUT data) */

commit 322337168f22e8245aae7f38e84c5711cd4c1265
Author: Giuseppe GORGOGLIONE <giuseppe.gorgoglione@st.com>
Date:   Tue Feb 24 15:27:34 2009 -0800

    USB: musb: fix init oops crash with static FIFO config
    
    Correct musb_read_fifosize() and musb_configure_ep0() functions
    for the #ifndef BLACKFIN branch when the silicon uses static FIFO
    configuration.  (Most current silicon configures this controller
    to use dynamic FIFO configuration; some parts from ST don't, like
    the STM STA2062.)
    
    Signed-off-by: Giuseppe GORGOGLIONE <giuseppe.gorgoglione@st.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index adf1806007ff..efb39b5e55b5 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -478,10 +478,11 @@ static inline void musb_configure_ep0(struct musb *musb)
 static inline int musb_read_fifosize(struct musb *musb,
 		struct musb_hw_ep *hw_ep, u8 epnum)
 {
+	void *mbase = musb->mregs;
 	u8 reg = 0;
 
 	/* read from core using indexed model */
-	reg = musb_readb(hw_ep->regs, 0x10 + MUSB_FIFOSIZE);
+	reg = musb_readb(mbase, MUSB_EP_OFFSET(epnum, MUSB_FIFOSIZE));
 	/* 0's returned when no more endpoints */
 	if (!reg)
 		return -ENODEV;
@@ -508,6 +509,7 @@ static inline void musb_configure_ep0(struct musb *musb)
 {
 	musb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;
 	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
+	musb->endpoints[0].is_shared_fifo = true;
 }
 #endif /* CONFIG_BLACKFIN */
 

commit 5d67a851bca63d30cde0474bfc4fc4f03db1a1b8
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Feb 24 15:23:34 2009 -0800

    USB: musb: rewrite host periodic endpoint allocation
    
    The current MUSB host code doesn't make use of all the available
    FIFOs in for periodic transfers since it wrongly assumes the RX
    and TX sides of any given hw_ep always share one FIFO.
    
    Change:  use 'in_qh' and 'out_qh' fields of the 'struct musb_hw_ep'
    to check the endpoint's business; get rid of the now-unused 'periodic'
    array in the 'struct musb'.  Also optimize a loop induction variable
    in the endpoint lookup code.
    
    (Based on a previous patch from Ajay Kumar Gupta <ajay.gupta@ti.com>)
    
    [ dbrownell@users.sourceforge.net: clarify description and origin
      of this fix; whitespace ]
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 630946a2d9fc..adf1806007ff 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -331,7 +331,6 @@ struct musb {
 	struct list_head	control;	/* of musb_qh */
 	struct list_head	in_bulk;	/* of musb_qh */
 	struct list_head	out_bulk;	/* of musb_qh */
-	struct musb_qh		*periodic[32];	/* tree of interrupt+iso */
 #endif
 
 	/* called with IRQs blocked; ON/nonzero implies starting a session,

commit c6cf8b003e5a37f8193c2883876c5942adcd7284
Author: Bryan Wu <cooloney@kernel.org>
Date:   Tue Dec 2 21:33:48 2008 +0200

    USB: musb: add Blackfin specific configuration to MUSB
    
    Some config registers are not avaiable in Blackfin, we have to comment them out.
    
    v1-v2:
     - remove Blackfin specific header file
     - add Blackfin register version to musb_regs.h header file
    
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index d45d258e63f0..630946a2d9fc 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -191,7 +191,7 @@ enum musb_g_ep0_state {
  */
 
 #if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
-		|| defined(CONFIG_ARCH_OMAP3430)
+		|| defined(CONFIG_ARCH_OMAP3430) || defined(CONFIG_BLACKFIN)
 /* REVISIT indexed access seemed to
  * misbehave (on DaVinci) for at least peripheral IN ...
  */
@@ -448,6 +448,70 @@ static inline struct musb *gadget_to_musb(struct usb_gadget *g)
 }
 #endif
 
+#ifdef CONFIG_BLACKFIN
+static inline int musb_read_fifosize(struct musb *musb,
+		struct musb_hw_ep *hw_ep, u8 epnum)
+{
+	musb->nr_endpoints++;
+	musb->epmask |= (1 << epnum);
+
+	if (epnum < 5) {
+		hw_ep->max_packet_sz_tx = 128;
+		hw_ep->max_packet_sz_rx = 128;
+	} else {
+		hw_ep->max_packet_sz_tx = 1024;
+		hw_ep->max_packet_sz_rx = 1024;
+	}
+	hw_ep->is_shared_fifo = false;
+
+	return 0;
+}
+
+static inline void musb_configure_ep0(struct musb *musb)
+{
+	musb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;
+	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
+	musb->endpoints[0].is_shared_fifo = true;
+}
+
+#else
+
+static inline int musb_read_fifosize(struct musb *musb,
+		struct musb_hw_ep *hw_ep, u8 epnum)
+{
+	u8 reg = 0;
+
+	/* read from core using indexed model */
+	reg = musb_readb(hw_ep->regs, 0x10 + MUSB_FIFOSIZE);
+	/* 0's returned when no more endpoints */
+	if (!reg)
+		return -ENODEV;
+
+	musb->nr_endpoints++;
+	musb->epmask |= (1 << epnum);
+
+	hw_ep->max_packet_sz_tx = 1 << (reg & 0x0f);
+
+	/* shared TX/RX FIFO? */
+	if ((reg & 0xf0) == 0xf0) {
+		hw_ep->max_packet_sz_rx = hw_ep->max_packet_sz_tx;
+		hw_ep->is_shared_fifo = true;
+		return 0;
+	} else {
+		hw_ep->max_packet_sz_rx = 1 << ((reg & 0xf0) >> 4);
+		hw_ep->is_shared_fifo = false;
+	}
+
+	return 0;
+}
+
+static inline void musb_configure_ep0(struct musb *musb)
+{
+	musb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;
+	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
+}
+#endif /* CONFIG_BLACKFIN */
+
 
 /***************************** Glue it together *****************************/
 
@@ -470,14 +534,14 @@ extern void musb_hnp_stop(struct musb *musb);
 
 extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
 
-#if defined(CONFIG_USB_TUSB6010) || \
+#if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN) || \
 	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP34XX)
 extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
 #else
 #define musb_platform_try_idle(x, y)		do {} while (0)
 #endif
 
-#ifdef CONFIG_USB_TUSB6010
+#if defined(CONFIG_USB_TUSB6010) || defined(CONFIG_BLACKFIN)
 extern int musb_platform_get_vbus_status(struct musb *musb);
 #else
 #define musb_platform_get_vbus_status(x)	0

commit c48a5155252fd9cba7bedc59e5f8a339a3454d58
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Mon Nov 24 13:06:53 2008 +0200

    USB: musb: check if set_irq_wake succeded and remember it
    
    Without it, in platforms that don't provide irq_chip.set_wake(),
    like omap, musb will WARN() on driver removal.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index b3d605073071..d45d258e63f0 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -359,6 +359,7 @@ struct musb {
 	struct otg_transceiver	xceiv;
 
 	int nIrq;
+	unsigned		irq_wake:1;
 
 	struct musb_hw_ep	 endpoints[MUSB_C_NUM_EPS];
 #define control_ep		endpoints

commit 96a274d1da950a96cb31ac1bed044e049d770980
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Nov 24 13:06:47 2008 +0200

    USB: musb: sysfs mode updates
    
    Fix three omissions in the "mode" sysfs attribute support:
      (a) inability to report errors;
      (b) no DaVinci support ... just report an error;
      (c) for omap2430, accepting unsupportable values
    
    The 2430 stuff is still odd....
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 82227251931b..b3d605073071 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -467,7 +467,7 @@ extern void musb_platform_disable(struct musb *musb);
 
 extern void musb_hnp_stop(struct musb *musb);
 
-extern void musb_platform_set_mode(struct musb *musb, u8 musb_mode);
+extern int musb_platform_set_mode(struct musb *musb, u8 musb_mode);
 
 #if defined(CONFIG_USB_TUSB6010) || \
 	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP34XX)

commit 746cdd0b2d1254b11382789b6630c4d379bdcf13
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Sun Aug 10 21:22:34 2008 +0300

    usb: musb: get rid of procfs entry
    
    Drivers should not add procfs. The functionality in the old
    procfs file will be moved to debugfs.
    
    Cc: Anand Gadiyar <gadiyar@ti.com>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index eade46d81708..82227251931b 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -485,23 +485,4 @@ extern int musb_platform_get_vbus_status(struct musb *musb);
 extern int __init musb_platform_init(struct musb *musb);
 extern int musb_platform_exit(struct musb *musb);
 
-/*-------------------------- ProcFS definitions ---------------------*/
-
-struct proc_dir_entry;
-
-#if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
-extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
-extern void musb_debug_delete(char *name, struct musb *data);
-
-#else
-static inline struct proc_dir_entry *
-musb_debug_create(char *name, struct musb *data)
-{
-	return NULL;
-}
-static inline void musb_debug_delete(char *name, struct musb *data)
-{
-}
-#endif
-
 #endif	/* __MUSB_CORE_H__ */

commit ca6d1b1333bc2e61e37982de1f28d8604c232414
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Fri Aug 8 12:40:54 2008 +0300

    usb: musb: pass configuration specifics via pdata
    
    Use platform_data to pass musb configuration-specific
    details to musb driver.
    
    This patch will prevent that other platforms selecting
    HAVE_CLK and enabling musb won't break tree building.
    
    The other parts of it will come when linux-omap merge
    up more omap2/3 board-files.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 90035c12ab5f..eade46d81708 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -56,18 +56,6 @@ struct musb_ep;
 #include "musb_debug.h"
 #include "musb_dma.h"
 
-#ifdef CONFIG_USB_MUSB_SOC
-/*
- * Get core configuration from a header converted (by cfg_conv)
- * from the Verilog config file generated by the core config utility
- *
- * For now we assume that header is provided along with other
- * arch-specific files.  Discrete chips will need a build tweak.
- * So will using AHB IDs from silicon that provides them.
- */
-#include <asm/arch/hdrc_cnf.h>
-#endif
-
 #include "musb_io.h"
 #include "musb_regs.h"
 
@@ -440,6 +428,8 @@ struct musb {
 	struct usb_gadget_driver *gadget_driver;	/* its driver */
 #endif
 
+	struct musb_hdrc_config	*config;
+
 #ifdef MUSB_CONFIG_PROC_FS
 	struct proc_dir_entry *proc_entry;
 #endif

commit 550a7375fe720924241f0eb76e4a5c1a3eb8c32f
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Jul 24 12:27:36 2008 +0300

    USB: Add MUSB and TUSB support
    
    This patch adds support for MUSB and TUSB controllers
    integrated into omap2430 and davinci. It also adds support
    for external tusb6010 controller.
    
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
new file mode 100644
index 000000000000..90035c12ab5f
--- /dev/null
+++ b/drivers/usb/musb/musb_core.h
@@ -0,0 +1,517 @@
+/*
+ * MUSB OTG driver defines
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_CORE_H__
+#define __MUSB_CORE_H__
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/musb.h>
+
+struct musb;
+struct musb_hw_ep;
+struct musb_ep;
+
+
+#include "musb_debug.h"
+#include "musb_dma.h"
+
+#ifdef CONFIG_USB_MUSB_SOC
+/*
+ * Get core configuration from a header converted (by cfg_conv)
+ * from the Verilog config file generated by the core config utility
+ *
+ * For now we assume that header is provided along with other
+ * arch-specific files.  Discrete chips will need a build tweak.
+ * So will using AHB IDs from silicon that provides them.
+ */
+#include <asm/arch/hdrc_cnf.h>
+#endif
+
+#include "musb_io.h"
+#include "musb_regs.h"
+
+#include "musb_gadget.h"
+#include "../core/hcd.h"
+#include "musb_host.h"
+
+
+
+#ifdef CONFIG_USB_MUSB_OTG
+
+#define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
+#define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
+#define	is_otg_enabled(musb)		((musb)->board_mode == MUSB_OTG)
+
+/* NOTE:  otg and peripheral-only state machines start at B_IDLE.
+ * OTG or host-only go to A_IDLE when ID is sensed.
+ */
+#define is_peripheral_active(m)		(!(m)->is_host)
+#define is_host_active(m)		((m)->is_host)
+
+#else
+#define	is_peripheral_enabled(musb)	is_peripheral_capable()
+#define	is_host_enabled(musb)		is_host_capable()
+#define	is_otg_enabled(musb)		0
+
+#define	is_peripheral_active(musb)	is_peripheral_capable()
+#define	is_host_active(musb)		is_host_capable()
+#endif
+
+#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_PERIPHERAL)
+/* for some reason, the "select USB_GADGET_MUSB_HDRC" doesn't always
+ * override that choice selection (often USB_GADGET_DUMMY_HCD).
+ */
+#ifndef CONFIG_USB_GADGET_MUSB_HDRC
+#error bogus Kconfig output ... select CONFIG_USB_GADGET_MUSB_HDRC
+#endif
+#endif	/* need MUSB gadget selection */
+
+
+#ifdef CONFIG_PROC_FS
+#include <linux/fs.h>
+#define MUSB_CONFIG_PROC_FS
+#endif
+
+/****************************** PERIPHERAL ROLE *****************************/
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+
+#define	is_peripheral_capable()	(1)
+
+extern irqreturn_t musb_g_ep0_irq(struct musb *);
+extern void musb_g_tx(struct musb *, u8);
+extern void musb_g_rx(struct musb *, u8);
+extern void musb_g_reset(struct musb *);
+extern void musb_g_suspend(struct musb *);
+extern void musb_g_resume(struct musb *);
+extern void musb_g_wakeup(struct musb *);
+extern void musb_g_disconnect(struct musb *);
+
+#else
+
+#define	is_peripheral_capable()	(0)
+
+static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
+static inline void musb_g_reset(struct musb *m) {}
+static inline void musb_g_suspend(struct musb *m) {}
+static inline void musb_g_resume(struct musb *m) {}
+static inline void musb_g_wakeup(struct musb *m) {}
+static inline void musb_g_disconnect(struct musb *m) {}
+
+#endif
+
+/****************************** HOST ROLE ***********************************/
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+
+#define	is_host_capable()	(1)
+
+extern irqreturn_t musb_h_ep0_irq(struct musb *);
+extern void musb_host_tx(struct musb *, u8);
+extern void musb_host_rx(struct musb *, u8);
+
+#else
+
+#define	is_host_capable()	(0)
+
+static inline irqreturn_t musb_h_ep0_irq(struct musb *m) { return IRQ_NONE; }
+static inline void musb_host_tx(struct musb *m, u8 e) {}
+static inline void musb_host_rx(struct musb *m, u8 e) {}
+
+#endif
+
+
+/****************************** CONSTANTS ********************************/
+
+#ifndef MUSB_C_NUM_EPS
+#define MUSB_C_NUM_EPS ((u8)16)
+#endif
+
+#ifndef MUSB_MAX_END0_PACKET
+#define MUSB_MAX_END0_PACKET ((u16)MUSB_EP0_FIFOSIZE)
+#endif
+
+/* host side ep0 states */
+enum musb_h_ep0_state {
+	MUSB_EP0_IDLE,
+	MUSB_EP0_START,			/* expect ack of setup */
+	MUSB_EP0_IN,			/* expect IN DATA */
+	MUSB_EP0_OUT,			/* expect ack of OUT DATA */
+	MUSB_EP0_STATUS,		/* expect ack of STATUS */
+} __attribute__ ((packed));
+
+/* peripheral side ep0 states */
+enum musb_g_ep0_state {
+	MUSB_EP0_STAGE_SETUP,		/* idle, waiting for setup */
+	MUSB_EP0_STAGE_TX,		/* IN data */
+	MUSB_EP0_STAGE_RX,		/* OUT data */
+	MUSB_EP0_STAGE_STATUSIN,	/* (after OUT data) */
+	MUSB_EP0_STAGE_STATUSOUT,	/* (after IN data) */
+	MUSB_EP0_STAGE_ACKWAIT,		/* after zlp, before statusin */
+} __attribute__ ((packed));
+
+/* OTG protocol constants */
+#define OTG_TIME_A_WAIT_VRISE	100		/* msec (max) */
+#define OTG_TIME_A_WAIT_BCON	0		/* 0=infinite; min 1000 msec */
+#define OTG_TIME_A_IDLE_BDIS	200		/* msec (min) */
+
+/*************************** REGISTER ACCESS ********************************/
+
+/* Endpoint registers (other than dynfifo setup) can be accessed either
+ * directly with the "flat" model, or after setting up an index register.
+ */
+
+#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
+		|| defined(CONFIG_ARCH_OMAP3430)
+/* REVISIT indexed access seemed to
+ * misbehave (on DaVinci) for at least peripheral IN ...
+ */
+#define	MUSB_FLAT_REG
+#endif
+
+/* TUSB mapping: "flat" plus ep0 special cases */
+#if	defined(CONFIG_USB_TUSB6010)
+#define musb_ep_select(_mbase, _epnum) \
+	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
+#define	MUSB_EP_OFFSET			MUSB_TUSB_OFFSET
+
+/* "flat" mapping: each endpoint has its own i/o address */
+#elif	defined(MUSB_FLAT_REG)
+#define musb_ep_select(_mbase, _epnum)	(((void)(_mbase)), ((void)(_epnum)))
+#define	MUSB_EP_OFFSET			MUSB_FLAT_OFFSET
+
+/* "indexed" mapping: INDEX register controls register bank select */
+#else
+#define musb_ep_select(_mbase, _epnum) \
+	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
+#define	MUSB_EP_OFFSET			MUSB_INDEXED_OFFSET
+#endif
+
+/****************************** FUNCTIONS ********************************/
+
+#define MUSB_HST_MODE(_musb)\
+	{ (_musb)->is_host = true; }
+#define MUSB_DEV_MODE(_musb) \
+	{ (_musb)->is_host = false; }
+
+#define test_devctl_hst_mode(_x) \
+	(musb_readb((_x)->mregs, MUSB_DEVCTL)&MUSB_DEVCTL_HM)
+
+#define MUSB_MODE(musb) ((musb)->is_host ? "Host" : "Peripheral")
+
+/******************************** TYPES *************************************/
+
+/*
+ * struct musb_hw_ep - endpoint hardware (bidirectional)
+ *
+ * Ordered slightly for better cacheline locality.
+ */
+struct musb_hw_ep {
+	struct musb		*musb;
+	void __iomem		*fifo;
+	void __iomem		*regs;
+
+#ifdef CONFIG_USB_TUSB6010
+	void __iomem		*conf;
+#endif
+
+	/* index in musb->endpoints[]  */
+	u8			epnum;
+
+	/* hardware configuration, possibly dynamic */
+	bool			is_shared_fifo;
+	bool			tx_double_buffered;
+	bool			rx_double_buffered;
+	u16			max_packet_sz_tx;
+	u16			max_packet_sz_rx;
+
+	struct dma_channel	*tx_channel;
+	struct dma_channel	*rx_channel;
+
+#ifdef CONFIG_USB_TUSB6010
+	/* TUSB has "asynchronous" and "synchronous" dma modes */
+	dma_addr_t		fifo_async;
+	dma_addr_t		fifo_sync;
+	void __iomem		*fifo_sync_va;
+#endif
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	void __iomem		*target_regs;
+
+	/* currently scheduled peripheral endpoint */
+	struct musb_qh		*in_qh;
+	struct musb_qh		*out_qh;
+
+	u8			rx_reinit;
+	u8			tx_reinit;
+#endif
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* peripheral side */
+	struct musb_ep		ep_in;			/* TX */
+	struct musb_ep		ep_out;			/* RX */
+#endif
+};
+
+static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
+{
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	return next_request(&hw_ep->ep_in);
+#else
+	return NULL;
+#endif
+}
+
+static inline struct usb_request *next_out_request(struct musb_hw_ep *hw_ep)
+{
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	return next_request(&hw_ep->ep_out);
+#else
+	return NULL;
+#endif
+}
+
+/*
+ * struct musb - Driver instance data.
+ */
+struct musb {
+	/* device lock */
+	spinlock_t		lock;
+	struct clk		*clock;
+	irqreturn_t		(*isr)(int, void *);
+	struct work_struct	irq_work;
+
+/* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
+#define MUSB_PORT_STAT_RESUME	(1 << 31)
+
+	u32			port1_status;
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	unsigned long		rh_timer;
+
+	enum musb_h_ep0_state	ep0_stage;
+
+	/* bulk traffic normally dedicates endpoint hardware, and each
+	 * direction has its own ring of host side endpoints.
+	 * we try to progress the transfer at the head of each endpoint's
+	 * queue until it completes or NAKs too much; then we try the next
+	 * endpoint.
+	 */
+	struct musb_hw_ep	*bulk_ep;
+
+	struct list_head	control;	/* of musb_qh */
+	struct list_head	in_bulk;	/* of musb_qh */
+	struct list_head	out_bulk;	/* of musb_qh */
+	struct musb_qh		*periodic[32];	/* tree of interrupt+iso */
+#endif
+
+	/* called with IRQs blocked; ON/nonzero implies starting a session,
+	 * and waiting at least a_wait_vrise_tmout.
+	 */
+	void			(*board_set_vbus)(struct musb *, int is_on);
+
+	struct dma_controller	*dma_controller;
+
+	struct device		*controller;
+	void __iomem		*ctrl_base;
+	void __iomem		*mregs;
+
+#ifdef CONFIG_USB_TUSB6010
+	dma_addr_t		async;
+	dma_addr_t		sync;
+	void __iomem		*sync_va;
+#endif
+
+	/* passed down from chip/board specific irq handlers */
+	u8			int_usb;
+	u16			int_rx;
+	u16			int_tx;
+
+	struct otg_transceiver	xceiv;
+
+	int nIrq;
+
+	struct musb_hw_ep	 endpoints[MUSB_C_NUM_EPS];
+#define control_ep		endpoints
+
+#define VBUSERR_RETRY_COUNT	3
+	u16			vbuserr_retry;
+	u16 epmask;
+	u8 nr_endpoints;
+
+	u8 board_mode;		/* enum musb_mode */
+	int			(*board_set_power)(int state);
+
+	int			(*set_clock)(struct clk *clk, int is_active);
+
+	u8			min_power;	/* vbus for periph, in mA/2 */
+
+	bool			is_host;
+
+	int			a_wait_bcon;	/* VBUS timeout in msecs */
+	unsigned long		idle_timeout;	/* Next timeout in jiffies */
+
+	/* active means connected and not suspended */
+	unsigned		is_active:1;
+
+	unsigned is_multipoint:1;
+	unsigned ignore_disconnect:1;	/* during bus resets */
+
+#ifdef C_MP_TX
+	unsigned bulk_split:1;
+#define	can_bulk_split(musb,type) \
+		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_split)
+#else
+#define	can_bulk_split(musb, type)	0
+#endif
+
+#ifdef C_MP_RX
+	unsigned bulk_combine:1;
+#define	can_bulk_combine(musb,type) \
+		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
+#else
+#define	can_bulk_combine(musb, type)	0
+#endif
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* is_suspended means USB B_PERIPHERAL suspend */
+	unsigned		is_suspended:1;
+
+	/* may_wakeup means remote wakeup is enabled */
+	unsigned		may_wakeup:1;
+
+	/* is_self_powered is reported in device status and the
+	 * config descriptor.  is_bus_powered means B_PERIPHERAL
+	 * draws some VBUS current; both can be true.
+	 */
+	unsigned		is_self_powered:1;
+	unsigned		is_bus_powered:1;
+
+	unsigned		set_address:1;
+	unsigned		test_mode:1;
+	unsigned		softconnect:1;
+
+	u8			address;
+	u8			test_mode_nr;
+	u16			ackpend;		/* ep0 */
+	enum musb_g_ep0_state	ep0_state;
+	struct usb_gadget	g;			/* the gadget */
+	struct usb_gadget_driver *gadget_driver;	/* its driver */
+#endif
+
+#ifdef MUSB_CONFIG_PROC_FS
+	struct proc_dir_entry *proc_entry;
+#endif
+};
+
+static inline void musb_set_vbus(struct musb *musb, int is_on)
+{
+	musb->board_set_vbus(musb, is_on);
+}
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+static inline struct musb *gadget_to_musb(struct usb_gadget *g)
+{
+	return container_of(g, struct musb, g);
+}
+#endif
+
+
+/***************************** Glue it together *****************************/
+
+extern const char musb_driver_name[];
+
+extern void musb_start(struct musb *musb);
+extern void musb_stop(struct musb *musb);
+
+extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
+extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);
+
+extern void musb_load_testpacket(struct musb *);
+
+extern irqreturn_t musb_interrupt(struct musb *);
+
+extern void musb_platform_enable(struct musb *musb);
+extern void musb_platform_disable(struct musb *musb);
+
+extern void musb_hnp_stop(struct musb *musb);
+
+extern void musb_platform_set_mode(struct musb *musb, u8 musb_mode);
+
+#if defined(CONFIG_USB_TUSB6010) || \
+	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP34XX)
+extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
+#else
+#define musb_platform_try_idle(x, y)		do {} while (0)
+#endif
+
+#ifdef CONFIG_USB_TUSB6010
+extern int musb_platform_get_vbus_status(struct musb *musb);
+#else
+#define musb_platform_get_vbus_status(x)	0
+#endif
+
+extern int __init musb_platform_init(struct musb *musb);
+extern int musb_platform_exit(struct musb *musb);
+
+/*-------------------------- ProcFS definitions ---------------------*/
+
+struct proc_dir_entry;
+
+#if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
+extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
+extern void musb_debug_delete(char *name, struct musb *data);
+
+#else
+static inline struct proc_dir_entry *
+musb_debug_create(char *name, struct musb *data)
+{
+	return NULL;
+}
+static inline void musb_debug_delete(char *name, struct musb *data)
+{
+}
+#endif
+
+#endif	/* __MUSB_CORE_H__ */
