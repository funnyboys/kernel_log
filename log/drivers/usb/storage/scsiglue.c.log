commit f8c63edfd78905320e86b6b2be2b7a5ac768fa4e
Author: Fredrik Noring <noring@nocrew.org>
Date:   Tue Dec 10 18:29:05 2019 +0100

    USB: Fix incorrect DMA allocations for local memory pool drivers
    
    Fix commit 7b81cb6bddd2 ("usb: add a HCD_DMA flag instead of
    guestimating DMA capabilities") where local memory USB drivers
    erroneously allocate DMA memory instead of pool memory, causing
    
            OHCI Unrecoverable Error, disabled
            HC died; cleaning up
    
    The order between hcd_uses_dma() and hcd->localmem_pool is now
    arranged as in hcd_buffer_alloc() and hcd_buffer_free(), with the
    test for hcd->localmem_pool placed first.
    
    As an alternative, one might consider adjusting hcd_uses_dma() with
    
     static inline bool hcd_uses_dma(struct usb_hcd *hcd)
     {
    -       return IS_ENABLED(CONFIG_HAS_DMA) && (hcd->driver->flags & HCD_DMA);
    +       return IS_ENABLED(CONFIG_HAS_DMA) &&
    +               (hcd->driver->flags & HCD_DMA) &&
    +               (hcd->localmem_pool == NULL);
     }
    
    One can also consider unsetting HCD_DMA for local memory pool drivers.
    
    Fixes: 7b81cb6bddd2 ("usb: add a HCD_DMA flag instead of guestimating DMA capabilities")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Fredrik Noring <noring@nocrew.org>
    Link: https://lore.kernel.org/r/20191210172905.GA52526@sx9
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 66a4dcbbb1fc..f4c2359abb1b 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -135,7 +135,8 @@ static int slave_configure(struct scsi_device *sdev)
 	 * For such controllers we need to make sure the block layer sets
 	 * up bounce buffers in addressable memory.
 	 */
-	if (!hcd_uses_dma(bus_to_hcd(us->pusb_dev->bus)))
+	if (!hcd_uses_dma(bus_to_hcd(us->pusb_dev->bus)) ||
+			(bus_to_hcd(us->pusb_dev->bus)->localmem_pool != NULL))
 		blk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);
 
 	/*

commit 16c8373ecf7b3c723a8e765d798ea413bc8345a6
Merge: d19f1d44e743 a99d8080aaf3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 4 06:41:09 2019 +0100

    Merge 5.4-rc6 into usb-next
    
    We need the USB fixes in here to build on top of.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a976949613132977098fc49510b46fa8678d864
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 21 11:48:06 2019 -0400

    usb-storage: Revert commit 747668dbc061 ("usb-storage: Set virt_boundary_mask to avoid SG overflows")
    
    Commit 747668dbc061 ("usb-storage: Set virt_boundary_mask to avoid SG
    overflows") attempted to solve a problem involving scatter-gather I/O
    and USB/IP by setting the virt_boundary_mask for mass-storage devices.
    
    However, it now turns out that this interacts badly with commit
    09324d32d2a0 ("block: force an unlimited segment size on queues with a
    virt boundary"), which was added later.  A typical error message is:
    
            ehci-pci 0000:00:13.2: swiotlb buffer is full (sz: 327680 bytes),
            total 32768 (slots), used 97 (slots)
    
    There is no longer any reason to keep the virt_boundary_mask setting
    for usb-storage.  It was needed in the first place only for handling
    devices with a block size smaller than the maxpacket size and where
    the host controller was not capable of fully general scatter-gather
    operation (that is, able to merge two SG segments into a single USB
    packet).  But:
    
            High-speed or slower connections never use a bulk maxpacket
            value larger than 512;
    
            The SCSI layer does not handle block devices with a block size
            smaller than 512 bytes;
    
            All the host controllers capable of SuperSpeed operation can
            handle fully general SG;
    
            Since commit ea44d190764b ("usbip: Implement SG support to
            vhci-hcd and stub driver") was merged, the USB/IP driver can
            also handle SG.
    
    Therefore all supported device/controller combinations should be okay
    with no need for any special virt_boundary_mask.  So in order to fix
    the swiotlb problem, this patch reverts commit 747668dbc061.
    
    Reported-and-tested-by: Piergiorgio Sartor <piergiorgio.sartor@nexgo.de>
    Link: https://marc.info/?l=linux-usb&m=157134199501202&w=2
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Seth Bollinger <Seth.Bollinger@digi.com>
    CC: <stable@vger.kernel.org>
    Fixes: 747668dbc061 ("usb-storage: Set virt_boundary_mask to avoid SG overflows")
    Acked-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1910211145520.1673-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 6737fab94959..54a3c8195c96 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -68,7 +68,6 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
-	int maxp;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -77,15 +76,6 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	sdev->inquiry_len = 36;
 
-	/*
-	 * USB has unusual scatter-gather requirements: the length of each
-	 * scatterlist element except the last must be divisible by the
-	 * Bulk maxpacket value.  Fortunately this value is always a
-	 * power of 2.  Inform the block layer about this requirement.
-	 */
-	maxp = usb_maxpacket(us->pusb_dev, us->recv_bulk_pipe, 0);
-	blk_queue_virt_boundary(sdev->request_queue, maxp - 1);
-
 	/*
 	 * Some host controllers may have alignment requirements.
 	 * We'll play it safe by requiring 512-byte alignment always.

commit 3055c92c7d4024d1fb540d0946e82c97235c8479
Author: Matthias Maennich <maennich@google.com>
Date:   Wed Oct 2 12:03:12 2019 +0100

    usb-storage: SCSI glue: use dev_err instead of printk
    
    Follow common practice and retire printk(KERN_ERR ...) in favor of
    dev_err().
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: usb-storage@lists.one-eyed-alien.net
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Link: https://lore.kernel.org/r/20191002110312.75749-1-maennich@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 6737fab94959..4c0c247e4101 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -379,8 +379,8 @@ static int queuecommand_lck(struct scsi_cmnd *srb,
 
 	/* check for state-transition errors */
 	if (us->srb != NULL) {
-		printk(KERN_ERR "usb-storage: Error in %s: us->srb = %p\n",
-			__func__, us->srb);
+		dev_err(&us->pusb_intf->dev,
+			"Error in %s: us->srb = %p\n", __func__, us->srb);
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 

commit bf89015a54131253f963ee68b95461e6a3a4c462
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 3 10:46:12 2019 +0200

    usb-storage: use hcd_uses_dma to check for DMA capabilities
    
    The dma_mask on its own doesn't mean much.  Instead check for the actual
    flag.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190903084615.19161-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index df4de8323eff..6737fab94959 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -40,6 +40,7 @@
 #include <scsi/scsi_eh.h>
 
 #include "usb.h"
+#include <linux/usb/hcd.h>
 #include "scsiglue.h"
 #include "debug.h"
 #include "transport.h"
@@ -141,11 +142,10 @@ static int slave_configure(struct scsi_device *sdev)
 
 	/*
 	 * Some USB host controllers can't do DMA; they have to use PIO.
-	 * They indicate this by setting their dma_mask to NULL.  For
-	 * such controllers we need to make sure the block layer sets
+	 * For such controllers we need to make sure the block layer sets
 	 * up bounce buffers in addressable memory.
 	 */
-	if (!us->pusb_dev->bus->controller->dma_mask)
+	if (!hcd_uses_dma(bus_to_hcd(us->pusb_dev->bus)))
 		blk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);
 
 	/*

commit 115f3bad1a36791b5293aeebde342a95a516198e
Author: Matthias Maennich <maennich@google.com>
Date:   Tue Aug 13 13:17:06 2019 +0100

    usb-storage: remove single-use define for debugging
    
    USB_STORAGE was defined as "usb-storage: " and used in a single location
    as argument to printk. In order to be able to use the name
    'USB_STORAGE', drop the definition and use the string directly for the
    printk call.
    
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Link: https://lore.kernel.org/r/20190813121733.52480-10-maennich@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 05b80211290d..df4de8323eff 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -379,7 +379,7 @@ static int queuecommand_lck(struct scsi_cmnd *srb,
 
 	/* check for state-transition errors */
 	if (us->srb != NULL) {
-		printk(KERN_ERR USB_STORAGE "Error in %s: us->srb = %p\n",
+		printk(KERN_ERR "usb-storage: Error in %s: us->srb = %p\n",
 			__func__, us->srb);
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}

commit d74ffae8b8dd17eaa8b82fc163e6aa2076dc8fb1
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Jul 22 19:58:25 2019 +0900

    usb-storage: Add a limitation for blk_queue_max_hw_sectors()
    
    This patch fixes an issue that the following error happens on
    swiotlb environment:
    
            xhci-hcd ee000000.usb: swiotlb buffer is full (sz: 524288 bytes), total 32768 (slots), used 1338 (slots)
    
    On the kernel v5.1, block settings of a usb-storage with SuperSpeed
    were the following so that the block layer will allocate buffers
    up to 64 KiB, and then the issue didn't happen.
    
            max_segment_size = 65536
            max_hw_sectors_kb = 1024
    
    After the commit 09324d32d2a0 ("block: force an unlimited segment
    size on queues with a virt boundary") is applied, the block settings
    are the following. So, the block layer will allocate buffers up to
    1024 KiB, and then the issue happens:
    
            max_segment_size = 4294967295
            max_hw_sectors_kb = 1024
    
    To fix the issue, the usb-storage driver checks the maximum size of
    a mapping for the device and then adjusts the max_hw_sectors_kb
    if required. After this patch is applied, the block settings will
    be the following, and then the issue doesn't happen.
    
            max_segment_size = 4294967295
            max_hw_sectors_kb = 256
    
    Fixes: 09324d32d2a0 ("block: force an unlimited segment size on queues with a virt boundary")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/1563793105-20597-1-git-send-email-yoshihiro.shimoda.uh@renesas.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 30790240aec6..05b80211290d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -28,6 +28,8 @@
  * status of a command.
  */
 
+#include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 
@@ -99,6 +101,7 @@ static int slave_alloc (struct scsi_device *sdev)
 static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
+	struct device *dev = us->pusb_dev->bus->sysdev;
 
 	/*
 	 * Many devices have trouble transferring more than 32KB at a time,
@@ -128,6 +131,14 @@ static int slave_configure(struct scsi_device *sdev)
 		blk_queue_max_hw_sectors(sdev->request_queue, 2048);
 	}
 
+	/*
+	 * The max_hw_sectors should be up to maximum size of a mapping for
+	 * the device. Otherwise, a DMA API might fail on swiotlb environment.
+	 */
+	blk_queue_max_hw_sectors(sdev->request_queue,
+		min_t(size_t, queue_max_hw_sectors(sdev->request_queue),
+		      dma_max_mapping_size(dev) >> SECTOR_SHIFT));
+
 	/*
 	 * Some USB host controllers can't do DMA; they have to use PIO.
 	 * They indicate this by setting their dma_mask to NULL.  For

commit 349148785b8cea9781af520fd53c29ee8087ee74
Author: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
Date:   Tue Jun 18 19:44:54 2019 -0300

    usb: storage: scsiglue: Do not skip VPD if try_vpd_pages is set
    
    If BLIST_TRY_VPD_PAGES is set for a device, even for an USB, it should
    be honored, so only set skip_vpd_pages is try_vpd_pages is not set.
    
    Signed-off-by: Marcos Paulo de Souza <marcos.souza.org@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 59190d88fa9f..30790240aec6 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -195,8 +195,11 @@ static int slave_configure(struct scsi_device *sdev)
 		 */
 		sdev->skip_ms_page_8 = 1;
 
-		/* Some devices don't handle VPD pages correctly */
-		sdev->skip_vpd_pages = 1;
+		/*
+		 * Some devices don't handle VPD pages correctly, so skip vpd
+		 * pages if not forced by SCSI layer.
+		 */
+		sdev->skip_vpd_pages = !sdev->try_vpd_pages;
 
 		/* Do not attempt to use REPORT SUPPORTED OPERATION CODES */
 		sdev->no_report_opcodes = 1;

commit 747668dbc061b3e62bc1982767a3a1f9815fcf0e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 15 13:19:25 2019 -0400

    usb-storage: Set virt_boundary_mask to avoid SG overflows
    
    The USB subsystem has always had an unusual requirement for its
    scatter-gather transfers: Each element in the scatterlist (except the
    last one) must have a length divisible by the bulk maxpacket size.
    This is a particular issue for USB mass storage, which uses SG lists
    created by the block layer rather than setting up its own.
    
    So far we have scraped by okay because most devices have a logical
    block size of 512 bytes or larger, and the bulk maxpacket sizes for
    USB 2 and below are all <= 512.  However, USB 3 has a bulk maxpacket
    size of 1024.  Since the xhci-hcd driver includes native SG support,
    this hasn't mattered much.  But now people are trying to use USB-3
    mass storage devices with USBIP, and the vhci-hcd driver currently
    does not have full SG support.
    
    The result is an overflow error, when the driver attempts to implement
    an SG transfer of 63 512-byte blocks as a single
    3584-byte (7 blocks) transfer followed by seven 4096-byte (8 blocks)
    transfers.  The device instead sends 31 1024-byte packets followed by
    a 512-byte packet, and this overruns the first SG buffer.
    
    Ideally this would be fixed by adding better SG support to vhci-hcd.
    But for now it appears we can work around the problem by
    asking the block layer to respect the maxpacket limitation, through
    the use of the virt_boundary_mask.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Seth Bollinger <Seth.Bollinger@digi.com>
    Tested-by: Seth Bollinger <Seth.Bollinger@digi.com>
    CC: Ming Lei <tom.leiming@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a73ea495d5a7..59190d88fa9f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -65,6 +65,7 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
+	int maxp;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -74,20 +75,17 @@ static int slave_alloc (struct scsi_device *sdev)
 	sdev->inquiry_len = 36;
 
 	/*
-	 * USB has unusual DMA-alignment requirements: Although the
-	 * starting address of each scatter-gather element doesn't matter,
-	 * the length of each element except the last must be divisible
-	 * by the Bulk maxpacket value.  There's currently no way to
-	 * express this by block-layer constraints, so we'll cop out
-	 * and simply require addresses to be aligned at 512-byte
-	 * boundaries.  This is okay since most block I/O involves
-	 * hardware sectors that are multiples of 512 bytes in length,
-	 * and since host controllers up through USB 2.0 have maxpacket
-	 * values no larger than 512.
-	 *
-	 * But it doesn't suffice for Wireless USB, where Bulk maxpacket
-	 * values can be as large as 2048.  To make that work properly
-	 * will require changes to the block layer.
+	 * USB has unusual scatter-gather requirements: the length of each
+	 * scatterlist element except the last must be divisible by the
+	 * Bulk maxpacket value.  Fortunately this value is always a
+	 * power of 2.  Inform the block layer about this requirement.
+	 */
+	maxp = usb_maxpacket(us->pusb_dev, us->recv_bulk_pipe, 0);
+	blk_queue_virt_boundary(sdev->request_queue, maxp - 1);
+
+	/*
+	 * Some host controllers may have alignment requirements.
+	 * We'll play it safe by requiring 512-byte alignment always.
 	 */
 	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
 

commit c5603d2fdb424849360fe7e3f8c1befc97571b8c
Author: Icenowy Zheng <icenowy@aosc.io>
Date:   Thu Jan 3 11:26:17 2019 +0800

    USB: storage: don't insert sane sense for SPC3+ when bad sense specified
    
    Currently the code will set US_FL_SANE_SENSE flag unconditionally if
    device claims SPC3+, however we should allow US_FL_BAD_SENSE flag to
    prevent this behavior, because SMI SM3350 UFS-USB bridge controller,
    which claims SPC4, will show strange behavior with 96-byte sense
    (put the chip into a wrong state that cannot read/write anything).
    
    Check the presence of US_FL_BAD_SENSE when assuming US_FL_SANE_SENSE on
    SPC4+ devices.
    
    Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index fde2e71a6ade..a73ea495d5a7 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -235,8 +235,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (!(us->fflags & US_FL_NEEDS_CAP16))
 			sdev->try_rc_10_first = 1;
 
-		/* assume SPC3 or latter devices support sense size > 18 */
-		if (sdev->scsi_level > SCSI_SPC_2)
+		/*
+		 * assume SPC3 or latter devices support sense size > 18
+		 * unless US_FL_BAD_SENSE quirk is specified.
+		 */
+		if (sdev->scsi_level > SCSI_SPC_2 &&
+		    !(us->fflags & US_FL_BAD_SENSE))
 			us->fflags |= US_FL_SANE_SENSE;
 
 		/*

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e227bb5b794f..fde2e71a6ade 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -639,13 +639,6 @@ static const struct scsi_host_template usb_stor_host_template = {
 	 */
 	.max_sectors =                  240,
 
-	/*
-	 * merge commands... this seems to help performance, but
-	 * periodically someone should test to see which setting is more
-	 * optimal.
-	 */
-	.use_clustering =		1,
-
 	/* emulated HBA */
 	.emulated =			1,
 

commit f45681f9becaa65111ed0a691ccf080a0cd5feb8
Author: Tim Anderson <tsa@biglakesoftware.com>
Date:   Thu Aug 9 14:55:34 2018 -0700

    USB: Add quirk to support DJI CineSSD
    
    This device does not correctly handle the LPM operations.
    
    Also, the device cannot handle ATA pass-through commands
    and locks up when attempted while running in super speed.
    
    This patch adds the equivalent quirk logic as found in uas.
    
    Signed-off-by: Tim Anderson <tsa@biglakesoftware.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index c267f2812a04..e227bb5b794f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -376,6 +376,15 @@ static int queuecommand_lck(struct scsi_cmnd *srb,
 		return 0;
 	}
 
+	if ((us->fflags & US_FL_NO_ATA_1X) &&
+			(srb->cmnd[0] == ATA_12 || srb->cmnd[0] == ATA_16)) {
+		memcpy(srb->sense_buffer, usb_stor_sense_invalidCDB,
+		       sizeof(usb_stor_sense_invalidCDB));
+		srb->result = SAM_STAT_CHECK_CONDITION;
+		done(srb);
+		return 0;
+	}
+
 	/* enqueue the command and wake up the control thread */
 	srb->scsi_done = done;
 	us->srb = srb;

commit 077af794d9ab016b52cd3dd90bd8b1709a61710f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 22 15:41:53 2018 +0100

    USB: storage: remove invalid URL from drivers
    
    The old URL for usb-storage driver help is long gone.  So remove it from
    the comments to not confuse people anymore.
    
    Reported-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 585efd120193..c267f2812a04 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -26,9 +26,6 @@
  *
  * Also, for certain devices, the interrupt endpoint is used to convey
  * status of a command.
- *
- * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more
- * information about this driver.
  */
 
 #include <linux/module.h>

commit 7cb2d993c4617c842230949f901d1cfe8c0b2f11
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:57 2017 +0100

    USB: storage: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 878922fb54b8..585efd120193 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -29,20 +29,6 @@
  *
  * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more
  * information about this driver.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/module.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 8cd2926fb1fe..878922fb54b8 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Driver for USB Mass Storage compliant devices
  * SCSI layer glue code

commit 050bc4e846af24e77af82d0fa5f718e0919d15a4
Author: Oliver Neukum <oneukum@suse.com>
Date:   Mon Sep 12 15:19:41 2016 +0200

    scsi: introduce a quirk for false cache reporting
    
    Some SATA to USB bridges fail to cooperate with some
    drives resulting in no cache being present being reported
    to the host. That causes the host to skip sending
    a command to synchronize caches. That causes data loss
    when the drive is powered down.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 33eb923df892..8cd2926fb1fe 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -296,6 +296,14 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_BROKEN_FUA)
 			sdev->broken_fua = 1;
 
+		/* Some even totally fail to indicate a cache */
+		if (us->fflags & US_FL_ALWAYS_SYNC) {
+			/* don't read caching information */
+			sdev->skip_ms_page_8 = 1;
+			sdev->skip_ms_page_3f = 1;
+			/* assume sync is needed */
+			sdev->wce_default_on = 1;
+		}
 	} else {
 
 		/*

commit 19e36ad292ab24980db64a5ff17973d3118a8fb9
Merge: e10abc629f38 60d5794fe5a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 21:12:25 2016 -0700

    Merge tag 'usb-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB updates from Greg KH:
     "Here's the big pull request for USB and PHY drivers for 4.7-rc1
    
      Full details in the shortlog, but it's the normal major gadget driver
      updates, phy updates, new usbip code, as well as a bit of lots of
      other stuff.
    
      All have been in linux-next with no reported issues"
    
    * tag 'usb-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (164 commits)
      USB: serial: ti_usb_3410_5052: add MOXA UPORT 11x0 support
      USB: serial: fix minor-number allocation
      USB: serial: quatech2: fix use-after-free in probe error path
      USB: serial: mxuport: fix use-after-free in probe error path
      USB: serial: keyspan: fix debug and error messages
      USB: serial: keyspan: fix URB unlink
      USB: serial: keyspan: fix use-after-free in probe error path
      USB: serial: io_edgeport: fix memory leaks in probe error path
      USB: serial: io_edgeport: fix memory leaks in attach error path
      usb: Remove unnecessary space before operator ','.
      usb: Remove unnecessary space before open square bracket.
      USB: FHCI: avoid redundant condition
      usb: host: xhci-rcar: Avoid long wait in xhci_reset()
      usb/host/fotg210: remove dead code in create_sysfs_files
      usb: wusbcore: Do not initialise statics to 0.
      usb: wusbcore: Remove space before ',' and '(' .
      USB: serial: cp210x: clean up CRTSCTS flag code
      USB: serial: cp210x: get rid of magic numbers in CRTSCTS flag code
      USB: serial: cp210x: fix hardware flow-control disable
      USB: serial: option: add even more ZTE device ids
      ...

commit f0183a338e4f90e59a4b4daa10cba0fae8e3fca7
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Apr 18 13:09:11 2016 +0300

    usb: storage: fix multi-line comment style
    
    No functional changes here, just making sure our
    storage driver uses a consistent multi-line comment
    style.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 88920142e375..7adb6c9c7018 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -1,4 +1,5 @@
-/* Driver for USB Mass Storage compliant devices
+/*
+ * Driver for USB Mass Storage compliant devices
  * SCSI layer glue code
  *
  * Current development and maintenance by:
@@ -58,7 +59,8 @@
 #include "transport.h"
 #include "protocol.h"
 
-/* Vendor IDs for companies that seem to include the READ CAPACITY bug
+/*
+ * Vendor IDs for companies that seem to include the READ CAPACITY bug
  * in all their devices
  */
 #define VENDOR_ID_NOKIA		0x0421
@@ -87,7 +89,8 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	sdev->inquiry_len = 36;
 
-	/* USB has unusual DMA-alignment requirements: Although the
+	/*
+	 * USB has unusual DMA-alignment requirements: Although the
 	 * starting address of each scatter-gather element doesn't matter,
 	 * the length of each element except the last must be divisible
 	 * by the Bulk maxpacket value.  There's currently no way to
@@ -115,7 +118,8 @@ static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
 
-	/* Many devices have trouble transferring more than 32KB at a time,
+	/*
+	 * Many devices have trouble transferring more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */
@@ -128,19 +132,22 @@ static int slave_configure(struct scsi_device *sdev)
 			blk_queue_max_hw_sectors(sdev->request_queue,
 					      max_sectors);
 	} else if (sdev->type == TYPE_TAPE) {
-		/* Tapes need much higher max_sector limits, so just
+		/*
+		 * Tapes need much higher max_sector limits, so just
 		 * raise it to the maximum possible (4 GB / 512) and
 		 * let the queue segment size sort out the real limit.
 		 */
 		blk_queue_max_hw_sectors(sdev->request_queue, 0x7FFFFF);
 	} else if (us->pusb_dev->speed >= USB_SPEED_SUPER) {
-		/* USB3 devices will be limited to 2048 sectors. This gives us
+		/*
+		 * USB3 devices will be limited to 2048 sectors. This gives us
 		 * better throughput on most devices.
 		 */
 		blk_queue_max_hw_sectors(sdev->request_queue, 2048);
 	}
 
-	/* Some USB host controllers can't do DMA; they have to use PIO.
+	/*
+	 * Some USB host controllers can't do DMA; they have to use PIO.
 	 * They indicate this by setting their dma_mask to NULL.  For
 	 * such controllers we need to make sure the block layer sets
 	 * up bounce buffers in addressable memory.
@@ -148,17 +155,21 @@ static int slave_configure(struct scsi_device *sdev)
 	if (!us->pusb_dev->bus->controller->dma_mask)
 		blk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);
 
-	/* We can't put these settings in slave_alloc() because that gets
+	/*
+	 * We can't put these settings in slave_alloc() because that gets
 	 * called before the device type is known.  Consequently these
-	 * settings can't be overridden via the scsi devinfo mechanism. */
+	 * settings can't be overridden via the scsi devinfo mechanism.
+	 */
 	if (sdev->type == TYPE_DISK) {
 
-		/* Some vendors seem to put the READ CAPACITY bug into
+		/*
+		 * Some vendors seem to put the READ CAPACITY bug into
 		 * all their devices -- primarily makers of cell phones
 		 * and digital cameras.  Since these devices always use
 		 * flash media and can be expected to have an even number
 		 * of sectors, we will always enable the CAPACITY_HEURISTICS
-		 * flag unless told otherwise. */
+		 * flag unless told otherwise.
+		 */
 		switch (le16_to_cpu(us->pusb_dev->descriptor.idVendor)) {
 		case VENDOR_ID_NOKIA:
 		case VENDOR_ID_NIKON:
@@ -170,28 +181,36 @@ static int slave_configure(struct scsi_device *sdev)
 			break;
 		}
 
-		/* Disk-type devices use MODE SENSE(6) if the protocol
+		/*
+		 * Disk-type devices use MODE SENSE(6) if the protocol
 		 * (SubClass) is Transparent SCSI, otherwise they use
-		 * MODE SENSE(10). */
+		 * MODE SENSE(10).
+		 */
 		if (us->subclass != USB_SC_SCSI && us->subclass != USB_SC_CYP_ATACB)
 			sdev->use_10_for_ms = 1;
 
-		/* Many disks only accept MODE SENSE transfer lengths of
-		 * 192 bytes (that's what Windows uses). */
+		/*
+		 *Many disks only accept MODE SENSE transfer lengths of
+		 * 192 bytes (that's what Windows uses).
+		 */
 		sdev->use_192_bytes_for_3f = 1;
 
-		/* Some devices don't like MODE SENSE with page=0x3f,
+		/*
+		 * Some devices don't like MODE SENSE with page=0x3f,
 		 * which is the command used for checking if a device
 		 * is write-protected.  Now that we tell the sd driver
 		 * to do a 192-byte transfer with this command the
 		 * majority of devices work fine, but a few still can't
 		 * handle it.  The sd driver will simply assume those
-		 * devices are write-enabled. */
+		 * devices are write-enabled.
+		 */
 		if (us->fflags & US_FL_NO_WP_DETECT)
 			sdev->skip_ms_page_3f = 1;
 
-		/* A number of devices have problems with MODE SENSE for
-		 * page x08, so we will skip it. */
+		/*
+		 * A number of devices have problems with MODE SENSE for
+		 * page x08, so we will skip it.
+		 */
 		sdev->skip_ms_page_8 = 1;
 
 		/* Some devices don't handle VPD pages correctly */
@@ -203,15 +222,19 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Do not attempt to use WRITE SAME */
 		sdev->no_write_same = 1;
 
-		/* Some disks return the total number of blocks in response
+		/*
+		 * Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
-		 * If this device makes that mistake, tell the sd driver. */
+		 * If this device makes that mistake, tell the sd driver.
+		 */
 		if (us->fflags & US_FL_FIX_CAPACITY)
 			sdev->fix_capacity = 1;
 
-		/* A few disks have two indistinguishable version, one of
+		/*
+		 * A few disks have two indistinguishable version, one of
 		 * which reports the correct capacity and the other does not.
-		 * The sd driver has to guess which is the case. */
+		 * The sd driver has to guess which is the case.
+		 */
 		if (us->fflags & US_FL_CAPACITY_HEURISTICS)
 			sdev->guess_capacity = 1;
 
@@ -232,26 +255,34 @@ static int slave_configure(struct scsi_device *sdev)
 		if (sdev->scsi_level > SCSI_SPC_2)
 			us->fflags |= US_FL_SANE_SENSE;
 
-		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
+		/*
+		 * USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
 		 * recoverable or not.  Setting this flag tells the SCSI
 		 * midlayer to retry such commands, which frequently will
 		 * succeed and fix the error.  The worst this can lead to
-		 * is an occasional series of retries that will all fail. */
+		 * is an occasional series of retries that will all fail.
+		 */
 		sdev->retry_hwerror = 1;
 
-		/* USB disks should allow restart.  Some drives spin down
-		 * automatically, requiring a START-STOP UNIT command. */
+		/*
+		 * USB disks should allow restart.  Some drives spin down
+		 * automatically, requiring a START-STOP UNIT command.
+		 */
 		sdev->allow_restart = 1;
 
-		/* Some USB cardreaders have trouble reading an sdcard's last
+		/*
+		 * Some USB cardreaders have trouble reading an sdcard's last
 		 * sector in a larger then 1 sector read, since the performance
-		 * impact is negligible we set this flag for all USB disks */
+		 * impact is negligible we set this flag for all USB disks
+		 */
 		sdev->last_sector_bug = 1;
 
-		/* Enable last-sector hacks for single-target devices using
+		/*
+		 * Enable last-sector hacks for single-target devices using
 		 * the Bulk-only transport, unless we already know the
-		 * capacity will be decremented or is correct. */
+		 * capacity will be decremented or is correct.
+		 */
 		if (!(us->fflags & (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |
 					US_FL_SCM_MULT_TARG)) &&
 				us->protocol == USB_PR_BULK)
@@ -267,9 +298,11 @@ static int slave_configure(struct scsi_device *sdev)
 
 	} else {
 
-		/* Non-disk-type devices don't need to blacklist any pages
+		/*
+		 * Non-disk-type devices don't need to blacklist any pages
 		 * or to force 192-byte transfer lengths for MODE SENSE.
-		 * But they do need to use MODE SENSE(10). */
+		 * But they do need to use MODE SENSE(10).
+		 */
 		sdev->use_10_for_ms = 1;
 
 		/* Some (fake) usb cdrom devices don't like READ_DISC_INFO */
@@ -277,7 +310,8 @@ static int slave_configure(struct scsi_device *sdev)
 			sdev->no_read_disc_info = 1;
 	}
 
-	/* The CB and CBI transports have no way to pass LUN values
+	/*
+	 * The CB and CBI transports have no way to pass LUN values
 	 * other than the bits in the second byte of a CDB.  But those
 	 * bits don't get set to the LUN value if the device reports
 	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily
@@ -287,13 +321,17 @@ static int slave_configure(struct scsi_device *sdev)
 			sdev->scsi_level == SCSI_UNKNOWN)
 		us->max_lun = 0;
 
-	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
-	 * REMOVAL command, so suppress those commands. */
+	/*
+	 * Some devices choke when they receive a PREVENT-ALLOW MEDIUM
+	 * REMOVAL command, so suppress those commands.
+	 */
 	if (us->fflags & US_FL_NOT_LOCKABLE)
 		sdev->lockable = 0;
 
-	/* this is to satisfy the compiler, tho I don't think the 
-	 * return code is ever checked anywhere. */
+	/*
+	 * this is to satisfy the compiler, tho I don't think the 
+	 * return code is ever checked anywhere.
+	 */
 	return 0;
 }
 
@@ -367,8 +405,10 @@ static int command_abort(struct scsi_cmnd *srb)
 
 	usb_stor_dbg(us, "%s called\n", __func__);
 
-	/* us->srb together with the TIMED_OUT, RESETTING, and ABORTING
-	 * bits are protected by the host lock. */
+	/*
+	 * us->srb together with the TIMED_OUT, RESETTING, and ABORTING
+	 * bits are protected by the host lock.
+	 */
 	scsi_lock(us_to_host(us));
 
 	/* Is this command still active? */
@@ -378,11 +418,13 @@ static int command_abort(struct scsi_cmnd *srb)
 		return FAILED;
 	}
 
-	/* Set the TIMED_OUT bit.  Also set the ABORTING bit, but only if
+	/*
+	 * Set the TIMED_OUT bit.  Also set the ABORTING bit, but only if
 	 * a device reset isn't already in progress (to avoid interfering
 	 * with the reset).  Note that we must retain the host lock while
 	 * calling usb_stor_stop_transport(); otherwise it might interfere
-	 * with an auto-reset that begins as soon as we release the lock. */
+	 * with an auto-reset that begins as soon as we release the lock.
+	 */
 	set_bit(US_FLIDX_TIMED_OUT, &us->dflags);
 	if (!test_bit(US_FLIDX_RESETTING, &us->dflags)) {
 		set_bit(US_FLIDX_ABORTING, &us->dflags);
@@ -395,8 +437,10 @@ static int command_abort(struct scsi_cmnd *srb)
 	return SUCCESS;
 }
 
-/* This invokes the transport reset mechanism to reset the state of the
- * device */
+/*
+ * This invokes the transport reset mechanism to reset the state of the
+ * device
+ */
 static int device_reset(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
@@ -424,9 +468,11 @@ static int bus_reset(struct scsi_cmnd *srb)
 	return result < 0 ? FAILED : SUCCESS;
 }
 
-/* Report a driver-initiated device reset to the SCSI layer.
+/*
+ * Report a driver-initiated device reset to the SCSI layer.
  * Calling this for a SCSI-initiated reset is unnecessary but harmless.
- * The caller must own the SCSI host lock. */
+ * The caller must own the SCSI host lock.
+ */
 void usb_stor_report_device_reset(struct us_data *us)
 {
 	int i;
@@ -439,9 +485,11 @@ void usb_stor_report_device_reset(struct us_data *us)
 	}
 }
 
-/* Report a driver-initiated bus reset to the SCSI layer.
+/*
+ * Report a driver-initiated bus reset to the SCSI layer.
  * Calling this for a SCSI-initiated reset is unnecessary but harmless.
- * The caller must not own the SCSI host lock. */
+ * The caller must not own the SCSI host lock.
+ */
 void usb_stor_report_bus_reset(struct us_data *us)
 {
 	struct Scsi_Host *host = us_to_host(us);
@@ -590,7 +638,8 @@ static const struct scsi_host_template usb_stor_host_template = {
 	 */
 	.max_sectors =                  240,
 
-	/* merge commands... this seems to help performance, but
+	/*
+	 * merge commands... this seems to help performance, but
 	 * periodically someone should test to see which setting is more
 	 * optimal.
 	 */

commit 5b91dfe187bbe3a8116432016375f39fff91a237
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Apr 18 13:09:10 2016 +0300

    usb: storage: scsiglue: limit USB3 devices to 2048 sectors
    
    USB3 devices, because they are much newer, have much
    less chance of having issues with larger transfers.
    
    We still keep a limit because anything above 2048
    sectors really rendered negligible speed
    improvements, so we will simply ignore
    that. Transferring 1MiB should already give us
    pretty good performance.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 9da1fb3d0ff4..88920142e375 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -133,6 +133,11 @@ static int slave_configure(struct scsi_device *sdev)
 		 * let the queue segment size sort out the real limit.
 		 */
 		blk_queue_max_hw_sectors(sdev->request_queue, 0x7FFFFF);
+	} else if (us->pusb_dev->speed >= USB_SPEED_SUPER) {
+		/* USB3 devices will be limited to 2048 sectors. This gives us
+		 * better throughput on most devices.
+		 */
+		blk_queue_max_hw_sectors(sdev->request_queue, 2048);
 	}
 
 	/* Some USB host controllers can't do DMA; they have to use PIO.

commit 779b457f66e10de3471479373463b27fd308dc85
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Apr 18 13:09:09 2016 +0300

    usb: storage: scsiglue: further describe our 240 sector limit
    
    Just so we have some sort of documentation as to why
    we limit our Mass Storage transfers to 240 sectors,
    let's update the comment to make clearer that
    devices were found that would choke with larger
    transfers.
    
    While at that, also make sure to clarify that other
    operating systems have similar, albeit different,
    limits on mass storage transfers.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 90901861bfc0..9da1fb3d0ff4 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -565,7 +565,24 @@ static const struct scsi_host_template usb_stor_host_template = {
 	/* lots of sg segments can be handled */
 	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
 
-	/* limit the total size of a transfer to 120 KB */
+
+	/*
+	 * Limit the total size of a transfer to 120 KB.
+	 *
+	 * Some devices are known to choke with anything larger. It seems like
+	 * the problem stems from the fact that original IDE controllers had
+	 * only an 8-bit register to hold the number of sectors in one transfer
+	 * and even those couldn't handle a full 256 sectors.
+	 *
+	 * Because we want to make sure we interoperate with as many devices as
+	 * possible, we will maintain a 240 sector transfer size limit for USB
+	 * Mass Storage devices.
+	 *
+	 * Tests show that other operating have similar limits with Microsoft
+	 * Windows 7 limiting transfers to 128 sectors for both USB2 and USB3
+	 * and Apple Mac OS X 10.11 limiting transfers to 256 sectors for USB2
+	 * and 2048 for USB3 devices.
+	 */
 	.max_sectors =                  240,
 
 	/* merge commands... this seems to help performance, but

commit 65e8617fba17732b4c68d3369a621725838b6f28
Author: Ming Lin <ming.l@ssi.samsung.com>
Date:   Mon Apr 4 14:48:10 2016 -0700

    scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS
    
    Rename SCSI_MAX_SG_SEGMENTS to SG_CHUNK_SIZE, which means the amount
    we fit into a single scatterlist chunk.
    
    Rename SCSI_MAX_SG_CHAIN_SEGMENTS to SG_MAX_SEGMENTS.
    
    Will move these 2 generic definitions to scatterlist.h later.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Bart Van Assche <bart.vanassche@sandisk.com> (for ib_srp changes)
    Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 90901861bfc0..ae85861051eb 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -563,7 +563,7 @@ static const struct scsi_host_template usb_stor_host_template = {
 	.target_alloc =			target_alloc,
 
 	/* lots of sg segments can be handled */
-	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize =			SG_MAX_SEGMENTS,
 
 	/* limit the total size of a transfer to 120 KB */
 	.max_sectors =                  240,

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index dba51362d2e2..90901861bfc0 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -123,7 +123,7 @@ static int slave_configure(struct scsi_device *sdev)
 		unsigned int max_sectors = 64;
 
 		if (us->fflags & US_FL_MAX_SECTORS_MIN)
-			max_sectors = PAGE_CACHE_SIZE >> 9;
+			max_sectors = PAGE_SIZE >> 9;
 		if (queue_max_hw_sectors(sdev->request_queue) > max_sectors)
 			blk_queue_max_hw_sectors(sdev->request_queue,
 					      max_sectors);

commit 2a298679b41199ae742a77ce69766385dffe816f
Merge: 8c7febe83915 50641056d833
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 15:59:26 2015 -0700

    Merge tag 'usb-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB updates from Greg KH:
     "Here's the big USB patchset for 4.2-rc1.  As is normal these days, the
      majority of changes are in the gadget drivers, with a bunch of other
      small driver changes.
    
      All of these have been in linux-next with no reported issues"
    
    * tag 'usb-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (175 commits)
      usb: dwc3: Use ASCII space in Kconfig
      usb: chipidea: add work-around for Marvell HSIC PHY startup
      usb: chipidea: allow multiple instances to use default ci_default_pdata
      dt-bindings: Consolidate ChipIdea USB ci13xxx bindings
      phy: add Marvell HSIC 28nm PHY
      phy: Add Marvell USB 2.0 OTG 28nm PHY
      dt-bindings: Add Marvell PXA1928 USB and HSIC PHY bindings
      USB: ssb: use devm_kzalloc
      USB: ssb: fix error handling in ssb_hcd_create_pdev()
      usb: isp1760: check for null return from kzalloc
      cdc-acm: Add support of ATOL FPrint fiscal printers
      usb: chipidea: usbmisc_imx: Remove unneeded semicolon
      USB: usbtmc: add device quirk for Rigol DS6104
      USB: serial: mos7840: Use setup_timer
      phy: twl4030-usb: add ABI documentation
      phy: twl4030-usb: remove incorrect pm_runtime_get_sync() in probe function.
      phy: twl4030-usb: remove pointless 'suspended' test in 'suspend' callback.
      phy: twl4030-usb: make runtime pm more reliable.
      drivers:usb:fsl: Fix compilation error for fsl ehci drv
      usb: renesas_usbhs: Don't disable the pipe if Control write status stage
      ...

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 0e400f382f3a..996ef1e882d3 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -558,7 +558,6 @@ struct scsi_host_template usb_stor_host_template = {
 
 	/* queue commands only, only one command per LUN */
 	.can_queue =			1,
-	.cmd_per_lun =			1,
 
 	/* unknown initiator id */
 	.this_id =			-1,

commit aa519be34f45954f33a6c20430deac8e544a180f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed May 6 18:24:21 2015 +0900

    usb: storage: fix module reference for scsi host
    
    While accessing a unusual usb storage (ums-alauda, ums-cypress, ...),
    the module reference count is not incremented.  Because these drivers
    allocate scsi hosts with usb_stor_host_template defined in usb-storage
    module.  So these drivers always can be unloaded.
    
    This fixes it by preparing scsi host template which is initialized
    at module_init() for each ums-* driver.  In order to minimize the
    difference in ums-* drivers, introduce module_usb_stor_driver() helper
    macro which is same as module_usb_driver() except that it also
    initializes scsi host template.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Vinayak Holikatti <vinholikatti@gmail.com>
    Cc: Dolev Raviv <draviv@codeaurora.org>
    Cc: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Cc: Subhash Jadavani <subhashj@codeaurora.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: linux-usb@vger.kernel.org
    Cc: usb-storage@lists.one-eyed-alien.net
    Cc: linux-scsi@vger.kernel.org
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a8cbbffe822c..c922d8b64362 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -536,7 +536,7 @@ static struct device_attribute *sysfs_device_attr_list[] = {
  * this defines our host template, with which we'll allocate hosts
  */
 
-struct scsi_host_template usb_stor_host_template = {
+static const struct scsi_host_template usb_stor_host_template = {
 	/* basic userland interface stuff */
 	.name =				"usb-storage",
 	.proc_name =			"usb-storage",
@@ -588,6 +588,16 @@ struct scsi_host_template usb_stor_host_template = {
 	.module =			THIS_MODULE
 };
 
+void usb_stor_host_template_init(struct scsi_host_template *sht,
+				 const char *name, struct module *owner)
+{
+	*sht = usb_stor_host_template;
+	sht->name = name;
+	sht->proc_name = name;
+	sht->module = owner;
+}
+EXPORT_SYMBOL_GPL(usb_stor_host_template_init);
+
 /* To Report "Illegal Request: Invalid Field in CDB */
 unsigned char usb_stor_sense_invalidCDB[18] = {
 	[0]	= 0x70,			    /* current error */

commit 7d203a9e11fa179306a9f49ad06eb3dd1b9d8614
Author: Joe Perches <joe@perches.com>
Date:   Sat Apr 18 19:59:48 2015 -0700

    usb: storage: scsiglue: Remove SPRINTF macro use
    
    Single transform macros with hidden arguments are not
    particularly useful.  Just use seq_printf directly instead.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 0e400f382f3a..a8cbbffe822c 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -456,17 +456,13 @@ static int write_info(struct Scsi_Host *host, char *buffer, int length)
 	return length;
 }
 
-/* we use this macro to help us write into the buffer */
-#undef SPRINTF
-#define SPRINTF(args...) seq_printf(m, ## args)
-
 static int show_info (struct seq_file *m, struct Scsi_Host *host)
 {
 	struct us_data *us = host_to_us(host);
 	const char *string;
 
 	/* print the controller name */
-	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
+	seq_printf(m, "   Host scsi%d: usb-storage\n", host->host_no);
 
 	/* print product, vendor, and serial number strings */
 	if (us->pusb_dev->manufacturer)
@@ -475,26 +471,26 @@ static int show_info (struct seq_file *m, struct Scsi_Host *host)
 		string = us->unusual_dev->vendorName;
 	else
 		string = "Unknown";
-	SPRINTF("       Vendor: %s\n", string);
+	seq_printf(m, "       Vendor: %s\n", string);
 	if (us->pusb_dev->product)
 		string = us->pusb_dev->product;
 	else if (us->unusual_dev->productName)
 		string = us->unusual_dev->productName;
 	else
 		string = "Unknown";
-	SPRINTF("      Product: %s\n", string);
+	seq_printf(m, "      Product: %s\n", string);
 	if (us->pusb_dev->serial)
 		string = us->pusb_dev->serial;
 	else
 		string = "None";
-	SPRINTF("Serial Number: %s\n", string);
+	seq_printf(m, "Serial Number: %s\n", string);
 
 	/* show the protocol and transport */
-	SPRINTF("     Protocol: %s\n", us->protocol_name);
-	SPRINTF("    Transport: %s\n", us->transport_name);
+	seq_printf(m, "     Protocol: %s\n", us->protocol_name);
+	seq_printf(m, "    Transport: %s\n", us->transport_name);
 
 	/* show the device flags */
-	SPRINTF("       Quirks:");
+	seq_printf(m, "       Quirks:");
 
 #define US_FLAG(name, value) \
 	if (us->fflags & value) seq_printf(m, " " #name);

commit a6cd244b921973e4ff38f238496cc094142bd444
Author: Mickael Maison <mickael.maison@gmail.com>
Date:   Thu Sep 18 11:25:04 2014 +0200

    usb: Fixed a few typos
    
    Fixed typos in comments of various drivers/usb files
    
    Signed-off-by: Mickael Maison <mickael.maison@gmail.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 866b5df36ed1..0e400f382f3a 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -241,7 +241,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 		/* Some USB cardreaders have trouble reading an sdcard's last
 		 * sector in a larger then 1 sector read, since the performance
-		 * impact is negible we set this flag for all USB disks */
+		 * impact is negligible we set this flag for all USB disks */
 		sdev->last_sector_bug = 1;
 
 		/* Enable last-sector hacks for single-target devices using

commit b14bf2d0c0358140041d1c1805a674376964d0e0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 30 11:04:21 2014 -0400

    usb-storage/SCSI: Add broken_fua blacklist flag
    
    Some buggy JMicron USB-ATA bridges don't know how to translate the FUA
    bit in READs or WRITEs.  This patch adds an entry in unusual_devs.h
    and a blacklist flag to tell the sd driver not to use FUA.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Michael Büsch <m@bues.ch>
    Tested-by: Michael Büsch <m@bues.ch>
    Acked-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 9d38ddc8da49..866b5df36ed1 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -256,6 +256,10 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_WRITE_CACHE)
 			sdev->wce_default_on = 1;
 
+		/* A few buggy USB-ATA bridges don't understand FUA */
+		if (us->fflags & US_FL_BROKEN_FUA)
+			sdev->broken_fua = 1;
+
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit 823d12c95c666fa7ab7dad208d735f6bc6afabdc
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 30 10:43:22 2014 -0500

    usb-storage: enable multi-LUN scanning when needed
    
    People sometimes create their own custom-configured kernels and forget
    to enable CONFIG_SCSI_MULTI_LUN.  This causes problems when they plug
    in a USB storage device (such as a card reader) with more than one
    LUN.
    
    Fortunately, we can tell fairly easily when a storage device claims to
    have more than one LUN.  When that happens, this patch asks the SCSI
    layer to probe all the LUNs automatically, regardless of the config
    setting.
    
    The patch also updates the Kconfig help text for usb-storage,
    explaining that CONFIG_SCSI_MULTI_LUN may be necessary.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Thomas Raschbacher <lordvan@lordvan.com>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    CC: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 18509e6c21ab..9d38ddc8da49 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -78,6 +78,8 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
+	struct us_data *us = host_to_us(sdev->host);
+
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
@@ -102,6 +104,10 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
 
+	/* Tell the SCSI layer if we know there is more than one LUN */
+	if (us->protocol == USB_PR_BULK && us->max_lun > 0)
+		sdev->sdev_bflags |= BLIST_FORCELUN;
+
 	return 0;
 }
 

commit 32c37fc30c52508711ea6a108cfd5855b8a07176
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Oct 14 15:24:55 2013 +0200

    usb-storage: add quirk for mandatory READ_CAPACITY_16
    
    Some USB drive enclosures do not correctly report an
    overflow condition if they hold a drive with a capacity
    over 2TB and are confronted with a READ_CAPACITY_10.
    They answer with their capacity modulo 2TB.
    The generic layer cannot cope with that. It must be told
    to use READ_CAPACITY_16 from the beginning.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 94d75edef77f..18509e6c21ab 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -211,8 +211,11 @@ static int slave_configure(struct scsi_device *sdev)
 		/*
 		 * Many devices do not respond properly to READ_CAPACITY_16.
 		 * Tell the SCSI layer to try READ_CAPACITY_10 first.
+		 * However some USB 3.0 drive enclosures return capacity
+		 * modulo 2TB. Those must use READ_CAPACITY_16
 		 */
-		sdev->try_rc_10_first = 1;
+		if (!(us->fflags & US_FL_NEEDS_CAP16))
+			sdev->try_rc_10_first = 1;
 
 		/* assume SPC3 or latter devices support sense size > 18 */
 		if (sdev->scsi_level > SCSI_SPC_2)

commit f2e0ae93cc81cb56ed32722da7b7246a24940f90
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 27 13:13:07 2013 -0700

    USB storage: audit sysfs attribute permissions
    
    Convert the usbsorage sysfs attribute to use the _RW macro to make it
    easier to determine the permissions for the file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 92b05d95ec5e..94d75edef77f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -496,7 +496,7 @@ US_DO_ALL_FLAGS
  ***********************************************************************/
 
 /* Output routine for the sysfs max_sectors file */
-static ssize_t show_max_sectors(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t max_sectors_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
 
@@ -504,7 +504,7 @@ static ssize_t show_max_sectors(struct device *dev, struct device_attribute *att
 }
 
 /* Input routine for the sysfs max_sectors file */
-static ssize_t store_max_sectors(struct device *dev, struct device_attribute *attr, const char *buf,
+static ssize_t max_sectors_store(struct device *dev, struct device_attribute *attr, const char *buf,
 		size_t count)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
@@ -514,16 +514,14 @@ static ssize_t store_max_sectors(struct device *dev, struct device_attribute *at
 		blk_queue_max_hw_sectors(sdev->request_queue, ms);
 		return count;
 	}
-	return -EINVAL;	
+	return -EINVAL;
 }
-
-static DEVICE_ATTR(max_sectors, S_IRUGO | S_IWUSR, show_max_sectors,
-		store_max_sectors);
+static DEVICE_ATTR_RW(max_sectors);
 
 static struct device_attribute *sysfs_device_attr_list[] = {
-		&dev_attr_max_sectors,
-		NULL,
-		};
+	&dev_attr_max_sectors,
+	NULL,
+};
 
 /*
  * this defines our host template, with which we'll allocate hosts

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit 191648d03d20229523d9a75b8abef56421298d28
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 19 11:44:00 2013 -0700

    usb: storage: Convert US_DEBUGP to usb_stor_dbg
    
    Use a more current logging style with dev_printk
    where possible.
    
    o Convert uses of US_DEBUGP to usb_stor_dbg
    o Add "struct us_data *" to usb_stor_dbg uses
    o usb_stor_dbg now uses struct device */dev_vprint_emit
    o Removed embedded function names
    o Coalesce formats
    o Remove trailing whitespace
    o Remove useless OOM messages
    o Remove useless function entry/exit logging
    o Convert some US_DEBUGP uses to dev_info and dev_dbg
    
    Object size is slightly reduced when debugging
    is enabled, slightly increased with no debugging
    because some initialization and removal messages
    are now always emitted.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 92f35abee92d..4faa982807f2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -313,8 +313,6 @@ static int queuecommand_lck(struct scsi_cmnd *srb,
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
-	US_DEBUGP("%s called\n", __func__);
-
 	/* check for state-transition errors */
 	if (us->srb != NULL) {
 		printk(KERN_ERR USB_STORAGE "Error in %s: us->srb = %p\n",
@@ -324,7 +322,7 @@ static int queuecommand_lck(struct scsi_cmnd *srb,
 
 	/* fail the command if we are disconnecting */
 	if (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {
-		US_DEBUGP("Fail command during disconnect\n");
+		usb_stor_dbg(us, "Fail command during disconnect\n");
 		srb->result = DID_NO_CONNECT << 16;
 		done(srb);
 		return 0;
@@ -349,7 +347,7 @@ static int command_abort(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
-	US_DEBUGP("%s called\n", __func__);
+	usb_stor_dbg(us, "%s called\n", __func__);
 
 	/* us->srb together with the TIMED_OUT, RESETTING, and ABORTING
 	 * bits are protected by the host lock. */
@@ -358,7 +356,7 @@ static int command_abort(struct scsi_cmnd *srb)
 	/* Is this command still active? */
 	if (us->srb != srb) {
 		scsi_unlock(us_to_host(us));
-		US_DEBUGP ("-- nothing to abort\n");
+		usb_stor_dbg(us, "-- nothing to abort\n");
 		return FAILED;
 	}
 
@@ -386,7 +384,7 @@ static int device_reset(struct scsi_cmnd *srb)
 	struct us_data *us = host_to_us(srb->device->host);
 	int result;
 
-	US_DEBUGP("%s called\n", __func__);
+	usb_stor_dbg(us, "%s called\n", __func__);
 
 	/* lock the device pointers and do the reset */
 	mutex_lock(&(us->dev_mutex));
@@ -402,7 +400,8 @@ static int bus_reset(struct scsi_cmnd *srb)
 	struct us_data *us = host_to_us(srb->device->host);
 	int result;
 
-	US_DEBUGP("%s called\n", __func__);
+	usb_stor_dbg(us, "%s called\n", __func__);
+
 	result = usb_stor_port_reset(us);
 	return result < 0 ? FAILED : SUCCESS;
 }

commit 09dae7fc57a010288875ef46a44e30d16cedd232
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 01:37:13 2013 -0400

    usb-storage: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 92f35abee92d..615c66eaedeb 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -438,22 +438,21 @@ void usb_stor_report_bus_reset(struct us_data *us)
  * /proc/scsi/ functions
  ***********************************************************************/
 
+static int write_info(struct Scsi_Host *host, char *buffer, int length)
+{
+	/* if someone is sending us data, just throw it away */
+	return length;
+}
+
 /* we use this macro to help us write into the buffer */
 #undef SPRINTF
-#define SPRINTF(args...) \
-	do { if (pos < buffer+length) pos += sprintf(pos, ## args); } while (0)
+#define SPRINTF(args...) seq_printf(m, ## args)
 
-static int proc_info (struct Scsi_Host *host, char *buffer,
-		char **start, off_t offset, int length, int inout)
+static int show_info (struct seq_file *m, struct Scsi_Host *host)
 {
 	struct us_data *us = host_to_us(host);
-	char *pos = buffer;
 	const char *string;
 
-	/* if someone is sending us data, just throw it away */
-	if (inout)
-		return length;
-
 	/* print the controller name */
 	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
 
@@ -483,28 +482,14 @@ static int proc_info (struct Scsi_Host *host, char *buffer,
 	SPRINTF("    Transport: %s\n", us->transport_name);
 
 	/* show the device flags */
-	if (pos < buffer + length) {
-		pos += sprintf(pos, "       Quirks:");
+	SPRINTF("       Quirks:");
 
 #define US_FLAG(name, value) \
-	if (us->fflags & value) pos += sprintf(pos, " " #name);
+	if (us->fflags & value) seq_printf(m, " " #name);
 US_DO_ALL_FLAGS
 #undef US_FLAG
-
-		*(pos++) = '\n';
-	}
-
-	/*
-	 * Calculate start of next buffer, and return value.
-	 */
-	*start = buffer + offset;
-
-	if ((pos - buffer) < offset)
-		return (0);
-	else if ((pos - buffer - offset) < length)
-		return (pos - buffer - offset);
-	else
-		return (length);
+	seq_putc(m, '\n');
+	return 0;
 }
 
 /***********************************************************************
@@ -549,7 +534,8 @@ struct scsi_host_template usb_stor_host_template = {
 	/* basic userland interface stuff */
 	.name =				"usb-storage",
 	.proc_name =			"usb-storage",
-	.proc_info =			proc_info,
+	.show_info =			show_info,
+	.write_info =			write_info,
 	.info =				host_info,
 
 	/* command interface -- queued only */

commit 5db44863b6ebbb400c5e61d56ebe8f21ef48b1bd
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Tue Sep 18 12:19:32 2012 -0400

    [SCSI] sd: Implement support for WRITE SAME
    
    Implement support for WRITE SAME(10) and WRITE SAME(16) in the SCSI disk
    driver.
    
     - We set the default maximum to 0xFFFF because there are several
       devices out there that only support two-byte block counts even with
       WRITE SAME(16). We only enable transfers bigger than 0xFFFF if the
       device explicitly reports MAXIMUM WRITE SAME LENGTH in the BLOCK
       LIMITS VPD.
    
     - max_write_same_blocks can be overriden per-device basis in sysfs.
    
     - The UNMAP discovery heuristics remain unchanged but the discard
       limits are tweaked to match the "real" WRITE SAME commands.
    
     - In the error handling logic we now distinguish between WRITE SAME
       with and without UNMAP set.
    
    The discovery process heuristics are:
    
     - If the device reports a SCSI level of SPC-3 or greater we'll issue
       READ SUPPORTED OPERATION CODES to find out whether WRITE SAME(16) is
       supported. If that's the case we will use it.
    
     - If the device supports the block limits VPD and reports a MAXIMUM
       WRITE SAME LENGTH bigger than 0xFFFF we will use WRITE SAME(16).
    
     - Otherwise we will use WRITE SAME(10) unless the target LBA is beyond
       0xFFFFFFFF or the block count exceeds 0xFFFF.
    
     - no_write_same is set for ATA, FireWire and USB.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Mike Snitzer <snitzer@redhat.com>
    Reviewed-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 6ab376a7c501..92f35abee92d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -189,6 +189,9 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Do not attempt to use REPORT SUPPORTED OPERATION CODES */
 		sdev->no_report_opcodes = 1;
 
+		/* Do not attempt to use WRITE SAME */
+		sdev->no_write_same = 1;
+
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */

commit 3c6bdaeab4fda6c9fdd5f3f5c610dea97bddf7d6
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Tue Sep 18 12:19:30 2012 -0400

    [SCSI] Add a report opcode helper
    
    The REPORT SUPPORTED OPERATION CODES command can be used to query
    whether a given opcode is supported by a device. Add a helper function
    that allows us to look up commands.
    
    We only issue RSOC if the device reports compliance with SPC-3 or
    later. But to err on the side of caution we disable the command for ATA,
    FireWire and USB.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a3d54366afcc..6ab376a7c501 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -186,6 +186,9 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Some devices don't handle VPD pages correctly */
 		sdev->skip_vpd_pages = 1;
 
+		/* Do not attempt to use REPORT SUPPORTED OPERATION CODES */
+		sdev->no_report_opcodes = 1;
+
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */

commit eaa05dfcdb12cf3a7bedf8918dc8699c00944384
Author: Namjae Jeon <namjae.jeon@samsung.com>
Date:   Sat Jul 7 23:05:28 2012 -0400

    [SCSI] usb-storage: add support for write cache quirk
    
    Add support for write cache quirk on usb hdd. scsi driver will be set to wce
    by detecting write cache quirk in quirk list when plugging usb hdd.
    
    Signed-off-by: Namjae Jeon <namjae.jeon@samsung.com>
    Signed-off-by: Pankaj Kumar <pankaj.km@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 11418da9bc09..a3d54366afcc 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -236,6 +236,11 @@ static int slave_configure(struct scsi_device *sdev)
 					US_FL_SCM_MULT_TARG)) &&
 				us->protocol == USB_PR_BULK)
 			us->use_last_sector_hacks = 1;
+
+		/* Check if write cache default on flag is set or not */
+		if (us->fflags & US_FL_WRITE_CACHE)
+			sdev->wce_default_on = 1;
+
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit 6a0bdffa0073857870a4ed1b4489762146359eb4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jun 20 16:04:19 2012 -0400

    SCSI & usb-storage: add try_rc_10_first flag
    
    Several bug reports have been received recently for USB mass-storage
    devices that don't handle READ CAPACITY(16) commands properly.  They
    report bogus sizes, in some cases becoming unusable as a result.
    
    The bugs were triggered by commit
    09b6b51b0b6c1b9bb61815baf205e4d74c89ff04 (SCSI & usb-storage: add
    flags for VPD pages and REPORT LUNS), which caused usb-storage to stop
    overriding the SCSI level reported by devices.  By default, the sd
    driver will try READ CAPACITY(16) first for any device whose level is
    above SCSI_SPC_2.
    
    It seems likely that any device large enough to require the use of
    READ CAPACITY(16) (i.e., 2 TB or more) would be able to handle READ
    CAPACITY(10) commands properly.  Indeed, I don't know of any devices
    that don't handle READ CAPACITY(10) properly.
    
    Therefore this patch (as1559) adds a new flag telling the sd driver
    to try READ CAPACITY(10) before READ CAPACITY(16), and sets this flag
    for every USB mass-storage device.  If a device really is larger than
    2 TB, sd will fall back to READ CAPACITY(16) just as it used to.
    
    This fixes Bugzilla #43391.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    CC: "James E.J. Bottomley" <JBottomley@parallels.com>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a324a5d21e99..11418da9bc09 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -202,6 +202,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_NO_READ_CAPACITY_16)
 			sdev->no_read_capacity_16 = 1;
 
+		/*
+		 * Many devices do not respond properly to READ_CAPACITY_16.
+		 * Tell the SCSI layer to try READ_CAPACITY_10 first.
+		 */
+		sdev->try_rc_10_first = 1;
+
 		/* assume SPC3 or latter devices support sense size > 18 */
 		if (sdev->scsi_level > SCSI_SPC_2)
 			us->fflags |= US_FL_SANE_SENSE;

commit af74d2dae8f85a0e90a30594beb507f5d954fa3f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 10 13:43:40 2012 -0500

    usb-storage: reorganize target-specific code
    
    Now that usb-storage has a target_alloc() routine, this patch (as1508)
    moves some existing target-specific code out of the slave_alloc()
    routine to where it really belongs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index dc68cc9fef5d..a324a5d21e99 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -78,8 +78,6 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
-	struct us_data *us = host_to_us(sdev->host);
-
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
@@ -104,18 +102,6 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
 
-	/*
-	 * The UFI spec treates the Peripheral Qualifier bits in an
-	 * INQUIRY result as reserved and requires devices to set them
-	 * to 0.  However the SCSI spec requires these bits to be set
-	 * to 3 to indicate when a LUN is not present.
-	 *
-	 * Let the scanning code know if this target merely sets
-	 * Peripheral Device Type to 0x1f to indicate no LUN.
-	 */
-	if (us->subclass == USB_SC_UFI)
-		sdev->sdev_target->pdt_1f_for_no_lun = 1;
-
 	return 0;
 }
 
@@ -278,6 +264,8 @@ static int slave_configure(struct scsi_device *sdev)
 
 static int target_alloc(struct scsi_target *starget)
 {
+	struct us_data *us = host_to_us(dev_to_shost(starget->dev.parent));
+
 	/*
 	 * Some USB drives don't support REPORT LUNS, even though they
 	 * report a SCSI revision level above 2.  Tell the SCSI layer
@@ -285,6 +273,19 @@ static int target_alloc(struct scsi_target *starget)
 	 * scan instead.
 	 */
 	starget->no_report_luns = 1;
+
+	/*
+	 * The UFI spec treats the Peripheral Qualifier bits in an
+	 * INQUIRY result as reserved and requires devices to set them
+	 * to 0.  However the SCSI spec requires these bits to be set
+	 * to 3 to indicate when a LUN is not present.
+	 *
+	 * Let the scanning code know if this target merely sets
+	 * Peripheral Device Type to 0x1f to indicate no LUN.
+	 */
+	if (us->subclass == USB_SC_UFI)
+		starget->pdt_1f_for_no_lun = 1;
+
 	return 0;
 }
 

commit 09b6b51b0b6c1b9bb61815baf205e4d74c89ff04
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 10 13:43:30 2012 -0500

    SCSI & usb-storage: add flags for VPD pages and REPORT LUNS
    
    This patch (as1507) adds a skip_vpd_pages flag to struct scsi_device
    and a no_report_luns flag to struct scsi_target.  The first is used to
    control whether sd will look at VPD pages for information on block
    provisioning, limits, and characteristics.  The second prevents
    scsi_report_lun_scan() from issuing a REPORT LUNS command.
    
    The patch also modifies usb-storage to set the new flag bits for all
    USB devices and targets, and to stop adjusting the scsi_level value.
    
    Historically we have seen that USB mass-storage devices often don't
    support VPD pages or REPORT LUNS properly.  Until now we have avoided
    these things by setting the scsi_level to SCSI_2 for all USB devices.
    But this has the side effect of storing the LUN bits into the second
    byte of each CDB, and now we have a report of a device which doesn't
    like that.  The best solution is to stop abusing scsi_level and
    instead have separate flags for VPD pages and REPORT LUNS.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Perry Wagle <wagle@mac.com>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 13b8bcdf3dba..dc68cc9fef5d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -197,6 +197,9 @@ static int slave_configure(struct scsi_device *sdev)
 		 * page x08, so we will skip it. */
 		sdev->skip_ms_page_8 = 1;
 
+		/* Some devices don't handle VPD pages correctly */
+		sdev->skip_vpd_pages = 1;
+
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */
@@ -217,16 +220,6 @@ static int slave_configure(struct scsi_device *sdev)
 		if (sdev->scsi_level > SCSI_SPC_2)
 			us->fflags |= US_FL_SANE_SENSE;
 
-		/* Some devices report a SCSI revision level above 2 but are
-		 * unable to handle the REPORT LUNS command (for which
-		 * support is mandatory at level 3).  Since we already have
-		 * a Get-Max-LUN request, we won't lose much by setting the
-		 * revision level down to 2.  The only devices that would be
-		 * affected are those with sparse LUNs. */
-		if (sdev->scsi_level > SCSI_2)
-			sdev->sdev_target->scsi_level =
-					sdev->scsi_level = SCSI_2;
-
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
 		 * recoverable or not.  Setting this flag tells the SCSI
@@ -283,6 +276,18 @@ static int slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+static int target_alloc(struct scsi_target *starget)
+{
+	/*
+	 * Some USB drives don't support REPORT LUNS, even though they
+	 * report a SCSI revision level above 2.  Tell the SCSI layer
+	 * not to issue that command; it will perform a normal sequential
+	 * scan instead.
+	 */
+	starget->no_report_luns = 1;
+	return 0;
+}
+
 /* queue a command */
 /* This is always called with scsi_lock(host) held */
 static int queuecommand_lck(struct scsi_cmnd *srb,
@@ -546,6 +551,7 @@ struct scsi_host_template usb_stor_host_template = {
 
 	.slave_alloc =			slave_alloc,
 	.slave_configure =		slave_configure,
+	.target_alloc =			target_alloc,
 
 	/* lots of sg segments can be handled */
 	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 689ee1fb702a..13b8bcdf3dba 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -123,7 +123,7 @@ static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
 
-	/* Many devices have trouble transfering more than 32KB at a time,
+	/* Many devices have trouble transferring more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a688b1e686ea..689ee1fb702a 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -285,7 +285,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 /* queue a command */
 /* This is always called with scsi_lock(host) held */
-static int queuecommand(struct scsi_cmnd *srb,
+static int queuecommand_lck(struct scsi_cmnd *srb,
 			void (*done)(struct scsi_cmnd *))
 {
 	struct us_data *us = host_to_us(srb->device->host);
@@ -315,6 +315,8 @@ static int queuecommand(struct scsi_cmnd *srb,
 	return 0;
 }
 
+static DEF_SCSI_QCMD(queuecommand)
+
 /***********************************************************************
  * Error handling functions
  ***********************************************************************/

commit 00914025cc4e783d4703b4db1d47b41f389e50c8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 1 14:20:11 2010 -0700

    usb-storage: add new no_read_capacity_16 quirk
    
    Some Rockbox based mp4 players will crash when ever they see a
    read_capacity_16 scsi command.  So add a new US_FL which tells the scsi sd
    driver to not issue any read_capacity_16 scsi commands.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a1128ff5cc2c..a688b1e686ea 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -209,6 +209,10 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_CAPACITY_HEURISTICS)
 			sdev->guess_capacity = 1;
 
+		/* Some devices cannot handle READ_CAPACITY_16 */
+		if (us->fflags & US_FL_NO_READ_CAPACITY_16)
+			sdev->no_read_capacity_16 = 1;
+
 		/* assume SPC3 or latter devices support sense size > 18 */
 		if (sdev->scsi_level > SCSI_SPC_2)
 			us->fflags |= US_FL_SANE_SENSE;

commit ae38c78a03e1b77ad45248fcf097e4568e740209
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 1 14:20:10 2010 -0700

    usb-storage: add new no_read_disc_info quirk
    
    Appotech ax3003 (the larger brother of the ax203) based devices are even
    more buggy then the ax203.  They will go of into lala land when ever they
    see a READ_DISC_INFO scsi command.  So add a new US_FL which tells the
    scsi sr driver to not issue any READ_DISC_INFO scsi commands.
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e80362d148f3..a1128ff5cc2c 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -253,6 +253,10 @@ static int slave_configure(struct scsi_device *sdev)
 		 * or to force 192-byte transfer lengths for MODE SENSE.
 		 * But they do need to use MODE SENSE(10). */
 		sdev->use_10_for_ms = 1;
+
+		/* Some (fake) usb cdrom devices don't like READ_DISC_INFO */
+		if (us->fflags & US_FL_NO_READ_DISC_INFO)
+			sdev->no_read_disc_info = 1;
 	}
 
 	/* The CB and CBI transports have no way to pass LUN values

commit 8fa7fd74ef398370383df276ca41082ba35aafd8
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Thu Oct 7 13:05:21 2010 +0200

    USB: storage: Use USB_ prefix instead of US_ prefix
    
    This commit changes prefix for some of the USB mass storage
    class related macros (ie. USB_SC_ for subclass and USB_PR_
    for class).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index d8d98cfecada..e80362d148f3 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -113,7 +113,7 @@ static int slave_alloc (struct scsi_device *sdev)
 	 * Let the scanning code know if this target merely sets
 	 * Peripheral Device Type to 0x1f to indicate no LUN.
 	 */
-	if (us->subclass == US_SC_UFI)
+	if (us->subclass == USB_SC_UFI)
 		sdev->sdev_target->pdt_1f_for_no_lun = 1;
 
 	return 0;
@@ -176,7 +176,7 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Disk-type devices use MODE SENSE(6) if the protocol
 		 * (SubClass) is Transparent SCSI, otherwise they use
 		 * MODE SENSE(10). */
-		if (us->subclass != US_SC_SCSI && us->subclass != US_SC_CYP_ATACB)
+		if (us->subclass != USB_SC_SCSI && us->subclass != USB_SC_CYP_ATACB)
 			sdev->use_10_for_ms = 1;
 
 		/* Many disks only accept MODE SENSE transfer lengths of
@@ -245,7 +245,7 @@ static int slave_configure(struct scsi_device *sdev)
 		 * capacity will be decremented or is correct. */
 		if (!(us->fflags & (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |
 					US_FL_SCM_MULT_TARG)) &&
-				us->protocol == US_PR_BULK)
+				us->protocol == USB_PR_BULK)
 			us->use_last_sector_hacks = 1;
 	} else {
 
@@ -261,7 +261,7 @@ static int slave_configure(struct scsi_device *sdev)
 	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily
 	 * be single-LUN.
 	 */
-	if ((us->protocol == US_PR_CB || us->protocol == US_PR_CBI) &&
+	if ((us->protocol == USB_PR_CB || us->protocol == USB_PR_CBI) &&
 			sdev->scsi_level == SCSI_UNKNOWN)
 		us->max_lun = 0;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 4cc035562cc2..d8d98cfecada 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -43,7 +43,6 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 

commit 49d6271b85a3e18062eaf4d6f8d899abe00a7725
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Feb 26 11:49:39 2010 -0500

    usb-storage: use max_hw_sectors instead of max_sectors
    
    This patch (as1347) makes some adjustments to the way usb-storage
    handles the request-queue parameters.
    
    USB host controllers are able to handle arbitrarily long
    scatter-gather lists, since they are limited only by main memory and
    not by the controller hardware.  Hence the sg_tablesize field in the
    host template can be increased to the maximum value.
    
    Drivers like usb-storage aren't supposed to touch the queue's
    max_sectors parameter; instead they are supposed to use the
    max_hw_sectors value.  Accordingly, the patch replaces calls of
    queue_max_sectors() with calls of queue_max_hw_sectors().  Oddly
    enough, the blk_queue_max_sectors() routine is nevertheless still
    appropriate.
    
    The existing code imposes a limit of SCSI_DEFAULT_MAX_SECTORS (1024)
    on the values accepted by the max_sectors attribute file.  There's no
    reason not to accept larger values, so the limit is removed.  (It
    would be nice to change the file's name to max_hw_sectors, but the old
    name is already a well-established API.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index aadc16b5eed7..4cc035562cc2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -133,7 +133,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 		if (us->fflags & US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE >> 9;
-		if (queue_max_sectors(sdev->request_queue) > max_sectors)
+		if (queue_max_hw_sectors(sdev->request_queue) > max_sectors)
 			blk_queue_max_hw_sectors(sdev->request_queue,
 					      max_sectors);
 	} else if (sdev->type == TYPE_TAPE) {
@@ -484,7 +484,7 @@ static ssize_t show_max_sectors(struct device *dev, struct device_attribute *att
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
 
-	return sprintf(buf, "%u\n", queue_max_sectors(sdev->request_queue));
+	return sprintf(buf, "%u\n", queue_max_hw_sectors(sdev->request_queue));
 }
 
 /* Input routine for the sysfs max_sectors file */
@@ -494,9 +494,9 @@ static ssize_t store_max_sectors(struct device *dev, struct device_attribute *at
 	struct scsi_device *sdev = to_scsi_device(dev);
 	unsigned short ms;
 
-	if (sscanf(buf, "%hu", &ms) > 0 && ms <= SCSI_DEFAULT_MAX_SECTORS) {
+	if (sscanf(buf, "%hu", &ms) > 0) {
 		blk_queue_max_hw_sectors(sdev->request_queue, ms);
-		return strlen(buf);
+		return count;
 	}
 	return -EINVAL;	
 }
@@ -539,7 +539,7 @@ struct scsi_host_template usb_stor_host_template = {
 	.slave_configure =		slave_configure,
 
 	/* lots of sg segments can be handled */
-	.sg_tablesize =			SG_ALL,
+	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
 
 	/* limit the total size of a transfer to 120 KB */
 	.max_sectors =                  240,

commit 086fa5ff0854c676ec333760f4c0154b3b242616
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Feb 26 00:20:38 2010 -0500

    block: Rename blk_queue_max_sectors to blk_queue_max_hw_sectors
    
    The block layer calling convention is blk_queue_<limit name>.
    blk_queue_max_sectors predates this practice, leading to some confusion.
    Rename the function to appropriately reflect that its intended use is to
    set max_hw_sectors.
    
    Also introduce a temporary wrapper for backwards compability.  This can
    be removed after the merge window is closed.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e5e6df39e737..aadc16b5eed7 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -134,14 +134,14 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE >> 9;
 		if (queue_max_sectors(sdev->request_queue) > max_sectors)
-			blk_queue_max_sectors(sdev->request_queue,
+			blk_queue_max_hw_sectors(sdev->request_queue,
 					      max_sectors);
 	} else if (sdev->type == TYPE_TAPE) {
 		/* Tapes need much higher max_sector limits, so just
 		 * raise it to the maximum possible (4 GB / 512) and
 		 * let the queue segment size sort out the real limit.
 		 */
-		blk_queue_max_sectors(sdev->request_queue, 0x7FFFFF);
+		blk_queue_max_hw_sectors(sdev->request_queue, 0x7FFFFF);
 	}
 
 	/* Some USB host controllers can't do DMA; they have to use PIO.
@@ -495,7 +495,7 @@ static ssize_t store_max_sectors(struct device *dev, struct device_attribute *at
 	unsigned short ms;
 
 	if (sscanf(buf, "%hu", &ms) > 0 && ms <= SCSI_DEFAULT_MAX_SECTORS) {
-		blk_queue_max_sectors(sdev->request_queue, ms);
+		blk_queue_max_hw_sectors(sdev->request_queue, ms);
 		return strlen(buf);
 	}
 	return -EINVAL;	

commit 00fa43ef09c6bb357d58c14a99181cce09c315c6
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Thu Sep 24 16:19:11 2009 -0600

    USB: usb-storage: Associate the name of the interface with the scsi host
    
    Instead of reporting "SCSI emulation for USB Mass Storage devices",
    report "usb-storage 1-4:1.0".
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index cfa26d56ce60..e5e6df39e737 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -73,7 +73,8 @@
 
 static const char* host_info(struct Scsi_Host *host)
 {
-	return "SCSI emulation for USB Mass Storage devices";
+	struct us_data *us = host_to_us(host);
+	return us->scsi_name;
 }
 
 static int slave_alloc (struct scsi_device *sdev)

commit ae03bf639a5027d27270123f5f6e3ee6a412781d
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri May 22 17:17:50 2009 -0400

    block: Use accessor functions for queue limits
    
    Convert all external users of queue limits to using wrapper functions
    instead of poking the request queue variables directly.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 4ca3b5860643..cfa26d56ce60 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -132,7 +132,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 		if (us->fflags & US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE >> 9;
-		if (sdev->request_queue->max_sectors > max_sectors)
+		if (queue_max_sectors(sdev->request_queue) > max_sectors)
 			blk_queue_max_sectors(sdev->request_queue,
 					      max_sectors);
 	} else if (sdev->type == TYPE_TAPE) {
@@ -483,7 +483,7 @@ static ssize_t show_max_sectors(struct device *dev, struct device_attribute *att
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
 
-	return sprintf(buf, "%u\n", sdev->request_queue->max_sectors);
+	return sprintf(buf, "%u\n", queue_max_sectors(sdev->request_queue));
 }
 
 /* Input routine for the sysfs max_sectors file */

commit e6e244b6cb1f70e7109381626293cd40a8334ed3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 12 14:47:44 2009 -0500

    usb-storage: prepare for subdriver separation
    
    This patch (as1206) is the first step in converting usb-storage's
    subdrivers into separate modules.  It makes the following large-scale
    changes:
    
            Remove a bunch of unnecessary #ifdef's from usb_usual.h.
            Not truly necessary, but it does clean things up.
    
            Move the USB device-ID table (which is duplicated between
            libusual and usb-storage) into its own source file,
            usual-tables.c, and arrange for this to be linked with
            either libusual or usb-storage according to whether
            USB_LIBUSUAL is configured.
    
            Add to usual-tables.c a new usb_usual_ignore_device()
            function to detect whether a particular device needs to be
            managed by a subdriver and not by the standard handlers
            in usb-storage.
    
            Export a whole bunch of functions in usb-storage, renaming
            some of them because their names don't already begin with
            "usb_stor_".  These functions will be needed by the new
            subdriver modules.
    
            Split usb-storage's probe routine into two functions.
            The subdrivers will call the probe1 routine, then fill in
            their transport and protocol settings, and then call the
            probe2 routine.
    
            Take the default cases and error checking out of
            get_transport() and get_protocol(), which run during
            probe1, and instead put a check for invalid transport
            or protocol values into the probe2 function.
    
            Add a new probe routine to be used for standard devices,
            i.e., those that don't need a subdriver.  This new routine
            checks whether the device should be ignored (because it
            should be handled by ub or by a subdriver), and if not,
            calls the probe1 and probe2 functions.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index ed710bcdaab2..4ca3b5860643 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -569,4 +569,4 @@ unsigned char usb_stor_sense_invalidCDB[18] = {
 	[7]	= 0x0a,			    /* additional length */
 	[12]	= 0x24			    /* Invalid Field in CDB */
 };
-
+EXPORT_SYMBOL_GPL(usb_stor_sense_invalidCDB);

commit 5c16034d73da2c1b663aa25dedadbc533b3d811c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 23 09:51:02 2009 -0400

    USB: usb-storage: increase max_sectors for tape drives
    
    This patch (as1203) increases the max_sector limit for USB tape
    drives.  By default usb-storage sets max_sectors to 240 (i.e., 120 KB)
    for all devices.  But tape drives need a higher limit, since tapes can
    and do have very large block sizes.  Without the ability to transfer
    an entire large block in a single command, such tapes can't be used.
    
    This fixes Bugzilla #12207.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Phil Mitchell <philipm@sybase.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 727c506417cc..ed710bcdaab2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -135,6 +135,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (sdev->request_queue->max_sectors > max_sectors)
 			blk_queue_max_sectors(sdev->request_queue,
 					      max_sectors);
+	} else if (sdev->type == TYPE_TAPE) {
+		/* Tapes need much higher max_sector limits, so just
+		 * raise it to the maximum possible (4 GB / 512) and
+		 * let the queue segment size sort out the real limit.
+		 */
+		blk_queue_max_sectors(sdev->request_queue, 0x7FFFFF);
 	}
 
 	/* Some USB host controllers can't do DMA; they have to use PIO.

commit 506e9469833c66ed6bb9acd902e208f7301b6adb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Feb 4 15:48:03 2009 -0500

    USB: usb-storage: add Pentax to the bad-vendor list
    
    This patch (as1202) adds Pentax to usb-storage's list of bad vendors
    whose devices always need the CAPACITY_HEURISTICS flag.  This is in
    addition to the existing entries: Nokia, Nikon, and Motorola.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Virgo Pärna <virgo.parna@mail.ee>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 2a42b862aa9f..727c506417cc 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -64,6 +64,7 @@
  */
 #define VENDOR_ID_NOKIA		0x0421
 #define VENDOR_ID_NIKON		0x04b0
+#define VENDOR_ID_PENTAX	0x0a17
 #define VENDOR_ID_MOTOROLA	0x22b8
 
 /***********************************************************************
@@ -158,6 +159,7 @@ static int slave_configure(struct scsi_device *sdev)
 		switch (le16_to_cpu(us->pusb_dev->descriptor.idVendor)) {
 		case VENDOR_ID_NOKIA:
 		case VENDOR_ID_NIKON:
+		case VENDOR_ID_PENTAX:
 		case VENDOR_ID_MOTOROLA:
 			if (!(us->fflags & (US_FL_FIX_CAPACITY |
 					US_FL_CAPACITY_OK)))

commit a81a81a25d3ecdab777abca87c5ddf484056103d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Dec 18 16:41:49 2008 -0500

    USB: storage: set CAPACITY_HEURISTICS flag for bad vendors
    
    This patch (as1194) makes usb-storage set the CAPACITY_HEURISTICS flag
    for all devices made by Nokia, Nikon, or Motorola.  These companies
    seem to include the READ CAPACITY bug in all of their devices.
    
    Since cell phones and digital cameras rely on flash storage, which
    always has an even number of sectors, setting CAPACITY_HEURISTICS
    shouldn't cause any problems.  Not even if the companies wise up and
    start making devices without the bug.
    
    A large number of unusual_devs entries are now unnecessary, so the
    patch removes them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 8d78084abf9f..2a42b862aa9f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -59,6 +59,13 @@
 #include "transport.h"
 #include "protocol.h"
 
+/* Vendor IDs for companies that seem to include the READ CAPACITY bug
+ * in all their devices
+ */
+#define VENDOR_ID_NOKIA		0x0421
+#define VENDOR_ID_NIKON		0x04b0
+#define VENDOR_ID_MOTOROLA	0x22b8
+
 /***********************************************************************
  * Host functions 
  ***********************************************************************/
@@ -142,6 +149,22 @@ static int slave_configure(struct scsi_device *sdev)
 	 * settings can't be overridden via the scsi devinfo mechanism. */
 	if (sdev->type == TYPE_DISK) {
 
+		/* Some vendors seem to put the READ CAPACITY bug into
+		 * all their devices -- primarily makers of cell phones
+		 * and digital cameras.  Since these devices always use
+		 * flash media and can be expected to have an even number
+		 * of sectors, we will always enable the CAPACITY_HEURISTICS
+		 * flag unless told otherwise. */
+		switch (le16_to_cpu(us->pusb_dev->descriptor.idVendor)) {
+		case VENDOR_ID_NOKIA:
+		case VENDOR_ID_NIKON:
+		case VENDOR_ID_MOTOROLA:
+			if (!(us->fflags & (US_FL_FIX_CAPACITY |
+					US_FL_CAPACITY_OK)))
+				us->fflags |= US_FL_CAPACITY_HEURISTICS;
+			break;
+		}
+
 		/* Disk-type devices use MODE SENSE(6) if the protocol
 		 * (SubClass) is Transparent SCSI, otherwise they use
 		 * MODE SENSE(10). */

commit 25ff1c316f6a763f1eefe7f8984b2d8c03888432
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Dec 15 12:43:41 2008 -0500

    USB: storage: add last-sector hacks
    
    This patch (as1189b) adds some hacks to usb-storage for dealing with
    the growing problems involving bad capacity values and last-sector
    accesses:
    
            A new flag, US_FL_CAPACITY_OK, is created to indicate that
            the device is known to report its capacity correctly.  An
            unusual_devs entry for Linux's own File-backed Storage Gadget
            is added with this flag set, since g_file_storage always
            reports the correct capacity and since the capacity need
            not be even (it is determined by the size of the backing
            file).
    
            An entry in unusual_devs.h which has only the CAPACITY_OK
            flag set shouldn't prejudice libusual, since the device will
            work perfectly well with either usb-storage or ub.  So a
            new macro, COMPLIANT_DEV, is added to let libusual know
            about these entries.
    
            When a last-sector access succeeds and the total number of
            sectors is odd (the unexpected case, in which guessing that
            the number is even might cause trouble), a WARN is triggered.
            The kerneloops.org project will collect these warnings,
            allowing us to add CAPACITY_OK flags for the devices in
            question before implementing the default-to-even heuristic.
            If users want to prevent the stack dump produced by the WARN,
            they can disable the hack by adding an unusual_devs entry
            for their device with the CAPACITY_OK flag.
    
            When a last-sector access fails three times in a row and
            neither the FIX_CAPACITY nor the CAPACITY_OK flag is set,
            we assume the last-sector bug is present.  We replace the
            existing status and sense data with values that will cause
            the SCSI core to fail the access immediately rather than
            retry indefinitely.  This should fix the difficulties
            people have been having with Nokia phones.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e9d6c196a7ab..8d78084abf9f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -208,6 +208,14 @@ static int slave_configure(struct scsi_device *sdev)
 		 * sector in a larger then 1 sector read, since the performance
 		 * impact is negible we set this flag for all USB disks */
 		sdev->last_sector_bug = 1;
+
+		/* Enable last-sector hacks for single-target devices using
+		 * the Bulk-only transport, unless we already know the
+		 * capacity will be decremented or is correct. */
+		if (!(us->fflags & (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |
+					US_FL_SCM_MULT_TARG)) &&
+				us->protocol == US_PR_BULK)
+			us->use_last_sector_hacks = 1;
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit 96983d2d861bf94b7f70bc47ac3c5b289f519a2d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 21 11:46:17 2008 -0500

    USB: storage: set bounce limit for non-DMA-capable host controllers
    
    This patch (as1175) makes usb-storage set a SCSI device's
    request-queue bounce limit such that all buffers will be located in
    addressable memory (i.e., not in high memory) if the host controller's
    dma_mask is NULL.  This is necessary when the host controller doesn't
    support DMA: If a buffer is in high memory then the both the virtual
    and DMA addresses produced by the scatter-gather library will be NULL,
    preventing the HCD from accessing the buffer's data.
    
    In particular, the isp1760 driver needs this when used on a system
    with more than 1 GB of memory.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Tested-by: Thomas Hommel <Thomas.Hommel@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1b35e011a34f..e9d6c196a7ab 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -129,6 +129,14 @@ static int slave_configure(struct scsi_device *sdev)
 					      max_sectors);
 	}
 
+	/* Some USB host controllers can't do DMA; they have to use PIO.
+	 * They indicate this by setting their dma_mask to NULL.  For
+	 * such controllers we need to make sure the block layer sets
+	 * up bounce buffers in addressable memory.
+	 */
+	if (!us->pusb_dev->bus->controller->dma_mask)
+		blk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);
+
 	/* We can't put these settings in slave_alloc() because that gets
 	 * called before the device type is known.  Consequently these
 	 * settings can't be overridden via the scsi devinfo mechanism. */

commit 1537e0ad944acf3a4c2b311a646d7993b89499f7
Author: Ben Efros <ben@pc-doctor.com>
Date:   Tue Nov 18 13:31:13 2008 -0800

    USB: storage devices and SAT
    
    Add the SANE SENSE flag to indicate that a device is capable of handling
    more than 18-bytes of sense data.  This functionality is required for
    USB-ATA bridges implementing SAT.  A future patch will actually enable this
    function for several devices.
    
    The logic behind this is that we can detect support for SANE_SENSE in a few ways:
     1) ATA PASS THROUGH (12) or (16) execute successfully
     2) SPC-3 or higher is in use
     3) A previous CHECK CONDITION occurred with sense format 70-73 and had
        a length greater than 18-bytes total
    
    Signed-off-by: Ben Efros <ben@pc-doctor.com>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 09779f6a8179..1b35e011a34f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -170,6 +170,10 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->fflags & US_FL_CAPACITY_HEURISTICS)
 			sdev->guess_capacity = 1;
 
+		/* assume SPC3 or latter devices support sense size > 18 */
+		if (sdev->scsi_level > SCSI_SPC_2)
+			us->fflags |= US_FL_SANE_SENSE;
+
 		/* Some devices report a SCSI revision level above 2 but are
 		 * unable to handle the REPORT LUNS command (for which
 		 * support is mandatory at level 3).  Since we already have

commit f756cbd458ab71c996a069cb3928fb1e2d7cd9cc
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 30 13:39:59 2008 -0400

    usb-storage: revert DMA-alignment change for Wireless USB
    
    This patch (as1110) reverts an earlier patch meant to help with
    Wireless USB host controllers.  These controllers can have bulk
    maxpacket values larger than 512, which puts unusual constraints on
    the sizes of scatter-gather list elements.  However it turns out that
    the block layer does not provide the support we need to enforce these
    constraints; merely changing the DMA alignment mask doesn't help.
    Hence there's no reason to keep the original patch.  The Wireless USB
    problem will have to be solved a different way.
    
    In addition, there is a reason to get rid of the earlier patch.  By
    dereferencing a pointer stored in the ep_in array of struct
    usb_device, the current code risks an invalid memory access when it
    runs concurrently with device removal.  The members of that array are
    cleared before the driver's disconnect method is called, so it should
    not try to use them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index b4c9e0f18a82..09779f6a8179 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -71,7 +71,6 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
-	struct usb_host_endpoint *bulk_in_ep;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -80,16 +79,22 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	sdev->inquiry_len = 36;
 
-	/* Scatter-gather buffers (all but the last) must have a length
-	 * divisible by the bulk maxpacket size.  Otherwise a data packet
-	 * would end up being short, causing a premature end to the data
-	 * transfer.  We'll use the maxpacket value of the bulk-IN pipe
-	 * to set the SCSI device queue's DMA alignment mask.
+	/* USB has unusual DMA-alignment requirements: Although the
+	 * starting address of each scatter-gather element doesn't matter,
+	 * the length of each element except the last must be divisible
+	 * by the Bulk maxpacket value.  There's currently no way to
+	 * express this by block-layer constraints, so we'll cop out
+	 * and simply require addresses to be aligned at 512-byte
+	 * boundaries.  This is okay since most block I/O involves
+	 * hardware sectors that are multiples of 512 bytes in length,
+	 * and since host controllers up through USB 2.0 have maxpacket
+	 * values no larger than 512.
+	 *
+	 * But it doesn't suffice for Wireless USB, where Bulk maxpacket
+	 * values can be as large as 2048.  To make that work properly
+	 * will require changes to the block layer.
 	 */
-	bulk_in_ep = us->pusb_dev->ep_in[usb_pipeendpoint(us->recv_bulk_pipe)];
-	blk_queue_update_dma_alignment(sdev->request_queue,
-			le16_to_cpu(bulk_in_ep->desc.wMaxPacketSize) - 1);
-			/* wMaxPacketSize must be a power of 2 */
+	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
 
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an

commit ea05af61a874ffbc158d9cf06df8a9396f299f38
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:00:46 2008 +0300

    USB: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 043b60b2ad17..b4c9e0f18a82 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -1,8 +1,6 @@
 /* Driver for USB Mass Storage compliant devices
  * SCSI layer glue code
  *
- * $Id: scsiglue.c,v 1.26 2002/04/22 03:39:43 mdharm Exp $
- *
  * Current development and maintenance by:
  *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
  *

commit 7119e3c37fbf7c27adb5929f344c826ecb8c7859
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu May 1 15:36:13 2008 -0400

    usb-storage: change remaining semaphore to completion
    
    This patch (as1090) converts the one remaining semaphore in
    usb-storage into a completion.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1caf3f7af349..043b60b2ad17 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -248,7 +248,7 @@ static int queuecommand(struct scsi_cmnd *srb,
 	/* enqueue the command and wake up the control thread */
 	srb->scsi_done = done;
 	us->srb = srb;
-	up(&(us->sema));
+	complete(&us->cmnd_ready);
 
 	return 0;
 }

commit 7e4d6c387994294ac8198b624ee71e75de60dfd2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu May 1 15:35:18 2008 -0400

    usb-storage: separate dynamic flags from fixed flags
    
    This patch (as1089) separates out the dynamic atomic bitflags and the
    static bitfields in usb-storage.  Until now the two sorts of flags
    have been sharing the same word; this has always been awkward.
    
    To help prevent possible confusion, the two new fields each have a
    different name from the original.  us->fflags contains the fixed
    bitfields (mostly taken from the USB ID table in unusual_devs.h), and
    us->dflags contains the dynamic atomic bitflags (used with set_bit,
    test_bit, and so on).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 3fcde9f0fa5f..1caf3f7af349 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -116,10 +116,10 @@ static int slave_configure(struct scsi_device *sdev)
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */
-	if (us->flags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {
+	if (us->fflags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {
 		unsigned int max_sectors = 64;
 
-		if (us->flags & US_FL_MAX_SECTORS_MIN)
+		if (us->fflags & US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE >> 9;
 		if (sdev->request_queue->max_sectors > max_sectors)
 			blk_queue_max_sectors(sdev->request_queue,
@@ -148,7 +148,7 @@ static int slave_configure(struct scsi_device *sdev)
 		 * majority of devices work fine, but a few still can't
 		 * handle it.  The sd driver will simply assume those
 		 * devices are write-enabled. */
-		if (us->flags & US_FL_NO_WP_DETECT)
+		if (us->fflags & US_FL_NO_WP_DETECT)
 			sdev->skip_ms_page_3f = 1;
 
 		/* A number of devices have problems with MODE SENSE for
@@ -158,13 +158,13 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */
-		if (us->flags & US_FL_FIX_CAPACITY)
+		if (us->fflags & US_FL_FIX_CAPACITY)
 			sdev->fix_capacity = 1;
 
 		/* A few disks have two indistinguishable version, one of
 		 * which reports the correct capacity and the other does not.
 		 * The sd driver has to guess which is the case. */
-		if (us->flags & US_FL_CAPACITY_HEURISTICS)
+		if (us->fflags & US_FL_CAPACITY_HEURISTICS)
 			sdev->guess_capacity = 1;
 
 		/* Some devices report a SCSI revision level above 2 but are
@@ -213,7 +213,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
 	 * REMOVAL command, so suppress those commands. */
-	if (us->flags & US_FL_NOT_LOCKABLE)
+	if (us->fflags & US_FL_NOT_LOCKABLE)
 		sdev->lockable = 0;
 
 	/* this is to satisfy the compiler, tho I don't think the 
@@ -238,7 +238,7 @@ static int queuecommand(struct scsi_cmnd *srb,
 	}
 
 	/* fail the command if we are disconnecting */
-	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
+	if (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {
 		US_DEBUGP("Fail command during disconnect\n");
 		srb->result = DID_NO_CONNECT << 16;
 		done(srb);
@@ -280,9 +280,9 @@ static int command_abort(struct scsi_cmnd *srb)
 	 * with the reset).  Note that we must retain the host lock while
 	 * calling usb_stor_stop_transport(); otherwise it might interfere
 	 * with an auto-reset that begins as soon as we release the lock. */
-	set_bit(US_FLIDX_TIMED_OUT, &us->flags);
-	if (!test_bit(US_FLIDX_RESETTING, &us->flags)) {
-		set_bit(US_FLIDX_ABORTING, &us->flags);
+	set_bit(US_FLIDX_TIMED_OUT, &us->dflags);
+	if (!test_bit(US_FLIDX_RESETTING, &us->dflags)) {
+		set_bit(US_FLIDX_ABORTING, &us->dflags);
 		usb_stor_stop_transport(us);
 	}
 	scsi_unlock(us_to_host(us));
@@ -329,7 +329,7 @@ void usb_stor_report_device_reset(struct us_data *us)
 	struct Scsi_Host *host = us_to_host(us);
 
 	scsi_report_device_reset(host, 0, 0);
-	if (us->flags & US_FL_SCM_MULT_TARG) {
+	if (us->fflags & US_FL_SCM_MULT_TARG) {
 		for (i = 1; i < host->max_id; ++i)
 			scsi_report_device_reset(host, 0, i);
 	}
@@ -400,7 +400,7 @@ static int proc_info (struct Scsi_Host *host, char *buffer,
 		pos += sprintf(pos, "       Quirks:");
 
 #define US_FLAG(name, value) \
-	if (us->flags & value) pos += sprintf(pos, " " #name);
+	if (us->fflags & value) pos += sprintf(pos, " " #name);
 US_DO_ALL_FLAGS
 #undef US_FLAG
 

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 521f0297aef9..3fcde9f0fa5f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -228,12 +228,12 @@ static int queuecommand(struct scsi_cmnd *srb,
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
-	US_DEBUGP("%s called\n", __FUNCTION__);
+	US_DEBUGP("%s called\n", __func__);
 
 	/* check for state-transition errors */
 	if (us->srb != NULL) {
 		printk(KERN_ERR USB_STORAGE "Error in %s: us->srb = %p\n",
-			__FUNCTION__, us->srb);
+			__func__, us->srb);
 		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
@@ -262,7 +262,7 @@ static int command_abort(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
-	US_DEBUGP("%s called\n", __FUNCTION__);
+	US_DEBUGP("%s called\n", __func__);
 
 	/* us->srb together with the TIMED_OUT, RESETTING, and ABORTING
 	 * bits are protected by the host lock. */
@@ -299,7 +299,7 @@ static int device_reset(struct scsi_cmnd *srb)
 	struct us_data *us = host_to_us(srb->device->host);
 	int result;
 
-	US_DEBUGP("%s called\n", __FUNCTION__);
+	US_DEBUGP("%s called\n", __func__);
 
 	/* lock the device pointers and do the reset */
 	mutex_lock(&(us->dev_mutex));
@@ -315,7 +315,7 @@ static int bus_reset(struct scsi_cmnd *srb)
 	struct us_data *us = host_to_us(srb->device->host);
 	int result;
 
-	US_DEBUGP("%s called\n", __FUNCTION__);
+	US_DEBUGP("%s called\n", __func__);
 	result = usb_stor_port_reset(us);
 	return result < 0 ? FAILED : SUCCESS;
 }

commit 148d9fe4c91a6356dae1b05b76b8133586c26be4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 27 14:52:57 2008 -0400

    USB: usb-storage: use adaptive DMA mask
    
    This patch (as1060) makes usb-storage set the DMA alignment mask for
    SCSI slaves to match the maxpacket size of the bulk-IN endpoint,
    rather than always setting it to 511.  For full-speed devices that
    mask is too restrictive, and wireless USB devices can have maxpacket
    sizes larger than 512.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5405ba8cd9d2..521f0297aef9 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -73,6 +73,7 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
+	struct usb_host_endpoint *bulk_in_ep;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -84,12 +85,13 @@ static int slave_alloc (struct scsi_device *sdev)
 	/* Scatter-gather buffers (all but the last) must have a length
 	 * divisible by the bulk maxpacket size.  Otherwise a data packet
 	 * would end up being short, causing a premature end to the data
-	 * transfer.  Since high-speed bulk pipes have a maxpacket size
-	 * of 512, we'll use that as the scsi device queue's DMA alignment
-	 * mask.  Guaranteeing proper alignment of the first buffer will
-	 * have the desired effect because, except at the beginning and
-	 * the end, scatter-gather buffers follow page boundaries. */
-	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
+	 * transfer.  We'll use the maxpacket value of the bulk-IN pipe
+	 * to set the SCSI device queue's DMA alignment mask.
+	 */
+	bulk_in_ep = us->pusb_dev->ep_in[usb_pipeendpoint(us->recv_bulk_pipe)];
+	blk_queue_update_dma_alignment(sdev->request_queue,
+			le16_to_cpu(bulk_in_ep->desc.wMaxPacketSize) - 1);
+			/* wMaxPacketSize must be a power of 2 */
 
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an

commit d277064e7e16d02e0078a6bc1820764ae00dea87
Author: matthieu castet <castet.matthieu@free.fr>
Date:   Wed Mar 19 19:40:52 2008 +0100

    USB: mass storage: emulation of sat scsi_pass_thru with ATACB
    
    I have got a cypress usb-ide bridge and I would like to tune or monitor
    my disk with tools like hdparm, hddtemp or smartctl.
    
    My controller support a way to send raw ATA command to the disk with
    something call atacb (see
    http://download.cypress.com.edgesuite.net/design_resources/datasheets/contents/cy7c68300c_8.pdf).
    
    Atacb support can be added for each application, but there is some disadvantages :
    - all application need to be patched
    - A race is possible if there other accesses, because the emulation can
    be split in 2 atacb scsi transactions. One for sending the command, one
    for reading the register (if ck_cond is set).
    
    I have implemented the emulation in usb-storage with a special proto_handler,
    and an unsual entry.
    
    Signed-off-by: Matthieu CASTET <castet.matthieu@free.fr>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 8c1e2954f3b9..5405ba8cd9d2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -132,7 +132,7 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Disk-type devices use MODE SENSE(6) if the protocol
 		 * (SubClass) is Transparent SCSI, otherwise they use
 		 * MODE SENSE(10). */
-		if (us->subclass != US_SC_SCSI)
+		if (us->subclass != US_SC_SCSI && us->subclass != US_SC_CYP_ATACB)
 			sdev->use_10_for_ms = 1;
 
 		/* Many disks only accept MODE SENSE transfer lengths of

commit 23c3e290fb9ce38cabc2822b47583fc8702411bf
Author: Hans de Goede <j.w.r.degoede@hhs.nl>
Date:   Sun Jan 20 11:27:29 2008 +0100

    [SCSI] usbstorage: use last_sector_bug flag universally
    
    This patch sets the last_sector_bug flag to 1 for all USB disks. This is
    needed to makes the cardreader on various HP multifunction printers work.
    
    Since the performance impact is negible we set this flag for all USB disks to
    avoid an unusual_devs.h nightmare.
    
    Signed-off-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Acked-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index dd8b13ef2414..8c1e2954f3b9 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -187,6 +187,10 @@ static int slave_configure(struct scsi_device *sdev)
 		 * automatically, requiring a START-STOP UNIT command. */
 		sdev->allow_restart = 1;
 
+		/* Some USB cardreaders have trouble reading an sdcard's last
+		 * sector in a larger then 1 sector read, since the performance
+		 * impact is negible we set this flag for all USB disks */
+		sdev->last_sector_bug = 1;
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit 465ff3185e0cb76d46137335a4d21d0d9d3ac8a2
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 1 10:00:10 2008 -0600

    [SCSI] relax scsi dma alignment
    
    This patch relaxes the default SCSI DMA alignment from 512 bytes to 4
    bytes.  I remember from previous discussions that usb and firewire have
    sector size alignment requirements, so I upped their alignments in the
    respective slave allocs.
    
    The reason for doing this is so that we don't get such a huge amount of
    copy overhead in bio_copy_user() for udev.  (basically all inquiries it
    issues can now be directly mapped).
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 7c9593b7b04e..dd8b13ef2414 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -81,6 +81,16 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	sdev->inquiry_len = 36;
 
+	/* Scatter-gather buffers (all but the last) must have a length
+	 * divisible by the bulk maxpacket size.  Otherwise a data packet
+	 * would end up being short, causing a premature end to the data
+	 * transfer.  Since high-speed bulk pipes have a maxpacket size
+	 * of 512, we'll use that as the scsi device queue's DMA alignment
+	 * mask.  Guaranteeing proper alignment of the first buffer will
+	 * have the desired effect because, except at the beginning and
+	 * the end, scatter-gather buffers follow page boundaries. */
+	blk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));
+
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an
 	 * INQUIRY result as reserved and requires devices to set them
@@ -100,16 +110,6 @@ static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
 
-	/* Scatter-gather buffers (all but the last) must have a length
-	 * divisible by the bulk maxpacket size.  Otherwise a data packet
-	 * would end up being short, causing a premature end to the data
-	 * transfer.  Since high-speed bulk pipes have a maxpacket size
-	 * of 512, we'll use that as the scsi device queue's DMA alignment
-	 * mask.  Guaranteeing proper alignment of the first buffer will
-	 * have the desired effect because, except at the beginning and
-	 * the end, scatter-gather buffers follow page boundaries. */
-	blk_queue_dma_alignment(sdev->request_queue, (512 - 1));
-
 	/* Many devices have trouble transfering more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).

commit 33abc04f0420dceed0ebc2d1094019d3bb2b5c29
Author: Doug Maxey <dwm@enoyolf.org>
Date:   Wed Dec 5 23:36:45 2007 -0600

    usb-storage: Fix devices that cannot handle 32k transfers
    
    When a device cannot handle the smallest previously limited transfer
    size (64 blocks) without stalling, limit the device to the amount of
    packets that fit in a platform native page.
    
    The lowest possible limit is PAGE_CACHE_SIZE, so if the device is ever
    used on a platform that has larger than 8K pages, you lose unless you
    can convince the device firmware folks to fix the issue.
    
    Cc: Mathew Dharm <mdharm-scsi@one-eyed-alien.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Doug Maxey <dwm@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 836a34ae6ec6..7c9593b7b04e 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -114,9 +114,15 @@ static int slave_configure(struct scsi_device *sdev)
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */
-	if ((us->flags & US_FL_MAX_SECTORS_64) &&
-			sdev->request_queue->max_sectors > 64)
-		blk_queue_max_sectors(sdev->request_queue, 64);
+	if (us->flags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {
+		unsigned int max_sectors = 64;
+
+		if (us->flags & US_FL_MAX_SECTORS_MIN)
+			max_sectors = PAGE_CACHE_SIZE >> 9;
+		if (sdev->request_queue->max_sectors > max_sectors)
+			blk_queue_max_sectors(sdev->request_queue,
+					      max_sectors);
+	}
 
 	/* We can't put these settings in slave_alloc() because that gets
 	 * called before the device type is known.  Consequently these

commit f09e495df27d80ae77005ddb2e93df18ec24d04a
Author: Mauro Carvalho Chehab <mchehab@infradead.org>
Date:   Wed Oct 10 16:29:02 2007 -0400

    usb-storage: always set the allow_restart flag
    
    This patch (as1000) sets the SCSI allow_restart flag for USB disk
    devices.  In theory this should never hurt, and there definitely are
    devices out there (such as the Seagate 250-GB external drive) which
    need the flag to be set.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1ba19eaa1970..836a34ae6ec6 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -177,6 +177,10 @@ static int slave_configure(struct scsi_device *sdev)
 		 * is an occasional series of retries that will all fail. */
 		sdev->retry_hwerror = 1;
 
+		/* USB disks should allow restart.  Some drives spin down
+		 * automatically, requiring a START-STOP UNIT command. */
+		sdev->allow_restart = 1;
+
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit d526875deb42e0f4c0d31cb50b4e5bfaf19c3138
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 13 06:01:24 2007 -0700

    Revert "usb-storage: implement autosuspend"
    
    This reverts commit 8dfe4b14869fd185ca25ee88b02ada58a3005eaf.
    
    There are a number of issues still remaining in usb-storage autosuspend,
    so, to be safe, we need to revert this for now.
    
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 47e56079925d..1ba19eaa1970 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -285,15 +285,10 @@ static int device_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	result = usb_autopm_get_interface(us->pusb_intf);
-	if (result == 0) {
-
-		/* lock the device pointers and do the reset */
-		mutex_lock(&(us->dev_mutex));
-		result = us->transport_reset(us);
-		mutex_unlock(&us->dev_mutex);
-		usb_autopm_put_interface(us->pusb_intf);
-	}
+	/* lock the device pointers and do the reset */
+	mutex_lock(&(us->dev_mutex));
+	result = us->transport_reset(us);
+	mutex_unlock(&us->dev_mutex);
 
 	return result < 0 ? FAILED : SUCCESS;
 }

commit 8dfe4b14869fd185ca25ee88b02ada58a3005eaf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 6 14:24:27 2007 -0400

    usb-storage: implement autosuspend
    
    This patch (as930) implements autosuspend for usb-storage.  It is
    adapted from a patch by Oliver Neukum.  Autosuspend is allowed except
    during LUN scanning, resets, and command execution.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1ba19eaa1970..47e56079925d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -285,10 +285,15 @@ static int device_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	/* lock the device pointers and do the reset */
-	mutex_lock(&(us->dev_mutex));
-	result = us->transport_reset(us);
-	mutex_unlock(&us->dev_mutex);
+	result = usb_autopm_get_interface(us->pusb_intf);
+	if (result == 0) {
+
+		/* lock the device pointers and do the reset */
+		mutex_lock(&(us->dev_mutex));
+		result = us->transport_reset(us);
+		mutex_unlock(&us->dev_mutex);
+		usb_autopm_put_interface(us->pusb_intf);
+	}
 
 	return result < 0 ? FAILED : SUCCESS;
 }

commit f07600cf9eb3ee92777b2001e564faa413144a99
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:38:16 2007 -0400

    USB: add reset_resume method
    
    This patch (as918) introduces a new USB driver method: reset_resume.
    It is called when a device needs to be reset as part of a resume
    procedure (whether because of a device quirk or because of the
    USB-Persist facility), thereby taking over a role formerly assigned to
    the post_reset method.  As a consequence, post_reset no longer needs
    an argument indicating whether it is being called as part of a
    reset-resume.  This separation of functions makes the code clearer.
    
    In addition, the pre_reset and post_reset method return types are
    changed; they now must return an error code.  The return value is
    unused at present, but at some later time we may unbind drivers and
    re-probe if they encounter an error during reset handling.
    
    The existing pre_reset and post_reset methods in the usbhid,
    usb-storage, and hub drivers are updated to match the new
    requirements.  For usbhid the post_reset routine is also used for
    reset_resume (duplicate method pointers); for the other drivers a new
    reset_resume routine is added.  The change to hub.c looks bigger than
    it really is, because mark_children_for_reset_resume() gets moved down
    next to the new hub_reset_resume() routine.
    
    A minor change to usb-storage makes the usb_stor_report_bus_reset()
    routine acquire the host lock instead of requiring the caller to hold
    it already.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e227f64d5641..1ba19eaa1970 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -321,10 +321,14 @@ void usb_stor_report_device_reset(struct us_data *us)
 
 /* Report a driver-initiated bus reset to the SCSI layer.
  * Calling this for a SCSI-initiated reset is unnecessary but harmless.
- * The caller must own the SCSI host lock. */
+ * The caller must not own the SCSI host lock. */
 void usb_stor_report_bus_reset(struct us_data *us)
 {
-	scsi_report_bus_reset(us_to_host(us), 0);
+	struct Scsi_Host *host = us_to_host(us);
+
+	scsi_lock(host);
+	scsi_report_bus_reset(host, 0);
+	scsi_unlock(host);
 }
 
 /***********************************************************************

commit 61bf54b71d5abf767ee46284be19965d7253ddbf
Author: Oliver Neukum <oneukum@suse.de>
Date:   Thu Feb 8 09:04:48 2007 +0100

    USB Storage: indistinguishable devices with broken and unbroken firmware
    
    there's a USB mass storage device which exists in two version. One
    reports the correct size and the other does not. Apart from that they
    are identical and cannot be told apart. Here's a heuristic based on the
    empirical finding that drives have even sizes.
    
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 70234f5dbeeb..e227f64d5641 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -153,6 +153,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->flags & US_FL_FIX_CAPACITY)
 			sdev->fix_capacity = 1;
 
+		/* A few disks have two indistinguishable version, one of
+		 * which reports the correct capacity and the other does not.
+		 * The sd driver has to guess which is the case. */
+		if (us->flags & US_FL_CAPACITY_HEURISTICS)
+			sdev->guess_capacity = 1;
+
 		/* Some devices report a SCSI revision level above 2 but are
 		 * unable to handle the REPORT LUNS command (for which
 		 * support is mandatory at level 3).  Since we already have

commit f3f4906516a084bbd9aa3da7592e6b029fe78f5b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 8 16:18:05 2007 -0500

    usb-storage: SCSI level fixes
    
    This patch (as835) removes from usb-storage the code which sets all
    devices to a SCSI level of at least SCSI-2.  The original reasons for
    doing this no longer apply, and in fact it prevents certain kinds of
    ATA pass-thru commands from being used.
    
    The patch also marks CB and CBI devices that are SCSI-0 (legacy SCSI)
    as being single-LUN, since the combined SCSI-over-USB transport
    protocol has no way to convey LUN information to these devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e1072d52d641..70234f5dbeeb 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -110,23 +110,6 @@ static int slave_configure(struct scsi_device *sdev)
 	 * the end, scatter-gather buffers follow page boundaries. */
 	blk_queue_dma_alignment(sdev->request_queue, (512 - 1));
 
-	/* Set the SCSI level to at least 2.  We'll leave it at 3 if that's
-	 * what is originally reported.  We need this to avoid confusing
-	 * the SCSI layer with devices that report 0 or 1, but need 10-byte
-	 * commands (ala ATAPI devices behind certain bridges, or devices
-	 * which simply have broken INQUIRY data).
-	 *
-	 * NOTE: This means /dev/sg programs (ala cdrecord) will get the
-	 * actual information.  This seems to be the preference for
-	 * programs like that.
-	 *
-	 * NOTE: This also means that /proc/scsi/scsi and sysfs may report
-	 * the actual value or the modified one, depending on where the
-	 * data comes from.
-	 */
-	if (sdev->scsi_level < SCSI_2)
-		sdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;
-
 	/* Many devices have trouble transfering more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
@@ -176,7 +159,9 @@ static int slave_configure(struct scsi_device *sdev)
 		 * a Get-Max-LUN request, we won't lose much by setting the
 		 * revision level down to 2.  The only devices that would be
 		 * affected are those with sparse LUNs. */
-		sdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;
+		if (sdev->scsi_level > SCSI_2)
+			sdev->sdev_target->scsi_level =
+					sdev->scsi_level = SCSI_2;
 
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
@@ -194,6 +179,16 @@ static int slave_configure(struct scsi_device *sdev)
 		sdev->use_10_for_ms = 1;
 	}
 
+	/* The CB and CBI transports have no way to pass LUN values
+	 * other than the bits in the second byte of a CDB.  But those
+	 * bits don't get set to the LUN value if the device reports
+	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily
+	 * be single-LUN.
+	 */
+	if ((us->protocol == US_PR_CB || us->protocol == US_PR_CBI) &&
+			sdev->scsi_level == SCSI_UNKNOWN)
+		us->max_lun = 0;
+
 	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
 	 * REMOVAL command, so suppress those commands. */
 	if (us->flags & US_FL_NOT_LOCKABLE)

commit 3a3416b12f1fbd607bc137a57c924a628aa5485c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Aug 21 12:00:53 2006 -0400

    usb-storage: fix for UFI LUN detection
    
    The UFI specification doesn't permit devices to indicate non-existent
    LUNs in the manner prescribed by the SCSI spec.  This patch (as773)
    sets a special flag so that the SCSI scanner will recognize these
    devices and treat them specially.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a4b7df9ff8c1..e1072d52d641 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -72,12 +72,27 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
+	struct us_data *us = host_to_us(sdev->host);
+
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
 	 * less than 36 bytes.
 	 */
 	sdev->inquiry_len = 36;
+
+	/*
+	 * The UFI spec treates the Peripheral Qualifier bits in an
+	 * INQUIRY result as reserved and requires devices to set them
+	 * to 0.  However the SCSI spec requires these bits to be set
+	 * to 3 to indicate when a LUN is not present.
+	 *
+	 * Let the scanning code know if this target merely sets
+	 * Peripheral Device Type to 0x1f to indicate no LUN.
+	 */
+	if (us->subclass == US_SC_UFI)
+		sdev->sdev_target->pdt_1f_for_no_lun = 1;
+
 	return 0;
 }
 

commit 883d989a7edf7a62e38e9150990b56209420e9e5
Author: Phil Dibowitz <phil@ipom.com>
Date:   Sat Jun 24 17:27:10 2006 -0700

    [PATCH] USB Storage: US_FL_MAX_SECTORS_64 flag
    
    This patch adds a US_FL_MAX_SECTORS_64 and removes the Genesys special-cases
    for this that were in scsiglue.c. It also adds the flag to other devices
    reported to need it.
    
    Signed-off-by: Phil Dibowitz <phil@ipom.com>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5715291ba540..a4b7df9ff8c1 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -112,13 +112,11 @@ static int slave_configure(struct scsi_device *sdev)
 	if (sdev->scsi_level < SCSI_2)
 		sdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;
 
-	/* According to the technical support people at Genesys Logic,
-	 * devices using their chips have problems transferring more than
-	 * 32 KB at a time.  In practice people have found that 64 KB
-	 * works okay and that's what Windows does.  But we'll be
-	 * conservative; people can always use the sysfs interface to
-	 * increase max_sectors. */
-	if (le16_to_cpu(us->pusb_dev->descriptor.idVendor) == USB_VENDOR_ID_GENESYS &&
+	/* Many devices have trouble transfering more than 32KB at a time,
+	 * while others have trouble with more than 64K. At this time we
+	 * are limiting both to 32K (64 sectores).
+	 */
+	if ((us->flags & US_FL_MAX_SECTORS_64) &&
 			sdev->request_queue->max_sectors > 64)
 		blk_queue_max_sectors(sdev->request_queue, 64);
 

commit 47104b0dd32cec467574822b0dc3517b3de3f0ad
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 1 13:52:56 2006 -0400

    [PATCH] usb-storage: use usb_reset_composite_device
    
    This patch (as701) modifies usb-storage to take advantage of the new
    usb_reset_composite_device() API.  Now we will be able to safely request
    port resets even if other drivers are bound to a mass-storage device.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5f11e19eaae3..5715291ba540 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -286,11 +286,7 @@ static int bus_reset(struct scsi_cmnd *srb)
 	int result;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
-
-	mutex_lock(&(us->dev_mutex));
 	result = usb_stor_port_reset(us);
-	mutex_unlock(&us->dev_mutex);
-
 	return result < 0 ? FAILED : SUCCESS;
 }
 

commit 4186ecf8ad16dd05759a09594de6a87e48759ba6
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 15:55:29 2006 +0100

    [PATCH] USB: convert a bunch of USB semaphores to mutexes
    
    the patch below converts a bunch of semaphores-used-as-mutex in the USB
    code to mutexes
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 4ef5527028c5..5f11e19eaae3 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -47,6 +47,7 @@
 
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -271,9 +272,9 @@ static int device_reset(struct scsi_cmnd *srb)
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
 	/* lock the device pointers and do the reset */
-	down(&(us->dev_semaphore));
+	mutex_lock(&(us->dev_mutex));
 	result = us->transport_reset(us);
-	up(&(us->dev_semaphore));
+	mutex_unlock(&us->dev_mutex);
 
 	return result < 0 ? FAILED : SUCCESS;
 }
@@ -286,9 +287,9 @@ static int bus_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	down(&(us->dev_semaphore));
+	mutex_lock(&(us->dev_mutex));
 	result = usb_stor_port_reset(us);
-	up(&(us->dev_semaphore));
+	mutex_unlock(&us->dev_mutex);
 
 	return result < 0 ? FAILED : SUCCESS;
 }

commit 28120be5d6830cd7c7777d8bf570bdb20abef58a
Author: Paul Walmsley <paul@booyaka.com>
Date:   Wed Dec 21 14:28:06 2005 -0800

    [PATCH] USB Storage: Force starget->scsi_level in usb-storage scsiglue.c
    
    When the usb-storage module forces sdev->scsi_level to SCSI_2, it should
    also force starget->scsi_level to the same value.  Otherwise, the SCSI
    layer may attempt to issue SCSI-3 commands to the device, such as REPORT
    LUNS, which it cannot handle.  This can prevent the device from working
    with Linux.
    
    The AMS Venus DS3 DS2316SU2S SATA-to-SATA+USB enclosure, based on the
    Oxford Semiconductor OXU921S chip, requires this patch to function
    correctly on Linux.  The enclosure reports a SCSI-3 SPC-2 command set
    level, but does not correctly handle the REPORT LUNS SCSI command -
    probably due to a bug in its firmware.
    
    It seems likely that other USB storage enclosures with similar bugs will
    also benefit from this patch.
    
    Tony Lindgren <tony@atomide.com> collaborated in the development of this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@booyaka.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 4837524eada7..4ef5527028c5 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -109,7 +109,7 @@ static int slave_configure(struct scsi_device *sdev)
 	 * data comes from.
 	 */
 	if (sdev->scsi_level < SCSI_2)
-		sdev->scsi_level = SCSI_2;
+		sdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;
 
 	/* According to the technical support people at Genesys Logic,
 	 * devices using their chips have problems transferring more than
@@ -162,7 +162,7 @@ static int slave_configure(struct scsi_device *sdev)
 		 * a Get-Max-LUN request, we won't lose much by setting the
 		 * revision level down to 2.  The only devices that would be
 		 * affected are those with sparse LUNs. */
-		sdev->scsi_level = SCSI_2;
+		sdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;
 
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,

commit 226173edae1c49c68ebb723771a02302c85e3475
Author: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
Date:   Thu Aug 25 20:03:50 2005 -0700

    [PATCH] USB: storage: Fix messed-up locking
    
    This is patch as550 from Alan Stern.
    
    Apparently someone changed the SCSI core so that it no longer holds the
    host lock when doing a device or bus reset.  usb-storage was updated at
    the time, but the change was done carelessly.  Some of the code depends
    on that lock being held.
    
    This patch reintroduces the host lock where needed and tries to clarify
    the comments explaining why the lock is necessary.  It also moves the
    code that clears the TIMED_OUT and ABORTING bitflags so that it executes
    as soon as the timed-out command has completed (and while the host lock
    is held).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index d34dc9f417f0..4837524eada7 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -227,42 +227,42 @@ static int queuecommand(struct scsi_cmnd *srb,
  ***********************************************************************/
 
 /* Command timeout and abort */
-/* This is always called with scsi_lock(host) held */
 static int command_abort(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
+	/* us->srb together with the TIMED_OUT, RESETTING, and ABORTING
+	 * bits are protected by the host lock. */
+	scsi_lock(us_to_host(us));
+
 	/* Is this command still active? */
 	if (us->srb != srb) {
+		scsi_unlock(us_to_host(us));
 		US_DEBUGP ("-- nothing to abort\n");
 		return FAILED;
 	}
 
 	/* Set the TIMED_OUT bit.  Also set the ABORTING bit, but only if
 	 * a device reset isn't already in progress (to avoid interfering
-	 * with the reset).  To prevent races with auto-reset, we must
-	 * stop any ongoing USB transfers while still holding the host
-	 * lock. */
+	 * with the reset).  Note that we must retain the host lock while
+	 * calling usb_stor_stop_transport(); otherwise it might interfere
+	 * with an auto-reset that begins as soon as we release the lock. */
 	set_bit(US_FLIDX_TIMED_OUT, &us->flags);
 	if (!test_bit(US_FLIDX_RESETTING, &us->flags)) {
 		set_bit(US_FLIDX_ABORTING, &us->flags);
 		usb_stor_stop_transport(us);
 	}
+	scsi_unlock(us_to_host(us));
 
 	/* Wait for the aborted command to finish */
 	wait_for_completion(&us->notify);
-
-	/* Reacquire the lock and allow USB transfers to resume */
-	clear_bit(US_FLIDX_ABORTING, &us->flags);
-	clear_bit(US_FLIDX_TIMED_OUT, &us->flags);
 	return SUCCESS;
 }
 
 /* This invokes the transport reset mechanism to reset the state of the
  * device */
-/* This is always called with scsi_lock(host) held */
 static int device_reset(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
@@ -279,7 +279,6 @@ static int device_reset(struct scsi_cmnd *srb)
 }
 
 /* Simulate a SCSI bus reset by resetting the device's USB port. */
-/* This is always called with scsi_lock(host) held */
 static int bus_reset(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
@@ -291,7 +290,6 @@ static int bus_reset(struct scsi_cmnd *srb)
 	result = usb_stor_port_reset(us);
 	up(&(us->dev_semaphore));
 
-	/* lock the host for the return */
 	return result < 0 ? FAILED : SUCCESS;
 }
 

commit a4e628328ec60873fec9d506d682155391f589ce
Author: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
Date:   Thu Jul 28 14:50:29 2005 -0700

    [PATCH] USB Storage: wedge SCSI revision at 2 for usb-storage devices
    
    This patch started life as as479b, and has been rediffed.  Please note
    the order of submission of this latest patch series -- even tho this has
    an older original number, it is the last patch I'll be sending today.
    
    This patch changes the reported SCSI revision level to 2 for all
    disk-type devices.  This is needed in a few cases because the device
    reports a level of 3 or higher but then crashes when given a REPORT LUNS
    command (for which support is supposed to be mandatory at those levels).
    This shouldn't harm us, since it only matters for sparse LUNs and we
    have separate ways of coping with that.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index af294bb68c35..d34dc9f417f0 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -156,6 +156,14 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us->flags & US_FL_FIX_CAPACITY)
 			sdev->fix_capacity = 1;
 
+		/* Some devices report a SCSI revision level above 2 but are
+		 * unable to handle the REPORT LUNS command (for which
+		 * support is mandatory at level 3).  Since we already have
+		 * a Get-Max-LUN request, we won't lose much by setting the
+		 * revision level down to 2.  The only devices that would be
+		 * affected are those with sparse LUNs. */
+		sdev->scsi_level = SCSI_2;
+
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
 		 * recoverable or not.  Setting this flag tells the SCSI

commit 86dbde9cbdfe8bc2c2dfe5d33027d3acc55e0470
Author: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
Date:   Mon Jun 6 17:22:42 2005 -0700

    [PATCH] USB Storage: retry hard errors
    
    This patch started life as as527, and was rediffed by me.
    
    Since the IDE interface doesn't convey much information about types of
    errors, many USB-IDE adapters report all low-level errors with SK = 0x04,
    which is supposed to be used only for non-recoverable errors.  As a result
    the SCSI midlayer doesn't retry the command.  But quite often a retry
    would succeed, whereas an unnecessary retry doesn't really hurt anything.
    
    This patch uses a recently-implemented flag to tell the SCSI midlayer that
    such hardware errors should be retried.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index da2bfa944b96..af294bb68c35 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -155,6 +155,15 @@ static int slave_configure(struct scsi_device *sdev)
 		 * If this device makes that mistake, tell the sd driver. */
 		if (us->flags & US_FL_FIX_CAPACITY)
 			sdev->fix_capacity = 1;
+
+		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
+		 * Hardware Error) when any low-level error occurs,
+		 * recoverable or not.  Setting this flag tells the SCSI
+		 * midlayer to retry such commands, which frequently will
+		 * succeed and fix the error.  The worst this can lead to
+		 * is an occasional series of retries that will all fail. */
+		sdev->retry_hwerror = 1;
+
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages

commit 4d07ef762fc8d6d35ecc1511a3b953a733a61a5f
Author: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
Date:   Mon Jun 6 17:21:41 2005 -0700

    [PATCH] USB Storage: port reset on transport error
    
    This patch causes a port reset whenever there's a transport error or abort.
    If that fails it reverts back to doing a mass-storage device reset.  It
    started life as as497 and was rediffed by me.
    
    This makes error recovery a lot quicker and more reliable.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e43eddc3d44b..da2bfa944b96 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -255,50 +255,23 @@ static int device_reset(struct scsi_cmnd *srb)
 
 	/* lock the device pointers and do the reset */
 	down(&(us->dev_semaphore));
-	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
-		result = FAILED;
-		US_DEBUGP("No reset during disconnect\n");
-	} else
-		result = us->transport_reset(us);
+	result = us->transport_reset(us);
 	up(&(us->dev_semaphore));
 
-	return result;
+	return result < 0 ? FAILED : SUCCESS;
 }
 
-/* This resets the device's USB port. */
-/* It refuses to work if there's more than one interface in
- * the device, so that other users are not affected. */
+/* Simulate a SCSI bus reset by resetting the device's USB port. */
 /* This is always called with scsi_lock(host) held */
 static int bus_reset(struct scsi_cmnd *srb)
 {
 	struct us_data *us = host_to_us(srb->device->host);
-	int result, rc;
+	int result;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	/* The USB subsystem doesn't handle synchronisation between
-	 * a device's several drivers. Therefore we reset only devices
-	 * with just one interface, which we of course own. */
-
 	down(&(us->dev_semaphore));
-	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
-		result = -EIO;
-		US_DEBUGP("No reset during disconnect\n");
-	} else if (us->pusb_dev->actconfig->desc.bNumInterfaces != 1) {
-		result = -EBUSY;
-		US_DEBUGP("Refusing to reset a multi-interface device\n");
-	} else {
-		rc = usb_lock_device_for_reset(us->pusb_dev, us->pusb_intf);
-		if (rc < 0) {
-			US_DEBUGP("unable to lock device for reset: %d\n", rc);
-			result = rc;
-		} else {
-			result = usb_reset_device(us->pusb_dev);
-			if (rc)
-				usb_unlock_device(us->pusb_dev);
-			US_DEBUGP("usb_reset_device returns %d\n", result);
-		}
-	}
+	result = usb_stor_port_reset(us);
 	up(&(us->dev_semaphore));
 
 	/* lock the host for the return */
@@ -320,6 +293,14 @@ void usb_stor_report_device_reset(struct us_data *us)
 	}
 }
 
+/* Report a driver-initiated bus reset to the SCSI layer.
+ * Calling this for a SCSI-initiated reset is unnecessary but harmless.
+ * The caller must own the SCSI host lock. */
+void usb_stor_report_bus_reset(struct us_data *us)
+{
+	scsi_report_bus_reset(us_to_host(us), 0);
+}
+
 /***********************************************************************
  * /proc/scsi/ functions
  ***********************************************************************/

commit 060b8845e6bea938d65ad6f89e83507e5ff4fec4
Author: Yani Ioannou <yani.ioannou@gmail.com>
Date:   Tue May 17 06:44:04 2005 -0400

    [PATCH] Driver Core: drivers/usb/input/aiptek.c - drivers/zorro/zorro-sysfs.c: update device attribute callbacks
    
    Signed-off-by: Yani Ioannou <yani.ioannou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1035b248eff4..e43eddc3d44b 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -398,7 +398,7 @@ US_DO_ALL_FLAGS
  ***********************************************************************/
 
 /* Output routine for the sysfs max_sectors file */
-static ssize_t show_max_sectors(struct device *dev, char *buf)
+static ssize_t show_max_sectors(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
 
@@ -406,7 +406,7 @@ static ssize_t show_max_sectors(struct device *dev, char *buf)
 }
 
 /* Input routine for the sysfs max_sectors file */
-static ssize_t store_max_sectors(struct device *dev, const char *buf,
+static ssize_t store_max_sectors(struct device *dev, struct device_attribute *attr, const char *buf,
 		size_t count)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 739a9143477d..1035b248eff4 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -276,8 +276,6 @@ static int bus_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	scsi_unlock(us_to_host(us));
-
 	/* The USB subsystem doesn't handle synchronisation between
 	 * a device's several drivers. Therefore we reset only devices
 	 * with just one interface, which we of course own. */
@@ -304,7 +302,6 @@ static int bus_reset(struct scsi_cmnd *srb)
 	up(&(us->dev_semaphore));
 
 	/* lock the host for the return */
-	scsi_lock(us_to_host(us));
 	return result < 0 ? FAILED : SUCCESS;
 }
 

commit 94d0e7b805961c44e4dc486ffc21075084bb7175
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:55:48 2005 -0400

    [SCSI] allow sleeping in ->eh_device_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 7dce9c01c357..739a9143477d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -253,8 +253,6 @@ static int device_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	scsi_unlock(us_to_host(us));
-
 	/* lock the device pointers and do the reset */
 	down(&(us->dev_semaphore));
 	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
@@ -264,8 +262,6 @@ static int device_reset(struct scsi_cmnd *srb)
 		result = us->transport_reset(us);
 	up(&(us->dev_semaphore));
 
-	/* lock the host for the return */
-	scsi_lock(us_to_host(us));
 	return result;
 }
 

commit 8fa728a26886f56a9ee10a44fea0ddda301d21c3
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:54:40 2005 -0400

    [SCSI] allow sleeping in ->eh_abort_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 22e48a2b0bd1..7dce9c01c357 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -233,13 +233,11 @@ static int command_abort(struct scsi_cmnd *srb)
 		set_bit(US_FLIDX_ABORTING, &us->flags);
 		usb_stor_stop_transport(us);
 	}
-	scsi_unlock(us_to_host(us));
 
 	/* Wait for the aborted command to finish */
 	wait_for_completion(&us->notify);
 
 	/* Reacquire the lock and allow USB transfers to resume */
-	scsi_lock(us_to_host(us));
 	clear_bit(US_FLIDX_ABORTING, &us->flags);
 	clear_bit(US_FLIDX_TIMED_OUT, &us->flags);
 	return SUCCESS;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
new file mode 100644
index 000000000000..22e48a2b0bd1
--- /dev/null
+++ b/drivers/usb/storage/scsiglue.c
@@ -0,0 +1,500 @@
+/* Driver for USB Mass Storage compliant devices
+ * SCSI layer glue code
+ *
+ * $Id: scsiglue.c,v 1.26 2002/04/22 03:39:43 mdharm Exp $
+ *
+ * Current development and maintenance by:
+ *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
+ *
+ * Developed with the assistance of:
+ *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)
+ *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)
+ *
+ * Initial work by:
+ *   (c) 1999 Michael Gee (michael@linuxspecific.com)
+ *
+ * This driver is based on the 'USB Mass Storage Class' document. This
+ * describes in detail the protocol used to communicate with such
+ * devices.  Clearly, the designers had SCSI and ATAPI commands in
+ * mind when they created this document.  The commands are all very
+ * similar to commands in the SCSI-II and ATAPI specifications.
+ *
+ * It is important to note that in a number of cases this class
+ * exhibits class-specific exemptions from the USB specification.
+ * Notably the usage of NAK, STALL and ACK differs from the norm, in
+ * that they are used to communicate wait, failed and OK on commands.
+ *
+ * Also, for certain devices, the interrupt endpoint is used to convey
+ * status of a command.
+ *
+ * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more
+ * information about this driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_devinfo.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
+
+#include "usb.h"
+#include "scsiglue.h"
+#include "debug.h"
+#include "transport.h"
+#include "protocol.h"
+
+/***********************************************************************
+ * Host functions 
+ ***********************************************************************/
+
+static const char* host_info(struct Scsi_Host *host)
+{
+	return "SCSI emulation for USB Mass Storage devices";
+}
+
+static int slave_alloc (struct scsi_device *sdev)
+{
+	/*
+	 * Set the INQUIRY transfer length to 36.  We don't use any of
+	 * the extra data and many devices choke if asked for more or
+	 * less than 36 bytes.
+	 */
+	sdev->inquiry_len = 36;
+	return 0;
+}
+
+static int slave_configure(struct scsi_device *sdev)
+{
+	struct us_data *us = host_to_us(sdev->host);
+
+	/* Scatter-gather buffers (all but the last) must have a length
+	 * divisible by the bulk maxpacket size.  Otherwise a data packet
+	 * would end up being short, causing a premature end to the data
+	 * transfer.  Since high-speed bulk pipes have a maxpacket size
+	 * of 512, we'll use that as the scsi device queue's DMA alignment
+	 * mask.  Guaranteeing proper alignment of the first buffer will
+	 * have the desired effect because, except at the beginning and
+	 * the end, scatter-gather buffers follow page boundaries. */
+	blk_queue_dma_alignment(sdev->request_queue, (512 - 1));
+
+	/* Set the SCSI level to at least 2.  We'll leave it at 3 if that's
+	 * what is originally reported.  We need this to avoid confusing
+	 * the SCSI layer with devices that report 0 or 1, but need 10-byte
+	 * commands (ala ATAPI devices behind certain bridges, or devices
+	 * which simply have broken INQUIRY data).
+	 *
+	 * NOTE: This means /dev/sg programs (ala cdrecord) will get the
+	 * actual information.  This seems to be the preference for
+	 * programs like that.
+	 *
+	 * NOTE: This also means that /proc/scsi/scsi and sysfs may report
+	 * the actual value or the modified one, depending on where the
+	 * data comes from.
+	 */
+	if (sdev->scsi_level < SCSI_2)
+		sdev->scsi_level = SCSI_2;
+
+	/* According to the technical support people at Genesys Logic,
+	 * devices using their chips have problems transferring more than
+	 * 32 KB at a time.  In practice people have found that 64 KB
+	 * works okay and that's what Windows does.  But we'll be
+	 * conservative; people can always use the sysfs interface to
+	 * increase max_sectors. */
+	if (le16_to_cpu(us->pusb_dev->descriptor.idVendor) == USB_VENDOR_ID_GENESYS &&
+			sdev->request_queue->max_sectors > 64)
+		blk_queue_max_sectors(sdev->request_queue, 64);
+
+	/* We can't put these settings in slave_alloc() because that gets
+	 * called before the device type is known.  Consequently these
+	 * settings can't be overridden via the scsi devinfo mechanism. */
+	if (sdev->type == TYPE_DISK) {
+
+		/* Disk-type devices use MODE SENSE(6) if the protocol
+		 * (SubClass) is Transparent SCSI, otherwise they use
+		 * MODE SENSE(10). */
+		if (us->subclass != US_SC_SCSI)
+			sdev->use_10_for_ms = 1;
+
+		/* Many disks only accept MODE SENSE transfer lengths of
+		 * 192 bytes (that's what Windows uses). */
+		sdev->use_192_bytes_for_3f = 1;
+
+		/* Some devices don't like MODE SENSE with page=0x3f,
+		 * which is the command used for checking if a device
+		 * is write-protected.  Now that we tell the sd driver
+		 * to do a 192-byte transfer with this command the
+		 * majority of devices work fine, but a few still can't
+		 * handle it.  The sd driver will simply assume those
+		 * devices are write-enabled. */
+		if (us->flags & US_FL_NO_WP_DETECT)
+			sdev->skip_ms_page_3f = 1;
+
+		/* A number of devices have problems with MODE SENSE for
+		 * page x08, so we will skip it. */
+		sdev->skip_ms_page_8 = 1;
+
+		/* Some disks return the total number of blocks in response
+		 * to READ CAPACITY rather than the highest block number.
+		 * If this device makes that mistake, tell the sd driver. */
+		if (us->flags & US_FL_FIX_CAPACITY)
+			sdev->fix_capacity = 1;
+	} else {
+
+		/* Non-disk-type devices don't need to blacklist any pages
+		 * or to force 192-byte transfer lengths for MODE SENSE.
+		 * But they do need to use MODE SENSE(10). */
+		sdev->use_10_for_ms = 1;
+	}
+
+	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
+	 * REMOVAL command, so suppress those commands. */
+	if (us->flags & US_FL_NOT_LOCKABLE)
+		sdev->lockable = 0;
+
+	/* this is to satisfy the compiler, tho I don't think the 
+	 * return code is ever checked anywhere. */
+	return 0;
+}
+
+/* queue a command */
+/* This is always called with scsi_lock(host) held */
+static int queuecommand(struct scsi_cmnd *srb,
+			void (*done)(struct scsi_cmnd *))
+{
+	struct us_data *us = host_to_us(srb->device->host);
+
+	US_DEBUGP("%s called\n", __FUNCTION__);
+
+	/* check for state-transition errors */
+	if (us->srb != NULL) {
+		printk(KERN_ERR USB_STORAGE "Error in %s: us->srb = %p\n",
+			__FUNCTION__, us->srb);
+		return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+	/* fail the command if we are disconnecting */
+	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
+		US_DEBUGP("Fail command during disconnect\n");
+		srb->result = DID_NO_CONNECT << 16;
+		done(srb);
+		return 0;
+	}
+
+	/* enqueue the command and wake up the control thread */
+	srb->scsi_done = done;
+	us->srb = srb;
+	up(&(us->sema));
+
+	return 0;
+}
+
+/***********************************************************************
+ * Error handling functions
+ ***********************************************************************/
+
+/* Command timeout and abort */
+/* This is always called with scsi_lock(host) held */
+static int command_abort(struct scsi_cmnd *srb)
+{
+	struct us_data *us = host_to_us(srb->device->host);
+
+	US_DEBUGP("%s called\n", __FUNCTION__);
+
+	/* Is this command still active? */
+	if (us->srb != srb) {
+		US_DEBUGP ("-- nothing to abort\n");
+		return FAILED;
+	}
+
+	/* Set the TIMED_OUT bit.  Also set the ABORTING bit, but only if
+	 * a device reset isn't already in progress (to avoid interfering
+	 * with the reset).  To prevent races with auto-reset, we must
+	 * stop any ongoing USB transfers while still holding the host
+	 * lock. */
+	set_bit(US_FLIDX_TIMED_OUT, &us->flags);
+	if (!test_bit(US_FLIDX_RESETTING, &us->flags)) {
+		set_bit(US_FLIDX_ABORTING, &us->flags);
+		usb_stor_stop_transport(us);
+	}
+	scsi_unlock(us_to_host(us));
+
+	/* Wait for the aborted command to finish */
+	wait_for_completion(&us->notify);
+
+	/* Reacquire the lock and allow USB transfers to resume */
+	scsi_lock(us_to_host(us));
+	clear_bit(US_FLIDX_ABORTING, &us->flags);
+	clear_bit(US_FLIDX_TIMED_OUT, &us->flags);
+	return SUCCESS;
+}
+
+/* This invokes the transport reset mechanism to reset the state of the
+ * device */
+/* This is always called with scsi_lock(host) held */
+static int device_reset(struct scsi_cmnd *srb)
+{
+	struct us_data *us = host_to_us(srb->device->host);
+	int result;
+
+	US_DEBUGP("%s called\n", __FUNCTION__);
+
+	scsi_unlock(us_to_host(us));
+
+	/* lock the device pointers and do the reset */
+	down(&(us->dev_semaphore));
+	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
+		result = FAILED;
+		US_DEBUGP("No reset during disconnect\n");
+	} else
+		result = us->transport_reset(us);
+	up(&(us->dev_semaphore));
+
+	/* lock the host for the return */
+	scsi_lock(us_to_host(us));
+	return result;
+}
+
+/* This resets the device's USB port. */
+/* It refuses to work if there's more than one interface in
+ * the device, so that other users are not affected. */
+/* This is always called with scsi_lock(host) held */
+static int bus_reset(struct scsi_cmnd *srb)
+{
+	struct us_data *us = host_to_us(srb->device->host);
+	int result, rc;
+
+	US_DEBUGP("%s called\n", __FUNCTION__);
+
+	scsi_unlock(us_to_host(us));
+
+	/* The USB subsystem doesn't handle synchronisation between
+	 * a device's several drivers. Therefore we reset only devices
+	 * with just one interface, which we of course own. */
+
+	down(&(us->dev_semaphore));
+	if (test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
+		result = -EIO;
+		US_DEBUGP("No reset during disconnect\n");
+	} else if (us->pusb_dev->actconfig->desc.bNumInterfaces != 1) {
+		result = -EBUSY;
+		US_DEBUGP("Refusing to reset a multi-interface device\n");
+	} else {
+		rc = usb_lock_device_for_reset(us->pusb_dev, us->pusb_intf);
+		if (rc < 0) {
+			US_DEBUGP("unable to lock device for reset: %d\n", rc);
+			result = rc;
+		} else {
+			result = usb_reset_device(us->pusb_dev);
+			if (rc)
+				usb_unlock_device(us->pusb_dev);
+			US_DEBUGP("usb_reset_device returns %d\n", result);
+		}
+	}
+	up(&(us->dev_semaphore));
+
+	/* lock the host for the return */
+	scsi_lock(us_to_host(us));
+	return result < 0 ? FAILED : SUCCESS;
+}
+
+/* Report a driver-initiated device reset to the SCSI layer.
+ * Calling this for a SCSI-initiated reset is unnecessary but harmless.
+ * The caller must own the SCSI host lock. */
+void usb_stor_report_device_reset(struct us_data *us)
+{
+	int i;
+	struct Scsi_Host *host = us_to_host(us);
+
+	scsi_report_device_reset(host, 0, 0);
+	if (us->flags & US_FL_SCM_MULT_TARG) {
+		for (i = 1; i < host->max_id; ++i)
+			scsi_report_device_reset(host, 0, i);
+	}
+}
+
+/***********************************************************************
+ * /proc/scsi/ functions
+ ***********************************************************************/
+
+/* we use this macro to help us write into the buffer */
+#undef SPRINTF
+#define SPRINTF(args...) \
+	do { if (pos < buffer+length) pos += sprintf(pos, ## args); } while (0)
+
+static int proc_info (struct Scsi_Host *host, char *buffer,
+		char **start, off_t offset, int length, int inout)
+{
+	struct us_data *us = host_to_us(host);
+	char *pos = buffer;
+	const char *string;
+
+	/* if someone is sending us data, just throw it away */
+	if (inout)
+		return length;
+
+	/* print the controller name */
+	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
+
+	/* print product, vendor, and serial number strings */
+	if (us->pusb_dev->manufacturer)
+		string = us->pusb_dev->manufacturer;
+	else if (us->unusual_dev->vendorName)
+		string = us->unusual_dev->vendorName;
+	else
+		string = "Unknown";
+	SPRINTF("       Vendor: %s\n", string);
+	if (us->pusb_dev->product)
+		string = us->pusb_dev->product;
+	else if (us->unusual_dev->productName)
+		string = us->unusual_dev->productName;
+	else
+		string = "Unknown";
+	SPRINTF("      Product: %s\n", string);
+	if (us->pusb_dev->serial)
+		string = us->pusb_dev->serial;
+	else
+		string = "None";
+	SPRINTF("Serial Number: %s\n", string);
+
+	/* show the protocol and transport */
+	SPRINTF("     Protocol: %s\n", us->protocol_name);
+	SPRINTF("    Transport: %s\n", us->transport_name);
+
+	/* show the device flags */
+	if (pos < buffer + length) {
+		pos += sprintf(pos, "       Quirks:");
+
+#define US_FLAG(name, value) \
+	if (us->flags & value) pos += sprintf(pos, " " #name);
+US_DO_ALL_FLAGS
+#undef US_FLAG
+
+		*(pos++) = '\n';
+	}
+
+	/*
+	 * Calculate start of next buffer, and return value.
+	 */
+	*start = buffer + offset;
+
+	if ((pos - buffer) < offset)
+		return (0);
+	else if ((pos - buffer - offset) < length)
+		return (pos - buffer - offset);
+	else
+		return (length);
+}
+
+/***********************************************************************
+ * Sysfs interface
+ ***********************************************************************/
+
+/* Output routine for the sysfs max_sectors file */
+static ssize_t show_max_sectors(struct device *dev, char *buf)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+
+	return sprintf(buf, "%u\n", sdev->request_queue->max_sectors);
+}
+
+/* Input routine for the sysfs max_sectors file */
+static ssize_t store_max_sectors(struct device *dev, const char *buf,
+		size_t count)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	unsigned short ms;
+
+	if (sscanf(buf, "%hu", &ms) > 0 && ms <= SCSI_DEFAULT_MAX_SECTORS) {
+		blk_queue_max_sectors(sdev->request_queue, ms);
+		return strlen(buf);
+	}
+	return -EINVAL;	
+}
+
+static DEVICE_ATTR(max_sectors, S_IRUGO | S_IWUSR, show_max_sectors,
+		store_max_sectors);
+
+static struct device_attribute *sysfs_device_attr_list[] = {
+		&dev_attr_max_sectors,
+		NULL,
+		};
+
+/*
+ * this defines our host template, with which we'll allocate hosts
+ */
+
+struct scsi_host_template usb_stor_host_template = {
+	/* basic userland interface stuff */
+	.name =				"usb-storage",
+	.proc_name =			"usb-storage",
+	.proc_info =			proc_info,
+	.info =				host_info,
+
+	/* command interface -- queued only */
+	.queuecommand =			queuecommand,
+
+	/* error and abort handlers */
+	.eh_abort_handler =		command_abort,
+	.eh_device_reset_handler =	device_reset,
+	.eh_bus_reset_handler =		bus_reset,
+
+	/* queue commands only, only one command per LUN */
+	.can_queue =			1,
+	.cmd_per_lun =			1,
+
+	/* unknown initiator id */
+	.this_id =			-1,
+
+	.slave_alloc =			slave_alloc,
+	.slave_configure =		slave_configure,
+
+	/* lots of sg segments can be handled */
+	.sg_tablesize =			SG_ALL,
+
+	/* limit the total size of a transfer to 120 KB */
+	.max_sectors =                  240,
+
+	/* merge commands... this seems to help performance, but
+	 * periodically someone should test to see which setting is more
+	 * optimal.
+	 */
+	.use_clustering =		1,
+
+	/* emulated HBA */
+	.emulated =			1,
+
+	/* we do our own delay after a device or bus reset */
+	.skip_settle_delay =		1,
+
+	/* sysfs device attributes */
+	.sdev_attrs =			sysfs_device_attr_list,
+
+	/* module management */
+	.module =			THIS_MODULE
+};
+
+/* To Report "Illegal Request: Invalid Field in CDB */
+unsigned char usb_stor_sense_invalidCDB[18] = {
+	[0]	= 0x70,			    /* current error */
+	[2]	= ILLEGAL_REQUEST,	    /* Illegal Request = 0x05 */
+	[7]	= 0x0a,			    /* additional length */
+	[12]	= 0x24			    /* Invalid Field in CDB */
+};
+
