commit e48aa1eb443f80fc6953734c805add4fb694b835
Author: Peter Chen <peter.chen@nxp.com>
Date:   Fri Feb 21 21:40:57 2020 +0800

    usb: chipidea: udc: add software sg list support
    
    The chipidea controller doesn't support short transfer for sg list,
    so we still keep setting IOC per TD, otherwise, there will be no interrupt
    for short transfer. Each TD has five entries for data buffer, each data
    buffer could be non-countinuous 4KB buffer, so it could handle
    up to 5 sg buffers one time. The benefit of this patch is avoiding
    OOM for low memory system(eg, 256MB) during large USB transfers, see
    below for detail. The non-sg handling has not changed.
    
    ufb: page allocation failure: order:4, mode:0x40cc0(GFP_KERNEL|__GFP_COMP),
    nodemask=(null),cpuset=/,mems_allowed=0
    CPU: 2 PID: 370 Comm: ufb Not tainted 5.4.3-1.1.0+g54b3750d61fd #1
    Hardware name: NXP i.MX8MNano DDR4 EVK board (DT)
    Call trace:
     dump_backtrace+0x0/0x140
     show_stack+0x14/0x20
     dump_stack+0xb4/0xf8
     warn_alloc+0xec/0x158
     __alloc_pages_slowpath+0x9cc/0x9f8
     __alloc_pages_nodemask+0x21c/0x280
     alloc_pages_current+0x7c/0xe8
     kmalloc_order+0x1c/0x88
     __kmalloc+0x25c/0x298
     ffs_epfile_io.isra.0+0x20c/0x7d0
     ffs_epfile_read_iter+0xa8/0x188
     new_sync_read+0xe4/0x170
     __vfs_read+0x2c/0x40
     vfs_read+0xc8/0x1a0
     ksys_read+0x68/0xf0
     __arm64_sys_read+0x18/0x20
     el0_svc_common.constprop.0+0x68/0x160
     el0_svc_handler+0x20/0x80
     el0_svc+0x8/0xc
    Mem-Info:
    active_anon:2856 inactive_anon:5269 isolated_anon:12
     active_file:5238 inactive_file:18803 isolated_file:0
     unevictable:0 dirty:22 writeback:416 unstable:0
     slab_reclaimable:4073 slab_unreclaimable:3408
     mapped:727 shmem:7393 pagetables:37 bounce:0
     free:4104 free_pcp:118 free_cma:0
    Node 0 active_anon:11436kB inactive_anon:21076kB active_file:20988kB inactive_file:75216kB unevictable:0kB isolated(ano
    Node 0 DMA32 free:16820kB min:1808kB low:2260kB high:2712kB active_anon:11436kB inactive_anon:21076kB active_file:2098B
    lowmem_reserve[]: 0 0 0
    Node 0 DMA32: 508*4kB (UME) 242*8kB (UME) 730*16kB (UM) 21*32kB (UME) 5*64kB (UME) 2*128kB (M) 0*256kB 0*512kB 0*1024kB
    Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=1048576kB
    Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=32768kB
    Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB
    Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=64kB
    31455 total pagecache pages
    0 pages in swap cache
    Swap cache stats: add 0, delete 0, find 0/0
    Free swap  = 0kB
    Total swap = 0kB
    65536 pages RAM
    0 pages HighMem/MovableOnly
    10766 pages reserved
    0 pages cma reserved
    0 pages hwpoisoned
    
    Reviewed-by: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 644ecaef17ee..0697eb980e5f 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -25,6 +25,7 @@
 #define TD_PAGE_COUNT      5
 #define CI_HDRC_PAGE_SIZE  4096ul /* page size for TD's */
 #define ENDPT_MAX          32
+#define CI_MAX_BUF_SIZE	(TD_PAGE_COUNT * CI_HDRC_PAGE_SIZE)
 
 /******************************************************************************
  * REGISTERS

commit d9958306d4be14f4c7466242b38ed3893a7b1386
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sun Mar 15 16:25:07 2020 +0530

    USB: chipidea: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to ChipIdea Highspeed Dual Role Controller.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://eur01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flkml.org%2Flkml%2F2019%2F2%2F7%2F46&amp;data=02%7C01%7CPeter.Chen%40nxp.com%7Cbea69ff84b574ca6b48e08d7c8cf58cf%7C686ea1d3bc2b4c6fa92cd99c5c301635%7C0%7C0%7C637198665199494622&amp;sdata=bk1n4%2BvnrfRS6ZDrps%2BuXiImdzaxKZ00YskBg6pjtn4%3D&amp;reserved=0.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index d49d5e1235d0..644ecaef17ee 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * ci.h - common structures, functions, and macros of the ChipIdea driver
  *

commit 27bf5be8fbe0b60b1f1aa13083198dac64fc4249
Author: Jun Li <jun.li@nxp.com>
Date:   Wed Jan 22 01:46:59 2020 +0000

    usb: chipidea: handle single role for usb role class
    
    If usb port is configed to be single role, but usb role class
    is trying to set unavailable role, don't try to do role change.
    
    Signed-off-by: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Link: https://lore.kernel.org/r/20200122014639.22667-2-peter.chen@nxp.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 6911aef500e9..d49d5e1235d0 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -302,6 +302,16 @@ static inline enum usb_role ci_role_to_usb_role(struct ci_hdrc *ci)
 		return USB_ROLE_NONE;
 }
 
+static inline enum ci_role usb_role_to_ci_role(enum usb_role role)
+{
+	if (role == USB_ROLE_HOST)
+		return CI_ROLE_HOST;
+	else if (role == USB_ROLE_DEVICE)
+		return CI_ROLE_GADGET;
+	else
+		return CI_ROLE_END;
+}
+
 /**
  * hw_read_id_reg: reads from a identification register
  * @ci: the controller

commit 05559f10ed797b79f7fa47313682c48919a2b111
Author: Li Jun <jun.li@nxp.com>
Date:   Mon Aug 26 18:25:12 2019 +0800

    usb: chipidea: add role switch class support
    
    USB role is fully controlled by usb role switch consumer(e.g. typec),
    usb port can be at host mode(USB_ROLE_HOST), device mode connected to
    host(USB_ROLE_DEVICE), or not connecting any partner(USB_ROLE_NONE).
    
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 6a2cc5cd0281..6911aef500e9 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -16,6 +16,7 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg-fsm.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/role.h>
 #include <linux/ulpi/interface.h>
 
 /******************************************************************************
@@ -217,6 +218,7 @@ struct ci_hdrc {
 	ktime_t				hr_timeouts[NUM_OTG_FSM_TIMERS];
 	unsigned			enabled_otg_timer_bits;
 	enum otg_fsm_timer		next_otg_timer;
+	struct usb_role_switch		*role_switch;
 	struct work_struct		work;
 	struct workqueue_struct		*wq;
 
@@ -290,6 +292,16 @@ static inline void ci_role_stop(struct ci_hdrc *ci)
 	ci->roles[role]->stop(ci);
 }
 
+static inline enum usb_role ci_role_to_usb_role(struct ci_hdrc *ci)
+{
+	if (ci->role == CI_ROLE_HOST)
+		return USB_ROLE_HOST;
+	else if (ci->role == CI_ROLE_GADGET && ci->vbus_active)
+		return USB_ROLE_DEVICE;
+	else
+		return USB_ROLE_NONE;
+}
+
 /**
  * hw_read_id_reg: reads from a identification register
  * @ci: the controller

commit a930d8bd94d8db7715d1af74299f710b1fb22fc8
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Jul 4 10:09:58 2018 -0300

    usb: chipidea: Always build ULPI code
    
    Commit 03e6275ae381 ("usb: chipidea: Fix ULPI on imx51") causes a kernel
    hang on imx51 systems that use the ULPI interface and do not select the
    CONFIG_USB_CHIPIDEA_ULPI option.
    
    In order to avoid such potential misuse, let's always build the
    chipidea ULPI code into the final ci_hdrc object.
    
    Tested on a imx51-babbage board.
    
    Fixes: 03e6275ae381 ("usb: chipidea: Fix ULPI on imx51")
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 0bf244d50544..6a2cc5cd0281 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -240,10 +240,8 @@ struct ci_hdrc {
 
 	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
-#ifdef CONFIG_USB_CHIPIDEA_ULPI
 	struct ulpi			*ulpi;
 	struct ulpi_ops 		ulpi_ops;
-#endif
 	struct phy			*phy;
 	/* old usb_phy interface */
 	struct usb_phy			*usb_phy;
@@ -426,15 +424,9 @@ static inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)
 #endif
 }
 
-#if IS_ENABLED(CONFIG_USB_CHIPIDEA_ULPI)
 int ci_ulpi_init(struct ci_hdrc *ci);
 void ci_ulpi_exit(struct ci_hdrc *ci);
 int ci_ulpi_resume(struct ci_hdrc *ci);
-#else
-static inline int ci_ulpi_init(struct ci_hdrc *ci) { return 0; }
-static inline void ci_ulpi_exit(struct ci_hdrc *ci) { }
-static inline int ci_ulpi_resume(struct ci_hdrc *ci) { return 0; }
-#endif
 
 u32 hw_read_intr_enable(struct ci_hdrc *ci);
 

commit a61b75d10882b3732b6dba29c10b1a54ffb36819
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 29 17:30:58 2018 +0200

    USB: chipidea: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 98b7cb3d0064..0bf244d50544 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -450,7 +450,7 @@ void hw_phymode_configure(struct ci_hdrc *ci);
 
 void ci_platform_configure(struct ci_hdrc *ci);
 
-int dbg_create_files(struct ci_hdrc *ci);
+void dbg_create_files(struct ci_hdrc *ci);
 
 void dbg_remove_files(struct ci_hdrc *ci);
 #endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */

commit 51b751f112dcbb24b46051fe64c2ddbe8aa367ea
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:18 2017 +0100

    USB: chipidea: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index fa6dd9d9f5c6..98b7cb3d0064 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -5,10 +5,6 @@
  * Copyright (C) 2008 Chipidea - MIPS Technologies, Inc. All rights reserved.
  *
  * Author: David Lopo
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __DRIVERS_USB_CHIPIDEA_CI_H

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 6743f85b1b7a..fa6dd9d9f5c6 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ci.h - common structures, functions, and macros of the ChipIdea driver
  *

commit 4f4555cfe704913ce4ce836ab2707825d784a7cc
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Mar 7 10:35:01 2017 +0800

    usb: chipidea: udc: update gadget state after bus resume
    
    Gadget state is set to be suspended when bus suspened, but not updated
    after resume, this patch saves the gadget state before suspend and
    restores it after resume.
    
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 59e22389c10b..6743f85b1b7a 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -177,6 +177,7 @@ struct hw_bank {
  * @td_pool: allocation pool for transfer descriptors
  * @gadget: device side representation for peripheral controller
  * @driver: gadget driver
+ * @resume_state: save the state of gadget suspend from
  * @hw_ep_max: total number of endpoints supported by hardware
  * @ci_hw_ep: array of endpoints
  * @ep0_dir: ep0 direction
@@ -227,6 +228,7 @@ struct ci_hdrc {
 
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
+	enum usb_device_state		resume_state;
 	unsigned			hw_ep_max;
 	struct ci_hw_ep			ci_hw_ep[ENDPT_MAX];
 	u32				ep0_dir;

commit 7bb7e9b1a4319d7c305c033c2df46028fbcc10ae
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:56:55 2016 -0800

    usb: chipidea: Add support for ULPI PHY bus
    
    Some phys for the chipidea controller are controlled via the ULPI
    viewport. Add support for the ULPI bus so that these sorts of
    phys can be probed and read/written automatically without having
    to duplicate the viewport logic in each phy driver.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 05bc4d631cb9..59e22389c10b 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -18,6 +18,8 @@
 #include <linux/usb.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg-fsm.h>
+#include <linux/usb/otg.h>
+#include <linux/ulpi/interface.h>
 
 /******************************************************************************
  * DEFINE
@@ -52,6 +54,7 @@ enum ci_hw_regs {
 	OP_ENDPTLISTADDR,
 	OP_TTCTRL,
 	OP_BURSTSIZE,
+	OP_ULPI_VIEWPORT,
 	OP_PORTSC,
 	OP_DEVLC,
 	OP_OTGSC,
@@ -187,6 +190,8 @@ struct hw_bank {
  * @test_mode: the selected test mode
  * @platdata: platform specific information supplied by parent device
  * @vbus_active: is VBUS active
+ * @ulpi: pointer to ULPI device, if any
+ * @ulpi_ops: ULPI read/write ops for this device
  * @phy: pointer to PHY, if any
  * @usb_phy: pointer to USB PHY, if any and if using the USB PHY framework
  * @hcd: pointer to usb_hcd for ehci host driver
@@ -236,6 +241,10 @@ struct ci_hdrc {
 
 	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
+#ifdef CONFIG_USB_CHIPIDEA_ULPI
+	struct ulpi			*ulpi;
+	struct ulpi_ops 		ulpi_ops;
+#endif
 	struct phy			*phy;
 	/* old usb_phy interface */
 	struct usb_phy			*usb_phy;
@@ -418,6 +427,16 @@ static inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)
 #endif
 }
 
+#if IS_ENABLED(CONFIG_USB_CHIPIDEA_ULPI)
+int ci_ulpi_init(struct ci_hdrc *ci);
+void ci_ulpi_exit(struct ci_hdrc *ci);
+int ci_ulpi_resume(struct ci_hdrc *ci);
+#else
+static inline int ci_ulpi_init(struct ci_hdrc *ci) { return 0; }
+static inline void ci_ulpi_exit(struct ci_hdrc *ci) { }
+static inline int ci_ulpi_resume(struct ci_hdrc *ci) { return 0; }
+#endif
+
 u32 hw_read_intr_enable(struct ci_hdrc *ci);
 
 u32 hw_read_intr_status(struct ci_hdrc *ci);
@@ -428,6 +447,8 @@ int hw_port_test_set(struct ci_hdrc *ci, u8 mode);
 
 u8 hw_port_test_get(struct ci_hdrc *ci);
 
+void hw_phymode_configure(struct ci_hdrc *ci);
+
 void ci_platform_configure(struct ci_hdrc *ci);
 
 int dbg_create_files(struct ci_hdrc *ci);

commit f60f8ccd54e03c1afafb2b20ceb029a0eaf7a134
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:56:50 2016 -0800

    usb: chipidea: Only read/write OTGSC from one place
    
    With the id and vbus detection done via extcon we need to make
    sure we poll the status of OTGSC properly by considering what the
    extcon is saying, and not just what the register is saying. Let's
    move this hw_wait_reg() function to the only place it's used and
    simplify it for polling the OTGSC register. Then we can make
    certain we only use the hw_read_otgsc() API to read OTGSC, which
    will make sure we properly handle extcon events.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Ivan T. Ivanov" <iivanov.xz@gmail.com>
    Fixes: 3ecb3e09b042 ("usb: chipidea: Use extcon framework for VBUS and ID detect")
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index cd414559040f..05bc4d631cb9 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -428,9 +428,6 @@ int hw_port_test_set(struct ci_hdrc *ci, u8 mode);
 
 u8 hw_port_test_get(struct ci_hdrc *ci);
 
-int hw_wait_reg(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask,
-				u32 value, unsigned int timeout_ms);
-
 void ci_platform_configure(struct ci_hdrc *ci);
 
 int dbg_create_files(struct ci_hdrc *ci);

commit 9d8c850d02b01f3e0157a8f9859fe3f04cab68fe
Author: Peter Chen <peter.chen@freescale.com>
Date:   Fri Oct 23 10:33:58 2015 +0800

    usb: chipidea: support debugfs without CONFIG_USB_CHIPIDEA_DEBUG
    
    Since we need to mount debugfs to show/store the things we
    want to debug, it is duplicated to add another configuration
    to enable it. Meanwhile, with CONFIG_USB_CHIPIDEA_DEBUG,
    we can't support chipidea debugfs at runtime.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Cc: Jun Li <jun.li@freescale.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 41d7cf6d63ba..cd414559040f 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -433,4 +433,7 @@ int hw_wait_reg(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask,
 
 void ci_platform_configure(struct ci_hdrc *ci);
 
+int dbg_create_files(struct ci_hdrc *ci);
+
+void dbg_remove_files(struct ci_hdrc *ci);
 #endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */

commit 37a842d36f63a047d94be2603d40d4407c949f1b
Merge: a3fbedf98fe9 96625eadca1b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 14 16:43:09 2015 -0700

    Merge tag 'usb-ci-v4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/peter.chen/usb into usb-next
    
    Peter writes:
    
    USB: chipidea updates for v4.3-rc1
    
    The main changes are adding several system interfaces for
    tuning performance, and each vendors can adjust them according
    to their design configurations.
    
    Others are tiny improvements, like more well siTD supports,
    USB_DEVICE_A_HNP_SUPPORT supports, etc.

commit 96625eadca1bb8832fb502f0899a543695f1ba35
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Mar 17 17:32:45 2015 +0800

    usb: chipidea: add tx/rx burst size configuration interface
    
    The user can adjust it through dts or platform data
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 1320a4dbbcd5..62f2a7be0697 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -51,6 +51,7 @@ enum ci_hw_regs {
 	OP_DEVICEADDR,
 	OP_ENDPTLISTADDR,
 	OP_TTCTRL,
+	OP_BURSTSIZE,
 	OP_PORTSC,
 	OP_DEVLC,
 	OP_OTGSC,

commit bf9c85e78d0fec61360ece46dacf9ab71ba89361
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Mar 17 10:40:50 2015 +0800

    usb: chipidea: introduce ci_platform_configure
    
    It is used to configure controller parameters according to
    platform data, like speed, stream mode, etc, both host and
    device's initialization need it, most of code are the
    same for both roles, with this new interface, it can reduce
    the duplicated code and be easy to maintain in future.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index df57e49ed4ef..1320a4dbbcd5 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -427,4 +427,6 @@ u8 hw_port_test_get(struct ci_hdrc *ci);
 int hw_wait_reg(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask,
 				u32 value, unsigned int timeout_ms);
 
+void ci_platform_configure(struct ci_hdrc *ci);
+
 #endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */

commit 28362673129e7d4510a5a92a8b68ee47f282210b
Author: Peter Chen <peter.chen@freescale.com>
Date:   Thu Jun 18 11:51:53 2015 +0800

    usb: chipidea: add ttctrl.ttha control interface
    
    The register of ttctrl.ttha describes like below:
    - Internal TT Hub Address Representation
    - RW
    - Default = 0000000b
    This field is used to match against the Hub Address field in QH & siTD
    to determine if the packet is routed to the internal TT for directly
    attached FS/LS devices. If the Hub Address in the QH or siTD does not
    match this address then the packet will be broadcast on the High Speed
    ports destined for a downstream High Speed hub with the address in the QH/siTD.
    
    In silicon RTL, this entry only affects QH and siTD, and the hub.addr at
    both QH and siTD are 0 in ehci core for chipidea (with hcd->has_tt = 1).
    
    So, for QH, if the "usage_tt" flag at RTL is 0, set CI_HDRC_SET_NON_ZERO_TTHA
    will not affect QH (with non-hs device); for siTD, set this flag
    will change remaining space requirement for the last transaction from 1023
    bytes to 188 bytes, it can increase the number of transactions within one
    frame, ehci periodic schedule code will not queue the packet if the frame space
    is full, so it is safe to set this flag for siTD.
    
    With this flag, it can fix the problem Alan Stern reported below:
    http://www.spinics.net/lists/linux-usb/msg123125.html
    And may fix Michael Tessier's problem too.
    http://www.spinics.net/lists/linux-usb/msg118679.html
    
    CC: stern@rowland.harvard.edu
    CC: michael.tessier@axiontech.ca
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 6d6200e37b71..df57e49ed4ef 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -50,6 +50,7 @@ enum ci_hw_regs {
 	OP_USBINTR,
 	OP_DEVICEADDR,
 	OP_ENDPTLISTADDR,
+	OP_TTCTRL,
 	OP_PORTSC,
 	OP_DEVLC,
 	OP_OTGSC,

commit b0930d4cafb487a663ac6780a0369d1a0f461bc2
Author: Li Jun <jun.li@freescale.com>
Date:   Thu Jul 9 15:18:46 2015 +0800

    usb: chipidea: update ci_otg_is_fsm_mode conditions
    
    After introduce usb otg properties, update ci_otg_is_fsm_mode conditions
    to be depending on both usb hardware properties and usb driver config,
    also resolve a compile issue in debug.c after the API change.
    
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 6d6200e37b71..f243f0b431c3 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -406,8 +406,11 @@ static inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 static inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)
 {
 #ifdef CONFIG_USB_OTG_FSM
+	struct usb_otg_caps *otg_caps = &ci->platdata->ci_otg_caps;
+
 	return ci->is_otg && ci->roles[CI_ROLE_HOST] &&
-					ci->roles[CI_ROLE_GADGET];
+		ci->roles[CI_ROLE_GADGET] && (otg_caps->srp_support ||
+		otg_caps->hnp_support || otg_caps->adp_support);
 #else
 	return false;
 #endif

commit 3a316ec4c91cfe03093d708369f9ab57000c96c3
Author: Li Jun <b47624@freescale.com>
Date:   Fri Mar 20 16:28:06 2015 +0800

    usb: chipidea: use hrtimer for otg fsm timers
    
    Current otg fsm timers are using controller 1ms irq and count it, this patch
    is to replace it with hrtimer solution, use one hrtimer for all otg timers.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index c09381d4ca77..6d6200e37b71 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -162,7 +162,10 @@ struct hw_bank {
  * @role: current role
  * @is_otg: if the device is otg-capable
  * @fsm: otg finite state machine
- * @fsm_timer: pointer to timer list of otg fsm
+ * @otg_fsm_hrtimer: hrtimer for otg fsm timers
+ * @hr_timeouts: time out list for active otg fsm timers
+ * @enabled_otg_timer_bits: bits of enabled otg timers
+ * @next_otg_timer: next nearest enabled timer to be expired
  * @work: work for role changing
  * @wq: workqueue thread
  * @qh_pool: allocation pool for queue heads
@@ -205,7 +208,10 @@ struct ci_hdrc {
 	bool				is_otg;
 	struct usb_otg			otg;
 	struct otg_fsm			fsm;
-	struct ci_otg_fsm_timer_list	*fsm_timer;
+	struct hrtimer			otg_fsm_hrtimer;
+	ktime_t				hr_timeouts[NUM_OTG_FSM_TIMERS];
+	unsigned			enabled_otg_timer_bits;
+	enum otg_fsm_timer		next_otg_timer;
 	struct work_struct		work;
 	struct workqueue_struct		*wq;
 

commit cb271f3ce969a0fc4ecf9fc4b5a28852509714ed
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 11 12:44:55 2015 +0800

    usb: chipidea: add chipidea revision information
    
    Define ci_get_revision API to know the controller revision
    information according to chipidea 1.1a, 2.0a and 2.5a spec.
    Besides, add one entry at struct ci_hdrc to indicate revision
    information, it can be used for adding different code for
    revisions, eg kinds of errata.
    
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index e53287aff916..c09381d4ca77 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -106,6 +106,18 @@ enum ci_role {
 	CI_ROLE_END,
 };
 
+enum ci_revision {
+	CI_REVISION_1X = 10,	/* Revision 1.x */
+	CI_REVISION_20 = 20, /* Revision 2.0 */
+	CI_REVISION_21, /* Revision 2.1 */
+	CI_REVISION_22, /* Revision 2.2 */
+	CI_REVISION_23, /* Revision 2.3 */
+	CI_REVISION_24, /* Revision 2.4 */
+	CI_REVISION_25, /* Revision 2.5 */
+	CI_REVISION_25_PLUS, /* Revision above than 2.5 */
+	CI_REVISION_UNKNOWN = 99, /* Unknown Revision */
+};
+
 /**
  * struct ci_role_driver - host/gadget role driver
  * @start: start this role
@@ -181,6 +193,7 @@ struct hw_bank {
  * @supports_runtime_pm: if runtime pm is supported
  * @in_lpm: if the core in low power mode
  * @wakeup_int: if wakeup interrupt occur
+ * @rev: The revision number for controller
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -226,6 +239,7 @@ struct ci_hdrc {
 	bool				supports_runtime_pm;
 	bool				in_lpm;
 	bool				wakeup_int;
+	enum ci_revision		rev;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)

commit 655d32e9b2b2b912ff86de656eb620627b0df117
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 11 12:44:54 2015 +0800

    usb: chipidea: add identification registers access APIs
    
    Using hw_write_id_reg and hw_read_id_reg to write and read identification
    registers contents, they can be used to get controller information, change
    some system configurations, and so on.
    
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index a0aeb8df9280..e53287aff916 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -29,6 +29,15 @@
 /******************************************************************************
  * REGISTERS
  *****************************************************************************/
+/* Identification Registers */
+#define ID_ID				0x0
+#define ID_HWGENERAL			0x4
+#define ID_HWHOST			0x8
+#define ID_HWDEVICE			0xc
+#define ID_HWTXBUF			0x10
+#define ID_HWRXBUF			0x14
+#define ID_SBUSCFG			0x90
+
 /* register indices */
 enum ci_hw_regs {
 	CAP_CAPLENGTH,
@@ -253,6 +262,36 @@ static inline void ci_role_stop(struct ci_hdrc *ci)
 	ci->roles[role]->stop(ci);
 }
 
+/**
+ * hw_read_id_reg: reads from a identification register
+ * @ci: the controller
+ * @offset: offset from the beginning of identification registers region
+ * @mask: bitfield mask
+ *
+ * This function returns register contents
+ */
+static inline u32 hw_read_id_reg(struct ci_hdrc *ci, u32 offset, u32 mask)
+{
+	return ioread32(ci->hw_bank.abs + offset) & mask;
+}
+
+/**
+ * hw_write_id_reg: writes to a identification register
+ * @ci: the controller
+ * @offset: offset from the beginning of identification registers region
+ * @mask: bitfield mask
+ * @data: new value
+ */
+static inline void hw_write_id_reg(struct ci_hdrc *ci, u32 offset,
+			    u32 mask, u32 data)
+{
+	if (~mask)
+		data = (ioread32(ci->hw_bank.abs + offset) & ~mask)
+			| (data & mask);
+
+	iowrite32(data, ci->hw_bank.abs + offset);
+}
+
 /**
  * hw_read: reads from a hw register
  * @ci: the controller

commit 1f874edcb7318c5dd71025df9f3849715b4e4f71
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 11 12:44:45 2015 +0800

    usb: chipidea: add runtime power management support
    
    Add runtime power management support.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 65913d48f0c8..a0aeb8df9280 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -169,6 +169,9 @@ struct hw_bank {
  * @b_sess_valid_event: indicates there is a vbus event, and handled
  * at ci_otg_work
  * @imx28_write_fix: Freescale imx28 needs swp instruction for writing
+ * @supports_runtime_pm: if runtime pm is supported
+ * @in_lpm: if the core in low power mode
+ * @wakeup_int: if wakeup interrupt occur
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -211,6 +214,9 @@ struct ci_hdrc {
 	bool				id_event;
 	bool				b_sess_valid_event;
 	bool				imx28_write_fix;
+	bool				supports_runtime_pm;
+	bool				in_lpm;
+	bool				wakeup_int;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)

commit 5b1573005a91dc448e6919d6bec076bedc7e1919
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Nov 26 13:44:33 2014 +0800

    usb: chipidea: parameter 'mode' isn't needed for hw_device_reset
    
    The hw_device_reset is dedicated to be used at device mode initializaiton,
    so delete the parameter 'mode'. For host driver, the ehci driver will
    handle all things.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 5bbfcc73cf70..65913d48f0c8 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -352,7 +352,7 @@ u32 hw_read_intr_enable(struct ci_hdrc *ci);
 
 u32 hw_read_intr_status(struct ci_hdrc *ci);
 
-int hw_device_reset(struct ci_hdrc *ci, u32 mode);
+int hw_device_reset(struct ci_hdrc *ci);
 
 int hw_port_test_set(struct ci_hdrc *ci, u8 mode);
 

commit 1e5e2d3d055436c114e2f16145b83339aed024ff
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:19 2014 +0100

    usb: chipidea: add support to the generic PHY framework
    
    This patch adds support of the PHY framework for ChipIdea drivers.
    Changes are done in both the ChipIdea common code and in the drivers
    accessing the PHY. This is done by adding a new PHY member in
    ChipIdea's structures and by taking care of it in the code.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 9015139a8027..5bbfcc73cf70 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -161,7 +161,8 @@ struct hw_bank {
  * @test_mode: the selected test mode
  * @platdata: platform specific information supplied by parent device
  * @vbus_active: is VBUS active
- * @usb_phy: pointer to USB PHY, if any
+ * @phy: pointer to PHY, if any
+ * @usb_phy: pointer to USB PHY, if any and if using the USB PHY framework
  * @hcd: pointer to usb_hcd for ehci host driver
  * @debugfs: root dentry for this controller in debugfs
  * @id_event: indicates there is an id event, and handled at ci_otg_work
@@ -202,6 +203,8 @@ struct ci_hdrc {
 
 	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
+	struct phy			*phy;
+	/* old usb_phy interface */
 	struct usb_phy			*usb_phy;
 	struct usb_hcd			*hcd;
 	struct dentry			*debugfs;

commit ef44cb4226d132146e44f8ea562a16b27ff61126
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:16 2014 +0100

    usb: allow to supply the PHY in the drivers when using HCD
    
    This patch modify the generic code handling PHYs to allow them to be
    supplied from the drivers. This adds checks to ensure no PHY was already
    there when looking for one in the generic code. This also makes sure we
    do not modify its state in the generic HCD functions, it was provided by
    the driver.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index ea40626e0246..9015139a8027 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -161,7 +161,7 @@ struct hw_bank {
  * @test_mode: the selected test mode
  * @platdata: platform specific information supplied by parent device
  * @vbus_active: is VBUS active
- * @transceiver: pointer to USB PHY, if any
+ * @usb_phy: pointer to USB PHY, if any
  * @hcd: pointer to usb_hcd for ehci host driver
  * @debugfs: root dentry for this controller in debugfs
  * @id_event: indicates there is an id event, and handled at ci_otg_work
@@ -177,6 +177,7 @@ struct ci_hdrc {
 	struct ci_role_driver		*roles[CI_ROLE_END];
 	enum ci_role			role;
 	bool				is_otg;
+	struct usb_otg			otg;
 	struct otg_fsm			fsm;
 	struct ci_otg_fsm_timer_list	*fsm_timer;
 	struct work_struct		work;
@@ -201,7 +202,7 @@ struct ci_hdrc {
 
 	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
-	struct usb_phy			*transceiver;
+	struct usb_phy			*usb_phy;
 	struct usb_hcd			*hcd;
 	struct dentry			*debugfs;
 	bool				id_event;

commit 19353881b4afc9e2351fa8987b8fa2921587e0d6
Author: Peter Chen <peter.chen@freescale.com>
Date:   Mon Sep 22 08:14:17 2014 +0800

    usb: chipidea: enhance kernel-doc format
    
    Some kernel-doc style comment are not satisfied for format, fix them.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 9563cb56d564..ea40626e0246 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -99,10 +99,10 @@ enum ci_role {
 
 /**
  * struct ci_role_driver - host/gadget role driver
- * start: start this role
- * stop: stop this role
- * irq: irq handler for this role
- * name: role name string (host/gadget)
+ * @start: start this role
+ * @stop: stop this role
+ * @irq: irq handler for this role
+ * @name: role name string (host/gadget)
  */
 struct ci_role_driver {
 	int		(*start)(struct ci_hdrc *);
@@ -245,6 +245,7 @@ static inline void ci_role_stop(struct ci_hdrc *ci)
 
 /**
  * hw_read: reads from a hw register
+ * @ci: the controller
  * @reg:  register index
  * @mask: bitfield mask
  *
@@ -277,6 +278,7 @@ static inline void __hw_write(struct ci_hdrc *ci, u32 val,
 
 /**
  * hw_write: writes to a hw register
+ * @ci: the controller
  * @reg:  register index
  * @mask: bitfield mask
  * @data: new value
@@ -293,6 +295,7 @@ static inline void hw_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 
 /**
  * hw_test_and_clear: tests & clears a hw register
+ * @ci: the controller
  * @reg:  register index
  * @mask: bitfield mask
  *
@@ -309,6 +312,7 @@ static inline u32 hw_test_and_clear(struct ci_hdrc *ci, enum ci_hw_regs reg,
 
 /**
  * hw_test_and_write: tests & writes a hw register
+ * @ci: the controller
  * @reg:  register index
  * @mask: bitfield mask
  * @data: new value
@@ -327,6 +331,8 @@ static inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 /**
  * ci_otg_is_fsm_mode: runtime check if otg controller
  * is in otg fsm mode.
+ *
+ * @ci: chipidea device
  */
 static inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)
 {

commit 826cfe751f3e1faf4a63b65245f5ee3a7efeb763
Author: Li Jun <B47624@freescale.com>
Date:   Wed Apr 23 15:56:48 2014 +0800

    usb: chipidea: add OTG fsm operation functions implementation
    
    Add OTG HNP and SRP operation functions implementation:
    - charge vbus
    - drive vbus
    - connection signaling
    - drive sof
    - start data pulse
    - add fsm timer
    - delete fsm timer
    - start host
    - start gadget
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index bd3529f29e86..9563cb56d564 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -141,6 +141,7 @@ struct hw_bank {
  * @role: current role
  * @is_otg: if the device is otg-capable
  * @fsm: otg finite state machine
+ * @fsm_timer: pointer to timer list of otg fsm
  * @work: work for role changing
  * @wq: workqueue thread
  * @qh_pool: allocation pool for queue heads
@@ -177,6 +178,7 @@ struct ci_hdrc {
 	enum ci_role			role;
 	bool				is_otg;
 	struct otg_fsm			fsm;
+	struct ci_otg_fsm_timer_list	*fsm_timer;
 	struct work_struct		work;
 	struct workqueue_struct		*wq;
 

commit 57677be5ef838743561f4c1d16821dda0438d362
Author: Li Jun <B47624@freescale.com>
Date:   Wed Apr 23 15:56:44 2014 +0800

    usb: chipidea: usb OTG fsm initialization.
    
    This patch adds OTG fsm related initialization when do otg init,
    add a seperate file for OTG fsm related utilities.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 7ae8cb680321..bd3529f29e86 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -17,6 +17,7 @@
 #include <linux/irqreturn.h>
 #include <linux/usb.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/otg-fsm.h>
 
 /******************************************************************************
  * DEFINE
@@ -139,6 +140,7 @@ struct hw_bank {
  * @roles: array of supported roles for this controller
  * @role: current role
  * @is_otg: if the device is otg-capable
+ * @fsm: otg finite state machine
  * @work: work for role changing
  * @wq: workqueue thread
  * @qh_pool: allocation pool for queue heads
@@ -174,6 +176,7 @@ struct ci_hdrc {
 	struct ci_role_driver		*roles[CI_ROLE_END];
 	enum ci_role			role;
 	bool				is_otg;
+	struct otg_fsm			fsm;
 	struct work_struct		work;
 	struct workqueue_struct		*wq;
 
@@ -319,6 +322,20 @@ static inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 	return (val & mask) >> __ffs(mask);
 }
 
+/**
+ * ci_otg_is_fsm_mode: runtime check if otg controller
+ * is in otg fsm mode.
+ */
+static inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)
+{
+#ifdef CONFIG_USB_OTG_FSM
+	return ci->is_otg && ci->roles[CI_ROLE_HOST] &&
+					ci->roles[CI_ROLE_GADGET];
+#else
+	return false;
+#endif
+}
+
 u32 hw_read_intr_enable(struct ci_hdrc *ci);
 
 u32 hw_read_intr_status(struct ci_hdrc *ci);

commit 36304b0616280809a58ebdd69d74f7c61286f9b5
Author: Li Jun <B47624@freescale.com>
Date:   Wed Apr 23 15:56:39 2014 +0800

    usb: chipidea: export interrupt enable and status register read functions
    
    This patch moves usb interrupt enable and status register read functions
    from udc driver to core driver to use them in all ci drivers.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index e206406ae1d9..7ae8cb680321 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -319,6 +319,10 @@ static inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 	return (val & mask) >> __ffs(mask);
 }
 
+u32 hw_read_intr_enable(struct ci_hdrc *ci);
+
+u32 hw_read_intr_status(struct ci_hdrc *ci);
+
 int hw_device_reset(struct ci_hdrc *ci, u32 mode);
 
 int hw_port_test_set(struct ci_hdrc *ci, u8 mode);

commit c859aa65a7ec40c02f435f14fa71de2a87c64513
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 19 13:41:40 2014 +0800

    usb: chipidea: refine PHY operation
    
    - Delete global_phy due to we can get the phy from phy layer now
    - using devm_usb_get_phy to instead of usb_get_phy
    - delete the otg_set_peripheral, which should be handled by otg layer
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 88b80f7728e4..e206406ae1d9 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -196,8 +196,6 @@ struct ci_hdrc {
 
 	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
-	/* FIXME: some day, we'll not use global phy */
-	bool				global_phy;
 	struct usb_phy			*transceiver;
 	struct usb_hcd			*hcd;
 	struct dentry			*debugfs;

commit ed8f8318d2ef3e5f9e4ddf79349508c116b68d7f
Author: Peter Chen <peter.chen@freescale.com>
Date:   Fri Jan 10 13:51:27 2014 +0800

    usb: chipidea: add freescale imx28 special write register method
    
    According to Freescale imx28 Errata, "ENGR119653 USB: ARM to USB
    register error issue", All USB register write operations must
    use the ARM SWP instruction. So, we implement special hw_write
    and hw_test_and_clear for imx28.
    
    Discussion for it at below:
    http://marc.info/?l=linux-usb&m=137996395529294&w=2
    
    This patch is needed for stable tree 3.11+.
    
    Cc: stable@vger.kernel.org
    Cc: robert.hodaszi@digi.com
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Tested-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index a71dc1c89aa2..88b80f7728e4 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -164,6 +164,7 @@ struct hw_bank {
  * @id_event: indicates there is an id event, and handled at ci_otg_work
  * @b_sess_valid_event: indicates there is a vbus event, and handled
  * at ci_otg_work
+ * @imx28_write_fix: Freescale imx28 needs swp instruction for writing
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -202,6 +203,7 @@ struct ci_hdrc {
 	struct dentry			*debugfs;
 	bool				id_event;
 	bool				b_sess_valid_event;
+	bool				imx28_write_fix;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)
@@ -250,6 +252,26 @@ static inline u32 hw_read(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask)
 	return ioread32(ci->hw_bank.regmap[reg]) & mask;
 }
 
+#ifdef CONFIG_SOC_IMX28
+static inline void imx28_ci_writel(u32 val, volatile void __iomem *addr)
+{
+	__asm__ ("swp %0, %0, [%1]" : : "r"(val), "r"(addr));
+}
+#else
+static inline void imx28_ci_writel(u32 val, volatile void __iomem *addr)
+{
+}
+#endif
+
+static inline void __hw_write(struct ci_hdrc *ci, u32 val,
+		void __iomem *addr)
+{
+	if (ci->imx28_write_fix)
+		imx28_ci_writel(val, addr);
+	else
+		iowrite32(val, addr);
+}
+
 /**
  * hw_write: writes to a hw register
  * @reg:  register index
@@ -263,7 +285,7 @@ static inline void hw_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 		data = (ioread32(ci->hw_bank.regmap[reg]) & ~mask)
 			| (data & mask);
 
-	iowrite32(data, ci->hw_bank.regmap[reg]);
+	__hw_write(ci, data, ci->hw_bank.regmap[reg]);
 }
 
 /**
@@ -278,7 +300,7 @@ static inline u32 hw_test_and_clear(struct ci_hdrc *ci, enum ci_hw_regs reg,
 {
 	u32 val = ioread32(ci->hw_bank.regmap[reg]) & mask;
 
-	iowrite32(val, ci->hw_bank.regmap[reg]);
+	__hw_write(ci, val, ci->hw_bank.regmap[reg]);
 	return val;
 }
 

commit 21395a1aac7ce1e19dbb43542a9e06cca2bfca01
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Jan 6 10:10:38 2014 +0800

    usb: chipidea: move malloced regmap directly into struct hw_bank
    
    Without this patch a seperate chunk of memory is allocated for the regmap
    array. As the regmap is always used it makes no sense to allocate a seperate
    memory block for it, this patch moves the regmap array directly into the struct
    hw_bank.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 1c94fc5257f4..a71dc1c89aa2 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -25,6 +25,35 @@
 #define CI_HDRC_PAGE_SIZE  4096ul /* page size for TD's */
 #define ENDPT_MAX          32
 
+/******************************************************************************
+ * REGISTERS
+ *****************************************************************************/
+/* register indices */
+enum ci_hw_regs {
+	CAP_CAPLENGTH,
+	CAP_HCCPARAMS,
+	CAP_DCCPARAMS,
+	CAP_TESTMODE,
+	CAP_LAST = CAP_TESTMODE,
+	OP_USBCMD,
+	OP_USBSTS,
+	OP_USBINTR,
+	OP_DEVICEADDR,
+	OP_ENDPTLISTADDR,
+	OP_PORTSC,
+	OP_DEVLC,
+	OP_OTGSC,
+	OP_USBMODE,
+	OP_ENDPTSETUPSTAT,
+	OP_ENDPTPRIME,
+	OP_ENDPTFLUSH,
+	OP_ENDPTSTAT,
+	OP_ENDPTCOMPLETE,
+	OP_ENDPTCTRL,
+	/* endptctrl1..15 follow */
+	OP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,
+};
+
 /******************************************************************************
  * STRUCTURES
  *****************************************************************************/
@@ -98,7 +127,7 @@ struct hw_bank {
 	void __iomem	*cap;
 	void __iomem	*op;
 	size_t		size;
-	void __iomem	**regmap;
+	void __iomem	*regmap[OP_LAST + 1];
 };
 
 /**
@@ -209,38 +238,6 @@ static inline void ci_role_stop(struct ci_hdrc *ci)
 	ci->roles[role]->stop(ci);
 }
 
-/******************************************************************************
- * REGISTERS
- *****************************************************************************/
-/* register size */
-#define REG_BITS   (32)
-
-/* register indices */
-enum ci_hw_regs {
-	CAP_CAPLENGTH,
-	CAP_HCCPARAMS,
-	CAP_DCCPARAMS,
-	CAP_TESTMODE,
-	CAP_LAST = CAP_TESTMODE,
-	OP_USBCMD,
-	OP_USBSTS,
-	OP_USBINTR,
-	OP_DEVICEADDR,
-	OP_ENDPTLISTADDR,
-	OP_PORTSC,
-	OP_DEVLC,
-	OP_OTGSC,
-	OP_USBMODE,
-	OP_ENDPTSETUPSTAT,
-	OP_ENDPTPRIME,
-	OP_ENDPTFLUSH,
-	OP_ENDPTSTAT,
-	OP_ENDPTCOMPLETE,
-	OP_ENDPTCTRL,
-	/* endptctrl1..15 follow */
-	OP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,
-};
-
 /**
  * hw_read: reads from a hw register
  * @reg:  register index

commit 22fa84455a2a80566ead8efe4b5e629f2375da60
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:12 2013 +0300

    usb: chipidea: add wait vbus lower than OTGSC_BSV before role starts
    
    When the gadget role starts, we need to make sure the vbus is lower
    than OTGSC_BSV, or there will be an vbus interrupt since we use
    B_SESSION_VALID as vbus interrupt to indicate connect and disconnect.
    When the host role starts, it may not be useful to wait vbus to lower
    than OTGSC_BSV, but it can indicate some hardware problems like the
    vbus is still higher than OTGSC_BSV after we disconnect to host some
    time later (5000 milliseconds currently), which is obvious not correct.
    
    Tested-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 316036392e11..1c94fc5257f4 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -308,4 +308,7 @@ int hw_port_test_set(struct ci_hdrc *ci, u8 mode);
 
 u8 hw_port_test_get(struct ci_hdrc *ci);
 
+int hw_wait_reg(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask,
+				u32 value, unsigned int timeout_ms);
+
 #endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */

commit a107f8c505cd8606ae192d24c70b380e980fbe67
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:11 2013 +0300

    usb: chipidea: add vbus interrupt handler
    
    We add vbus interrupt handler at ci_otg_work, it uses OTGSC_BSV(at otgsc)
    to know it is connect or disconnet event.
    Meanwhile, we introduce two flags id_event and b_sess_valid_event to
    indicate it is an id interrupt or a vbus interrupt.
    
    Tested-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 33cb29f36e06..316036392e11 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -132,6 +132,9 @@ struct hw_bank {
  * @transceiver: pointer to USB PHY, if any
  * @hcd: pointer to usb_hcd for ehci host driver
  * @debugfs: root dentry for this controller in debugfs
+ * @id_event: indicates there is an id event, and handled at ci_otg_work
+ * @b_sess_valid_event: indicates there is a vbus event, and handled
+ * at ci_otg_work
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -168,6 +171,8 @@ struct ci_hdrc {
 	struct usb_phy			*transceiver;
 	struct usb_hcd			*hcd;
 	struct dentry			*debugfs;
+	bool				id_event;
+	bool				b_sess_valid_event;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)

commit 8e22978c57087aac4d88693278db1cc3e94f1253
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Mon Jun 24 14:46:36 2013 +0300

    usb: chipidea: drop "13xxx" infix
    
    "ci13xxx" is bad for at least the following reasons:
      * people often mistype it
      * it doesn't add any informational value to the names it's used in
      * it needlessly attracts mail filters
    
    This patch replaces it with "ci_hdrc", "ci_udc" or "ci_hw", depending
    on the situation. Modules with ci13xxx prefix are also renamed accordingly
    and aliases are added for compatibility. Otherwise, no functional changes.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 9ef686086c24..33cb29f36e06 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -22,14 +22,14 @@
  * DEFINE
  *****************************************************************************/
 #define TD_PAGE_COUNT      5
-#define CI13XXX_PAGE_SIZE  4096ul /* page size for TD's */
+#define CI_HDRC_PAGE_SIZE  4096ul /* page size for TD's */
 #define ENDPT_MAX          32
 
 /******************************************************************************
  * STRUCTURES
  *****************************************************************************/
 /**
- * struct ci13xxx_ep - endpoint representation
+ * struct ci_hw_ep - endpoint representation
  * @ep: endpoint structure for gadget drivers
  * @dir: endpoint direction (TX/RX)
  * @num: endpoint number
@@ -41,7 +41,7 @@
  * @lock: pointer to controller's spinlock
  * @td_pool: pointer to controller's TD pool
  */
-struct ci13xxx_ep {
+struct ci_hw_ep {
 	struct usb_ep				ep;
 	u8					dir;
 	u8					num;
@@ -49,13 +49,13 @@ struct ci13xxx_ep {
 	char					name[16];
 	struct {
 		struct list_head	queue;
-		struct ci13xxx_qh	*ptr;
+		struct ci_hw_qh		*ptr;
 		dma_addr_t		dma;
 	}					qh;
 	int					wedge;
 
 	/* global resources */
-	struct ci13xxx				*ci;
+	struct ci_hdrc				*ci;
 	spinlock_t				*lock;
 	struct dma_pool				*td_pool;
 	struct td_node				*pending_td;
@@ -75,9 +75,9 @@ enum ci_role {
  * name: role name string (host/gadget)
  */
 struct ci_role_driver {
-	int		(*start)(struct ci13xxx *);
-	void		(*stop)(struct ci13xxx *);
-	irqreturn_t	(*irq)(struct ci13xxx *);
+	int		(*start)(struct ci_hdrc *);
+	void		(*stop)(struct ci_hdrc *);
+	irqreturn_t	(*irq)(struct ci_hdrc *);
 	const char	*name;
 };
 
@@ -102,7 +102,7 @@ struct hw_bank {
 };
 
 /**
- * struct ci13xxx - chipidea device representation
+ * struct ci_hdrc - chipidea device representation
  * @dev: pointer to parent device
  * @lock: access synchronization
  * @hw_bank: hardware register mapping
@@ -117,7 +117,7 @@ struct hw_bank {
  * @gadget: device side representation for peripheral controller
  * @driver: gadget driver
  * @hw_ep_max: total number of endpoints supported by hardware
- * @ci13xxx_ep: array of endpoints
+ * @ci_hw_ep: array of endpoints
  * @ep0_dir: ep0 direction
  * @ep0out: pointer to ep0 OUT endpoint
  * @ep0in: pointer to ep0 IN endpoint
@@ -133,7 +133,7 @@ struct hw_bank {
  * @hcd: pointer to usb_hcd for ehci host driver
  * @debugfs: root dentry for this controller in debugfs
  */
-struct ci13xxx {
+struct ci_hdrc {
 	struct device			*dev;
 	spinlock_t			lock;
 	struct hw_bank			hw_bank;
@@ -150,9 +150,9 @@ struct ci13xxx {
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	unsigned			hw_ep_max;
-	struct ci13xxx_ep		ci13xxx_ep[ENDPT_MAX];
+	struct ci_hw_ep			ci_hw_ep[ENDPT_MAX];
 	u32				ep0_dir;
-	struct ci13xxx_ep		*ep0out, *ep0in;
+	struct ci_hw_ep			*ep0out, *ep0in;
 
 	struct usb_request		*status;
 	bool				setaddr;
@@ -161,7 +161,7 @@ struct ci13xxx {
 	u8				suspended;
 	u8				test_mode;
 
-	struct ci13xxx_platform_data	*platdata;
+	struct ci_hdrc_platform_data	*platdata;
 	int				vbus_active;
 	/* FIXME: some day, we'll not use global phy */
 	bool				global_phy;
@@ -170,13 +170,13 @@ struct ci13xxx {
 	struct dentry			*debugfs;
 };
 
-static inline struct ci_role_driver *ci_role(struct ci13xxx *ci)
+static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)
 {
 	BUG_ON(ci->role >= CI_ROLE_END || !ci->roles[ci->role]);
 	return ci->roles[ci->role];
 }
 
-static inline int ci_role_start(struct ci13xxx *ci, enum ci_role role)
+static inline int ci_role_start(struct ci_hdrc *ci, enum ci_role role)
 {
 	int ret;
 
@@ -192,7 +192,7 @@ static inline int ci_role_start(struct ci13xxx *ci, enum ci_role role)
 	return ret;
 }
 
-static inline void ci_role_stop(struct ci13xxx *ci)
+static inline void ci_role_stop(struct ci_hdrc *ci)
 {
 	enum ci_role role = ci->role;
 
@@ -211,7 +211,7 @@ static inline void ci_role_stop(struct ci13xxx *ci)
 #define REG_BITS   (32)
 
 /* register indices */
-enum ci13xxx_regs {
+enum ci_hw_regs {
 	CAP_CAPLENGTH,
 	CAP_HCCPARAMS,
 	CAP_DCCPARAMS,
@@ -243,7 +243,7 @@ enum ci13xxx_regs {
  *
  * This function returns register contents
  */
-static inline u32 hw_read(struct ci13xxx *ci, enum ci13xxx_regs reg, u32 mask)
+static inline u32 hw_read(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask)
 {
 	return ioread32(ci->hw_bank.regmap[reg]) & mask;
 }
@@ -254,7 +254,7 @@ static inline u32 hw_read(struct ci13xxx *ci, enum ci13xxx_regs reg, u32 mask)
  * @mask: bitfield mask
  * @data: new value
  */
-static inline void hw_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
+static inline void hw_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 			    u32 mask, u32 data)
 {
 	if (~mask)
@@ -271,7 +271,7 @@ static inline void hw_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
  *
  * This function returns register contents
  */
-static inline u32 hw_test_and_clear(struct ci13xxx *ci, enum ci13xxx_regs reg,
+static inline u32 hw_test_and_clear(struct ci_hdrc *ci, enum ci_hw_regs reg,
 				    u32 mask)
 {
 	u32 val = ioread32(ci->hw_bank.regmap[reg]) & mask;
@@ -288,7 +288,7 @@ static inline u32 hw_test_and_clear(struct ci13xxx *ci, enum ci13xxx_regs reg,
  *
  * This function returns register contents
  */
-static inline u32 hw_test_and_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
+static inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,
 				    u32 mask, u32 data)
 {
 	u32 val = hw_read(ci, reg, ~0);
@@ -297,10 +297,10 @@ static inline u32 hw_test_and_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
 	return (val & mask) >> __ffs(mask);
 }
 
-int hw_device_reset(struct ci13xxx *ci, u32 mode);
+int hw_device_reset(struct ci_hdrc *ci, u32 mode);
 
-int hw_port_test_set(struct ci13xxx *ci, u8 mode);
+int hw_port_test_set(struct ci_hdrc *ci, u8 mode);
 
-u8 hw_port_test_get(struct ci13xxx *ci);
+u8 hw_port_test_get(struct ci_hdrc *ci);
 
 #endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */

commit 2e270412968d961ecde347343ffa67dfe39f6c95
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Thu Jun 13 17:59:54 2013 +0300

    usb: chipidea: udc: add multiple td support to hardware_{en,de}queue
    
    This patch removes the restriction of having a limited amount of only
    four active tds on one endpoint. We use the linked list implementation
    to manage all tds which get added and removed by hardware_{en,de}queue.
    
    The removal of this restriction adds the driver to run into a hardware
    errata. It's possible that the hardware will still address an transfer
    descriptor that already got cleaned up. To solve this the patch also
    postpone the cleanup of processed tds by one.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index b0a6bce064ca..9ef686086c24 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -58,6 +58,7 @@ struct ci13xxx_ep {
 	struct ci13xxx				*ci;
 	spinlock_t				*lock;
 	struct dma_pool				*td_pool;
+	struct td_node				*pending_td;
 };
 
 enum ci_role {

commit b983e51a73b60b358e2c15a64c0c489cb266fe67
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Sat Mar 30 12:54:10 2013 +0200

    usb: chipidea: udc: add the define TD_PAGE_COUNT and fix all users
    
    A static count of transfer descriptors was used everywhere in the driver
    with the fixed number 5. This patch adds a define, named TD_PAGE_COUNT,
    and replaces all users of this value. This way its possible to have only
    one parameter to change and limit the amount of buffer pointers per TD.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Reviewed-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 68577d1f1c0d..b0a6bce064ca 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -21,6 +21,7 @@
 /******************************************************************************
  * DEFINE
  *****************************************************************************/
+#define TD_PAGE_COUNT      5
 #define CI13XXX_PAGE_SIZE  4096ul /* page size for TD's */
 #define ENDPT_MAX          32
 

commit 727b4ddb48dcd8c9ca81b58ca58191233bdf75aa
Author: Felipe Balbi <balbi@ti.com>
Date:   Sat Mar 30 12:53:55 2013 +0200

    usb: chipidea: don't redefine __ffs()
    
    chipidea's ffs_nr() is pretty much what __ffs() does.
    
    Use that one instead.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    [rebased on top of debug infrastructure rework]
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index c7d4622782ce..68577d1f1c0d 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -234,19 +234,6 @@ enum ci13xxx_regs {
 	OP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,
 };
 
-/**
- * ffs_nr: find first (least significant) bit set
- * @x: the word to search
- *
- * This function returns bit number (instead of position)
- */
-static inline int ffs_nr(u32 x)
-{
-	int n = ffs(x);
-
-	return n ? n-1 : 32;
-}
-
 /**
  * hw_read: reads from a hw register
  * @reg:  register index
@@ -305,7 +292,7 @@ static inline u32 hw_test_and_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
 	u32 val = hw_read(ci, reg, ~0);
 
 	hw_write(ci, reg, mask, data);
-	return (val & mask) >> ffs_nr(mask);
+	return (val & mask) >> __ffs(mask);
 }
 
 int hw_device_reset(struct ci13xxx *ci, u32 mode);

commit 2d6512892c106556f07e502939005e73cdc6e2cc
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Sat Mar 30 12:53:51 2013 +0200

    usb: chipidea: convert debug entries in sysfs to debugfs
    
    Currently, we have a bunch of files in sysfs that display all sorts of
    debugging information for the device controller, so they have to move to
    debugfs where they belong. The "registers" interface have been removed,
    since it doesn't fit into the current driver design as is and it's hardly
    a good idea to touch the registers from userspace anyway.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index d738603a2757..c7d4622782ce 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -129,6 +129,7 @@ struct hw_bank {
  * @vbus_active: is VBUS active
  * @transceiver: pointer to USB PHY, if any
  * @hcd: pointer to usb_hcd for ehci host driver
+ * @debugfs: root dentry for this controller in debugfs
  */
 struct ci13xxx {
 	struct device			*dev;
@@ -164,6 +165,7 @@ struct ci13xxx {
 	bool				global_phy;
 	struct usb_phy			*transceiver;
 	struct usb_hcd			*hcd;
+	struct dentry			*debugfs;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci13xxx *ci)

commit 571bb7abac4ed02cf7d5094b4a04a8bdca3783ed
Author: Peter Chen <peter.chen@freescale.com>
Date:   Sat Mar 30 02:46:43 2013 +0200

    Revert "USB: chipidea: add vbus detect for udc"
    
    There are several problems with this patch:
      + in introduces a sparse warning for a condition that's always negative,
      + and because of that, it actually doesn't do anything useful,
      + and vbus detection belongs to otg, not device function anyway.
    
    This reverts commit 8c4fc031954b4eb72daf13d3c907a985a3eee208.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    [Alex: amended the above text]
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index e25d1263da13..d738603a2757 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -139,7 +139,6 @@ struct ci13xxx {
 	enum ci_role			role;
 	bool				is_otg;
 	struct work_struct		work;
-	struct work_struct		vbus_work;
 	struct workqueue_struct		*wq;
 
 	struct dma_pool			*qh_pool;

commit 8c4fc031954b4eb72daf13d3c907a985a3eee208
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Wed Sep 12 14:58:09 2012 +0300

    USB: chipidea: add vbus detect for udc
    
    Using vbus valid interrupt to detect vbus.
    
    Tested-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Tested-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index d738603a2757..e25d1263da13 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -139,6 +139,7 @@ struct ci13xxx {
 	enum ci_role			role;
 	bool				is_otg;
 	struct work_struct		work;
+	struct work_struct		vbus_work;
 	struct workqueue_struct		*wq;
 
 	struct dma_pool			*qh_pool;

commit a2c3d6902f6f9916b5376c44baa8c1d08bf92a27
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:46 2012 +0800

    usb: chipidea: permit driver bindings pass phy pointer
    
    Sometimes, the driver bindings may know what phy they use.
    For example, when using device tree, the usb controller may have a
    phandler pointing to usb phy.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Subodh Nijsure <snijsure@grid-net.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 9655e3569d4c..d738603a2757 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -160,6 +160,8 @@ struct ci13xxx {
 
 	struct ci13xxx_platform_data	*platdata;
 	int				vbus_active;
+	/* FIXME: some day, we'll not use global phy */
+	bool				global_phy;
 	struct usb_phy			*transceiver;
 	struct usb_hcd			*hcd;
 };

commit 26c696c678c4ce180599330999e895cded0f625b
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:40 2012 +0800

    USB: Chipidea: rename struct ci13xxx variables from udc to ci
    
    struct ci13xxx represent the controller, which may be device or host,
    so name its variables as ci.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 0b093308548d..9655e3569d4c 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -36,7 +36,7 @@
  * @name: string description of the endpoint
  * @qh: queue head for this endpoint
  * @wedge: is the endpoint wedged
- * @udc: pointer to the controller
+ * @ci: pointer to the controller
  * @lock: pointer to controller's spinlock
  * @td_pool: pointer to controller's TD pool
  */
@@ -54,7 +54,7 @@ struct ci13xxx_ep {
 	int					wedge;
 
 	/* global resources */
-	struct ci13xxx				*udc;
+	struct ci13xxx				*ci;
 	spinlock_t				*lock;
 	struct dma_pool				*td_pool;
 };
@@ -250,9 +250,9 @@ static inline int ffs_nr(u32 x)
  *
  * This function returns register contents
  */
-static inline u32 hw_read(struct ci13xxx *udc, enum ci13xxx_regs reg, u32 mask)
+static inline u32 hw_read(struct ci13xxx *ci, enum ci13xxx_regs reg, u32 mask)
 {
-	return ioread32(udc->hw_bank.regmap[reg]) & mask;
+	return ioread32(ci->hw_bank.regmap[reg]) & mask;
 }
 
 /**
@@ -261,14 +261,14 @@ static inline u32 hw_read(struct ci13xxx *udc, enum ci13xxx_regs reg, u32 mask)
  * @mask: bitfield mask
  * @data: new value
  */
-static inline void hw_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
+static inline void hw_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
 			    u32 mask, u32 data)
 {
 	if (~mask)
-		data = (ioread32(udc->hw_bank.regmap[reg]) & ~mask)
+		data = (ioread32(ci->hw_bank.regmap[reg]) & ~mask)
 			| (data & mask);
 
-	iowrite32(data, udc->hw_bank.regmap[reg]);
+	iowrite32(data, ci->hw_bank.regmap[reg]);
 }
 
 /**
@@ -278,12 +278,12 @@ static inline void hw_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
  *
  * This function returns register contents
  */
-static inline u32 hw_test_and_clear(struct ci13xxx *udc, enum ci13xxx_regs reg,
+static inline u32 hw_test_and_clear(struct ci13xxx *ci, enum ci13xxx_regs reg,
 				    u32 mask)
 {
-	u32 val = ioread32(udc->hw_bank.regmap[reg]) & mask;
+	u32 val = ioread32(ci->hw_bank.regmap[reg]) & mask;
 
-	iowrite32(val, udc->hw_bank.regmap[reg]);
+	iowrite32(val, ci->hw_bank.regmap[reg]);
 	return val;
 }
 
@@ -295,12 +295,12 @@ static inline u32 hw_test_and_clear(struct ci13xxx *udc, enum ci13xxx_regs reg,
  *
  * This function returns register contents
  */
-static inline u32 hw_test_and_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
+static inline u32 hw_test_and_write(struct ci13xxx *ci, enum ci13xxx_regs reg,
 				    u32 mask, u32 data)
 {
-	u32 val = hw_read(udc, reg, ~0);
+	u32 val = hw_read(ci, reg, ~0);
 
-	hw_write(udc, reg, mask, data);
+	hw_write(ci, reg, mask, data);
 	return (val & mask) >> ffs_nr(mask);
 }
 

commit 77c4400f2f0fd8384ab5cbe41d81ccc664896b2d
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Fri Jun 29 17:48:53 2012 +0800

    USB: Chipidea: rename struct ci13xxx_udc_driver to struct ci13xxx_platform_data
    
    This patch rename struct ci13xxx_udc_driver and var with the type.
    
    ci13xxx_platform_data reflect it's passed from platfrom driver.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 50911f8490d4..0b093308548d 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -125,7 +125,7 @@ struct hw_bank {
  * @remote_wakeup: host-enabled remote wakeup
  * @suspended: suspended by host
  * @test_mode: the selected test mode
- * @udc_driver: platform specific information supplied by parent device
+ * @platdata: platform specific information supplied by parent device
  * @vbus_active: is VBUS active
  * @transceiver: pointer to USB PHY, if any
  * @hcd: pointer to usb_hcd for ehci host driver
@@ -158,7 +158,7 @@ struct ci13xxx {
 	u8				suspended;
 	u8				test_mode;
 
-	struct ci13xxx_udc_driver	*udc_driver;
+	struct ci13xxx_platform_data	*platdata;
 	int				vbus_active;
 	struct usb_phy			*transceiver;
 	struct usb_hcd			*hcd;

commit ab3999a26147e9c0d2949df751b86519065bf8bd
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:57 2012 +0300

    usb: chipidea: drop unused field "device" from ci13xxx_ep
    
    It was used as a shorthand for gadget's device in request mapping/unmapping
    code, but now it's not used any more.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 8a6872aae79f..50911f8490d4 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -38,7 +38,6 @@
  * @wedge: is the endpoint wedged
  * @udc: pointer to the controller
  * @lock: pointer to controller's spinlock
- * @device: pointer to gadget's struct device
  * @td_pool: pointer to controller's TD pool
  */
 struct ci13xxx_ep {
@@ -57,7 +56,6 @@ struct ci13xxx_ep {
 	/* global resources */
 	struct ci13xxx				*udc;
 	spinlock_t				*lock;
-	struct device				*device;
 	struct dma_pool				*td_pool;
 };
 

commit 5e0aa49ec61e888d50727a7e80e87626f745c119
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:56 2012 +0300

    usb: chipidea: use generic map/unmap routines
    
    We're one of the remaining drivers to map/unmap requests by hand. Switch
    to using generic gadget routines for that instead.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index c605acc5568a..8a6872aae79f 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -21,7 +21,6 @@
 /******************************************************************************
  * DEFINE
  *****************************************************************************/
-#define DMA_ADDR_INVALID	(~(dma_addr_t)0)
 #define CI13XXX_PAGE_SIZE  4096ul /* page size for TD's */
 #define ENDPT_MAX          32
 

commit eb70e5ab8f95a81283623c03d2c99dfc59fcb319
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:54 2012 +0300

    usb: chipidea: add host role
    
    This adds EHCI host support to the chipidea driver. We want it to be
    part of the hdrc driver and not a standalone (sub-)driver module, as
    the structure of ehci-hcd.c suggests, so for chipidea controller we
    hack it to not provide platform-related code, but only the ehci hcd.
    
    The ehci-platform driver won't work for us here too, because the
    controller uses the same registers for both device and host mode and
    also otg-related bits, so it's not really possible to put ehci registers
    into a separate resource.
    
    This is not a pretty solution, but the alternative is exporting symbols
    from the chipidea driver to a ehci-chipidea driver and doing all the
    module refcounting.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 0ab83411d800..c605acc5568a 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -15,6 +15,7 @@
 
 #include <linux/list.h>
 #include <linux/irqreturn.h>
+#include <linux/usb.h>
 #include <linux/usb/gadget.h>
 
 /******************************************************************************
@@ -84,6 +85,7 @@ struct ci_role_driver {
 /**
  * struct hw_bank - hardware register mapping representation
  * @lpm: set if the device is LPM capable
+ * @phys: physical address of the controller's registers
  * @abs: absolute address of the beginning of register window
  * @cap: capability registers
  * @op: operational registers
@@ -92,6 +94,7 @@ struct ci_role_driver {
  */
 struct hw_bank {
 	unsigned	lpm;
+	resource_size_t	phys;
 	void __iomem	*abs;
 	void __iomem	*cap;
 	void __iomem	*op;
@@ -128,6 +131,7 @@ struct hw_bank {
  * @udc_driver: platform specific information supplied by parent device
  * @vbus_active: is VBUS active
  * @transceiver: pointer to USB PHY, if any
+ * @hcd: pointer to usb_hcd for ehci host driver
  */
 struct ci13xxx {
 	struct device			*dev;
@@ -160,6 +164,7 @@ struct ci13xxx {
 	struct ci13xxx_udc_driver	*udc_driver;
 	int				vbus_active;
 	struct usb_phy			*transceiver;
+	struct usb_hcd			*hcd;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci13xxx *ci)
@@ -302,7 +307,7 @@ static inline u32 hw_test_and_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
 	return (val & mask) >> ffs_nr(mask);
 }
 
-int hw_device_reset(struct ci13xxx *ci);
+int hw_device_reset(struct ci13xxx *ci, u32 mode);
 
 int hw_port_test_set(struct ci13xxx *ci, u8 mode);
 

commit 551a8ac64e4ea9e9e2b8656ee3bf94c8d0821d41
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:49 2012 +0300

    usb: chipidea: brush up structure definitions
    
    Get rid of trailing comments in the structure definitions in favor of
    kernel-doc.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 0f226b0d4761..0ab83411d800 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -27,25 +27,38 @@
 /******************************************************************************
  * STRUCTURES
  *****************************************************************************/
-/* Extension of usb_ep */
+/**
+ * struct ci13xxx_ep - endpoint representation
+ * @ep: endpoint structure for gadget drivers
+ * @dir: endpoint direction (TX/RX)
+ * @num: endpoint number
+ * @type: endpoint type
+ * @name: string description of the endpoint
+ * @qh: queue head for this endpoint
+ * @wedge: is the endpoint wedged
+ * @udc: pointer to the controller
+ * @lock: pointer to controller's spinlock
+ * @device: pointer to gadget's struct device
+ * @td_pool: pointer to controller's TD pool
+ */
 struct ci13xxx_ep {
-	struct usb_ep                          ep;
-	u8                                     dir;
-	u8                                     num;
-	u8                                     type;
-	char                                   name[16];
+	struct usb_ep				ep;
+	u8					dir;
+	u8					num;
+	u8					type;
+	char					name[16];
 	struct {
-		struct list_head   queue;
-		struct ci13xxx_qh *ptr;
-		dma_addr_t         dma;
-	}                                      qh;
-	int                                    wedge;
+		struct list_head	queue;
+		struct ci13xxx_qh	*ptr;
+		dma_addr_t		dma;
+	}					qh;
+	int					wedge;
 
 	/* global resources */
-	struct ci13xxx                        *udc;
-	spinlock_t                            *lock;
-	struct device                         *device;
-	struct dma_pool                       *td_pool;
+	struct ci13xxx				*udc;
+	spinlock_t				*lock;
+	struct device				*device;
+	struct dma_pool				*td_pool;
 };
 
 enum ci_role {
@@ -68,48 +81,85 @@ struct ci_role_driver {
 	const char	*name;
 };
 
+/**
+ * struct hw_bank - hardware register mapping representation
+ * @lpm: set if the device is LPM capable
+ * @abs: absolute address of the beginning of register window
+ * @cap: capability registers
+ * @op: operational registers
+ * @size: size of the register window
+ * @regmap: register lookup table
+ */
 struct hw_bank {
-	unsigned      lpm;    /* is LPM? */
-	void __iomem *abs;    /* bus map offset */
-	void __iomem *cap;    /* bus map offset + CAP offset */
-	void __iomem *op;     /* bus map offset + OP offset */
-	size_t        size;   /* bank size */
-	void __iomem **regmap;
+	unsigned	lpm;
+	void __iomem	*abs;
+	void __iomem	*cap;
+	void __iomem	*op;
+	size_t		size;
+	void __iomem	**regmap;
 };
 
-/* CI13XXX UDC descriptor & global resources */
+/**
+ * struct ci13xxx - chipidea device representation
+ * @dev: pointer to parent device
+ * @lock: access synchronization
+ * @hw_bank: hardware register mapping
+ * @irq: IRQ number
+ * @roles: array of supported roles for this controller
+ * @role: current role
+ * @is_otg: if the device is otg-capable
+ * @work: work for role changing
+ * @wq: workqueue thread
+ * @qh_pool: allocation pool for queue heads
+ * @td_pool: allocation pool for transfer descriptors
+ * @gadget: device side representation for peripheral controller
+ * @driver: gadget driver
+ * @hw_ep_max: total number of endpoints supported by hardware
+ * @ci13xxx_ep: array of endpoints
+ * @ep0_dir: ep0 direction
+ * @ep0out: pointer to ep0 OUT endpoint
+ * @ep0in: pointer to ep0 IN endpoint
+ * @status: ep0 status request
+ * @setaddr: if we should set the address on status completion
+ * @address: usb address received from the host
+ * @remote_wakeup: host-enabled remote wakeup
+ * @suspended: suspended by host
+ * @test_mode: the selected test mode
+ * @udc_driver: platform specific information supplied by parent device
+ * @vbus_active: is VBUS active
+ * @transceiver: pointer to USB PHY, if any
+ */
 struct ci13xxx {
-	spinlock_t		   lock;      /* ctrl register bank access */
-
-	struct dma_pool           *qh_pool;   /* DMA pool for queue heads */
-	struct dma_pool           *td_pool;   /* DMA pool for transfer descs */
-	struct usb_request        *status;    /* ep0 status request */
-
-	struct device             *dev;
-	struct usb_gadget          gadget;     /* USB slave device */
-	struct ci13xxx_ep          ci13xxx_ep[ENDPT_MAX]; /* extended endpts */
-	u32                        ep0_dir;    /* ep0 direction */
-	struct ci13xxx_ep          *ep0out, *ep0in;
-	unsigned		   hw_ep_max;  /* number of hw endpoints */
-
-	bool			   setaddr;
-	u8			   address;
-	u8                         remote_wakeup; /* Is remote wakeup feature
-							enabled by the host? */
-	u8                         suspended;  /* suspended by the host */
-	u8                         test_mode;  /* the selected test mode */
-
-	struct hw_bank             hw_bank;
-	int			   irq;
-	struct usb_gadget_driver  *driver;     /* 3rd party gadget driver */
-	struct ci13xxx_udc_driver *udc_driver; /* device controller driver */
-	int                        vbus_active; /* is VBUS active */
-	struct usb_phy            *transceiver; /* Transceiver struct */
-	struct ci_role_driver     *roles[CI_ROLE_END];
-	enum ci_role               role;
-	bool			   is_otg;
-	struct work_struct	   work;
-	struct workqueue_struct	  *wq;
+	struct device			*dev;
+	spinlock_t			lock;
+	struct hw_bank			hw_bank;
+	int				irq;
+	struct ci_role_driver		*roles[CI_ROLE_END];
+	enum ci_role			role;
+	bool				is_otg;
+	struct work_struct		work;
+	struct workqueue_struct		*wq;
+
+	struct dma_pool			*qh_pool;
+	struct dma_pool			*td_pool;
+
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	unsigned			hw_ep_max;
+	struct ci13xxx_ep		ci13xxx_ep[ENDPT_MAX];
+	u32				ep0_dir;
+	struct ci13xxx_ep		*ep0out, *ep0in;
+
+	struct usb_request		*status;
+	bool				setaddr;
+	u8				address;
+	u8				remote_wakeup;
+	u8				suspended;
+	u8				test_mode;
+
+	struct ci13xxx_udc_driver	*udc_driver;
+	int				vbus_active;
+	struct usb_phy			*transceiver;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci13xxx *ci)

commit f8c1376c2202c9158ab908d730524a590bafdcb8
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:48 2012 +0300

    usb: chipidea: remove unused field "regs" from ci13xxx
    
    The old implementation used global hw_bank, the new implementation uses
    udc-local hw_bank. This field seems to be a leftover from previous coding
    experiments.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 56cb73b1e903..0f226b0d4761 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -80,7 +80,6 @@ struct hw_bank {
 /* CI13XXX UDC descriptor & global resources */
 struct ci13xxx {
 	spinlock_t		   lock;      /* ctrl register bank access */
-	void __iomem              *regs;      /* registers address space */
 
 	struct dma_pool           *qh_pool;   /* DMA pool for queue heads */
 	struct dma_pool           *td_pool;   /* DMA pool for transfer descs */

commit 5f36e231e9dbffb5264612e5b5817ab574a5e5db
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:47 2012 +0300

    usb: chipidea: add support for roles
    
    Add some generic code for roles and implement simple role switching
    based on ID pin state and/or a sysfs file. At this, we also rename
    the device to ci_hdrc, which is what it is.
    
    The "manual" switch is made into a sysfs file and not debugfs, because
    it might be useful even in non-debug context. For some boards, like
    sheevaplug, it seems to be the only way to switch roles without modifying
    the hardware, since the ID pin is always grounded.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index f5b3b8538a3b..56cb73b1e903 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -14,6 +14,7 @@
 #define __DRIVERS_USB_CHIPIDEA_CI_H
 
 #include <linux/list.h>
+#include <linux/irqreturn.h>
 #include <linux/usb/gadget.h>
 
 /******************************************************************************
@@ -47,6 +48,26 @@ struct ci13xxx_ep {
 	struct dma_pool                       *td_pool;
 };
 
+enum ci_role {
+	CI_ROLE_HOST = 0,
+	CI_ROLE_GADGET,
+	CI_ROLE_END,
+};
+
+/**
+ * struct ci_role_driver - host/gadget role driver
+ * start: start this role
+ * stop: stop this role
+ * irq: irq handler for this role
+ * name: role name string (host/gadget)
+ */
+struct ci_role_driver {
+	int		(*start)(struct ci13xxx *);
+	void		(*stop)(struct ci13xxx *);
+	irqreturn_t	(*irq)(struct ci13xxx *);
+	const char	*name;
+};
+
 struct hw_bank {
 	unsigned      lpm;    /* is LPM? */
 	void __iomem *abs;    /* bus map offset */
@@ -85,8 +106,47 @@ struct ci13xxx {
 	struct ci13xxx_udc_driver *udc_driver; /* device controller driver */
 	int                        vbus_active; /* is VBUS active */
 	struct usb_phy            *transceiver; /* Transceiver struct */
+	struct ci_role_driver     *roles[CI_ROLE_END];
+	enum ci_role               role;
+	bool			   is_otg;
+	struct work_struct	   work;
+	struct workqueue_struct	  *wq;
 };
 
+static inline struct ci_role_driver *ci_role(struct ci13xxx *ci)
+{
+	BUG_ON(ci->role >= CI_ROLE_END || !ci->roles[ci->role]);
+	return ci->roles[ci->role];
+}
+
+static inline int ci_role_start(struct ci13xxx *ci, enum ci_role role)
+{
+	int ret;
+
+	if (role >= CI_ROLE_END)
+		return -EINVAL;
+
+	if (!ci->roles[role])
+		return -ENXIO;
+
+	ret = ci->roles[role]->start(ci);
+	if (!ret)
+		ci->role = role;
+	return ret;
+}
+
+static inline void ci_role_stop(struct ci13xxx *ci)
+{
+	enum ci_role role = ci->role;
+
+	if (role == CI_ROLE_END)
+		return;
+
+	ci->role = CI_ROLE_END;
+
+	ci->roles[role]->stop(ci);
+}
+
 /******************************************************************************
  * REGISTERS
  *****************************************************************************/
@@ -107,6 +167,7 @@ enum ci13xxx_regs {
 	OP_ENDPTLISTADDR,
 	OP_PORTSC,
 	OP_DEVLC,
+	OP_OTGSC,
 	OP_USBMODE,
 	OP_ENDPTSETUPSTAT,
 	OP_ENDPTPRIME,
@@ -118,7 +179,6 @@ enum ci13xxx_regs {
 	OP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,
 };
 
-
 /**
  * ffs_nr: find first (least significant) bit set
  * @x: the word to search
@@ -193,8 +253,6 @@ static inline u32 hw_test_and_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
 	return (val & mask) >> ffs_nr(mask);
 }
 
-int hw_device_init(struct ci13xxx *udc, void __iomem *base,
-		   uintptr_t cap_offset);
 int hw_device_reset(struct ci13xxx *ci);
 
 int hw_port_test_set(struct ci13xxx *ci, u8 mode);

commit e443b333629f82ca0da91a05ca638050943bbedd
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:46 2012 +0300

    usb: chipidea: split the driver code into units
    
    Split the driver into the following parts:
      * core  -- resources, register access, capabilities, etc;
      * udc   -- device controller functionality;
      * debug -- logging events.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
new file mode 100644
index 000000000000..f5b3b8538a3b
--- /dev/null
+++ b/drivers/usb/chipidea/ci.h
@@ -0,0 +1,204 @@
+/*
+ * ci.h - common structures, functions, and macros of the ChipIdea driver
+ *
+ * Copyright (C) 2008 Chipidea - MIPS Technologies, Inc. All rights reserved.
+ *
+ * Author: David Lopo
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __DRIVERS_USB_CHIPIDEA_CI_H
+#define __DRIVERS_USB_CHIPIDEA_CI_H
+
+#include <linux/list.h>
+#include <linux/usb/gadget.h>
+
+/******************************************************************************
+ * DEFINE
+ *****************************************************************************/
+#define DMA_ADDR_INVALID	(~(dma_addr_t)0)
+#define CI13XXX_PAGE_SIZE  4096ul /* page size for TD's */
+#define ENDPT_MAX          32
+
+/******************************************************************************
+ * STRUCTURES
+ *****************************************************************************/
+/* Extension of usb_ep */
+struct ci13xxx_ep {
+	struct usb_ep                          ep;
+	u8                                     dir;
+	u8                                     num;
+	u8                                     type;
+	char                                   name[16];
+	struct {
+		struct list_head   queue;
+		struct ci13xxx_qh *ptr;
+		dma_addr_t         dma;
+	}                                      qh;
+	int                                    wedge;
+
+	/* global resources */
+	struct ci13xxx                        *udc;
+	spinlock_t                            *lock;
+	struct device                         *device;
+	struct dma_pool                       *td_pool;
+};
+
+struct hw_bank {
+	unsigned      lpm;    /* is LPM? */
+	void __iomem *abs;    /* bus map offset */
+	void __iomem *cap;    /* bus map offset + CAP offset */
+	void __iomem *op;     /* bus map offset + OP offset */
+	size_t        size;   /* bank size */
+	void __iomem **regmap;
+};
+
+/* CI13XXX UDC descriptor & global resources */
+struct ci13xxx {
+	spinlock_t		   lock;      /* ctrl register bank access */
+	void __iomem              *regs;      /* registers address space */
+
+	struct dma_pool           *qh_pool;   /* DMA pool for queue heads */
+	struct dma_pool           *td_pool;   /* DMA pool for transfer descs */
+	struct usb_request        *status;    /* ep0 status request */
+
+	struct device             *dev;
+	struct usb_gadget          gadget;     /* USB slave device */
+	struct ci13xxx_ep          ci13xxx_ep[ENDPT_MAX]; /* extended endpts */
+	u32                        ep0_dir;    /* ep0 direction */
+	struct ci13xxx_ep          *ep0out, *ep0in;
+	unsigned		   hw_ep_max;  /* number of hw endpoints */
+
+	bool			   setaddr;
+	u8			   address;
+	u8                         remote_wakeup; /* Is remote wakeup feature
+							enabled by the host? */
+	u8                         suspended;  /* suspended by the host */
+	u8                         test_mode;  /* the selected test mode */
+
+	struct hw_bank             hw_bank;
+	int			   irq;
+	struct usb_gadget_driver  *driver;     /* 3rd party gadget driver */
+	struct ci13xxx_udc_driver *udc_driver; /* device controller driver */
+	int                        vbus_active; /* is VBUS active */
+	struct usb_phy            *transceiver; /* Transceiver struct */
+};
+
+/******************************************************************************
+ * REGISTERS
+ *****************************************************************************/
+/* register size */
+#define REG_BITS   (32)
+
+/* register indices */
+enum ci13xxx_regs {
+	CAP_CAPLENGTH,
+	CAP_HCCPARAMS,
+	CAP_DCCPARAMS,
+	CAP_TESTMODE,
+	CAP_LAST = CAP_TESTMODE,
+	OP_USBCMD,
+	OP_USBSTS,
+	OP_USBINTR,
+	OP_DEVICEADDR,
+	OP_ENDPTLISTADDR,
+	OP_PORTSC,
+	OP_DEVLC,
+	OP_USBMODE,
+	OP_ENDPTSETUPSTAT,
+	OP_ENDPTPRIME,
+	OP_ENDPTFLUSH,
+	OP_ENDPTSTAT,
+	OP_ENDPTCOMPLETE,
+	OP_ENDPTCTRL,
+	/* endptctrl1..15 follow */
+	OP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,
+};
+
+
+/**
+ * ffs_nr: find first (least significant) bit set
+ * @x: the word to search
+ *
+ * This function returns bit number (instead of position)
+ */
+static inline int ffs_nr(u32 x)
+{
+	int n = ffs(x);
+
+	return n ? n-1 : 32;
+}
+
+/**
+ * hw_read: reads from a hw register
+ * @reg:  register index
+ * @mask: bitfield mask
+ *
+ * This function returns register contents
+ */
+static inline u32 hw_read(struct ci13xxx *udc, enum ci13xxx_regs reg, u32 mask)
+{
+	return ioread32(udc->hw_bank.regmap[reg]) & mask;
+}
+
+/**
+ * hw_write: writes to a hw register
+ * @reg:  register index
+ * @mask: bitfield mask
+ * @data: new value
+ */
+static inline void hw_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
+			    u32 mask, u32 data)
+{
+	if (~mask)
+		data = (ioread32(udc->hw_bank.regmap[reg]) & ~mask)
+			| (data & mask);
+
+	iowrite32(data, udc->hw_bank.regmap[reg]);
+}
+
+/**
+ * hw_test_and_clear: tests & clears a hw register
+ * @reg:  register index
+ * @mask: bitfield mask
+ *
+ * This function returns register contents
+ */
+static inline u32 hw_test_and_clear(struct ci13xxx *udc, enum ci13xxx_regs reg,
+				    u32 mask)
+{
+	u32 val = ioread32(udc->hw_bank.regmap[reg]) & mask;
+
+	iowrite32(val, udc->hw_bank.regmap[reg]);
+	return val;
+}
+
+/**
+ * hw_test_and_write: tests & writes a hw register
+ * @reg:  register index
+ * @mask: bitfield mask
+ * @data: new value
+ *
+ * This function returns register contents
+ */
+static inline u32 hw_test_and_write(struct ci13xxx *udc, enum ci13xxx_regs reg,
+				    u32 mask, u32 data)
+{
+	u32 val = hw_read(udc, reg, ~0);
+
+	hw_write(udc, reg, mask, data);
+	return (val & mask) >> ffs_nr(mask);
+}
+
+int hw_device_init(struct ci13xxx *udc, void __iomem *base,
+		   uintptr_t cap_offset);
+int hw_device_reset(struct ci13xxx *ci);
+
+int hw_port_test_set(struct ci13xxx *ci, u8 mode);
+
+u8 hw_port_test_get(struct ci13xxx *ci);
+
+#endif	/* __DRIVERS_USB_CHIPIDEA_CI_H */
