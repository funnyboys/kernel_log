commit c1ffba305dbcf3fb9ca969c20a97acbddc38f8e9
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Dec 26 07:57:54 2019 -0800

    usb: chipidea: host: Disable port power only if previously enabled
    
    On shutdown, ehci_power_off() is called unconditionally to power off
    each port, even if it was never called to power on the port.
    For chipidea, this results in a call to ehci_ci_portpower() with a request
    to power off ports even if the port was never powered on.
    This results in the following warning from the regulator code.
    
    WARNING: CPU: 0 PID: 182 at drivers/regulator/core.c:2596 _regulator_disable+0x1a8/0x210
    unbalanced disables for usb_otg2_vbus
    Modules linked in:
    CPU: 0 PID: 182 Comm: init Not tainted 5.4.6 #1
    Hardware name: Freescale i.MX7 Dual (Device Tree)
    [<c0313658>] (unwind_backtrace) from [<c030d698>] (show_stack+0x10/0x14)
    [<c030d698>] (show_stack) from [<c1133afc>] (dump_stack+0xe0/0x10c)
    [<c1133afc>] (dump_stack) from [<c0349098>] (__warn+0xf4/0x10c)
    [<c0349098>] (__warn) from [<c0349128>] (warn_slowpath_fmt+0x78/0xbc)
    [<c0349128>] (warn_slowpath_fmt) from [<c09f36ac>] (_regulator_disable+0x1a8/0x210)
    [<c09f36ac>] (_regulator_disable) from [<c09f374c>] (regulator_disable+0x38/0xe8)
    [<c09f374c>] (regulator_disable) from [<c0df7bac>] (ehci_ci_portpower+0x38/0xdc)
    [<c0df7bac>] (ehci_ci_portpower) from [<c0db4fa4>] (ehci_port_power+0x50/0xa4)
    [<c0db4fa4>] (ehci_port_power) from [<c0db5420>] (ehci_silence_controller+0x5c/0xc4)
    [<c0db5420>] (ehci_silence_controller) from [<c0db7644>] (ehci_stop+0x3c/0xcc)
    [<c0db7644>] (ehci_stop) from [<c0d5bdc4>] (usb_remove_hcd+0xe0/0x19c)
    [<c0d5bdc4>] (usb_remove_hcd) from [<c0df7638>] (host_stop+0x38/0xa8)
    [<c0df7638>] (host_stop) from [<c0df2f34>] (ci_hdrc_remove+0x44/0xe4)
    ...
    
    Keeping track of the power enable state avoids the warning and traceback.
    
    Fixes: c8679a2fb8dec ("usb: chipidea: host: add portpower override")
    Cc: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Cc: Peter Chen <peter.chen@freescale.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Link: https://lore.kernel.org/r/20191226155754.25451-1-linux@roeck-us.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index b45ceb91c735..48e4a5ca1835 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -26,6 +26,7 @@ static int (*orig_bus_suspend)(struct usb_hcd *hcd);
 
 struct ehci_ci_priv {
 	struct regulator *reg_vbus;
+	bool enabled;
 };
 
 static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
@@ -37,7 +38,7 @@ static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 	int ret = 0;
 	int port = HCS_N_PORTS(ehci->hcs_params);
 
-	if (priv->reg_vbus) {
+	if (priv->reg_vbus && enable != priv->enabled) {
 		if (port > 1) {
 			dev_warn(dev,
 				"Not support multi-port regulator control\n");
@@ -53,6 +54,7 @@ static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 				enable ? "enable" : "disable", ret);
 			return ret;
 		}
+		priv->enabled = enable;
 	}
 
 	if (enable && (ci->platdata->phy_mode == USBPHY_INTERFACE_MODE_HSIC)) {

commit 2c4593ecc920b6f3c148f2d123a5c6aa2f1f3e73
Author: Peter Chen <peter.chen@nxp.com>
Date:   Tue Oct 16 10:11:42 2018 +0800

    usb: chipidea: host: override ehci->hub_control
    
    The chipidea controller has some special requirements during
    suspend/resume, override common ehci->hub_control to implement
    it.
    
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 028a3574266a..b45ceb91c735 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -220,6 +220,80 @@ void ci_hdrc_host_destroy(struct ci_hdrc *ci)
 		host_stop(ci);
 }
 
+/* The below code is based on tegra ehci driver */
+static int ci_ehci_hub_control(
+	struct usb_hcd	*hcd,
+	u16		typeReq,
+	u16		wValue,
+	u16		wIndex,
+	char		*buf,
+	u16		wLength
+)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+	u32 __iomem	*status_reg;
+	u32		temp;
+	unsigned long	flags;
+	int		retval = 0;
+	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
+
+	status_reg = &ehci->regs->port_status[(wIndex & 0xff) - 1];
+
+	spin_lock_irqsave(&ehci->lock, flags);
+
+	if (typeReq == SetPortFeature && wValue == USB_PORT_FEAT_SUSPEND) {
+		temp = ehci_readl(ehci, status_reg);
+		if ((temp & PORT_PE) == 0 || (temp & PORT_RESET) != 0) {
+			retval = -EPIPE;
+			goto done;
+		}
+
+		temp &= ~(PORT_RWC_BITS | PORT_WKCONN_E);
+		temp |= PORT_WKDISC_E | PORT_WKOC_E;
+		ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+
+		/*
+		 * If a transaction is in progress, there may be a delay in
+		 * suspending the port. Poll until the port is suspended.
+		 */
+		if (ehci_handshake(ehci, status_reg, PORT_SUSPEND,
+			PORT_SUSPEND, 5000))
+			ehci_err(ehci, "timeout waiting for SUSPEND\n");
+
+		if (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC) {
+			if (ci->platdata->notify_event)
+				ci->platdata->notify_event(ci,
+					CI_HDRC_IMX_HSIC_SUSPEND_EVENT);
+
+			temp = ehci_readl(ehci, status_reg);
+			temp &= ~(PORT_WKDISC_E | PORT_WKCONN_E);
+			ehci_writel(ehci, temp, status_reg);
+		}
+
+		set_bit((wIndex & 0xff) - 1, &ehci->suspended_ports);
+		goto done;
+	}
+
+	/*
+	 * After resume has finished, it needs do some post resume
+	 * operation for some SoCs.
+	 */
+	else if (typeReq == ClearPortFeature &&
+		wValue == USB_PORT_FEAT_C_SUSPEND) {
+		/* Make sure the resume has finished, it should be finished */
+		if (ehci_handshake(ehci, status_reg, PORT_RESUME, 0, 25000))
+			ehci_err(ehci, "timeout waiting for resume\n");
+	}
+
+	spin_unlock_irqrestore(&ehci->lock, flags);
+
+	/* Handle the hub control events here */
+	return ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);
+done:
+	spin_unlock_irqrestore(&ehci->lock, flags);
+	return retval;
+}
 static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
@@ -298,4 +372,5 @@ void ci_hdrc_host_driver_init(void)
 	ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
 	orig_bus_suspend = ci_ehci_hc_driver.bus_suspend;
 	ci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;
+	ci_ehci_hc_driver.hub_control = ci_ehci_hub_control;
 }

commit 014abe34a9095daaa6cbb2693ee90bbb54674693
Author: Peter Chen <peter.chen@nxp.com>
Date:   Mon Oct 15 17:02:57 2018 +0800

    usb: chipidea: add flag for imx hsic implementation
    
    NXP (Freecale) imx HSIC design has some special requirements, add
    some flags at host code to handle them.
    
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index d858a82c4f44..028a3574266a 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -170,6 +170,11 @@ static int host_start(struct ci_hdrc *ci)
 			otg->host = &hcd->self;
 			hcd->self.otg_port = 1;
 		}
+
+		if (ci->platdata->notify_event &&
+			(ci->platdata->flags & CI_HDRC_IMX_IS_HSIC))
+			ci->platdata->notify_event
+				(ci, CI_HDRC_IMX_HSIC_ACTIVE_EVENT);
 	}
 
 	return ret;
@@ -218,6 +223,8 @@ void ci_hdrc_host_destroy(struct ci_hdrc *ci)
 static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
 	int port;
 	u32 tmp;
 
@@ -249,6 +256,16 @@ static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 			 * It needs a short delay between set RS bit and PHCD.
 			 */
 			usleep_range(150, 200);
+			/*
+			 * Need to clear WKCN and WKOC for imx HSIC,
+			 * otherwise, there will be wakeup event.
+			 */
+			if (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC) {
+				tmp = ehci_readl(ehci, reg);
+				tmp &= ~(PORT_WKDISC_E | PORT_WKCONN_E);
+				ehci_writel(ehci, tmp, reg);
+			}
+
 			break;
 		}
 	}

commit 16caf1fa37db4722d8d8c7bc26177279949d75a6
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Tue Sep 4 17:18:55 2018 +0200

    usb: chipidea: Add dynamic pinctrl selection
    
    Some hardware implementations require to configure pins differently
    according to the USB role (host/device), this can be an update of the
    pins routing or a simple GPIO value change.
    
    This patch introduces new optional "host" and "device" pinctrls.
    If these pinctrls are defined by the device, they are respectively
    selected on host/device role start.
    
    If a default pinctrl exist, it is restored on host/device role stop.
    
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 4638d9b066be..d858a82c4f44 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -13,6 +13,7 @@
 #include <linux/usb/hcd.h>
 #include <linux/usb/chipidea.h>
 #include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
 
 #include "../host/ehci.h"
 
@@ -153,6 +154,10 @@ static int host_start(struct ci_hdrc *ci)
 		}
 	}
 
+	if (ci->platdata->pins_host)
+		pinctrl_select_state(ci->platdata->pctl,
+				     ci->platdata->pins_host);
+
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret) {
 		goto disable_reg;
@@ -197,6 +202,10 @@ static void host_stop(struct ci_hdrc *ci)
 	}
 	ci->hcd = NULL;
 	ci->otg.host = NULL;
+
+	if (ci->platdata->pins_host && ci->platdata->pins_default)
+		pinctrl_select_state(ci->platdata->pctl,
+				     ci->platdata->pins_default);
 }
 
 

commit 90f26cc6bb90b35040f4da0347f480ea9df6e2fc
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Jun 6 09:43:27 2018 +0800

    usb: chipidea: host: fix disconnection detect issue
    
    The commit 4e88d4c08301 ("usb: add a flag to skip PHY
    initialization to struct usb_hcd") delete the assignment
    for hcd->usb_phy, it causes usb_phy_notify_connect{disconnect)
    are not called, the USB PHY driver is not notified of hot plug
    event, then the disconnection will not be detected by hardware.
    
    Fixes: 4e88d4c08301 ("usb: add a flag to skip PHY initialization
            to struct usb_hcd")
    Acked-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Reported-by: Mats Karrman <mats.dev.list@gmail.com>
    Tested-by: Mats Karrman <mats.dev.list@gmail.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index af45aa3222b5..4638d9b066be 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -124,8 +124,11 @@ static int host_start(struct ci_hdrc *ci)
 
 	hcd->power_budget = ci->platdata->power_budget;
 	hcd->tpl_support = ci->platdata->tpl_support;
-	if (ci->phy || ci->usb_phy)
+	if (ci->phy || ci->usb_phy) {
 		hcd->skip_phy_initialization = 1;
+		if (ci->usb_phy)
+			hcd->usb_phy = ci->usb_phy;
+	}
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit 4e88d4c083016454f179686529ae65d70b933b58
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat Mar 3 22:43:03 2018 +0100

    usb: add a flag to skip PHY initialization to struct usb_hcd
    
    The USB HCD core driver parses the device-tree node for "phys" and
    "usb-phys" properties. It also manages the power state of these PHYs
    automatically.
    However, drivers may opt-out of this behavior by setting "phy" or
    "usb_phy" in struct usb_hcd to a non-null value. An example where this
    is required is the "Qualcomm USB2 controller", implemented by the
    chipidea driver. The hardware requires that the PHY is only powered on
    after the "reset completed" event from the controller is received.
    
    A follow-up patch will allow the USB HCD core driver to manage more than
    one PHY. Add a new "skip_phy_initialization" bitflag to struct usb_hcd
    so drivers can opt-out of any PHY management provided by the USB HCD
    core driver.
    
    This also updates the existing drivers so they use the new flag if they
    want to opt out of the PHY management provided by the USB HCD core
    driver. This means that for these drivers the new "multiple PHY"
    handling (which will be added in a follow-up patch) will be disabled as
    well.
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.con>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 19d60ed7e41f..af45aa3222b5 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -124,10 +124,8 @@ static int host_start(struct ci_hdrc *ci)
 
 	hcd->power_budget = ci->platdata->power_budget;
 	hcd->tpl_support = ci->platdata->tpl_support;
-	if (ci->phy)
-		hcd->phy = ci->phy;
-	else
-		hcd->usb_phy = ci->usb_phy;
+	if (ci->phy || ci->usb_phy)
+		hcd->skip_phy_initialization = 1;
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit 51b751f112dcbb24b46051fe64c2ddbe8aa367ea
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:18 2017 +0100

    USB: chipidea: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index a49e8567ac7d..19d60ed7e41f 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -5,19 +5,6 @@
  * Copyright (c) 2012 Intel Corporation
  *
  * Author: Alexander Shishkin
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 18cb8e46262d..a49e8567ac7d 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * host.c - ChipIdea USB host controller driver
  *

commit aeb78cda51005fa00943e331c1fb47c6ad74015d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 13 10:18:42 2017 +0800

    usb: chipidea: use bus->sysdev for DMA configuration
    
    Set the dma for chipidea from sysdev. This is inherited from its
    parent node. Also, do not set dma mask for child as it is not required
    now.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sriram Dash <sriram.dash@nxp.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 915f3e91586e..18cb8e46262d 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -123,7 +123,8 @@ static int host_start(struct ci_hdrc *ci)
 	if (usb_disabled())
 		return -ENODEV;
 
-	hcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));
+	hcd = __usb_create_hcd(&ci_ehci_hc_driver, ci->dev->parent,
+			       ci->dev, dev_name(ci->dev), NULL);
 	if (!hcd)
 		return -ENOMEM;
 

commit 11893dae63da0f5b251cf7f9a24d64c8ff4771ff
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:57:06 2016 -0800

    usb: chipidea: msm: Handle phy power states
    
    The ULPI phy on qcom platforms needs to be initialized and
    powered on after a USB reset and before we toggle the run/stop
    bit. Otherwise, the phy locks up and doesn't work properly. Hook
    the phy initialization into the RESET event and the phy power off
    into the STOPPED event.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index f884c0877bca..915f3e91586e 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -90,8 +90,12 @@ static int ehci_ci_reset(struct usb_hcd *hcd)
 
 	ehci->need_io_watchdog = 0;
 
-	if (ci->platdata->notify_event)
-		ci->platdata->notify_event(ci, CI_HDRC_CONTROLLER_RESET_EVENT);
+	if (ci->platdata->notify_event) {
+		ret = ci->platdata->notify_event(ci,
+				CI_HDRC_CONTROLLER_RESET_EVENT);
+		if (ret)
+			return ret;
+	}
 
 	ci_platform_configure(ci);
 

commit b90a17c5ba81bc34cf2becab49a1a2eeff45c70b
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:56:53 2016 -0800

    usb: chipidea: Notify events when switching host mode
    
    The chipidea/udc.c file sends a CI_HDRC_CONTROLLER_RESET_EVENT to
    the wrapper drivers when it calls hw_device_reset(), but that
    function is not called from chipidea/host.c. And the udc.c file
    sends the CI_HDRC_CONTROLLER_STOPPED_EVENT but the host.c file
    doesn't do anything.
    
    The intent of the reset event is to allow the wrapper driver to
    do any wrapper specific things after the reset bit has been set
    in the usb command register. Therefore, add this event hook in
    the host role after we toggle that bit.
    
    Similarly, the intent of the stopped event is to allow the
    wrapper driver to do any wrapper specific things after the device
    is stopped. So when we stop the host role, send the stopped
    event.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 111b0e0b8698..f884c0877bca 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -90,6 +90,9 @@ static int ehci_ci_reset(struct usb_hcd *hcd)
 
 	ehci->need_io_watchdog = 0;
 
+	if (ci->platdata->notify_event)
+		ci->platdata->notify_event(ci, CI_HDRC_CONTROLLER_RESET_EVENT);
+
 	ci_platform_configure(ci);
 
 	return ret;
@@ -187,6 +190,9 @@ static void host_stop(struct ci_hdrc *ci)
 	struct usb_hcd *hcd = ci->hcd;
 
 	if (hcd) {
+		if (ci->platdata->notify_event)
+			ci->platdata->notify_event(ci,
+				CI_HDRC_CONTROLLER_STOPPED_EVENT);
 		usb_remove_hcd(hcd);
 		ci->role = CI_ROLE_END;
 		synchronize_irq(ci->irq);

commit 991d5add50a5bb6ab8f12f2129f5c7487f6baaf6
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Sat Sep 10 12:53:21 2016 +0000

    usb: chipidea: host: fix NULL ptr dereference during shutdown
    
    After commit b09b5224fe86 ("usb: chipidea: implement platform shutdown
    callback") and commit 43a404577a93 ("usb: chipidea: host: set host to
    be null after hcd is freed") a NULL pointer dereference is caused
    on i.MX23 during shutdown. So ensure that role is set to CI_ROLE_END and
    we finish interrupt handling before the hcd is deallocated. This avoids
    the NULL pointer dereference.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Fixes: b09b5224fe86 ("usb: chipidea: implement platform shutdown callback")
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 96ae69502c86..111b0e0b8698 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -188,6 +188,8 @@ static void host_stop(struct ci_hdrc *ci)
 
 	if (hcd) {
 		usb_remove_hcd(hcd);
+		ci->role = CI_ROLE_END;
+		synchronize_irq(ci->irq);
 		usb_put_hcd(hcd);
 		if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&
 			(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))

commit c744a0db756b34c7e2b60100bcfc58beb6b68c99
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Mon Aug 15 16:09:07 2016 +0200

    usb: chipidea: host: disable io watchdog
    
    The Chipidea EHCI core seems to behave sanely and doesn't need
    the IO watchdog. This kills off 10 non-deferrable wakeup events
    per second when the controller is otherwise idle.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Tested-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 053bac9d983c..96ae69502c86 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -81,12 +81,15 @@ static int ehci_ci_reset(struct usb_hcd *hcd)
 {
 	struct device *dev = hcd->self.controller;
 	struct ci_hdrc *ci = dev_get_drvdata(dev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int ret;
 
 	ret = ehci_setup(hcd);
 	if (ret)
 		return ret;
 
+	ehci->need_io_watchdog = 0;
+
 	ci_platform_configure(ci);
 
 	return ret;

commit 43a404577a93d236913b67e41758adf5b9a8f45d
Author: Li Jun <jun.li@freescale.com>
Date:   Tue Dec 15 17:47:47 2015 +0800

    usb: chipidea: host: set host to be null after hcd is freed
    
    Set ci->hcd and ci->otg.host to be null in host_stop since the
    hcd already freed.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 3d24304405b3..053bac9d983c 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -190,6 +190,8 @@ static void host_stop(struct ci_hdrc *ci)
 			(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))
 				regulator_disable(ci->platdata->reg_vbus);
 	}
+	ci->hcd = NULL;
+	ci->otg.host = NULL;
 }
 
 

commit 11a27098e884b8eb797f1579ebc51cb0e0510cc3
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 5 10:16:19 2015 +0800

    usb: chipidea: host: override hcd reset API
    
    The system configuration API should be called before the controller
    run, otherwise, undefined results may occur. So, we override hcd
    reset API, and add system configuration API after controller reset.
    
    Cc: Li Jun <peter.chen@freescale.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ee38c5da211a..3d24304405b3 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -77,9 +77,25 @@ static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 	return 0;
 };
 
+static int ehci_ci_reset(struct usb_hcd *hcd)
+{
+	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
+	int ret;
+
+	ret = ehci_setup(hcd);
+	if (ret)
+		return ret;
+
+	ci_platform_configure(ci);
+
+	return ret;
+}
+
 static const struct ehci_driver_overrides ehci_ci_overrides = {
 	.extra_priv_size = sizeof(struct ehci_ci_priv),
 	.port_power	 = ehci_ci_portpower,
+	.reset		 = ehci_ci_reset,
 };
 
 static irqreturn_t host_irq(struct ci_hdrc *ci)
@@ -151,8 +167,6 @@ static int host_start(struct ci_hdrc *ci)
 		}
 	}
 
-	ci_platform_configure(ci);
-
 	return ret;
 
 disable_reg:

commit 1311d6e3ea3316e9d2383219a36353ad335f6932
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Jul 14 15:43:02 2015 +0800

    usb: chipidea: host: delete the redundancy ci_hdrc struct
    
    The struct ci_hdrc is the drvdata for hcd device, so we don't
    need to introduce extra ci_hdrc structure for ehci.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 44554318db8a..ee38c5da211a 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -37,15 +37,14 @@ static int (*orig_bus_suspend)(struct usb_hcd *hcd);
 
 struct ehci_ci_priv {
 	struct regulator *reg_vbus;
-	struct ci_hdrc *ci;
 };
 
 static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;
-	struct ci_hdrc *ci = priv->ci;
 	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
 	int ret = 0;
 	int port = HCS_N_PORTS(ehci->hcs_params);
 
@@ -123,7 +122,6 @@ static int host_start(struct ci_hdrc *ci)
 
 	priv = (struct ehci_ci_priv *)ehci->priv;
 	priv->reg_vbus = NULL;
-	priv->ci = ci;
 
 	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
 		if (ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON) {

commit bf9c85e78d0fec61360ece46dacf9ab71ba89361
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Mar 17 10:40:50 2015 +0800

    usb: chipidea: introduce ci_platform_configure
    
    It is used to configure controller parameters according to
    platform data, like speed, stream mode, etc, both host and
    device's initialization need it, most of code are the
    same for both roles, with this new interface, it can reduce
    the duplicated code and be easy to maintain in future.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index b01716c8c66b..44554318db8a 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -153,14 +153,7 @@ static int host_start(struct ci_hdrc *ci)
 		}
 	}
 
-	if (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)
-		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
-
-	if (ci->platdata->flags & CI_HDRC_FORCE_FULLSPEED)
-		hw_write(ci, OP_PORTSC, PORTSC_PFSC, PORTSC_PFSC);
-
-	if (ci->platdata->flags & CI_HDRC_SET_NON_ZERO_TTHA)
-		hw_write(ci, OP_TTCTRL, TTCTRL_TTHA_MASK, TTCTRL_TTHA);
+	ci_platform_configure(ci);
 
 	return ret;
 

commit 28362673129e7d4510a5a92a8b68ee47f282210b
Author: Peter Chen <peter.chen@freescale.com>
Date:   Thu Jun 18 11:51:53 2015 +0800

    usb: chipidea: add ttctrl.ttha control interface
    
    The register of ttctrl.ttha describes like below:
    - Internal TT Hub Address Representation
    - RW
    - Default = 0000000b
    This field is used to match against the Hub Address field in QH & siTD
    to determine if the packet is routed to the internal TT for directly
    attached FS/LS devices. If the Hub Address in the QH or siTD does not
    match this address then the packet will be broadcast on the High Speed
    ports destined for a downstream High Speed hub with the address in the QH/siTD.
    
    In silicon RTL, this entry only affects QH and siTD, and the hub.addr at
    both QH and siTD are 0 in ehci core for chipidea (with hcd->has_tt = 1).
    
    So, for QH, if the "usage_tt" flag at RTL is 0, set CI_HDRC_SET_NON_ZERO_TTHA
    will not affect QH (with non-hs device); for siTD, set this flag
    will change remaining space requirement for the last transaction from 1023
    bytes to 188 bytes, it can increase the number of transactions within one
    frame, ehci periodic schedule code will not queue the packet if the frame space
    is full, so it is safe to set this flag for siTD.
    
    With this flag, it can fix the problem Alan Stern reported below:
    http://www.spinics.net/lists/linux-usb/msg123125.html
    And may fix Michael Tessier's problem too.
    http://www.spinics.net/lists/linux-usb/msg118679.html
    
    CC: stern@rowland.harvard.edu
    CC: michael.tessier@axiontech.ca
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 7161439def19..b01716c8c66b 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -159,6 +159,9 @@ static int host_start(struct ci_hdrc *ci)
 	if (ci->platdata->flags & CI_HDRC_FORCE_FULLSPEED)
 		hw_write(ci, OP_PORTSC, PORTSC_PFSC, PORTSC_PFSC);
 
+	if (ci->platdata->flags & CI_HDRC_SET_NON_ZERO_TTHA)
+		hw_write(ci, OP_TTCTRL, TTCTRL_TTHA_MASK, TTCTRL_TTHA);
+
 	return ret;
 
 disable_reg:

commit 2f01a33bd26545c16fea7592697f7f15c416402b
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Jul 21 09:51:29 2015 +0800

    usb: chipidea: ehci_init_driver is intended to call one time
    
    The ehci_init_driver is used to initialize hcd APIs for each
    ehci controller driver, it is designed to be called only one time
    and before driver register is called. The current design will
    cause ehci_init_driver is called multiple times at probe process,
    it will cause hc_driver's initialization affect current running hcd.
    
    We run out NULL pointer dereference problem when one hcd is started
    by module_init, and the other is started by otg thread at SMP platform.
    The reason for this problem is ehci_init_driver will do memory copy
    for current uniform hc_driver, and this memory copy will do memset (as 0)
    first, so when the first hcd is running usb_add_hcd, and the second
    hcd may clear the uniform hc_driver's space (at ehci_init_driver),
    then the first hcd will meet NULL pointer at the same time.
    
    See below two logs:
    
    LOG_1:
    ci_hdrc ci_hdrc.0: EHCI Host Controller
    ci_hdrc ci_hdrc.0: new USB bus registered, assigned bus number 1
    ci_hdrc ci_hdrc.1: doesn't support gadget
    Unable to handle kernel NULL pointer dereference at virtual address 00000014
    pgd = 80004000
    [00000014] *pgd=00000000
    Internal error: Oops: 805 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 108 Comm: kworker/u8:2 Not tainted 3.14.38-222193-g24b2734-dirty #25
    Workqueue: ci_otg ci_otg_work
    task: d839ec00 ti: d8400000 task.ti: d8400000
    PC is at ehci_run+0x4c/0x284
    LR is at _raw_spin_unlock_irqrestore+0x28/0x54
    pc : [<8041f9a0>]    lr : [<8070ea84>]    psr: 60000113
    sp : d8401e30  ip : 00000000  fp : d8004400
    r10: 00000001  r9 : 00000001  r8 : 00000000
    r7 : 00000000  r6 : d8419940  r5 : 80dd24c0  r4 : d8419800
    r3 : 8001d060  r2 : 00000000  r1 : 00000001  r0 : 00000000
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c53c7d  Table: 1000404a  DAC: 00000015
    Process kworker/u8:2 (pid: 108, stack limit = 0xd8400238)
    Stack: (0xd8401e30 to 0xd8402000)
    1e20:                                     d87523c0 d8401e48 66667562 d8419800
    1e40: 00000000 00000000 d8419800 00000000 00000000 00000000 d84198b0 8040fcdc
    1e60: 00000000 80dd320c d8477610 d8419c00 d803d010 d8419800 00000000 00000000
    1e80: d8004400 00000000 d8400008 80431494 80431374 d803d100 d803d010 d803d1ac
    1ea0: 00000000 80432428 804323d4 d803d100 00000001 80435eb8 80e0d0bc d803d100
    1ec0: 00000006 80436458 00000000 d803d100 80e92ec8 80436f44 d803d010 d803d100
    1ee0: d83fde00 8043292c d8752710 d803d1f4 d803d010 8042ddfc 8042ddb8 d83f3b00
    1f00: d803d1f4 80042b60 00000000 00000003 00000001 00000001 80054598 d83f3b00
    1f20: d8004400 d83f3b18 d8004414 d8400000 80e3957b 00000089 d8004400 80043814
    1f40: d839ec00 00000000 d83fcd80 d83f3b00 800436e4 00000000 00000000 00000000
    1f60: 00000000 80048f34 00000000 00000000 00000000 d83f3b00 00000000 00000000
    1f80: d8401f80 d8401f80 00000000 00000000 d8401f90 d8401f90 d8401fac d83fcd80
    1fa0: 80048e68 00000000 00000000 8000e538 00000000 00000000 00000000 00000000
    1fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    1fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [<8041f9a0>] (ehci_run) from [<8040fcdc>] (usb_add_hcd+0x248/0x6e8)
    [<8040fcdc>] (usb_add_hcd) from [<80431494>] (host_start+0x120/0x2e4)
    [<80431494>] (host_start) from [<80432428>] (ci_otg_start_host+0x54/0xbc)
    [<80432428>] (ci_otg_start_host) from [<80435eb8>] (otg_set_protocol+0xa4/0xd0)
    [<80435eb8>] (otg_set_protocol) from [<80436458>] (otg_set_state+0x574/0xc58)
    [<80436458>] (otg_set_state) from [<80436f44>] (otg_statemachine+0x408/0x46c)
    [<80436f44>] (otg_statemachine) from [<8043292c>] (ci_otg_fsm_work+0x3c/0x190)
    [<8043292c>] (ci_otg_fsm_work) from [<8042ddfc>] (ci_otg_work+0x44/0x1c4)
    [<8042ddfc>] (ci_otg_work) from [<80042b60>] (process_one_work+0xf4/0x35c)
    [<80042b60>] (process_one_work) from [<80043814>] (worker_thread+0x130/0x3bc)
    [<80043814>] (worker_thread) from [<80048f34>] (kthread+0xcc/0xe4)
    [<80048f34>] (kthread) from [<8000e538>] (ret_from_fork+0x14/0x3c)
    Code: e5953018 e3530000 0a000000 e12fff33 (e5878014)
    
    LOG_2:
    ci_hdrc ci_hdrc.0: EHCI Host Controller
    ci_hdrc ci_hdrc.0: new USB bus registered, assigned bus number 1
    ci_hdrc ci_hdrc.1: doesn't support gadget
    Unable to handle kernel NULL pointer dereference at virtual address 00000000
    pgd = 80004000
    [00000000] *pgd=00000000
    In Online 00:00ternal e      Offline rror: Oops: 80000005 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 108 Comm: kworker/u8:2 Not tainted 3.14.38-02007-g24b2734-dirty #127
    Workque Online 00:00ue: ci_o      Offline tg ci_otg_work
    Online 00:00task: d8      Offline 39ec00 ti: d83ea000 task.ti: d83ea000
    PC is at 0x0
    LR is at usb_add_hcd+0x248/0x6e8
    pc : [<00000000>]    lr : [<8040f644>]    psr: 60000113
    sp : d83ebe60  ip : 00000000  fp : d8004400
    r10: 00000001  r9 : 00000001  r8 : d85fd4b0
    r7 : 00000000  r6 : 00000000  r5 : 00000000  r4 : d85fd400
    r3 : 00000000  r2 : d85fd4f4  r1 : 80410178  r0 : d85fd400
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c53c7d  Table: 1000404a  DAC: 00000015
    Process kworker/u8:2 (pid: 108, stack limit = 0xd83ea238)
    Stack: (0xd83ebe60 to 0xd83ec000)
    be60: 00000000 80dd920c d8654e10 d85fd800 d803e010 d85fd400 00000000 00000000
    be80: d8004400 00000000 d83ea008 80430e34 80430d14 d803e100 d803e010 d803e1ac
    bea0: 00000000 80431dc8 80431d74 d803e100 00000001 80435858 80e130bc d803e100
    bec0: 00000006 80435df8 00000000 d803e100 80e98ec8 804368e4 d803e010 d803e100
    bee0: d86e8100 804322cc d86cf050 d803e1f4 d803e010 8042d79c 8042d758 d83cf900
    bf00: d803e1f4 80042b78 00000000 00000003 00000001 00000001 800545e8 d83cf900
    bf20: d8004400 d83cf918 d8004414 d83ea000 80e3f57b 00000089 d8004400 8004382c
    bf40: d839ec00 00000000 d8393780 d83cf900 800436fc 00000000 00000000 00000000
    bf60: 00000000 80048f50 80e019f4 00000000 0000264c d83cf900 00000000 00000000
    bf80: d83ebf80 d83ebf80 00000000 00000000 d83ebf90 d83ebf90 d83ebfac d8393780
    bfa0: 80048e84 00000000 00000000 8000e538 00000000 00000000 00000000 00000000
    bfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    bfe0: 00000000 00000000 00000000 00000000 00000013 00000000 ee66e85d 133ebd03
    [<804 Online 00:000f644>]       Offline (usb_add_hcd) from [<80430e34>] (host_start+0x120/0x2e4)
    [<80430e34>] (host_start) from [<80431dc8>] (ci_otg_start_host+0x54/0xbc)
    [<80431dc8>] (ci_otg_start_host) from [<80435858>] (otg_set_protocol+0xa4/0xd0)
    [<80435858>] (otg_set_protocol) from [<80435df8>] (otg_set_state+0x574/0xc58)
    [<80435df8>] (otg_set_state) from [<804368e4>] (otg_statemachine+0x408/0x46c)
    [<804368e4>] (otg_statemachine) from [<804322cc>] (ci_otg_fsm_work+0x3c/0x190)
    [<804322cc>] (ci_otg_fsm_work) from [<8042d79c>] (ci_otg_work+0x44/0x1c4)
    [<8042d79c>] (ci_otg_work) from [<80042b78>] (process_one_work+0xf4/0x35c)
    [<80042b78>] (process_one_work) from [<8004382c>] (worker_thread+0x130/0x3bc)
    [<8004382c>] (worker_thread) from [<80048f50>] (kthread+0xcc/0xe4)
    [<80048f50>] (kthread) from [<8000e538>] (ret_from_fork+0x14/0x3c)
    Code: bad PC value
    
    Cc: Jun Li <jun.li@freescale.com>
    Cc: <stable@vger.kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 6cf87b8b13a8..7161439def19 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -249,9 +249,12 @@ int ci_hdrc_host_init(struct ci_hdrc *ci)
 	rdrv->name	= "host";
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
+	return 0;
+}
+
+void ci_hdrc_host_driver_init(void)
+{
 	ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
 	orig_bus_suspend = ci_ehci_hc_driver.bus_suspend;
 	ci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;
-
-	return 0;
 }

commit fc6b68ba4990b4fb2625b150599c77d04d85b1eb
Author: Rob Herring <robh@kernel.org>
Date:   Fri May 29 11:38:46 2015 -0500

    usb: chipidea: add work-around for Marvell HSIC PHY startup
    
    The Marvell 28nm HSIC PHY requires the port to be forced to HS mode after
    the port power is applied. This is done using the test mode in the PORTSC
    register.
    
    As HSIC is always HS, this work-around should be safe to do with all HSIC
    PHYs and has been tested on i.MX6S.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Peter Chen <Peter.Chen@freescale.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 21fe1a314313..6cf87b8b13a8 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -37,12 +37,14 @@ static int (*orig_bus_suspend)(struct usb_hcd *hcd);
 
 struct ehci_ci_priv {
 	struct regulator *reg_vbus;
+	struct ci_hdrc *ci;
 };
 
 static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;
+	struct ci_hdrc *ci = priv->ci;
 	struct device *dev = hcd->self.controller;
 	int ret = 0;
 	int port = HCS_N_PORTS(ehci->hcs_params);
@@ -64,6 +66,15 @@ static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 			return ret;
 		}
 	}
+
+	if (enable && (ci->platdata->phy_mode == USBPHY_INTERFACE_MODE_HSIC)) {
+		/*
+		 * Marvell 28nm HSIC PHY requires forcing the port to HS mode.
+		 * As HSIC is always HS, this should be safe for others.
+		 */
+		hw_port_test_set(ci, 5);
+		hw_port_test_set(ci, 0);
+	}
 	return 0;
 };
 
@@ -112,6 +123,7 @@ static int host_start(struct ci_hdrc *ci)
 
 	priv = (struct ehci_ci_priv *)ehci->priv;
 	priv->reg_vbus = NULL;
+	priv->ci = ci;
 
 	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
 		if (ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON) {

commit 6594591741883e004aaba105951337878698b054
Author: Li Jun <b47624@freescale.com>
Date:   Wed Feb 11 12:45:02 2015 +0800

    usb: chipidea: host: turn on vbus before add hcd if early vbus on is required
    
    If CI_HDRC_TURN_VBUS_EARLY_ON is set, turn on vbus before adding hcd, so it
    will not set reg_vbus of ehci_ci_priv, then vbus will not be handled by ehci core.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index feb9f0735227..21fe1a314313 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -44,11 +44,10 @@ static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;
 	struct device *dev = hcd->self.controller;
-	struct ci_hdrc *ci = dev_get_drvdata(dev);
 	int ret = 0;
 	int port = HCS_N_PORTS(ehci->hcs_params);
 
-	if (priv->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
+	if (priv->reg_vbus) {
 		if (port > 1) {
 			dev_warn(dev,
 				"Not support multi-port regulator control\n");
@@ -114,12 +113,23 @@ static int host_start(struct ci_hdrc *ci)
 	priv = (struct ehci_ci_priv *)ehci->priv;
 	priv->reg_vbus = NULL;
 
-	if (ci->platdata->reg_vbus)
-		priv->reg_vbus = ci->platdata->reg_vbus;
+	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
+		if (ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON) {
+			ret = regulator_enable(ci->platdata->reg_vbus);
+			if (ret) {
+				dev_err(ci->dev,
+				"Failed to enable vbus regulator, ret=%d\n",
+									ret);
+				goto put_hcd;
+			}
+		} else {
+			priv->reg_vbus = ci->platdata->reg_vbus;
+		}
+	}
 
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret) {
-		goto put_hcd;
+		goto disable_reg;
 	} else {
 		struct usb_otg *otg = &ci->otg;
 
@@ -139,6 +149,10 @@ static int host_start(struct ci_hdrc *ci)
 
 	return ret;
 
+disable_reg:
+	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&
+			(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))
+		regulator_disable(ci->platdata->reg_vbus);
 put_hcd:
 	usb_put_hcd(hcd);
 
@@ -152,6 +166,9 @@ static void host_stop(struct ci_hdrc *ci)
 	if (hcd) {
 		usb_remove_hcd(hcd);
 		usb_put_hcd(hcd);
+		if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&
+			(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))
+				regulator_disable(ci->platdata->reg_vbus);
 	}
 }
 

commit 78f0357ec8baa1ffe9c14b81f88cb0f3a5e1c15a
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 11 12:44:59 2015 +0800

    usb: chipidea: host: add .bus_suspend quirk
    
    For chipidea, its resume sequence is not-EHCI compatible, see
    below description for FPR at portsc. So in order to send SoF in
    time for remote wakeup sequence(within 3ms), the RUN/STOP bit must
    be set before the resume signal is ended, but the usb resume
    code may run after resume signal is ended, so we had to set it
    at suspend path.
    
    Force Port Resume - RW. Default = 0b.
    1= Resume detected/driven on port.
    0=No resume (K-state) detected/driven on port.
    Host mode:
    Software sets this bit to one to drive resume signaling. The Controller sets this bit to '1' if
    a J-to-K transition is detected while the port is in the Suspend state. When this bit
    transitions to a '1' because a J-to-K transition is detected, the Port Change Detect bit in
    the USBSTS register is also set to '1'. This bit will automatically change to '0' after the
    resume sequence is complete. This behavior is different from EHCI where the controller
    driver is required to set this bit to a '0' after the resume duration is timed in the driver.
    Note that when the controller owns the port, the resume sequence follows the defined
    
    sequence documented in the USB Specification Revision 2.0. The resume signaling
    (Full-speed 'K') is driven on the port as long as this bit remains a '1'. This bit will remain
    a '1' until the port has switched to idle. Writing a '0' has no affect because the port
    controller will time the resume operation, clear the bit and the port control state switches
    to HS or FS idle.
    This field is '0' if Port Power(PP) is '0' in host mode.
    
    This bit is not-EHCI compatible.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 12edbd0c998a..feb9f0735227 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -33,6 +33,7 @@
 #include "host.h"
 
 static struct hc_driver __read_mostly ci_ehci_hc_driver;
+static int (*orig_bus_suspend)(struct usb_hcd *hcd);
 
 struct ehci_ci_priv {
 	struct regulator *reg_vbus;
@@ -161,6 +162,47 @@ void ci_hdrc_host_destroy(struct ci_hdrc *ci)
 		host_stop(ci);
 }
 
+static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int port;
+	u32 tmp;
+
+	int ret = orig_bus_suspend(hcd);
+
+	if (ret)
+		return ret;
+
+	port = HCS_N_PORTS(ehci->hcs_params);
+	while (port--) {
+		u32 __iomem *reg = &ehci->regs->port_status[port];
+		u32 portsc = ehci_readl(ehci, reg);
+
+		if (portsc & PORT_CONNECT) {
+			/*
+			 * For chipidea, the resume signal will be ended
+			 * automatically, so for remote wakeup case, the
+			 * usbcmd.rs may not be set before the resume has
+			 * ended if other resume paths consumes too much
+			 * time (~24ms), in that case, the SOF will not
+			 * send out within 3ms after resume ends, then the
+			 * high speed device will enter full speed mode.
+			 */
+
+			tmp = ehci_readl(ehci, &ehci->regs->command);
+			tmp |= CMD_RUN;
+			ehci_writel(ehci, tmp, &ehci->regs->command);
+			/*
+			 * It needs a short delay between set RS bit and PHCD.
+			 */
+			usleep_range(150, 200);
+			break;
+		}
+	}
+
+	return 0;
+}
+
 int ci_hdrc_host_init(struct ci_hdrc *ci)
 {
 	struct ci_role_driver *rdrv;
@@ -179,6 +221,8 @@ int ci_hdrc_host_init(struct ci_hdrc *ci)
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
 	ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
+	orig_bus_suspend = ci_ehci_hc_driver.bus_suspend;
+	ci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;
 
 	return 0;
 }

commit 905276c4319174d52de0e45fc9b22f599497be47
Author: Daniel Tang <dt.tangr@gmail.com>
Date:   Wed Feb 11 12:44:58 2015 +0800

    Chipidea: Set connect-at-fullspeed bit when entering host mode if CI_HDRC_FORCE_FULLSPEED is set in the platform data
    
    PORTSC_PFSC is not set on entering host mode which means the USB OTG
    controller will attempt to enumerate USB devices at high speed even when the
    CI_HDRC_FORCE_FULLSPEED flag is set in the platform data.
    
    This patch ensures it is set right before host mode operations begin if needed.
    
    Signed-off-by: Daniel Tang <dt.tangr@gmail.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 48731d0bab35..12edbd0c998a 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -133,6 +133,9 @@ static int host_start(struct ci_hdrc *ci)
 	if (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)
 		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
 
+	if (ci->platdata->flags & CI_HDRC_FORCE_FULLSPEED)
+		hw_write(ci, OP_PORTSC, PORTSC_PFSC, PORTSC_PFSC);
+
 	return ret;
 
 put_hcd:

commit 24c498df1c70fa3b8b4df18f4424904bf014c709
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Dec 24 11:33:17 2014 +0800

    Revert "usb: chipidea: remove duplicate dev_set_drvdata for host_start"
    
    This reverts commit 14b4099c074f2ddf4d84b22d370170e61b527529
    
    It moved platform_set_drvdata(pdev, ci) before hcd is created,
    and the hcd will assign itself as ci controller's drvdata during
    the hcd creation function (in usb_create_shared_hcd), so it
    overwrites the real ci's drvdata which we want to use.
    
    So, if the controller is at host mode, the system suspend
    API will get the wrong struct ci_hdrc pointer, and cause the
    oops.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index c1694cff1eaf..48731d0bab35 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -91,6 +91,7 @@ static int host_start(struct ci_hdrc *ci)
 	if (!hcd)
 		return -ENOMEM;
 
+	dev_set_drvdata(ci->dev, ci);
 	hcd->rsrc_start = ci->hw_bank.phys;
 	hcd->rsrc_len = ci->hw_bank.size;
 	hcd->regs = ci->hw_bank.abs;

commit 14b4099c074f2ddf4d84b22d370170e61b527529
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Nov 26 13:44:34 2014 +0800

    usb: chipidea: remove duplicate dev_set_drvdata for host_start
    
    The core driver has already done it, besides, move set driver data
    operation just after ci has allocated successfully in case some
    code (like ci_role_start) want to access this driver data.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 48731d0bab35..c1694cff1eaf 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -91,7 +91,6 @@ static int host_start(struct ci_hdrc *ci)
 	if (!hcd)
 		return -ENOMEM;
 
-	dev_set_drvdata(ci->dev, ci);
 	hcd->rsrc_start = ci->hw_bank.phys;
 	hcd->rsrc_len = ci->hw_bank.size;
 	hcd->regs = ci->hw_bank.abs;

commit 2d4d9f35bab1cad7f83d10864291d1e50b12c3f9
Merge: 2193dda5eec6 ebf3992061db
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 25 09:31:14 2014 -0800

    Merge tag 'usb-for-v3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v3.19 merge window
    
    This time, a very pull request with 216 non-merge
    commits. Most of the commits contained here are
    sparse or coccinelle fixes ranging from missing
    'static' to returning 0 in case of errors.
    
    More importantly, we have the removal the now
    unnecessary 'driver' argument to ->udc_stop().
    
    DWC2 learned about Dual-Role builds. Users of
    this IP can now have a single driver built for
    host and device roles.
    
    DWC3 got support for two new HW platforms: Exynos7
    and AMD.
    
    The Broadcom USB 3.0 Device Controller IP is now
    supported and so is PLX USB338x, which means DWC3
    has lost is badge as the only USB 3.0 peripheral
    IP supported on Linux.
    
    Thanks for Tony Lindgren's work, we can now have
    a distro-like kernel where all MUSB glue layers
    can be built into the same kernel (statically
    or dynamically linked) and it'll work in PIO (DMA
    will come probably on v3.20).
    
    Other than these, the usual set of cleanups and
    non-critical fixes.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit c8679a2fb8decc949c848ca58f93ff7fb619931a
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Mon Oct 13 09:53:04 2014 +0800

    usb: chipidea: host: add portpower override
    
    This patch adds an external portpower override callback, only single
    port regulator control is supported now.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ebde7b6ce687..33027abb5349 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -34,6 +34,44 @@
 
 static struct hc_driver __read_mostly ci_ehci_hc_driver;
 
+struct ehci_ci_priv {
+	struct regulator *reg_vbus;
+};
+
+static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;
+	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
+	int ret = 0;
+	int port = HCS_N_PORTS(ehci->hcs_params);
+
+	if (priv->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
+		if (port > 1) {
+			dev_warn(dev,
+				"Not support multi-port regulator control\n");
+			return 0;
+		}
+		if (enable)
+			ret = regulator_enable(priv->reg_vbus);
+		else
+			ret = regulator_disable(priv->reg_vbus);
+		if (ret) {
+			dev_err(dev,
+				"Failed to %s vbus regulator, ret=%d\n",
+				enable ? "enable" : "disable", ret);
+			return ret;
+		}
+	}
+	return 0;
+};
+
+static const struct ehci_driver_overrides ehci_ci_overrides = {
+	.extra_priv_size = sizeof(struct ehci_ci_priv),
+	.port_power	 = ehci_ci_portpower,
+};
+
 static irqreturn_t host_irq(struct ci_hdrc *ci)
 {
 	return usb_hcd_irq(ci->irq, ci->hcd);
@@ -43,6 +81,7 @@ static int host_start(struct ci_hdrc *ci)
 {
 	struct usb_hcd *hcd;
 	struct ehci_hcd *ehci;
+	struct ehci_ci_priv *priv;
 	int ret;
 
 	if (usb_disabled())
@@ -68,23 +107,15 @@ static int host_start(struct ci_hdrc *ci)
 	ehci->has_tdi_phy_lpm = ci->hw_bank.lpm;
 	ehci->imx28_write_fix = ci->imx28_write_fix;
 
-	/*
-	 * vbus is always on if host is not in OTG FSM mode,
-	 * otherwise should be controlled by OTG FSM
-	 */
-	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
-		ret = regulator_enable(ci->platdata->reg_vbus);
-		if (ret) {
-			dev_err(ci->dev,
-				"Failed to enable vbus regulator, ret=%d\n",
-				ret);
-			goto put_hcd;
-		}
-	}
+	priv = (struct ehci_ci_priv *)ehci->priv;
+	priv->reg_vbus = NULL;
+
+	if (ci->platdata->reg_vbus)
+		priv->reg_vbus = ci->platdata->reg_vbus;
 
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret) {
-		goto disable_reg;
+		goto put_hcd;
 	} else {
 		struct usb_otg *otg = ci->transceiver->otg;
 
@@ -100,10 +131,6 @@ static int host_start(struct ci_hdrc *ci)
 
 	return ret;
 
-disable_reg:
-	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci))
-		regulator_disable(ci->platdata->reg_vbus);
-
 put_hcd:
 	usb_put_hcd(hcd);
 
@@ -117,8 +144,6 @@ static void host_stop(struct ci_hdrc *ci)
 	if (hcd) {
 		usb_remove_hcd(hcd);
 		usb_put_hcd(hcd);
-		if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci))
-			regulator_disable(ci->platdata->reg_vbus);
 	}
 }
 
@@ -146,7 +171,7 @@ int ci_hdrc_host_init(struct ci_hdrc *ci)
 	rdrv->name	= "host";
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
-	ehci_init_driver(&ci_ehci_hc_driver, NULL);
+	ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
 
 	return 0;
 }

commit 1e5e2d3d055436c114e2f16145b83339aed024ff
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:19 2014 +0100

    usb: chipidea: add support to the generic PHY framework
    
    This patch adds support of the PHY framework for ChipIdea drivers.
    Changes are done in both the ChipIdea common code and in the drivers
    accessing the PHY. This is done by adding a new PHY member in
    ChipIdea's structures and by taking care of it in the code.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 789809f680aa..4f8eb40ad93a 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -59,8 +59,11 @@ static int host_start(struct ci_hdrc *ci)
 	hcd->has_tt = 1;
 
 	hcd->power_budget = ci->platdata->power_budget;
-	hcd->usb_phy = ci->usb_phy;
 	hcd->tpl_support = ci->platdata->tpl_support;
+	if (ci->phy)
+		hcd->phy = ci->phy;
+	else
+		hcd->usb_phy = ci->usb_phy;
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit ef44cb4226d132146e44f8ea562a16b27ff61126
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:16 2014 +0100

    usb: allow to supply the PHY in the drivers when using HCD
    
    This patch modify the generic code handling PHYs to allow them to be
    supplied from the drivers. This adds checks to ensure no PHY was already
    there when looking for one in the generic code. This also makes sure we
    do not modify its state in the generic HCD functions, it was provided by
    the driver.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ebde7b6ce687..789809f680aa 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -59,7 +59,7 @@ static int host_start(struct ci_hdrc *ci)
 	hcd->has_tt = 1;
 
 	hcd->power_budget = ci->platdata->power_budget;
-	hcd->usb_phy = ci->transceiver;
+	hcd->usb_phy = ci->usb_phy;
 	hcd->tpl_support = ci->platdata->tpl_support;
 
 	ehci = hcd_to_ehci(hcd);
@@ -86,10 +86,11 @@ static int host_start(struct ci_hdrc *ci)
 	if (ret) {
 		goto disable_reg;
 	} else {
-		struct usb_otg *otg = ci->transceiver->otg;
+		struct usb_otg *otg = &ci->otg;
 
 		ci->hcd = hcd;
-		if (otg) {
+
+		if (ci_otg_is_fsm_mode(ci)) {
 			otg->host = &hcd->self;
 			hcd->self.otg_port = 1;
 		}

commit 3d46e73dfdb840f460e5b06416965d132570ec33
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Wed Sep 24 23:05:50 2014 +0400

    usb: rename phy to usb_phy in HCD
    
    The USB PHY member of the HCD structure is renamed to 'usb_phy' and
    modifications are done in all drivers accessing it.
    This is in preparation to adding the generic PHY support.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    [Sergei: added missing 'drivers/usb/misc/lvstest.c' file, resolved rejects,
    updated changelog.]
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 0d6b24cb2270..ebde7b6ce687 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -59,7 +59,7 @@ static int host_start(struct ci_hdrc *ci)
 	hcd->has_tt = 1;
 
 	hcd->power_budget = ci->platdata->power_budget;
-	hcd->phy = ci->transceiver;
+	hcd->usb_phy = ci->transceiver;
 	hcd->tpl_support = ci->platdata->tpl_support;
 
 	ehci = hcd_to_ehci(hcd);

commit f6a9ff07832a9d30d457e976e6233b4351cd4cdf
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Aug 19 09:51:56 2014 +0800

    usb: chipidea: add TPL support for targeted hosts
    
    For OTG and Embedded hosts, they may need TPL (Targeted Peripheral List)
    for usb certification and other vender specific requirements, the
    platform can tell chipidea core driver if it supports tpl through DT
    or platform data.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index a93d950e9468..0d6b24cb2270 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -60,6 +60,7 @@ static int host_start(struct ci_hdrc *ci)
 
 	hcd->power_budget = ci->platdata->power_budget;
 	hcd->phy = ci->transceiver;
+	hcd->tpl_support = ci->platdata->tpl_support;
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit 0698b9b384d39ae8e855bbffac180ad5773efa72
Author: Li Jun <B47624@freescale.com>
Date:   Wed Apr 23 15:56:46 2014 +0800

    usb: chipidea: host: init otg port number
    
    Init otg_port number of otg capable host to be 1 at host start.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ffb41688c49f..a93d950e9468 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -82,10 +82,17 @@ static int host_start(struct ci_hdrc *ci)
 	}
 
 	ret = usb_add_hcd(hcd, 0, 0);
-	if (ret)
+	if (ret) {
 		goto disable_reg;
-	else
+	} else {
+		struct usb_otg *otg = ci->transceiver->otg;
+
 		ci->hcd = hcd;
+		if (otg) {
+			otg->host = &hcd->self;
+			hcd->self.otg_port = 1;
+		}
+	}
 
 	if (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)
 		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);

commit 8a28b904ad9146cfb217e814f6d07355b1f77536
Author: Li Jun <B47624@freescale.com>
Date:   Wed Apr 23 15:56:45 2014 +0800

    usb: chipidea: host: vbus control change for OTG HNP
    
    Leave vbus on/off hanlded by OTG fsm if in OTG mode.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Li Jun <b47624@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index a8ac6c16dac9..ffb41688c49f 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -67,7 +67,11 @@ static int host_start(struct ci_hdrc *ci)
 	ehci->has_tdi_phy_lpm = ci->hw_bank.lpm;
 	ehci->imx28_write_fix = ci->imx28_write_fix;
 
-	if (ci->platdata->reg_vbus) {
+	/*
+	 * vbus is always on if host is not in OTG FSM mode,
+	 * otherwise should be controlled by OTG FSM
+	 */
+	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {
 		ret = regulator_enable(ci->platdata->reg_vbus);
 		if (ret) {
 			dev_err(ci->dev,
@@ -89,7 +93,7 @@ static int host_start(struct ci_hdrc *ci)
 	return ret;
 
 disable_reg:
-	if (ci->platdata->reg_vbus)
+	if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci))
 		regulator_disable(ci->platdata->reg_vbus);
 
 put_hcd:
@@ -105,7 +109,7 @@ static void host_stop(struct ci_hdrc *ci)
 	if (hcd) {
 		usb_remove_hcd(hcd);
 		usb_put_hcd(hcd);
-		if (ci->platdata->reg_vbus)
+		if (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci))
 			regulator_disable(ci->platdata->reg_vbus);
 	}
 }

commit ed8f8318d2ef3e5f9e4ddf79349508c116b68d7f
Author: Peter Chen <peter.chen@freescale.com>
Date:   Fri Jan 10 13:51:27 2014 +0800

    usb: chipidea: add freescale imx28 special write register method
    
    According to Freescale imx28 Errata, "ENGR119653 USB: ARM to USB
    register error issue", All USB register write operations must
    use the ARM SWP instruction. So, we implement special hw_write
    and hw_test_and_clear for imx28.
    
    Discussion for it at below:
    http://marc.info/?l=linux-usb&m=137996395529294&w=2
    
    This patch is needed for stable tree 3.11+.
    
    Cc: stable@vger.kernel.org
    Cc: robert.hodaszi@digi.com
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Tested-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 526cd77563d8..a8ac6c16dac9 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -65,6 +65,7 @@ static int host_start(struct ci_hdrc *ci)
 	ehci->caps = ci->hw_bank.cap;
 	ehci->has_hostpc = ci->hw_bank.lpm;
 	ehci->has_tdi_phy_lpm = ci->hw_bank.lpm;
+	ehci->imx28_write_fix = ci->imx28_write_fix;
 
 	if (ci->platdata->reg_vbus) {
 		ret = regulator_enable(ci->platdata->reg_vbus);

commit 46adcf3d82b44a4a9f147b2b898595d48873aa53
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Fri Nov 8 01:09:47 2013 -0200

    usb: chipidea: host: Only disable the vbus regulator if it is not NULL
    
    Commit 40ed51a4b (usb: chipidea: host: add vbus regulator
    control) introduced a smatch complaint because regulator_disable() is called
    without checking whether ci->platdata->reg_vbus is not NULL.
    
    Fix this by adding the check.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 59e6020ea753..526cd77563d8 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -88,7 +88,8 @@ static int host_start(struct ci_hdrc *ci)
 	return ret;
 
 disable_reg:
-	regulator_disable(ci->platdata->reg_vbus);
+	if (ci->platdata->reg_vbus)
+		regulator_disable(ci->platdata->reg_vbus);
 
 put_hcd:
 	usb_put_hcd(hcd);

commit df101c531eb737915349a1c4b677da7db55eaf69
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Oct 22 11:13:41 2013 +0800

    usb: chipidea: host: more enhancement when ci->hcd is NULL
    
    Like http://marc.info/?l=linux-usb&m=138200449428874&w=2 said:
    two more things are needed to be done:
    
    - If host_start fails, the host_stop should not be called, so we
    add check that ci->hcd is not NULL.
    - if the host_start fails at the beginning, we need to consider
    regulator mismatch issue.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 64d7a6d9a1ad..59e6020ea753 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -103,15 +103,15 @@ static void host_stop(struct ci_hdrc *ci)
 	if (hcd) {
 		usb_remove_hcd(hcd);
 		usb_put_hcd(hcd);
+		if (ci->platdata->reg_vbus)
+			regulator_disable(ci->platdata->reg_vbus);
 	}
-	if (ci->platdata->reg_vbus)
-		regulator_disable(ci->platdata->reg_vbus);
 }
 
 
 void ci_hdrc_host_destroy(struct ci_hdrc *ci)
 {
-	if (ci->role == CI_ROLE_HOST)
+	if (ci->role == CI_ROLE_HOST && ci->hcd)
 		host_stop(ci);
 }
 

commit 41314fea2ffb6dc716b7e698a47c68b329602fc0
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Wed Oct 16 13:45:15 2013 +0100

    usb/chipidea: fix oops on memory allocation failure
    
    When CMA fails to initialize in v3.12-rc4, the chipidea driver oopses
    the kernel while trying to remove and put the HCD which doesn't exist:
    
    WARNING: CPU: 0 PID: 6 at /home/rmk/git/linux-rmk/arch/arm/mm/dma-mapping.c:511
    __dma_alloc+0x200/0x240()
    coherent pool not initialised!
    Modules linked in:
    CPU: 0 PID: 6 Comm: kworker/u2:0 Tainted: G        W    3.12.0-rc4+ #56
    Workqueue: deferwq deferred_probe_work_func
    Backtrace:
    [<c001218c>] (dump_backtrace+0x0/0x10c) from [<c0012328>] (show_stack+0x18/0x1c)
     r6:c05fd9cc r5:000001ff r4:00000000 r3:df86ad00
    [<c0012310>] (show_stack+0x0/0x1c) from [<c05f3a4c>] (dump_stack+0x70/0x8c)
    [<c05f39dc>] (dump_stack+0x0/0x8c) from [<c00230a8>] (warn_slowpath_common+0x6c/0x8c)
     r4:df883a60 r3:df86ad00
    [<c002303c>] (warn_slowpath_common+0x0/0x8c) from [<c002316c>] (warn_slowpath_fmt+0x38/0x40)
     r8:ffffffff r7:00001000 r6:c083b808 r5:00000000 r4:df2efe80
    [<c0023134>] (warn_slowpath_fmt+0x0/0x40) from [<c00196bc>] (__dma_alloc+0x200/0x240)
     r3:00000000 r2:c05fda00
    [<c00194bc>] (__dma_alloc+0x0/0x240) from [<c001982c>] (arm_dma_alloc+0x88/0xa0)
    [<c00197a4>] (arm_dma_alloc+0x0/0xa0) from [<c03e2904>] (ehci_setup+0x1f4/0x438)
    [<c03e2710>] (ehci_setup+0x0/0x438) from [<c03cbd60>] (usb_add_hcd+0x18c/0x664)
    [<c03cbbd4>] (usb_add_hcd+0x0/0x664) from [<c03e89f4>] (host_start+0xf0/0x180)
    [<c03e8904>] (host_start+0x0/0x180) from [<c03e7c34>] (ci_hdrc_probe+0x360/0x670
    )
     r6:df2ef410 r5:00000000 r4:df2c3010 r3:c03e8904
    [<c03e78d4>] (ci_hdrc_probe+0x0/0x670) from [<c0311044>] (platform_drv_probe+0x20/0x24)
    [<c0311024>] (platform_drv_probe+0x0/0x24) from [<c030fcac>] (driver_probe_device+0x9c/0x234)
    ...
    ---[ end trace c88ccaf3969e8422 ]---
    Unable to handle kernel NULL pointer dereference at virtual address 00000028
    pgd = c0004000
    [00000028] *pgd=00000000
    Internal error: Oops: 17 [#1] SMP ARM
    Modules linked in:
    CPU: 0 PID: 6 Comm: kworker/u2:0 Tainted: G        W    3.12.0-rc4+ #56
    Workqueue: deferwq deferred_probe_work_func
    task: df86ad00 ti: df882000 task.ti: df882000
    PC is at usb_remove_hcd+0x10/0x150
    LR is at host_stop+0x1c/0x3c
    pc : [<c03cacec>]    lr : [<c03e88e4>]    psr: 60000013
    sp : df883b50  ip : df883b78  fp : df883b74
    r10: c11f4c54  r9 : c0836450  r8 : df30c400
    r7 : fffffff4  r6 : df2ef410  r5 : 00000000  r4 : df2c3010
    r3 : 00000000  r2 : 00000000  r1 : df86b0a0  r0 : 00000000
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c53c7d  Table: 2f29404a  DAC: 00000015
    Process kworker/u2:0 (pid: 6, stack limit = 0xdf882240)
    Stack: (0xdf883b50 to 0xdf884000)
    ...
    Backtrace:
    [<c03cacdc>] (usb_remove_hcd+0x0/0x150) from [<c03e88e4>] (host_stop+0x1c/0x3c)
     r6:df2ef410 r5:00000000 r4:df2c3010
    [<c03e88c8>] (host_stop+0x0/0x3c) from [<c03e8aa0>] (ci_hdrc_host_destroy+0x1c/0x20)
     r5:00000000 r4:df2c3010
    [<c03e8a84>] (ci_hdrc_host_destroy+0x0/0x20) from [<c03e7c80>] (ci_hdrc_probe+0x3ac/0x670)
    [<c03e78d4>] (ci_hdrc_probe+0x0/0x670) from [<c0311044>] (platform_drv_probe+0x20/0x24)
    [<c0311024>] (platform_drv_probe+0x0/0x24) from [<c030fcac>] (driver_probe_device+0x9c/0x234)
    [<c030fc10>] (driver_probe_device+0x0/0x234) from [<c030ff28>] (__device_attach+0x44/0x48)
    ...
    ---[ end trace c88ccaf3969e8423 ]---
    
    Fix this so at least we can continue booting and get to a shell prompt.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 6f96795dd20c..64d7a6d9a1ad 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -100,8 +100,10 @@ static void host_stop(struct ci_hdrc *ci)
 {
 	struct usb_hcd *hcd = ci->hcd;
 
-	usb_remove_hcd(hcd);
-	usb_put_hcd(hcd);
+	if (hcd) {
+		usb_remove_hcd(hcd);
+		usb_put_hcd(hcd);
+	}
 	if (ci->platdata->reg_vbus)
 		regulator_disable(ci->platdata->reg_vbus);
 }

commit 3f124d233e97db96d9471d1fb346335d43d8650d
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:07 2013 +0300

    usb: chipidea: add role init and destroy APIs
    
    - The role's init will be called at probe procedure.
    - The role's destroy will be called at fail patch
    at probe and driver's removal.
    - The role's start/stop will be called when specific
    role has started.
    
    Tested-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 8cf8d28c88d6..6f96795dd20c 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -106,6 +106,13 @@ static void host_stop(struct ci_hdrc *ci)
 		regulator_disable(ci->platdata->reg_vbus);
 }
 
+
+void ci_hdrc_host_destroy(struct ci_hdrc *ci)
+{
+	if (ci->role == CI_ROLE_HOST)
+		host_stop(ci);
+}
+
 int ci_hdrc_host_init(struct ci_hdrc *ci)
 {
 	struct ci_role_driver *rdrv;

commit 40ed51a4b8588055ccd8e5420c76290659c4c974
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:04 2013 +0300

    usb: chipidea: host: add vbus regulator control
    
    For boards which have board level vbus control (eg, through gpio), we
    need to vbus operation according to below rules:
    - For host, we need open vbus before start hcd, and close it
    after remove hcd.
    - For otg, the vbus needs to be on/off when usb role switches.
    When the host roles begins, it opens vbus; when the host role
    finishes, it closes vbus.
    
    We put vbus operation to host as host is the only vbus user,
    When we are at host mode, the vbus is on, when we are not at
    host mode, vbus should be off.
    
    Tested-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 9b3aaf132bc3..8cf8d28c88d6 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -24,6 +24,7 @@
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
 #include <linux/usb/chipidea.h>
+#include <linux/regulator/consumer.h>
 
 #include "../host/ehci.h"
 
@@ -65,9 +66,19 @@ static int host_start(struct ci_hdrc *ci)
 	ehci->has_hostpc = ci->hw_bank.lpm;
 	ehci->has_tdi_phy_lpm = ci->hw_bank.lpm;
 
+	if (ci->platdata->reg_vbus) {
+		ret = regulator_enable(ci->platdata->reg_vbus);
+		if (ret) {
+			dev_err(ci->dev,
+				"Failed to enable vbus regulator, ret=%d\n",
+				ret);
+			goto put_hcd;
+		}
+	}
+
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret)
-		usb_put_hcd(hcd);
+		goto disable_reg;
 	else
 		ci->hcd = hcd;
 
@@ -75,6 +86,14 @@ static int host_start(struct ci_hdrc *ci)
 		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
 
 	return ret;
+
+disable_reg:
+	regulator_disable(ci->platdata->reg_vbus);
+
+put_hcd:
+	usb_put_hcd(hcd);
+
+	return ret;
 }
 
 static void host_stop(struct ci_hdrc *ci)
@@ -83,6 +102,8 @@ static void host_stop(struct ci_hdrc *ci)
 
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
+	if (ci->platdata->reg_vbus)
+		regulator_disable(ci->platdata->reg_vbus);
 }
 
 int ci_hdrc_host_init(struct ci_hdrc *ci)

commit 2cdcec4fedd6a5ee77bd551e6be7505f2230cd43
Author: Tuomas Tynkkynen <ttynkkynen@nvidia.com>
Date:   Mon Aug 12 16:06:49 2013 +0300

    usb: host: add has_tdi_phy_lpm capability bit
    
    The has_hostpc capability bit indicates that the host controller has the
    HOSTPC register extensions, but at the same time enables clock disabling
    power saving features with the PHY Low Power Clock Disable (PHCD) bit.
    
    However, some host controllers have the HOSTPC extensions but don't
    support the low-power feature, so the PHCD bit must not be set on those
    controllers. Add a separate capability bit for the low-power feature
    instead, and change all existing users of has_hostpc to use this new
    capability bit.
    
    The idea for this commit is taken from an old 2012 commit that never got
    merged ("disociate chipidea PHY low power suspend control from hostpc")
    
    Inspired-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Signed-off-by: Tuomas Tynkkynen <ttynkkynen@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 40d0fda4f66c..9b3aaf132bc3 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -63,6 +63,7 @@ static int host_start(struct ci_hdrc *ci)
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;
 	ehci->has_hostpc = ci->hw_bank.lpm;
+	ehci->has_tdi_phy_lpm = ci->hw_bank.lpm;
 
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret)

commit 8e22978c57087aac4d88693278db1cc3e94f1253
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Mon Jun 24 14:46:36 2013 +0300

    usb: chipidea: drop "13xxx" infix
    
    "ci13xxx" is bad for at least the following reasons:
      * people often mistype it
      * it doesn't add any informational value to the names it's used in
      * it needlessly attracts mail filters
    
    This patch replaces it with "ci_hdrc", "ci_udc" or "ci_hw", depending
    on the situation. Modules with ci13xxx prefix are also renamed accordingly
    and aliases are added for compatibility. Otherwise, no functional changes.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 8e9d31277c43..40d0fda4f66c 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -33,12 +33,12 @@
 
 static struct hc_driver __read_mostly ci_ehci_hc_driver;
 
-static irqreturn_t host_irq(struct ci13xxx *ci)
+static irqreturn_t host_irq(struct ci_hdrc *ci)
 {
 	return usb_hcd_irq(ci->irq, ci->hcd);
 }
 
-static int host_start(struct ci13xxx *ci)
+static int host_start(struct ci_hdrc *ci)
 {
 	struct usb_hcd *hcd;
 	struct ehci_hcd *ehci;
@@ -70,13 +70,13 @@ static int host_start(struct ci13xxx *ci)
 	else
 		ci->hcd = hcd;
 
-	if (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)
+	if (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)
 		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
 
 	return ret;
 }
 
-static void host_stop(struct ci13xxx *ci)
+static void host_stop(struct ci_hdrc *ci)
 {
 	struct usb_hcd *hcd = ci->hcd;
 
@@ -84,7 +84,7 @@ static void host_stop(struct ci13xxx *ci)
 	usb_put_hcd(hcd);
 }
 
-int ci_hdrc_host_init(struct ci13xxx *ci)
+int ci_hdrc_host_init(struct ci_hdrc *ci)
 {
 	struct ci_role_driver *rdrv;
 

commit 929473ea05db455ad88cdc081f2adc556b8dc48f
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Dec 22 09:24:11 2012 -0200

    usb: chipidea: Allow disabling streaming not only in udc mode
    
    When running a scp transfer using a USB/Ethernet adapter the following crash
    happens:
    
    $ scp test.tar.gz fabio@192.168.1.100:/home/fabio
    fabio@192.168.1.100's password:
    test.tar.gz                                      0%    0     0.0KB/s   --:-- ETA
    ------------[ cut here ]------------
    WARNING: at net/sched/sch_generic.c:255 dev_watchdog+0x2cc/0x2f0()
    NETDEV WATCHDOG: eth0 (asix): transmit queue 0 timed out
    Modules linked in:
    Backtrace:
    [<80011c94>] (dump_backtrace+0x0/0x10c) from [<804d3a5c>] (dump_stack+0x18/0x1c)
     r6:000000ff r5:80412388 r4:80685dc0 r3:80696cc0
    [<804d3a44>] (dump_stack+0x0/0x1c) from [<80021868>]
    (warn_slowpath_common+0x54/0x6c)
    [<80021814>] (warn_slowpath_common+0x0/0x6c) from [<80021924>]
    (warn_slowpath_fmt+0x38/0x40)
    ...
    
    Setting SDIS (Stream Disable Mode- bit 4 of USBMODE register) fixes the problem.
    
    However, in current code CI13XXX_DISABLE_STREAMING flag is only set in udc mode,
    so allow disabling streaming also in host mode.
    
    Tested on a mx6qsabrelite board.
    
    Suggested-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Reviewed-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index caecad9213f5..8e9d31277c43 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -70,6 +70,9 @@ static int host_start(struct ci13xxx *ci)
 	else
 		ci->hcd = hcd;
 
+	if (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)
+		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
+
 	return ret;
 }
 

commit 1b36810e27a9791878e4694357ab6d4c06acc22d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 7 16:12:47 2012 -0500

    USB: EHCI: miscellaneous cleanups for the library conversion
    
    This patch (as1630) cleans up a few minor items resulting from the
    split-up of the ehci-hcd driver:
    
            Remove the product_desc string from the ehci_driver_overrides
            structure.  All drivers will use the generic "EHCI Host
            Controller" string.  (This was requested by Felipe Balbi.)
    
            Allow drivers to pass a NULL pointer to ehci_init_driver()
            if they don't have to override any settings.
    
            Remove a #define symbol that is no longer used from the
            ChipIdea host driver.
    
            Rename overrides to pci_overrides in ehci-pci.c, for
            consistency with ehci-platform.c.
    
            Mark the *_overrides structures as __initdata.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index fed97d323899..caecad9213f5 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -25,17 +25,12 @@
 #include <linux/usb/hcd.h>
 #include <linux/usb/chipidea.h>
 
-#define CHIPIDEA_EHCI
 #include "../host/ehci.h"
 
 #include "ci.h"
 #include "bits.h"
 #include "host.h"
 
-static const struct ehci_driver_overrides ci_overrides = {
-	.product_desc =		"ChipIdea HDRC EHCI host controller",
-};
-
 static struct hc_driver __read_mostly ci_ehci_hc_driver;
 
 static irqreturn_t host_irq(struct ci13xxx *ci)
@@ -103,7 +98,7 @@ int ci_hdrc_host_init(struct ci13xxx *ci)
 	rdrv->name	= "host";
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
-	ehci_init_driver(&ci_ehci_hc_driver, &ci_overrides);
+	ehci_init_driver(&ci_ehci_hc_driver, NULL);
 
 	return 0;
 }

commit cdb2fac78321a8d621b5612c7ddfe96bdbe7d267
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Nov 3 12:39:27 2012 -0400

    USB: EHCI: fix build error in ChipIdea host driver
    
    This patch (as1629) fixes a build error in the ChipIdea host driver
    when compiled for the ARM architecture.  The error was introduced
    by commit 99f91934a907df31ba878dfdd090002049dc476a (USB: EHCI: make
    ehci-platform a separate driver).
    
    The fix is simple; an additional header-file #include is needed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 30b17ae5aa22..fed97d323899 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -20,6 +20,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/io.h>
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
 #include <linux/usb/chipidea.h>

commit 09f6ffde2ecef4cc4e2a5edaa303210cabd96f57
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 2 12:34:41 2012 -0400

    USB: EHCI: fix build error by making ChipIdea host a normal EHCI driver
    
    This patch (as1627) splits the ehci-hcd core code, which has become a
    separate library module, out from the ChipIdea host driver.  Instead
    of #include-ing ehci-hcd.c directly, the ChipIdea module will now use
    the ehci-hcd library in a normal fashion.
    
    This fixes a build error caused by commit
    3e0232039967d7a1a06c013d097458b4d5892af1 (USB: EHCI: prepare to make
    ehci-hcd a library module); I had forgotten about the unorthodox way
    the ChipIdea driver uses the ehci-hcd code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ebc041ff9cd5..30b17ae5aa22 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -25,57 +25,18 @@
 #include <linux/usb/chipidea.h>
 
 #define CHIPIDEA_EHCI
-#include "../host/ehci-hcd.c"
+#include "../host/ehci.h"
 
 #include "ci.h"
 #include "bits.h"
 #include "host.h"
 
-static const struct hc_driver ci_ehci_hc_driver = {
-	.description	= "ehci_hcd",
-	.product_desc	= "ChipIdea HDRC EHCI",
-	.hcd_priv_size	= sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq	= ehci_irq,
-	.flags	= HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset		= ehci_setup,
-	.start		= ehci_run,
-	.stop		= ehci_stop,
-	.shutdown	= ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.endpoint_reset		= ehci_endpoint_reset,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
-	.relinquish_port	= ehci_relinquish_port,
-	.port_handed_over	= ehci_port_handed_over,
-
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+static const struct ehci_driver_overrides ci_overrides = {
+	.product_desc =		"ChipIdea HDRC EHCI host controller",
 };
 
+static struct hc_driver __read_mostly ci_ehci_hc_driver;
+
 static irqreturn_t host_irq(struct ci13xxx *ci)
 {
 	return usb_hcd_irq(ci->irq, ci->hcd);
@@ -141,5 +102,7 @@ int ci_hdrc_host_init(struct ci13xxx *ci)
 	rdrv->name	= "host";
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
+	ehci_init_driver(&ci_ehci_hc_driver, &ci_overrides);
+
 	return 0;
 }

commit c73cee717e7d5da0698acb720ad1219646fe4f46
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:21:06 2012 -0400

    USB: EHCI: remove ehci_port_power() routine
    
    This patch (as1623) removes the ehci_port_power() routine and all the
    places that call it.  There's no reason for ehci-hcd to change the
    port power settings; the hub driver takes care of all that stuff.
    
    There is one exception: When the controller is resumed from
    hibernation or following a loss of power, the ports that are supposed
    to be handed over to a companion controller must be powered on first.
    Otherwise the handover won't work.  This process is not visible to the
    hub driver, so it has to be handled in ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ebff9f4f56ec..ebc041ff9cd5 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -31,22 +31,6 @@
 #include "bits.h"
 #include "host.h"
 
-static int ci_ehci_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	int ret;
-
-	hcd->has_tt = 1;
-
-	ret = ehci_setup(hcd);
-	if (ret)
-		return ret;
-
-	ehci_port_power(ehci, 0);
-
-	return ret;
-}
-
 static const struct hc_driver ci_ehci_hc_driver = {
 	.description	= "ehci_hcd",
 	.product_desc	= "ChipIdea HDRC EHCI",
@@ -61,7 +45,7 @@ static const struct hc_driver ci_ehci_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset		= ci_ehci_setup,
+	.reset		= ehci_setup,
 	.start		= ehci_run,
 	.stop		= ehci_stop,
 	.shutdown	= ehci_shutdown,

commit a2c3d6902f6f9916b5376c44baa8c1d08bf92a27
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:46 2012 +0800

    usb: chipidea: permit driver bindings pass phy pointer
    
    Sometimes, the driver bindings may know what phy they use.
    For example, when using device tree, the usb controller may have a
    phandler pointing to usb phy.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Subodh Nijsure <snijsure@grid-net.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 4a4fdb8c65f8..ebff9f4f56ec 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -117,6 +117,7 @@ static int host_start(struct ci13xxx *ci)
 	hcd->has_tt = 1;
 
 	hcd->power_budget = ci->platdata->power_budget;
+	hcd->phy = ci->transceiver;
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit 77c4400f2f0fd8384ab5cbe41d81ccc664896b2d
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Fri Jun 29 17:48:53 2012 +0800

    USB: Chipidea: rename struct ci13xxx_udc_driver to struct ci13xxx_platform_data
    
    This patch rename struct ci13xxx_udc_driver and var with the type.
    
    ci13xxx_platform_data reflect it's passed from platfrom driver.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 9eacd21c0cd9..4a4fdb8c65f8 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -116,7 +116,7 @@ static int host_start(struct ci13xxx *ci)
 	hcd->regs = ci->hw_bank.abs;
 	hcd->has_tt = 1;
 
-	hcd->power_budget = ci->udc_driver->power_budget;
+	hcd->power_budget = ci->platdata->power_budget;
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;

commit a756186b61d487c067411764080fd48f995d3799
Author: Marek Vasut <marex@denx.de>
Date:   Tue May 15 06:10:21 2012 +0200

    USB: CI13xxx: Use usb_put_hcd() on failure to drop HCD
    
    Use usb_put_hcd() call instead of usb_remove_hcd() as that's the appropriate
    call to drop hcd which failed registration.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 0cffcfe5ce53..9eacd21c0cd9 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -124,7 +124,7 @@ static int host_start(struct ci13xxx *ci)
 
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret)
-		usb_remove_hcd(hcd);
+		usb_put_hcd(hcd);
 	else
 		ci->hcd = hcd;
 

commit bd841986e4e1fe60fe97da45be5139f173c5188e
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:55 2012 +0300

    usb: chipidea: add power_budget limit for ehci to platform data
    
    Some implementations need this limitation to work correctly.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index 8c8362c89a8c..0cffcfe5ce53 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -116,6 +116,8 @@ static int host_start(struct ci13xxx *ci)
 	hcd->regs = ci->hw_bank.abs;
 	hcd->has_tt = 1;
 
+	hcd->power_budget = ci->udc_driver->power_budget;
+
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = ci->hw_bank.cap;
 	ehci->has_hostpc = ci->hw_bank.lpm;

commit eb70e5ab8f95a81283623c03d2c99dfc59fcb319
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:54 2012 +0300

    usb: chipidea: add host role
    
    This adds EHCI host support to the chipidea driver. We want it to be
    part of the hdrc driver and not a standalone (sub-)driver module, as
    the structure of ehci-hcd.c suggests, so for chipidea controller we
    hack it to not provide platform-related code, but only the ehci hcd.
    
    The ehci-platform driver won't work for us here too, because the
    controller uses the same registers for both device and host mode and
    also otg-related bits, so it's not really possible to put ehci registers
    into a separate resource.
    
    This is not a pretty solution, but the alternative is exporting symbols
    from the chipidea driver to a ehci-chipidea driver and doing all the
    module refcounting.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
new file mode 100644
index 000000000000..8c8362c89a8c
--- /dev/null
+++ b/drivers/usb/chipidea/host.c
@@ -0,0 +1,158 @@
+/*
+ * host.c - ChipIdea USB host controller driver
+ *
+ * Copyright (c) 2012 Intel Corporation
+ *
+ * Author: Alexander Shishkin
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/chipidea.h>
+
+#define CHIPIDEA_EHCI
+#include "../host/ehci-hcd.c"
+
+#include "ci.h"
+#include "bits.h"
+#include "host.h"
+
+static int ci_ehci_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int ret;
+
+	hcd->has_tt = 1;
+
+	ret = ehci_setup(hcd);
+	if (ret)
+		return ret;
+
+	ehci_port_power(ehci, 0);
+
+	return ret;
+}
+
+static const struct hc_driver ci_ehci_hc_driver = {
+	.description	= "ehci_hcd",
+	.product_desc	= "ChipIdea HDRC EHCI",
+	.hcd_priv_size	= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq	= ehci_irq,
+	.flags	= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset		= ci_ehci_setup,
+	.start		= ehci_run,
+	.stop		= ehci_stop,
+	.shutdown	= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static irqreturn_t host_irq(struct ci13xxx *ci)
+{
+	return usb_hcd_irq(ci->irq, ci->hcd);
+}
+
+static int host_start(struct ci13xxx *ci)
+{
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	hcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	dev_set_drvdata(ci->dev, ci);
+	hcd->rsrc_start = ci->hw_bank.phys;
+	hcd->rsrc_len = ci->hw_bank.size;
+	hcd->regs = ci->hw_bank.abs;
+	hcd->has_tt = 1;
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = ci->hw_bank.cap;
+	ehci->has_hostpc = ci->hw_bank.lpm;
+
+	ret = usb_add_hcd(hcd, 0, 0);
+	if (ret)
+		usb_remove_hcd(hcd);
+	else
+		ci->hcd = hcd;
+
+	return ret;
+}
+
+static void host_stop(struct ci13xxx *ci)
+{
+	struct usb_hcd *hcd = ci->hcd;
+
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+}
+
+int ci_hdrc_host_init(struct ci13xxx *ci)
+{
+	struct ci_role_driver *rdrv;
+
+	if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))
+		return -ENXIO;
+
+	rdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);
+	if (!rdrv)
+		return -ENOMEM;
+
+	rdrv->start	= host_start;
+	rdrv->stop	= host_stop;
+	rdrv->irq	= host_irq;
+	rdrv->name	= "host";
+	ci->roles[CI_ROLE_HOST] = rdrv;
+
+	return 0;
+}
