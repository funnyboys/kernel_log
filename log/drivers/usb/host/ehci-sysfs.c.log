commit ed5bd7a47fd77166860e39f857ae8e3fe25c836c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 23 11:24:05 2018 +0100

    USB: move many drivers to use DEVICE_ATTR_RW
    
    Instead of "open coding" a DEVICE_ATTR() define, use the
    DEVICE_ATTR_RW() macro instead, which does everything properly instead.
    
    This does require a few static functions to be renamed to work properly,
    but thanks to a script from Joe Perches, this was easily done.
    
    Reported-by: Joe Perches <joe@perches.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Stanislaw Gruszka <stf_xl@wp.pl>
    Cc: Peter Chen <Peter.Chen@nxp.com>
    Cc: Mathias Nyman <mathias.nyman@intel.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 71fb61dd4a87..8f75cb7b197c 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -7,7 +7,7 @@
 
 
 /* Display the ports dedicated to the companion controller */
-static ssize_t show_companion(struct device *dev,
+static ssize_t companion_show(struct device *dev,
 			      struct device_attribute *attr,
 			      char *buf)
 {
@@ -34,7 +34,7 @@ static ssize_t show_companion(struct device *dev,
  * Syntax is "[-]portnum", where a leading '-' sign means
  * return control of the port to the EHCI controller.
  */
-static ssize_t store_companion(struct device *dev,
+static ssize_t companion_store(struct device *dev,
 			       struct device_attribute *attr,
 			       const char *buf, size_t count)
 {
@@ -59,13 +59,13 @@ static ssize_t store_companion(struct device *dev,
 	set_owner(ehci, portnum, new_owner);
 	return count;
 }
-static DEVICE_ATTR(companion, 0644, show_companion, store_companion);
+static DEVICE_ATTR_RW(companion);
 
 
 /*
  * Display / Set uframe_periodic_max
  */
-static ssize_t show_uframe_periodic_max(struct device *dev,
+static ssize_t uframe_periodic_max_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
@@ -78,7 +78,7 @@ static ssize_t show_uframe_periodic_max(struct device *dev,
 }
 
 
-static ssize_t store_uframe_periodic_max(struct device *dev,
+static ssize_t uframe_periodic_max_store(struct device *dev,
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
@@ -143,7 +143,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	return ret;
 }
-static DEVICE_ATTR(uframe_periodic_max, 0644, show_uframe_periodic_max, store_uframe_periodic_max);
+static DEVICE_ATTR_RW(uframe_periodic_max);
 
 
 static inline int create_sysfs_files(struct ehci_hcd *ehci)

commit d214109875b419c85c596d39b032692133bf58ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:26 2017 +0100

    USB: host: ehci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 16669619cfc5..71fb61dd4a87 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -1,20 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2007 by Alan Stern
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /* this file is part of ehci-hcd.c */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 5216f2b09d63..16669619cfc5 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2007 by Alan Stern
  *

commit 0521cfd06e1ebcd575e7ae36aab068b38df23850
Author: Peter Chen <peter.chen@freescale.com>
Date:   Mon Aug 17 10:23:03 2015 +0800

    usb: host: ehci-sys: delete useless bus_to_hcd conversion
    
    The ehci platform device's drvdata is the pointer of struct usb_hcd
    already, so we doesn't need to call bus_to_hcd conversion again.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 5e44407aa099..5216f2b09d63 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -29,7 +29,7 @@ static ssize_t show_companion(struct device *dev,
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	nports = HCS_N_PORTS(ehci->hcs_params);
 
 	for (index = 0; index < nports; ++index) {
@@ -54,7 +54,7 @@ static ssize_t store_companion(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			portnum, new_owner;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	new_owner = PORT_OWNER;		/* Owned by companion */
 	if (sscanf(buf, "%d", &portnum) != 1)
 		return -EINVAL;
@@ -85,7 +85,7 @@ static ssize_t show_uframe_periodic_max(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			n;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	n = scnprintf(buf, PAGE_SIZE, "%d\n", ehci->uframe_periodic_max);
 	return n;
 }
@@ -101,7 +101,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 	unsigned long		flags;
 	ssize_t			ret;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	if (kstrtouint(buf, 0, &uframe_periodic_max) < 0)
 		return -EINVAL;
 

commit 6774def6422f6eac53f1828c317bf3b08a8f5a60
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Nov 5 22:26:48 2014 +0900

    treewide: fix typo in printk and Kconfig
    
    This patch fix spelling typo in printk and Kconfig within
    various part of kernel sources.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index f6459dfb6f54..5e44407aa099 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -132,7 +132,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 		if (allocated_max > uframe_periodic_max) {
 			ehci_info(ehci,
-				"cannot decrease uframe_periodic_max becase "
+				"cannot decrease uframe_periodic_max because "
 				"periodic bandwidth is already allocated "
 				"(%u > %u)\n",
 				allocated_max, uframe_periodic_max);

commit d0ce5c6b9208c79fc725c578eebdeb5724faf17d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:29:13 2013 -0400

    USB: EHCI: use a bandwidth-allocation table
    
    This patch significantly changes the scheduling code in ehci-hcd.
    Instead of calculating the current bandwidth utilization by trudging
    through the schedule and adding up the times used by the existing
    transfers, we will now maintain a table holding the time used for each
    of 64 microframes.  This will drastically speed up the bandwidth
    computations.
    
    In addition, it eliminates a theoretical bug.  An isochronous endpoint
    may have bandwidth reserved even at times when it has no transfers
    listed in the schedule.  The table will keep track of the reserved
    bandwidth, whereas adding up entries in the schedule would miss it.
    
    As a corollary, we can keep bandwidth reserved for endpoints even
    when they aren't in active use.  Eventually the bandwidth will be
    reserved when a new alternate setting is installed; for now the
    endpoint's reservation takes place when its first URB is submitted.
    
    A drawback of this approach is that transfers with an interval larger
    than 64 microframes will have to be charged for bandwidth as though
    the interval was 64.  In practice this shouldn't matter much;
    transfers with longer intervals tend to be rather short anyway (things
    like hubs or HID devices).
    
    Another minor drawback is that we will keep track of two different
    period and phase values: the actual ones and the ones used for
    bandwidth allocation (which are limited to 64).  This adds only a
    small amount of overhead: 3 bytes for each endpoint.
    
    The patch also adds a new debugfs file named "bandwidth" to display
    the information stored in the new table.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 14ced00ba220..f6459dfb6f54 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -97,8 +97,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 {
 	struct ehci_hcd		*ehci;
 	unsigned		uframe_periodic_max;
-	unsigned		frame, uframe;
-	unsigned short		allocated_max;
+	unsigned		uframe;
 	unsigned long		flags;
 	ssize_t			ret;
 
@@ -122,16 +121,14 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 	/*
 	 * for request to decrease max periodic bandwidth, we have to check
-	 * every microframe in the schedule to see whether the decrease is
-	 * possible.
+	 * to see whether the decrease is possible.
 	 */
 	if (uframe_periodic_max < ehci->uframe_periodic_max) {
-		allocated_max = 0;
+		u8		allocated_max = 0;
 
-		for (frame = 0; frame < ehci->periodic_size; ++frame)
-			for (uframe = 0; uframe < 7; ++uframe)
-				allocated_max = max(allocated_max,
-						    periodic_usecs (ehci, frame, uframe));
+		for (uframe = 0; uframe < EHCI_BANDWIDTH_SIZE; ++uframe)
+			allocated_max = max(allocated_max,
+					ehci->bandwidth[uframe]);
 
 		if (allocated_max > uframe_periodic_max) {
 			ehci_info(ehci,

commit cc62a7eb6396e8be95b9a30053ed09191818b99b
Author: Kirill Smelkov <kirr@mns.spb.ru>
Date:   Sun Jul 3 20:36:57 2011 +0400

    USB: EHCI: Allow users to override 80% max periodic bandwidth
    
    There are cases, when 80% max isochronous bandwidth is too limiting.
    
    For example I have two USB video capture cards which stream uncompressed
    video, and to stream full NTSC + PAL videos we'd need
    
        NTSC 640x480 YUV422 @30fps      ~17.6 MB/s
        PAL  720x576 YUV422 @25fps      ~19.7 MB/s
    
    isoc bandwidth.
    
    Now, due to limited alt settings in capture devices NTSC one ends up
    streaming with max_pkt_size=2688  and  PAL with max_pkt_size=2892, both
    with interval=1. In terms of microframe time allocation this gives
    
        NTSC    ~53us
        PAL     ~57us
    
    and together
    
        ~110us  >  100us == 80% of 125us uframe time.
    
    So those two devices can't work together simultaneously because the'd
    over allocate isochronous bandwidth.
    
    80% seemed a bit arbitrary to me, and I've tried to raise it to 90% and
    both devices started to work together, so I though sometimes it would be
    a good idea for users to override hardcoded default of max 80% isoc
    bandwidth.
    
    After all, isn't it a user who should decide how to load the bus? If I
    can live with 10% or even 5% bulk bandwidth that should be ok. I'm a USB
    newcomer, but that 80% set in stone by USB 2.0 specification seems to be
    chosen pretty arbitrary to me, just to serve as a reasonable default.
    
    NOTE 1
    ~~~~~~
    
    for two streams with max_pkt_size=3072 (worst case) both time
    allocation would be 60us+60us=120us which is 96% periodic bandwidth
    leaving 4% for bulk and control.  Alan Stern suggested that bulk then
    would be problematic (less than 300*8 bittimes left per microframe), but
    I think that is still enough for control traffic.
    
    NOTE 2
    ~~~~~~
    
    Sarah Sharp expressed concern that maxing out periodic bandwidth
    could lead to vendor-specific hardware bugs on host controllers, because
    
    > It's entirely possible that you'll run into
    > vendor-specific bugs if you try to pack the schedule with isochronous
    > transfers.  I don't think any hardware designer would seriously test or
    > validate their hardware with a schedule that is basically a violation of
    > the USB bus spec (more than 80% for periodic transfers).
    
    So far I've only tested this patch on my HP Mini 5103 with N10 chipset
    
        kirr@mini:~$ lspci
        00:00.0 Host bridge: Intel Corporation N10 Family DMI Bridge
        00:02.0 VGA compatible controller: Intel Corporation N10 Family Integrated Graphics Controller
        00:02.1 Display controller: Intel Corporation N10 Family Integrated Graphics Controller
        00:1b.0 Audio device: Intel Corporation N10/ICH 7 Family High Definition Audio Controller (rev 02)
        00:1c.0 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 1 (rev 02)
        00:1c.3 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 4 (rev 02)
        00:1d.0 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #1 (rev 02)
        00:1d.1 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #2 (rev 02)
        00:1d.2 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #3 (rev 02)
        00:1d.3 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #4 (rev 02)
        00:1d.7 USB Controller: Intel Corporation N10/ICH 7 Family USB2 EHCI Controller (rev 02)
        00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev e2)
        00:1f.0 ISA bridge: Intel Corporation NM10 Family LPC Controller (rev 02)
        00:1f.2 SATA controller: Intel Corporation N10/ICH7 Family SATA AHCI Controller (rev 02)
        01:00.0 Network controller: Broadcom Corporation BCM4313 802.11b/g/n Wireless LAN Controller (rev 01)
        02:00.0 Ethernet controller: Marvell Technology Group Ltd. 88E8059 PCI-E Gigabit Ethernet Controller (rev 11)
    
    and the system works stable with 110us/uframe (~88%) isoc bandwith allocated for
    above-mentioned isochronous transfers.
    
    NOTE 3
    ~~~~~~
    
    This feature is off by default. I mean max periodic bandwidth is set to
    100us/uframe by default exactly as it was before the patch. So only those of us
    who need the extreme settings are taking the risk - normal users who do not
    alter uframe_periodic_max sysfs attribute should not see any change at all.
    
    NOTE 4
    ~~~~~~
    
    I've tried to update documentation in Documentation/ABI/ thoroughly, but
    only "TBD" was put into Documentation/usb/ehci.txt -- the text there seems
    to be outdated and much needing refreshing, before it could be amended.
    
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Kirill Smelkov <kirr@mns.spb.ru>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 29824a98aec9..14ced00ba220 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -74,21 +74,117 @@ static ssize_t store_companion(struct device *dev,
 }
 static DEVICE_ATTR(companion, 0644, show_companion, store_companion);
 
+
+/*
+ * Display / Set uframe_periodic_max
+ */
+static ssize_t show_uframe_periodic_max(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct ehci_hcd		*ehci;
+	int			n;
+
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	n = scnprintf(buf, PAGE_SIZE, "%d\n", ehci->uframe_periodic_max);
+	return n;
+}
+
+
+static ssize_t store_uframe_periodic_max(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct ehci_hcd		*ehci;
+	unsigned		uframe_periodic_max;
+	unsigned		frame, uframe;
+	unsigned short		allocated_max;
+	unsigned long		flags;
+	ssize_t			ret;
+
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	if (kstrtouint(buf, 0, &uframe_periodic_max) < 0)
+		return -EINVAL;
+
+	if (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {
+		ehci_info(ehci, "rejecting invalid request for "
+				"uframe_periodic_max=%u\n", uframe_periodic_max);
+		return -EINVAL;
+	}
+
+	ret = -EINVAL;
+
+	/*
+	 * lock, so that our checking does not race with possible periodic
+	 * bandwidth allocation through submitting new urbs.
+	 */
+	spin_lock_irqsave (&ehci->lock, flags);
+
+	/*
+	 * for request to decrease max periodic bandwidth, we have to check
+	 * every microframe in the schedule to see whether the decrease is
+	 * possible.
+	 */
+	if (uframe_periodic_max < ehci->uframe_periodic_max) {
+		allocated_max = 0;
+
+		for (frame = 0; frame < ehci->periodic_size; ++frame)
+			for (uframe = 0; uframe < 7; ++uframe)
+				allocated_max = max(allocated_max,
+						    periodic_usecs (ehci, frame, uframe));
+
+		if (allocated_max > uframe_periodic_max) {
+			ehci_info(ehci,
+				"cannot decrease uframe_periodic_max becase "
+				"periodic bandwidth is already allocated "
+				"(%u > %u)\n",
+				allocated_max, uframe_periodic_max);
+			goto out_unlock;
+		}
+	}
+
+	/* increasing is always ok */
+
+	ehci_info(ehci, "setting max periodic bandwidth to %u%% "
+			"(== %u usec/uframe)\n",
+			100*uframe_periodic_max/125, uframe_periodic_max);
+
+	if (uframe_periodic_max != 100)
+		ehci_warn(ehci, "max periodic bandwidth set is non-standard\n");
+
+	ehci->uframe_periodic_max = uframe_periodic_max;
+	ret = count;
+
+out_unlock:
+	spin_unlock_irqrestore (&ehci->lock, flags);
+	return ret;
+}
+static DEVICE_ATTR(uframe_periodic_max, 0644, show_uframe_periodic_max, store_uframe_periodic_max);
+
+
 static inline int create_sysfs_files(struct ehci_hcd *ehci)
 {
+	struct device	*controller = ehci_to_hcd(ehci)->self.controller;
 	int	i = 0;
 
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
-		i = device_create_file(ehci_to_hcd(ehci)->self.controller,
-				       &dev_attr_companion);
+		i = device_create_file(controller, &dev_attr_companion);
+	if (i)
+		goto out;
+
+	i = device_create_file(controller, &dev_attr_uframe_periodic_max);
+out:
 	return i;
 }
 
 static inline void remove_sysfs_files(struct ehci_hcd *ehci)
 {
+	struct device	*controller = ehci_to_hcd(ehci)->self.controller;
+
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
-		device_remove_file(ehci_to_hcd(ehci)->self.controller,
-				   &dev_attr_companion);
+		device_remove_file(controller, &dev_attr_companion);
+
+	device_remove_file(controller, &dev_attr_uframe_periodic_max);
 }

commit 4c67045bfc2c14a1d3c6040e80eb4a62946282dd
Author: Kirill Smelkov <kirr@mns.spb.ru>
Date:   Sun Jul 3 20:36:56 2011 +0400

    USB: EHCI: Move sysfs related bits into ehci-sysfs.c
    
    The only sysfs attr implemented so far is "companion" from ehci-hub.c,
    but in the next patch we are going to add another sysfs file, so prior
    to that let's structure things and move already-in-there sysfs code to
    separate file.
    
    NOTE: All the code I'm moving into this new file was written by Alan
    Stern (in 57e06c11 "EHCI: force high-speed devices to run at full
    speed"; Jan 16 2007), that's why I'm putting
    
        Copyright (C) 2007 by Alan Stern
    
    there after explicit request from the author.
    
    Signed-off-by: Kirill Smelkov <kirr@mns.spb.ru>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
new file mode 100644
index 000000000000..29824a98aec9
--- /dev/null
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2007 by Alan Stern
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* this file is part of ehci-hcd.c */
+
+
+/* Display the ports dedicated to the companion controller */
+static ssize_t show_companion(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct ehci_hcd		*ehci;
+	int			nports, index, n;
+	int			count = PAGE_SIZE;
+	char			*ptr = buf;
+
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	nports = HCS_N_PORTS(ehci->hcs_params);
+
+	for (index = 0; index < nports; ++index) {
+		if (test_bit(index, &ehci->companion_ports)) {
+			n = scnprintf(ptr, count, "%d\n", index + 1);
+			ptr += n;
+			count -= n;
+		}
+	}
+	return ptr - buf;
+}
+
+/*
+ * Dedicate or undedicate a port to the companion controller.
+ * Syntax is "[-]portnum", where a leading '-' sign means
+ * return control of the port to the EHCI controller.
+ */
+static ssize_t store_companion(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct ehci_hcd		*ehci;
+	int			portnum, new_owner;
+
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	new_owner = PORT_OWNER;		/* Owned by companion */
+	if (sscanf(buf, "%d", &portnum) != 1)
+		return -EINVAL;
+	if (portnum < 0) {
+		portnum = - portnum;
+		new_owner = 0;		/* Owned by EHCI */
+	}
+	if (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))
+		return -ENOENT;
+	portnum--;
+	if (new_owner)
+		set_bit(portnum, &ehci->companion_ports);
+	else
+		clear_bit(portnum, &ehci->companion_ports);
+	set_owner(ehci, portnum, new_owner);
+	return count;
+}
+static DEVICE_ATTR(companion, 0644, show_companion, store_companion);
+
+static inline int create_sysfs_files(struct ehci_hcd *ehci)
+{
+	int	i = 0;
+
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		i = device_create_file(ehci_to_hcd(ehci)->self.controller,
+				       &dev_attr_companion);
+	return i;
+}
+
+static inline void remove_sysfs_files(struct ehci_hcd *ehci)
+{
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		device_remove_file(ehci_to_hcd(ehci)->self.controller,
+				   &dev_attr_companion);
+}
