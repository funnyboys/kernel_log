commit a66d21d7dba84deeaf3b296c43eafc11094b6f09
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:38 2020 +0530

    usb: xhci: Add support for Renesas controller with memory
    
    Some rensas controller like uPD720201 and uPD720202 need firmware to be
    loaded. Add these devices in table and invoke renesas firmware loader
    functions to check and load the firmware into device memory when
    required.
    
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-4-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index b6c2f5c530e3..ef513c2fb843 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -15,6 +15,7 @@
 
 #include "xhci.h"
 #include "xhci-trace.h"
+#include "xhci-pci.h"
 
 #define SSIC_PORT_NUM		2
 #define SSIC_PORT_CFG2		0x880c
@@ -87,7 +88,16 @@ static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 
 static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 {
-	struct pci_dev		*pdev = to_pci_dev(dev);
+	struct pci_dev                  *pdev = to_pci_dev(dev);
+	struct xhci_driver_data         *driver_data;
+	const struct pci_device_id      *id;
+
+	id = pci_match_id(pdev->driver->id_table, pdev);
+
+	if (id && id->driver_data) {
+		driver_data = (struct xhci_driver_data *)id->driver_data;
+		xhci->quirks |= driver_data->quirks;
+	}
 
 	/* Look for vendor-specific quirks */
 	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
@@ -328,6 +338,14 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	int retval;
 	struct xhci_hcd *xhci;
 	struct usb_hcd *hcd;
+	struct xhci_driver_data *driver_data;
+
+	driver_data = (struct xhci_driver_data *)id->driver_data;
+	if (driver_data && driver_data->quirks & XHCI_RENESAS_FW_QUIRK) {
+		retval = renesas_xhci_check_request_fw(dev, id);
+		if (retval)
+			return retval;
+	}
 
 	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
 	pm_runtime_get_noresume(&dev->dev);
@@ -389,6 +407,9 @@ static void xhci_pci_remove(struct pci_dev *dev)
 	struct xhci_hcd *xhci;
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
+	if (xhci->quirks & XHCI_RENESAS_FW_QUIRK)
+		renesas_xhci_pci_exit(dev);
+
 	xhci->xhc_state |= XHCI_STATE_REMOVING;
 
 	if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)
@@ -540,14 +561,26 @@ static void xhci_pci_shutdown(struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+static const struct xhci_driver_data reneses_data = {
+	.quirks  = XHCI_RENESAS_FW_QUIRK,
+	.firmware = "renesas_usb_fw.mem",
+};
+
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids[] = {
+	{ PCI_DEVICE(0x1912, 0x0014),
+		.driver_data =  (unsigned long)&reneses_data,
+	},
+	{ PCI_DEVICE(0x1912, 0x0015),
+		.driver_data =  (unsigned long)&reneses_data,
+	},
 	/* handle any USB 3.0 xHCI controller */
 	{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
 	},
 	{ /* end: all zeroes */ }
 };
 MODULE_DEVICE_TABLE(pci, pci_ids);
+MODULE_FIRMWARE("renesas_usb_fw.mem");
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver xhci_pci_driver = {

commit ff4c65ca48f08f4781accfb1d224acd7c897070e
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:36 2020 +0530

    usb: hci: add hc_driver as argument for usb_hcd_pci_probe
    
    usb_hcd_pci_probe expects users to call this with driver_data set as
    hc_driver, that limits the possibility of using the driver_data for
    driver data.
    
    Add hc_driver as argument to usb_hcd_pci_probe and modify the callers
    ehci/ohci/xhci/uhci to pass hc_driver as argument and freeup the
    driver_data used
    
    Tested xhci driver on Dragon-board RB3, compile tested ehci, ohci and
    uhci.
    
    [For all but the xHCI parts]
    [For the xhci part]
    
    Suggested-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-2-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 766b74723e64..b6c2f5c530e3 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -327,11 +327,8 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	int retval;
 	struct xhci_hcd *xhci;
-	struct hc_driver *driver;
 	struct usb_hcd *hcd;
 
-	driver = (struct hc_driver *)id->driver_data;
-
 	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
 	pm_runtime_get_noresume(&dev->dev);
 
@@ -341,7 +338,7 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	 * to say USB 2.0, but I'm not sure what the implications would be in
 	 * the other parts of the HCD code.
 	 */
-	retval = usb_hcd_pci_probe(dev, id);
+	retval = usb_hcd_pci_probe(dev, id, &xhci_pci_hc_driver);
 
 	if (retval)
 		goto put_runtime_pm;
@@ -349,8 +346,8 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	/* USB 2.0 roothub is stored in the PCI device now. */
 	hcd = dev_get_drvdata(&dev->dev);
 	xhci = hcd_to_xhci(hcd);
-	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
-				pci_name(dev), hcd);
+	xhci->shared_hcd = usb_create_shared_hcd(&xhci_pci_hc_driver, &dev->dev,
+						 pci_name(dev), hcd);
 	if (!xhci->shared_hcd) {
 		retval = -ENOMEM;
 		goto dealloc_usb2_hcd;
@@ -544,10 +541,9 @@ static void xhci_pci_shutdown(struct usb_hcd *hcd)
 /*-------------------------------------------------------------------------*/
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id pci_ids[] = { {
+static const struct pci_device_id pci_ids[] = {
 	/* handle any USB 3.0 xHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
-	.driver_data =	(unsigned long) &xhci_pci_hc_driver,
+	{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
 	},
 	{ /* end: all zeroes */ }
 };

commit d2e971d884e7b7e65162788b8f3b7801cd8bc137
Merge: e79220db6349 16fbf79b0f83
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 23 08:04:08 2020 +0100

    Merge 5.6-rc7 into usb-next
    
    We need the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6a7c533d4a1854f54901a065d8c672e890400d8a
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Mar 12 16:45:17 2020 +0200

    xhci-pci: Allow host runtime PM as default for Intel Tiger Lake xHCI
    
    In the same way as Intel Ice Lake TCSS (Type-C Subsystem) the Tiger Lake
    TCSS xHCI needs to be runtime suspended whenever possible to allow the
    TCSS hardware block to enter D3cold and thus save energy.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312144517.1593-10-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index b98a1b54db56..b60f4afd4aef 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -50,6 +50,7 @@
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI		0x15f0
 #define PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI		0x8a13
 #define PCI_DEVICE_ID_INTEL_CML_XHCI			0xa3af
+#define PCI_DEVICE_ID_INTEL_TIGER_LAKE_XHCI		0x9a13
 
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
@@ -216,7 +217,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI ||
-	     pdev->device == PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI))
+	     pdev->device == PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_TIGER_LAKE_XHCI))
 		xhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;
 
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&

commit 2170a98d56cc86cef71134ac213aede2fdf64021
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Thu Mar 12 16:45:12 2020 +0200

    usb: xhci: Enable LPM for VIA LABS VL805
    
    This PCIe controller chip is used on the Raspberry Pi 4 and multiple
    adapter cards. There is no publicly available documentation for the
    chip, yet both the downstream RPi4 kernel and the controller cards
    support/advertise LPM support.
    
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312144517.1593-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 0715a2e75413..b98a1b54db56 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -243,6 +243,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == 0x3432)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 
+	if (pdev->vendor == PCI_VENDOR_ID_VIA && pdev->device == 0x3483)
+		xhci->quirks |= XHCI_LPM_SUPPORT;
+
 	if (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&
 			pdev->device == 0x1042)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;

commit 16263abc12d09871156a1c8650fb651f0e552f5e
Author: Alberto Mattea <alberto@mattea.info>
Date:   Fri Mar 6 17:08:58 2020 +0200

    usb: xhci: apply XHCI_SUSPEND_DELAY to AMD XHCI controller 1022:145c
    
    This controller timeouts during suspend (S3) with
    [  240.521724] xhci_hcd 0000:30:00.3: WARN: xHC save state timeout
    [  240.521729] xhci_hcd 0000:30:00.3: ERROR mismatched command completion event
    thus preventing the system from entering S3.
    Moreover it remains in an undefined state where some connected devices stop
    working until a reboot.
    Apply the XHCI_SUSPEND_DELAY quirk to make it suspend properly.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Alberto Mattea <alberto@mattea.info>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200306150858.21904-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 5e9b537df631..1fddc41fa1f3 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -136,7 +136,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
-		(pdev->device == 0x15e0 ||
+		(pdev->device == 0x145c ||
+		 pdev->device == 0x15e0 ||
 		 pdev->device == 0x15e1 ||
 		 pdev->device == 0x43bb))
 		xhci->quirks |= XHCI_SUSPEND_DELAY;

commit 24e6aea4801bae1dce3b16da6bc64fc06742ac14
Merge: 6bc3f3979edc f8788d86ab28
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 24 08:48:49 2020 +0100

    Merge 5.6-rc3 into usb-next
    
    We need the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c02f1ef68a7fba20346b1fa0791ce7012f0c12fb
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Tue Feb 18 19:33:02 2020 +0000

    usb: host: xhci-pci: remove useless cast for driver.name
    
    pci_driver name is const char pointer, so it not useful to cast
    hcd_name (which is already const char).
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Link: https://lore.kernel.org/r/1582054383-35760-20-git-send-email-clabbe@baylibre.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4917c5b033fa..4d3ea921dd14 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -547,7 +547,7 @@ MODULE_DEVICE_TABLE(pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver xhci_pci_driver = {
-	.name =		(char *) hcd_name,
+	.name =		hcd_name,
 	.id_table =	pci_ids,
 
 	.probe =	xhci_pci_probe,

commit a3ae87dce3a5abe0b57c811bab02b2564b574106
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Feb 10 15:45:53 2020 +0200

    xhci: apply XHCI_PME_STUCK_QUIRK to Intel Comet Lake platforms
    
    Intel Comet Lake based platform require the XHCI_PME_STUCK_QUIRK
    quirk as well. Without this xHC can not enter D3 in runtime suspend.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200210134553.9144-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index da7c2db41671..5e9b537df631 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -49,6 +49,7 @@
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI		0x15ec
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI		0x15f0
 #define PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI		0x8a13
+#define PCI_DEVICE_ID_INTEL_CML_XHCI			0xa3af
 
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
@@ -187,7 +188,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||
-		 pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI)) {
+		 pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_CML_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&

commit 024d411e9c5d49eb96c825af52a3ce2682895676
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Feb 10 15:45:52 2020 +0200

    xhci: fix runtime pm enabling for quirky Intel hosts
    
    Intel hosts that need the XHCI_PME_STUCK_QUIRK flag should enable
    runtime pm by calling xhci_pme_acpi_rtd3_enable() before
    usb_hcd_pci_probe() calls pci_dev_run_wake().
    Otherwise usage count for the device won't be decreased, and runtime
    suspend is prevented.
    
    usb_hcd_pci_probe() only decreases the usage count if device can
    generate run-time wake-up events, i.e. when pci_dev_run_wake()
    returns true.
    
    This issue was exposed by pci_dev_run_wake() change in
    commit 8feaec33b986 ("PCI / PM: Always check PME wakeup capability for
    runtime wakeup support")
    and should be backported to kernels with that change
    
    Cc: <stable@vger.kernel.org> # 4.13+
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200210134553.9144-4-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4917c5b033fa..da7c2db41671 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -302,6 +302,9 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (!usb_hcd_is_primary_hcd(hcd))
 		return 0;
 
+	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
+		xhci_pme_acpi_rtd3_enable(pdev);
+
 	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
 
 	/* Find any debug ports */
@@ -359,9 +362,6 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 			HCC_MAX_PSA(xhci->hcc_params) >= 4)
 		xhci->shared_hcd->can_do_streams = 1;
 
-	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
-		xhci_pme_acpi_rtd3_enable(dev);
-
 	/* USB-2 and USB-3 roothubs initialized, allow runtime pm suspend */
 	pm_runtime_put_noidle(&dev->dev);
 

commit 6056a0f8ede27b296d10ef46f7f677cc9d715371
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Dec 17 17:19:11 2019 -0800

    usb: xhci: Fix build warning seen with CONFIG_PM=n
    
    The following build warning is seen if CONFIG_PM is disabled.
    
    drivers/usb/host/xhci-pci.c:498:13: warning:
            unused function 'xhci_pci_shutdown'
    
    Fixes: f2c710f7dca8 ("usb: xhci: only set D3hot for pci device")
    Cc: Henry Lin <henryl@nvidia.com>
    Cc: stable@vger.kernel.org      # all stable releases with f2c710f7dca8
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191218011911.6907-1-linux@roeck-us.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 2907fe4d78dd..4917c5b033fa 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -519,7 +519,6 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	retval = xhci_resume(xhci, hibernated);
 	return retval;
 }
-#endif /* CONFIG_PM */
 
 static void xhci_pci_shutdown(struct usb_hcd *hcd)
 {
@@ -532,6 +531,7 @@ static void xhci_pci_shutdown(struct usb_hcd *hcd)
 	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(pdev, PCI_D3hot);
 }
+#endif /* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
 

commit f2c710f7dca8457e88b4ac9de2060f011254f9dd
Author: Henry Lin <henryl@nvidia.com>
Date:   Wed Dec 11 16:20:04 2019 +0200

    usb: xhci: only set D3hot for pci device
    
    Xhci driver cannot call pci_set_power_state() on non-pci xhci host
    controllers. For example, NVIDIA Tegra XHCI host controller which acts
    as platform device with XHCI_SPURIOUS_WAKEUP quirk set in some platform
    hits this issue during shutdown.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 638298dc66ea ("xhci: Fix spurious wakeups after S5 on Haswell")
    Signed-off-by: Henry Lin <henryl@nvidia.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-4-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index a0025d23b257..2907fe4d78dd 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -521,6 +521,18 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 }
 #endif /* CONFIG_PM */
 
+static void xhci_pci_shutdown(struct usb_hcd *hcd)
+{
+	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+
+	xhci_shutdown(hcd);
+
+	/* Yet another workaround for spurious wakeups at shutdown with HSW */
+	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
+		pci_set_power_state(pdev, PCI_D3hot);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
@@ -556,6 +568,7 @@ static int __init xhci_pci_init(void)
 #ifdef CONFIG_PM
 	xhci_pci_hc_driver.pci_suspend = xhci_pci_suspend;
 	xhci_pci_hc_driver.pci_resume = xhci_pci_resume;
+	xhci_pci_hc_driver.shutdown = xhci_pci_shutdown;
 #endif
 	return pci_register_driver(&xhci_pci_driver);
 }

commit 07a594f353655b1628f598add352e7e754f44869
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Nov 15 18:50:03 2019 +0200

    xhci-pci: Allow host runtime PM as default also for Intel Ice Lake xHCI
    
    Intel Ice Lake has two xHCI controllers one on PCH and the other as part
    of the CPU itself. The latter is also part of the so called Type C
    Subsystem (TCSS) sharing ACPI power resources with the PCIe root ports
    and the Thunderbolt controllers. In order to put the whole TCSS block
    into D3cold the xHCI needs to be runtime suspended as well when idle.
    
    For this reason allow runtime PM as default for Ice Lake TCSS xHCI
    controller.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/1573836603-10871-5-git-send-email-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1e0236e90687..a0025d23b257 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -48,6 +48,7 @@
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI		0x15e9
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI		0x15ec
 #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI		0x15f0
+#define PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI		0x8a13
 
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
@@ -212,7 +213,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI ||
-	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI))
+	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI))
 		xhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;
 
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&

commit 4fbb8aa75836c3361987f431d9451aecc1830bdd
Author: Ryan Kennedy <ryan5544@gmail.com>
Date:   Thu Jul 4 11:35:29 2019 -0400

    usb: pci-quirks: Minor cleanup for AMD PLL quirk
    
    usb_amd_find_chipset_info() is used for chipset detection for
    several quirks. It is strange that its return value indicates
    the need for the PLL quirk, which means it is often ignored.
    This patch adds a function specifically for checking the PLL
    quirk like the other ones. Additionally, rename probe_result to
    something more appropriate.
    
    Signed-off-by: Ryan Kennedy <ryan5544@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20190704153529.9429-3-ryan5544@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c2fe218e051f..1e0236e90687 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -130,7 +130,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_AMD_0x96_HOST;
 
 	/* AMD PLL quirk */
-	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
+	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_quirk_pll_check())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&

commit 8fde481ef3674ae5ad0dbfef4df18ff507c5675a
Author: Balaji Manoharan <m.balaji@intel.com>
Date:   Wed Feb 20 19:50:53 2019 +0200

    usb: xhci: Fix for Enabling USB ROLE SWITCH QUIRK on INTEL_SUNRISEPOINT_LP_XHCI
    
    This fix enables USB role feature on intel commercial nuc
    platform which is based on Kabylake chipset.
    
    Signed-off-by: Balaji Manoharan <m.balaji@intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index a9ec7051f286..c2fe218e051f 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -194,6 +194,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_SSIC_PORT_UNUSED;
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI))
 		xhci->quirks |= XHCI_INTEL_USB_ROLE_SW;
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&

commit a7d57abcc8a5bdeb53bbf8e87558e8e0a2c2a29d
Author: Sandeep Singh <sandeep.singh@amd.com>
Date:   Wed Dec 5 14:22:38 2018 +0200

    xhci: workaround CSS timeout on AMD SNPS 3.0 xHC
    
    Occasionally AMD SNPS 3.0 xHC does not respond to
    CSS when set, also it does not flag anything on SRE and HCE
    to point the internal xHC errors on USBSTS register. This stalls
    the entire system wide suspend and there is no point in stalling
    just because of xHC CSS is not responding.
    
    To work around this problem, if the xHC does not flag
    anything on SRE and HCE, we can skip the CSS
    timeout and allow the system to continue the suspend. Once the
    system resume happens we can internally reset the controller
    using XHCI_RESET_ON_RESUME quirk
    
    Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Sandeep Singh <Sandeep.Singh@amd.com>
    cc: Nehal Shah <Nehal-bakulchandra.Shah@amd.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index a9515265db4d..a9ec7051f286 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -139,6 +139,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == 0x43bb))
 		xhci->quirks |= XHCI_SUSPEND_DELAY;
 
+	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
+	    (pdev->device == 0x15e0 || pdev->device == 0x15e1))
+		xhci->quirks |= XHCI_SNPS_BROKEN_SUSPEND;
+
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 

commit 11644a7659529730eaf2f166efaabe7c3dc7af8c
Author: Cherian, George <George.Cherian@cavium.com>
Date:   Fri Nov 9 17:21:22 2018 +0200

    xhci: Add quirk to workaround the errata seen on Cavium Thunder-X2 Soc
    
    Implement workaround for ThunderX2 Errata-129 (documented in
    CN99XX Known Issues" available at Cavium support site).
    As per ThunderX2errata-129, USB 2 device may come up as USB 1
    if a connection to a USB 1 device is followed by another connection to
    a USB 2 device, the link will come up as USB 1 for the USB 2 device.
    
    Resolution: Reset the PHY after the USB 1 device is disconnected.
    The PHY reset sequence is done using private registers in XHCI register
    space. After the PHY is reset we check for the PLL lock status and retry
    the operation if it fails. From our tests, retrying 4 times is sufficient.
    
    Add a new quirk flag XHCI_RESET_PLL_ON_DISCONNECT to invoke the workaround
    in handle_xhci_port_status().
    
    Cc: stable@vger.kernel.org
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1fb448cd2667..a9515265db4d 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -248,6 +248,11 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241)
 		xhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;
 
+	if ((pdev->vendor == PCI_VENDOR_ID_BROADCOM ||
+	     pdev->vendor == PCI_VENDOR_ID_CAVIUM) &&
+	     pdev->device == 0x9026)
+		xhci->quirks |= XHCI_RESET_PLL_ON_DISCONNECT;
+
 	if (xhci->quirks & XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				"QUIRK: Resetting on resume");

commit f068090426ea8d72c408ebd42953a82a88e2282c
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Nov 9 17:21:17 2018 +0200

    xhci: Fix leaking USB3 shared_hcd at xhci removal
    
    Ensure that the shared_hcd pointer is valid when calling usb_put_hcd()
    
    The shared_hcd is removed and freed in xhci by first calling
    usb_remove_hcd(xhci->shared_hcd), and later
    usb_put_hcd(xhci->shared_hcd)
    
    Afer commit fe190ed0d602 ("xhci: Do not halt the host until both HCD have
    disconnected their devices.") the shared_hcd was never properly put as
    xhci->shared_hcd was set to NULL before usb_put_hcd(xhci->shared_hcd) was
    called.
    
    shared_hcd (USB3) is removed before primary hcd (USB2).
    While removing the primary hcd we might need to handle xhci interrupts
    to cleanly remove last USB2 devices, therefore we need to set
    xhci->shared_hcd to NULL before removing the primary hcd to let xhci
    interrupt handler know shared_hcd is no longer available.
    
    xhci-plat.c, xhci-histb.c and xhci-mtk first create both their hcd's before
    adding them. so to keep the correct reverse removal order use a temporary
    shared_hcd variable for them.
    For more details see commit 4ac53087d6d4 ("usb: xhci: plat: Create both
    HCDs before adding them")
    
    Fixes: fe190ed0d602 ("xhci: Do not halt the host until both HCD have disconnected their devices.")
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Jianguo Sun <sunjianguo1@huawei.com>
    Cc: <stable@vger.kernel.org>
    Reported-by: Jack Pham <jackp@codeaurora.org>
    Tested-by: Jack Pham <jackp@codeaurora.org>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 01c57055c0c5..1fb448cd2667 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -380,6 +380,7 @@ static void xhci_pci_remove(struct pci_dev *dev)
 	if (xhci->shared_hcd) {
 		usb_remove_hcd(xhci->shared_hcd);
 		usb_put_hcd(xhci->shared_hcd);
+		xhci->shared_hcd = NULL;
 	}
 
 	/* Workaround for spurious wakeups at shutdown with HSW */

commit 9703fc8caf36ac65dca1538b23dd137de0b53233
Merge: da19a102ce87 b8d9ee24493d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 26 08:14:13 2018 -0700

    Merge tag 'usb-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB/PHY updates from Greg KH:
     "Here is the big USB/PHY driver patches for 4.20-rc1
    
      Lots of USB changes in here, primarily in these areas:
    
       - typec updates and new drivers
    
       - new PHY drivers
    
       - dwc2 driver updates and additions (this old core keeps getting
         added to new devices.)
    
       - usbtmc major update based on the industry group coming together and
         working to add new features and performance to the driver.
    
       - USB gadget additions for new features
    
       - USB gadget configfs updates
    
       - chipidea driver updates
    
       - other USB gadget updates
    
       - USB serial driver updates
    
       - renesas driver updates
    
       - xhci driver updates
    
       - other tiny USB driver updates
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'usb-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (229 commits)
      usb: phy: ab8500: silence some uninitialized variable warnings
      usb: xhci: tegra: Add genpd support
      usb: xhci: tegra: Power-off power-domains on removal
      usbip:vudc: BUG kmalloc-2048 (Not tainted): Poison overwritten
      usbip: tools: fix atoi() on non-null terminated string
      USB: misc: appledisplay: fix backlight update_status return code
      phy: phy-pxa-usb: add a new driver
      usb: host: add DT bindings for faraday fotg2
      usb: host: ohci-at91: fix request of irq for optional gpio
      usb/early: remove set but not used variable 'remain_length'
      usb: typec: Fix copy/paste on typec_set_vconn_role() kerneldoc
      usb: typec: tcpm: Report back negotiated PPS voltage and current
      USB: core: remove set but not used variable 'udev'
      usb: core: fix memory leak on port_dev_path allocation
      USB: net2280: Remove ->disconnect() callback from net2280_pullup()
      usb: dwc2: disable power_down on rockchip devices
      usb: gadget: udc: renesas_usb3: add support for r8a77990
      dt-bindings: usb: renesas_usb3: add bindings for r8a77990
      usb: gadget: udc: renesas_usb3: Add r8a774a1 support
      USB: serial: cypress_m8: remove set but not used variable 'iflag'
      ...

commit c02588a352defaf985fc1816eb6232663159e1b8
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Oct 1 18:53:05 2018 +0300

    usb: xhci: pci: Enable Intel USB role mux on Apollo Lake platforms
    
    Intel Apollo Lake has the same internal USB role mux as
    Intel Cherry Trail.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 722860eb5a91..51dd8e00c4f8 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -179,10 +179,12 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
+	    pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)
 		xhci->quirks |= XHCI_SSIC_PORT_UNUSED;
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI))
 		xhci->quirks |= XHCI_INTEL_USB_ROLE_SW;
-	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||

commit 8aff4eaa1de7a0ba70af8447ed08127ef0e8e45d
Merge: e7a2c3fa2857 0238df646e62
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 8 15:40:42 2018 +0200

    Merge 4.19-rc7 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ffe84e01bb1b38c7eb9c6b6da127a6c136d251df
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Oct 1 18:36:07 2018 +0300

    xhci: Add missing CAS workaround for Intel Sunrise Point xHCI
    
    The workaround for missing CAS bit is also needed for xHC on Intel
    sunrisepoint PCH. For more details see:
    
    Intel 100/c230 series PCH specification update Doc #332692-006 Errata #8
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 6372edf339d9..722860eb5a91 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -185,6 +185,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI))
 		xhci->quirks |= XHCI_MISSING_CAS;

commit 2815ef7fe4d43072b9eda448d04fbc184f2aa513
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Sep 20 19:13:38 2018 +0300

    xhci-pci: allow host runtime PM as default for Intel Alpine and Titan Ridge
    
    The xhci controller on Alpine and Titan Ridge keeps the whole thunderbolt
    awake if the host controller is not allowed tp sleep.
    This is the case even if no USB devices are connected to the host.
    
    Because of this bigger impact, allow runtime pm as default for these xhci
    controllers in the driver.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 6372edf339d9..9433e70aeeb0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -41,6 +41,13 @@
 #define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_XHCI	0x15b5
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_XHCI	0x15b6
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_XHCI	0x15db
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_XHCI	0x15d4
+#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI		0x15e9
+#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI		0x15ec
+#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI		0x15f0
 
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
@@ -189,6 +196,16 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	     pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI))
 		xhci->quirks |= XHCI_MISSING_CAS;
 
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI))
+		xhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;
+
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_EJ168) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
@@ -332,6 +349,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	/* USB-2 and USB-3 roothubs initialized, allow runtime pm suspend */
 	pm_runtime_put_noidle(&dev->dev);
 
+	if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)
+		pm_runtime_allow(&dev->dev);
+
 	return 0;
 
 put_usb3_hcd:
@@ -349,6 +369,10 @@ static void xhci_pci_remove(struct pci_dev *dev)
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
 	xhci->xhc_state |= XHCI_STATE_REMOVING;
+
+	if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)
+		pm_runtime_forbid(&dev->dev);
+
 	if (xhci->shared_hcd) {
 		usb_remove_hcd(xhci->shared_hcd);
 		usb_put_hcd(xhci->shared_hcd);

commit c2ef60fea2dc7f903450926aee1f9c282ea529ca
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed May 23 18:41:38 2018 +0100

    Revert "xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue"
    
    This reverts commit 8466489ef5ba48272ba4fa4ea9f8f403306de4c7.
    
    Now that we can properly reset the uPD72020x without a hard PCI reset,
    let's get rid of the existing quirks.
    
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e0a0a12871e2..6372edf339d9 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -288,13 +288,6 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	driver = (struct hc_driver *)id->driver_data;
 
-	/* For some HW implementation, a XHCI reset is just not enough... */
-	if (usb_xhci_needs_pci_reset(dev)) {
-		dev_info(&dev->dev, "Resetting\n");
-		if (pci_reset_function_locked(dev))
-			dev_warn(&dev->dev, "Reset failed");
-	}
-
 	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
 	pm_runtime_get_noresume(&dev->dev);
 

commit 12de0a35c996c3a75d050bff748815db3432849c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed May 23 18:41:37 2018 +0100

    xhci: Add quirk to zero 64bit registers on Renesas PCIe controllers
    
    Some Renesas controllers get into a weird state if they are reset while
    programmed with 64bit addresses (they will preserve the top half of the
    address in internal, non visible registers).
    
    You end up with half the address coming from the kernel, and the other
    half coming from the firmware.
    
    Also, changing the programming leads to extra accesses even if the
    controller is supposed to be halted. The controller ends up with a fatal
    fault, and is then ripe for being properly reset. On the flip side,
    this is completely unsafe if the defvice isn't behind an IOMMU, so
    we have to make sure that this is the case. Can you say "broken"?
    
    This is an alternative method to the one introduced in 8466489ef5ba
    ("xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue"),
    which will subsequently be removed.
    
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 85ffda85f8ab..e0a0a12871e2 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -196,11 +196,15 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-			pdev->device == 0x0014)
+	    pdev->device == 0x0014) {
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
+		xhci->quirks |= XHCI_ZERO_64B_REGS;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-			pdev->device == 0x0015)
+	    pdev->device == 0x0015) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
+		xhci->quirks |= XHCI_ZERO_64B_REGS;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 

commit 621faf4f6a181b6e012c1d1865213f36f4159b7f
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Apr 20 16:52:50 2018 +0300

    xhci: Fix USB ports for Dell Inspiron 5775
    
    The Dell Inspiron 5775 is a Raven Ridge. The Enable Slot command timed
    out when a USB device gets plugged:
    [ 212.156326] xhci_hcd 0000:03:00.3: Error while assigning device slot ID
    [ 212.156340] xhci_hcd 0000:03:00.3: Max number of devices this xHCI host supports is 64.
    [ 212.156348] usb usb2-port3: couldn't allocate usb_device
    
    AMD suggests that a delay before xHC suspends can fix the issue.
    
    I can confirm it fixes the issue, so use the suspend delay quirk for
    Raven Ridge's xHC.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index f17b7eab66cf..85ffda85f8ab 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -126,7 +126,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
 
-	if (pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x43bb)
+	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
+		(pdev->device == 0x15e0 ||
+		 pdev->device == 0x15e1 ||
+		 pdev->device == 0x43bb))
 		xhci->quirks |= XHCI_SUSPEND_DELAY;
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)

commit fa31b3cb2ae143aa6e26974fcbe75689da60bdbe
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Mar 20 15:57:09 2018 +0300

    xhci: Add Intel extended cap / otg phy mux handling
    
    The xHCI controller on various Intel SoCs has an extended cap mmio-range
    which contains registers to control the muxing to the xHCI (host mode)
    or the dwc3 (device mode) and vbus-detection for the otg usb-phy.
    
    Having a role-sw driver included in the xHCI code (under drivers/usb/host)
    is not desirable. So this commit adds a simple handler for this extended
    capability, which creates a platform device with the caps mmio region as
    resource, this allows us to write a separate platform role-sw driver for
    the role-switch.
    
    Note this commit adds a call to the new xhci_ext_cap_init() function
    to xhci_pci_probe(), it is added here because xhci_ext_cap_init() must
    be called only once. If in the future we also want to handle ext-caps
    on non pci xHCI HCDs from xhci_ext_cap_init() a call to it should also
    be added to other bus probe paths.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index d9f831b67e57..f17b7eab66cf 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -178,6 +178,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 		xhci->quirks |= XHCI_SSIC_PORT_UNUSED;
+		xhci->quirks |= XHCI_INTEL_USB_ROLE_SW;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
@@ -311,6 +312,10 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto dealloc_usb2_hcd;
 	}
 
+	retval = xhci_ext_cap_init(xhci);
+	if (retval)
+		goto put_usb3_hcd;
+
 	retval = usb_add_hcd(xhci->shared_hcd, dev->irq,
 			IRQF_SHARED);
 	if (retval)

commit 191edc5e2e515aab1075a3f0ef23599e80be5f59
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Thu Mar 8 17:17:17 2018 +0200

    xhci: Fix front USB ports on ASUS PRIME B350M-A
    
    When a USB device gets plugged on ASUS PRIME B350M-A's front ports, the
    xHC stops working:
    [  549.114587] xhci_hcd 0000:02:00.0: WARN: xHC CMD_RUN timeout
    [  549.114608] suspend_common(): xhci_pci_suspend+0x0/0xc0 returns -110
    [  549.114638] xhci_hcd 0000:02:00.0: can't suspend (hcd_pci_runtime_suspend returned -110)
    
    Delay before running xHC command CMD_RUN can workaround the issue.
    
    Use a new quirk to make the delay only targets to the affected xHC.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 5262fa571a5d..d9f831b67e57 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -126,6 +126,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
 
+	if (pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x43bb)
+		xhci->quirks |= XHCI_SUSPEND_DELAY;
+
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 

commit bde0716d1f076e4c913c7946bcc858f71243c7a0
Author: Joe Lee <asmt.swfae@gmail.com>
Date:   Mon Feb 12 14:24:46 2018 +0200

    xhci: workaround for AMD Promontory disabled ports wakeup
    
    For AMD Promontory xHCI host, although you can disable USB ports in
    BIOS settings, those ports will be enabled anyway after you remove a
    device on that port and re-plug it in again. It's a known limitation of
    the chip. As a workaround we can clear the PORT_WAKE_BITS.
    
    [commit and code comment rephrasing -Mathias]
    Signed-off-by: Joe Lee <asmt.swfae@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 6c79037876db..5262fa571a5d 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -42,6 +42,10 @@
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc
 #define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI		0x1142
 
 static const char hcd_name[] = "xhci_hcd";
@@ -125,6 +129,13 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 
+	if ((pdev->vendor == PCI_VENDOR_ID_AMD) &&
+		((pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))
+		xhci->quirks |= XHCI_U2_DISABLE_WAKE;
+
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;

commit 01f1918833e4817fdb0810306c021c5cbee775d3
Merge: 3df613ec12f7 30a7acd57389
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 2 15:13:41 2018 +0100

    Merge 4.15.0-rc6 into usb-next
    
    We want the USB fixes in here, and this resolves a merge issue with the
    vhci_rx.c file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit da99706689481717998d1d48edd389f339eea979
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Thu Dec 21 15:06:15 2017 +0200

    usb: xhci: Add XHCI_TRUST_TX_LENGTH for Renesas uPD720201
    
    When plugging in a USB webcam I see the following message:
    xhci_hcd 0000:04:00.0: WARN Successful completion on short TX: needs
    XHCI_TRUST_TX_LENGTH quirk?
    handle_tx_event: 913 callbacks suppressed
    
    All is quiet again with this patch (and I've done a fair but of soak
    testing with the camera since).
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7ef1274ef7f7..1aad89b8aba0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -177,6 +177,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
+			pdev->device == 0x0014)
+		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
 			pdev->device == 0x0015)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;

commit ab725cbec3e83dc29cc00b733bd26063b588fa98
Author: Adam Wallis <awallis@codeaurora.org>
Date:   Fri Dec 8 17:59:13 2017 +0200

    usb: xhci: allow imod-interval to be configurable
    
    The xHCI driver currently has the IMOD set to 160, which
    translates to an IMOD interval of 40,000ns (160 * 250)ns
    
    Commit 0cbd4b34cda9 ("xhci: mediatek: support MTK xHCI host controller")
    introduced a QUIRK for the MTK platform to adjust this interval to 20,
    which translates to an IMOD interval of 5,000ns (20 * 250)ns. This is
    due to the fact that the MTK controller IMOD interval is 8 times
    as much as defined in xHCI spec.
    
    Instead of adding more quirk bits for additional platforms, this patch
    introduces the ability for vendors to set the IMOD_INTERVAL as is
    optimal for their platform. By using device_property_read_u32() on
    "imod-interval-ns", the IMOD INTERVAL can be specified in nano seconds.
    If no interval is specified, the default of 40,000ns (IMOD=160) will be
    used.
    
    No bounds checking has been implemented due to the fact that a vendor
    may have violated the spec and would need to specify a value outside of
    the max 8,000 IRQs/second limit specified in the xHCI spec.
    
    Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Adam Wallis <awallis@codeaurora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7ef1274ef7f7..4bcddd424a07 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -234,6 +234,9 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (!xhci->sbrn)
 		pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
 
+	/* imod_interval is the interrupt moderation value in nanoseconds. */
+	xhci->imod_interval = 40000;
+
 	retval = xhci_gen_setup(hcd, xhci_pci_quirks);
 	if (retval)
 		return retval;

commit 9ed64195e35efa8901d20a0cd8ff3668ae68e7d6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:23 2017 +0100

    USB: host: xhci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4281bbee0544..7ef1274ef7f7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -6,19 +6,6 @@
  *
  * Author: Sarah Sharp
  * Some code borrowed from the Linux EHCI driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/pci.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 76f392954733..4281bbee0544 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * xHCI host controller driver PCI Bus Glue.
  *

commit bcd6a7aa13800afc1418e6b29d944d882214939a
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Sep 18 17:39:19 2017 +0300

    Revert "xhci: Limit USB2 port wake support for AMD Promontory hosts"
    
    This reverts commit dec08194ffeccfa1cf085906b53d301930eae18f.
    
    Commit dec08194ffec ("xhci: Limit USB2 port wake support for AMD Promontory
    hosts") makes all high speed USB ports on ASUS PRIME B350M-A cease to
    function after enabling runtime PM.
    
    All boards with this chipsets will be affected, so revert the commit.
    
    The original patch was added to stable 4.9, 4.11 and 4.12 and needs
    to reverted from there as well
    
    Cc: <stable@vger.kernel.org> # 4.9+
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 8071c8fdd15e..76f392954733 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -54,11 +54,6 @@
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
-#define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
-#define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
-#define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb
-#define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc
-
 #define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI		0x1142
 
 static const char hcd_name[] = "xhci_hcd";
@@ -142,13 +137,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 
-	if ((pdev->vendor == PCI_VENDOR_ID_AMD) &&
-		((pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||
-		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||
-		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||
-		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))
-		xhci->quirks |= XHCI_U2_DISABLE_WAKE;
-
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;

commit 8466489ef5ba48272ba4fa4ea9f8f403306de4c7
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Aug 1 20:11:08 2017 -0500

    xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue
    
    The Renesas uPD72020x XHCI controller seems to suffer from a really
    annoying bug, where it may retain some of its DMA programming across a XHCI
    reset, and despite the driver correctly programming new DMA addresses.
    This is visible if the device has been using 64-bit DMA addresses, and is
    then switched to using 32-bit DMA addresses.  The top 32 bits of the
    address (now zero) are ignored are replaced by the 32 bits from the
    *previous* programming.  Sticking with 64-bit DMA always works, but doesn't
    seem very appropriate.
    
    A PCI reset of the device restores the normal functionality, which is done
    at probe time.  Unfortunately, this has to be done before any quirk has
    been discovered, hence the intrusive nature of the fix.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    CC: stable@vger.kernel.org      # v4.11+

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 5b0fa553c8bc..8071c8fdd15e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -284,6 +284,13 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	driver = (struct hc_driver *)id->driver_data;
 
+	/* For some HW implementation, a XHCI reset is just not enough... */
+	if (usb_xhci_needs_pci_reset(dev)) {
+		dev_info(&dev->dev, "Resetting\n");
+		if (pci_reset_function_locked(dev))
+			dev_warn(&dev->dev, "Reset failed");
+	}
+
 	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
 	pm_runtime_get_noresume(&dev->dev);
 

commit 9da5a1092b13468839b1a864b126cacfb72ad016
Author: Jiahau Chang <jiahau@gmail.com>
Date:   Thu Jul 20 14:48:27 2017 +0300

    xhci: Bad Ethernet performance plugged in ASM1042A host
    
    When USB Ethernet is plugged in ASMEDIA ASM1042A xHCI host, bad
    performance was manifesting in Web browser use (like download
    large file such as ISO image). It is known limitation of
    ASM1042A that is not compatible with driver scheduling,
    As a workaround we can modify flow control handling of ASM1042A.
    The register we modify is changes the behavior
    
    [use quirk bit 28, usleep_range 40-60us, empty non-pci function -Mathias]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Jiahau Chang <Lars_chang@asmedia.com.tw>
    Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 53882e2babbb..5b0fa553c8bc 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -59,6 +59,8 @@
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc
 
+#define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI		0x1142
+
 static const char hcd_name[] = "xhci_hcd";
 
 static struct hc_driver __read_mostly xhci_pci_hc_driver;
@@ -217,6 +219,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == 0x1142)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 
+	if (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&
+		pdev->device == PCI_DEVICE_ID_ASMEDIA_1042A_XHCI)
+		xhci->quirks |= XHCI_ASMEDIA_MODIFY_FLOWCONTROL;
+
 	if (pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241)
 		xhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;
 

commit 6481352082e8c373a005387c4fc7258b197f0bc9
Merge: df7cb187edc7 dec08194ffec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 13:42:04 2017 -0700

    Merge tag 'usb-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB fixes from Greg KH:
     "Here are some remaining USB fixes for 4.13-rc1. They were originally
      scheduled for 4.12-final, but I didn't send them to you in time.
      Because of that, they were in a separate branch from the larger USB
      set of patches, so here they are in a separate pull request.
    
      Nothing major here a all, just three small patches:
    
       - some usb-serial new device ids
       - xhci bugfix for some crazy AMD hardware
    
      All of these have been in linux-next for a long time with no reported
      issues"
    
    * tag 'usb-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb:
      xhci: Limit USB2 port wake support for AMD Promontory hosts
      USB: serial: qcserial: new Sierra Wireless EM7305 device ID
      USB: serial: option: add two Longcheer device ids

commit 81e3e044897b0875a52953b3fb6241a33428e4f9
Merge: 6f7da290413b b86a496a4206
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 09:55:26 2017 -0700

    Merge tag 'uuid-for-4.13' of git://git.infradead.org/users/hch/uuid
    
    Pull uuid subsystem from Christoph Hellwig:
     "This is the new uuid subsystem, in which Amir, Andy and I have started
      consolidating our uuid/guid helpers and improving the types used for
      them. Note that various other subsystems have pulled in this tree, so
      I'd like it to go in early.
    
      UUID/GUID summary:
    
       - introduce the new uuid_t/guid_t types that are going to replace the
         somewhat confusing uuid_be/uuid_le types and make the terminology
         fit the various specs, as well as the userspace libuuid library.
         (me, based on a previous version from Amir)
    
       - consolidated generic uuid/guid helper functions lifted from XFS and
         libnvdimm (Amir and me)
    
       - conversions to the new types and helpers (Amir, Andy and me)"
    
    * tag 'uuid-for-4.13' of git://git.infradead.org/users/hch/uuid: (34 commits)
      ACPI: hns_dsaf_acpi_dsm_guid can be static
      mmc: sdhci-pci: make guid intel_dsm_guid static
      uuid: Take const on input of uuid_is_null() and guid_is_null()
      thermal: int340x_thermal: fix compile after the UUID API switch
      thermal: int340x_thermal: Switch to use new generic UUID API
      acpi: always include uuid.h
      ACPI: Switch to use generic guid_t in acpi_evaluate_dsm()
      ACPI / extlog: Switch to use new generic UUID API
      ACPI / bus: Switch to use new generic UUID API
      ACPI / APEI: Switch to use new generic UUID API
      acpi, nfit: Switch to use new generic UUID API
      MAINTAINERS: add uuid entry
      tmpfs: generate random sb->s_uuid
      scsi_debug: switch to uuid_t
      nvme: switch to uuid_t
      sysctl: switch to use uuid_t
      partitions/ldm: switch to use uuid_t
      overlayfs: use uuid_t instead of uuid_be
      fs: switch ->s_uuid to uuid_t
      ima/policy: switch to use uuid_t
      ...

commit dec08194ffeccfa1cf085906b53d301930eae18f
Author: Jiahau Chang <jiahau@gmail.com>
Date:   Mon Jun 19 13:08:30 2017 +0300

    xhci: Limit USB2 port wake support for AMD Promontory hosts
    
    For AMD Promontory xHCI host, although you can disable USB 2.0 ports in
    BIOS settings, those ports will be enabled anyway after you remove a
    device on that port and re-plug it in again. It's a known limitation of
    the chip. As a workaround we can clear the PORT_WAKE_BITS.
    
    This will disable wake on connect, disconnect and overcurrent on
    AMD Promontory USB2 ports
    
    [checkpatch cleanup and commit message reword -Mathias]
    Cc: <stable@vger.kernel.org>
    Cc: Tsai Nicholas <nicholas.tsai@amd.com>
    Signed-off-by: Jiahau Chang <Lars_Chang@asmedia.com.tw>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1bcf971141c0..0965bae95a7b 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -54,6 +54,11 @@
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 #define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_4			0x43b9
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_3			0x43ba
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb
+#define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc
+
 static const char hcd_name[] = "xhci_hcd";
 
 static struct hc_driver __read_mostly xhci_pci_hc_driver;
@@ -135,6 +140,13 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 
+	if ((pdev->vendor == PCI_VENDOR_ID_AMD) &&
+		((pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||
+		(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))
+		xhci->quirks |= XHCI_U2_DISABLE_WAKE;
+
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;

commit d2f48f05cd2a2a0a708fbfa45f1a00a87660d937
Author: Corentin Labbe <clabbe.montjoie@gmail.com>
Date:   Fri Jun 9 14:48:41 2017 +0300

    usb: xhci: ASMedia ASM1042A chipset need shorts TX quirk
    
    When plugging an USB webcam I see the following message:
    [106385.615559] xhci_hcd 0000:04:00.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [106390.583860] handle_tx_event: 913 callbacks suppressed
    
    With this patch applied, I get no more printing of this message.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index fcf1f3f63e7a..1bcf971141c0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -201,6 +201,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&
 			pdev->device == 0x1042)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
+	if (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&
+			pdev->device == 0x1142)
+		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 
 	if (pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241)
 		xhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;

commit 94116f8126de9762751fd92731581b73b56292e5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:46 2017 +0300

    ACPI: Switch to use generic guid_t in acpi_evaluate_dsm()
    
    acpi_evaluate_dsm() and friends take a pointer to a raw buffer of 16
    bytes. Instead we convert them to use guid_t type. At the same time we
    convert current users.
    
    acpi_str_to_uuid() becomes useless after the conversion and it's safe to
    get rid of it.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index fcf1f3f63e7a..4842be5687a7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -213,13 +213,12 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 #ifdef CONFIG_ACPI
 static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)
 {
-	static const u8 intel_dsm_uuid[] = {
-		0xb7, 0x0c, 0x34, 0xac,	0x01, 0xe9, 0xbf, 0x45,
-		0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23,
-	};
+	static const guid_t intel_dsm_guid =
+		GUID_INIT(0xac340cb7, 0xe901, 0x45bf,
+			  0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23);
 	union acpi_object *obj;
 
-	obj = acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), intel_dsm_uuid, 3, 1,
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), &intel_dsm_guid, 3, 1,
 				NULL);
 	ACPI_FREE(obj);
 }

commit a0c16630d35a874e82bdf2088f58ecaca1024315
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Wed May 17 18:32:00 2017 +0300

    xhci: apply PME_STUCK_QUIRK and MISSING_CAS quirk for Denverton
    
    Intel Denverton microserver is Atom based and need the PME and CAS quirks
    as well.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7b86508ac8cf..fcf1f3f63e7a 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -52,6 +52,7 @@
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
 #define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
 #define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
+#define PCI_DEVICE_ID_INTEL_DNV_XHCI			0x19d0
 
 static const char hcd_name[] = "xhci_hcd";
 
@@ -166,7 +167,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||
-		 pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI)) {
+		 pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
@@ -175,7 +177,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
-	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI))
+	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI))
 		xhci->quirks |= XHCI_MISSING_CAS;
 
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&

commit 69307ccb9ad7ccb653e332de68effdeaaab6907d
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Apr 7 17:57:12 2017 +0300

    usb: xhci: bInterval quirk for TI TUSB73x0
    
    As per [1] issue #4,
    "The periodic EP scheduler always tries to schedule the EPs
    that have large intervals (interval equal to or greater than
    128 microframes) into different microframes. So it maintains
    an internal counter and increments for each large interval
    EP added. When the counter is greater than 128, the scheduler
    rejects the new EP. So when the hub re-enumerated 128 times,
    it triggers this condition."
    
    This results in Bandwidth error when devices with periodic
    endpoints (ISO/INT) having bInterval > 7 are plugged and
    unplugged several times on a TUSB73x0 XHCI host.
    
    Workaround this issue by limiting the bInterval to 7
    (i.e. interval to 6) for High-speed or faster periodic endpoints.
    
    [1] - http://www.ti.com/lit/er/sllz076/sllz076.pdf
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index fc99f51d12e1..7b86508ac8cf 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -199,6 +199,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == 0x1042)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 
+	if (pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241)
+		xhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;
+
 	if (xhci->quirks & XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				"QUIRK: Resetting on resume");

commit 989bad111979f6e3827f23c3797f6ecd67766bab
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Mon Jan 23 14:20:03 2017 +0200

    usb: xhci: remove unnecessary return in xhci_pci_setup()
    
    Remove the unnecessary return line in xhci_pci_setup().
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 954abfd5014d..fc99f51d12e1 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -242,11 +242,7 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
 
 	/* Find any debug ports */
-	retval = xhci_pci_reinit(xhci, pdev);
-	if (!retval)
-		return retval;
-
-	return retval;
+	return xhci_pci_reinit(xhci, pdev);
 }
 
 /*

commit 6c97cfc1a097b1e0786c836e92b7a72b4d031e25
Author: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
Date:   Tue Jan 3 18:28:52 2017 +0200

    usb: xhci: apply XHCI_PME_STUCK_QUIRK to Intel Apollo Lake
    
    Intel Apollo Lake also requires XHCI_PME_STUCK_QUIRK.
    Adding its PCI ID to quirk.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e96ae80d107e..954abfd5014d 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -165,7 +165,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
-		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {
+		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&

commit 346e99736c3ce328fd42d678343b70243aca5f36
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 20 18:09:19 2016 +0300

    xhci: workaround for hosts missing CAS bit
    
    If a device is unplugged and replugged during Sx system suspend
    some  Intel xHC hosts will overwrite the CAS (Cold attach status) flag
    and no device connection is noticed in resume.
    
    A device in this state can be identified in resume if its link state
    is in polling or compliance mode, and the current connect status is 0.
    A device in this state needs to be warm reset.
    
    Intel 100/c230 series PCH specification update Doc #332692-006 Errata #8
    
    Observed on Cherryview and Apollolake as they go into compliance mode
    if LFPS times out during polling, and re-plugged devices are not
    discovered at resume.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 314179b4824e..e96ae80d107e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -51,6 +51,7 @@
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
 #define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
+#define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8
 
 static const char hcd_name[] = "xhci_hcd";
 
@@ -171,6 +172,11 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 		xhci->quirks |= XHCI_SSIC_PORT_UNUSED;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI))
+		xhci->quirks |= XHCI_MISSING_CAS;
+
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_EJ168) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;

commit 4c39135aa412d2f1381e43802523da110ca7855c
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 20 18:09:18 2016 +0300

    xhci: add restart quirk for Intel Wildcatpoint PCH
    
    xHC in Wildcatpoint-LP PCH is similar to LynxPoint-LP and need the
    same quirks to prevent machines from spurious restart while
    shutting them down.
    
    Reported-by: Hasan Mahmood <hasan.mahm@gmail.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index d7b0f97abbad..314179b4824e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -45,6 +45,7 @@
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
+#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI	0x9cb1
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
@@ -153,7 +154,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
+		(pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI)) {
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
 	}

commit f1f6d9a8b540df22b87a5bf6bc104edaade81f47
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Aug 16 10:18:06 2016 +0300

    xhci: don't dereference a xhci member after removing xhci
    
    Remove the hcd after checking for the xhci last quirks, not before.
    
    This caused a hang on a Alpine Ridge xhci based maching which remove
    the whole xhci controller when unplugging the last usb device
    
    CC: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4fd041bec332..d7b0f97abbad 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -314,11 +314,12 @@ static void xhci_pci_remove(struct pci_dev *dev)
 		usb_remove_hcd(xhci->shared_hcd);
 		usb_put_hcd(xhci->shared_hcd);
 	}
-	usb_hcd_pci_remove(dev);
 
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
+
+	usb_hcd_pci_remove(dev);
 }
 
 #ifdef CONFIG_PM

commit 9454c23852ca6d7aec89fd6fd46a046c323caac3
Merge: a04bee8285a7 4ef33685aa09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:34:01 2016 -0500

    Merge branch 'pci/msi-affinity' into next
    
    Conflicts:
            drivers/nvme/host/pci.c

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 48672fac7ff3..ac352fe391f4 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -382,7 +382,7 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	 * need to have the registers polled during D3, so avoid D3cold.
 	 */
 	if (xhci->quirks & XHCI_COMP_MODE_QUIRK)
-		pdev->no_d3cold = true;
+		pci_d3cold_disable(pdev);
 
 	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
 		xhci_pme_quirk(hcd);

commit d95815ba6a0f287213118c136e64d8c56daeaeab
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jun 1 21:01:29 2016 +0200

    USB: xhci: Add broken streams quirk for Frescologic device id 1009
    
    I got one of these cards for testing uas with, it seems that with streams
    it dma-s all over the place, corrupting memory. On my first tests it
    managed to dma over the BIOS of the motherboard somehow and completely
    bricked it.
    
    Tests on another motherboard show that it does work with streams disabled.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 48672fac7ff3..c10972fcc8e4 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -37,6 +37,7 @@
 /* Device for a quirk */
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
 #define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
+#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1009	0x1009
 #define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400	0x1400
 
 #define PCI_VENDOR_ID_ETRON		0x1b6f
@@ -114,6 +115,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
+			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1009)
+		xhci->quirks |= XHCI_BROKEN_STREAMS;
+
 	if (pdev->vendor == PCI_VENDOR_ID_NEC)
 		xhci->quirks |= XHCI_NEC_HOST;
 

commit 98d74f9ceaefc2b6c4a6440050163a83be0abede
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Apr 8 16:25:10 2016 +0300

    xhci: fix 10 second timeout on removal of PCI hotpluggable xhci controllers
    
    PCI hotpluggable xhci controllers such as some Alpine Ridge solutions will
    remove the xhci controller from the PCI bus when the last USB device is
    disconnected.
    
    Add a flag to indicate that the host is being removed to avoid queueing
    configure_endpoint commands for the dropped endpoints.
    For PCI hotplugged controllers this will prevent 5 second command timeouts
    For static xhci controllers the configure_endpoint command is not needed
    in the removal case as everything will be returned, freed, and the
    controller is reset.
    
    For now the flag is only set for PCI connected host controllers.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 071b34ae9c4e..48672fac7ff3 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -304,6 +304,7 @@ static void xhci_pci_remove(struct pci_dev *dev)
 	struct xhci_hcd *xhci;
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
+	xhci->xhc_state |= XHCI_STATE_REMOVING;
 	if (xhci->shared_hcd) {
 		usb_remove_hcd(xhci->shared_hcd);
 		usb_put_hcd(xhci->shared_hcd);

commit 0d46faca6f887a849efb07c1655b5a9f7c288b45
Author: Rafal Redzimski <rafal.f.redzimski@intel.com>
Date:   Fri Apr 8 16:25:05 2016 +0300

    usb: xhci: applying XHCI_PME_STUCK_QUIRK to Intel BXT B0 host
    
    Broxton B0 also requires XHCI_PME_STUCK_QUIRK.
    Adding PCI device ID for Broxton B and adding to quirk.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Rafal Redzimski <rafal.f.redzimski@intel.com>
    Signed-off-by: Robert Dobrowolski <robert.dobrowolski@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index f0640b7a1c42..071b34ae9c4e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -48,6 +48,7 @@
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
+#define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
 
 static const char hcd_name[] = "xhci_hcd";
 
@@ -155,7 +156,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		(pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
-		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {
+		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&

commit ccc04afb72cddbdf7c0e1c17e92886405a71b754
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jan 26 17:50:08 2016 +0200

    usb: xhci: apply XHCI_PME_STUCK_QUIRK to Intel Broxton-M platforms
    
    Intel Broxton M was verifed to require XHCI_PME_STUCK_QUIRK quirk as well.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7ee1d0f6891c..f0640b7a1c42 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -47,6 +47,7 @@
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
+#define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
 
 static const char hcd_name[] = "xhci_hcd";
 
@@ -153,7 +154,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		(pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
-		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {
+		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&

commit 92149c930cce1865d0d4aca2ab07c2b4b197b418
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jan 26 17:50:07 2016 +0200

    usb: xhci: set SSIC port unused only if xhci_suspend succeeds
    
    XHCI_SSIC_PORT_UNUSED quirk was applied to the xHCI host controllers
    in some Intel SoC chips.  With this quirk applied, SSIC port is set
    to "unused" prior to xhci_suspend(). This may cause problem if host
    fails to suspend.  In this case, the port is set to unused without
    host further entering D3, and the port will not be usable anymore.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Zhuang Jin Can <jin.can.zhuang@intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 86377a0955e6..7ee1d0f6891c 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -370,6 +370,7 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	int			ret;
 
 	/*
 	 * Systems with the TI redriver that loses port status change events
@@ -384,7 +385,11 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	if (xhci->quirks & XHCI_SSIC_PORT_UNUSED)
 		xhci_ssic_port_unused_quirk(hcd, true);
 
-	return xhci_suspend(xhci, do_wakeup);
+	ret = xhci_suspend(xhci, do_wakeup);
+	if (ret && (xhci->quirks & XHCI_SSIC_PORT_UNUSED))
+		xhci_ssic_port_unused_quirk(hcd, false);
+
+	return ret;
 }
 
 static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)

commit 7e70cbffe236721051bbaff965e477df06dcb190
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jan 26 17:50:06 2016 +0200

    usb: xhci: add a quirk bit for ssic port unused
    
    Two workarounds introduced by commit b8cb91e058cd ("xhci: Workaround
    for PME stuck issues in Intel xhci") and commit abce329c27b3 ("xhci:
    Workaround to get D3 working in Intel xHCI") share a single quirk bit
    XHCI_PME_STUCK_QUIRK. These two workarounds actually are different and
    might happen on different hardwares. Need to separate them by adding a
    quirk bit for the later.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 67471fb28de5..86377a0955e6 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -156,6 +156,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {
 		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
+		xhci->quirks |= XHCI_SSIC_PORT_UNUSED;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_EJ168) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
@@ -314,46 +318,47 @@ static void xhci_pci_remove(struct pci_dev *dev)
  * SSIC PORT need to be marked as "unused" before putting xHCI
  * into D3. After D3 exit, the SSIC port need to be marked as "used".
  * Without this change, xHCI might not enter D3 state.
- * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
- * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
  */
-static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)
+static void xhci_ssic_port_unused_quirk(struct usb_hcd *hcd, bool suspend)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
-	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	u32 val;
 	void __iomem *reg;
 	int i;
 
-	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
-
-		for (i = 0; i < SSIC_PORT_NUM; i++) {
-			reg = (void __iomem *) xhci->cap_regs +
-					SSIC_PORT_CFG2 +
-					i * SSIC_PORT_CFG2_OFFSET;
-
-			/*
-			 * Notify SSIC that SSIC profile programming
-			 * is not done.
-			 */
-			val = readl(reg) & ~PROG_DONE;
-			writel(val, reg);
-
-			/* Mark SSIC port as unused(suspend) or used(resume) */
-			val = readl(reg);
-			if (suspend)
-				val |= SSIC_PORT_UNUSED;
-			else
-				val &= ~SSIC_PORT_UNUSED;
-			writel(val, reg);
-
-			/* Notify SSIC that SSIC profile programming is done */
-			val = readl(reg) | PROG_DONE;
-			writel(val, reg);
-			readl(reg);
-		}
+	for (i = 0; i < SSIC_PORT_NUM; i++) {
+		reg = (void __iomem *) xhci->cap_regs +
+				SSIC_PORT_CFG2 +
+				i * SSIC_PORT_CFG2_OFFSET;
+
+		/* Notify SSIC that SSIC profile programming is not done. */
+		val = readl(reg) & ~PROG_DONE;
+		writel(val, reg);
+
+		/* Mark SSIC port as unused(suspend) or used(resume) */
+		val = readl(reg);
+		if (suspend)
+			val |= SSIC_PORT_UNUSED;
+		else
+			val &= ~SSIC_PORT_UNUSED;
+		writel(val, reg);
+
+		/* Notify SSIC that SSIC profile programming is done */
+		val = readl(reg) | PROG_DONE;
+		writel(val, reg);
+		readl(reg);
 	}
+}
+
+/*
+ * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
+ * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
+ */
+static void xhci_pme_quirk(struct usb_hcd *hcd)
+{
+	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	void __iomem *reg;
+	u32 val;
 
 	reg = (void __iomem *) xhci->cap_regs + 0x80a4;
 	val = readl(reg);
@@ -374,7 +379,10 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 		pdev->no_d3cold = true;
 
 	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
-		xhci_pme_quirk(hcd, true);
+		xhci_pme_quirk(hcd);
+
+	if (xhci->quirks & XHCI_SSIC_PORT_UNUSED)
+		xhci_ssic_port_unused_quirk(hcd, true);
 
 	return xhci_suspend(xhci, do_wakeup);
 }
@@ -406,8 +414,11 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
 		usb_enable_intel_xhci_ports(pdev);
 
+	if (xhci->quirks & XHCI_SSIC_PORT_UNUSED)
+		xhci_ssic_port_unused_quirk(hcd, false);
+
 	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
-		xhci_pme_quirk(hcd, false);
+		xhci_pme_quirk(hcd);
 
 	retval = xhci_resume(xhci, hibernated);
 	return retval;

commit fa89537783cb442263fa5a14df6c7693eaf32f11
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jan 26 17:50:05 2016 +0200

    usb: xhci: handle both SSIC ports in PME stuck quirk
    
    Commit abce329c27b3 ("xhci: Workaround to get D3 working in Intel xHCI")
    adds a workaround for a limitation of PME storm caused by SSIC port in
    some Intel SoCs. This commit only handled one SSIC port, while there
    are actually two SSIC ports in the chips. This patch handles both SSIC
    ports. Without this fix, users still see PME storm.
    
    Cc: stable@vger.kernel.org # v4.2+
    Signed-off-by: Zhuang Jin Can <jin.can.zhuang@intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 58c43ed7ff3b..67471fb28de5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -28,7 +28,9 @@
 #include "xhci.h"
 #include "xhci-trace.h"
 
-#define PORT2_SSIC_CONFIG_REG2	0x883c
+#define SSIC_PORT_NUM		2
+#define SSIC_PORT_CFG2		0x880c
+#define SSIC_PORT_CFG2_OFFSET	0x30
 #define PROG_DONE		(1 << 30)
 #define SSIC_PORT_UNUSED	(1 << 31)
 
@@ -321,28 +323,36 @@ static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	u32 val;
 	void __iomem *reg;
+	int i;
 
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 
-		reg = (void __iomem *) xhci->cap_regs + PORT2_SSIC_CONFIG_REG2;
-
-		/* Notify SSIC that SSIC profile programming is not done */
-		val = readl(reg) & ~PROG_DONE;
-		writel(val, reg);
-
-		/* Mark SSIC port as unused(suspend) or used(resume) */
-		val = readl(reg);
-		if (suspend)
-			val |= SSIC_PORT_UNUSED;
-		else
-			val &= ~SSIC_PORT_UNUSED;
-		writel(val, reg);
-
-		/* Notify SSIC that SSIC profile programming is done */
-		val = readl(reg) | PROG_DONE;
-		writel(val, reg);
-		readl(reg);
+		for (i = 0; i < SSIC_PORT_NUM; i++) {
+			reg = (void __iomem *) xhci->cap_regs +
+					SSIC_PORT_CFG2 +
+					i * SSIC_PORT_CFG2_OFFSET;
+
+			/*
+			 * Notify SSIC that SSIC profile programming
+			 * is not done.
+			 */
+			val = readl(reg) & ~PROG_DONE;
+			writel(val, reg);
+
+			/* Mark SSIC port as unused(suspend) or used(resume) */
+			val = readl(reg);
+			if (suspend)
+				val |= SSIC_PORT_UNUSED;
+			else
+				val &= ~SSIC_PORT_UNUSED;
+			writel(val, reg);
+
+			/* Notify SSIC that SSIC profile programming is done */
+			val = readl(reg) | PROG_DONE;
+			writel(val, reg);
+			readl(reg);
+		}
 	}
 
 	reg = (void __iomem *) xhci->cap_regs + 0x80a4;

commit 252ca494ac75f0dc47469f130d6dc67ed14081f4
Merge: 900937c0375e 9f9499ae8e64
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Dec 13 19:20:27 2015 -0800

    Merge 4.4-rc5 into usb-next as we want those fixes here for testing
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 84ed91526f9881886d70a082032236edaa20e7d4
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Dec 4 15:53:42 2015 +0200

    xhci: Fix memory leak in xhci_pme_acpi_rtd3_enable()
    
    There is a memory leak because acpi_evaluate_dsm() actually returns an
    object which the caller is supposed to release. Fix this by calling
    ACPI_FREE() for the returned object (this expands to kfree() so passing
    NULL there is fine as well).
    
    While there correct indentation in !CONFIG_ACPI case.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: stable <stable@vger.kernel.org> # v4.2
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 17f6897acde2..c62109091d12 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -188,10 +188,14 @@ static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)
 		0xb7, 0x0c, 0x34, 0xac,	0x01, 0xe9, 0xbf, 0x45,
 		0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23,
 	};
-	acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), intel_dsm_uuid, 3, 1, NULL);
+	union acpi_object *obj;
+
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), intel_dsm_uuid, 3, 1,
+				NULL);
+	ACPI_FREE(obj);
 }
 #else
-	static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }
+static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }
 #endif /* CONFIG_ACPI */
 
 /* called during probe() after chip reset completes */

commit 32479d4b929714b7891efea3783ac4d378e30c59
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Nov 24 13:09:47 2015 +0200

    usb: host: xhci: cleanup hcd private size
    
    This patch cleanups the hcd private size to suitable size.
    The previous code has "sizeof(struct xhci_hcd *)" in xhci_hc_driver
    as hcd_priv_size and sizeof(struct xhci_hcd) in xhci_plat_overrides
    or xhci_pci_overrides as extra_priv_size. However, the xhci driver
    uses a "sizeof(struct xhcd_hcd)" memory space in each hcd
    (main_hcd and shared_hcd) actually.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 17f6897acde2..b51ac631c240 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -53,7 +53,6 @@ static struct hc_driver __read_mostly xhci_pci_hc_driver;
 static int xhci_pci_setup(struct usb_hcd *hcd);
 
 static const struct xhci_driver_overrides xhci_pci_overrides __initconst = {
-	.extra_priv_size = sizeof(struct xhci_hcd),
 	.reset = xhci_pci_setup,
 };
 

commit 0bbc367e21bfeea33230d893be4fa3a3ff9bcb48
Merge: ae416ba4e94a 32b88194f71d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 26 06:39:46 2015 +0900

    Merge 4.3-rc7 into usb-next
    
    We want the USB and other fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fd7cd061adcf5f7503515ba52b6a724642a839c8
Author: Laura Abbott <labbott@fedoraproject.org>
Date:   Mon Oct 12 11:30:13 2015 +0300

    xhci: Add spurious wakeup quirk for LynxPoint-LP controllers
    
    We received several reports of systems rebooting and powering on
    after an attempted shutdown. Testing showed that setting
    XHCI_SPURIOUS_WAKEUP quirk in addition to the XHCI_SPURIOUS_REBOOT
    quirk allowed the system to shutdown as expected for LynxPoint-LP
    xHCI controllers. Set the quirk back.
    
    Note that the quirk was originally introduced for LynxPoint and
    LynxPoint-LP just for this same reason. See:
    
    commit 638298dc66ea ("xhci: Fix spurious wakeups after S5 on Haswell")
    
    It was later limited to only concern HP machines as it caused
    regression on some machines, see both bug and commit:
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=66171
    commit 6962d914f317 ("xhci: Limit the spurious wakeup fix only to HP machines")
    
    Later it was discovered that the powering on after shutdown
    was limited to LynxPoint-LP (Haswell-ULT) and that some non-LP HP
    machine suffered from spontaneous resume from S3 (which should
    not be related to the SPURIOUS_WAKEUP quirk at all). An attempt
    to fix this then removed the SPURIOUS_WAKEUP flag usage completely.
    
    commit b45abacde3d5 ("xhci: no switching back on non-ULT Haswell")
    
    Current understanding is that LynxPoint-LP (Haswell ULT) machines
    need the SPURIOUS_WAKEUP quirk, otherwise they will restart, and
    plain Lynxpoint (Haswell) machines may _not_ have the quirk
    set otherwise they again will restart.
    
    Signed-off-by: Laura Abbott <labbott@fedoraproject.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Oliver Neukum <oneukum@suse.com>
    [Added more history to commit message -Mathias]
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c79d33676672..c47d3e480586 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -147,6 +147,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
+		xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		(pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||

commit b50107bb83d027dfd36bb7efb90570559757d6ae
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:38 2015 +0300

    xhci: check xhci hardware for USB 3.1 support
    
    Set the controller speed to HCD_USB31 to if host hardware supports USB 3.1
    
    For PCI xhci controllers the USB 3.1 support is checked from SBRN bits in
    pci config space. Platform controllers will need to set xhci->sbrn == 0x31
    to indicate USB 3.1 support before calling xhci_gen_setup().
    
    Also make sure xhci driver works correctly with speed set to HCD_USB31
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c79d33676672..012d7f4c2901 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -200,15 +200,17 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval;
 
+	xhci = hcd_to_xhci(hcd);
+	if (!xhci->sbrn)
+		pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
+
 	retval = xhci_gen_setup(hcd, xhci_pci_quirks);
 	if (retval)
 		return retval;
 
-	xhci = hcd_to_xhci(hcd);
 	if (!usb_hcd_is_primary_hcd(hcd))
 		return 0;
 
-	pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
 	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
 
 	/* Find any debug ports */

commit 2b7627b73e81e5d23d5ae1490fe8e690af86e053
Author: Tomer Barletz <barletz@gmail.com>
Date:   Mon Sep 21 17:46:11 2015 +0300

    xhci: Move xhci_pme_quirk() behind #ifdef CONFIG_PM
    
    xhci_pme_quirk() is only used when CONFIG_PM is defined.
    Compiling a kernel without PM complains about this function
    
    [reworded commit message -Mathias]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Tomer Barletz <barletz@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 5590eac2b22d..c79d33676672 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -180,51 +180,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 				"QUIRK: Resetting on resume");
 }
 
-/*
- * In some Intel xHCI controllers, in order to get D3 working,
- * through a vendor specific SSIC CONFIG register at offset 0x883c,
- * SSIC PORT need to be marked as "unused" before putting xHCI
- * into D3. After D3 exit, the SSIC port need to be marked as "used".
- * Without this change, xHCI might not enter D3 state.
- * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
- * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
- */
-static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)
-{
-	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
-	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
-	u32 val;
-	void __iomem *reg;
-
-	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
-
-		reg = (void __iomem *) xhci->cap_regs + PORT2_SSIC_CONFIG_REG2;
-
-		/* Notify SSIC that SSIC profile programming is not done */
-		val = readl(reg) & ~PROG_DONE;
-		writel(val, reg);
-
-		/* Mark SSIC port as unused(suspend) or used(resume) */
-		val = readl(reg);
-		if (suspend)
-			val |= SSIC_PORT_UNUSED;
-		else
-			val &= ~SSIC_PORT_UNUSED;
-		writel(val, reg);
-
-		/* Notify SSIC that SSIC profile programming is done */
-		val = readl(reg) | PROG_DONE;
-		writel(val, reg);
-		readl(reg);
-	}
-
-	reg = (void __iomem *) xhci->cap_regs + 0x80a4;
-	val = readl(reg);
-	writel(val | BIT(28), reg);
-	readl(reg);
-}
-
 #ifdef CONFIG_ACPI
 static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)
 {
@@ -345,6 +300,51 @@ static void xhci_pci_remove(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
+/*
+ * In some Intel xHCI controllers, in order to get D3 working,
+ * through a vendor specific SSIC CONFIG register at offset 0x883c,
+ * SSIC PORT need to be marked as "unused" before putting xHCI
+ * into D3. After D3 exit, the SSIC port need to be marked as "used".
+ * Without this change, xHCI might not enter D3 state.
+ * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
+ * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
+ */
+static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)
+{
+	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	u32 val;
+	void __iomem *reg;
+
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
+
+		reg = (void __iomem *) xhci->cap_regs + PORT2_SSIC_CONFIG_REG2;
+
+		/* Notify SSIC that SSIC profile programming is not done */
+		val = readl(reg) & ~PROG_DONE;
+		writel(val, reg);
+
+		/* Mark SSIC port as unused(suspend) or used(resume) */
+		val = readl(reg);
+		if (suspend)
+			val |= SSIC_PORT_UNUSED;
+		else
+			val &= ~SSIC_PORT_UNUSED;
+		writel(val, reg);
+
+		/* Notify SSIC that SSIC profile programming is done */
+		val = readl(reg) | PROG_DONE;
+		writel(val, reg);
+		readl(reg);
+	}
+
+	reg = (void __iomem *) xhci->cap_regs + 0x80a4;
+	val = readl(reg);
+	writel(val | BIT(28), reg);
+	readl(reg);
+}
+
 static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);

commit abce329c27b315cfc01be1a305ee976ee13ed4cf
Author: Rajmohan Mani <rajmohan.mani@intel.com>
Date:   Tue Jul 21 17:20:26 2015 +0300

    xhci: Workaround to get D3 working in Intel xHCI
    
    The xHCI in Intel CherryView / Braswell Platform requires
    a driver workaround to get xHCI D3 working. Without this
    workaround, xHCI might not enter D3.
    
    Workaround is to configure SSIC PORT as "unused" before D3
    entry and "used" after D3 exit. This is done through a
    vendor specific register (PORT2_SSIC_CONFIG_REG2 at offset
    0x883c), in xhci suspend / resume callbacks.
    
    Verified xHCI D3 works fine in CherryView / Braswell platform.
    
    Signed-off-by: Rajmohan Mani <rajmohan.mani@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index da10dc728acb..5590eac2b22d 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -28,6 +28,10 @@
 #include "xhci.h"
 #include "xhci-trace.h"
 
+#define PORT2_SSIC_CONFIG_REG2	0x883c
+#define PROG_DONE		(1 << 30)
+#define SSIC_PORT_UNUSED	(1 << 31)
+
 /* Device for a quirk */
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
 #define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
@@ -177,14 +181,44 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 }
 
 /*
+ * In some Intel xHCI controllers, in order to get D3 working,
+ * through a vendor specific SSIC CONFIG register at offset 0x883c,
+ * SSIC PORT need to be marked as "unused" before putting xHCI
+ * into D3. After D3 exit, the SSIC port need to be marked as "used".
+ * Without this change, xHCI might not enter D3 state.
  * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
  * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
  */
-static void xhci_pme_quirk(struct xhci_hcd *xhci)
+static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)
 {
+	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	u32 val;
 	void __iomem *reg;
 
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
+
+		reg = (void __iomem *) xhci->cap_regs + PORT2_SSIC_CONFIG_REG2;
+
+		/* Notify SSIC that SSIC profile programming is not done */
+		val = readl(reg) & ~PROG_DONE;
+		writel(val, reg);
+
+		/* Mark SSIC port as unused(suspend) or used(resume) */
+		val = readl(reg);
+		if (suspend)
+			val |= SSIC_PORT_UNUSED;
+		else
+			val &= ~SSIC_PORT_UNUSED;
+		writel(val, reg);
+
+		/* Notify SSIC that SSIC profile programming is done */
+		val = readl(reg) | PROG_DONE;
+		writel(val, reg);
+		readl(reg);
+	}
+
 	reg = (void __iomem *) xhci->cap_regs + 0x80a4;
 	val = readl(reg);
 	writel(val | BIT(28), reg);
@@ -324,7 +358,7 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 		pdev->no_d3cold = true;
 
 	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
-		xhci_pme_quirk(xhci);
+		xhci_pme_quirk(hcd, true);
 
 	return xhci_suspend(xhci, do_wakeup);
 }
@@ -357,7 +391,7 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 		usb_enable_intel_xhci_ports(pdev);
 
 	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
-		xhci_pme_quirk(xhci);
+		xhci_pme_quirk(hcd, false);
 
 	retval = xhci_resume(xhci, hibernated);
 	return retval;

commit c3c5819a350952439c3198aa46581f9e4c46557f
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jul 21 17:20:25 2015 +0300

    xhci: call BIOS workaround to enable runtime suspend on Intel Braswell
    
    Intel xhci hw that require XHCI_PME_STUCK quirk have as default disabled
    xhci from going to D3 state in runtime suspend. Driver needs to verify
    it can deal with the hw by calling an ACPI _DSM method to get D3 enabled.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4a4cb1d91ac8..da10dc728acb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -23,6 +23,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/acpi.h>
 
 #include "xhci.h"
 #include "xhci-trace.h"
@@ -190,6 +191,19 @@ static void xhci_pme_quirk(struct xhci_hcd *xhci)
 	readl(reg);
 }
 
+#ifdef CONFIG_ACPI
+static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)
+{
+	static const u8 intel_dsm_uuid[] = {
+		0xb7, 0x0c, 0x34, 0xac,	0x01, 0xe9, 0xbf, 0x45,
+		0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23,
+	};
+	acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), intel_dsm_uuid, 3, 1, NULL);
+}
+#else
+	static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }
+#endif /* CONFIG_ACPI */
+
 /* called during probe() after chip reset completes */
 static int xhci_pci_setup(struct usb_hcd *hcd)
 {
@@ -263,6 +277,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 			HCC_MAX_PSA(xhci->hcc_params) >= 4)
 		xhci->shared_hcd->can_do_streams = 1;
 
+	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
+		xhci_pme_acpi_rtd3_enable(dev);
+
 	/* USB-2 and USB-3 roothubs initialized, allow runtime pm suspend */
 	pm_runtime_put_noidle(&dev->dev);
 

commit cd33a32157e42483ffea31e32b1cee4f11ff9592
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri May 29 17:01:46 2015 +0300

    usb: xhci: cleanup xhci_hcd allocation
    
    HCD core allocates memory for HCD private data in
    usb_create_[shared_]hcd() so make use of that
    mechanism to allocate the struct xhci_hcd.
    
    Introduce struct xhci_driver_overrides to provide
    the size of HCD private data and hc_driver operation
    overrides. As of now we only need to override the
    reset and start methods.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 2af32e26fafc..4a4cb1d91ac8 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -45,6 +45,13 @@ static const char hcd_name[] = "xhci_hcd";
 
 static struct hc_driver __read_mostly xhci_pci_hc_driver;
 
+static int xhci_pci_setup(struct usb_hcd *hcd);
+
+static const struct xhci_driver_overrides xhci_pci_overrides __initconst = {
+	.extra_priv_size = sizeof(struct xhci_hcd),
+	.reset = xhci_pci_setup,
+};
+
 /* called after powerup, by probe or system-pm "wakeup" */
 static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 {
@@ -206,7 +213,6 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (!retval)
 		return retval;
 
-	kfree(xhci);
 	return retval;
 }
 
@@ -247,11 +253,6 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto dealloc_usb2_hcd;
 	}
 
-	/* Set the xHCI pointer before xhci_pci_setup() (aka hcd_driver.reset)
-	 * is called by usb_add_hcd().
-	 */
-	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
-
 	retval = usb_add_hcd(xhci->shared_hcd, dev->irq,
 			IRQF_SHARED);
 	if (retval)
@@ -290,8 +291,6 @@ static void xhci_pci_remove(struct pci_dev *dev)
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
-
-	kfree(xhci);
 }
 
 #ifdef CONFIG_PM
@@ -379,7 +378,7 @@ static struct pci_driver xhci_pci_driver = {
 
 static int __init xhci_pci_init(void)
 {
-	xhci_init_driver(&xhci_pci_hc_driver, xhci_pci_setup);
+	xhci_init_driver(&xhci_pci_hc_driver, &xhci_pci_overrides);
 #ifdef CONFIG_PM
 	xhci_pci_hc_driver.pci_suspend = xhci_pci_suspend;
 	xhci_pci_hc_driver.pci_resume = xhci_pci_resume;

commit 227a4fd801c8a9fa2c4700ab98ec1aec06e3b44d
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Mon Mar 23 18:27:42 2015 +0200

    usb: xhci: apply XHCI_AVOID_BEI quirk to all Intel xHCI controllers
    
    When a device with an isochronous endpoint is plugged into the Intel
    xHCI host controller, and the driver submits multiple frames per URB,
    the xHCI driver will set the Block Event Interrupt (BEI) flag on all
    but the last TD for the URB. This causes the host controller to place
    an event on the event ring, but not send an interrupt. When the last
    TD for the URB completes, BEI is cleared, and we get an interrupt for
    the whole URB.
    
    However, under Intel xHCI host controllers, if the event ring is full
    of events from transfers with BEI set,  an "Event Ring is Full" event
    will be posted to the last entry of the event ring,  but no interrupt
    is generated. Host will cease all transfer and command executions and
    wait until software completes handling the pending events in the event
    ring.  That means xHC stops, but event of "event ring is full" is not
    notified. As the result, the xHC looks like dead to user.
    
    This patch is to apply XHCI_AVOID_BEI quirk to Intel xHC devices. And
    it should be backported to kernels as old as 3.0, that contains the
    commit 69e848c2090a ("Intel xhci: Support EHCI/xHCI port switching.").
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Tested-by: Alistair Grant <akgrant0710@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index fd53c9ebd662..2af32e26fafc 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -115,6 +115,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;
+		xhci->quirks |= XHCI_AVOID_BEI;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
@@ -130,7 +131,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 * PPT chipsets.
 		 */
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
-		xhci->quirks |= XHCI_AVOID_BEI;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {

commit b8cb91e058cd0c0f02059c1207293c5b31d350fa
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Mar 6 17:23:19 2015 +0200

    xhci: Workaround for PME stuck issues in Intel xhci
    
    The xhci in Intel Sunrisepoint and Cherryview platforms need a driver
    workaround for a Stuck PME that might either block PME events in suspend,
    or create spurious PME events preventing runtime suspend.
    
    Workaround is to clear a internal PME flag, BIT(28) in a vendor specific
    PMCTRL register at offset 0x80a4, in both suspend resume callbacks
    
    Without this, xhci connected usb devices might never be able to wake up the
    system from suspend, or prevent device from going to suspend (xhci d3)
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7f76c8a12f89..fd53c9ebd662 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -37,6 +37,9 @@
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
+#define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 
 static const char hcd_name[] = "xhci_hcd";
 
@@ -133,6 +136,12 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		(pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
+		 pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {
+		xhci->quirks |= XHCI_PME_STUCK_QUIRK;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_EJ168) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
@@ -159,6 +168,21 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 				"QUIRK: Resetting on resume");
 }
 
+/*
+ * Make sure PME works on some Intel xHCI controllers by writing 1 to clear
+ * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4
+ */
+static void xhci_pme_quirk(struct xhci_hcd *xhci)
+{
+	u32 val;
+	void __iomem *reg;
+
+	reg = (void __iomem *) xhci->cap_regs + 0x80a4;
+	val = readl(reg);
+	writel(val | BIT(28), reg);
+	readl(reg);
+}
+
 /* called during probe() after chip reset completes */
 static int xhci_pci_setup(struct usb_hcd *hcd)
 {
@@ -283,6 +307,9 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	if (xhci->quirks & XHCI_COMP_MODE_QUIRK)
 		pdev->no_d3cold = true;
 
+	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
+		xhci_pme_quirk(xhci);
+
 	return xhci_suspend(xhci, do_wakeup);
 }
 
@@ -313,6 +340,9 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
 		usb_enable_intel_xhci_ports(pdev);
 
+	if (xhci->quirks & XHCI_PME_STUCK_QUIRK)
+		xhci_pme_quirk(xhci);
+
 	retval = xhci_resume(xhci, hibernated);
 	return retval;
 }

commit 7f5c4d631aed243ca89c6673427954210b1628ec
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Dec 5 11:11:28 2014 +0100

    xhci: Add broken-streams quirk for Fresco Logic FL1000G xhci controllers
    
    Streams do not work reliabe on Fresco Logic FL1000G xhci controllers,
    trying to use them results in errors like this:
    
    21:37:33 kernel: xhci_hcd 0000:04:00.0: ERROR Transfer event for disabled endpoint or incorrect stream ring
    21:37:33 kernel: xhci_hcd 0000:04:00.0: @00000000368b3570 9067b000 00000000 05000000 01078001
    21:37:33 kernel: xhci_hcd 0000:04:00.0: ERROR Transfer event for disabled endpoint or incorrect stream ring
    21:37:33 kernel: xhci_hcd 0000:04:00.0: @00000000368b3580 9067b400 00000000 05000000 01038001
    
    As always I've ordered a pci-e addon card with a Fresco Logic controller for
    myself to see if I can come up with a better fix then the big hammer, in
    the mean time this will make uas devices work again (in usb-storage mode)
    for FL1000G users.
    
    Reported-by: Marcin Zajączkowski <mszpak@wp.pl>
    Cc: stable@vger.kernel.org # 3.15
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 142b601f9563..7f76c8a12f89 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -82,6 +82,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 				"must be suspended extra slowly",
 				pdev->revision);
 		}
+		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK)
+			xhci->quirks |= XHCI_BROKEN_STREAMS;
 		/* Fresco Logic confirms: all revisions of this chip do not
 		 * support MSI, even though some of them claim to in their PCI
 		 * capabilities.

commit a1377e5397ab321e21b793ec8cd2b6f12bd3c718
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Nov 18 11:27:14 2014 +0200

    usb: xhci: rework root port wake bits if controller isn't allowed to wakeup
    
    When system is being suspended, if host device is not allowed to do wakeup,
    xhci_suspend() needs to clear all root port wake on bits. Otherwise, some
    platforms may generate spurious wakeup, even if PCI PME# is disabled.
    
    The initial commit ff8cbf250b44 ("xhci: clear root port wake on bits"),
    which also got into stable, turned out to not work correctly and had to
    be reverted, and is now rewritten.
    
    Cc: stable <stable@vger.kernel.org> # v3.2+
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    [Mathias Nyman: reword commit message]
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 9a69b1f1b300..142b601f9563 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -281,7 +281,7 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	if (xhci->quirks & XHCI_COMP_MODE_QUIRK)
 		pdev->no_d3cold = true;
 
-	return xhci_suspend(xhci);
+	return xhci_suspend(xhci, do_wakeup);
 }
 
 static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)

commit b45abacde3d551c6696c6738bef4a1805d0bf27a
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Oct 27 14:53:29 2014 +0100

    xhci: no switching back on non-ULT Haswell
    
    The switch back is limited to ULT even on HP. The contrary
    finding arose by bad luck in BIOS versions for testing.
    This fixes spontaneous resume from S3 on some HP laptops.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 2c7f3fb811d1..9a69b1f1b300 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -127,20 +127,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci->quirks |= XHCI_AVOID_BEI;
 	}
-	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
-	    (pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI ||
-	     pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI)) {
-		/* Workaround for occasional spurious wakeups from S5 (or
-		 * any other sleep) on Haswell machines with LPT and LPT-LP
-		 * with the new Intel BIOS
-		 */
-		/* Limit the quirk to only known vendors, as this triggers
-		 * yet another BIOS bug on some other machines
-		 * https://bugzilla.kernel.org/show_bug.cgi?id=66171
-		 */
-		if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)
-			xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
-	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;

commit 2391eacbd00b706ff4902db7dbee21e33b6f1850
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Oct 28 11:05:29 2014 +0100

    xhci: Disable streams on Asmedia 1042 xhci controllers
    
    Streams seem to be broken on the Asmedia 1042. An uas capable Seagate disk
    which is known to work fine with other controllers causes the system to freeze
    when connected over usb-3 with this controller, where as it works fine with
    uas in usb-2 ports, indicating a problem with streams.
    
    This is a bit bigger hammer then I would like to use for this, but for now it
    will have to make do. I've ordered a pci-e usb controller card with an Asmedia
    1042, once that arrives I'll try to get streams to work (with a quirk flag if
    necessary) and then we can re-enable them. For now this at least makes uas
    capable disk enclosures work again by forcing fallback to the usb-storage
    driver.
    
    Reported-by: Bogdan Mihalcea <bogdan.mihalcea@infim.ro>
    Cc: Bogdan Mihalcea <bogdan.mihalcea@infim.ro>
    Cc: stable@vger.kernel.org # 3.16
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 280dde93abe5..2c7f3fb811d1 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -162,6 +162,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == 0x3432)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 
+	if (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&
+			pdev->device == 0x1042)
+		xhci->quirks |= XHCI_BROKEN_STREAMS;
+
 	if (xhci->quirks & XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				"QUIRK: Resetting on resume");

commit 29e409f0f7613f9fd2235e41f0fa33e48e94544e
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:29 2014 +0300

    xhci: Allow xHCI drivers to be built as separate modules
    
    Instead of building all of the xHCI code into a single module, separate
    it out into the core (xhci-hcd), PCI (xhci-pci, now selected by the new
    config option CONFIG_USB_XHCI_PCI), and platform (xhci-plat) drivers.
    Also update the PCI/platform drivers with module descriptions/licenses
    and have them register their respective drivers in their initcalls.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index effa62aa4a2e..280dde93abe5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -355,7 +355,7 @@ static struct pci_driver xhci_pci_driver = {
 #endif
 };
 
-int __init xhci_register_pci(void)
+static int __init xhci_pci_init(void)
 {
 	xhci_init_driver(&xhci_pci_hc_driver, xhci_pci_setup);
 #ifdef CONFIG_PM
@@ -364,8 +364,13 @@ int __init xhci_register_pci(void)
 #endif
 	return pci_register_driver(&xhci_pci_driver);
 }
+module_init(xhci_pci_init);
 
-void xhci_unregister_pci(void)
+static void __exit xhci_pci_exit(void)
 {
 	pci_unregister_driver(&xhci_pci_driver);
 }
+module_exit(xhci_pci_exit);
+
+MODULE_DESCRIPTION("xHCI PCI Host Controller Driver");
+MODULE_LICENSE("GPL");

commit e1cd972741f537828307640c9e55f7b595e9ba1e
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:27 2014 +0300

    xhci: Check for XHCI_COMP_MODE_QUIRK when disabling D3cold
    
    Instead of calling xhci_compliance_mode_recovery_timer_quirk_check() again
    in the PCI suspend path, just check for XHCI_COMP_MODE_QUIRK which will
    have been set based on xhci_compliance_mode_recovery_timer_quirk_check()
    in xhci_init().
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 605852d180cb..effa62aa4a2e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -288,7 +288,7 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	 * Systems with the TI redriver that loses port status change events
 	 * need to have the registers polled during D3, so avoid D3cold.
 	 */
-	if (xhci_compliance_mode_recovery_timer_quirk_check())
+	if (xhci->quirks & XHCI_COMP_MODE_QUIRK)
 		pdev->no_d3cold = true;
 
 	return xhci_suspend(xhci);

commit 1885d9a33753b73cbbe3f8efde4a852ecca08674
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:26 2014 +0300

    xhci: Introduce xhci_init_driver()
    
    Since the struct hc_driver is mostly the same across the xhci-pci,
    xhci-plat, and the upcoming xhci-tegra driver, introduce the function
    xhci_init_driver() which will populate the hc_driver with the default
    xHCI operations.  The caller must supply a setup function which will
    be used as the hc_driver's reset callback.
    
    Note that xhci-plat also overrides the default ->start() callback so
    that it can do rcar-specific initialization.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c22a3e15a16e..605852d180cb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -40,6 +40,8 @@
 
 static const char hcd_name[] = "xhci_hcd";
 
+static struct hc_driver __read_mostly xhci_pci_hc_driver;
+
 /* called after powerup, by probe or system-pm "wakeup" */
 static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 {
@@ -324,68 +326,6 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 }
 #endif /* CONFIG_PM */
 
-static const struct hc_driver xhci_pci_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"xHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct xhci_hcd *),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			xhci_irq,
-	.flags =		HCD_MEMORY | HCD_USB3 | HCD_SHARED,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		xhci_pci_setup,
-	.start =		xhci_run,
-#ifdef CONFIG_PM
-	.pci_suspend =          xhci_pci_suspend,
-	.pci_resume =           xhci_pci_resume,
-#endif
-	.stop =			xhci_stop,
-	.shutdown =		xhci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		xhci_urb_enqueue,
-	.urb_dequeue =		xhci_urb_dequeue,
-	.alloc_dev =		xhci_alloc_dev,
-	.free_dev =		xhci_free_dev,
-	.alloc_streams =	xhci_alloc_streams,
-	.free_streams =		xhci_free_streams,
-	.add_endpoint =		xhci_add_endpoint,
-	.drop_endpoint =	xhci_drop_endpoint,
-	.endpoint_reset =	xhci_endpoint_reset,
-	.check_bandwidth =	xhci_check_bandwidth,
-	.reset_bandwidth =	xhci_reset_bandwidth,
-	.address_device =	xhci_address_device,
-	.enable_device =	xhci_enable_device,
-	.update_hub_device =	xhci_update_hub_device,
-	.reset_device =		xhci_discover_or_reset_device,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	xhci_get_frame,
-
-	/* Root hub support */
-	.hub_control =		xhci_hub_control,
-	.hub_status_data =	xhci_hub_status_data,
-	.bus_suspend =		xhci_bus_suspend,
-	.bus_resume =		xhci_bus_resume,
-	/*
-	 * call back when device connected and addressed
-	 */
-	.update_device =        xhci_update_device,
-	.set_usb2_hw_lpm =	xhci_set_usb2_hardware_lpm,
-	.enable_usb3_lpm_timeout =	xhci_enable_usb3_lpm_timeout,
-	.disable_usb3_lpm_timeout =	xhci_disable_usb3_lpm_timeout,
-	.find_raw_port_number =	xhci_find_raw_port_number,
-};
-
 /*-------------------------------------------------------------------------*/
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
@@ -417,6 +357,11 @@ static struct pci_driver xhci_pci_driver = {
 
 int __init xhci_register_pci(void)
 {
+	xhci_init_driver(&xhci_pci_hc_driver, xhci_pci_setup);
+#ifdef CONFIG_PM
+	xhci_pci_hc_driver.pci_suspend = xhci_pci_suspend;
+	xhci_pci_hc_driver.pci_resume = xhci_pci_resume;
+#endif
 	return pci_register_driver(&xhci_pci_driver);
 }
 

commit e21eba05afd288a227320f797864ddd859397eed
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Aug 25 12:21:56 2014 +0200

    xhci: Disable streams on Via XHCI with device-id 0x3432
    
    This is a bit bigger hammer then I would like to use for this, but for now
    it will have to make do. I'm working on getting my hands on one of these so
    that I can try to get streams to work (with a quirk flag if necessary) and
    then we can re-enable them.
    
    For now this at least makes uas capable disk enclosures work again by forcing
    fallback to the usb-storage driver.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=79511
    
    Cc: stable@vger.kernel.org # 3.15
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 95d0a6d984f1..c22a3e15a16e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -155,6 +155,11 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 
+	/* See https://bugzilla.kernel.org/show_bug.cgi?id=79511 */
+	if (pdev->vendor == PCI_VENDOR_ID_VIA &&
+			pdev->device == 0x3432)
+		xhci->quirks |= XHCI_BROKEN_STREAMS;
+
 	if (xhci->quirks & XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				"QUIRK: Resetting on resume");

commit 2597fe99bb0259387111d0431691f5daac84f5a5
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Aug 19 15:17:57 2014 +0300

    usb: xhci: amd chipset also needs short TX quirk
    
    AMD xHC also needs short tx quirk after tested on most of chipset
    generations. That's because there is the same incorrect behavior like
    Fresco Logic host. Please see below message with on USB webcam
    attached on xHC host:
    
    [  139.262944] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.266934] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.270913] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.274937] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.278914] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.282936] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.286915] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.290938] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.294913] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    [  139.298917] xhci_hcd 0000:00:10.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    
    Reported-by: Arindam Nath <arindam.nath@amd.com>
    Tested-by: Shriraj-Rai P <shriraj-rai.p@amd.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 687d36608155..95d0a6d984f1 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -101,6 +101,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	/* AMD PLL quirk */
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
+
+	if (pdev->vendor == PCI_VENDOR_ID_AMD)
+		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
+
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;

commit 170625e99485aac578c83fb4aa2bcd9f589570ef
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jul 25 22:01:19 2014 +0200

    xhci: Rename Asrock P67 pci product-id to EJ168
    
    The 7023 product id is the generic product id for the Etron EJ168, it is
    not specific to the version found on the Asrock P67 motherboard. The same id
    is e.g. also used on Gigabyte motherboards and on no-name pci-e usb-3 addon
    cards.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 464049f638c0..687d36608155 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -33,7 +33,7 @@
 #define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400	0x1400
 
 #define PCI_VENDOR_ID_ETRON		0x1b6f
-#define PCI_DEVICE_ID_ASROCK_P67	0x7023
+#define PCI_DEVICE_ID_EJ168		0x7023
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
@@ -140,7 +140,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
-			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
+			pdev->device == PCI_DEVICE_ID_EJ168) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci->quirks |= XHCI_BROKEN_STREAMS;

commit 8f873c1ff4ca034626093d03b254e7cb8bb782dd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jul 25 22:01:18 2014 +0200

    xhci: Blacklist using streams on the Etron EJ168 controller
    
    Streams on the EJ168 do not work as they should. I've spend 2 days trying
    to get them to work, but without success.
    
    The first problem is that when ever you ring the stream-ring doorbell, the
    controller starts executing trbs at the beginning of the first ring segment,
    event if it ended somewhere else previously. This can be worked around by
    allowing enqueing only one td (not a problem with how streams are typically
    used) and then resetting our copies of the enqueueing en dequeueing pointers
    on a td completion to match what the controller seems to be doing.
    
    This way things seem to start working with uas and instead of being able
    to complete only the very first scsi command, the scsi core can probe the disk.
    
    But then things break later on when td-s get enqueued with more then one
    trb. The controller does seem to increase its dequeue pointer while executing
    a stream-ring (data transfer events I inserted for debugging do trigger).
    However execution seems to stop at the final normal trb of a multi trb td,
    even if there is a data transfer event inserted after the final trb.
    
    The first problem alone is a serious deviation from the spec, and esp.
    dealing with cancellation would have been very tricky if not outright
    impossible, but the second problem simply is a deal breaker altogether,
    so this patch simply disables streams.
    
    Note this will cause the usb-storage + uas driver pair to automatically switch
    to using usb-storage instead of uas on these devices, essentially reverting
    to the 3.14 and earlier behavior when uas was marked CONFIG_BROKEN.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1121288
    https://bugzilla.kernel.org/show_bug.cgi?id=80101
    
    Cc: stable@vger.kernel.org # 3.15
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e20520f42753..464049f638c0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -143,6 +143,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
+		xhci->quirks |= XHCI_BROKEN_STREAMS;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
 			pdev->device == 0x0015)
@@ -230,7 +231,8 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto put_usb3_hcd;
 	/* Roothub already marked as USB 3.0 speed */
 
-	if (HCC_MAX_PSA(xhci->hcc_params) >= 4)
+	if (!(xhci->quirks & XHCI_BROKEN_STREAMS) &&
+			HCC_MAX_PSA(xhci->hcc_params) >= 4)
 		xhci->shared_hcd->can_do_streams = 1;
 
 	/* USB-2 and USB-3 roothubs initialized, allow runtime pm suspend */

commit 0a939993bff117d3657108ca13b011fc0378aedb
Author: Denis Turischev <denis.turischev@compulab.co.il>
Date:   Tue May 20 14:00:42 2014 +0300

    xhci: Switch only Intel Lynx Point-LP ports to EHCI on shutdown.
    
    Patch "xhci: Switch Intel Lynx Point ports to EHCI on shutdown."
    commit c09ec25d3684cad74d851c0f028a495999591279 is not fully correct
    
    It switches both Lynx Point and Lynx Point-LP ports to EHCI on shutdown.
    On some Lynx Point machines it causes spurious interrupt,
    which wake the system: bugzilla.kernel.org/show_bug.cgi?id=76291
    
    On Lynx Point-LP on the contrary switching ports to EHCI seems to be
    necessary to fix these spurious interrupts.
    
    Signed-off-by: Denis Turischev <denis@compulab.co.il>
    Reported-by: Wulf Richartz <wulf.richartz@gmail.com>
    Cc: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index ffd119eb3e29..e20520f42753 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -134,7 +134,9 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 */
 		if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)
 			xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
-
+	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&

commit 85f4e45b11e5d351789e09c259620d037246f6d8
Author: Oliver Neukum <oneukum@suse.de>
Date:   Wed May 14 14:00:23 2014 +0200

    xhci: unified loggig of RESET_ON_RESUME
    
    Either we log for all chips we set the quirk for or for
    none. This patch reports it for all chips.
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 35d447780707..ffd119eb3e29 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -140,8 +140,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
-		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
-				"QUIRK: Resetting on resume");
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
@@ -149,6 +147,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
+
+	if (xhci->quirks & XHCI_RESET_ON_RESUME)
+		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
+				"QUIRK: Resetting on resume");
 }
 
 /* called during probe() after chip reset completes */

commit 6db249ebefc6bf5c39f35dfaacc046d8ad3ffd70
Author: Igor Gnatenko <i.gnatenko.brain@gmail.com>
Date:   Fri Apr 25 19:20:15 2014 +0300

    xhci: extend quirk for Renesas cards
    
    After suspend another Renesas PCI-X USB 3.0 card doesn't work.
    [root@fedora-20 ~]# lspci -vmnnd 1912:
    Device: 03:00.0
    Class:  USB controller [0c03]
    Vendor: Renesas Technology Corp. [1912]
    Device: uPD720202 USB 3.0 Host Controller [0015]
    SVendor:        Renesas Technology Corp. [1912]
    SDevice:        uPD720202 USB 3.0 Host Controller [0015]
    Rev:    02
    ProgIf: 30
    
    This patch should be applied to stable kernel 3.14 that contain
    the commit 1aa9578c1a9450fb21501c4f549f5b1edb557e6d
    "xhci: Fix resume issues on Renesas chips in Samsung laptops"
    
    Reported-and-tested-by: Anatoly Kharchenko <rfr-bugs@yandex.ru>
    Reference: http://redmine.russianfedora.pro/issues/1315
    Signed-off-by: Igor Gnatenko <i.gnatenko.brain@gmail.com>
    Cc: stable@vger.kernel.org # 3.14
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1715063630bd..35d447780707 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -145,9 +145,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-			pdev->device == 0x0015 &&
-			pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG &&
-			pdev->subsystem_device == 0xc0cd)
+			pdev->device == 0x0015)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;

commit c09ec25d3684cad74d851c0f028a495999591279
Author: Denis Turischev <denis.turischev@compulab.co.il>
Date:   Fri Apr 25 19:20:14 2014 +0300

    xhci: Switch Intel Lynx Point ports to EHCI on shutdown.
    
    The same issue like with Panther Point chipsets. If the USB ports are
    switched to xHCI on shutdown, the xHCI host will send a spurious interrupt,
    which will wake the system. Some BIOS have work around for this, but not all.
    One example is Compulab's mini-desktop, the Intense-PC2.
    
    The bug can be avoided if the USB ports are switched back to EHCI on
    shutdown.
    
    This patch should be backported to stable kernels as old as 3.12,
    that contain the commit 638298dc66ea36623dbc2757a24fc2c4ab41b016
    "xhci: Fix spurious wakeups after S5 on Haswell"
    
    Signed-off-by: Denis Turischev <denis@compulab.co.il>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 47390e369cd4..1715063630bd 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -134,6 +134,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 */
 		if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)
 			xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
+
+		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {

commit bcffae7708eb8352f44dc510b326541fe43a02a4
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Mar 3 19:30:17 2014 +0200

    xhci: Prevent runtime pm from autosuspending during initialization
    
    xHCI driver has its own pci probe function that will call usb_hcd_pci_probe
    to register its usb-2 bus, and then continue to manually register the
    usb-3 bus. usb_hcd_pci_probe does a pm_runtime_put_noidle at the end and
    might thus trigger a runtime suspend before the usb-3 bus is ready.
    
    Prevent the runtime suspend by increasing the usage count in the
    beginning of xhci_pci_probe, and decrease it once the usb-3 bus is
    ready.
    
    xhci-platform driver is not using usb_hcd_pci_probe to set up
    busses and should not need to have it's usage count increased during probe.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index cbf0c5cffc92..47390e369cd4 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -190,6 +190,10 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	struct usb_hcd *hcd;
 
 	driver = (struct hc_driver *)id->driver_data;
+
+	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
+	pm_runtime_get_noresume(&dev->dev);
+
 	/* Register the USB 2.0 roothub.
 	 * FIXME: USB core must know to register the USB 2.0 roothub first.
 	 * This is sort of silly, because we could just set the HCD driver flags
@@ -199,7 +203,7 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	retval = usb_hcd_pci_probe(dev, id);
 
 	if (retval)
-		return retval;
+		goto put_runtime_pm;
 
 	/* USB 2.0 roothub is stored in the PCI device now. */
 	hcd = dev_get_drvdata(&dev->dev);
@@ -225,12 +229,17 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (HCC_MAX_PSA(xhci->hcc_params) >= 4)
 		xhci->shared_hcd->can_do_streams = 1;
 
+	/* USB-2 and USB-3 roothubs initialized, allow runtime pm suspend */
+	pm_runtime_put_noidle(&dev->dev);
+
 	return 0;
 
 put_usb3_hcd:
 	usb_put_hcd(xhci->shared_hcd);
 dealloc_usb2_hcd:
 	usb_hcd_pci_remove(dev);
+put_runtime_pm:
+	pm_runtime_put_noidle(&dev->dev);
 	return retval;
 }
 

commit 14aec589327a6fc4035f5327d90ac5548f501c4c
Author: Oliver Neukum <oneukum@suse.de>
Date:   Tue Feb 11 20:36:04 2014 +0100

    storage: accept some UAS devices if streams are unavailable
    
    On some older XHCIs streams are not supported and the UAS driver
    will fail at probe time. For those devices storage should try
    to bind to UAS devices.
    This patch adds a flag for stream support to HCDs and evaluates
    it.
    
    [Note: Sarah fixed a bug where the USB 2.0 root hub, not USB 3.0 root
    hub would get marked as being able to support streams.]
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 6c03584ac15f..cbf0c5cffc92 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -222,6 +222,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto put_usb3_hcd;
 	/* Roothub already marked as USB 3.0 speed */
 
+	if (HCC_MAX_PSA(xhci->hcc_params) >= 4)
+		xhci->shared_hcd->can_do_streams = 1;
+
 	return 0;
 
 put_usb3_hcd:

commit 25cd2882e2fc8bd8ed7acaee0ec979f11feda6d7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Jan 17 14:15:44 2014 -0800

    usb/xhci: Change how we indicate a host supports Link PM.
    
    The xHCI driver currently uses a USB core internal field,
    udev->lpm_capable, to indicate the xHCI driver knows how to calculate
    the LPM timeout values.  If this value is set for the host controller
    udev, it means Link PM can be enabled for child devices under that host.
    
    Change the code so the xHCI driver isn't mucking with USB core internal
    fields.  Instead, indicate the xHCI driver doesn't support Link PM on
    this host by clearing the U1 and U2 exit latencies in the roothub
    SuperSpeed Extended Capabilities BOS descriptor.
    
    The code to check for the roothub setting U1 and U2 exit latencies to
    zero will also disable LPM for external devices that do that same.  This
    was already effectively done with commit
    ae8963adb4ad8c5f2a89ca1d99fb7bb721e7599f "usb: Don't enable LPM if the
    exit latency is zero."  Leave that code in place, so that if a device
    sets one exit latency value to zero, but the other is set to a valid
    value, LPM is only enabled for the U1 or U2 state that had the valid
    value.  This is the same behavior the code had before.
    
    Also, change messages about missing Link PM information from warning
    level to info level.  Only print a warning about the first device that
    doesn't support LPM, to avoid log spam.  Further, cleanup some
    unnecessary line breaks to help people to grep for the error messages.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 04f986d9234f..6c03584ac15f 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -222,12 +222,6 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto put_usb3_hcd;
 	/* Roothub already marked as USB 3.0 speed */
 
-	/* We know the LPM timeout algorithms for this host, let the USB core
-	 * enable and disable LPM for devices under the USB 3.0 roothub.
-	 */
-	if (xhci->quirks & XHCI_LPM_SUPPORT)
-		hcd_to_bus(xhci->shared_hcd)->root_hub->lpm_capable = 1;
-
 	return 0;
 
 put_usb3_hcd:

commit 1aa9578c1a9450fb21501c4f549f5b1edb557e6d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Jan 17 15:38:12 2014 -0800

    xhci: Fix resume issues on Renesas chips in Samsung laptops
    
    Don Zickus <dzickus@redhat.com> writes:
    
    Some co-workers of mine bought Samsung laptops that had mostly usb3 ports.
    Those ports did not resume correctly (the driver would timeout communicating
    and fail).  This led to frustration as suspend/resume is a common use for
    laptops.
    
    Poking around, I applied the reset on resume quirk to this chipset and the
    resume started working.  Reloading the xhci_hcd module had been the temporary
    workaround.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Don Zickus <dzickus@redhat.com>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable # 2.6.37

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 3c898c12a06b..04f986d9234f 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -142,6 +142,11 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 				"QUIRK: Resetting on resume");
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
+			pdev->device == 0x0015 &&
+			pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG &&
+			pdev->subsystem_device == 0xc0cd)
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 }

commit 99f14bd4d1b2a1b1b6cd508e08efdbc5e3919198
Merge: 3482528e9ace 413541dd66d5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Dec 24 10:18:03 2013 -0800

    Merge 3.13-rc5 into usb-next
    
    This resolves the merge issue with drivers/usb/host/ohci-at91.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 48fc7dbd52c0559647291f33a10ccdc6cdbe4c72
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Dec 5 17:07:27 2013 -0800

    usb: xhci: change enumeration scheme to 'new scheme' by default
    
    Change the default enumeration scheme for xhci attached non-SuperSpeed
    devices from:
    
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(8)
       GetDescriptor(18)
    
    ...to:
    
       Reset
       [xhci address-device BSR = 1]
       GetDescriptor(64)
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(18)
    
    ...as some devices misbehave when encountering a SetAddress command
    prior to GetDescriptor.  There are known legacy devices that require
    this scheme, but testing has found at least one USB3 device that fails
    enumeration when presented with this ordering.  For now, follow the ehci
    case and enable 'new scheme' by default for non-SuperSpeed devices.
    
    To support this enumeration scheme on xhci the AddressDevice operation
    needs to be performed twice.  The first instance of the command enables
    the HC's device and slot context info for the device, but omits sending
    the device a SetAddress command (BSR == block set address request).
    Then, after GetDescriptor completes, follow up with the full
    AddressDevice+SetAddress operation.
    
    As mentioned before, this ordering of events with USB3 devices causes an
    extra state transition to be exposed to xhci.  Previously USB3 devices
    would transition directly from 'enabled' to 'addressed' and never need
    to underrun responses to 'get descriptor'. We do see the 64-byte
    descriptor fetch the correct data, but the following 18-byte descriptor
    read after the reset gets:
    
    bLength            = 0
    bDescriptorType    = 0
    bcdUSB             = 0
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    instead of:
    
    bLength            = 12
    bDescriptorType    = 1
    bcdUSB             = 300
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    which results in the discovery process looping until falling back to
    'old scheme' enumeration.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: David Moore <david.moore@gmail.com>
    Suggested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index b8dffd59eb25..4221dee924b5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -331,6 +331,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.check_bandwidth =	xhci_check_bandwidth,
 	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,
+	.enable_device =	xhci_enable_device,
 	.update_hub_device =	xhci_update_hub_device,
 	.reset_device =		xhci_discover_or_reset_device,
 

commit 6962d914f317b119e0db7189199b21ec77a4b3e0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 14:53:36 2013 +0100

    xhci: Limit the spurious wakeup fix only to HP machines
    
    We've got regression reports that my previous fix for spurious wakeups
    after S5 on HP Haswell machines leads to the automatic reboot at
    shutdown on some machines.  It turned out that the fix for one side
    triggers another BIOS bug in other side.  So, it's exclusive.
    
    Since the original S5 wakeups have been confirmed only on HP machines,
    it'd be safer to apply it only to limited machines.  As a wild guess,
    limiting to machines with HP PCI SSID should suffice.
    
    This patch should be backported to kernels as old as 3.12, that
    contain the commit 638298dc66ea36623dbc2757a24fc2c4ab41b016 "xhci: Fix
    spurious wakeups after S5 on Haswell".
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=66171
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: <dashing.meng@gmail.com>
    Reported-by: Niklas Schnelle <niklas@komani.de>
    Reported-by: Giorgos <ganastasiouGR@gmail.com>
    Reported-by: <art1@vhex.net>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index b8dffd59eb25..73f5208714a4 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -128,7 +128,12 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 * any other sleep) on Haswell machines with LPT and LPT-LP
 		 * with the new Intel BIOS
 		 */
-		xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
+		/* Limit the quirk to only known vendors, as this triggers
+		 * yet another BIOS bug on some other machines
+		 * https://bugzilla.kernel.org/show_bug.cgi?id=66171
+		 */
+		if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)
+			xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {

commit 638298dc66ea36623dbc2757a24fc2c4ab41b016
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 12 08:11:06 2013 +0200

    xhci: Fix spurious wakeups after S5 on Haswell
    
    Haswell LynxPoint and LynxPoint-LP with the recent Intel BIOS show
    mysterious wakeups after shutdown occasionally.  After discussing with
    BIOS engineers, they explained that the new BIOS expects that the
    wakeup sources are cleared and set to D3 for all wakeup devices when
    the system is going to sleep or power off, but the current xhci driver
    doesn't do this properly (partly intentionally).
    
    This patch introduces a new quirk, XHCI_SPURIOUS_WAKEUP, for
    fixing the spurious wakeups at S5 by calling xhci_reset() in the xhci
    shutdown ops as done in xhci_stop(), and setting the device to PCI D3
    at shutdown and remove ops.
    
    The PCI D3 call is based on the initial fix patch by Oliver Neukum.
    
    [Note: Sarah changed the quirk name from XHCI_HSW_SPURIOUS_WAKEUP to
    XHCI_SPURIOUS_WAKEUP, since none of the other quirks have system names
    in them.  Sarah also fixed a collision with a quirk submitted around the
    same time, by changing the xhci->quirks bit from 17 to 18.]
    
    This patch should be backported to kernels as old as 3.0, that
    contain the commit 1c12443ab8eba71a658fae4572147e56d1f84f66 "xhci: Add
    Lynx Point to list of Intel switchable hosts."
    
    Cc: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 5444ecdbfb92..b8dffd59eb25 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -35,6 +35,9 @@
 #define PCI_VENDOR_ID_ETRON		0x1b6f
 #define PCI_DEVICE_ID_ASROCK_P67	0x7023
 
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
+
 static const char hcd_name[] = "xhci_hcd";
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -118,6 +121,15 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci->quirks |= XHCI_AVOID_BEI;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI)) {
+		/* Workaround for occasional spurious wakeups from S5 (or
+		 * any other sleep) on Haswell machines with LPT and LPT-LP
+		 * with the new Intel BIOS
+		 */
+		xhci->quirks |= XHCI_SPURIOUS_WAKEUP;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
@@ -225,6 +237,11 @@ static void xhci_pci_remove(struct pci_dev *dev)
 		usb_put_hcd(xhci->shared_hcd);
 	}
 	usb_hcd_pci_remove(dev);
+
+	/* Workaround for spurious wakeups at shutdown with HSW */
+	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
+		pci_set_power_state(dev, PCI_D3hot);
+
 	kfree(xhci);
 }
 

commit 455f58925247e8a1a1941e159f3636ad6ee4c90b
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Sep 30 15:50:54 2013 +0200

    xhci: quirk for extra long delay for S4
    
    It has been reported that this chipset really cannot
    sleep without this extraordinary delay.
    
    This patch should be backported, in order to ensure this host functions
    under stable kernels.  The last quirk for Fresco Logic hosts (commit
    bba18e33f25072ebf70fd8f7f0cdbf8cdb59a746 "xhci: Extend Fresco Logic MSI
    quirk.") was backported to stable kernels as old as 2.6.36.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 236c3aabe940..5444ecdbfb92 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -69,6 +69,14 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 				"QUIRK: Fresco Logic xHC needs configure"
 				" endpoint cmd after reset endpoint");
 		}
+		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
+				pdev->revision == 0x4) {
+			xhci->quirks |= XHCI_SLOW_SUSPEND;
+			xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
+				"QUIRK: Fresco Logic xHC revision %u"
+				"must be suspended extra slowly",
+				pdev->revision);
+		}
 		/* Fresco Logic confirms: all revisions of this chip do not
 		 * support MSI, even though some of them claim to in their PCI
 		 * capabilities.

commit f875fdbf344b9fde207f66b392c40845dd7e5aa6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 24 15:45:25 2013 -0400

    USB: fix PM config symbol in uhci-hcd, ehci-hcd, and xhci-hcd
    
    Since uhci-hcd, ehci-hcd, and xhci-hcd support runtime PM, the .pm
    field in their pci_driver structures should be protected by CONFIG_PM
    rather than CONFIG_PM_SLEEP.  The corresponding change has already
    been made for ohci-hcd.
    
    Without this change, controllers won't do runtime suspend if system
    suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c2d495057eb5..236c3aabe940 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -351,7 +351,7 @@ static struct pci_driver xhci_pci_driver = {
 	/* suspend and resume implemented later */
 
 	.shutdown = 	usb_hcd_pci_shutdown,
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver = {
 		.pm = &usb_hcd_pci_pm_ops
 	},

commit 4bdfe4c38fd5b06da558050a3288a0a48825a3e7
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Aug 6 07:52:45 2013 +0300

    xhci: add trace for debug messages related to quirks
    
    This patch defines a new trace event, which is called xhci_dbg_quirks
    and belongs in the event class xhci_log_msg, and adds tracepoints that
    trace the debug messages associated with xHCs' quirks.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 72960684a942..c2d495057eb5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 
 #include "xhci.h"
+#include "xhci-trace.h"
 
 /* Device for a quirk */
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
@@ -64,16 +65,18 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
 				pdev->revision == 0x0) {
 			xhci->quirks |= XHCI_RESET_EP_QUIRK;
-			xhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"
-					" endpoint cmd after reset endpoint\n");
+			xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
+				"QUIRK: Fresco Logic xHC needs configure"
+				" endpoint cmd after reset endpoint");
 		}
 		/* Fresco Logic confirms: all revisions of this chip do not
 		 * support MSI, even though some of them claim to in their PCI
 		 * capabilities.
 		 */
 		xhci->quirks |= XHCI_BROKEN_MSI;
-		xhci_dbg(xhci, "QUIRK: Fresco Logic revision %u "
-				"has broken MSI implementation\n",
+		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
+				"QUIRK: Fresco Logic revision %u "
+				"has broken MSI implementation",
 				pdev->revision);
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
@@ -110,7 +113,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
-		xhci_dbg(xhci, "QUIRK: Resetting on resume\n");
+		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
+				"QUIRK: Resetting on resume");
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)

commit 78283dd29e647775cb1e63a4d6554b3090b9a9ff
Merge: 435932f2c75e 5ae90d8e467e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 29 07:43:16 2013 -0700

    Merge 3.11-rc3 into usb-next

commit 07f3cb7c28bf3f4dd80bfb136cf45810c46ac474
Author: George Cherian <george.cherian@ti.com>
Date:   Mon Jul 1 10:59:12 2013 +0530

    usb: host: xhci: Enable XHCI_SPURIOUS_SUCCESS for all controllers with xhci 1.0
    
    Xhci controllers with hci_version > 0.96 gives spurious success
    events on short packet completion. During webcam capture the
    "ERROR Transfer event TRB DMA ptr not part of current TD" was observed.
    The same application works fine with synopsis controllers hci_version 0.96.
    The same issue is seen with Intel Pantherpoint xhci controller. So enabling
    this quirk in xhci_gen_setup if controller verion is greater than 0.96.
    For xhci-pci move the quirk to much generic place xhci_gen_setup.
    
    Note from Sarah:
    
    The xHCI 1.0 spec changed how hardware handles short packets.  The HW
    will notify SW of the TRB where the short packet occurred, and it will
    also give a successful status for the last TRB in a TD (the one with the
    IOC flag set).  On the second successful status, that warning will be
    triggered in the driver.
    
    Software is now supposed to not assume the TD is not completed until it
    gets that last successful status.  That means we have a slight race
    condition, although it should have little practical impact.  This patch
    papers over that issue.
    
    It's on my long-term to-do list to fix this race condition, but it is a
    much more involved patch that will probably be too big for stable.  This
    patch is needed for stable to avoid serious log spam.
    
    This patch should be backported to kernels as old as 3.0, that
    contain the commit ad808333d8201d53075a11bc8dd83b81f3d68f0b "Intel xhci:
    Ignore spurious successful event."
    
    The patch will have to be modified for kernels older than 3.2, since
    that kernel added the xhci_gen_setup function for xhci platform devices.
    The correct conflict resolution for kernels older than 3.2 is to set
    XHCI_SPURIOUS_SUCCESS in xhci_pci_quirks for all xHCI 1.0 hosts.
    
    Signed-off-by: George Cherian <george.cherian@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index cc24e39b97d5..f00cb203faea 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -93,7 +93,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
-		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;
 		xhci->quirks |= XHCI_EP_LIMIT_QUIRK;
 		xhci->limit_active_eps = 64;
 		xhci->quirks |= XHCI_SW_BW_CHECKING;

commit 26b76798e0507429506b93cd49f8c4cfdab06896
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jul 23 11:35:47 2013 +0300

    Intel xhci: refactor EHCI/xHCI port switching
    
    Make the Linux xHCI driver automatically try to switchover the EHCI ports to
    xHCI when an Intel xHCI host is detected, and it also finds an Intel EHCI host.
    
    This means we will no longer have to add Intel xHCI hosts to a quirks list when
    the PCI device IDs change.  Simply continuing to add new Intel xHCI PCI device
    IDs to the quirks list is not sustainable.
    
    During suspend ports may be swicthed back to EHCI by BIOS and not properly
    restored to xHCI at resume. Previously both EHCI and xHCI resume functions
    switched ports back to XHCI, but it's enough to do it in xHCI only
    because the hub driver doesn't start running again until after both hosts are resumed.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index cc24e39b97d5..475e06e10a77 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -250,13 +250,15 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	 * writers.
 	 *
 	 * Unconditionally switch the ports back to xHCI after a system resume.
-	 * We can't tell whether the EHCI or xHCI controller will be resumed
-	 * first, so we have to do the port switchover in both drivers.  Writing
-	 * a '1' to the port switchover registers should have no effect if the
-	 * port was already switched over.
+	 * It should not matter whether the EHCI or xHCI controller is
+	 * resumed first. It's enough to do the switchover in xHCI because
+	 * USB core won't notice anything as the hub driver doesn't start
+	 * running again until after all the devices (including both EHCI and
+	 * xHCI host controllers) have been resumed.
 	 */
-	if (usb_is_intel_switchable_xhci(pdev))
-		usb_enable_xhci_ports(pdev);
+
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
+		usb_enable_intel_xhci_ports(pdev);
 
 	retval = xhci_resume(xhci, hibernated);
 	return retval;

commit c3897aa5386faba77e5bbdf94902a1658d3a5b11
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Apr 18 10:02:03 2013 -0700

    xhci: Disable D3cold for buggy TI redrivers.
    
    Some xHCI hosts contain a "redriver" from TI that silently drops port
    status connect changes if the port slips into Compliance Mode.  If the
    port slips into compliance mode while the host is in D0, there will not
    be a port status change event.  If the port slips into compliance mode
    while the host is in D3, the host will not send a PME.  This includes
    when the system is suspended (S3) or hibernated (S4).
    
    If this happens when the system is in S3/S4, there is nothing software
    can do.  Other port status change events that would normally cause the
    host to wake the system from S3/S4 may also be lost.  This includes
    remote wakeup, disconnects and connects on other ports, and overrcurrent
    events.  A decision was made to _NOT_ disable system suspend/hibernate
    on these systems, since users are unlikely to enable wakeup from S3/S4
    for the xHCI host.
    
    Software can deal with this issue when the system is in S0.  A work
    around was put in to poll the port status registers for Compliance Mode.
    The xHCI driver will continue to poll the registers while the host is
    runtime suspended.  Unfortunately, that means we can't allow the PCI
    device to go into D3cold, because power will be removed from the host,
    and the config space will read as all Fs.
    
    Disable D3cold in the xHCI PCI runtime suspend function.
    
    This patch should be backported to kernels as old as 3.2, that
    contain the commit 71c731a296f1b08a3724bd1b514b64f1bda87a23 "usb: host:
    xhci: Fix Compliance Mode on SN65LVPE502CP Hardware"
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1a30c380043c..cc24e39b97d5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -221,6 +221,14 @@ static void xhci_pci_remove(struct pci_dev *dev)
 static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+
+	/*
+	 * Systems with the TI redriver that loses port status change events
+	 * need to have the registers polled during D3, so avoid D3cold.
+	 */
+	if (xhci_compliance_mode_recovery_timer_quirk_check())
+		pdev->no_d3cold = true;
 
 	return xhci_suspend(xhci);
 }

commit 3f5eb14135ba9d97ba4b8514fc7ef5e0dac2abf4
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Mar 19 16:48:12 2013 +0800

    usb: add find_raw_port_number callback to struct hc_driver()
    
    xhci driver divides the root hub into two logical hubs which work
    respectively for usb 2.0 and usb 3.0 devices. They are independent
    devices in the usb core. But in the ACPI table, it's one device node
    and all usb2.0 and usb3.0 ports are under it. Binding usb port with
    its acpi node needs the raw port number which is reflected in the xhci
    extended capabilities table. This patch is to add find_raw_port_number
    callback to struct hc_driver(), fill it with xhci_find_raw_port_number()
    which will return raw port number and add a wrap usb_hcd_find_raw_port_number().
    
    Otherwise, refactor xhci_find_real_port_number(). Using
    xhci_find_raw_port_number() to get real index in the HW port status
    registers instead of scanning through the xHCI roothub port array.
    This can help to speed up.
    
    All addresses in xhci->usb2_ports and xhci->usb3_ports array are
    kown good ports and don't include following bad ports in the extended
    capabilities talbe.
         (1) root port that doesn't have an entry
         (2) root port with unknown speed
         (3) root port that is listed twice and with different speeds.
    
    So xhci_find_raw_port_number() will only return port num of good ones
    and never touch bad ports above.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index af259e0ec172..1a30c380043c 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -313,6 +313,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.set_usb2_hw_lpm =	xhci_set_usb2_hardware_lpm,
 	.enable_usb3_lpm_timeout =	xhci_enable_usb3_lpm_timeout,
 	.disable_usb3_lpm_timeout =	xhci_disable_usb3_lpm_timeout,
+	.find_raw_port_number =	xhci_find_raw_port_number,
 };
 
 /*-------------------------------------------------------------------------*/

commit 77b847677e7cb633627a9ddaa7efbc3fa8586427
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Oct 19 10:55:16 2012 +0300

    usb: host: xhci: move HC_STATE_SUSPENDED check to xhci_suspend()
    
    that check will have to be done by all users
    of xhci_suspend() so it sounds a lot better to
    move the check to xhci_suspend() in order to
    avoid code duplication.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index dcb72f724d0e..af259e0ec172 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -221,15 +221,8 @@ static void xhci_pci_remove(struct pci_dev *dev)
 static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
-	int	retval = 0;
 
-	if (hcd->state != HC_STATE_SUSPENDED ||
-			xhci->shared_hcd->state != HC_STATE_SUSPENDED)
-		return -EINVAL;
-
-	retval = xhci_suspend(xhci);
-
-	return retval;
+	return xhci_suspend(xhci);
 }
 
 static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)

commit bba18e33f25072ebf70fd8f7f0cdbf8cdb59a746
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Oct 17 13:44:06 2012 -0700

    xhci: Extend Fresco Logic MSI quirk.
    
    Ali reports that plugging a device into the Fresco Logic xHCI host with
    PCI device ID 1400 produces an IRQ error:
    
     do_IRQ: 3.176 No irq handler for vector (irq -1)
    
    Other early Fresco Logic host revisions don't support MSI, even though
    their PCI config space claims they do.  Extend the quirk to disabling
    MSI to this chipset revision.  Also enable the short transfer quirk,
    since it's likely this revision also has that quirk, and it should be
    harmless to enable.
    
    04:00.0 0c03: 1b73:1400 (rev 01) (prog-if 30 [XHCI])
            Subsystem: 1d5c:1000
            Physical Slot: 3
            Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
            Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- INTx-
            Latency: 0, Cache Line Size: 64 bytes
            Interrupt: pin A routed to IRQ 51
            Region 0: Memory at d4600000 (32-bit, non-prefetchable) [size=64K]
            Capabilities: [50] Power Management version 3
                    Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)
                    Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-
            Capabilities: [68] MSI: Enable+ Count=1/1 Maskable- 64bit+
                    Address: 00000000feeff00c  Data: 41b1
            Capabilities: [80] Express (v1) Endpoint, MSI 00
                    DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s <2us, L1 <32us
                            ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset-
                    DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
                            RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
                            MaxPayload 128 bytes, MaxReadReq 512 bytes
                    DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-
                    LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s L1, Latency L0 unlimited, L1 unlimited
                            ClockPM- Surprise- LLActRep- BwNot-
                    LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk+
                            ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                    LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
            Kernel driver in use: xhci_hcd
    
    This patch should be backported to stable kernels as old as 2.6.36, that
    contain the commit f5182b4155b9d686c5540a6822486400e34ddd98 "xhci:
    Disable MSI for some Fresco Logic hosts."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: A Sh <smr.ash1991@gmail.com>
    Tested-by: A Sh <smr.ash1991@gmail.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 8345d7c23061..dcb72f724d0e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -29,6 +29,7 @@
 /* Device for a quirk */
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
 #define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
+#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400	0x1400
 
 #define PCI_VENDOR_ID_ETRON		0x1b6f
 #define PCI_DEVICE_ID_ASROCK_P67	0x7023
@@ -58,8 +59,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 
 	/* Look for vendor-specific quirks */
 	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
-			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {
-		if (pdev->revision == 0x0) {
+			(pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK ||
+			 pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1400)) {
+		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
+				pdev->revision == 0x0) {
 			xhci->quirks |= XHCI_RESET_EP_QUIRK;
 			xhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"
 					" endpoint cmd after reset endpoint\n");

commit 80fab3b244a22e0ca539d2439bdda50e81e5666f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Sep 19 16:27:26 2012 -0700

    xhci: Intel Panther Point BEI quirk.
    
    When a device with an isochronous endpoint is behind a hub plugged into
    the Intel Panther Point xHCI host controller, and the driver submits
    multiple frames per URB, the xHCI driver will set the Block Event
    Interrupt (BEI) flag on all but the last TD for the URB.  This causes
    the host controller to place an event on the event ring, but not send an
    interrupt.  When the last TD for the URB completes, BEI is cleared, and
    we get an interrupt for the whole URB.
    
    However, under a Panther Point xHCI host controller, if the parent hub
    is unplugged when one or more events from transfers with BEI set are on
    the event ring, a port status change event is placed on the event ring,
    but no interrupt is generated.  This means URBs stop completing, and the
    USB device disconnect is not noticed.  Something like a USB headset will
    cause mplayer to hang when the device is disconnected.
    
    If another transfer is sent (such as running `sudo lsusb -v`), the next
    transfer event seems to "unstick" the event ring, the xHCI driver gets
    an interrupt, and the disconnect is reported to the USB core.
    
    The fix is not to use the BEI flag under the Panther Point xHCI host.
    This will impact power consumption and system responsiveness, because
    the xHCI driver will receive an interrupt for every frame in all
    isochronous URBs instead of once per URB.
    
    Intel chipset developers confirm that this bug will be hit if the BEI
    flag is used on any endpoint, not just ones that are behind a hub.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 69e848c2090aebba5698a1620604c7dccb448684 "Intel xhci: Support
    EHCI/xHCI port switching."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 9bfd4ca1153c..8345d7c23061 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -103,6 +103,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 * PPT chipsets.
 		 */
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
+		xhci->quirks |= XHCI_AVOID_BEI;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {

commit e95829f474f0db3a4d940cae1423783edd966027
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 23 18:59:30 2012 +0300

    xhci: Switch PPT ports to EHCI on shutdown.
    
    The Intel desktop boards DH77EB and DH77DF have a hardware issue that
    can be worked around by BIOS.  If the USB ports are switched to xHCI on
    shutdown, the xHCI host will send a spurious interrupt, which will wake
    the system.  Some BIOS will work around this, but not all.
    
    The bug can be avoided if the USB ports are switched back to EHCI on
    shutdown.  The Intel Windows driver switches the ports back to EHCI, so
    change the Linux xHCI driver to do the same.
    
    Unfortunately, we can't tell the two effected boards apart from other
    working motherboards, because the vendors will change the DMI strings
    for the DH77EB and DH77DF boards to their own custom names.  One example
    is Compulab's mini-desktop, the Intense-PC.  Instead, key off the
    Panther Point xHCI host PCI vendor and device ID, and switch the ports
    over for all PPT xHCI hosts.
    
    The only impact this will have on non-effected boards is to add a couple
    hundred milliseconds delay on boot when the BIOS has to switch the ports
    over from EHCI to xHCI.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 69e848c2090aebba5698a1620604c7dccb448684 "Intel xhci: Support
    EHCI/xHCI port switching."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Denis Turischev <denis@compulab.co.il>
    Tested-by: Denis Turischev <denis@compulab.co.il>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 92eaff6097c0..9bfd4ca1153c 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -94,6 +94,15 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_EP_LIMIT_QUIRK;
 		xhci->limit_active_eps = 64;
 		xhci->quirks |= XHCI_SW_BW_CHECKING;
+		/*
+		 * PPT desktop boards DH77EB and DH77DF will power back on after
+		 * a few seconds of being shutdown.  The fix for this is to
+		 * switch the ports from xHCI to EHCI on shutdown.  We can't use
+		 * DMI information to find those particular boards (since each
+		 * vendor will change the board name), so we have to key off all
+		 * PPT chipsets.
+		 */
+		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {

commit 5cb7df2b2d3afee7638b3ef23a5bcb89c6f07bd9
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 2 13:36:23 2012 -0700

    xhci: Add Etron XHCI_TRUST_TX_LENGTH quirk.
    
    Gary reports that with recent kernels, he notices more xHCI driver
    warnings:
    
    xhci_hcd 0000:03:00.0: WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?
    
    We think his Etron xHCI host controller may have the same buggy behavior
    as the Fresco Logic xHCI host.  When a short transfer is received, the
    host will mark the transfer as successfully completed when it should be
    marking it with a short completion.
    
    Fix this by turning on the XHCI_TRUST_TX_LENGTH quirk when the Etron
    host is discovered.  Note that Gary has revision 1, but if Etron fixes
    this bug in future revisions, the quirk will have no effect.
    
    This patch should be backported to kernels as old as 2.6.36, that
    contain a backported version of commit
    1530bbc6272d9da1e39ef8e06190d42c13a02733 "xhci: Add new short TX quirk
    for Fresco Logic host."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Gary E. Miller <gem@rellim.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 18b231b0c5d3..92eaff6097c0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -99,6 +99,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci_dbg(xhci, "QUIRK: Resetting on resume\n");
+		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;

commit e3567d2c15a7a8e2f992a5f7c7683453ca406d82
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 16 13:36:24 2012 -0700

    xhci: Add Intel U1/U2 timeout policy.
    
    All Intel xHCI host controllers support USB 3.0 Link Power Management.
    
    The Panther Point xHCI host controller needs the xHCI driver to
    calculate the U1 and U2 timeout values, because it will blindly accept a
    MEL that would cause scheduling issues.
    
    The Lynx Point xHCI host controller will reject MEL values that are too
    high, but internally it implements the same algorithm that is needed for
    Panther Point xHCI.
    
    Simplify the code paths by just having the xHCI driver calculate what
    the U1/U2 timeouts should be.  Comments on the policy are in the code.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 890ba735dee7..18b231b0c5d3 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -84,6 +84,10 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	/* AMD PLL quirk */
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
+		xhci->quirks |= XHCI_LPM_SUPPORT;
+		xhci->quirks |= XHCI_INTEL_HOST;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;

commit 3b3db026414bba1c8f45c49d5eeaefd48d66e1ae
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 9 10:55:03 2012 -0700

    xhci: Add infrastructure for host-specific LPM policies.
    
    The choice of U1 and U2 timeouts for USB 3.0 Link Power Management (LPM)
    is highly host controller specific.  Here are a few examples of why it's
    host specific:
    
     1. Setting the U1/U2 timeout too short may cause the link to go into
        U1/U2 in between service intervals, which some hosts may tolerate,
        and some may not.
    
     2. The host controller has to modify its bus schedule in order to take
        into account the Maximum Exit Latency (MEL) to bring all the links
        from the host to the device into U0.  If the MEL is too big, and it
        takes too long to bring the links into an active state, the host
        controller may not be able to service periodic endpoints in time.
    
     3. Host controllers may also have scheduling limitations that force
        them to disable U1 or U2 if a USB device is behind too many tiers of
        hubs.
    
    We could take an educated guess at what U1/U2 timeouts may work for a
    particular host controller.  However, that would result in a binary
    search on every new configuration or alt setting installation, with
    multiple failed Evaluate Context commands.  Worse, the host may blindly
    accept the timeouts and just fail to update its schedule for U1/U2 exit
    latencies, which could result in randomly delayed periodic transfers.
    
    Since we don't want to cause jitter in periodic transfers, or delay
    config/alt setting changes too much, lay down a framework that xHCI
    vendors can extend in order to add their own U1/U2 timeout policies.
    
    To extend the framework, they will need to:
    
     - Modify the PCI init code to add a new xhci->quirk for their host, and
       set the XHCI_LPM_SUPPORT quirk flag.
     - Add their own vendor-specific hooks, like the ones that will be added
       in xhci_call_host_update_timeout_for_endpoint() and
       xhci_check_tier_policy()
     - Make the LPM enable/disable methods call those functions based on the
       xhci->quirk for their host.
    
    An example will be provided for the Intel xHCI host controller in the
    next patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 19e89216436e..890ba735dee7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -170,6 +170,13 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (retval)
 		goto put_usb3_hcd;
 	/* Roothub already marked as USB 3.0 speed */
+
+	/* We know the LPM timeout algorithms for this host, let the USB core
+	 * enable and disable LPM for devices under the USB 3.0 roothub.
+	 */
+	if (xhci->quirks & XHCI_LPM_SUPPORT)
+		hcd_to_bus(xhci->shared_hcd)->root_hub->lpm_capable = 1;
+
 	return 0;
 
 put_usb3_hcd:
@@ -293,6 +300,8 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	 */
 	.update_device =        xhci_update_device,
 	.set_usb2_hw_lpm =	xhci_set_usb2_hardware_lpm,
+	.enable_usb3_lpm_timeout =	xhci_enable_usb3_lpm_timeout,
+	.disable_usb3_lpm_timeout =	xhci_disable_usb3_lpm_timeout,
 };
 
 /*-------------------------------------------------------------------------*/

commit 1530bbc6272d9da1e39ef8e06190d42c13a02733
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue May 8 09:22:49 2012 -0700

    xhci: Add new short TX quirk for Fresco Logic host.
    
    Sergio reported that when he recorded audio from a USB headset mic
    plugged into the USB 3.0 port on his ASUS N53SV-DH72, the audio sounded
    "robotic".  When plugged into the USB 2.0 port under EHCI on the same
    laptop, the audio sounded fine.  The device is:
    
    Bus 002 Device 004: ID 046d:0a0c Logitech, Inc. Clear Chat Comfort USB Headset
    
    The problem was tracked down to the Fresco Logic xHCI host controller
    not correctly reporting short transfers on isochronous IN endpoints.
    The driver would submit a 96 byte transfer, the device would only send
    88 or 90 bytes, and the xHCI host would report the transfer had a
    "successful" completion code, with an untransferred buffer length of 8
    or 6 bytes.
    
    The successful completion code and non-zero untransferred length is a
    contradiction.  The xHCI host is supposed to only mark a transfer as
    successful if all the bytes are transferred.  Otherwise, the transfer
    should be marked with a short packet completion code.  Without the EHCI
    bus trace, we wouldn't know whether the xHCI driver should trust the
    completion code or the untransferred length.  With it, we know to trust
    the untransferred length.
    
    Add a new xHCI quirk for the Fresco Logic host controller.  If a
    transfer is reported as successful, but the untransferred length is
    non-zero, print a warning.  For the Fresco Logic host, change the
    completion code to COMP_SHORT_TX and process the transfer like a short
    transfer.
    
    This should be backported to stable kernels that contain the commit
    f5182b4155b9d686c5540a6822486400e34ddd98 "xhci: Disable MSI for some
    Fresco Logic hosts."  That commit was marked for stable kernels as old
    as 2.6.36.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Sergio Correia <lists@uece.net>
    Tested-by: Sergio Correia <lists@uece.net>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7a856a767e77..19e89216436e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -72,6 +72,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci_dbg(xhci, "QUIRK: Fresco Logic revision %u "
 				"has broken MSI implementation\n",
 				pdev->revision);
+		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 	}
 
 	if (pdev->vendor == PCI_VENDOR_ID_NEC)

commit 457a4f61f9bfc3ae76e5b49f30f25d86bb696f67
Author: Elric Fu <elricfu1@gmail.com>
Date:   Thu Mar 29 15:47:50 2012 +0800

    xHCI: add XHCI_RESET_ON_RESUME quirk for VIA xHCI host
    
    The suspend operation of VIA xHCI host have some issues and
    hibernate operation works fine, so The XHCI_RESET_ON_RESUME
    quirk is added for it.
    
    This patch should base on "xHCI: Don't write zeroed pointer
    to xHC registers" that is released by Sarah. Otherwise, the
    host system error will ocurr in the hibernate operation
    process.
    
    This should be backported to stable kernels as old as 2.6.37,
    that contain the commit c877b3b2ad5cb9d4fe523c5496185cc328ff3ae9
    "xhci: Add reset on resume quirk for asrock p67 host".
    
    Signed-off-by: Elric Fu <elricfu1@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 0d7b85135965..7a856a767e77 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -95,6 +95,8 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci_dbg(xhci, "QUIRK: Resetting on resume\n");
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_VIA)
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
 }
 
 /* called during probe() after chip reset completes */

commit a46c46a1d752756ba159dd454b746a3fb735c4f5
Author: Gerard Snitselaar <dev@snitselaar.org>
Date:   Fri Mar 16 11:34:11 2012 -0700

    usb: xhci: fix section mismatch in linux-next
    
    xhci_unregister_pci() is called in xhci_hcd_init().
    
    Signed-off-by: Gerard Snitselaar <dev@snitselaar.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index ef98b38626fb..0d7b85135965 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -326,7 +326,7 @@ int __init xhci_register_pci(void)
 	return pci_register_driver(&xhci_pci_driver);
 }
 
-void __exit xhci_unregister_pci(void)
+void xhci_unregister_pci(void)
 {
 	pci_unregister_driver(&xhci_pci_driver);
 }

commit 6eb0de827084060e6607c8f8542d9e9566214538
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 16:09:31 2011 -0400

    usb: Add module.h to drivers/usb consumers who really use it.
    
    The situation up to this point meant that module.h was pretty
    much everywhere, regardless of whether you asked for it or not.
    We are fixing that, so give the USB folks who want it an actual
    include of it.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 9f51f88cc0f5..ef98b38626fb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -22,6 +22,7 @@
 
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 
 #include "xhci.h"
 

commit 0cc47d547d7a482434926331265b3713381b1e60
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 23 14:20:02 2011 -0700

    usb/xhci: remove CONFIG_PCI in xhci.c's probe function
    
    This removes the need of ifdefs within the init function and with it the
    headache about the correct clean without bus X but with bus/platform Y &
    Z.
    xhci-pci is only compiled if CONFIG_PCI is selected which can be
    de-selected now without trouble. For now the result is kinda useless
    because we have no other glue code. However, since nobody is using
    USB_ARCH_HAS_XHCI then it should not be an issue :)
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e2c82d1249c2..9f51f88cc0f5 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -320,12 +320,12 @@ static struct pci_driver xhci_pci_driver = {
 #endif
 };
 
-int xhci_register_pci(void)
+int __init xhci_register_pci(void)
 {
 	return pci_register_driver(&xhci_pci_driver);
 }
 
-void xhci_unregister_pci(void)
+void __exit xhci_unregister_pci(void)
 {
 	pci_unregister_driver(&xhci_pci_driver);
 }

commit 552e0c4f12fef0ad1caf21d2b57ac3a2735edef3
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 23 14:20:01 2011 -0700

    usb/xhci: move xhci_gen_setup() away from -pci.
    
    xhci_gen_setup() is generic so it can be used to perform the bare xhci
    setup even on non-pci based platform. The typedef for the function
    pointer is moved into the headerfile
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index ca56af5e01bc..e2c82d1249c2 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -51,97 +51,6 @@ static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 	return 0;
 }
 
-typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
-
-static int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
-{
-	struct xhci_hcd		*xhci;
-	struct device		*dev = hcd->self.controller;
-	int			retval;
-	u32			temp;
-
-	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;
-
-	if (usb_hcd_is_primary_hcd(hcd)) {
-		xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
-		if (!xhci)
-			return -ENOMEM;
-		*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
-		xhci->main_hcd = hcd;
-		/* Mark the first roothub as being USB 2.0.
-		 * The xHCI driver will register the USB 3.0 roothub.
-		 */
-		hcd->speed = HCD_USB2;
-		hcd->self.root_hub->speed = USB_SPEED_HIGH;
-		/*
-		 * USB 2.0 roothub under xHCI has an integrated TT,
-		 * (rate matching hub) as opposed to having an OHCI/UHCI
-		 * companion controller.
-		 */
-		hcd->has_tt = 1;
-	} else {
-		/* xHCI private pointer was set in xhci_pci_probe for the second
-		 * registered roothub.
-		 */
-		xhci = hcd_to_xhci(hcd);
-		temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
-		if (HCC_64BIT_ADDR(temp)) {
-			xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-			dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
-		} else {
-			dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
-		}
-		return 0;
-	}
-
-	xhci->cap_regs = hcd->regs;
-	xhci->op_regs = hcd->regs +
-		HC_LENGTH(xhci_readl(xhci, &xhci->cap_regs->hc_capbase));
-	xhci->run_regs = hcd->regs +
-		(xhci_readl(xhci, &xhci->cap_regs->run_regs_off) & RTSOFF_MASK);
-	/* Cache read-only capability registers */
-	xhci->hcs_params1 = xhci_readl(xhci, &xhci->cap_regs->hcs_params1);
-	xhci->hcs_params2 = xhci_readl(xhci, &xhci->cap_regs->hcs_params2);
-	xhci->hcs_params3 = xhci_readl(xhci, &xhci->cap_regs->hcs_params3);
-	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hc_capbase);
-	xhci->hci_version = HC_VERSION(xhci->hcc_params);
-	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
-	xhci_print_registers(xhci);
-
-	get_quirks(dev, xhci);
-
-	/* Make sure the HC is halted. */
-	retval = xhci_halt(xhci);
-	if (retval)
-		goto error;
-
-	xhci_dbg(xhci, "Resetting HCD\n");
-	/* Reset the internal HC memory state and registers. */
-	retval = xhci_reset(xhci);
-	if (retval)
-		goto error;
-	xhci_dbg(xhci, "Reset complete\n");
-
-	temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
-	if (HCC_64BIT_ADDR(temp)) {
-		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
-	} else {
-		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
-	}
-
-	xhci_dbg(xhci, "Calling HCD init\n");
-	/* Initialize HCD and host controller data structures. */
-	retval = xhci_init(hcd);
-	if (retval)
-		goto error;
-	xhci_dbg(xhci, "Called HCD init\n");
-	return 0;
-error:
-	kfree(xhci);
-	return retval;
-}
-
 static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 {
 	struct pci_dev		*pdev = to_pci_dev(dev);

commit da3c9c4fc5ff47da0febb7658c51d20d22e34f58
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 23 14:20:00 2011 -0700

    usb/xhci: refactor xhci_pci_setup()
    
    xhci_pci_setup() is split into three pieces:
    
    - xhci_gen_setup()
      The major remaining of xhci_pci_setup() is now containing the generic
      part of the xhci setup. It allocates the xhci struct, setup
      hcs_params? and friends, performs xhci_halt(), xhci_init and so one.
      It also obtains the quirks via a callback
    - xhci_pci_quirks()
      It checks the origin of the xhci core and sets core specific quirks.
    - xhci_pci_setup()
      PCI specific setup functions. Besides calling xhci_gen_setup() with
      xhci_pci_quirks() as an argument it performs PCI specific setup like
      obtaining the address of sbrn via a PCI config space.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 732837eafabe..ca56af5e01bc 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -51,11 +51,12 @@ static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 	return 0;
 }
 
-/* called during probe() after chip reset completes */
-static int xhci_pci_setup(struct usb_hcd *hcd)
+typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
+
+static int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 {
 	struct xhci_hcd		*xhci;
-	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	struct device		*dev = hcd->self.controller;
 	int			retval;
 	u32			temp;
 
@@ -107,6 +108,44 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
 	xhci_print_registers(xhci);
 
+	get_quirks(dev, xhci);
+
+	/* Make sure the HC is halted. */
+	retval = xhci_halt(xhci);
+	if (retval)
+		goto error;
+
+	xhci_dbg(xhci, "Resetting HCD\n");
+	/* Reset the internal HC memory state and registers. */
+	retval = xhci_reset(xhci);
+	if (retval)
+		goto error;
+	xhci_dbg(xhci, "Reset complete\n");
+
+	temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
+	if (HCC_64BIT_ADDR(temp)) {
+		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
+	} else {
+		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
+	}
+
+	xhci_dbg(xhci, "Calling HCD init\n");
+	/* Initialize HCD and host controller data structures. */
+	retval = xhci_init(hcd);
+	if (retval)
+		goto error;
+	xhci_dbg(xhci, "Called HCD init\n");
+	return 0;
+error:
+	kfree(xhci);
+	return retval;
+}
+
+static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
 	/* Look for vendor-specific quirks */
 	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
 			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {
@@ -146,33 +185,22 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci_dbg(xhci, "QUIRK: Resetting on resume\n");
 	}
+}
 
-	/* Make sure the HC is halted. */
-	retval = xhci_halt(xhci);
-	if (retval)
-		goto error;
+/* called during probe() after chip reset completes */
+static int xhci_pci_setup(struct usb_hcd *hcd)
+{
+	struct xhci_hcd		*xhci;
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	int			retval;
 
-	xhci_dbg(xhci, "Resetting HCD\n");
-	/* Reset the internal HC memory state and registers. */
-	retval = xhci_reset(xhci);
+	retval = xhci_gen_setup(hcd, xhci_pci_quirks);
 	if (retval)
-		goto error;
-	xhci_dbg(xhci, "Reset complete\n");
-
-	temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
-	if (HCC_64BIT_ADDR(temp)) {
-		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
-	} else {
-		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
-	}
+		return retval;
 
-	xhci_dbg(xhci, "Calling HCD init\n");
-	/* Initialize HCD and host controller data structures. */
-	retval = xhci_init(hcd);
-	if (retval)
-		goto error;
-	xhci_dbg(xhci, "Called HCD init\n");
+	xhci = hcd_to_xhci(hcd);
+	if (!usb_hcd_is_primary_hcd(hcd))
+		return 0;
 
 	pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
 	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
@@ -182,7 +210,6 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (!retval)
 		return retval;
 
-error:
 	kfree(xhci);
 	return retval;
 }

commit 7e393a834b41001174a8fb3ae3bc23a749467760
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:54 2011 -0700

    xHCI: AMD isoc link TRB chain bit quirk
    
    Setting the chain (CH) bit in the link TRB of isochronous transfer rings
    is required by AMD 0.96 xHCI host controller to successfully transverse
    multi-TRB TD that span through different memory segments.
    
    When a Missed Service Error event occurs, if the chain bit is not set in
    the link TRB and the host skips TDs which just across a link TRB, the
    host may falsely recognize the link TRB as a normal TRB. You can see
    this may cause big trouble - the host does not jump to the right address
    which is pointed by the link TRB, but continue fetching the memory which
    is after the link TRB address, which may not even belong to the host,
    and the result cannot be predicted.
    
    This causes some big problems. Without the former patch I sent: "xHCI:
    prevent infinite loop when processing MSE event", the system may hang.
    With that patch applied, system does not hang, but the host still access
    wrong memory address and isoc transfer will fail. With this patch,
    isochronous transfer works as expected.
    
    This patch should be applied to kernels as old as 2.6.36, which was when
    the first isochronous support was added for the xHCI host controller.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e66e2b03fbbe..732837eafabe 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -128,6 +128,9 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (pdev->vendor == PCI_VENDOR_ID_NEC)
 		xhci->quirks |= XHCI_NEC_HOST;
 
+	if (pdev->vendor == PCI_VENDOR_ID_AMD && xhci->hci_version == 0x96)
+		xhci->quirks |= XHCI_AMD_0x96_HOST;
+
 	/* AMD PLL quirk */
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;

commit 65580b4321eb36f16ae8b5987bfa1bb948fc5112
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:52 2011 -0700

    xHCI: set USB2 hardware LPM
    
    If the device pass the USB2 software LPM and the host supports hardware
    LPM, enable hardware LPM for the device to let the host decide when to
    put the link into lower power state.
    
    If hardware LPM is enabled for a port and driver wants to put it into
    suspend, it must first disable hardware LPM, resume the port into U0,
    and then suspend the port.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 213a7d73b118..e66e2b03fbbe 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -349,6 +349,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	 * call back when device connected and addressed
 	 */
 	.update_device =        xhci_update_device,
+	.set_usb2_hw_lpm =	xhci_set_usb2_hardware_lpm,
 };
 
 /*-------------------------------------------------------------------------*/

commit 9574323c39d1f8359a04843075d89c9f32d8b7e6
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:51 2011 -0700

    xHCI: test USB2 software LPM
    
    This patch tests USB2 software LPM for a USB2 LPM-capable device.
    
    When a lpm-capable device is addressed, if the host also supports software
    LPM, apply a test by putting the device into L1 state and resume it to see
    if the device can do L1 suspend/resume successfully.
    
    If the device fails to enter L1 or resume from L1 state, it may not
    function normally and usbcore may disconnect and re-enumerate it. In this
    case, store the device's Vid and Pid information, make sure the host will
    not test LPM for it twice.
    
    The test result is per device/host. Some devices claim to be lpm-capable,
    but fail to enter L1 or resume. So the test is necessary.
    
    The xHCI 1.0 errata has modified the USB2.0 LPM implementation. It redefines
    the HIRD field to BESL, and adds another register Port Hardware LPM Control
    (PORTHLPMC). However, this should not affect the LPM behavior on xHC which
    does not implement 1.0 errata.
    
    USB2.0 LPM errata defines a new bit BESL in the device's USB 2.0 extension
    descriptor. If the device reports it uses BESL, driver should use BESL
    instead of HIRD for it.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index a1110996b76f..213a7d73b118 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -345,6 +345,10 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.hub_status_data =	xhci_hub_status_data,
 	.bus_suspend =		xhci_bus_suspend,
 	.bus_resume =		xhci_bus_resume,
+	/*
+	 * call back when device connected and addressed
+	 */
+	.update_device =        xhci_update_device,
 };
 
 /*-------------------------------------------------------------------------*/

commit b5dd18d8747010e3f3eb1cc76a49f94291938559
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 7 16:10:52 2011 +0800

    USB: irq: Remove IRQF_DISABLED
    
    This flag is a NOOP and can be removed now.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 50d3fcf593ff..a1110996b76f 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -223,7 +223,7 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
 
 	retval = usb_add_hcd(xhci->shared_hcd, dev->irq,
-			IRQF_DISABLED | IRQF_SHARED);
+			IRQF_SHARED);
 	if (retval)
 		goto put_usb3_hcd;
 	/* Roothub already marked as USB 3.0 speed */

commit 86cc558ea52b123d7657e609557d60dc121eedd6
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:54 2011 -0700

    xhci: Add software BW checking quirk to Intel PPT xHCI
    
    The xHCI host controller in the Intel Panther Point chipset needs to have
    software check whether new devices will fit in the available bus
    bandwidth.  Activate the software bandwidth checking quirk when we find
    the right PCI device.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index cb16de213f64..50d3fcf593ff 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -136,6 +136,7 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;
 		xhci->quirks |= XHCI_EP_LIMIT_QUIRK;
 		xhci->limit_active_eps = 64;
+		xhci->quirks |= XHCI_SW_BW_CHECKING;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {

commit c877b3b2ad5cb9d4fe523c5496185cc328ff3ae9
Author: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Date:   Wed Jun 15 23:47:21 2011 +0200

    xhci: Add reset on resume quirk for asrock p67 host
    
    The asrock p67 xhci controller completely dies on resume, add a
    quirk for this, to bring the host back online after a suspend.
    
    This should be backported to stable kernels as old as 2.6.37.
    
    Signed-off-by: Maarten Lankhorst <m.b.lankhorst@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 17541d09eabb..cb16de213f64 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -29,6 +29,9 @@
 #define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
 #define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
 
+#define PCI_VENDOR_ID_ETRON		0x1b6f
+#define PCI_DEVICE_ID_ASROCK_P67	0x7023
+
 static const char hcd_name[] = "xhci_hcd";
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -134,6 +137,11 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 		xhci->quirks |= XHCI_EP_LIMIT_QUIRK;
 		xhci->limit_active_eps = 64;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
+			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
+		xhci_dbg(xhci, "QUIRK: Resetting on resume\n");
+	}
 
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);

commit f5182b4155b9d686c5540a6822486400e34ddd98
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jun 2 11:33:02 2011 -0700

    xhci: Disable MSI for some Fresco Logic hosts.
    
    Some Fresco Logic hosts, including those found in the AUAU N533V laptop,
    advertise MSI, but fail to actually generate MSI interrupts.  Add a new
    xHCI quirk to skip MSI enabling for the Fresco Logic host controllers.
    Fresco Logic confirms that all chips with PCI vendor ID 0x1b73 and device
    ID 0x1000, regardless of PCI revision ID, do not support MSI.
    
    This should be backported to stable kernels as far back as 2.6.36, which
    was the first kernel to support MSI on xHCI hosts.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Sergey Galanov <sergey.e.galanov@gmail.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c408e9f6a707..17541d09eabb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -106,12 +106,22 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 
 	/* Look for vendor-specific quirks */
 	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
-			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
-			pdev->revision == 0x0) {
+			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {
+		if (pdev->revision == 0x0) {
 			xhci->quirks |= XHCI_RESET_EP_QUIRK;
 			xhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"
 					" endpoint cmd after reset endpoint\n");
+		}
+		/* Fresco Logic confirms: all revisions of this chip do not
+		 * support MSI, even though some of them claim to in their PCI
+		 * capabilities.
+		 */
+		xhci->quirks |= XHCI_BROKEN_MSI;
+		xhci_dbg(xhci, "QUIRK: Fresco Logic revision %u "
+				"has broken MSI implementation\n",
+				pdev->revision);
 	}
+
 	if (pdev->vendor == PCI_VENDOR_ID_NEC)
 		xhci->quirks |= XHCI_NEC_HOST;
 

commit 2cf95c18d5069e13c02a8667d91e064df8e17e09
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 11 16:14:58 2011 -0700

    Intel xhci: Limit number of active endpoints to 64.
    
    The Panther Point chipset has an xHCI host controller that has a limit to
    the number of active endpoints it can handle.  Ideally, it would signal
    that it can't handle anymore endpoints by returning a Resource Error for
    the Configure Endpoint command, but they don't.  Instead it needs software
    to keep track of the number of active endpoints, across configure endpoint
    commands, reset device commands, disable slot commands, and address device
    commands.
    
    Add a new endpoint context counter, xhci_hcd->num_active_eps, and use it
    to track the number of endpoints the xHC has active.  This gets a little
    tricky, because commands to change the number of active endpoints can
    fail.  This patch adds a new xHCI quirk for these Intel hosts, and the new
    code should not have any effect on other xHCI host controllers.
    
    Fail a new device allocation if we don't have room for the new default
    control endpoint.  Use the endpoint ring pointers to determine what
    endpoints were active before a Reset Device command or a Disable Slot
    command, and drop those once the command completes.
    
    Fail a configure endpoint command if it would add too many new endpoints.
    We have to be a bit over zealous here, and only count the number of new
    endpoints to be added, without subtracting the number of dropped
    endpoints.  That's because a second configure endpoint command for a
    different device could sneak in before we know if the first command is
    completed.  If the first command dropped resources, the host controller
    fails the command for some reason, and we're nearing the limit of
    endpoints, we could end up oversubscribing the host.
    
    To fix this race condition, when evaluating whether a configure endpoint
    command will fix in our bandwidth budget, only add the new endpoints to
    xhci->num_active_eps, and don't subtract the dropped endpoints.  Ignore
    changed endpoints (ones that are dropped and then re-added), as that
    shouldn't effect the host's endpoint resources.  When the configure
    endpoint command completes, subtract off the dropped endpoints.
    
    This may mean some configuration changes may temporarily fail, but it's
    always better to under-subscribe than over-subscribe resources.
    
    (Originally my plan had been to push the resource allocation down into the
    ring allocation functions.  However, that would cause us to allocate
    unnecessary resources when endpoints were changed, because the xHCI driver
    allocates a new ring for the changed endpoint, and only deletes the old
    ring once the Configure Endpoint command succeeds.  A further complication
    would have been dealing with the per-device endpoint ring cache.)
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index eafd17fae949..c408e9f6a707 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -121,6 +121,8 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
 		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;
+		xhci->quirks |= XHCI_EP_LIMIT_QUIRK;
+		xhci->limit_active_eps = 64;
 	}
 
 	/* Make sure the HC is halted. */

commit ad808333d8201d53075a11bc8dd83b81f3d68f0b
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 25 10:43:56 2011 -0700

    Intel xhci: Ignore spurious successful event.
    
    The xHCI host controller in the Panther Point chipset sometimes produces
    spurious events on the event ring.  If it receives a short packet, it
    first puts a Transfer Event with a short transfer completion code on the
    event ring.  Then it puts a Transfer Event with a successful completion
    code on the ring for the same TD.  The xHCI driver correctly processes the
    short transfer completion code, gives the URB back to the driver, and then
    prints a warning in dmesg about the spurious event.  These warning
    messages really fill up dmesg when an HD webcam is plugged into xHCI.
    
    This spurious successful event behavior isn't technically disallowed by
    the xHCI specification, so make the xHCI driver just ignore the spurious
    completion event.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index faf039ac6573..eafd17fae949 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -118,6 +118,10 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	/* AMD PLL quirk */
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
 		xhci->quirks |= XHCI_AMD_PLL_FIX;
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
+		xhci->quirks |= XHCI_SPURIOUS_SUCCESS;
+	}
 
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);

commit 69e848c2090aebba5698a1620604c7dccb448684
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Feb 22 09:57:15 2011 -0800

    Intel xhci: Support EHCI/xHCI port switching.
    
    The Intel Panther Point chipsets contain an EHCI and xHCI host controller
    that shares some number of skew-dependent ports.  These ports can be
    switched from the EHCI to the xHCI host (and vice versa) by a hardware MUX
    that is controlled by registers in the xHCI PCI configuration space.  The
    USB 3.0 SuperSpeed terminations on the xHCI ports can be controlled
    separately from the USB 2.0 data wires.
    
    This switchover mechanism is there to support users who do a custom
    install of certain non-Linux operating systems that don't have official
    USB 3.0 support.  By default, the ports are under EHCI, SuperSpeed
    terminations are off, and USB 3.0 devices will show up under the EHCI
    controller at reduced speeds.  (This was more palatable for the marketing
    folks than having completely dead USB 3.0 ports if no xHCI drivers are
    available.)  Users should be able to turn on xHCI by default through a
    BIOS option, but users are happiest when they don't have to change random
    BIOS settings.
    
    This patch introduces a driver method to switchover the ports from EHCI to
    xHCI before the EHCI driver finishes PCI enumeration.  We want to switch
    the ports over before the USB core has the chance to enumerate devices
    under EHCI, or boot from USB mass storage will fail if the boot device
    connects under EHCI first, and then gets disconnected when the port
    switches over to xHCI.
    
    Add code to the xHCI PCI quirk to switch the ports from EHCI to xHCI.  The
    PCI quirks code will run before any other PCI probe function is called, so
    this avoids the issue with boot devices.
    
    Another issue is with BIOS behavior during system resume from hibernate.
    If the BIOS doesn't support xHCI, it may switch the devices under EHCI to
    allow use of the USB keyboard, mice, and mass storage devices.  It's
    supposed to remember the value of the port routing registers and switch
    them back when the OS attempts to take control of the xHCI host controller,
    but we all know not to trust BIOS writers.
    
    Make both the xHCI driver and the EHCI driver attempt to switchover the
    ports in their PCI resume functions.  We can't guarantee which PCI device
    will be resumed first, so this avoids any race conditions.  Writing a '1'
    to an already set port switchover bit or a '0' to a cleared port switchover
    bit should have no effect.
    
    The xHCI PCI configuration registers will be documented in the EDS-level
    chipset spec, which is not public yet.  I have permission from legal and
    the Intel chipset group to release this patch early to allow good Linux
    support at product launch.  I've tried to document the registers as much
    as possible, so please let me know if anything is unclear.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index cbc4d491e626..faf039ac6573 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -242,8 +242,28 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval = 0;
 
+	/* The BIOS on systems with the Intel Panther Point chipset may or may
+	 * not support xHCI natively.  That means that during system resume, it
+	 * may switch the ports back to EHCI so that users can use their
+	 * keyboard to select a kernel from GRUB after resume from hibernate.
+	 *
+	 * The BIOS is supposed to remember whether the OS had xHCI ports
+	 * enabled before resume, and switch the ports back to xHCI when the
+	 * BIOS/OS semaphore is written, but we all know we can't trust BIOS
+	 * writers.
+	 *
+	 * Unconditionally switch the ports back to xHCI after a system resume.
+	 * We can't tell whether the EHCI or xHCI controller will be resumed
+	 * first, so we have to do the port switchover in both drivers.  Writing
+	 * a '1' to the port switchover registers should have no effect if the
+	 * port was already switched over.
+	 */
+	if (usb_is_intel_switchable_xhci(pdev))
+		usb_enable_xhci_ports(pdev);
+
 	retval = xhci_resume(xhci, hibernated);
 	return retval;
 }

commit 7fc2a61638ef78cdf8d65d5934782963a6e0fc66
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Mon Apr 25 16:54:28 2011 +0100

    xhci-hcd: Include <linux/slab.h> in xhci-pci.c
    
    Commit b02d0ed677acb3465e7600366f2353413bf24074 ('xhci: Change
    hcd_priv into a pointer') added calls to kzalloc() and kfree() in
    xhci-pci.c.  On most architectures <linux/slab.h> is indirectly
    included, but on some it is not.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>,
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index a10494c2f3c7..cbc4d491e626 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -21,6 +21,7 @@
  */
 
 #include <linux/pci.h>
+#include <linux/slab.h>
 
 #include "xhci.h"
 

commit c41136b05d3fb213a192f76a5688ff83687c1136
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Mar 22 17:08:14 2011 +0800

    xHCI: Implement AMD PLL quirk
    
    This patch disable the optional PM feature inside the Hudson3 platform under
    the following conditions:
    
    1. If an isochronous device is connected to xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    The PM feature needs to be disabled to eliminate PLL startup delays when the
    link comes out of low power state. The performance of DMA data transfer could
    be impacted if system delay were encountered and in addition to the PLL start
    up delays. Disabling the PM would leave room for unpredictable system delays
    in order to guarantee uninterrupted data transfer to isochronous audio or
    video stream devices that require time sensitive information. If data in an
    audio/video stream was interrupted then erratic audio or video performance
    may be encountered.
    
    AMD PLL quirk is already implemented in OHCI/EHCI driver. After moving the
    quirk code to pci-quirks.c and export them, xHCI driver can call it directly
    without having the quirk implementation in itself.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index ceea9f33491c..a10494c2f3c7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -114,6 +114,10 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (pdev->vendor == PCI_VENDOR_ID_NEC)
 		xhci->quirks |= XHCI_NEC_HOST;
 
+	/* AMD PLL quirk */
+	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
+		xhci->quirks |= XHCI_AMD_PLL_FIX;
+
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);
 	if (retval)

commit b320937972d456db2a46fdcbc6bebc4dcdc9daa4
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Mar 7 11:24:07 2011 -0800

    xhci: Fixes for suspend/resume of shared HCDs.
    
    Make sure the HCD_FLAG_HW_ACCESSIBLE flag is mirrored by both roothubs,
    since it refers to whether the shared hardware is accessible.  Make sure
    each bus is marked as suspended by setting usb_hcd->state to
    HC_STATE_SUSPENDED when the PCI host controller is resumed.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4a9d55e80f73..ceea9f33491c 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -225,7 +225,8 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 	int	retval = 0;
 
-	if (hcd->state != HC_STATE_SUSPENDED)
+	if (hcd->state != HC_STATE_SUSPENDED ||
+			xhci->shared_hcd->state != HC_STATE_SUSPENDED)
 		return -EINVAL;
 
 	retval = xhci_suspend(xhci);

commit f6ff0ac878eb420011fa2448851dd48c3a7e7b31
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 16 11:21:10 2010 -0800

    xhci: Register second xHCI roothub.
    
    This patch changes the xHCI driver to allocate two roothubs.  This touches
    the driver initialization and shutdown paths, roothub emulation code, and
    port status change event handlers.  This is a rather large patch, but it
    can't be broken up, or it would break git-bisect.
    
    Make the xHCI driver register its own PCI probe function.  This will call
    the USB core to create the USB 2.0 roothub, and then create the USB 3.0
    roothub.  This gets the code for registering a shared roothub out of the
    USB core, and allows other HCDs later to decide if and how many shared
    roothubs they want to allocate.
    
    Make sure the xHCI's reset method marks the xHCI host controller's primary
    roothub as the USB 2.0 roothub.  This ensures that the high speed bus will
    be processed first when the PCI device is resumed, and any USB 3.0 devices
    that have migrated over to high speed will migrate back after being reset.
    This ensures that USB persist works with these odd devices.
    
    The reset method will also mark the xHCI USB2 roothub as having an
    integrated TT.  Like EHCI host controllers with a "rate matching hub" the
    xHCI USB 2.0 roothub doesn't have an OHCI or UHCI companion controller.
    It doesn't really have a TT, but we'll lie and say it has an integrated
    TT.  We need to do this because the USB core will reject LS/FS devices
    under a HS hub without a TT.
    
    Other details:
    -------------
    
    The roothub emulation code is changed to return the correct number of
    ports for the two roothubs.  For the USB 3.0 roothub, it only reports the
    USB 3.0 ports.  For the USB 2.0 roothub, it reports all the LS/FS/HS
    ports.  The code to disable a port now checks the speed of the roothub,
    and refuses to disable SuperSpeed ports under the USB 3.0 roothub.
    
    The code for initializing a new device context must be changed to set the
    proper roothub port number.  Since we've split the xHCI host into two
    roothubs, we can't just use the port number in the ancestor hub.  Instead,
    we loop through the array of hardware port status register speeds and find
    the Nth port with a similar speed.
    
    The port status change event handler is updated to figure out whether the
    port that reported the change is a USB 3.0 port, or a non-SuperSpeed port.
    Once it figures out the port speed, it kicks the proper roothub.
    
    The function to find a slot ID based on the port index is updated to take
    into account that the two roothubs will have over-lapping port indexes.
    It checks that the virtual device with a matching port index is the same
    speed as the passed in roothub.
    
    There's also changes to the driver initialization and shutdown paths:
    
     1. Make sure that the xhci_hcd pointer is shared across the two
        usb_hcd structures.  The xhci_hcd pointer is allocated and the
        registers are mapped in when xhci_pci_setup() is called with the
        primary HCD.  When xhci_pci_setup() is called with the non-primary
        HCD, the xhci_hcd pointer is stored.
    
     2. Make sure to set the sg_tablesize for both usb_hcd structures.  Set
        the PCI DMA mask for the non-primary HCD to allow for 64-bit or 32-bit
        DMA.  (The PCI DMA mask is set from the primary HCD further down in
        the xhci_pci_setup() function.)
    
     3. Ensure that the host controller doesn't start kicking khubd in
        response to port status changes before both usb_hcd structures are
        registered.  xhci_run() only starts the xHC running once it has been
        called with the non-primary roothub.  Similarly, the xhci_stop()
        function only halts the host controller when it is called with the
        non-primary HCD.  Then on the second call, it resets and cleans up the
        MSI-X irqs.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 009082829364..4a9d55e80f73 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -50,18 +50,44 @@ static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
 /* called during probe() after chip reset completes */
 static int xhci_pci_setup(struct usb_hcd *hcd)
 {
-	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	struct xhci_hcd		*xhci;
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval;
 	u32			temp;
 
 	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;
 
-	xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
-	if (!xhci)
-		return -ENOMEM;
-	*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
-	xhci->main_hcd = hcd;
+	if (usb_hcd_is_primary_hcd(hcd)) {
+		xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
+		if (!xhci)
+			return -ENOMEM;
+		*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
+		xhci->main_hcd = hcd;
+		/* Mark the first roothub as being USB 2.0.
+		 * The xHCI driver will register the USB 3.0 roothub.
+		 */
+		hcd->speed = HCD_USB2;
+		hcd->self.root_hub->speed = USB_SPEED_HIGH;
+		/*
+		 * USB 2.0 roothub under xHCI has an integrated TT,
+		 * (rate matching hub) as opposed to having an OHCI/UHCI
+		 * companion controller.
+		 */
+		hcd->has_tt = 1;
+	} else {
+		/* xHCI private pointer was set in xhci_pci_probe for the second
+		 * registered roothub.
+		 */
+		xhci = hcd_to_xhci(hcd);
+		temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
+		if (HCC_64BIT_ADDR(temp)) {
+			xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+			dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
+		} else {
+			dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
+		}
+		return 0;
+	}
 
 	xhci->cap_regs = hcd->regs;
 	xhci->op_regs = hcd->regs +
@@ -128,11 +154,67 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	return retval;
 }
 
+/*
+ * We need to register our own PCI probe function (instead of the USB core's
+ * function) in order to create a second roothub under xHCI.
+ */
+static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int retval;
+	struct xhci_hcd *xhci;
+	struct hc_driver *driver;
+	struct usb_hcd *hcd;
+
+	driver = (struct hc_driver *)id->driver_data;
+	/* Register the USB 2.0 roothub.
+	 * FIXME: USB core must know to register the USB 2.0 roothub first.
+	 * This is sort of silly, because we could just set the HCD driver flags
+	 * to say USB 2.0, but I'm not sure what the implications would be in
+	 * the other parts of the HCD code.
+	 */
+	retval = usb_hcd_pci_probe(dev, id);
+
+	if (retval)
+		return retval;
+
+	/* USB 2.0 roothub is stored in the PCI device now. */
+	hcd = dev_get_drvdata(&dev->dev);
+	xhci = hcd_to_xhci(hcd);
+	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
+				pci_name(dev), hcd);
+	if (!xhci->shared_hcd) {
+		retval = -ENOMEM;
+		goto dealloc_usb2_hcd;
+	}
+
+	/* Set the xHCI pointer before xhci_pci_setup() (aka hcd_driver.reset)
+	 * is called by usb_add_hcd().
+	 */
+	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
+
+	retval = usb_add_hcd(xhci->shared_hcd, dev->irq,
+			IRQF_DISABLED | IRQF_SHARED);
+	if (retval)
+		goto put_usb3_hcd;
+	/* Roothub already marked as USB 3.0 speed */
+	return 0;
+
+put_usb3_hcd:
+	usb_put_hcd(xhci->shared_hcd);
+dealloc_usb2_hcd:
+	usb_hcd_pci_remove(dev);
+	return retval;
+}
+
 static void xhci_pci_remove(struct pci_dev *dev)
 {
 	struct xhci_hcd *xhci;
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
+	if (xhci->shared_hcd) {
+		usb_remove_hcd(xhci->shared_hcd);
+		usb_put_hcd(xhci->shared_hcd);
+	}
 	usb_hcd_pci_remove(dev);
 	kfree(xhci);
 }
@@ -170,7 +252,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq =			xhci_irq,
-	.flags =		HCD_MEMORY | HCD_USB3,
+	.flags =		HCD_MEMORY | HCD_USB3 | HCD_SHARED,
 
 	/*
 	 * basic lifecycle operations
@@ -231,7 +313,7 @@ static struct pci_driver xhci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
 
-	.probe =	usb_hcd_pci_probe,
+	.probe =	xhci_pci_probe,
 	.remove =	xhci_pci_remove,
 	/* suspend and resume implemented later */
 

commit b02d0ed677acb3465e7600366f2353413bf24074
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 26 11:03:44 2010 -0700

    xhci: Change hcd_priv into a pointer.
    
    Instead of allocating space for the whole xhci_hcd structure at the end of
    usb_hcd, make the USB core allocate enough space for a pointer to the
    xhci_hcd structure.  This will make it easy to share the xhci_hcd
    structure across the two roothubs (the USB 3.0 usb_hcd and the USB 2.0
    usb_hcd).
    
    Deallocate the xhci_hcd at PCI remove time, so the hcd_priv will be
    deallocated after the usb_hcd is deallocated.  We do this by registering a
    different PCI remove function that calls the usb_hcd_pci_remove()
    function, and then frees the xhci_hcd.  usb_hcd_pci_remove() calls
    kput() on the usb_hcd structure, which will deallocate the memory that
    contains the hcd_priv pointer, but not the memory it points to.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index bb668a894ab9..009082829364 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -57,6 +57,12 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 
 	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;
 
+	xhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);
+	if (!xhci)
+		return -ENOMEM;
+	*((struct xhci_hcd **) hcd->hcd_priv) = xhci;
+	xhci->main_hcd = hcd;
+
 	xhci->cap_regs = hcd->regs;
 	xhci->op_regs = hcd->regs +
 		HC_LENGTH(xhci_readl(xhci, &xhci->cap_regs->hc_capbase));
@@ -85,13 +91,13 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);
 	if (retval)
-		return retval;
+		goto error;
 
 	xhci_dbg(xhci, "Resetting HCD\n");
 	/* Reset the internal HC memory state and registers. */
 	retval = xhci_reset(xhci);
 	if (retval)
-		return retval;
+		goto error;
 	xhci_dbg(xhci, "Reset complete\n");
 
 	temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
@@ -106,14 +112,29 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	/* Initialize HCD and host controller data structures. */
 	retval = xhci_init(hcd);
 	if (retval)
-		return retval;
+		goto error;
 	xhci_dbg(xhci, "Called HCD init\n");
 
 	pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
 	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
 
 	/* Find any debug ports */
-	return xhci_pci_reinit(xhci, pdev);
+	retval = xhci_pci_reinit(xhci, pdev);
+	if (!retval)
+		return retval;
+
+error:
+	kfree(xhci);
+	return retval;
+}
+
+static void xhci_pci_remove(struct pci_dev *dev)
+{
+	struct xhci_hcd *xhci;
+
+	xhci = hcd_to_xhci(pci_get_drvdata(dev));
+	usb_hcd_pci_remove(dev);
+	kfree(xhci);
 }
 
 #ifdef CONFIG_PM
@@ -143,7 +164,7 @@ static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 static const struct hc_driver xhci_pci_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"xHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct xhci_hcd),
+	.hcd_priv_size =	sizeof(struct xhci_hcd *),
 
 	/*
 	 * generic hardware linkage
@@ -211,7 +232,7 @@ static struct pci_driver xhci_pci_driver = {
 	.id_table =	pci_ids,
 
 	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
+	.remove =	xhci_pci_remove,
 	/* suspend and resume implemented later */
 
 	.shutdown = 	usb_hcd_pci_shutdown,

commit 5535b1d5f8885695c6ded783c692e3c0d0eda8ca
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:23:06 2010 -0700

    USB: xHCI: PCI power management implementation
    
    This patch implements the PCI suspend/resume.
    
    Please refer to xHCI spec for doing the suspend/resume operation.
    
    For S3, CSS/SRS in USBCMD is used to save/restore the internal state.
    However, an error maybe occurs while restoring the internal state.
    In this case, it means that HC internal state is wrong and HC will be
    re-initialized.
    
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: Dong Nguyen <dong.nguyen@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 3865f8c6f647..bb668a894ab9 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -116,6 +116,30 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	return xhci_pci_reinit(xhci, pdev);
 }
 
+#ifdef CONFIG_PM
+static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+{
+	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	int	retval = 0;
+
+	if (hcd->state != HC_STATE_SUSPENDED)
+		return -EINVAL;
+
+	retval = xhci_suspend(xhci);
+
+	return retval;
+}
+
+static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	int			retval = 0;
+
+	retval = xhci_resume(xhci, hibernated);
+	return retval;
+}
+#endif /* CONFIG_PM */
+
 static const struct hc_driver xhci_pci_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"xHCI Host Controller",
@@ -132,7 +156,10 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	 */
 	.reset =		xhci_pci_setup,
 	.start =		xhci_run,
-	/* suspend and resume implemented later */
+#ifdef CONFIG_PM
+	.pci_suspend =          xhci_pci_suspend,
+	.pci_resume =           xhci_pci_resume,
+#endif
 	.stop =			xhci_stop,
 	.shutdown =		xhci_shutdown,
 
@@ -188,6 +215,11 @@ static struct pci_driver xhci_pci_driver = {
 	/* suspend and resume implemented later */
 
 	.shutdown = 	usb_hcd_pci_shutdown,
+#ifdef CONFIG_PM_SLEEP
+	.driver = {
+		.pm = &usb_hcd_pci_pm_ops
+	},
+#endif
 };
 
 int xhci_register_pci(void)

commit 9777e3ce907d4cb5a513902a87ecd03b52499569
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:23:03 2010 -0700

    USB: xHCI: bus power management implementation
    
    This patch implements xHCI bus suspend/resume function hook.
    
    In the patch it goes through all the ports and suspend/resume
    the ports if needed.
    
    If any port is in remote wakeup, abort bus suspend as what ehci/ohci do.
    
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: Crane Cai <crane.cai@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index aefc3496376a..3865f8c6f647 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -162,6 +162,8 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	/* Root hub support */
 	.hub_control =		xhci_hub_control,
 	.hub_status_data =	xhci_hub_status_data,
+	.bus_suspend =		xhci_bus_suspend,
+	.bus_resume =		xhci_bus_resume,
 };
 
 /*-------------------------------------------------------------------------*/

commit f0615c45ce5feb141c1172480c5198d4b8d25436
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:22:48 2010 -0700

    USB: xHCI: change xhci_reset_device() to allocate new device
    
    Rename xhci_reset_device() to xhci_discover_or_reset_device().
    If xhci_discover_or_reset_device() is called to reset a device which does
    not exist or does not match the udev, it calls xhci_alloc_dev() to
    re-allocate the device.
    
    This would prevent the reset device failure, possibly due to the xHC restore
    error during S3/S4 resume.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index f7efe025beda..aefc3496376a 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -152,7 +152,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,
 	.update_hub_device =	xhci_update_hub_device,
-	.reset_device =		xhci_reset_device,
+	.reset_device =		xhci_discover_or_reset_device,
 
 	/*
 	 * scheduling support

commit 006d5820b41b298328e6b6085e4d58129fbc78f0
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 29 22:13:22 2010 -0700

    USB: xhci: Set DMA mask for host.
    
    Tell the USB core that we can do DMA directly (instead of needing it to
    memory-map the buffers for PIO).  If the xHCI host supports 64-bit addresses,
    set the DMA mask accordingly.  Otherwise indicate the host can handle 32-bit DMA
    addresses.
    
    This improves performance because the USB core doesn't have to spend time
    remapping buffers in high memory into the 32-bit address range.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 11482b6b9381..f7efe025beda 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -53,6 +53,7 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval;
+	u32			temp;
 
 	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;
 
@@ -93,6 +94,14 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 		return retval;
 	xhci_dbg(xhci, "Reset complete\n");
 
+	temp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
+	if (HCC_64BIT_ADDR(temp)) {
+		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));
+	} else {
+		dma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));
+	}
+
 	xhci_dbg(xhci, "Calling HCD init\n");
 	/* Initialize HCD and host controller data structures. */
 	retval = xhci_init(hcd);

commit 0238634d02dd10b678ebe9ea5d8803483277ee93
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon May 24 13:25:28 2010 -0700

    USB: xhci: Print NEC firmware version.
    
    The NEC xHCI host controller firmware version can be found by putting a
    vendor-specific command on the command ring and extracting the BCD
    encoded-version out of the vendor-specific event TRB.
    
    The firmware version debug line in dmesg will look like:
    
    xhci_hcd 0000:05:00.0: NEC firmware version 30.21
    
    (NEC merged with Renesas Technologies and became Renesas Electronics on
    April 1, 2010.  I have their OK to merge this vendor-specific code.)
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Satoshi Otani <satoshi.otani.xm@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index edffd81fc253..11482b6b9381 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -78,6 +78,8 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 			xhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"
 					" endpoint cmd after reset endpoint\n");
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_NEC)
+		xhci->quirks |= XHCI_NEC_HOST;
 
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);

commit 326b4810cc995209e31136af4202ed0414814ed5
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Apr 19 08:53:50 2010 -0700

    USB: clean up some host controller sparse warnings
    
    Fix usb sparse warnings:
    
    drivers/usb/host/isp1362-hcd.c:2220:50: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:43:24: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:49:24: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:161:24: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:198:16: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:319:31: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:1231:33: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-pci.c:177:23: warning: non-ANSI function declaration of function 'xhci_register_pci'
    drivers/usb/host/xhci-pci.c:182:26: warning: non-ANSI function declaration of function 'xhci_unregister_pci'
    drivers/usb/host/xhci-ring.c:342:32: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:525:34: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:1009:32: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:1031:32: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:1041:16: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:1096:30: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-ring.c:1100:27: warning: Using plain integer as NULL pointer
    drivers/usb/host/xhci-mem.c:224:27: warning: symbol 'xhci_alloc_container_ctx' was not declared. Should it be static?
    drivers/usb/host/xhci-mem.c:242:6: warning: symbol 'xhci_free_container_ctx' was not declared. Should it be static?
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Lothar Wassmann <LW@KARO-electronics.de>
    Signed-off By: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index d295bbc15eb7..edffd81fc253 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -177,12 +177,12 @@ static struct pci_driver xhci_pci_driver = {
 	.shutdown = 	usb_hcd_pci_shutdown,
 };
 
-int xhci_register_pci()
+int xhci_register_pci(void)
 {
 	return pci_register_driver(&xhci_pci_driver);
 }
 
-void xhci_unregister_pci()
+void xhci_unregister_pci(void)
 {
 	pci_unregister_driver(&xhci_pci_driver);
 }

commit eab1cafc3b524b714b0567ab98fc75ace09db98c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 5 10:55:58 2010 -0700

    USB: Support for allocating USB 3.0 streams.
    
    Bulk endpoint streams were added in the USB 3.0 specification.  Streams
    allow a device driver to overload a bulk endpoint so that multiple
    transfers can be queued at once.
    
    The device then decides which transfer it wants to work on first, and can
    queue part of a transfer before it switches to a new stream.  All this
    switching is invisible to the device driver, which just gets a completion
    for the URB.  Drivers that use streams must be able to handle URBs
    completing in a different order than they were submitted to the endpoint.
    
    This requires adding new API to set up xHCI data structures to support
    multiple queues ("stream rings") per endpoint.  Drivers will allocate a
    number of stream IDs before enqueueing URBs to the bulk endpoints of the
    device, and free the stream IDs in their disconnect function.  See
    Documentation/usb/bulk-streams.txt for details.
    
    The new mass storage device class, USB Attached SCSI Protocol (UASP), uses
    these streams API.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 98a73cd20cc6..d295bbc15eb7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -132,6 +132,8 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.urb_dequeue =		xhci_urb_dequeue,
 	.alloc_dev =		xhci_alloc_dev,
 	.free_dev =		xhci_free_dev,
+	.alloc_streams =	xhci_alloc_streams,
+	.free_streams =		xhci_free_streams,
 	.add_endpoint =		xhci_add_endpoint,
 	.drop_endpoint =	xhci_drop_endpoint,
 	.endpoint_reset =	xhci_endpoint_reset,

commit bc88d2eba5e19d10dd546e428314909d889b3b6a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue May 18 16:05:21 2010 -0700

    USB: xhci: Limit bus sg_tablesize to 62 TRBs.
    
    When a scatter-gather list is enqueued to the xHCI driver, it translates
    each entry into a transfer request block (TRB).  Only 63 TRBs can be
    used per ring segment, and there must be one additional TRB reserved to
    make sure the hardware does not think the ring is empty (so the enqueue
    pointer doesn't equal the dequeue pointer).  Limit the bus sg_tablesize
    to 62 TRBs.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 417d37aff8d7..98a73cd20cc6 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -54,7 +54,7 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval;
 
-	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 1;
+	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;
 
 	xhci->cap_regs = hcd->regs;
 	xhci->op_regs = hcd->regs +

commit a5f0efaba4c2b644e6248648f75b0a8a522359f6
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:17 2009 -0800

    USB: Add call to notify xHC of a device reset.
    
    Add a new host controller driver method, reset_device(), that the USB core
    will use to notify the host of a successful device reset.  The call may
    fail due to out-of-memory errors; attempt the port reset sequence again if
    that happens.  Update hub_port_init() to allow resetting a configured
    device.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e097008d6fb1..417d37aff8d7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -139,6 +139,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,
 	.update_hub_device =	xhci_update_hub_device,
+	.reset_device =		xhci_reset_device,
 
 	/*
 	 * scheduling support

commit 4c1bd3d7a7d114dabd58f62f386ac4bfd268be1f
Author: David Vrabel <david.vrabel@csr.com>
Date:   Mon Aug 24 14:44:30 2009 +0100

    USB: make urb scatter-gather support more generic
    
    The WHCI HCD will also support urbs with scatter-gather lists.  Add a
    usb_bus field to indicated how many sg list elements are supported by
    the HCD.  Use this to decide whether to pass the scatter-list to the HCD
    or not.
    
    Make the usb-storage driver use this new field.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 06595ec27bb7..e097008d6fb1 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -54,6 +54,8 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval;
 
+	hcd->self.sg_tablesize = TRBS_PER_SEGMENT - 1;
+
 	xhci->cap_regs = hcd->regs;
 	xhci->op_regs = hcd->regs +
 		HC_LENGTH(xhci_readl(xhci, &xhci->cap_regs->hc_capbase));

commit b356b7c7696b289dda99022d71e3979c6134af52
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 4 10:53:24 2009 -0700

    USB: Add hub descriptor update hook for xHCI
    
    Add a hook for updating xHCI internal structures after khubd fetches the
    hub descriptor and sets up the hub's TT information.  The xHCI driver must
    update the internal structures before devices under the hub can be
    enumerated.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index b7712f22a9fb..06595ec27bb7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -136,6 +136,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.check_bandwidth =	xhci_check_bandwidth,
 	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,
+	.update_hub_device =	xhci_update_hub_device,
 
 	/*
 	 * scheduling support

commit ac1c1b7f16ed287fcec5bcfae06d0165c3941ec3
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 4 10:53:20 2009 -0700

    USB: xhci: Support USB hubs.
    
    For a USB hub to work under an xHCI host controller, the xHC's internal
    scheduler must be made aware of the hub's characteristics.  Add an xHCI
    hook that the USB core will call after it fetches the hub descriptor.
    This hook will add hub information to the slot context for that device,
    including whether it has multiple TTs or a single TT, the number of ports
    on the hub, and TT think time.
    
    Setting up the slot context for the device is different for 0.95 and 0.96
    xHCI host controllers.
    
    Some of the slot context reserved fields in the 0.95 specification were
    changed into hub fields in the 0.96 specification.  Don't set the TT think
    time or number of ports for a hub if we're dealing with a 0.95-compliant
    xHCI host controller.
    
    The 0.95 xHCI specification says that to modify the hub flag, we need to
    issue an evaluate context command.  The 0.96 specification says that flag
    can be set with a configure endpoint command.  Issue the correct command
    based on the version reported by the hardware.
    
    This patch does not add support for multi-TT hubs.  Multi-TT hubs expose
    a single TT on alt setting 0, and multi-TT on alt setting 1.  The xHCI
    driver can't handle setting alternate interfaces yet.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 8fb308d43bc1..b7712f22a9fb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -63,6 +63,8 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	xhci->hcs_params1 = xhci_readl(xhci, &xhci->cap_regs->hcs_params1);
 	xhci->hcs_params2 = xhci_readl(xhci, &xhci->cap_regs->hcs_params2);
 	xhci->hcs_params3 = xhci_readl(xhci, &xhci->cap_regs->hcs_params3);
+	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hc_capbase);
+	xhci->hci_version = HC_VERSION(xhci->hcc_params);
 	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
 	xhci_print_registers(xhci);
 

commit ac9d8fe7c6a8041cca5a0738915d2c4e21381421
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:55 2009 -0700

    USB: xhci: Add quirk for Fresco Logic xHCI hardware.
    
    This Fresco Logic xHCI host controller chip revision puts bad data into
    the output endpoint context after a Reset Endpoint command.  It needs a
    Configure Endpoint command (instead of a Set TR Dequeue Pointer command)
    after the reset endpoint command.
    
    Set up the input context before issuing the Reset Endpoint command so we
    don't copy bad data from the output endpoint context.  The HW also can't
    handle two commands queued at once, so submit the TRB for the Configure
    Endpoint command in the event handler for the Reset Endpoint command.
    
    Devices that stall on control endpoints before a configuration is selected
    will not work under this Fresco Logic xHCI host controller revision.
    
    This patch is for prototype hardware that will be given to other companies
    for evaluation purposes only, and should not reach consumer hands.  Fresco
    Logic's next chip rev should have this bug fixed.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 592fe7e623f7..8fb308d43bc1 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -24,6 +24,10 @@
 
 #include "xhci.h"
 
+/* Device for a quirk */
+#define PCI_VENDOR_ID_FRESCO_LOGIC	0x1b73
+#define PCI_DEVICE_ID_FRESCO_LOGIC_PDK	0x1000
+
 static const char hcd_name[] = "xhci_hcd";
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -62,6 +66,15 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
 	xhci_print_registers(xhci);
 
+	/* Look for vendor-specific quirks */
+	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
+			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
+			pdev->revision == 0x0) {
+			xhci->quirks |= XHCI_RESET_EP_QUIRK;
+			xhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"
+					" endpoint cmd after reset endpoint\n");
+	}
+
 	/* Make sure the HC is halted. */
 	retval = xhci_halt(xhci);
 	if (retval)

commit a1587d97ce3e53816c88b513a2038f6c5e5babd7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:03:15 2009 -0700

    USB: xhci: Deal with stalled endpoints.
    
    When an endpoint on a device under an xHCI host controller stalls, the
    host controller driver must let the hardware know that the USB core has
    successfully cleared the halt condition.  The HCD submits a Reset Endpoint
    Command, which will clear the toggle bit for USB 2.0 devices, and set the
    sequence number to zero for USB 3.0 devices.
    
    The xHCI urb_enqueue will accept new URBs while the endpoint is halted,
    and will queue them to the hardware rings.  However, the endpoint doorbell
    will not be rung until the Reset Endpoint Command completes.
    
    Don't queue a reset endpoint command for root hubs.  khubd clears halt
    conditions on the roothub during the initialization process, but the roothub
    isn't a real device, so the xHCI host controller doesn't need to know about the
    cleared halt.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 1462709e26c0..592fe7e623f7 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -117,6 +117,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.free_dev =		xhci_free_dev,
 	.add_endpoint =		xhci_add_endpoint,
 	.drop_endpoint =	xhci_drop_endpoint,
+	.endpoint_reset =	xhci_endpoint_reset,
 	.check_bandwidth =	xhci_check_bandwidth,
 	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,

commit f94e0186312b0fc39f41eed4e21836ed74b7efe1
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:38 2009 -0700

    USB: xhci: Bandwidth allocation support
    
    Since the xHCI host controller hardware (xHC) has an internal schedule, it
    needs a better representation of what devices are consuming bandwidth on
    the bus.  Each device is represented by a device context, with data about
    the device, endpoints, and pointers to each endpoint ring.
    
    We need to update the endpoint information for a device context before a
    new configuration or alternate interface setting is selected.  We setup an
    input device context with modified endpoint information and newly
    allocated endpoint rings, and then submit a Configure Endpoint Command to
    the hardware.
    
    The host controller can reject the new configuration if it exceeds the bus
    bandwidth, or the host controller doesn't have enough internal resources
    for the configuration.  If the command fails, we still have the older
    device context with the previous configuration.  If the command succeeds,
    we free the old endpoint rings.
    
    The root hub isn't a real device, so always say yes to any bandwidth
    changes for it.
    
    The USB core will enable, disable, and then enable endpoint 0 several
    times during the initialization sequence.  The device will always have an
    endpoint ring for endpoint 0 and bandwidth allocated for that, unless the
    device is disconnected or gets a SetAddress 0 request.  So we don't pay
    attention for when xhci_check_bandwidth() is called for a re-add of
    endpoint 0.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index ff9a4ef22338..1462709e26c0 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -115,6 +115,10 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.urb_dequeue =		xhci_urb_dequeue,
 	.alloc_dev =		xhci_alloc_dev,
 	.free_dev =		xhci_free_dev,
+	.add_endpoint =		xhci_add_endpoint,
+	.drop_endpoint =	xhci_drop_endpoint,
+	.check_bandwidth =	xhci_check_bandwidth,
+	.reset_bandwidth =	xhci_reset_bandwidth,
 	.address_device =	xhci_address_device,
 
 	/*

commit d0e96f5a71a032ced0c35f521c1cbd67e816922a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:01 2009 -0700

    USB: xhci: Control transfer support.
    
    Allow device drivers to enqueue URBs to control endpoints on devices under
    an xHCI host controller.  Each control transfer is represented by a
    series of Transfer Descriptors (TDs) written to an endpoint ring.  There
    is one TD for the Setup phase, (optionally) one TD for the Data phase, and
    one TD for the Status phase.
    
    Enqueue these TDs onto the endpoint ring that represents the control
    endpoint.  The host controller hardware will return an event on the event
    ring that points to the (DMA) address of one of the TDs on the endpoint
    ring.  If the transfer was successful, the transfer event TRB will have a
    completion code of success, and it will point to the Status phase TD.
    Anything else is considered an error.
    
    This should work for control endpoints besides the default endpoint, but
    that hasn't been tested.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 7ac12b4ffe86..ff9a4ef22338 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -111,6 +111,8 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	/*
 	 * managing i/o requests and associated device resources
 	 */
+	.urb_enqueue =		xhci_urb_enqueue,
+	.urb_dequeue =		xhci_urb_dequeue,
 	.alloc_dev =		xhci_alloc_dev,
 	.free_dev =		xhci_free_dev,
 	.address_device =	xhci_address_device,

commit 3ffbba9511b4148cbe1f6b6238686adaeaca8feb
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:38 2009 -0700

    USB: xhci: Allocate and address USB devices
    
    xHCI needs to get a "Slot ID" from the host controller and allocate other
    data structures for every USB device.  Make usb_alloc_dev() and
    usb_release_dev() allocate and free these device structures.  After
    setting up the xHC device structures, usb_alloc_dev() must wait for the
    hardware to respond to an Enable Slot command.  usb_alloc_dev() fires off
    a Disable Slot command and does not wait for it to complete.
    
    When the USB core wants to choose an address for the device, the xHCI
    driver must issue a Set Address command and wait for an event for that
    command.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 005c5b264a7c..7ac12b4ffe86 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -108,6 +108,13 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	.stop =			xhci_stop,
 	.shutdown =		xhci_shutdown,
 
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.alloc_dev =		xhci_alloc_dev,
+	.free_dev =		xhci_free_dev,
+	.address_device =	xhci_address_device,
+
 	/*
 	 * scheduling support
 	 */

commit 0f2a79300a1471cf92ab43af165ea13555c8b0a5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:12 2009 -0700

    USB: xhci: Root hub support.
    
    Add functionality for getting port status and hub descriptor for xHCI root
    hubs.  This is WIP because the USB 3.0 hub descriptor is different from
    the USB 2.0 hub descriptor.  For now, we lie about the root hub descriptor
    because the changes won't effect how the core talks to the root hub.
    Later we will need to add the USB 3.0 hub descriptor for real hubs, and
    this code might change.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 89614af80d20..005c5b264a7c 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -113,7 +113,9 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	 */
 	.get_frame_number =	xhci_get_frame,
 
-	/* Implement root hub support later. */
+	/* Root hub support */
+	.hub_control =		xhci_hub_control,
+	.hub_status_data =	xhci_hub_status_data,
 };
 
 /*-------------------------------------------------------------------------*/

commit 7f84eef0dafb1d318263d8b71c38700aaf2d530d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:53:56 2009 -0700

    USB: xhci: No-op command queueing and irq handler.
    
    xHCI host controllers can optionally implement a no-op test.  This
    simple test ensures the OS has correctly setup all basic data structures
    and can correctly respond to interrupts from the host controller
    hardware.
    
    There are two rings exercised by the no-op test:  the command ring, and
    the event ring.
    
    The host controller driver writes a no-op command TRB to the command
    ring, and rings the doorbell for the command ring (the first entry in
    the doorbell array).  The hardware receives this event, places a command
    completion event on the event ring, and fires an interrupt.
    
    The host controller driver sees the interrupt, and checks the event ring
    for TRBs it can process, and sees the command completion event.  (See
    the rules in xhci-ring.c for who "owns" a TRB.  This is a simplified set
    of rules, and may not contain all the details that are in the xHCI 0.95
    spec.)
    
    A timer fires every 60 seconds to debug the state of the hardware and
    command and event rings.  This timer only runs if
    CONFIG_USB_XHCI_HCD_DEBUGGING is 'y'.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 4015082adf60..89614af80d20 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -96,6 +96,7 @@ static const struct hc_driver xhci_pci_hc_driver = {
 	/*
 	 * generic hardware linkage
 	 */
+	.irq =			xhci_irq,
 	.flags =		HCD_MEMORY | HCD_USB3,
 
 	/*

commit 66d4eadd8d067269ea8fead1a50fe87c2979a80d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:52:28 2009 -0700

    USB: xhci: BIOS handoff and HW initialization.
    
    Add PCI initialization code to take control of the xHCI host controller
    away from the BIOS, halt, and reset the host controller.  The xHCI spec
    says that BIOSes must give up the host controller within 5 seconds.
    
    Add some host controller glue functions to handle hardware initialization
    and memory allocation for the host controller.  The current xHCI
    prototypes use PCI interrupts, but the xHCI spec requires MSI-X
    interrupts.  Add code to support MSI-X interrupts, but use the PCI
    interrupts for now.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
new file mode 100644
index 000000000000..4015082adf60
--- /dev/null
+++ b/drivers/usb/host/xhci-pci.c
@@ -0,0 +1,150 @@
+/*
+ * xHCI host controller driver PCI Bus Glue.
+ *
+ * Copyright (C) 2008 Intel Corp.
+ *
+ * Author: Sarah Sharp
+ * Some code borrowed from the Linux EHCI driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/pci.h>
+
+#include "xhci.h"
+
+static const char hcd_name[] = "xhci_hcd";
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)
+{
+	/*
+	 * TODO: Implement finding debug ports later.
+	 * TODO: see if there are any quirks that need to be added to handle
+	 * new extended capabilities.
+	 */
+
+	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
+	if (!pci_set_mwi(pdev))
+		xhci_dbg(xhci, "MWI active\n");
+
+	xhci_dbg(xhci, "Finished xhci_pci_reinit\n");
+	return 0;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_pci_setup(struct usb_hcd *hcd)
+{
+	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	int			retval;
+
+	xhci->cap_regs = hcd->regs;
+	xhci->op_regs = hcd->regs +
+		HC_LENGTH(xhci_readl(xhci, &xhci->cap_regs->hc_capbase));
+	xhci->run_regs = hcd->regs +
+		(xhci_readl(xhci, &xhci->cap_regs->run_regs_off) & RTSOFF_MASK);
+	/* Cache read-only capability registers */
+	xhci->hcs_params1 = xhci_readl(xhci, &xhci->cap_regs->hcs_params1);
+	xhci->hcs_params2 = xhci_readl(xhci, &xhci->cap_regs->hcs_params2);
+	xhci->hcs_params3 = xhci_readl(xhci, &xhci->cap_regs->hcs_params3);
+	xhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);
+	xhci_print_registers(xhci);
+
+	/* Make sure the HC is halted. */
+	retval = xhci_halt(xhci);
+	if (retval)
+		return retval;
+
+	xhci_dbg(xhci, "Resetting HCD\n");
+	/* Reset the internal HC memory state and registers. */
+	retval = xhci_reset(xhci);
+	if (retval)
+		return retval;
+	xhci_dbg(xhci, "Reset complete\n");
+
+	xhci_dbg(xhci, "Calling HCD init\n");
+	/* Initialize HCD and host controller data structures. */
+	retval = xhci_init(hcd);
+	if (retval)
+		return retval;
+	xhci_dbg(xhci, "Called HCD init\n");
+
+	pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
+	xhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);
+
+	/* Find any debug ports */
+	return xhci_pci_reinit(xhci, pdev);
+}
+
+static const struct hc_driver xhci_pci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"xHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct xhci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.flags =		HCD_MEMORY | HCD_USB3,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		xhci_pci_setup,
+	.start =		xhci_run,
+	/* suspend and resume implemented later */
+	.stop =			xhci_stop,
+	.shutdown =		xhci_shutdown,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	xhci_get_frame,
+
+	/* Implement root hub support later. */
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* PCI driver selection metadata; PCI hotplugging uses this */
+static const struct pci_device_id pci_ids[] = { {
+	/* handle any USB 3.0 xHCI controller */
+	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
+	.driver_data =	(unsigned long) &xhci_pci_hc_driver,
+	},
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver xhci_pci_driver = {
+	.name =		(char *) hcd_name,
+	.id_table =	pci_ids,
+
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
+	/* suspend and resume implemented later */
+
+	.shutdown = 	usb_hcd_pci_shutdown,
+};
+
+int xhci_register_pci()
+{
+	return pci_register_driver(&xhci_pci_driver);
+}
+
+void xhci_unregister_pci()
+{
+	pci_unregister_driver(&xhci_pci_driver);
+}
