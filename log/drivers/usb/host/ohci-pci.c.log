commit ff4c65ca48f08f4781accfb1d224acd7c897070e
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:36 2020 +0530

    usb: hci: add hc_driver as argument for usb_hcd_pci_probe
    
    usb_hcd_pci_probe expects users to call this with driver_data set as
    hc_driver, that limits the possibility of using the driver_data for
    driver data.
    
    Add hc_driver as argument to usb_hcd_pci_probe and modify the callers
    ehci/ohci/xhci/uhci to pass hc_driver as argument and freeup the
    driver_data used
    
    Tested xhci driver on Dragon-board RB3, compile tested ehci, ohci and
    uhci.
    
    [For all but the xHCI parts]
    [For the xhci part]
    
    Suggested-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-2-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 22117a6aeb4a..585222af24ff 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -277,21 +277,24 @@ static const struct ohci_driver_overrides pci_overrides __initconst = {
 static const struct pci_device_id pci_ids[] = { {
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
-	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, {
 	/* The device in the ConneXT I/O hub has no class reg */
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_OHCI),
-	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, { /* end: all zeroes */ }
 };
 MODULE_DEVICE_TABLE (pci, pci_ids);
 
+static int ohci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	return usb_hcd_pci_probe(dev, id, &ohci_pci_hc_driver);
+}
+
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ohci_pci_driver = {
 	.name =		hcd_name,
 	.id_table =	pci_ids,
 
-	.probe =	usb_hcd_pci_probe,
+	.probe =	ohci_pci_probe,
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
 

commit cd3d8cfc322f56488fe8a4fb6246751d32c8df6c
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Tue Feb 18 19:32:59 2020 +0000

    usb: host: ohci-pci: remove useless cast for driver.name
    
    pci_driver name is const char pointer, so it not useful to cast
    hcd_name (which is already const char).
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Link: https://lore.kernel.org/r/1582054383-35760-17-git-send-email-clabbe@baylibre.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index f4e13a3fddee..22117a6aeb4a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -288,7 +288,7 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ohci_pci_driver = {
-	.name =		(char *) hcd_name,
+	.name =		hcd_name,
 	.id_table =	pci_ids,
 
 	.probe =	usb_hcd_pci_probe,

commit 4fbb8aa75836c3361987f431d9451aecc1830bdd
Author: Ryan Kennedy <ryan5544@gmail.com>
Date:   Thu Jul 4 11:35:29 2019 -0400

    usb: pci-quirks: Minor cleanup for AMD PLL quirk
    
    usb_amd_find_chipset_info() is used for chipset detection for
    several quirks. It is strange that its return value indicates
    the need for the PLL quirk, which means it is often ignored.
    This patch adds a function specifically for checking the PLL
    quirk like the other ones. Additionally, rename probe_result to
    something more appropriate.
    
    Signed-off-by: Ryan Kennedy <ryan5544@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20190704153529.9429-3-ryan5544@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a033f7d855e0..f4e13a3fddee 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -152,7 +152,7 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
 
-	if (usb_amd_find_chipset_info())
+	if (usb_amd_quirk_pll_check())
 		ohci->flags |= OHCI_QUIRK_AMD_PLL;
 
 	/* SB800 needs pre-fetch fix */

commit 4e4feeec4e6cf6d0e14a45470c7f232cb685336b
Author: Naveen Kumar Parna <parna.naveenkumar@gmail.com>
Date:   Thu May 16 20:49:23 2019 +0530

    USB: OHCI: remove space before open square bracket '['
    
    This patch removes following checkpatch.pl error in usb/host/ohci-pci.c file.
    ERROR: space prohibited before open square bracket '['
    
    Signed-off-by: Naveen Kumar Parna <parna.naveenkumar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index fbcd34911025..a033f7d855e0 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -274,7 +274,7 @@ static const struct ohci_driver_overrides pci_overrides __initconst = {
 	.reset =		ohci_pci_reset,
 };
 
-static const struct pci_device_id pci_ids [] = { {
+static const struct pci_device_id pci_ids[] = { {
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a84aebe9b0a9..fbcd34911025 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-1.0+
 /*
  * OHCI HCD (Host Controller Driver) for USB.
  *

commit 21a60f6e65181cad64fd66ccc8080d413721ba27
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Mon Mar 20 09:11:49 2017 +0100

    ohci-pci: add qemu quirk
    
    On a loaded virtualization host (dozen guests booting at the same time)
    it may happen that the ohci controller emulation doesn't manage to do
    timely frame processing, with the result that the io watchdog fires and
    considers the controller being dead, even though it's only the emulation
    being unusual slow due to the load peak.
    
    So, add a quirk for qemu and don't use the watchdog in case we figure we
    are running on emulated ohci.  The virtual ohci controller masquerades
    as apple ohci controller, but we can identify it by subsystem id.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index bb1509675727..a84aebe9b0a9 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -164,6 +164,15 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	return 0;
 }
 
+static int ohci_quirk_qemu(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+
+	ohci->flags |= OHCI_QUIRK_QEMU;
+	ohci_dbg(ohci, "enabled qemu quirk\n");
+	return 0;
+}
+
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{
@@ -214,6 +223,13 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
 		.driver_data = (unsigned long)ohci_quirk_amd700,
 	},
+	{
+		.vendor		= PCI_VENDOR_ID_APPLE,
+		.device		= 0x003f,
+		.subvendor	= PCI_SUBVENDOR_ID_REDHAT_QUMRANET,
+		.subdevice	= PCI_SUBDEVICE_ID_QEMU,
+		.driver_data	= (unsigned long)ohci_quirk_qemu,
+	},
 
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.

commit c1db30a2a79eb59997b13b8cabf2a50bea9f04e1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu May 1 15:21:42 2014 -0400

    USB: OHCI: fix problem with global suspend on ATI controllers
    
    Some OHCI controllers from ATI/AMD seem to have difficulty with
    "global" USB suspend, that is, suspending an entire USB bus without
    setting the suspend feature for each port connected to a device.  When
    we try to resume the child devices, the controller gives timeout
    errors on the unsuspended ports, requiring resets, and can even cause
    ohci-hcd to hang; see
    
            http://marc.info/?l=linux-usb&m=139514332820398&w=2
    
    and the following messages.
    
    This patch fixes the problem by adding a new quirk flag to ohci-hcd.
    The flag causes the ohci_rh_suspend() routine to suspend each
    unsuspended, enabled port before suspending the root hub.  This
    effectively converts the "global" suspend to an ordinary root-hub
    suspend.  There is no need to unsuspend these ports when the root hub
    is resumed, because the child devices will be resumed anyway in the
    course of a normal system resume ("global" suspend is never used for
    runtime PM).
    
    This patch should be applied to all stable kernels which include
    commit 0aa2832dd0d9 (USB: use "global suspend" for system sleep on
    USB-2 buses) or a backported version thereof.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Peter Münster <pmlists@free.fr>
    Tested-by: Peter Münster <pmlists@free.fr>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 90879e9ccbec..bb1509675727 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -160,6 +160,7 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
+	ohci->flags |= OHCI_QUIRK_GLOBAL_SUSPEND;
 	return 0;
 }
 

commit 02c123ee99c793f65af2dbda17d5fe87d448f808
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Oct 3 23:37:13 2013 +0800

    usb: ohci: use amd_chipset_type to filter for SB800 prefetch
    
    Commit "usb: pci-quirks: refactor AMD quirk to abstract AMD chipset types"
    introduced a new AMD chipset type to filter AMD platforms with different
    chipsets.
    
    According to a recent thread [1], this patch updates SB800 prefetch routine
    in AMD PLL quirk. And make it use the new chipset type to represent SB800
    generation.
    
    [1] http://marc.info/?l=linux-usb&m=138012321616452&w=2
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index eedf97c1790e..90879e9ccbec 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -150,28 +150,16 @@ static int ohci_quirk_nec(struct usb_hcd *hcd)
 static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	struct pci_dev *amd_smbus_dev;
-	u8 rev;
 
 	if (usb_amd_find_chipset_info())
 		ohci->flags |= OHCI_QUIRK_AMD_PLL;
 
-	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
-			PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
-	if (!amd_smbus_dev)
-		return 0;
-
-	rev = amd_smbus_dev->revision;
-
 	/* SB800 needs pre-fetch fix */
-	if ((rev >= 0x40) && (rev <= 0x4f)) {
+	if (usb_amd_prefetch_quirk()) {
 		ohci->flags |= OHCI_QUIRK_AMD_PREFETCH;
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
-	pci_dev_put(amd_smbus_dev);
-	amd_smbus_dev = NULL;
-
 	return 0;
 }
 

commit 05c92da0c52494caf97d58be1b05b1f95a79ce4e
Author: Tom Gundersen <teg@jklm.no>
Date:   Tue Sep 10 23:30:14 2013 +0200

    usb: ohci/uhci - add soft dependencies on ehci_pci
    
    Support for specifying soft dependencies in the modules themselves was
    introduced in commit 7cb14ba.
    
    In Arch we have always been shipping a module.d(5) fragment ordering ohci/uhci
    after ehci. If this ordering is really necessary, it would be great to move it
    to the kernel and getting the correct fragment generated by depmod.
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ec337c2bd5e0..eedf97c1790e 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -323,3 +323,4 @@ module_exit(ohci_pci_cleanup);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
+MODULE_SOFTDEP("pre: ehci_pci");

commit b3b49114c80e799af8b08c0c6d1ff886ea843f03
Merge: 1ccfd5eaf8f0 b9a1048137f4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 11:35:32 2013 -0700

    Merge tag 'usb-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB patches from Greg KH:
     "Here's the big USB driver pull request for 3.12-rc1
    
      Lots of USB driver fixes and updates.  Nothing major, just the normal
      xhci, gadget, and other driver changes.  Full details in the shortlog"
    
    * tag 'usb-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (352 commits)
      usbcore: fix incorrect type in assignment in descriptors_changed()
      usbcore: compare and release one bos descriptor in usb_reset_and_verify_device()
      ehci: remove debugging statement with ehci statistics in ehci_stop()
      ehci: remove duplicate debug_async_open() prototype in ehci-dbg.c
      ehci: enable debugging code when CONFIG_DYNAMIC_DEBUG is set
      ehci: remove ehci_vdbg() verbose debugging statements
      Documentation sysfs-bus-usb: Document which files are used by libusb
      Documentation sysfs-bus-usb: Document the speed file used by libusb
      Documentation sysfs-bus-usb: Move files with known users to stable
      USB: fix build error when CONFIG_PM_SLEEP isn't enabled
      usb: r8a66597-hcd: use platform_{get,set}_drvdata()
      usb: phy-tegra-usb: use platform_{get,set}_drvdata()
      usb: acm gadget: Null termintate strings table
      dma: cppi41: off by one in desc_to_chan()
      xhci: Fix warning introduced by disabling runtime PM.
      dev-core: fix build break when DEBUG is enabled
      USB: OHCI: Allow runtime PM without system sleep
      usb: ohci-at91: remove unnecessary dev_set_drvdata()
      usb: renesas_usbhs: use platform_{get,set}_drvdata()
      usb: fotg210-udc: use platform_{get,set}_drvdata()
      ...

commit 69820e01aa756b8d228143d997f71523c1e97984
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Aug 26 15:01:40 2013 -0400

    USB: OHCI: Allow runtime PM without system sleep
    
    Since ohci-hcd supports runtime PM, the .pm field in its pci_driver
    structure should be protected by CONFIG_PM rather than
    CONFIG_PM_SLEEP.
    
    Without this change, OHCI controllers won't do runtime suspend if
    system suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..767a5eeff848 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -289,7 +289,7 @@ static struct pci_driver ohci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&usb_hcd_pci_pm_ops
 	},

commit d3474049ab6cfcf14274f5ab9f20c8f50b083eab
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Aug 26 10:53:53 2013 -0400

    USB: OHCI: fix build error related to ohci_suspend/resume
    
    Commit 9a11899c5e69 (USB: OHCI: add missing PCI PM callbacks to
    ohci-pci.c) added missing ohci_suspend and ohci_resume callback
    pointers, but forgot that these callbacks are declared and defined
    only when CONFIG_PM is enabled.
    
    This patch adds a preprocessor conditional to avoid build errors when
    PM is disabled.
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Reported-by: Meelis Roos <mroos@linux.ee>,
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 0f1d193fef02..279b04910f00 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -305,9 +305,11 @@ static int __init ohci_pci_init(void)
 
 	ohci_init_driver(&ohci_pci_hc_driver, &pci_overrides);
 
+#ifdef	CONFIG_PM
 	/* Entries for the PCI suspend/resume callbacks are special */
 	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
 	ohci_pci_hc_driver.pci_resume = ohci_resume;
+#endif
 
 	return pci_register_driver(&ohci_pci_driver);
 }

commit 9a11899c5e699a8d2551692dfcd4372e39dcbdf6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 21 10:33:17 2013 -0400

    USB: OHCI: add missing PCI PM callbacks to ohci-pci.c
    
    Commit c1117afb8589 (USB: OHCI: make ohci-pci a separate driver)
    neglected to preserve the entries for the pci_suspend and pci_resume
    driver callbacks.  As a result, OHCI controllers don't work properly
    during suspend and after hibernation.
    
    This patch adds the missing callbacks to the driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Steve Cotton <steve@s.cotton.clara.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..0f1d193fef02 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -304,6 +304,11 @@ static int __init ohci_pci_init(void)
 	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
 	ohci_init_driver(&ohci_pci_hc_driver, &pci_overrides);
+
+	/* Entries for the PCI suspend/resume callbacks are special */
+	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
+	ohci_pci_hc_driver.pci_resume = ohci_resume;
+
 	return pci_register_driver(&ohci_pci_driver);
 }
 module_init(ohci_pci_init);

commit c1117afb85890adf4073c7ff18ebcb4d0495e6af
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue May 28 18:34:51 2013 +0530

    USB: OHCI: make ohci-pci a separate driver
    
    This patch splits the PCI portion of ohci-hcd out into its
    own separate driver module, called ohci-pci.
    
    The major point of difficulty lies in ohci-pci's many vendor- and
    device-specific workarounds.  Some of them have to be applied before
    calling ohci_start() some after, which necessitates a fair amount of
    code motion.  The other platform drivers require much smaller changes.
    
    The complete sb800_prefetch() function moved to ohci-q.c,because its
    only related to ohci-pci driver.
    
    USB_OHCI_HCD_PCI symbol no longer dependence on STB03xxx, PPC_MPC52xx and
    USB_OHCI_HCD_PPC_OF that's what removed.
    
    V2:
      - few specific content of pci related code in ohci_pci_start function has been moved to ohci_pci_reset
        and rest of the generic code is written in ohci_start of ohci-hcd.c file.
    V3:
     - ohci_restart() has been called in ohci_pci_reset() function for to reset the ohci pci.
    
    V4:
     -sb800_prefetch() moved to ohci-q.c,because its only related to ohci-pci.
     -no longer _creating_ CONFIG_USB_OHCI_PCI,creating CONFIG_USB_OHCI_HCD_PCI.
     -overrides renamed with pci_override,its giving proper meaning.
    
    V5:
     -sb800_prefetch() moved to pci-quirks.c,because its only related to pci.
    
    V6:
     -sb800_prefetch() function has been moved to pci-quirks.c made as separate patch in 2/3.
     -Most of the generic ohci pci changes moved in 2/3 patch,now this is complete  ohci-pci separation patch.
    
    V7:
     -Unrelated include file has been removed from ohci.h file.
    
    V8:
     -USB_OHCI_HCD_PCI symbol does not dependence on STB03xxx, PPC_MPC52xx and USB_OHCI_HCD_PPC_OF.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index c3fa93638ea6..08613e241894 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -14,12 +14,19 @@
  * This file is licenced under the GPL.
  */
 
-#ifndef CONFIG_PCI
-#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
-#endif
-
-#include <linux/pci.h>
 #include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+
+#include "ohci.h"
+#include "pci-quirks.h"
+
+#define DRIVER_DESC "OHCI PCI platform driver"
+
+static const char hcd_name[] = "ohci-pci";
 
 
 /*-------------------------------------------------------------------------*/
@@ -229,10 +236,10 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 static int ohci_pci_reset (struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 	int ret = 0;
 
 	if (hcd->self.controller) {
-		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 		const struct pci_device_id *quirk_id;
 
 		quirk_id = pci_match_id(ohci_pci_quirks, pdev);
@@ -242,94 +249,25 @@ static int ohci_pci_reset (struct usb_hcd *hcd)
 			ret = quirk(hcd);
 		}
 	}
-	if (ret == 0) {
-		ohci_hcd_init (ohci);
-		return ohci_init (ohci);
-	}
-	return ret;
-}
-
-
-static int ohci_pci_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-#ifdef CONFIG_PM /* avoid warnings about unused pdev */
-	if (hcd->self.controller) {
-		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
-
-		/* RWC may not be set for add-in PCI cards, since boot
-		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities.
-		 */
-		if (device_can_wakeup(&pdev->dev))
-			ohci->hc_control |= OHCI_CTRL_RWC;
-	}
-#endif /* CONFIG_PM */
 
-	ret = ohci_run (ohci);
-	if (ret < 0) {
-		ohci_err (ohci, "can't start\n");
-		ohci_stop (hcd);
-	}
+	if (ret == 0)
+		ret = ohci_setup(hcd);
+	/*
+	* After ohci setup RWC may not be set for add-in PCI cards.
+	* This transfers PCI PM wakeup capabilities.
+	*/
+	if (device_can_wakeup(&pdev->dev))
+		ohci->hc_control |= OHCI_CTRL_RWC;
 	return ret;
 }
 
+static struct hc_driver __read_mostly ohci_pci_hc_driver;
 
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_pci_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"OHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_MEMORY | HCD_USB11,
-
-	/*
-	 * basic lifecycle operations
-	 */
+static const struct ohci_driver_overrides pci_overrides __initconst = {
+	.product_desc =		"OHCI PCI host controller",
 	.reset =		ohci_pci_reset,
-	.start =		ohci_pci_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-#ifdef	CONFIG_PM
-	.pci_suspend =		ohci_suspend,
-	.pci_resume =		ohci_resume,
-#endif
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
 };
 
-/*-------------------------------------------------------------------------*/
-
-
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
@@ -357,3 +295,24 @@ static struct pci_driver ohci_pci_driver = {
 	},
 #endif
 };
+
+static int __init ohci_pci_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+
+	ohci_init_driver(&ohci_pci_hc_driver, &pci_overrides);
+	return pci_register_driver(&ohci_pci_driver);
+}
+module_init(ohci_pci_init);
+
+static void __exit ohci_pci_cleanup(void)
+{
+	pci_unregister_driver(&ohci_pci_driver);
+}
+module_exit(ohci_pci_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");

commit 2621d0119e574f12496c4ab731265d5777cb6a18
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue May 28 18:34:50 2013 +0530

    USB: OHCI: Generic changes to make ohci-pci a separate driver
    
    Note that this changes is part of separating the ohci pci host controller
    driver from ohci-hcd host code.
    This contains :
         -Moved sb800_prefetch() function from ohci-pci.c to pci-quirks.c file
          and EXPORTed, this is part of the effort to move the ohci pci related
          code to generic pci code.
         -Passed "device" argument instead  of "ohci_hcd" in sb800_prefetch()
          function to avoid extra include file in pci-quirks.c.
    
    V2:
         -Passed "device" argment instead of "pci_dev", then we use to_pci_dev()
          to get the "pci_dev" structure.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 2c27a5fc4bfe..c3fa93638ea6 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -168,19 +168,6 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	return 0;
 }
 
-static void sb800_prefetch(struct ohci_hcd *ohci, int on)
-{
-	struct pci_dev *pdev;
-	u16 misc;
-
-	pdev = to_pci_dev(ohci_to_hcd(ohci)->self.controller);
-	pci_read_config_word(pdev, 0x50, &misc);
-	if (on == 0)
-		pci_write_config_word(pdev, 0x50, misc & 0xfcff);
-	else
-		pci_write_config_word(pdev, 0x50, misc | 0x0300);
-}
-
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{

commit 95e44d44fc29b3d84a74fc5793d8a78ba843c66b
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue May 28 18:34:49 2013 +0530

    USB: OHCI: prepare to make ohci-hcd a library module
    
    This patch prepares ohci-hcd for being split up into a core
    library and separate platform driver modules.  A generic
    ohci_hc_driver structure is created, containing all the "standard"
    values, and a new mechanism is added whereby a driver module can
    specify a set of overrides to those values.  In addition the
    ohci_restart(),ohci_suspend() and ohci_resume() routines need
    to be EXPORTed for use by the drivers.
    
    Added ohci_setip(() and ohci_start() routine for to start the generic
    controller rather than each having its own idiosyncratic approach.
    This allow to clean duplicated code in most of SOC driver
    
    In V2:
     -ohci_hcd_init() ohci_run() and ohci_stop() are not made non-static.
     -Adds the ohci_setup() and ohci_start() routine.
    
    In V3:
     -purpose of ohci_setup() and ohci_start() function description written in the patch
      description.
     -ohci_init() are not made non-static but now called beginning of the ohci_restart().
     -ohci_run() signature change reverted back.
     -unrelated changes removed.
     -duplicate comment line removed.
     -inline ohci_suspend() and ohci_resume() is not needed so removed from ohci.h file.
    
    In V4:
     -ohci-init() EXPORTed because it is called by all bus glue modules.
     -ohci-setup() removed from 1/2 added into 2/2 patch.
    
    In V5:
     -Again ohci_setup() is added and EXPORTed because to replace the ohci_init() from
      all bus glues.
     -ohci_init() is not made non-static function.
    
    In V6:
      -ohci_init() call is removed from ohci_quirk_nec_worker(), because it is already called in ohci_restart().
    
    In V8:
      -ohci_hcd_init() is called by ohci_setup() to make generic ohci initialization in all ohci drivers.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 951514ef446d..2c27a5fc4bfe 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -123,13 +123,6 @@ static void ohci_quirk_nec_worker(struct work_struct *work)
 	struct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);
 	int status;
 
-	status = ohci_init(ohci);
-	if (status != 0) {
-		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",
-			 "ohci_init", status);
-		return;
-	}
-
 	status = ohci_restart(ohci);
 	if (status != 0)
 		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",

commit 41ac7b3ab7fe1d6175839947a877fdf95cbd2211
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:48 2012 -0500

    usb: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Olav Kongas <ok@artecdesign.ee>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 6afa7dc4e4c3..951514ef446d 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -270,7 +270,7 @@ static int ohci_pci_reset (struct usb_hcd *hcd)
 }
 
 
-static int __devinit ohci_pci_start (struct usb_hcd *hcd)
+static int ohci_pci_start (struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ret;

commit cd1965db054eeace344487b9c8560439961f5f55
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:27 2012 +0200

    USB: ohci: move ohci_pci_{suspend,resume} to ohci-hcd.c
    
    As suggested by Alan Stern, move the ohci-pci.c ohci_pci_{suspend,resume}
    routines to ohci-hcd.c. Due to their move, also rename them to
    ohci_{suspend,resume} to make it clear they operate on ohci_hcd. Since they
    are not necessarily called, annotate them with __maybe_unused, and make them
    enclosed within an #ifdef CONFIG_PM / #endif section.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 1843bb68ac7c..6afa7dc4e4c3 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -296,49 +296,6 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
-#ifdef	CONFIG_PM
-
-static int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	unsigned long	flags;
-	int		rc = 0;
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 */
-	spin_lock_irqsave (&ohci->lock, flags);
-	if (ohci->rh_state != OHCI_RH_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
-	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
-	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
- bail:
-	spin_unlock_irqrestore (&ohci->lock, flags);
-
-	return rc;
-}
-
-
-static int ohci_pci_resume(struct usb_hcd *hcd, bool hibernated)
-{
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* Make sure resume from hibernation re-enumerates everything */
-	if (hibernated)
-		ohci_usb_reset(hcd_to_ohci(hcd));
-
-	ohci_finish_controller_resume(hcd);
-	return 0;
-}
-
-#endif	/* CONFIG_PM */
-
 
 /*-------------------------------------------------------------------------*/
 
@@ -362,8 +319,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
-	.pci_suspend =		ohci_pci_suspend,
-	.pci_resume =		ohci_pci_resume,
+	.pci_suspend =		ohci_suspend,
+	.pci_resume =		ohci_resume,
 #endif
 
 	/*

commit 3a0bac0676d7f433c12389fc0bc574f048f921c3
Author: Alessandro Rubini <rubini@gnudd.com>
Date:   Fri Jan 6 13:33:28 2012 +0100

    usb: add support for STA2X11 host driver
    
    Signed-off-by: Alessandro Rubini <rubini@gnudd.com>
    Acked-by: Giancarlo Asnaghi <giancarlo.asnaghi@st.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 6109810cc2d3..1843bb68ac7c 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -397,6 +397,10 @@ static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
+	}, {
+	/* The device in the ConneXT I/O hub has no class reg */
+	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_OHCI),
+	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, { /* end: all zeroes */ }
 };
 MODULE_DEVICE_TABLE (pci, pci_ids);

commit 47b649590dbbea182f854d6470ee1cd59b7b7684
Merge: 3af5154a869b caca6a03d365
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Nov 26 19:46:19 2011 -0800

    Merge 3.2-rc3 into usb-linus
    
    This pulls in the latest USB bugfixes and helps a few of the drivers
    merge nicer in the future due to changes in both branches.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c61875977458637226ab093a35d200f2d5789787
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 17 16:41:45 2011 -0500

    OHCI: final fix for NVIDIA problems (I hope)
    
    Problems with NVIDIA's OHCI host controllers persist.  After looking
    carefully through the spec, I finally realized that when a controller
    is reset it then automatically goes into a SUSPEND state in which it
    is completely quiescent (no DMA and no IRQs) and from which it will
    not awaken until the system puts it into the OPERATIONAL state.
    
    Therefore there's no need to worry about controllers being in the
    RESET state for extended periods, or remaining in the OPERATIONAL
    state during system shutdown.  The proper action for device
    initialization is to put the controller into the RESET state (if it's
    not there already) and then to issue a software reset.  Similarly, the
    proper action for device shutdown is simply to do a software reset.
    
    This patch (as1499) implements such an approach.  It simplifies
    initialization and shutdown, and allows the NVIDIA shutdown-quirk code
    to be removed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Andre "Osku" Schmidt <andre.osku.schmidt@googlemail.com>
    Tested-by: Arno Augustin <Arno.Augustin@web.de>
    Cc: stable <stable@vger.kernel.org> [after tested in 3.2 for a while]
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ad8166c681e2..bc01b064585a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -175,28 +175,6 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	return 0;
 }
 
-/* nVidia controllers continue to drive Reset signalling on the bus
- * even after system shutdown, wasting power.  This flag tells the
- * shutdown routine to leave the controller OPERATIONAL instead of RESET.
- */
-static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
-{
-	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
-	/* Evidently nVidia fixed their later hardware; this is a guess at
-	 * the changeover point.
-	 */
-#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB		0x026d
-
-	if (pdev->device < PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {
-		ohci->flags |= OHCI_QUIRK_SHUTDOWN;
-		ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
-	}
-
-	return 0;
-}
-
 static void sb800_prefetch(struct ohci_hcd *ohci, int on)
 {
 	struct pci_dev *pdev;
@@ -260,10 +238,6 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
 		.driver_data = (unsigned long)ohci_quirk_amd700,
 	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID),
-		.driver_data = (unsigned long) ohci_quirk_nvidia_shutdown,
-	},
 
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.

commit b7463c71fbbff7111d0c879d2f64fe2b08f51848
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 17 16:41:56 2011 -0500

    OHCI: remove uses of hcd->state
    
    This patch (as1500) removes all uses of the objectionable hcd->state
    variable from the ohci-hcd family of drivers.  It is replaced by a
    private ohci->rh_state field, just as in uhci-hcd and ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ad8166c681e2..847187df50a1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -334,12 +334,9 @@ static int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	 * mark HW unaccessible, bail out if RH has been resumed. Use
 	 * the spinlock to properly synchronize with possible pending
 	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd->state is manipulated outside of
-	 * any locks =P But that will be a different fix.
 	 */
 	spin_lock_irqsave (&ohci->lock, flags);
-	if (hcd->state != HC_STATE_SUSPENDED) {
+	if (ohci->rh_state != OHCI_RH_SUSPENDED) {
 		rc = -EINVAL;
 		goto bail;
 	}

commit 2b7aaf503d56216b847c8265421d2a7d9b42df3e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 16 12:15:19 2011 -0400

    OHCI: fix regression caused by nVidia shutdown workaround
    
    This patch (as1463) fixes a regression caused by commit
    3df7169e73fc1d71a39cffeacc969f6840cdf52b (OHCI: work around for nVidia
    shutdown problem).
    
    The original problem encountered by people using NVIDIA chipsets was
    that USB devices were not turning off when the system shut down.  For
    example, the LED on an optical mouse would remain on, draining a
    laptop's battery.  The problem was caused by a bug in the chipset; an
    OHCI controller in the Reset state would continue to drive a bus reset
    signal even after system shutdown.  The workaround was to put the
    controllers into the Suspend state instead.
    
    It turns out that later NVIDIA chipsets do not suffer from this bug.
    Instead some have the opposite bug: If a system is shut down while an
    OHCI controller is in the Suspend state, USB devices remain powered!
    On other systems, shutting down with a Suspended controller causes the
    system to reboot immediately.  Thus, working around the original bug
    on some machines exposes other bugs on other machines.
    
    The best solution seems to be to limit the workaround to OHCI
    controllers with a low-numbered PCI product ID.  I don't know exactly
    at what point NVIDIA changed their chipsets; the value used here is a
    guess.  So far it was worked out okay for all the people who have
    tested it.
    
    This fixes Bugzilla #35032.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Andre "Osku" Schmidt <andre.osku.schmidt@googlemail.com>
    Tested-by: Yury Siamashka <yurand2@gmail.com>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d84d6f0314f9..ad8166c681e2 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -181,10 +181,18 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
  */
 static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 {
+	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
-	ohci->flags |= OHCI_QUIRK_SHUTDOWN;
-	ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	/* Evidently nVidia fixed their later hardware; this is a guess at
+	 * the changeover point.
+	 */
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB		0x026d
+
+	if (pdev->device < PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {
+		ohci->flags |= OHCI_QUIRK_SHUTDOWN;
+		ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	}
 
 	return 0;
 }

commit fa417c369b48a8f7acaf9aba1ff94b0969b0cb7e
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Mar 3 21:10:05 2011 +0300

    USB: OHCI: use pci_dev->revision
    
    Commit ab1666c1364a209e6141d7c14e47a42b5f00eca2 (USB: quirk PLL power down mode)
    added code that reads the revision ID from the PCI configuration register while
    it's stored by PCI subsystem in the 'revision' field of 'struct pci_dev'...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 9816a2870d00..d84d6f0314f9 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -151,7 +151,7 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
 	struct pci_dev *amd_smbus_dev;
-	u8 rev = 0;
+	u8 rev;
 
 	if (usb_amd_find_chipset_info())
 		ohci->flags |= OHCI_QUIRK_AMD_PLL;
@@ -161,7 +161,7 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	if (!amd_smbus_dev)
 		return 0;
 
-	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+	rev = amd_smbus_dev->revision;
 
 	/* SB800 needs pre-fetch fix */
 	if ((rev >= 0x40) && (rev <= 0x4f)) {

commit ad93562bdeecdded7d02eaaaf1aa5705ab57b1b7
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Mar 1 14:57:05 2011 +0800

    USB host: Move AMD PLL quirk to pci-quirks.c
    
    This patch moves the AMD PLL quirk code in OHCI/EHCI driver to pci-quirks.c,
    and exports the functions to be used by xHCI driver later.
    
    AMD PLL quirk disable the optional PM feature inside specific
    SB700/SB800/Hudson-2/3 platforms under the following conditions:
    
    1. If an isochronous device is connected to OHCI/EHCI/xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    Without AMD PLL quirk, USB isochronous stream may stutter or have breaks
    occasionally, which greatly impair the performance of audio/video streams.
    
    Currently AMD PLL quirk is implemented in OHCI and EHCI driver, and will be
    added to xHCI driver too. They are doing similar things actually, so move
    the quirk code to pci-quirks.c, which has several advantages:
    
    1. Remove duplicate defines and functions in OHCI/EHCI (and xHCI) driver and
       make them cleaner;
    2. AMD chipset information will be probed only once and then stored.
       Currently they're probed during every OHCI/EHCI initialization, move
       the detect code to pci-quirks.c saves the repeat detect cost;
    3. Build up synchronization among OHCI/EHCI/xHCI driver. In current
       code, every host controller enable/disable PLL only according to
       its own status, and may enable PLL while there is still isoc transfer on
       other HCs. Move the quirk to pci-quirks.c prevents this issue.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alex He <alex.he@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 36ee9a666e93..9816a2870d00 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -22,24 +22,6 @@
 #include <linux/io.h>
 
 
-/* constants used to work around PM-related transfer
- * glitches in some AMD 700 series southbridges
- */
-#define AB_REG_BAR	0xf0
-#define AB_INDX(addr)	((addr) + 0x00)
-#define AB_DATA(addr)	((addr) + 0x04)
-#define AX_INDXC	0X30
-#define AX_DATAC	0x34
-
-#define NB_PCIE_INDX_ADDR	0xe0
-#define NB_PCIE_INDX_DATA	0xe4
-#define PCIE_P_CNTL		0x10040
-#define BIF_NB			0x10002
-
-static struct pci_dev *amd_smbus_dev;
-static struct pci_dev *amd_hb_dev;
-static int amd_ohci_iso_count;
-
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -168,11 +150,14 @@ static int ohci_quirk_nec(struct usb_hcd *hcd)
 static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct pci_dev *amd_smbus_dev;
 	u8 rev = 0;
 
-	if (!amd_smbus_dev)
-		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
-				PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	if (usb_amd_find_chipset_info())
+		ohci->flags |= OHCI_QUIRK_AMD_PLL;
+
+	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+			PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
 	if (!amd_smbus_dev)
 		return 0;
 
@@ -184,19 +169,8 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
-	if ((rev > 0x3b) || (rev < 0x30)) {
-		pci_dev_put(amd_smbus_dev);
-		amd_smbus_dev = NULL;
-		return 0;
-	}
-
-	amd_ohci_iso_count++;
-
-	if (!amd_hb_dev)
-		amd_hb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9600, NULL);
-
-	ohci->flags |= OHCI_QUIRK_AMD_ISO;
-	ohci_dbg(ohci, "enabled AMD ISO transfers quirk\n");
+	pci_dev_put(amd_smbus_dev);
+	amd_smbus_dev = NULL;
 
 	return 0;
 }
@@ -215,74 +189,6 @@ static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 	return 0;
 }
 
-/*
- * The hardware normally enables the A-link power management feature, which
- * lets the system lower the power consumption in idle states.
- *
- * Assume the system is configured to have USB 1.1 ISO transfers going
- * to or from a USB device.  Without this quirk, that stream may stutter
- * or have breaks occasionally.  For transfers going to speakers, this
- * makes a very audible mess...
- *
- * That audio playback corruption is due to the audio stream getting
- * interrupted occasionally when the link goes in lower power state
- * This USB quirk prevents the link going into that lower power state
- * during audio playback or other ISO operations.
- */
-static void quirk_amd_pll(int on)
-{
-	u32 addr;
-	u32 val;
-	u32 bit = (on > 0) ? 1 : 0;
-
-	pci_read_config_dword(amd_smbus_dev, AB_REG_BAR, &addr);
-
-	/* BIT names/meanings are NDA-protected, sorry ... */
-
-	outl(AX_INDXC, AB_INDX(addr));
-	outl(0x40, AB_DATA(addr));
-	outl(AX_DATAC, AB_INDX(addr));
-	val = inl(AB_DATA(addr));
-	val &= ~((1 << 3) | (1 << 4) | (1 << 9));
-	val |= (bit << 3) | ((!bit) << 4) | ((!bit) << 9);
-	outl(val, AB_DATA(addr));
-
-	if (amd_hb_dev) {
-		addr = PCIE_P_CNTL;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
-
-		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
-		val &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));
-		val |= bit | (bit << 3) | (bit << 12);
-		val |= ((!bit) << 4) | ((!bit) << 9);
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
-
-		addr = BIF_NB;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
-
-		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
-		val &= ~(1 << 8);
-		val |= bit << 8;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
-	}
-}
-
-static void amd_iso_dev_put(void)
-{
-	amd_ohci_iso_count--;
-	if (amd_ohci_iso_count == 0) {
-		if (amd_smbus_dev) {
-			pci_dev_put(amd_smbus_dev);
-			amd_smbus_dev = NULL;
-		}
-		if (amd_hb_dev) {
-			pci_dev_put(amd_hb_dev);
-			amd_hb_dev = NULL;
-		}
-	}
-
-}
-
 static void sb800_prefetch(struct ohci_hcd *ohci, int on)
 {
 	struct pci_dev *pdev;

commit 479b46b5599b1e610630d7332e168c1f9c4ee0b4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 17 09:54:16 2011 -0800

    Revert "USB host: Move AMD PLL quirk to pci-quirks.c"
    
    This reverts commit b7d5b439b7a40dd0a0202fe1c118615a3fcc3b25.
    It conflicts with commit baab93afc2844b68d57b0dcca5e1d34c5d7cf411 "USB:
    EHCI: ASPM quirk of ISOC on AMD Hudson" and merging the two just doesn't
    work properly.
    
    Cc: Andiry Xu <andiry.xu@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alex He <alex.he@amd.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 9816a2870d00..36ee9a666e93 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -22,6 +22,24 @@
 #include <linux/io.h>
 
 
+/* constants used to work around PM-related transfer
+ * glitches in some AMD 700 series southbridges
+ */
+#define AB_REG_BAR	0xf0
+#define AB_INDX(addr)	((addr) + 0x00)
+#define AB_DATA(addr)	((addr) + 0x04)
+#define AX_INDXC	0X30
+#define AX_DATAC	0x34
+
+#define NB_PCIE_INDX_ADDR	0xe0
+#define NB_PCIE_INDX_DATA	0xe4
+#define PCIE_P_CNTL		0x10040
+#define BIF_NB			0x10002
+
+static struct pci_dev *amd_smbus_dev;
+static struct pci_dev *amd_hb_dev;
+static int amd_ohci_iso_count;
+
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -150,14 +168,11 @@ static int ohci_quirk_nec(struct usb_hcd *hcd)
 static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	struct pci_dev *amd_smbus_dev;
 	u8 rev = 0;
 
-	if (usb_amd_find_chipset_info())
-		ohci->flags |= OHCI_QUIRK_AMD_PLL;
-
-	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
-			PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	if (!amd_smbus_dev)
+		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+				PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
 	if (!amd_smbus_dev)
 		return 0;
 
@@ -169,8 +184,19 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
-	pci_dev_put(amd_smbus_dev);
-	amd_smbus_dev = NULL;
+	if ((rev > 0x3b) || (rev < 0x30)) {
+		pci_dev_put(amd_smbus_dev);
+		amd_smbus_dev = NULL;
+		return 0;
+	}
+
+	amd_ohci_iso_count++;
+
+	if (!amd_hb_dev)
+		amd_hb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9600, NULL);
+
+	ohci->flags |= OHCI_QUIRK_AMD_ISO;
+	ohci_dbg(ohci, "enabled AMD ISO transfers quirk\n");
 
 	return 0;
 }
@@ -189,6 +215,74 @@ static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 	return 0;
 }
 
+/*
+ * The hardware normally enables the A-link power management feature, which
+ * lets the system lower the power consumption in idle states.
+ *
+ * Assume the system is configured to have USB 1.1 ISO transfers going
+ * to or from a USB device.  Without this quirk, that stream may stutter
+ * or have breaks occasionally.  For transfers going to speakers, this
+ * makes a very audible mess...
+ *
+ * That audio playback corruption is due to the audio stream getting
+ * interrupted occasionally when the link goes in lower power state
+ * This USB quirk prevents the link going into that lower power state
+ * during audio playback or other ISO operations.
+ */
+static void quirk_amd_pll(int on)
+{
+	u32 addr;
+	u32 val;
+	u32 bit = (on > 0) ? 1 : 0;
+
+	pci_read_config_dword(amd_smbus_dev, AB_REG_BAR, &addr);
+
+	/* BIT names/meanings are NDA-protected, sorry ... */
+
+	outl(AX_INDXC, AB_INDX(addr));
+	outl(0x40, AB_DATA(addr));
+	outl(AX_DATAC, AB_INDX(addr));
+	val = inl(AB_DATA(addr));
+	val &= ~((1 << 3) | (1 << 4) | (1 << 9));
+	val |= (bit << 3) | ((!bit) << 4) | ((!bit) << 9);
+	outl(val, AB_DATA(addr));
+
+	if (amd_hb_dev) {
+		addr = PCIE_P_CNTL;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));
+		val |= bit | (bit << 3) | (bit << 12);
+		val |= ((!bit) << 4) | ((!bit) << 9);
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+
+		addr = BIF_NB;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 << 8);
+		val |= bit << 8;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+	}
+}
+
+static void amd_iso_dev_put(void)
+{
+	amd_ohci_iso_count--;
+	if (amd_ohci_iso_count == 0) {
+		if (amd_smbus_dev) {
+			pci_dev_put(amd_smbus_dev);
+			amd_smbus_dev = NULL;
+		}
+		if (amd_hb_dev) {
+			pci_dev_put(amd_hb_dev);
+			amd_hb_dev = NULL;
+		}
+	}
+
+}
+
 static void sb800_prefetch(struct ohci_hcd *ohci, int on)
 {
 	struct pci_dev *pdev;

commit b7d5b439b7a40dd0a0202fe1c118615a3fcc3b25
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Jan 25 18:41:21 2011 +0800

    USB host: Move AMD PLL quirk to pci-quirks.c
    
    This patch moves the AMD PLL quirk code in OHCI/EHCI driver to pci-quirks.c,
    and exports the functions to be used by xHCI driver later.
    
    AMD PLL quirk disable the optional PM feature inside specific
    SB700/SB800/Hudson-2/3 platforms under the following conditions:
    
    1. If an isochronous device is connected to OHCI/EHCI/xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    Without AMD PLL quirk, USB isochronous stream may stutter or have breaks
    occasionally, which greatly impair the performance of audio/video streams.
    
    Currently AMD PLL quirk is implemented in OHCI and EHCI driver, and will be
    added to xHCI driver too. They are doing similar things actually, so move
    the quirk code to pci-quirks.c, which has several advantages:
    
    1. Remove duplicate defines and functions in OHCI/EHCI (and xHCI) driver and
       make them cleaner;
    2. AMD chipset information will be probed only once and then stored.
       Currently they're probed during every OHCI/EHCI initialization, move
       the detect code to pci-quirks.c saves the repeat detect cost;
    3. Build up synchronization among OHCI/EHCI/xHCI driver. In current
       code, every host controller enable/disable PLL only according to
       its own status, and may enable PLL while there is still isoc transfer on
       other HCs. Move the quirk to pci-quirks.c prevents this issue.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alex He <alex.he@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 36ee9a666e93..9816a2870d00 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -22,24 +22,6 @@
 #include <linux/io.h>
 
 
-/* constants used to work around PM-related transfer
- * glitches in some AMD 700 series southbridges
- */
-#define AB_REG_BAR	0xf0
-#define AB_INDX(addr)	((addr) + 0x00)
-#define AB_DATA(addr)	((addr) + 0x04)
-#define AX_INDXC	0X30
-#define AX_DATAC	0x34
-
-#define NB_PCIE_INDX_ADDR	0xe0
-#define NB_PCIE_INDX_DATA	0xe4
-#define PCIE_P_CNTL		0x10040
-#define BIF_NB			0x10002
-
-static struct pci_dev *amd_smbus_dev;
-static struct pci_dev *amd_hb_dev;
-static int amd_ohci_iso_count;
-
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -168,11 +150,14 @@ static int ohci_quirk_nec(struct usb_hcd *hcd)
 static int ohci_quirk_amd700(struct usb_hcd *hcd)
 {
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct pci_dev *amd_smbus_dev;
 	u8 rev = 0;
 
-	if (!amd_smbus_dev)
-		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
-				PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	if (usb_amd_find_chipset_info())
+		ohci->flags |= OHCI_QUIRK_AMD_PLL;
+
+	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+			PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
 	if (!amd_smbus_dev)
 		return 0;
 
@@ -184,19 +169,8 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
 	}
 
-	if ((rev > 0x3b) || (rev < 0x30)) {
-		pci_dev_put(amd_smbus_dev);
-		amd_smbus_dev = NULL;
-		return 0;
-	}
-
-	amd_ohci_iso_count++;
-
-	if (!amd_hb_dev)
-		amd_hb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9600, NULL);
-
-	ohci->flags |= OHCI_QUIRK_AMD_ISO;
-	ohci_dbg(ohci, "enabled AMD ISO transfers quirk\n");
+	pci_dev_put(amd_smbus_dev);
+	amd_smbus_dev = NULL;
 
 	return 0;
 }
@@ -215,74 +189,6 @@ static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 	return 0;
 }
 
-/*
- * The hardware normally enables the A-link power management feature, which
- * lets the system lower the power consumption in idle states.
- *
- * Assume the system is configured to have USB 1.1 ISO transfers going
- * to or from a USB device.  Without this quirk, that stream may stutter
- * or have breaks occasionally.  For transfers going to speakers, this
- * makes a very audible mess...
- *
- * That audio playback corruption is due to the audio stream getting
- * interrupted occasionally when the link goes in lower power state
- * This USB quirk prevents the link going into that lower power state
- * during audio playback or other ISO operations.
- */
-static void quirk_amd_pll(int on)
-{
-	u32 addr;
-	u32 val;
-	u32 bit = (on > 0) ? 1 : 0;
-
-	pci_read_config_dword(amd_smbus_dev, AB_REG_BAR, &addr);
-
-	/* BIT names/meanings are NDA-protected, sorry ... */
-
-	outl(AX_INDXC, AB_INDX(addr));
-	outl(0x40, AB_DATA(addr));
-	outl(AX_DATAC, AB_INDX(addr));
-	val = inl(AB_DATA(addr));
-	val &= ~((1 << 3) | (1 << 4) | (1 << 9));
-	val |= (bit << 3) | ((!bit) << 4) | ((!bit) << 9);
-	outl(val, AB_DATA(addr));
-
-	if (amd_hb_dev) {
-		addr = PCIE_P_CNTL;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
-
-		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
-		val &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));
-		val |= bit | (bit << 3) | (bit << 12);
-		val |= ((!bit) << 4) | ((!bit) << 9);
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
-
-		addr = BIF_NB;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
-
-		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
-		val &= ~(1 << 8);
-		val |= bit << 8;
-		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
-	}
-}
-
-static void amd_iso_dev_put(void)
-{
-	amd_ohci_iso_count--;
-	if (amd_ohci_iso_count == 0) {
-		if (amd_smbus_dev) {
-			pci_dev_put(amd_smbus_dev);
-			amd_smbus_dev = NULL;
-		}
-		if (amd_hb_dev) {
-			pci_dev_put(amd_hb_dev);
-			amd_hb_dev = NULL;
-		}
-	}
-
-}
-
 static void sb800_prefetch(struct ohci_hcd *ohci, int on)
 {
 	struct pci_dev *pdev;

commit 3df7169e73fc1d71a39cffeacc969f6840cdf52b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Sep 10 16:37:05 2010 -0400

    OHCI: work around for nVidia shutdown problem
    
    This patch (as1417) fixes a problem affecting some (or all) nVidia
    chipsets.  When the computer is shut down, the OHCI controllers
    continue to power the USB buses and evidently they drive a Reset
    signal out all their ports.  This prevents attached devices from going
    to low power.  Mouse LEDs stay on, for example, which is disconcerting
    for users and a drain on laptop batteries.
    
    The fix involves leaving each OHCI controller in the OPERATIONAL state
    during system shutdown rather than putting it in the RESET state.
    Although this nominally means the controller is running, in fact it's
    not doing very much since all the schedules are all disabled.  However
    there is ongoing DMA to the Host Controller Communications Area, so
    the patch also disables the bus-master capability of all PCI USB
    controllers after the shutdown routine runs.
    
    The fix is applied only to nVidia-based PCI OHCI controllers, so it
    shouldn't cause problems on systems using other hardware.  As an added
    safety measure, in case the kernel encounters one of these running
    controllers during boot, the patch changes quirk_usb_handoff_ohci()
    (which runs early on during PCI discovery) to reset the controller
    before anything bad can happen.
    
    Reported-by: Pali Rohár <pali.rohar@gmail.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Tested-by: Pali Rohár <pali.rohar@gmail.com>
    CC: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 6bdc8b25a6a1..36ee9a666e93 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -201,6 +201,20 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	return 0;
 }
 
+/* nVidia controllers continue to drive Reset signalling on the bus
+ * even after system shutdown, wasting power.  This flag tells the
+ * shutdown routine to leave the controller OPERATIONAL instead of RESET.
+ */
+static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
+	ohci->flags |= OHCI_QUIRK_SHUTDOWN;
+	ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+
+	return 0;
+}
+
 /*
  * The hardware normally enables the A-link power management feature, which
  * lets the system lower the power consumption in idle states.
@@ -332,6 +346,10 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
 		.driver_data = (unsigned long)ohci_quirk_amd700,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID),
+		.driver_data = (unsigned long) ohci_quirk_nvidia_shutdown,
+	},
 
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.

commit 4147200d25c423e627ab4487530b3d9f2ef829c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 25 14:02:14 2010 -0400

    USB: add do_wakeup parameter for PCI HCD suspend
    
    This patch (as1385) adds a "do_wakeup" parameter to the pci_suspend
    method used by PCI-based host controller drivers.  ehci-hcd in
    particular needs to know whether or not to enable wakeup when
    suspending a controller.  Although that information is currently
    available through device_may_wakeup(), when support is added for
    runtime suspend this will no longer be true.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b8a1148f248e..6bdc8b25a6a1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -392,7 +392,7 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 #ifdef	CONFIG_PM
 
-static int ohci_pci_suspend(struct usb_hcd *hcd)
+static int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	unsigned long	flags;

commit a1f17a872bc7b1cb7efdd5486a2963e88a536e61
Author: Libin Yang <libin.yang@amd.com>
Date:   Wed Nov 4 14:55:18 2009 +0800

    USB: ohci: quirk AMD prefetch for USB 1.1 ISO transfer
    
    The following patch in the driver is required to avoid USB 1.1 device
    failures that may occur due to requests from USB OHCI controllers may
    be overwritten if the latency for any pending request by the USB
    controller is very long (in the range of milliseconds).
    
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d2ba04dd785e..b8a1148f248e 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -177,6 +177,13 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 		return 0;
 
 	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+
+	/* SB800 needs pre-fetch fix */
+	if ((rev >= 0x40) && (rev <= 0x4f)) {
+		ohci->flags |= OHCI_QUIRK_AMD_PREFETCH;
+		ohci_dbg(ohci, "enabled AMD prefetch quirk\n");
+	}
+
 	if ((rev > 0x3b) || (rev < 0x30)) {
 		pci_dev_put(amd_smbus_dev);
 		amd_smbus_dev = NULL;
@@ -262,6 +269,19 @@ static void amd_iso_dev_put(void)
 
 }
 
+static void sb800_prefetch(struct ohci_hcd *ohci, int on)
+{
+	struct pci_dev *pdev;
+	u16 misc;
+
+	pdev = to_pci_dev(ohci_to_hcd(ohci)->self.controller);
+	pci_read_config_word(pdev, 0x50, &misc);
+	if (on == 0)
+		pci_write_config_word(pdev, 0x50, misc & 0xfcff);
+	else
+		pci_write_config_word(pdev, 0x50, misc | 0x0300);
+}
+
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{

commit 6ec4beb5c701f728548b587082c83ef62eb36035
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 27 13:33:41 2009 -0400

    USB: new flag for resume-from-hibernation
    
    This patch (as1237) changes the way the PCI host controller drivers
    avoid retaining bogus hardware states during resume-from-hibernation.
    Previously we had reset the hardware as part of preparing to reinstate
    the memory image.  But we can do better now with the new PM framework,
    since we know exactly which resume operations are from hibernation.
    
    The pci_resume method is changed to accept a flag indicating whether
    the system is resuming from hibernation.  When this flag is set, the
    drivers will reset the hardware to get rid of any existing state.
    
    Similarly, the pci_suspend method is changed to remove the
    pm_message_t argument.  It's no longer needed, since no special action
    has to be taken when preparing to reinstate the memory image.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ee0a68ca5fda..d2ba04dd785e 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -372,7 +372,7 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 #ifdef	CONFIG_PM
 
-static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
+static int ohci_pci_suspend(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	unsigned long	flags;
@@ -394,10 +394,6 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
 	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
 
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW)
-		ohci_usb_reset(ohci);
-
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  bail:
 	spin_unlock_irqrestore (&ohci->lock, flags);
@@ -406,9 +402,14 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 }
 
 
-static int ohci_pci_resume (struct usb_hcd *hcd)
+static int ohci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* Make sure resume from hibernation re-enumerates everything */
+	if (hibernated)
+		ohci_usb_reset(hcd_to_ohci(hcd));
+
 	ohci_finish_controller_resume(hcd);
 	return 0;
 }

commit abb306416a7ec2386678de0da6b632a6cb068af0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 27 13:33:24 2009 -0400

    USB: move PCI host controllers to new PM framework
    
    This patch (as1236) converts the USB PCI power management routines
    over to the new PM framework.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index f9961b4c0da3..ee0a68ca5fda 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -484,12 +484,11 @@ static struct pci_driver ohci_pci_driver = {
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+	.shutdown =	usb_hcd_pci_shutdown,
 
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
+#ifdef CONFIG_PM_SLEEP
+	.driver =	{
+		.pm =	&usb_hcd_pci_pm_ops
+	},
 #endif
-
-	.shutdown =	usb_hcd_pci_shutdown,
 };
-

commit 3494252d5644993f407a45f01c3e8ad5ae38f93c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 13 23:41:12 2009 +0100

    USB/PCI: Fix resume breakage of controllers behind cardbus bridges
    
    If a USB PCI controller is behind a cardbus bridge, we are trying to
    restore its configuration registers too early, before the cardbus
    bridge is operational.  To fix this, call pci_restore_state() from
    usb_hcd_pci_resume() and remove usb_hcd_pci_resume_early() which is
    no longer necessary (the configuration spaces of USB controllers that
    are not behind cardbus bridges will be restored by the PCI PM core
    with interrupts disabled anyway).
    
    This patch fixes the regression from 2.6.28 tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12659
    
    [ Side note: the proper long-term fix is probably to just force the
      unplug event at suspend time instead of doing a plug/unplug at resume
      time, but this patch is fine regardless  - Linus ]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Miles Lane <miles.lane@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 5d625c3fd423..f9961b4c0da3 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -487,7 +487,6 @@ static struct pci_driver ohci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
-	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 

commit a15d95a003fae154121733f049dd25e9c13dbef3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 20 01:26:56 2009 +0100

    USB: Fix suspend-resume of PCI USB controllers
    
    Commit a0d4922da2e4ccb0973095d8d29f36f6b1b5f703
    (USB: fix up suspend and resume for PCI host controllers) attempted
    to fix the suspend-resume of PCI USB controllers, but unfortunately
    it did that incorrectly and interrupts are left enabled by the USB
    controllers' ->suspend_late() callback as a result.  This leads to
    serious problems during suspend which are very difficult to debug.
    
    Fix the issue by removing the ->suspend_late() callback of PCI
    USB controllers and moving the code from there to the ->suspend()
    callback executed with interrupts enabled.  Additionally, make
    the ->resume() callback of PCI USB controllers execute
    pci_enable_wake(dev, PCI_D0, false) to disable wake-up from the
    full power state (PCI_D0).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Tested-by: "Jeff Chua" <jeff.chua.linux@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: "Zdenek Kabelac" <zdenek.kabelac@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 8b28ae7865ba..5d625c3fd423 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -487,7 +487,6 @@ static struct pci_driver ohci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
-	.suspend_late =	usb_hcd_pci_suspend_late,
 	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif

commit 6fd9086a518d4f14213a32fe6c9ac17fabebbc1e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 17 17:20:38 2008 -0500

    USB: automatically enable wakeup for PCI host controllers
    
    This patch (as1193b) enables wakeup during initialization for all PCI
    host controllers, and it removes some code (and comments!) that are no
    longer needed now that the PCI core automatically initializes wakeup
    settings for all new devices.
    
    The idea is that the bus should initialize wakeup, and the bus glue
    or controller driver should enable it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 8380cc2e961a..8b28ae7865ba 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -355,9 +355,9 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 		/* RWC may not be set for add-in PCI cards, since boot
 		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities (once the PCI layer is fixed).
+		 * PM wakeup capabilities.
 		 */
-		if (device_may_wakeup(&pdev->dev))
+		if (device_can_wakeup(&pdev->dev))
 			ohci->hc_control |= OHCI_CTRL_RWC;
 	}
 #endif /* CONFIG_PM */

commit a0d4922da2e4ccb0973095d8d29f36f6b1b5f703
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 17 15:06:03 2008 -0500

    USB: fix up suspend and resume for PCI host controllers
    
    This patch (as1192) rearranges the USB PCI host controller suspend and
    resume and resume routines:
    
            Use pci_wake_from_d3() for enabling and disabling wakeup,
            instead of pci_enable_wake().
    
            Carry out the actual state change while interrupts are
            disabled.
    
            Change the order of the preparations to agree with the
            general recommendation for PCI devices, instead of
            messing around with the wakeup settings while the device
            is in D3.
    
                    In .suspend:
                            Call the underlying driver to disable IRQ
                                    generation;
                            pci_wake_from_d3(device_may_wakeup());
                            pci_disable_device();
    
                    In .suspend_late:
                            pci_save_state();
                            pci_set_power_state(D3hot);
                            (for PPC_PMAC) Disable ASIC clocks
    
                    In .resume_early:
                            (for PPC_PMAC) Enable ASIC clocks
                            pci_set_power_state(D0);
                            pci_restore_state();
    
                    In .resume:
                            pci_enable_device();
                            pci_set_master();
                            pci_wake_from_d3(0);
                            Call the underlying driver to reenable IRQ
                                    generation
    
            Add the necessary .suspend_late and .resume_early method
            pointers to the PCI host controller drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a9c2ae36c7ad..8380cc2e961a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -487,6 +487,8 @@ static struct pci_driver ohci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
+	.suspend_late =	usb_hcd_pci_suspend_late,
+	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 

commit b5fb454f69642f9d933b327b185a2ba06dd0945c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 20 17:22:05 2008 -0400

    USB: automatically enable RHSC interrupts
    
    This patch (as1069c) changes the way OHCI root-hub status-change
    interrupts are enabled.  Currently a special HCD method,
    hub_irq_enable(), is called when the hub driver is finished using a
    root hub.  This approach turns out to be subject to races, resulting
    in unnecessary polling.
    
    The patch does away with the method entirely.  Instead, the driver
    automatically enables the RHSC interrupt when no more status changes
    are present.  This scheme is safe with controllers using
    level-triggered semantics for their interrupt flags.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 083e8df0a817..a9c2ae36c7ad 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -459,7 +459,6 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,

commit ab1666c1364a209e6141d7c14e47a42b5f00eca2
Author: Libin Yang <Libin.Yang@amd.com>
Date:   Fri Aug 8 15:03:31 2008 +0800

    USB: quirk PLL power down mode
    
    On some AMD 700 series southbridges, ISO OUT transfers (such as audio
    playback through speakers) on the USB OHCI controller may be corrupted
    when an A-Link express power saving feature is active.
    
    PLL power down mode in conjunction with link power management feature
    L1 being enabled is the bad combination ... this patch prevents them
    from being enabled when ISO transfers are pending.
    
    Signed-off-by: Crane Cai <crane.cai@amd.com>
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 4696cc912e16..083e8df0a817 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -18,6 +18,28 @@
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
 
+#include <linux/pci.h>
+#include <linux/io.h>
+
+
+/* constants used to work around PM-related transfer
+ * glitches in some AMD 700 series southbridges
+ */
+#define AB_REG_BAR	0xf0
+#define AB_INDX(addr)	((addr) + 0x00)
+#define AB_DATA(addr)	((addr) + 0x04)
+#define AX_INDXC	0X30
+#define AX_DATAC	0x34
+
+#define NB_PCIE_INDX_ADDR	0xe0
+#define NB_PCIE_INDX_DATA	0xe4
+#define PCIE_P_CNTL		0x10040
+#define BIF_NB			0x10002
+
+static struct pci_dev *amd_smbus_dev;
+static struct pci_dev *amd_hb_dev;
+static int amd_ohci_iso_count;
+
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -143,6 +165,103 @@ static int ohci_quirk_nec(struct usb_hcd *hcd)
 	return 0;
 }
 
+static int ohci_quirk_amd700(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	u8 rev = 0;
+
+	if (!amd_smbus_dev)
+		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+				PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	if (!amd_smbus_dev)
+		return 0;
+
+	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+	if ((rev > 0x3b) || (rev < 0x30)) {
+		pci_dev_put(amd_smbus_dev);
+		amd_smbus_dev = NULL;
+		return 0;
+	}
+
+	amd_ohci_iso_count++;
+
+	if (!amd_hb_dev)
+		amd_hb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9600, NULL);
+
+	ohci->flags |= OHCI_QUIRK_AMD_ISO;
+	ohci_dbg(ohci, "enabled AMD ISO transfers quirk\n");
+
+	return 0;
+}
+
+/*
+ * The hardware normally enables the A-link power management feature, which
+ * lets the system lower the power consumption in idle states.
+ *
+ * Assume the system is configured to have USB 1.1 ISO transfers going
+ * to or from a USB device.  Without this quirk, that stream may stutter
+ * or have breaks occasionally.  For transfers going to speakers, this
+ * makes a very audible mess...
+ *
+ * That audio playback corruption is due to the audio stream getting
+ * interrupted occasionally when the link goes in lower power state
+ * This USB quirk prevents the link going into that lower power state
+ * during audio playback or other ISO operations.
+ */
+static void quirk_amd_pll(int on)
+{
+	u32 addr;
+	u32 val;
+	u32 bit = (on > 0) ? 1 : 0;
+
+	pci_read_config_dword(amd_smbus_dev, AB_REG_BAR, &addr);
+
+	/* BIT names/meanings are NDA-protected, sorry ... */
+
+	outl(AX_INDXC, AB_INDX(addr));
+	outl(0x40, AB_DATA(addr));
+	outl(AX_DATAC, AB_INDX(addr));
+	val = inl(AB_DATA(addr));
+	val &= ~((1 << 3) | (1 << 4) | (1 << 9));
+	val |= (bit << 3) | ((!bit) << 4) | ((!bit) << 9);
+	outl(val, AB_DATA(addr));
+
+	if (amd_hb_dev) {
+		addr = PCIE_P_CNTL;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));
+		val |= bit | (bit << 3) | (bit << 12);
+		val |= ((!bit) << 4) | ((!bit) << 9);
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+
+		addr = BIF_NB;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 << 8);
+		val |= bit << 8;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+	}
+}
+
+static void amd_iso_dev_put(void)
+{
+	amd_ohci_iso_count--;
+	if (amd_ohci_iso_count == 0) {
+		if (amd_smbus_dev) {
+			pci_dev_put(amd_smbus_dev);
+			amd_smbus_dev = NULL;
+		}
+		if (amd_hb_dev) {
+			pci_dev_put(amd_hb_dev);
+			amd_hb_dev = NULL;
+		}
+	}
+
+}
+
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{
@@ -181,6 +300,19 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_ITE, 0x8152),
 		.driver_data = (unsigned long) broken_suspend,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4397),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4398),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
 	 */

commit 09ca8adbe9f724a7e96f512c0039c4c4a1c5dcc0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 6 10:27:25 2008 -0700

    Revert "USB: don't explicitly reenable root-hub status interrupts"
    
    This reverts commit e872154921a6b5256a3c412dd69158ac0b135176.
    
    Andrey Borzenkov reports that it resulted in a totally hung machine for
    him when loading the OHCI driver.  Extensive netconsole capture with
    SysRq output shows that modprobe gets stuck in ohci_hub_status_data()
    when probing and enabling the OHCI controller, see for example
    
            http://lkml.org/lkml/2008/7/5/236
    
    for an analysis.
    
    The problem appears to be an interrupt flood triggered by the commit
    that gets reverted, and Andrey confirmed that the revert makes things
    work for him again.
    
    Reported-and-tested-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brownell <david-b@pacbell.net>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 3bf175d95a23..4696cc912e16 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -327,6 +327,7 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
+	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,

commit e872154921a6b5256a3c412dd69158ac0b135176
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 14 12:17:56 2008 -0400

    USB: don't explicitly reenable root-hub status interrupts
    
    This patch (as1069b) changes the way OHCI root-hub status-change
    interrupts are enabled.  Currently a special HCD method,
    hub_irq_enable(), is called when the hub driver is finished using a
    root hub.  This approach turns out to be subject to races, resulting
    in unnecessary polling.
    
    The patch does away with the method entirely.  Instead, the driver
    automatically enables the RHSC interrupt when no more status changes
    are present.  This scheme is safe with controllers using
    level-triggered semantics for their interrupt flags.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 4696cc912e16..3bf175d95a23 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -327,7 +327,6 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,

commit 43bbb7e015c4380064796c5868b536437b165615
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 3 18:03:17 2008 -0400

    USB: OHCI: host-controller resumes leave root hub suspended
    
    Drivers in the ohci-hcd family should perform certain tasks whenever
    their controller device is resumed.  These include checking for loss
    of power during suspend, turning on port power, and enabling interrupt
    requests.
    
    Until now these jobs have been carried out when the root hub is
    resumed, not when the controller is.  Many drivers work around the
    resulting awkwardness by automatically resuming their root hub
    whenever the controller is resumed.  But this is wasteful and
    unnecessary.
    
    To simplify the situation, this patch (as1066) adds a new core
    routine, ohci_finish_controller_resume(), which can be used by all the
    OHCI-variant drivers.  They can call the new routine instead of
    resuming their root hubs.  And ohci-pci.c can call it instead of using
    its own special-purpose handler.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 40b62a35fd3c..4696cc912e16 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -238,42 +238,6 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
-#if	defined(CONFIG_USB_PERSIST) && (defined(CONFIG_USB_EHCI_HCD) || \
-		defined(CONFIG_USB_EHCI_HCD_MODULE))
-
-/* Following a power loss, we must prepare to regain control of the ports
- * we used to own.  This means turning on the port power before ehci-hcd
- * tries to switch ownership.
- *
- * This isn't a 100% perfect solution.  On most systems the OHCI controllers
- * lie at lower PCI addresses than the EHCI controller, so they will be
- * discovered (and hence resumed) first.  But there is no guarantee things
- * will always work this way.  If the EHCI controller is resumed first and
- * the OHCI ports are unpowered, then the handover will fail.
- */
-static void prepare_for_handover(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		port;
-
-	/* Here we "know" root ports should always stay powered */
-	ohci_dbg(ohci, "powerup ports\n");
-	for (port = 0; port < ohci->num_ports; port++)
-		ohci_writel(ohci, RH_PS_PPS,
-				&ohci->regs->roothub.portstatus[port]);
-
-	/* Flush those writes */
-	ohci_readl(ohci, &ohci->regs->control);
-	msleep(20);
-}
-
-#else
-
-static inline void prepare_for_handover(struct usb_hcd *hcd)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST etc. */
-
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -312,13 +276,8 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* FIXME: we should try to detect loss of VBUS power here */
-	prepare_for_handover(hcd);
-	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 

commit 7be7d7418776a41badce7ca00246e270d408e4b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 3 18:03:06 2008 -0400

    USB: clarify usage of hcd->suspend/resume methods
    
    The .suspend and .resume method pointers in struct usb_hcd have not
    been fully understood by host-controller driver writers.  They are
    meant for use with PCI controllers; other platform-specific drivers
    generally should not refer to them.
    
    To try and clarify matters, this patch (as1065) renames those methods
    to .pci_suspend and .pci_resume.  It eliminates corresponding dead code
    and bogus references in the ohci-ssb and u132-hcd drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b0e2275755c8..40b62a35fd3c 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -347,9 +347,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
-	/* these suspend/resume entries are for upstream PCI glue ONLY */
-	.suspend =		ohci_pci_suspend,
-	.resume =		ohci_pci_resume,
+	.pci_suspend =		ohci_pci_suspend,
+	.pci_resume =		ohci_pci_resume,
 #endif
 
 	/*

commit 0d22f65515307c878ddd20b1305cce925ca9516c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 3 11:35:26 2008 -0400

    USB: OHCI: fix bug in controller resume
    
    This patch (as1063) fixes a bug in the way ohci-hcd resumes its
    controllers.  It leaves the Master Interrupt Enable bit turned off.
    
    If the root hub is resumed immediately this won't matter.  But if the
    root hub is suspended (say because no devices are plugged in), it won't
    ever wake up by itself.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d0360f65ebd9..b0e2275755c8 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -312,11 +312,13 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
 	/* FIXME: we should try to detect loss of VBUS power here */
 	prepare_for_handover(hcd);
-
+	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);
 	return 0;
 }
 

commit 89a0fd18a96eb1f8732714b575073f8a8d69c009
Author: Mike Nuss <mike@terascala.com>
Date:   Wed Aug 1 13:24:30 2007 -0700

    USB: OHCI handles more ZFMicro quirks
    
    The ZF Micro OHCI controller exhibits unexpected behavior that seems to be
    related to high load.  Under certain conditions, the controller will
    complete a TD, remove it from the endpoint's queue, and fail to add it to
    the donelist. This causes the endpoint to appear to stop responding. Worse,
    if the device is removed while in that state, OHCI will hang while waiting
    for the orphaned TD to complete.  The situation is not recoverable without
    rebooting.
    
    This fix enhances the scope of the existing OHCI_QUIRK_ZFMICRO flag:
    
     1. A watchdog routine periodically scans the OHCI structures to check
        for orphaned TDs. In these cases the TD is taken back from the
        controller and completed normally.
    
     2. If a device is removed while the endpoint is hung but before the
        watchdog catches the situation, any outstanding TDs are taken back
        from the controller in the 'sanitize' phase.
    
    The ohci-hcd driver used to print "INTR_SF lossage" in this situation;
    this changes it to the universally accurate "ED unlink timeout".  Other
    instances of this message presumably have different root causes.
    
    Both this Compaq quirk and a NEC quirk are now properly compiled out for
    non-PCI builds of this driver.
    
    Signed-off-by: Mike Nuss <mike@terascala.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a5e2eb85d073..d0360f65ebd9 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -84,7 +84,7 @@ static int ohci_quirk_zfmicro(struct usb_hcd *hcd)
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
 	ohci->flags |= OHCI_QUIRK_ZFMICRO;
-	ohci_dbg (ohci, "enabled Compaq ZFMicro chipset quirk\n");
+	ohci_dbg(ohci, "enabled Compaq ZFMicro chipset quirks\n");
 
 	return 0;
 }
@@ -113,11 +113,31 @@ static int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
 
 /* Check for NEC chip and apply quirk for allegedly lost interrupts.
  */
+
+static void ohci_quirk_nec_worker(struct work_struct *work)
+{
+	struct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);
+	int status;
+
+	status = ohci_init(ohci);
+	if (status != 0) {
+		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",
+			 "ohci_init", status);
+		return;
+	}
+
+	status = ohci_restart(ohci);
+	if (status != 0)
+		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",
+			 "ohci_restart", status);
+}
+
 static int ohci_quirk_nec(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
 	ohci->flags |= OHCI_QUIRK_NEC;
+	INIT_WORK(&ohci->nec_work, ohci_quirk_nec_worker);
 	ohci_dbg (ohci, "enabled NEC chipset lost interrupt quirk\n");
 
 	return 0;

commit d576bb9f2769b315a795f77f0c33322a976add7a
Author: Michael Hanselmann <linux-kernel@hansmi.ch>
Date:   Thu May 31 23:34:27 2007 +0200

    USB: Fix NEC OHCI chip silicon bug
    
    This patch fixes a silicon bug in some NEC OHCI chips. The bug appears
    at random times and is very, very difficult to reproduce. Without the
    following patch, Linux would shut the chip and its associated devices
    down. In Apple PowerBooks this leads to an unusable keyboard and mouse
    (SSH still working). The idea of restarting the chip is taken from
    public Darwin code.
    
    Signed-off-by: Michael Hanselmann <linux-kernel@hansmi.ch>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 15013f4519ad..a5e2eb85d073 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -111,6 +111,18 @@ static int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
 #endif
 }
 
+/* Check for NEC chip and apply quirk for allegedly lost interrupts.
+ */
+static int ohci_quirk_nec(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+
+	ohci->flags |= OHCI_QUIRK_NEC;
+	ohci_dbg (ohci, "enabled NEC chipset lost interrupt quirk\n");
+
+	return 0;
+}
+
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{
@@ -133,6 +145,10 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, 0x01b6),
 		.driver_data = (unsigned long)ohci_quirk_toshiba_scc,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB),
+		.driver_data = (unsigned long)ohci_quirk_nec,
+	},
 	{
 		/* Toshiba portege 4000 */
 		.vendor		= PCI_VENDOR_ID_AL,

commit 383975d765523a56dc43a6cd6d52e9b376800cf2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:40 2007 -0400

    USB: EHCI, OHCI: handover changes
    
    This patch (as887) changes the way ehci-hcd and ohci-hcd handle a loss
    of VBUS power during suspend.  In order for the USB-persist facility
    to work correctly, it is necessary for low- and full-speed devices
    attached to a high-speed port to be handed back to the companion
    controller during resume processing.
    
    This entails three changes: adding code to ehci-hcd to perform the
    handover, removing code from ohci-hcd to turn off ports during
    root-hub reinit, and adding code to ohci-hcd to turn on ports during
    PCI controller resume.  (Other bus glue resume methods for platforms
    supporting high-speed controllers would need a similar change, if any
    existed.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ca62cb583221..15013f4519ad 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -202,6 +202,42 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
+#if	defined(CONFIG_USB_PERSIST) && (defined(CONFIG_USB_EHCI_HCD) || \
+		defined(CONFIG_USB_EHCI_HCD_MODULE))
+
+/* Following a power loss, we must prepare to regain control of the ports
+ * we used to own.  This means turning on the port power before ehci-hcd
+ * tries to switch ownership.
+ *
+ * This isn't a 100% perfect solution.  On most systems the OHCI controllers
+ * lie at lower PCI addresses than the EHCI controller, so they will be
+ * discovered (and hence resumed) first.  But there is no guarantee things
+ * will always work this way.  If the EHCI controller is resumed first and
+ * the OHCI ports are unpowered, then the handover will fail.
+ */
+static void prepare_for_handover(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int		port;
+
+	/* Here we "know" root ports should always stay powered */
+	ohci_dbg(ohci, "powerup ports\n");
+	for (port = 0; port < ohci->num_ports; port++)
+		ohci_writel(ohci, RH_PS_PPS,
+				&ohci->regs->roothub.portstatus[port]);
+
+	/* Flush those writes */
+	ohci_readl(ohci, &ohci->regs->control);
+	msleep(20);
+}
+
+#else
+
+static inline void prepare_for_handover(struct usb_hcd *hcd)
+{ }
+
+#endif	/* CONFIG_USB_PERSIST etc. */
+
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -241,7 +277,10 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-	usb_hcd_resume_root_hub(hcd);
+
+	/* FIXME: we should try to detect loss of VBUS power here */
+	prepare_for_handover(hcd);
+
 	return 0;
 }
 

commit 8ab5e8c0ca55c4b40d254f7043a9052345fcd343
Author: Andrey Borzenkov <arvidjaar@mail.ru>
Date:   Sat May 19 14:23:28 2007 -0700

    USB: Fix USB OHCI Subvendor for Toshiba Portege 4000
    
    This fixes a bug in an OHCI quirk handler for Portege 4000; the
    Subvendor is 0x1179 (PCI_VENDOR_ID_TOSHIBA)
    not 0x102f (PCI_VENDOR_ID_TOSHIBA_2)
    
    bugid 8510
    
    00:02.0 USB Controller [0c03]: ALi Corporation USB 1.1 Controller
    [10b9:5237] (rev 03) (prog-if 10 [OHCI])
            Subsystem: Toshiba America Info Systems Unknown device [1179:0004]
            Flags: bus master, medium devsel, latency 64, IRQ 11
            Memory at f7eff000 (32-bit, non-prefetchable) [size=4K]
            Capabilities: <access denied>
    
    Signed-off-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 79705609fd0c..ca62cb583221 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -137,7 +137,7 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		/* Toshiba portege 4000 */
 		.vendor		= PCI_VENDOR_ID_AL,
 		.device		= 0x5237,
-		.subvendor	= PCI_VENDOR_ID_TOSHIBA_2,
+		.subvendor	= PCI_VENDOR_ID_TOSHIBA,
 		.subdevice	= 0x0004,
 		.driver_data	= (unsigned long) broken_suspend,
 	},

commit 33f73e56198457c38789e08c47d2af47174c1d8f
Author: Raphael Assenat <raph@8d.com>
Date:   Tue Apr 17 13:09:18 2007 -0700

    USB: quirk for broken suspend of IT8152F/G
    
    Here's a patch which adds my device to the list.
    
    This patch enables the broken suspend quirk for the PCI OHCI controller
    present in the IT8152F/G RISC-to-PCI Companion Chip.
    
    Signed-off-by: Raphael Assenat <raph@8d.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 321f35150b81..79705609fd0c 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -141,6 +141,10 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		.subdevice	= 0x0004,
 		.driver_data	= (unsigned long) broken_suspend,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ITE, 0x8152),
+		.driver_data = (unsigned long) broken_suspend,
+	},
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
 	 */

commit 931384fb0ec99a7459b3052f5d4db15bcb5037ea
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Apr 17 13:06:29 2007 -0700

    USB: add an ohci board-specific quirk
    
    Use the new ohci-pci quirk infrastructure to address the problem it was
    created to address: a quirk specific to the Portege 4000, in buzilla as
    
            http://bugzilla.kernel.org/show_bug.cgi?id=6723
    
    Also fix a misuse of "__devinit" for the quirk functions.  It must not
    be used without first ensuring that the references from the quirk tables
    are gone, and that the function using those quirk tables is also gone.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b331ac4d0d62..321f35150b81 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -20,10 +20,16 @@
 
 /*-------------------------------------------------------------------------*/
 
+static int broken_suspend(struct usb_hcd *hcd)
+{
+	device_init_wakeup(&hcd->self.root_hub->dev, 0);
+	return 0;
+}
+
 /* AMD 756, for most chips (early revs), corrupts register
  * values on read ... so enable the vendor workaround.
  */
-static int __devinit ohci_quirk_amd756(struct usb_hcd *hcd)
+static int ohci_quirk_amd756(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
@@ -31,16 +37,14 @@ static int __devinit ohci_quirk_amd756(struct usb_hcd *hcd)
 	ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
 
 	/* also erratum 10 (suspend/resume issues) */
-	device_init_wakeup(&hcd->self.root_hub->dev, 0);
-
-	return 0;
+	return broken_suspend(hcd);
 }
 
 /* Apple's OHCI driver has a lot of bizarre workarounds
  * for this chip.  Evidently control and bulk lists
  * can get confused.  (B&W G3 models, and ...)
  */
-static int __devinit ohci_quirk_opti(struct usb_hcd *hcd)
+static int ohci_quirk_opti(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
@@ -53,7 +57,7 @@ static int __devinit ohci_quirk_opti(struct usb_hcd *hcd)
  * identify the USB (fn2). This quirk might apply to more or
  * even all NSC stuff.
  */
-static int __devinit ohci_quirk_ns(struct usb_hcd *hcd)
+static int ohci_quirk_ns(struct usb_hcd *hcd)
 {
 	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 	struct pci_dev	*b;
@@ -75,7 +79,7 @@ static int __devinit ohci_quirk_ns(struct usb_hcd *hcd)
  * delays before control or bulk queues get re-activated
  * in finish_unlinks()
  */
-static int __devinit ohci_quirk_zfmicro(struct usb_hcd *hcd)
+static int ohci_quirk_zfmicro(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
@@ -88,7 +92,7 @@ static int __devinit ohci_quirk_zfmicro(struct usb_hcd *hcd)
 /* Check for Toshiba SCC OHCI which has big endian registers
  * and little endian in memory data structures
  */
-static int __devinit ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
+static int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
@@ -129,6 +133,14 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, 0x01b6),
 		.driver_data = (unsigned long)ohci_quirk_toshiba_scc,
 	},
+	{
+		/* Toshiba portege 4000 */
+		.vendor		= PCI_VENDOR_ID_AL,
+		.device		= 0x5237,
+		.subvendor	= PCI_VENDOR_ID_TOSHIBA_2,
+		.subdevice	= 0x0004,
+		.driver_data	= (unsigned long) broken_suspend,
+	},
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
 	 */

commit 5e16fabe5dbcff15de6cdcba406195fe6e4380df
Author: Sylvain Munaut <tnt@246tNt.com>
Date:   Wed Dec 13 21:09:54 2006 +0100

    ohci: Rework bus glue integration to allow several at once
    
    The previous model had the module_init & module_exit function in the
    bus glue .c files themselves. That's a problem if several glues need
    to be selected at once and the driver is built has module. This case
    is quite common in embedded system where you want to handle both the
    integrated ohci controller and some extra controller on PCI.
    
    The ohci-hcd.c file now provide the module_init & module_exit and
    appropriate driver registering/unregistering is done conditionally,
    using #ifdefs.
    
    Signed-off-by: Sylvain Munaut <tnt@246tNt.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 292daf044b62..b331ac4d0d62 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -311,23 +311,3 @@ static struct pci_driver ohci_pci_driver = {
 	.shutdown =	usb_hcd_pci_shutdown,
 };
 
-
-static int __init ohci_hcd_pci_init (void)
-{
-	printk (KERN_DEBUG "%s: " DRIVER_INFO " (PCI)\n", hcd_name);
-	if (usb_disabled())
-		return -ENODEV;
-
-	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
-		sizeof (struct ed), sizeof (struct td));
-	return pci_register_driver (&ohci_pci_driver);
-}
-module_init (ohci_hcd_pci_init);
-
-/*-------------------------------------------------------------------------*/
-
-static void __exit ohci_hcd_pci_cleanup (void)
-{
-	pci_unregister_driver (&ohci_pci_driver);
-}
-module_exit (ohci_hcd_pci_cleanup);

commit 11d1a4aa8d657478cb2e5d33f203ba8f01b9ac24
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Dec 15 06:54:03 2006 +1100

    USB: Implement support for "split" endian OHCI
    
    This patch separates support for big endian MMIO register access
    and big endian descriptors in order to support the Toshiba SCC
    implementation which has big endian registers but little endian
    in-memory descriptors.
    
    It simplifies the access functions a bit in ohci.h while at it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 82fbec305a66..292daf044b62 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -85,6 +85,27 @@ static int __devinit ohci_quirk_zfmicro(struct usb_hcd *hcd)
 	return 0;
 }
 
+/* Check for Toshiba SCC OHCI which has big endian registers
+ * and little endian in memory data structures
+ */
+static int __devinit ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+
+	/* That chip is only present in the southbridge of some
+	 * cell based platforms which are supposed to select
+	 * CONFIG_USB_OHCI_BIG_ENDIAN_MMIO. We verify here if
+	 * that was the case though.
+	 */
+#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
+	ohci->flags |= OHCI_QUIRK_BE_MMIO;
+	ohci_dbg (ohci, "enabled big endian Toshiba quirk\n");
+	return 0;
+#else
+	ohci_err (ohci, "unsupported big endian Toshiba quirk\n");
+	return -ENXIO;
+#endif
+}
 
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
@@ -104,9 +125,14 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xa0f8),
 		.driver_data = (unsigned long)ohci_quirk_zfmicro,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, 0x01b6),
+		.driver_data = (unsigned long)ohci_quirk_toshiba_scc,
+	},
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
 	 */
+
 	{},
 };
 

commit 4302a595cd9c6363b495460497ecbda49fa16858
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Dec 15 06:53:55 2006 +1100

    USB: Rework the OHCI quirk mecanism as suggested by David
    
    This patch applies David Brownell's suggestion for reworking the
    OHCI quirk mechanism via a table of PCI IDs. It adapts the existing
    quirks to use that mechanism.
    
    This also moves the quirks to reset() as suggested by the comment
    in there. This is necessary as we need to have the endian properly
    set before we try to init the controller.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 596e0b41e606..82fbec305a66 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -20,79 +20,128 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int
-ohci_pci_reset (struct usb_hcd *hcd)
+/* AMD 756, for most chips (early revs), corrupts register
+ * values on read ... so enable the vendor workaround.
+ */
+static int __devinit ohci_quirk_amd756(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
-	ohci_hcd_init (ohci);
-	return ohci_init (ohci);
+	ohci->flags = OHCI_QUIRK_AMD756;
+	ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
+
+	/* also erratum 10 (suspend/resume issues) */
+	device_init_wakeup(&hcd->self.root_hub->dev, 0);
+
+	return 0;
 }
 
-static int __devinit
-ohci_pci_start (struct usb_hcd *hcd)
+/* Apple's OHCI driver has a lot of bizarre workarounds
+ * for this chip.  Evidently control and bulk lists
+ * can get confused.  (B&W G3 models, and ...)
+ */
+static int __devinit ohci_quirk_opti(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
 
-	/* REVISIT this whole block should move to reset(), which handles
-	 * all the other one-time init.
+	ohci_dbg (ohci, "WARNING: OPTi workarounds unavailable\n");
+
+	return 0;
+}
+
+/* Check for NSC87560. We have to look at the bridge (fn1) to
+ * identify the USB (fn2). This quirk might apply to more or
+ * even all NSC stuff.
+ */
+static int __devinit ohci_quirk_ns(struct usb_hcd *hcd)
+{
+	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
+	struct pci_dev	*b;
+
+	b  = pci_get_slot (pdev->bus, PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
+	if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
+	    && b->vendor == PCI_VENDOR_ID_NS) {
+		struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+
+		ohci->flags |= OHCI_QUIRK_SUPERIO;
+		ohci_dbg (ohci, "Using NSC SuperIO setup\n");
+	}
+	pci_dev_put(b);
+
+	return 0;
+}
+
+/* Check for Compaq's ZFMicro chipset, which needs short
+ * delays before control or bulk queues get re-activated
+ * in finish_unlinks()
+ */
+static int __devinit ohci_quirk_zfmicro(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+
+	ohci->flags |= OHCI_QUIRK_ZFMICRO;
+	ohci_dbg (ohci, "enabled Compaq ZFMicro chipset quirk\n");
+
+	return 0;
+}
+
+
+/* List of quirks for OHCI */
+static const struct pci_device_id ohci_pci_quirks[] = {
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_AMD, 0x740c),
+		.driver_data = (unsigned long)ohci_quirk_amd756,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_OPTI, 0xc861),
+		.driver_data = (unsigned long)ohci_quirk_opti,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_ANY_ID),
+		.driver_data = (unsigned long)ohci_quirk_ns,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xa0f8),
+		.driver_data = (unsigned long)ohci_quirk_zfmicro,
+	},
+	/* FIXME for some of the early AMD 760 southbridges, OHCI
+	 * won't work at all.  blacklist them.
 	 */
+	{},
+};
+
+static int ohci_pci_reset (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int ret = 0;
+
 	if (hcd->self.controller) {
 		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
+		const struct pci_device_id *quirk_id;
 
-		/* AMD 756, for most chips (early revs), corrupts register
-		 * values on read ... so enable the vendor workaround.
-		 */
-		if (pdev->vendor == PCI_VENDOR_ID_AMD
-				&& pdev->device == 0x740c) {
-			ohci->flags = OHCI_QUIRK_AMD756;
-			ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
-			/* also erratum 10 (suspend/resume issues) */
-			device_init_wakeup(&hcd->self.root_hub->dev, 0);
+		quirk_id = pci_match_id(ohci_pci_quirks, pdev);
+		if (quirk_id != NULL) {
+			int (*quirk)(struct usb_hcd *ohci);
+			quirk = (void *)quirk_id->driver_data;
+			ret = quirk(hcd);
 		}
+	}
+	if (ret == 0) {
+		ohci_hcd_init (ohci);
+		return ohci_init (ohci);
+	}
+	return ret;
+}
 
-		/* FIXME for some of the early AMD 760 southbridges, OHCI
-		 * won't work at all.  blacklist them.
-		 */
-
-		/* Apple's OHCI driver has a lot of bizarre workarounds
-		 * for this chip.  Evidently control and bulk lists
-		 * can get confused.  (B&W G3 models, and ...)
-		 */
-		else if (pdev->vendor == PCI_VENDOR_ID_OPTI
-				&& pdev->device == 0xc861) {
-			ohci_dbg (ohci,
-				"WARNING: OPTi workarounds unavailable\n");
-		}
 
-		/* Check for NSC87560. We have to look at the bridge (fn1) to
-		 * identify the USB (fn2). This quirk might apply to more or
-		 * even all NSC stuff.
-		 */
-		else if (pdev->vendor == PCI_VENDOR_ID_NS) {
-			struct pci_dev	*b;
-
-			b  = pci_get_slot (pdev->bus,
-					PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
-			if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
-					&& b->vendor == PCI_VENDOR_ID_NS) {
-				ohci->flags |= OHCI_QUIRK_SUPERIO;
-				ohci_dbg (ohci, "Using NSC SuperIO setup\n");
-			}
-			pci_dev_put(b);
-		}
+static int __devinit ohci_pci_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
 
-		/* Check for Compaq's ZFMicro chipset, which needs short
-		 * delays before control or bulk queues get re-activated
-		 * in finish_unlinks()
-		 */
-		else if (pdev->vendor == PCI_VENDOR_ID_COMPAQ
-				&& pdev->device  == 0xa0f8) {
-			ohci->flags |= OHCI_QUIRK_ZFMICRO;
-			ohci_dbg (ohci,
-				"enabled Compaq ZFMicro chipset quirk\n");
-		}
+#ifdef CONFIG_PM /* avoid warnings about unused pdev */
+	if (hcd->self.controller) {
+		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 
 		/* RWC may not be set for add-in PCI cards, since boot
 		 * firmware probably ignored them.  This transfers PCI
@@ -101,16 +150,14 @@ ohci_pci_start (struct usb_hcd *hcd)
 		if (device_may_wakeup(&pdev->dev))
 			ohci->hc_control |= OHCI_CTRL_RWC;
 	}
+#endif /* CONFIG_PM */
 
-	/* NOTE: there may have already been a first reset, to
-	 * keep bios/smm irqs from making trouble
-	 */
-	if ((ret = ohci_run (ohci)) < 0) {
+	ret = ohci_run (ohci);
+	if (ret < 0) {
 		ohci_err (ohci, "can't start\n");
 		ohci_stop (hcd);
-		return ret;
 	}
-	return 0;
+	return ret;
 }
 
 #ifdef	CONFIG_PM

commit dd9048af41d017f5f9ea18fb451a3b5dc89d6b83
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Dec 5 03:18:31 2006 -0800

    USB: ohci whitespace/comment fixups
    
    This is an OHCI cleanup patch ... it removes a lot of erroneous whitespace
    (space before tab, at end of line) as well as the obsolete inline changelog.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 874418552789..596e0b41e606 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -3,17 +3,17 @@
  *
  * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
  * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * 
+ *
  * [ Initialisation is based on Linus'  ]
  * [ uhci code and gregs ohci fragments ]
  * [ (C) Copyright 1999 Linus Torvalds  ]
  * [ (C) Copyright 1999 Gregory P. Smith]
- * 
+ *
  * PCI Bus Glue
  *
  * This file is licenced under the GPL.
  */
- 
+
 #ifndef CONFIG_PCI
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
@@ -83,7 +83,7 @@ ohci_pci_start (struct usb_hcd *hcd)
 			pci_dev_put(b);
 		}
 
-		/* Check for Compaq's ZFMicro chipset, which needs short 
+		/* Check for Compaq's ZFMicro chipset, which needs short
 		 * delays before control or bulk queues get re-activated
 		 * in finish_unlinks()
 		 */
@@ -238,8 +238,8 @@ static struct pci_driver ohci_pci_driver = {
 	.shutdown =	usb_hcd_pci_shutdown,
 };
 
- 
-static int __init ohci_hcd_pci_init (void) 
+
+static int __init ohci_hcd_pci_init (void)
 {
 	printk (KERN_DEBUG "%s: " DRIVER_INFO " (PCI)\n", hcd_name);
 	if (usb_disabled())
@@ -253,8 +253,8 @@ module_init (ohci_hcd_pci_init);
 
 /*-------------------------------------------------------------------------*/
 
-static void __exit ohci_hcd_pci_cleanup (void) 
-{	
+static void __exit ohci_hcd_pci_cleanup (void)
+{
 	pci_unregister_driver (&ohci_pci_driver);
 }
 module_exit (ohci_hcd_pci_cleanup);

commit 2e3a43f0b6f16705ec76d3744b82a116965ebebe
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Sep 27 15:43:22 2006 -0700

    ohci: Use ref-counting hotplug safe interfaces
    
    We want to avoid legacy APIs like pci_find_slot().
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 3732db7d68eb..874418552789 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -73,13 +73,14 @@ ohci_pci_start (struct usb_hcd *hcd)
 		else if (pdev->vendor == PCI_VENDOR_ID_NS) {
 			struct pci_dev	*b;
 
-			b  = pci_find_slot (pdev->bus->number,
+			b  = pci_get_slot (pdev->bus,
 					PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
 			if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
 					&& b->vendor == PCI_VENDOR_ID_NS) {
 				ohci->flags |= OHCI_QUIRK_SUPERIO;
 				ohci_dbg (ohci, "Using NSC SuperIO setup\n");
 			}
+			pci_dev_put(b);
 		}
 
 		/* Check for Compaq's ZFMicro chipset, which needs short 

commit 64a21d025d3a979a8715f2ec7acabca7b5406c8a
Author: Aleksey Gorelov <dared1st@yahoo.com>
Date:   Tue Aug 8 17:24:08 2006 -0700

    USB: Properly unregister reboot notifier in case of failure in ehci hcd
    
    If some problem occurs during ehci startup, for instance, request_irq fails,
    echi hcd driver tries it best to cleanup, but fails to unregister reboot
    notifier, which in turn leads to crash on reboot/poweroff.
    
    The following patch resolves this problem by not using reboot notifiers
    anymore, but instead making ehci/ohci driver get its own shutdown method.  For
    PCI, it is done through pci glue, for everything else through platform driver
    glue.
    
    One downside: sa1111 does not use platform driver stuff, and does not have its
    own shutdown hook, so no 'shutdown' is called for it now.  I'm not sure if it
    is really necessary on that platform, though.
    
    Signed-off-by: Aleks Gorelov <dared1st@yahoo.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ef874443aa9f..3732db7d68eb 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -177,6 +177,7 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.reset =		ohci_pci_reset,
 	.start =		ohci_pci_start,
 	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
 	/* these suspend/resume entries are for upstream PCI glue ONLY */
@@ -232,6 +233,8 @@ static struct pci_driver ohci_pci_driver = {
 	.suspend =	usb_hcd_pci_suspend,
 	.resume =	usb_hcd_pci_resume,
 #endif
+
+	.shutdown =	usb_hcd_pci_shutdown,
 };
 
  

commit d413984ae936fad46678403b38d79c595e5aaafe
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Aug 4 11:31:55 2006 -0700

    USB: OHCI avoids root hub timer polling
    
    This teaches OHCI to use the root hub status change (RHSC) IRQ, bypassing
    root hub timers most of the time and switching over to the "new" root hub
    polling scheme.  It's complicated by the fact that implementations of OHCI
    trigger and ack that IRQ differently (the spec is vague there).
    
    Avoiding root hub timers helps mechanisms like "dynamic tick" leave the
    CPU in lowpower modes for longer intervals.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 37e122812b67..ef874443aa9f 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -176,11 +176,13 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.reset =		ohci_pci_reset,
 	.start =		ohci_pci_start,
+	.stop =			ohci_stop,
+
 #ifdef	CONFIG_PM
+	/* these suspend/resume entries are for upstream PCI glue ONLY */
 	.suspend =		ohci_pci_suspend,
 	.resume =		ohci_pci_resume,
 #endif
-	.stop =			ohci_stop,
 
 	/*
 	 * managing i/o requests and associated device resources
@@ -199,6 +201,7 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
+	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,

commit 185849991d592497e43bcd264c6152af1261ffe2
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:06 2006 -0700

    PM: USB HCDs use PM_EVENT_PRETHAW
    
    This teaches several USB host controller drivers to treat PRETHAW as a chip
    reset since the controller, and all devices connected to it, are no longer in
    states compatible with how the snapshotted suspend() left them.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b268537e389e..37e122812b67 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -135,6 +135,11 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	}
 	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
 	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
+
+	/* make sure snapshot being resumed re-enumerates everything */
+	if (message.event == PM_EVENT_PRETHAW)
+		ohci_usb_reset(ohci);
+
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  bail:
 	spin_unlock_irqrestore (&ohci->lock, flags);

commit c67808eee61a01c3128298c5972426a1a67b9093
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Apr 9 20:07:35 2006 +0200

    [PATCH] USB: Use new PCI_CLASS_SERIAL_USB_* defines
    
    We could use the recently added PCI_CLASS_SERIAL_USB_UHCI,
    PCI_CLASS_SERIAL_USB_OHCI and PCI_CLASS_SERIAL_USB_EHCI defines in
    more places, for slightly shorter and clearer code.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 1bfe96f4d045..b268537e389e 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -206,7 +206,7 @@ static const struct hc_driver ohci_pci_hc_driver = {
 
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB OHCI controller */
-	PCI_DEVICE_CLASS((PCI_CLASS_SERIAL_USB << 8) | 0x10, ~0),
+	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, { /* end: all zeroes */ }
 };

commit 6a9062f393fa48125df23c5491543828a21e1ae0
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Jan 23 15:28:07 2006 -0800

    [PATCH] USB: ohci uses driver model wakeup flags
    
    This makes OHCI use the driver model wakeup control bits for its root hub
    (e.g. disable on amd756, because of chip erratum) and for the controller
    itself.  It no longer uses the hcd glue bits with those roles, and depends
    on the previous patch making the root hub available earlier.
    
    Note that on most platforms (boot code properly setting the RWC bit) this
    gives a partial workaround for the way PCI isn't currently flagging devices
    that support PME# signals.  (Because of odd PCI init sequencing on PPC.)
    That's because many OHCI controllers support "legacy PCI PM" ... without
    involving any PCI PM capability.
    
    USB wakeup from STR, if it works on your system, may still involve
    tweaking things by hand in /proc/acpi/wakeup.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 1b09dde068e1..1bfe96f4d045 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -35,7 +35,10 @@ ohci_pci_start (struct usb_hcd *hcd)
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ret;
 
-	if(hcd->self.controller && hcd->self.controller->bus == &pci_bus_type) {
+	/* REVISIT this whole block should move to reset(), which handles
+	 * all the other one-time init.
+	 */
+	if (hcd->self.controller) {
 		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
 
 		/* AMD 756, for most chips (early revs), corrupts register
@@ -45,7 +48,8 @@ ohci_pci_start (struct usb_hcd *hcd)
 				&& pdev->device == 0x740c) {
 			ohci->flags = OHCI_QUIRK_AMD756;
 			ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
-			// also somewhat erratum 10 (suspend/resume issues)
+			/* also erratum 10 (suspend/resume issues) */
+			device_init_wakeup(&hcd->self.root_hub->dev, 0);
 		}
 
 		/* FIXME for some of the early AMD 760 southbridges, OHCI
@@ -88,6 +92,13 @@ ohci_pci_start (struct usb_hcd *hcd)
 			ohci_dbg (ohci,
 				"enabled Compaq ZFMicro chipset quirk\n");
 		}
+
+		/* RWC may not be set for add-in PCI cards, since boot
+		 * firmware probably ignored them.  This transfers PCI
+		 * PM wakeup capabilities (once the PCI layer is fixed).
+		 */
+		if (device_may_wakeup(&pdev->dev))
+			ohci->hc_control |= OHCI_CTRL_RWC;
 	}
 
 	/* NOTE: there may have already been a first reset, to

commit 8de98402652c01839ae321be6cb3054cf5735d83
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Nov 25 09:59:46 2005 +1100

    [PATCH] USB: Fix USB suspend/resume crasher (#2)
    
    This patch closes the IRQ race and makes various other OHCI & EHCI code
    path safer vs. suspend/resume.
    I've been able to (finally !) successfully suspend and resume various
    Mac models, with or without USB mouse plugged, or plugging while asleep,
    or unplugging while asleep etc... all without a crash.
    
    Alan, please verify the UHCI bit I did, I only verified that it builds.
    It's very simple so I wouldn't expect any issue there. If you aren't
    confident, then just drop the hunks that change uhci-hcd.c
    
    I also made the patch a little bit more "safer" by making sure the store
    to the interrupt register that disables interrupts is not posted before
    I set the flag and drop the spinlock.
    
    Without this patch, you cannot reliably sleep/wakeup any recent Mac, and
    I suspect PCs have some more sneaky issues too (they don't frankly crash
    with machine checks because x86 tend to silently swallow PCI errors but
    that won't last afaik, at least PCI Express will blow up in those
    situations, but the USB code may still misbehave).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 5f22e6590cd1..1b09dde068e1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -105,13 +105,36 @@ ohci_pci_start (struct usb_hcd *hcd)
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 {
-	/* root hub was already suspended */
-	return 0;
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	unsigned long	flags;
+	int		rc = 0;
+
+	/* Root hub was already suspended. Disable irq emission and
+	 * mark HW unaccessible, bail out if RH has been resumed. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
+	 *
+	 * This is still racy as hcd->state is manipulated outside of
+	 * any locks =P But that will be a different fix.
+	 */
+	spin_lock_irqsave (&ohci->lock, flags);
+	if (hcd->state != HC_STATE_SUSPENDED) {
+		rc = -EINVAL;
+		goto bail;
+	}
+	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+ bail:
+	spin_unlock_irqrestore (&ohci->lock, flags);
+
+	return rc;
 }
 
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	usb_hcd_resume_root_hub(hcd);
 	return 0;
 }

commit 21b1861fb2ba5b25b32c63bc540bbc7ca1d186f8
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:42 2005 -0800

    [PATCH] USB: ohci, move ppc asic tweaks nearer pci
    
    This should fix a suspend/resume issues that appear with OHCI on some
    PPC hardware.  The PCI layer should doesn't have the hooks needed for
    such ASIC-specific hooks (in this case, software clock gating), so
    this moves the code to do that into hcd-pci.c ... where it can be
    done after the relevant PCI PM state transition (to/from D3).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a59e536441e1..5f22e6590cd1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -14,15 +14,6 @@
  * This file is licenced under the GPL.
  */
  
-#include <linux/jiffies.h>
-
-#ifdef CONFIG_PPC_PMAC
-#include <asm/machdep.h>
-#include <asm/pmac_feature.h>
-#include <asm/pci-bridge.h>
-#include <asm/prom.h>
-#endif
-
 #ifndef CONFIG_PCI
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
@@ -115,39 +106,12 @@ ohci_pci_start (struct usb_hcd *hcd)
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 {
 	/* root hub was already suspended */
-
-	/* FIXME these PMAC things get called in the wrong places.  ASIC
-	 * clocks should be turned off AFTER entering D3, and on BEFORE
-	 * trying to enter D0.  Evidently the PCI layer doesn't currently
-	 * provide the right sort of platform hooks for this ...
-	 */
-#ifdef CONFIG_PPC_PMAC
-	if (_machine == _MACH_Pmac) {
-	   	struct device_node	*of_node;
- 
-		/* Disable USB PAD & cell clock */
-		of_node = pci_device_to_OF_node (to_pci_dev(hcd->self.controller));
-		if (of_node)
-			pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
-	}
-#endif /* CONFIG_PPC_PMAC */
 	return 0;
 }
 
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
-#ifdef CONFIG_PPC_PMAC
-	if (_machine == _MACH_Pmac) {
-		struct device_node *of_node;
-
-		/* Re-enable USB PAD & cell clock */
-		of_node = pci_device_to_OF_node (to_pci_dev(hcd->self.controller));
-		if (of_node)
-			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
-	}
-#endif /* CONFIG_PPC_PMAC */
-
 	usb_hcd_resume_root_hub(hcd);
 	return 0;
 }

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 7ce1d9ef0289..a59e536441e1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -218,7 +218,6 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-	.owner =	THIS_MODULE,
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index bf1d5ab4aa3a..7ce1d9ef0289 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -14,6 +14,8 @@
  * This file is licenced under the GPL.
  */
  
+#include <linux/jiffies.h>
+
 #ifdef CONFIG_PPC_PMAC
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>

commit efa400db5332ba341cc354c9d8a5298ff57faa98
Author: Ben Dooks <ben@fluff.org.uk>
Date:   Mon Oct 10 02:32:15 2005 +0100

    [PATCH] USB: add owner initialisation to host drivers
    
    Add .owner initialisation to the device drivers
    in drivers/usb/host so that when built as module
    the device_driver refers to the owning module
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a8dde8b75691..bf1d5ab4aa3a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -216,6 +216,7 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
+	.owner =	THIS_MODULE,
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,

commit 0c0382e32d46f606951010b202382be14d180a17
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Oct 13 17:08:02 2005 -0400

    [PATCH] USB: Rename hcd->hub_suspend to hcd->bus_suspend
    
    This patch (as580) is perhaps the only result from the long discussion I
    had with David about his changes to the root-hub suspend/resume code.  It
    renames the hub_suspend and hub_resume methods in struct usb_hcd to
    bus_suspend and bus_resume.  These are more descriptive names, since the
    methods really do suspend or resume an entire USB bus, and less likely to
    be confused with the hub_suspend and hub_resume routines in hub.c.
    
    It also takes David's advice about removing the layer of bus glue, where
    those methods are called.  And it implements a related change that David
    made to the other HCDs but forgot to put into dummy_hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 99a0ad41aec5..a8dde8b75691 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -195,8 +195,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };

commit f197b2c54b9d9a133a9a8ff92f35cadf8945ea14
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Sep 22 22:42:53 2005 -0700

    [PATCH] OHCI PM updates
    
    This simplifies the OHCI root hub suspend logic:
    
     - Uses new usbcore root hub calls to make autosuspend work again:
            * Uses a newish usbcore root hub wakeup mechanism,
              making requests to khubd not keventd.
            * Uses an even newer sibling suspend hook.
    
     - Expect someone always made usbcore call ohci_hub_suspend() before bus
       glue fires; and that ohci_hub_resume() is only called after that bus
       glue ran.  Previously, only CONFIG_USB_SUSPEND promised those things.
       (Includes updates to PCI and OMAP bus glue.)
    
     - Handle a not-noticed-before special case during resume from one of
       the swsusp snapshots when using "usb-handoff":  the controller isn't
       left in RESET state.  (A bug to fix in the usb-handoff code...)
    
    Also cleans up a minor debug printk glitch, and switches an mdelay over
    to an msleep (how did that stick around for so long?).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/host/ohci-dbg.c  |    4 ----
     drivers/usb/host/ohci-hcd.c  |    2 +-
     drivers/usb/host/ohci-hub.c  |   42 ++++++++++++------------------------------
     drivers/usb/host/ohci-mem.c  |    1 -
     drivers/usb/host/ohci-omap.c |   36 ++++++++++++------------------------
     drivers/usb/host/ohci-pci.c  |   40 ++++++++--------------------------------
     drivers/usb/host/ohci.h      |    1 -
     7 files changed, 33 insertions(+), 93 deletions(-)

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 0afa237b02ad..99a0ad41aec5 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -112,23 +112,13 @@ ohci_pci_start (struct usb_hcd *hcd)
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	/* suspend root hub, hoping it keeps power during suspend */
-	if (time_before (jiffies, ohci->next_statechange))
-		msleep (100);
-
-#ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub);
-#else
-	usb_lock_device (hcd->self.root_hub);
-	(void) ohci_hub_suspend (hcd);
-	usb_unlock_device (hcd->self.root_hub);
-#endif
+	/* root hub was already suspended */
 
-	/* let things settle down a bit */
-	msleep (100);
-	
+	/* FIXME these PMAC things get called in the wrong places.  ASIC
+	 * clocks should be turned off AFTER entering D3, and on BEFORE
+	 * trying to enter D0.  Evidently the PCI layer doesn't currently
+	 * provide the right sort of platform hooks for this ...
+	 */
 #ifdef CONFIG_PPC_PMAC
 	if (_machine == _MACH_Pmac) {
 	   	struct device_node	*of_node;
@@ -145,9 +135,6 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	int			retval = 0;
-
 #ifdef CONFIG_PPC_PMAC
 	if (_machine == _MACH_Pmac) {
 		struct device_node *of_node;
@@ -159,19 +146,8 @@ static int ohci_pci_resume (struct usb_hcd *hcd)
 	}
 #endif /* CONFIG_PPC_PMAC */
 
-	/* resume root hub */
-	if (time_before (jiffies, ohci->next_statechange))
-		msleep (100);
-#ifdef	CONFIG_USB_SUSPEND
-	/* get extra cleanup even if remote wakeup isn't in use */
-	retval = usb_resume_device (hcd->self.root_hub);
-#else
-	usb_lock_device (hcd->self.root_hub);
-	retval = ohci_hub_resume (hcd);
-	usb_unlock_device (hcd->self.root_hub);
-#endif
-
-	return retval;
+	usb_hcd_resume_root_hub(hcd);
+	return 0;
 }
 
 #endif	/* CONFIG_PM */

commit 8ad7fe16df5e07320626be83fbba6d1c6bda5ec0
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:59:11 2005 -0700

    [PATCH] remove some USB_SUSPEND dependencies
    
    This simplifies some of the PM-related #ifdeffing by recognizing
    that USB_SUSPEND depends on PM.  Also, OHCI drivers were often
    testing for USB_SUSPEND when they should have tested just PM.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hcd.c          |    2 ++
     drivers/usb/host/ohci-hcd.c     |    2 +-
     drivers/usb/host/ohci-hub.c     |    4 ++--
     drivers/usb/host/ohci-omap.c    |    2 +-
     drivers/usb/host/ohci-pci.c     |    2 +-
     drivers/usb/host/ohci-ppc-soc.c |    4 ++--
     drivers/usb/host/ohci-pxa27x.c  |    2 +-
     drivers/usb/host/ohci-s3c2410.c |    3 +--
     drivers/usb/host/ohci-sa1111.c  |    2 +-
     9 files changed, 12 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 41e85980fa7a..0afa237b02ad 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -218,7 +218,7 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-#ifdef	CONFIG_USB_SUSPEND
+#ifdef	CONFIG_PM
 	.hub_suspend =		ohci_hub_suspend,
 	.hub_resume =		ohci_hub_resume,
 #endif

commit 390a8c345e6415cbf811232feedac70b56c9fc8d
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:57:27 2005 -0700

    [PATCH] remove usb_suspend_device() parameter
    
    This patch removes the extra usb_suspend_device() parameter.  The original
    reason to pass that parameter was so that this routine could suspend any
    active children.  A previous patch removed that functionality ... leaving
    no reason to pass the parameter.  A close analogy is pci_set_power_state,
    which doesn't need a pm_message_t either.
    
    On the internal code path that comes through the driver model, the parameter
    is now used to distinguish cases where USB devices need to "freeze" but not
    suspend.   It also checks for an error case that's accessible through sysfs:
    attempting to suspend a device before its interfaces (or for hubs, ports).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c         |   34 +++++++++++++++++++++-------------
     drivers/usb/core/usb.c         |   23 +++++++++++++++++++++--
     drivers/usb/host/ehci-hcd.c    |    2 +-
     drivers/usb/host/isp116x-hcd.c |    2 +-
     drivers/usb/host/ohci-pci.c    |    2 +-
     include/linux/usb.h            |    2 +-
     6 files changed, 46 insertions(+), 19 deletions(-)

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index eede6be098d2..41e85980fa7a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -119,7 +119,7 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 		msleep (100);
 
 #ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, message);
+	(void) usb_suspend_device (hcd->self.root_hub);
 #else
 	usb_lock_device (hcd->self.root_hub);
 	(void) ohci_hub_suspend (hcd);

commit 8c8709334cec803368a432a33e0f2e116d48fe07
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jun 27 14:36:34 2005 -0700

    [PATCH] ppc32: Remove CONFIG_PMAC_PBOOK
    
    This patch removes CONFIG_PMAC_PBOOK (PowerBook support).  This is now
    split into CONFIG_PMAC_MEDIABAY for the actual hotswap bay that some
    powerbooks have, CONFIG_PM for power management related code, and just left
    out of any CONFIG_* option for some generally useful stuff that can be used
    on non-laptops as well.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 57fd07d00549..eede6be098d2 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -14,14 +14,11 @@
  * This file is licenced under the GPL.
  */
  
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PPC_PMAC
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>
 #include <asm/pci-bridge.h>
 #include <asm/prom.h>
-#ifndef CONFIG_PM
-#	define CONFIG_PM
-#endif
 #endif
 
 #ifndef CONFIG_PCI
@@ -132,7 +129,7 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	/* let things settle down a bit */
 	msleep (100);
 	
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PPC_PMAC
 	if (_machine == _MACH_Pmac) {
 	   	struct device_node	*of_node;
  
@@ -141,7 +138,7 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 		if (of_node)
 			pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
 	}
-#endif /* CONFIG_PMAC_PBOOK */
+#endif /* CONFIG_PPC_PMAC */
 	return 0;
 }
 
@@ -151,7 +148,7 @@ static int ohci_pci_resume (struct usb_hcd *hcd)
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	int			retval = 0;
 
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PPC_PMAC
 	if (_machine == _MACH_Pmac) {
 		struct device_node *of_node;
 
@@ -160,7 +157,7 @@ static int ohci_pci_resume (struct usb_hcd *hcd)
 		if (of_node)
 			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
 	}
-#endif /* CONFIG_PMAC_PBOOK */
+#endif /* CONFIG_PPC_PMAC */
 
 	/* resume root hub */
 	if (time_before (jiffies, ohci->next_statechange))

commit 0e4987639a774d08b69c1c58774f3430f6083d4f
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 18 17:39:30 2005 -0700

    [PATCH] USB: OHCI on Compaq Aramada 7400
    
    This adds a quirk to the OHCI driver that lets it work with an old
    Compaq implementation.  It also removes some needless strings from
    the non-debug version of the driver.
    
    Signed-off-by: Chris Clayton <chris_clayton@f1internet.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index f30118b5f9aa..57fd07d00549 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -54,7 +54,7 @@ ohci_pci_start (struct usb_hcd *hcd)
 		if (pdev->vendor == PCI_VENDOR_ID_AMD
 				&& pdev->device == 0x740c) {
 			ohci->flags = OHCI_QUIRK_AMD756;
-			ohci_info (ohci, "AMD756 erratum 4 workaround\n");
+			ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
 			// also somewhat erratum 10 (suspend/resume issues)
 		}
 
@@ -68,7 +68,7 @@ ohci_pci_start (struct usb_hcd *hcd)
 		 */
 		else if (pdev->vendor == PCI_VENDOR_ID_OPTI
 				&& pdev->device == 0xc861) {
-			ohci_info (ohci,
+			ohci_dbg (ohci,
 				"WARNING: OPTi workarounds unavailable\n");
 		}
 
@@ -84,9 +84,20 @@ ohci_pci_start (struct usb_hcd *hcd)
 			if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
 					&& b->vendor == PCI_VENDOR_ID_NS) {
 				ohci->flags |= OHCI_QUIRK_SUPERIO;
-				ohci_info (ohci, "Using NSC SuperIO setup\n");
+				ohci_dbg (ohci, "Using NSC SuperIO setup\n");
 			}
 		}
+
+		/* Check for Compaq's ZFMicro chipset, which needs short 
+		 * delays before control or bulk queues get re-activated
+		 * in finish_unlinks()
+		 */
+		else if (pdev->vendor == PCI_VENDOR_ID_COMPAQ
+				&& pdev->device  == 0xa0f8) {
+			ohci->flags |= OHCI_QUIRK_ZFMICRO;
+			ohci_dbg (ohci,
+				"enabled Compaq ZFMicro chipset quirk\n");
+		}
 	}
 
 	/* NOTE: there may have already been a first reset, to

commit 9a5d3e98dd31abcecbf4533b81866d440cc0f106
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 18 17:39:23 2005 -0700

    [PATCH] USB: hcd suspend uses pm_message_t
    
    This patch includes minor "sparse -Wbitwise" updates for the PCI based
    HCDs.  Almost all of them involve just changing the second parameter of the
    suspend() method to a pm_message_t ...  the others relate to how the EHCI
    code walks in-memory data structures.  (There's a minor bug fixed there too
    ...  affecting the big-endian sysfs async schedule dump.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    
    Index: gregkh-2.6/drivers/usb/core/hcd.h
    ===================================================================

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b611582e6bcf..f30118b5f9aa 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -102,7 +102,7 @@ ohci_pci_start (struct usb_hcd *hcd)
 
 #ifdef	CONFIG_PM
 
-static int ohci_pci_suspend (struct usb_hcd *hcd, u32 state)
+static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
@@ -111,7 +111,7 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, u32 state)
 		msleep (100);
 
 #ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, state);
+	(void) usb_suspend_device (hcd->self.root_hub, message);
 #else
 	usb_lock_device (hcd->self.root_hub);
 	(void) ohci_hub_suspend (hcd);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
new file mode 100644
index 000000000000..b611582e6bcf
--- /dev/null
+++ b/drivers/usb/host/ohci-pci.c
@@ -0,0 +1,264 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * 
+ * [ Initialisation is based on Linus'  ]
+ * [ uhci code and gregs ohci fragments ]
+ * [ (C) Copyright 1999 Linus Torvalds  ]
+ * [ (C) Copyright 1999 Gregory P. Smith]
+ * 
+ * PCI Bus Glue
+ *
+ * This file is licenced under the GPL.
+ */
+ 
+#ifdef CONFIG_PMAC_PBOOK
+#include <asm/machdep.h>
+#include <asm/pmac_feature.h>
+#include <asm/pci-bridge.h>
+#include <asm/prom.h>
+#ifndef CONFIG_PM
+#	define CONFIG_PM
+#endif
+#endif
+
+#ifndef CONFIG_PCI
+#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static int
+ohci_pci_reset (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+
+	ohci_hcd_init (ohci);
+	return ohci_init (ohci);
+}
+
+static int __devinit
+ohci_pci_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	if(hcd->self.controller && hcd->self.controller->bus == &pci_bus_type) {
+		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
+
+		/* AMD 756, for most chips (early revs), corrupts register
+		 * values on read ... so enable the vendor workaround.
+		 */
+		if (pdev->vendor == PCI_VENDOR_ID_AMD
+				&& pdev->device == 0x740c) {
+			ohci->flags = OHCI_QUIRK_AMD756;
+			ohci_info (ohci, "AMD756 erratum 4 workaround\n");
+			// also somewhat erratum 10 (suspend/resume issues)
+		}
+
+		/* FIXME for some of the early AMD 760 southbridges, OHCI
+		 * won't work at all.  blacklist them.
+		 */
+
+		/* Apple's OHCI driver has a lot of bizarre workarounds
+		 * for this chip.  Evidently control and bulk lists
+		 * can get confused.  (B&W G3 models, and ...)
+		 */
+		else if (pdev->vendor == PCI_VENDOR_ID_OPTI
+				&& pdev->device == 0xc861) {
+			ohci_info (ohci,
+				"WARNING: OPTi workarounds unavailable\n");
+		}
+
+		/* Check for NSC87560. We have to look at the bridge (fn1) to
+		 * identify the USB (fn2). This quirk might apply to more or
+		 * even all NSC stuff.
+		 */
+		else if (pdev->vendor == PCI_VENDOR_ID_NS) {
+			struct pci_dev	*b;
+
+			b  = pci_find_slot (pdev->bus->number,
+					PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
+			if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
+					&& b->vendor == PCI_VENDOR_ID_NS) {
+				ohci->flags |= OHCI_QUIRK_SUPERIO;
+				ohci_info (ohci, "Using NSC SuperIO setup\n");
+			}
+		}
+	}
+
+	/* NOTE: there may have already been a first reset, to
+	 * keep bios/smm irqs from making trouble
+	 */
+	if ((ret = ohci_run (ohci)) < 0) {
+		ohci_err (ohci, "can't start\n");
+		ohci_stop (hcd);
+		return ret;
+	}
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+
+static int ohci_pci_suspend (struct usb_hcd *hcd, u32 state)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+
+	/* suspend root hub, hoping it keeps power during suspend */
+	if (time_before (jiffies, ohci->next_statechange))
+		msleep (100);
+
+#ifdef	CONFIG_USB_SUSPEND
+	(void) usb_suspend_device (hcd->self.root_hub, state);
+#else
+	usb_lock_device (hcd->self.root_hub);
+	(void) ohci_hub_suspend (hcd);
+	usb_unlock_device (hcd->self.root_hub);
+#endif
+
+	/* let things settle down a bit */
+	msleep (100);
+	
+#ifdef CONFIG_PMAC_PBOOK
+	if (_machine == _MACH_Pmac) {
+	   	struct device_node	*of_node;
+ 
+		/* Disable USB PAD & cell clock */
+		of_node = pci_device_to_OF_node (to_pci_dev(hcd->self.controller));
+		if (of_node)
+			pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
+	}
+#endif /* CONFIG_PMAC_PBOOK */
+	return 0;
+}
+
+
+static int ohci_pci_resume (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			retval = 0;
+
+#ifdef CONFIG_PMAC_PBOOK
+	if (_machine == _MACH_Pmac) {
+		struct device_node *of_node;
+
+		/* Re-enable USB PAD & cell clock */
+		of_node = pci_device_to_OF_node (to_pci_dev(hcd->self.controller));
+		if (of_node)
+			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
+	}
+#endif /* CONFIG_PMAC_PBOOK */
+
+	/* resume root hub */
+	if (time_before (jiffies, ohci->next_statechange))
+		msleep (100);
+#ifdef	CONFIG_USB_SUSPEND
+	/* get extra cleanup even if remote wakeup isn't in use */
+	retval = usb_resume_device (hcd->self.root_hub);
+#else
+	usb_lock_device (hcd->self.root_hub);
+	retval = ohci_hub_resume (hcd);
+	usb_unlock_device (hcd->self.root_hub);
+#endif
+
+	return retval;
+}
+
+#endif	/* CONFIG_PM */
+
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_pci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"OHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_MEMORY | HCD_USB11,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ohci_pci_reset,
+	.start =		ohci_pci_start,
+#ifdef	CONFIG_PM
+	.suspend =		ohci_pci_suspend,
+	.resume =		ohci_pci_resume,
+#endif
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_USB_SUSPEND
+	.hub_suspend =		ohci_hub_suspend,
+	.hub_resume =		ohci_hub_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+
+static const struct pci_device_id pci_ids [] = { {
+	/* handle any USB OHCI controller */
+	PCI_DEVICE_CLASS((PCI_CLASS_SERIAL_USB << 8) | 0x10, ~0),
+	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
+	}, { /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE (pci, pci_ids);
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver ohci_pci_driver = {
+	.name =		(char *) hcd_name,
+	.id_table =	pci_ids,
+
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
+
+#ifdef	CONFIG_PM
+	.suspend =	usb_hcd_pci_suspend,
+	.resume =	usb_hcd_pci_resume,
+#endif
+};
+
+ 
+static int __init ohci_hcd_pci_init (void) 
+{
+	printk (KERN_DEBUG "%s: " DRIVER_INFO " (PCI)\n", hcd_name);
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
+		sizeof (struct ed), sizeof (struct td));
+	return pci_register_driver (&ohci_pci_driver);
+}
+module_init (ohci_hcd_pci_init);
+
+/*-------------------------------------------------------------------------*/
+
+static void __exit ohci_hcd_pci_cleanup (void) 
+{	
+	pci_unregister_driver (&ohci_pci_driver);
+}
+module_exit (ohci_hcd_pci_cleanup);
