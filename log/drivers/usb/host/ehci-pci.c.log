commit 1ddcb71a3edf0e1682b6e056158e4c4b00325f66
Author: Longfang Liu <liulongfang@huawei.com>
Date:   Mon Jun 8 11:46:59 2020 +0800

    USB: ehci: reopen solution for Synopsys HC bug
    
    A Synopsys USB2.0 core used in Huawei Kunpeng920 SoC has a bug which
    might cause the host controller not issuing ping.
    
    Bug description:
    After indicating an Interrupt on Async Advance, the software uses the
    doorbell mechanism to delete the Next Link queue head of the last
    executed queue head. At this time, the host controller still references
    the removed queue head(the queue head is NULL). NULL reference causes
    the host controller to lose the USB device.
    
    Solution:
    After deleting the Next Link queue head, when has_synopsys_hc_bug set
    to 1ï¼Œthe software can write one of the valid queue head addresses to
    the ASYNCLISTADDR register to allow the host controller to get
    the valid queue head. in order to solve that problem, this patch set
    the flag for Huawei Kunpeng920
    
    There are detailed instructions and solutions in this patch:
    commit 2f7ac6c19997 ("USB: ehci: add workaround for Synopsys HC bug")
    
    Signed-off-by: Longfang Liu <liulongfang@huawei.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/1591588019-44284-1-git-send-email-liulongfang@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3c3820ad9092..af3c1b9b38b2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -216,6 +216,13 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci_info(ehci, "applying MosChip frame-index workaround\n");
 		ehci->frame_index_bug = 1;
 		break;
+	case PCI_VENDOR_ID_HUAWEI:
+		/* Synopsys HC bug */
+		if (pdev->device == 0xa239) {
+			ehci_info(ehci, "applying Synopsys HC workaround\n");
+			ehci->has_synopsys_hc_bug = 1;
+		}
+		break;
 	}
 
 	/* optional debug port, normally in the first BAR */

commit ff4c65ca48f08f4781accfb1d224acd7c897070e
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:36 2020 +0530

    usb: hci: add hc_driver as argument for usb_hcd_pci_probe
    
    usb_hcd_pci_probe expects users to call this with driver_data set as
    hc_driver, that limits the possibility of using the driver_data for
    driver data.
    
    Add hc_driver as argument to usb_hcd_pci_probe and modify the callers
    ehci/ohci/xhci/uhci to pass hc_driver as argument and freeup the
    driver_data used
    
    Tested xhci driver on Dragon-board RB3, compile tested ehci, ohci and
    uhci.
    
    [For all but the xHCI parts]
    [For the xhci part]
    
    Suggested-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-2-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1a48ab1bd3b2..3c3820ad9092 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -360,23 +360,21 @@ static int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	if (is_bypassed_id(pdev))
 		return -ENODEV;
-	return usb_hcd_pci_probe(pdev, id);
+	return usb_hcd_pci_probe(pdev, id, &ehci_pci_hc_driver);
 }
 
 static void ehci_pci_remove(struct pci_dev *pdev)
 {
 	pci_clear_mwi(pdev);
-	usb_hcd_pci_remove(pdev);	
+	usb_hcd_pci_remove(pdev);
 }
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
-	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	}, {
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),
-	.driver_data = (unsigned long) &ehci_pci_hc_driver,
 	},
 	{ /* end: all zeroes */ }
 };

commit 7cbfeb65f0584ccabee8d52bda47eaee6c074e7e
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Tue Feb 18 19:32:58 2020 +0000

    usb: host: ehci-pci: remove useless cast for driver.name
    
    pci_driver name is const char pointer, so it not useful to cast
    hcd_name (which is already const char).
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Link: https://lore.kernel.org/r/1582054383-35760-16-git-send-email-clabbe@baylibre.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index b0882c13a1d1..1a48ab1bd3b2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -384,7 +384,7 @@ MODULE_DEVICE_TABLE(pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ehci_pci_driver = {
-	.name =		(char *) hcd_name,
+	.name =		hcd_name,
 	.id_table =	pci_ids,
 
 	.probe =	ehci_pci_probe,

commit 4fbb8aa75836c3361987f431d9451aecc1830bdd
Author: Ryan Kennedy <ryan5544@gmail.com>
Date:   Thu Jul 4 11:35:29 2019 -0400

    usb: pci-quirks: Minor cleanup for AMD PLL quirk
    
    usb_amd_find_chipset_info() is used for chipset detection for
    several quirks. It is strange that its return value indicates
    the need for the PLL quirk, which means it is often ignored.
    This patch adds a function specifically for checking the PLL
    quirk like the other ones. Additionally, rename probe_result to
    something more appropriate.
    
    Signed-off-by: Ryan Kennedy <ryan5544@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20190704153529.9429-3-ryan5544@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index fe9422d3bcdc..b0882c13a1d1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -149,7 +149,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_AMD:
 		/* AMD PLL quirk */
-		if (usb_amd_find_chipset_info())
+		if (usb_amd_quirk_pll_check())
 			ehci->amd_pll_fix = 1;
 		/* AMD8111 EHCI doesn't work, according to AMD errata */
 		if (pdev->device == 0x7463) {
@@ -186,7 +186,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_ATI:
 		/* AMD PLL quirk */
-		if (usb_amd_find_chipset_info())
+		if (usb_amd_quirk_pll_check())
 			ehci->amd_pll_fix = 1;
 
 		/*

commit d214109875b419c85c596d39b032692133bf58ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:26 2017 +0100

    USB: host: ehci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f6015f6ca488..fe9422d3bcdc 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -3,20 +3,6 @@
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *
  * Copyright (c) 2000-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 93326974ff4b..f6015f6ca488 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *

commit 629dd219881a6d9643806acf4f0166501f4c3374
Author: Lucas Stach <dev@lynxeye.de>
Date:   Sun Oct 23 01:02:03 2016 +0200

    USB: EHCI: merge all cases that disable the IO watchdog
    
    This merges the vendor NEC case with the INTEL and AMD one,
    as those 3 do exactly the same thing: disabling of the IO
    watchdog.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 0ed683c176f0..93326974ff4b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -258,8 +258,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* These workarounds need to be applied after ehci_setup() */
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_NEC:
-		ehci->need_io_watchdog = 0;
-		break;
 	case PCI_VENDOR_ID_INTEL:
 	case PCI_VENDOR_ID_AMD:
 		ehci->need_io_watchdog = 0;

commit 5c2ad982fb422ae710184e5911de0d4e030de8ac
Author: Lucas Stach <dev@lynxeye.de>
Date:   Sun Oct 23 01:02:02 2016 +0200

    USB: EHCI: elide I/O watchdog on AMD parts
    
    This removes 10 timer wakeups per second. I'm running this patch for
    a while now and haven't spotted any adverse effects.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3b3649d88c5f..0ed683c176f0 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -261,6 +261,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci->need_io_watchdog = 0;
 		break;
 	case PCI_VENDOR_ID_INTEL:
+	case PCI_VENDOR_ID_AMD:
 		ehci->need_io_watchdog = 0;
 		break;
 	case PCI_VENDOR_ID_NVIDIA:

commit e3e2e36c106a1e4212c65ba5b5d2bcb3455cb354
Author: Jia-Ju Bai <baijiaju1990@163.com>
Date:   Mon Jan 4 16:14:29 2016 +0800

    ehci-hcd: Disable memory-write-invalidate when the driver is removed
    
    The driver calls pci_set_mwi to enable memory-write-invalidate when it
    is initialized, but does not call pci_clear_mwi when it is removed. Many
    other drivers calls pci_clear_mwi when pci_set_mwi is called, such as
    r8169, 8139cp and e1000.
    
    This patch adds a function "ehci_pci_remove" to remove the pci driver.
    This function calls pci_clear_mwi and usb_hcd_pci_remove, which can
    fix the problem.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@163.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 2a5d2fd76040..3b3649d88c5f 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -377,6 +377,12 @@ static int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	return usb_hcd_pci_probe(pdev, id);
 }
 
+static void ehci_pci_remove(struct pci_dev *pdev)
+{
+	pci_clear_mwi(pdev);
+	usb_hcd_pci_remove(pdev);	
+}
+
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
@@ -396,7 +402,7 @@ static struct pci_driver ehci_pci_driver = {
 	.id_table =	pci_ids,
 
 	.probe =	ehci_pci_probe,
-	.remove =	usb_hcd_pci_remove,
+	.remove =	ehci_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
 #ifdef CONFIG_PM

commit 518ca8d9326e258f4595bfe9bc7fc61f5c3636cb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Feb 3 18:08:39 2015 +0200

    ehci-pci: disable for Intel MID platforms (update)
    
    This is a follow up to the previously submitted commit cefa9a31a5f0 (ehci-pci:
    disable for Intel MID platforms).
    
    It includes the following changes:
    - table and function are renamed to reflect this is not only about ChipIdea
    - ChipIdea PCI driver (ci_hdrc_pci.c) gets the comment about the table in
      ehci-pci.c
    - MIPS IDs removed from the list since it was discovered and tested on Intel
      MID platforms
    
    Reviewed-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 965202138161..2a5d2fd76040 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -42,18 +42,22 @@ static inline bool is_intel_quark_x1000(struct pci_dev *pdev)
 		pdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;
 }
 
-static const struct pci_device_id ci_hdrc_pci_id_table[] = {
-	{ PCI_DEVICE(0x153F, 0x1004), },
-	{ PCI_DEVICE(0x153F, 0x1006), },
+/*
+ * This is the list of PCI IDs for the devices that have EHCI USB class and
+ * specific drivers for that. One of the example is a ChipIdea device installed
+ * on some Intel MID platforms.
+ */
+static const struct pci_device_id bypass_pci_id_table[] = {
+	/* ChipIdea on Intel MID platform */
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0811), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0829), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xe006), },
 	{}
 };
 
-static inline bool is_ci_hdrc_pci(struct pci_dev *pdev)
+static inline bool is_bypassed_id(struct pci_dev *pdev)
 {
-	return !!pci_match_id(ci_hdrc_pci_id_table, pdev);
+	return !!pci_match_id(bypass_pci_id_table, pdev);
 }
 
 /*
@@ -368,7 +372,7 @@ static const struct ehci_driver_overrides pci_overrides __initconst = {
 
 static int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
-	if (is_ci_hdrc_pci(pdev))
+	if (is_bypassed_id(pdev))
 		return -ENODEV;
 	return usb_hcd_pci_probe(pdev, id);
 }

commit cefa9a31a5f0856b81d53030815485fcb1fe8aab
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 28 20:04:06 2015 +0200

    ehci-pci: disable for Intel MID platforms
    
    On some Intel MID platforms the ChipIdea USB controller is used. The EHCI PCI
    is in conflict with the proper driver. The patch makes ehci-pci to be ignored
    in favour of ChipIdea controller.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 851006a0d97b..965202138161 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -42,6 +42,20 @@ static inline bool is_intel_quark_x1000(struct pci_dev *pdev)
 		pdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;
 }
 
+static const struct pci_device_id ci_hdrc_pci_id_table[] = {
+	{ PCI_DEVICE(0x153F, 0x1004), },
+	{ PCI_DEVICE(0x153F, 0x1006), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0811), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0829), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xe006), },
+	{}
+};
+
+static inline bool is_ci_hdrc_pci(struct pci_dev *pdev)
+{
+	return !!pci_match_id(ci_hdrc_pci_id_table, pdev);
+}
+
 /*
  * 0x84 is the offset of in/out threshold register,
  * and it is the same offset as the register of 'hostpc'.
@@ -352,6 +366,13 @@ static const struct ehci_driver_overrides pci_overrides __initconst = {
 
 /*-------------------------------------------------------------------------*/
 
+static int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	if (is_ci_hdrc_pci(pdev))
+		return -ENODEV;
+	return usb_hcd_pci_probe(pdev, id);
+}
+
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
@@ -370,7 +391,7 @@ static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
 
-	.probe =	usb_hcd_pci_probe,
+	.probe =	ehci_pci_probe,
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 

commit ceb6c9c862c86423f41c1e20ecf8d454f837f519
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 29 23:47:05 2014 +0100

    USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM (or even dropped in some cases).
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the USB core code
    and documentation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ca7b964124af..851006a0d97b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -305,7 +305,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 	}
 
-#ifdef	CONFIG_PM_RUNTIME
+#ifdef	CONFIG_PM
 	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif

commit 6e693739e9b603b3ca9ce0d4f4178f0633458465
Author: Bryan O'Donoghue <bryan.odonoghue@intel.com>
Date:   Wed Jul 2 01:58:18 2014 -0700

    USB: ehci-pci: USB host controller support for Intel Quark X1000
    
    The EHCI packet buffer in/out threshold is programmable for Intel Quark X1000
    USB host controller, and the default value is 0x20 dwords. The in/out threshold
    can be programmed to 0x80 dwords (512 Bytes) to maximize the perfomrance,
    but only when isochronous/interrupt transactions are not initiated by the USB
    host controller. This patch is to reconfigure the packet buffer in/out
    threshold as maximal as possible to maximize the performance, and 0x7F dwords
    (508 Bytes) should be used because the USB host controller initiates
    isochronous/interrupt transactions.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@intel.com>
    Signed-off-by: Alvin (Weike) Chen <alvin.chen@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Jingoo Han <jg1.han@samsung.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3e86bf4371b3..ca7b964124af 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -35,6 +35,21 @@ static const char hcd_name[] = "ehci-pci";
 #define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
 
 /*-------------------------------------------------------------------------*/
+#define PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC		0x0939
+static inline bool is_intel_quark_x1000(struct pci_dev *pdev)
+{
+	return pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		pdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;
+}
+
+/*
+ * 0x84 is the offset of in/out threshold register,
+ * and it is the same offset as the register of 'hostpc'.
+ */
+#define	intel_quark_x1000_insnreg01	hostpc
+
+/* Maximum usable threshold value is 0x7f dwords for both IN and OUT */
+#define INTEL_QUARK_X1000_EHCI_MAX_THRESHOLD	0x007f007f
 
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
@@ -50,6 +65,16 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	if (!retval)
 		ehci_dbg(ehci, "MWI active\n");
 
+	/* Reset the threshold limit */
+	if (is_intel_quark_x1000(pdev)) {
+		/*
+		 * For the Intel QUARK X1000, raise the I/O threshold to the
+		 * maximum usable value in order to improve performance.
+		 */
+		ehci_writel(ehci, INTEL_QUARK_X1000_EHCI_MAX_THRESHOLD,
+			ehci->regs->intel_quark_x1000_insnreg01);
+	}
+
 	return 0;
 }
 

commit 3ad145b62a15c86150dd0cc229a39a3120d462f9
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Oct 3 23:37:12 2013 +0800

    usb: ehci: use amd_chipset_type to filter for usb subsystem hang bug
    
    Commit "usb: pci-quirks: refactor AMD quirk to abstract AMD chipset types"
    introduced a new AMD chipset type to filter AMD platforms with different
    chipsets.
    
    According to a recent thread [1], this patch updates USB subsystem hang
    symptom quirk which is observed on AMD all SB600 and SB700 revision
    0x3a/0x3b. And make it use the new chipset type to represent.
    
    [1] http://marc.info/?l=linux-usb&m=138012321616452&w=2
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 854c2ec7b699..3e86bf4371b3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -58,8 +58,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
-	struct pci_dev		*p_smbus;
-	u8			rev;
 	u32			temp;
 	int			retval;
 
@@ -175,22 +173,12 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		/* SB600 and old version of SB700 have a bug in EHCI controller,
 		 * which causes usb devices lose response in some cases.
 		 */
-		if ((pdev->device == 0x4386) || (pdev->device == 0x4396)) {
-			p_smbus = pci_get_device(PCI_VENDOR_ID_ATI,
-						 PCI_DEVICE_ID_ATI_SBX00_SMBUS,
-						 NULL);
-			if (!p_smbus)
-				break;
-			rev = p_smbus->revision;
-			if ((pdev->device == 0x4386) || (rev == 0x3a)
-			    || (rev == 0x3b)) {
-				u8 tmp;
-				ehci_info(ehci, "applying AMD SB600/SB700 USB "
-					"freeze workaround\n");
-				pci_read_config_byte(pdev, 0x53, &tmp);
-				pci_write_config_byte(pdev, 0x53, tmp | (1<<3));
-			}
-			pci_dev_put(p_smbus);
+		if ((pdev->device == 0x4386 || pdev->device == 0x4396) &&
+				usb_amd_hang_symptom_quirk()) {
+			u8 tmp;
+			ehci_info(ehci, "applying AMD SB600/SB700 USB freeze workaround\n");
+			pci_read_config_byte(pdev, 0x53, &tmp);
+			pci_write_config_byte(pdev, 0x53, tmp | (1<<3));
 		}
 		break;
 	case PCI_VENDOR_ID_NETMOS:

commit f875fdbf344b9fde207f66b392c40845dd7e5aa6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 24 15:45:25 2013 -0400

    USB: fix PM config symbol in uhci-hcd, ehci-hcd, and xhci-hcd
    
    Since uhci-hcd, ehci-hcd, and xhci-hcd support runtime PM, the .pm
    field in their pci_driver structures should be protected by CONFIG_PM
    rather than CONFIG_PM_SLEEP.  The corresponding change has already
    been made for ohci-hcd.
    
    Without this change, controllers won't do runtime suspend if system
    suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6bd299e61f58..854c2ec7b699 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -361,7 +361,7 @@ static struct pci_driver ehci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&usb_hcd_pci_pm_ops
 	},

commit 26b76798e0507429506b93cd49f8c4cfdab06896
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jul 23 11:35:47 2013 +0300

    Intel xhci: refactor EHCI/xHCI port switching
    
    Make the Linux xHCI driver automatically try to switchover the EHCI ports to
    xHCI when an Intel xHCI host is detected, and it also finds an Intel EHCI host.
    
    This means we will no longer have to add Intel xHCI hosts to a quirks list when
    the PCI device IDs change.  Simply continuing to add new Intel xHCI PCI device
    IDs to the quirks list is not sustainable.
    
    During suspend ports may be swicthed back to EHCI by BIOS and not properly
    restored to xHCI at resume. Previously both EHCI and xHCI resume functions
    switched ports back to XHCI, but it's enough to do it in xHCI only
    because the hub driver doesn't start running again until after both hosts are resumed.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 595d210655b6..6bd299e61f58 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -315,53 +315,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
-{
-	return pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&
-		pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		(pdev->device == 0x1E26 ||
-		 pdev->device == 0x8C2D ||
-		 pdev->device == 0x8C26 ||
-		 pdev->device == 0x9C26);
-}
-
-static void ehci_enable_xhci_companion(void)
-{
-	struct pci_dev		*companion = NULL;
-
-	/* The xHCI and EHCI controllers are not on the same PCI slot */
-	for_each_pci_dev(companion) {
-		if (!usb_is_intel_switchable_xhci(companion))
-			continue;
-		usb_enable_xhci_ports(companion);
-		return;
-	}
-}
-
 static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 
-	/* The BIOS on systems with the Intel Panther Point chipset may or may
-	 * not support xHCI natively.  That means that during system resume, it
-	 * may switch the ports back to EHCI so that users can use their
-	 * keyboard to select a kernel from GRUB after resume from hibernate.
-	 *
-	 * The BIOS is supposed to remember whether the OS had xHCI ports
-	 * enabled before resume, and switch the ports back to xHCI when the
-	 * BIOS/OS semaphore is written, but we all know we can't trust BIOS
-	 * writers.
-	 *
-	 * Unconditionally switch the ports back to xHCI after a system resume.
-	 * We can't tell whether the EHCI or xHCI controller will be resumed
-	 * first, so we have to do the port switchover in both drivers.  Writing
-	 * a '1' to the port switchover registers should have no effect if the
-	 * port was already switched over.
-	 */
-	if (usb_is_intel_switchable_ehci(pdev))
-		ehci_enable_xhci_companion();
-
 	if (ehci_resume(hcd, hibernated) != 0)
 		(void) ehci_pci_reinit(ehci, pdev);
 	return 0;

commit 62d08a1151d2755dc580a8311a6684275e4aeb94
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Apr 22 09:44:56 2013 -0700

    USB: Fix initconst in ehci driver
    
    Fix some of the initconst markings in the ehci driver(s).
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a573d5ff9adc..595d210655b6 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -375,7 +375,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 
 static struct hc_driver __read_mostly ehci_pci_hc_driver;
 
-static const struct ehci_driver_overrides pci_overrides __initdata = {
+static const struct ehci_driver_overrides pci_overrides __initconst = {
 	.reset =		ehci_pci_setup,
 };
 

commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:46 2013 -0400

    USB: remove CONFIG_USB_SUSPEND option
    
    This patch (as1675) removes the CONFIG_USB_SUSPEND option, essentially
    replacing it everywhere with CONFIG_PM_RUNTIME (except for one place
    in hub.c, where it is replaced with CONFIG_PM because the code needs
    to be used in both runtime and system PM).  The net result is code
    shrinkage and simplification.
    
    There's very little point in keeping CONFIG_USB_SUSPEND because almost
    everybody enables it.  The few that don't will find that the usbcore
    module has gotten somewhat bigger and they will have to take active
    measures if they want to prevent hubs from being runtime suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 170b9399e09f..a573d5ff9adc 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -292,17 +292,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 	}
 
-#ifdef	CONFIG_USB_SUSPEND
-	/* REVISIT: the controller works fine for wakeup iff the root hub
-	 * itself is "globally" suspended, but usbcore currently doesn't
-	 * understand such things.
-	 *
-	 * System suspend currently expects to be able to suspend the entire
-	 * device tree, device-at-a-time.  If we failed selective suspend
-	 * reports, system suspend would fail; so the root hub code must claim
-	 * success.  That's lying to usbcore, and it matters for runtime
-	 * PM scenarios with selective suspend and remote wakeup...
-	 */
+#ifdef	CONFIG_PM_RUNTIME
 	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif

commit 75e1a2ae1f61ce1ae640410ba757bba84bd9fefe
Author: Jan Beulich <JBeulich@suse.com>
Date:   Wed Dec 19 16:15:56 2012 +0000

    USB: ehci: make debug port in-use detection functional again
    
    Debug port in-use determination must be done before the controller gets
    reset the first time, i.e. before the call to ehci_setup() as of commit
    1a49e2ac9651df7349867a5cf44e2c83de1046af. That commit effectively
    rendered commit 9fa5780beea1274d498a224822397100022da7d4 useless.
    
    While moving that code around, also fix the BAR determination - the
    respective capability field is a 3- rather than a 2-bit one -, and use
    PCI_CAP_ID_DBG instead of the literal 0x0a.
    
    It's unclear to me whether the debug port functionality is important
    enough to warrant fixing this in stable kernels too.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index dabb20494826..170b9399e09f 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -200,6 +200,26 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
+	/* optional debug port, normally in the first BAR */
+	temp = pci_find_capability(pdev, PCI_CAP_ID_DBG);
+	if (temp) {
+		pci_read_config_dword(pdev, temp, &temp);
+		temp >>= 16;
+		if (((temp >> 13) & 7) == 1) {
+			u32 hcs_params = ehci_readl(ehci,
+						    &ehci->caps->hcs_params);
+
+			temp &= 0x1fff;
+			ehci->debug = hcd->regs + temp;
+			temp = ehci_readl(ehci, &ehci->debug->control);
+			ehci_info(ehci, "debug port %d%s\n",
+				  HCS_DEBUG_PORT(hcs_params),
+				  (temp & DBGP_ENABLED) ? " IN USE" : "");
+			if (!(temp & DBGP_ENABLED))
+				ehci->debug = NULL;
+		}
+	}
+
 	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
@@ -228,25 +248,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
-	/* optional debug port, normally in the first BAR */
-	temp = pci_find_capability(pdev, 0x0a);
-	if (temp) {
-		pci_read_config_dword(pdev, temp, &temp);
-		temp >>= 16;
-		if ((temp & (3 << 13)) == (1 << 13)) {
-			temp &= 0x1fff;
-			ehci->debug = hcd->regs + temp;
-			temp = ehci_readl(ehci, &ehci->debug->control);
-			ehci_info(ehci, "debug port %d%s\n",
-				HCS_DEBUG_PORT(ehci->hcs_params),
-				(temp & DBGP_ENABLED)
-					? " IN USE"
-					: "");
-			if (!(temp & DBGP_ENABLED))
-				ehci->debug = NULL;
-		}
-	}
-
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
 	temp &= 0x0f;

commit bb1e5dd7113d2fd178d3af9aca8f480ae0468edf
Author: Russell Webb <russell.webb@linux.intel.com>
Date:   Fri Nov 9 13:58:49 2012 -0800

    xhci: Add Lynx Point LP to list of Intel switchable hosts
    
    Like Lynx Point, Lynx Point LP is also switchable.  See
    1c12443ab8eba71a658fae4572147e56d1f84f66 for more details.
    
    This patch should be backported to stable kernels as old as 3.0,
    that contain commit 69e848c2090aebba5698a1620604c7dccb448684
    "Intel xhci: Support EHCI/xHCI port switching."
    
    Signed-off-by: Russell Webb <russell.webb@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3fb76ca61848..dabb20494826 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -330,7 +330,8 @@ static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
 		pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		(pdev->device == 0x1E26 ||
 		 pdev->device == 0x8C2D ||
-		 pdev->device == 0x8C26);
+		 pdev->device == 0x8C26 ||
+		 pdev->device == 0x9C26);
 }
 
 static void ehci_enable_xhci_companion(void)

commit 1b36810e27a9791878e4694357ab6d4c06acc22d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 7 16:12:47 2012 -0500

    USB: EHCI: miscellaneous cleanups for the library conversion
    
    This patch (as1630) cleans up a few minor items resulting from the
    split-up of the ehci-hcd driver:
    
            Remove the product_desc string from the ehci_driver_overrides
            structure.  All drivers will use the generic "EHCI Host
            Controller" string.  (This was requested by Felipe Balbi.)
    
            Allow drivers to pass a NULL pointer to ehci_init_driver()
            if they don't have to override any settings.
    
            Remove a #define symbol that is no longer used from the
            ChipIdea host driver.
    
            Rename overrides to pci_overrides in ehci-pci.c, for
            consistency with ehci-platform.c.
    
            Mark the *_overrides structures as __initdata.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 46018e975244..3fb76ca61848 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -383,8 +383,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 
 static struct hc_driver __read_mostly ehci_pci_hc_driver;
 
-static const struct ehci_driver_overrides overrides = {
-	.product_desc =		"EHCI PCI host controller",
+static const struct ehci_driver_overrides pci_overrides __initdata = {
 	.reset =		ehci_pci_setup,
 };
 
@@ -426,7 +425,7 @@ static int __init ehci_pci_init(void)
 
 	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
-	ehci_init_driver(&ehci_pci_hc_driver, &overrides);
+	ehci_init_driver(&ehci_pci_hc_driver, &pci_overrides);
 
 	/* Entries for the PCI suspend/resume callbacks are special */
 	ehci_pci_hc_driver.pci_suspend = ehci_suspend;

commit adfa79d1c06a32650332930ca4c488ca570b3407
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 1 11:13:04 2012 -0400

    USB: EHCI: make ehci-pci a separate driver
    
    This patch (as1625) splits the PCI portion of ehci-hcd out into its
    own separate driver module, called ehci-pci.  Consistently with the
    current practice, the decision whether to build this module is not
    user-configurable.  If EHCI and PCI are enabled then the module will
    be built, always.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index c92dcaee0d4d..46018e975244 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -18,9 +18,18 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#ifndef CONFIG_PCI
-#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
-#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+
+#include "ehci.h"
+#include "pci-quirks.h"
+
+#define DRIVER_DESC "EHCI PCI platform driver"
+
+static const char hcd_name[] = "ehci-pci";
 
 /* defined here to avoid adding to pci_ids.h for single instance use */
 #define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
@@ -315,11 +324,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
-{
-	return ehci_suspend(hcd, do_wakeup);
-}
-
 static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
 {
 	return pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&
@@ -370,55 +374,18 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 		(void) ehci_pci_reinit(ehci, pdev);
 	return 0;
 }
-#endif
-
-static const struct hc_driver ehci_pci_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"EHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ehci_hcd),
 
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		ehci_pci_setup,
-	.start =		ehci_run,
-#ifdef	CONFIG_PM
-	.pci_suspend =		ehci_pci_suspend,
-	.pci_resume =		ehci_pci_resume,
-#endif
-	.stop =			ehci_stop,
-	.shutdown =		ehci_shutdown,
+#else
 
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ehci_urb_enqueue,
-	.urb_dequeue =		ehci_urb_dequeue,
-	.endpoint_disable =	ehci_endpoint_disable,
-	.endpoint_reset =	ehci_endpoint_reset,
+#define ehci_suspend		NULL
+#define ehci_pci_resume		NULL
+#endif	/* CONFIG_PM */
 
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ehci_get_frame,
+static struct hc_driver __read_mostly ehci_pci_hc_driver;
 
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ehci_hub_status_data,
-	.hub_control =		ehci_hub_control,
-	.bus_suspend =		ehci_bus_suspend,
-	.bus_resume =		ehci_bus_resume,
-	.relinquish_port =	ehci_relinquish_port,
-	.port_handed_over =	ehci_port_handed_over,
-
-	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
+static const struct ehci_driver_overrides overrides = {
+	.product_desc =		"EHCI PCI host controller",
+	.reset =		ehci_pci_setup,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -451,3 +418,31 @@ static struct pci_driver ehci_pci_driver = {
 	},
 #endif
 };
+
+static int __init ehci_pci_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+
+	ehci_init_driver(&ehci_pci_hc_driver, &overrides);
+
+	/* Entries for the PCI suspend/resume callbacks are special */
+	ehci_pci_hc_driver.pci_suspend = ehci_suspend;
+	ehci_pci_hc_driver.pci_resume = ehci_pci_resume;
+
+	return pci_register_driver(&ehci_pci_driver);
+}
+module_init(ehci_pci_init);
+
+static void __exit ehci_pci_cleanup(void)
+{
+	pci_unregister_driver(&ehci_pci_driver);
+}
+module_exit(ehci_pci_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("David Brownell");
+MODULE_AUTHOR("Alan Stern");
+MODULE_LICENSE("GPL");

commit c73cee717e7d5da0698acb720ad1219646fe4f46
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:21:06 2012 -0400

    USB: EHCI: remove ehci_port_power() routine
    
    This patch (as1623) removes the ehci_port_power() routine and all the
    places that call it.  There's no reason for ehci-hcd to change the
    port power settings; the hub driver takes care of all that stuff.
    
    There is one exception: When the controller is resumed from
    hibernation or following a loss of power, the ports that are supposed
    to be handed over to a companion controller must be powered on first.
    Otherwise the handover won't work.  This process is not visible to the
    hub driver, so it has to be handled in ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e17330ae0aee..c92dcaee0d4d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -297,7 +297,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif
 
-	ehci_port_power(ehci, 1);
 	retval = ehci_pci_reinit(ehci, pdev);
 done:
 	return retval;

commit 4968f951913997adc8c68c4e986e8168ee1d2998
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:12:11 2012 -0400

    USB: EHCI: remove unused Link Power Management code
    
    This patch (as1622) removes the USB-2.1 Link Power Management code
    from the ehci-hcd driver.  This code was never integrated with
    usbcore, it is full of bugs, and it was not getting used by anybody.
    
    However, the debugging code for dumping the LPM-related fields in the
    EHCI registers is left in place.  In theory it might be useful to see
    these values, even though we don't use them.
    
    This essentially amounts to a partial revert of commit
    aa4d8342988d0c1a79ff19b2ede1e81dfbb16ea5 (USB: EHCI: EHCI 1.1
    addendum: preparation) and an almost full revert of commit
    48f24970144479c29b8cee6d2e1dbedf6dcf9cfb (USB: EHCI: EHCI 1.1
    addendum: Basic LPM feature support) plus its follow-ons.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 7880ba621f89..e17330ae0aee 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -202,11 +202,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci->need_io_watchdog = 0;
-		if (pdev->device == 0x0806 || pdev->device == 0x0811
-				|| pdev->device == 0x0829) {
-			ehci_info(ehci, "disable lpm for langwell/penwell\n");
-			ehci->has_lpm = 0;
-		}
 		break;
 	case PCI_VENDOR_ID_NVIDIA:
 		switch (pdev->device) {
@@ -216,8 +211,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		 * devices with PPCD enabled.
 		 */
 		case 0x0d9d:
-			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
-			ehci->has_lpm = 0;
+			ehci_info(ehci, "disable ppcd for nvidia mcp89\n");
 			ehci->has_ppcd = 0;
 			ehci->command &= ~CMD_PPCEE;
 			break;
@@ -425,11 +419,6 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
 
-	/*
-	 * call back when device connected and addressed
-	 */
-	.update_device =	ehci_update_device,
-
 	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
 };
 

commit d39dbc8918be0e6bb850592e334203c9114c0e77
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 10 15:07:46 2012 -0400

    USB: EHCI: move ehci_update_device() to ehci-lpm.c
    
    In preparation for splitting the ehci-hcd driver into a core library
    and separate platform-specific driver modules, this patch (as1618)
    moves ehci_update_device() from a couple of platform-specific source
    files into ehci-lpm.c.  This is where it should have been all along,
    since all it does is call a couple of other functions that are already
    in ehci-lpm.c.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d1407f8d42b1..7880ba621f89 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -379,22 +379,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 }
 #endif
 
-static int ehci_update_device(struct usb_hcd *hcd, struct usb_device *udev)
-{
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	int rc = 0;
-
-	if (!udev->parent) /* udev is root hub itself, impossible */
-		rc = -1;
-	/* we only support lpm device connected to root hub yet */
-	if (ehci->has_lpm && !udev->parent->parent) {
-		rc = ehci_lpm_set_da(ehci, udev->devnum, udev->portnum);
-		if (!rc)
-			rc = ehci_lpm_check(ehci, udev->portnum);
-	}
-	return rc;
-}
-
 static const struct hc_driver ehci_pci_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"EHCI Host Controller",

commit 98cae42d82fe9c9e2b5dacdf391edaa007e147e5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Sep 28 16:01:34 2012 -0400

    EHCI: use the isochronous scheduling threshold
    
    This patch (as1609) changes the way ehci-hcd uses the "Isochronous
    Scheduling Threshold" in its calculations.  Until now the code has
    ignored the threshold except for certain Intel PCI-based controllers.
    This violates the EHCI spec.
    
    The new code takes the threshold into account always, removing the
    need for the fs_i_thresh quirk flag.  In addition it implements the
    "full frame cache" setting more efficiently, moving forward only as
    far as the next frame boundary instead of always moving forward 8
    microframes.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 2cb7d370c4ef..d1407f8d42b1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -103,7 +103,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_INTEL:
-		ehci->fs_i_thresh = 1;
 		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd->has_tt = 1;
 		break;

commit 3ca9aebac2ebb8f56d2d097636b8c568320a9f87
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:05 2012 -0400

    USB: EHCI: use hrtimer for the periodic schedule
    
    This patch (as1573) adds hrtimer support for managing ehci-hcd's
    periodic schedule.  There are two issues to deal with.
    
    First, the schedule's state (on or off) must not be changed until the
    hardware status has caught up with the current command.  This is
    handled by an hrtimer event that polls at 1-ms intervals to see when
    the Periodic Schedule Status (PSS) flag matches the Periodic Schedule
    Enable (PSE) value.
    
    Second, the schedule should not be turned off as soon as it becomes
    empty.  Turning the schedule on and off takes time, so we want to wait
    until the schedule has been empty for a suitable period before turning
    it off.  This is handled by an hrtimer event that gets set to expire
    10 ms after the periodic schedule becomes empty.
    
    The existing code polls (for up to 1125 us and with interrupts
    disabled!) to check the status, and doesn't implement a delay before
    turning off the schedule.  Furthermore, if the polling fails then the
    driver decides that the controller has died.  This has caused problems
    for several people; some controllers can take 10 ms or more to turn
    off their periodic schedules.
    
    This patch fixes these issues.  It also makes the "broken_periodic"
    workaround unnecessary; there is no longer any danger of turning off
    the periodic schedule after it has been on for less than 1 ms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 21e5f963f331..2cb7d370c4ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -104,10 +104,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci->fs_i_thresh = 1;
-		if (pdev->device == 0x27cc) {
-			ehci->broken_periodic = 1;
-			ehci_info(ehci, "using broken periodic workaround\n");
-		}
 		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd->has_tt = 1;
 		break;

commit 1a49e2ac9651df7349867a5cf44e2c83de1046af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 9 15:55:14 2012 -0400

    EHCI: centralize controller initialization
    
    This patch (as1564c) converts the EHCI platform drivers to use the
    central ehci_setup() routine for generic controller initialization
    rather than each having its own idiosyncratic approach.
    
    The major point of difficulty lies in ehci-pci's many vendor- and
    device-specific workarounds.  Some of them have to be applied before
    calling ehci_setup() and some after, which necessitates a fair amount
    of code motion.  The other platform drivers require much smaller
    changes.
    
    One point not addressed by the patch is whether ports should be
    powered on or off following initialization.  The different drivers
    appear to handle this pretty much at random.  In fact it shouldn't
    matter, because the hub driver turns on power to all ports when it
    binds to the root hub.  Straightening that out will be left for
    another day.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6e767bce0605..21e5f963f331 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -54,6 +54,17 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	u32			temp;
 	int			retval;
 
+	ehci->caps = hcd->regs;
+
+	/*
+	 * ehci_init() causes memory for DMA transfers to be
+	 * allocated.  Thus, any vendor-specific workarounds based on
+	 * limiting the type of memory used for DMA transfers must
+	 * happen before ehci_setup() is called.
+	 *
+	 * Most other workarounds can be done either before or after
+	 * init and reset; they are located here too.
+	 */
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_TOSHIBA_2:
 		/* celleb's companion chip */
@@ -66,20 +77,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 		}
 		break;
-	}
-
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-        /* ehci_init() causes memory for DMA transfers to be
-         * allocated.  Thus, any vendor-specific workarounds based on
-         * limiting the type of memory used for DMA transfers must
-         * happen before ehci_init() is called. */
-	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_NVIDIA:
 		/* NVidia reports that certain chips don't handle
 		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
@@ -95,61 +92,28 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 				ehci_warn(ehci, "can't enable NVidia "
 					"workaround for >2GB RAM\n");
 			break;
-		}
-		break;
-	}
 
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	if ((pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x7808) ||
-	    (pdev->vendor == PCI_VENDOR_ID_ATI && pdev->device == 0x4396)) {
-		/* EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
-		 * read/write memory space which does not belong to it when
-		 * there is NULL pointer with T-bit set to 1 in the frame list
-		 * table. To avoid the issue, the frame list link pointer
-		 * should always contain a valid pointer to a inactive qh.
+		/* Some NForce2 chips have problems with selective suspend;
+		 * fixed in newer silicon.
 		 */
-		ehci->use_dummy_qh = 1;
-		ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI "
-				"dummy qh workaround\n");
-	}
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	switch (pdev->vendor) {
-	case PCI_VENDOR_ID_NEC:
-		ehci->need_io_watchdog = 0;
+		case 0x0068:
+			if (pdev->revision < 0xa4)
+				ehci->no_selective_suspend = 1;
+			break;
+		}
 		break;
 	case PCI_VENDOR_ID_INTEL:
-		ehci->need_io_watchdog = 0;
 		ehci->fs_i_thresh = 1;
 		if (pdev->device == 0x27cc) {
 			ehci->broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");
 		}
-		if (pdev->device == 0x0806 || pdev->device == 0x0811
-				|| pdev->device == 0x0829) {
-			ehci_info(ehci, "disable lpm for langwell/penwell\n");
-			ehci->has_lpm = 0;
-		}
-		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB) {
+		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd->has_tt = 1;
-			tdi_reset(ehci);
-		}
 		break;
 	case PCI_VENDOR_ID_TDI:
-		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
+		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI)
 			hcd->has_tt = 1;
-			tdi_reset(ehci);
-		}
 		break;
 	case PCI_VENDOR_ID_AMD:
 		/* AMD PLL quirk */
@@ -161,28 +125,17 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			retval = -EIO;
 			goto done;
 		}
-		break;
-	case PCI_VENDOR_ID_NVIDIA:
-		switch (pdev->device) {
-		/* Some NForce2 chips have problems with selective suspend;
-		 * fixed in newer silicon.
-		 */
-		case 0x0068:
-			if (pdev->revision < 0xa4)
-				ehci->no_selective_suspend = 1;
-			break;
 
-		/* MCP89 chips on the MacBookAir3,1 give EPROTO when
-		 * fetching device descriptors unless LPM is disabled.
-		 * There are also intermittent problems enumerating
-		 * devices with PPCD enabled.
+		/*
+		 * EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
+		 * read/write memory space which does not belong to it when
+		 * there is NULL pointer with T-bit set to 1 in the frame list
+		 * table. To avoid the issue, the frame list link pointer
+		 * should always contain a valid pointer to a inactive qh.
 		 */
-		case 0x0d9d:
-			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
-			ehci->has_lpm = 0;
-			ehci->has_ppcd = 0;
-			ehci->command &= ~CMD_PPCEE;
-			break;
+		if (pdev->device == 0x7808) {
+			ehci->use_dummy_qh = 1;
+			ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");
 		}
 		break;
 	case PCI_VENDOR_ID_VIA:
@@ -203,6 +156,18 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		/* AMD PLL quirk */
 		if (usb_amd_find_chipset_info())
 			ehci->amd_pll_fix = 1;
+
+		/*
+		 * EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
+		 * read/write memory space which does not belong to it when
+		 * there is NULL pointer with T-bit set to 1 in the frame list
+		 * table. To avoid the issue, the frame list link pointer
+		 * should always contain a valid pointer to a inactive qh.
+		 */
+		if (pdev->device == 0x4396) {
+			ehci->use_dummy_qh = 1;
+			ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");
+		}
 		/* SB600 and old version of SB700 have a bug in EHCI controller,
 		 * which causes usb devices lose response in some cases.
 		 */
@@ -231,6 +196,40 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
+	retval = ehci_setup(hcd);
+	if (retval)
+		return retval;
+
+	/* These workarounds need to be applied after ehci_setup() */
+	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_NEC:
+		ehci->need_io_watchdog = 0;
+		break;
+	case PCI_VENDOR_ID_INTEL:
+		ehci->need_io_watchdog = 0;
+		if (pdev->device == 0x0806 || pdev->device == 0x0811
+				|| pdev->device == 0x0829) {
+			ehci_info(ehci, "disable lpm for langwell/penwell\n");
+			ehci->has_lpm = 0;
+		}
+		break;
+	case PCI_VENDOR_ID_NVIDIA:
+		switch (pdev->device) {
+		/* MCP89 chips on the MacBookAir3,1 give EPROTO when
+		 * fetching device descriptors unless LPM is disabled.
+		 * There are also intermittent problems enumerating
+		 * devices with PPCD enabled.
+		 */
+		case 0x0d9d:
+			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
+			ehci->has_lpm = 0;
+			ehci->has_ppcd = 0;
+			ehci->command &= ~CMD_PPCEE;
+			break;
+		}
+		break;
+	}
+
 	/* optional debug port, normally in the first BAR */
 	temp = pci_find_capability(pdev, 0x0a);
 	if (temp) {
@@ -238,7 +237,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		temp >>= 16;
 		if ((temp & (3 << 13)) == (1 << 13)) {
 			temp &= 0x1fff;
-			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
+			ehci->debug = hcd->regs + temp;
 			temp = ehci_readl(ehci, &ehci->debug->control);
 			ehci_info(ehci, "debug port %d%s\n",
 				HCS_DEBUG_PORT(ehci->hcs_params),
@@ -250,8 +249,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 	}
 
-	ehci_reset(ehci);
-
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
 	temp &= 0x0f;
@@ -275,10 +272,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	}
 
 	/* Serial Bus Release Number is at PCI 0x60 offset */
-	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 	if (pdev->vendor == PCI_VENDOR_ID_STMICRO
 	    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)
-		ehci->sbrn = 0x20; /* ConneXT has no sbrn register */
+		;	/* ConneXT has no sbrn register */
+	else
+		pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
 	/* Keep this around for a while just in case some EHCI
 	 * implementation uses legacy PCI PM support.  This test

commit c5cf9212a368d88fe1e25797699b167f6daa64a5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 28 11:19:02 2012 -0400

    EHCI: centralize controller suspend/resume
    
    This patch (as1563) removes a lot of duplicated code by moving the
    EHCI controller suspend/resume routines into the core driver, where
    the various platform drivers can invoke them as needed.
    
    Not only does this simplify these platform drivers, this also makes it
    easier for other platform drivers to add suspend/resume support in the
    future.
    
    Note: The patch does not touch the ehci-fsl.c file, because its
    approach to suspend and resume is so different from all the others.
    It will have to be handled specially by its maintainer.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 123481793a47..6e767bce0605 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -331,29 +331,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 
 static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned long		flags;
-	int			rc = 0;
-
-	if (time_before(jiffies, ehci->next_statechange))
-		msleep(10);
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible.  The PM and USB cores make sure that
-	 * the root hub is either suspended or stopped.
-	 */
-	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
-	spin_lock_irqsave (&ehci->lock, flags);
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
-	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-	// could save FLADJ in case of Vaux power loss
-	// ... we'd only use it to handle clock skew
-
-	return rc;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
@@ -402,54 +380,8 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (usb_is_intel_switchable_ehci(pdev))
 		ehci_enable_xhci_companion();
 
-	// maybe restore FLADJ
-
-	if (time_before(jiffies, ehci->next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* If CF is still set and we aren't resuming from hibernation
-	 * then we maintained PCI Vaux power.
-	 * Just undo the effect of ehci_pci_suspend().
-	 */
-	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
-				!hibernated) {
-		int	mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-		if (!hcd->self.root_hub->do_remote_wakeup)
-			mask &= ~STS_PCD;
-		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
-		ehci_readl(ehci, &ehci->regs->intr_enable);
-		return 0;
-	}
-
-	usb_root_hub_lost_power(hcd->self.root_hub);
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having let BIOS kick in during reboot.
-	 */
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-	(void) ehci_pci_reinit(ehci, pdev);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&ehci->lock);
-	if (ehci->reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&ehci->lock);
-
-	ehci_writel(ehci, ehci->command, &ehci->regs->command);
-	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
-	ehci->rh_state = EHCI_RH_SUSPENDED;
+	if (ehci_resume(hcd, hibernated) != 0)
+		(void) ehci_pci_reinit(ehci, pdev);
 	return 0;
 }
 #endif

commit c2fb8a3fa25513de8fedb38509b1f15a5bbee47b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jun 13 11:20:19 2012 -0400

    USB: add NO_D3_DURING_SLEEP flag and revert 151b61284776be2
    
    This patch (as1558) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    A similar patch has already been applied as commit
    151b61284776be2d6f02d48c23c3625678960b97 (USB: EHCI: fix crash during
    suspend on ASUS computers).  The patch supersedes that one and reverts
    it.  There are two differences:
    
            The old patch added the flag at the USB level; this patch
            adds it at the PCI level.
    
            The old patch applied to all chipsets with the same vendor,
            subsystem vendor, and product IDs; this patch makes an
            exception for a known-good system (based on DMI information).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: DÃ¢niel Fraga <fragabr@gmail.com>
    Tested-by: Andrey Rahmatullin <wrar@wrar.name>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bc94d7bf072d..123481793a47 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -144,14 +144,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			hcd->has_tt = 1;
 			tdi_reset(ehci);
 		}
-		if (pdev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK) {
-			/* EHCI #1 or #2 on 6 Series/C200 Series chipset */
-			if (pdev->device == 0x1c26 || pdev->device == 0x1c2d) {
-				ehci_info(ehci, "broken D3 during system sleep on ASUS\n");
-				hcd->broken_pci_sleep = 1;
-				device_set_wakeup_capable(&pdev->dev, false);
-			}
-		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {

commit 8e192910d96615a32646b8978b201b650f62ef34
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 21 08:54:43 2012 -0700

    Revert "USB: EHCI: work around bug in the Philips ISP1562 controller"
    
    This reverts commit 1996e6c572969a8cf6d7fa97eef621219acd94a9.
    
    It turned out to not be needed, now that the real fix has been
    committed.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 4baafa3e80b2..bc94d7bf072d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -97,13 +97,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			break;
 		}
 		break;
-
-	case PCI_VENDOR_ID_PHILIPS:
-		/*
-		 * Philips controllers set HCC_PGM_FRAMELISTLEN, but
-		 * they don't implement schedule sizes shorter than 1024.
-		 */
-		ehci->sched_size_bug = 1;
 	}
 
 	/* cache this readonly data; minimize chip reads */

commit 1996e6c572969a8cf6d7fa97eef621219acd94a9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 14 13:48:16 2012 -0400

    USB: EHCI: work around bug in the Philips ISP1562 controller
    
    This patch (as1556) works around a bug in the Philips ISP1562 EHCI
    controller.  Although the controller claims to support frame-list
    lengths smaller than the default of 1024 for its periodic schedule, in
    fact smaller values don't work.  A new quirk flag is added to indicate
    when the bug is present, and if it is then the schedule size is left
    at the default value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bc94d7bf072d..4baafa3e80b2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -97,6 +97,13 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			break;
 		}
 		break;
+
+	case PCI_VENDOR_ID_PHILIPS:
+		/*
+		 * Philips controllers set HCC_PGM_FRAMELISTLEN, but
+		 * they don't implement schedule sizes shorter than 1024.
+		 */
+		ehci->sched_size_bug = 1;
 	}
 
 	/* cache this readonly data; minimize chip reads */

commit 61906313bd41cde2f9aaa14e461e6108d3e71aaa
Merge: 3aa2ae74ba63 d48b97b403d2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 09:03:39 2012 -0700

    Merge 3.4-rc6 into usb-next
    
    This resolves the conflict with:
            drivers/usb/host/ehci-tegra.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c12443ab8eba71a658fae4572147e56d1f84f66
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Feb 9 15:55:13 2012 -0800

    xhci: Add Lynx Point to list of Intel switchable hosts.
    
    The upcoming Intel Lynx Point chipset includes an xHCI host controller
    that can have ports switched from the EHCI host controller, just like
    the Intel Panther Point xHCI host.  This time, ports from both EHCI
    hosts can be switched to the xHCI host controller.  The PCI config
    registers to do the port switching are in the exact same place in the
    xHCI PCI configuration registers, with the same semantics.
    
    Hooray for shipping patches for next-gen hardware before the current gen
    hardware is even available for purchase!
    
    This patch should be backported to stable kernels as old as 3.0,
    that contain commit 69e848c2090aebba5698a1620604c7dccb448684
    "Intel xhci: Support EHCI/xHCI port switching."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 01bb7241d6ef..123481793a47 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -360,7 +360,9 @@ static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
 {
 	return pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&
 		pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		pdev->device == 0x1E26;
+		(pdev->device == 0x1E26 ||
+		 pdev->device == 0x8C2D ||
+		 pdev->device == 0x8C26);
 }
 
 static void ehci_enable_xhci_companion(void)

commit 151b61284776be2d6f02d48c23c3625678960b97
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 24 14:07:22 2012 -0400

    USB: EHCI: fix crash during suspend on ASUS computers
    
    This patch (as1545) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    This fixes Bugzilla #42728.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Tested-by: Andrey Rahmatullin <wrar@wrar.name>
    Tested-by: Oleksij Rempel (fishor) <bug-track@fisher-privat.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 01bb7241d6ef..fe8dc069164e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -144,6 +144,14 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			hcd->has_tt = 1;
 			tdi_reset(ehci);
 		}
+		if (pdev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK) {
+			/* EHCI #1 or #2 on 6 Series/C200 Series chipset */
+			if (pdev->device == 0x1c26 || pdev->device == 0x1c2d) {
+				ehci_info(ehci, "broken D3 during system sleep on ASUS\n");
+				hcd->broken_pci_sleep = 1;
+				device_set_wakeup_capable(&pdev->dev, false);
+			}
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {

commit 3a0bac0676d7f433c12389fc0bc574f048f921c3
Author: Alessandro Rubini <rubini@gnudd.com>
Date:   Fri Jan 6 13:33:28 2012 +0100

    usb: add support for STA2X11 host driver
    
    Signed-off-by: Alessandro Rubini <rubini@gnudd.com>
    Acked-by: Giancarlo Asnaghi <giancarlo.asnaghi@st.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f4b627d343ac..01bb7241d6ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -276,6 +276,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
+	if (pdev->vendor == PCI_VENDOR_ID_STMICRO
+	    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)
+		ehci->sbrn = 0x20; /* ConneXT has no sbrn register */
 
 	/* Keep this around for a while just in case some EHCI
 	 * implementation uses legacy PCI PM support.  This test
@@ -526,6 +529,9 @@ static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
+	}, {
+	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),
+	.driver_data = (unsigned long) &ehci_pci_hc_driver,
 	},
 	{ /* end: all zeroes */ }
 };

commit 68aa95d5d4de31c9348c1628ffa85c805305ebc5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 12 10:39:14 2011 -0400

    EHCI: workaround for MosChip controller bug
    
    This patch (as1489) works around a hardware bug in MosChip EHCI
    controllers.  Evidently when one of these controllers increments the
    frame-index register, it changes the three low-order bits (the
    microframe counter) before changing the higher order bits (the frame
    counter).  If the register is read at just the wrong time, the value
    obtained is too low by 8.
    
    When the appropriate quirk flag is set, we work around this problem by
    reading the frame-index register a second time if the first value's
    three low-order bits are all 0.  This gives the hardware a chance to
    finish updating the register, yielding the correct value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Jason N Pitt <jpitt@fhcrc.org>
    CC: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 8311de7c0a75..f4b627d343ac 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -224,6 +224,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			pci_dev_put(p_smbus);
 		}
 		break;
+	case PCI_VENDOR_ID_NETMOS:
+		/* MosChip frame-index-register bug */
+		ehci_info(ehci, "applying MosChip frame-index workaround\n");
+		ehci->frame_index_bug = 1;
+		break;
 	}
 
 	/* optional debug port, normally in the first BAR */

commit e8799906045302776b35b66b16495c575db3b69c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 18 16:31:30 2011 -0400

    USB: EHCI: remove usages of hcd->state
    
    This patch (as1483) improves the ehci-hcd driver family by getting rid
    of the reliance on the hcd->state variable.  It has no clear owner and
    it isn't protected by the usual HCD locks.  In its place, the patch
    adds a new, private ehci->rh_state field to record the state of the
    root hub.
    
    Along the way, the patch removes a couple of lines containing
    redundant assignments to the state variable.  Also, the QUIESCING
    state simply gets changed to the RUNNING state, because the driver
    doesn't make any distinction between them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1102ce65a3a9..8311de7c0a75 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -439,7 +439,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd->state = HC_STATE_SUSPENDED;
+	ehci->rh_state = EHCI_RH_SUSPENDED;
 	return 0;
 }
 #endif

commit 69e848c2090aebba5698a1620604c7dccb448684
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Feb 22 09:57:15 2011 -0800

    Intel xhci: Support EHCI/xHCI port switching.
    
    The Intel Panther Point chipsets contain an EHCI and xHCI host controller
    that shares some number of skew-dependent ports.  These ports can be
    switched from the EHCI to the xHCI host (and vice versa) by a hardware MUX
    that is controlled by registers in the xHCI PCI configuration space.  The
    USB 3.0 SuperSpeed terminations on the xHCI ports can be controlled
    separately from the USB 2.0 data wires.
    
    This switchover mechanism is there to support users who do a custom
    install of certain non-Linux operating systems that don't have official
    USB 3.0 support.  By default, the ports are under EHCI, SuperSpeed
    terminations are off, and USB 3.0 devices will show up under the EHCI
    controller at reduced speeds.  (This was more palatable for the marketing
    folks than having completely dead USB 3.0 ports if no xHCI drivers are
    available.)  Users should be able to turn on xHCI by default through a
    BIOS option, but users are happiest when they don't have to change random
    BIOS settings.
    
    This patch introduces a driver method to switchover the ports from EHCI to
    xHCI before the EHCI driver finishes PCI enumeration.  We want to switch
    the ports over before the USB core has the chance to enumerate devices
    under EHCI, or boot from USB mass storage will fail if the boot device
    connects under EHCI first, and then gets disconnected when the port
    switches over to xHCI.
    
    Add code to the xHCI PCI quirk to switch the ports from EHCI to xHCI.  The
    PCI quirks code will run before any other PCI probe function is called, so
    this avoids the issue with boot devices.
    
    Another issue is with BIOS behavior during system resume from hibernate.
    If the BIOS doesn't support xHCI, it may switch the devices under EHCI to
    allow use of the USB keyboard, mice, and mass storage devices.  It's
    supposed to remember the value of the port routing registers and switch
    them back when the OS attempts to take control of the xHCI host controller,
    but we all know not to trust BIOS writers.
    
    Make both the xHCI driver and the EHCI driver attempt to switchover the
    ports in their PCI resume functions.  We can't guarantee which PCI device
    will be resumed first, so this avoids any race conditions.  Writing a '1'
    to an already set port switchover bit or a '0' to a cleared port switchover
    bit should have no effect.
    
    The xHCI PCI configuration registers will be documented in the EDS-level
    chipset spec, which is not public yet.  I have permission from legal and
    the Intel chipset group to release this patch early to allow good Linux
    support at product launch.  I've tried to document the registers as much
    as possible, so please let me know if anything is unclear.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 660b80a75cac..1102ce65a3a9 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -348,11 +348,50 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	return rc;
 }
 
+static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
+{
+	return pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&
+		pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		pdev->device == 0x1E26;
+}
+
+static void ehci_enable_xhci_companion(void)
+{
+	struct pci_dev		*companion = NULL;
+
+	/* The xHCI and EHCI controllers are not on the same PCI slot */
+	for_each_pci_dev(companion) {
+		if (!usb_is_intel_switchable_xhci(companion))
+			continue;
+		usb_enable_xhci_ports(companion);
+		return;
+	}
+}
+
 static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 
+	/* The BIOS on systems with the Intel Panther Point chipset may or may
+	 * not support xHCI natively.  That means that during system resume, it
+	 * may switch the ports back to EHCI so that users can use their
+	 * keyboard to select a kernel from GRUB after resume from hibernate.
+	 *
+	 * The BIOS is supposed to remember whether the OS had xHCI ports
+	 * enabled before resume, and switch the ports back to xHCI when the
+	 * BIOS/OS semaphore is written, but we all know we can't trust BIOS
+	 * writers.
+	 *
+	 * Unconditionally switch the ports back to xHCI after a system resume.
+	 * We can't tell whether the EHCI or xHCI controller will be resumed
+	 * first, so we have to do the port switchover in both drivers.  Writing
+	 * a '1' to the port switchover registers should have no effect if the
+	 * port was already switched over.
+	 */
+	if (usb_is_intel_switchable_ehci(pdev))
+		ehci_enable_xhci_companion();
+
 	// maybe restore FLADJ
 
 	if (time_before(jiffies, ehci->next_statechange))

commit c430131a02d677aa708f56342c1565edfdacb3c0
Author: Jan Andersson <jan@gaisler.com>
Date:   Tue May 3 20:11:57 2011 +0200

    USB: EHCI: Support controllers with big endian capability regs
    
    The two first HC capability registers (CAPLENGTH and HCIVERSION)
    are defined as one 8-bit and one 16-bit register. Most HC
    implementations have selected to treat these registers as part
    of a 32-bit register, giving the same layout for both big and
    small endian systems.
    
    This patch adds a new quirk, big_endian_capbase, to support
    controllers with big endian register interfaces that treat
    HCIVERSION and CAPLENGTH as individual registers.
    
    Signed-off-by: Jan Andersson <jan@gaisler.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d5eaea7caf89..660b80a75cac 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -70,7 +70,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 
 	ehci->caps = hcd->regs;
 	ehci->regs = hcd->regs +
-		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
 
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");

commit ad93562bdeecdded7d02eaaaf1aa5705ab57b1b7
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Mar 1 14:57:05 2011 +0800

    USB host: Move AMD PLL quirk to pci-quirks.c
    
    This patch moves the AMD PLL quirk code in OHCI/EHCI driver to pci-quirks.c,
    and exports the functions to be used by xHCI driver later.
    
    AMD PLL quirk disable the optional PM feature inside specific
    SB700/SB800/Hudson-2/3 platforms under the following conditions:
    
    1. If an isochronous device is connected to OHCI/EHCI/xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    Without AMD PLL quirk, USB isochronous stream may stutter or have breaks
    occasionally, which greatly impair the performance of audio/video streams.
    
    Currently AMD PLL quirk is implemented in OHCI and EHCI driver, and will be
    added to xHCI driver too. They are doing similar things actually, so move
    the quirk code to pci-quirks.c, which has several advantages:
    
    1. Remove duplicate defines and functions in OHCI/EHCI (and xHCI) driver and
       make them cleaner;
    2. AMD chipset information will be probed only once and then stored.
       Currently they're probed during every OHCI/EHCI initialization, move
       the detect code to pci-quirks.c saves the repeat detect cost;
    3. Build up synchronization among OHCI/EHCI/xHCI driver. In current
       code, every host controller enable/disable PLL only according to
       its own status, and may enable PLL while there is still isoc transfer on
       other HCs. Move the quirk to pci-quirks.c prevents this issue.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alex He <alex.he@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 07bb982e59f6..d5eaea7caf89 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -44,42 +44,6 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	return 0;
 }
 
-static int ehci_quirk_amd_hudson(struct ehci_hcd *ehci)
-{
-	struct pci_dev *amd_smbus_dev;
-	u8 rev = 0;
-
-	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI, 0x4385, NULL);
-	if (amd_smbus_dev) {
-		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
-		if (rev < 0x40) {
-			pci_dev_put(amd_smbus_dev);
-			amd_smbus_dev = NULL;
-			return 0;
-		}
-	} else {
-		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x780b, NULL);
-		if (!amd_smbus_dev)
-			return 0;
-		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
-		if (rev < 0x11 || rev > 0x18) {
-			pci_dev_put(amd_smbus_dev);
-			amd_smbus_dev = NULL;
-			return 0;
-		}
-	}
-
-	if (!amd_nb_dev)
-		amd_nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);
-
-	ehci_info(ehci, "QUIRK: Enable exception for AMD Hudson ASPM\n");
-
-	pci_dev_put(amd_smbus_dev);
-	amd_smbus_dev = NULL;
-
-	return 1;
-}
-
 /* called during probe() after chip reset completes */
 static int ehci_pci_setup(struct usb_hcd *hcd)
 {
@@ -138,9 +102,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
-	if (ehci_quirk_amd_hudson(ehci))
-		ehci->amd_l1_fix = 1;
-
 	retval = ehci_halt(ehci);
 	if (retval)
 		return retval;
@@ -191,6 +152,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_AMD:
+		/* AMD PLL quirk */
+		if (usb_amd_find_chipset_info())
+			ehci->amd_pll_fix = 1;
 		/* AMD8111 EHCI doesn't work, according to AMD errata */
 		if (pdev->device == 0x7463) {
 			ehci_info(ehci, "ignoring AMD8111 (errata)\n");
@@ -236,6 +200,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_ATI:
+		/* AMD PLL quirk */
+		if (usb_amd_find_chipset_info())
+			ehci->amd_pll_fix = 1;
 		/* SB600 and old version of SB700 have a bug in EHCI controller,
 		 * which causes usb devices lose response in some cases.
 		 */

commit 148fc55fd0449683a1d15bf219ad8d8b6fa17545
Author: Yin Kangkai <kangkai.yin@intel.com>
Date:   Fri Jan 28 12:04:35 2011 +0800

    USB: EHCI: fix scheduling while atomic during suspend
    
    There is a msleep with spin lock held during ehci pci suspend, which will
    cause kernel BUG: scheduling while atomic. Fix that.
    
    [  184.139620] BUG: scheduling while atomic: kworker/u:11/416/0x00000002
    [  184.139632] 4 locks held by kworker/u:11/416:
    [  184.139640]  #0:  (events_unbound){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139669]  #1:  ((&entry->work)){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139686]  #2:  (&__lockdep_no_validate__){+.+.+.}, at: [<c127cde3>] __device_suspend+0x2c/0x154
    [  184.139706]  #3:  (&(&ehci->lock)->rlock){-.-...}, at: [<c132f3d8>] ehci_pci_suspend+0x35/0x7b
    [  184.139725] Modules linked in: serio_raw pegasus joydev mrst_gfx(C) battery
    [  184.139748] irq event stamp: 52
    [  184.139753] hardirqs last  enabled at (51): [<c14fdaac>] mutex_lock_nested+0x258/0x293
    [  184.139766] hardirqs last disabled at (52): [<c14fe7b4>] _raw_spin_lock_irqsave+0xf/0x3e
    [  184.139777] softirqs last  enabled at (0): [<c10371c1>] copy_process+0x3d2/0x109d
    [  184.139789] softirqs last disabled at (0): [<  (null)>]   (null)
    [  184.139802] Pid: 416, comm: kworker/u:11 Tainted: G         C  2.6.37-6.3-adaptation-oaktrail #37
    [  184.139809] Call Trace:
    [  184.139820]  [<c102eeff>] __schedule_bug+0x5e/0x65
    [  184.139829]  [<c14fbca5>] schedule+0xac/0xc4c
    [  184.139840]  [<c11d4845>] ? string+0x37/0x8b
    [  184.139853]  [<c1044f21>] ? lock_timer_base+0x1f/0x3e
    [  184.139863]  [<c14fe7da>] ? _raw_spin_lock_irqsave+0x35/0x3e
    [  184.139876]  [<c1061590>] ? trace_hardirqs_off+0xb/0xd
    [  184.139885]  [<c14fccdc>] schedule_timeout+0x283/0x2d9
    [  184.139896]  [<c104516f>] ? process_timeout+0x0/0xa
    [  184.139906]  [<c14fcd47>] schedule_timeout_uninterruptible+0x15/0x17
    [  184.139916]  [<c104566a>] msleep+0x10/0x16
    [  184.139926]  [<c132f316>] ehci_adjust_port_wakeup_flags+0x69/0xf6
    [  184.139937]  [<c132f3eb>] ehci_pci_suspend+0x48/0x7b
    [  184.139946]  [<c1326587>] suspend_common+0x52/0xbb
    [  184.139956]  [<c1326625>] hcd_pci_suspend+0x26/0x28
    [  184.139967]  [<c11e7182>] pci_pm_suspend+0x5f/0xd0
    [  184.139976]  [<c127ca3a>] pm_op+0x5d/0xf0
    [  184.139986]  [<c127ceac>] __device_suspend+0xf5/0x154
    [  184.139996]  [<c127d2c8>] async_suspend+0x16/0x3a
    [  184.140006]  [<c1058f54>] async_run_entry_fn+0x89/0x111
    [  184.140016]  [<c104deb6>] process_one_work+0x295/0x4cb
    [  184.140026]  [<c1058ecb>] ? async_run_entry_fn+0x0/0x111
    [  184.140036]  [<c104e3d0>] worker_thread+0x17f/0x298
    [  184.140045]  [<c104e251>] ? worker_thread+0x0/0x298
    [  184.140055]  [<c105277f>] kthread+0x64/0x69
    [  184.140064]  [<c105271b>] ? kthread+0x0/0x69
    [  184.140075]  [<c1002efa>] kernel_thread_helper+0x6/0x1a
    
    Signed-off-by: Yin Kangkai <kangkai.yin@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    CC: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bed07d4aab06..07bb982e59f6 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -367,8 +367,8 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	 * mark HW unaccessible.  The PM and USB cores make sure that
 	 * the root hub is either suspended or stopped.
 	 */
-	spin_lock_irqsave (&ehci->lock, flags);
 	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
+	spin_lock_irqsave (&ehci->lock, flags);
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 

commit baab93afc2844b68d57b0dcca5e1d34c5d7cf411
Author: Alex He <alex.he@amd.com>
Date:   Tue Dec 21 17:45:46 2010 +0800

    USB: EHCI: ASPM quirk of ISOC on AMD Hudson
    
    AMD Hudson also needs the same ASPM quirk as SB800
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 76179c39c0e3..bed07d4aab06 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -44,28 +44,35 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	return 0;
 }
 
-static int ehci_quirk_amd_SB800(struct ehci_hcd *ehci)
+static int ehci_quirk_amd_hudson(struct ehci_hcd *ehci)
 {
 	struct pci_dev *amd_smbus_dev;
 	u8 rev = 0;
 
 	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI, 0x4385, NULL);
-	if (!amd_smbus_dev)
-		return 0;
-
-	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
-	if (rev < 0x40) {
-		pci_dev_put(amd_smbus_dev);
-		amd_smbus_dev = NULL;
-		return 0;
+	if (amd_smbus_dev) {
+		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+		if (rev < 0x40) {
+			pci_dev_put(amd_smbus_dev);
+			amd_smbus_dev = NULL;
+			return 0;
+		}
+	} else {
+		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x780b, NULL);
+		if (!amd_smbus_dev)
+			return 0;
+		pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+		if (rev < 0x11 || rev > 0x18) {
+			pci_dev_put(amd_smbus_dev);
+			amd_smbus_dev = NULL;
+			return 0;
+		}
 	}
 
 	if (!amd_nb_dev)
 		amd_nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);
-	if (!amd_nb_dev)
-		ehci_err(ehci, "QUIRK: unable to get AMD NB device\n");
 
-	ehci_info(ehci, "QUIRK: Enable AMD SB800 L1 fix\n");
+	ehci_info(ehci, "QUIRK: Enable exception for AMD Hudson ASPM\n");
 
 	pci_dev_put(amd_smbus_dev);
 	amd_smbus_dev = NULL;
@@ -131,7 +138,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
-	if (ehci_quirk_amd_SB800(ehci))
+	if (ehci_quirk_amd_hudson(ehci))
 		ehci->amd_l1_fix = 1;
 
 	retval = ehci_halt(ehci);

commit 36facadd9ea98f8415d0dbb63e0763b7ee9d3911
Merge: 2faa83e2a519 0b83ae960cd7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 16 10:05:06 2010 -0800

    Merge branch 'usb-next' into musb-merge
    
    * usb-next: (132 commits)
      USB: uas: Use GFP_NOIO instead of GFP_KERNEL in I/O submission path
      USB: uas: Ensure we only bind to a UAS interface
      USB: uas: Rename sense pipe and sense urb to status pipe and status urb
      USB: uas: Use kzalloc instead of kmalloc
      USB: uas: Fix up the Sense IU
      usb: musb: core: kill unneeded #include's
      DA8xx: assign name to MUSB IRQ resource
      usb: gadget: g_ncm added
      usb: gadget: f_ncm.c added
      usb: gadget: u_ether: prepare for NCM
      usb: pch_udc: Fix setup transfers with data out
      usb: pch_udc: Fix compile error, warnings and checkpatch warnings
      usb: add ab8500 usb transceiver driver
      USB: gadget: Implement runtime PM for MSM bus glue driver
      USB: gadget: Implement runtime PM for ci13xxx gadget
      USB: gadget: Add USB controller driver for MSM SoC
      USB: gadget: Introduce ci13xxx_udc_driver struct
      USB: gadget: Initialize ci13xxx gadget device's coherent DMA mask
      USB: gadget: Fix "scheduling while atomic" bugs in ci13xxx_udc
      USB: gadget: Separate out PCI bus code from ci13xxx_udc
      ...

commit 05570297ecbe834b1756b522412b68eaffb9ab11
Author: Alex He <alex.he@amd.com>
Date:   Tue Dec 7 10:10:08 2010 +0800

    USB: EHCI: ASPM quirk of ISOC on AMD SB800
    
    When ASPM PM Feature is enabled on UMI link, devices that use ISOC stream of
    data transfer may be exposed to longer latency causing less than optimal per-
    formance of the device. The longer latencies are normal and are due to link
    wake time coming out of low power state which happens frequently to save
    power when the link is not active.
    The following code will make exception for certain features of ASPM to be by
    passed and keep the logic normal state only when the ISOC device is connected
    and active. This change will allow the device to run at optimal performance
    yet minimize the impact on overall power savings.
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 56c78e93440f..35a533e4c01d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -44,6 +44,35 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	return 0;
 }
 
+static int ehci_quirk_amd_SB800(struct ehci_hcd *ehci)
+{
+	struct pci_dev *amd_smbus_dev;
+	u8 rev = 0;
+
+	amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI, 0x4385, NULL);
+	if (!amd_smbus_dev)
+		return 0;
+
+	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+	if (rev < 0x40) {
+		pci_dev_put(amd_smbus_dev);
+		amd_smbus_dev = NULL;
+		return 0;
+	}
+
+	if (!amd_nb_dev)
+		amd_nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);
+	if (!amd_nb_dev)
+		ehci_err(ehci, "QUIRK: unable to get AMD NB device\n");
+
+	ehci_info(ehci, "QUIRK: Enable AMD SB800 L1 fix\n");
+
+	pci_dev_put(amd_smbus_dev);
+	amd_smbus_dev = NULL;
+
+	return 1;
+}
+
 /* called during probe() after chip reset completes */
 static int ehci_pci_setup(struct usb_hcd *hcd)
 {
@@ -102,6 +131,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
+	if (ehci_quirk_amd_SB800(ehci))
+		ehci->amd_l1_fix = 1;
+
 	retval = ehci_halt(ehci);
 	if (retval)
 		return retval;

commit a85b4e7f4481c5a1ca89fa63c9c871151965075e
Author: Brian J. Tarricone <brian@tarricone.org>
Date:   Sun Nov 21 21:15:52 2010 -0800

    USB: ehci: disable LPM and PPCD for nVidia MCP89 chips
    
    Tested on MacBookAir3,1.  Without this, we get EPROTO errors when
    fetching device config descriptors.
    
    Signed-off-by: Brian Tarricone <brian@tarricone.org>
    Reported-by: Benoit Gschwind <gschwind@gnu-log.net>
    Tested-by: Edgar Hucek <gimli@dark-green.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 01bb72b71832..655f3c9f88bf 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -161,6 +161,18 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			if (pdev->revision < 0xa4)
 				ehci->no_selective_suspend = 1;
 			break;
+
+		/* MCP89 chips on the MacBookAir3,1 give EPROTO when
+		 * fetching device descriptors unless LPM is disabled.
+		 * There are also intermittent problems enumerating
+		 * devices with PPCD enabled.
+		 */
+		case 0x0d9d:
+			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
+			ehci->has_lpm = 0;
+			ehci->has_ppcd = 0;
+			ehci->command &= ~CMD_PPCEE;
+			break;
 		}
 		break;
 	case PCI_VENDOR_ID_VIA:

commit 4f6838436915fdc281173bfd5bef6d8ab5cb1a7f
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Wed Nov 17 07:43:09 2010 -0800

    USB: ce4100: Add support for CE4100 EHCI IP block to EHCI driver
    
    This patch adds support for the EHCI IP block present on the Intel
    CE4100.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a1e8d273103f..56c78e93440f 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -22,6 +22,9 @@
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
 
+/* defined here to avoid adding to pci_ids.h for single instance use */
+#define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
+
 /*-------------------------------------------------------------------------*/
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -124,6 +127,10 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			ehci_info(ehci, "disable lpm for langwell/penwell\n");
 			ehci->has_lpm = 0;
 		}
+		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB) {
+			hcd->has_tt = 1;
+			tdi_reset(ehci);
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {

commit 3d091a6f703906c5680855ff29bd94d051c8c6d8
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Nov 8 17:58:35 2010 +0800

    USB: EHCI: AMD periodic frame list table quirk
    
    On AMD SB700/SB800/Hudson-2/3 platforms, USB EHCI controller may read/write
    to memory space not allocated to USB controller if there is longer than
    normal latency on DMA read encountered. In this condition the exposure will
    be encountered only if the driver has following format of Periodic Frame
    List link pointer structure:
    
    For any idle periodic schedule, the Frame List link pointers that have the
    T-bit set to 1 intending to terminate the use of frame list link pointer
    as a physical memory pointer.
    
    Idle periodic schedule Frame List Link pointer shoule be in the following
    format to avoid the issue:
    
    Frame list link pointer should be always contains a valid pointer to a
    inactive QHead with T-bit set to 0.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a1e8d273103f..01bb72b71832 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -103,6 +103,19 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
+	if ((pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x7808) ||
+	    (pdev->vendor == PCI_VENDOR_ID_ATI && pdev->device == 0x4396)) {
+		/* EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
+		 * read/write memory space which does not belong to it when
+		 * there is NULL pointer with T-bit set to 1 in the frame list
+		 * table. To avoid the issue, the frame list link pointer
+		 * should always contain a valid pointer to a inactive qh.
+		 */
+		ehci->use_dummy_qh = 1;
+		ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI "
+				"dummy qh workaround\n");
+	}
+
 	/* data structure init */
 	retval = ehci_init(hcd);
 	if (retval)

commit fc9282506114d4be188a464af2d373db31dd781c
Author: Alek Du <alek.du@intel.com>
Date:   Mon Sep 6 14:50:57 2010 +0100

    USB: EHCI: Disable langwell/penwell LPM capability
    
    We have to do so due to HW limitation.
    
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 58b72d741d93..a1e8d273103f 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -119,6 +119,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			ehci->broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");
 		}
+		if (pdev->device == 0x0806 || pdev->device == 0x0811
+				|| pdev->device == 0x0829) {
+			ehci_info(ehci, "disable lpm for langwell/penwell\n");
+			ehci->has_lpm = 0;
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {

commit ae68a83bdc1971cb02fefc7a686ba6d077065e71
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 14 11:03:23 2010 -0400

    USB: EHCI: remove PCI assumption
    
    This patch (as1405) fixes a small bug in ehci-hcd's isochronous
    scheduler.  Not all EHCI controllers are PCI, and the code shouldn't
    assume that they are.  Instead, introduce a special flag for
    controllers which need to delay iso scheduling for full-speed devices
    beyond the scheduling threshold.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    CC: David Brownell <david-b@pacbell.net>
    CC: stable <stable@kernel.org>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f555e4f35a04..58b72d741d93 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -114,6 +114,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci->need_io_watchdog = 0;
+		ehci->fs_i_thresh = 1;
 		if (pdev->device == 0x27cc) {
 			ehci->broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");

commit 4147200d25c423e627ab4487530b3d9f2ef829c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 25 14:02:14 2010 -0400

    USB: add do_wakeup parameter for PCI HCD suspend
    
    This patch (as1385) adds a "do_wakeup" parameter to the pci_suspend
    method used by PCI-based host controller drivers.  ehci-hcd in
    particular needs to know whether or not to enable wakeup when
    suspending a controller.  Although that information is currently
    available through device_may_wakeup(), when support is added for
    runtime suspend this will no longer be true.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a307d550bdaf..f555e4f35a04 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -277,7 +277,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static int ehci_pci_suspend(struct usb_hcd *hcd)
+static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned long		flags;
@@ -291,7 +291,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd)
 	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave (&ehci->lock, flags);
-	ehci_prepare_ports_for_controller_suspend(ehci);
+	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 

commit 48f24970144479c29b8cee6d2e1dbedf6dcf9cfb
Author: Alek Du <alek.du@intel.com>
Date:   Fri Jun 4 15:47:55 2010 +0800

    USB: EHCI: EHCI 1.1 addendum: Basic LPM feature support
    
    With this patch, the LPM capable EHCI host controller can put device
    into L1 sleep state which is a mode that can enter/exit quickly, and
    reduce power consumption.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d43d176161aa..a307d550bdaf 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -361,6 +361,22 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 }
 #endif
 
+static int ehci_update_device(struct usb_hcd *hcd, struct usb_device *udev)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int rc = 0;
+
+	if (!udev->parent) /* udev is root hub itself, impossible */
+		rc = -1;
+	/* we only support lpm device connected to root hub yet */
+	if (ehci->has_lpm && !udev->parent->parent) {
+		rc = ehci_lpm_set_da(ehci, udev->devnum, udev->portnum);
+		if (!rc)
+			rc = ehci_lpm_check(ehci, udev->portnum);
+	}
+	return rc;
+}
+
 static const struct hc_driver ehci_pci_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"EHCI Host Controller",
@@ -407,6 +423,11 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
 
+	/*
+	 * call back when device connected and addressed
+	 */
+	.update_device =	ehci_update_device,
+
 	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
 };
 

commit 16032c4f5b291af541e9114a09ea20ff5a0dc474
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 12 18:21:35 2010 -0400

    USB: EHCI: fix controller wakeup flag settings during suspend
    
    This patch (as1380) fixes a bug in the wakeup settings for EHCI host
    controllers.  When the controller is suspended, if it isn't enabled
    for remote wakeup then we have to turn off all the port wakeup flags.
    Disabling PCI PME# isn't good enough, because some systems (Intel)
    evidently use alternate wakeup signalling paths.
    
    In addition, the patch improves the handling of the Intel Moorestown
    hardware by performing various power-up and power-down delays just
    once instead of once for each port (i.e., the delays are moved outside
    of the port loops).  This requires extra code, but the total delay
    time is reduced.
    
    There are also a few additional minor cleanups.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Ondrej Zary <linux@rainbow-software.org>
    CC: Alek Du <alek.du@intel.com>
    CC: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d120059bbbf7..d43d176161aa 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -287,23 +287,15 @@ static int ehci_pci_suspend(struct usb_hcd *hcd)
 		msleep(10);
 
 	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd->state is manipulated outside of
-	 * any locks =P But that will be a different fix.
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave (&ehci->lock, flags);
-	if (hcd->state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
+	ehci_prepare_ports_for_controller_suspend(ehci);
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
- bail:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
 	// could save FLADJ in case of Vaux power loss
@@ -333,6 +325,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 				!hibernated) {
 		int	mask = INTR_MASK;
 
+		ehci_prepare_ports_for_controller_resume(ehci);
 		if (!hcd->self.root_hub->do_remote_wakeup)
 			mask &= ~STS_PCD;
 		ehci_writel(ehci, mask, &ehci->regs->intr_enable);

commit 3681d8f3ee8f47b60b4621a3d80f8d1d39e7185b
Author: David Miller <davem@davemloft.net>
Date:   Tue Apr 6 18:26:03 2010 -0700

    USB: ehci: Elide I/O watchdog on NEC parts
    
    I've been running with this patch on my Niagara2 boxes for some time
    and have not seen any ill effects yet.  Maybe we can stash this into
    the USB tree to get exposure for some time in -next and if anything
    crops up we can simply revert?
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ead5f4f2aa5a..d120059bbbf7 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -109,6 +109,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		return retval;
 
 	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_NEC:
+		ehci->need_io_watchdog = 0;
+		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci->need_io_watchdog = 0;
 		if (pdev->device == 0x27cc) {

commit ee4ecb8ac63a5792bec448037d4b82ec4144f94b
Author: Oliver Neukum <oliver@neukum.org>
Date:   Fri Nov 27 15:17:59 2009 +0100

    USB: work around for EHCI with quirky periodic schedules
    
    a quirky chipset needs periodic schedules to run for a minimum
    time before they can be disabled again. This enforces the requirement
    with a time stamp and a calculated delay
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 378861b9d79a..ead5f4f2aa5a 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -111,6 +111,10 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_INTEL:
 		ehci->need_io_watchdog = 0;
+		if (pdev->device == 0x27cc) {
+			ehci->broken_periodic = 1;
+			ehci_info(ehci, "using broken periodic workaround\n");
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {

commit 8d053c79f22462f55c02c8083580730b922cf7b4
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 20 15:39:54 2009 -0500

    USB: ehci-dbgp,ehci: Allow early or late use of the dbgp device
    
    If the EHCI debug port is initialized and in use, the EHCI host
    controller driver must follow two rules.
    
    1) If the EHCI host driver issues a controller reset, the debug
       controller driver re-initialization must get called after the reset
       is completed.
    
    2) The EHCI host driver should ignore any requests to the physical
       EHCI debug port when the EHCI debug port is in use.
    
    The code to check for the debug port was moved from ehci_pci_reinit()
    to ehci_pci_setup because it must get called prior to ehci_reset()
    which will clear the debug port registers.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: dbrownell@users.sourceforge.net
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a88ad517ec5c..378861b9d79a 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -27,28 +27,8 @@
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 {
-	u32			temp;
 	int			retval;
 
-	/* optional debug port, normally in the first BAR */
-	temp = pci_find_capability(pdev, 0x0a);
-	if (temp) {
-		pci_read_config_dword(pdev, temp, &temp);
-		temp >>= 16;
-		if ((temp & (3 << 13)) == (1 << 13)) {
-			temp &= 0x1fff;
-			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
-			temp = ehci_readl(ehci, &ehci->debug->control);
-			ehci_info(ehci, "debug port %d%s\n",
-				HCS_DEBUG_PORT(ehci->hcs_params),
-				(temp & DBGP_ENABLED)
-					? " IN USE"
-					: "");
-			if (!(temp & DBGP_ENABLED))
-				ehci->debug = NULL;
-		}
-	}
-
 	/* we expect static quirk code to handle the "extended capabilities"
 	 * (currently just BIOS handoff) allowed starting with EHCI 0.96
 	 */
@@ -195,6 +175,25 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
+	/* optional debug port, normally in the first BAR */
+	temp = pci_find_capability(pdev, 0x0a);
+	if (temp) {
+		pci_read_config_dword(pdev, temp, &temp);
+		temp >>= 16;
+		if ((temp & (3 << 13)) == (1 << 13)) {
+			temp &= 0x1fff;
+			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
+			temp = ehci_readl(ehci, &ehci->debug->control);
+			ehci_info(ehci, "debug port %d%s\n",
+				HCS_DEBUG_PORT(ehci->hcs_params),
+				(temp & DBGP_ENABLED)
+					? " IN USE"
+					: "");
+			if (!(temp & DBGP_ENABLED))
+				ehci->debug = NULL;
+		}
+	}
+
 	ehci_reset(ehci);
 
 	/* at least the Genesys GL880S needs fixup here */

commit 403dbd36739e344d2d25f56ebbe342248487bd48
Author: Alek Du <alek.du@intel.com>
Date:   Mon Jul 13 17:30:41 2009 +0800

    USB: EHCI: add need_io_watchdog flag to ehci_hcd
    
    Basically the io watchdog is only useful for those quirk HCDs. For most
    good ones, it only brings unnecessary wakeups.  At least, I know the
    Intel EHCI HCDs should turn off the flag.
    
    Signed-off-by: Alek Du <alek.du@intel.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index b5b83c43898a..a88ad517ec5c 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -129,6 +129,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		return retval;
 
 	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_INTEL:
+		ehci->need_io_watchdog = 0;
+		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
 			hcd->has_tt = 1;

commit 411c94038594b2a3fd123d09bdec3fe2500e383d
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Tue Jul 7 15:24:23 2009 +0530

    trivial: fix typo "for for" in multiple files
    
    trivial: fix typo "for for" in multiple files
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index c2f1b7df918c..b5b83c43898a 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -242,7 +242,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	 * System suspend currently expects to be able to suspend the entire
 	 * device tree, device-at-a-time.  If we failed selective suspend
 	 * reports, system suspend would fail; so the root hub code must claim
-	 * success.  That's lying to usbcore, and it matters for for runtime
+	 * success.  That's lying to usbcore, and it matters for runtime
 	 * PM scenarios with selective suspend and remote wakeup...
 	 */
 	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))

commit 914b701280a76f96890ad63eb0fa99bf204b961c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:47:30 2009 -0400

    USB: EHCI: use the new clear_tt_buffer interface
    
    This patch (as1256) changes ehci-hcd and all the other drivers in the
    EHCI family to make use of the new clear_tt_buffer callbacks.  When a
    Clear-TT-Buffer request is in progress for a QH, the QH is not allowed
    to be linked into the async schedule until the request is finished.
    At that time, if there are any URBs queued for the QH, it is linked
    into the async schedule.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f3683e1da161..c2f1b7df918c 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -404,6 +404,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
+
+	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
 };
 
 /*-------------------------------------------------------------------------*/

commit b18ffd49e86102a9ed0a1cc83fdafe3891e844e5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 27 18:21:56 2009 -0400

    USB: EHCI: update toggle state for linked QHs
    
    This patch (as1245) fixes a bug in ehci-hcd.  When an URB is queued
    for an endpoint whose QH is already in the LINKED state, the QH
    doesn't get refreshed.  As a result, if usb_clear_halt() was called
    during the time that the QH was linked but idle, the data toggle value
    in the QH doesn't get reset.
    
    The symptom is that after a clear_halt, data gets lost and transfers
    time out.  This problem is starting to show up now because the
    "ehci-hcd unlink speedups" patch causes QHs with no queued URBs to
    remain linked for a suitable time.
    
    The patch utilizes the new endpoint_reset mechanism to fix the
    problem.  When an endpoint is reset, the new method forcibly unlinks
    the QH (if necessary) and safely updates the toggle value.  This
    allows qh_update() to be simplified and avoids using usb_device's
    toggle bits in a rather unintuitive way.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Tested-by: David <david@unsolicited.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e74948898f76..f3683e1da161 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -388,6 +388,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.urb_enqueue =		ehci_urb_enqueue,
 	.urb_dequeue =		ehci_urb_dequeue,
 	.endpoint_disable =	ehci_endpoint_disable,
+	.endpoint_reset =	ehci_endpoint_reset,
 
 	/*
 	 * scheduling support

commit 6ec4beb5c701f728548b587082c83ef62eb36035
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 27 13:33:41 2009 -0400

    USB: new flag for resume-from-hibernation
    
    This patch (as1237) changes the way the PCI host controller drivers
    avoid retaining bogus hardware states during resume-from-hibernation.
    Previously we had reset the hardware as part of preparing to reinstate
    the memory image.  But we can do better now with the new PM framework,
    since we know exactly which resume operations are from hibernation.
    
    The pci_resume method is changed to accept a flag indicating whether
    the system is resuming from hibernation.  When this flag is set, the
    drivers will reset the hardware to get rid of any existing state.
    
    Similarly, the pci_suspend method is changed to remove the
    pm_message_t argument.  It's no longer needed, since no special action
    has to be taken when preparing to reinstate the memory image.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 8172383e8908..e74948898f76 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -268,7 +268,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
+static int ehci_pci_suspend(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned long		flags;
@@ -293,12 +293,6 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW) {
-		ehci_halt(ehci);
-		ehci_reset(ehci);
-	}
-
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  bail:
 	spin_unlock_irqrestore (&ehci->lock, flags);
@@ -309,7 +303,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	return rc;
 }
 
-static int ehci_pci_resume(struct usb_hcd *hcd)
+static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
@@ -322,10 +316,12 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* Mark hardware accessible again as we are out of D3 state by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
-	/* If CF is still set, we maintained PCI Vaux power.
+	/* If CF is still set and we aren't resuming from hibernation
+	 * then we maintained PCI Vaux power.
 	 * Just undo the effect of ehci_pci_suspend().
 	 */
-	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
+				!hibernated) {
 		int	mask = INTR_MASK;
 
 		if (!hcd->self.root_hub->do_remote_wakeup)
@@ -335,7 +331,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 		return 0;
 	}
 
-	ehci_dbg(ehci, "lost power, restarting\n");
 	usb_root_hub_lost_power(hcd->self.root_hub);
 
 	/* Else reset, to cope with power loss or flush-to-storage

commit abb306416a7ec2386678de0da6b632a6cb068af0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 27 13:33:24 2009 -0400

    USB: move PCI host controllers to new PM framework
    
    This patch (as1236) converts the USB PCI power management routines
    over to the new PM framework.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 5aa8bce90e1f..8172383e8908 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -429,10 +429,11 @@ static struct pci_driver ehci_pci_driver = {
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+	.shutdown = 	usb_hcd_pci_shutdown,
 
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
+#ifdef CONFIG_PM_SLEEP
+	.driver =	{
+		.pm =	&usb_hcd_pci_pm_ops
+	},
 #endif
-	.shutdown = 	usb_hcd_pci_shutdown,
 };

commit 929a22a558429bd22001d6b41cf31c233c68a5e2
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:16 2009 -0700

    dma-mapping: replace all DMA_31BIT_MASK macro with DMA_BIT_MASK(31)
    
    Replace all DMA_31BIT_MASK macro with DMA_BIT_MASK(31)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index abb9a7706ec7..5aa8bce90e1f 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -108,7 +108,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		case 0x00d8:	/* CK8 */
 		case 0x00e8:	/* CK8S */
 			if (pci_set_consistent_dma_mask(pdev,
-						DMA_31BIT_MASK) < 0)
+						DMA_BIT_MASK(31)) < 0)
 				ehci_warn(ehci, "can't enable NVidia "
 					"workaround for >2GB RAM\n");
 			break;

commit 3494252d5644993f407a45f01c3e8ad5ae38f93c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 13 23:41:12 2009 +0100

    USB/PCI: Fix resume breakage of controllers behind cardbus bridges
    
    If a USB PCI controller is behind a cardbus bridge, we are trying to
    restore its configuration registers too early, before the cardbus
    bridge is operational.  To fix this, call pci_restore_state() from
    usb_hcd_pci_resume() and remove usb_hcd_pci_resume_early() which is
    no longer necessary (the configuration spaces of USB controllers that
    are not behind cardbus bridges will be restored by the PCI PM core
    with interrupts disabled anyway).
    
    This patch fixes the regression from 2.6.28 tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12659
    
    [ Side note: the proper long-term fix is probably to just force the
      unplug event at suspend time instead of doing a plug/unplug at resume
      time, but this patch is fine regardless  - Linus ]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Miles Lane <miles.lane@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bb21fb0a4969..abb9a7706ec7 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -432,7 +432,6 @@ static struct pci_driver ehci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
-	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 	.shutdown = 	usb_hcd_pci_shutdown,

commit a15d95a003fae154121733f049dd25e9c13dbef3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 20 01:26:56 2009 +0100

    USB: Fix suspend-resume of PCI USB controllers
    
    Commit a0d4922da2e4ccb0973095d8d29f36f6b1b5f703
    (USB: fix up suspend and resume for PCI host controllers) attempted
    to fix the suspend-resume of PCI USB controllers, but unfortunately
    it did that incorrectly and interrupts are left enabled by the USB
    controllers' ->suspend_late() callback as a result.  This leads to
    serious problems during suspend which are very difficult to debug.
    
    Fix the issue by removing the ->suspend_late() callback of PCI
    USB controllers and moving the code from there to the ->suspend()
    callback executed with interrupts enabled.  Additionally, make
    the ->resume() callback of PCI USB controllers execute
    pci_enable_wake(dev, PCI_D0, false) to disable wake-up from the
    full power state (PCI_D0).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Tested-by: "Jeff Chua" <jeff.chua.linux@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: "Zdenek Kabelac" <zdenek.kabelac@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 9faa5c8fe025..bb21fb0a4969 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -432,7 +432,6 @@ static struct pci_driver ehci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
-	.suspend_late =	usb_hcd_pci_suspend_late,
 	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif

commit bcca06efea883bdf3803a0bb0ffa60f26730387d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 13 11:35:54 2009 -0500

    USB: don't enable wakeup by default for PCI host controllers
    
    This patch (as1199) changes the initial wakeup settings for PCI USB
    host controllers.  The controllers are marked as capable of waking the
    system, but wakeup is not enabled by default.
    
    It turns out that enabling wakeup for USB host controllers has a lot
    of bad consequences.  As the simplest example, if a USB mouse or
    keyboard is unplugged immediately after the computer is put to sleep,
    the unplug will cause the system to wake back up again!  We are better
    off marking them as wakeup-capable and leaving wakeup disabled.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Rafael J. Wysocki <rjw@sisk.pl>
    CC: David Brownell <david-b@pacbell.net>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bdc6e86e1f8b..9faa5c8fe025 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -230,7 +230,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		pci_read_config_word(pdev, 0x62, &port_wake);
 		if (port_wake & 0x0001) {
 			dev_warn(&pdev->dev, "Enabling legacy PCI PM\n");
-			device_init_wakeup(&pdev->dev, 1);
+			device_set_wakeup_capable(&pdev->dev, 1);
 		}
 	}
 

commit 6fd9086a518d4f14213a32fe6c9ac17fabebbc1e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 17 17:20:38 2008 -0500

    USB: automatically enable wakeup for PCI host controllers
    
    This patch (as1193b) enables wakeup during initialization for all PCI
    host controllers, and it removes some code (and comments!) that are no
    longer needed now that the PCI core automatically initializes wakeup
    settings for all new devices.
    
    The idea is that the bus should initialize wakeup, and the bus glue
    or controller driver should enable it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6af47a0937b8..bdc6e86e1f8b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -219,15 +219,19 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-	/* Workaround current PCI init glitch:  wakeup bits aren't
-	 * being set from PCI PM capability.
+	/* Keep this around for a while just in case some EHCI
+	 * implementation uses legacy PCI PM support.  This test
+	 * can be removed on 17 Dec 2009 if the dev_warn() hasn't
+	 * been triggered by then.
 	 */
 	if (!device_can_wakeup(&pdev->dev)) {
 		u16	port_wake;
 
 		pci_read_config_word(pdev, 0x62, &port_wake);
-		if (port_wake & 0x0001)
+		if (port_wake & 0x0001) {
+			dev_warn(&pdev->dev, "Enabling legacy PCI PM\n");
 			device_init_wakeup(&pdev->dev, 1);
+		}
 	}
 
 #ifdef	CONFIG_USB_SUSPEND

commit a0d4922da2e4ccb0973095d8d29f36f6b1b5f703
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 17 15:06:03 2008 -0500

    USB: fix up suspend and resume for PCI host controllers
    
    This patch (as1192) rearranges the USB PCI host controller suspend and
    resume and resume routines:
    
            Use pci_wake_from_d3() for enabling and disabling wakeup,
            instead of pci_enable_wake().
    
            Carry out the actual state change while interrupts are
            disabled.
    
            Change the order of the preparations to agree with the
            general recommendation for PCI devices, instead of
            messing around with the wakeup settings while the device
            is in D3.
    
                    In .suspend:
                            Call the underlying driver to disable IRQ
                                    generation;
                            pci_wake_from_d3(device_may_wakeup());
                            pci_disable_device();
    
                    In .suspend_late:
                            pci_save_state();
                            pci_set_power_state(D3hot);
                            (for PPC_PMAC) Disable ASIC clocks
    
                    In .resume_early:
                            (for PPC_PMAC) Enable ASIC clocks
                            pci_set_power_state(D0);
                            pci_restore_state();
    
                    In .resume:
                            pci_enable_device();
                            pci_set_master();
                            pci_wake_from_d3(0);
                            Call the underlying driver to reenable IRQ
                                    generation
    
            Add the necessary .suspend_late and .resume_early method
            pointers to the PCI host controller drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 36864f958444..6af47a0937b8 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -428,6 +428,8 @@ static struct pci_driver ehci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
+	.suspend_late =	usb_hcd_pci_suspend_late,
+	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 	.shutdown = 	usb_hcd_pci_shutdown,

commit 0a99e8ac430a27825bd055719765fd0d65cd797f
Author: Shane Huang <shane.huang@amd.com>
Date:   Tue Nov 25 15:12:33 2008 +0800

    USB: fix SB600 USB subsystem hang bug
    
    This patch is required for all AMD SB600 revisions to avoid USB subsystem hang
    symptom. The USB subsystem hang symptom is observed when the system has
    multiple USB devices connected to it. In some cases a USB hub may be required
    to observe this symptom.
    
    Reported in bugzilla as #11599, the similar patch for SB700 old revision is:
    commit b09bc6cbae4dd3a2d35722668ef2c502a7b8b093
    
    Reported-by: raffaele <ralfconn@tele2.it>
    Tested-by: Roman Mamedov <roman@rm.pp.ru>
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 9d0ea573aef6..36864f958444 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -169,18 +169,21 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_ATI:
-		/* SB700 old version has a bug in EHCI controller,
+		/* SB600 and old version of SB700 have a bug in EHCI controller,
 		 * which causes usb devices lose response in some cases.
 		 */
-		if (pdev->device == 0x4396) {
+		if ((pdev->device == 0x4386) || (pdev->device == 0x4396)) {
 			p_smbus = pci_get_device(PCI_VENDOR_ID_ATI,
 						 PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 						 NULL);
 			if (!p_smbus)
 				break;
 			rev = p_smbus->revision;
-			if ((rev == 0x3a) || (rev == 0x3b)) {
+			if ((pdev->device == 0x4386) || (rev == 0x3a)
+			    || (rev == 0x3b)) {
 				u8 tmp;
+				ehci_info(ehci, "applying AMD SB600/SB700 USB "
+					"freeze workaround\n");
 				pci_read_config_byte(pdev, 0x53, &tmp);
 				pci_write_config_byte(pdev, 0x53, tmp | (1<<3));
 			}

commit b09bc6cbae4dd3a2d35722668ef2c502a7b8b093
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Nov 14 11:42:29 2008 +0800

    USB: fix SB700 usb subsystem hang bug
    
    This patch is required for AMD SB700 south bridge revision A12 and A13 to avoid
    USB subsystem hang symptom. The USB subsystem hang symptom is observed when the
    system has multiple USB devices connected to it. In some cases a USB hub may be
    required to observe this symptom.
    
    This patch works around the problem by correcting the internal register setting
    that will help by changing the behavior of the internal logic to avoid the
    USB subsystem hang issue. The change in the behavior of the logic does not
    impact the normal operation of the USB subsystem.
    
    Reported-by: Volker Armin Hemmann <volker.armin.hemmann@tu-clausthal.de>
    Tested-by: Volker Armin Hemmann <volker.armin.hemmann@tu-clausthal.de>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index c46a58f9181d..9d0ea573aef6 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -66,6 +66,8 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	struct pci_dev		*p_smbus;
+	u8			rev;
 	u32			temp;
 	int			retval;
 
@@ -166,6 +168,25 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			pci_write_config_byte(pdev, 0x4b, tmp | 0x20);
 		}
 		break;
+	case PCI_VENDOR_ID_ATI:
+		/* SB700 old version has a bug in EHCI controller,
+		 * which causes usb devices lose response in some cases.
+		 */
+		if (pdev->device == 0x4396) {
+			p_smbus = pci_get_device(PCI_VENDOR_ID_ATI,
+						 PCI_DEVICE_ID_ATI_SBX00_SMBUS,
+						 NULL);
+			if (!p_smbus)
+				break;
+			rev = p_smbus->revision;
+			if ((rev == 0x3a) || (rev == 0x3b)) {
+				u8 tmp;
+				pci_read_config_byte(pdev, 0x53, &tmp);
+				pci_write_config_byte(pdev, 0x53, tmp | (1<<3));
+			}
+			pci_dev_put(p_smbus);
+		}
+		break;
 	}
 
 	ehci_reset(ehci);

commit 3a31155cfff0935e4b178f3dca733d2d60d2eb8d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 20 16:58:29 2008 -0400

    USB: EHCI: suppress unwanted error messages
    
    This patch (as1096) fixes an annoying problem: When a full-speed or
    low-speed device is plugged into an EHCI controller, it fails to
    enumerate at high speed and then is handed over to the companion
    controller.  But usbcore logs a misleading and unwanted error message
    when the high-speed enumeration fails.
    
    The patch adds a new HCD method, port_handed_over, which asks whether
    a port has been handed over to a companion controller.  If it has, the
    error message is suppressed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6ff453f935e7..c46a58f9181d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -379,6 +379,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/

commit a8e5177583e975fc1f7c621c93956f494df9b979
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 20 16:58:11 2008 -0400

    USB: EHCI: fix up root-hub TT mess
    
    This patch (as1095) cleans up the HCD glue and several of the EHCI
    bus-glue files.  The ehci->is_tdi_rh_tt flag is redundant, since it
    means the same thing as the hcd->has_tt flag, so it is removed and the
    other flag used in its place.
    
    Some of the bus-glue files didn't get the relinquish_port method added
    to their hc_driver structures.  Although that routine currently
    doesn't do anything for controllers with an integrated TT, in the
    future it might.  So the patch adds it where it is missing.
    
    Lastly, some of the bus-glue files have erroneous entries for their
    hc_driver's suspend and resume methods.  These method pointers are
    specific to PCI and shouldn't be used otherwise.
    
    (The patch also includes an invisible whitespace fix.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 5bb7f6bb13f3..6ff453f935e7 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -129,7 +129,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
-			ehci->is_tdi_rh_tt = 1;
 			hcd->has_tt = 1;
 			tdi_reset(ehci);
 		}
@@ -379,7 +378,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.hub_control =		ehci_hub_control,
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
-	.relinquish_port = 	ehci_relinquish_port,
+	.relinquish_port =	ehci_relinquish_port,
 };
 
 /*-------------------------------------------------------------------------*/

commit aff6d18f95bb81b2d07994372c8edcc2c2b41180
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 18 11:11:26 2008 -0400

    USB: fix compile problems in ehci-hcd
    
    This patch (as1072) fixes some recently-introduced compile problems
    that show up in ehci-hcd when CONFIG_PM is turned off.
    
            PORT_WAKE_BITS needs to be defined always.
    
            ehci_port_power() is called during initialization by all the
            EHCI variants other than the PCI version, in which it is
            "defined but not used".  So add a call to it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 88dad4b53131..5bb7f6bb13f3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -222,6 +222,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif
 
+	ehci_port_power(ehci, 1);
 	retval = ehci_pci_reinit(ehci, pdev);
 done:
 	return retval;

commit 58a97ffeb2297f154659f339d77eb3f32c4d8b3e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 14 12:17:10 2008 -0400

    USB: HCDs use the do_remote_wakeup flag
    
    When a USB device is suspended, whether or not it is enabled for
    remote wakeup depends on the device_may_wakeup() setting.  The setting
    is then saved in the do_remote_wakeup flag.
    
    Later on, however, the device_may_wakeup() value can change because of
    user activity.  So when testing whether a suspended device is or
    should be enabled for remote wakeup, we should always test
    do_remote_wakeup instead of device_may_wakeup().  This patch (as1076)
    makes that change for root hubs in several places.
    
    The patch also adjusts uhci-hcd so that when an autostopped controller
    is suspended, the remote wakeup setting agrees with the value recorded
    in the root hub's do_remote_wakeup flag.
    
    And the patch adjusts ehci-hcd so that wakeup events on selectively
    suspended ports (i.e., the bus itself isn't suspended) don't turn on
    the PME# wakeup signal.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a0afc78b273e..88dad4b53131 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -300,7 +300,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
-		if (!device_may_wakeup(&hcd->self.root_hub->dev))
+		if (!hcd->self.root_hub->do_remote_wakeup)
 			mask &= ~STS_PCD;
 		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
 		ehci_readl(ehci, &ehci->regs->intr_enable);

commit 7be7d7418776a41badce7ca00246e270d408e4b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 3 18:03:06 2008 -0400

    USB: clarify usage of hcd->suspend/resume methods
    
    The .suspend and .resume method pointers in struct usb_hcd have not
    been fully understood by host-controller driver writers.  They are
    meant for use with PCI controllers; other platform-specific drivers
    generally should not refer to them.
    
    To try and clarify matters, this patch (as1065) renames those methods
    to .pci_suspend and .pci_resume.  It eliminates corresponding dead code
    and bogus references in the ohci-ssb and u132-hcd drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 7c8a2ccf78f1..a0afc78b273e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -353,8 +353,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.reset =		ehci_pci_setup,
 	.start =		ehci_run,
 #ifdef	CONFIG_PM
-	.suspend =		ehci_pci_suspend,
-	.resume =		ehci_pci_resume,
+	.pci_suspend =		ehci_pci_suspend,
+	.pci_resume =		ehci_pci_resume,
 #endif
 	.stop =			ehci_stop,
 	.shutdown =		ehci_shutdown,

commit 7329e211b987a493cbcfca0e98c60eb108ab42df
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 3 18:02:56 2008 -0400

    USB: root hubs don't lie about their number of TTs
    
    Currently EHCI root hubs enumerate with a bDeviceProtocol code
    indicating that they possess a Transaction Translator.  However the
    vast majority of controllers do not; they rely on a companion
    controller to handle full- and low-speed communications.  This patch
    (as1064) changes the root-hub device descriptor to match the actual
    situation.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 040bd8632eb3..7c8a2ccf78f1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -130,6 +130,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
 			ehci->is_tdi_rh_tt = 1;
+			hcd->has_tt = 1;
 			tdi_reset(ehci);
 		}
 		break;

commit 3bb1af5243d41af9518728445e9c9bd30dd47237
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 3 15:15:36 2008 -0500

    USB: EHCI: carry out port handover during each root-hub resume
    
    This patch (as1044) causes EHCI port handover for non-high-speed
    devices to occur during every root-hub resume, not just in cases where
    the controller lost power or was reset.  This is necessary because:
    
            When some machines go into suspend, they remove power from
            on-board USB devices while retaining suspend current for USB
            controllers.
    
            The user might well unplug a USB device while the system is
            suspended and then plug it back in before resuming.
    
    A corresponding change is made to the core resume routine; now
    high-speed root hubs will always be resumed when the system wakes up,
    even if they were suspended before the system went to sleep.  If this
    weren't done then EHCI port handover wouldn't work, since it is called
    when the EHCI root hub is resumed.
    
    Finally, a comment is added to the hub driver explaining the khubd has
    to be freezable; if it weren't frozen then it could interfere with
    port handover.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 72ccd56e36dd..040bd8632eb3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -329,7 +329,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
-	ehci_handover_companion_ports(ehci);
 
 	hcd->state = HC_STATE_SUSPENDED;
 	return 0;

commit 055b93c9e32a44acfe3e5e58b900f1e8fcd5f858
Author: Rene Herman <rene.herman@gmail.com>
Date:   Thu Mar 20 00:58:16 2008 -0700

    USB: ehci: stop vt6212 bus hogging
    
    The VIA VT6212 defaults to only waiting 1us between passes over EHCI's
    async ring, which hammers PCI badly ... and by preventing other devices
    from accessing the bus, causes problems like drops in IDE throughput,
    a problem that's been bugging users of those chips for several years.
    
    A (partial) datasheet for this chip eventually turned up, letting us
    see how to make it use a VIA-specific register to switch over to the
    the normal 10us value instead, as suggested by the EHCI specification
    Solution noted by Lev A. Melnikovsky.
    
    It's not clear whether this register exists on other VIA chips; we
    know that it's ineffective on the vt8235.  So this patch only applies
    to chips that seem to be incarnations of the (discrete) vt6212.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Lev A. Melnikovsky <melnikovsky@mail.ru>
    Tested-by: Alessandro Suardi <alessandro.suardi@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3ba01664f821..72ccd56e36dd 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -152,6 +152,20 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			break;
 		}
 		break;
+	case PCI_VENDOR_ID_VIA:
+		if (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {
+			u8 tmp;
+
+			/* The VT6212 defaults to a 1 usec EHCI sleep time which
+			 * hogs the PCI bus *badly*. Setting bit 5 of 0x4B makes
+			 * that sleep time use the conventional 10 usec.
+			 */
+			pci_read_config_byte(pdev, 0x4b, &tmp);
+			if (tmp & 0x20)
+				break;
+			pci_write_config_byte(pdev, 0x4b, tmp | 0x20);
+		}
+		break;
 	}
 
 	ehci_reset(ehci);

commit 07d29b63ef6b39963ab37818653284d861cf55af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 11 16:05:30 2007 -0500

    USB: EHCI: add separate IAA watchdog timer
    
    This patch (as1028) was mostly written by David Brownell; I made only
    a few changes (extra log info and a small bug fix -- which might
    account for why David's version had to be reverted).  It adds a new
    watchdog timer to the ehci-hcd driver to be used exclusively for
    detecting lost or missing IAA notifications.
    
    Previously a shared timer had been used, which may have led to some
    problems as reported by Christian Hoffmann.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 45e040000280..3ba01664f821 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -305,7 +305,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
+		end_unlink_async(ehci);
 	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 

commit 90da096ee46b682011b7d549e52b81cf9742e60b
Author: Balaji Rao <balajirrao@gmail.com>
Date:   Thu Nov 22 01:58:14 2007 +0530

    USB: force handover port to companion when hub_port_connect_change fails
    
    This patch hands over the port to the companion when the
    hub_port_connect_change fails.
    
    Signed-off-by: Balaji Rao <balajirrao@gmail.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ad0d4965f2fb..45e040000280 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -364,6 +364,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.hub_control =		ehci_hub_control,
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
+	.relinquish_port = 	ehci_relinquish_port,
 };
 
 /*-------------------------------------------------------------------------*/

commit af1c51fcb2aea23ec2dfe73b7d66515d1622e689
Author: Marcelo Tosatti <marcelo@kvack.org>
Date:   Mon Aug 20 18:13:27 2007 -0700

    USB: EHCI restart speedup
    
    It is not necessary to powerdown the ports on ehci_pci_reinit() when the
    chip reset already did that.  Removing this saves 20ms during restart
    after poweroff paths (which OLPC uses a lot).
    
    To ensure driver startup then behaves consistently, force a reset during
    driver startup.  (Not doing this was an accident of some previous changes
    to the init sequence.)
    
    Make the corresponding change in the PS3 support.  It's not clear what
    ehci-fsl should do here; it has similar code to the PS3.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: <rvinson@mvista.com>
    Acked-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a7816e392a85..ad0d4965f2fb 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -58,8 +58,6 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	if (!retval)
 		ehci_dbg(ehci, "MWI active\n");
 
-	ehci_port_power(ehci, 0);
-
 	return 0;
 }
 
@@ -156,8 +154,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
-	if (ehci_is_TDI(ehci))
-		ehci_reset(ehci);
+	ehci_reset(ehci);
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);

commit 383975d765523a56dc43a6cd6d52e9b376800cf2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:40 2007 -0400

    USB: EHCI, OHCI: handover changes
    
    This patch (as887) changes the way ehci-hcd and ohci-hcd handle a loss
    of VBUS power during suspend.  In order for the USB-persist facility
    to work correctly, it is necessary for low- and full-speed devices
    attached to a high-speed port to be handed back to the companion
    controller during resume processing.
    
    This entails three changes: adding code to ehci-hcd to perform the
    handover, removing code from ohci-hcd to turn off ports during
    root-hub reinit, and adding code to ohci-hcd to turn on ports during
    PCI controller resume.  (Other bus glue resume methods for platforms
    supporting high-speed controllers would need a similar change, if any
    existed.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 966965f72338..a7816e392a85 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -312,13 +312,14 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+	ehci_handover_companion_ports(ehci);
+
 	hcd->state = HC_STATE_SUSPENDED;
 	return 0;
 }

commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:36 2007 -0700

    PCI: Change all drivers to use pci_device->revision
    
    Instead of all drivers reading pci config space to get the revision
    ID, they can now use the pci_device->revision member.
    
    This exposes some issues where drivers where reading a word or a dword
    for the revision number, and adding useless error-handling around the
    read. Some drivers even just read it for no purpose of all.
    
    In devices where the revision ID is being copied over and used in what
    appears to be the equivalent of hotpath, I have left the copy code
    and the cached copy as not to influence the driver's performance.
    
    Compile tested with make all{yes,mod}config on x86_64 and i386.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 12edc723ec73..966965f72338 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -149,8 +149,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		 * fixed in newer silicon.
 		 */
 		case 0x0068:
-			pci_read_config_dword(pdev, PCI_REVISION_ID, &temp);
-			if ((temp & 0xff) < 0xa4)
+			if (pdev->revision < 0xa4)
 				ehci->no_selective_suspend = 1;
 			break;
 		}

commit 083522d76662cda71328df1f3d75e5a9057c7c9f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Dec 15 06:54:08 2006 +1100

    USB: Implement support for EHCI with big endian MMIO
    
    This patch implements supports for EHCI controllers whose MMIO
    registers are big endian and enables that functionality for
    the Toshiba SCC chip. It does _not_ add support for big endian
    in-memory data structures as this is not needed for that chip
    and I hope it will never be.
    
    The guts of the patch are to convert readl(...) to
    ehci_readl(ehci, ...) and similarly for register writes.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 4bc7970ba3ef..12edc723ec73 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -38,7 +38,7 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 		if ((temp & (3 << 13)) == (1 << 13)) {
 			temp &= 0x1fff;
 			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
-			temp = readl(&ehci->debug->control);
+			temp = ehci_readl(ehci, &ehci->debug->control);
 			ehci_info(ehci, "debug port %d%s\n",
 				HCS_DEBUG_PORT(ehci->hcs_params),
 				(temp & DBGP_ENABLED)
@@ -71,8 +71,24 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	u32			temp;
 	int			retval;
 
+	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_TOSHIBA_2:
+		/* celleb's companion chip */
+		if (pdev->device == 0x01b5) {
+#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+			ehci->big_endian_mmio = 1;
+#else
+			ehci_warn(ehci,
+				  "unsupported big endian Toshiba quirk\n");
+#endif
+		}
+		break;
+	}
+
 	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	ehci->regs = hcd->regs +
+		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");
 
@@ -101,7 +117,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	}
 
 	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
 	retval = ehci_halt(ehci);
 	if (retval)
@@ -235,8 +251,8 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 		rc = -EINVAL;
 		goto bail;
 	}
-	writel (0, &ehci->regs->intr_enable);
-	(void)readl(&ehci->regs->intr_enable);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 
 	/* make sure snapshot being resumed re-enumerates everything */
 	if (message.event == PM_EVENT_PRETHAW) {
@@ -270,13 +286,13 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* If CF is still set, we maintained PCI Vaux power.
 	 * Just undo the effect of ehci_pci_suspend().
 	 */
-	if (readl(&ehci->regs->configured_flag) == FLAG_CF) {
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
 		if (!device_may_wakeup(&hcd->self.root_hub->dev))
 			mask &= ~STS_PCD;
-		writel(mask, &ehci->regs->intr_enable);
-		readl(&ehci->regs->intr_enable);
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
 		return 0;
 	}
 
@@ -300,9 +316,9 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	writel(ehci->command, &ehci->regs->command);
-	writel(FLAG_CF, &ehci->regs->configured_flag);
-	readl(&ehci->regs->command);	/* unblock posted writes */
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 
 	hcd->state = HC_STATE_SUSPENDED;
 	return 0;

commit 8c03356a559ced6fa78931f498193f776d67e445
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 9 14:42:16 2006 -0500

    EHCI: Fix root-hub and port suspend/resume problems
    
    This patch (as738b) fixes numerous problems in the controller/root-hub
    suspend/resume/remote-wakeup support in ehci-hcd:
    
            The bus_resume() routine should wake up only the ports that
            were suspended by bus_suspend().  Ports that were already
            suspended should remain that way.
    
            The interrupt mask is used to detect loss of power in the
            bus_resume() routine (if the mask is 0 then power was lost).
            However bus_suspend() always sets the mask to 0.  Instead the
            mask should retain its normal value, with port-change-detect
            interrupts disabled if remote wakeup is turned off.
    
            The interrupt mask should be reset to its correct value at the
            end of bus_resume() regardless of whether power was lost.
    
            bus_resume() reinitializes the operational registers if power
            was lost.  However those registers are not in the aux power
            well, hence they can lose their values whenever the controller
            is put into D3.  They should always be reinitialized.
    
            When a port-change interrupt occurs and the root hub is
            suspended, the interrupt handler should request a root-hub
            resume instead of starting up the controller all by itself.
    
            There's no need for the interrupt handler to request a
            root-hub resume every time a suspended port sends a
            remote-wakeup request.
    
            The pci_resume() method doesn't need to check for connected
            ports when deciding whether or not to reset the controller.
            It can make that decision based on whether Vaux power was
            maintained.
    
            Even when the controller does not need to be reset,
            pci_resume() must undo the effect of pci_suspend() by
            re-enabling the interrupt mask.
    
            If power was lost, pci_resume() must not call ehci_run().
            At this point the root hub is still supposed to be suspended,
            not running.  It's enough to rewrite the command register and
            set the configured_flag.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e51c1ed81ac4..4bc7970ba3ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -257,9 +257,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned		port;
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
-	int			retval = -EINVAL;
 
 	// maybe restore FLADJ
 
@@ -269,27 +267,19 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* Mark hardware accessible again as we are out of D3 state by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
-	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
-	if (readl(&ehci->regs->configured_flag) != FLAG_CF)
-		goto restart;
-
-	/* If any port is suspended (or owned by the companion),
-	 * we know we can/must resume the HC (and mustn't reset it).
-	 * We just defer that to the root hub code.
+	/* If CF is still set, we maintained PCI Vaux power.
+	 * Just undo the effect of ehci_pci_suspend().
 	 */
-	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0; ) {
-		u32	status;
-		port--;
-		status = readl(&ehci->regs->port_status [port]);
-		if (!(status & PORT_POWER))
-			continue;
-		if (status & (PORT_SUSPEND | PORT_RESUME | PORT_OWNER)) {
-			usb_hcd_resume_root_hub(hcd);
-			return 0;
-		}
+	if (readl(&ehci->regs->configured_flag) == FLAG_CF) {
+		int	mask = INTR_MASK;
+
+		if (!device_may_wakeup(&hcd->self.root_hub->dev))
+			mask &= ~STS_PCD;
+		writel(mask, &ehci->regs->intr_enable);
+		readl(&ehci->regs->intr_enable);
+		return 0;
 	}
 
-restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
 	usb_root_hub_lost_power(hcd->self.root_hub);
 
@@ -307,13 +297,15 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 
-	/* restart; khubd will disconnect devices */
-	retval = ehci_run(hcd);
-
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	return retval;
+	writel(ehci->command, &ehci->regs->command);
+	writel(FLAG_CF, &ehci->regs->configured_flag);
+	readl(&ehci->regs->command);	/* unblock posted writes */
+
+	hcd->state = HC_STATE_SUSPENDED;
+	return 0;
 }
 #endif
 

commit 64f89798da35f43c6ef6afda0541e25034513458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 17 13:57:18 2006 -0700

    USB: revert EHCI VIA workaround patch
    
    This reverts 26f953fd884ea4879585287917f855c63c6b2666 which caused
    resume problems on the mac mini.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 35e3fab6fc4e..e51c1ed81ac4 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -303,7 +303,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
-		end_unlink_async (ehci);
+		ehci->reclaim_ready = 1;
 	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 08d0472d4f57..35e3fab6fc4e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -303,8 +303,8 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
-		end_unlink_async (ehci, NULL);
-	ehci_work(ehci, NULL);
+		end_unlink_async (ehci);
+	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 
 	/* restart; khubd will disconnect devices */

commit 26f953fd884ea4879585287917f855c63c6b2666
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Sep 18 17:03:16 2006 -0700

    USB: EHCI update VIA workaround
    
    This revamps handling of the hardware "async advance" IRQ, and its watchdog
    timer.  Basically it dis-entangles that important timeout from the others,
    simplifying the associated state and code to make it more robust.
    
    This reportedly improves behavior of EHCI on some systems with VIA chips,
    and AFAIK won't affect non-VIA hardware.  VIA systems need this code to
    recover from silcon bugs whereby the "async advance" IRQ isn't issued.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e6a3bcddd55b..08d0472d4f57 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -303,7 +303,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
+		end_unlink_async (ehci, NULL);
 	ehci_work(ehci, NULL);
 	spin_unlock_irq(&ehci->lock);
 

commit 64a21d025d3a979a8715f2ec7acabca7b5406c8a
Author: Aleksey Gorelov <dared1st@yahoo.com>
Date:   Tue Aug 8 17:24:08 2006 -0700

    USB: Properly unregister reboot notifier in case of failure in ehci hcd
    
    If some problem occurs during ehci startup, for instance, request_irq fails,
    echi hcd driver tries it best to cleanup, but fails to unregister reboot
    notifier, which in turn leads to crash on reboot/poweroff.
    
    The following patch resolves this problem by not using reboot notifiers
    anymore, but instead making ehci/ohci driver get its own shutdown method.  For
    PCI, it is done through pci glue, for everything else through platform driver
    glue.
    
    One downside: sa1111 does not use platform driver stuff, and does not have its
    own shutdown hook, so no 'shutdown' is called for it now.  I'm not sure if it
    is really necessary on that platform, though.
    
    Signed-off-by: Aleks Gorelov <dared1st@yahoo.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6967ab71e282..e6a3bcddd55b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -338,6 +338,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.resume =		ehci_pci_resume,
 #endif
 	.stop =			ehci_stop,
+	.shutdown =		ehci_shutdown,
 
 	/*
 	 * managing i/o requests and associated device resources
@@ -384,4 +385,5 @@ static struct pci_driver ehci_pci_driver = {
 	.suspend =	usb_hcd_pci_suspend,
 	.resume =	usb_hcd_pci_resume,
 #endif
+	.shutdown = 	usb_hcd_pci_shutdown,
 };

commit 185849991d592497e43bcd264c6152af1261ffe2
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:06 2006 -0700

    PM: USB HCDs use PM_EVENT_PRETHAW
    
    This teaches several USB host controller drivers to treat PRETHAW as a chip
    reset since the controller, and all devices connected to it, are no longer in
    states compatible with how the snapshotted suspend() left them.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index cadffacd945b..6967ab71e282 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -238,6 +238,12 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	writel (0, &ehci->regs->intr_enable);
 	(void)readl(&ehci->regs->intr_enable);
 
+	/* make sure snapshot being resumed re-enumerates everything */
+	if (message.event == PM_EVENT_PRETHAW) {
+		ehci_halt(ehci);
+		ehci_reset(ehci);
+	}
+
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  bail:
 	spin_unlock_irqrestore (&ehci->lock, flags);

commit 01cced250722d22d99c2342979490f93ca886521
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Tue Apr 11 10:07:16 2006 -0500

    [PATCH] USB: allow multiple types of EHCI controllers to be built as modules
    
    In some systems we may have both a platform EHCI controller and PCI EHCI
    controller.  Previously we couldn't build the EHCI support as a module due
    to conflicting module_init() calls in the code.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 648ddb52d579..cadffacd945b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -379,23 +379,3 @@ static struct pci_driver ehci_pci_driver = {
 	.resume =	usb_hcd_pci_resume,
 #endif
 };
-
-static int __init ehci_hcd_pci_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
-		hcd_name,
-		sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
-		sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
-
-	return pci_register_driver(&ehci_pci_driver);
-}
-module_init(ehci_hcd_pci_init);
-
-static void __exit ehci_hcd_pci_cleanup(void)
-{
-	pci_unregister_driver(&ehci_pci_driver);
-}
-module_exit(ehci_hcd_pci_cleanup);

commit c32ba30f76eb18b3d4449072fe9c345a9574796b
Author: Paul Serice <paul@serice.net>
Date:   Wed Jun 7 10:23:38 2006 -0700

    [PATCH] USB: EHCI works again on NVidia controllers with >2GB RAM
    
    From: Paul Serice <paul@serice.net>
    
    The workaround in commit f7201c3dcd7799f2aa3d6ec427b194225360ecee
    broke.  The work around requires memory for DMA transfers for some
    NVidia EHCI controllers to be below 2GB, but recent changes have
    caused some DMA memory to be allocated before the DMA mask is set.
    
    Signed-off-by: Paul Serice <paul@serice.net>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a1bd2bea6deb..648ddb52d579 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -76,6 +76,30 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");
 
+        /* ehci_init() causes memory for DMA transfers to be
+         * allocated.  Thus, any vendor-specific workarounds based on
+         * limiting the type of memory used for DMA transfers must
+         * happen before ehci_init() is called. */
+	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_NVIDIA:
+		/* NVidia reports that certain chips don't handle
+		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
+		 * data buffer, and periodic schedule are normal.)
+		 */
+		switch (pdev->device) {
+		case 0x003c:	/* MCP04 */
+		case 0x005b:	/* CK804 */
+		case 0x00d8:	/* CK8 */
+		case 0x00e8:	/* CK8S */
+			if (pci_set_consistent_dma_mask(pdev,
+						DMA_31BIT_MASK) < 0)
+				ehci_warn(ehci, "can't enable NVidia "
+					"workaround for >2GB RAM\n");
+			break;
+		}
+		break;
+	}
+
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
@@ -88,8 +112,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
-	/* NOTE:  only the parts below this line are PCI-specific */
-
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
@@ -107,19 +129,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_NVIDIA:
 		switch (pdev->device) {
-		/* NVidia reports that certain chips don't handle
-		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
-		 * data buffer, and periodic schedule are normal.)
-		 */
-		case 0x003c:	/* MCP04 */
-		case 0x005b:	/* CK804 */
-		case 0x00d8:	/* CK8 */
-		case 0x00e8:	/* CK8S */
-			if (pci_set_consistent_dma_mask(pdev,
-						DMA_31BIT_MASK) < 0)
-				ehci_warn(ehci, "can't enable NVidia "
-					"workaround for >2GB RAM\n");
-			break;
 		/* Some NForce2 chips have problems with selective suspend;
 		 * fixed in newer silicon.
 		 */

commit c67808eee61a01c3128298c5972426a1a67b9093
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Apr 9 20:07:35 2006 +0200

    [PATCH] USB: Use new PCI_CLASS_SERIAL_USB_* defines
    
    We could use the recently added PCI_CLASS_SERIAL_USB_UHCI,
    PCI_CLASS_SERIAL_USB_OHCI and PCI_CLASS_SERIAL_USB_EHCI defines in
    more places, for slightly shorter and clearer code.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1e03f1a5a5fd..a1bd2bea6deb 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -350,7 +350,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
 	/* handle any USB 2.0 EHCI controller */
-	PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x20), ~0),
+	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	},
 	{ /* end: all zeroes */ }

commit f8aeb3bb8657b207895aa10f75e63f2c48d08985
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Jan 20 13:55:14 2006 -0800

    [PATCH] USB: EHCI and NF2 quirk
    
    This teaches the EHCI driver about a quirk seen in older NForce2 chips,
    adding a workaround to ignore selective suspend requests.  Bus-wide
    (so-called "global") suspend still works, as does USB wakeup of a
    root hub that's globally suspended.
    
    There's still a hole in this support though.  Strictly speaking, this
    should _fail_ selective suspend requests, rather than ignoring them,
    since doing it this way means that devices which should be able to issue
    remote wakeup are not going to be able to do that.  For now, we'll just
    live with that problem ... since usbcore expects to do selective suspend
    on the way towards a full bus suspend, and usbcore needs to be able to
    do full bus suspend.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3a6687df5594..1e03f1a5a5fd 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -106,11 +106,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_NVIDIA:
+		switch (pdev->device) {
 		/* NVidia reports that certain chips don't handle
 		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
 		 * data buffer, and periodic schedule are normal.)
 		 */
-		switch (pdev->device) {
 		case 0x003c:	/* MCP04 */
 		case 0x005b:	/* CK804 */
 		case 0x00d8:	/* CK8 */
@@ -120,6 +120,14 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 				ehci_warn(ehci, "can't enable NVidia "
 					"workaround for >2GB RAM\n");
 			break;
+		/* Some NForce2 chips have problems with selective suspend;
+		 * fixed in newer silicon.
+		 */
+		case 0x0068:
+			pci_read_config_dword(pdev, PCI_REVISION_ID, &temp);
+			if ((temp & 0xff) < 0xa4)
+				ehci->no_selective_suspend = 1;
+			break;
 		}
 		break;
 	}
@@ -163,6 +171,21 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			device_init_wakeup(&pdev->dev, 1);
 	}
 
+#ifdef	CONFIG_USB_SUSPEND
+	/* REVISIT: the controller works fine for wakeup iff the root hub
+	 * itself is "globally" suspended, but usbcore currently doesn't
+	 * understand such things.
+	 *
+	 * System suspend currently expects to be able to suspend the entire
+	 * device tree, device-at-a-time.  If we failed selective suspend
+	 * reports, system suspend would fail; so the root hub code must claim
+	 * success.  That's lying to usbcore, and it matters for for runtime
+	 * PM scenarios with selective suspend and remote wakeup...
+	 */
+	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
+		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
+#endif
+
 	retval = ehci_pci_reinit(ehci, pdev);
 done:
 	return retval;

commit b6daf7f50836c8ed12d8b0ec0113e415f04e8530
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jan 24 17:42:24 2006 -0800

    [PATCH] USB: fix ehci early handoff issues warning
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 286b2f4acdc2..3a6687df5594 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -29,7 +29,6 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 {
 	u32			temp;
 	int			retval;
-	unsigned		count = 256/4;
 
 	/* optional debug port, normally in the first BAR */
 	temp = pci_find_capability(pdev, 0x0a);

commit 401feafa621ba98ecaeed5db1a53ab878943c225
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jan 24 07:15:30 2006 -0800

    [PATCH] USB: fix EHCI early handoff issues
    
    This moves the previously widely-used ehci-pci.c BIOS handoff
    code into the pci-quirks.c file, replacing the less widely used
    "early handoff" version that seems to cause problems lately.
    
    One notable change:  the "early handoff" version always enabled
    an SMI IRQ ... and did so even if the pre-Linux code said it was
    not using EHCI (and not expecting EHCI SMIs).  Looks like a goof
    in a workaround for some unknown BIOS version.
    
    This merged version only forcibly enables those IRQs when pre-Linux
    code says it's using EHCI.  And now it always forces them off "just
    in case".
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 08ca0f849dab..286b2f4acdc2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -24,40 +24,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
- * off the controller (maybe it can boot from highspeed USB disks).
- */
-static int bios_handoff(struct ehci_hcd *ehci, int where, u32 cap)
-{
-	struct pci_dev *pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
-
-	/* always say Linux will own the hardware */
-	pci_write_config_byte(pdev, where + 3, 1);
-
-	/* maybe wait a while for BIOS to respond */
-	if (cap & (1 << 16)) {
-		int msec = 5000;
-
-		do {
-			msleep(10);
-			msec -= 10;
-			pci_read_config_dword(pdev, where, &cap);
-		} while ((cap & (1 << 16)) && msec);
-		if (cap & (1 << 16)) {
-			ehci_err(ehci, "BIOS handoff failed (%d, %08x)\n",
-				where, cap);
-			// some BIOS versions seem buggy...
-			// return 1;
-			ehci_warn(ehci, "continuing after BIOS bug...\n");
-			/* disable all SMIs, and clear "BIOS owns" flag */
-			pci_write_config_dword(pdev, where + 4, 0);
-			pci_write_config_byte(pdev, where + 2, 0);
-		} else
-			ehci_dbg(ehci, "BIOS handoff succeeded\n");
-	}
-	return 0;
-}
-
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 {
@@ -84,32 +50,9 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 		}
 	}
 
-	temp = HCC_EXT_CAPS(readl(&ehci->caps->hcc_params));
-
-	/* EHCI 0.96 and later may have "extended capabilities" */
-	while (temp && count--) {
-		u32		cap;
-
-		pci_read_config_dword(pdev, temp, &cap);
-		ehci_dbg(ehci, "capability %04x at %02x\n", cap, temp);
-		switch (cap & 0xff) {
-		case 1:			/* BIOS/SMM/... handoff */
-			if (bios_handoff(ehci, temp, cap) != 0)
-				return -EOPNOTSUPP;
-			break;
-		case 0:			/* illegal reserved capability */
-			ehci_dbg(ehci, "illegal capability!\n");
-			cap = 0;
-			/* FALLTHROUGH */
-		default:		/* unknown */
-			break;
-		}
-		temp = (cap >> 8) & 0xff;
-	}
-	if (!count) {
-		ehci_err(ehci, "bogus capabilities ... PCI problems!\n");
-		return -EIO;
-	}
+	/* we expect static quirk code to handle the "extended capabilities"
+	 * (currently just BIOS handoff) allowed starting with EHCI 0.96
+	 */
 
 	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
 	retval = pci_set_mwi(pdev);

commit 1c50c317e2e7f15427149cbc216a63366468710e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 14 11:45:38 2005 -0500

    [PATCH] USB: central handling for host controllers that were reset during suspend/resume
    
    This patch (as515b) adds a routine to usbcore to simplify handling of
    host controllers that lost power or were reset during suspend/resume.
    The new core routine marks all the child devices of the root hub as
    NOTATTACHED and tells khubd to disconnect the device structures as soon
    as possible.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ac088bc72f1c..08ca0f849dab 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -278,7 +278,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned		port;
-	struct usb_device	*root = hcd->self.root_hub;
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval = -EINVAL;
 
@@ -312,13 +311,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 
 restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
-	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0; ) {
-		port--;
-		if (!root->children [port])
-			continue;
-		usb_set_device_state(root->children[port],
-					USB_STATE_NOTATTACHED);
-	}
+	usb_root_hub_lost_power(hcd->self.root_hub);
 
 	/* Else reset, to cope with power loss or flush-to-storage
 	 * style "resume" having let BIOS kick in during reboot.

commit 2c1c3c4cd5f796b1912c65aaf3bf48c0ddf11f5e
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Nov 7 15:24:46 2005 -0800

    [PATCH] USB: EHCI updates (4/4) driver model wakeup flags
    
    This teaches the EHCI driver to use the new driver model wakeup flags,
    replacing the similar ones in the HCD glue.  It also adds a workaround
    for the current glitch whereby PCI init doesn't init the wakeup flags
    from the PCI PM capabilities.  (EHCI controllers don't worry about
    legacy mode; the PCI PM capability would always do the job.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 13f73a836e45..ac088bc72f1c 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -210,7 +210,16 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-	/* REVISIT:  per-port wake capability (PCI 0x62) currently unused */
+	/* Workaround current PCI init glitch:  wakeup bits aren't
+	 * being set from PCI PM capability.
+	 */
+	if (!device_can_wakeup(&pdev->dev)) {
+		u16	port_wake;
+
+		pci_read_config_word(pdev, 0x62, &port_wake);
+		if (port_wake & 0x0001)
+			device_init_wakeup(&pdev->dev, 1);
+	}
 
 	retval = ehci_pci_reinit(ehci, pdev);
 done:

commit 8926bfa7462d4c3f8b05cca929e0c4bcde93ae38
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Nov 28 08:40:38 2005 -0800

    [PATCH] USB: ehci fixups
    
    Rename the EHCI "reset" routine so it better matches what it does (setup);
    and move the one-time data structure setup earlier, before doing anything
    that implicitly relies on it having been completed already.
    
    From: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 14fff5714c1e..13f73a836e45 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -121,8 +121,8 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 	return 0;
 }
 
-/* called by khubd or root hub (re)init threads; leaves HC in halt state */
-static int ehci_pci_reset(struct usb_hcd *hcd)
+/* called during probe() after chip reset completes */
+static int ehci_pci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
@@ -141,6 +141,11 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
 	/* NOTE:  only the parts below this line are PCI-specific */
 
 	switch (pdev->vendor) {
@@ -154,7 +159,8 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 		/* AMD8111 EHCI doesn't work, according to AMD errata */
 		if (pdev->device == 0x7463) {
 			ehci_info(ehci, "ignoring AMD8111 (errata)\n");
-			return -EIO;
+			retval = -EIO;
+			goto done;
 		}
 		break;
 	case PCI_VENDOR_ID_NVIDIA:
@@ -207,9 +213,8 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 	/* REVISIT:  per-port wake capability (PCI 0x62) currently unused */
 
 	retval = ehci_pci_reinit(ehci, pdev);
-
-	/* finish init */
-	return ehci_init(hcd);
+done:
+	return retval;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -344,7 +349,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset =		ehci_pci_reset,
+	.reset =		ehci_pci_setup,
 	.start =		ehci_run,
 #ifdef	CONFIG_PM
 	.suspend =		ehci_pci_suspend,

commit 8de98402652c01839ae321be6cb3054cf5735d83
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Nov 25 09:59:46 2005 +1100

    [PATCH] USB: Fix USB suspend/resume crasher (#2)
    
    This patch closes the IRQ race and makes various other OHCI & EHCI code
    path safer vs. suspend/resume.
    I've been able to (finally !) successfully suspend and resume various
    Mac models, with or without USB mouse plugged, or plugging while asleep,
    or unplugging while asleep etc... all without a crash.
    
    Alan, please verify the UHCI bit I did, I only verified that it builds.
    It's very simple so I wouldn't expect any issue there. If you aren't
    confident, then just drop the hunks that change uhci-hcd.c
    
    I also made the patch a little bit more "safer" by making sure the store
    to the interrupt register that disables interrupts is not posted before
    I set the flag and drop the spinlock.
    
    Without this patch, you cannot reliably sleep/wakeup any recent Mac, and
    I suspect PCs have some more sneaky issues too (they don't frankly crash
    with machine checks because x86 tend to silently swallow PCI errors but
    that won't last afaik, at least PCI Express will blow up in those
    situations, but the USB code may still misbehave).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 441c26064b44..14fff5714c1e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -228,14 +228,36 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	unsigned long		flags;
+	int			rc = 0;
 
 	if (time_before(jiffies, ehci->next_statechange))
 		msleep(10);
 
+	/* Root hub was already suspended. Disable irq emission and
+	 * mark HW unaccessible, bail out if RH has been resumed. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
+	 *
+	 * This is still racy as hcd->state is manipulated outside of
+	 * any locks =P But that will be a different fix.
+	 */
+	spin_lock_irqsave (&ehci->lock, flags);
+	if (hcd->state != HC_STATE_SUSPENDED) {
+		rc = -EINVAL;
+		goto bail;
+	}
+	writel (0, &ehci->regs->intr_enable);
+	(void)readl(&ehci->regs->intr_enable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+ bail:
+	spin_unlock_irqrestore (&ehci->lock, flags);
+
 	// could save FLADJ in case of Vaux power loss
 	// ... we'd only use it to handle clock skew
 
-	return 0;
+	return rc;
 }
 
 static int ehci_pci_resume(struct usb_hcd *hcd)
@@ -251,6 +273,9 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	if (time_before(jiffies, ehci->next_statechange))
 		msleep(100);
 
+	/* Mark hardware accessible again as we are out of D3 state by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
 	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
 	if (readl(&ehci->regs->configured_flag) != FLAG_CF)
 		goto restart;

commit 188075211cc75a31190de4a19a084e3d83ee1c89
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:37 2005 -0800

    [PATCH] USB: EHCI updates split init/reinit logic for resume
    
    Moving the PCI-specific parts of the EHCI driver into their own file
    created a few issues ... notably on resume paths which (like swsusp)
    require re-initializing the controller.  This patch:
    
     - Splits the EHCI startup code into run-once HCD setup code and
       separate "init the hardware" reinit code.  (That reinit code is
       a superset of the "early usb handoff" code.)
    
     - Then it makes the PCI init code run both, and the resume code only
       run the reinit code.
    
     - It also removes needless pci wrappers around EHCI start/stop methods.
    
     - Removes a byteswap issue that would be seen on big-endian hardware.
    
    The HCD glue still doesn't actually provide a good way to do all this
    run-one init stuff in one place though.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index b654e3f800b4..441c26064b44 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -58,15 +58,76 @@ static int bios_handoff(struct ehci_hcd *ehci, int where, u32 cap)
 	return 0;
 }
 
-/* called by khubd or root hub init threads */
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
+{
+	u32			temp;
+	int			retval;
+	unsigned		count = 256/4;
+
+	/* optional debug port, normally in the first BAR */
+	temp = pci_find_capability(pdev, 0x0a);
+	if (temp) {
+		pci_read_config_dword(pdev, temp, &temp);
+		temp >>= 16;
+		if ((temp & (3 << 13)) == (1 << 13)) {
+			temp &= 0x1fff;
+			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
+			temp = readl(&ehci->debug->control);
+			ehci_info(ehci, "debug port %d%s\n",
+				HCS_DEBUG_PORT(ehci->hcs_params),
+				(temp & DBGP_ENABLED)
+					? " IN USE"
+					: "");
+			if (!(temp & DBGP_ENABLED))
+				ehci->debug = NULL;
+		}
+	}
+
+	temp = HCC_EXT_CAPS(readl(&ehci->caps->hcc_params));
+
+	/* EHCI 0.96 and later may have "extended capabilities" */
+	while (temp && count--) {
+		u32		cap;
+
+		pci_read_config_dword(pdev, temp, &cap);
+		ehci_dbg(ehci, "capability %04x at %02x\n", cap, temp);
+		switch (cap & 0xff) {
+		case 1:			/* BIOS/SMM/... handoff */
+			if (bios_handoff(ehci, temp, cap) != 0)
+				return -EOPNOTSUPP;
+			break;
+		case 0:			/* illegal reserved capability */
+			ehci_dbg(ehci, "illegal capability!\n");
+			cap = 0;
+			/* FALLTHROUGH */
+		default:		/* unknown */
+			break;
+		}
+		temp = (cap >> 8) & 0xff;
+	}
+	if (!count) {
+		ehci_err(ehci, "bogus capabilities ... PCI problems!\n");
+		return -EIO;
+	}
+
+	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
+	retval = pci_set_mwi(pdev);
+	if (!retval)
+		ehci_dbg(ehci, "MWI active\n");
+
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+/* called by khubd or root hub (re)init threads; leaves HC in halt state */
 static int ehci_pci_reset(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	u32			temp;
-	unsigned		count = 256/4;
-
-	spin_lock_init (&ehci->lock);
+	int			retval;
 
 	ehci->caps = hcd->regs;
 	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
@@ -76,6 +137,10 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
 	/* NOTE:  only the parts below this line are PCI-specific */
 
 	switch (pdev->vendor) {
@@ -111,57 +176,9 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 		break;
 	}
 
-	/* optional debug port, normally in the first BAR */
-	temp = pci_find_capability(pdev, 0x0a);
-	if (temp) {
-		pci_read_config_dword(pdev, temp, &temp);
-		temp >>= 16;
-		if ((temp & (3 << 13)) == (1 << 13)) {
-			temp &= 0x1fff;
-			ehci->debug = hcd->regs + temp;
-			temp = readl(&ehci->debug->control);
-			ehci_info(ehci, "debug port %d%s\n",
-				HCS_DEBUG_PORT(ehci->hcs_params),
-				(temp & DBGP_ENABLED)
-					? " IN USE"
-					: "");
-			if (!(temp & DBGP_ENABLED))
-				ehci->debug = NULL;
-		}
-	}
-
-	temp = HCC_EXT_CAPS(readl(&ehci->caps->hcc_params));
-
-	/* EHCI 0.96 and later may have "extended capabilities" */
-	while (temp && count--) {
-		u32		cap;
-
-		pci_read_config_dword(to_pci_dev(hcd->self.controller),
-				temp, &cap);
-		ehci_dbg(ehci, "capability %04x at %02x\n", cap, temp);
-		switch (cap & 0xff) {
-		case 1:			/* BIOS/SMM/... handoff */
-			if (bios_handoff(ehci, temp, cap) != 0)
-				return -EOPNOTSUPP;
-			break;
-		case 0:			/* illegal reserved capability */
-			ehci_warn(ehci, "illegal capability!\n");
-			cap = 0;
-			/* FALLTHROUGH */
-		default:		/* unknown */
-			break;
-		}
-		temp = (cap >> 8) & 0xff;
-	}
-	if (!count) {
-		ehci_err(ehci, "bogus capabilities ... PCI problems!\n");
-		return -EIO;
-	}
 	if (ehci_is_TDI(ehci))
 		ehci_reset(ehci);
 
-	ehci_port_power(ehci, 0);
-
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
 	temp &= 0x0f;
@@ -184,39 +201,15 @@ static int ehci_pci_reset(struct usb_hcd *hcd)
 		}
 	}
 
-	/* force HC to halt state */
-	return ehci_halt(ehci);
-}
-
-static int ehci_pci_start(struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	int			result = 0;
-	struct pci_dev		*pdev;
-	u16			port_wake;
-
-	pdev = to_pci_dev(hcd->self.controller);
-
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-	/* port wake capability, reported by boot firmware */
-	pci_read_config_word(pdev, 0x62, &port_wake);
-	hcd->can_wakeup = (port_wake & 1) != 0;
-
-	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
-	result = pci_set_mwi(pdev);
-	if (!result)
-		ehci_dbg(ehci, "MWI active\n");
-
-	return ehci_run(hcd);
-}
+	/* REVISIT:  per-port wake capability (PCI 0x62) currently unused */
 
-/* always called by thread; normally rmmod */
+	retval = ehci_pci_reinit(ehci, pdev);
 
-static void ehci_pci_stop(struct usb_hcd *hcd)
-{
-	ehci_stop(hcd);
+	/* finish init */
+	return ehci_init(hcd);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -250,6 +243,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned		port;
 	struct usb_device	*root = hcd->self.root_hub;
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	int			retval = -EINVAL;
 
 	// maybe restore FLADJ
@@ -258,7 +252,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 		msleep(100);
 
 	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
-	if (readl(&ehci->regs->configured_flag) != cpu_to_le32(FLAG_CF))
+	if (readl(&ehci->regs->configured_flag) != FLAG_CF)
 		goto restart;
 
 	/* If any port is suspended (or owned by the companion),
@@ -292,7 +286,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	 */
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
-	(void) ehci_pci_reset(hcd);
+	(void) ehci_pci_reinit(ehci, pdev);
 
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
@@ -304,9 +298,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* restart; khubd will disconnect devices */
 	retval = ehci_run(hcd);
 
-	/* here we "know" root ports should always stay powered;
-	 * but some controllers may lose all power.
-	 */
+	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
 	return retval;
@@ -328,12 +320,12 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	 * basic lifecycle operations
 	 */
 	.reset =		ehci_pci_reset,
-	.start =		ehci_pci_start,
+	.start =		ehci_run,
 #ifdef	CONFIG_PM
 	.suspend =		ehci_pci_suspend,
 	.resume =		ehci_pci_resume,
 #endif
-	.stop =			ehci_pci_stop,
+	.stop =			ehci_stop,
 
 	/*
 	 * managing i/o requests and associated device resources

commit abcc94480634f6fe9fc29b821261e8162c87ddd2
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:32 2005 -0800

    [PATCH] USB: EHCI updates mostly whitespace cleanups
    
    This cleans up the recent updates to EHCI PCI support:
    
      - Gets rid of checks for "is this a PCI device", they're no
        longer needed since this is now all PCI-only code.
    
      - Reduce log spamming:  MWI is only interesting in the atypical
        case that it can actually be used.
    
      - Whitespace cleanup, as appropriate for a new file with no
        other pending patches.
    
    So other than that minor logging change, no functional updates.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 0f2be91e5e0e..b654e3f800b4 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -27,7 +27,7 @@
 /* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
  * off the controller (maybe it can boot from highspeed USB disks).
  */
-static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
+static int bios_handoff(struct ehci_hcd *ehci, int where, u32 cap)
 {
 	struct pci_dev *pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
 
@@ -48,7 +48,7 @@ static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
 				where, cap);
 			// some BIOS versions seem buggy...
 			// return 1;
-			ehci_warn (ehci, "continuing after BIOS bug...\n");
+			ehci_warn(ehci, "continuing after BIOS bug...\n");
 			/* disable all SMIs, and clear "BIOS owns" flag */
 			pci_write_config_dword(pdev, where + 4, 0);
 			pci_write_config_byte(pdev, where + 2, 0);
@@ -59,95 +59,93 @@ static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
 }
 
 /* called by khubd or root hub init threads */
-static int ehci_pci_reset (struct usb_hcd *hcd)
+static int ehci_pci_reset(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
 	u32			temp;
 	unsigned		count = 256/4;
 
 	spin_lock_init (&ehci->lock);
 
 	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH (readl (&ehci->caps->hc_capbase));
-	dbg_hcs_params (ehci, "reset");
-	dbg_hcc_params (ehci, "reset");
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
 
 	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev	*pdev = to_pci_dev(hcd->self.controller);
+	/* NOTE:  only the parts below this line are PCI-specific */
 
-		switch (pdev->vendor) {
-		case PCI_VENDOR_ID_TDI:
-			if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
-				ehci->is_tdi_rh_tt = 1;
-				tdi_reset (ehci);
-			}
-			break;
-		case PCI_VENDOR_ID_AMD:
-			/* AMD8111 EHCI doesn't work, according to AMD errata */
-			if (pdev->device == 0x7463) {
-				ehci_info (ehci, "ignoring AMD8111 (errata)\n");
-				return -EIO;
-			}
-			break;
-		case PCI_VENDOR_ID_NVIDIA:
-			/* NVidia reports that certain chips don't handle
-			 * QH, ITD, or SITD addresses above 2GB.  (But TD,
-			 * data buffer, and periodic schedule are normal.)
-			 */
-			switch (pdev->device) {
-			case 0x003c:	/* MCP04 */
-			case 0x005b:	/* CK804 */
-			case 0x00d8:	/* CK8 */
-			case 0x00e8:	/* CK8S */
-				if (pci_set_consistent_dma_mask(pdev,
-							DMA_31BIT_MASK) < 0)
-					ehci_warn (ehci, "can't enable NVidia "
-						"workaround for >2GB RAM\n");
-				break;
-			}
+	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_TDI:
+		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
+			ehci->is_tdi_rh_tt = 1;
+			tdi_reset(ehci);
+		}
+		break;
+	case PCI_VENDOR_ID_AMD:
+		/* AMD8111 EHCI doesn't work, according to AMD errata */
+		if (pdev->device == 0x7463) {
+			ehci_info(ehci, "ignoring AMD8111 (errata)\n");
+			return -EIO;
+		}
+		break;
+	case PCI_VENDOR_ID_NVIDIA:
+		/* NVidia reports that certain chips don't handle
+		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
+		 * data buffer, and periodic schedule are normal.)
+		 */
+		switch (pdev->device) {
+		case 0x003c:	/* MCP04 */
+		case 0x005b:	/* CK804 */
+		case 0x00d8:	/* CK8 */
+		case 0x00e8:	/* CK8S */
+			if (pci_set_consistent_dma_mask(pdev,
+						DMA_31BIT_MASK) < 0)
+				ehci_warn(ehci, "can't enable NVidia "
+					"workaround for >2GB RAM\n");
 			break;
 		}
+		break;
+	}
 
-		/* optional debug port, normally in the first BAR */
-		temp = pci_find_capability (pdev, 0x0a);
-		if (temp) {
-			pci_read_config_dword(pdev, temp, &temp);
-			temp >>= 16;
-			if ((temp & (3 << 13)) == (1 << 13)) {
-				temp &= 0x1fff;
-				ehci->debug = hcd->regs + temp;
-				temp = readl (&ehci->debug->control);
-				ehci_info (ehci, "debug port %d%s\n",
-					HCS_DEBUG_PORT(ehci->hcs_params),
-					(temp & DBGP_ENABLED)
-						? " IN USE"
-						: "");
-				if (!(temp & DBGP_ENABLED))
-					ehci->debug = NULL;
-			}
+	/* optional debug port, normally in the first BAR */
+	temp = pci_find_capability(pdev, 0x0a);
+	if (temp) {
+		pci_read_config_dword(pdev, temp, &temp);
+		temp >>= 16;
+		if ((temp & (3 << 13)) == (1 << 13)) {
+			temp &= 0x1fff;
+			ehci->debug = hcd->regs + temp;
+			temp = readl(&ehci->debug->control);
+			ehci_info(ehci, "debug port %d%s\n",
+				HCS_DEBUG_PORT(ehci->hcs_params),
+				(temp & DBGP_ENABLED)
+					? " IN USE"
+					: "");
+			if (!(temp & DBGP_ENABLED))
+				ehci->debug = NULL;
 		}
+	}
 
-		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
-	} else
-		temp = 0;
+	temp = HCC_EXT_CAPS(readl(&ehci->caps->hcc_params));
 
 	/* EHCI 0.96 and later may have "extended capabilities" */
 	while (temp && count--) {
 		u32		cap;
 
-		pci_read_config_dword (to_pci_dev(hcd->self.controller),
+		pci_read_config_dword(to_pci_dev(hcd->self.controller),
 				temp, &cap);
-		ehci_dbg (ehci, "capability %04x at %02x\n", cap, temp);
+		ehci_dbg(ehci, "capability %04x at %02x\n", cap, temp);
 		switch (cap & 0xff) {
 		case 1:			/* BIOS/SMM/... handoff */
-			if (bios_handoff (ehci, temp, cap) != 0)
+			if (bios_handoff(ehci, temp, cap) != 0)
 				return -EOPNOTSUPP;
 			break;
 		case 0:			/* illegal reserved capability */
-			ehci_warn (ehci, "illegal capability!\n");
+			ehci_warn(ehci, "illegal capability!\n");
 			cap = 0;
 			/* FALLTHROUGH */
 		default:		/* unknown */
@@ -156,77 +154,69 @@ static int ehci_pci_reset (struct usb_hcd *hcd)
 		temp = (cap >> 8) & 0xff;
 	}
 	if (!count) {
-		ehci_err (ehci, "bogus capabilities ... PCI problems!\n");
+		ehci_err(ehci, "bogus capabilities ... PCI problems!\n");
 		return -EIO;
 	}
 	if (ehci_is_TDI(ehci))
-		ehci_reset (ehci);
+		ehci_reset(ehci);
 
-	ehci_port_power (ehci, 0);
+	ehci_port_power(ehci, 0);
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
 	temp &= 0x0f;
 	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
-		ehci_dbg (ehci, "bogus port configuration: "
+		ehci_dbg(ehci, "bogus port configuration: "
 			"cc=%d x pcc=%d < ports=%d\n",
 			HCS_N_CC(ehci->hcs_params),
 			HCS_N_PCC(ehci->hcs_params),
 			HCS_N_PORTS(ehci->hcs_params));
 
-		if (hcd->self.controller->bus == &pci_bus_type) {
-			struct pci_dev	*pdev;
-
-			pdev = to_pci_dev(hcd->self.controller);
-			switch (pdev->vendor) {
-			case 0x17a0:		/* GENESYS */
-				/* GL880S: should be PORTS=2 */
-				temp |= (ehci->hcs_params & ~0xf);
-				ehci->hcs_params = temp;
-				break;
-			case PCI_VENDOR_ID_NVIDIA:
-				/* NF4: should be PCC=10 */
-				break;
-			}
+		switch (pdev->vendor) {
+		case 0x17a0:		/* GENESYS */
+			/* GL880S: should be PORTS=2 */
+			temp |= (ehci->hcs_params & ~0xf);
+			ehci->hcs_params = temp;
+			break;
+		case PCI_VENDOR_ID_NVIDIA:
+			/* NF4: should be PCC=10 */
+			break;
 		}
 	}
 
 	/* force HC to halt state */
-	return ehci_halt (ehci);
+	return ehci_halt(ehci);
 }
 
-static int ehci_pci_start (struct usb_hcd *hcd)
+static int ehci_pci_start(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	int result = 0;
-
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev		*pdev;
-		u16			port_wake;
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	int			result = 0;
+	struct pci_dev		*pdev;
+	u16			port_wake;
 
-		pdev = to_pci_dev(hcd->self.controller);
+	pdev = to_pci_dev(hcd->self.controller);
 
-		/* Serial Bus Release Number is at PCI 0x60 offset */
-		pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
+	/* Serial Bus Release Number is at PCI 0x60 offset */
+	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-		/* port wake capability, reported by boot firmware */
-		pci_read_config_word(pdev, 0x62, &port_wake);
-		hcd->can_wakeup = (port_wake & 1) != 0;
+	/* port wake capability, reported by boot firmware */
+	pci_read_config_word(pdev, 0x62, &port_wake);
+	hcd->can_wakeup = (port_wake & 1) != 0;
 
-		/* help hc dma work well with cachelines */
-		result = pci_set_mwi(pdev);
-		if (result)
-			ehci_dbg(ehci, "unable to enable MWI - not fatal.\n");
-	}
+	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
+	result = pci_set_mwi(pdev);
+	if (!result)
+		ehci_dbg(ehci, "MWI active\n");
 
-	return ehci_run (hcd);
+	return ehci_run(hcd);
 }
 
 /* always called by thread; normally rmmod */
 
-static void ehci_pci_stop (struct usb_hcd *hcd)
+static void ehci_pci_stop(struct usb_hcd *hcd)
 {
-	ehci_stop (hcd);
+	ehci_stop(hcd);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -242,12 +232,12 @@ static void ehci_pci_stop (struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
+static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep (10);
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(10);
 
 	// could save FLADJ in case of Vaux power loss
 	// ... we'd only use it to handle clock skew
@@ -255,30 +245,30 @@ static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	return 0;
 }
 
-static int ehci_pci_resume (struct usb_hcd *hcd)
+static int ehci_pci_resume(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned		port;
 	struct usb_device	*root = hcd->self.root_hub;
 	int			retval = -EINVAL;
 
 	// maybe restore FLADJ
 
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(100);
 
 	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
-	if (readl (&ehci->regs->configured_flag) != cpu_to_le32(FLAG_CF))
+	if (readl(&ehci->regs->configured_flag) != cpu_to_le32(FLAG_CF))
 		goto restart;
 
 	/* If any port is suspended (or owned by the companion),
 	 * we know we can/must resume the HC (and mustn't reset it).
 	 * We just defer that to the root hub code.
 	 */
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
+	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0; ) {
 		u32	status;
 		port--;
-		status = readl (&ehci->regs->port_status [port]);
+		status = readl(&ehci->regs->port_status [port]);
 		if (!(status & PORT_POWER))
 			continue;
 		if (status & (PORT_SUSPEND | PORT_RESUME | PORT_OWNER)) {
@@ -289,35 +279,35 @@ static int ehci_pci_resume (struct usb_hcd *hcd)
 
 restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
+	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0; ) {
 		port--;
 		if (!root->children [port])
 			continue;
-		usb_set_device_state (root->children[port],
+		usb_set_device_state(root->children[port],
 					USB_STATE_NOTATTACHED);
 	}
 
 	/* Else reset, to cope with power loss or flush-to-storage
 	 * style "resume" having let BIOS kick in during reboot.
 	 */
-	(void) ehci_halt (ehci);
-	(void) ehci_reset (ehci);
-	(void) ehci_pci_reset (hcd);
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+	(void) ehci_pci_reset(hcd);
 
 	/* emptying the schedule aborts any urbs */
-	spin_lock_irq (&ehci->lock);
+	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
 		ehci->reclaim_ready = 1;
-	ehci_work (ehci, NULL);
-	spin_unlock_irq (&ehci->lock);
+	ehci_work(ehci, NULL);
+	spin_unlock_irq(&ehci->lock);
 
 	/* restart; khubd will disconnect devices */
-	retval = ehci_run (hcd);
+	retval = ehci_run(hcd);
 
 	/* here we "know" root ports should always stay powered;
 	 * but some controllers may lose all power.
 	 */
-	ehci_port_power (ehci, 1);
+	ehci_port_power(ehci, 1);
 
 	return retval;
 }
@@ -376,7 +366,7 @@ static const struct pci_device_id pci_ids [] = { {
 	},
 	{ /* end: all zeroes */ }
 };
-MODULE_DEVICE_TABLE (pci, pci_ids);
+MODULE_DEVICE_TABLE(pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ehci_pci_driver = {
@@ -392,22 +382,22 @@ static struct pci_driver ehci_pci_driver = {
 #endif
 };
 
-static int __init ehci_hcd_pci_init (void)
+static int __init ehci_hcd_pci_init(void)
 {
 	if (usb_disabled())
 		return -ENODEV;
 
-	pr_debug ("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		hcd_name,
-		sizeof (struct ehci_qh), sizeof (struct ehci_qtd),
-		sizeof (struct ehci_itd), sizeof (struct ehci_sitd));
+		sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
+		sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
-	return pci_register_driver (&ehci_pci_driver);
+	return pci_register_driver(&ehci_pci_driver);
 }
-module_init (ehci_hcd_pci_init);
+module_init(ehci_hcd_pci_init);
 
-static void __exit ehci_hcd_pci_cleanup (void)
+static void __exit ehci_hcd_pci_cleanup(void)
 {
-	pci_unregister_driver (&ehci_pci_driver);
+	pci_unregister_driver(&ehci_pci_driver);
 }
-module_exit (ehci_hcd_pci_cleanup);
+module_exit(ehci_hcd_pci_cleanup);

commit f03c17fc9abe8582d6ad830290b3093fdf1eea61
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:28 2005 -0800

    [PATCH] USB: EHCI updates
    
    This fixes some bugs in EHCI suspend/resume that joined us over the past
    few releases (as usbcore, PCI, pmcore, and other components evolved):
    
      - Removes suspend and resume recursion from the EHCI driver, getting
        rid of the USB_SUSPEND special casing.
    
      - Updates the wakeup mechanism to work again; there's a newish usbcore
        call it needs to use.
    
      - Provide simpler tests for "do we need to restart from scratch", to
        address another case where PCI Vaux was lost.  (In this case it was
        restoring a swsusp snapshot, but there could be others.)
    
    Un-exports a symbol that was temporarily exported.
    
    A notable change from previous version is that this doesn't move
    the spinlock init, so there's still a resume/reinit path bug.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index dfd9bd0b1828..0f2be91e5e0e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -235,10 +235,11 @@ static void ehci_pci_stop (struct usb_hcd *hcd)
 
 /* suspend/resume, section 4.3 */
 
-/* These routines rely on the bus (pci, platform, etc)
+/* These routines rely on the PCI bus glue
  * to handle powerdown and wakeup, and currently also on
  * transceivers that don't need any software attention to set up
  * the right sort of wakeup.
+ * Also they depend on separate root hub suspend/resume.
  */
 
 static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -246,17 +247,9 @@ static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 
 	if (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
-
-#ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub);
-#else
-	usb_lock_device (hcd->self.root_hub);
-	(void) ehci_bus_suspend (hcd);
-	usb_unlock_device (hcd->self.root_hub);
-#endif
+		msleep (10);
 
-	// save (PCI) FLADJ in case of Vaux power loss
+	// could save FLADJ in case of Vaux power loss
 	// ... we'd only use it to handle clock skew
 
 	return 0;
@@ -269,13 +262,18 @@ static int ehci_pci_resume (struct usb_hcd *hcd)
 	struct usb_device	*root = hcd->self.root_hub;
 	int			retval = -EINVAL;
 
-	// maybe restore (PCI) FLADJ
+	// maybe restore FLADJ
 
 	if (time_before (jiffies, ehci->next_statechange))
 		msleep (100);
 
+	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
+	if (readl (&ehci->regs->configured_flag) != cpu_to_le32(FLAG_CF))
+		goto restart;
+
 	/* If any port is suspended (or owned by the companion),
 	 * we know we can/must resume the HC (and mustn't reset it).
+	 * We just defer that to the root hub code.
 	 */
 	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
 		u32	status;
@@ -283,42 +281,43 @@ static int ehci_pci_resume (struct usb_hcd *hcd)
 		status = readl (&ehci->regs->port_status [port]);
 		if (!(status & PORT_POWER))
 			continue;
-		if (status & (PORT_SUSPEND | PORT_OWNER)) {
-			down (&hcd->self.root_hub->serialize);
-			retval = ehci_bus_resume (hcd);
-			up (&hcd->self.root_hub->serialize);
-			break;
+		if (status & (PORT_SUSPEND | PORT_RESUME | PORT_OWNER)) {
+			usb_hcd_resume_root_hub(hcd);
+			return 0;
 		}
+	}
+
+restart:
+	ehci_dbg(ehci, "lost power, restarting\n");
+	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
+		port--;
 		if (!root->children [port])
 			continue;
-		dbg_port (ehci, __FUNCTION__, port + 1, status);
 		usb_set_device_state (root->children[port],
 					USB_STATE_NOTATTACHED);
 	}
 
 	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having activated BIOS during reboot.
+	 * style "resume" having let BIOS kick in during reboot.
 	 */
-	if (port == 0) {
-		(void) ehci_halt (ehci);
-		(void) ehci_reset (ehci);
-		(void) ehci_pci_reset (hcd);
-
-		/* emptying the schedule aborts any urbs */
-		spin_lock_irq (&ehci->lock);
-		if (ehci->reclaim)
-			ehci->reclaim_ready = 1;
-		ehci_work (ehci, NULL);
-		spin_unlock_irq (&ehci->lock);
-
-		/* restart; khubd will disconnect devices */
-		retval = ehci_run (hcd);
-
-		/* here we "know" root ports should always stay powered;
-		 * but some controllers may lose all power.
-		 */
-		ehci_port_power (ehci, 1);
-	}
+	(void) ehci_halt (ehci);
+	(void) ehci_reset (ehci);
+	(void) ehci_pci_reset (hcd);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq (&ehci->lock);
+	if (ehci->reclaim)
+		ehci->reclaim_ready = 1;
+	ehci_work (ehci, NULL);
+	spin_unlock_irq (&ehci->lock);
+
+	/* restart; khubd will disconnect devices */
+	retval = ehci_run (hcd);
+
+	/* here we "know" root ports should always stay powered;
+	 * but some controllers may lose all power.
+	 */
+	ehci_port_power (ehci, 1);
 
 	return retval;
 }

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 145008853966..dfd9bd0b1828 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -383,7 +383,6 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-	.owner = 	THIS_MODULE,
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,

commit 4303fc6f055cf1a7ec63c3c3fd777b91b7d576f1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 28 19:59:31 2005 -0700

    USB: fix up some odd parts due to partial merges
    
    Thanks to Andrew for doing the hard work on this.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 7872469ccbb1..145008853966 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -252,7 +252,7 @@ static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 	(void) usb_suspend_device (hcd->self.root_hub);
 #else
 	usb_lock_device (hcd->self.root_hub);
-	(void) ehci_hub_suspend (hcd);
+	(void) ehci_bus_suspend (hcd);
 	usb_unlock_device (hcd->self.root_hub);
 #endif
 
@@ -285,7 +285,7 @@ static int ehci_pci_resume (struct usb_hcd *hcd)
 			continue;
 		if (status & (PORT_SUSPEND | PORT_OWNER)) {
 			down (&hcd->self.root_hub->serialize);
-			retval = ehci_hub_resume (hcd);
+			retval = ehci_bus_resume (hcd);
 			up (&hcd->self.root_hub->serialize);
 			break;
 		}

commit efa400db5332ba341cc354c9d8a5298ff57faa98
Author: Ben Dooks <ben@fluff.org.uk>
Date:   Mon Oct 10 02:32:15 2005 +0100

    [PATCH] USB: add owner initialisation to host drivers
    
    Add .owner initialisation to the device drivers
    in drivers/usb/host so that when built as module
    the device_driver refers to the owning module
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 8bbc8dfe19f3..7872469ccbb1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -383,6 +383,7 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
+	.owner = 	THIS_MODULE,
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,

commit 0c0382e32d46f606951010b202382be14d180a17
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Oct 13 17:08:02 2005 -0400

    [PATCH] USB: Rename hcd->hub_suspend to hcd->bus_suspend
    
    This patch (as580) is perhaps the only result from the long discussion I
    had with David about his changes to the root-hub suspend/resume code.  It
    renames the hub_suspend and hub_resume methods in struct usb_hcd to
    bus_suspend and bus_resume.  These are more descriptive names, since the
    methods really do suspend or resume an entire USB bus, and less likely to
    be confused with the hub_suspend and hub_resume routines in hub.c.
    
    It also takes David's advice about removing the layer of bus glue, where
    those methods are called.  And it implements a related change that David
    made to the other HCDs but forgot to put into dummy_hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 66ebf75b2037..8bbc8dfe19f3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -363,8 +363,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ehci_hub_status_data,
 	.hub_control =		ehci_hub_control,
-	.hub_suspend =		ehci_hub_suspend,
-	.hub_resume =		ehci_hub_resume,
+	.bus_suspend =		ehci_bus_suspend,
+	.bus_resume =		ehci_bus_resume,
 };
 
 /*-------------------------------------------------------------------------*/

commit 7ff71d6adf81a43505b7cbaa034e4063d3439182
Author: Matt Porter <mporter@kernel.crashing.org>
Date:   Thu Sep 22 22:31:15 2005 -0700

    [PATCH] EHCI, split out PCI glue
    
    This splits BIOS and PCI specific support out of ehci-hcd.c into
    ehci-pci.c.  It follows the model already used in the OHCI driver
    so support for non-PCI EHCI controllers can be more easily added.
    
    Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/host/ehci-hcd.c |  543 ++++++--------------------------------------
     drivers/usb/host/ehci-pci.c |  414 +++++++++++++++++++++++++++++++++
     drivers/usb/host/ehci.h     |    1
     3 files changed, 492 insertions(+), 466 deletions(-)

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
new file mode 100644
index 000000000000..66ebf75b2037
--- /dev/null
+++ b/drivers/usb/host/ehci-pci.c
@@ -0,0 +1,414 @@
+/*
+ * EHCI HCD (Host Controller Driver) PCI Bus Glue.
+ *
+ * Copyright (c) 2000-2004 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef CONFIG_PCI
+#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
+ * off the controller (maybe it can boot from highspeed USB disks).
+ */
+static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
+{
+	struct pci_dev *pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
+
+	/* always say Linux will own the hardware */
+	pci_write_config_byte(pdev, where + 3, 1);
+
+	/* maybe wait a while for BIOS to respond */
+	if (cap & (1 << 16)) {
+		int msec = 5000;
+
+		do {
+			msleep(10);
+			msec -= 10;
+			pci_read_config_dword(pdev, where, &cap);
+		} while ((cap & (1 << 16)) && msec);
+		if (cap & (1 << 16)) {
+			ehci_err(ehci, "BIOS handoff failed (%d, %08x)\n",
+				where, cap);
+			// some BIOS versions seem buggy...
+			// return 1;
+			ehci_warn (ehci, "continuing after BIOS bug...\n");
+			/* disable all SMIs, and clear "BIOS owns" flag */
+			pci_write_config_dword(pdev, where + 4, 0);
+			pci_write_config_byte(pdev, where + 2, 0);
+		} else
+			ehci_dbg(ehci, "BIOS handoff succeeded\n");
+	}
+	return 0;
+}
+
+/* called by khubd or root hub init threads */
+static int ehci_pci_reset (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			temp;
+	unsigned		count = 256/4;
+
+	spin_lock_init (&ehci->lock);
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH (readl (&ehci->caps->hc_capbase));
+	dbg_hcs_params (ehci, "reset");
+	dbg_hcc_params (ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+
+	if (hcd->self.controller->bus == &pci_bus_type) {
+		struct pci_dev	*pdev = to_pci_dev(hcd->self.controller);
+
+		switch (pdev->vendor) {
+		case PCI_VENDOR_ID_TDI:
+			if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
+				ehci->is_tdi_rh_tt = 1;
+				tdi_reset (ehci);
+			}
+			break;
+		case PCI_VENDOR_ID_AMD:
+			/* AMD8111 EHCI doesn't work, according to AMD errata */
+			if (pdev->device == 0x7463) {
+				ehci_info (ehci, "ignoring AMD8111 (errata)\n");
+				return -EIO;
+			}
+			break;
+		case PCI_VENDOR_ID_NVIDIA:
+			/* NVidia reports that certain chips don't handle
+			 * QH, ITD, or SITD addresses above 2GB.  (But TD,
+			 * data buffer, and periodic schedule are normal.)
+			 */
+			switch (pdev->device) {
+			case 0x003c:	/* MCP04 */
+			case 0x005b:	/* CK804 */
+			case 0x00d8:	/* CK8 */
+			case 0x00e8:	/* CK8S */
+				if (pci_set_consistent_dma_mask(pdev,
+							DMA_31BIT_MASK) < 0)
+					ehci_warn (ehci, "can't enable NVidia "
+						"workaround for >2GB RAM\n");
+				break;
+			}
+			break;
+		}
+
+		/* optional debug port, normally in the first BAR */
+		temp = pci_find_capability (pdev, 0x0a);
+		if (temp) {
+			pci_read_config_dword(pdev, temp, &temp);
+			temp >>= 16;
+			if ((temp & (3 << 13)) == (1 << 13)) {
+				temp &= 0x1fff;
+				ehci->debug = hcd->regs + temp;
+				temp = readl (&ehci->debug->control);
+				ehci_info (ehci, "debug port %d%s\n",
+					HCS_DEBUG_PORT(ehci->hcs_params),
+					(temp & DBGP_ENABLED)
+						? " IN USE"
+						: "");
+				if (!(temp & DBGP_ENABLED))
+					ehci->debug = NULL;
+			}
+		}
+
+		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
+	} else
+		temp = 0;
+
+	/* EHCI 0.96 and later may have "extended capabilities" */
+	while (temp && count--) {
+		u32		cap;
+
+		pci_read_config_dword (to_pci_dev(hcd->self.controller),
+				temp, &cap);
+		ehci_dbg (ehci, "capability %04x at %02x\n", cap, temp);
+		switch (cap & 0xff) {
+		case 1:			/* BIOS/SMM/... handoff */
+			if (bios_handoff (ehci, temp, cap) != 0)
+				return -EOPNOTSUPP;
+			break;
+		case 0:			/* illegal reserved capability */
+			ehci_warn (ehci, "illegal capability!\n");
+			cap = 0;
+			/* FALLTHROUGH */
+		default:		/* unknown */
+			break;
+		}
+		temp = (cap >> 8) & 0xff;
+	}
+	if (!count) {
+		ehci_err (ehci, "bogus capabilities ... PCI problems!\n");
+		return -EIO;
+	}
+	if (ehci_is_TDI(ehci))
+		ehci_reset (ehci);
+
+	ehci_port_power (ehci, 0);
+
+	/* at least the Genesys GL880S needs fixup here */
+	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+	temp &= 0x0f;
+	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
+		ehci_dbg (ehci, "bogus port configuration: "
+			"cc=%d x pcc=%d < ports=%d\n",
+			HCS_N_CC(ehci->hcs_params),
+			HCS_N_PCC(ehci->hcs_params),
+			HCS_N_PORTS(ehci->hcs_params));
+
+		if (hcd->self.controller->bus == &pci_bus_type) {
+			struct pci_dev	*pdev;
+
+			pdev = to_pci_dev(hcd->self.controller);
+			switch (pdev->vendor) {
+			case 0x17a0:		/* GENESYS */
+				/* GL880S: should be PORTS=2 */
+				temp |= (ehci->hcs_params & ~0xf);
+				ehci->hcs_params = temp;
+				break;
+			case PCI_VENDOR_ID_NVIDIA:
+				/* NF4: should be PCC=10 */
+				break;
+			}
+		}
+	}
+
+	/* force HC to halt state */
+	return ehci_halt (ehci);
+}
+
+static int ehci_pci_start (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	int result = 0;
+
+	if (hcd->self.controller->bus == &pci_bus_type) {
+		struct pci_dev		*pdev;
+		u16			port_wake;
+
+		pdev = to_pci_dev(hcd->self.controller);
+
+		/* Serial Bus Release Number is at PCI 0x60 offset */
+		pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
+
+		/* port wake capability, reported by boot firmware */
+		pci_read_config_word(pdev, 0x62, &port_wake);
+		hcd->can_wakeup = (port_wake & 1) != 0;
+
+		/* help hc dma work well with cachelines */
+		result = pci_set_mwi(pdev);
+		if (result)
+			ehci_dbg(ehci, "unable to enable MWI - not fatal.\n");
+	}
+
+	return ehci_run (hcd);
+}
+
+/* always called by thread; normally rmmod */
+
+static void ehci_pci_stop (struct usb_hcd *hcd)
+{
+	ehci_stop (hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ */
+
+static int ehci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+
+	if (time_before (jiffies, ehci->next_statechange))
+		msleep (100);
+
+#ifdef	CONFIG_USB_SUSPEND
+	(void) usb_suspend_device (hcd->self.root_hub);
+#else
+	usb_lock_device (hcd->self.root_hub);
+	(void) ehci_hub_suspend (hcd);
+	usb_unlock_device (hcd->self.root_hub);
+#endif
+
+	// save (PCI) FLADJ in case of Vaux power loss
+	// ... we'd only use it to handle clock skew
+
+	return 0;
+}
+
+static int ehci_pci_resume (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	unsigned		port;
+	struct usb_device	*root = hcd->self.root_hub;
+	int			retval = -EINVAL;
+
+	// maybe restore (PCI) FLADJ
+
+	if (time_before (jiffies, ehci->next_statechange))
+		msleep (100);
+
+	/* If any port is suspended (or owned by the companion),
+	 * we know we can/must resume the HC (and mustn't reset it).
+	 */
+	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
+		u32	status;
+		port--;
+		status = readl (&ehci->regs->port_status [port]);
+		if (!(status & PORT_POWER))
+			continue;
+		if (status & (PORT_SUSPEND | PORT_OWNER)) {
+			down (&hcd->self.root_hub->serialize);
+			retval = ehci_hub_resume (hcd);
+			up (&hcd->self.root_hub->serialize);
+			break;
+		}
+		if (!root->children [port])
+			continue;
+		dbg_port (ehci, __FUNCTION__, port + 1, status);
+		usb_set_device_state (root->children[port],
+					USB_STATE_NOTATTACHED);
+	}
+
+	/* Else reset, to cope with power loss or flush-to-storage
+	 * style "resume" having activated BIOS during reboot.
+	 */
+	if (port == 0) {
+		(void) ehci_halt (ehci);
+		(void) ehci_reset (ehci);
+		(void) ehci_pci_reset (hcd);
+
+		/* emptying the schedule aborts any urbs */
+		spin_lock_irq (&ehci->lock);
+		if (ehci->reclaim)
+			ehci->reclaim_ready = 1;
+		ehci_work (ehci, NULL);
+		spin_unlock_irq (&ehci->lock);
+
+		/* restart; khubd will disconnect devices */
+		retval = ehci_run (hcd);
+
+		/* here we "know" root ports should always stay powered;
+		 * but some controllers may lose all power.
+		 */
+		ehci_port_power (ehci, 1);
+	}
+
+	return retval;
+}
+#endif
+
+static const struct hc_driver ehci_pci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ehci_pci_reset,
+	.start =		ehci_pci_start,
+#ifdef	CONFIG_PM
+	.suspend =		ehci_pci_suspend,
+	.resume =		ehci_pci_resume,
+#endif
+	.stop =			ehci_pci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.hub_suspend =		ehci_hub_suspend,
+	.hub_resume =		ehci_hub_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* PCI driver selection metadata; PCI hotplugging uses this */
+static const struct pci_device_id pci_ids [] = { {
+	/* handle any USB 2.0 EHCI controller */
+	PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x20), ~0),
+	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
+	},
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE (pci, pci_ids);
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver ehci_pci_driver = {
+	.name =		(char *) hcd_name,
+	.id_table =	pci_ids,
+
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
+
+#ifdef	CONFIG_PM
+	.suspend =	usb_hcd_pci_suspend,
+	.resume =	usb_hcd_pci_resume,
+#endif
+};
+
+static int __init ehci_hcd_pci_init (void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug ("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+		hcd_name,
+		sizeof (struct ehci_qh), sizeof (struct ehci_qtd),
+		sizeof (struct ehci_itd), sizeof (struct ehci_sitd));
+
+	return pci_register_driver (&ehci_pci_driver);
+}
+module_init (ehci_hcd_pci_init);
+
+static void __exit ehci_hcd_pci_cleanup (void)
+{
+	pci_unregister_driver (&ehci_pci_driver);
+}
+module_exit (ehci_hcd_pci_cleanup);
