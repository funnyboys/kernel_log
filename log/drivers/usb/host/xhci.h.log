commit dceea67058fe22075db3aed62d5cb62092be5053
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Wed Jun 24 16:59:45 2020 +0300

    xhci: Fix incorrect EP_STATE_MASK
    
    EP_STATE_MASK should be 0x7 instead of 0xf
    
    xhci spec 6.2.3 shows that the EP state field in the endpoint context data
    structure consist of bits [2:0].
    The old value included a bit from the next field which fortunately is a
     RsvdZ region. So hopefully this hasn't caused too much harm
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-2-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2c6c4f8d1ee1..c295e8a7f5ae 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -716,7 +716,7 @@ struct xhci_ep_ctx {
  * 4 - TRB error
  * 5-7 - reserved
  */
-#define EP_STATE_MASK		(0xf)
+#define EP_STATE_MASK		(0x7)
 #define EP_STATE_DISABLED	0
 #define EP_STATE_RUNNING	1
 #define EP_STATE_HALTED		2

commit a66d21d7dba84deeaf3b296c43eafc11094b6f09
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:38 2020 +0530

    usb: xhci: Add support for Renesas controller with memory
    
    Some rensas controller like uPD720201 and uPD720202 need firmware to be
    loaded. Add these devices in table and invoke renesas firmware loader
    functions to check and load the firmware into device memory when
    required.
    
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-4-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 38fc2fe7a036..2c6c4f8d1ee1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1873,6 +1873,7 @@ struct xhci_hcd {
 #define XHCI_DEFAULT_PM_RUNTIME_ALLOW	BIT_ULL(33)
 #define XHCI_RESET_PLL_ON_DISCONNECT	BIT_ULL(34)
 #define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)
+#define XHCI_RENESAS_FW_QUIRK	BIT_ULL(36)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit f6402eb4a2b3192bdf23fa39ef8e85fd3691cca9
Merge: 992a60ed0d5e 6a8b55ed4056
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 27 09:32:30 2020 +0200

    Merge 5.7-rc3 into usb-next
    
    We need the USB fixes in here too.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93ceaa808e8defc67ebca1396e2f42f812a2efc0
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Apr 21 17:08:20 2020 +0300

    xhci: Fix handling halted endpoint even if endpoint ring appears empty
    
    If a class driver cancels its only URB then the endpoint ring buffer will
    appear empty to the xhci driver. xHC hardware may still process cached
    TRBs, and complete with a STALL, halting the endpoint.
    
    This halted endpoint was not handled correctly by xhci driver as events on
    empty rings were all assumed to be spurious events.
    xhci driver refused to restart the ring with EP_HALTED flag set, so class
    driver was never informed the endpoint halted even if it queued new URBs.
    
    The host side of the endpoint needs to be reset, and dequeue pointer should
    be moved in order to clear the cached TRBs and resetart the endpoint.
    
    Small adjustments in finding the new dequeue pointer are needed to support
    the case of stall on an empty ring and unknown current TD.
    
    Cc: <stable@vger.kernel.org>
    cc: Jeremy Compostella <jeremy.compostella@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200421140822.28233-2-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3289bb516201..86cfefdd6632 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2116,8 +2116,9 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
-void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int ep_index,
-		unsigned int stream_id, struct xhci_td *td);
+void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int slot_id,
+			       unsigned int ep_index, unsigned int stream_id,
+			       struct xhci_td *td);
 void xhci_stop_endpoint_command_watchdog(struct timer_list *t);
 void xhci_handle_command_timeout(struct work_struct *work);
 

commit 3e45ed3cc14894a4d5114127ebdc62296521f365
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Apr 4 14:51:40 2020 +0530

    USB: host: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to USB host controller drivers.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Link: https://lore.kernel.org/r/20200404092135.GA4522@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3289bb516201..fb50f0e82d08 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 
 /*
  * xHCI host controller driver

commit 0200b9f790b0fc9e9a42f685f5ad54b23fe959f4
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Thu Mar 12 16:45:15 2020 +0200

    xhci: Wait until link state trainsits to U0 after setting USB_SS_PORT_LS_U0
    
    Like U3 case, xHCI spec doesn't specify the upper bound of U0 transition
    time. The 20ms is not enough for some devices.
    
    Intead of polling PLS or PLC, we can facilitate the port change event to
    know that the link transits to U0 is completed.
    
    While at it, also separate U0 and U3 case to make the code cleaner.
    
    [variable rename to u3exit, and skip completion for usb2 ports -Mathias ]
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312144517.1593-8-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3ff199c9aea6..3289bb516201 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1694,6 +1694,7 @@ struct xhci_bus_state {
 	/* Which ports are waiting on RExit to U0 transition. */
 	unsigned long		rexit_ports;
 	struct completion	rexit_done[USB_MAXCHILDREN];
+	struct completion	u3exit_done[USB_MAXCHILDREN];
 };
 
 

commit 9c1aa36efdae0c97c6d7285187b0573fc1793552
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Mar 12 16:45:11 2020 +0200

    xhci: Show host status when watchdog triggers and host is assumed dead.
    
    Additional debugging to show xHC USBSTS register when stop endpoint
    command watchdog triggers and host is assumed dead.
    
    useful to know the current status before the controller is stopped by
    the xhci driver and everything is released and freed.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312144517.1593-4-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 685180e1b98a..3ff199c9aea6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2589,6 +2589,35 @@ static inline const char *xhci_decode_portsc(u32 portsc)
 	return str;
 }
 
+static inline const char *xhci_decode_usbsts(u32 usbsts)
+{
+	static char str[256];
+	int ret = 0;
+
+	if (usbsts == ~(u32)0)
+		return " 0xffffffff";
+	if (usbsts & STS_HALT)
+		ret += sprintf(str + ret, " HCHalted");
+	if (usbsts & STS_FATAL)
+		ret += sprintf(str + ret, " HSE");
+	if (usbsts & STS_EINT)
+		ret += sprintf(str + ret, " EINT");
+	if (usbsts & STS_PORT)
+		ret += sprintf(str + ret, " PCD");
+	if (usbsts & STS_SAVE)
+		ret += sprintf(str + ret, " SSS");
+	if (usbsts & STS_RESTORE)
+		ret += sprintf(str + ret, " RSS");
+	if (usbsts & STS_SRE)
+		ret += sprintf(str + ret, " SRE");
+	if (usbsts & STS_CNR)
+		ret += sprintf(str + ret, " CNR");
+	if (usbsts & STS_HCE)
+		ret += sprintf(str + ret, " HCE");
+
+	return str;
+}
+
 static inline const char *xhci_decode_doorbell(u32 slot, u32 doorbell)
 {
 	static char str[256];

commit 24e6aea4801bae1dce3b16da6bc64fc06742ac14
Merge: 6bc3f3979edc f8788d86ab28
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 24 08:48:49 2020 +0100

    Merge 5.6-rc3 into usb-next
    
    We need the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6bc3f3979edce0b11deb685a4c817abb7d74b227
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 20 07:20:17 2020 -0600

    USB: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200220132017.GA29262@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 13d8838cd552..5f47b18609ee 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1642,7 +1642,7 @@ struct xhci_scratchpad {
 struct urb_priv {
 	int	num_tds;
 	int	num_tds_done;
-	struct	xhci_td	td[0];
+	struct	xhci_td	td[];
 };
 
 /*
@@ -1893,7 +1893,7 @@ struct xhci_hcd {
 
 	void			*dbc;
 	/* platform-specific data -- must come last */
-	unsigned long		priv[0] __aligned(sizeof(s64));
+	unsigned long		priv[] __aligned(sizeof(s64));
 };
 
 /* Platform specific overrides to generic XHCI hc_driver ops */

commit cf0ee7c60c89641f6e4d1d3c7867fe32b9e30300
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Feb 11 17:01:58 2020 +0200

    xhci: Fix memory leak when caching protocol extended capability PSI tables - take 2
    
    xhci driver assumed that xHC controllers have at most one custom
    supported speed table (PSI) for all usb 3.x ports.
    Memory was allocated for one PSI table under the xhci hub structure.
    
    Turns out this is not the case, some controllers have a separate
    "supported protocol capability" entry with a PSI table for each port.
    This means each usb3 roothub port can in theory support different custom
    speeds.
    
    To solve this, cache all supported protocol capabilities with their PSI
    tables in an array, and add pointers to the xhci port structure so that
    every port points to its capability entry in the array.
    
    When creating the SuperSpeedPlus USB Device Capability BOS descriptor
    for the xhci USB 3.1 roothub we for now will use only data from the
    first USB 3.1 capable protocol capability entry in the array.
    This could be improved later, this patch focuses resolving
    the memory leak.
    
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Reported-by: Sajja Venkateswara Rao <VenkateswaraRao.Sajja@amd.com>
    Fixes: 47189098f8be ("xhci: parse xhci protocol speed ID list for usb 3.1 usage")
    Cc: stable <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200211150158.14475-1-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 13d8838cd552..3ecee10fdcdc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1702,12 +1702,20 @@ struct xhci_bus_state {
  * Intel Lynx Point LP xHCI host.
  */
 #define	XHCI_MAX_REXIT_TIMEOUT_MS	20
+struct xhci_port_cap {
+	u32			*psi;	/* array of protocol speed ID entries */
+	u8			psi_count;
+	u8			psi_uid_count;
+	u8			maj_rev;
+	u8			min_rev;
+};
 
 struct xhci_port {
 	__le32 __iomem		*addr;
 	int			hw_portnum;
 	int			hcd_portnum;
 	struct xhci_hub		*rhub;
+	struct xhci_port_cap	*port_cap;
 };
 
 struct xhci_hub {
@@ -1719,9 +1727,6 @@ struct xhci_hub {
 	/* supported prococol extended capabiliy values */
 	u8			maj_rev;
 	u8			min_rev;
-	u32			*psi;	/* array of protocol speed ID entries */
-	u8			psi_count;
-	u8			psi_uid_count;
 };
 
 /* There is one xhci_hcd structure per controller */
@@ -1880,6 +1885,9 @@ struct xhci_hcd {
 	/* cached usb2 extened protocol capabilites */
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
+	/* cached extended protocol port capabilities */
+	struct xhci_port_cap	*port_caps;
+	unsigned int		num_port_caps;
 	/* Compliance Mode Recovery Data */
 	struct timer_list	comp_mode_recovery_timer;
 	u32			port_status_u0;

commit 67f68f977a12657028e866c013d43dd87320d210
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Feb 12 09:48:57 2020 -0800

    Revert "xhci: Fix memory leak when caching protocol extended capability PSI tables"
    
    This reverts commit fc57313d1017dd6b6f37a94e88daa8df54368ecc.
    
    Marek reports that it breaks things:
            This patch landed in today's linux-next (20200211) and causes
            NULL pointer dereference during second suspend/resume cycle on
            Samsung Exynos5422-based (arm 32bit) Odroid XU3lite board:
    
    A more complete fix will be added soon.
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Fixes: fc57313d1017 ("xhci: Fix memory leak when caching protocol extended capability PSI tables")
    Cc: Paul Menzel <pmenzel@molgen.mpg.de>
    Cc: Sajja Venkateswara Rao <VenkateswaraRao.Sajja@amd.com>
    Cc: stable <stable@vger.kernel.org> # v4.4+
    Cc: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3ecee10fdcdc..13d8838cd552 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1702,20 +1702,12 @@ struct xhci_bus_state {
  * Intel Lynx Point LP xHCI host.
  */
 #define	XHCI_MAX_REXIT_TIMEOUT_MS	20
-struct xhci_port_cap {
-	u32			*psi;	/* array of protocol speed ID entries */
-	u8			psi_count;
-	u8			psi_uid_count;
-	u8			maj_rev;
-	u8			min_rev;
-};
 
 struct xhci_port {
 	__le32 __iomem		*addr;
 	int			hw_portnum;
 	int			hcd_portnum;
 	struct xhci_hub		*rhub;
-	struct xhci_port_cap	*port_cap;
 };
 
 struct xhci_hub {
@@ -1727,6 +1719,9 @@ struct xhci_hub {
 	/* supported prococol extended capabiliy values */
 	u8			maj_rev;
 	u8			min_rev;
+	u32			*psi;	/* array of protocol speed ID entries */
+	u8			psi_count;
+	u8			psi_uid_count;
 };
 
 /* There is one xhci_hcd structure per controller */
@@ -1885,9 +1880,6 @@ struct xhci_hcd {
 	/* cached usb2 extened protocol capabilites */
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
-	/* cached extended protocol port capabilities */
-	struct xhci_port_cap	*port_caps;
-	unsigned int		num_port_caps;
 	/* Compliance Mode Recovery Data */
 	struct timer_list	comp_mode_recovery_timer;
 	u32			port_status_u0;

commit fc57313d1017dd6b6f37a94e88daa8df54368ecc
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Feb 10 15:45:51 2020 +0200

    xhci: Fix memory leak when caching protocol extended capability PSI tables
    
    xhci driver assumed that xHC controllers have at most one custom
    supported speed table (PSI) for all usb 3.x ports.
    Memory was allocated for one PSI table under the xhci hub structure.
    
    Turns out this is not the case, some controllers have a separate
    "supported protocol capability" entry with a PSI table for each port.
    This means each usb3 roothub port can in theory support different custom
    speeds.
    
    To solve this, cache all supported protocol capabilities with their PSI
    tables in an array, and add pointers to the xhci port structure so that
    every port points to its capability entry in the array.
    
    When creating the SuperSpeedPlus USB Device Capability BOS descriptor
    for the xhci USB 3.1 roothub we for now will use only data from the
    first USB 3.1 capable protocol capability entry in the array.
    This could be improved later, this patch focuses resolving
    the memory leak.
    
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Reported-by: Sajja Venkateswara Rao <VenkateswaraRao.Sajja@amd.com>
    Fixes: 47189098f8be ("xhci: parse xhci protocol speed ID list for usb 3.1 usage")
    Cc: stable <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200210134553.9144-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 13d8838cd552..3ecee10fdcdc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1702,12 +1702,20 @@ struct xhci_bus_state {
  * Intel Lynx Point LP xHCI host.
  */
 #define	XHCI_MAX_REXIT_TIMEOUT_MS	20
+struct xhci_port_cap {
+	u32			*psi;	/* array of protocol speed ID entries */
+	u8			psi_count;
+	u8			psi_uid_count;
+	u8			maj_rev;
+	u8			min_rev;
+};
 
 struct xhci_port {
 	__le32 __iomem		*addr;
 	int			hw_portnum;
 	int			hcd_portnum;
 	struct xhci_hub		*rhub;
+	struct xhci_port_cap	*port_cap;
 };
 
 struct xhci_hub {
@@ -1719,9 +1727,6 @@ struct xhci_hub {
 	/* supported prococol extended capabiliy values */
 	u8			maj_rev;
 	u8			min_rev;
-	u32			*psi;	/* array of protocol speed ID entries */
-	u8			psi_count;
-	u8			psi_uid_count;
 };
 
 /* There is one xhci_hcd structure per controller */
@@ -1880,6 +1885,9 @@ struct xhci_hcd {
 	/* cached usb2 extened protocol capabilites */
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
+	/* cached extended protocol port capabilities */
+	struct xhci_port_cap	*port_caps;
+	unsigned int		num_port_caps;
 	/* Compliance Mode Recovery Data */
 	struct timer_list	comp_mode_recovery_timer;
 	u32			port_status_u0;

commit f2c710f7dca8457e88b4ac9de2060f011254f9dd
Author: Henry Lin <henryl@nvidia.com>
Date:   Wed Dec 11 16:20:04 2019 +0200

    usb: xhci: only set D3hot for pci device
    
    Xhci driver cannot call pci_set_power_state() on non-pci xhci host
    controllers. For example, NVIDIA Tegra XHCI host controller which acts
    as platform device with XHCI_SPURIOUS_WAKEUP quirk set in some platform
    hits this issue during shutdown.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 638298dc66ea ("xhci: Fix spurious wakeups after S5 on Haswell")
    Signed-off-by: Henry Lin <henryl@nvidia.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-4-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dc6f62a4b197..13d8838cd552 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2050,6 +2050,7 @@ int xhci_start(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
 int xhci_run(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
+void xhci_shutdown(struct usb_hcd *hcd);
 void xhci_init_driver(struct hc_driver *drv,
 		      const struct xhci_driver_overrides *over);
 int xhci_disable_slot(struct xhci_hcd *xhci, u32 slot_id);

commit 58b9d71a0f55e2514211875553dd092f74dc2cbc
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Nov 15 18:50:01 2019 +0200

    xhci: Add tracing for xhci doorbell register writes
    
    Trace when a register in the doorbell array is written,
    both for host controller command doorbell and device doorbells,
    including for which endpoint and stream
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/1573836603-10871-3-git-send-email-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f9f88626a57a..dc6f62a4b197 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2580,6 +2580,35 @@ static inline const char *xhci_decode_portsc(u32 portsc)
 	return str;
 }
 
+static inline const char *xhci_decode_doorbell(u32 slot, u32 doorbell)
+{
+	static char str[256];
+	u8 ep;
+	u16 stream;
+	int ret;
+
+	ep = (doorbell & 0xff);
+	stream = doorbell >> 16;
+
+	if (slot == 0) {
+		sprintf(str, "Command Ring %d", doorbell);
+		return str;
+	}
+	ret = sprintf(str, "Slot %d ", slot);
+	if (ep > 0 && ep < 32)
+		ret = sprintf(str + ret, "ep%d%s",
+			      ep / 2,
+			      ep % 2 ? "in" : "out");
+	else if (ep == 0 || ep < 248)
+		ret = sprintf(str + ret, "Reserved %d", ep);
+	else
+		ret = sprintf(str + ret, "Vendor Defined %d", ep);
+	if (stream)
+		ret = sprintf(str + ret, " Stream %d", stream);
+
+	return str;
+}
+
 static inline const char *xhci_ep_state_string(u8 state)
 {
 	switch (state) {

commit 8a62dff2c0734a67fefd96742839a6d4bbb2587b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Aug 30 16:39:15 2019 +0300

    xhci: add TSP bitflag to TRB tracing
    
    Software can set a Transfer State Preserve (TSP) flag to maintain
    data toggle and sequence number when issuing a reset endpoint
    command.
    
    xhci driver is using TSP for soft retry, we want to show TSP usage
    in tracing as well
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/1567172356-12915-4-git-send-email-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f5c41448d067..f9f88626a57a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2337,12 +2337,13 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 		break;
 	case TRB_RESET_EP:
 		sprintf(str,
-			"%s: ctx %08x%08x slot %d ep %d flags %c",
+			"%s: ctx %08x%08x slot %d ep %d flags %c:%c",
 			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			/* Macro decrements 1, maybe it shouldn't?!? */
 			TRB_TO_EP_INDEX(field3) + 1,
+			field3 & TRB_TSP ? 'T' : 't',
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_STOP_RING:

commit d39b5bad8658d6d94cb2d98a44a7e159db4f5030
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Jul 25 11:54:21 2019 +0300

    xhci: Fix crash if scatter gather is used with Immediate Data Transfer (IDT).
    
    A second regression was found in the immediate data transfer (IDT)
    support which was added to 5.2 kernel
    
    IDT is used to transfer small amounts of data (up to 8 bytes) in the
    field normally used for data dma address, thus avoiding dma mapping.
    
    If the data was not already dma mapped, then IDT support assumed data was
    in urb->transfer_buffer, and did not take into accound that even
    small amounts of data (8 bytes) can be in a scatterlist instead.
    
    This caused a NULL pointer dereference when sg_dma_len() was used
    with non-dma mapped data.
    
    Solve this by not using IDT if scatter gather buffer list is used.
    
    Fixes: 33e39350ebd2 ("usb: xhci: add Immediate Data Transfer support")
    Cc: <stable@vger.kernel.org> # v5.2
    Reported-by: Maik Stohn <maik.stohn@seal-one.com>
    Tested-by: Maik Stohn <maik.stohn@seal-one.com>
    CC: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/1564044861-1445-1-git-send-email-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7a264962a1a9..f5c41448d067 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2175,7 +2175,8 @@ static inline bool xhci_urb_suitable_for_idt(struct urb *urb)
 	if (!usb_endpoint_xfer_isoc(&urb->ep->desc) && usb_urb_dir_out(urb) &&
 	    usb_endpoint_maxp(&urb->ep->desc) >= TRB_IDT_MAX_SIZE &&
 	    urb->transfer_buffer_length <= TRB_IDT_MAX_SIZE &&
-	    !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP))
+	    !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) &&
+	    !urb->num_sgs)
 		return true;
 
 	return false;

commit 58ee01007c9e00531c1280b2d99b49d29a5e9844
Merge: 4850f26abfca 4b972a01a7da
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jun 23 09:21:15 2019 +0200

    Merge 5.2-rc6 into usb-next
    
    We need the USB fixes in here too.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b8c3b718087bf7c3c8e388eb1f72ac1108a4926e
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jun 18 17:27:47 2019 +0300

    usb: xhci: Don't try to recover an endpoint if port is in error state.
    
    A USB3 device needs to be reset and re-enumarated if the port it
    connects to goes to a error state, with link state inactive.
    
    There is no use in trying to recover failed transactions by resetting
    endpoints at this stage. Tests show that in rare cases, after multiple
    endpoint resets of a roothub port the whole host controller might stop
    completely.
    
    Several retries to recover from transaction error can happen as
    it can take a long time before the hub thread discovers the USB3
    port error and inactive link.
    
    We can't reliably detect the port error from slot or endpoint context
    due to a limitation in xhci, see xhci specs section 4.8.3:
    "There are several cases where the EP State field in the Output
    Endpoint Context may not reflect the current state of an endpoint"
    and
    "Software should maintain an accurate value for EP State, by tracking it
    with an internal variable that is driven by Events and Doorbell accesses"
    
    Same appears to be true for slot state.
    
    set a flag to the corresponding slot if a USB3 roothub port link goes
    inactive to prevent both queueing new URBs and resetting endpoints.
    
    Reported-by: Rapolu Chiranjeevi <chiranjeevi.rapolu@intel.com>
    Tested-by: Rapolu Chiranjeevi <chiranjeevi.rapolu@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7f8b950d1a73..92e764c54154 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1010,6 +1010,15 @@ struct xhci_virt_device {
 	u8				real_port;
 	struct xhci_interval_bw_table	*bw_table;
 	struct xhci_tt_bw_info		*tt_info;
+	/*
+	 * flags for state tracking based on events and issued commands.
+	 * Software can not rely on states from output contexts because of
+	 * latency between events and xHC updating output context values.
+	 * See xhci 1.1 section 4.8.3 for more details
+	 */
+	unsigned long			flags;
+#define VDEV_PORT_ERROR			BIT(0) /* Port error, link inactive */
+
 	/* The current max exit latency for the enabled USB3 link states. */
 	u16				current_mel;
 	/* Used for the debugfs interfaces. */

commit ef513be0a9057cc6baf5d29566aaaefa214ba344
Author: Jim Lin <jilin@nvidia.com>
Date:   Mon Jun 3 18:53:44 2019 +0800

    usb: xhci: Add Clear_TT_Buffer
    
    USB 2.0 specification chapter 11.17.5 says "as part of endpoint halt
    processing for full-/low-speed endpoints connected via a TT, the host
    software must use the Clear_TT_Buffer request to the TT to ensure
    that the buffer is not in the busy state".
    
    In our case, a full-speed speaker (ConferenceCam) is behind a high-
    speed hub (ConferenceCam Connect), sometimes once we get STALL on a
    request we may continue to get STALL with the folllowing requests,
    like Set_Interface.
    
    Here we invoke usb_hub_clear_tt_buffer() to send Clear_TT_Buffer
    request to the hub of the device for the following Set_Interface
    requests to the device to get ACK successfully.
    
    Signed-off-by: Jim Lin <jilin@nvidia.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7f8b950d1a73..34789f4db555 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -936,6 +936,8 @@ struct xhci_virt_ep {
 #define EP_GETTING_NO_STREAMS	(1 << 5)
 #define EP_HARD_CLEAR_TOGGLE	(1 << 6)
 #define EP_SOFT_CLEAR_TOGGLE	(1 << 7)
+/* usb_hub_clear_tt_buffer is in progress */
+#define EP_CLEARING_TT		(1 << 8)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
 	/* Watchdog timer for stop endpoint command to cancel URBs */
@@ -2102,6 +2104,9 @@ void xhci_handle_command_timeout(struct work_struct *work);
 
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
+void xhci_ring_doorbell_for_active_rings(struct xhci_hcd *xhci,
+		unsigned int slot_id,
+		unsigned int ep_index);
 void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
 void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring);
 unsigned int count_trbs(u64 addr, u64 len);

commit 13b82b746310b51b064bc855993a1c84bf862726
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Wed May 22 14:34:00 2019 +0300

    xhci: Fix immediate data transfer if buffer is already DMA mapped
    
    xhci immediate data transfer (IDT) support in 5.2-rc1 caused regression
    on various Samsung Exynos boards with ASIX USB 2.0 ethernet dongle.
    
    If the transfer buffer in the URB is already DMA mapped then IDT should
    not be used. urb->transfer_dma will already contain a valid dma address,
    and there is no guarantee the data in urb->transfer_buffer is valid.
    
    The IDT support patch used urb->transfer_dma as a temporary storage,
    copying data from urb->transfer_buffer into it.
    
    Issue was solved by preventing IDT if transfer buffer is already dma
    mapped, and by not using urb->transfer_dma as temporary storage.
    
    Fixes: 33e39350ebd2 ("usb: xhci: add Immediate Data Transfer support")
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    CC: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a450a99e90eb..7f8b950d1a73 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2160,7 +2160,8 @@ static inline bool xhci_urb_suitable_for_idt(struct urb *urb)
 {
 	if (!usb_endpoint_xfer_isoc(&urb->ep->desc) && usb_urb_dir_out(urb) &&
 	    usb_endpoint_maxp(&urb->ep->desc) >= TRB_IDT_MAX_SIZE &&
-	    urb->transfer_buffer_length <= TRB_IDT_MAX_SIZE)
+	    urb->transfer_buffer_length <= TRB_IDT_MAX_SIZE &&
+	    !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP))
 		return true;
 
 	return false;

commit 90d6d5731da79a55de51552d930f9ad0b13262a2
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Apr 26 16:23:31 2019 +0300

    xhci: Add tracing for input control context
    
    Add tracing for the add and drop bits in the input control context
    used in Address device, configure endpoint, evaluate context commands.
    
    The add and drop bits tell xHC which enpoints are added and dropped.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index abbd4813e8a2..a450a99e90eb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2401,6 +2401,35 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	return str;
 }
 
+static inline const char *xhci_decode_ctrl_ctx(unsigned long drop,
+					       unsigned long add)
+{
+	static char	str[1024];
+	unsigned int	bit;
+	int		ret = 0;
+
+	if (drop) {
+		ret = sprintf(str, "Drop:");
+		for_each_set_bit(bit, &drop, 32)
+			ret += sprintf(str + ret, " %d%s",
+				       bit / 2,
+				       bit % 2 ? "in":"out");
+		ret += sprintf(str + ret, ", ");
+	}
+
+	if (add) {
+		ret += sprintf(str + ret, "Add:%s%s",
+			       (add & SLOT_FLAG) ? " slot":"",
+			       (add & EP0_FLAG) ? " ep0":"");
+		add &= ~(SLOT_FLAG | EP0_FLAG);
+		for_each_set_bit(bit, &add, 32)
+			ret += sprintf(str + ret, " %d%s",
+				       bit / 2,
+				       bit % 2 ? "in":"out");
+	}
+	return str;
+}
+
 static inline const char *xhci_decode_slot_context(u32 info, u32 info2,
 		u32 tt_info, u32 state)
 {

commit 33e39350ebd20fe6a77a51b8c21c3aa6b4a208cf
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Fri Apr 26 16:23:29 2019 +0300

    usb: xhci: add Immediate Data Transfer support
    
    Immediate data transfers (IDT) allow the HCD to copy small chunks of
    data (up to 8bytes) directly into its output transfer TRBs. This avoids
    the somewhat expensive DMA mappings that are performed by default on
    most URBs submissions.
    
    In the case an URB was suitable for IDT. The data is directly copied
    into the "Data Buffer Pointer" region of the TRB and the IDT flag is
    set. Instead of triggering memory accesses the HC will use the data
    directly.
    
    The implementation could cover all kind of output endpoints. Yet
    Isochronous endpoints are bypassed as I was unable to find one that
    matched IDT's constraints. As we try to bypass the default DMA mappings
    on URB buffers we'd need to find a Isochronous device with an
    urb->transfer_buffer_length <= 8 bytes.
    
    The implementation takes into account that the 8 byte buffers provided
    by the URB will never cross a 64KB boundary.
    
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9334cdee382a..abbd4813e8a2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1303,6 +1303,8 @@ enum xhci_setup_dev {
 #define TRB_IOC			(1<<5)
 /* The buffer pointer contains immediate data */
 #define TRB_IDT			(1<<6)
+/* TDs smaller than this might use IDT */
+#define TRB_IDT_MAX_SIZE	8
 
 /* Block Event Interrupt */
 #define	TRB_BEI			(1<<9)
@@ -2149,6 +2151,21 @@ static inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
 					urb->stream_id);
 }
 
+/*
+ * TODO: As per spec Isochronous IDT transmissions are supported. We bypass
+ * them anyways as we where unable to find a device that matches the
+ * constraints.
+ */
+static inline bool xhci_urb_suitable_for_idt(struct urb *urb)
+{
+	if (!usb_endpoint_xfer_isoc(&urb->ep->desc) && usb_urb_dir_out(urb) &&
+	    usb_endpoint_maxp(&urb->ep->desc) >= TRB_IDT_MAX_SIZE &&
+	    urb->transfer_buffer_length <= TRB_IDT_MAX_SIZE)
+		return true;
+
+	return false;
+}
+
 static inline char *xhci_slot_state_string(u32 state)
 {
 	switch (state) {

commit d92f2c59cc2cbca6bfb2cc54882b58ba76b15fd4
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Mar 22 17:50:17 2019 +0200

    xhci: Don't let USB3 ports stuck in polling state prevent suspend
    
    Commit 2f31a67f01a8 ("usb: xhci: Prevent bus suspend if a port connect
    change or polling state is detected") was intended to prevent ports that
    were still link training from being forced to U3 suspend state mid
    enumeration.
    This solved enumeration issues for devices with slow link training.
    
    Turns out some devices are stuck in the link training/polling state,
    and thus that patch will prevent suspend completely for these devices.
    This is seen with USB3 card readers in some MacBooks.
    
    Instead of preventing suspend, give some time to complete the link
    training. On successful training the port will end up as connected
    and enabled.
    If port instead is stuck in link training the bus suspend will continue
    suspending after 360ms (10 * 36ms) timeout (tPollingLFPSTimeout).
    
    Original patch was sent to stable, this one should go there as well
    
    Fixes: 2f31a67f01a8 ("usb: xhci: Prevent bus suspend if a port connect change or polling state is detected")
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 652dc36e3012..9334cdee382a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -452,6 +452,14 @@ struct xhci_op_regs {
  */
 #define XHCI_DEFAULT_BESL	4
 
+/*
+ * USB3 specification define a 360ms tPollingLFPSTiemout for USB3 ports
+ * to complete link training. usually link trainig completes much faster
+ * so check status 10 times with 36ms sleep in places we need to wait for
+ * polling to complete.
+ */
+#define XHCI_PORT_POLLING_LFPS_TIME  36
+
 /**
  * struct xhci_intr_reg - Interrupt Register Set
  * @irq_pending:	IMAN - Interrupt Management Register.  Used to enable

commit cd6a22310ec2a70092e136d0cd65bb77c1502521
Merge: 1e12a521d691 177c459b08a3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 16:46:08 2018 +0100

    Merge USB 4.20-rc8 mergepoint into usb-next
    
    We need the USB changes in here for additional patches to be able to
    apply cleanly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2419f30a4a4fcaa5f35111563b4c61f1b2b26841
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Mon Dec 17 14:37:40 2018 +0100

    USB: xhci: fix 'broken_suspend' placement in struct xchi_hcd
    
    As commented in the struct's definition there shouldn't be anything
    underneath its 'priv[0]' member as it would break some macros.
    
    The patch converts the broken_suspend into a bit-field and relocates it
    next to to the rest of bit-fields.
    
    Fixes: a7d57abcc8a5 ("xhci: workaround CSS timeout on AMD SNPS 3.0 xHC")
    Reported-by: Oliver Neukum  <oneukum@suse.com>
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c3515bad5dbb..011dd45f8718 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1863,6 +1863,8 @@ struct xhci_hcd {
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
+	/* Broken Suspend flag for SNPS Suspend resume issue */
+	unsigned		broken_suspend:1;
 	/* cached usb2 extened protocol capabilites */
 	u32                     *ext_caps;
 	unsigned int            num_ext_caps;
@@ -1880,8 +1882,6 @@ struct xhci_hcd {
 	void			*dbc;
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
-	/* Broken Suspend flag for SNPS Suspend resume issue */
-	u8			broken_suspend;
 };
 
 /* Platform specific overrides to generic XHCI hc_driver ops */

commit b53bde6686fb6952f560e82c5b6c529966d205a4
Merge: e67ebf1b3815 40e020c129cf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 10 10:19:08 2018 +0100

    Merge 4.20-rc6 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c2d81cc287c59161b19c5810f0091fe33448e07
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 7 16:19:31 2018 +0200

    xhci: remove unused hcd_index()
    
    Now that each root hub has their own bus_state strucure the
    hcd_undex() used to get the correct bus_state strucure is
    no longer needed.
    
    No functional changes
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b57b7934fae1..3c6b5049464a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1682,13 +1682,6 @@ struct xhci_bus_state {
  */
 #define	XHCI_MAX_REXIT_TIMEOUT_MS	20
 
-static inline unsigned int hcd_index(struct usb_hcd *hcd)
-{
-	if (hcd->speed >= HCD_USB3)
-		return 0;
-	else
-		return 1;
-}
 struct xhci_port {
 	__le32 __iomem		*addr;
 	int			hw_portnum;

commit f6187f424c10210e8e9917d4b7035ddc935010f6
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 7 16:19:30 2018 +0200

    xhci: move bus_state structure under the xhci_hub structure.
    
    Move the bus_state structure under struct usb_hub.
    
    We need a bus_state strucure for each roothub to keep track of suspend
    related info for each port.
    Instead of keeping an array of two bus_state structures right under
    struct xhci, it makes more sense move them to the xhci_hub structure.
    
    No functional changes.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 59b8562a2ffe..b57b7934fae1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1700,6 +1700,8 @@ struct xhci_hub {
 	struct xhci_port	**ports;
 	unsigned int		num_ports;
 	struct usb_hcd		*hcd;
+	/* keep track of bus suspend info */
+	struct xhci_bus_state   bus_state;
 	/* supported prococol extended capabiliy values */
 	u8			maj_rev;
 	u8			min_rev;
@@ -1853,8 +1855,6 @@ struct xhci_hcd {
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
-	/* There are two roothubs to keep track of bus suspend info for */
-	struct xhci_bus_state   bus_state[2];
 	struct xhci_port	*hw_ports;
 	struct xhci_hub		usb2_rhub;
 	struct xhci_hub		usb3_rhub;

commit f1fd62a6b6c62e10ceb97432e9616b575538b699
Author: Zeng Tao <prime.zeng@hisilicon.com>
Date:   Fri Dec 7 16:19:29 2018 +0200

    xhci: remove the unused sw_lpm_support
    
    It is introduced for the pre-0.96 xHC controllers, and the driver only
    support HW LPM for 1.0 and later controllers.It's not actually used now
    and is thought not to be used in the future any more, so just remove it.
    
    Signed-off-by: Zeng Tao <prime.zeng@hisilicon.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 260b259b72bc..59b8562a2ffe 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1858,8 +1858,6 @@ struct xhci_hcd {
 	struct xhci_port	*hw_ports;
 	struct xhci_hub		usb2_rhub;
 	struct xhci_hub		usb3_rhub;
-	/* support xHCI 0.96 spec USB2 software LPM */
-	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
 	/* cached usb2 extened protocol capabilites */

commit a7d57abcc8a5bdeb53bbf8e87558e8e0a2c2a29d
Author: Sandeep Singh <sandeep.singh@amd.com>
Date:   Wed Dec 5 14:22:38 2018 +0200

    xhci: workaround CSS timeout on AMD SNPS 3.0 xHC
    
    Occasionally AMD SNPS 3.0 xHC does not respond to
    CSS when set, also it does not flag anything on SRE and HCE
    to point the internal xHC errors on USBSTS register. This stalls
    the entire system wide suspend and there is no point in stalling
    just because of xHC CSS is not responding.
    
    To work around this problem, if the xHC does not flag
    anything on SRE and HCE, we can skip the CSS
    timeout and allow the system to continue the suspend. Once the
    system resume happens we can internally reset the controller
    using XHCI_RESET_ON_RESUME quirk
    
    Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Sandeep Singh <Sandeep.Singh@amd.com>
    cc: Nehal Shah <Nehal-bakulchandra.Shah@amd.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 260b259b72bc..c3515bad5dbb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1850,6 +1850,7 @@ struct xhci_hcd {
 #define XHCI_ZERO_64B_REGS	BIT_ULL(32)
 #define XHCI_DEFAULT_PM_RUNTIME_ALLOW	BIT_ULL(33)
 #define XHCI_RESET_PLL_ON_DISCONNECT	BIT_ULL(34)
+#define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
@@ -1879,6 +1880,8 @@ struct xhci_hcd {
 	void			*dbc;
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
+	/* Broken Suspend flag for SNPS Suspend resume issue */
+	u8			broken_suspend;
 };
 
 /* Platform specific overrides to generic XHCI hc_driver ops */

commit 11644a7659529730eaf2f166efaabe7c3dc7af8c
Author: Cherian, George <George.Cherian@cavium.com>
Date:   Fri Nov 9 17:21:22 2018 +0200

    xhci: Add quirk to workaround the errata seen on Cavium Thunder-X2 Soc
    
    Implement workaround for ThunderX2 Errata-129 (documented in
    CN99XX Known Issues" available at Cavium support site).
    As per ThunderX2errata-129, USB 2 device may come up as USB 1
    if a connection to a USB 1 device is followed by another connection to
    a USB 2 device, the link will come up as USB 1 for the USB 2 device.
    
    Resolution: Reset the PHY after the USB 1 device is disconnected.
    The PHY reset sequence is done using private registers in XHCI register
    space. After the PHY is reset we check for the PLL lock status and retry
    the operation if it fails. From our tests, retrying 4 times is sufficient.
    
    Add a new quirk flag XHCI_RESET_PLL_ON_DISCONNECT to invoke the workaround
    in handle_xhci_port_status().
    
    Cc: stable@vger.kernel.org
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5f0c4f197f13..260b259b72bc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1849,6 +1849,7 @@ struct xhci_hcd {
 #define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
 #define XHCI_ZERO_64B_REGS	BIT_ULL(32)
 #define XHCI_DEFAULT_PM_RUNTIME_ALLOW	BIT_ULL(33)
+#define XHCI_RESET_PLL_ON_DISCONNECT	BIT_ULL(34)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit a5baeaeabcca3244782a9b6382ebab6f8a58f583
Author: Aaron Ma <aaron.ma@canonical.com>
Date:   Fri Nov 9 17:21:21 2018 +0200

    usb: xhci: fix timeout for transition from RExit to U0
    
    This definition is used by msecs_to_jiffies in milliseconds.
    According to the comments, max rexit timeout should be 20ms.
    Align with the comments to properly calculate the delay.
    
    Verified on Sunrise Point-LP and Cannon Lake.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Aaron Ma <aaron.ma@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bf0b3692dc9a..5f0c4f197f13 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1680,7 +1680,7 @@ struct xhci_bus_state {
  * It can take up to 20 ms to transition from RExit to U0 on the
  * Intel Lynx Point LP xHCI host.
  */
-#define	XHCI_MAX_REXIT_TIMEOUT	(20 * 1000)
+#define	XHCI_MAX_REXIT_TIMEOUT_MS	20
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {

commit 2815ef7fe4d43072b9eda448d04fbc184f2aa513
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Sep 20 19:13:38 2018 +0300

    xhci-pci: allow host runtime PM as default for Intel Alpine and Titan Ridge
    
    The xhci controller on Alpine and Titan Ridge keeps the whole thunderbolt
    awake if the host controller is not allowed tp sleep.
    This is the case even if no USB devices are connected to the host.
    
    Because of this bigger impact, allow runtime pm as default for these xhci
    controllers in the driver.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b63578548bef..bf0b3692dc9a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1848,6 +1848,7 @@ struct xhci_hcd {
 #define XHCI_SUSPEND_DELAY	BIT_ULL(30)
 #define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
 #define XHCI_ZERO_64B_REGS	BIT_ULL(32)
+#define XHCI_DEFAULT_PM_RUNTIME_ALLOW	BIT_ULL(33)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit f8f80be501aa2f10669585c3e328fad079d8cb3a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Sep 20 19:13:37 2018 +0300

    xhci: Use soft retry to recover faster from transaction errors
    
    Use soft retry to recover from a USB Transaction Errors that are caused by
    temporary error conditions. The USB device is not aware that the xHC
    has halted the endpoint, and will be waiting for another retry
    
    A Soft Retry perform additional retries and recover from an error which has
    caused the xHC to halt an endpoint.
    
    Soft retry has some limitations:
    Soft Retry attempts shall not be performed on Isoch endpoints
    Soft Retry attempts shall not be performed if the device is behind a TT in
    a HS Hub
    
    Software shall limit the number of unsuccessful Soft Retry attempts to
    prevent an infinite loop.
    
    For more details on Soft retry see xhci specs  4.6.8.1
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6230a578324c..b63578548bef 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1496,6 +1496,7 @@ static inline const char *xhci_trb_type_string(u8 type)
 /* How much data is left before the 64KB boundary? */
 #define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr)	(TRB_MAX_BUFF_SIZE - \
 					(addr & (TRB_MAX_BUFF_SIZE - 1)))
+#define MAX_SOFT_RETRY		3
 
 struct xhci_segment {
 	union xhci_trb		*trbs;
@@ -1583,6 +1584,7 @@ struct xhci_ring {
 	 * if we own the TRB (if we are the consumer).  See section 4.9.1.
 	 */
 	u32			cycle_state;
+	unsigned int            err_count;
 	unsigned int		stream_id;
 	unsigned int		num_segs;
 	unsigned int		num_trbs_free;

commit 714c95ce8bad7a2042006fc9a2079fcd469b6a03
Merge: aaf3f4e925dc 021c91791a5e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 2 08:28:32 2018 +0200

    Merge 4.18-rc3 into usb-next
    
    We want the USB and other fixes in here as well to make merges and
    testing easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8f9cc83c06d44081d7c7e179f778cbeb4d074fa7
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 8 16:59:57 2018 -0400

    USB: xhci-hcd: Add get_resuming_ports method
    
    This patch adds support for the new get_resuming_ports HCD method to
    the xhci-hcd driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 939e2f86b595..ece5891240f0 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2110,9 +2110,11 @@ void xhci_hc_died(struct xhci_hcd *xhci);
 #ifdef CONFIG_PM
 int xhci_bus_suspend(struct usb_hcd *hcd);
 int xhci_bus_resume(struct usb_hcd *hcd);
+unsigned long xhci_get_resuming_ports(struct usb_hcd *hcd);
 #else
 #define	xhci_bus_suspend	NULL
 #define	xhci_bus_resume		NULL
+#define	xhci_get_resuming_ports	NULL
 #endif	/* CONFIG_PM */
 
 u32 xhci_port_state_to_neutral(u32 state);

commit 229bc19fd7aca4f37964af06e3583c1c8f36b5d6
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Jun 21 16:19:41 2018 +0300

    xhci: Fix perceived dead host due to runtime suspend race with event handler
    
    Don't rely on event interrupt (EINT) bit alone to detect pending port
    change in resume. If no change event is detected the host may be suspended
    again, oterwise roothubs are resumed.
    
    There is a lag in xHC setting EINT. If we don't notice the pending change
    in resume, and the controller is runtime suspeded again, it causes the
    event handler to assume host is dead as it will fail to read xHC registers
    once PCI puts the controller to D3 state.
    
    [  268.520969] xhci_hcd: xhci_resume: starting port polling.
    [  268.520985] xhci_hcd: xhci_hub_status_data: stopping port polling.
    [  268.521030] xhci_hcd: xhci_suspend: stopping port polling.
    [  268.521040] xhci_hcd: // Setting command ring address to 0x349bd001
    [  268.521139] xhci_hcd: Port Status Change Event for port 3
    [  268.521149] xhci_hcd: resume root hub
    [  268.521163] xhci_hcd: port resume event for port 3
    [  268.521168] xhci_hcd: xHC is not running.
    [  268.521174] xhci_hcd: handle_port_status: starting port polling.
    [  268.596322] xhci_hcd: xhci_hc_died: xHCI host controller not responding, assume dead
    
    The EINT lag is described in a additional note in xhci specs 4.19.2:
    
    "Due to internal xHC scheduling and system delays, there will be a lag
    between a change bit being set and the Port Status Change Event that it
    generated being written to the Event Ring. If SW reads the PORTSC and
    sees a change bit set, there is no guarantee that the corresponding Port
    Status Change Event has already been written into the Event Ring."
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 939e2f86b595..841e89ffe2e9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -382,6 +382,10 @@ struct xhci_op_regs {
 #define PORT_PLC	(1 << 22)
 /* port configure error change - port failed to configure its link partner */
 #define PORT_CEC	(1 << 23)
+#define PORT_CHANGE_MASK	(PORT_CSC | PORT_PEC | PORT_WRC | PORT_OCC | \
+				 PORT_RC | PORT_PLC | PORT_CEC)
+
+
 /* Cold Attach Status - xHC can set this bit to report device attached during
  * Sx state. Warm port reset should be perfomed to clear this bit and move port
  * to connected state.

commit 12de0a35c996c3a75d050bff748815db3432849c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed May 23 18:41:37 2018 +0100

    xhci: Add quirk to zero 64bit registers on Renesas PCIe controllers
    
    Some Renesas controllers get into a weird state if they are reset while
    programmed with 64bit addresses (they will preserve the top half of the
    address in internal, non visible registers).
    
    You end up with half the address coming from the kernel, and the other
    half coming from the firmware.
    
    Also, changing the programming leads to extra accesses even if the
    controller is supposed to be halted. The controller ends up with a fatal
    fault, and is then ripe for being properly reset. On the flip side,
    this is completely unsafe if the defvice isn't behind an IOMMU, so
    we have to make sure that this is the case. Can you say "broken"?
    
    This is an alternative method to the one introduced in 8466489ef5ba
    ("xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue"),
    which will subsequently be removed.
    
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2303ee4307af..939e2f86b595 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1841,6 +1841,7 @@ struct xhci_hcd {
 #define XHCI_HW_LPM_DISABLE	BIT_ULL(29)
 #define XHCI_SUSPEND_DELAY	BIT_ULL(30)
 #define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
+#define XHCI_ZERO_64B_REGS	BIT_ULL(32)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit 36b6857932f380fcb55c31ac75857e3e81dd583a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed May 23 18:41:36 2018 +0100

    xhci: Allow more than 32 quirks
    
    We now have 32 different quirks, and the field that holds them
    is full. Let's bump it up to the next stage so that we can handle
    some more... The type is now an unsigned long long, which is 64bit
    on most architectures.
    
    We take this opportunity to change the quirks from using (1 << x)
    to BIT_ULL(x).
    
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6c5f00178d09..2303ee4307af 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1797,12 +1797,12 @@ struct xhci_hcd {
 #define XHCI_STATE_DYING	(1 << 0)
 #define XHCI_STATE_HALTED	(1 << 1)
 #define XHCI_STATE_REMOVING	(1 << 2)
-	unsigned int		quirks;
-#define	XHCI_LINK_TRB_QUIRK	(1 << 0)
-#define XHCI_RESET_EP_QUIRK	(1 << 1)
-#define XHCI_NEC_HOST		(1 << 2)
-#define XHCI_AMD_PLL_FIX	(1 << 3)
-#define XHCI_SPURIOUS_SUCCESS	(1 << 4)
+	unsigned long long	quirks;
+#define	XHCI_LINK_TRB_QUIRK	BIT_ULL(0)
+#define XHCI_RESET_EP_QUIRK	BIT_ULL(1)
+#define XHCI_NEC_HOST		BIT_ULL(2)
+#define XHCI_AMD_PLL_FIX	BIT_ULL(3)
+#define XHCI_SPURIOUS_SUCCESS	BIT_ULL(4)
 /*
  * Certain Intel host controllers have a limit to the number of endpoint
  * contexts they can handle.  Ideally, they would signal that they can't handle
@@ -1812,35 +1812,35 @@ struct xhci_hcd {
  * commands, reset device commands, disable slot commands, and address device
  * commands.
  */
-#define XHCI_EP_LIMIT_QUIRK	(1 << 5)
-#define XHCI_BROKEN_MSI		(1 << 6)
-#define XHCI_RESET_ON_RESUME	(1 << 7)
-#define	XHCI_SW_BW_CHECKING	(1 << 8)
-#define XHCI_AMD_0x96_HOST	(1 << 9)
-#define XHCI_TRUST_TX_LENGTH	(1 << 10)
-#define XHCI_LPM_SUPPORT	(1 << 11)
-#define XHCI_INTEL_HOST		(1 << 12)
-#define XHCI_SPURIOUS_REBOOT	(1 << 13)
-#define XHCI_COMP_MODE_QUIRK	(1 << 14)
-#define XHCI_AVOID_BEI		(1 << 15)
-#define XHCI_PLAT		(1 << 16)
-#define XHCI_SLOW_SUSPEND	(1 << 17)
-#define XHCI_SPURIOUS_WAKEUP	(1 << 18)
+#define XHCI_EP_LIMIT_QUIRK	BIT_ULL(5)
+#define XHCI_BROKEN_MSI		BIT_ULL(6)
+#define XHCI_RESET_ON_RESUME	BIT_ULL(7)
+#define	XHCI_SW_BW_CHECKING	BIT_ULL(8)
+#define XHCI_AMD_0x96_HOST	BIT_ULL(9)
+#define XHCI_TRUST_TX_LENGTH	BIT_ULL(10)
+#define XHCI_LPM_SUPPORT	BIT_ULL(11)
+#define XHCI_INTEL_HOST		BIT_ULL(12)
+#define XHCI_SPURIOUS_REBOOT	BIT_ULL(13)
+#define XHCI_COMP_MODE_QUIRK	BIT_ULL(14)
+#define XHCI_AVOID_BEI		BIT_ULL(15)
+#define XHCI_PLAT		BIT_ULL(16)
+#define XHCI_SLOW_SUSPEND	BIT_ULL(17)
+#define XHCI_SPURIOUS_WAKEUP	BIT_ULL(18)
 /* For controllers with a broken beyond repair streams implementation */
-#define XHCI_BROKEN_STREAMS	(1 << 19)
-#define XHCI_PME_STUCK_QUIRK	(1 << 20)
-#define XHCI_MTK_HOST		(1 << 21)
-#define XHCI_SSIC_PORT_UNUSED	(1 << 22)
-#define XHCI_NO_64BIT_SUPPORT	(1 << 23)
-#define XHCI_MISSING_CAS	(1 << 24)
+#define XHCI_BROKEN_STREAMS	BIT_ULL(19)
+#define XHCI_PME_STUCK_QUIRK	BIT_ULL(20)
+#define XHCI_MTK_HOST		BIT_ULL(21)
+#define XHCI_SSIC_PORT_UNUSED	BIT_ULL(22)
+#define XHCI_NO_64BIT_SUPPORT	BIT_ULL(23)
+#define XHCI_MISSING_CAS	BIT_ULL(24)
 /* For controller with a broken Port Disable implementation */
-#define XHCI_BROKEN_PORT_PED	(1 << 25)
-#define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
-#define XHCI_U2_DISABLE_WAKE	(1 << 27)
-#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
-#define XHCI_HW_LPM_DISABLE	(1 << 29)
-#define XHCI_SUSPEND_DELAY	(1 << 30)
-#define XHCI_INTEL_USB_ROLE_SW	(1 << 31)
+#define XHCI_BROKEN_PORT_PED	BIT_ULL(25)
+#define XHCI_LIMIT_ENDPOINT_INTERVAL_7	BIT_ULL(26)
+#define XHCI_U2_DISABLE_WAKE	BIT_ULL(27)
+#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	BIT_ULL(28)
+#define XHCI_HW_LPM_DISABLE	BIT_ULL(29)
+#define XHCI_SUSPEND_DELAY	BIT_ULL(30)
+#define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit 07f7619053874ba60d620367b965b8a0ae38a696
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 21 16:40:04 2018 +0300

    xhci: xhci-mem: remove port_arrays and the code initializing them
    
    As we are now using the new port strtuctes the port_arrays
    are no longer needed, remove them completely
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f1b37d3946b2..6c5f00178d09 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1846,17 +1846,9 @@ struct xhci_hcd {
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
 	struct xhci_bus_state   bus_state[2];
-	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
-	u8			*port_array;
 	struct xhci_port	*hw_ports;
-	/* Array of pointers to USB 3.0 PORTSC registers */
-	__le32 __iomem		**usb3_ports;
-	unsigned int		num_usb3_ports;
-	/* Array of pointers to USB 2.0 PORTSC registers */
-	__le32 __iomem		**usb2_ports;
 	struct xhci_hub		usb2_rhub;
 	struct xhci_hub		usb3_rhub;
-	unsigned int		num_usb2_ports;
 	/* support xHCI 0.96 spec USB2 software LPM */
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */

commit eaefcf246b56ec888ccbbb6b39da688166d4d4fb
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 21 16:40:00 2018 +0300

    xhci: change xhci_test_and_clear_bit() to use new port structure
    
    Don't use pointers to port array and port index as function parameters
    in xhci_test_and_clear_bit(), just use a pointer to the right port
    structure.
    
    xhci_test_and_clear_bit() was the last port_array user in
    xhci_get_port_status() and handle_port_status(), so remove the
    port_array from them as well.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a13b43105a8f..f1b37d3946b2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2104,8 +2104,8 @@ unsigned int count_trbs(u64 addr, u64 len);
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,
 				u32 link_state);
-void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
-				int port_id, u32 port_bit);
+void xhci_test_and_clear_bit(struct xhci_hcd *xhci, struct xhci_port *port,
+				u32 port_bit);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);

commit 6b7f40f712344ec8fdca10450834825094e797fb
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 21 16:39:59 2018 +0300

    xhci: change xhci_set_link_state() to work with port structures
    
    Remove old iomem port array and index as parameters, just
    send a ponter to a port strucure instread
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cdf8e1adc06f..a13b43105a8f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2102,8 +2102,8 @@ void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring);
 unsigned int count_trbs(u64 addr, u64 len);
 
 /* xHCI roothub code */
-void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
-				int port_id, u32 link_state);
+void xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,
+				u32 link_state);
 void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 port_bit);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit ffd4b4fc0b9a1526b64240676d309506b2d5eceb
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 21 16:39:54 2018 +0300

    xhci: Add helper to get xhci roothub from hcd
    
    quick way to get the xhci roothub and thus all the ports
    belonging to a certain hcd
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 38aa8a6777a8..cdf8e1adc06f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2110,6 +2110,8 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
 int xhci_find_raw_port_number(struct usb_hcd *hcd, int port1);
+struct xhci_hub *xhci_get_rhub(struct usb_hcd *hcd);
+
 void xhci_hc_died(struct xhci_hcd *xhci);
 
 #ifdef CONFIG_PM

commit bcaa9d5c59005eceed5f2112c13240401f0fb93b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon May 21 16:39:52 2018 +0300

    xhci: Create new structures to store xhci port information
    
    Current way of having one array telling only the port speed,
    and then two separate arrays with mmio addresses for usb2 and usb3 ports
    requeres helper functions to transate  hw to hcd, and hcd to hw port
    numbers, and is hard to expand.
    
    Instead create a structure describing a port, including the mmio address,
    the port hardware index, hcd port index, and a pointer to the roothub
    it belongs to.
    
    Create one array containing all port structures in the same order the
    hardware controller sees them. Then add an array of port pointers to
    each xhci hub structure pointing to the ports that belonging to the
    roothub.
    
    This way we can easily convert hw indexed port events to usb core
    hcd port numbers, and vice versa usb core hub hcd port numbers
    to hw index and mmio address.
    
    Other benefit is that we can easily find the parent hcd and xhci
    structure of a port structure. This is useful in debugfs where
    we can give one port structure pointer as parameter and get both
    the correct mmio address and xhci lock needed to set some port
    parameter.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6dfc4867dbcf..38aa8a6777a8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1683,13 +1683,23 @@ static inline unsigned int hcd_index(struct usb_hcd *hcd)
 	else
 		return 1;
 }
+struct xhci_port {
+	__le32 __iomem		*addr;
+	int			hw_portnum;
+	int			hcd_portnum;
+	struct xhci_hub		*rhub;
+};
 
 struct xhci_hub {
-	u8	maj_rev;
-	u8	min_rev;
-	u32	*psi;		/* array of protocol speed ID entries */
-	u8	psi_count;
-	u8	psi_uid_count;
+	struct xhci_port	**ports;
+	unsigned int		num_ports;
+	struct usb_hcd		*hcd;
+	/* supported prococol extended capabiliy values */
+	u8			maj_rev;
+	u8			min_rev;
+	u32			*psi;	/* array of protocol speed ID entries */
+	u8			psi_count;
+	u8			psi_uid_count;
 };
 
 /* There is one xhci_hcd structure per controller */
@@ -1838,6 +1848,7 @@ struct xhci_hcd {
 	struct xhci_bus_state   bus_state[2];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
 	u8			*port_array;
+	struct xhci_port	*hw_ports;
 	/* Array of pointers to USB 3.0 PORTSC registers */
 	__le32 __iomem		**usb3_ports;
 	unsigned int		num_usb3_ports;

commit 0fd2060ad42726de387e0e78b3d34a3b7e47a6e1
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Thu Apr 19 15:30:53 2018 +0200

    usb: host: xhci-plat: Fix clock resource by adding a register clock
    
    On Armada 7K/8K we need to explicitly enable the register clock. This
    clock is optional because not all the SoCs using this IP need it but at
    least for Armada 7K/8K it is actually mandatory.
    
    The change was done at xhci-plat level and not at a xhci-mvebu.c because,
    it is expected that other SoC would have this kind of constraint.
    
    The binding documentation is updating accordingly.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 05c909b04f14..6dfc4867dbcf 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1729,8 +1729,9 @@ struct xhci_hcd {
 	int		page_shift;
 	/* msi-x vectors */
 	int		msix_count;
-	/* optional clock */
+	/* optional clocks */
 	struct clk		*clk;
+	struct clk		*reg_clk;
 	/* data structures */
 	struct xhci_device_context_array *dcbaa;
 	struct xhci_ring	*cmd_ring;

commit fa31b3cb2ae143aa6e26974fcbe75689da60bdbe
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Mar 20 15:57:09 2018 +0300

    xhci: Add Intel extended cap / otg phy mux handling
    
    The xHCI controller on various Intel SoCs has an extended cap mmio-range
    which contains registers to control the muxing to the xHCI (host mode)
    or the dwc3 (device mode) and vbus-detection for the otg usb-phy.
    
    Having a role-sw driver included in the xHCI code (under drivers/usb/host)
    is not desirable. So this commit adds a simple handler for this extended
    capability, which creates a platform device with the caps mmio region as
    resource, this allows us to write a separate platform role-sw driver for
    the role-switch.
    
    Note this commit adds a call to the new xhci_ext_cap_init() function
    to xhci_pci_probe(), it is added here because xhci_ext_cap_init() must
    be called only once. If in the future we also want to handle ext-caps
    on non pci xHCI HCDs from xhci_ext_cap_init() a call to it should also
    be added to other bus probe paths.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8acc8f8d790f..05c909b04f14 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1829,6 +1829,7 @@ struct xhci_hcd {
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 #define XHCI_HW_LPM_DISABLE	(1 << 29)
 #define XHCI_SUSPEND_DELAY	(1 << 30)
+#define XHCI_INTEL_USB_ROLE_SW	(1 << 31)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
@@ -2024,6 +2025,7 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 void xhci_init_driver(struct hc_driver *drv,
 		      const struct xhci_driver_overrides *over);
 int xhci_disable_slot(struct xhci_hcd *xhci, u32 slot_id);
+int xhci_ext_cap_init(struct xhci_hcd *xhci);
 
 int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);
 int xhci_resume(struct xhci_hcd *xhci, bool hibernated);

commit a8f25c36f7322fd089e6d006b4e3708038882561
Merge: 225b3dc92da1 c698ca527893
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 20 09:56:08 2018 +0100

    Merge branch 4.16-rc6 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f5249461b504d35aa1a40140983b7ec415807d9e
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Mar 16 16:33:04 2018 +0200

    xhci: Clear the host side toggle manually when endpoint is soft reset
    
    Some devices use a clear endpoint halt request as a soft reset, even if
    the endpoint is not halted. This will clear the toggle and sequence on the
    device side.
    
    xHCI however refuses to reset a non-halted endpoint, so instead
    we need to issue a configure endpoint command on xHCI to clear its host
    side toggle and sequence, and get it in sync with the device side.
    
    This is a respin of a old patch that was reverted as it had a stale
    endpoint context dequeue value which caused regression.
    commit 27082e2654dc ("xhci: Clear the host side toggle manually when
    endpoint is 'soft reset'")
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e4d7d3d06a75..9f236da1093d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -921,6 +921,8 @@ struct xhci_virt_ep {
 #define EP_HAS_STREAMS		(1 << 4)
 /* Transitioning the endpoint to not using streams, don't enqueue URBs */
 #define EP_GETTING_NO_STREAMS	(1 << 5)
+#define EP_HARD_CLEAR_TOGGLE	(1 << 6)
+#define EP_SOFT_CLEAR_TOGGLE	(1 << 7)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
 	/* Watchdog timer for stop endpoint command to cancel URBs */

commit 191edc5e2e515aab1075a3f0ef23599e80be5f59
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Thu Mar 8 17:17:17 2018 +0200

    xhci: Fix front USB ports on ASUS PRIME B350M-A
    
    When a USB device gets plugged on ASUS PRIME B350M-A's front ports, the
    xHC stops working:
    [  549.114587] xhci_hcd 0000:02:00.0: WARN: xHC CMD_RUN timeout
    [  549.114608] suspend_common(): xhci_pci_suspend+0x0/0xc0 returns -110
    [  549.114638] xhci_hcd 0000:02:00.0: can't suspend (hcd_pci_runtime_suspend returned -110)
    
    Delay before running xHC command CMD_RUN can workaround the issue.
    
    Use a new quirk to make the delay only targets to the affected xHC.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d20e57b35d32..866e141d4972 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1826,6 +1826,7 @@ struct xhci_hcd {
 #define XHCI_U2_DISABLE_WAKE	(1 << 27)
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 #define XHCI_HW_LPM_DISABLE	(1 << 29)
+#define XHCI_SUSPEND_DELAY	(1 << 30)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit 97ef0faf575e03b352553f92c9430cb4c0431436
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Mar 8 17:17:14 2018 +0200

    xhci: fix endpoint context tracer output
    
    Fix incorrent values showed for max Primary stream and
    Linear stream array (LSA) values in the endpoint context
    decoder.
    
    Fixes: 19a7d0d65c4a ("usb: host: xhci: add Slot and EP Context tracers")
    Cc: <stable@vger.kernel.org> # v4.12+
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e4d7d3d06a75..d20e57b35d32 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -718,11 +718,12 @@ struct xhci_ep_ctx {
 /* bits 10:14 are Max Primary Streams */
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
-#define EP_INTERVAL(p)		(((p) & 0xff) << 16)
-#define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
-#define CTX_TO_EP_INTERVAL(p)	(((p) >> 16) & 0xff)
-#define EP_MAXPSTREAMS_MASK	(0x1f << 10)
-#define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
+#define EP_INTERVAL(p)			(((p) & 0xff) << 16)
+#define EP_INTERVAL_TO_UFRAMES(p)	(1 << (((p) >> 16) & 0xff))
+#define CTX_TO_EP_INTERVAL(p)		(((p) >> 16) & 0xff)
+#define EP_MAXPSTREAMS_MASK		(0x1f << 10)
+#define EP_MAXPSTREAMS(p)		(((p) << 10) & EP_MAXPSTREAMS_MASK)
+#define CTX_TO_EP_MAXPSTREAMS(p)	(((p) & EP_MAXPSTREAMS_MASK) >> 10)
 /* Endpoint is set up with a Linear Stream Array (vs. Secondary Stream Array) */
 #define	EP_HAS_LSA		(1 << 15)
 /* hosts with LEC=1 use bits 31:24 as ESIT high bits. */
@@ -2549,21 +2550,22 @@ static inline const char *xhci_decode_ep_context(u32 info, u32 info2, u64 deq,
 	u8 burst;
 	u8 cerr;
 	u8 mult;
-	u8 lsa;
-	u8 hid;
+
+	bool lsa;
+	bool hid;
 
 	esit = CTX_TO_MAX_ESIT_PAYLOAD_HI(info) << 16 |
 		CTX_TO_MAX_ESIT_PAYLOAD(tx_info);
 
 	ep_state = info & EP_STATE_MASK;
-	max_pstr = info & EP_MAXPSTREAMS_MASK;
+	max_pstr = CTX_TO_EP_MAXPSTREAMS(info);
 	interval = CTX_TO_EP_INTERVAL(info);
 	mult = CTX_TO_EP_MULT(info) + 1;
-	lsa = info & EP_HAS_LSA;
+	lsa = !!(info & EP_HAS_LSA);
 
 	cerr = (info2 & (3 << 1)) >> 1;
 	ep_type = CTX_TO_EP_TYPE(info2);
-	hid = info2 & (1 << 7);
+	hid = !!(info2 & (1 << 7));
 	burst = CTX_TO_MAX_BURST(info2);
 	maxp = MAX_PACKET_DECODED(info2);
 

commit bde0716d1f076e4c913c7946bcc858f71243c7a0
Author: Joe Lee <asmt.swfae@gmail.com>
Date:   Mon Feb 12 14:24:46 2018 +0200

    xhci: workaround for AMD Promontory disabled ports wakeup
    
    For AMD Promontory xHCI host, although you can disable USB ports in
    BIOS settings, those ports will be enabled anyway after you remove a
    device on that port and re-plug it in again. It's a known limitation of
    the chip. As a workaround we can clear the PORT_WAKE_BITS.
    
    [commit and code comment rephrasing -Mathias]
    Signed-off-by: Joe Lee <asmt.swfae@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 96099a245c69..e4d7d3d06a75 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1822,7 +1822,7 @@ struct xhci_hcd {
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
-/* Reserved. It was XHCI_U2_DISABLE_WAKE */
+#define XHCI_U2_DISABLE_WAKE	(1 << 27)
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 #define XHCI_HW_LPM_DISABLE	(1 << 29)
 

commit ab725cbec3e83dc29cc00b733bd26063b588fa98
Author: Adam Wallis <awallis@codeaurora.org>
Date:   Fri Dec 8 17:59:13 2017 +0200

    usb: xhci: allow imod-interval to be configurable
    
    The xHCI driver currently has the IMOD set to 160, which
    translates to an IMOD interval of 40,000ns (160 * 250)ns
    
    Commit 0cbd4b34cda9 ("xhci: mediatek: support MTK xHCI host controller")
    introduced a QUIRK for the MTK platform to adjust this interval to 20,
    which translates to an IMOD interval of 5,000ns (20 * 250)ns. This is
    due to the fact that the MTK controller IMOD interval is 8 times
    as much as defined in xHCI spec.
    
    Instead of adding more quirk bits for additional platforms, this patch
    introduces the ability for vendors to set the IMOD_INTERVAL as is
    optimal for their platform. By using device_property_read_u32() on
    "imod-interval-ns", the IMOD INTERVAL can be specified in nano seconds.
    If no interval is specified, the default of 40,000ns (IMOD=160) will be
    used.
    
    No bounds checking has been implemented due to the fact that a vendor
    may have violated the spec and would need to specify a value outside of
    the max 8,000 IRQs/second limit specified in the xHCI spec.
    
    Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Adam Wallis <awallis@codeaurora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7c8781758cea..96099a245c69 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1717,6 +1717,8 @@ struct xhci_hcd {
 	u8		max_interrupters;
 	u8		max_ports;
 	u8		isoc_threshold;
+	/* imod_interval in ns (I * 250ns) */
+	u32		imod_interval;
 	int		event_ring_max;
 	/* 4KB min, 128MB max */
 	int		page_size;

commit 3054ea45fb8758b7c1a4849001e213e1267452fa
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Dec 8 17:59:12 2017 +0200

    usb: xhci: Cleanup printk debug message for ERST
    
    Each event segment has been exposed through debugfs. There is no
    need to dump ERST content with printk in code. Remove it to make
    code more concise and readable.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8ab2d83b7527..7c8781758cea 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1925,7 +1925,6 @@ static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 }
 
 /* xHCI debugging */
-void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
 void xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),

commit 4c116cb138977838786257f039003eb76a05dc7a
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Dec 8 17:59:11 2017 +0200

    usb: xhci: Cleanup printk debug message for registers
    
    The content of each register has been exposed through debugfs.
    There is no need to dump register content with printk in code
    lines. Remove them to make code more concise and readable.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e613344f050a..8ab2d83b7527 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1925,12 +1925,7 @@ static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 }
 
 /* xHCI debugging */
-void xhci_print_ir_set(struct xhci_hcd *xhci, int set_num);
-void xhci_print_registers(struct xhci_hcd *xhci);
-void xhci_dbg_regs(struct xhci_hcd *xhci);
-void xhci_print_run_regs(struct xhci_hcd *xhci);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
-void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
 void xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),

commit dfba2174dc421ecad8dc50741054a305cd3ba681
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Dec 8 17:59:10 2017 +0200

    usb: xhci: Add DbC support in xHCI driver
    
    xHCI compatible USB host controllers(i.e. super-speed USB3 controllers)
    can be implemented with the Debug Capability(DbC). It presents a debug
    device which is fully compliant with the USB framework and provides the
    equivalent of a very high performance full-duplex serial link. The debug
    capability operation model and registers interface are defined in 7.6.8
    of the xHCI specification, revision 1.1.
    
    The DbC debug device shares a root port with the xHCI host. By default,
    the debug capability is disabled and the root port is assigned to xHCI.
    When the DbC is enabled, the root port will be assigned to the DbC debug
    device, and the xHCI sees nothing on this port. This implementation uses
    a sysfs node named <dbc> under the xHCI device to manage the enabling
    and disabling of the debug capability.
    
    When the debug capability is enabled, it will present a debug device
    through the debug port. This debug device is fully compliant with the
    USB3 framework, and it can be enumerated by a debug host on the other
    end of the USB link. As soon as the debug device is configured, a TTY
    serial device named /dev/ttyDBC0 will be created.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f1515500ed88..e613344f050a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1856,6 +1856,7 @@ struct xhci_hcd {
 	struct dentry		*debugfs_slots;
 	struct list_head	regset_list;
 
+	void			*dbc;
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
 };

commit 67d2ea9fde2aa96f36af0537e4004efb123319fb
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Dec 8 17:59:09 2017 +0200

    usb: xhci: Make some static functions global
    
    This patch makes some static functions global to avoid duplications
    in different files. These functions can be used in the implementation
    of xHCI debug capability. There is no functional change.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e78a20aec8be..f1515500ed88 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1965,9 +1965,17 @@ void xhci_slot_copy(struct xhci_hcd *xhci,
 int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
+struct xhci_ring *xhci_ring_alloc(struct xhci_hcd *xhci,
+		unsigned int num_segs, unsigned int cycle_state,
+		enum xhci_ring_type type, unsigned int max_packet, gfp_t flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 int xhci_ring_expansion(struct xhci_hcd *xhci, struct xhci_ring *ring,
-				unsigned int num_trbs, gfp_t flags);
+		unsigned int num_trbs, gfp_t flags);
+int xhci_alloc_erst(struct xhci_hcd *xhci,
+		struct xhci_ring *evt_ring,
+		struct xhci_erst *erst,
+		gfp_t flags);
+void xhci_free_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_free_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);
@@ -1998,6 +2006,10 @@ struct xhci_command *xhci_alloc_command_with_ctx(struct xhci_hcd *xhci,
 void xhci_urb_free_priv(struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
+struct xhci_container_ctx *xhci_alloc_container_ctx(struct xhci_hcd *xhci,
+		int type, gfp_t flags);
+void xhci_free_container_ctx(struct xhci_hcd *xhci,
+		struct xhci_container_ctx *ctx);
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
@@ -2071,6 +2083,8 @@ void xhci_handle_command_timeout(struct work_struct *work);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
+void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring);
+unsigned int count_trbs(u64 addr, u64 len);
 
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,

commit 103afda0e6ac58927bc85dc5a7ebc0f51892f407
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 8 17:59:08 2017 +0200

    xhci: remove unnecessary boolean parameter from xhci_alloc_command
    
    commands with input contexts are allocated with the
    xhci_alloc_command_with_ctx helper.
    
    No functional changes
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 147f1a0cb933..e78a20aec8be 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1992,8 +1992,7 @@ struct xhci_ring *xhci_stream_id_to_ring(
 		unsigned int ep_index,
 		unsigned int stream_id);
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
-		bool allocate_in_ctx, bool allocate_completion,
-		gfp_t mem_flags);
+		bool allocate_completion, gfp_t mem_flags);
 struct xhci_command *xhci_alloc_command_with_ctx(struct xhci_hcd *xhci,
 		bool allocate_completion, gfp_t mem_flags);
 void xhci_urb_free_priv(struct urb_priv *urb_priv);

commit 14d49b7a0bfe76ef694a61e0c7b5f091ea780b91
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 8 17:59:07 2017 +0200

    xhci: add helper to allocate command with input context
    
    Add a xhci_alloc_command_with_ctx() helper to get rid of
    one of the boolean parameters telling if a context should
    be allocated with the command.
    
    No functional changes, improves core readability
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 99a014a920d3..147f1a0cb933 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1994,6 +1994,8 @@ struct xhci_ring *xhci_stream_id_to_ring(
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_in_ctx, bool allocate_completion,
 		gfp_t mem_flags);
+struct xhci_command *xhci_alloc_command_with_ctx(struct xhci_hcd *xhci,
+		bool allocate_completion, gfp_t mem_flags);
 void xhci_urb_free_priv(struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);

commit 9ed64195e35efa8901d20a0cd8ff3668ae68e7d6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:23 2017 +0100

    USB: host: xhci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dd8bcdf64a9f..99a014a920d3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -7,19 +7,6 @@
  *
  * Author: Sarah Sharp
  * Some code borrowed from the Linux EHCI driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #ifndef __LINUX_XHCI_HCD_H

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 86df906aec46..dd8bcdf64a9f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 
 /*
  * xHCI host controller driver

commit 66a4550308b8391fecd46c7e733cbccb3e01ee96
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:16:58 2017 -0700

    xhci: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Mathias Nyman <mathias.nyman@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-usb@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b966cd878351..86df906aec46 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2076,7 +2076,7 @@ void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int ep_index,
 		unsigned int stream_id, struct xhci_td *td);
-void xhci_stop_endpoint_command_watchdog(unsigned long arg);
+void xhci_stop_endpoint_command_watchdog(struct timer_list *t);
 void xhci_handle_command_timeout(struct work_struct *work);
 
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,

commit 4fcae770f3027abefd952c5d511ac6299828865a
Merge: 2847d242a1e4 8a5776a5f498
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 9 09:11:09 2017 +0200

    Merge 4.14-rc4 into usb-next
    
    This merges in the USB fixes that we need here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cd3f1790b006d91786728c20a01da21ee277aff1
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Oct 5 11:21:41 2017 +0300

    usb: xhci: Fix potential memory leak in xhci_disable_slot()
    
    xhci_disable_slot() allows the invoker to pass a command pointer
    as paramenter. Otherwise, it will allocate one. This will cause
    memory leak when a command structure was allocated inside of this
    function while queuing command trb fails. Another problem comes up
    when the invoker passed a command pointer, but xhci_disable_slot()
    frees it when it detects a dead host.
    
    This patch fixes these two problems by removing the command parameter
    from xhci_disable_slot().
    
    Fixes: f9e609b82479 ("usb: xhci: Add helper function xhci_disable_slot().")
    Cc: Guoqing Zhang <guoqing.zhang@intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ccf0ca3ed71e..7379309f4d1f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2019,8 +2019,7 @@ int xhci_run(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 void xhci_init_driver(struct hc_driver *drv,
 		      const struct xhci_driver_overrides *over);
-int xhci_disable_slot(struct xhci_hcd *xhci,
-			struct xhci_command *command, u32 slot_id);
+int xhci_disable_slot(struct xhci_hcd *xhci, u32 slot_id);
 
 int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);
 int xhci_resume(struct xhci_hcd *xhci, bool hibernated);

commit 02b6fdc2a153e61b957937772a562fb6357dc861
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Oct 5 11:21:39 2017 +0300

    usb: xhci: Add debugfs interface for xHCI driver
    
    This adds debugfs consumer for xHCI driver. The debugfs entries
    read all host registers, device/endpoint contexts, command ring,
    event ring and various endpoint rings. With these entries, users
    can check the registers and memory spaces used by a host during
    run time, or save all the information with a simple 'cp -r' for
    post-mortem programs.
    
    The file hierarchy looks like this.
    
    [root of debugfs]
    |__usb
    |____[e,u,o]hci                 <---------[root for other HCIs]
    |____xhci                       <---------------[root for xHCI]
    |______0000:00:14.0             <--------------[xHCI host name]
    |________reg-cap                <--------[capability registers]
    |________reg-op                 <-------[operational registers]
    |________reg-runtime            <-----------[runtime registers]
    |________reg-ext-#cap_name      <----[extended capability regs]
    |________command-ring           <-------[root for command ring]
    |__________cycle                <------------------[ring cycle]
    |__________dequeue              <--------[ring dequeue pointer]
    |__________enqueue              <--------[ring enqueue pointer]
    |__________trbs                 <-------------------[ring trbs]
    |________event-ring             <---------[root for event ring]
    |__________cycle                <------------------[ring cycle]
    |__________dequeue              <--------[ring dequeue pointer]
    |__________enqueue              <--------[ring enqueue pointer]
    |__________trbs                 <-------------------[ring trbs]
    |________devices                <------------[root for devices]
    |__________#slot_id             <-----------[root for a device]
    |____________name               <-----------------[device name]
    |____________slot-context       <----------------[slot context]
    |____________ep-context         <-----------[endpoint contexts]
    |____________ep#ep_index        <--------[root for an endpoint]
    |______________cycle            <------------------[ring cycle]
    |______________dequeue          <--------[ring dequeue pointer]
    |______________enqueue          <--------[ring enqueue pointer]
    |______________trbs             <-------------------[ring trbs]
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ea176da627cd..ccf0ca3ed71e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -131,6 +131,8 @@ struct xhci_cap_regs {
 /* Extended Capabilities pointer from PCI base - section 5.3.6 */
 #define HCC_EXT_CAPS(p)		XHCI_HCC_EXT_CAPS(p)
 
+#define CTX_SIZE(_hcc)		(HCC_64BYTE_CONTEXT(_hcc) ? 64 : 32)
+
 /* db_off bitmask - bits 0:1 reserved */
 #define	DBOFF_MASK	(~0x3)
 
@@ -1005,6 +1007,8 @@ struct xhci_virt_device {
 	struct xhci_tt_bw_info		*tt_info;
 	/* The current max exit latency for the enabled USB3 link states. */
 	u16				current_mel;
+	/* Used for the debugfs interfaces. */
+	void				*debugfs_private;
 };
 
 /*
@@ -1858,6 +1862,10 @@ struct xhci_hcd {
 /* Compliance Mode Timer Triggered every 2 seconds */
 #define COMP_MODE_RCVRY_MSECS 2000
 
+	struct dentry		*debugfs_root;
+	struct dentry		*debugfs_slots;
+	struct list_head	regset_list;
+
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
 };
@@ -2106,6 +2114,7 @@ struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container
 struct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		unsigned int stream_id);
+
 static inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
 								struct urb *urb)
 {

commit 8f11487719401e20ecc58c114d9fc3177535c40a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 5 11:21:38 2017 +0300

    xhci: add port speed ID to portsc tracing
    
    Shows the port speed protocol speed ID (PSID) in use.
    speed ID may map to custom speeds, but in most cases it uses default
    
    1 = Full-Speed        12 MB/s
    2 = Low-Speed         1.5 Mb/s
    3 = High-speed        480 Mb/s
    4 = SuperSpeed        5 Gb/s
    5 = SuperSpeedPlus    10 Gb/s
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dc22392711e3..ea176da627cd 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2441,11 +2441,12 @@ static inline const char *xhci_decode_portsc(u32 portsc)
 	static char str[256];
 	int ret;
 
-	ret = sprintf(str, "%s %s %s Link:%s ",
+	ret = sprintf(str, "%s %s %s Link:%s PortSpeed:%d ",
 		      portsc & PORT_POWER	? "Powered" : "Powered-off",
 		      portsc & PORT_CONNECT	? "Connected" : "Not-connected",
 		      portsc & PORT_PE		? "Enabled" : "Disabled",
-		      xhci_portsc_link_state_string(portsc));
+		      xhci_portsc_link_state_string(portsc),
+		      DEV_PORT_SPEED(portsc));
 
 	if (portsc & PORT_OC)
 		ret += sprintf(str + ret, "OverCurrent ");

commit 4750bc78efdb126ddc40f1b34dbae7ce319344cb
Author: Thang Q. Nguyen <tqnguyen@apm.com>
Date:   Thu Oct 5 11:21:37 2017 +0300

    usb: host: xhci support option to disable the xHCI USB2 HW LPM
    
    XHCI specification 1.1 does not require xHCI-compliant controllers
    to always enable hardware USB2 LPM. However, the current xHCI
    driver always enable it when seeing HLC=1.
    This patch supports an option for users to control disabling
    USB2 Hardware LPM via DT/ACPI attribute.
    This option is needed in case user would like to disable this
    feature. For example, their xHCI controller has its USB2 HW LPM
    broken.
    
    Signed-off-by: Tung Nguyen <tunguyen@apm.com>
    Signed-off-by: Thang Q. Nguyen <tqnguyen@apm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2abaa4d6d39d..dc22392711e3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1828,6 +1828,7 @@ struct xhci_hcd {
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
 #define XHCI_U2_DISABLE_WAKE	(1 << 27)
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
+#define XHCI_HW_LPM_DISABLE	(1 << 29)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit bcd6a7aa13800afc1418e6b29d944d882214939a
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Sep 18 17:39:19 2017 +0300

    Revert "xhci: Limit USB2 port wake support for AMD Promontory hosts"
    
    This reverts commit dec08194ffeccfa1cf085906b53d301930eae18f.
    
    Commit dec08194ffec ("xhci: Limit USB2 port wake support for AMD Promontory
    hosts") makes all high speed USB ports on ASUS PRIME B350M-A cease to
    function after enabling runtime PM.
    
    All boards with this chipsets will be affected, so revert the commit.
    
    The original patch was added to stable 4.9, 4.11 and 4.12 and needs
    to reverted from there as well
    
    Cc: <stable@vger.kernel.org> # 4.9+
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7c87189e8110..2b48aa4f6b76 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1828,7 +1828,7 @@ struct xhci_hcd {
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
-#define XHCI_U2_DISABLE_WAKE	(1 << 27)
+/* Reserved. It was XHCI_U2_DISABLE_WAKE */
 #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 
 	unsigned int		num_active_eps;

commit 76a14d7bf92960aac2f5450bfd23783bfa618be9
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Sep 18 17:39:15 2017 +0300

    xhci: fix wrong endpoint ESIT value shown in tracing
    
    Read the endpiont ESIT from endpiont context using correct macro.
    Add a macro for reading the high bits of ESIT for Large ESIT Payload
    Capable hosts (LEC=1)
    
    Cc: <stable@vger.kernel.org> # 4.12
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e96e90d0fe9f..7c87189e8110 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -735,6 +735,8 @@ struct xhci_ep_ctx {
 #define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
 /* Endpoint is set up with a Linear Stream Array (vs. Secondary Stream Array) */
 #define	EP_HAS_LSA		(1 << 15)
+/* hosts with LEC=1 use bits 31:24 as ESIT high bits. */
+#define CTX_TO_MAX_ESIT_PAYLOAD_HI(p)	(((p) >> 24) & 0xff)
 
 /* ep_info2 bitmasks */
 /*
@@ -2540,8 +2542,8 @@ static inline const char *xhci_decode_ep_context(u32 info, u32 info2, u64 deq,
 	u8 lsa;
 	u8 hid;
 
-	esit = EP_MAX_ESIT_PAYLOAD_HI(info) << 16 |
-		EP_MAX_ESIT_PAYLOAD_LO(tx_info);
+	esit = CTX_TO_MAX_ESIT_PAYLOAD_HI(info) << 16 |
+		CTX_TO_MAX_ESIT_PAYLOAD(tx_info);
 
 	ep_state = info & EP_STATE_MASK;
 	max_pstr = info & EP_MAXPSTREAMS_MASK;

commit 5a838a13c9b4e5dd188b7a6eaeb894e9358ead0c
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Sep 18 17:39:13 2017 +0300

    xhci: fix finding correct bus_state structure for USB 3.1 hosts
    
    xhci driver keeps a bus_state structure for each hcd (usb2 and usb3)
    
    The structure is picked based on hcd speed, but driver only compared
    for HCD_USB3 speed, returning the wrong bus_state for HCD_USB31 hosts.
    
    This caused null pointer dereference errors in bus_resume function.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2abaa4d6d39d..e96e90d0fe9f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1681,7 +1681,7 @@ struct xhci_bus_state {
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
-	if (hcd->speed == HCD_USB3)
+	if (hcd->speed >= HCD_USB3)
 		return 0;
 	else
 		return 1;

commit 2e77a8253d1db03deceb2a1b265307f21e2a879a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Wed Aug 16 14:23:22 2017 +0300

    xhci: Add port status decoder for tracing purposes
    
    Add PORTSC Port status and control register decoder to
    show human readable tracing of portsc register
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 18fe51c4ca85..2abaa4d6d39d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2399,6 +2399,87 @@ static inline const char *xhci_decode_slot_context(u32 info, u32 info2,
 	return str;
 }
 
+
+static inline const char *xhci_portsc_link_state_string(u32 portsc)
+{
+	switch (portsc & PORT_PLS_MASK) {
+	case XDEV_U0:
+		return "U0";
+	case XDEV_U1:
+		return "U1";
+	case XDEV_U2:
+		return "U2";
+	case XDEV_U3:
+		return "U3";
+	case XDEV_DISABLED:
+		return "Disabled";
+	case XDEV_RXDETECT:
+		return "RxDetect";
+	case XDEV_INACTIVE:
+		return "Inactive";
+	case XDEV_POLLING:
+		return "Polling";
+	case XDEV_RECOVERY:
+		return "Recovery";
+	case XDEV_HOT_RESET:
+		return "Hot Reset";
+	case XDEV_COMP_MODE:
+		return "Compliance mode";
+	case XDEV_TEST_MODE:
+		return "Test mode";
+	case XDEV_RESUME:
+		return "Resume";
+	default:
+		break;
+	}
+	return "Unknown";
+}
+
+static inline const char *xhci_decode_portsc(u32 portsc)
+{
+	static char str[256];
+	int ret;
+
+	ret = sprintf(str, "%s %s %s Link:%s ",
+		      portsc & PORT_POWER	? "Powered" : "Powered-off",
+		      portsc & PORT_CONNECT	? "Connected" : "Not-connected",
+		      portsc & PORT_PE		? "Enabled" : "Disabled",
+		      xhci_portsc_link_state_string(portsc));
+
+	if (portsc & PORT_OC)
+		ret += sprintf(str + ret, "OverCurrent ");
+	if (portsc & PORT_RESET)
+		ret += sprintf(str + ret, "In-Reset ");
+
+	ret += sprintf(str + ret, "Change: ");
+	if (portsc & PORT_CSC)
+		ret += sprintf(str + ret, "CSC ");
+	if (portsc & PORT_PEC)
+		ret += sprintf(str + ret, "PEC ");
+	if (portsc & PORT_WRC)
+		ret += sprintf(str + ret, "WRC ");
+	if (portsc & PORT_OCC)
+		ret += sprintf(str + ret, "OCC ");
+	if (portsc & PORT_RC)
+		ret += sprintf(str + ret, "PRC ");
+	if (portsc & PORT_PLC)
+		ret += sprintf(str + ret, "PLC ");
+	if (portsc & PORT_CEC)
+		ret += sprintf(str + ret, "CEC ");
+	if (portsc & PORT_CAS)
+		ret += sprintf(str + ret, "CAS ");
+
+	ret += sprintf(str + ret, "Wake: ");
+	if (portsc & PORT_WKCONN_E)
+		ret += sprintf(str + ret, "WCE ");
+	if (portsc & PORT_WKDISC_E)
+		ret += sprintf(str + ret, "WDE ");
+	if (portsc & PORT_WKOC_E)
+		ret += sprintf(str + ret, "WOE ");
+
+	return str;
+}
+
 static inline const char *xhci_ep_state_string(u8 state)
 {
 	switch (state) {

commit 7344ee328c5bd2a709d9d849306b8a7e3a78c74d
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Wed Aug 16 14:23:21 2017 +0300

    xhci: add definitions for all port link states
    
    Add definitions for all port link states defined in xhci
    specification for PORTSC register.
    
    Will be needed for human readable port status tracing
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e3e935291ed6..18fe51c4ca85 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -311,12 +311,19 @@ struct xhci_op_regs {
  */
 #define PORT_PLS_MASK	(0xf << 5)
 #define XDEV_U0		(0x0 << 5)
+#define XDEV_U1		(0x1 << 5)
 #define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
+#define XDEV_DISABLED	(0x4 << 5)
+#define XDEV_RXDETECT	(0x5 << 5)
 #define XDEV_INACTIVE	(0x6 << 5)
 #define XDEV_POLLING	(0x7 << 5)
-#define XDEV_COMP_MODE  (0xa << 5)
+#define XDEV_RECOVERY	(0x8 << 5)
+#define XDEV_HOT_RESET	(0x9 << 5)
+#define XDEV_COMP_MODE	(0xa << 5)
+#define XDEV_TEST_MODE	(0xb << 5)
 #define XDEV_RESUME	(0xf << 5)
+
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)
 /* bits 10:13 indicate device speed:

commit 9da5a1092b13468839b1a864b126cacfb72ad016
Author: Jiahau Chang <jiahau@gmail.com>
Date:   Thu Jul 20 14:48:27 2017 +0300

    xhci: Bad Ethernet performance plugged in ASM1042A host
    
    When USB Ethernet is plugged in ASMEDIA ASM1042A xHCI host, bad
    performance was manifesting in Web browser use (like download
    large file such as ISO image). It is known limitation of
    ASM1042A that is not compatible with driver scheduling,
    As a workaround we can modify flow control handling of ASM1042A.
    The register we modify is changes the behavior
    
    [use quirk bit 28, usleep_range 40-60us, empty non-pci function -Mathias]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Jiahau Chang <Lars_chang@asmedia.com.tw>
    Signed-off-by: Ian Pilcher <arequipeno@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3c6da1f93c84..e3e935291ed6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1820,6 +1820,7 @@ struct xhci_hcd {
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
 #define XHCI_U2_DISABLE_WAKE	(1 << 27)
+#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit 6481352082e8c373a005387c4fc7258b197f0bc9
Merge: df7cb187edc7 dec08194ffec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 13:42:04 2017 -0700

    Merge tag 'usb-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB fixes from Greg KH:
     "Here are some remaining USB fixes for 4.13-rc1. They were originally
      scheduled for 4.12-final, but I didn't send them to you in time.
      Because of that, they were in a separate branch from the larger USB
      set of patches, so here they are in a separate pull request.
    
      Nothing major here a all, just three small patches:
    
       - some usb-serial new device ids
       - xhci bugfix for some crazy AMD hardware
    
      All of these have been in linux-next for a long time with no reported
      issues"
    
    * tag 'usb-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb:
      xhci: Limit USB2 port wake support for AMD Promontory hosts
      USB: serial: qcserial: new Sierra Wireless EM7305 device ID
      USB: serial: option: add two Longcheer device ids

commit dec08194ffeccfa1cf085906b53d301930eae18f
Author: Jiahau Chang <jiahau@gmail.com>
Date:   Mon Jun 19 13:08:30 2017 +0300

    xhci: Limit USB2 port wake support for AMD Promontory hosts
    
    For AMD Promontory xHCI host, although you can disable USB 2.0 ports in
    BIOS settings, those ports will be enabled anyway after you remove a
    device on that port and re-plug it in again. It's a known limitation of
    the chip. As a workaround we can clear the PORT_WAKE_BITS.
    
    This will disable wake on connect, disconnect and overcurrent on
    AMD Promontory USB2 ports
    
    [checkpatch cleanup and commit message reword -Mathias]
    Cc: <stable@vger.kernel.org>
    Cc: Tsai Nicholas <nicholas.tsai@amd.com>
    Signed-off-by: Jiahau Chang <Lars_Chang@asmedia.com.tw>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 73a28a986d5e..dcd9649808c0 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1819,6 +1819,7 @@ struct xhci_hcd {
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
+#define XHCI_U2_DISABLE_WAKE	(1 << 27)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit d36374fdfb259bac4511762bb349e69c6d093d37
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Jun 15 11:55:47 2017 +0300

    xhci: cleanup virtual endoint structure, remove stopped_stream
    
    Get rid of stopped_stream member in virtual endpoint structure as
    it is only used in one case when cleaning a halted endpoint.
    
    Pass it as function parameter instead.
    
    No functional changes
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index acd66f7ea25c..650a2d9d4aec 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -924,7 +924,6 @@ struct xhci_virt_ep {
 #define EP_GETTING_NO_STREAMS	(1 << 5)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
-	unsigned int		stopped_stream;
 	/* Watchdog timer for stop endpoint command to cancel URBs */
 	struct timer_list	stop_cmd_timer;
 	struct xhci_hcd		*xhci;
@@ -2056,8 +2055,8 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
-void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
-		unsigned int ep_index, struct xhci_td *td);
+void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int ep_index,
+		unsigned int stream_id, struct xhci_td *td);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
 void xhci_handle_command_timeout(struct work_struct *work);
 

commit 217491487c43892318c18b6dcafe33b6353efd40
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Jun 15 11:55:44 2017 +0300

    xhci: Add support for endpoint soft reset
    
    xhci supports soft retry recovery when the host halted the host side of an
    endopint but the connected USB device is not aware of the halt.
    
    In this case xhci needs to issue a reset endopint command  with a TSP
    (Transfer State Preserve) flag set which preserves the Data toggle
    and Sequence number of the endpoint.
    
    This feature is needed to handle a few special transfer event types
    such as USB Transaction error that don't always point to a causing TRB.
    
    see xhci 4.6.8.1 for more details
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index deb85342e0a3..acd66f7ea25c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1205,6 +1205,11 @@ struct xhci_event_cmd {
 /* Stop Ring - Transfer State Preserve */
 #define TRB_TSP		(1<<9)
 
+enum xhci_ep_reset_type {
+	EP_HARD_RESET,
+	EP_SOFT_RESET,
+};
+
 /* Force Event */
 #define TRB_TO_VF_INTR_TARGET(p)	(((p) & (0x3ff << 22)) >> 22)
 #define TRB_TO_VF_ID(p)			(((p) & (0xff << 16)) >> 16)
@@ -2040,7 +2045,8 @@ int xhci_queue_configure_endpoint(struct xhci_hcd *xhci,
 int xhci_queue_evaluate_context(struct xhci_hcd *xhci, struct xhci_command *cmd,
 		dma_addr_t in_ctx_ptr, u32 slot_id, bool command_must_succeed);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, struct xhci_command *cmd,
-		int slot_id, unsigned int ep_index);
+		int slot_id, unsigned int ep_index,
+		enum xhci_ep_reset_type reset_type);
 int xhci_queue_reset_device(struct xhci_hcd *xhci, struct xhci_command *cmd,
 		u32 slot_id);
 void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,

commit c5628a2af83aeda6cc02b6c64acb91f249727b1c
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Jun 15 11:55:42 2017 +0300

    xhci: remove endpoint ring cache
    
    Anurag Kumar Vulisha reported several issues with xhci endpoint
    ring caching.
    
    31 Rings are cached per device before a ring is freed.
    These cached rings are not used as default if a new ring is needed.
    They are only used if the driver fails to allocate memory for a ring.
    
    The current ring cache is more a reason to why we run out memory than a
    help when we actually do so.
    
    Anurag Kumar Vulisha tried to use cached rings as a first option and
    found new issues with cached ring initialization.
    Cached rings were first zeroed and then manually reinitialized with link
    trbs etc, but forgetting to set some important bits like cycle toggle bit.
    
    Remove the ring cache completely as it's a faulty premature optimization
    eating memory
    
    Reported-by: Anurag Kumar Vulisha <anuragku@xilinx.com>
    Tested-by: Anurag Kumar Vulisha <anuragku@xilinx.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 886f150bad0f..deb85342e0a3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -992,10 +992,6 @@ struct xhci_virt_device {
 	struct xhci_container_ctx       *out_ctx;
 	/* Used for addressing devices and configuration changes */
 	struct xhci_container_ctx       *in_ctx;
-	/* Rings saved to ensure old alt settings can be re-instated */
-	struct xhci_ring		**ring_cache;
-	int				num_rings_cached;
-#define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
 	u8				fake_port;
 	u8				real_port;
@@ -1960,7 +1956,7 @@ int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 int xhci_ring_expansion(struct xhci_hcd *xhci, struct xhci_ring *ring,
 				unsigned int num_trbs, gfp_t flags);
-void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
+void xhci_free_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);
 struct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,

commit 8790736dbf2676ea398d8de952c791009290e3cc
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Jun 2 16:36:23 2017 +0300

    xhci: Add stream id to xhci_dequeue_state structure
    
    The values for the new dequeue segment, new dequeue pointer and new cycle
    state are needed for manually moving the xHC ring dequeue pointer.
    These are conveniently stored in a xhci_dequeue_state structure.
    
    stream support was added later and stream_id was carried
    as a function parameter.
    
    Move the stream_id to the xhci_dequeue_state structure instead.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 12df1323212b..886f150bad0f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1526,6 +1526,7 @@ struct xhci_dequeue_state {
 	struct xhci_segment *new_deq_seg;
 	union xhci_trb *new_deq_ptr;
 	int new_cycle_state;
+	unsigned int stream_id;
 };
 
 enum xhci_ring_type {
@@ -2052,7 +2053,6 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		struct xhci_dequeue_state *state);
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
-		unsigned int stream_id,
 		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
 		unsigned int ep_index, struct xhci_td *td);

commit 11e1d25db643da9d620bfc53b14ff7151220b5fb
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Jun 2 16:36:25 2017 +0300

    xhci: remove unused stopped_td pointer
    
    We no longer keep track of where we stopped in a stopped_td pointer.
    We get the ring dequeue pointer from the endpoint or stream context
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 73a28a986d5e..12df1323212b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -924,7 +924,6 @@ struct xhci_virt_ep {
 #define EP_GETTING_NO_STREAMS	(1 << 5)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
-	struct xhci_td		*stopped_td;
 	unsigned int		stopped_stream;
 	/* Watchdog timer for stop endpoint command to cancel URBs */
 	struct timer_list	stop_cmd_timer;

commit d852ed98f62e0d44f594adb850b3d6cedb5c9292
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 21 23:42:54 2017 +0200

    usb: host: xhci: remove #ifdef around PM functions
    
    The #ifdef is slightly wrong as it doesn't cover the xhci_priv_resume_quirk()
    function, causing a harmless warning:
    
    drivers/usb/host/xhci-plat.c:58:12: error: 'xhci_priv_resume_quirk' defined but not used [-Werror=unused-function]
     static int xhci_priv_resume_quirk(struct usb_hcd *hcd)
    
    A simpler way to do this correctly is to use __maybe_unused annotations
    that let the compiler silently drop the functions when there is no
    reference.
    
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cae8fb901aa8..73a28a986d5e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2004,13 +2004,8 @@ void xhci_init_driver(struct hc_driver *drv,
 int xhci_disable_slot(struct xhci_hcd *xhci,
 			struct xhci_command *command, u32 slot_id);
 
-#ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);
 int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
-#else
-#define	xhci_suspend	NULL
-#define	xhci_resume	NULL
-#endif
 
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
 irqreturn_t xhci_msi_irq(int irq, void *hcd);

commit 314eaf7dec13b975e51c8faf980f7b0f4e20b3e9
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Apr 19 16:55:51 2017 +0300

    usb: host: xhci: delete sp_dma_buffers for scratchpad
    
    We already have sp_array to store each scratch buffer address for xHC,
    it doesn't need another sp_dma_buffers array to store it.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 44123dd1816f..cae8fb901aa8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1606,7 +1606,6 @@ struct xhci_scratchpad {
 	u64 *sp_array;
 	dma_addr_t sp_dma;
 	void **sp_buffers;
-	dma_addr_t *sp_dma_buffers;
 };
 
 struct urb_priv {

commit 77d45b4500967de674b8f75a9a91f58d57d5704d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 19 16:55:49 2017 +0300

    xhci: switch to pci_alloc_irq_vectors
    
    Use the modern API to request MSI or MSI-X interrupts, which allows us to
    get rid of the msix_entries array, as well as cleaning up the cleanup
    code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 914968c662c9..44123dd1816f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1724,7 +1724,6 @@ struct xhci_hcd {
 	int		page_shift;
 	/* msi-x vectors */
 	int		msix_count;
-	struct msix_entry	*msix_entries;
 	/* optional clock */
 	struct clk		*clk;
 	/* data structures */

commit 69307ccb9ad7ccb653e332de68effdeaaab6907d
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Apr 7 17:57:12 2017 +0300

    usb: xhci: bInterval quirk for TI TUSB73x0
    
    As per [1] issue #4,
    "The periodic EP scheduler always tries to schedule the EPs
    that have large intervals (interval equal to or greater than
    128 microframes) into different microframes. So it maintains
    an internal counter and increments for each large interval
    EP added. When the counter is greater than 128, the scheduler
    rejects the new EP. So when the hub re-enumerated 128 times,
    it triggers this condition."
    
    This results in Bandwidth error when devices with periodic
    endpoints (ISO/INT) having bInterval > 7 are plugged and
    unplugged several times on a TUSB73x0 XHCI host.
    
    Workaround this issue by limiting the bInterval to 7
    (i.e. interval to 6) for High-speed or faster periodic endpoints.
    
    [1] - http://www.ti.com/lit/er/sllz076/sllz076.pdf
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dbe8ba934737..914968c662c9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1820,6 +1820,7 @@ struct xhci_hcd {
 #define XHCI_MISSING_CAS	(1 << 24)
 /* For controller with a broken Port Disable implementation */
 #define XHCI_BROKEN_PORT_PED	(1 << 25)
+#define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;

commit d2561626b9d126a94753ad6f048114bab702f02f
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:11 2017 +0300

    usb: xhci: refine xhci_decode_trb()
    
    Replace 'TRB_FIELD_TO_TYPE(field3)' with 'type' to simplify
    code.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4d49f5e95eae..dbe8ba934737 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2137,7 +2137,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 		sprintf(str,
 			"LINK %08x%08x intr %d type '%s' flags %c:%c:%c:%c",
 			field1, field0, GET_INTR_TARGET(field2),
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field3 & TRB_IOC ? 'I' : 'i',
 			field3 & TRB_CHAIN ? 'C' : 'c',
 			field3 & TRB_TC ? 'T' : 't',
@@ -2158,7 +2158,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 			EVENT_TRB_LEN(field2), TRB_TO_SLOT_ID(field3),
 			/* Macro decrements 1, maybe it shouldn't?!? */
 			TRB_TO_EP_INDEX(field3) + 1,
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field3 & EVENT_DATA ? 'E' : 'e',
 			field3 & TRB_CYCLE ? 'C' : 'c');
 
@@ -2175,7 +2175,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 				(field1 & 0xff0000) >> 16,
 				TRB_LEN(field2), GET_TD_SIZE(field2),
 				GET_INTR_TARGET(field2),
-				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				xhci_trb_type_string(type),
 				field3 & TRB_IDT ? 'I' : 'i',
 				field3 & TRB_IOC ? 'I' : 'i',
 				field3 & TRB_CYCLE ? 'C' : 'c');
@@ -2184,7 +2184,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 		sprintf(str, "Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c",
 				field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
 				GET_INTR_TARGET(field2),
-				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				xhci_trb_type_string(type),
 				field3 & TRB_IDT ? 'I' : 'i',
 				field3 & TRB_IOC ? 'I' : 'i',
 				field3 & TRB_CHAIN ? 'C' : 'c',
@@ -2197,7 +2197,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 		sprintf(str, "Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c",
 				field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
 				GET_INTR_TARGET(field2),
-				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				xhci_trb_type_string(type),
 				field3 & TRB_IOC ? 'I' : 'i',
 				field3 & TRB_CHAIN ? 'C' : 'c',
 				field3 & TRB_ENT ? 'E' : 'e',
@@ -2211,7 +2211,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 			"Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c:%c",
 			field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
 			GET_INTR_TARGET(field2),
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field3 & TRB_BEI ? 'B' : 'b',
 			field3 & TRB_IDT ? 'I' : 'i',
 			field3 & TRB_IOC ? 'I' : 'i',
@@ -2226,21 +2226,21 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_ENABLE_SLOT:
 		sprintf(str,
 			"%s: flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_DISABLE_SLOT:
 	case TRB_NEG_BANDWIDTH:
 		sprintf(str,
 			"%s: slot %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			TRB_TO_SLOT_ID(field3),
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_ADDR_DEV:
 		sprintf(str,
 			"%s: ctx %08x%08x slot %d flags %c:%c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			field3 & TRB_BSR ? 'B' : 'b',
@@ -2249,7 +2249,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_CONFIG_EP:
 		sprintf(str,
 			"%s: ctx %08x%08x slot %d flags %c:%c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			field3 & TRB_DC ? 'D' : 'd',
@@ -2258,7 +2258,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_EVAL_CONTEXT:
 		sprintf(str,
 			"%s: ctx %08x%08x slot %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			field3 & TRB_CYCLE ? 'C' : 'c');
@@ -2266,7 +2266,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_RESET_EP:
 		sprintf(str,
 			"%s: ctx %08x%08x slot %d ep %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			/* Macro decrements 1, maybe it shouldn't?!? */
@@ -2276,7 +2276,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_STOP_RING:
 		sprintf(str,
 			"%s: slot %d sp %d ep %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			TRB_TO_SLOT_ID(field3),
 			TRB_TO_SUSPEND_PORT(field3),
 			/* Macro decrements 1, maybe it shouldn't?!? */
@@ -2286,7 +2286,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_SET_DEQ:
 		sprintf(str,
 			"%s: deq %08x%08x stream %d slot %d ep %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_STREAM_ID(field2),
 			TRB_TO_SLOT_ID(field3),
@@ -2297,14 +2297,14 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_RESET_DEV:
 		sprintf(str,
 			"%s: slot %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			TRB_TO_SLOT_ID(field3),
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_FORCE_EVENT:
 		sprintf(str,
 			"%s: event %08x%08x vf intr %d vf id %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_VF_INTR_TARGET(field2),
 			TRB_TO_VF_ID(field3),
@@ -2313,14 +2313,14 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_SET_LT:
 		sprintf(str,
 			"%s: belt %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			TRB_TO_BELT(field3),
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_GET_BW:
 		sprintf(str,
 			"%s: ctx %08x%08x slot %d speed %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field1, field0,
 			TRB_TO_SLOT_ID(field3),
 			TRB_TO_DEV_SPEED(field3),
@@ -2329,7 +2329,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	case TRB_FORCE_HEADER:
 		sprintf(str,
 			"%s: info %08x%08x%08x pkt type %d roothub port %d flags %c",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field2, field1, field0 & 0xffffffe0,
 			TRB_TO_PACKET_TYPE(field0),
 			TRB_TO_ROOTHUB_PORT(field3),
@@ -2338,7 +2338,7 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	default:
 		sprintf(str,
 			"type '%s' -> raw %08x %08x %08x %08x",
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			xhci_trb_type_string(type),
 			field0, field1, field2, field3);
 	}
 

commit 96d9a6eb97d77d6a3768f101f400c42743799bb2
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:10 2017 +0300

    usb: xhci: fix link trb decoding
    
    xhci_decode_trb() treats a link trb in the same way as that for
    an event trb. This patch fixes this by decoding the link trb
    according to the spec.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 04e041feba3c..4d49f5e95eae 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2135,14 +2135,12 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	switch (type) {
 	case TRB_LINK:
 		sprintf(str,
-			"TRB %08x%08x status '%s' len %d slot %d ep %d type '%s' flags %c:%c",
-			field1, field0,
-			xhci_trb_comp_code_string(GET_COMP_CODE(field2)),
-			EVENT_TRB_LEN(field2), TRB_TO_SLOT_ID(field3),
-			/* Macro decrements 1, maybe it shouldn't?!? */
-			TRB_TO_EP_INDEX(field3) + 1,
+			"LINK %08x%08x intr %d type '%s' flags %c:%c:%c:%c",
+			field1, field0, GET_INTR_TARGET(field2),
 			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
-			field3 & EVENT_DATA ? 'E' : 'e',
+			field3 & TRB_IOC ? 'I' : 'i',
+			field3 & TRB_CHAIN ? 'C' : 'c',
+			field3 & TRB_TC ? 'T' : 't',
 			field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
 	case TRB_TRANSFER:

commit c8844f2ddb0d2bc42a813c567ad4240759f373bd
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:09 2017 +0300

    usb: xhci: remove xhci_dbg_ctx()
    
    XHCI context changes have already been traced by the trace
    events. It's unnecessary to put the same message in kernel
    log. This patch removes the use of xhci_dbg_ctx().
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index aef4fd55f3dc..04e041feba3c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1923,7 +1923,6 @@ void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
-void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
 void xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),

commit 8c10152ec52b850f9806c5c2f5a93ebe38838959
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:08 2017 +0300

    usb: xhci: remove xhci_debug_trb()
    
    Every XHCI TRB has already been traced by the trb trace events.
    It is unnecessary to put the same message in kernel log. This
    patch removes xhci_debug_trb().
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dca59095fbbe..aef4fd55f3dc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1921,8 +1921,6 @@ void xhci_print_ir_set(struct xhci_hcd *xhci, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);
 void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);
-void xhci_print_trb_offsets(struct xhci_hcd *xhci, union xhci_trb *trb);
-void xhci_debug_trb(struct xhci_hcd *xhci, union xhci_trb *trb);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);

commit 121dcf11908ecea252776c8268aab117f91aa1f5
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:07 2017 +0300

    usb: xhci: remove ring debugging code
    
    XHCI ring changes have already been traced by the ring trace
    events. It's unnecessary to put the same messages in kernel
    log. This patch removes the debugging code for a ring.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 1a6446647ede..dca59095fbbe 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1923,11 +1923,8 @@ void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);
 void xhci_print_trb_offsets(struct xhci_hcd *xhci, union xhci_trb *trb);
 void xhci_debug_trb(struct xhci_hcd *xhci, union xhci_trb *trb);
-void xhci_debug_segment(struct xhci_hcd *xhci, struct xhci_segment *seg);
-void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
-void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);

commit cd12fd9f6d05d1b2b9ff2630802c55b5fd2e534c
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:06 2017 +0300

    usb: xhci: remove enq_updates and deq_updates from ring
    
    enq_updates and deq_updates were introduced in the first place
    to check whether an xhci hardware is able to respond to trbs
    enqueued in the ring. We now have trb tracers to trace every
    single enqueue/dequeue trb. It's time to remove them and the
    associated debugging code.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dc69d3ca2659..1a6446647ede 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1566,10 +1566,8 @@ struct xhci_ring {
 	struct xhci_segment	*last_seg;
 	union  xhci_trb		*enqueue;
 	struct xhci_segment	*enq_seg;
-	unsigned int		enq_updates;
 	union  xhci_trb		*dequeue;
 	struct xhci_segment	*deq_seg;
-	unsigned int		deq_updates;
 	struct list_head	td_list;
 	/*
 	 * Write the cycle state into the TRB cycle field to give ownership of

commit 3969384cf88aa2726afb05ad5d1c6ec27e670f07
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:04 2017 +0300

    usb: xhci: make several functions static
    
    Several functions have a single user in the same file where it
    is defined. There's no need to expose it anywhere else.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5d771e36989e..dc69d3ca2659 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1946,16 +1946,8 @@ void xhci_copy_ep0_dequeue_into_input_ctx(struct xhci_hcd *xhci,
 		struct usb_device *udev);
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_address(unsigned int ep_index);
-unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
-unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
 unsigned int xhci_last_valid_endpoint(u32 added_ctxs);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
-void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,
-		struct xhci_bw_info *ep_bw,
-		struct xhci_interval_bw_table *bw_table,
-		struct usb_device *udev,
-		struct xhci_virt_ep *virt_ep,
-		struct xhci_tt_bw_info *tt_info);
 void xhci_update_tt_active_eps(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		int old_active_eps);
@@ -2014,10 +2006,7 @@ void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
 int xhci_start(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
-int xhci_init(struct usb_hcd *hcd);
 int xhci_run(struct usb_hcd *hcd);
-void xhci_stop(struct usb_hcd *hcd);
-void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 void xhci_init_driver(struct hc_driver *drv,
 		      const struct xhci_driver_overrides *over);
@@ -2032,36 +2021,13 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
 #define	xhci_resume	NULL
 #endif
 
-int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
 irqreturn_t xhci_msi_irq(int irq, void *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
-void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_alloc_tt_info(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		struct usb_device *hdev,
 		struct usb_tt *tt, gfp_t mem_flags);
-int xhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,
-		struct usb_host_endpoint **eps, unsigned int num_eps,
-		unsigned int num_streams, gfp_t mem_flags);
-int xhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,
-		struct usb_host_endpoint **eps, unsigned int num_eps,
-		gfp_t mem_flags);
-int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
-int xhci_enable_device(struct usb_hcd *hcd, struct usb_device *udev);
-int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev);
-int xhci_set_usb2_hardware_lpm(struct usb_hcd *hcd,
-				struct usb_device *udev, int enable);
-int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
-			struct usb_tt *tt, gfp_t mem_flags);
-int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
-int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
-int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
-int xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
-void xhci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
-int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev);
-int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
-void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
@@ -2105,9 +2071,6 @@ void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
 		unsigned int ep_index, struct xhci_td *td);
-void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
-		unsigned int slot_id, unsigned int ep_index,
-		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
 void xhci_handle_command_timeout(struct work_struct *work);
 
@@ -2118,10 +2081,6 @@ void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 link_state);
-int xhci_enable_usb3_lpm_timeout(struct usb_hcd *hcd,
-			struct usb_device *udev, enum usb3_link_state state);
-int xhci_disable_usb3_lpm_timeout(struct usb_hcd *hcd,
-			struct usb_device *udev, enum usb3_link_state state);
 void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 port_bit);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit b7d09fe863561014085503986cb202f4111be347
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Apr 7 17:57:03 2017 +0300

    usb: xhci: remove xhci_dbg_ep_rings()
    
    xhci_dbg_ep_rings() isn't used in xhci driver anymore. Remove
    it to reduce the module binary size.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3818504886d2..5d771e36989e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1933,9 +1933,6 @@ void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
-void xhci_dbg_ep_rings(struct xhci_hcd *xhci,
-		unsigned int slot_id, unsigned int ep_index,
-		struct xhci_virt_ep *ep);
 void xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),
 			const char *fmt, ...);
 

commit d9f11ba9f107aa335091ab8d7ba5eea714e46e8b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Apr 7 17:57:01 2017 +0300

    xhci: Rework how we handle unresponsive or hoptlug removed hosts
    
    Introduce a new xhci_hc_died() function that takes care of handling
    pending commands and URBs if a host controller becomes unresponsive.
    
    This addresses issues on hotpluggable xhci controllers that disappear
    from the bus suddenly, often while the bus (PCI) remove function is
    still being processed.
    
    xhci_hc_died() sets a XHCI_STATUS_DYING flag to prevent new URBs and
    commands or to be queued. The flag also ensures xhci_hc_died() will
    give back pending commands and URBs once.
    
    Host is considered dead if register read returns 0xffffffff, or host
    fails to abort the command ring, or fails stopping an endpoint after
    trying for 5 seconds.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 52153e1b3bf5..3818504886d2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2131,6 +2131,7 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
 int xhci_find_raw_port_number(struct usb_hcd *hcd, int port1);
+void xhci_hc_died(struct xhci_hcd *xhci);
 
 #ifdef CONFIG_PM
 int xhci_bus_suspend(struct usb_hcd *hcd);

commit 5d062aba0d399c57e2d793603d6e372adb09b4d7
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Fri Apr 7 17:56:58 2017 +0300

    usb: host: xhci: fix up Control Transfer TRB decoder
    
    Format for each TRB in each control transfer stage differs. Let's make
    sure we correctly pretty print these fields to avoid confusion.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cf79c1fd24be..52153e1b3bf5 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2217,31 +2217,46 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 
 		break;
 	case TRB_SETUP:
-		sprintf(str,
-			"bRequestType %02x bRequest %02x wValue %02x%02x wIndex %02x%02x wLength %d length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c:%c",
-			field0 & 0xff,
-			(field0 & 0xff00) >> 8,
-			(field0 & 0xff000000) >> 24,
-			(field0 & 0xff0000) >> 16,
-			(field1 & 0xff00) >> 8,
-			field1 & 0xff,
-			(field1 & 0xff000000) >> 16 |
-			(field1 & 0xff0000) >> 16,
-			TRB_LEN(field2), GET_TD_SIZE(field2),
-			GET_INTR_TARGET(field2),
-			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
-			field3 & TRB_BEI ? 'B' : 'b',
-			field3 & TRB_IDT ? 'I' : 'i',
-			field3 & TRB_IOC ? 'I' : 'i',
-			field3 & TRB_CHAIN ? 'C' : 'c',
-			field3 & TRB_NO_SNOOP ? 'S' : 's',
-			field3 & TRB_ISP ? 'I' : 'i',
-			field3 & TRB_ENT ? 'E' : 'e',
-			field3 & TRB_CYCLE ? 'C' : 'c');
+		sprintf(str, "bRequestType %02x bRequest %02x wValue %02x%02x wIndex %02x%02x wLength %d length %d TD size %d intr %d type '%s' flags %c:%c:%c",
+				field0 & 0xff,
+				(field0 & 0xff00) >> 8,
+				(field0 & 0xff000000) >> 24,
+				(field0 & 0xff0000) >> 16,
+				(field1 & 0xff00) >> 8,
+				field1 & 0xff,
+				(field1 & 0xff000000) >> 16 |
+				(field1 & 0xff0000) >> 16,
+				TRB_LEN(field2), GET_TD_SIZE(field2),
+				GET_INTR_TARGET(field2),
+				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				field3 & TRB_IDT ? 'I' : 'i',
+				field3 & TRB_IOC ? 'I' : 'i',
+				field3 & TRB_CYCLE ? 'C' : 'c');
 		break;
-	case TRB_NORMAL:
 	case TRB_DATA:
+		sprintf(str, "Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c",
+				field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
+				GET_INTR_TARGET(field2),
+				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				field3 & TRB_IDT ? 'I' : 'i',
+				field3 & TRB_IOC ? 'I' : 'i',
+				field3 & TRB_CHAIN ? 'C' : 'c',
+				field3 & TRB_NO_SNOOP ? 'S' : 's',
+				field3 & TRB_ISP ? 'I' : 'i',
+				field3 & TRB_ENT ? 'E' : 'e',
+				field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
 	case TRB_STATUS:
+		sprintf(str, "Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c",
+				field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
+				GET_INTR_TARGET(field2),
+				xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+				field3 & TRB_IOC ? 'I' : 'i',
+				field3 & TRB_CHAIN ? 'C' : 'c',
+				field3 & TRB_ENT ? 'E' : 'e',
+				field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_NORMAL:
 	case TRB_ISOC:
 	case TRB_EVENT_DATA:
 	case TRB_TR_NOOP:

commit 19a7d0d65c4a813069f4bc4ca701d6a163c337e9
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Fri Apr 7 17:56:57 2017 +0300

    usb: host: xhci: add Slot and EP Context tracers
    
    With these, we can track what's happening with the HW while executing
    each and every command. It will give us visibility into how the
    different contexts are being modified by xHC which can bring insight
    into problems while debugging.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 44d031c87108..cf79c1fd24be 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -618,6 +618,7 @@ struct xhci_slot_ctx {
 #define ROUTE_STRING_MASK	(0xfffff)
 /* Device speed - values defined by PORTSC Device Speed field - 20:23 */
 #define DEV_SPEED	(0xf << 20)
+#define GET_DEV_SPEED(n) (((n) & DEV_SPEED) >> 20)
 /* bit 24 reserved */
 /* Is this LS/FS device connected through a HS hub? - bit 25 */
 #define DEV_MTT		(0x1 << 25)
@@ -638,6 +639,7 @@ struct xhci_slot_ctx {
 #define DEVINFO_TO_ROOT_HUB_PORT(p)	(((p) >> 16) & 0xff)
 /* Maximum number of ports under a hub device */
 #define XHCI_MAX_PORTS(p)	(((p) & 0xff) << 24)
+#define DEVINFO_TO_MAX_PORTS(p)	(((p) & (0xff << 24)) >> 24)
 
 /* tt_info bitmasks */
 /*
@@ -652,6 +654,7 @@ struct xhci_slot_ctx {
  */
 #define TT_PORT		(0xff << 8)
 #define TT_THINK_TIME(p)	(((p) & 0x3) << 16)
+#define GET_TT_THINK_TIME(p)	(((p) & (0x3 << 16)) >> 16)
 
 /* dev_state bitmasks */
 /* USB device address - assigned by the HC */
@@ -2380,5 +2383,148 @@ static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 	return str;
 }
 
+static inline const char *xhci_decode_slot_context(u32 info, u32 info2,
+		u32 tt_info, u32 state)
+{
+	static char str[1024];
+	u32 speed;
+	u32 hub;
+	u32 mtt;
+	int ret = 0;
+
+	speed = info & DEV_SPEED;
+	hub = info & DEV_HUB;
+	mtt = info & DEV_MTT;
+
+	ret = sprintf(str, "RS %05x %s%s%s Ctx Entries %d MEL %d us Port# %d/%d",
+			info & ROUTE_STRING_MASK,
+			({ char *s;
+			switch (speed) {
+			case SLOT_SPEED_FS:
+				s = "full-speed";
+				break;
+			case SLOT_SPEED_LS:
+				s = "low-speed";
+				break;
+			case SLOT_SPEED_HS:
+				s = "high-speed";
+				break;
+			case SLOT_SPEED_SS:
+				s = "super-speed";
+				break;
+			case SLOT_SPEED_SSP:
+				s = "super-speed plus";
+				break;
+			default:
+				s = "UNKNOWN speed";
+			} s; }),
+			mtt ? " multi-TT" : "",
+			hub ? " Hub" : "",
+			(info & LAST_CTX_MASK) >> 27,
+			info2 & MAX_EXIT,
+			DEVINFO_TO_ROOT_HUB_PORT(info2),
+			DEVINFO_TO_MAX_PORTS(info2));
+
+	ret += sprintf(str + ret, " [TT Slot %d Port# %d TTT %d Intr %d] Addr %d State %s",
+			tt_info & TT_SLOT, (tt_info & TT_PORT) >> 8,
+			GET_TT_THINK_TIME(tt_info), GET_INTR_TARGET(tt_info),
+			state & DEV_ADDR_MASK,
+			xhci_slot_state_string(GET_SLOT_STATE(state)));
+
+	return str;
+}
+
+static inline const char *xhci_ep_state_string(u8 state)
+{
+	switch (state) {
+	case EP_STATE_DISABLED:
+		return "disabled";
+	case EP_STATE_RUNNING:
+		return "running";
+	case EP_STATE_HALTED:
+		return "halted";
+	case EP_STATE_STOPPED:
+		return "stopped";
+	case EP_STATE_ERROR:
+		return "error";
+	default:
+		return "INVALID";
+	}
+}
+
+static inline const char *xhci_ep_type_string(u8 type)
+{
+	switch (type) {
+	case ISOC_OUT_EP:
+		return "Isoc OUT";
+	case BULK_OUT_EP:
+		return "Bulk OUT";
+	case INT_OUT_EP:
+		return "Int OUT";
+	case CTRL_EP:
+		return "Ctrl";
+	case ISOC_IN_EP:
+		return "Isoc IN";
+	case BULK_IN_EP:
+		return "Bulk IN";
+	case INT_IN_EP:
+		return "Int IN";
+	default:
+		return "INVALID";
+	}
+}
+
+static inline const char *xhci_decode_ep_context(u32 info, u32 info2, u64 deq,
+		u32 tx_info)
+{
+	static char str[1024];
+	int ret;
+
+	u32 esit;
+	u16 maxp;
+	u16 avg;
+
+	u8 max_pstr;
+	u8 ep_state;
+	u8 interval;
+	u8 ep_type;
+	u8 burst;
+	u8 cerr;
+	u8 mult;
+	u8 lsa;
+	u8 hid;
+
+	esit = EP_MAX_ESIT_PAYLOAD_HI(info) << 16 |
+		EP_MAX_ESIT_PAYLOAD_LO(tx_info);
+
+	ep_state = info & EP_STATE_MASK;
+	max_pstr = info & EP_MAXPSTREAMS_MASK;
+	interval = CTX_TO_EP_INTERVAL(info);
+	mult = CTX_TO_EP_MULT(info) + 1;
+	lsa = info & EP_HAS_LSA;
+
+	cerr = (info2 & (3 << 1)) >> 1;
+	ep_type = CTX_TO_EP_TYPE(info2);
+	hid = info2 & (1 << 7);
+	burst = CTX_TO_MAX_BURST(info2);
+	maxp = MAX_PACKET_DECODED(info2);
+
+	avg = EP_AVG_TRB_LENGTH(tx_info);
+
+	ret = sprintf(str, "State %s mult %d max P. Streams %d %s",
+			xhci_ep_state_string(ep_state), mult,
+			max_pstr, lsa ? "LSA " : "");
+
+	ret += sprintf(str + ret, "interval %d us max ESIT payload %d CErr %d ",
+			(1 << interval) * 125, esit, cerr);
+
+	ret += sprintf(str + ret, "Type %s %sburst %d maxp %d deq %016llx ",
+			xhci_ep_type_string(ep_type), hid ? "HID" : "",
+			burst, maxp, deq);
+
+	ret += sprintf(str + ret, "avg trb len %d", avg);
+
+	return str;
+}
 
 #endif /* __LINUX_XHCI_HCD_H */

commit 52407729fbeabb654d38c0c99661a41a481092d1
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Fri Apr 7 17:56:56 2017 +0300

    usb: host: xhci: extract xhci_slot_state_string()
    
    By extracting and exposing xhci_slot_state_string() in a header file, we
    can re-use it to print Slot Context State from our tracepoints, which
    can aid in tracking down problems related to command execution.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 675d552e420e..44d031c87108 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2158,6 +2158,22 @@ static inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
 					urb->stream_id);
 }
 
+static inline char *xhci_slot_state_string(u32 state)
+{
+	switch (state) {
+	case SLOT_STATE_ENABLED:
+		return "enabled/disabled";
+	case SLOT_STATE_DEFAULT:
+		return "default";
+	case SLOT_STATE_ADDRESSED:
+		return "addressed";
+	case SLOT_STATE_CONFIGURED:
+		return "configured";
+	default:
+		return "reserved";
+	}
+}
+
 static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
 		u32 field3)
 {

commit 0f1d832ed1fb9527a4cc5fcb8511e85fd0a85185
Author: Guoqing Zhang <guoqing.zhang@intel.com>
Date:   Fri Apr 7 17:56:54 2017 +0300

    usb: xhci: Add port test modes support for usb2.
    
    For usb2 ports, the port test mode Test_J_State, Test_K_State,
    Test_Packet, Test_SE0_NAK and Test_Force_En can be enabled
    as described in usb2 spec.
    
    USB2 test mode is a required hardware feature for system integrators
    validating their hardware according to USB spec, regarding signal
    strength and stuff. It is purely a hardware test feature.
    
    Usually you need an oscilloscope and have to enable those test modes on
    the hardware. This will send some specific test patterns on D+/D-. There
    is no report available (in Linux itself) as it is purely externally
    visible. Regular USB usage is not possible at that time.
    Anyone (well access to e.g. /dev/bus/usb/001/001 provided) can use it by
    sending appropriate USB_PORT_FEAT_TEST requests to the hub.
    
    [Add better commit message by Alexander Stein  -Mathias]
    Signed-off-by: Guoqing Zhang <guoqing.zhang@intel.com>
    Cc: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4e12c8cb557a..675d552e420e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -425,6 +425,7 @@ struct xhci_op_regs {
 #define	PORT_L1DS_MASK		(0xff << 8)
 #define	PORT_L1DS(p)		(((p) & 0xff) << 8)
 #define	PORT_HLE		(1 << 16)
+#define PORT_TEST_MODE_SHIFT	28
 
 /* USB3 Protocol PORTLI  Port Link Information */
 #define PORT_RX_LANES(p)	(((p) >> 16) & 0xf)
@@ -1843,6 +1844,7 @@ struct xhci_hcd {
 	/* Compliance Mode Recovery Data */
 	struct timer_list	comp_mode_recovery_timer;
 	u32			port_status_u0;
+	u16			test_mode;
 /* Compliance Mode Timer Triggered every 2 seconds */
 #define COMP_MODE_RCVRY_MSECS 2000
 

commit 26bba5c767de6724f330cdc2ad28bb783674f5a0
Author: Guoqing Zhang <guoqing.zhang@intel.com>
Date:   Fri Apr 7 17:56:53 2017 +0300

    usb: xhci: Expose xhci_start() function.
    
    Change the visability of xhci_start() so that it
    can be used when enabling test mode.
    
    Signed-off-by: Guoqing Zhang <guoqing.zhang@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d3485f881680..4e12c8cb557a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2010,6 +2010,7 @@ typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
 int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, int usec);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
+int xhci_start(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
 int xhci_init(struct usb_hcd *hcd);
 int xhci_run(struct usb_hcd *hcd);

commit f9e609b82479ef48469d42b022b0951abc00dcd1
Author: Guoqing Zhang <guoqing.zhang@intel.com>
Date:   Fri Apr 7 17:56:52 2017 +0300

    usb: xhci: Add helper function xhci_disable_slot().
    
    Refactoring slot disable related code into a helper
    function xhci_disable_slot() which can be used when
    enabling test mode.
    
    Signed-off-by: Guoqing Zhang <guoqing.zhang@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index da3eb695fe54..d3485f881680 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -2018,6 +2018,8 @@ void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 void xhci_init_driver(struct hc_driver *drv,
 		      const struct xhci_driver_overrides *over);
+int xhci_disable_slot(struct xhci_hcd *xhci,
+			struct xhci_command *command, u32 slot_id);
 
 #ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);

commit 7e64b0373af50fa46d3bf441f1c079615bbdf77f
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 23 14:20:26 2017 +0200

    xhci: simplify how we store TDs in urb private data
    
    Instead of storing a zero length array of td pointers, and then
    allocate memory both for the td pointer array and the td's, just
    use a zero length array of actual td's in urb private data.
    
    old:
    
    struct urb_priv {
           struct xhci_td *td[0]
    }
    
    new:
    
    struct urb_priv {
            struct xhci_td td[0]
    }
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dab271995aca..da3eb695fe54 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1610,7 +1610,7 @@ struct xhci_scratchpad {
 struct urb_priv {
 	int	num_tds;
 	int	num_tds_done;
-	struct	xhci_td	*td[0];
+	struct	xhci_td	td[0];
 };
 
 /*

commit 9ef7fbbb4fdfb857e606a9fd550faa8011cce5e2
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 23 14:20:25 2017 +0200

    xhci: Rename variables related to transfer descritpors
    
    urb_priv structure has a count on how many TDs the
    URB contains, and how many of those TD's we have handled.
    
    rename:
    length -> num_tds
    td_cnt -> num_tds_done
    
    No functional changes
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9193a4224209..dab271995aca 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1608,8 +1608,8 @@ struct xhci_scratchpad {
 };
 
 struct urb_priv {
-	int	length;
-	int	td_cnt;
+	int	num_tds;
+	int	num_tds_done;
 	struct	xhci_td	*td[0];
 };
 

commit a37c3f76e6a6b5eabacb1364c2218b0daafab18a
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Jan 23 14:20:19 2017 +0200

    usb: host: xhci: make a generic TRB tracer
    
    instead of having a tracer that can only trace command completions,
    let's promote this tracer so it can trace and decode any TRB.
    
    With that, it will be easier to extrapolate the lifetime of any TRB
    which might help debugging certain issues.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ebdd920fc958..9193a4224209 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1199,6 +1199,27 @@ struct xhci_event_cmd {
 
 /* Address device - disable SetAddress */
 #define TRB_BSR		(1<<9)
+
+/* Configure Endpoint - Deconfigure */
+#define TRB_DC		(1<<9)
+
+/* Stop Ring - Transfer State Preserve */
+#define TRB_TSP		(1<<9)
+
+/* Force Event */
+#define TRB_TO_VF_INTR_TARGET(p)	(((p) & (0x3ff << 22)) >> 22)
+#define TRB_TO_VF_ID(p)			(((p) & (0xff << 16)) >> 16)
+
+/* Set Latency Tolerance Value */
+#define TRB_TO_BELT(p)			(((p) & (0xfff << 16)) >> 16)
+
+/* Get Port Bandwidth */
+#define TRB_TO_DEV_SPEED(p)		(((p) & (0xf << 16)) >> 16)
+
+/* Force Header */
+#define TRB_TO_PACKET_TYPE(p)		((p) & 0x1f)
+#define TRB_TO_ROOTHUB_PORT(p)		(((p) & (0xff << 24)) >> 24)
+
 enum xhci_setup_dev {
 	SETUP_CONTEXT_ONLY,
 	SETUP_CONTEXT_ADDRESS,
@@ -1222,16 +1243,21 @@ enum xhci_setup_dev {
 #define STREAM_ID_FOR_TRB(p)		((((p)) & 0xffff) << 16)
 #define SCT_FOR_TRB(p)			(((p) << 1) & 0x7)
 
+/* Link TRB specific fields */
+#define TRB_TC			(1<<1)
 
 /* Port Status Change Event TRB fields */
 /* Port ID - bits 31:24 */
 #define GET_PORT_ID(p)		(((p) & (0xff << 24)) >> 24)
 
+#define EVENT_DATA		(1 << 2)
+
 /* Normal TRB fields */
 /* transfer_len bitmasks - bits 0:16 */
 #define	TRB_LEN(p)		((p) & 0x1ffff)
 /* TD Size, packets remaining in this TD, bits 21:17 (5 bits, so max 31) */
 #define TRB_TD_SIZE(p)          (min((p), (u32)31) << 17)
+#define GET_TD_SIZE(p)		(((p) & 0x3e0000) >> 17)
 /* xhci 1.1 uses the TD_SIZE field for TBC if Extended TBC is enabled (ETE) */
 #define TRB_TD_SIZE_TBC(p)      (min((p), (u32)31) << 17)
 /* Interrupter Target - which MSI-X vector to target the completion event at */
@@ -1359,6 +1385,80 @@ union xhci_trb {
 /* Get NEC firmware revision. */
 #define	TRB_NEC_GET_FW		49
 
+static inline const char *xhci_trb_type_string(u8 type)
+{
+	switch (type) {
+	case TRB_NORMAL:
+		return "Normal";
+	case TRB_SETUP:
+		return "Setup Stage";
+	case TRB_DATA:
+		return "Data Stage";
+	case TRB_STATUS:
+		return "Status Stage";
+	case TRB_ISOC:
+		return "Isoch";
+	case TRB_LINK:
+		return "Link";
+	case TRB_EVENT_DATA:
+		return "Event Data";
+	case TRB_TR_NOOP:
+		return "No-Op";
+	case TRB_ENABLE_SLOT:
+		return "Enable Slot Command";
+	case TRB_DISABLE_SLOT:
+		return "Disable Slot Command";
+	case TRB_ADDR_DEV:
+		return "Address Device Command";
+	case TRB_CONFIG_EP:
+		return "Configure Endpoint Command";
+	case TRB_EVAL_CONTEXT:
+		return "Evaluate Context Command";
+	case TRB_RESET_EP:
+		return "Reset Endpoint Command";
+	case TRB_STOP_RING:
+		return "Stop Ring Command";
+	case TRB_SET_DEQ:
+		return "Set TR Dequeue Pointer Command";
+	case TRB_RESET_DEV:
+		return "Reset Device Command";
+	case TRB_FORCE_EVENT:
+		return "Force Event Command";
+	case TRB_NEG_BANDWIDTH:
+		return "Negotiate Bandwidth Command";
+	case TRB_SET_LT:
+		return "Set Latency Tolerance Value Command";
+	case TRB_GET_BW:
+		return "Get Port Bandwidth Command";
+	case TRB_FORCE_HEADER:
+		return "Force Header Command";
+	case TRB_CMD_NOOP:
+		return "No-Op Command";
+	case TRB_TRANSFER:
+		return "Transfer Event";
+	case TRB_COMPLETION:
+		return "Command Completion Event";
+	case TRB_PORT_STATUS:
+		return "Port Status Change Event";
+	case TRB_BANDWIDTH_EVENT:
+		return "Bandwidth Request Event";
+	case TRB_DOORBELL:
+		return "Doorbell Event";
+	case TRB_HC_EVENT:
+		return "Host Controller Event";
+	case TRB_DEV_NOTE:
+		return "Device Notification Event";
+	case TRB_MFINDEX_WRAP:
+		return "MFINDEX Wrap Event";
+	case TRB_NEC_CMD_COMP:
+		return "NEC Command Completion Event";
+	case TRB_NEC_GET_FW:
+		return "NET Get Firmware Revision Command";
+	default:
+		return "UNKNOWN";
+	}
+}
+
 #define TRB_TYPE_LINK(x)	(((x) & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK))
 /* Above, but for __le32 types -- can avoid work by swapping constants: */
 #define TRB_TYPE_LINK_LE32(x)	(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \
@@ -1435,6 +1535,28 @@ enum xhci_ring_type {
 	TYPE_EVENT,
 };
 
+static inline const char *xhci_ring_type_string(enum xhci_ring_type type)
+{
+	switch (type) {
+	case TYPE_CTRL:
+		return "CTRL";
+	case TYPE_ISOC:
+		return "ISOC";
+	case TYPE_BULK:
+		return "BULK";
+	case TYPE_INTR:
+		return "INTR";
+	case TYPE_STREAM:
+		return "STREAM";
+	case TYPE_COMMAND:
+		return "CMD";
+	case TYPE_EVENT:
+		return "EVENT";
+	}
+
+	return "UNKNOWN";
+}
+
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
 	struct xhci_segment	*last_seg;
@@ -2031,4 +2153,211 @@ static inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
 					urb->stream_id);
 }
 
+static inline const char *xhci_decode_trb(u32 field0, u32 field1, u32 field2,
+		u32 field3)
+{
+	static char str[256];
+	int type = TRB_FIELD_TO_TYPE(field3);
+
+	switch (type) {
+	case TRB_LINK:
+		sprintf(str,
+			"TRB %08x%08x status '%s' len %d slot %d ep %d type '%s' flags %c:%c",
+			field1, field0,
+			xhci_trb_comp_code_string(GET_COMP_CODE(field2)),
+			EVENT_TRB_LEN(field2), TRB_TO_SLOT_ID(field3),
+			/* Macro decrements 1, maybe it shouldn't?!? */
+			TRB_TO_EP_INDEX(field3) + 1,
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field3 & EVENT_DATA ? 'E' : 'e',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_TRANSFER:
+	case TRB_COMPLETION:
+	case TRB_PORT_STATUS:
+	case TRB_BANDWIDTH_EVENT:
+	case TRB_DOORBELL:
+	case TRB_HC_EVENT:
+	case TRB_DEV_NOTE:
+	case TRB_MFINDEX_WRAP:
+		sprintf(str,
+			"TRB %08x%08x status '%s' len %d slot %d ep %d type '%s' flags %c:%c",
+			field1, field0,
+			xhci_trb_comp_code_string(GET_COMP_CODE(field2)),
+			EVENT_TRB_LEN(field2), TRB_TO_SLOT_ID(field3),
+			/* Macro decrements 1, maybe it shouldn't?!? */
+			TRB_TO_EP_INDEX(field3) + 1,
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field3 & EVENT_DATA ? 'E' : 'e',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+
+		break;
+	case TRB_SETUP:
+		sprintf(str,
+			"bRequestType %02x bRequest %02x wValue %02x%02x wIndex %02x%02x wLength %d length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c:%c",
+			field0 & 0xff,
+			(field0 & 0xff00) >> 8,
+			(field0 & 0xff000000) >> 24,
+			(field0 & 0xff0000) >> 16,
+			(field1 & 0xff00) >> 8,
+			field1 & 0xff,
+			(field1 & 0xff000000) >> 16 |
+			(field1 & 0xff0000) >> 16,
+			TRB_LEN(field2), GET_TD_SIZE(field2),
+			GET_INTR_TARGET(field2),
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field3 & TRB_BEI ? 'B' : 'b',
+			field3 & TRB_IDT ? 'I' : 'i',
+			field3 & TRB_IOC ? 'I' : 'i',
+			field3 & TRB_CHAIN ? 'C' : 'c',
+			field3 & TRB_NO_SNOOP ? 'S' : 's',
+			field3 & TRB_ISP ? 'I' : 'i',
+			field3 & TRB_ENT ? 'E' : 'e',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_NORMAL:
+	case TRB_DATA:
+	case TRB_STATUS:
+	case TRB_ISOC:
+	case TRB_EVENT_DATA:
+	case TRB_TR_NOOP:
+		sprintf(str,
+			"Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c:%c",
+			field1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),
+			GET_INTR_TARGET(field2),
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field3 & TRB_BEI ? 'B' : 'b',
+			field3 & TRB_IDT ? 'I' : 'i',
+			field3 & TRB_IOC ? 'I' : 'i',
+			field3 & TRB_CHAIN ? 'C' : 'c',
+			field3 & TRB_NO_SNOOP ? 'S' : 's',
+			field3 & TRB_ISP ? 'I' : 'i',
+			field3 & TRB_ENT ? 'E' : 'e',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+
+	case TRB_CMD_NOOP:
+	case TRB_ENABLE_SLOT:
+		sprintf(str,
+			"%s: flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_DISABLE_SLOT:
+	case TRB_NEG_BANDWIDTH:
+		sprintf(str,
+			"%s: slot %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			TRB_TO_SLOT_ID(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_ADDR_DEV:
+		sprintf(str,
+			"%s: ctx %08x%08x slot %d flags %c:%c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_SLOT_ID(field3),
+			field3 & TRB_BSR ? 'B' : 'b',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_CONFIG_EP:
+		sprintf(str,
+			"%s: ctx %08x%08x slot %d flags %c:%c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_SLOT_ID(field3),
+			field3 & TRB_DC ? 'D' : 'd',
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_EVAL_CONTEXT:
+		sprintf(str,
+			"%s: ctx %08x%08x slot %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_SLOT_ID(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_RESET_EP:
+		sprintf(str,
+			"%s: ctx %08x%08x slot %d ep %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_SLOT_ID(field3),
+			/* Macro decrements 1, maybe it shouldn't?!? */
+			TRB_TO_EP_INDEX(field3) + 1,
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_STOP_RING:
+		sprintf(str,
+			"%s: slot %d sp %d ep %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			TRB_TO_SLOT_ID(field3),
+			TRB_TO_SUSPEND_PORT(field3),
+			/* Macro decrements 1, maybe it shouldn't?!? */
+			TRB_TO_EP_INDEX(field3) + 1,
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_SET_DEQ:
+		sprintf(str,
+			"%s: deq %08x%08x stream %d slot %d ep %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_STREAM_ID(field2),
+			TRB_TO_SLOT_ID(field3),
+			/* Macro decrements 1, maybe it shouldn't?!? */
+			TRB_TO_EP_INDEX(field3) + 1,
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_RESET_DEV:
+		sprintf(str,
+			"%s: slot %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			TRB_TO_SLOT_ID(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_FORCE_EVENT:
+		sprintf(str,
+			"%s: event %08x%08x vf intr %d vf id %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_VF_INTR_TARGET(field2),
+			TRB_TO_VF_ID(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_SET_LT:
+		sprintf(str,
+			"%s: belt %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			TRB_TO_BELT(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_GET_BW:
+		sprintf(str,
+			"%s: ctx %08x%08x slot %d speed %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field1, field0,
+			TRB_TO_SLOT_ID(field3),
+			TRB_TO_DEV_SPEED(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	case TRB_FORCE_HEADER:
+		sprintf(str,
+			"%s: info %08x%08x%08x pkt type %d roothub port %d flags %c",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field2, field1, field0 & 0xffffffe0,
+			TRB_TO_PACKET_TYPE(field0),
+			TRB_TO_ROOTHUB_PORT(field3),
+			field3 & TRB_CYCLE ? 'C' : 'c');
+		break;
+	default:
+		sprintf(str,
+			"type '%s' -> raw %08x %08x %08x %08x",
+			xhci_trb_type_string(TRB_FIELD_TO_TYPE(field3)),
+			field0, field1, field2, field3);
+	}
+
+	return str;
+}
+
+
 #endif /* __LINUX_XHCI_HCD_H */

commit ed6d643b14e7bc2fac794a0bbac7dd742ca2ed80
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Jan 23 14:20:18 2017 +0200

    usb: host: xhci: combine event TRB completion debugging messages
    
    If we just provide a helper to convert completion code to string, we can
    combine all debugging messages into a single print.
    
    [keep the old debug messages, for warn and grep -Mathias]
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index aa63e386b51d..ebdd920fc958 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1097,6 +1097,86 @@ struct xhci_transfer_event {
 #define COMP_SECONDARY_BANDWIDTH_ERROR		35
 #define COMP_SPLIT_TRANSACTION_ERROR		36
 
+static inline const char *xhci_trb_comp_code_string(u8 status)
+{
+	switch (status) {
+	case COMP_INVALID:
+		return "Invalid";
+	case COMP_SUCCESS:
+		return "Success";
+	case COMP_DATA_BUFFER_ERROR:
+		return "Data Buffer Error";
+	case COMP_BABBLE_DETECTED_ERROR:
+		return "Babble Detected";
+	case COMP_USB_TRANSACTION_ERROR:
+		return "USB Transaction Error";
+	case COMP_TRB_ERROR:
+		return "TRB Error";
+	case COMP_STALL_ERROR:
+		return "Stall Error";
+	case COMP_RESOURCE_ERROR:
+		return "Resource Error";
+	case COMP_BANDWIDTH_ERROR:
+		return "Bandwidth Error";
+	case COMP_NO_SLOTS_AVAILABLE_ERROR:
+		return "No Slots Available Error";
+	case COMP_INVALID_STREAM_TYPE_ERROR:
+		return "Invalid Stream Type Error";
+	case COMP_SLOT_NOT_ENABLED_ERROR:
+		return "Slot Not Enabled Error";
+	case COMP_ENDPOINT_NOT_ENABLED_ERROR:
+		return "Endpoint Not Enabled Error";
+	case COMP_SHORT_PACKET:
+		return "Short Packet";
+	case COMP_RING_UNDERRUN:
+		return "Ring Underrun";
+	case COMP_RING_OVERRUN:
+		return "Ring Overrun";
+	case COMP_VF_EVENT_RING_FULL_ERROR:
+		return "VF Event Ring Full Error";
+	case COMP_PARAMETER_ERROR:
+		return "Parameter Error";
+	case COMP_BANDWIDTH_OVERRUN_ERROR:
+		return "Bandwidth Overrun Error";
+	case COMP_CONTEXT_STATE_ERROR:
+		return "Context State Error";
+	case COMP_NO_PING_RESPONSE_ERROR:
+		return "No Ping Response Error";
+	case COMP_EVENT_RING_FULL_ERROR:
+		return "Event Ring Full Error";
+	case COMP_INCOMPATIBLE_DEVICE_ERROR:
+		return "Incompatible Device Error";
+	case COMP_MISSED_SERVICE_ERROR:
+		return "Missed Service Error";
+	case COMP_COMMAND_RING_STOPPED:
+		return "Command Ring Stopped";
+	case COMP_COMMAND_ABORTED:
+		return "Command Aborted";
+	case COMP_STOPPED:
+		return "Stopped";
+	case COMP_STOPPED_LENGTH_INVALID:
+		return "Stopped - Length Invalid";
+	case COMP_STOPPED_SHORT_PACKET:
+		return "Stopped - Short Packet";
+	case COMP_MAX_EXIT_LATENCY_TOO_LARGE_ERROR:
+		return "Max Exit Latency Too Large Error";
+	case COMP_ISOCH_BUFFER_OVERRUN:
+		return "Isoch Buffer Overrun";
+	case COMP_EVENT_LOST_ERROR:
+		return "Event Lost Error";
+	case COMP_UNDEFINED_ERROR:
+		return "Undefined Error";
+	case COMP_INVALID_STREAM_ID_ERROR:
+		return "Invalid Stream ID Error";
+	case COMP_SECONDARY_BANDWIDTH_ERROR:
+		return "Secondary Bandwidth Error";
+	case COMP_SPLIT_TRANSACTION_ERROR:
+		return "Split Transaction Error";
+	default:
+		return "Unknown!!";
+	}
+}
+
 struct xhci_link_trb {
 	/* 64-bit segment pointer*/
 	__le64 segment_ptr;

commit 0b7c105a04ca793acf5d39ff9bafebe89182fc6b
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Mon Jan 23 14:20:06 2017 +0200

    usb: host: xhci: rename completion codes to match spec
    
    Cleanup only. This patch is a mechaninal rename to make sure our macros
    for TRB completion codes match what the specification uses to refer to
    such errors. The idea behind this is that it makes it far easier to grep
    the specification and match it with implementation.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b8474a2e6e5d..aa63e386b51d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1060,76 +1060,42 @@ struct xhci_transfer_event {
 /* Completion Code - only applicable for some types of TRBs */
 #define	COMP_CODE_MASK		(0xff << 24)
 #define GET_COMP_CODE(p)	(((p) & COMP_CODE_MASK) >> 24)
-#define COMP_SUCCESS	1
-/* Data Buffer Error */
-#define COMP_DB_ERR	2
-/* Babble Detected Error */
-#define COMP_BABBLE	3
-/* USB Transaction Error */
-#define COMP_TX_ERR	4
-/* TRB Error - some TRB field is invalid */
-#define COMP_TRB_ERR	5
-/* Stall Error - USB device is stalled */
-#define COMP_STALL	6
-/* Resource Error - HC doesn't have memory for that device configuration */
-#define COMP_ENOMEM	7
-/* Bandwidth Error - not enough room in schedule for this dev config */
-#define COMP_BW_ERR	8
-/* No Slots Available Error - HC ran out of device slots */
-#define COMP_ENOSLOTS	9
-/* Invalid Stream Type Error */
-#define COMP_STREAM_ERR	10
-/* Slot Not Enabled Error - doorbell rung for disabled device slot */
-#define COMP_EBADSLT	11
-/* Endpoint Not Enabled Error */
-#define COMP_EBADEP	12
-/* Short Packet */
-#define COMP_SHORT_TX	13
-/* Ring Underrun - doorbell rung for an empty isoc OUT ep ring */
-#define COMP_UNDERRUN	14
-/* Ring Overrun - isoc IN ep ring is empty when ep is scheduled to RX */
-#define COMP_OVERRUN	15
-/* Virtual Function Event Ring Full Error */
-#define COMP_VF_FULL	16
-/* Parameter Error - Context parameter is invalid */
-#define COMP_EINVAL	17
-/* Bandwidth Overrun Error - isoc ep exceeded its allocated bandwidth */
-#define COMP_BW_OVER	18
-/* Context State Error - illegal context state transition requested */
-#define COMP_CTX_STATE	19
-/* No Ping Response Error - HC didn't get PING_RESPONSE in time to TX */
-#define COMP_PING_ERR	20
-/* Event Ring is full */
-#define COMP_ER_FULL	21
-/* Incompatible Device Error */
-#define COMP_DEV_ERR	22
-/* Missed Service Error - HC couldn't service an isoc ep within interval */
-#define COMP_MISSED_INT	23
-/* Successfully stopped command ring */
-#define COMP_CMD_STOP	24
-/* Successfully aborted current command and stopped command ring */
-#define COMP_CMD_ABORT	25
-/* Stopped - transfer was terminated by a stop endpoint command */
-#define COMP_STOP	26
-/* Same as COMP_EP_STOPPED, but the transferred length in the event is invalid */
-#define COMP_STOP_INVAL	27
-/* Same as COMP_EP_STOPPED, but a short packet detected */
-#define COMP_STOP_SHORT	28
-/* Max Exit Latency Too Large Error */
-#define COMP_MEL_ERR	29
-/* TRB type 30 reserved */
-/* Isoc Buffer Overrun - an isoc IN ep sent more data than could fit in TD */
-#define COMP_BUFF_OVER	31
-/* Event Lost Error - xHC has an "internal event overrun condition" */
-#define COMP_ISSUES	32
-/* Undefined Error - reported when other error codes don't apply */
-#define COMP_UNKNOWN	33
-/* Invalid Stream ID Error */
-#define COMP_STRID_ERR	34
-/* Secondary Bandwidth Error - may be returned by a Configure Endpoint cmd */
-#define COMP_2ND_BW_ERR	35
-/* Split Transaction Error */
-#define	COMP_SPLIT_ERR	36
+#define COMP_INVALID				0
+#define COMP_SUCCESS				1
+#define COMP_DATA_BUFFER_ERROR			2
+#define COMP_BABBLE_DETECTED_ERROR		3
+#define COMP_USB_TRANSACTION_ERROR		4
+#define COMP_TRB_ERROR				5
+#define COMP_STALL_ERROR			6
+#define COMP_RESOURCE_ERROR			7
+#define COMP_BANDWIDTH_ERROR			8
+#define COMP_NO_SLOTS_AVAILABLE_ERROR		9
+#define COMP_INVALID_STREAM_TYPE_ERROR		10
+#define COMP_SLOT_NOT_ENABLED_ERROR		11
+#define COMP_ENDPOINT_NOT_ENABLED_ERROR		12
+#define COMP_SHORT_PACKET			13
+#define COMP_RING_UNDERRUN			14
+#define COMP_RING_OVERRUN			15
+#define COMP_VF_EVENT_RING_FULL_ERROR		16
+#define COMP_PARAMETER_ERROR			17
+#define COMP_BANDWIDTH_OVERRUN_ERROR		18
+#define COMP_CONTEXT_STATE_ERROR		19
+#define COMP_NO_PING_RESPONSE_ERROR		20
+#define COMP_EVENT_RING_FULL_ERROR		21
+#define COMP_INCOMPATIBLE_DEVICE_ERROR		22
+#define COMP_MISSED_SERVICE_ERROR		23
+#define COMP_COMMAND_RING_STOPPED		24
+#define COMP_COMMAND_ABORTED			25
+#define COMP_STOPPED				26
+#define COMP_STOPPED_LENGTH_INVALID		27
+#define COMP_STOPPED_SHORT_PACKET		28
+#define COMP_MAX_EXIT_LATENCY_TOO_LARGE_ERROR	29
+#define COMP_ISOCH_BUFFER_OVERRUN		31
+#define COMP_EVENT_LOST_ERROR			32
+#define COMP_UNDEFINED_ERROR			33
+#define COMP_INVALID_STREAM_ID_ERROR		34
+#define COMP_SECONDARY_BANDWIDTH_ERROR		35
+#define COMP_SPLIT_TRANSACTION_ERROR		36
 
 struct xhci_link_trb {
 	/* 64-bit segment pointer*/

commit 41135de1e7fd14c6fcb9158404ba5c8fb97bf259
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Jan 23 14:19:58 2017 +0200

    usb: xhci: add quirk flag for broken PED bits
    
    Some devices from Texas Instruments [1] suffer from
    a silicon bug where Port Enabled/Disabled bit
    should not be used to silence an erroneous device.
    
    The bug is so that if port is disabled with PED
    bit, an IRQ for device removal (or attachment)
    will never fire.
    
    Just for the sake of completeness, the actual
    problem lies with SNPS USB IP and this affects
    all known versions up to 3.00a. A separate
    patch will be added to dwc3 to enabled this
    quirk flag if version is <= 3.00a.
    
    [1] - AM572x Silicon Errata http://www.ti.com/lit/er/sprz429j/sprz429j.pdf
    Section i896 USB xHCI Port Disable Feature Does Not Work
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5bf9df25e2ea..b8474a2e6e5d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1648,6 +1648,9 @@ struct xhci_hcd {
 #define XHCI_SSIC_PORT_UNUSED	(1 << 22)
 #define XHCI_NO_64BIT_SUPPORT	(1 << 23)
 #define XHCI_MISSING_CAS	(1 << 24)
+/* For controller with a broken Port Disable implementation */
+#define XHCI_BROKEN_PORT_PED	(1 << 25)
+
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit e22caf8bc140d8efa52922040c173c0b84647b66
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon Jan 23 14:19:56 2017 +0200

    usb: host: xhci: Remove unused 'addr_64' variable in xhci_hcd structure
    
    Since the 'addr_64' variable as legacy is unused now, then remove it from
    xhci_hcd structure.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cdf8c037d481..5bf9df25e2ea 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1548,7 +1548,6 @@ struct xhci_hcd {
 	u8		max_ports;
 	u8		isoc_threshold;
 	int		event_ring_max;
-	int		addr_64;
 	/* 4KB min, 128MB max */
 	int		page_size;
 	/* Valid values are 12 to 20, inclusive */

commit f99265965b3203baf5266994578db14851fbf7fa
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 23 14:19:53 2017 +0200

    xhci: detect stop endpoint race using pending timer instead of counter.
    
    A counter was used to find out if the stop endpoint completion raced with
    the stop endpoint timeout timer. This was needed in case the stop ep
    completion failed to delete the timer as it was running on anoter cpu.
    
    The EP_STOP_CMD_PENDING flag was not enough as a new stop endpoint command
    may be queued between the command completion and timeout function, which
    would set the flag back.
    
    Instead of the separate counter that was used we can detect the race by
    checking both the STOP_EP_PENDING flag and timer_pending in the timeout
    function.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 198f40388344..cdf8c037d481 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -924,7 +924,6 @@ struct xhci_virt_ep {
 	unsigned int		stopped_stream;
 	/* Watchdog timer for stop endpoint command to cancel URBs */
 	struct timer_list	stop_cmd_timer;
-	int			stop_cmds_pending;
 	struct xhci_hcd		*xhci;
 	/* Dequeue pointer and dequeue segment for a submitted Set TR Dequeue
 	 * command.  We'll need to update the ring's dequeue segment and dequeue

commit 9983a5fc39bfce7581db49f884aa782f24149d93
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 23 14:19:52 2017 +0200

    xhci: rename EP_HALT_PENDING to EP_STOP_CMD_PENDING
    
    We don't want to confuse halted and stalled endpoint states with
    a flag indicating we are waiting for a stop endpoint command to
    finish or timeout
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2d7b6374b58d..198f40388344 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -912,7 +912,7 @@ struct xhci_virt_ep {
 	unsigned int			ep_state;
 #define SET_DEQ_PENDING		(1 << 0)
 #define EP_HALTED		(1 << 1)	/* For stall handling */
-#define EP_HALT_PENDING		(1 << 2)	/* For URB cancellation */
+#define EP_STOP_CMD_PENDING	(1 << 2)	/* For URB cancellation */
 /* Transitioning the endpoint to using streams, don't enqueue URBs */
 #define EP_GETTING_STREAMS	(1 << 3)
 #define EP_HAS_STREAMS		(1 << 4)

commit 1c111b6c3844a142e03bcfc2fa17bfbdea08e9dc
Author: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
Date:   Tue Jan 3 18:28:51 2017 +0200

    xhci: Fix race related to abort operation
    
    Current abort operation has race.
    
        xhci_handle_command_timeout()
          xhci_abort_cmd_ring()
            xhci_write_64(CMD_RING_ABORT)
            xhci_handshake(5s)
              do {
                check CMD_RING_RUNNING
                udelay(1)
                                             ...
                                             COMP_CMD_ABORT event
                                             COMP_CMD_STOP event
                                             xhci_handle_stopped_cmd_ring()
                                               restart cmd_ring
                                               CMD_RING_RUNNING become 1 again
              } while ()
              return -ETIMEDOUT
            xhci_write_64(CMD_RING_ABORT)
            /* can abort random command */
    
    To do abort operation correctly, we have to wait both of COMP_CMD_STOP
    event and negation of CMD_RING_RUNNING.
    
    But like above, while timeout handler is waiting negation of
    CMD_RING_RUNNING, event handler can restart cmd_ring. So timeout
    handler never be notice negation of CMD_RING_RUNNING, and retry of
    CMD_RING_ABORT can abort random command (BTW, I guess retry of
    CMD_RING_ABORT was workaround of this race).
    
    To fix this race, this moves xhci_handle_stopped_cmd_ring() to
    xhci_abort_cmd_ring().  And timeout handler waits COMP_CMD_STOP event.
    
    At this point, timeout handler is owner of cmd_ring, and safely
    restart cmd_ring by using xhci_handle_stopped_cmd_ring().
    
    [FWIW, as bonus, this way would be easily extend to add CMD_RING_PAUSE
    operation]
    
    [locks edited as patch is rebased on other locking fixes -Mathias]
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b54c486df956..2d7b6374b58d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1569,6 +1569,7 @@ struct xhci_hcd {
 	struct list_head        cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
 	struct delayed_work	cmd_timer;
+	struct completion	cmd_ring_stop_completion;
 	struct xhci_command	*current_cmd;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;

commit cb4d5ce588c5ff68e0fdd30370a0e6bc2c0a736b
Author: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
Date:   Tue Jan 3 18:28:50 2017 +0200

    xhci: Use delayed_work instead of timer for command timeout
    
    This is preparation to fix abort operation race (See "xhci: Fix race
    related to abort operation"). To make timeout sleepable, use
    delayed_work instead of timer.
    
    [change a newly added pending timer fix to pending work -Mathias]
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8ccc11a974b8..b54c486df956 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1568,7 +1568,7 @@ struct xhci_hcd {
 #define CMD_RING_STATE_STOPPED         (1 << 2)
 	struct list_head        cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
-	struct timer_list	cmd_timer;
+	struct delayed_work	cmd_timer;
 	struct xhci_command	*current_cmd;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
@@ -1934,7 +1934,7 @@ void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
-void xhci_handle_command_timeout(unsigned long data);
+void xhci_handle_command_timeout(struct work_struct *work);
 
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);

commit ae4d814bf1f2b0b7a37b3c30970d6974911f1377
Merge: 37be66767e3c d5c024f3761d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 18 16:02:15 2016 +0100

    Merge tag 'usb-for-v4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v4.10 merge window
    
    One big merge this time with a total of 166 non-merge commits.
    
    Most of the work, by far, is on dwc2 this time (68.2%) with dwc3 a far
    second (22.5%). The remaining 9.3% are scattered on gadget drivers.
    
    The most important changes for dwc2 are the peripheral side DMA support
    implemented by Synopsys folks and support for the new IOT dwc2
    compatible core from Synopsys.
    
    In dwc3 land we have support for high-bandwidth, high-speed isochronous
    endpoints and some non-critical fixes for large scatter lists.
    
    Apart from these, we have our usual set of cleanups, non-critical fixes,
    etc.

commit c2d3d49bba0889f42e4753651d103f7ba74fbaf1
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Nov 11 15:13:31 2016 +0200

    usb: xhci: move slot_id from xhci_hcd to xhci_command structure
    
    xhci->slot_id is used for providing a way to pass slot id from the
    command completion handler to the function waiting for completion.
    It's shared by enumerations of all USB devices connected to an
    xhci host. Hence, it's a source for possible races. Since we've
    introduced command structure and the command queue to xhci driver.
    It's better to move slot_id from xhci_hcd structure to xhci_command
    structure. Hence the race source is removed.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f24ae0ac12ae..266e3a86b6b4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -791,6 +791,7 @@ struct xhci_command {
 	/* Input context for changing device state */
 	struct xhci_container_ctx	*in_ctx;
 	u32				status;
+	int				slot_id;
 	/* If completion is null, no one is waiting on this command
 	 * and the structure can be freed after the command completes.
 	 */
@@ -1584,7 +1585,6 @@ struct xhci_hcd {
 	/* slot enabling and address device helpers */
 	/* these are not thread safe so use mutex */
 	struct mutex mutex;
-	int slot_id;
 	/* For USB 3.0 LPM enable/disable. */
 	struct xhci_command		*lpm_command;
 	/* Internal mirror of the HW's dcbaa */

commit 87e44f2aac8d45c1e48c94017942fa10037daae0
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Nov 11 15:13:30 2016 +0200

    usb: xhci: remove the use of xhci->addr_dev
    
    xhci->addr_dev is used for the completion of both address device
    and enable slot commands. It's shared by enumerations of all USB
    devices connected to an xhci host. Hence, it's just a source for
    possible races. Since we've introduced command structure and the
    command queue to xhci driver.  It is time to get rid of addr_dev
    and use the completion in the command structure instead.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2561924c34f2..f24ae0ac12ae 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1584,7 +1584,6 @@ struct xhci_hcd {
 	/* slot enabling and address device helpers */
 	/* these are not thread safe so use mutex */
 	struct mutex mutex;
-	struct completion	addr_dev;
 	int slot_id;
 	/* For USB 3.0 LPM enable/disable. */
 	struct xhci_command		*lpm_command;

commit 228cfaea541824ac9bb0c83d957e8b34d631f58a
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Nov 11 15:13:29 2016 +0200

    usb: xhci: cleanup cmd_completion in xhci_virt_device
    
    cmd_completion in struct xhci_virt_device is legacy. With command
    structure and command queue introduced in xhci, cmd_completion is
    not used any more. This patch removes it.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ad1a25b7b9be..2561924c34f2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -999,7 +999,6 @@ struct xhci_virt_device {
 	int				num_rings_cached;
 #define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
-	struct completion		cmd_completion;
 	u8				fake_port;
 	u8				real_port;
 	struct xhci_interval_bw_table	*bw_table;

commit 5071e6b279178f7d25e1aebd23f49f686657a5fb
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Nov 11 15:13:28 2016 +0200

    xhci: add helper to get the endpoint state of a endpoint context
    
    define GET_EP_CTX_STATE() macro to get the endpoint state from a
    pointer to a le32 enpoint context structure
    
    No functional changes
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0751c6ad52e6..ad1a25b7b9be 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -709,6 +709,8 @@ struct xhci_ep_ctx {
 #define EP_STATE_HALTED		2
 #define EP_STATE_STOPPED	3
 #define EP_STATE_ERROR		4
+#define GET_EP_CTX_STATE(ctx)	(le32_to_cpu((ctx)->ep_info) & EP_STATE_MASK)
+
 /* Mult - Max number of burtst within an interval, in EP companion desc. */
 #define EP_MULT(p)		(((p) & 0x3) << 8)
 #define CTX_TO_EP_MULT(p)	(((p) >> 8) & 0x3)

commit f4c8f03ca31a9cf4c122780ea693d145658ba397
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Fri Nov 11 15:13:25 2016 +0200

    usb: xhci: clean up error_bitmask usage
    
    In xhci_handle_event(), when errors are detected, driver always sets
    a bit in error_bitmask (one member of the xhci private driver data).
    That means users have to retrieve and decode the value of error_bitmask
    in xhci private driver data if they want to know whether those erros
    ever happened in xhci_handle_event(). Otherwise, those errors are just
    ignored silently.
    
    This patch cleans up this by replacing the setting of error_bitmask
    with the kernel print functions, so that users can easily check and
    report the errors happened in xhci_handle_event().
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f945380035d0..0751c6ad52e6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1618,8 +1618,6 @@ struct xhci_hcd {
 #define XHCI_STATE_DYING	(1 << 0)
 #define XHCI_STATE_HALTED	(1 << 1)
 #define XHCI_STATE_REMOVING	(1 << 2)
-	/* Statistics */
-	int			error_bitmask;
 	unsigned int		quirks;
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)

commit 734d3ddd81902d839e5bba50601b011f6ae40d05
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Wed Sep 28 13:46:37 2016 +0300

    usb: host: xhci: purge GET_MAX_PACKET()
    
    usb_endpoint_maxp() is now returning maxpacket
    correctly - iow only bits 10:0. We can finaly remove
    XHCI's private GET_MAX_PACKET macro.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f945380035d0..3e5922dcc2f9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -747,11 +747,6 @@ struct xhci_ep_ctx {
 #define MAX_PACKET_MASK		(0xffff << 16)
 #define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
 
-/* Get max packet size from ep desc. Bit 10..0 specify the max packet size.
- * USB2.0 spec 9.6.6.
- */
-#define GET_MAX_PACKET(p)	((p) & 0x7ff)
-
 /* tx_info bitmasks */
 #define EP_AVG_TRB_LENGTH(p)		((p) & 0xffff)
 #define EP_MAX_ESIT_PAYLOAD_LO(p)	(((p) & 0xffff) << 16)

commit 346e99736c3ce328fd42d678343b70243aca5f36
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 20 18:09:19 2016 +0300

    xhci: workaround for hosts missing CAS bit
    
    If a device is unplugged and replugged during Sx system suspend
    some  Intel xHC hosts will overwrite the CAS (Cold attach status) flag
    and no device connection is noticed in resume.
    
    A device in this state can be identified in resume if its link state
    is in polling or compliance mode, and the current connect status is 0.
    A device in this state needs to be warm reset.
    
    Intel 100/c230 series PCH specification update Doc #332692-006 Errata #8
    
    Observed on Cherryview and Apollolake as they go into compliance mode
    if LFPS times out during polling, and re-plugged devices are not
    discovered at resume.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b2c1dc5dc0f3..f945380035d0 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -314,6 +314,8 @@ struct xhci_op_regs {
 #define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
 #define XDEV_INACTIVE	(0x6 << 5)
+#define XDEV_POLLING	(0x7 << 5)
+#define XDEV_COMP_MODE  (0xa << 5)
 #define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)
@@ -1653,6 +1655,7 @@ struct xhci_hcd {
 #define XHCI_MTK_HOST		(1 << 21)
 #define XHCI_SSIC_PORT_UNUSED	(1 << 22)
 #define XHCI_NO_64BIT_SUPPORT	(1 << 23)
+#define XHCI_MISSING_CAS	(1 << 24)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit f9c589e142d04b8a19eb382162f804d17102b5ed
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jun 21 10:58:02 2016 +0300

    xhci: TD-fragment, align the unsplittable case with a bounce buffer
    
    If the last trb before a link is not packet size aligned, and is not
    splittable then use a bounce buffer for that chunk of max packet size
    unalignable data.
    
    Allocate a max packet size bounce buffer for every segment of a bulk
    endpoint ring at the same time as allocating the ring.
    If we need to align the data before the link trb in that segment then
    copy the data to the segment bounce buffer, dma map it, and enqueue it.
    Once the td finishes, or is cancelled, unmap it.
    
    For in transfers we need to first map the bounce buffer, then queue it,
    after it finishes, copy the bounce buffer to the original sg list, and
    finally unmap it
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b0b8d0f8791a..b2c1dc5dc0f3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1347,6 +1347,11 @@ struct xhci_segment {
 	/* private to HCD */
 	struct xhci_segment	*next;
 	dma_addr_t		dma;
+	/* Max packet sized bounce buffer for td-fragmant alignment */
+	dma_addr_t		bounce_dma;
+	void			*bounce_buf;
+	unsigned int		bounce_offs;
+	unsigned int		bounce_len;
 };
 
 struct xhci_td {
@@ -1356,6 +1361,7 @@ struct xhci_td {
 	struct xhci_segment	*start_seg;
 	union xhci_trb		*first_trb;
 	union xhci_trb		*last_trb;
+	struct xhci_segment	*bounce_seg;
 	/* actual_length of the URB has already been set */
 	bool			urb_length_set;
 };
@@ -1405,6 +1411,7 @@ struct xhci_ring {
 	unsigned int		num_segs;
 	unsigned int		num_trbs_free;
 	unsigned int		num_trbs_free_temp;
+	unsigned int		bounce_buf_len;
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 	struct radix_tree_root	*trb_address_map;
@@ -1807,7 +1814,8 @@ void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
 		unsigned int ep_index);
 struct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,
 		unsigned int num_stream_ctxs,
-		unsigned int num_streams, gfp_t flags);
+		unsigned int num_streams,
+		unsigned int max_packet, gfp_t flags);
 void xhci_free_stream_info(struct xhci_hcd *xhci,
 		struct xhci_stream_info *stream_info);
 void xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,

commit 75b040ec60a8bf0ef7f69fcfc8dd81c8f75eabc7
Author: Alexandr Ivanov <alexandr.sky@gmail.com>
Date:   Fri Apr 22 13:17:10 2016 +0300

    usb: xhci: remove duplicate function xhci_urb_to_transfer_ring
    
    Remove duplicate function xhci_urb_to_transfer_ring from xhci.c.
    We have same function in xhci-ring.c.
    
    Signed-off-by: Alexandr Ivanov <alexandr.sky@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8fd35a65913d..b0b8d0f8791a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1968,4 +1968,15 @@ struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_container_
 struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
 struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);
 
+struct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,
+		unsigned int slot_id, unsigned int ep_index,
+		unsigned int stream_id);
+static inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
+								struct urb *urb)
+{
+	return xhci_triad_to_transfer_ring(xhci, urb->dev->slot_id,
+					xhci_get_endpoint_index(&urb->ep->desc),
+					urb->stream_id);
+}
+
 #endif /* __LINUX_XHCI_HCD_H */

commit d2510342fe93d5ac8b807bc1d44b613eb5d9c64d
Author: Alexandr Ivanov <alexandr.sky@gmail.com>
Date:   Fri Apr 22 13:17:09 2016 +0300

    usb: xhci: merge xhci_queue_bulk_tx and queue_bulk_sg_tx functions
    
    In drivers/usb/host/xhci-ring.c there are two functions
    (xhci_queue_bulk_tx and queue_bulk_sg_tx) that are very similar,
    so a lot of code duplication.
    This patch merges these functions into to one xhci_queue_bulk_tx.
    Also counting the needed TRBs is merged and refactored.
    
    Signed-off-by: Alexandr Ivanov <alexandr.sky@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6c629c97f8ad..8fd35a65913d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1338,6 +1338,9 @@ union xhci_trb {
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
+/* How much data is left before the 64KB boundary? */
+#define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr)	(TRB_MAX_BUFF_SIZE - \
+					(addr & (TRB_MAX_BUFF_SIZE - 1)))
 
 struct xhci_segment {
 	union xhci_trb		*trbs;

commit 98d74f9ceaefc2b6c4a6440050163a83be0abede
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Apr 8 16:25:10 2016 +0300

    xhci: fix 10 second timeout on removal of PCI hotpluggable xhci controllers
    
    PCI hotpluggable xhci controllers such as some Alpine Ridge solutions will
    remove the xhci controller from the PCI bus when the last USB device is
    disconnected.
    
    Add a flag to indicate that the host is being removed to avoid queueing
    configure_endpoint commands for the dropped endpoints.
    For PCI hotplugged controllers this will prevent 5 second command timeouts
    For static xhci controllers the configure_endpoint command is not needed
    in the removal case as everything will be returned, freed, and the
    controller is reset.
    
    For now the flag is only set for PCI connected host controllers.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 70f215c20b2b..6c629c97f8ad 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1605,6 +1605,7 @@ struct xhci_hcd {
  */
 #define XHCI_STATE_DYING	(1 << 0)
 #define XHCI_STATE_HALTED	(1 << 1)
+#define XHCI_STATE_REMOVING	(1 << 2)
 	/* Statistics */
 	int			error_bitmask;
 	unsigned int		quirks;

commit 0a380be8233dbf8dd20795b801c5d5d5ef3992f7
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Fri Apr 8 16:25:07 2016 +0300

    usb: host: xhci: add a new quirk XHCI_NO_64BIT_SUPPORT
    
    On some xHCI controllers (e.g. R-Car SoCs), the AC64 bit (bit 0) of
    HCCPARAMS1 is set to 1. However, the xHCs don't support 64-bit
    address memory pointers actually. So, in this case, this driver should
    call dma_set_coherent_mask(dev, DMA_BIT_MASK(32)) in xhci_gen_setup().
    Otherwise, the xHCI controller will be died after a usb device is
    connected if it runs on above 4GB physical memory environment.
    
    So, this patch adds a new quirk XHCI_NO_64BIT_SUPPORT to resolve
    such an issue.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Reviewed-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e293e0974f48..70f215c20b2b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1641,6 +1641,7 @@ struct xhci_hcd {
 #define XHCI_PME_STUCK_QUIRK	(1 << 20)
 #define XHCI_MTK_HOST		(1 << 21)
 #define XHCI_SSIC_PORT_UNUSED	(1 << 22)
+#define XHCI_NO_64BIT_SUPPORT	(1 << 23)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 2f6d3b653777e68bbccfdcff3de2ea8165934531
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Feb 12 16:40:18 2016 +0200

    xhci: Support extended burst isoc TRB structure used by xhci 1.1 for USB 3.1
    
    The transfer burst count (TBC) field in the Isoc TRB does not fit the new
    larger burst count available for USB 3.1 SSP Isoc tranfers.
    xhci 1.1 solved this by reusing the TD size field for transfer burst count.
    The Mult field was outgrown as well. xhci 1.1  controllers can calculate
    Mult itself and is not set if the new layout is used.
    
    xhci 1.1 controllers that support the new Isoc TRB format expose a
    Extended TBC Capability (ETC). To take the new format into use the xhci
    host controller driver needs to set a Extended TBC Enable (ETE) bit.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 40a7efd86b9c..e293e0974f48 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -232,7 +232,9 @@ struct xhci_op_regs {
  * disabled, or powered-off state.
  */
 #define CMD_PM_INDEX	(1 << 11)
-/* bits 12:31 are reserved (and should be preserved on writes). */
+/* bit 14 Extended TBC Enable, changes Isoc TRB fields to support larger TBC */
+#define CMD_ETE		(1 << 14)
+/* bits 15:31 are reserved (and should be preserved on writes). */
 
 /* IMAN - Interrupt Management Register */
 #define IMAN_IE		(1 << 1)
@@ -943,6 +945,8 @@ struct xhci_virt_ep {
 	struct list_head	bw_endpoint_list;
 	/* Isoch Frame ID checking storage */
 	int			next_frame_id;
+	/* Use new Isoch TRB layout needed for extended TBC support */
+	bool			use_extended_tbc;
 };
 
 enum xhci_overhead_type {
@@ -1184,9 +1188,12 @@ enum xhci_setup_dev {
 #define	TRB_LEN(p)		((p) & 0x1ffff)
 /* TD Size, packets remaining in this TD, bits 21:17 (5 bits, so max 31) */
 #define TRB_TD_SIZE(p)          (min((p), (u32)31) << 17)
+/* xhci 1.1 uses the TD_SIZE field for TBC if Extended TBC is enabled (ETE) */
+#define TRB_TD_SIZE_TBC(p)      (min((p), (u32)31) << 17)
 /* Interrupter Target - which MSI-X vector to target the completion event at */
 #define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
 #define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)
+/* Total burst count field, Rsvdz on xhci 1.1 with Extended TBC enabled (ETE) */
 #define TRB_TBC(p)		(((p) & 0x3) << 7)
 #define TRB_TLBPC(p)		(((p) & 0xf) << 16)
 

commit 8ef8a9f5c148ae1dbeae926e5b6129e396faded2
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Feb 12 16:40:16 2016 +0200

    xhci: Add SuperSpeedPlus high bandwidth isoc support to xhci endpoints
    
    SuperSpeedPlus doubled the number of transactions per service interval
    the isoc endpoints supports.
    
    To support this, xhci 1.1 added Large ESIT Capability (LEC), which
    takes into use new bits in the endpoint context to fit the parameters.
    
    If xhci supports LEC, and the device has a SuperSpeedPlus Isoc companion
    descriptor then take into use the high bits of max esit payload, and
    skip calculating the Mult field as it wouldn't fit. LEC capable
    host will calculate the Mult based on other paramenters.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a0279cf4245f..40a7efd86b9c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -751,6 +751,7 @@ struct xhci_ep_ctx {
 /* tx_info bitmasks */
 #define EP_AVG_TRB_LENGTH(p)		((p) & 0xffff)
 #define EP_MAX_ESIT_PAYLOAD_LO(p)	(((p) & 0xffff) << 16)
+#define EP_MAX_ESIT_PAYLOAD_HI(p)	((((p) >> 16) & 0xff) << 24)
 #define CTX_TO_MAX_ESIT_PAYLOAD(p)	(((p) >> 16) & 0xffff)
 
 /* deq bitmasks */

commit def4e6f7b419c4092c82222d0896d6c409692326
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Feb 12 16:40:15 2016 +0200

    xhci: refactor and cleanup endpoint initialization.
    
    xhci_endpoint_init() and helper functions were a bit messy.
    Adding the higher bandwidth SuperSpeedPlus Isoc support on
    top of it would make it even harder to read.
    
    No functional changes.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e1bee3fe1a39..a0279cf4245f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -749,8 +749,8 @@ struct xhci_ep_ctx {
 #define GET_MAX_PACKET(p)	((p) & 0x7ff)
 
 /* tx_info bitmasks */
-#define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
-#define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
+#define EP_AVG_TRB_LENGTH(p)		((p) & 0xffff)
+#define EP_MAX_ESIT_PAYLOAD_LO(p)	(((p) & 0xffff) << 16)
 #define CTX_TO_MAX_ESIT_PAYLOAD(p)	(((p) >> 16) & 0xffff)
 
 /* deq bitmasks */

commit 172ad9af55d236cb124d67de7314a90dedb50df1
Merge: a44007a42dfd 18558cae0272
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Feb 14 14:38:30 2016 -0800

    Merge 4.5-rc4 into usb-next
    
    We want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7e70cbffe236721051bbaff965e477df06dcb190
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jan 26 17:50:06 2016 +0200

    usb: xhci: add a quirk bit for ssic port unused
    
    Two workarounds introduced by commit b8cb91e058cd ("xhci: Workaround
    for PME stuck issues in Intel xhci") and commit abce329c27b3 ("xhci:
    Workaround to get D3 working in Intel xHCI") share a single quirk bit
    XHCI_PME_STUCK_QUIRK. These two workarounds actually are different and
    might happen on different hardwares. Need to separate them by adding a
    quirk bit for the later.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9be7348872ba..cc651383ce5a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1631,6 +1631,7 @@ struct xhci_hcd {
 #define XHCI_BROKEN_STREAMS	(1 << 19)
 #define XHCI_PME_STUCK_QUIRK	(1 << 20)
 #define XHCI_MTK_HOST		(1 << 21)
+#define XHCI_SSIC_PORT_UNUSED	(1 << 22)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit d78540419866887345cec480016b0f87f6a5aca2
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Jan 25 15:30:47 2016 +0200

    xhci: set slot context speed field to SuperSpeedPlus for USB 3.1 SSP devices
    
    The speed field of the input slot context should represent the speed the
    device is working at.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9be7348872ba..9f28bea65fed 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -343,6 +343,7 @@ struct xhci_op_regs {
 #define	SLOT_SPEED_LS		(XDEV_LS << 10)
 #define	SLOT_SPEED_HS		(XDEV_HS << 10)
 #define	SLOT_SPEED_SS		(XDEV_SS << 10)
+#define	SLOT_SPEED_SSP		(XDEV_SSP << 10)
 /* Port Indicator Control */
 #define PORT_LED_OFF	(0 << 14)
 #define PORT_LED_AMBER	(1 << 14)

commit 0cbd4b34cda9dfd36b6c26b692dee181e0100b67
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Tue Nov 24 13:09:55 2015 +0200

    xhci: mediatek: support MTK xHCI host controller
    
    There some vendor quirks for MTK xhci host controller:
    1. It defines some extra SW scheduling parameters for HW
      to minimize the scheduling effort for synchronous and
      interrupt endpoints. The parameters are put into reseved
      DWs of slot context and endpoint context.
    2. Its IMODI unit for Interrupter Moderation register is
      8 times as much as that defined in xHCI spec.
    3. Its TDS in  Normal TRB defines a number of packets that
      remains to be transferred for a TD after processing all
      Max packets in all previous TRBs.
    
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8b4629650328..9be7348872ba 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1630,6 +1630,7 @@ struct xhci_hcd {
 /* For controllers with a broken beyond repair streams implementation */
 #define XHCI_BROKEN_STREAMS	(1 << 19)
 #define XHCI_PME_STUCK_QUIRK	(1 << 20)
+#define XHCI_MTK_HOST		(1 << 21)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 79a17ddf89173cf3749656e5d3f87d33c196492b
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Nov 24 13:09:48 2015 +0200

    usb: host: xhci: add a platform-private field
    
    This patch adds an xhci->priv field for private use by
    XHCI platform drivers. Until now none of the platform drivers
    has used this private space.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0b9451250e33..8b4629650328 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1656,6 +1656,9 @@ struct xhci_hcd {
 	u32			port_status_u0;
 /* Compliance Mode Timer Triggered every 2 seconds */
 #define COMP_MODE_RCVRY_MSECS 2000
+
+	/* platform-specific data -- must come last */
+	unsigned long		priv[0] __aligned(sizeof(s64));
 };
 
 /* Platform specific overrides to generic XHCI hc_driver ops */

commit 9cf5c095b65da63c08b928a7d0015d5d5dca8a66
Merge: 22402cd0af68 4008cb3ad223
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 14:22:15 2015 -0800

    Merge tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic cleanups from Arnd Bergmann:
     "The asm-generic changes for 4.4 are mostly a series from Christoph
      Hellwig to clean up various abuses of headers in there.  The patch to
      rename the io-64-nonatomic-*.h headers caused some conflicts with new
      users, so I added a workaround that we can remove in the next merge
      window.
    
      The only other patch is a warning fix from Marek Vasut"
    
    * tag 'asm-generic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic:
      asm-generic: temporarily add back asm-generic/io-64-nonatomic*.h
      asm-generic: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
      gpio-mxc: stop including <asm-generic/bug>
      n_tracesink: stop including <asm-generic/bug>
      n_tracerouter: stop including <asm-generic/bug>
      mlx5: stop including <asm-generic/kmap_types.h>
      hifn_795x: stop including <asm-generic/kmap_types.h>
      drbd: stop including <asm-generic/kmap_types.h>
      move count_zeroes.h out of asm-generic
      move io-64-nonatomic*.h out of asm-generic

commit 5990e5dd7850b4e76a0dace302ac1f801fb8c729
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Oct 9 13:30:09 2015 +0300

    xhci: replace custom implementation of readq / writeq
    
    The readq() and writeq() helpers are available in the
    asm-generic/io-64-nonatomic-hi-lo.h and asm-generic/io-64-nonatomic-lo-hi.h
    headers. Replace custom implementation by the generic helpers.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f24b7d1e255b..be9048e2d4d4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -29,6 +29,8 @@
 #include <linux/kernel.h>
 #include <linux/usb/hcd.h>
 
+#include <asm-generic/io-64-nonatomic-lo-hi.h>
+
 /* Code sharing between pci-quirks and xhci hcd */
 #include	"xhci-ext-caps.h"
 #include "pci-quirks.h"
@@ -1707,20 +1709,12 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
 		__le64 __iomem *regs)
 {
-	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u64 val_lo = readl(ptr);
-	u64 val_hi = readl(ptr + 1);
-	return val_lo + (val_hi << 32);
+	return lo_hi_readq(regs);
 }
 static inline void xhci_write_64(struct xhci_hcd *xhci,
 				 const u64 val, __le64 __iomem *regs)
 {
-	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u32 val_lo = lower_32_bits(val);
-	u32 val_hi = upper_32_bits(val);
-
-	writel(val_lo, ptr);
-	writel(val_hi, ptr + 1);
+	lo_hi_writeq(val, regs);
 }
 
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)

commit c840d6ce772d47c777070ca4bbbfbf21d8d727a3
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Oct 9 13:30:08 2015 +0300

    xhci: create one unified function to calculate TRB TD remainder.
    
    xhci versions 1.0 and later report the untransferred data remaining in a
    TD a bit differently than older hosts.
    
    We used to have separate functions for these, and needed to check host
    version before calling the right function.
    
    Now Mediatek host has an additional quirk on how it uses the TD Size
    field for remaining data. To prevent yet another function for calculating
    remainder we instead want to make one quirk friendly unified function.
    
    Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 51093df15938..f24b7d1e255b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1179,6 +1179,8 @@ enum xhci_setup_dev {
 /* Normal TRB fields */
 /* transfer_len bitmasks - bits 0:16 */
 #define	TRB_LEN(p)		((p) & 0x1ffff)
+/* TD Size, packets remaining in this TD, bits 21:17 (5 bits, so max 31) */
+#define TRB_TD_SIZE(p)          (min((p), (u32)31) << 17)
 /* Interrupter Target - which MSI-X vector to target the completion event at */
 #define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
 #define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)

commit 395f5409ca4336ee6ad461d3e0436bcc2d7c6309
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:39 2015 +0300

    xhci: support new USB 3.1 hub request to get extended port status
    
    USB 3.1 adds different types of Get Port Status request.
    The Get Extended Port Status request returns 4 additional bytes
    after the normal portstatus and portchange words containing
    link speed and lane information about a connected enhanced super
    speed device
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e2c76e210817..51093df15938 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -335,6 +335,7 @@ struct xhci_op_regs {
 #define DEV_SUPERSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_SS)
 #define DEV_SUPERSPEEDPLUS(p)	(((p) & DEV_SPEED_MASK) == XDEV_SSP)
 #define DEV_SUPERSPEED_ANY(p)	(((p) & DEV_SPEED_MASK) >= XDEV_SS)
+#define DEV_PORT_SPEED(p)	(((p) >> 10) & 0x0f)
 
 /* Bits 20:23 in the Slot Context are the speed for the device */
 #define	SLOT_SPEED_FS		(XDEV_FS << 10)
@@ -419,6 +420,9 @@ struct xhci_op_regs {
 #define	PORT_L1DS(p)		(((p) & 0xff) << 8)
 #define	PORT_HLE		(1 << 16)
 
+/* USB3 Protocol PORTLI  Port Link Information */
+#define PORT_RX_LANES(p)	(((p) >> 16) & 0xf)
+#define PORT_TX_LANES(p)	(((p) >> 20) & 0xf)
 
 /* USB2 Protocol PORTHLPMC */
 #define PORT_HIRDM(p)((p) & 3)

commit 2338b9e47fba0cd35e1e59f09838a8b9b339a55a
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:36 2015 +0300

    xhci: define the new default speed ID for SuperSpeedPlus used by xhci hw
    
    USB 3.1 capable xhci controllers use a new default speed ID "5" in the
    PORTSC register to represent a 10Gbps connection speed of a SuperSpeedPlus
    device
    
    Make sure the xhci driver can handle the returned SuperSpeedPlus speed ID
    properly
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cd4a6e795329..e2c76e210817 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -327,11 +327,15 @@ struct xhci_op_regs {
 #define	XDEV_LS			(0x2 << 10)
 #define	XDEV_HS			(0x3 << 10)
 #define	XDEV_SS			(0x4 << 10)
+#define	XDEV_SSP		(0x5 << 10)
 #define DEV_UNDEFSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x0<<10))
 #define DEV_FULLSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_FS)
 #define DEV_LOWSPEED(p)		(((p) & DEV_SPEED_MASK) == XDEV_LS)
 #define DEV_HIGHSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_HS)
 #define DEV_SUPERSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_SS)
+#define DEV_SUPERSPEEDPLUS(p)	(((p) & DEV_SPEED_MASK) == XDEV_SSP)
+#define DEV_SUPERSPEED_ANY(p)	(((p) & DEV_SPEED_MASK) >= XDEV_SS)
+
 /* Bits 20:23 in the Slot Context are the speed for the device */
 #define	SLOT_SPEED_FS		(XDEV_FS << 10)
 #define	SLOT_SPEED_LS		(XDEV_LS << 10)

commit 47189098f8bebe4d937945df70d3ca8e6c0b3e4d
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:34 2015 +0300

    xhci: parse xhci protocol speed ID list for usb 3.1 usage
    
    xhci 1.1 controllers that support USB 3.1 must provide a protocol speed ID
    (PSI) list to inform the driver of the supported speeds.
    
    The PSI list can be read from the xhci supported protocol extended
    capabilities.
    The PSI values will be used to create a USB 3.1 SuperSpeedPlus capability
    descriptor for the xhci USB 3.1 roothub.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 17d4d4408637..cd4a6e795329 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -540,9 +540,23 @@ struct xhci_protocol_caps {
 };
 
 #define	XHCI_EXT_PORT_MAJOR(x)	(((x) >> 24) & 0xff)
+#define	XHCI_EXT_PORT_MINOR(x)	(((x) >> 16) & 0xff)
+#define	XHCI_EXT_PORT_PSIC(x)	(((x) >> 28) & 0x0f)
 #define	XHCI_EXT_PORT_OFF(x)	((x) & 0xff)
 #define	XHCI_EXT_PORT_COUNT(x)	(((x) >> 8) & 0xff)
 
+#define	XHCI_EXT_PORT_PSIV(x)	(((x) >> 0) & 0x0f)
+#define	XHCI_EXT_PORT_PSIE(x)	(((x) >> 4) & 0x03)
+#define	XHCI_EXT_PORT_PLT(x)	(((x) >> 6) & 0x03)
+#define	XHCI_EXT_PORT_PFD(x)	(((x) >> 8) & 0x01)
+#define	XHCI_EXT_PORT_LP(x)	(((x) >> 14) & 0x03)
+#define	XHCI_EXT_PORT_PSIM(x)	(((x) >> 16) & 0xffff)
+
+#define PLT_MASK        (0x03 << 6)
+#define PLT_SYM         (0x00 << 6)
+#define PLT_ASYM_RX     (0x02 << 6)
+#define PLT_ASYM_TX     (0x03 << 6)
+
 /**
  * struct xhci_container_ctx
  * @type: Type of context.  Used to calculated offsets to contained contexts.
@@ -1469,6 +1483,14 @@ static inline unsigned int hcd_index(struct usb_hcd *hcd)
 		return 1;
 }
 
+struct xhci_hub {
+	u8	maj_rev;
+	u8	min_rev;
+	u32	*psi;		/* array of protocol speed ID entries */
+	u8	psi_count;
+	u8	psi_uid_count;
+};
+
 /* There is one xhci_hcd structure per controller */
 struct xhci_hcd {
 	struct usb_hcd *main_hcd;
@@ -1608,6 +1630,8 @@ struct xhci_hcd {
 	unsigned int		num_usb3_ports;
 	/* Array of pointers to USB 2.0 PORTSC registers */
 	__le32 __iomem		**usb2_ports;
+	struct xhci_hub		usb2_rhub;
+	struct xhci_hub		usb3_rhub;
 	unsigned int		num_usb2_ports;
 	/* support xHCI 0.96 spec USB2 software LPM */
 	unsigned		sw_lpm_support:1;

commit 04abb6de28250d619ec5aa53695f12a1e4265e1a
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Oct 1 18:40:31 2015 +0300

    xhci: Read and parse new xhci 1.1 capability register
    
    xhci 1.1 capable controllers have a new HCCPARAMS2 registers
    with bits indicating support for new xhci 1.1 capabilities.
    
    Also add support for the new xhci 1.1 bits in the config operational
    opertational register that used to be reserved
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    [modified and left out parts not related to HCCPARAMS2 -Mathias]
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dbda41e91c84..17d4d4408637 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -56,6 +56,7 @@
  * @hcc_params:		HCCPARAMS - Capability Parameters
  * @db_off:		DBOFF - Doorbell array offset
  * @run_regs_off:	RTSOFF - Runtime register space offset
+ * @hcc_params2:	HCCPARAMS2 Capability Parameters 2, xhci 1.1 only
  */
 struct xhci_cap_regs {
 	__le32	hc_capbase;
@@ -65,6 +66,7 @@ struct xhci_cap_regs {
 	__le32	hcc_params;
 	__le32	db_off;
 	__le32	run_regs_off;
+	__le32	hcc_params2; /* xhci 1.1 */
 	/* Reserved up to (CAPLENGTH - 0x1C) */
 };
 
@@ -134,6 +136,21 @@ struct xhci_cap_regs {
 /* run_regs_off bitmask - bits 0:4 reserved */
 #define	RTSOFF_MASK	(~0x1f)
 
+/* HCCPARAMS2 - hcc_params2 - bitmasks */
+/* true: HC supports U3 entry Capability */
+#define	HCC2_U3C(p)		((p) & (1 << 0))
+/* true: HC supports Configure endpoint command Max exit latency too large */
+#define	HCC2_CMC(p)		((p) & (1 << 1))
+/* true: HC supports Force Save context Capability */
+#define	HCC2_FSC(p)		((p) & (1 << 2))
+/* true: HC supports Compliance Transition Capability */
+#define	HCC2_CTC(p)		((p) & (1 << 3))
+/* true: HC support Large ESIT payload Capability > 48k */
+#define	HCC2_LEC(p)		((p) & (1 << 4))
+/* true: HC support Configuration Information Capability */
+#define	HCC2_CIC(p)		((p) & (1 << 5))
+/* true: HC support Extended TBC Capability, Isoc burst count > 65535 */
+#define	HCC2_ETC(p)		((p) & (1 << 6))
 
 /* Number of registers per port */
 #define	NUM_PORT_REGS	4
@@ -269,7 +286,11 @@ struct xhci_op_regs {
 /* CONFIG - Configure Register - config_reg bitmasks */
 /* bits 0:7 - maximum number of device slots enabled (NumSlotsEn) */
 #define MAX_DEVS(p)	((p) & 0xff)
-/* bits 8:31 - reserved and should be preserved */
+/* bit 8: U3 Entry Enabled, assert PLC when root port enters U3, xhci 1.1 */
+#define CONFIG_U3E		(1 << 8)
+/* bit 9: Configuration Information Enable, xhci 1.1 */
+#define CONFIG_CIE		(1 << 9)
+/* bits 10:31 - reserved and should be preserved */
 
 /* PORTSC - Port Status and Control Register - port_status_base bitmasks */
 /* true: device connected */
@@ -1465,6 +1486,7 @@ struct xhci_hcd {
 	__u32		hcs_params2;
 	__u32		hcs_params3;
 	__u32		hcc_params;
+	__u32		hcc_params2;
 
 	spinlock_t	lock;
 

commit 40a3b775f49c2784c96b19170fd2478e5e5511a1
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Aug 6 19:24:01 2015 +0300

    xhci: xHCI 1.1: Stopped - Short Packet Capability (SPC)
    
    This patch enables xhci driver to support SPC by handling
    Stopped - Short Packet event in transfer event path.
    
    If SPC = '1' and the stop endpoint command is executed, after a Short
    Packet condition has been detected, but before the end of the TD has been
    reached, (i.e. the TD is in progress for pipe), then a Transfer Event TRB
    with its Completion Code set to Stopped - Short Packet and its TRB
    Transfer Length set to value of the EDTLA shall be forced for the
    interrupted TRB, irrespective of whether its IOC or ISP flags are set.
    This Transfer Event TRB will precede the Command Completion Event TRB for
    the command, and is referred to as a Stopped Transfer Event.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 73686928cae3..dbda41e91c84 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -119,6 +119,8 @@ struct xhci_cap_regs {
 #define HCC_LTC(p)		((p) & (1 << 6))
 /* true: no secondary Stream ID Support */
 #define HCC_NSS(p)		((p) & (1 << 7))
+/* true: HC supports Stopped - Short Packet */
+#define HCC_SPC(p)		((p) & (1 << 9))
 /* true: HC has Contiguous Frame ID Capability */
 #define HCC_CFC(p)		((p) & (1 << 11))
 /* Max size for Primary Stream Arrays - 2^(n+1), where n is bits 12:15 */
@@ -1063,8 +1065,8 @@ struct xhci_transfer_event {
 #define COMP_STOP	26
 /* Same as COMP_EP_STOPPED, but the transferred length in the event is invalid */
 #define COMP_STOP_INVAL	27
-/* Control Abort Error - Debug Capability - control pipe aborted */
-#define COMP_DBG_ABORT	28
+/* Same as COMP_EP_STOPPED, but a short packet detected */
+#define COMP_STOP_SHORT	28
 /* Max Exit Latency Too Large Error */
 #define COMP_MEL_ERR	29
 /* TRB type 30 reserved */

commit 79b8094f60d8ce54ee76e631ab665c5e3012e6ba
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Aug 6 19:24:00 2015 +0300

    xhci: xHCI 1.1: Contiguous Frame ID Capability (CFC)
    
    If the Contiguous Frame ID Capability is supported (CFC = 1),
    then the xHC shall match the Frame ID in every Isoch TD with
    SIA = 0 against the Frame Index of the MFINDEX register. This
    rule ensures resynchronization of Isoch TDs even if some are
    dropped due to Missed Service Errors or Stopping the endpoint.
    
    This patch enables xHCI driver to support CFC by calculating
    and setting the Frame ID field of an Isoch TRB.
    
    [made some dbg messages checkpatch friendly -Mathias]
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ed2ebf647c38..73686928cae3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -119,6 +119,8 @@ struct xhci_cap_regs {
 #define HCC_LTC(p)		((p) & (1 << 6))
 /* true: no secondary Stream ID Support */
 #define HCC_NSS(p)		((p) & (1 << 7))
+/* true: HC has Contiguous Frame ID Capability */
+#define HCC_CFC(p)		((p) & (1 << 11))
 /* Max size for Primary Stream Arrays - 2^(n+1), where n is bits 12:15 */
 #define HCC_MAX_PSA(p)		(1 << ((((p) >> 12) & 0xf) + 1))
 /* Extended Capabilities pointer from PCI base - section 5.3.6 */
@@ -891,6 +893,8 @@ struct xhci_virt_ep {
 	/* Bandwidth checking storage */
 	struct xhci_bw_info	bw_info;
 	struct list_head	bw_endpoint_list;
+	/* Isoch Frame ID checking storage */
+	int			next_frame_id;
 };
 
 enum xhci_overhead_type {
@@ -1165,6 +1169,7 @@ enum xhci_setup_dev {
 
 /* Isochronous TRB specific fields */
 #define TRB_SIA			(1<<31)
+#define TRB_FRAME_ID(p)		(((p) & 0x7ff) << 20)
 
 struct xhci_generic_trb {
 	__le32 field[4];
@@ -1601,6 +1606,8 @@ struct xhci_driver_overrides {
 	int (*start)(struct usb_hcd *hcd);
 };
 
+#define	XHCI_CFC_DELAY		10
+
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
 {

commit fac4271d1126c45ceaceb7f4a336317b771eb121
Author: Zhuang Jin Can <jin.can.zhuang@intel.com>
Date:   Tue Jul 21 17:20:30 2015 +0300

    xhci: prevent bus_suspend if SS port resuming in phase 1
    
    When the link is just waken, it's in Resume state, and driver sets PLS to
    U0. This refers to Phase 1. Phase 2 refers to when the link has completed
    the transition from Resume state to U0.
    
    With the fix of xhci: report U3 when link is in resume state, it also
    exposes an issue that usb3 roothub and controller can suspend right
    after phase 1, and this causes a hard hang in controller.
    
    To fix the issue, we need to prevent usb3 bus suspend if any port is
    resuming in phase 1.
    
    [merge separate USB2 and USB3 port resume checking to one -Mathias]
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Zhuang Jin Can <jin.can.zhuang@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 31e46cc55807..ed2ebf647c38 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -285,6 +285,7 @@ struct xhci_op_regs {
 #define XDEV_U0		(0x0 << 5)
 #define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
+#define XDEV_INACTIVE	(0x6 << 5)
 #define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)

commit 19915e623458004547c1c2490b09bb923fe69337
Merge: 4e47dcf78d2f d4a4f75cd8f2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 8 10:57:51 2015 -0700

    Merge 4.1-rc7 into usb-next
    
    This resolves a merge issue in musb_core.c and we want the fixes that
    were in Linus's tree in this branch as well for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cd33a32157e42483ffea31e32b1cee4f11ff9592
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri May 29 17:01:46 2015 +0300

    usb: xhci: cleanup xhci_hcd allocation
    
    HCD core allocates memory for HCD private data in
    usb_create_[shared_]hcd() so make use of that
    mechanism to allocate the struct xhci_hcd.
    
    Introduce struct xhci_driver_overrides to provide
    the size of HCD private data and hc_driver operation
    overrides. As of now we only need to override the
    reset and start methods.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ea75e8ccd3c1..11a231d61409 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1591,10 +1591,24 @@ struct xhci_hcd {
 #define COMP_MODE_RCVRY_MSECS 2000
 };
 
+/* Platform specific overrides to generic XHCI hc_driver ops */
+struct xhci_driver_overrides {
+	size_t extra_priv_size;
+	int (*reset)(struct usb_hcd *hcd);
+	int (*start)(struct usb_hcd *hcd);
+};
+
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
 {
-	return *((struct xhci_hcd **) (hcd->hcd_priv));
+	struct usb_hcd *primary_hcd;
+
+	if (usb_hcd_is_primary_hcd(hcd))
+		primary_hcd = hcd;
+	else
+		primary_hcd = hcd->primary_hcd;
+
+	return (struct xhci_hcd *) (primary_hcd->hcd_priv);
 }
 
 static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
@@ -1748,7 +1762,8 @@ int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
-void xhci_init_driver(struct hc_driver *drv, int (*setup_fn)(struct usb_hcd *));
+void xhci_init_driver(struct hc_driver *drv,
+		      const struct xhci_driver_overrides *over);
 
 #ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);

commit a00918d0521df1c7a2ec9143142a3ea998c8526d
Author: Chris Bainbridge <chris.bainbridge@gmail.com>
Date:   Tue May 19 16:30:51 2015 +0300

    usb: host: xhci: add mutex for non-thread-safe data
    
    Regression in commit 638139eb95d2 ("usb: hub: allow to process more usb
    hub events in parallel")
    
    The regression resulted in intermittent failure to initialise a 10-port
    hub (with three internal VL812 4-port hub controllers) on boot, with a
    failure rate of around 8%, due to multiple race conditions when
    accessing addr_dev and slot_id in struct xhci_hcd.
    
    This regression also exposed a problem with xhci_setup_device, which
    "should be protected by the usb_address0_mutex" but no longer is due to
    
    commit 6fecd4f2a58c ("USB: separate usb_address0 mutexes for each bus")
    
    With separate buses (and locks) it is no longer the case that a single
    lock will protect xhci_setup_device from accesses by two parallel
    threads processing events on the two buses.
    
    Fix this by adding a mutex to protect addr_dev and slot_id in struct
    xhci_hcd, and by making the assignment of slot_id atomic.
    
    Fixes multiple boot errors:
    
    [ 0.583008] xhci_hcd 0000:00:14.0: Bad Slot ID 2
    [ 0.583009] xhci_hcd 0000:00:14.0: Could not allocate xHCI USB device data structures
    [ 0.583012] usb usb1-port3: couldn't allocate usb_device
    
    And:
    
    [ 0.637409] xhci_hcd 0000:00:14.0: Error while assigning device slot ID
    [ 0.637417] xhci_hcd 0000:00:14.0: Max number of devices this xHCI host supports is 32.
    [ 0.637421] usb usb1-port1: couldn't allocate usb_device
    
    And:
    
    [ 0.753372] xhci_hcd 0000:00:14.0: ERROR: unexpected setup context command completion code 0x0.
    [ 0.753373] usb 1-3: hub failed to enable device, error -22
    [ 0.753400] xhci_hcd 0000:00:14.0: Error while assigning device slot ID
    [ 0.753402] xhci_hcd 0000:00:14.0: Max number of devices this xHCI host supports is 32.
    [ 0.753403] usb usb1-port3: couldn't allocate usb_device
    
    And:
    
    [ 11.018386] usb 1-3: device descriptor read/all, error -110
    
    And:
    
    [ 5.753838] xhci_hcd 0000:00:14.0: Timeout while waiting for setup device command
    
    Tested with 200 reboots, resulting in no USB hub init related errors.
    
    Fixes: 638139eb95d2 ("usb: hub: allow to process more usb hub events in parallel")
    Link: https://lkml.kernel.org/g/CAP-bSRb=A0iEYobdGCLpwynS7pkxpt_9ZnwyZTPVAoy0Y=Zo3Q@mail.gmail.com
    Signed-off-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Cc: <stable@vger.kernel.org> # 3.18+
    [changed git commit description style for checkpatch -Mathias]
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ea75e8ccd3c1..6977f8491fa7 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1497,6 +1497,8 @@ struct xhci_hcd {
 	struct list_head	lpm_failed_devs;
 
 	/* slot enabling and address device helpers */
+	/* these are not thread safe so use mutex */
+	struct mutex mutex;
 	struct completion	addr_dev;
 	int slot_id;
 	/* For USB 3.0 LPM enable/disable. */

commit 18cc2f4cbbaf825a4fedcf2d60fd388d291e0a38
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Apr 30 17:16:03 2015 +0300

    xhci: Solve full event ring by increasing TRBS_PER_SEGMENT to 256
    
    Our event ring consists of only one segment, and we risk filling
    the event ring in case we get isoc transfers with short intervals
    such as webcams that fill a TD every microframe (125us)
    
    With 64 TRB segment size one usb camera could fill the event ring in 8ms.
    A setup with several cameras and other devices can fill up the
    event ring as it is shared between all devices.
    This has occurred when uvcvideo queues 5 * 32TD URBs which then
    get cancelled when the video mode changes. The cancelled URBs are returned
    in the xhci interrupt context and blocks the interrupt handler from
    handling the new events.
    
    A full event ring will block xhci from scheduling traffic and affect all
    devices conneted to the xhci, will see errors such as Missed Service
    Intervals for isoc devices, and  and Split transaction errors for LS/FS
    interrupt devices.
    
    Increasing the TRB_PER_SEGMENT will also increase the default endpoint ring
    size, which is welcome as for most isoc transfer we had to dynamically
    expand the endpoint ring anyway to be able to queue the 5 * 32TDs uvcvideo
    queues.
    
    The default size used to be 64 TRBs per segment
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8e421b89632d..ea75e8ccd3c1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1267,7 +1267,7 @@ union xhci_trb {
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
-#define TRBS_PER_SEGMENT	64
+#define TRBS_PER_SEGMENT	256
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)

commit d0167ad2954ee2d1c70704c454c646086b6653d6
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Mar 10 19:49:00 2015 +0200

    Revert "xhci: Clear the host side toggle manually when endpoint is 'soft reset'"
    
    This reverts commit 27082e2654dc ("xhci: Clear the host side toggle manually")
    
    Turns out this fix to enable soft resetting endpoints wasn't mature enough.
    It caused regression with some usb DVB-T devices and needs some more tuning
    to get the endpiont ring pointers set correctly.
    
    The original commit was tagged for stable 3.18, and should be reverted
    from there as well.
    
    Cc: stable <stable@vger.kernel.org> # v3.18
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 265ab1771d24..8e421b89632d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -865,8 +865,6 @@ struct xhci_virt_ep {
 #define EP_HAS_STREAMS		(1 << 4)
 /* Transitioning the endpoint to not using streams, don't enqueue URBs */
 #define EP_GETTING_NO_STREAMS	(1 << 5)
-#define EP_RECENTLY_HALTED	(1 << 6)
-#define EP_CONFIG_PENDING	(1 << 7)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
 	struct xhci_td		*stopped_td;

commit b8cb91e058cd0c0f02059c1207293c5b31d350fa
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Mar 6 17:23:19 2015 +0200

    xhci: Workaround for PME stuck issues in Intel xhci
    
    The xhci in Intel Sunrisepoint and Cherryview platforms need a driver
    workaround for a Stuck PME that might either block PME events in suspend,
    or create spurious PME events preventing runtime suspend.
    
    Workaround is to clear a internal PME flag, BIT(28) in a vendor specific
    PMCTRL register at offset 0x80a4, in both suspend resume callbacks
    
    Without this, xhci connected usb devices might never be able to wake up the
    system from suspend, or prevent device from going to suspend (xhci d3)
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d0663931e5ba..265ab1771d24 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1566,6 +1566,7 @@ struct xhci_hcd {
 #define XHCI_SPURIOUS_WAKEUP	(1 << 18)
 /* For controllers with a broken beyond repair streams implementation */
 #define XHCI_BROKEN_STREAMS	(1 << 19)
+#define XHCI_PME_STUCK_QUIRK	(1 << 20)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 45ba2154d12fc43b70312198ec47085f10be801a
Author: Aleksander Morgado <aleksander@aleksander.es>
Date:   Fri Mar 6 17:14:21 2015 +0200

    xhci: fix reporting of 0-sized URBs in control endpoint
    
    When a control transfer has a short data stage, the xHCI controller generates
    two transfer events: a COMP_SHORT_TX event that specifies the untransferred
    amount, and a COMP_SUCCESS event. But when the data stage is not short, only the
    COMP_SUCCESS event occurs. Therefore, xhci-hcd must set urb->actual_length to
    urb->transfer_buffer_length while processing the COMP_SUCCESS event, unless
    urb->actual_length was set already by a previous COMP_SHORT_TX event.
    
    The driver checks this by seeing whether urb->actual_length == 0, but this alone
    is the wrong test, as it is entirely possible for a short transfer to have an
    urb->actual_length = 0.
    
    This patch changes the xhci driver to rely on a new td->urb_length_set flag,
    which is set to true when a COMP_SHORT_TX event is received and the URB length
    updated at that stage.
    
    This fixes a bug which affected the HSO plugin, which relies on URBs with
    urb->actual_length == 0 to halt re-submitting the RX URB in the control
    endpoint.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Aleksander Morgado <aleksander@aleksander.es>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3b97f0582155..d0663931e5ba 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1,3 +1,4 @@
+
 /*
  * xHCI host controller driver
  *
@@ -1291,6 +1292,8 @@ struct xhci_td {
 	struct xhci_segment	*start_seg;
 	union xhci_trb		*first_trb;
 	union xhci_trb		*last_trb;
+	/* actual_length of the URB has already been set */
+	bool			urb_length_set;
 };
 
 /* xHCI command default timeout value */

commit 27082e2654dc148078b0abdfc3c8e5ccbde0ebfa
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Feb 24 18:27:02 2015 +0200

    xhci: Clear the host side toggle manually when endpoint is 'soft reset'
    
    Main benefit of this is to get xhci connected USB scanners to work.
    
    Some devices use a clear endpoint halt request as a 'soft reset' even if
    the endpoint is not halted. This will clear the toggle and sequence on the
    device side. xHCI however refuses to reset a non-halted endpoint, so instead
    we need to issue a configure endpoint command on xHCI to clear its host side
    toggle and sequence, and get it in sync with the device side.
    
    Tested-by: Mike Mammarella <mikem@crystalorb.net>
    Cc: <stable@vger.kernel.org> # v3.18
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 68956b13b8d1..3b97f0582155 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -864,6 +864,8 @@ struct xhci_virt_ep {
 #define EP_HAS_STREAMS		(1 << 4)
 /* Transitioning the endpoint to not using streams, don't enqueue URBs */
 #define EP_GETTING_NO_STREAMS	(1 << 5)
+#define EP_RECENTLY_HALTED	(1 << 6)
+#define EP_CONFIG_PENDING	(1 << 7)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
 	struct xhci_td		*stopped_td;

commit 6596a926b0b6c80b730a1dd2fa91908e0a539c37
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Feb 24 18:27:01 2015 +0200

    xhci: Allocate correct amount of scratchpad buffers
    
    Include the high order bit fields for Max scratchpad buffers when
    calculating how many scratchpad buffers are needed.
    
    I'm suprised this hasn't caused more issues, we never allocated more than
    32 buffers even if xhci needed more. Either we got lucky and xhci never
    really used past that area, or then we got enough zeroed dma memory anyway.
    
    Should be backported as far back as possible
    
    Reported-by: Tim Chen <tim.c.chen@linux.intel.com>
    Tested-by: Tim Chen <tim.c.chen@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 974514762a14..68956b13b8d1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -88,9 +88,10 @@ struct xhci_cap_regs {
 #define HCS_IST(p)		(((p) >> 0) & 0xf)
 /* bits 4:7, max number of Event Ring segments */
 #define HCS_ERST_MAX(p)		(((p) >> 4) & 0xf)
+/* bits 21:25 Hi 5 bits of Scratchpad buffers SW must allocate for the HW */
 /* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
-/* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */
-#define HCS_MAX_SCRATCHPAD(p)   (((p) >> 27) & 0x1f)
+/* bits 27:31 Lo 5 bits of Scratchpad buffers SW must allocate for the HW */
+#define HCS_MAX_SCRATCHPAD(p)   ((((p) >> 16) & 0x3e0) | (((p) >> 27) & 0x1f))
 
 /* HCSPARAMS3 - hcs_params3 - bitmasks */
 /* bits 0:7, Max U1 to U0 latency for the roothub ports */

commit 99705092a83f0202d2b64c1b754a831464c5ce90
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 16 17:54:01 2015 +0200

    xhci: Print hcc params, version and quirks on init
    
    To help debugging xhci problems.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e23f31d029a3..974514762a14 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1605,6 +1605,8 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 	dev_warn(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 #define xhci_warn_ratelimited(xhci, fmt, args...) \
 	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
+#define xhci_info(xhci, fmt, args...) \
+	dev_info(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
 /*
  * Registers should always be accessed with double word or quad word accesses.

commit 4daf9df51fbfb03b8c2bcb538cb467f7c7af1f11
Author: Lin Wang <lin.x.wang@intel.com>
Date:   Fri Jan 9 16:06:31 2015 +0200

    xhci: clean up work to remove unused parameters for functions in xhci-mem.c
    
    Some parameters are not used by functions in xhci-mem.c, just
    remove it.
    
    Changes compared to v1:
    - Rebase to the latest usb-next branch
    
    Signed-off-by: Lin Wang <lin.x.wang@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index eeea5c074493..e23f31d029a3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1712,8 +1712,7 @@ void xhci_free_stream_info(struct xhci_hcd *xhci,
 void xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,
 		struct xhci_ep_ctx *ep_ctx,
 		struct xhci_stream_info *stream_info);
-void xhci_setup_no_streams_ep_input_ctx(struct xhci_hcd *xhci,
-		struct xhci_ep_ctx *ep_ctx,
+void xhci_setup_no_streams_ep_input_ctx(struct xhci_ep_ctx *ep_ctx,
 		struct xhci_virt_ep *ep);
 void xhci_free_device_endpoint_resources(struct xhci_hcd *xhci,
 	struct xhci_virt_device *virt_dev, bool drop_control_ep);
@@ -1727,7 +1726,7 @@ struct xhci_ring *xhci_stream_id_to_ring(
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_in_ctx, bool allocate_completion,
 		gfp_t mem_flags);
-void xhci_urb_free_priv(struct xhci_hcd *xhci, struct urb_priv *urb_priv);
+void xhci_urb_free_priv(struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
 
@@ -1863,7 +1862,7 @@ int xhci_find_slot_id_by_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,
 void xhci_ring_device(struct xhci_hcd *xhci, int slot_id);
 
 /* xHCI contexts */
-struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
+struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_container_ctx *ctx);
 struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
 struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);
 

commit dc0b177cf8be1e7371cfb92cfbccac595bf8dac8
Author: Lin Wang <lin.x.wang@intel.com>
Date:   Fri Jan 9 16:06:28 2015 +0200

    xhci: remove unused parameter 'xhci' in function xhci_handshake().
    
    Parameter 'xhci' is no longer be used in function xhci_handshake(),
    just remove it.
    
    Signed-off-by: Lin Wang <lin.x.wang@intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cc7c5bb7cbcf..eeea5c074493 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1733,8 +1733,7 @@ void xhci_free_command(struct xhci_hcd *xhci,
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
-int xhci_handshake(struct xhci_hcd *xhci, void __iomem *ptr,
-		u32 mask, u32 done, int usec);
+int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, int usec);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);

commit e1fd1dc831fa0e1a4c090d0fc018ccce77569236
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Thu Nov 27 18:19:17 2014 +0200

    usb: xhci: fix comment for PORT_DEV_REMOVE
    
    According to xHCI specification, PORT_DEV_REMOVE(bit 30) in PORTSC
    true means "Device is non-removable".
    
    Reported-by: Juro Bystricky <jurobystricky@hotmail.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 053c9ead4f65..cc7c5bb7cbcf 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -358,7 +358,7 @@ struct xhci_op_regs {
 /* wake on over-current (enable) */
 #define PORT_WKOC_E	(1 << 27)
 /* bits 28:29 reserved */
-/* true: device is removable - for USB 3.0 roothub emulation */
+/* true: device is non-removable - for USB 3.0 roothub emulation */
 #define PORT_DEV_REMOVE	(1 << 30)
 /* Initiate a warm port reset - complete when PORT_WRC is '1' */
 #define PORT_WR		(1 << 31)

commit d97b4f8d690b9fc0e7dd4f4ff5aaea838254e350
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Nov 27 18:19:16 2014 +0200

    xhci: don't use the same variable for stopped and halted rings current TD
    
    Endpoints halted on errors, and endpoints stopped manually both used
    the same ep->stopped_td to store the halted or stopped td. this causes
    confusion and possible races.
    
    There is no longer a need to use the ep->stopped_td variable to store
    the halted TD. A halted endpoint is handled immediately and we can pass
    it to the handling function directly.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d745715a1e2f..053c9ead4f65 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1825,7 +1825,7 @@ void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int stream_id,
 		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
-		struct usb_device *udev, unsigned int ep_index);
+		unsigned int ep_index, struct xhci_td *td);
 void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);

commit a1377e5397ab321e21b793ec8cd2b6f12bd3c718
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Nov 18 11:27:14 2014 +0200

    usb: xhci: rework root port wake bits if controller isn't allowed to wakeup
    
    When system is being suspended, if host device is not allowed to do wakeup,
    xhci_suspend() needs to clear all root port wake on bits. Otherwise, some
    platforms may generate spurious wakeup, even if PCI PME# is disabled.
    
    The initial commit ff8cbf250b44 ("xhci: clear root port wake on bits"),
    which also got into stable, turned out to not work correctly and had to
    be reverted, and is now rewritten.
    
    Cc: stable <stable@vger.kernel.org> # v3.2+
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    [Mathias Nyman: reword commit message]
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index df76d642e719..d745715a1e2f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1746,7 +1746,7 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 void xhci_init_driver(struct hc_driver *drv, int (*setup_fn)(struct usb_hcd *));
 
 #ifdef	CONFIG_PM
-int xhci_suspend(struct xhci_hcd *xhci);
+int xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);
 int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
 #else
 #define	xhci_suspend	NULL

commit 29e409f0f7613f9fd2235e41f0fa33e48e94544e
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:29 2014 +0300

    xhci: Allow xHCI drivers to be built as separate modules
    
    Instead of building all of the xHCI code into a single module, separate
    it out into the core (xhci-hcd), PCI (xhci-pci, now selected by the new
    config option CONFIG_USB_XHCI_PCI), and platform (xhci-plat) drivers.
    Also update the PCI/platform drivers with module descriptions/licenses
    and have them register their respective drivers in their initcalls.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a099f382bee0..df76d642e719 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1731,25 +1731,6 @@ void xhci_urb_free_priv(struct xhci_hcd *xhci, struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
 
-#ifdef CONFIG_PCI
-/* xHCI PCI glue */
-int xhci_register_pci(void);
-void xhci_unregister_pci(void);
-#else
-static inline int xhci_register_pci(void) { return 0; }
-static inline void xhci_unregister_pci(void) {}
-#endif
-
-#if IS_ENABLED(CONFIG_USB_XHCI_PLATFORM)
-int xhci_register_plat(void);
-void xhci_unregister_plat(void);
-#else
-static inline int xhci_register_plat(void)
-{ return 0; }
-static inline void xhci_unregister_plat(void)
-{  }
-#endif
-
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
 int xhci_handshake(struct xhci_hcd *xhci, void __iomem *ptr,

commit e1cd972741f537828307640c9e55f7b595e9ba1e
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:27 2014 +0300

    xhci: Check for XHCI_COMP_MODE_QUIRK when disabling D3cold
    
    Instead of calling xhci_compliance_mode_recovery_timer_quirk_check() again
    in the PCI suspend path, just check for XHCI_COMP_MODE_QUIRK which will
    have been set based on xhci_compliance_mode_recovery_timer_quirk_check()
    in xhci_init().
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fdc394e30a62..a099f382bee0 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1887,7 +1887,4 @@ struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_hcd *xhci,
 struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
 struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);
 
-/* xHCI quirks */
-bool xhci_compliance_mode_recovery_timer_quirk_check(void);
-
 #endif /* __LINUX_XHCI_HCD_H */

commit 1885d9a33753b73cbbe3f8efde4a852ecca08674
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Fri Oct 3 11:35:26 2014 +0300

    xhci: Introduce xhci_init_driver()
    
    Since the struct hc_driver is mostly the same across the xhci-pci,
    xhci-plat, and the upcoming xhci-tegra driver, introduce the function
    xhci_init_driver() which will populate the hc_driver with the default
    xHCI operations.  The caller must supply a setup function which will
    be used as the hc_driver's reset callback.
    
    Note that xhci-plat also overrides the default ->start() callback so
    that it can do rcar-specific initialization.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 276fd8efd171..fdc394e30a62 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1762,6 +1762,7 @@ int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
+void xhci_init_driver(struct hc_driver *drv, int (*setup_fn)(struct usb_hcd *));
 
 #ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci);

commit cffb9be80f8a6d51d025780864c781ba83541720
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Aug 20 16:41:51 2014 +0300

    xhci: Log extra info on "ERROR Transfer event TRB DMA ptr not part of current TD"
    
    Lately (with the use of uas / bulk-streams) we have been seeing several
    cases where this error triggers (which should never happen).
    
    Add some extra logging to make debugging these errors easier.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f4d12f6fcfe8..276fd8efd171 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1804,9 +1804,9 @@ void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
-struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
-		union xhci_trb *start_trb, union xhci_trb *end_trb,
-		dma_addr_t suspect_dma);
+struct xhci_segment *trb_in_td(struct xhci_hcd *xhci,
+		struct xhci_segment *start_seg, union xhci_trb *start_trb,
+		union xhci_trb *end_trb, dma_addr_t suspect_dma, bool debug);
 int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, struct xhci_command *cmd,

commit 1e3452e3f08c5af7fb4b08551aaa96b6627c7416
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Aug 20 16:41:52 2014 +0300

    xhci: Move allocating of command for new_dequeue_state to queue_set_tr_deq()
    
    There are multiple reasons for this:
    
    1) This fixes a missing check for xhci_alloc_command failing in
       xhci_handle_cmd_stop_ep()
    2) This adds a warning when we cannot set the new dequeue state because of
       xhci_alloc_command failing
    3) It puts the allocation of the command after the sanity checks in
       queue_set_tr_deq(), avoiding leaking the command if those fail
    4) Since queue_set_tr_deq now owns the command it can free it if queue_command
       fails
    5) It reduces code duplication
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dace5152e179..f4d12f6fcfe8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1839,7 +1839,6 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int stream_id, struct xhci_td *cur_td,
 		struct xhci_dequeue_state *state);
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
-		struct xhci_command *cmd,
 		unsigned int slot_id, unsigned int ep_index,
 		unsigned int stream_id,
 		struct xhci_dequeue_state *deq_state);

commit 8f873c1ff4ca034626093d03b254e7cb8bb782dd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jul 25 22:01:18 2014 +0200

    xhci: Blacklist using streams on the Etron EJ168 controller
    
    Streams on the EJ168 do not work as they should. I've spend 2 days trying
    to get them to work, but without success.
    
    The first problem is that when ever you ring the stream-ring doorbell, the
    controller starts executing trbs at the beginning of the first ring segment,
    event if it ended somewhere else previously. This can be worked around by
    allowing enqueing only one td (not a problem with how streams are typically
    used) and then resetting our copies of the enqueueing en dequeueing pointers
    on a td completion to match what the controller seems to be doing.
    
    This way things seem to start working with uas and instead of being able
    to complete only the very first scsi command, the scsi core can probe the disk.
    
    But then things break later on when td-s get enqueued with more then one
    trb. The controller does seem to increase its dequeue pointer while executing
    a stream-ring (data transfer events I inserted for debugging do trigger).
    However execution seems to stop at the final normal trb of a multi trb td,
    even if there is a data transfer event inserted after the final trb.
    
    The first problem alone is a serious deviation from the spec, and esp.
    dealing with cancellation would have been very tricky if not outright
    impossible, but the second problem simply is a deal breaker altogether,
    so this patch simply disables streams.
    
    Note this will cause the usb-storage + uas driver pair to automatically switch
    to using usb-storage instead of uas on these devices, essentially reverting
    to the 3.14 and earlier behavior when uas was marked CONFIG_BROKEN.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1121288
    https://bugzilla.kernel.org/show_bug.cgi?id=80101
    
    Cc: stable@vger.kernel.org # 3.15
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9ffecd56600d..dace5152e179 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1558,6 +1558,8 @@ struct xhci_hcd {
 #define XHCI_PLAT		(1 << 16)
 #define XHCI_SLOW_SUSPEND	(1 << 17)
 #define XHCI_SPURIOUS_WAKEUP	(1 << 18)
+/* For controllers with a broken beyond repair streams implementation */
+#define XHCI_BROKEN_STREAMS	(1 << 19)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 4718c177405112386a977fd9f1cba5fd6aa82315
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu May 15 12:17:32 2014 +0200

    usb: host: xhci-plat: add clock support
    
    Some platforms (such as the Armada 38x ones) can gate the clock of
    their USB controller. This patch adds the support for one clock in
    xhci-plat, by enabling it during probe and disabling it on remove.
    
    To achieve this, it adds a 'struct clk *' member in xhci_hcd. While
    only used for now in xhci-plat, it might be used by other drivers in
    the future. Moreover, the xhci_hcd structure already holds other
    members such as msix_count and msix_entries, which are MSI-X specific,
    and therefore only used by xhci-pci.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2774526449a6..9ffecd56600d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1472,6 +1472,8 @@ struct xhci_hcd {
 	/* msi-x vectors */
 	int		msix_count;
 	struct msix_entry	*msix_entries;
+	/* optional clock */
+	struct clk		*clk;
 	/* data structures */
 	struct xhci_device_context_array *dcbaa;
 	struct xhci_ring	*cmd_ring;

commit c311e391a7efd101250c0e123286709b7e736249
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 8 19:26:03 2014 +0300

    xhci: rework command timeout and cancellation,
    
    Use one timer to control command timeout.
    
    start/kick the timer every time a command is completed and a
    new command is waiting, or a new command is added to a empty list.
    
    If the timer runs out, then tag the current command as "aborted", and
    start the xhci command abortion process.
    
    Previously each function that submitted a command had its own timer.
    If that command timed out, a new command structure for the
    command was created and it was put on a cancel_cmd_list list,
    then a pci write to abort the command ring was issued.
    
    when the ring was aborted, it checked if the current command
    was the one to be canceled, later when the ring was stopped the
    driver got ownership of the TRBs in the command ring,
    compared then to the TRBs in the cancel_cmd_list,
    and turned them into No-ops.
    
    Now, instead, at timeout we tag the status of the command in the
    command queue to be aborted, and start the ring abortion.
    Ring abortion stops the command ring and gives control of the
    commands to us.
    All the aborted commands are now turned into No-ops.
    
    If the ring is already stopped when the command times outs its not possible
    to start the ring abortion, in this case the command is turnd to No-op
    right away.
    
    All these changes allows us to remove the entire cancel_cmd_list code.
    
    The functions waiting for a command to finish no longer have their own timeouts.
    They will wait either until the command completes normally,
    or until the whole command abortion is done.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fde57b09a9bd..2774526449a6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1295,7 +1295,6 @@ struct xhci_td {
 
 /* command descriptor */
 struct xhci_cd {
-	struct list_head	cancel_cmd_list;
 	struct xhci_command	*command;
 	union xhci_trb		*cmd_trb;
 };
@@ -1480,9 +1479,10 @@ struct xhci_hcd {
 #define CMD_RING_STATE_RUNNING         (1 << 0)
 #define CMD_RING_STATE_ABORTED         (1 << 1)
 #define CMD_RING_STATE_STOPPED         (1 << 2)
-	struct list_head        cancel_cmd_list;
 	struct list_head        cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
+	struct timer_list	cmd_timer;
+	struct xhci_command	*current_cmd;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
 	/* Scratchpad */
@@ -1845,8 +1845,8 @@ void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
-int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
-		union xhci_trb *cmd_trb);
+void xhci_handle_command_timeout(unsigned long data);
+
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 void xhci_cleanup_command_queue(struct xhci_hcd *xhci);

commit 9ea1833e4c210ac5580f63495be15502f275c578
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 8 19:26:02 2014 +0300

    xhci: Use completion and status in global command queue
    
    Remove the per-device command list and handle_cmd_in_cmd_wait_list()
    and use the completion and status variables found in the
    command structure in the global command list.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d33cd3750a15..fde57b09a9bd 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -937,9 +937,6 @@ struct xhci_virt_device {
 #define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
 	struct completion		cmd_completion;
-	/* Status of the last command issued for this device */
-	u32				cmd_status;
-	struct list_head		cmd_list;
 	u8				fake_port;
 	u8				real_port;
 	struct xhci_interval_bw_table	*bw_table;

commit c9aa1a2de4cbf7d0db6012fbf86b6ee0c3719470
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 8 19:26:01 2014 +0300

    xhci: Add a global command queue
    
    Create a list to store command structures, add a structure to it every time
    a command is submitted, and remove it from the list once we get a
    command completion event matching the command.
    
    Callers that wait for completion will free their command structures themselves.
    The other command structures are freed in the command completion event handler.
    
    Also add a check that prevents queuing commands if host is dying
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c0fdb4984b0d..d33cd3750a15 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1484,6 +1484,7 @@ struct xhci_hcd {
 #define CMD_RING_STATE_ABORTED         (1 << 1)
 #define CMD_RING_STATE_STOPPED         (1 << 2)
 	struct list_head        cancel_cmd_list;
+	struct list_head        cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
@@ -1851,6 +1852,7 @@ int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
 		union xhci_trb *cmd_trb);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
+void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
 
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,

commit ddba5cd0aeff5bbed92ebdf4b1223300b0541e78
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 8 19:26:00 2014 +0300

    xhci: Use command structures when queuing commands on the command ring
    
    To create a global command queue we require that each command put on the
    command ring is submitted with a command structure.
    
    Functions that queue commands and wait for completion need to allocate a command
    before submitting it, and free it once completed. The following command queuing
    functions need to be modified.
    
    xhci_configure_endpoint()
    xhci_address_device()
    xhci_queue_slot_control()
    xhci_queue_stop_endpoint()
    xhci_queue_new_dequeue_state()
    xhci_queue_reset_ep()
    xhci_configure_endpoint()
    
    xhci_configure_endpoint() could already be called with a command structure,
    and only xhci_check_maxpacket and xhci_check_bandwidth did not do so. These
    are changed and a command structure is now required. This change also simplifies
    the configure endpoint command completion handling and the "goto bandwidth_change"
    handling code can be removed.
    
    In some cases the command queuing function is called in interrupt context.
    These commands needs to be allocated atomically, and they can't wait for
    completion. These commands will in this patch be freed directly after queuing,
    but freeing will be moved to the command completion event handler in a later
    patch once we get the global command queue up.(Just so that we won't leak
    memory in the middle of the patch set)
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cc67c7686706..c0fdb4984b0d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1807,13 +1807,14 @@ struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
 		dma_addr_t suspect_dma);
 int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
-int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
-int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id, enum xhci_setup_dev);
-int xhci_queue_vendor_command(struct xhci_hcd *xhci,
+int xhci_queue_slot_control(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		u32 trb_type, u32 slot_id);
+int xhci_queue_address_device(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		dma_addr_t in_ctx_ptr, u32 slot_id, enum xhci_setup_dev);
+int xhci_queue_vendor_command(struct xhci_hcd *xhci, struct xhci_command *cmd,
 		u32 field1, u32 field2, u32 field3, u32 field4);
-int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
-		unsigned int ep_index, int suspend);
+int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		int slot_id, unsigned int ep_index, int suspend);
 int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
@@ -1822,18 +1823,21 @@ int xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_isoc_tx_prepare(struct xhci_hcd *xhci, gfp_t mem_flags,
 		struct urb *urb, int slot_id, unsigned int ep_index);
-int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id, bool command_must_succeed);
-int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id, bool command_must_succeed);
-int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
-		unsigned int ep_index);
-int xhci_queue_reset_device(struct xhci_hcd *xhci, u32 slot_id);
+int xhci_queue_configure_endpoint(struct xhci_hcd *xhci,
+		struct xhci_command *cmd, dma_addr_t in_ctx_ptr, u32 slot_id,
+		bool command_must_succeed);
+int xhci_queue_evaluate_context(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		dma_addr_t in_ctx_ptr, u32 slot_id, bool command_must_succeed);
+int xhci_queue_reset_ep(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		int slot_id, unsigned int ep_index);
+int xhci_queue_reset_device(struct xhci_hcd *xhci, struct xhci_command *cmd,
+		u32 slot_id);
 void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		unsigned int stream_id, struct xhci_td *cur_td,
 		struct xhci_dequeue_state *state);
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
+		struct xhci_command *cmd,
 		unsigned int slot_id, unsigned int ep_index,
 		unsigned int stream_id,
 		struct xhci_dequeue_state *deq_state);
@@ -1847,7 +1851,6 @@ int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
 		union xhci_trb *cmd_trb);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
-union xhci_trb *xhci_find_next_enqueue(struct xhci_ring *ring);
 
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,

commit 961b3d0a990f8b1214f5425c4acbebbd0b777e36
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Thu May 8 19:25:57 2014 +0300

    usb: xhci: Use IS_ENABLED() macro
    
    Using the IS_ENABLED() macro can make the code shorter and easier to read.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4746816aed3e..cc67c7686706 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1738,8 +1738,7 @@ static inline int xhci_register_pci(void) { return 0; }
 static inline void xhci_unregister_pci(void) {}
 #endif
 
-#if defined(CONFIG_USB_XHCI_PLATFORM) \
-	|| defined(CONFIG_USB_XHCI_PLATFORM_MODULE)
+#if IS_ENABLED(CONFIG_USB_XHCI_PLATFORM)
 int xhci_register_plat(void);
 void xhci_unregister_plat(void);
 #else

commit 1f81b6d22a5980955b01e08cf27fb745dc9b686f
Author: Julius Werner <jwerner@chromium.org>
Date:   Fri Apr 25 19:20:13 2014 +0300

    usb: xhci: Prefer endpoint context dequeue pointer over stopped_trb
    
    We have observed a rare cycle state desync bug after Set TR Dequeue
    Pointer commands on Intel LynxPoint xHCs (resulting in an endpoint that
    doesn't fetch new TRBs and thus an unresponsive USB device). It always
    triggers when a previous Set TR Dequeue Pointer command has set the
    pointer to the final Link TRB of a segment, and then another URB gets
    enqueued and cancelled again before it can be completed. Further
    investigation showed that the xHC had returned the Link TRB in the TRB
    Pointer field of the Transfer Event (CC == Stopped -- Length Invalid),
    but when xhci_find_new_dequeue_state() later accesses the Endpoint
    Context's TR Dequeue Pointer field it is set to the first TRB of the
    next segment.
    
    The driver expects those two values to be the same in this situation,
    and uses the cycle state of the latter together with the address of the
    former. This should be fine according to the XHCI specification, since
    the endpoint ring should be stopped when returning the Transfer Event
    and thus should not advance over the Link TRB before it gets restarted.
    However, real-world XHCI implementations apparently don't really care
    that much about these details, so the driver should follow a more
    defensive approach to try to work around HC spec violations.
    
    This patch removes the stopped_trb variable that had been used to store
    the TRB Pointer from the last Transfer Event of a stopped TRB. Instead,
    xhci_find_new_dequeue_state() now relies only on the Endpoint Context,
    requiring a small amount of additional processing to find the virtual
    address corresponding to the TR Dequeue Pointer. Some other parts of the
    function were slightly rearranged to better fit into this model.
    
    This patch should be backported to kernels as old as 2.6.31 that contain
    the commit ae636747146ea97efa18e04576acd3416e2514f5 "USB: xhci: URB
    cancellation support."
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d280e9213d08..4746816aed3e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -865,8 +865,6 @@ struct xhci_virt_ep {
 #define EP_GETTING_NO_STREAMS	(1 << 5)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
-	/* The TRB that was last reported in a stopped endpoint ring */
-	union xhci_trb		*stopped_trb;
 	struct xhci_td		*stopped_td;
 	unsigned int		stopped_stream;
 	/* Watchdog timer for stop endpoint command to cancel URBs */

commit 9aad95e292f58d00aa0f2e30c7f7dafd7fc7491c
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 4 00:29:49 2013 +0200

    xhci: For streams the dequeue ptr must be read from the stream ctx
    
    This fixes TR dequeue validation failing on Intel XHCI controllers with the
    following warning:
    
    Mismatch between completed Set TR Deq Ptr command & xHCI internal state.
    
    Interestingly enough reading the deq ptr from the ep ctx after a
    TR Deq Ptr command does work on a Nec XHCI controller, it seems the Nec
    writes the ptr to both the ep and stream contexts when streams are used.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2c77bf7ab9e5..d280e9213d08 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -703,6 +703,7 @@ struct xhci_ep_ctx {
 
 /* deq bitmasks */
 #define EP_CTX_CYCLE_MASK		(1 << 0)
+#define SCTX_DEQ_MASK			(~0xfL)
 
 
 /**

commit 95241dbdf8281ece1355b8673b882d6a182f3c7d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 4 00:29:48 2013 +0200

    xhci: Set SCT field for Set TR dequeue on streams
    
    Nec XHCI controllers don't seem to care, but without this Intel XHCI
    controllers reject Set TR dequeue commands with a COMP_TRB_ERR, leading
    to the following warning:
    
    WARN Set TR Deq Ptr cmd invalid because of stream ID configuration
    
    And very shortly after this the system completely freezes.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a6aa98f19a1f..2c77bf7ab9e5 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1118,9 +1118,10 @@ enum xhci_setup_dev {
 #define TRB_TO_SUSPEND_PORT(p)		(((p) & (1 << 23)) >> 23)
 #define LAST_EP_INDEX			30
 
-/* Set TR Dequeue Pointer command TRB fields */
+/* Set TR Dequeue Pointer command TRB fields, 6.4.3.9 */
 #define TRB_TO_STREAM_ID(p)		((((p) & (0xffff << 16)) >> 16))
 #define STREAM_ID_FOR_TRB(p)		((((p)) & 0xffff) << 16)
+#define SCT_FOR_TRB(p)			(((p) << 1) & 0x7)
 
 
 /* Port Status Change Event TRB fields */

commit 153413032c6ea624fccc6732aba27a57688a7f91
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Oct 4 00:29:44 2013 +0200

    xhci: fix usb3 streams
    
    xhci maintains a radix tree for each stream endpoint because it must
    be able to map a trb address to the stream ring.  Each ring segment
    must be added to the ring for this to work.  Currently xhci sticks
    only the first segment of each stream ring into the radix tree.
    
    Result is that things work initially, but as soon as the first segment
    is full xhci can't map the trb address from the completion event to the
    stream ring any more -> BOOM.  You'll find this message in the logs:
    
      ERROR Transfer event for disabled endpoint or incorrect stream ring
    
    This patch adds a helper function to update the radix tree, and a
    function to remove ring segments from the tree.  Both functions loop
    over the segment list and handles all segments instead of just the
    first.
    
    [Note: Sarah changed this patch to add radix_tree_maybe_preload() and
    radix_tree_preload_end() calls around the radix tree insert, since we
    can now insert entries in interrupt context.  There are now two helper
    functions to make the code cleaner, and those functions are moved to
    make them static.]
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 58ed9d088e63..a6aa98f19a1f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1341,6 +1341,7 @@ struct xhci_ring {
 	unsigned int		num_trbs_free_temp;
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
+	struct radix_tree_root	*trb_address_map;
 };
 
 struct xhci_erst_entry {

commit 1386ff75797a187df324062fb4e929152392da88
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Jan 31 11:45:02 2014 -0800

    Revert "xhci: Set scatter-gather limit to avoid failed block writes."
    
    This reverts commit f2d9b991c549f159dc9ae81f77d8206c790cbfee.
    
    We are ripping out commit 35773dac5f862cb1c82ea151eba3e2f6de51ec3e "usb:
    xhci: Link TRB must not occur within a USB payload burst" because it's a
    hack that caused regressions in the usb-storage and userspace USB
    drivers that use usbfs and libusb.  This commit attempted to fix the
    issues with that patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org #3.12

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9154fd6cf24c..58ed9d088e63 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1268,7 +1268,7 @@ union xhci_trb {
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
-#define TRBS_PER_SEGMENT	256
+#define TRBS_PER_SEGMENT	64
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)

commit f7b2e4032d52deff480e0c303fbd9180276f8dfc
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jan 30 13:27:49 2014 -0800

    Revert "xhci: replace xhci_read_64() with readq()"
    
    This reverts commit e8b373326d8efcaf9ec1da8b618556c89bd5ffc4.  Many xHCI
    host controllers can only handle 32-bit addresses, and writing 64-bits
    at a time causes them to fail.  Reading 64-bits at a time may also cause
    them to return 0xffffffff, so revert this commit as well.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 60def15d129c..9154fd6cf24c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -28,8 +28,6 @@
 #include <linux/kernel.h>
 #include <linux/usb/hcd.h>
 
-#include <asm-generic/io-64-nonatomic-lo-hi.h>
-
 /* Code sharing between pci-quirks and xhci hcd */
 #include	"xhci-ext-caps.h"
 #include "pci-quirks.h"
@@ -1614,6 +1612,14 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
  * xHCI implementations that do not support 64-bit address pointers will ignore
  * the high dword, and write order is irrelevant.
  */
+static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
+		__le64 __iomem *regs)
+{
+	__u32 __iomem *ptr = (__u32 __iomem *) regs;
+	u64 val_lo = readl(ptr);
+	u64 val_hi = readl(ptr + 1);
+	return val_lo + (val_hi << 32);
+}
 static inline void xhci_write_64(struct xhci_hcd *xhci,
 				 const u64 val, __le64 __iomem *regs)
 {

commit 477632dff5c7deaa165701f441e9a4bd33e22b18
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Jan 29 14:02:00 2014 -0800

    Revert "xhci: replace xhci_write_64() with writeq()"
    
    This reverts commit 7dd09a1af2c7150269350aaa567a11b06e831003.
    
    Many xHCI host controllers can only handle 32-bit addresses, and writing
    64-bits at a time causes them to fail.  Rafa reports that USB devices
    simply do not enumerate, and reverting this patch helps.  Branimir
    reports that his host controller doesn't respond to an Enable Slot
    command and dies:
    
    [   75.576160] xhci_hcd 0000:03:00.0: Timeout while waiting for a slot
    [   88.991634] xhci_hcd 0000:03:00.0: Stopped the command ring failed, maybe the host is dead
    [   88.991748] xhci_hcd 0000:03:00.0: Abort command ring failed
    [   88.991845] xhci_hcd 0000:03:00.0: HC died; cleaning up
    [   93.985489] xhci_hcd 0000:03:00.0: Timeout while waiting for a slot
    [   93.985494] xhci_hcd 0000:03:00.0: Abort the command ring, but the xHCI is dead.
    [   98.982586] xhci_hcd 0000:03:00.0: Timeout while waiting for a slot
    [   98.982591] xhci_hcd 0000:03:00.0: Abort the command ring, but the xHCI is dead.
    [  103.979696] xhci_hcd 0000:03:00.0: Timeout while waiting for a slot
    [  103.979702] xhci_hcd 0000:03:00.0: Abort the command ring, but the xHCI is dead
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@intel.com>
    Reported-by: Rafa Miecki <zajec5@gmail.com>
    Reported-by: Branimir Maksimovic <branimir.maksimovic@gmail.com>
    Cc: Xenia Ragiadakou <burzalodowa@gmail.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f8416639bf31..60def15d129c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -28,15 +28,6 @@
 #include <linux/kernel.h>
 #include <linux/usb/hcd.h>
 
-/*
- * Registers should always be accessed with double word or quad word accesses.
- *
- * Some xHCI implementations may support 64-bit address pointers.  Registers
- * with 64-bit address pointers should be written to with dword accesses by
- * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
- * xHCI implementations that do not support 64-bit address pointers will ignore
- * the high dword, and write order is irrelevant.
- */
 #include <asm-generic/io-64-nonatomic-lo-hi.h>
 
 /* Code sharing between pci-quirks and xhci hcd */
@@ -1614,6 +1605,26 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 #define xhci_warn_ratelimited(xhci, fmt, args...) \
 	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
+/*
+ * Registers should always be accessed with double word or quad word accesses.
+ *
+ * Some xHCI implementations may support 64-bit address pointers.  Registers
+ * with 64-bit address pointers should be written to with dword accesses by
+ * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
+ * xHCI implementations that do not support 64-bit address pointers will ignore
+ * the high dword, and write order is irrelevant.
+ */
+static inline void xhci_write_64(struct xhci_hcd *xhci,
+				 const u64 val, __le64 __iomem *regs)
+{
+	__u32 __iomem *ptr = (__u32 __iomem *) regs;
+	u32 val_lo = lower_32_bits(val);
+	u32 val_hi = upper_32_bits(val);
+
+	writel(val_lo, ptr);
+	writel(val_hi, ptr + 1);
+}
+
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 {
 	return xhci->quirks & XHCI_LINK_TRB_QUIRK;

commit f2d9b991c549f159dc9ae81f77d8206c790cbfee
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jan 6 13:07:03 2014 -0800

    xhci: Set scatter-gather limit to avoid failed block writes.
    
    Commit 35773dac5f862cb1c82ea151eba3e2f6de51ec3e "usb: xhci: Link TRB
    must not occur within a USB payload burst" attempted to fix an issue
    found with USB ethernet adapters, and inadvertently broke USB storage
    devices.  The patch attempts to ensure that transfers never span a
    segment, and rejects transfers that have more than 63 entries (or
    possibly less, if some entries cross 64KB boundaries).
    
    usb-storage limits the maximum transfer size to 120K, and we had assumed
    the block layer would pass a scatter-gather list of 4K entries,
    resulting in no more than 31 sglist entries:
    
    http://marc.info/?l=linux-usb&m=138498190419312&w=2
    
    That assumption was wrong, since we've seen the driver reject a write
    that was 218 sectors long (of probably 512 bytes each):
    
    Jan  1 07:04:49 jidanni5 kernel: [  559.624704] xhci_hcd 0000:00:14.0: Too many fragments 79, max 63
    ...
    Jan  1 07:04:58 jidanni5 kernel: [  568.622583] Write(10): 2a 00 00 06 85 0e 00 00 da 00
    
    Limit the number of scatter-gather entries to half a ring segment.  That
    should be margin enough in case some entries cross 64KB boundaries.
    Increase the number of TRBs per segment from 64 to 256, which should
    result in ring segments fitting on a 4K page.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: jidanni@jidanni.org
    References: http://bugs.debian.org/733907
    Fixes: 35773dac5f86 ('usb: xhci: Link TRB must not occur within a USB payload burst')
    Cc: stable <stable@vger.kernel.org> # 3.12

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 24344aab2107..f8416639bf31 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1279,7 +1279,7 @@ union xhci_trb {
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
-#define TRBS_PER_SEGMENT	64
+#define TRBS_PER_SEGMENT	256
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)

commit 48fc7dbd52c0559647291f33a10ccdc6cdbe4c72
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Dec 5 17:07:27 2013 -0800

    usb: xhci: change enumeration scheme to 'new scheme' by default
    
    Change the default enumeration scheme for xhci attached non-SuperSpeed
    devices from:
    
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(8)
       GetDescriptor(18)
    
    ...to:
    
       Reset
       [xhci address-device BSR = 1]
       GetDescriptor(64)
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(18)
    
    ...as some devices misbehave when encountering a SetAddress command
    prior to GetDescriptor.  There are known legacy devices that require
    this scheme, but testing has found at least one USB3 device that fails
    enumeration when presented with this ordering.  For now, follow the ehci
    case and enable 'new scheme' by default for non-SuperSpeed devices.
    
    To support this enumeration scheme on xhci the AddressDevice operation
    needs to be performed twice.  The first instance of the command enables
    the HC's device and slot context info for the device, but omits sending
    the device a SetAddress command (BSR == block set address request).
    Then, after GetDescriptor completes, follow up with the full
    AddressDevice+SetAddress operation.
    
    As mentioned before, this ordering of events with USB3 devices causes an
    extra state transition to be exposed to xhci.  Previously USB3 devices
    would transition directly from 'enabled' to 'addressed' and never need
    to underrun responses to 'get descriptor'. We do see the 64-byte
    descriptor fetch the correct data, but the following 18-byte descriptor
    read after the reset gets:
    
    bLength            = 0
    bDescriptorType    = 0
    bcdUSB             = 0
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    instead of:
    
    bLength            = 12
    bDescriptorType    = 1
    bcdUSB             = 300
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    which results in the discovery process looping until falling back to
    'old scheme' enumeration.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: David Moore <david.moore@gmail.com>
    Suggested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7807f621a713..24344aab2107 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1108,6 +1108,14 @@ struct xhci_event_cmd {
 };
 
 /* flags bitmasks */
+
+/* Address device - disable SetAddress */
+#define TRB_BSR		(1<<9)
+enum xhci_setup_dev {
+	SETUP_CONTEXT_ONLY,
+	SETUP_CONTEXT_ADDRESS,
+};
+
 /* bits 16:23 are the virtual function ID */
 /* bits 24:31 are the slot ID */
 #define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
@@ -1760,6 +1768,7 @@ int xhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		gfp_t mem_flags);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_enable_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_set_usb2_hardware_lpm(struct usb_hcd *hcd,
 				struct usb_device *udev, int enable);
@@ -1783,7 +1792,7 @@ int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id);
+		u32 slot_id, enum xhci_setup_dev);
 int xhci_queue_vendor_command(struct xhci_hcd *xhci,
 		u32 field1, u32 field2, u32 field3, u32 field4);
 int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,

commit 7dd09a1af2c7150269350aaa567a11b06e831003
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Fri Nov 15 05:34:09 2013 +0200

    xhci: replace xhci_write_64() with writeq()
    
    Function xhci_write_64() is used to write 64bit xHC registers residing in MMIO.
    On 32bit systems, xHC registers need to be written with 32bit accesses by
    writing first the lower 32bits and then the higher 32bits. The header file
    asm-generic/io-64-nonatomic-lo-hi.h ensures that on 32bit systems writeq() will
    will write 64bit registers in 32bit chunks with low-high order.
    
    Replace all calls to xhci_write_64() with calls to writeq().
    
    This is done to reduce code duplication since 64bit low-high write logic
    is already implemented and to take advantage of inherent "atomic" 64bit
    write operations on 64bit systems.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5579b44379a4..7807f621a713 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -28,6 +28,15 @@
 #include <linux/kernel.h>
 #include <linux/usb/hcd.h>
 
+/*
+ * Registers should always be accessed with double word or quad word accesses.
+ *
+ * Some xHCI implementations may support 64-bit address pointers.  Registers
+ * with 64-bit address pointers should be written to with dword accesses by
+ * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
+ * xHCI implementations that do not support 64-bit address pointers will ignore
+ * the high dword, and write order is irrelevant.
+ */
 #include <asm-generic/io-64-nonatomic-lo-hi.h>
 
 /* Code sharing between pci-quirks and xhci hcd */
@@ -1597,26 +1606,6 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 #define xhci_warn_ratelimited(xhci, fmt, args...) \
 	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
-/*
- * Registers should always be accessed with double word or quad word accesses.
- *
- * Some xHCI implementations may support 64-bit address pointers.  Registers
- * with 64-bit address pointers should be written to with dword accesses by
- * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
- * xHCI implementations that do not support 64-bit address pointers will ignore
- * the high dword, and write order is irrelevant.
- */
-static inline void xhci_write_64(struct xhci_hcd *xhci,
-				 const u64 val, __le64 __iomem *regs)
-{
-	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u32 val_lo = lower_32_bits(val);
-	u32 val_hi = upper_32_bits(val);
-
-	writel(val_lo, ptr);
-	writel(val_hi, ptr + 1);
-}
-
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 {
 	return xhci->quirks & XHCI_LINK_TRB_QUIRK;

commit e8b373326d8efcaf9ec1da8b618556c89bd5ffc4
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Fri Nov 15 05:34:08 2013 +0200

    xhci: replace xhci_read_64() with readq()
    
    Function xhci_read_64() is used to read 64bit xHC registers residing in MMIO.
    On 32bit systems, xHC registers need to be read with 32bit accesses by
    reading first the lower 32bits and then the higher 32bits.
    
    Replace all calls to xhci_read_64() with calls to readq() and include
    asm-generic/io-64-nonatomic-lo-hi.h header file, so that if the system
    is not 64bit, readq() will read registers in 32bit chunks with low-high order.
    
    This is done to reduce code duplication since 64bit low-high read logic
    is already implemented and to take advantage of inherent "atomic" 64bit
    read operations on 64bit systems.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 402d8743d245..5579b44379a4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -28,6 +28,8 @@
 #include <linux/kernel.h>
 #include <linux/usb/hcd.h>
 
+#include <asm-generic/io-64-nonatomic-lo-hi.h>
+
 /* Code sharing between pci-quirks and xhci hcd */
 #include	"xhci-ext-caps.h"
 #include "pci-quirks.h"
@@ -1604,14 +1606,6 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
  * xHCI implementations that do not support 64-bit address pointers will ignore
  * the high dword, and write order is irrelevant.
  */
-static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
-		__le64 __iomem *regs)
-{
-	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u64 val_lo = readl(ptr);
-	u64 val_hi = readl(ptr + 1);
-	return val_lo + (val_hi << 32);
-}
 static inline void xhci_write_64(struct xhci_hcd *xhci,
 				 const u64 val, __le64 __iomem *regs)
 {

commit 204b7793f2a9935e9a08524d0b4bb51b990d518e
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Fri Nov 15 05:34:07 2013 +0200

    xhci: replace xhci_writel() with writel()
    
    Function xhci_writel() is used to write a 32bit value in xHC registers residing
    in MMIO address space. It takes as first argument a pointer to the xhci_hcd
    although it does not use it. xhci_writel() internally simply calls writel().
    This creates an illusion that xhci_writel() is an xhci specific function that
    has to be called in a context where a pointer to xhci_hcd is available.
    
    Remove xhci_writel() wrapper function and replace its calls with calls to
    writel() to make the code more straight-forward.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c727f1edb37f..402d8743d245 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1595,14 +1595,6 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 #define xhci_warn_ratelimited(xhci, fmt, args...) \
 	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
-/* TODO: copied from ehci.h - can be refactored? */
-/* xHCI spec says all registers are little endian */
-static inline void xhci_writel(struct xhci_hcd *xhci,
-		const unsigned int val, __le32 __iomem *regs)
-{
-	writel(val, regs);
-}
-
 /*
  * Registers should always be accessed with double word or quad word accesses.
  *

commit b0ba9720846c980d053b1ffcd766fddfbef95d4c
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Fri Nov 15 05:34:06 2013 +0200

    xhci: replace xhci_readl() with readl()
    
    Function xhci_readl() is used to read 32bit xHC registers residing in MMIO
    address space. It takes as first argument a pointer to the xhci_hcd although
    it does not use it. xhci_readl() internally simply calls readl(). This creates
    an illusion that xhci_readl() is an xhci specific function that has to be
    called in a context where a pointer to xhci_hcd is available.
    
    Remove the unnecessary xhci_readl() wrapper function and replace its calls to
    with calls to readl() to make the code more straightforward.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a33e8b5bf7a2..c727f1edb37f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1597,11 +1597,6 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 
 /* TODO: copied from ehci.h - can be refactored? */
 /* xHCI spec says all registers are little endian */
-static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
-		__le32 __iomem *regs)
-{
-	return readl(regs);
-}
 static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __le32 __iomem *regs)
 {

commit 63a67a72d63dd077c2313cf19eb29d8e4bfa6963
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Mon Aug 26 23:29:47 2013 +0300

    xhci: fix SCT_FOR_CTX(p) macro
    
    SCT_FOR_CTX(p) is defined as (((p) << 1) & 0x7) in which case if we want
    to set the stream context type to SCT_SSA_256 i.e 0x7 (although secondary
    stream arrays are not yet supported) using this macro definition we will
    get actually 0x6 which is not what we want.
    
    This patch fixes the above issue by defining the SCT_FOR_CTX(p) macro as
    (((p) & 0x7) << 1)
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 03c74b7965f8..a33e8b5bf7a2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -752,7 +752,7 @@ struct xhci_stream_ctx {
 };
 
 /* Stream Context Types (section 6.4.1) - bits 3:1 of stream ctx deq ptr */
-#define	SCT_FOR_CTX(p)		(((p) << 1) & 0x7)
+#define	SCT_FOR_CTX(p)		(((p) & 0x7) << 1)
 /* Secondary stream array type, dequeue pointer is to a transfer ring */
 #define	SCT_SEC_TR		0
 /* Primary stream array type, dequeue pointer is to a transfer ring */

commit 9afcdb10ade4c3f5bedb1c7de9dd37f7061819eb
Merge: 5584cfbafc1a a2cdc3432c36
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Oct 19 14:03:44 2013 -0700

    Merge tag 'for-usb-next-2013-10-17' of git://git.kernel.org/pub/scm/linux/kernel/git/sarah/xhci into usb-next
    
    Sarah writes:
    
    xhci: Final patches for 3.13
    
    Hi Greg,
    
    Here's my pull request for usb-next and 3.13.  My xHCI tree is closed
    after this point, since I won't be able to run my full tests while I'm in
    Scotland.  After Kernel Summit, I'll be on vacation with access to email
    from Oct 26th to Nov 6th.
    
    Here's what's in this request:
    
     - Patches to fix USB 2.0 Link PM issues that cause USB 3.0 devices to not
       enumerate or misbehave when plugged into a USB 2.0 port.  Those are
       marked for stable.
    
     - A msec vs jiffies bug fix by xiao jin, which results in fairly harmless
       behavior, and thus isn't marked for stable.
    
     - Xenia's patches to refactor the xHCI command handling code, which makes
       it much more readable and consistent.
    
     - Misc cleanup patches, one by Sachin Kamat and three from Dan Williams.
    
    Here's what's not in this request:
    
     - Dan's two patches to allow the xHCI host to use the "Windows" or "new"
       enumeration scheme.  I did not have time to test those, and I want to
       run them with as many USB devices as I can get a hold of.  That will
       have to wait for 3.14.
    
     - Xenia's patches to remove xhci_readl in favor of readl.  I'll queue
       those for 3.14 after I test them.
    
     - The xHCI streams update, UAS fixes, and usbfs streams support.  I'm not
       comfortable with changes and fixes to that patchset coming in this late.
       I would rather wait for 3.14 and be really sure the streams support is
       stable before we add new userspace API and remove CONFIG_BROKEN from the
       uas driver.
    
     - Julius' patch to clear the port reset bit on hub resume that came in
       a couple days ago.  It looks harmless, but I would rather take the time
       to test and queue it for usb-linus and the stable trees once 3.13-rc1
       is out.
    
    Sarah Sharp

commit a2cdc3432c361bb885476d1c625e22b518e0bc07
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Oct 16 12:25:44 2013 -0700

    usb: xhci: remove the unused ->address field
    
    Only used for debug output, so we don't need to save it.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 466081934b68..2c701c60cbf4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -935,8 +935,6 @@ struct xhci_virt_device {
 	/* Rings saved to ensure old alt settings can be re-instated */
 	struct xhci_ring		**ring_cache;
 	int				num_rings_cached;
-	/* Store xHC assigned device address */
-	int				address;
 #define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
 	struct completion		cmd_completion;

commit 58e21f73975ec927119370635bf68b9023831c56
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Oct 7 17:17:20 2013 -0700

    xhci: Set L1 device slot on USB2 LPM enable/disable.
    
    To enable USB 2.0 Link Power Management (LPM), the xHCI host controller
    needs the device slot ID to generate the device address used in L1 entry
    tokens.  That information is set in the L1 device slot ID field of the
    USB 2.0 LPM registers.
    
    Currently, the L1 device slot ID is overwritten when the xHCI driver
    initiates the software test of USB 2.0 Link PM in
    xhci_usb2_software_lpm_test.  It is never cleared when USB 2.0 Link PM
    is disabled for the device.  That should be harmless, because the
    Hardware LPM Enable (HLE) bit is cleared when USB 2.0 Link PM is
    disabled, so the host should not pay attention to the slot ID.
    
    This patch should have no effect on host behavior, but since
    xhci_usb2_software_lpm_test is going away in an upcoming bug fix patch,
    we need to move that code to the function that enables and disables USB
    2.0 Link PM.
    
    This patch should be backported to kernels as old as 3.11, that contain
    the commit a558ccdcc71c7770c5e80c926a31cfe8a3892a09 "usb: xhci: add USB2
    Link power management BESL support".  The upcoming bug fix patch is also
    marked for that stable kernel.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 289fbfbae746..466081934b68 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -383,6 +383,7 @@ struct xhci_op_regs {
 #define	PORT_RWE		(1 << 3)
 #define	PORT_HIRD(p)		(((p) & 0xf) << 4)
 #define	PORT_HIRD_MASK		(0xf << 4)
+#define	PORT_L1DS_MASK		(0xff << 8)
 #define	PORT_L1DS(p)		(((p) & 0xff) << 8)
 #define	PORT_HLE		(1 << 16)
 

commit 638298dc66ea36623dbc2757a24fc2c4ab41b016
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 12 08:11:06 2013 +0200

    xhci: Fix spurious wakeups after S5 on Haswell
    
    Haswell LynxPoint and LynxPoint-LP with the recent Intel BIOS show
    mysterious wakeups after shutdown occasionally.  After discussing with
    BIOS engineers, they explained that the new BIOS expects that the
    wakeup sources are cleared and set to D3 for all wakeup devices when
    the system is going to sleep or power off, but the current xhci driver
    doesn't do this properly (partly intentionally).
    
    This patch introduces a new quirk, XHCI_SPURIOUS_WAKEUP, for
    fixing the spurious wakeups at S5 by calling xhci_reset() in the xhci
    shutdown ops as done in xhci_stop(), and setting the device to PCI D3
    at shutdown and remove ops.
    
    The PCI D3 call is based on the initial fix patch by Oliver Neukum.
    
    [Note: Sarah changed the quirk name from XHCI_HSW_SPURIOUS_WAKEUP to
    XHCI_SPURIOUS_WAKEUP, since none of the other quirks have system names
    in them.  Sarah also fixed a collision with a quirk submitted around the
    same time, by changing the xhci->quirks bit from 17 to 18.]
    
    This patch should be backported to kernels as old as 3.0, that
    contain the commit 1c12443ab8eba71a658fae4572147e56d1f84f66 "xhci: Add
    Lynx Point to list of Intel switchable hosts."
    
    Cc: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4f82d2172afa..941d5f59e4dc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1549,6 +1549,7 @@ struct xhci_hcd {
 #define XHCI_AVOID_BEI		(1 << 15)
 #define XHCI_PLAT		(1 << 16)
 #define XHCI_SLOW_SUSPEND	(1 << 17)
+#define XHCI_SPURIOUS_WAKEUP	(1 << 18)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 455f58925247e8a1a1941e159f3636ad6ee4c90b
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Sep 30 15:50:54 2013 +0200

    xhci: quirk for extra long delay for S4
    
    It has been reported that this chipset really cannot
    sleep without this extraordinary delay.
    
    This patch should be backported, in order to ensure this host functions
    under stable kernels.  The last quirk for Fresco Logic hosts (commit
    bba18e33f25072ebf70fd8f7f0cdbf8cdb59a746 "xhci: Extend Fresco Logic MSI
    quirk.") was backported to stable kernels as old as 2.6.36.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 289fbfbae746..4f82d2172afa 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1548,6 +1548,7 @@ struct xhci_hcd {
 #define XHCI_COMP_MODE_QUIRK	(1 << 14)
 #define XHCI_AVOID_BEI		(1 << 15)
 #define XHCI_PLAT		(1 << 16)
+#define XHCI_SLOW_SUSPEND	(1 << 17)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 8b3d45705e54075cfb9d4212dbca9ea82c85c4b8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Aug 20 08:12:12 2013 -0700

    usb: Fix xHCI host issues on remote wakeup.
    
    When a device signals remote wakeup on a roothub, and the suspend change
    bit is set, the host controller driver must not give control back to the
    USB core until the port goes back into the active state.
    
    EHCI accomplishes this by waiting in the get port status function until
    the PORT_RESUME bit is cleared:
    
                            /* stop resume signaling */
                            temp &= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);
                            ehci_writel(ehci, temp, status_reg);
                            clear_bit(wIndex, &ehci->resuming_ports);
                            retval = ehci_handshake(ehci, status_reg,
                                            PORT_RESUME, 0, 2000 /* 2msec */);
    
    Similarly, the xHCI host should wait until the port goes into U0, before
    passing control up to the USB core.  When the port transitions from the
    RExit state to U0, the xHCI driver will get a port status change event.
    We need to wait for that event before passing control up to the USB
    core.
    
    After the port transitions to the active state, the USB core should time
    a recovery interval before it talks to the device.  The length of that
    recovery interval is TRSMRCY, 10 ms, mentioned in the USB 2.0 spec,
    section 7.1.7.7.  The previous xHCI code (which did not wait for the
    port to go into U0) would cause the USB core to violate that recovery
    interval.
    
    This bug caused numerous USB device disconnects on remote wakeup under
    ChromeOS and a Lynx Point LP xHCI host that takes up to 20 ms to move
    from RExit to U0.  ChromeOS is very aggressive about power savings, and
    sets the autosuspend_delay to 100 ms, and disables USB persist.
    
    I attempted to replicate this bug with Ubuntu 12.04, but could not.  I
    used Ubuntu 12.04 on the same platform, with the same BIOS that the bug
    was triggered on ChromeOS with.  I also changed the USB sysfs settings
    as described above, but still could not reproduce the bug under Ubuntu.
    It may be that ChromeOS userspace triggers this bug through additional
    settings.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f3e10206cd95..289fbfbae746 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1412,8 +1412,18 @@ struct xhci_bus_state {
 	unsigned long		resume_done[USB_MAXCHILDREN];
 	/* which ports have started to resume */
 	unsigned long		resuming_ports;
+	/* Which ports are waiting on RExit to U0 transition. */
+	unsigned long		rexit_ports;
+	struct completion	rexit_done[USB_MAXCHILDREN];
 };
 
+
+/*
+ * It can take up to 20 ms to transition from RExit to U0 on the
+ * Intel Lynx Point LP xHCI host.
+ */
+#define	XHCI_MAX_REXIT_TIMEOUT	(20 * 1000)
+
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
 	if (hcd->speed == HCD_USB3)

commit ec7e43e2d98173483866fe2e4e690143626b659c
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Aug 30 18:25:49 2013 +0300

    xhci: Ensure a command structure points to the correct trb on the command ring
    
    If a command on the command ring needs to be cancelled before it is handled
    it can be turned to a no-op operation when the ring is stopped.
    We want to store the command ring enqueue pointer in the command structure
    when the command in enqueued for the cancellation case.
    
    Some commands used to store the command ring dequeue pointers instead of enqueue
    (these often worked because enqueue happends to equal dequeue quite often)
    
    Other commands correctly used the enqueue pointer but did not check if it pointed
    to a valid trb or a link trb, this caused for example stop endpoint command to timeout in
    xhci_stop_device() in about 2% of suspend/resume cases.
    
    This should also solve some weird behavior happening in command cancellation cases.
    
    This patch is based on a patch submitted by Sarah Sharp to linux-usb, but
    then forgotten:
        http://marc.info/?l=linux-usb&m=136269803207465&w=2
    
    This patch should be backported to kernels as old as 3.7, that contain
    the commit b92cc66c047ff7cf587b318fe377061a353c120f "xHCI: add aborting
    command ring function"
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 46aa14894148..f3e10206cd95 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1840,6 +1840,7 @@ int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
 		union xhci_trb *cmd_trb);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
+union xhci_trb *xhci_find_next_enqueue(struct xhci_ring *ring);
 
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,

commit 5845c13a70b40f1ce4dfe83acb7796bed8a60672
Merge: 224563b6ce03 52fb61250a7a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Aug 15 18:00:46 2013 -0700

    Merge tag 'for-usb-2013-08-15-step-1' into for-usb-next
    
    xhci: Step 1 to fix usb-linus and usb-next.
    
    Hi Greg,
    
    This is the first of three steps to fix your usb-linus and usb-next
    trees.  As I mentioned, commit 4fae6f0fa86f92e6bc7429371b1e177ad0aaac66
    "USB: handle LPM errors during device suspend correctly" was incorrectly
    added to usb-next when it should have been added to usb-linus and marked
    for stable.
    
    Two port power off bug fixes touch the same code that patch touches, but
    it's not easy to simply move commit 4fae6f0f patch to usb-linus because
    commit 28e861658e23ca94692f98e245d254c75c8088a7 "USB: refactor code for
    enabling/disabling remote wakeup" also touched those code sections.
    
    I propose a two step process to fix this:
    
    1. Pull these four patches into usb-linus.
    
    2. Revert commit 28e861658e23ca94692f98e245d254c75c8088a7 from usb-next.
       Merge usb-linus into usb-next, and resolve the conflicts.
    
    I will be sending pull requests for these steps.
    
    This pull request is step one, and contains the backported version of
    commit 4fae6f0fa86f92e6bc7429371b1e177ad0aaac66, the two port power off
    fixes, and an unrelated xhci-plat bug fix.
    
    Sarah Sharp
    
    Resolved conflicts:
            drivers/usb/core/hub.c

commit 52fb61250a7a132b0cfb9f4a1060a1f3c49e5a25
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Aug 8 10:08:34 2013 -0700

    xhci-plat: Don't enable legacy PCI interrupts.
    
    The xHCI platform driver calls into usb_add_hcd to register the irq for
    its platform device.  It does not want the xHCI generic driver to
    register an interrupt for it at all.  The original code did that by
    setting the XHCI_BROKEN_MSI quirk, which tells the xHCI driver to not
    enable MSI or MSI-X for a PCI host.
    
    Unfortunately, if CONFIG_PCI is enabled, and CONFIG_USB_DW3 is enabled,
    the xHCI generic driver will attempt to register a legacy PCI interrupt
    for the xHCI platform device in xhci_try_enable_msi().  This will result
    in a bogus irq being registered, since the underlying device is a
    platform_device, not a pci_device, and thus the pci_device->irq pointer
    will be bogus.
    
    Add a new quirk, XHCI_PLAT, so that the xHCI generic driver can
    distinguish between a PCI device that can't handle MSI or MSI-X, and a
    platform device that should not have its interrupts touched at all.
    This quirk may be useful in the future, in case other corner cases like
    this arise.
    
    This patch should be backported to kernels as old as 3.9, that
    contain the commit 00eed9c814cb8f281be6f0f5d8f45025dc0a97eb "USB: xhci:
    correctly enable interrupts".
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Yu Y Wang <yu.y.wang@intel.com>
    Tested-by: Yu Y Wang <yu.y.wang@intel.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c338741a675d..6ab1e600dc18 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1542,6 +1542,7 @@ struct xhci_hcd {
 #define XHCI_SPURIOUS_REBOOT	(1 << 13)
 #define XHCI_COMP_MODE_QUIRK	(1 << 14)
 #define XHCI_AVOID_BEI		(1 << 15)
+#define XHCI_PLAT		(1 << 16)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 84a99f6fc5d4a2b7583aa287979268a8bb926367
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Aug 6 00:22:15 2013 +0300

    xhci: add traces for debug messages in xhci_address_device()
    
    This patch declares an event class for trace events that
    trace messages with variadic arguments, called xhci_log_msg,
    and defines a trace event for tracing the debug messages in
    xhci_address_device() function, called xhci_dbg_address.
    
    In order to implement this type of trace events, a wrapper function,
    called xhci_dbg_trace(), was created that records the format string
    and variadic arguments into a va_format structure which is passed as
    argument to the tracepoints of the class xhci_log_msg.
    
    All the xhci_dbg() calls in xhci_address_device() are replaced
    with calls to xhci_dbg_trace(). The functionality of xhci_dbg()
    log messages was not removed though, but it is placed inside
    xhci_dbg_trace().
    
    This trace event aims to give the ability to the user or the
    developper to isolate and trace the debug messages generated
    when an Address Device Command is issued to xHC.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4d43531f5fcf..d2045916531b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1647,6 +1647,8 @@ char *xhci_get_slot_state(struct xhci_hcd *xhci,
 void xhci_dbg_ep_rings(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_virt_ep *ep);
+void xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),
+			const char *fmt, ...);
 
 /* xHCI memory management */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);

commit b2497509df002e9a09c8550cd0ecd2f77c9640d8
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jul 2 17:49:27 2013 +0300

    xhci: remove CONFIG_USB_XHCI_HCD_DEBUGGING and unused code
    
    CONFIG_USB_XHCI_HCD_DEBUGGING option is used to enable
    verbose debugging output for the xHCI host controller
    driver.
    
    In the current version of the xhci-hcd driver, this
    option must be turned on, in order for the debugging
    log messages to be displayed, and users may need to
    recompile the linux kernel to obtain debugging
    information that will help them track down problems.
    
    This patch removes the above debug option to enable
    debugging log messages at all times.
    The aim of this is to rely on the debugfs and the
    dynamic debugging feature for fine-grained management
    of debugging messages and to not force users to set
    the debug config option and compile the linux kernel
    in order to have access in that information.
    
    This patch, also, removes the XHCI_DEBUG symbol and the
    functions dma_to_stream_ring(), xhci_test_radix_tree()
    and xhci_event_ring_work() that are not useful anymore.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0a74d10be8a1..4d43531f5fcf 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1490,11 +1490,6 @@ struct xhci_hcd {
 	struct dma_pool	*small_streams_pool;
 	struct dma_pool	*medium_streams_pool;
 
-#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING
-	/* Poll the rings - for debugging */
-	struct timer_list	event_ring_timer;
-	int			zombie;
-#endif
 	/* Host controller watchdog timer structures */
 	unsigned int		xhc_state;
 
@@ -1579,14 +1574,8 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 	return xhci->main_hcd;
 }
 
-#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING
-#define XHCI_DEBUG	1
-#else
-#define XHCI_DEBUG	0
-#endif
-
 #define xhci_dbg(xhci, fmt, args...) \
-	do { if (XHCI_DEBUG) dev_dbg(xhci_to_hcd(xhci)->self.controller , fmt , ## args); } while (0)
+	dev_dbg(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 #define xhci_err(xhci, fmt, args...) \
 	dev_err(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 #define xhci_warn(xhci, fmt, args...) \

commit 38a532a621ad8533d8839ef0ff8bd15dc08b8eab
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Tue Jul 2 17:49:25 2013 +0300

    xhci: replace xhci_info() with xhci_dbg()
    
    This patch replaces the calls to xhci_info() with calls to
    xhci_dbg() and removes the unused xhci_info() definition
    from xhci-hcd.
    
    By replacing the xhci_info() with xhci_dbg(), the calls to
    dev_info() are replaced with calls to dev_dbg() so that
    their output can be dynamically controlled via the dynamic
    debugging mechanism.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c338741a675d..0a74d10be8a1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1587,8 +1587,6 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 
 #define xhci_dbg(xhci, fmt, args...) \
 	do { if (XHCI_DEBUG) dev_dbg(xhci_to_hcd(xhci)->self.controller , fmt , ## args); } while (0)
-#define xhci_info(xhci, fmt, args...) \
-	do { if (XHCI_DEBUG) dev_info(xhci_to_hcd(xhci)->self.controller , fmt , ## args); } while (0)
 #define xhci_err(xhci, fmt, args...) \
 	dev_err(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 #define xhci_warn(xhci, fmt, args...) \

commit 141dc40ee343ab532717b235dd645e2d25ae3092
Merge: 1c83d94ff646 317ddd256b9c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jun 8 21:27:51 2013 -0700

    Merge 3.10-rc5 into usb-next
    
    We need the changes in this branch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a558ccdcc71c7770c5e80c926a31cfe8a3892a09
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 23 17:14:30 2013 +0300

    usb: xhci: add USB2 Link power management BESL support
    
    usb 2.0 devices with link power managment (LPM) can describe their idle link
    timeouts either in BESL or HIRD format, so far xHCI has only supported HIRD but
    later xHCI errata add BESL support as well
    
    BESL timeouts need to inform exit latency changes with an evaluate
    context command the same way USB 3.0 link PM code does.
    The same xhci_change_max_exit_latency() function is used as with USB3
    but code is pulled out from #ifdef CONFIG_PM as USB2.0 BESL LPM
    funcionality does not depend on CONFIG_PM.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 01325710424c..c306849eb299 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -386,6 +386,27 @@ struct xhci_op_regs {
 #define	PORT_L1DS(p)		(((p) & 0xff) << 8)
 #define	PORT_HLE		(1 << 16)
 
+
+/* USB2 Protocol PORTHLPMC */
+#define PORT_HIRDM(p)((p) & 3)
+#define PORT_L1_TIMEOUT(p)(((p) & 0xff) << 2)
+#define PORT_BESLD(p)(((p) & 0xf) << 10)
+
+/* use 512 microseconds as USB2 LPM L1 default timeout. */
+#define XHCI_L1_TIMEOUT		512
+
+/* Set default HIRD/BESL value to 4 (350/400us) for USB2 L1 LPM resume latency.
+ * Safe to use with mixed HIRD and BESL systems (host and device) and is used
+ * by other operating systems.
+ *
+ * XHCI 1.0 errata 8/14/12 Table 13 notes:
+ * "Software should choose xHC BESL/BESLD field values that do not violate a
+ * device's resume latency requirements,
+ * e.g. not program values > '4' if BLC = '1' and a HIRD device is attached,
+ * or not program values < '4' if BLC = '0' and a BESL device is attached.
+ */
+#define XHCI_DEFAULT_BESL	4
+
 /**
  * struct xhci_intr_reg - Interrupt Register Set
  * @irq_pending:	IMAN - Interrupt Management Register.  Used to enable

commit b6e76371c888f5cb677f190a28444ac8875359ad
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 23 17:14:29 2013 +0300

    usb: xhci: define port register names and use them instead of magic numbers
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 66b048a64ee0..01325710424c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -132,6 +132,11 @@ struct xhci_cap_regs {
 /* Number of registers per port */
 #define	NUM_PORT_REGS	4
 
+#define PORTSC		0
+#define PORTPMSC	1
+#define PORTLI		2
+#define PORTHLPMC	3
+
 /**
  * struct xhci_op_regs - xHCI Host Controller Operational Registers.
  * @command:		USBCMD - xHC command register

commit b630d4b9d05ba2e66878ca4614946d0f950d4111
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 23 17:14:28 2013 +0300

    usb: xhci: check usb2 port capabilities before adding hw link PM support
    
    Hardware link powermanagement in usb2 is a per-port capability.
    Previously support for hw lpm was enabled for all ports if any usb2 port supported it.
    
    Now instead cache the capability values and check them for each port individually
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d62ebca1e91c..66b048a64ee0 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1532,6 +1532,9 @@ struct xhci_hcd {
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
+	/* cached usb2 extened protocol capabilites */
+	u32                     *ext_caps;
+	unsigned int            num_ext_caps;
 	/* Compliance Mode Recovery Data */
 	struct timer_list	comp_mode_recovery_timer;
 	u32			port_status_u0;

commit 851ec164b14aa9dacafd6edb099e76a4cc9d06ec
Author: Alex Shi <alex.shi@intel.com>
Date:   Fri May 24 10:54:19 2013 +0800

    usb/xhci: unify parameter of xhci_msi_irq
    
    According to Felipe and Alan's comments the second parameter of irq
    handler should be 'void *' not a specific structure pointer.
    So change it.
    
    Signed-off-by: Alex Shi <alex.shi@intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3ee79d6fddae..d62ebca1e91c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1746,7 +1746,7 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
 
 int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
-irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd);
+irqreturn_t xhci_msi_irq(int irq, void *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_alloc_tt_info(struct xhci_hcd *xhci,

commit 01c5f4477d527732ecaf92d9b3d2201c8030000b
Author: Julius Werner <jwerner@chromium.org>
Date:   Mon Apr 15 15:55:04 2013 -0700

    usb: xhci-dbg: Display endpoint number and direction in context dump
    
    When CONFIG_XHCI_HCD_DEBUGGING is activated, the XHCI driver can dump
    device and input contexts to the console. The endpoint contexts in that
    dump are labeled "Endpoint N Context", where N is the XHCI endpoint
    index (DCI - 1). This can be very confusing, especially for people who
    are not that familiar with the XHCI specification. This patch introduces
    an xhci_get_endpoint_address function (as a counterpart to the reverse
    xhci_get_endpoint_index), and uses it to additionally display the
    endpoint number and direction when dumping contexts, which are much more
    commonly used concepts in USB.
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 29c978e37135..3ee79d6fddae 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1641,6 +1641,7 @@ int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *ud
 void xhci_copy_ep0_dequeue_into_input_ctx(struct xhci_hcd *xhci,
 		struct usb_device *udev);
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
+unsigned int xhci_get_endpoint_address(unsigned int ep_index);
 unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
 unsigned int xhci_last_valid_endpoint(u32 added_ctxs);

commit c3897aa5386faba77e5bbdf94902a1658d3a5b11
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Apr 18 10:02:03 2013 -0700

    xhci: Disable D3cold for buggy TI redrivers.
    
    Some xHCI hosts contain a "redriver" from TI that silently drops port
    status connect changes if the port slips into Compliance Mode.  If the
    port slips into compliance mode while the host is in D0, there will not
    be a port status change event.  If the port slips into compliance mode
    while the host is in D3, the host will not send a PME.  This includes
    when the system is suspended (S3) or hibernated (S4).
    
    If this happens when the system is in S3/S4, there is nothing software
    can do.  Other port status change events that would normally cause the
    host to wake the system from S3/S4 may also be lost.  This includes
    remote wakeup, disconnects and connects on other ports, and overrcurrent
    events.  A decision was made to _NOT_ disable system suspend/hibernate
    on these systems, since users are unlikely to enable wakeup from S3/S4
    for the xHCI host.
    
    Software can deal with this issue when the system is in S0.  A work
    around was put in to poll the port status registers for Compliance Mode.
    The xHCI driver will continue to poll the registers while the host is
    runtime suspended.  Unfortunately, that means we can't allow the PCI
    device to go into D3cold, because power will be removed from the host,
    and the config space will read as all Fs.
    
    Disable D3cold in the xHCI PCI runtime suspend function.
    
    This patch should be backported to kernels as old as 3.2, that
    contain the commit 71c731a296f1b08a3724bd1b514b64f1bda87a23 "usb: host:
    xhci: Fix Compliance Mode on SN65LVPE502CP Hardware"
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 29c978e37135..77600cefcaf1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1853,4 +1853,7 @@ struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_hcd *xhci,
 struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
 struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);
 
+/* xHCI quirks */
+bool xhci_compliance_mode_recovery_timer_quirk_check(void);
+
 #endif /* __LINUX_XHCI_HCD_H */

commit eb8ccd2b481123e5fe0872a83e07ea8a6e2c4026
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 28 18:48:35 2013 +0000

    xhci: Rename SEGMENT_SIZE and SEGMENT_SHIFT as the former is used in a.out.h
    
    Rename SEGMENT_SIZE and SEGMENT_SHIFT as the former is used in a.out.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: linux-usb@vger.kernel.org
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ca550ddb0b1d..29c978e37135 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1238,8 +1238,8 @@ union xhci_trb {
 #define TRBS_PER_SEGMENT	64
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
-#define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
-#define SEGMENT_SHIFT		(ilog2(SEGMENT_SIZE))
+#define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
+#define TRB_SEGMENT_SHIFT	(ilog2(TRB_SEGMENT_SIZE))
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)

commit 6a5d6943fe0e4b1e4c43c3aa1919360f68ae2f9a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 28 18:48:28 2013 +0000

    xhci: Use ilog2() rather than __ffs() for calculating SEGMENT_SHIFT
    
    Use ilog2() rather than __ffs() for calculating SEGMENT_SHIFT as ilog2() can
    be worked out at compile time, whereas __ffs() must be calculated at runtime.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: linux-usb@vger.kernel.org
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 63582719e0fb..ca550ddb0b1d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1239,7 +1239,7 @@ union xhci_trb {
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
-#define SEGMENT_SHIFT		(__ffs(SEGMENT_SIZE))
+#define SEGMENT_SHIFT		(ilog2(SEGMENT_SIZE))
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)

commit 1c11a172cb30492f5f6a82c6e118fdcd9946c34f
Author: Vivek Gautam <gautam.vivek@samsung.com>
Date:   Thu Mar 21 12:06:48 2013 +0530

    usb: xhci: Fix TRB transfer length macro used for Event TRB.
    
    Use proper macro while extracting TRB transfer length from
    Transfer event TRBs. Adding a macro EVENT_TRB_LEN (bits 0:23)
    for the same, and use it instead of TRB_LEN (bits 0:16) in
    case of event TRBs.
    
    This patch should be backported to kernels as old as 2.6.31, that
    contain the commit b10de142119a676552df3f0d2e3a9d647036c26a "USB: xhci:
    Bulk transfer support".  This patch will have issues applying to older
    kernels.
    
    Signed-off-by: Vivek gautam <gautam.vivek@samsung.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d798b6931914..63582719e0fb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -972,6 +972,10 @@ struct xhci_transfer_event {
 	__le32	flags;
 };
 
+/* Transfer event TRB length bit mask */
+/* bits 0:23 */
+#define	EVENT_TRB_LEN(p)		((p) & 0xffffff)
+
 /** Transfer Event bit fields **/
 #define	TRB_TO_EP_ID(p)	(((p) >> 16) & 0x1f)
 

commit 3f5eb14135ba9d97ba4b8514fc7ef5e0dac2abf4
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Mar 19 16:48:12 2013 +0800

    usb: add find_raw_port_number callback to struct hc_driver()
    
    xhci driver divides the root hub into two logical hubs which work
    respectively for usb 2.0 and usb 3.0 devices. They are independent
    devices in the usb core. But in the ACPI table, it's one device node
    and all usb2.0 and usb3.0 ports are under it. Binding usb port with
    its acpi node needs the raw port number which is reflected in the xhci
    extended capabilities table. This patch is to add find_raw_port_number
    callback to struct hc_driver(), fill it with xhci_find_raw_port_number()
    which will return raw port number and add a wrap usb_hcd_find_raw_port_number().
    
    Otherwise, refactor xhci_find_real_port_number(). Using
    xhci_find_raw_port_number() to get real index in the HW port status
    registers instead of scanning through the xHCI roothub port array.
    This can help to speed up.
    
    All addresses in xhci->usb2_ports and xhci->usb3_ports array are
    kown good ports and don't include following bad ports in the extended
    capabilities talbe.
         (1) root port that doesn't have an entry
         (2) root port with unknown speed
         (3) root port that is listed twice and with different speeds.
    
    So xhci_find_raw_port_number() will only return port num of good ones
    and never touch bad ports above.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2c510e4a7d4c..d798b6931914 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1829,6 +1829,7 @@ void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+int xhci_find_raw_port_number(struct usb_hcd *hcd, int port1);
 
 #ifdef CONFIG_PM
 int xhci_bus_suspend(struct usb_hcd *hcd);

commit f8264340e694604863255cc0276491d17c402390
Author: Dmitry Torokhov <dtor@vmware.com>
Date:   Mon Feb 25 10:56:01 2013 -0800

    USB: xhci - fix bit definitions for IMAN register
    
    According to XHCI specification (5.5.2.1) the IP is bit 0 and IE is bit 1
    of IMAN register. Previously their definitions were reversed.
    
    Even though there are no ill effects being observed from the swapped
    definitions (because IMAN_IP is RW1C and in legacy PCI case we come in
    with it already set to 1 so it was clearing itself even though we were
    setting IMAN_IE instead of IMAN_IP), we should still correct the values.
    
    This patch should be backported to kernels as old as 2.6.36, that
    contain the commit 4e833c0b87a30798e67f06120cecebef6ee9644c "xhci: don't
    re-enable IE constantly".
    
    Signed-off-by: Dmitry Torokhov <dtor@vmware.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f791bd0aee6c..2c510e4a7d4c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -206,8 +206,8 @@ struct xhci_op_regs {
 /* bits 12:31 are reserved (and should be preserved on writes). */
 
 /* IMAN - Interrupt Management Register */
-#define IMAN_IP		(1 << 1)
-#define IMAN_IE		(1 << 0)
+#define IMAN_IE		(1 << 1)
+#define IMAN_IP		(1 << 0)
 
 /* USBSTS - USB status - status bitmasks */
 /* HC not running - set to 1 when run/stop bit is cleared. */

commit 2611bd189ee8cb6761393aec90d699015d9c5e9f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Oct 25 13:27:51 2012 -0700

    xhci: Avoid global symbol pollution with handshake.
    
    Non-static xHCI driver symbols should start with the "xhci_" prefix, in
    order to avoid namespace pollution.  Rename the "handshake" function to
    "xhci_handshake".
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Ben Hutchings <ben@decadent.org.uk>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 53df4e70ca07..f791bd0aee6c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1720,7 +1720,7 @@ static inline void xhci_unregister_plat(void)
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
-int handshake(struct xhci_hcd *xhci, void __iomem *ptr,
+int xhci_handshake(struct xhci_hcd *xhci, void __iomem *ptr,
 		u32 mask, u32 done, int usec);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);

commit 80fab3b244a22e0ca539d2439bdda50e81e5666f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Sep 19 16:27:26 2012 -0700

    xhci: Intel Panther Point BEI quirk.
    
    When a device with an isochronous endpoint is behind a hub plugged into
    the Intel Panther Point xHCI host controller, and the driver submits
    multiple frames per URB, the xHCI driver will set the Block Event
    Interrupt (BEI) flag on all but the last TD for the URB.  This causes
    the host controller to place an event on the event ring, but not send an
    interrupt.  When the last TD for the URB completes, BEI is cleared, and
    we get an interrupt for the whole URB.
    
    However, under a Panther Point xHCI host controller, if the parent hub
    is unplugged when one or more events from transfers with BEI set are on
    the event ring, a port status change event is placed on the event ring,
    but no interrupt is generated.  This means URBs stop completing, and the
    USB device disconnect is not noticed.  Something like a USB headset will
    cause mplayer to hang when the device is disconnected.
    
    If another transfer is sent (such as running `sudo lsusb -v`), the next
    transfer event seems to "unstick" the event ring, the xHCI driver gets
    an interrupt, and the disconnect is reported to the USB core.
    
    The fix is not to use the BEI flag under the Panther Point xHCI host.
    This will impact power consumption and system responsiveness, because
    the xHCI driver will receive an interrupt for every frame in all
    isochronous URBs instead of once per URB.
    
    Intel chipset developers confirm that this bug will be hit if the BEI
    flag is used on any endpoint, not just ones that are behind a hub.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 69e848c2090aebba5698a1620604c7dccb448684 "Intel xhci: Support
    EHCI/xHCI port switching."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e44e2d3c83b0..53df4e70ca07 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1511,6 +1511,7 @@ struct xhci_hcd {
 #define XHCI_INTEL_HOST		(1 << 12)
 #define XHCI_SPURIOUS_REBOOT	(1 << 13)
 #define XHCI_COMP_MODE_QUIRK	(1 << 14)
+#define XHCI_AVOID_BEI		(1 << 15)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 2bcb132c693566bcb8208cc7ce66b72a4f852ecf
Merge: 67e6da702753 5698bd757d55
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 16 20:42:46 2012 -0700

    Merge 3.6-rc6 into usb-next
    
    This resolves the merge problems with:
            drivers/usb/dwc3/gadget.c
            drivers/usb/musb/tusb6010.c
    that had been seen in linux-next.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6e4468b9a0793dfb53eb80d9fe52c739b13b27fd
Author: Elric Fu <elricfu1@gmail.com>
Date:   Wed Jun 27 16:31:52 2012 +0800

    xHCI: cancel command after command timeout
    
    The patch is used to cancel command when the command isn't
    acknowledged and a timeout occurs.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 7ed603ecf8b68ab81f4c83097d3063d43ec73bb8 "xhci: Add an
    assertion to check for virt_dev=0 bug." That commit papers over a NULL
    pointer dereference, and this patch fixes the underlying issue that
    caused the NULL pointer dereference.
    
    Signed-off-by: Elric Fu <elricfu1@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Miroslav Sabljic <miroslav.sabljic@avl.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fdfcebf342e8..e81ccfa3552f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1256,6 +1256,9 @@ struct xhci_td {
 	union xhci_trb		*last_trb;
 };
 
+/* xHCI command default timeout value */
+#define XHCI_CMD_DEFAULT_TIMEOUT	(5 * HZ)
+
 /* command descriptor */
 struct xhci_cd {
 	struct list_head	cancel_cmd_list;

commit b92cc66c047ff7cf587b318fe377061a353c120f
Author: Elric Fu <elricfu1@gmail.com>
Date:   Wed Jun 27 16:31:12 2012 +0800

    xHCI: add aborting command ring function
    
    Software have to abort command ring and cancel command
    when a command is failed or hang. Otherwise, the command
    ring will hang up and can't handle the others. An example
    of a command that may hang is the Address Device Command,
    because waiting for a SET_ADDRESS request to be acknowledged
    by a USB device is outside of the xHC's ability to control.
    
    To cancel a command, software will initialize a command
    descriptor for the cancel command, and add it into a
    cancel_cmd_list of xhci.
    
    Sarah: Fixed missing newline on "Have the command ring been stopped?"
    debugging statement.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 7ed603ecf8b68ab81f4c83097d3063d43ec73bb8 "xhci: Add an
    assertion to check for virt_dev=0 bug." That commit papers over a NULL
    pointer dereference, and this patch fixes the underlying issue that
    caused the NULL pointer dereference.
    
    Signed-off-by: Elric Fu <elricfu1@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Miroslav Sabljic <miroslav.sabljic@avl.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 33f24e9fa766..fdfcebf342e8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1256,6 +1256,13 @@ struct xhci_td {
 	union xhci_trb		*last_trb;
 };
 
+/* command descriptor */
+struct xhci_cd {
+	struct list_head	cancel_cmd_list;
+	struct xhci_command	*command;
+	union xhci_trb		*cmd_trb;
+};
+
 struct xhci_dequeue_state {
 	struct xhci_segment *new_deq_seg;
 	union xhci_trb *new_deq_ptr;
@@ -1425,6 +1432,7 @@ struct xhci_hcd {
 #define CMD_RING_STATE_RUNNING         (1 << 0)
 #define CMD_RING_STATE_ABORTED         (1 << 1)
 #define CMD_RING_STATE_STOPPED         (1 << 2)
+	struct list_head        cancel_cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
@@ -1702,6 +1710,8 @@ static inline void xhci_unregister_plat(void)
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
+int handshake(struct xhci_hcd *xhci, void __iomem *ptr,
+		u32 mask, u32 done, int usec);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
@@ -1792,6 +1802,8 @@ void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
+int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
+		union xhci_trb *cmd_trb);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 

commit c181bc5b5d5c79b71203cd10cef97f802fb6f9c1
Author: Elric Fu <elricfu1@gmail.com>
Date:   Wed Jun 27 16:30:57 2012 +0800

    xHCI: add cmd_ring_state
    
    Adding cmd_ring_state for command ring. It helps to verify
    the current command ring state for controlling the command
    ring operations.
    
    This patch should be backported to kernels as old as 3.0.  The commit
    7ed603ecf8b68ab81f4c83097d3063d43ec73bb8 "xhci: Add an assertion to
    check for virt_dev=0 bug." papers over the NULL pointer dereference that
    I now believe is related to a timed out Set Address command.  This (and
    the four patches that follow it) contain the real fix that also allows
    VIA USB 3.0 hubs to consistently re-enumerate during the plug/unplug
    stress tests.
    
    Signed-off-by: Elric Fu <elricfu1@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Miroslav Sabljic <miroslav.sabljic@avl.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c713256297ac..33f24e9fa766 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1421,6 +1421,10 @@ struct xhci_hcd {
 	/* data structures */
 	struct xhci_device_context_array *dcbaa;
 	struct xhci_ring	*cmd_ring;
+	unsigned int            cmd_ring_state;
+#define CMD_RING_STATE_RUNNING         (1 << 0)
+#define CMD_RING_STATE_ABORTED         (1 << 1)
+#define CMD_RING_STATE_STOPPED         (1 << 2)
 	unsigned int		cmd_ring_reserved_trbs;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;

commit 71c731a296f1b08a3724bd1b514b64f1bda87a23
Author: Alexis R. Cortes <alexis.cortes@ti.com>
Date:   Fri Aug 3 14:00:27 2012 -0500

    usb: host: xhci: Fix Compliance Mode on SN65LVPE502CP Hardware
    
    This patch is intended to work around a known issue on the
    SN65LVPE502CP USB3.0 re-driver that can delay the negotiation
    between a device and the host past the usual handshake timeout.
    
    If that happens on the first insertion, the host controller
    port will enter in Compliance Mode and NO port status event will
    be generated (as per xHCI Spec) making impossible to detect this
    event by software. The port will remain in compliance mode until
    a warm reset is applied to it.
    
    As a result of this, the port will seem "dead" to the user and no
    device connections or disconnections will be detected.
    
    For solving this, the patch creates a timer which polls every 2
    seconds the link state of each host controller's port (this
    by reading the PORTSC register) and recovers the port by issuing a
    Warm reset every time Compliance mode is detected.
    
    If a xHC USB3.0 port has previously entered to U0, the compliance
    mode issue will NOT occur only until system resumes from
    sleep/hibernate, therefore, the compliance mode timer is stopped
    when all xHC USB 3.0 ports have entered U0. The timer is initialized
    again after each system resume.
    
    Since the issue is being caused by a piece of hardware, the timer
    will be enabled ONLY on those systems that have the SN65LVPE502CP
    installed (this patch uses DMI strings for detecting those systems)
    therefore making this patch to act as a quirk (XHCI_COMP_MODE_QUIRK
    has been added to the xhci stack).
    
    This patch applies for these systems:
    Vendor: Hewlett-Packard. System Models: Z420, Z620 and Z820.
    
    This patch should be backported to kernels as old as 3.2, as that was
    the first kernel to support warm reset.  The kernels will need to
    contain both commit 10d674a82e553cb8a1f41027bb3c3e309b3f6804 "USB: When
    hot reset for USB3 fails, try warm reset" and commit
    8bea2bd37df08aaa599aa361a9f8b836ba98e554 "usb: Add support for root hub
    port status CAS".  The first patch add warm reset support, and the
    second patch modifies the USB core to issue a warm reset when the port
    is in compliance mode.
    
    Signed-off-by: Alexis R. Cortes <alexis.cortes@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c713256297ac..1a05908c6673 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1495,6 +1495,7 @@ struct xhci_hcd {
 #define XHCI_LPM_SUPPORT	(1 << 11)
 #define XHCI_INTEL_HOST		(1 << 12)
 #define XHCI_SPURIOUS_REBOOT	(1 << 13)
+#define XHCI_COMP_MODE_QUIRK	(1 << 14)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
@@ -1511,6 +1512,11 @@ struct xhci_hcd {
 	unsigned		sw_lpm_support:1;
 	/* support xHCI 1.0 spec USB2 hardware LPM */
 	unsigned		hw_lpm_support:1;
+	/* Compliance Mode Recovery Data */
+	struct timer_list	comp_mode_recovery_timer;
+	u32			port_status_u0;
+/* Compliance Mode Timer Triggered every 2 seconds */
+#define COMP_MODE_RCVRY_MSECS 2000
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */

commit e95829f474f0db3a4d940cae1423783edd966027
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 23 18:59:30 2012 +0300

    xhci: Switch PPT ports to EHCI on shutdown.
    
    The Intel desktop boards DH77EB and DH77DF have a hardware issue that
    can be worked around by BIOS.  If the USB ports are switched to xHCI on
    shutdown, the xHCI host will send a spurious interrupt, which will wake
    the system.  Some BIOS will work around this, but not all.
    
    The bug can be avoided if the USB ports are switched back to EHCI on
    shutdown.  The Intel Windows driver switches the ports back to EHCI, so
    change the Linux xHCI driver to do the same.
    
    Unfortunately, we can't tell the two effected boards apart from other
    working motherboards, because the vendors will change the DMI strings
    for the DH77EB and DH77DF boards to their own custom names.  One example
    is Compulab's mini-desktop, the Intense-PC.  Instead, key off the
    Panther Point xHCI host PCI vendor and device ID, and switch the ports
    over for all PPT xHCI hosts.
    
    The only impact this will have on non-effected boards is to add a couple
    hundred milliseconds delay on boot when the BIOS has to switch the ports
    over from EHCI to xHCI.
    
    This patch should be backported to kernels as old as 3.0, that contain
    the commit 69e848c2090aebba5698a1620604c7dccb448684 "Intel xhci: Support
    EHCI/xHCI port switching."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Denis Turischev <denis@compulab.co.il>
    Tested-by: Denis Turischev <denis@compulab.co.il>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 96f49dbb50ac..c713256297ac 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1494,6 +1494,7 @@ struct xhci_hcd {
 #define XHCI_TRUST_TX_LENGTH	(1 << 10)
 #define XHCI_LPM_SUPPORT	(1 << 11)
 #define XHCI_INTEL_HOST		(1 << 12)
+#define XHCI_SPURIOUS_REBOOT	(1 << 13)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 8202ce2e2921941098aa72894ac5d7b486a9d273
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Jul 25 10:52:45 2012 -0700

    xhci: Rate-limit XHCI_TRUST_TX_LENGTH quirk warning.
    
    When we encounter an xHCI host that needs the XHCI_TRUST_TX_LENGTH
    quirk, the xHCI driver ends up spewing messages about the quirk into
    dmesg every time a short packet occurs.  Change the xHCI driver to
    rate-limit such warnings.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Matthew Hall <mhall@mhcomputing.net>
    Reported-by: Gary E. Miller <gem@rellim.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 55c0785810c9..96f49dbb50ac 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1537,6 +1537,8 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 	dev_err(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 #define xhci_warn(xhci, fmt, args...) \
 	dev_warn(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
+#define xhci_warn_ratelimited(xhci, fmt, args...) \
+	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
 /* TODO: copied from ehci.h - can be refactored? */
 /* xHCI spec says all registers are little endian */

commit 8bea2bd37df08aaa599aa361a9f8b836ba98e554
Author: Stanislaw Ledwon <staszek.ledwon@linux.jf.intel.com>
Date:   Mon Jun 18 15:20:00 2012 +0200

    usb: Add support for root hub port status CAS
    
    The host controller port status register supports CAS (Cold Attach
    Status) bit. This bit could be set when USB3.0 device is connected
    when system is in Sx state. When the system wakes to S0 this port
    status with CAS bit is reported and this port can't be used by any
    device.
    
    When CAS bit is set the port should be reset by warm reset. This
    was not supported by xhci driver.
    
    The issue was found when pendrive was connected to suspended
    platform. The link state of "Compliance Mode" was reported together
    with CAS bit. This link state was also not supported by xhci and
    core/hub.c.
    
    The CAS bit is defined only for xhci root hub port and it is
    not supported on regular hubs. The link status is used to force
    warm reset on port. Make the USB core issue a warm reset when port
    is in ether the 'inactive' or 'compliance mode'. Change the xHCI driver
    to report 'compliance mode' when the CAS is set. This force warm reset
    on the root hub port.
    
    This patch should be backported to stable kernels as old as 3.2, that
    contain the commit 10d674a82e553cb8a1f41027bb3c3e309b3f6804 "USB: When
    hot reset for USB3 fails, try warm reset."
    
    Signed-off-by: Stanislaw Ledwon <staszek.ledwon@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Andiry Xu <andiry.xu@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index de3d6e3e57be..55c0785810c9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -341,7 +341,11 @@ struct xhci_op_regs {
 #define PORT_PLC	(1 << 22)
 /* port configure error change - port failed to configure its link partner */
 #define PORT_CEC	(1 << 23)
-/* bit 24 reserved */
+/* Cold Attach Status - xHC can set this bit to report device attached during
+ * Sx state. Warm port reset should be perfomed to clear this bit and move port
+ * to connected state.
+ */
+#define PORT_CAS	(1 << 24)
 /* wake on connect (enable) */
 #define PORT_WKCONN_E	(1 << 25)
 /* wake on disconnect (enable) */

commit e3567d2c15a7a8e2f992a5f7c7683453ca406d82
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 16 13:36:24 2012 -0700

    xhci: Add Intel U1/U2 timeout policy.
    
    All Intel xHCI host controllers support USB 3.0 Link Power Management.
    
    The Panther Point xHCI host controller needs the xHCI driver to
    calculate the U1 and U2 timeout values, because it will blindly accept a
    MEL that would cause scheduling issues.
    
    The Lynx Point xHCI host controller will reject MEL values that are too
    high, but internally it implements the same algorithm that is needed for
    Panther Point xHCI.
    
    Simplify the code paths by just having the xHCI driver calculate what
    the U1/U2 timeouts should be.  Comments on the policy are in the code.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d55b3678c8b8..de3d6e3e57be 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1489,6 +1489,7 @@ struct xhci_hcd {
 #define XHCI_AMD_0x96_HOST	(1 << 9)
 #define XHCI_TRUST_TX_LENGTH	(1 << 10)
 #define XHCI_LPM_SUPPORT	(1 << 11)
+#define XHCI_INTEL_HOST		(1 << 12)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 3b3db026414bba1c8f45c49d5eeaefd48d66e1ae
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 9 10:55:03 2012 -0700

    xhci: Add infrastructure for host-specific LPM policies.
    
    The choice of U1 and U2 timeouts for USB 3.0 Link Power Management (LPM)
    is highly host controller specific.  Here are a few examples of why it's
    host specific:
    
     1. Setting the U1/U2 timeout too short may cause the link to go into
        U1/U2 in between service intervals, which some hosts may tolerate,
        and some may not.
    
     2. The host controller has to modify its bus schedule in order to take
        into account the Maximum Exit Latency (MEL) to bring all the links
        from the host to the device into U0.  If the MEL is too big, and it
        takes too long to bring the links into an active state, the host
        controller may not be able to service periodic endpoints in time.
    
     3. Host controllers may also have scheduling limitations that force
        them to disable U1 or U2 if a USB device is behind too many tiers of
        hubs.
    
    We could take an educated guess at what U1/U2 timeouts may work for a
    particular host controller.  However, that would result in a binary
    search on every new configuration or alt setting installation, with
    multiple failed Evaluate Context commands.  Worse, the host may blindly
    accept the timeouts and just fail to update its schedule for U1/U2 exit
    latencies, which could result in randomly delayed periodic transfers.
    
    Since we don't want to cause jitter in periodic transfers, or delay
    config/alt setting changes too much, lay down a framework that xHCI
    vendors can extend in order to add their own U1/U2 timeout policies.
    
    To extend the framework, they will need to:
    
     - Modify the PCI init code to add a new xhci->quirk for their host, and
       set the XHCI_LPM_SUPPORT quirk flag.
     - Add their own vendor-specific hooks, like the ones that will be added
       in xhci_call_host_update_timeout_for_endpoint() and
       xhci_check_tier_policy()
     - Make the LPM enable/disable methods call those functions based on the
       xhci->quirk for their host.
    
    An example will be provided for the Intel xHCI host controller in the
    next patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f5cb7417f231..d55b3678c8b8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -916,6 +916,8 @@ struct xhci_virt_device {
 	u8				real_port;
 	struct xhci_interval_bw_table	*bw_table;
 	struct xhci_tt_bw_info		*tt_info;
+	/* The current max exit latency for the enabled USB3 link states. */
+	u16				current_mel;
 };
 
 /*
@@ -1486,6 +1488,7 @@ struct xhci_hcd {
 #define	XHCI_SW_BW_CHECKING	(1 << 8)
 #define XHCI_AMD_0x96_HOST	(1 << 9)
 #define XHCI_TRUST_TX_LENGTH	(1 << 10)
+#define XHCI_LPM_SUPPORT	(1 << 11)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
@@ -1783,6 +1786,10 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 link_state);
+int xhci_enable_usb3_lpm_timeout(struct usb_hcd *hcd,
+			struct usb_device *udev, enum usb3_link_state state);
+int xhci_disable_usb3_lpm_timeout(struct usb_hcd *hcd,
+			struct usb_device *udev, enum usb3_link_state state);
 void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 port_bit);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit dbc33303e457bc9d9179d628951e6b7c7a3f6056
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue May 8 07:32:03 2012 -0700

    xhci: Reserve one command for USB3 LPM disable.
    
    We want to do everything we can to ensure that USB 3.0 Link Power
    Management (LPM) can be disabled when it is enabled.  If LPM can't be
    disabled, we can't suspend USB 3.0 devices, or reset them.  To make sure
    we can submit the command to disable LPM, allocate a command in the
    xhci_hcd structure, and reserve one TRB on the command ring.
    
    We only need one command per xHCI driver instance, because LPM is only
    disabled or enabled while the USB core is holding the bandwidth_mutex
    that is shared between the xHCI USB 2.0 and USB 3.0 roothubs.  The
    bandwidth_mutex will be held until the command completes, or times out.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 59248449b254..f5cb7417f231 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1426,6 +1426,8 @@ struct xhci_hcd {
 	/* slot enabling and address device helpers */
 	struct completion	addr_dev;
 	int slot_id;
+	/* For USB 3.0 LPM enable/disable. */
+	struct xhci_command		*lpm_command;
 	/* Internal mirror of the HW's dcbaa */
 	struct xhci_virt_device	*devs[MAX_HC_SLOTS];
 	/* For keeping track of bandwidth domains per roothub. */

commit 4b2665418c81c87e7a46df690a443b3d5ac5b088
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon May 7 15:34:26 2012 -0700

    xhci: Some Evaluate Context commands must succeed.
    
    The upcoming USB 3.0 Link PM patches will introduce new API to enable
    and disable low-power link states.  We must be able to disable LPM in
    order to reset a device, or place the device into U3 (device suspend).
    Therefore, we need to make sure the Evaluate Context command to disable
    the LPM timeouts can't fail due to there being no room on the command
    ring.
    
    Introduce a new flag to the function that queues the Evaluate Context
    command, command_must_succeed.  This tells the ring handler that a TRB
    has already been reserved for the command (by incrementing
    xhci->cmd_ring_reserved_trbs), and basically ensures that prepare_ring()
    won't fail.  A similar flag was already implemented for the Configure
    Endpoint command queuing function.
    
    All functions that currently call xhci_configure_endpoint() to issue an
    Evaluate Context command pass "false" for the "must_succeed" parameter,
    so this patch should have no effect on current xHCI driver behavior.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 58d527ccb24a..59248449b254 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1757,7 +1757,7 @@ int xhci_queue_isoc_tx_prepare(struct xhci_hcd *xhci, gfp_t mem_flags,
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id, bool command_must_succeed);
 int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id);
+		u32 slot_id, bool command_must_succeed);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
 int xhci_queue_reset_device(struct xhci_hcd *xhci, u32 slot_id);

commit 797b0ca5e6283b4cc0bdeeb0e5915f21522ba85f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Nov 10 16:02:13 2011 -0800

    xhci: Add roothub code to set U1/U2 timeouts.
    
    USB 3.0 hubs can be put into a mode where the hub can automatically
    request that the link go into a deeper link power state after the link
    has been idle for a specified amount of time.  Each of the new USB 3.0
    link states (U1 and U2) have their own timeout that can be programmed
    per port.
    
    Change the xHCI roothub emulation code to handle the request to set the
    U1 and U2 timeouts.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ac142760fd3b..58d527ccb24a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -362,8 +362,10 @@ struct xhci_op_regs {
  * Timeout can be up to 127us.  0xFF means an infinite timeout.
  */
 #define PORT_U1_TIMEOUT(p)	((p) & 0xff)
+#define PORT_U1_TIMEOUT_MASK	0xff
 /* Inactivity timer value for transitions into U2 */
 #define PORT_U2_TIMEOUT(p)	(((p) & 0xff) << 8)
+#define PORT_U2_TIMEOUT_MASK	(0xff << 8)
 /* Bits 24:31 for port testing */
 
 /* USB2 Protocol PORTSPMSC */

commit 1530bbc6272d9da1e39ef8e06190d42c13a02733
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue May 8 09:22:49 2012 -0700

    xhci: Add new short TX quirk for Fresco Logic host.
    
    Sergio reported that when he recorded audio from a USB headset mic
    plugged into the USB 3.0 port on his ASUS N53SV-DH72, the audio sounded
    "robotic".  When plugged into the USB 2.0 port under EHCI on the same
    laptop, the audio sounded fine.  The device is:
    
    Bus 002 Device 004: ID 046d:0a0c Logitech, Inc. Clear Chat Comfort USB Headset
    
    The problem was tracked down to the Fresco Logic xHCI host controller
    not correctly reporting short transfers on isochronous IN endpoints.
    The driver would submit a 96 byte transfer, the device would only send
    88 or 90 bytes, and the xHCI host would report the transfer had a
    "successful" completion code, with an untransferred buffer length of 8
    or 6 bytes.
    
    The successful completion code and non-zero untransferred length is a
    contradiction.  The xHCI host is supposed to only mark a transfer as
    successful if all the bytes are transferred.  Otherwise, the transfer
    should be marked with a short packet completion code.  Without the EHCI
    bus trace, we wouldn't know whether the xHCI driver should trust the
    completion code or the untransferred length.  With it, we know to trust
    the untransferred length.
    
    Add a new xHCI quirk for the Fresco Logic host controller.  If a
    transfer is reported as successful, but the untransferred length is
    non-zero, print a warning.  For the Fresco Logic host, change the
    completion code to COMP_SHORT_TX and process the transfer like a short
    transfer.
    
    This should be backported to stable kernels that contain the commit
    f5182b4155b9d686c5540a6822486400e34ddd98 "xhci: Disable MSI for some
    Fresco Logic hosts."  That commit was marked for stable kernels as old
    as 2.6.36.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Sergio Correia <lists@uece.net>
    Tested-by: Sergio Correia <lists@uece.net>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ce1edd7246aa..ac142760fd3b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1481,6 +1481,7 @@ struct xhci_hcd {
 #define XHCI_RESET_ON_RESUME	(1 << 7)
 #define	XHCI_SW_BW_CHECKING	(1 << 8)
 #define XHCI_AMD_0x96_HOST	(1 << 9)
+#define XHCI_TRUST_TX_LENGTH	(1 << 10)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit f370b9968a220a3d79d870dd7dee674cc0ff3d10
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Sat Apr 14 02:54:30 2012 +0800

    xHCI: keep track of ports being resumed and indicate in hub_status_data
    
    This commit adds a bit-array to xhci bus_state for keeping track of
    which ports are undergoing a resume transition. If any of the bits
    are set when xhci_hub_status_data() is called, the routine will return
    a non-zero value even if no ports have any status changes pending.
    This will allow usbcore to handle races between root-hub suspend and
    port wakeup.
    
    This patch should be backported to kernels as old as 3.4, that contain
    the commit 879d38e6bc36d73b0ac40ec9b0d839fda9fa8b1a "USB: fix race
    between root-hub suspend and remote wakeup".
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3d69c4b2b542..ce1edd7246aa 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1362,6 +1362,8 @@ struct xhci_bus_state {
 	u32			suspended_ports;
 	u32			port_remote_wakeup;
 	unsigned long		resume_done[USB_MAXCHILDREN];
+	/* which ports have started to resume */
+	unsigned long		resuming_ports;
 };
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)

commit 4e833c0b87a30798e67f06120cecebef6ee9644c
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 15 16:37:08 2012 +0200

    xhci: don't re-enable IE constantly
    
    While we're at that, define IMAN bitfield to aid readability.
    
    The interrupt enable bit should be set once on driver init, and we
    shouldn't need to continually re-enable it.  Commit c21599a3 introduced
    a read of the irq_pending register, and that allows us to preserve the
    state of the IE bit.  Before that commit, we were blindly writing 0x3 to
    the register.
    
    This patch should be backported to kernels as old as 2.6.36, or ones
    that contain the commit c21599a36165dbc78b380846b254017a548b9de5 "USB:
    xhci: Reduce reads and writes of interrupter registers".
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 91074fdab3eb..3d69c4b2b542 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -205,6 +205,10 @@ struct xhci_op_regs {
 #define CMD_PM_INDEX	(1 << 11)
 /* bits 12:31 are reserved (and should be preserved on writes). */
 
+/* IMAN - Interrupt Management Register */
+#define IMAN_IP		(1 << 1)
+#define IMAN_IE		(1 << 0)
+
 /* USBSTS - USB status - status bitmasks */
 /* HC not running - set to 1 when run/stop bit is cleared. */
 #define STS_HALT	XHCI_STS_HALT

commit 3429e91a661e1f383aecc86c6bbcf65afb15c892
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Mar 13 16:57:41 2012 +0200

    usb: host: xhci: add platform driver support
    
    This adds a fairly simple xhci-platform driver support. Currently it is
    used by the dwc3 driver for supporting host mode.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 57cd632064b4..91074fdab3eb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1663,6 +1663,17 @@ static inline int xhci_register_pci(void) { return 0; }
 static inline void xhci_unregister_pci(void) {}
 #endif
 
+#if defined(CONFIG_USB_XHCI_PLATFORM) \
+	|| defined(CONFIG_USB_XHCI_PLATFORM_MODULE)
+int xhci_register_plat(void);
+void xhci_unregister_plat(void);
+#else
+static inline int xhci_register_plat(void)
+{ return 0; }
+static inline void xhci_unregister_plat(void)
+{  }
+#endif
+
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
 void xhci_quiesce(struct xhci_hcd *xhci);

commit 8dfec6140fc617b932cf9a09ba46d0ee3f3a7d87
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Mar 5 17:49:37 2012 +0800

    xHCI: dynamic ring expansion
    
    If room_on_ring() check fails, try to expand the ring and check again.
    
    When expand a ring, use a cached ring or allocate new segments, link
    the original ring and the new ring or segments, update the original ring's
    segment numbers and the last segment pointer.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ea8fc237d158..57cd632064b4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1622,6 +1622,8 @@ int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
+int xhci_ring_expansion(struct xhci_hcd *xhci, struct xhci_ring *ring,
+				unsigned int num_trbs, gfp_t flags);
 void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);

commit b008df60c6369ba0290fa7daa177375407a12e07
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Mar 5 17:49:34 2012 +0800

    xHCI: count free TRBs on transfer ring
    
    In the past, the room_on_ring() check was implemented by walking all over
    the ring, which is wasteful and complicated.
    
    Count the number of free TRBs instead. The free TRBs number should be
    updated when enqueue/dequeue pointer is updated, or upon the completion
    of a set dequeue pointer command.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2337a8e80b60..ea8fc237d158 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1278,6 +1278,8 @@ struct xhci_ring {
 	u32			cycle_state;
 	unsigned int		stream_id;
 	unsigned int		num_segs;
+	unsigned int		num_trbs_free;
+	unsigned int		num_trbs_free_temp;
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 };

commit 3fe4fe083d3355537565b2b0a678807513dfa013
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Mar 5 17:49:33 2012 +0800

    xHCI: store ring's last segment and segment numbers
    
    Store the ring's last segment pointer and number of segments for ring
    expansion usage.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index eb369a1723b1..2337a8e80b60 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1262,6 +1262,7 @@ enum xhci_ring_type {
 
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
+	struct xhci_segment	*last_seg;
 	union  xhci_trb		*enqueue;
 	struct xhci_segment	*enq_seg;
 	unsigned int		enq_updates;
@@ -1276,6 +1277,7 @@ struct xhci_ring {
 	 */
 	u32			cycle_state;
 	unsigned int		stream_id;
+	unsigned int		num_segs;
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 };

commit 3b72fca09d7aed0c1a390370eb3f3f4f0480702a
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Mar 5 17:49:32 2012 +0800

    xHCI: store ring's type
    
    When allocate a ring, store its type - four transfer types for endpoint,
    TYPE_STREAM for stream transfer, and TYPE_COMMAND/TYPE_EVENT for xHCI host.
    
    This helps to get rid of three bool function parameters: link_trbs, isoc
    and consumer.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Paul Zimmerman <Paul.Zimmerman@synopsys.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9a7138c29030..eb369a1723b1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1250,6 +1250,16 @@ struct xhci_dequeue_state {
 	int new_cycle_state;
 };
 
+enum xhci_ring_type {
+	TYPE_CTRL = 0,
+	TYPE_ISOC,
+	TYPE_BULK,
+	TYPE_INTR,
+	TYPE_STREAM,
+	TYPE_COMMAND,
+	TYPE_EVENT,
+};
+
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
 	union  xhci_trb		*enqueue;
@@ -1266,6 +1276,7 @@ struct xhci_ring {
 	 */
 	u32			cycle_state;
 	unsigned int		stream_id;
+	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 };
 

commit 8d3709f3dd41769338cc383bec23673fd1ce34e7
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Jan 27 16:19:15 2012 +0200

    usb: host: xhci: use __ffs() instead of hardcoding shift
    
    __ffs() can tell us which is the SEGMENT_SHIFT value
    to be used. This will prevent problems when users are
    too fast and don't pay attention to the need of fixing
    the Shift after changing TRBS_PER_SEGMENT.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0f4936956103..9a7138c29030 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1223,10 +1223,7 @@ union xhci_trb {
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
-/* SEGMENT_SHIFT should be log2(SEGMENT_SIZE).
- * Change this if you change TRBS_PER_SEGMENT!
- */
-#define SEGMENT_SHIFT		10
+#define SEGMENT_SHIFT		(__ffs(SEGMENT_SIZE))
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)

commit 4ee823b83bc9851743fab756c76b27d6a1e2472b
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Nov 14 18:00:01 2011 -0800

    USB/xHCI: Support device-initiated USB 3.0 resume.
    
    USB 3.0 hubs don't have a port suspend change bit (that bit is now
    reserved).  Instead, when a host-initiated resume finishes, the hub sets
    the port link state change bit.
    
    When a USB 3.0 device initiates remote wakeup, the parent hubs with
    their upstream links in U3 will pass the LFPS up the chain.  The first
    hub that has an upstream link in U0 (which may be the roothub) will
    reflect that LFPS back down the path to the device.
    
    However, the parent hubs in the resumed path will not set their link
    state change bit.  Instead, the device that initiated the resume has to
    send an asynchronous "Function Wake" Device Notification up to the host
    controller.  Therefore, we need a way to notify the USB core of a device
    resume without going through the normal hub URB completion method.
    
    First, make the xHCI roothub act like an external USB 3.0 hub and not
    pass up the port link state change bit when a device-initiated resume
    finishes.  Introduce a new xHCI bit field, port_remote_wakeup, so that
    we can tell the difference between a port coming out of the U3Exit state
    (host-initiated resume) and the RExit state (ending state of
    device-initiated resume).
    
    Since the USB core can't tell whether a port on a hub has resumed by
    looking at the Hub Status buffer, we need to introduce a bitfield,
    wakeup_bits, that indicates which ports have resumed.  When the xHCI
    driver notices a port finishing a device-initiated resume, we call into
    a new USB core function, usb_wakeup_notification(), that will set
    the right bit in wakeup_bits, and kick khubd for that hub.
    
    We also call usb_wakeup_notification() when the Function Wake Device
    Notification is received by the xHCI driver.  This covers the case where
    the link between the roothub and the first-tier hub is in U0, and the
    hub reflects the resume signaling back to the device without giving any
    indication it has done so until the device sends the Function Wake
    notification.
    
    Change the code in khubd that handles the remote wakeup to look at the
    state the USB core thinks the device is in, and handle the remote wakeup
    if the port's wakeup bit is set.
    
    This patch only takes care of the case where the device is attached
    directly to the roothub, or the USB 3.0 hub that is attached to the root
    hub is the device sending the Function Wake Device Notification (e.g.
    because a new USB device was attached).  The other cases will be covered
    in a second patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fb99c8379142..0f4936956103 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1344,6 +1344,7 @@ struct xhci_bus_state {
 	/* ports suspend status arrays - max 31 ports for USB2, 15 for USB3 */
 	u32			port_c_suspend;
 	u32			suspended_ports;
+	u32			port_remote_wakeup;
 	unsigned long		resume_done[USB_MAXCHILDREN];
 };
 

commit 71d85724bdd947a3b42a88d08af79f290a1a767b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 4 23:29:18 2012 +0100

    xhci: Properly handle COMP_2ND_BW_ERR
    
    I encountered a result of COMP_2ND_BW_ERR while improving how the pwc
    webcam driver handles not having the full usb1 bandwidth available to
    itself.
    
    I created the following test setup, a NEC xhci controller with a
    single TT USB 2 hub plugged into it, with a usb keyboard and a pwc webcam
    plugged into the usb2 hub. This caused the following to show up in dmesg
    when trying to stream from the pwc camera at its highest alt setting:
    
    xhci_hcd 0000:01:00.0: ERROR: unexpected command completion code 0x23.
    usb 6-2.1: Not enough bandwidth for altsetting 9
    
    And usb_set_interface returned -EINVAL, which caused my pwc code to not
    do the right thing as it expected -ENOSPC.
    
    This patch makes the xhci driver properly handle COMP_2ND_BW_ERR and makes
    usb_set_interface return -ENOSPC as expected.
    
    This should be backported to stable kernels as old as 2.6.32.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ecd2ad5d226d..fb99c8379142 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1033,7 +1033,6 @@ struct xhci_transfer_event {
 /* Invalid Stream ID Error */
 #define COMP_STRID_ERR	34
 /* Secondary Bandwidth Error - may be returned by a Configure Endpoint cmd */
-/* FIXME - check for this */
 #define COMP_2ND_BW_ERR	35
 /* Split Transaction Error */
 #define	COMP_SPLIT_ERR	36

commit 051031143544ff196d94927be8f384864fbca6a4
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Jun 28 15:50:19 2011 -0700

    Trivial: xhci: Fix copy-paste error.
    
    The xHCI driver will create an xhci_hcd structure, not an ehci_hci
    structure.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3c8fbd2772ea..ecd2ad5d226d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1356,7 +1356,7 @@ static inline unsigned int hcd_index(struct usb_hcd *hcd)
 		return 1;
 }
 
-/* There is one ehci_hci structure per controller */
+/* There is one xhci_hcd structure per controller */
 struct xhci_hcd {
 	struct usb_hcd *main_hcd;
 	struct usb_hcd *shared_hcd;

commit 0cc47d547d7a482434926331265b3713381b1e60
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 23 14:20:02 2011 -0700

    usb/xhci: remove CONFIG_PCI in xhci.c's probe function
    
    This removes the need of ifdefs within the init function and with it the
    headache about the correct clean without bus X but with bus/platform Y &
    Z.
    xhci-pci is only compiled if CONFIG_PCI is selected which can be
    de-selected now without trouble. For now the result is kinda useless
    because we have no other glue code. However, since nobody is using
    USB_ARCH_HAS_XHCI then it should not be an issue :)
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ad11c38afe85..3c8fbd2772ea 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1644,6 +1644,9 @@ void xhci_free_command(struct xhci_hcd *xhci,
 /* xHCI PCI glue */
 int xhci_register_pci(void);
 void xhci_unregister_pci(void);
+#else
+static inline int xhci_register_pci(void) { return 0; }
+static inline void xhci_unregister_pci(void) {}
 #endif
 
 /* xHCI host controller glue */

commit 552e0c4f12fef0ad1caf21d2b57ac3a2735edef3
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 23 14:20:01 2011 -0700

    usb/xhci: move xhci_gen_setup() away from -pci.
    
    xhci_gen_setup() is generic so it can be used to perform the bare xhci
    setup even on non-pci based platform. The typedef for the function
    pointer is moved into the headerfile
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4050656bffed..ad11c38afe85 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1647,6 +1647,7 @@ void xhci_unregister_pci(void);
 #endif
 
 /* xHCI host controller glue */
+typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
@@ -1654,6 +1655,7 @@ int xhci_init(struct usb_hcd *hcd);
 int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
+int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);
 
 #ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci);

commit 7e393a834b41001174a8fb3ae3bc23a749467760
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:54 2011 -0700

    xHCI: AMD isoc link TRB chain bit quirk
    
    Setting the chain (CH) bit in the link TRB of isochronous transfer rings
    is required by AMD 0.96 xHCI host controller to successfully transverse
    multi-TRB TD that span through different memory segments.
    
    When a Missed Service Error event occurs, if the chain bit is not set in
    the link TRB and the host skips TDs which just across a link TRB, the
    host may falsely recognize the link TRB as a normal TRB. You can see
    this may cause big trouble - the host does not jump to the right address
    which is pointed by the link TRB, but continue fetching the memory which
    is after the link TRB address, which may not even belong to the host,
    and the result cannot be predicted.
    
    This causes some big problems. Without the former patch I sent: "xHCI:
    prevent infinite loop when processing MSE event", the system may hang.
    With that patch applied, system does not hang, but the host still access
    wrong memory address and isoc transfer will fail. With this patch,
    isochronous transfer works as expected.
    
    This patch should be applied to kernels as old as 2.6.36, which was when
    the first isochronous support was added for the xHCI host controller.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e738466703a5..4050656bffed 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1462,6 +1462,7 @@ struct xhci_hcd {
 #define XHCI_BROKEN_MSI		(1 << 6)
 #define XHCI_RESET_ON_RESUME	(1 << 7)
 #define	XHCI_SW_BW_CHECKING	(1 << 8)
+#define XHCI_AMD_0x96_HOST	(1 << 9)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 65580b4321eb36f16ae8b5987bfa1bb948fc5112
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:52 2011 -0700

    xHCI: set USB2 hardware LPM
    
    If the device pass the USB2 software LPM and the host supports hardware
    LPM, enable hardware LPM for the device to let the host decide when to
    put the link into lower power state.
    
    If hardware LPM is enabled for a port and driver wants to put it into
    suspend, it must first disable hardware LPM, resume the port into U0,
    and then suspend the port.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b24c4fce457e..e738466703a5 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -367,7 +367,9 @@ struct xhci_op_regs {
 #define	PORT_L1S_SUCCESS	1
 #define	PORT_RWE		(1 << 3)
 #define	PORT_HIRD(p)		(((p) & 0xf) << 4)
+#define	PORT_HIRD_MASK		(0xf << 4)
 #define	PORT_L1DS(p)		(((p) & 0xff) << 8)
+#define	PORT_HLE		(1 << 16)
 
 /**
  * struct xhci_intr_reg - Interrupt Register Set
@@ -1677,6 +1679,8 @@ int xhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,
 		gfp_t mem_flags);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_set_usb2_hardware_lpm(struct usb_hcd *hcd,
+				struct usb_device *udev, int enable);
 int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
 			struct usb_tt *tt, gfp_t mem_flags);
 int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);

commit 9574323c39d1f8359a04843075d89c9f32d8b7e6
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:51 2011 -0700

    xHCI: test USB2 software LPM
    
    This patch tests USB2 software LPM for a USB2 LPM-capable device.
    
    When a lpm-capable device is addressed, if the host also supports software
    LPM, apply a test by putting the device into L1 state and resume it to see
    if the device can do L1 suspend/resume successfully.
    
    If the device fails to enter L1 or resume from L1 state, it may not
    function normally and usbcore may disconnect and re-enumerate it. In this
    case, store the device's Vid and Pid information, make sure the host will
    not test LPM for it twice.
    
    The test result is per device/host. Some devices claim to be lpm-capable,
    but fail to enter L1 or resume. So the test is necessary.
    
    The xHCI 1.0 errata has modified the USB2.0 LPM implementation. It redefines
    the HIRD field to BESL, and adds another register Port Hardware LPM Control
    (PORTHLPMC). However, this should not affect the LPM behavior on xHC which
    does not implement 1.0 errata.
    
    USB2.0 LPM errata defines a new bit BESL in the device's USB 2.0 extension
    descriptor. If the device reports it uses BESL, driver should use BESL
    instead of HIRD for it.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8673f985046e..b24c4fce457e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -272,6 +272,7 @@ struct xhci_op_regs {
  */
 #define PORT_PLS_MASK	(0xf << 5)
 #define XDEV_U0		(0x0 << 5)
+#define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
 #define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
@@ -362,7 +363,11 @@ struct xhci_op_regs {
 /* Bits 24:31 for port testing */
 
 /* USB2 Protocol PORTSPMSC */
-#define PORT_RWE	(1 << 0x3)
+#define	PORT_L1S_MASK		7
+#define	PORT_L1S_SUCCESS	1
+#define	PORT_RWE		(1 << 3)
+#define	PORT_HIRD(p)		(((p) & 0xf) << 4)
+#define	PORT_L1DS(p)		(((p) & 0xff) << 8)
 
 /**
  * struct xhci_intr_reg - Interrupt Register Set
@@ -1324,6 +1329,12 @@ struct s3_save {
 	u64	erst_dequeue;
 };
 
+/* Use for lpm */
+struct dev_info {
+	u32			dev_id;
+	struct	list_head	list;
+};
+
 struct xhci_bus_state {
 	unsigned long		bus_suspended;
 	unsigned long		next_statechange;
@@ -1387,6 +1398,8 @@ struct xhci_hcd {
 	struct xhci_erst	erst;
 	/* Scratchpad */
 	struct xhci_scratchpad  *scratchpad;
+	/* Store LPM test failed devices' information */
+	struct list_head	lpm_failed_devs;
 
 	/* slot enabling and address device helpers */
 	struct completion	addr_dev;
@@ -1663,6 +1676,7 @@ int xhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		gfp_t mem_flags);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_update_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
 			struct usb_tt *tt, gfp_t mem_flags);
 int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);

commit fc71ff7583b14347fa1cb592b698f088ecff36e3
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:51 2011 -0700

    xHCI: Check host USB2 LPM capability
    
    Check the host's USB2 LPM capability.
    
    USB2 software LPM support is optional for xHCI 0.96 hosts. xHCI 1.0 hosts
    should support software LPM, and may support hardware LPM.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fa921cbbe872..8673f985046e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1459,6 +1459,10 @@ struct xhci_hcd {
 	/* Array of pointers to USB 2.0 PORTSC registers */
 	__le32 __iomem		**usb2_ports;
 	unsigned int		num_usb2_ports;
+	/* support xHCI 0.96 spec USB2 software LPM */
+	unsigned		sw_lpm_support:1;
+	/* support xHCI 1.0 spec USB2 hardware LPM */
+	unsigned		hw_lpm_support:1;
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */

commit d2f52c9e585bbb1a3c164e02b8dcd0d996c67353
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:49 2011 -0700

    xHCI: test and clear RWC bit
    
    Introduce xhci_test_and_clear_bit() to clear RWC bit in PORTSC register.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 92eba69b9239..fa921cbbe872 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1719,6 +1719,8 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 				int port_id, u32 link_state);
+void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
+				int port_id, u32 port_bit);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);

commit c9682dffceb4bb3bdf6df4c0c87c4b887b03f5b7
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:48 2011 -0700

    xHCI: set link state
    
    Introduce xhci_set_link_state() to remove redundant codes.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2882074eb2c8..92eba69b9239 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1717,6 +1717,8 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 
 /* xHCI roothub code */
+void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
+				int port_id, u32 link_state);
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);

commit 2b69899934c63b7b9432568584fb4c4a2924f40c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Sep 13 16:41:13 2011 -0700

    xhci: USB 3.0 BW checking.
    
    The Intel Panther Point xHCI host tracks SuperSpeed endpoints in a
    different way than USB 2.0/1.1 endpoints.  The bandwidth interval tables
    are not used, and instead the bandwidth is calculated in a very simple
    way.  Bandwidth for SuperSpeed endpoints is tracked individually in each
    direction, since each direction has the full USB 3.0 bandwidth available.
    10% of the bus bandwidth is reserved for non-periodic transfers.
    
    This checking would be more complex if we had USB 3.0 LPM enabled, because
    an additional latency for isochronous ping times need to be taken into
    account.  However, we don't have USB 3.0 LPM support in Linux yet.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 752a500f8695..2882074eb2c8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -799,6 +799,7 @@ struct xhci_bw_info {
 /* Percentage of bus bandwidth reserved for non-periodic transfers */
 #define FS_BW_RESERVED		10
 #define HS_BW_RESERVED		20
+#define SS_BW_RESERVED		10
 
 struct xhci_virt_ep {
 	struct xhci_ring		*ring;
@@ -869,6 +870,8 @@ struct xhci_interval_bw_table {
 	struct xhci_interval_bw	interval_bw[XHCI_MAX_INTERVAL];
 	/* Includes reserved bandwidth for async endpoints */
 	unsigned int		bw_used;
+	unsigned int		ss_bw_in;
+	unsigned int		ss_bw_out;
 };
 
 

commit 170c026347c867a71e27713b98c58b266146c468
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Sep 13 16:41:12 2011 -0700

    xhci: Fix mult base in endpoint bandwidth info.
    
    The "Mult" bits in the SuperSpeed Endpoint Companion Descriptor are
    zero-based, and the xHCI host controller wants them to be zero-based in
    the input context.  However, for the bandwidth math, we want them to be
    one-based.  Fix this.
    
    Fix the documentation about the endpoint bandwidth mult variable in the
    xhci.h file, which says it is zero-based.  Also fix the documentation
    about num_packets, which is also one-based, not zero-based.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 13f1c23ed19d..752a500f8695 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -747,8 +747,9 @@ struct xhci_stream_info {
  * (DMI) also limits the total bandwidth (across all domains) that can be used.
  */
 struct xhci_bw_info {
+	/* ep_interval is zero-based */
 	unsigned int		ep_interval;
-	/* mult and num_packets are zero-based */
+	/* mult and num_packets are one-based */
 	unsigned int		mult;
 	unsigned int		num_packets;
 	unsigned int		max_packet_size;

commit d78265992425ccb5753db9c56d9703c91b963e4b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Sep 13 16:41:10 2011 -0700

    usb/xhci: ignore xhci version while checking for the link quirk
    
    instead of reading the xhci interface version each time _even_ if the
    quirk is not required, simply check if the quirk flag is set. This flag
    is only set of the module parameter is set and here is where I moved the
    version check to.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b224b20b0784..13f1c23ed19d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1526,9 +1526,7 @@ static inline void xhci_write_64(struct xhci_hcd *xhci,
 
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 {
-	u32 temp = xhci_readl(xhci, &xhci->cap_regs->hc_capbase);
-	return ((HC_VERSION(temp) == 0x95) &&
-			(xhci->quirks & XHCI_LINK_TRB_QUIRK));
+	return xhci->quirks & XHCI_LINK_TRB_QUIRK;
 }
 
 /* xHCI debugging */

commit c29eea621900f18287d50519f72cb9113746d75a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:52 2011 -0700

    xhci: Implement HS/FS/LS bandwidth checking.
    
    Now that we have a bandwidth interval table per root port or TT that
    describes the endpoint bandwidth information, we can finally use it to
    check whether the bus bandwidth is oversubscribed for a new device
    configuration/alternate interface setting.
    
    The complication for this algorithm is that the bit of hardware logic that
    creates the bus schedule is only 12-bit logic.  In order to make sure it
    can represent the maximum bus bandwidth in 12 bits, it has to convert the
    endpoint max packet size and max esit payload into "blocks" (basically a
    less-precise representation).  The block size for each speed of device is
    different, aside from low speed and full speed.  In order to make sure we
    don't allow a setup where the scheduler might fail, we also have to do the
    bandwidth checking in blocks.
    
    After checking that the endpoints fit in the schedule, we store the
    bandwidth used for this root port or TT.  If this is a FS/LS device under
    an external HS hub, we also update the TT bandwidth and the root port
    bandwidth (if this is a newly activated or deactivated TT).
    
    I won't go into the details of the algorithm, as it's pretty well
    documented in the comments.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 050f07b1e790..b224b20b0784 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -756,6 +756,49 @@ struct xhci_bw_info {
 	unsigned int		type;
 };
 
+/* "Block" sizes in bytes the hardware uses for different device speeds.
+ * The logic in this part of the hardware limits the number of bits the hardware
+ * can use, so must represent bandwidth in a less precise manner to mimic what
+ * the scheduler hardware computes.
+ */
+#define	FS_BLOCK	1
+#define	HS_BLOCK	4
+#define	SS_BLOCK	16
+#define	DMI_BLOCK	32
+
+/* Each device speed has a protocol overhead (CRC, bit stuffing, etc) associated
+ * with each byte transferred.  SuperSpeed devices have an initial overhead to
+ * set up bursts.  These are in blocks, see above.  LS overhead has already been
+ * translated into FS blocks.
+ */
+#define DMI_OVERHEAD 8
+#define DMI_OVERHEAD_BURST 4
+#define SS_OVERHEAD 8
+#define SS_OVERHEAD_BURST 32
+#define HS_OVERHEAD 26
+#define FS_OVERHEAD 20
+#define LS_OVERHEAD 128
+/* The TTs need to claim roughly twice as much bandwidth (94 bytes per
+ * microframe ~= 24Mbps) of the HS bus as the devices can actually use because
+ * of overhead associated with split transfers crossing microframe boundaries.
+ * 31 blocks is pure protocol overhead.
+ */
+#define TT_HS_OVERHEAD (31 + 94)
+#define TT_DMI_OVERHEAD (25 + 12)
+
+/* Bandwidth limits in blocks */
+#define FS_BW_LIMIT		1285
+#define TT_BW_LIMIT		1320
+#define HS_BW_LIMIT		1607
+#define SS_BW_LIMIT_IN		3906
+#define DMI_BW_LIMIT_IN		3906
+#define SS_BW_LIMIT_OUT		3906
+#define DMI_BW_LIMIT_OUT	3906
+
+/* Percentage of bus bandwidth reserved for non-periodic transfers */
+#define FS_BW_RESERVED		10
+#define HS_BW_RESERVED		20
+
 struct xhci_virt_ep {
 	struct xhci_ring		*ring;
 	/* Related to endpoints that are configured to use stream IDs only */
@@ -823,6 +866,8 @@ struct xhci_interval_bw {
 struct xhci_interval_bw_table {
 	unsigned int		interval0_esit_payload;
 	struct xhci_interval_bw	interval_bw[XHCI_MAX_INTERVAL];
+	/* Includes reserved bandwidth for async endpoints */
+	unsigned int		bw_used;
 };
 
 
@@ -1397,6 +1442,7 @@ struct xhci_hcd {
 #define XHCI_EP_LIMIT_QUIRK	(1 << 5)
 #define XHCI_BROKEN_MSI		(1 << 6)
 #define XHCI_RESET_ON_RESUME	(1 << 7)
+#define	XHCI_SW_BW_CHECKING	(1 << 8)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit 2e27980e6eb78114c4ecbaad1ba71836e3887d18
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:50 2011 -0700

    xhci: Track interval bandwidth tables per port/TT.
    
    In order to update the root port or TT's bandwidth interval table, we will
    need to keep track of a list of endpoints, per interval.  That way we can
    easily know the new largest max packet size when we have to remove an
    endpoint.
    
    Add an endpoint list for each root port or TT structure, sorted by
    endpoint max packet size.  Insert new endpoints into the list such that
    the head of the list always has the endpoint with the greatest max packet
    size.  Only insert endpoints and update the interval table with new
    information when those endpoints are periodic.
    
    Make sure to update the number of active TTs when we add or drop periodic
    endpoints.  A TT is only considered active if it has one or more periodic
    endpoints attached (control and bulk are best effort, and counted in the
    20% reserved on the high speed bus).  If the number of active endpoints
    for a TT was zero, and it's now non-zero, increment the number of active
    TTs for the rootport.  If the number of active endpoints was non-zero, and
    it's now zero, decrement the number of active TTs.
    
    We have to be careful when we're checking the bandwidth for a new
    configuration/alt setting.  If we don't have enough bandwidth, we need to
    be able to "roll back" the bandwidth information stored in the endpoint
    and the root port/TT interval bandwidth table.  We can't just create a
    copy of the interval bandwidth table, modify it, and check the bandwidth
    with the copy because we have lists of endpoints and entries can't be on
    more than one list.  Instead, we copy the old endpoint bandwidth
    information, and use it to revert the interval table when the bandwidth
    check fails.
    
    We don't check the bandwidth after endpoints are dropped from the interval
    table when a device is reset or freed after a disconnect, because having
    endpoints use less bandwidth should not push the bandwidth usage over the
    limits.  Besides which, we can't fail a device disconnect.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index af15b903e061..050f07b1e790 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -797,7 +797,9 @@ struct xhci_virt_ep {
 	 * process the missed tds on the endpoint ring.
 	 */
 	bool			skip;
+	/* Bandwidth checking storage */
 	struct xhci_bw_info	bw_info;
+	struct list_head	bw_endpoint_list;
 };
 
 enum xhci_overhead_type {
@@ -808,6 +810,10 @@ enum xhci_overhead_type {
 
 struct xhci_interval_bw {
 	unsigned int		num_packets;
+	/* Sorted by max packet size.
+	 * Head of the list is the greatest max packet size.
+	 */
+	struct list_head	endpoints;
 	/* How many endpoints of each speed are present. */
 	unsigned int		overhead[3];
 };
@@ -1511,6 +1517,15 @@ unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
 unsigned int xhci_last_valid_endpoint(u32 added_ctxs);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
+void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,
+		struct xhci_bw_info *ep_bw,
+		struct xhci_interval_bw_table *bw_table,
+		struct usb_device *udev,
+		struct xhci_virt_ep *virt_ep,
+		struct xhci_tt_bw_info *tt_info);
+void xhci_update_tt_active_eps(struct xhci_hcd *xhci,
+		struct xhci_virt_device *virt_dev,
+		int old_active_eps);
 void xhci_clear_endpoint_bw_info(struct xhci_bw_info *bw_info);
 void xhci_update_bw_info(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *in_ctx,

commit 9af5d71d8e1fc404ad2ac1b568dafa1a2f9b3be2
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:48 2011 -0700

    xhci: Store endpoint bandwidth information.
    
    In the upcoming patches, we'll use some stored endpoint information to
    make software keep track of the worst-case bandwidth schedule.  We need to
    store several variables associated with each periodic endpoint:
     - the type of endpoint
     - Max Packet Size
     - Mult
     - Max ESIT payload
     - Max Burst Size (aka number of packets, stored in one-based form)
     - the endpoint interval (normalized to powers of 2 microframes)
    
    All this information is available to the hardware, and stored in its
    device output context.  However, we need to ensure that the new
    information is stored before the xHCI driver drops the xhci->lock to wait
    on the Configure Endpoint command, so that another driver requesting a
    configuration or alt setting change will see the update.  The Configure
    Endpoint command will never fail on the hardware that needs this software
    bandwidth checking (assuming the slot is enabled and the flags are set
    properly), so updating the endpoint info before the command completes
    should be fine.
    
    Until we add in the bandwidth checking code, just update the endpoint
    information after the Configure Endpoint command completes, and after a
    Reset Device command completes.  Don't bother to clear the endpoint
    bandwidth info when a device is being freed, since the xhci_virt_ep is
    just going to be freed anyway.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index eee47c8a6ee8..af15b903e061 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -611,11 +611,13 @@ struct xhci_ep_ctx {
 #define EP_STATE_ERROR		4
 /* Mult - Max number of burtst within an interval, in EP companion desc. */
 #define EP_MULT(p)		(((p) & 0x3) << 8)
+#define CTX_TO_EP_MULT(p)	(((p) >> 8) & 0x3)
 /* bits 10:14 are Max Primary Streams */
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
 #define EP_INTERVAL(p)		(((p) & 0xff) << 16)
 #define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
+#define CTX_TO_EP_INTERVAL(p)	(((p) >> 16) & 0xff)
 #define EP_MAXPSTREAMS_MASK	(0x1f << 10)
 #define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
 /* Endpoint is set up with a Linear Stream Array (vs. Secondary Stream Array) */
@@ -640,6 +642,7 @@ struct xhci_ep_ctx {
 /* bit 6 reserved */
 /* bit 7 is Host Initiate Disable - for disabling stream selection */
 #define MAX_BURST(p)	(((p)&0xff) << 8)
+#define CTX_TO_MAX_BURST(p)	(((p) >> 8) & 0xff)
 #define MAX_PACKET(p)	(((p)&0xffff) << 16)
 #define MAX_PACKET_MASK		(0xffff << 16)
 #define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
@@ -652,6 +655,7 @@ struct xhci_ep_ctx {
 /* tx_info bitmasks */
 #define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
 #define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
+#define CTX_TO_MAX_ESIT_PAYLOAD(p)	(((p) >> 16) & 0xffff)
 
 /* deq bitmasks */
 #define EP_CTX_CYCLE_MASK		(1 << 0)
@@ -670,6 +674,11 @@ struct xhci_input_control_ctx {
 	__le32	rsvd2[6];
 };
 
+#define	EP_IS_ADDED(ctrl_ctx, i) \
+	(le32_to_cpu(ctrl_ctx->add_flags) & (1 << (i + 1)))
+#define	EP_IS_DROPPED(ctrl_ctx, i)       \
+	(le32_to_cpu(ctrl_ctx->drop_flags) & (1 << (i + 1)))
+
 /* Represents everything that is needed to issue a command on the command ring.
  * It's useful to pre-allocate these for commands that cannot fail due to
  * out-of-memory errors, like freeing streams.
@@ -731,6 +740,22 @@ struct xhci_stream_info {
 #define	SMALL_STREAM_ARRAY_SIZE		256
 #define	MEDIUM_STREAM_ARRAY_SIZE	1024
 
+/* Some Intel xHCI host controllers need software to keep track of the bus
+ * bandwidth.  Keep track of endpoint info here.  Each root port is allocated
+ * the full bus bandwidth.  We must also treat TTs (including each port under a
+ * multi-TT hub) as a separate bandwidth domain.  The direct memory interface
+ * (DMI) also limits the total bandwidth (across all domains) that can be used.
+ */
+struct xhci_bw_info {
+	unsigned int		ep_interval;
+	/* mult and num_packets are zero-based */
+	unsigned int		mult;
+	unsigned int		num_packets;
+	unsigned int		max_packet_size;
+	unsigned int		max_esit_payload;
+	unsigned int		type;
+};
+
 struct xhci_virt_ep {
 	struct xhci_ring		*ring;
 	/* Related to endpoints that are configured to use stream IDs only */
@@ -772,6 +797,7 @@ struct xhci_virt_ep {
 	 * process the missed tds on the endpoint ring.
 	 */
 	bool			skip;
+	struct xhci_bw_info	bw_info;
 };
 
 enum xhci_overhead_type {
@@ -1485,6 +1511,11 @@ unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
 unsigned int xhci_last_valid_endpoint(u32 added_ctxs);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
+void xhci_clear_endpoint_bw_info(struct xhci_bw_info *bw_info);
+void xhci_update_bw_info(struct xhci_hcd *xhci,
+		struct xhci_container_ctx *in_ctx,
+		struct xhci_input_control_ctx *ctrl_ctx,
+		struct xhci_virt_device *virt_dev);
 void xhci_endpoint_copy(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *in_ctx,
 		struct xhci_container_ctx *out_ctx,

commit 839c817ce67178ca3c7c7ad534c571bba1e69ebe
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:47 2011 -0700

    xhci: Store information about roothubs and TTs.
    
    For upcoming patches, we need to keep information about the bandwidth
    domains under the xHCI host.  Each root port is a separate primary
    bandwidth domain, and each high speed hub's TT (and potentially each port
    on a multi-TT hub) is a secondary bandwidth domain.
    
    If the table were in text form, it would look a bit like this:
    
    EP Interval     Sum of Number   Largest Max     Max Packet
                    of Packets      Packet Size     Overhead
            0          N               mps            overhead
    ...
            15         N               mps            overhead
    
    Overhead is the maximum packet overhead (for bit stuffing, CRC, protocol
    overhead, etc) for all the endpoints in this interval.  Devices with
    different speeds have different max packet overhead.  For example, if
    there is a low speed and a full speed endpoint that both have an interval
    of 3, we would use the higher overhead (the low speed overhead).  Interval
    0 is a bit special, since we really just want to know the sum of the max
    ESIT payloads instead of the largest max packet size.  That's stored in
    the interval0_esit_payload variable.  For root ports, we also need to keep
    track of the number of active TTs.
    
    For each root port, and each TT under a root port, store some information
    about the bandwidth consumption.  Dynamically allocate an array of root
    port bandwidth information for the number of root ports on the xHCI host.
    Each root port stores a list of TTs under the root port.  A single TT hub
    only has one entry in the list, but a multi-TT hub will have an entry per
    port.
    
    When the USB core says that a USB device is a hub, create one or more
    entries in the root port TT list for the hub.  When a device is deleted,
    and it is a hub, search through the root port TT list and delete all
    TT entries for the hub.  Keep track of which TT entry is associated with a
    device under a TT.
    
    LS/FS devices attached directly to the root port will have usb_device->tt
    set to the roothub.  Ignore that, and treat it like a primary bandwidth
    domain, since there isn't really a high speed bus between the roothub and
    the host.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ec4817003a56..eee47c8a6ee8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -774,6 +774,26 @@ struct xhci_virt_ep {
 	bool			skip;
 };
 
+enum xhci_overhead_type {
+	LS_OVERHEAD_TYPE = 0,
+	FS_OVERHEAD_TYPE,
+	HS_OVERHEAD_TYPE,
+};
+
+struct xhci_interval_bw {
+	unsigned int		num_packets;
+	/* How many endpoints of each speed are present. */
+	unsigned int		overhead[3];
+};
+
+#define	XHCI_MAX_INTERVAL	16
+
+struct xhci_interval_bw_table {
+	unsigned int		interval0_esit_payload;
+	struct xhci_interval_bw	interval_bw[XHCI_MAX_INTERVAL];
+};
+
+
 struct xhci_virt_device {
 	struct usb_device		*udev;
 	/*
@@ -800,6 +820,30 @@ struct xhci_virt_device {
 	struct list_head		cmd_list;
 	u8				fake_port;
 	u8				real_port;
+	struct xhci_interval_bw_table	*bw_table;
+	struct xhci_tt_bw_info		*tt_info;
+};
+
+/*
+ * For each roothub, keep track of the bandwidth information for each periodic
+ * interval.
+ *
+ * If a high speed hub is attached to the roothub, each TT associated with that
+ * hub is a separate bandwidth domain.  The interval information for the
+ * endpoints on the devices under that TT will appear in the TT structure.
+ */
+struct xhci_root_port_bw_info {
+	struct list_head		tts;
+	unsigned int			num_active_tts;
+	struct xhci_interval_bw_table	bw_table;
+};
+
+struct xhci_tt_bw_info {
+	struct list_head		tt_list;
+	int				slot_id;
+	int				ttport;
+	struct xhci_interval_bw_table	bw_table;
+	int				active_eps;
 };
 
 
@@ -1268,6 +1312,8 @@ struct xhci_hcd {
 	int slot_id;
 	/* Internal mirror of the HW's dcbaa */
 	struct xhci_virt_device	*devs[MAX_HC_SLOTS];
+	/* For keeping track of bandwidth domains per roothub. */
+	struct xhci_root_port_bw_info	*rh_bw;
 
 	/* DMA pools */
 	struct dma_pool	*device_pool;
@@ -1508,6 +1554,10 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd);
 irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_alloc_tt_info(struct xhci_hcd *xhci,
+		struct xhci_virt_device *virt_dev,
+		struct usb_device *hdev,
+		struct usb_tt *tt, gfp_t mem_flags);
 int xhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		unsigned int num_streams, gfp_t mem_flags);

commit 66381755442189bbeb15f1a51b1e0059327d84ed
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:45 2011 -0700

    xhci: Store the "real" root port number.
    
    Since the xHCI driver now has split USB2/USB3 roothubs, devices under each
    roothub can have duplicate "fake" port numbers.  For the next set of
    patches, we need to keep track of the "real" port number that the xHCI
    host uses to index into the port status arrays.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bfb3fab20795..ec4817003a56 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -799,6 +799,7 @@ struct xhci_virt_device {
 	u32				cmd_status;
 	struct list_head		cmd_list;
 	u8				fake_port;
+	u8				real_port;
 };
 
 

commit fe30182c2553f491e5dc12074c8e52163d3bfbc7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 2 11:05:41 2011 -0700

    xhci: Rename virt_dev->port to fake_port.
    
    The "port" field in xhci_virt_dev stores the port number associated with
    one of the two xHCI split roothubs, not the unique port number the xHCI
    hardware uses.  Since we'll need to store the real hardware port number in
    future patches, rename this field to "fake_port".
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cae8e23308bf..bfb3fab20795 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -798,7 +798,7 @@ struct xhci_virt_device {
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
 	struct list_head		cmd_list;
-	u8				port;
+	u8				fake_port;
 };
 
 

commit f549953c15deab4c54708b39af86d4edecc6cddc
Merge: f0deb97ab13a e04f5f7e4230
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 23:08:32 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (115 commits)
      EHCI: fix direction handling for interrupt data toggles
      USB: serial: add IDs for WinChipHead USB->RS232 adapter
      USB: OHCI: fix another regression for NVIDIA controllers
      usb: gadget: m66592-udc: add pullup function
      usb: gadget: m66592-udc: add function for external controller
      usb: gadget: r8a66597-udc: add pullup function
      usb: renesas_usbhs: support multi driver
      usb: renesas_usbhs: inaccessible pipe is not an error
      usb: renesas_usbhs: care buff alignment when dma handler
      USB: PL2303: correctly handle baudrates above 115200
      usb: r8a66597-hcd: fixup USB_PORT_STAT_C_SUSPEND shift
      usb: renesas_usbhs: compile/config are rescued
      usb: renesas_usbhs: fixup comment-out
      usb: update email address in ohci-sh and r8a66597-hcd
      usb: r8a66597-hcd: add function for external controller
      EHCI: only power off port if over-current is active
      USB: mon: Allow to use usbmon without debugfs
      USB: EHCI: go back to using the system clock for QH unlinks
      ehci: add pci quirk for Ordissimo and RM Slate 100 too
      ehci: refactor pci quirk to use standard dmi_check_system method
      ...
    
    Fix up trivial conflicts in Documentation/feature-removal-schedule.txt

commit c877b3b2ad5cb9d4fe523c5496185cc328ff3ae9
Author: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Date:   Wed Jun 15 23:47:21 2011 +0200

    xhci: Add reset on resume quirk for asrock p67 host
    
    The asrock p67 xhci controller completely dies on resume, add a
    quirk for this, to bring the host back online after a suspend.
    
    This should be backported to stable kernels as old as 2.6.37.
    
    Signed-off-by: Maarten Lankhorst <m.b.lankhorst@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ba90af1c34b4..d8bbf5ccb10d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1310,6 +1310,7 @@ struct xhci_hcd {
  */
 #define XHCI_EP_LIMIT_QUIRK	(1 << 5)
 #define XHCI_BROKEN_MSI		(1 << 6)
+#define XHCI_RESET_ON_RESUME	(1 << 7)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit f6ba6fe2d913da6707a71a413d6ec8ae98d6ce18
Author: Alex He <alex.he@amd.com>
Date:   Wed Jun 8 18:34:06 2011 +0800

    xHCI 1.0: Incompatible Device Error
    
    It is one new TRB Completion Code for the xHCI spec v1.0.
    Asserted if the xHC detects a problem with a device that does not allow it to
    be successfully accessed, e.g. due to a device compliance or compatibility
    problem. This error may be returned by any command or transfer, and is fatal
    as far as the Slot is concerned. Return -EPROTO by urb->status or frame->status
    of ISOC for transfer case. And return -ENODEV for configure endpoint command,
    evaluate context command and address device command if there is an incompatible
    Device Error. The error codes will be sent back to the USB core to decide how
    to do. It's unnecessary for other commands because after the three commands run
    successfully means that the device has been accepted.
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7d1ea3bf5e1f..ba90af1c34b4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -874,6 +874,8 @@ struct xhci_transfer_event {
 #define COMP_PING_ERR	20
 /* Event Ring is full */
 #define COMP_ER_FULL	21
+/* Incompatible Device Error */
+#define COMP_DEV_ERR	22
 /* Missed Service Error - HC couldn't service an isoc ep within interval */
 #define COMP_MISSED_INT	23
 /* Successfully stopped command ring */

commit dcc854579059ff9633db4dc41c681371d22f794e
Merge: e73a9891b3a1 2c53b436a308
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 14 06:51:10 2011 -0700

    Merge 3.0-rc2 into usb-linus as it's needed by some USB patches
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f5182b4155b9d686c5540a6822486400e34ddd98
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jun 2 11:33:02 2011 -0700

    xhci: Disable MSI for some Fresco Logic hosts.
    
    Some Fresco Logic hosts, including those found in the AUAU N533V laptop,
    advertise MSI, but fail to actually generate MSI interrupts.  Add a new
    xHCI quirk to skip MSI enabling for the Fresco Logic host controllers.
    Fresco Logic confirms that all chips with PCI vendor ID 0x1b73 and device
    ID 0x1000, regardless of PCI revision ID, do not support MSI.
    
    This should be backported to stable kernels as far back as 2.6.36, which
    was the first kernel to support MSI on xHCI hosts.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Sergey Galanov <sergey.e.galanov@gmail.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bbc1d9afb49c..7d1ea3bf5e1f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1307,6 +1307,7 @@ struct xhci_hcd {
  * commands.
  */
 #define XHCI_EP_LIMIT_QUIRK	(1 << 5)
+#define XHCI_BROKEN_MSI		(1 << 6)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */

commit e2b0217715c6d10379d94bdfe5560af96eecbb7c
Author: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Date:   Wed Jun 1 23:27:49 2011 +0200

    xhci: Add defines for hardcoded slot states
    
    This needs to be added to the stable trees back to 2.6.34 to support an
    upcoming bug fix.
    
    Signed-off-by: Maarten Lankhorst <m.b.lankhorst@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ac0196e7fcf1..bbc1d9afb49c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -560,6 +560,11 @@ struct xhci_slot_ctx {
 #define SLOT_STATE	(0x1f << 27)
 #define GET_SLOT_STATE(p)	(((p) & (0x1f << 27)) >> 27)
 
+#define SLOT_STATE_DISABLED	0
+#define SLOT_STATE_ENABLED	SLOT_STATE_DISABLED
+#define SLOT_STATE_DEFAULT	1
+#define SLOT_STATE_ADDRESSED	2
+#define SLOT_STATE_CONFIGURED	3
 
 /**
  * struct xhci_ep_ctx

commit f5960b698eb50a39fce1a066dc19a6a5a1148e16
Author: Matt Evans <matt@ozlabs.org>
Date:   Wed Jun 1 10:22:55 2011 +1000

    xhci: Remove some unnecessary casts and tidy some endian swap code
    
    Some of the recently-added cpu_to_leXX and leXX_to_cpu made things somewhat
    messy; this patch neatens some of these areas, removing unnecessary casts
    in those parts also.  In some places (where Y & Z are constants) a
    comparison of (leXX_to_cpu(X) & Y) == Z has been replaced with
    (X & cpu_to_leXX(Y)) == cpu_to_leXX(Z).  The endian reversal of the
    constants should wash out at compile time.
    
    Signed-off-by: Matt Evans <matt@ozlabs.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ac0196e7fcf1..f9098a24d38b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1065,6 +1065,13 @@ union xhci_trb {
 /* Get NEC firmware revision. */
 #define	TRB_NEC_GET_FW		49
 
+#define TRB_TYPE_LINK(x)	(((x) & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK))
+/* Above, but for __le32 types -- can avoid work by swapping constants: */
+#define TRB_TYPE_LINK_LE32(x)	(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \
+				 cpu_to_le32(TRB_TYPE(TRB_LINK)))
+#define TRB_TYPE_NOOP_LE32(x)	(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \
+				 cpu_to_le32(TRB_TYPE(TRB_TR_NOOP)))
+
 #define NEC_FW_MINOR(p)		(((p) >> 0) & 0xff)
 #define NEC_FW_MAJOR(p)		(((p) >> 8) & 0xff)
 

commit 2cf95c18d5069e13c02a8667d91e064df8e17e09
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 11 16:14:58 2011 -0700

    Intel xhci: Limit number of active endpoints to 64.
    
    The Panther Point chipset has an xHCI host controller that has a limit to
    the number of active endpoints it can handle.  Ideally, it would signal
    that it can't handle anymore endpoints by returning a Resource Error for
    the Configure Endpoint command, but they don't.  Instead it needs software
    to keep track of the number of active endpoints, across configure endpoint
    commands, reset device commands, disable slot commands, and address device
    commands.
    
    Add a new endpoint context counter, xhci_hcd->num_active_eps, and use it
    to track the number of endpoints the xHC has active.  This gets a little
    tricky, because commands to change the number of active endpoints can
    fail.  This patch adds a new xHCI quirk for these Intel hosts, and the new
    code should not have any effect on other xHCI host controllers.
    
    Fail a new device allocation if we don't have room for the new default
    control endpoint.  Use the endpoint ring pointers to determine what
    endpoints were active before a Reset Device command or a Disable Slot
    command, and drop those once the command completes.
    
    Fail a configure endpoint command if it would add too many new endpoints.
    We have to be a bit over zealous here, and only count the number of new
    endpoints to be added, without subtracting the number of dropped
    endpoints.  That's because a second configure endpoint command for a
    different device could sneak in before we know if the first command is
    completed.  If the first command dropped resources, the host controller
    fails the command for some reason, and we're nearing the limit of
    endpoints, we could end up oversubscribing the host.
    
    To fix this race condition, when evaluating whether a configure endpoint
    command will fix in our bandwidth budget, only add the new endpoints to
    xhci->num_active_eps, and don't subtract the dropped endpoints.  Ignore
    changed endpoints (ones that are dropped and then re-added), as that
    shouldn't effect the host's endpoint resources.  When the configure
    endpoint command completes, subtract off the dropped endpoints.
    
    This may mean some configuration changes may temporarily fail, but it's
    always better to under-subscribe than over-subscribe resources.
    
    (Originally my plan had been to push the resource allocation down into the
    ring allocation functions.  However, that would cause us to allocate
    unnecessary resources when endpoints were changed, because the xHCI driver
    allocates a new ring for the changed endpoint, and only deletes the old
    ring once the Configure Endpoint command succeeds.  A further complication
    would have been dealing with the per-device endpoint ring cache.)
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5cfeb8614b87..ac0196e7fcf1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1292,6 +1292,18 @@ struct xhci_hcd {
 #define XHCI_NEC_HOST		(1 << 2)
 #define XHCI_AMD_PLL_FIX	(1 << 3)
 #define XHCI_SPURIOUS_SUCCESS	(1 << 4)
+/*
+ * Certain Intel host controllers have a limit to the number of endpoint
+ * contexts they can handle.  Ideally, they would signal that they can't handle
+ * anymore endpoint contexts by returning a Resource Error for the Configure
+ * Endpoint command, but they don't.  Instead they expect software to keep track
+ * of the number of active endpoints for them, across configure endpoint
+ * commands, reset device commands, disable slot commands, and address device
+ * commands.
+ */
+#define XHCI_EP_LIMIT_QUIRK	(1 << 5)
+	unsigned int		num_active_eps;
+	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
 	struct xhci_bus_state   bus_state[2];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
@@ -1435,6 +1447,8 @@ void xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,
 void xhci_setup_no_streams_ep_input_ctx(struct xhci_hcd *xhci,
 		struct xhci_ep_ctx *ep_ctx,
 		struct xhci_virt_ep *ep);
+void xhci_free_device_endpoint_resources(struct xhci_hcd *xhci,
+	struct xhci_virt_device *virt_dev, bool drop_control_ep);
 struct xhci_ring *xhci_dma_to_transfer_ring(
 		struct xhci_virt_ep *ep,
 		u64 address);

commit ad808333d8201d53075a11bc8dd83b81f3d68f0b
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 25 10:43:56 2011 -0700

    Intel xhci: Ignore spurious successful event.
    
    The xHCI host controller in the Panther Point chipset sometimes produces
    spurious events on the event ring.  If it receives a short packet, it
    first puts a Transfer Event with a short transfer completion code on the
    event ring.  Then it puts a Transfer Event with a successful completion
    code on the ring for the same TD.  The xHCI driver correctly processes the
    short transfer completion code, gives the URB back to the driver, and then
    prints a warning in dmesg about the spurious event.  These warning
    messages really fill up dmesg when an HD webcam is plugged into xHCI.
    
    This spurious successful event behavior isn't technically disallowed by
    the xHCI specification, so make the xHCI driver just ignore the spurious
    completion event.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0772a8cfea23..5cfeb8614b87 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1123,6 +1123,7 @@ struct xhci_ring {
 	 */
 	u32			cycle_state;
 	unsigned int		stream_id;
+	bool			last_td_was_short;
 };
 
 struct xhci_erst_entry {
@@ -1290,6 +1291,7 @@ struct xhci_hcd {
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
 #define XHCI_AMD_PLL_FIX	(1 << 3)
+#define XHCI_SPURIOUS_SUCCESS	(1 << 4)
 	/* There are two roothubs to keep track of bus suspend info for */
 	struct xhci_bus_state   bus_state[2];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */

commit f444ff27e9b8c953eef49da65c649fdcd202165a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Apr 5 15:53:47 2011 -0700

    xhci: STFU: Be quieter during URB submission and completion.
    
    Unsurprisingly, URBs get submitted and completed a lot in the xHCI
    driver.  If we have to print 10 lines of debug for every URB submitted
    or completed, then that can cause the whole system to stay in the
    interrupt handler too long, and can cause Missed Service completion
    codes for isochronous transfers.
    
    Cut down the debugging in the URB submission and completion paths:
     - Don't squawk about successful transfers, only unsuccessful ones.
     - Only print the number of bytes transferred if this was a short
       transfer.
     - Don't print the endpoint index for successful transfers (will add
       more debug to failed transfers to show endpoint index there later).
     - Stop printing MMIO writes.  This debugging shows up when the endpoint
       doorbell is rung a to start a transfer (basically for every URB).
     - Don't print out the ring enqueue and dequeue pointers
     - Stop printing when we're pointing to a link TRB.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e12db7cfb9bb..0772a8cfea23 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1338,9 +1338,6 @@ static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
 static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __le32 __iomem *regs)
 {
-	xhci_dbg(xhci,
-			"`MEM_WRITE_DWORD(3'b000, 32'h%p, 32'h%0x, 4'hf);\n",
-			regs, val);
 	writel(val, regs);
 }
 
@@ -1368,9 +1365,6 @@ static inline void xhci_write_64(struct xhci_hcd *xhci,
 	u32 val_lo = lower_32_bits(val);
 	u32 val_hi = upper_32_bits(val);
 
-	xhci_dbg(xhci,
-			"`MEM_WRITE_DWORD(3'b000, 64'h%p, 64'h%0lx, 4'hf);\n",
-			regs, (long unsigned int) val);
 	writel(val_lo, ptr);
 	writel(val_hi, ptr + 1);
 }

commit 1bb73a88839d473f4f2c529ecf453029439aa837
Author: Alex He <alex.he@amd.com>
Date:   Thu May 5 18:14:12 2011 +0800

    xHCI 1.0: Max Exit Latency Too Large Error
    
    This is a new TRB Completion Code of the xHCI spec 1.0.
    Asserted by the Evalute Context Command if the proposed Max Exit Latency would
    not allow the periodic endpoints of the Device Slot to be scheduled.
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 33a49d5d6c22..e12db7cfb9bb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -881,7 +881,9 @@ struct xhci_transfer_event {
 #define COMP_STOP_INVAL	27
 /* Control Abort Error - Debug Capability - control pipe aborted */
 #define COMP_DBG_ABORT	28
-/* TRB type 29 and 30 reserved */
+/* Max Exit Latency Too Large Error */
+#define COMP_MEL_ERR	29
+/* TRB type 30 reserved */
 /* Isoc Buffer Overrun - an isoc IN ep sent more data than could fit in TD */
 #define COMP_BUFF_OVER	31
 /* Event Lost Error - xHC has an "internal event overrun condition" */

commit ad106f292369d753d5c75751cb9e760726e3cd00
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu May 5 18:14:02 2011 +0800

    xHCI 1.0: Block Interrupts for Isoch transfer
    
    Currently an isoc URB is divided into multiple TDs, and every TD will
    trigger an interrupt when it's processed. However, software can schedule
    multiple TDs at a time, and it only needs an interrupt every URB.
    
    xHCI 1.0 introduces the Block Event Interrupt(BEI) flag which allows Normal
    and Isoch Transfer TRBs to place an Event TRB on an Event Ring but not
    assert an intrrupt to the host, and the interrupt rate is significantly
    reduced and the system performance is improved.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index af8b66f2fd00..33a49d5d6c22 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -964,6 +964,8 @@ struct xhci_event_cmd {
 /* The buffer pointer contains immediate data */
 #define TRB_IDT			(1<<6)
 
+/* Block Event Interrupt */
+#define	TRB_BEI			(1<<9)
 
 /* Control transfer TRB specific fields */
 #define TRB_DIR_IN		(1<<16)

commit b83cdc8f4d94a127e9319bef37f384b01ecca72e
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu May 5 18:13:56 2011 +0800

    xHCI 1.0: Setup Stage TRB Transfer Type flag
    
    Setup Stage Transfer Type field is added to indicate the presence and the
    direction of the Data Stage TD, and determines the direction of the Status
    Stage TD so the wLength length field should be ignored by the xHC.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index db661543a805..af8b66f2fd00 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -967,6 +967,9 @@ struct xhci_event_cmd {
 
 /* Control transfer TRB specific fields */
 #define TRB_DIR_IN		(1<<16)
+#define	TRB_TX_TYPE(p)		((p) << 16)
+#define	TRB_DATA_OUT		2
+#define	TRB_DATA_IN		3
 
 /* Isochronous TRB specific fields */
 #define TRB_SIA			(1<<31)

commit b61d378f2da41c748aba6ca19d77e1e1c02bcea5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Apr 19 17:43:33 2011 -0700

    xhci 1.0: Set transfer burst last packet count field.
    
    The xHCI 1.0 specification defines a new isochronous TRB field, called
    transfer burst last packet count (TBLPC).  This field defines the number
    of packets in the last "burst" of packets in a TD.  Only SuperSpeed
    endpoints can handle more than one burst, so this is set to the number for
    packets in a TD for all non-SuperSpeed devices (minus one, since the field
    is zero based).
    
    This patch should have no effect on host controllers that don't advertise
    the xHCI 1.0 (0x100) version number in their hci_version field.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 87ec3b079728..db661543a805 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -944,6 +944,7 @@ struct xhci_event_cmd {
 #define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
 #define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)
 #define TRB_TBC(p)		(((p) & 0x3) << 7)
+#define TRB_TLBPC(p)		(((p) & 0xf) << 16)
 
 /* Cycle bit - indicates TRB ownership by HC or HCD */
 #define TRB_CYCLE		(1<<0)

commit 5cd43e33b9519143f06f507dd7cbee6b7a621885
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Apr 8 09:37:29 2011 -0700

    xhci 1.0: Set transfer burst count field.
    
    The xHCI 1.0 specification adds a new field to the fourth dword in an
    isochronous TRB: the transfer burst count (TBC).  This field is only
    non-zero for SuperSpeed devices.  Each SS endpoint sets the bMaxBurst
    field in the SuperSpeed endpoint companion descriptor, which indicates how
    many max-packet-sized "bursts" it can handle in one service interval.  The
    device driver may choose to burst less max packet sized chunks each
    service interval (which is defined by one TD).  The xHCI driver indicates
    to the host controller how many bursts it needs to schedule through the
    transfer burst count field.
    
    This patch will only effect xHCI hosts that advertise 1.0 support (0x100)
    in the HCI version field of their capabilities register.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 85e779808189..87ec3b079728 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -943,6 +943,7 @@ struct xhci_event_cmd {
 /* Interrupter Target - which MSI-X vector to target the completion event at */
 #define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
 #define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)
+#define TRB_TBC(p)		(((p) & 0x3) << 7)
 
 /* Cycle bit - indicates TRB ownership by HC or HCD */
 #define TRB_CYCLE		(1<<0)

commit 28ccd2962c66556d7037b2d9f1c11cdcd3b805d5
Author: Matt Evans <matt@ozlabs.org>
Date:   Tue Mar 29 13:40:46 2011 +1100

    xhci: Make xHCI driver endian-safe
    
    This patch changes the struct members defining access to xHCI device-visible
    memory to use __le32/__le64 where appropriate, and then adds swaps where
    required.  Checked with sparse that all accesses are correct.
    
    MMIO accesses use readl/writel so already are performed LE, but prototypes
    now reflect this with __le*.
    
    There were a couple of (debug) instances of DMA pointers being truncated to
    32bits which have been fixed too.
    
    Signed-off-by: Matt Evans <matt@ozlabs.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ba1be6b7cc6d..85e779808189 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -57,13 +57,13 @@
  * @run_regs_off:	RTSOFF - Runtime register space offset
  */
 struct xhci_cap_regs {
-	u32	hc_capbase;
-	u32	hcs_params1;
-	u32	hcs_params2;
-	u32	hcs_params3;
-	u32	hcc_params;
-	u32	db_off;
-	u32	run_regs_off;
+	__le32	hc_capbase;
+	__le32	hcs_params1;
+	__le32	hcs_params2;
+	__le32	hcs_params3;
+	__le32	hcc_params;
+	__le32	db_off;
+	__le32	run_regs_off;
 	/* Reserved up to (CAPLENGTH - 0x1C) */
 };
 
@@ -155,26 +155,26 @@ struct xhci_cap_regs {
  * 			devices.
  */
 struct xhci_op_regs {
-	u32	command;
-	u32	status;
-	u32	page_size;
-	u32	reserved1;
-	u32	reserved2;
-	u32	dev_notification;
-	u64	cmd_ring;
+	__le32	command;
+	__le32	status;
+	__le32	page_size;
+	__le32	reserved1;
+	__le32	reserved2;
+	__le32	dev_notification;
+	__le64	cmd_ring;
 	/* rsvd: offset 0x20-2F */
-	u32	reserved3[4];
-	u64	dcbaa_ptr;
-	u32	config_reg;
+	__le32	reserved3[4];
+	__le64	dcbaa_ptr;
+	__le32	config_reg;
 	/* rsvd: offset 0x3C-3FF */
-	u32	reserved4[241];
+	__le32	reserved4[241];
 	/* port 1 registers, which serve as a base address for other ports */
-	u32	port_status_base;
-	u32	port_power_base;
-	u32	port_link_base;
-	u32	reserved5;
+	__le32	port_status_base;
+	__le32	port_power_base;
+	__le32	port_link_base;
+	__le32	reserved5;
 	/* registers for ports 2-255 */
-	u32	reserved6[NUM_PORT_REGS*254];
+	__le32	reserved6[NUM_PORT_REGS*254];
 };
 
 /* USBCMD - USB command - command bitmasks */
@@ -382,12 +382,12 @@ struct xhci_op_regs {
  * updates the dequeue pointer.
  */
 struct xhci_intr_reg {
-	u32	irq_pending;
-	u32	irq_control;
-	u32	erst_size;
-	u32	rsvd;
-	u64	erst_base;
-	u64	erst_dequeue;
+	__le32	irq_pending;
+	__le32	irq_control;
+	__le32	erst_size;
+	__le32	rsvd;
+	__le64	erst_base;
+	__le64	erst_dequeue;
 };
 
 /* irq_pending bitmasks */
@@ -432,8 +432,8 @@ struct xhci_intr_reg {
  * or larger accesses"
  */
 struct xhci_run_regs {
-	u32			microframe_index;
-	u32			rsvd[7];
+	__le32			microframe_index;
+	__le32			rsvd[7];
 	struct xhci_intr_reg	ir_set[128];
 };
 
@@ -447,7 +447,7 @@ struct xhci_run_regs {
  * Section 5.6
  */
 struct xhci_doorbell_array {
-	u32	doorbell[256];
+	__le32	doorbell[256];
 };
 
 #define DB_VALUE(ep, stream)	((((ep) + 1) & 0xff) | ((stream) << 16))
@@ -504,12 +504,12 @@ struct xhci_container_ctx {
  * reserved at the end of the slot context for HC internal use.
  */
 struct xhci_slot_ctx {
-	u32	dev_info;
-	u32	dev_info2;
-	u32	tt_info;
-	u32	dev_state;
+	__le32	dev_info;
+	__le32	dev_info2;
+	__le32	tt_info;
+	__le32	dev_state;
 	/* offset 0x10 to 0x1f reserved for HC internal use */
-	u32	reserved[4];
+	__le32	reserved[4];
 };
 
 /* dev_info bitmasks */
@@ -580,12 +580,12 @@ struct xhci_slot_ctx {
  * reserved at the end of the endpoint context for HC internal use.
  */
 struct xhci_ep_ctx {
-	u32	ep_info;
-	u32	ep_info2;
-	u64	deq;
-	u32	tx_info;
+	__le32	ep_info;
+	__le32	ep_info2;
+	__le64	deq;
+	__le32	tx_info;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
-	u32	reserved[3];
+	__le32	reserved[3];
 };
 
 /* ep_info bitmasks */
@@ -660,9 +660,9 @@ struct xhci_ep_ctx {
  * @add_context:	set the bit of the endpoint context you want to enable
  */
 struct xhci_input_control_ctx {
-	u32	drop_flags;
-	u32	add_flags;
-	u32	rsvd2[6];
+	__le32	drop_flags;
+	__le32	add_flags;
+	__le32	rsvd2[6];
 };
 
 /* Represents everything that is needed to issue a command on the command ring.
@@ -688,9 +688,9 @@ struct xhci_command {
 
 struct xhci_stream_ctx {
 	/* 64-bit stream ring address, cycle state, and stream type */
-	u64	stream_ring;
+	__le64	stream_ring;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
-	u32	reserved[2];
+	__le32	reserved[2];
 };
 
 /* Stream Context Types (section 6.4.1) - bits 3:1 of stream ctx deq ptr */
@@ -803,7 +803,7 @@ struct xhci_virt_device {
  */
 struct xhci_device_context_array {
 	/* 64-bit device addresses; we only write 32-bit addresses */
-	u64			dev_context_ptrs[MAX_HC_SLOTS];
+	__le64			dev_context_ptrs[MAX_HC_SLOTS];
 	/* private xHCD pointers */
 	dma_addr_t	dma;
 };
@@ -816,10 +816,10 @@ struct xhci_device_context_array {
 
 struct xhci_transfer_event {
 	/* 64-bit buffer address, or immediate data */
-	u64	buffer;
-	u32	transfer_len;
+	__le64	buffer;
+	__le32	transfer_len;
 	/* This field is interpreted differently based on the type of TRB */
-	u32	flags;
+	__le32	flags;
 };
 
 /** Transfer Event bit fields **/
@@ -898,9 +898,9 @@ struct xhci_transfer_event {
 
 struct xhci_link_trb {
 	/* 64-bit segment pointer*/
-	u64 segment_ptr;
-	u32 intr_target;
-	u32 control;
+	__le64 segment_ptr;
+	__le32 intr_target;
+	__le32 control;
 };
 
 /* control bitfields */
@@ -909,9 +909,9 @@ struct xhci_link_trb {
 /* Command completion event TRB */
 struct xhci_event_cmd {
 	/* Pointer to command TRB, or the value passed by the event data trb */
-	u64 cmd_trb;
-	u32 status;
-	u32 flags;
+	__le64 cmd_trb;
+	__le32 status;
+	__le32 flags;
 };
 
 /* flags bitmasks */
@@ -970,7 +970,7 @@ struct xhci_event_cmd {
 #define TRB_SIA			(1<<31)
 
 struct xhci_generic_trb {
-	u32 field[4];
+	__le32 field[4];
 };
 
 union xhci_trb {
@@ -1118,10 +1118,10 @@ struct xhci_ring {
 
 struct xhci_erst_entry {
 	/* 64-bit event ring segment address */
-	u64	seg_addr;
-	u32	seg_size;
+	__le64	seg_addr;
+	__le32	seg_size;
 	/* Set to zero */
-	u32	rsvd;
+	__le32	rsvd;
 };
 
 struct xhci_erst {
@@ -1286,10 +1286,10 @@ struct xhci_hcd {
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
 	u8			*port_array;
 	/* Array of pointers to USB 3.0 PORTSC registers */
-	u32 __iomem		**usb3_ports;
+	__le32 __iomem		**usb3_ports;
 	unsigned int		num_usb3_ports;
 	/* Array of pointers to USB 2.0 PORTSC registers */
-	u32 __iomem		**usb2_ports;
+	__le32 __iomem		**usb2_ports;
 	unsigned int		num_usb2_ports;
 };
 
@@ -1322,12 +1322,12 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 /* TODO: copied from ehci.h - can be refactored? */
 /* xHCI spec says all registers are little endian */
 static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
-		__u32 __iomem *regs)
+		__le32 __iomem *regs)
 {
 	return readl(regs);
 }
 static inline void xhci_writel(struct xhci_hcd *xhci,
-		const unsigned int val, __u32 __iomem *regs)
+		const unsigned int val, __le32 __iomem *regs)
 {
 	xhci_dbg(xhci,
 			"`MEM_WRITE_DWORD(3'b000, 32'h%p, 32'h%0x, 4'hf);\n",
@@ -1345,7 +1345,7 @@ static inline void xhci_writel(struct xhci_hcd *xhci,
  * the high dword, and write order is irrelevant.
  */
 static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
-		__u64 __iomem *regs)
+		__le64 __iomem *regs)
 {
 	__u32 __iomem *ptr = (__u32 __iomem *) regs;
 	u64 val_lo = readl(ptr);
@@ -1353,7 +1353,7 @@ static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
 	return val_lo + (val_hi << 32);
 }
 static inline void xhci_write_64(struct xhci_hcd *xhci,
-		const u64 val, __u64 __iomem *regs)
+				 const u64 val, __le64 __iomem *regs)
 {
 	__u32 __iomem *ptr = (__u32 __iomem *) regs;
 	u32 val_lo = lower_32_bits(val);

commit c41136b05d3fb213a192f76a5688ff83687c1136
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Mar 22 17:08:14 2011 +0800

    xHCI: Implement AMD PLL quirk
    
    This patch disable the optional PM feature inside the Hudson3 platform under
    the following conditions:
    
    1. If an isochronous device is connected to xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    The PM feature needs to be disabled to eliminate PLL startup delays when the
    link comes out of low power state. The performance of DMA data transfer could
    be impacted if system delay were encountered and in addition to the PLL start
    up delays. Disabling the PM would leave room for unpredictable system delays
    in order to guarantee uninterrupted data transfer to isochronous audio or
    video stream devices that require time sensitive information. If data in an
    audio/video stream was interrupted then erratic audio or video performance
    may be encountered.
    
    AMD PLL quirk is already implemented in OHCI/EHCI driver. After moving the
    quirk code to pci-quirks.c and export them, xHCI driver can call it directly
    without having the quirk implementation in itself.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bdb78f51735e..ba1be6b7cc6d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -30,6 +30,7 @@
 
 /* Code sharing between pci-quirks and xhci hcd */
 #include	"xhci-ext-caps.h"
+#include "pci-quirks.h"
 
 /* xHCI PCI Configuration Registers */
 #define XHCI_SBRN_OFFSET	(0x60)
@@ -1279,6 +1280,7 @@ struct xhci_hcd {
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
+#define XHCI_AMD_PLL_FIX	(1 << 3)
 	/* There are two roothubs to keep track of bus suspend info for */
 	struct xhci_bus_state   bus_state[2];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */

commit 22e0487047567252d5677ff35766cd884375efc2
Author: Dan Carpenter <error27@gmail.com>
Date:   Thu Mar 17 22:39:49 2011 +0300

    USB: xhci: unsigned char never equals -1
    
    There were some places that compared port_speed == -1 where port_speed
    is a u8.  This doesn't work unless we cast the -1 to u8.  Some places
    did it correctly.
    
    Instead of using -1 directly, I've created a DUPLICATE_ENTRY define
    which does the cast and is more descriptive as well.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 91b1a237c11e..bdb78f51735e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -348,6 +348,9 @@ struct xhci_op_regs {
 /* Initiate a warm port reset - complete when PORT_WRC is '1' */
 #define PORT_WR		(1 << 31)
 
+/* We mark duplicate entries with -1 */
+#define DUPLICATE_ENTRY ((u8)(-1))
+
 /* Port Power Management Status and Control - port_power_base bitmasks */
 /* Inactivity timer value for transitions into U1, in microseconds.
  * Timeout can be up to 127us.  0xFF means an infinite timeout.

commit 5a6c2f3ff039154872ce597952f8b8900ea0d732
Author: Dmitry Torokhov <dtor@vmware.com>
Date:   Sun Mar 20 02:15:17 2011 -0700

    USB: xhci - fix unsafe macro definitions
    
    Macro arguments used in expressions need to be enclosed in parenthesis
    to avoid unpleasant surprises.
    
    This should be queued for kernels back to 2.6.31
    
    Signed-off-by: Dmitry Torokhov <dtor@vmware.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 07e263063e37..91b1a237c11e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -232,7 +232,7 @@ struct xhci_op_regs {
  * notification type that matches a bit set in this bit field.
  */
 #define	DEV_NOTE_MASK		(0xffff)
-#define ENABLE_DEV_NOTE(x)	(1 << x)
+#define ENABLE_DEV_NOTE(x)	(1 << (x))
 /* Most of the device notification types should only be used for debug.
  * SW does need to pay attention to function wake notifications.
  */
@@ -601,11 +601,11 @@ struct xhci_ep_ctx {
 #define EP_STATE_STOPPED	3
 #define EP_STATE_ERROR		4
 /* Mult - Max number of burtst within an interval, in EP companion desc. */
-#define EP_MULT(p)		((p & 0x3) << 8)
+#define EP_MULT(p)		(((p) & 0x3) << 8)
 /* bits 10:14 are Max Primary Streams */
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
-#define EP_INTERVAL(p)		((p & 0xff) << 16)
+#define EP_INTERVAL(p)		(((p) & 0xff) << 16)
 #define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
 #define EP_MAXPSTREAMS_MASK	(0x1f << 10)
 #define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 711de253bc0f..07e263063e37 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -873,7 +873,7 @@ struct xhci_transfer_event {
 #define COMP_CMD_ABORT	25
 /* Stopped - transfer was terminated by a stop endpoint command */
 #define COMP_STOP	26
-/* Same as COMP_EP_STOPPED, but the transfered length in the event is invalid */
+/* Same as COMP_EP_STOPPED, but the transferred length in the event is invalid */
 #define COMP_STOP_INVAL	27
 /* Control Abort Error - Debug Capability - control pipe aborted */
 #define COMP_DBG_ABORT	28

commit 971f115a50afbe409825c9f3399d5a3b9aca4381
Merge: 2e270d842232 500132a0f26a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 15:04:26 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (172 commits)
      USB: Add support for SuperSpeed isoc endpoints
      xhci: Clean up cycle bit math used during stalls.
      xhci: Fix cycle bit calculation during stall handling.
      xhci: Update internal dequeue pointers after stalls.
      USB: Disable auto-suspend for USB 3.0 hubs.
      USB: Remove bogus USB_PORT_STAT_SUPER_SPEED symbol.
      xhci: Return canceled URBs immediately when host is halted.
      xhci: Fixes for suspend/resume of shared HCDs.
      xhci: Fix re-init on power loss after resume.
      xhci: Make roothub functions deal with device removal.
      xhci: Limit roothub ports to 15 USB3 & 31 USB2 ports.
      xhci: Return a USB 3.0 hub descriptor for USB3 roothub.
      xhci: Register second xHCI roothub.
      xhci: Change xhci_find_slot_id_by_port() API.
      xhci: Refactor bus suspend state into a struct.
      xhci: Index with a port array instead of PORTSC addresses.
      USB: Set usb_hcd->state and flags for shared roothubs.
      usb: Make core allocate resources per PCI-device.
      usb: Store bus type in usb_hcd, not in driver flags.
      usb: Change usb_hcd->bandwidth_mutex to a pointer.
      ...

commit bf161e85fb153c0dd5a95faca73fd6a9d237c389
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Feb 23 15:46:42 2011 -0800

    xhci: Update internal dequeue pointers after stalls.
    
    When an endpoint stalls, the xHCI driver must move the endpoint ring's
    dequeue pointer past the stalled transfer.  To do that, the driver issues
    a Set TR Dequeue Pointer command, which will complete some time later.
    
    Takashi was having issues with USB 1.1 audio devices that stalled, and his
    analysis of the code was that the old code would not update the xHCI
    driver's ring dequeue pointer after the command completes.  However, the
    dequeue pointer is set in xhci_find_new_dequeue_state(), just before the
    set command is issued to the hardware.
    
    Setting the dequeue pointer before the Set TR Dequeue Pointer command
    completes is a dangerous thing to do, since the xHCI hardware can fail the
    command.  Instead, store the new dequeue pointer in the xhci_virt_ep
    structure, and update the ring's dequeue pointer when the Set TR dequeue
    pointer command completes.
    
    While we're at it, make sure we can't queue another Set TR Dequeue Command
    while the first one is still being processed.  This just won't work with
    the internal xHCI state code.  I'm still not sure if this is the right
    thing to do, since we might have a case where a driver queues multiple
    URBs to a control ring, one of the URBs Stalls, and then the driver tries
    to cancel the second URB.  There may be a race condition there where the
    xHCI driver might try to issue multiple Set TR Dequeue Pointer commands,
    but I would have to think very hard about how the Stop Endpoint and
    cancellation code works.  Keep the fix simple until when/if we run into
    that case.
    
    This patch should be queued to kernels all the way back to 2.6.31.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e69f1cdf4b5b..7aca6b16e986 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -644,6 +644,9 @@ struct xhci_ep_ctx {
 #define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
 #define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
 
+/* deq bitmasks */
+#define EP_CTX_CYCLE_MASK		(1 << 0)
+
 
 /**
  * struct xhci_input_control_context
@@ -746,6 +749,12 @@ struct xhci_virt_ep {
 	struct timer_list	stop_cmd_timer;
 	int			stop_cmds_pending;
 	struct xhci_hcd		*xhci;
+	/* Dequeue pointer and dequeue segment for a submitted Set TR Dequeue
+	 * command.  We'll need to update the ring's dequeue segment and dequeue
+	 * pointer after the command completes.
+	 */
+	struct xhci_segment	*queued_deq_seg;
+	union xhci_trb		*queued_deq_ptr;
 	/*
 	 * Sometimes the xHC can not process isochronous endpoint ring quickly
 	 * enough, and it will miss some isoc tds on the ring and generate

commit c6cc27c782e3a64cced0fcf1d6f492c8d8881c76
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Mar 11 10:20:58 2011 -0800

    xhci: Return canceled URBs immediately when host is halted.
    
    When the xHCI host controller is halted, it won't respond to commands
    placed on the command ring.  So if an URB is cancelled after the first
    roothub is deallocated, it will try to place a stop endpoint command on
    the command ring, which will fail.  The command watchdog timer will fire
    after five seconds, and the host controller will be marked as dying, and
    all URBs will be completed.
    
    Add a flag to the xHCI's internal state variable for when the host
    controller is halted.  Immediately return the canceled URB if the host
    controller is halted.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e9217bb288ad..e69f1cdf4b5b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1260,6 +1260,7 @@ struct xhci_hcd {
  * There are no reports of xHCI host controllers that display this issue.
  */
 #define XHCI_STATE_DYING	(1 << 0)
+#define XHCI_STATE_HALTED	(1 << 1)
 	/* Statistics */
 	int			error_bitmask;
 	unsigned int		quirks;

commit f6ff0ac878eb420011fa2448851dd48c3a7e7b31
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 16 11:21:10 2010 -0800

    xhci: Register second xHCI roothub.
    
    This patch changes the xHCI driver to allocate two roothubs.  This touches
    the driver initialization and shutdown paths, roothub emulation code, and
    port status change event handlers.  This is a rather large patch, but it
    can't be broken up, or it would break git-bisect.
    
    Make the xHCI driver register its own PCI probe function.  This will call
    the USB core to create the USB 2.0 roothub, and then create the USB 3.0
    roothub.  This gets the code for registering a shared roothub out of the
    USB core, and allows other HCDs later to decide if and how many shared
    roothubs they want to allocate.
    
    Make sure the xHCI's reset method marks the xHCI host controller's primary
    roothub as the USB 2.0 roothub.  This ensures that the high speed bus will
    be processed first when the PCI device is resumed, and any USB 3.0 devices
    that have migrated over to high speed will migrate back after being reset.
    This ensures that USB persist works with these odd devices.
    
    The reset method will also mark the xHCI USB2 roothub as having an
    integrated TT.  Like EHCI host controllers with a "rate matching hub" the
    xHCI USB 2.0 roothub doesn't have an OHCI or UHCI companion controller.
    It doesn't really have a TT, but we'll lie and say it has an integrated
    TT.  We need to do this because the USB core will reject LS/FS devices
    under a HS hub without a TT.
    
    Other details:
    -------------
    
    The roothub emulation code is changed to return the correct number of
    ports for the two roothubs.  For the USB 3.0 roothub, it only reports the
    USB 3.0 ports.  For the USB 2.0 roothub, it reports all the LS/FS/HS
    ports.  The code to disable a port now checks the speed of the roothub,
    and refuses to disable SuperSpeed ports under the USB 3.0 roothub.
    
    The code for initializing a new device context must be changed to set the
    proper roothub port number.  Since we've split the xHCI host into two
    roothubs, we can't just use the port number in the ancestor hub.  Instead,
    we loop through the array of hardware port status register speeds and find
    the Nth port with a similar speed.
    
    The port status change event handler is updated to figure out whether the
    port that reported the change is a USB 3.0 port, or a non-SuperSpeed port.
    Once it figures out the port speed, it kicks the proper roothub.
    
    The function to find a slot ID based on the port index is updated to take
    into account that the two roothubs will have over-lapping port indexes.
    It checks that the virtual device with a matching port index is the same
    speed as the passed in roothub.
    
    There's also changes to the driver initialization and shutdown paths:
    
     1. Make sure that the xhci_hcd pointer is shared across the two
        usb_hcd structures.  The xhci_hcd pointer is allocated and the
        registers are mapped in when xhci_pci_setup() is called with the
        primary HCD.  When xhci_pci_setup() is called with the non-primary
        HCD, the xhci_hcd pointer is stored.
    
     2. Make sure to set the sg_tablesize for both usb_hcd structures.  Set
        the PCI DMA mask for the non-primary HCD to allow for 64-bit or 32-bit
        DMA.  (The PCI DMA mask is set from the primary HCD further down in
        the xhci_pci_setup() function.)
    
     3. Ensure that the host controller doesn't start kicking khubd in
        response to port status changes before both usb_hcd structures are
        registered.  xhci_run() only starts the xHC running once it has been
        called with the non-primary roothub.  Similarly, the xhci_stop()
        function only halts the host controller when it is called with the
        non-primary HCD.  Then on the second call, it resets and cleans up the
        MSI-X irqs.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 443d6333f280..e9217bb288ad 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1174,12 +1174,16 @@ struct xhci_bus_state {
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
-	return 0;
+	if (hcd->speed == HCD_USB3)
+		return 0;
+	else
+		return 1;
 }
 
 /* There is one ehci_hci structure per controller */
 struct xhci_hcd {
 	struct usb_hcd *main_hcd;
+	struct usb_hcd *shared_hcd;
 	/* glue to PCI and HCD framework */
 	struct xhci_cap_regs __iomem *cap_regs;
 	struct xhci_op_regs __iomem *op_regs;
@@ -1262,10 +1266,8 @@ struct xhci_hcd {
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
-	/* There's only one roothub to keep track of bus suspend info for
-	 * (right now).
-	 */
-	struct xhci_bus_state   bus_state[1];
+	/* There are two roothubs to keep track of bus suspend info for */
+	struct xhci_bus_state   bus_state[2];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
 	u8			*port_array;
 	/* Array of pointers to USB 3.0 PORTSC registers */

commit 5233630fcdd6f7d415dcbed264031439cab73f9d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 16 10:49:09 2010 -0800

    xhci: Change xhci_find_slot_id_by_port() API.
    
    xhci_find_slot_id_by_port() tries to map the port index to the slot ID for
    the USB device.  In the future, there will be two xHCI roothubs, and their
    port indices will overlap.  Therefore, xhci_find_slot_id_by_port() will
    need to use information in the roothub's usb_hcd structure to map the port
    index and roothub speed to the right slot ID.
    
    Add a new parameter to xhci_find_slot_id_by_port(), in order to pass in
    the roothub's usb_hcd structure.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c15470eb121a..443d6333f280 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1533,7 +1533,8 @@ int xhci_bus_resume(struct usb_hcd *hcd);
 #endif	/* CONFIG_PM */
 
 u32 xhci_port_state_to_neutral(u32 state);
-int xhci_find_slot_id_by_port(struct xhci_hcd *xhci, u16 port);
+int xhci_find_slot_id_by_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,
+		u16 port);
 void xhci_ring_device(struct xhci_hcd *xhci, int slot_id);
 
 /* xHCI contexts */

commit 20b67cf51fa606442bb343afad0ee1a393a6afb3
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 15 12:47:14 2010 -0800

    xhci: Refactor bus suspend state into a struct.
    
    There are several variables in the xhci_hcd structure that are related to
    bus suspend and resume state.  There are a couple different port status
    arrays that are accessed by port index.  Move those variables into a
    separate structure, xhci_bus_state.  Stash that structure in xhci_hcd.
    
    When we have two roothhubs that can be suspended and resumed separately,
    we can have two xhci_bus_states, and index into the port arrays in each
    structure with the fake roothub port index (not the real hardware port
    index).
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index daa88581ad66..c15470eb121a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1161,6 +1161,22 @@ struct s3_save {
 	u64	erst_dequeue;
 };
 
+struct xhci_bus_state {
+	unsigned long		bus_suspended;
+	unsigned long		next_statechange;
+
+	/* Port suspend arrays are indexed by the portnum of the fake roothub */
+	/* ports suspend status arrays - max 31 ports for USB2, 15 for USB3 */
+	u32			port_c_suspend;
+	u32			suspended_ports;
+	unsigned long		resume_done[USB_MAXCHILDREN];
+};
+
+static inline unsigned int hcd_index(struct usb_hcd *hcd)
+{
+	return 0;
+}
+
 /* There is one ehci_hci structure per controller */
 struct xhci_hcd {
 	struct usb_hcd *main_hcd;
@@ -1225,9 +1241,6 @@ struct xhci_hcd {
 	/* Host controller watchdog timer structures */
 	unsigned int		xhc_state;
 
-	unsigned long		bus_suspended;
-	unsigned long		next_statechange;
-
 	u32			command;
 	struct s3_save		s3;
 /* Host controller is dying - not responding to commands. "I'm not dead yet!"
@@ -1249,11 +1262,10 @@ struct xhci_hcd {
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
-	/* port suspend change*/
-	u32			port_c_suspend;
-	/* which ports are suspended */
-	u32			suspended_ports;
-	unsigned long		resume_done[USB_MAXCHILDREN];
+	/* There's only one roothub to keep track of bus suspend info for
+	 * (right now).
+	 */
+	struct xhci_bus_state   bus_state[1];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
 	u8			*port_array;
 	/* Array of pointers to USB 3.0 PORTSC registers */

commit b02d0ed677acb3465e7600366f2353413bf24074
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 26 11:03:44 2010 -0700

    xhci: Change hcd_priv into a pointer.
    
    Instead of allocating space for the whole xhci_hcd structure at the end of
    usb_hcd, make the USB core allocate enough space for a pointer to the
    xhci_hcd structure.  This will make it easy to share the xhci_hcd
    structure across the two roothubs (the USB 3.0 usb_hcd and the USB 2.0
    usb_hcd).
    
    Deallocate the xhci_hcd at PCI remove time, so the hcd_priv will be
    deallocated after the usb_hcd is deallocated.  We do this by registering a
    different PCI remove function that calls the usb_hcd_pci_remove()
    function, and then frees the xhci_hcd.  usb_hcd_pci_remove() calls
    kput() on the usb_hcd structure, which will deallocate the memory that
    contains the hcd_priv pointer, but not the memory it points to.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c4e70c6d809c..daa88581ad66 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1163,6 +1163,7 @@ struct s3_save {
 
 /* There is one ehci_hci structure per controller */
 struct xhci_hcd {
+	struct usb_hcd *main_hcd;
 	/* glue to PCI and HCD framework */
 	struct xhci_cap_regs __iomem *cap_regs;
 	struct xhci_op_regs __iomem *op_regs;
@@ -1266,12 +1267,12 @@ struct xhci_hcd {
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
 {
-	return (struct xhci_hcd *) (hcd->hcd_priv);
+	return *((struct xhci_hcd **) (hcd->hcd_priv));
 }
 
 static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 {
-	return container_of((void *) xhci, struct usb_hcd, hcd_priv);
+	return xhci->main_hcd;
 }
 
 #ifdef CONFIG_USB_XHCI_HCD_DEBUGGING

commit 1d5810b6923c76fc95e52d9d3491c91824c2f075
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 9 14:52:41 2010 -0800

    xhci: Rework port suspend structures for limited ports.
    
    The USB core only allows up to 31 (USB_MAXCHILDREN) ports under a roothub.
    The xHCI driver keeps track of which ports are suspended, which ports have
    a suspend change bit set, and what time the port will be done resuming.
    It keeps track of the first two by setting a bit in a u32 variable,
    suspended_ports or port_c_suspend.  The xHCI driver currently assumes we
    can have up to 256 ports under a roothub, so it allocates an array of 8
    u32 variables for both suspended_ports and port_c_suspend.  It also
    allocates a 256-element array to keep track of when the ports will be done
    resuming.
    
    Since we can only have 31 roothub ports, we only need to use one u32 for
    each of the suspend state and change variables.  We simplify the bit math
    that's trying to index into those arrays and set the correct bit, if we
    assume wIndex never exceeds 30.  (wIndex is zero-based after it's
    decremented from the value passed in from the USB core.)  Finally, we
    change the resume_done array to only hold 31 elements.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Andiry Xu <andiry.xu@amd.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2cb5932935d4..c4e70c6d809c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1248,10 +1248,11 @@ struct xhci_hcd {
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
-	u32			port_c_suspend[8];	/* port suspend change*/
-	u32			suspended_ports[8];	/* which ports are
-							   suspended */
-	unsigned long		resume_done[MAX_HC_PORTS];
+	/* port suspend change*/
+	u32			port_c_suspend;
+	/* which ports are suspended */
+	u32			suspended_ports;
+	unsigned long		resume_done[USB_MAXCHILDREN];
 	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
 	u8			*port_array;
 	/* Array of pointers to USB 3.0 PORTSC registers */

commit 0b8ca72a23df365a413e03f991bc6b8179dee13f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Oct 21 12:22:28 2010 -0700

    xhci: Remove old no-op test.
    
    The test of placing a number of command no-ops on the command ring and
    counting the number of no-op events that were generated was only used
    during the initial xHCI driver bring up.  This test is no longer used, so
    delete it.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7f236fd22015..2cb5932935d4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1243,8 +1243,6 @@ struct xhci_hcd {
  */
 #define XHCI_STATE_DYING	(1 << 0)
 	/* Statistics */
-	int			noops_submitted;
-	int			noops_handled;
 	int			error_bitmask;
 	unsigned int		quirks;
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
@@ -1264,9 +1262,6 @@ struct xhci_hcd {
 	unsigned int		num_usb2_ports;
 };
 
-/* For testing purposes */
-#define NUM_TEST_NOOPS	0
-
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
 {
@@ -1471,7 +1466,6 @@ struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
 		dma_addr_t suspect_dma);
 int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
-void *xhci_setup_one_noop(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);

commit 09ece30e06b19994e6f3d260e5c4be18dce22714
Author: Dmitry Torokhov <dtor@vmware.com>
Date:   Tue Feb 8 16:29:33 2011 -0800

    USB: xhci: rework xhci_print_ir_set() to get ir set from xhci itself
    
    xhci->ir_set points to __iomem region, but xhci_print_ir_set accepts
    plain struct xhci_intr_reg * causing multiple sparse warning at call
    sites and inside the fucntion when we try to read that memory.
    
    Instead of adding __iomem qualifier to the argument let's rework the
    function so it itself gets needed register set from xhci and prints
    it.
    
    Signed-off-by: Dmitry Torokhov <dtor@vmware.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7f236fd22015..7f127df6dd55 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1348,7 +1348,7 @@ static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
 }
 
 /* xHCI debugging */
-void xhci_print_ir_set(struct xhci_hcd *xhci, struct xhci_intr_reg *ir_set, int set_num);
+void xhci_print_ir_set(struct xhci_hcd *xhci, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);
 void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);

commit 50d64676d132a8a72a1a1657d7b3e6efa53da1ac
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Dec 15 14:18:11 2010 -0500

    xhci: Remove more doorbell-related reads
    
    The unused space in the doorbell is now marked as RsvdZ, not RsvdP, so
    we can avoid reading the doorbell before writing it.
    
    Update the doorbell-related defines to produce the entire doorbell value
    from a single macro.  Document the doorbell format in a comment.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 170c367112d2..7f236fd22015 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -436,22 +436,18 @@ struct xhci_run_regs {
 /**
  * struct doorbell_array
  *
+ * Bits  0 -  7: Endpoint target
+ * Bits  8 - 15: RsvdZ
+ * Bits 16 - 31: Stream ID
+ *
  * Section 5.6
  */
 struct xhci_doorbell_array {
 	u32	doorbell[256];
 };
 
-#define	DB_TARGET_MASK		0xFFFFFF00
-#define	DB_STREAM_ID_MASK	0x0000FFFF
-#define	DB_TARGET_HOST		0x0
-#define	DB_STREAM_ID_HOST	0x0
-#define	DB_MASK			(0xff << 8)
-
-/* Endpoint Target - bits 0:7 */
-#define EPI_TO_DB(p)		(((p) + 1) & 0xff)
-#define STREAM_ID_TO_DB(p)	(((p) & 0xffff) << 16)
-
+#define DB_VALUE(ep, stream)	((((ep) + 1) & 0xff) | ((stream) << 16))
+#define DB_VALUE_HOST		0x00000000
 
 /**
  * struct xhci_protocol_caps

commit da6699ce4a889c3795624ccdcfe7181cc89f18e8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 26 16:47:13 2010 -0700

    xhci: Setup array of USB 2.0 and USB 3.0 ports.
    
    An xHCI host controller contains USB 2.0 and USB 3.0 ports, which can
    occur in any order in the PORTSC registers.  We cannot read the port speed
    bits in the PORTSC registers at init time to determine the port speed,
    since those bits are only valid when a USB device is plugged into the
    port.
    
    Instead, we read the "Supported Protocol Capability" registers in the xHC
    Extended Capabilities space.  Those describe the protocol, port offset in
    the PORTSC registers, and port count.  We use those registers to create
    two arrays of pointers to the PORTSC registers, one for USB 3.0 ports, and
    another for USB 2.0 ports.  A third array keeps track of the port protocol
    major revision, and is indexed with the internal xHCI port number.
    
    This commit is a bit big, but it should be queued for stable because the "Don't
    let the USB core disable SuperSpeed ports" patch depends on it.  There is no
    other way to determine which ports are SuperSpeed ports without this patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Don Zickus <dzickus@redhat.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 85e65647d445..170c367112d2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -453,6 +453,24 @@ struct xhci_doorbell_array {
 #define STREAM_ID_TO_DB(p)	(((p) & 0xffff) << 16)
 
 
+/**
+ * struct xhci_protocol_caps
+ * @revision:		major revision, minor revision, capability ID,
+ *			and next capability pointer.
+ * @name_string:	Four ASCII characters to say which spec this xHC
+ *			follows, typically "USB ".
+ * @port_info:		Port offset, count, and protocol-defined information.
+ */
+struct xhci_protocol_caps {
+	u32	revision;
+	u32	name_string;
+	u32	port_info;
+};
+
+#define	XHCI_EXT_PORT_MAJOR(x)	(((x) >> 24) & 0xff)
+#define	XHCI_EXT_PORT_OFF(x)	((x) & 0xff)
+#define	XHCI_EXT_PORT_COUNT(x)	(((x) >> 8) & 0xff)
+
 /**
  * struct xhci_container_ctx
  * @type: Type of context.  Used to calculated offsets to contained contexts.
@@ -1240,6 +1258,14 @@ struct xhci_hcd {
 	u32			suspended_ports[8];	/* which ports are
 							   suspended */
 	unsigned long		resume_done[MAX_HC_PORTS];
+	/* Is each xHCI roothub port a USB 3.0, USB 2.0, or USB 1.1 port? */
+	u8			*port_array;
+	/* Array of pointers to USB 3.0 PORTSC registers */
+	u32 __iomem		**usb3_ports;
+	unsigned int		num_usb3_ports;
+	/* Array of pointers to USB 2.0 PORTSC registers */
+	u32 __iomem		**usb2_ports;
+	unsigned int		num_usb2_ports;
 };
 
 /* For testing purposes */

commit dc07c91b9b4067022210e68d914a6890a4d70622
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Nov 11 17:43:57 2010 +0800

    xHCI: fix wMaxPacketSize mask
    
    USB2.0 spec 9.6.6 says: For all endpoints, bit 10..0 specify the maximum
    packet size(in bytes).
    
    So the wMaxPacketSize mask should be 0x7ff rather than 0x3ff.
    
    This patch should be queued for the stable tree.  The bug in
    xhci_endpoint_init() was present as far back as 2.6.31, and the bug in
    xhci_get_max_esit_payload() was present when the function was introduced
    in 2.6.34.
    
    Reported-by: Sander Eikelenboom <linux@eikelenboom.it>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 93d3bf4d213c..85e65647d445 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -621,6 +621,11 @@ struct xhci_ep_ctx {
 #define MAX_PACKET_MASK		(0xffff << 16)
 #define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
 
+/* Get max packet size from ep desc. Bit 10..0 specify the max packet size.
+ * USB2.0 spec 9.6.6.
+ */
+#define GET_MAX_PACKET(p)	((p) & 0x7ff)
+
 /* tx_info bitmasks */
 #define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
 #define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)

commit 436a389096e1feda2c382cad83b6a8d6de8615a0
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Oct 15 14:59:15 2010 -0700

    usb: Fix linker errors with CONFIG_PM=n
    
    Fix these linker errors when CONFIG_PM=n:
    
    ERROR: "xhci_bus_resume" [drivers/usb/host/xhci-hcd.ko] undefined!
    ERROR: "xhci_bus_suspend" [drivers/usb/host/xhci-hcd.ko] undefined!
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c08928adc524..93d3bf4d213c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1405,8 +1405,15 @@ int xhci_init(struct usb_hcd *hcd);
 int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
+
+#ifdef	CONFIG_PM
 int xhci_suspend(struct xhci_hcd *xhci);
 int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
+#else
+#define	xhci_suspend	NULL
+#define	xhci_resume	NULL
+#endif
+
 int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
 irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd);
@@ -1481,8 +1488,15 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+
+#ifdef CONFIG_PM
 int xhci_bus_suspend(struct usb_hcd *hcd);
 int xhci_bus_resume(struct usb_hcd *hcd);
+#else
+#define	xhci_bus_suspend	NULL
+#define	xhci_bus_resume		NULL
+#endif	/* CONFIG_PM */
+
 u32 xhci_port_state_to_neutral(u32 state);
 int xhci_find_slot_id_by_port(struct xhci_hcd *xhci, u16 port);
 void xhci_ring_device(struct xhci_hcd *xhci, int slot_id);

commit 5535b1d5f8885695c6ded783c692e3c0d0eda8ca
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:23:06 2010 -0700

    USB: xHCI: PCI power management implementation
    
    This patch implements the PCI suspend/resume.
    
    Please refer to xHCI spec for doing the suspend/resume operation.
    
    For S3, CSS/SRS in USBCMD is used to save/restore the internal state.
    However, an error maybe occurs while restoring the internal state.
    In this case, it means that HC internal state is wrong and HC will be
    re-initialized.
    
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: Dong Nguyen <dong.nguyen@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 196e21fb36ff..c08928adc524 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -191,7 +191,7 @@ struct xhci_op_regs {
 /* bits 4:6 are reserved (and should be preserved on writes). */
 /* light reset (port status stays unchanged) - reset completed when this is 0 */
 #define CMD_LRESET	(1 << 7)
-/* FIXME: ignoring host controller save/restore state for now. */
+/* host controller save/restore state. */
 #define CMD_CSS		(1 << 8)
 #define CMD_CRS		(1 << 9)
 /* Enable Wrap Event - '1' means xHC generates an event when MFINDEX wraps. */
@@ -1130,6 +1130,17 @@ struct urb_priv {
 #define XHCI_STOP_EP_CMD_TIMEOUT	5
 /* XXX: Make these module parameters */
 
+struct s3_save {
+	u32	command;
+	u32	dev_nt;
+	u64	dcbaa_ptr;
+	u32	config_reg;
+	u32	irq_pending;
+	u32	irq_control;
+	u32	erst_size;
+	u64	erst_base;
+	u64	erst_dequeue;
+};
 
 /* There is one ehci_hci structure per controller */
 struct xhci_hcd {
@@ -1198,6 +1209,7 @@ struct xhci_hcd {
 	unsigned long		next_statechange;
 
 	u32			command;
+	struct s3_save		s3;
 /* Host controller is dying - not responding to commands. "I'm not dead yet!"
  *
  * xHC interrupts have been disabled and a watchdog timer will (or has already)
@@ -1393,6 +1405,8 @@ int xhci_init(struct usb_hcd *hcd);
 int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
+int xhci_suspend(struct xhci_hcd *xhci);
+int xhci_resume(struct xhci_hcd *xhci, bool hibernated);
 int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
 irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd);

commit 9777e3ce907d4cb5a513902a87ecd03b52499569
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:23:03 2010 -0700

    USB: xHCI: bus power management implementation
    
    This patch implements xHCI bus suspend/resume function hook.
    
    In the patch it goes through all the ports and suspend/resume
    the ports if needed.
    
    If any port is in remote wakeup, abort bus suspend as what ehci/ohci do.
    
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: Crane Cai <crane.cai@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ca4a923dc810..196e21fb36ff 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -357,6 +357,8 @@ struct xhci_op_regs {
 #define PORT_U2_TIMEOUT(p)	(((p) & 0xff) << 8)
 /* Bits 24:31 for port testing */
 
+/* USB2 Protocol PORTSPMSC */
+#define PORT_RWE	(1 << 0x3)
 
 /**
  * struct xhci_intr_reg - Interrupt Register Set
@@ -1191,6 +1193,11 @@ struct xhci_hcd {
 #endif
 	/* Host controller watchdog timer structures */
 	unsigned int		xhc_state;
+
+	unsigned long		bus_suspended;
+	unsigned long		next_statechange;
+
+	u32			command;
 /* Host controller is dying - not responding to commands. "I'm not dead yet!"
  *
  * xHC interrupts have been disabled and a watchdog timer will (or has already)
@@ -1460,6 +1467,8 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+int xhci_bus_suspend(struct usb_hcd *hcd);
+int xhci_bus_resume(struct usb_hcd *hcd);
 u32 xhci_port_state_to_neutral(u32 state);
 int xhci_find_slot_id_by_port(struct xhci_hcd *xhci, u16 port);
 void xhci_ring_device(struct xhci_hcd *xhci, int slot_id);

commit 561925318725a41189a69f36ebe99199b3fb84c4
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:23:00 2010 -0700

    USB: xHCI: port remote wakeup implementation
    
    This commit implements port remote wakeup.
    
    When a port is in U3 state and resume signaling is detected from a device,
    the port transitions to the Resume state, and the xHC generates a Port Status
    Change Event.
    
    For USB3 port, software write a '0' to the PLS field to complete the resume
    signaling. For USB2 port, the resume should be signaling for at least 20ms,
    irq handler set a timer for port remote wakeup, and then finishes process in
    hub_control GetPortStatus.
    
    Some codes are borrowed from EHCI code.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 73e5db3e89c9..ca4a923dc810 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1215,6 +1215,7 @@ struct xhci_hcd {
 	u32			port_c_suspend[8];	/* port suspend change*/
 	u32			suspended_ports[8];	/* which ports are
 							   suspended */
+	unsigned long		resume_done[MAX_HC_PORTS];
 };
 
 /* For testing purposes */
@@ -1459,6 +1460,9 @@ void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+u32 xhci_port_state_to_neutral(u32 state);
+int xhci_find_slot_id_by_port(struct xhci_hcd *xhci, u16 port);
+void xhci_ring_device(struct xhci_hcd *xhci, int slot_id);
 
 /* xHCI contexts */
 struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);

commit be88fe4f4dda93e3264a887745123b1e6c4a6845
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:22:57 2010 -0700

    USB: xHCI: port power management implementation
    
    Add software trigger USB device suspend resume function hook.
    Do port suspend & resume in terms of xHCI spec.
    
    Port Suspend:
    Stop all endpoints via Stop Endpoint Command with Suspend (SP) flag set.
    Place individual ports into suspend mode by writing '3' for Port Link State
    (PLS) field into PORTSC register. This can only be done when the port is in
    Enabled state. When writing, the Port Link State Write Strobe (LWS) bit shall
    be set to '1'.
    Allocate an xhci_command and stash it in xhci_virt_device to wait completion for
    the last Stop Endpoint Command.  Use the Suspend bit in TRB to indicate the Stop
    Endpoint Command is for port suspend. Based on Sarah's suggestion.
    
    Port Resume:
    Write '0' in PLS field, device will transition to running state.
    Ring an endpoints' doorbell to restart it.
    
    Ref: USB device remote wake need another patch to implement. For details of
    how USB subsystem do power management, please see:
        Documentation/usb/power-management.txt
    
    Signed-off-by: Crane Cai <crane.cai@amd.com>
    Signed-off-by: Libin Yang <libin.yang@amd.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a7181b491e67..73e5db3e89c9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -269,6 +269,10 @@ struct xhci_op_regs {
  * A read gives the current link PM state of the port,
  * a write with Link State Write Strobe set sets the link state.
  */
+#define PORT_PLS_MASK	(0xf << 5)
+#define XDEV_U0		(0x0 << 5)
+#define XDEV_U3		(0x3 << 5)
+#define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)
 /* bits 10:13 indicate device speed:
@@ -510,6 +514,7 @@ struct xhci_slot_ctx {
 #define MAX_EXIT	(0xffff)
 /* Root hub port number that is needed to access the USB device */
 #define ROOT_HUB_PORT(p)	(((p) & 0xff) << 16)
+#define DEVINFO_TO_ROOT_HUB_PORT(p)	(((p) >> 16) & 0xff)
 /* Maximum number of ports under a hub device */
 #define XHCI_MAX_PORTS(p)	(((p) & 0xff) << 24)
 
@@ -754,6 +759,7 @@ struct xhci_virt_device {
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
 	struct list_head		cmd_list;
+	u8				port;
 };
 
 
@@ -884,6 +890,10 @@ struct xhci_event_cmd {
 #define TRB_TO_EP_INDEX(p)		((((p) & (0x1f << 16)) >> 16) - 1)
 #define	EP_ID_FOR_TRB(p)		((((p) + 1) & 0x1f) << 16)
 
+#define SUSPEND_PORT_FOR_TRB(p)		(((p) & 1) << 23)
+#define TRB_TO_SUSPEND_PORT(p)		(((p) & (1 << 23)) >> 23)
+#define LAST_EP_INDEX			30
+
 /* Set TR Dequeue Pointer command TRB fields */
 #define TRB_TO_STREAM_ID(p)		((((p) & (0xffff << 16)) >> 16))
 #define STREAM_ID_FOR_TRB(p)		((((p)) & 0xffff) << 16)
@@ -1202,6 +1212,9 @@ struct xhci_hcd {
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
 #define XHCI_NEC_HOST		(1 << 2)
+	u32			port_c_suspend[8];	/* port suspend change*/
+	u32			suspended_ports[8];	/* which ports are
+							   suspended */
 };
 
 /* For testing purposes */
@@ -1409,7 +1422,7 @@ int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 int xhci_queue_vendor_command(struct xhci_hcd *xhci,
 		u32 field1, u32 field2, u32 field3, u32 field4);
 int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
-		unsigned int ep_index);
+		unsigned int ep_index, int suspend);
 int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
@@ -1439,6 +1452,8 @@ void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
+void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
+		unsigned int ep_index, unsigned int stream_id);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit c8d4af8e2af12cd4835ba5c4b54bdafe9deda71a
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:22:51 2010 -0700

    USB: core: use kernel assigned address for devices under xHCI
    
    xHCI driver uses hardware assigned device address. This may cause device
    address conflict in certain cases.
    
    Use kernel assigned address for devices under xHCI. Store the xHC assigned
    address locally in xHCI driver.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 490409f918f2..a7181b491e67 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -746,6 +746,8 @@ struct xhci_virt_device {
 	/* Rings saved to ensure old alt settings can be re-instated */
 	struct xhci_ring		**ring_cache;
 	int				num_rings_cached;
+	/* Store xHC assigned device address */
+	int				address;
 #define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
 	struct completion		cmd_completion;

commit f0615c45ce5feb141c1172480c5198d4b8d25436
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:22:48 2010 -0700

    USB: xHCI: change xhci_reset_device() to allocate new device
    
    Rename xhci_reset_device() to xhci_discover_or_reset_device().
    If xhci_discover_or_reset_device() is called to reset a device which does
    not exist or does not match the udev, it calls xhci_alloc_dev() to
    re-allocate the device.
    
    This would prevent the reset device failure, possibly due to the xHC restore
    error during S3/S4 resume.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f03f140a7d9a..490409f918f2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1389,7 +1389,7 @@ int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
 int xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
 void xhci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
-int xhci_reset_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 

commit 64927730c66333c9d5987aa72a0e6d44ed91cec7
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Oct 14 07:22:45 2010 -0700

    USB: xHCI: Add pointer to udev in struct xhci_virt_device
    
    Add a pointer to udev in struct xhci_virt_device. When allocate a new
    virt_device, make the pointer point to the corresponding udev.
    
    Modify xhci_check_args(), check if virt_dev->udev matches the target udev,
    to make sure command is issued to the right device.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 34a60d9f056a..f03f140a7d9a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -731,6 +731,7 @@ struct xhci_virt_ep {
 };
 
 struct xhci_virt_device {
+	struct usb_device		*udev;
 	/*
 	 * Commands to the hardware are passed an "input context" that
 	 * tells the hardware what to change in its data structures.

commit 257d585aaec469ded6ec15d8a8e7ebada21d7277
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 29 22:12:56 2010 -0700

    USB: xhci: Make xhci_set_hc_event_deq() static.
    
    Now that the event handler functions no longer use xhci_set_hc_event_deq()
    to update the event ring dequeue pointer, that function is not used by
    anything in xhci-ring.c.  Move that function into xhci-mem.c and make it
    static.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 25e108e981fa..34a60d9f056a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1400,7 +1400,6 @@ struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
 int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 void *xhci_setup_one_noop(struct xhci_hcd *xhci);
-void xhci_set_hc_event_deq(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);

commit d6d98a4d8d2411bca7e15d9c0796bf3bc30c3f21
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 29 22:12:46 2010 -0700

    USB: xhci: Make xhci_handle_event() static.
    
    xhci_handle_event() is now only called from within xhci-ring.c, so make it
    static.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6d829c41d963..25e108e981fa 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1400,7 +1400,6 @@ struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
 int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 void *xhci_setup_one_noop(struct xhci_hcd *xhci);
-void xhci_handle_event(struct xhci_hcd *xhci);
 void xhci_set_hc_event_deq(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,

commit 9032cd52798daf4cd6314ffea5030b37b3eb34af
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 29 22:12:29 2010 -0700

    USB: xhci: Performance - move interrupt handlers into xhci-ring.c
    
    Most of the work for interrupt handling is done in xhci-ring.c, so it makes
    sense to move the functions that are first called when an interrupt happens
    (xhci_irq() or xhci_msi_irq()) into xhci-ring.c, so that the compiler can better
    optimize them.
    
    Shorten some lines to make it pass checkpatch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9fe95c4e2a56..6d829c41d963 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1371,6 +1371,7 @@ void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
+irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,

commit 021bff9179c2d19c26599dc3e9134d04cf1c8a3a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 29 22:12:20 2010 -0700

    USB: xhci: Performance - move functions that find ep ring.
    
    I've been using perf to measure the top symbols while transferring 1GB of data
    on a USB 3.0 drive with dd.  This is using the raw disk with /dev/sdb, with a
    block size of 1K.
    
    During performance testing, the top symbol was xhci_triad_to_transfer_ring(), a
    function that should return immediately if streams are not enabled for an
    endpoint.  It turned out that the functions to find the endpoint ring was
    defined in xhci-mem.c and used in xhci-ring.c and xhci-hcd.c.  I moved a copy of
    xhci_triad_to_transfer_ring() and xhci_urb_to_transfer_ring() into xhci-ring.c
    and declared them static.  I also made a static version of
    xhci_urb_to_transfer_ring() in xhci.c.
    
    This improved throughput on a 1GB read of the raw disk with dd from
    186MB/s to 195MB/s, and perf reported sampling the xhci_triad_to_transfer_ring()
    0.06% of the time, rather than 9.26% of the time.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e1383d91468b..9fe95c4e2a56 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1344,11 +1344,6 @@ void xhci_setup_no_streams_ep_input_ctx(struct xhci_hcd *xhci,
 struct xhci_ring *xhci_dma_to_transfer_ring(
 		struct xhci_virt_ep *ep,
 		u64 address);
-struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
-		struct urb *urb);
-struct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,
-		unsigned int slot_id, unsigned int ep_index,
-		unsigned int stream_id);
 struct xhci_ring *xhci_stream_id_to_ring(
 		struct xhci_virt_device *dev,
 		unsigned int ep_index,

commit 04e51901dd44f40a5a385ced897f6bca87d5f40a
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Jul 22 15:23:39 2010 -0700

    USB: xHCI: Isochronous transfer implementation
    
    This patch implements isochronous urb enqueue and interrupt handler part.
    
    When an isochronous urb is passed to xHCI driver, first check the transfer
    ring to guarantee there is enough room for the whole urb. Then update the
    start_frame and interval field of the urb. Always assume URB_ISO_ASAP
    is set, and never use urb->start_frame as input.
    
    The number of isoc TDs is equal to urb->number_of_packets. One isoc TD is
    consumed every Interval. Each isoc TD consists of an Isoch TRB chained to
    zero or more Normal TRBs.
    
    Call prepare_transfer for each TD to do initialization; then calculate the
    number of TRBs needed for each TD. If the data required by an isoc TD is
    physically contiguous (not crosses a page boundary), then only one isoc TRB
    is needed; otherwise one or more additional normal TRB shall be chained to
    the isoc TRB by the host.
    
    Set TRB_IOC to the last TRB of each isoc TD. Do not ring endpoint doorbell
    to start xHC procession until all the TDs are inserted to the endpoint
    transer ring.
    
    In irq handler, update urb status and actual_length, increase
    urb_priv->td_cnt. When all the TDs are completed(td_cnt is equal to
    urb_priv->length), giveback the urb to usbcore.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ebf62082950b..e1383d91468b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -919,6 +919,9 @@ struct xhci_event_cmd {
 /* Control transfer TRB specific fields */
 #define TRB_DIR_IN		(1<<16)
 
+/* Isochronous TRB specific fields */
+#define TRB_SIA			(1<<31)
+
 struct xhci_generic_trb {
 	u32 field[4];
 };
@@ -1416,6 +1419,8 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
+int xhci_queue_isoc_tx_prepare(struct xhci_hcd *xhci, gfp_t mem_flags,
+		struct urb *urb, int slot_id, unsigned int ep_index);
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id, bool command_must_succeed);
 int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,

commit 8e51adccd4c4b9ffcd509d7f2afce0a906139f75
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Jul 22 15:23:31 2010 -0700

    USB: xHCI: Introduce urb_priv structure
    
    Add urb_priv data structure to xHCI driver. This structure allows multiple
    xhci TDs to be linked to one urb, which is essential for isochronous
    transfer. For non-isochronous urb, only one TD is needed for one urb;
    for isochronous urb, the TD number for the urb is equal to
    urb->number_of_packets.
    
    The length field of urb_priv indicates the number of TDs in the urb.
    The td_cnt field indicates the number of TDs already processed by xHC.
    When td_cnt matches length, the urb can be given back to usbcore.
    
    When an urb is dequeued or cancelled, add all the unprocessed TDs to the
    endpoint's cancelled_td_list. When process a cancelled TD, increase
    td_cnt field. When td_cnt equals urb_priv->length, giveback the
    cancelled urb.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f4dfb26a65aa..ebf62082950b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1090,6 +1090,12 @@ struct xhci_scratchpad {
 	dma_addr_t *sp_dma_buffers;
 };
 
+struct urb_priv {
+	int	length;
+	int	td_cnt;
+	struct	xhci_td	*td[0];
+};
+
 /*
  * Each segment table entry is 4*32bits long.  1K seems like an ok size:
  * (1K bytes * 8bytes/bit) / (4*32 bits) = 64 segment entries in the table,
@@ -1347,6 +1353,7 @@ struct xhci_ring *xhci_stream_id_to_ring(
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_in_ctx, bool allocate_completion,
 		gfp_t mem_flags);
+void xhci_urb_free_priv(struct xhci_hcd *xhci, struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
 

commit d18240db797ed749b511b8dc910c5dcf08be46d6
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Thu Jul 22 15:23:25 2010 -0700

    USB: xHCI: Missed Service Error Event process
    
    This patch adds mechanism to process Missed Service Error Event.
    Sometimes the xHC is unable to process the isoc TDs in time, it will
    generate Missed Service Error Event. In this case some TDs on the ring are
    not processed and missed. When encounter a Missed Servce Error Event, set
    the skip flag of the ep, and process the missed TDs until reach the next
    processed TD, then clear the skip flag.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5bc03d1c2beb..f4dfb26a65aa 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -720,6 +720,14 @@ struct xhci_virt_ep {
 	struct timer_list	stop_cmd_timer;
 	int			stop_cmds_pending;
 	struct xhci_hcd		*xhci;
+	/*
+	 * Sometimes the xHC can not process isochronous endpoint ring quickly
+	 * enough, and it will miss some isoc tds on the ring and generate
+	 * a Missed Service Error Event.
+	 * Set skip flag when receive a Missed Service Error Event and
+	 * process the missed tds on the endpoint ring.
+	 */
+	bool			skip;
 };
 
 struct xhci_virt_device {

commit 43b86af83da7db8b2c6d85ca970203950e5bad88
Author: Dong Nguyen <Dong.Nguyen@amd.com>
Date:   Wed Jul 21 16:56:08 2010 -0700

    USB: xHCI: Supporting MSI/MSI-X
    
    Enable MSI/MSI-X supporting in xhci driver.
    
    Provide the mechanism to fall back using MSI and Legacy IRQs
    if MSI-X IRQs register failed.
    
    Signed-off-by: Dong Nguyen <Dong.Nguyen@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>,
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6c7e3430ec93..5bc03d1c2beb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1130,7 +1130,7 @@ struct xhci_hcd {
 	int		page_size;
 	/* Valid values are 12 to 20, inclusive */
 	int		page_shift;
-	/* only one MSI vector for now, but might need more later */
+	/* msi-x vectors */
 	int		msix_count;
 	struct msix_entry	*msix_entries;
 	/* data structures */

commit 2d1ee5904bb51ea33c6a6f4bec6b6a243e2432a8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Jul 9 17:08:54 2010 +0200

    USB: xhci: Set EP0 dequeue ptr after reset of configured device.
    
    When a configured device is reset, the control endpoint's ring is reused.
    If control transfers to the device were issued before the device is reset,
    the dequeue pointer will be somewhere in the middle of the ring.  If the
    device is then issued an address with the set address command, the xHCI
    driver must provide a valid input context for control endpoint zero.
    
    The original code would give the hardware the original input context,
    which had a dequeue pointer set to the top of the ring.  This would cause
    the host to re-execute any control transfers until it reached the ring's
    enqueue pointer.  When issuing a set address command for a device that has
    just been configured and then reset, use the control endpoint's enqueue
    pointer as the hardware's dequeue pointer.
    
    Assumption:  All control transfers will be completed or cancelled before
    the set address command is issued to the device.  If there are any
    outstanding control transfers, this code will not work.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8b4b7d39f79c..6c7e3430ec93 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1292,6 +1292,8 @@ int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);
 void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);
 int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device *udev, gfp_t flags);
 int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);
+void xhci_copy_ep0_dequeue_into_input_ctx(struct xhci_hcd *xhci,
+		struct usb_device *udev);
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);

commit 0238634d02dd10b678ebe9ea5d8803483277ee93
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon May 24 13:25:28 2010 -0700

    USB: xhci: Print NEC firmware version.
    
    The NEC xHCI host controller firmware version can be found by putting a
    vendor-specific command on the command ring and extracting the BCD
    encoded-version out of the vendor-specific event TRB.
    
    The firmware version debug line in dmesg will look like:
    
    xhci_hcd 0000:05:00.0: NEC firmware version 30.21
    
    (NEC merged with Renesas Technologies and became Renesas Electronics on
    April 1, 2010.  I have their OK to merge this vendor-specific code.)
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Satoshi Otani <satoshi.otani.xm@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index dada2fb59261..8b4b7d39f79c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -925,6 +925,7 @@ union xhci_trb {
 /* TRB bit mask */
 #define	TRB_TYPE_BITMASK	(0xfc00)
 #define TRB_TYPE(p)		((p) << 10)
+#define TRB_FIELD_TO_TYPE(p)	(((p) & TRB_TYPE_BITMASK) >> 10)
 /* TRB type IDs */
 /* bulk, interrupt, isoc scatter/gather, and control data stage */
 #define TRB_NORMAL		1
@@ -992,6 +993,14 @@ union xhci_trb {
 #define TRB_MFINDEX_WRAP	39
 /* TRB IDs 40-47 reserved, 48-63 is vendor-defined */
 
+/* Nec vendor-specific command completion event. */
+#define	TRB_NEC_CMD_COMP	48
+/* Get NEC firmware revision. */
+#define	TRB_NEC_GET_FW		49
+
+#define NEC_FW_MINOR(p)		(((p) >> 0) & 0xff)
+#define NEC_FW_MAJOR(p)		(((p) >> 8) & 0xff)
+
 /*
  * TRBS_PER_SEGMENT must be a multiple of 4,
  * since the command ring is 64-byte aligned.
@@ -1172,6 +1181,7 @@ struct xhci_hcd {
 	unsigned int		quirks;
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 #define XHCI_RESET_EP_QUIRK	(1 << 1)
+#define XHCI_NEC_HOST		(1 << 2)
 };
 
 /* For testing purposes */
@@ -1379,6 +1389,8 @@ void xhci_set_hc_event_deq(struct xhci_hcd *xhci);
 int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
+int xhci_queue_vendor_command(struct xhci_hcd *xhci,
+		u32 field1, u32 field2, u32 field3, u32 field4);
 int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
 int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,

commit e9df17eb1408cfafa3d1844bfc7f22c7237b31b8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Apr 2 15:34:43 2010 -0700

    USB: xhci: Correct assumptions about number of rings per endpoint.
    
    Much of the xHCI driver code assumes that endpoints only have one ring.
    Now an endpoint can have one ring per enabled stream ID, so correct that
    assumption.  Use functions that translate the stream_id field in the URB
    or the DMA address of a TRB into the correct stream ring.
    
    Correct the polling loop to print out all enabled stream rings.  Make the
    URB cancellation routine find the correct stream ring if the URB has
    stream_id set.  Make sure the URB enqueueing routine does the same.  Also
    correct the code that handles stalled/halted endpoints.
    
    Check that commands and registers that can take stream IDs handle them
    properly.  That includes ringing an endpoint doorbell, resetting a
    stalled/halted endpoint, and setting a transfer ring dequeue pointer
    (since that command can set the dequeue pointer in a stream context or an
    endpoint context).
    
    Correct the transfer event handler to translate a TRB DMA address into the
    stream ring it was enqueued to.  Make the code to allocate and prepare TD
    structures adds the TD to the right td_list for the stream ring.  Make
    sure the code to give the first TRB in a TD to the hardware manipulates
    the correct stream ring.
    
    When an endpoint stalls, store the stream ID of the stream ring that
    stalled in the xhci_virt_ep structure.  Use that instead of the stream ID
    in the URB, since an URB may be re-used after it is given back after a
    non-control endpoint stall.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7a9447cb6ea9..dada2fb59261 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -444,6 +444,7 @@ struct xhci_doorbell_array {
 
 /* Endpoint Target - bits 0:7 */
 #define EPI_TO_DB(p)		(((p) + 1) & 0xff)
+#define STREAM_ID_TO_DB(p)	(((p) & 0xffff) << 16)
 
 
 /**
@@ -714,6 +715,7 @@ struct xhci_virt_ep {
 	/* The TRB that was last reported in a stopped endpoint ring */
 	union xhci_trb		*stopped_trb;
 	struct xhci_td		*stopped_td;
+	unsigned int		stopped_stream;
 	/* Watchdog timer for stop endpoint command to cancel URBs */
 	struct timer_list	stop_cmd_timer;
 	int			stop_cmds_pending;
@@ -871,6 +873,10 @@ struct xhci_event_cmd {
 #define TRB_TO_EP_INDEX(p)		((((p) & (0x1f << 16)) >> 16) - 1)
 #define	EP_ID_FOR_TRB(p)		((((p) + 1) & 0x1f) << 16)
 
+/* Set TR Dequeue Pointer command TRB fields */
+#define TRB_TO_STREAM_ID(p)		((((p) & (0xffff << 16)) >> 16))
+#define STREAM_ID_FOR_TRB(p)		((((p)) & 0xffff) << 16)
+
 
 /* Port Status Change Event TRB fields */
 /* Port ID - bits 31:24 */
@@ -1040,6 +1046,7 @@ struct xhci_ring {
 	 * if we own the TRB (if we are the consumer).  See section 4.9.1.
 	 */
 	u32			cycle_state;
+	unsigned int		stream_id;
 };
 
 struct xhci_erst_entry {
@@ -1265,6 +1272,9 @@ void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
+void xhci_dbg_ep_rings(struct xhci_hcd *xhci,
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_virt_ep *ep);
 
 /* xHCI memory management */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
@@ -1302,6 +1312,18 @@ void xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,
 void xhci_setup_no_streams_ep_input_ctx(struct xhci_hcd *xhci,
 		struct xhci_ep_ctx *ep_ctx,
 		struct xhci_virt_ep *ep);
+struct xhci_ring *xhci_dma_to_transfer_ring(
+		struct xhci_virt_ep *ep,
+		u64 address);
+struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,
+		struct urb *urb);
+struct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,
+		unsigned int slot_id, unsigned int ep_index,
+		unsigned int stream_id);
+struct xhci_ring *xhci_stream_id_to_ring(
+		struct xhci_virt_device *dev,
+		unsigned int ep_index,
+		unsigned int stream_id);
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_in_ctx, bool allocate_completion,
 		gfp_t mem_flags);
@@ -1374,9 +1396,11 @@ int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
 int xhci_queue_reset_device(struct xhci_hcd *xhci, u32 slot_id);
 void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
-		struct xhci_td *cur_td, struct xhci_dequeue_state *state);
+		unsigned int stream_id, struct xhci_td *cur_td,
+		struct xhci_dequeue_state *state);
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
+		unsigned int stream_id,
 		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
 		struct usb_device *udev, unsigned int ep_index);

commit 8df75f42f8e67e2851cdcf6da91640fb881defd1
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Apr 2 15:34:16 2010 -0700

    USB: xhci: Add memory allocation for USB3 bulk streams.
    
    Add support for allocating streams for USB 3.0 bulk endpoints.  See
    Documentation/usb/bulk-streams.txt for more information about how and why
    you would use streams.
    
    When an endpoint has streams enabled, instead of having one ring where all
    transfers are enqueued to the hardware, it has several rings.  The ring
    dequeue pointer in the endpoint context is changed to point to a "Stream
    Context Array".  This is basically an array of pointers to transfer rings,
    one for each stream ID that the driver wants to use.
    
    The Stream Context Array size must be a power of two, and host controllers
    can place a limit on the size of the array (4 to 2^16 entries).  These
    two facts make calculating the size of the Stream Context Array and the
    number of entries actually used by the driver a bit tricky.
    
    Besides the Stream Context Array and rings for all the stream IDs, we need
    one more data structure.  The xHCI hardware will not tell us which stream
    ID a transfer event was for, but it will give us the slot ID, endpoint
    index, and physical address for the TRB that caused the event.  For every
    endpoint on a device, add a radix tree to map physical TRB addresses to
    virtual segments within a stream ring.
    
    Keep track of whether an endpoint is transitioning to using streams, and
    don't enqueue any URBs while that's taking place.  Refuse to transition an
    endpoint to streams if there are already URBs enqueued for that endpoint.
    
    We need to make sure that freeing streams does not fail, since a driver's
    disconnect() function may attempt to do this, and it cannot fail.
    Pre-allocate the command structure used to issue the Configure Endpoint
    command, and reserve space on the command ring for each stream endpoint.
    This may be a bit overkill, but it is permissible for the driver to
    allocate all streams in one call and free them in multiple calls.  (It is
    not advised, however, since it is a waste of resources and time.)
    
    Even with the memory and ring room pre-allocated, freeing streams can
    still fail because the xHC rejects the configure endpoint command.  It is
    valid (by the xHCI 0.96 spec) to return a "Bandwidth Error" or a "Resource
    Error" for a configure endpoint command.  We should never see a Bandwidth
    Error, since bulk endpoints do not effect the reserved bandwidth.  The
    host controller can still return a Resource Error, but it's improbable
    since the xHC would be going from a more resource-intensive configuration
    (streams) to a less resource-intensive configuration (no streams).
    
    If the xHC returns a Resource Error, the endpoint will be stuck with
    streams and will be unusable for drivers.  It's an unavoidable consequence
    of broken host controller hardware.
    
    Includes bug fixes from the original patch, contributed by
    John Youn <John.Youn@synopsys.com> and Andy Green <AGreen@PLXTech.com>
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a7c4e1122902..7a9447cb6ea9 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -117,7 +117,7 @@ struct xhci_cap_regs {
 /* true: no secondary Stream ID Support */
 #define HCC_NSS(p)		((p) & (1 << 7))
 /* Max size for Primary Stream Arrays - 2^(n+1), where n is bits 12:15 */
-#define HCC_MAX_PSA		(1 << ((((p) >> 12) & 0xf) + 1))
+#define HCC_MAX_PSA(p)		(1 << ((((p) >> 12) & 0xf) + 1))
 /* Extended Capabilities pointer from PCI base - section 5.3.6 */
 #define HCC_EXT_CAPS(p)		XHCI_HCC_EXT_CAPS(p)
 
@@ -585,6 +585,10 @@ struct xhci_ep_ctx {
 /* Interval - period between requests to an endpoint - 125u increments. */
 #define EP_INTERVAL(p)		((p & 0xff) << 16)
 #define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
+#define EP_MAXPSTREAMS_MASK	(0x1f << 10)
+#define EP_MAXPSTREAMS(p)	(((p) << 10) & EP_MAXPSTREAMS_MASK)
+/* Endpoint is set up with a Linear Stream Array (vs. Secondary Stream Array) */
+#define	EP_HAS_LSA		(1 << 15)
 
 /* ep_info2 bitmasks */
 /*
@@ -648,8 +652,50 @@ struct xhci_command {
 /* add context bitmasks */
 #define	ADD_EP(x)	(0x1 << x)
 
+struct xhci_stream_ctx {
+	/* 64-bit stream ring address, cycle state, and stream type */
+	u64	stream_ring;
+	/* offset 0x14 - 0x1f reserved for HC internal use */
+	u32	reserved[2];
+};
+
+/* Stream Context Types (section 6.4.1) - bits 3:1 of stream ctx deq ptr */
+#define	SCT_FOR_CTX(p)		(((p) << 1) & 0x7)
+/* Secondary stream array type, dequeue pointer is to a transfer ring */
+#define	SCT_SEC_TR		0
+/* Primary stream array type, dequeue pointer is to a transfer ring */
+#define	SCT_PRI_TR		1
+/* Dequeue pointer is for a secondary stream array (SSA) with 8 entries */
+#define SCT_SSA_8		2
+#define SCT_SSA_16		3
+#define SCT_SSA_32		4
+#define SCT_SSA_64		5
+#define SCT_SSA_128		6
+#define SCT_SSA_256		7
+
+/* Assume no secondary streams for now */
+struct xhci_stream_info {
+	struct xhci_ring		**stream_rings;
+	/* Number of streams, including stream 0 (which drivers can't use) */
+	unsigned int			num_streams;
+	/* The stream context array may be bigger than
+	 * the number of streams the driver asked for
+	 */
+	struct xhci_stream_ctx		*stream_ctx_array;
+	unsigned int			num_stream_ctxs;
+	dma_addr_t			ctx_array_dma;
+	/* For mapping physical TRB addresses to segments in stream rings */
+	struct radix_tree_root		trb_address_map;
+	struct xhci_command		*free_streams_command;
+};
+
+#define	SMALL_STREAM_ARRAY_SIZE		256
+#define	MEDIUM_STREAM_ARRAY_SIZE	1024
+
 struct xhci_virt_ep {
 	struct xhci_ring		*ring;
+	/* Related to endpoints that are configured to use stream IDs only */
+	struct xhci_stream_info		*stream_info;
 	/* Temporary storage in case the configure endpoint command fails and we
 	 * have to restore the device state to the previous state
 	 */
@@ -658,6 +704,11 @@ struct xhci_virt_ep {
 #define SET_DEQ_PENDING		(1 << 0)
 #define EP_HALTED		(1 << 1)	/* For stall handling */
 #define EP_HALT_PENDING		(1 << 2)	/* For URB cancellation */
+/* Transitioning the endpoint to using streams, don't enqueue URBs */
+#define EP_GETTING_STREAMS	(1 << 3)
+#define EP_HAS_STREAMS		(1 << 4)
+/* Transitioning the endpoint to not using streams, don't enqueue URBs */
+#define EP_GETTING_NO_STREAMS	(1 << 5)
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
 	/* The TRB that was last reported in a stopped endpoint ring */
@@ -710,14 +761,6 @@ struct xhci_device_context_array {
  */
 
 
-struct xhci_stream_ctx {
-	/* 64-bit stream ring address, cycle state, and stream type */
-	u64	stream_ring;
-	/* offset 0x14 - 0x1f reserved for HC internal use */
-	u32	reserved[2];
-};
-
-
 struct xhci_transfer_event {
 	/* 64-bit buffer address, or immediate data */
 	u64	buffer;
@@ -952,6 +995,10 @@ union xhci_trb {
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
+/* SEGMENT_SHIFT should be log2(SEGMENT_SIZE).
+ * Change this if you change TRBS_PER_SEGMENT!
+ */
+#define SEGMENT_SHIFT		10
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
@@ -1088,6 +1135,8 @@ struct xhci_hcd {
 	/* DMA pools */
 	struct dma_pool	*device_pool;
 	struct dma_pool	*segment_pool;
+	struct dma_pool	*small_streams_pool;
+	struct dma_pool	*medium_streams_pool;
 
 #ifdef CONFIG_USB_XHCI_HCD_DEBUGGING
 	/* Poll the rings - for debugging */
@@ -1242,6 +1291,17 @@ void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);
+struct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,
+		unsigned int num_stream_ctxs,
+		unsigned int num_streams, gfp_t flags);
+void xhci_free_stream_info(struct xhci_hcd *xhci,
+		struct xhci_stream_info *stream_info);
+void xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,
+		struct xhci_ep_ctx *ep_ctx,
+		struct xhci_stream_info *stream_info);
+void xhci_setup_no_streams_ep_input_ctx(struct xhci_hcd *xhci,
+		struct xhci_ep_ctx *ep_ctx,
+		struct xhci_virt_ep *ep);
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_in_ctx, bool allocate_completion,
 		gfp_t mem_flags);
@@ -1266,6 +1326,12 @@ int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		unsigned int num_streams, gfp_t mem_flags);
+int xhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		gfp_t mem_flags);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
 			struct usb_tt *tt, gfp_t mem_flags);

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ea389e9a4931..a7c4e1122902 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -26,8 +26,8 @@
 #include <linux/usb.h>
 #include <linux/timer.h>
 #include <linux/kernel.h>
+#include <linux/usb/hcd.h>
 
-#include "../core/hcd.h"
 /* Code sharing between pci-quirks and xhci hcd */
 #include	"xhci-ext-caps.h"
 

commit 9238f25d5d32a435277eb234ec82bacdd5daed41
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Apr 16 08:07:27 2010 -0700

    USB: xhci: properly set endpoint context fields for periodic eps.
    
    For periodic endpoints, we must let the xHCI hardware know the maximum
    payload an endpoint can transfer in one service interval.  The xHCI
    specification refers to this as the Maximum Endpoint Service Interval Time
    Payload (Max ESIT Payload).  This is used by the hardware for bandwidth
    management and scheduling of packets.
    
    For SuperSpeed endpoints, the maximum is calculated by multiplying the max
    packet size by the number of bursts and the number of opportunities to
    transfer within a service interval (the Mult field of the SuperSpeed
    Endpoint companion descriptor).  Devices advertise this in the
    wBytesPerInterval field of their SuperSpeed Endpoint Companion Descriptor.
    
    For high speed devices, this is taken by multiplying the max packet size by the
    "number of additional transaction opportunities per microframe" (the high
    bits of the wMaxPacketSize field in the endpoint descriptor).
    
    For FS/LS devices, this is just the max packet size.
    
    The other thing we must set in the endpoint context is the Average TRB
    Length.  This is supposed to be the average of the total bytes in the
    transfer descriptor (TD), divided by the number of transfer request blocks
    (TRBs) it takes to describe the TD.  This gives the host controller an
    indication of whether the driver will be enqueuing a scatter gather list
    with many entries comprised of small buffers, or one contiguous buffer.
    
    It also takes into account the number of extra TRBs you need for every TD.
    This includes No-op TRBs and Link TRBs used to link ring segments
    together.  Some drivers may choose to chain an Event Data TRB on the end
    of every TD, thus increasing the average number of TRBs per TD.  The Linux
    xHCI driver does not use Event Data TRBs.
    
    In theory, if there was an API to allow drivers to state what their
    bandwidth requirements are, we could set this field accurately.  For now,
    we set it to the same number as the Max ESIT payload.
    
    The Average TRB Length should also be set for bulk and control endpoints,
    but I have no idea how to guess what it should be.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e5eb09b2f38e..ea389e9a4931 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -609,6 +609,10 @@ struct xhci_ep_ctx {
 #define MAX_PACKET_MASK		(0xffff << 16)
 #define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
 
+/* tx_info bitmasks */
+#define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
+#define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
+
 
 /**
  * struct xhci_input_control_context

commit 9c9a7dbf9a73191a24a13b9a0412355254a122c7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jan 4 12:20:17 2010 -0800

    USB: xhci: Fix compile issues with xhci_get_slot_state()
    
    Randy Dunlap reported this error when compiling the xHCI driver:
    
    linux-next-20100104/drivers/usb/host/xhci.h:1214:
    sorry, unimplemented: inlining failed in call to 'xhci_get_slot_state': function body not available
    
    The xhci_get_slot_state() function belongs in xhci-dbg.c, since it
    involves debugging internal xHCI structures.  However, it is only used in
    xhci-hcd.c.  Some toolchains may have issues since the inlined function
    body is not in the xhci.h header file.  Remove the inline keyword to avoid
    this.
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 741ece482e31..e5eb09b2f38e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1210,7 +1210,7 @@ void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
-inline char *xhci_get_slot_state(struct xhci_hcd *xhci,
+char *xhci_get_slot_state(struct xhci_hcd *xhci,
 		struct xhci_container_ctx *ctx);
 
 /* xHCI memory management */

commit a5f0efaba4c2b644e6248648f75b0a8a522359f6
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:17 2009 -0800

    USB: Add call to notify xHC of a device reset.
    
    Add a new host controller driver method, reset_device(), that the USB core
    will use to notify the host of a successful device reset.  The call may
    fail due to out-of-memory errors; attempt the port reset sequence again if
    that happens.  Update hub_port_init() to allow resetting a configured
    device.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index feb0101f91eb..741ece482e31 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1270,6 +1270,7 @@ int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
 int xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
 void xhci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
+int xhci_reset_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 

commit 2a8f82c4ceaffcfd64531dbdee1d1bc227387882
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:13 2009 -0800

    USB: xhci: Notify the xHC when a device is reset.
    
    When a USB device is reset, the xHCI hardware must know, in order to match
    the device state and disable all endpoints except control endpoint 0.
    Issue a Reset Device command after a USB device is successfully reset.
    Wait on the command to finish, and then cache or free the disabled
    endpoint rings.
    
    There are four different USB device states that the xHCI hardware tracks:
     - disabled/enabled - device connection has just been detected,
     - default - the device has been reset and has an address of 0,
     - addressed - the device has a non-zero address but no configuration has
       been set,
     - configured - a set configuration succeeded.
    
    The USB core may issue a port reset when a device is in any state, but the
    Reset Device command will fail for a 0.96 xHC if the device is not in the
    addressed or configured state.  Don't consider this failure as an error,
    but don't free any endpoint rings if this command fails.
    
    A storage driver may request that the USB device be reset during error
    handling, so use GPF_NOIO instead of GPF_KERNEL while allocating memory
    for the Reset Device command.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 20122ec75d94..feb0101f91eb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1210,6 +1210,8 @@ void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
+inline char *xhci_get_slot_state(struct xhci_hcd *xhci,
+		struct xhci_container_ctx *ctx);
 
 /* xHCI memory management */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
@@ -1298,6 +1300,7 @@ int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
+int xhci_queue_reset_device(struct xhci_hcd *xhci, u32 slot_id);
 void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_td *cur_td, struct xhci_dequeue_state *state);

commit b45b506911247008f694dcaf1d8220a4942ebc4f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:06 2009 -0800

    USB: xhci: Refactor test for vendor-specific completion codes.
    
    All commands that can be issued to the xHCI hardware can come back with
    vendor-specific "informational" completion codes.  These are to be treated
    like a successful completion code.  Refactor out the code to test for the
    range of these codes and print debugging messages.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 902be9647c60..20122ec75d94 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1276,6 +1276,7 @@ dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
 struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
 		union xhci_trb *start_trb, union xhci_trb *end_trb,
 		dma_addr_t suspect_dma);
+int xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 void *xhci_setup_one_noop(struct xhci_hcd *xhci);
 void xhci_handle_event(struct xhci_hcd *xhci);

commit a1d78c16bd31a715785e21967ac6110b386a3c1f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:03 2009 -0800

    USB: xhci: Allow allocation of commands without input contexts.
    
    The xhci_command structure is the basic structure for issuing commands to
    the xHCI hardware.  It contains a struct completion (so that the issuing
    function can wait on the command), command status, and a input context
    that is used to pass information to the hardware.  Not all commands need
    the input context, so make it optional to allocate.  Allow
    xhci_free_container_ctx() to be passed a NULL input context, to make
    freeing the xhci_command structure simple.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 61747f3c5c8f..902be9647c60 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1237,7 +1237,8 @@ void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
-		bool allocate_completion, gfp_t mem_flags);
+		bool allocate_in_ctx, bool allocate_completion,
+		gfp_t mem_flags);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
 

commit 412566bd716397e28e81fc9b20804bc6a6daf14d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Dec 9 15:59:01 2009 -0800

    USB: xhci: Refactor code to free or cache endpoint rings.
    
    Refactor out the code to cache or free endpoint rings from recently
    dropped or disabled endpoints.  This code will be used by a new function
    to reset a device and disable all endpoints except control endpoint 0.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 877813505ef2..61747f3c5c8f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1233,6 +1233,9 @@ int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
+void xhci_free_or_cache_endpoint_ring(struct xhci_hcd *xhci,
+		struct xhci_virt_device *virt_dev,
+		unsigned int ep_index);
 struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
 		bool allocate_completion, gfp_t mem_flags);
 void xhci_free_command(struct xhci_hcd *xhci,

commit 74f9fe21e0440066eb337b9f644238cb3050b91c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 3 09:44:29 2009 -0800

    USB: xhci: Make reverting an alt setting "unfailable".
    
    When a driver wants to switch to a different alternate setting for an
    interface, the USB core will (soon) check whether there is enough
    bandwidth.  Once the new alternate setting is installed in the xHCI
    hardware, the USB core will send a USB_REQ_SET_INTERFACE control
    message.  That can fail in various ways, and the USB core needs to be
    able to reinstate the old alternate setting.
    
    With the old code, reinstating the old alt setting could fail if the
    there's not enough memory to allocate new endpoint rings.  Keep
    around a cache of (at most 31) endpoint rings for this case.  When we
    successfully switch the xHCI hardware to the new alt setting, the old
    alt setting's rings will be stored in the cache.  Therefore we'll
    always have enough rings to satisfy a conversion back to a previous
    device setting.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bb8e6656cca4..877813505ef2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -677,6 +677,10 @@ struct xhci_virt_device {
 	struct xhci_container_ctx       *out_ctx;
 	/* Used for addressing devices and configuration changes */
 	struct xhci_container_ctx       *in_ctx;
+	/* Rings saved to ensure old alt settings can be re-instated */
+	struct xhci_ring		**ring_cache;
+	int				num_rings_cached;
+#define	XHCI_MAX_RINGS_CACHED	31
 	struct xhci_virt_ep		eps[31];
 	struct completion		cmd_completion;
 	/* Status of the last command issued for this device */

commit 04dd950d92f41155ed0cdf39b6bfbeea22eadb34
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Nov 11 10:28:30 2009 -0800

    USB: xhci: Set transfer descriptor size field correctly.
    
    The transfer descriptor (TD) is a series of transfer request buffers
    (TRBs) that describe the buffer pointer, length, and other
    characteristics.  The xHCI controllers want to know an estimate of how
    long the TD is, for caching reasons.  In each TRB, there is a "TD size"
    field that provides a rough estimate of the remaining buffers to be
    transmitted, including the buffer pointed to by that TRB.
    
    The TD size is 5 bits long, and contains the remaining size in bytes,
    right shifted by 10 bits.  So a remaining TD size less than 1024 would get
    a zero in the TD size field, and a remaining size greater than 32767 would
    get 31 in the field.
    
    This patches fixes a bug in the TD_REMAINDER macro that is triggered when
    the URB has a scatter gather list with a size bigger than 32767 bytes.
    Not all host controllers pay attention to the TD size field, so the bug
    will not appear on all USB 3.0 hosts.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3989aadcf670..bb8e6656cca4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -828,9 +828,6 @@ struct xhci_event_cmd {
 /* Normal TRB fields */
 /* transfer_len bitmasks - bits 0:16 */
 #define	TRB_LEN(p)		((p) & 0x1ffff)
-/* TD size - number of bytes remaining in the TD (including this TRB):
- * bits 17 - 21.  Shift the number of bytes by 10. */
-#define TD_REMAINDER(p)		((((p) >> 10) & 0x1f) << 17)
 /* Interrupter Target - which MSI-X vector to target the completion event at */
 #define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
 #define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)

commit 6648f29d3be2972a74ef8e29aa5d425ab4f1fc48
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Nov 9 13:35:23 2009 -0800

    USB: xhci: Add tests for TRB address translation.
    
    It's not surprising that the transfer request buffer (TRB) physical to
    virtual address translation function has bugs in it, since I wrote most of
    it at 4am last October.  Add a test suite to check the TRB math.  This
    runs at memory initialization time, and causes the driver to fail to load
    if the TRB math fails.
    
    Please excuse the excessively long lines in the test vectors; they can't
    really be made shorter and still be readable.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index c92f84154fb5..3989aadcf670 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1268,6 +1268,9 @@ void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
+struct xhci_segment *trb_in_td(struct xhci_segment *start_seg,
+		union xhci_trb *start_trb, union xhci_trb *end_trb,
+		dma_addr_t suspect_dma);
 void xhci_ring_cmd_db(struct xhci_hcd *xhci);
 void *xhci_setup_one_noop(struct xhci_hcd *xhci);
 void xhci_handle_event(struct xhci_hcd *xhci);

commit 6f5165cf989387e84ef23122330b27cca1cbe831
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 27 10:57:01 2009 -0700

    USB: xhci: Add watchdog timer for URB cancellation.
    
    In order to giveback a canceled URB, we must ensure that the xHCI
    hardware will not access the buffer in an URB.  We can't modify the
    buffer pointers on endpoint rings without issuing and waiting for a stop
    endpoint command.  Since URBs can be canceled in interrupt context, we
    can't wait on that command.  The old code trusted that the host
    controller would respond to the command, and would giveback the URBs in
    the event handler.  If the hardware never responds to the stop endpoint
    command, the URBs will never be completed, and we might hang the USB
    subsystem.
    
    Implement a watchdog timer that is spawned whenever a stop endpoint
    command is queued.  If a stop endpoint command event is found on the
    event ring during an interrupt, we need to stop the watchdog timer with
    del_timer().  Since del_timer() can fail if the timer is running and
    waiting on the xHCI lock, we need a way to signal to the timer that
    everything is fine and it should exit.  If we simply clear
    EP_HALT_PENDING, a new stop endpoint command could sneak in and set it
    before the watchdog timer can grab the lock.
    
    Instead we use a combination of the EP_HALT_PENDING flag and a counter
    for the number of pending stop endpoint commands
    (xhci_virt_ep->stop_cmds_pending).  If we need to cancel the watchdog
    timer and del_timer() succeeds, we decrement the number of pending stop
    endpoint commands.  If del_timer() fails, we leave the number of pending
    stop endpoint commands alone.  In either case, we clear the
    EP_HALT_PENDING flag.
    
    The timer will decrement the number of pending stop endpoint commands
    once it obtains the lock.  If the timer is the tail end of the last stop
    endpoint command (xhci_virt_ep->stop_cmds_pending == 0), and the
    endpoint's command is still pending (EP_HALT_PENDING is set), we assume
    the host is dying.  The watchdog timer will set XHCI_STATE_DYING, try to
    halt the xHCI host, and give back all pending URBs.
    
    Various other places in the driver need to check whether the xHCI host
    is dying.  If the interrupt handler ever notices, it should immediately
    stop processing events.  The URB enqueue function should also return
    -ESHUTDOWN.  The URB dequeue function should simply return the value
    of usb_hcd_check_unlink_urb() and the watchdog timer will take care of
    giving the URB back.  When a device is disconnected, the xHCI hardware
    structures should be freed without issuing a disable slot command (since
    the hardware probably won't respond to it anyway).  The debugging
    polling loop should stop polling if the host is dying.
    
    When a device is disconnected, any pending watchdog timers are killed
    with del_timer_sync().  It must be synchronous so that the watchdog
    timer doesn't attempt to access the freed endpoint structures.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index af3c5638526c..c92f84154fb5 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -659,6 +659,10 @@ struct xhci_virt_ep {
 	/* The TRB that was last reported in a stopped endpoint ring */
 	union xhci_trb		*stopped_trb;
 	struct xhci_td		*stopped_td;
+	/* Watchdog timer for stop endpoint command to cancel URBs */
+	struct timer_list	stop_cmd_timer;
+	int			stop_cmds_pending;
+	struct xhci_hcd		*xhci;
 };
 
 struct xhci_virt_device {
@@ -1022,6 +1026,8 @@ struct xhci_scratchpad {
 #define	ERST_ENTRIES	1
 /* Poll every 60 seconds */
 #define	POLL_TIMEOUT	60
+/* Stop endpoint command timeout (secs) for URB cancellation watchdog timer */
+#define XHCI_STOP_EP_CMD_TIMEOUT	5
 /* XXX: Make these module parameters */
 
 
@@ -1083,6 +1089,21 @@ struct xhci_hcd {
 	struct timer_list	event_ring_timer;
 	int			zombie;
 #endif
+	/* Host controller watchdog timer structures */
+	unsigned int		xhc_state;
+/* Host controller is dying - not responding to commands. "I'm not dead yet!"
+ *
+ * xHC interrupts have been disabled and a watchdog timer will (or has already)
+ * halt the xHCI host, and complete all URBs with an -ESHUTDOWN code.  Any code
+ * that sees this status (other than the timer that set it) should stop touching
+ * hardware immediately.  Interrupt handlers should return immediately when
+ * they see this status (any time they drop and re-acquire xhci->lock).
+ * xhci_urb_dequeue() should call usb_hcd_check_unlink_urb() and return without
+ * putting the TD on the canceled list, etc.
+ *
+ * There are no reports of xHCI host controllers that display this issue.
+ */
+#define XHCI_STATE_DYING	(1 << 0)
 	/* Statistics */
 	int			noops_submitted;
 	int			noops_handled;
@@ -1279,6 +1300,7 @@ void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
 void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
+void xhci_stop_endpoint_command_watchdog(unsigned long arg);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 4f0f0baef017dfd5d62b749716ab980a825e1071
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 27 10:56:33 2009 -0700

    USB: xhci: Re-purpose xhci_quiesce().
    
    xhci_quiesce() is basically a no-op right now.  It's only called if
    HC_IS_RUNNING() is true, and the body of the function consists of a
    BUG_ON if HC_IS_RUNNING() is false.  For the new xHCI watchdog timer, we
    need a new function that clears the xHCI running bit in the command
    register, but doesn't wait for the halt status to show up in the status
    register.  Re-purpose xhci_quiesce() to do that.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b173fd96dceb..af3c5638526c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1223,6 +1223,7 @@ void xhci_unregister_pci(void);
 #endif
 
 /* xHCI host controller glue */
+void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
 int xhci_reset(struct xhci_hcd *xhci);
 int xhci_init(struct usb_hcd *hcd);

commit 678539cfaa090093a9aef185f545f6b17acc445c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 27 10:55:52 2009 -0700

    USB: xhci: Handle URB cancel, complete and resubmit race.
    
    In the old code, there was a race condition between the stop endpoint
    command and the URB submission process.  When the stop endpoint command is
    handled by the event handler, the endpoint ring is assumed to be stopped.
    When a stop endpoint command is queued, URB submissions are to not ring
    the doorbell.  The old code would check the number of pending URBs to be
    canceled, and would not ring the doorbell if it was non-zero.
    
    However, the following race condition could occur with the old code:
    
    1. Cancel an URB, add it to the list of URBs to be canceled, queue the stop
       endpoint command, and increment ep->cancels_pending to 1.
    2. The URB finishes on the HW, and an event is enqueued to the event ring
       (at the same time as 1).
    3. The stop endpoint command finishes, and the endpoint is halted.  An
       event is queued to the event ring.
    4. The event handler sees the finished URB, notices it was to be
       canceled, decrements ep->cancels_pending to 0, and removes it from the to
       be canceled list.
    5. The event handler drops the lock and gives back the URB.  The
       completion handler requeues the URB (or a different driver enqueues a new
       URB).  This causes the endpoint's doorbell to be rung, since
       ep->cancels_pending == 0.  The endpoint is now running.
    6. A second URB is canceled, and it's added to the canceled list.
       Since ep->cancels_pending == 0, a new stop endpoint command is queued, and
       ep->cancels_pending is incremented to 1.
    7. The event handler then sees the completed stop endpoint command.  The
       handler assumes the endpoint is stopped, but it isn't.  It attempts to
       move the dequeue pointer or change TDs to cancel the second URB, while the
       hardware is actively accessing the endpoint ring.
    
    To eliminate this race condition, a new endpoint state bit is introduced,
    EP_HALT_PENDING.  When this bit is set, a stop endpoint command has been
    queued, and the command handler has not begun to process the URB
    cancellation list yet.  The endpoint doorbell should not be rung when this
    is set.  Set this when a stop endpoint command is queued, clear it when
    the handler for that command runs, and check if it's set before ringing a
    doorbell.  ep->cancels_pending is eliminated, because it is no longer
    used.
    
    Make sure to ring the doorbell for an endpoint when the stop endpoint
    command handler runs, even if the canceled URB list is empty.  All
    canceled URBs could have completed and new URBs could have been enqueued
    without the doorbell being rung before the command was handled.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4b254b6fa245..b173fd96dceb 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -652,10 +652,10 @@ struct xhci_virt_ep {
 	struct xhci_ring		*new_ring;
 	unsigned int			ep_state;
 #define SET_DEQ_PENDING		(1 << 0)
-#define EP_HALTED		(1 << 1)
+#define EP_HALTED		(1 << 1)	/* For stall handling */
+#define EP_HALT_PENDING		(1 << 2)	/* For URB cancellation */
 	/* ----  Related to URB cancellation ---- */
 	struct list_head	cancelled_td_list;
-	unsigned int		cancels_pending;
 	/* The TRB that was last reported in a stopped endpoint ring */
 	union xhci_trb		*stopped_trb;
 	struct xhci_td		*stopped_td;

commit ac1c1b7f16ed287fcec5bcfae06d0165c3941ec3
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 4 10:53:20 2009 -0700

    USB: xhci: Support USB hubs.
    
    For a USB hub to work under an xHCI host controller, the xHC's internal
    scheduler must be made aware of the hub's characteristics.  Add an xHCI
    hook that the USB core will call after it fetches the hub descriptor.
    This hook will add hub information to the slot context for that device,
    including whether it has multiple TTs or a single TT, the number of ports
    on the hub, and TT think time.
    
    Setting up the slot context for the device is different for 0.95 and 0.96
    xHCI host controllers.
    
    Some of the slot context reserved fields in the 0.95 specification were
    changed into hub fields in the 0.96 specification.  Don't set the TT think
    time or number of ports for a hub if we're dealing with a 0.95-compliant
    xHCI host controller.
    
    The 0.95 xHCI specification says that to modify the hub flag, we need to
    issue an evaluate context command.  The 0.96 specification says that flag
    can be set with a configure endpoint command.  Issue the correct command
    based on the version reported by the hardware.
    
    This patch does not add support for multi-TT hubs.  Multi-TT hubs expose
    a single TT on alt setting 0, and multi-TT on alt setting 1.  The xHCI
    driver can't handle setting alternate interfaces yet.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 36f7d4f91d9f..4b254b6fa245 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -509,6 +509,8 @@ struct xhci_slot_ctx {
 #define MAX_EXIT	(0xffff)
 /* Root hub port number that is needed to access the USB device */
 #define ROOT_HUB_PORT(p)	(((p) & 0xff) << 16)
+/* Maximum number of ports under a hub device */
+#define XHCI_MAX_PORTS(p)	(((p) & 0xff) << 24)
 
 /* tt_info bitmasks */
 /*
@@ -522,6 +524,7 @@ struct xhci_slot_ctx {
  * '0' if the device is not low or full speed.
  */
 #define TT_PORT		(0xff << 8)
+#define TT_THINK_TIME(p)	(((p) & 0x3) << 16)
 
 /* dev_state bitmasks */
 /* USB device address - assigned by the HC */
@@ -1231,6 +1234,8 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
+			struct usb_tt *tt, gfp_t mem_flags);
 int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
 int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);

commit 913a8a344ffcaf0b4a586d6662a2c66a7106557d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 4 10:53:13 2009 -0700

    USB: xhci: Change how xHCI commands are handled.
    
    Some commands to the xHCI hardware cannot be allowed to fail due to out of
    memory issues or the command ring being full.
    
    Add a way to reserve a TRB on the command ring, and make all command
    queueing functions indicate whether they are using a reserved TRB.
    
    Add a way to pre-allocate all the memory a command might need.  A command
    needs an input context, a variable to store the status, and (optionally) a
    completion for the caller to wait on.  Change all code that assumes the
    input device context, status, and completion for a command is stored in
    the xhci virtual USB device structure (xhci_virt_device).
    
    Store pending completions in a FIFO in xhci_virt_device.  Make the event
    handler for a configure endpoint command check to see whether a pending
    command in the list has completed.  We need to use separate input device
    contexts for some configure endpoint commands, since multiple drivers can
    submit requests at the same time that require a configure endpoint
    command.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 627092286d1b..36f7d4f91d9f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -620,6 +620,22 @@ struct xhci_input_control_ctx {
 	u32	rsvd2[6];
 };
 
+/* Represents everything that is needed to issue a command on the command ring.
+ * It's useful to pre-allocate these for commands that cannot fail due to
+ * out-of-memory errors, like freeing streams.
+ */
+struct xhci_command {
+	/* Input context for changing device state */
+	struct xhci_container_ctx	*in_ctx;
+	u32				status;
+	/* If completion is null, no one is waiting on this command
+	 * and the structure can be freed after the command completes.
+	 */
+	struct completion		*completion;
+	union xhci_trb			*command_trb;
+	struct list_head		cmd_list;
+};
+
 /* drop context bitmasks */
 #define	DROP_EP(x)	(0x1 << x)
 /* add context bitmasks */
@@ -658,6 +674,7 @@ struct xhci_virt_device {
 	struct completion		cmd_completion;
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
+	struct list_head		cmd_list;
 };
 
 
@@ -920,6 +937,8 @@ union xhci_trb {
  * It must also be greater than 16.
  */
 #define TRBS_PER_SEGMENT	64
+/* Allow two commands + a link TRB, along with any reserved command TRBs */
+#define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
 /* TRB buffer pointers can't cross 64KB boundaries */
 #define TRB_MAX_BUFF_SHIFT		16
@@ -1040,6 +1059,7 @@ struct xhci_hcd {
 	/* data structures */
 	struct xhci_device_context_array *dcbaa;
 	struct xhci_ring	*cmd_ring;
+	unsigned int		cmd_ring_reserved_trbs;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
 	/* Scratchpad */
@@ -1178,12 +1198,20 @@ unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
 unsigned int xhci_last_valid_endpoint(u32 added_ctxs);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
 void xhci_endpoint_copy(struct xhci_hcd *xhci,
-		struct xhci_virt_device *vdev, unsigned int ep_index);
-void xhci_slot_copy(struct xhci_hcd *xhci, struct xhci_virt_device *vdev);
+		struct xhci_container_ctx *in_ctx,
+		struct xhci_container_ctx *out_ctx,
+		unsigned int ep_index);
+void xhci_slot_copy(struct xhci_hcd *xhci,
+		struct xhci_container_ctx *in_ctx,
+		struct xhci_container_ctx *out_ctx);
 int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
+struct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,
+		bool allocate_completion, gfp_t mem_flags);
+void xhci_free_command(struct xhci_hcd *xhci,
+		struct xhci_command *command);
 
 #ifdef CONFIG_PCI
 /* xHCI PCI glue */
@@ -1229,7 +1257,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 int xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
-		u32 slot_id);
+		u32 slot_id, bool command_must_succeed);
 int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,

commit 63a0d9abd18cdcf5a985029c266c6bfe0511768f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Sep 4 10:53:09 2009 -0700

    USB: xhci: Endpoint representation refactoring.
    
    The xhci_ring structure contained information that is really related to an
    endpoint, not a ring.  This will cause problems later when endpoint
    streams are supported and there are multiple rings per endpoint.
    
    Move the endpoint state and cancellation information into a new virtual
    endpoint structure, xhci_virt_ep.  The list of TRBs to be cancelled should
    be per endpoint, not per ring, for easy access.  There can be only one TRB
    that the endpoint stopped on after a stop endpoint command (even with
    streams enabled); move the stopped TRB information into the new virtual
    endpoint structure.  Also move the 31 endpoint rings and temporary ring
    storage from the virtual device structure (xhci_virt_device) into the
    virtual endpoint structure (xhci_virt_ep).
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a7728aa91582..627092286d1b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -625,6 +625,23 @@ struct xhci_input_control_ctx {
 /* add context bitmasks */
 #define	ADD_EP(x)	(0x1 << x)
 
+struct xhci_virt_ep {
+	struct xhci_ring		*ring;
+	/* Temporary storage in case the configure endpoint command fails and we
+	 * have to restore the device state to the previous state
+	 */
+	struct xhci_ring		*new_ring;
+	unsigned int			ep_state;
+#define SET_DEQ_PENDING		(1 << 0)
+#define EP_HALTED		(1 << 1)
+	/* ----  Related to URB cancellation ---- */
+	struct list_head	cancelled_td_list;
+	unsigned int		cancels_pending;
+	/* The TRB that was last reported in a stopped endpoint ring */
+	union xhci_trb		*stopped_trb;
+	struct xhci_td		*stopped_td;
+};
+
 struct xhci_virt_device {
 	/*
 	 * Commands to the hardware are passed an "input context" that
@@ -637,13 +654,7 @@ struct xhci_virt_device {
 	struct xhci_container_ctx       *out_ctx;
 	/* Used for addressing devices and configuration changes */
 	struct xhci_container_ctx       *in_ctx;
-
-	/* FIXME when stream support is added */
-	struct xhci_ring		*ep_rings[31];
-	/* Temporary storage in case the configure endpoint command fails and we
-	 * have to restore the device state to the previous state
-	 */
-	struct xhci_ring		*new_ep_rings[31];
+	struct xhci_virt_ep		eps[31];
 	struct completion		cmd_completion;
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
@@ -945,15 +956,6 @@ struct xhci_ring {
 	struct xhci_segment	*deq_seg;
 	unsigned int		deq_updates;
 	struct list_head	td_list;
-	/* ----  Related to URB cancellation ---- */
-	struct list_head	cancelled_td_list;
-	unsigned int		cancels_pending;
-	unsigned int		state;
-#define SET_DEQ_PENDING		(1 << 0)
-#define EP_HALTED		(1 << 1)
-	/* The TRB that was last reported in a stopped endpoint ring */
-	union xhci_trb		*stopped_trb;
-	struct xhci_td		*stopped_td;
 	/*
 	 * Write the cycle state into the TRB cycle field to give ownership of
 	 * the TRB to the host controller (if we are the producer), or to check
@@ -1236,11 +1238,10 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_td *cur_td, struct xhci_dequeue_state *state);
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
-		struct xhci_ring *ep_ring, unsigned int slot_id,
-		unsigned int ep_index, struct xhci_dequeue_state *deq_state);
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
-		struct usb_device *udev,
-		unsigned int ep_index, struct xhci_ring *ep_ring);
+		struct usb_device *udev, unsigned int ep_index);
 void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);

commit 624defa12f304b4d11eda309bc207fa5a1900d0f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Sep 2 12:14:28 2009 -0700

    USB: xhci: Support interrupt transfers.
    
    Interrupt transfers are submitted to the xHCI hardware using the same TRB
    type as bulk transfers.  Re-use the bulk transfer enqueueing code to
    enqueue interrupt transfers.
    
    Interrupt transfers are a bit different than bulk transfers.  When the
    interrupt endpoint is to be serviced, the xHC will consume (at most) one
    TD.  A TD (comprised of sg list entries) can take several service
    intervals to transmit.  The important thing for device drivers to note is
    that if they use the scatter gather interface to submit interrupt
    requests, they will not get data sent from two different scatter gather
    lists in the same service interval.
    
    For now, the xHCI driver will use the service interval from the endpoint's
    descriptor (bInterval).  Drivers will need a hook to poll at a more
    frequent interval.  Set urb->interval to the interval that the xHCI
    hardware will use.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bc64b500feb8..a7728aa91582 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -581,6 +581,7 @@ struct xhci_ep_ctx {
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
 #define EP_INTERVAL(p)		((p & 0xff) << 16)
+#define EP_INTERVAL_TO_UFRAMES(p)		(1 << (((p) >> 16) & 0xff))
 
 /* ep_info2 bitmasks */
 /*
@@ -1223,6 +1224,8 @@ int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
+int xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
+		int slot_id, unsigned int ep_index);
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
 int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,

commit ac9d8fe7c6a8041cca5a0738915d2c4e21381421
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:55 2009 -0700

    USB: xhci: Add quirk for Fresco Logic xHCI hardware.
    
    This Fresco Logic xHCI host controller chip revision puts bad data into
    the output endpoint context after a Reset Endpoint command.  It needs a
    Configure Endpoint command (instead of a Set TR Dequeue Pointer command)
    after the reset endpoint command.
    
    Set up the input context before issuing the Reset Endpoint command so we
    don't copy bad data from the output endpoint context.  The HW also can't
    handle two commands queued at once, so submit the TRB for the Configure
    Endpoint command in the event handler for the Reset Endpoint command.
    
    Devices that stall on control endpoints before a configuration is selected
    will not work under this Fresco Logic xHCI host controller revision.
    
    This patch is for prototype hardware that will be given to other companies
    for evaluation purposes only, and should not reach consumer hands.  Fresco
    Logic's next chip rev should have this bug fixed.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index b1abaeb62b4c..bc64b500feb8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -929,6 +929,12 @@ struct xhci_td {
 	union xhci_trb		*last_trb;
 };
 
+struct xhci_dequeue_state {
+	struct xhci_segment *new_deq_seg;
+	union xhci_trb *new_deq_ptr;
+	int new_cycle_state;
+};
+
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
 	union  xhci_trb		*enqueue;
@@ -955,12 +961,6 @@ struct xhci_ring {
 	u32			cycle_state;
 };
 
-struct xhci_dequeue_state {
-	struct xhci_segment *new_deq_seg;
-	union xhci_trb *new_deq_ptr;
-	int new_cycle_state;
-};
-
 struct xhci_erst_entry {
 	/* 64-bit event ring segment address */
 	u64	seg_addr;
@@ -1063,6 +1063,7 @@ struct xhci_hcd {
 	int			error_bitmask;
 	unsigned int		quirks;
 #define	XHCI_LINK_TRB_QUIRK	(1 << 0)
+#define XHCI_RESET_EP_QUIRK	(1 << 1)
 };
 
 /* For testing purposes */
@@ -1170,6 +1171,8 @@ int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device
 int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
+unsigned int xhci_get_endpoint_flag_from_index(unsigned int ep_index);
+unsigned int xhci_last_valid_endpoint(u32 added_ctxs);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
 void xhci_endpoint_copy(struct xhci_hcd *xhci,
 		struct xhci_virt_device *vdev, unsigned int ep_index);
@@ -1233,8 +1236,11 @@ void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		struct xhci_ring *ep_ring, unsigned int slot_id,
 		unsigned int ep_index, struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
-		struct usb_device *udev, struct usb_host_endpoint *ep,
+		struct usb_device *udev,
 		unsigned int ep_index, struct xhci_ring *ep_ring);
+void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_dequeue_state *deq_state);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 82d1009f537c2a43be0a410abd33521f76ee3a5a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:52 2009 -0700

    USB: xhci: Handle stalled control endpoints.
    
    When a control endpoint stalls, the next control transfer will clear the
    stall.  The USB core doesn't call down to the host controller driver's
    endpoint_reset() method when control endpoints stall, so the xHCI driver
    has to do all its stall handling for internal state in its interrupt handler.
    
    When the host stalls on a control endpoint, it may stop on the data phase
    or status phase of the control transfer.  Like other stalled endpoints,
    the xHCI driver needs to queue a Reset Endpoint command and move the
    hardware's control endpoint ring dequeue pointer past the failed control
    transfer (with a Set TR Dequeue Pointer or a Configure Endpoint command).
    
    Since the USB core doesn't call usb_hcd_reset_endpoint() for control
    endpoints, we need to do this in interrupt context when we get notified of
    the stalled transfer.  URBs may be queued to the hardware before these two
    commands complete.  The endpoint queue will be restarted once both
    commands complete.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6aecede77ff6..b1abaeb62b4c 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -589,6 +589,7 @@ struct xhci_ep_ctx {
  */
 #define	FORCE_EVENT	(0x1)
 #define ERROR_COUNT(p)	(((p) & 0x3) << 1)
+#define CTX_TO_EP_TYPE(p)	(((p) >> 3) & 0x7)
 #define EP_TYPE(p)	((p) << 3)
 #define ISOC_OUT_EP	1
 #define BULK_OUT_EP	2
@@ -1231,6 +1232,9 @@ void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
 		struct xhci_ring *ep_ring, unsigned int slot_id,
 		unsigned int ep_index, struct xhci_dequeue_state *deq_state);
+void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci,
+		struct usb_device *udev, struct usb_host_endpoint *ep,
+		unsigned int ep_index, struct xhci_ring *ep_ring);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 2d3f1fac7ee8bb4c6fad40f838488edbeabb0c50
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:49 2009 -0700

    USB: xhci: Support full speed devices.
    
    Full speed devices have varying max packet sizes (8, 16, 32, or 64) for
    endpoint 0.  The xHCI hardware needs to know the real max packet size
    that the USB core discovers after it fetches the first 8 bytes of the
    device descriptor.
    
    In order to fix this without adding a new hook to host controller drivers,
    the xHCI driver looks for an updated max packet size for control
    endpoints.  If it finds an updated size, it issues an evaluate context
    command and waits for that command to finish.  This should only happen in
    the initialization and device descriptor fetching steps in the khubd
    thread, so blocking should be fine.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a8fe21762052..6aecede77ff6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -601,6 +601,8 @@ struct xhci_ep_ctx {
 /* bit 7 is Host Initiate Disable - for disabling stream selection */
 #define MAX_BURST(p)	(((p)&0xff) << 8)
 #define MAX_PACKET(p)	(((p)&0xffff) << 16)
+#define MAX_PACKET_MASK		(0xffff << 16)
+#define MAX_PACKET_DECODED(p)	(((p) >> 16) & 0xffff)
 
 
 /**

commit f2217e8edd95b0428d8123d426e0097a5e955f9f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:43 2009 -0700

    USB: xhci: Configure endpoint code refactoring.
    
    Refactor out the code issue, wait for, and parse the event completion code
    for a configure endpoint command.  Modify it to support the evaluate
    context command, which has a very similar submission process.  Add
    functions to copy parts of the output context into the input context
    (which will be used in the evaluate context command).
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 79ea627e8b8a..a8fe21762052 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1168,6 +1168,9 @@ int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *ud
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
+void xhci_endpoint_copy(struct xhci_hcd *xhci,
+		struct xhci_virt_device *vdev, unsigned int ep_index);
+void xhci_slot_copy(struct xhci_hcd *xhci, struct xhci_virt_device *vdev);
 int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
@@ -1216,6 +1219,8 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
+int xhci_queue_evaluate_context(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
+		u32 slot_id);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
 void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,

commit b0567b3f635db72c881a0d561cebb544ec085073
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Aug 7 14:04:36 2009 -0700

    USB: xhci: Work around for chain bit in link TRBs.
    
    Different sections of the xHCI 0.95 specification had opposing
    requirements for the chain bit in a link transaction request buffer (TRB).
    The chain bit is used to designate that adjacent TRBs are all part of the
    same scatter gather list that should be sent to the device.  Link TRBs can
    be in the middle, or at the beginning or end of these chained TRBs.
    
    Sections 4.11.5.1 and 6.4.4.1 both stated the link TRB "shall have the
    chain bit set to 1", meaning it is always chained to the next TRB.
    However, section 4.6.9 on the stop endpoint command has specific cases for
    what the hardware must do for a link TRB with the chain bit set to 0.  The
    0.96 specification errata later cleared up this issue by fixing the
    4.11.5.1 and 6.4.4.1 sections to state that a link TRB can have the chain
    bit set to 1 or 0.
    
    The problem is that the xHCI cancellation code depends on the chain bit of
    the link TRB being cleared when it's at the end of a TD, and some 0.95
    xHCI hardware simply stops processing the ring when it encounters a link
    TRB with the chain bit cleared.
    
    Allow users who are testing 0.95 xHCI prototypes to set a module parameter
    (link_quirk) to turn on this link TRB work around.  Cancellation may not
    work if the ring is stopped exactly on a link TRB with chain bit set, but
    cancellation should be a relatively uncommon case.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ffe1625d4e1b..79ea627e8b8a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1058,6 +1058,8 @@ struct xhci_hcd {
 	int			noops_submitted;
 	int			noops_handled;
 	int			error_bitmask;
+	unsigned int		quirks;
+#define	XHCI_LINK_TRB_QUIRK	(1 << 0)
 };
 
 /* For testing purposes */
@@ -1136,6 +1138,13 @@ static inline void xhci_write_64(struct xhci_hcd *xhci,
 	writel(val_hi, ptr + 1);
 }
 
+static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
+{
+	u32 temp = xhci_readl(xhci, &xhci->cap_regs->hc_capbase);
+	return ((HC_VERSION(temp) == 0x95) &&
+			(xhci->quirks & XHCI_LINK_TRB_QUIRK));
+}
+
 /* xHCI debugging */
 void xhci_print_ir_set(struct xhci_hcd *xhci, struct xhci_intr_reg *ir_set, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);

commit 3dbda77e6f3375f87090cfce97b2551d3723521b
Author: Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
Date:   Thu Jul 23 08:31:31 2009 +0200

    trivial: fix typos "man[ae]g?ment" -> "management"
    
    Signed-off-by: Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d31d32206ba3..ffe1625d4e1b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1150,7 +1150,7 @@ void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 
-/* xHCI memory managment */
+/* xHCI memory management */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
 int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);
 void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);

commit c92bcfa7b4038d8ffe1f02e21269f18eb0b64144
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:05:21 2009 -0700

    USB: xhci: Stall handling bug fixes.
    
    Correct the xHCI code to handle stalls on USB endpoints.  We need to move
    the endpoint ring's dequeue pointer past the stalled transfer, or the HW
    will try to restart the transfer the next time the doorbell is rung.
    
    Don't attempt to clear a halt on an endpoint if we haven't seen a stalled
    transfer for it.  The USB core will attempt to clear a halt on all
    endpoints when it selects a new configuration.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 9c108c632704..d31d32206ba3 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -952,6 +952,12 @@ struct xhci_ring {
 	u32			cycle_state;
 };
 
+struct xhci_dequeue_state {
+	struct xhci_segment *new_deq_seg;
+	union xhci_trb *new_deq_ptr;
+	int new_cycle_state;
+};
+
 struct xhci_erst_entry {
 	/* 64-bit event ring segment address */
 	u64	seg_addr;
@@ -1203,6 +1209,12 @@ int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
 int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
+void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_td *cur_td, struct xhci_dequeue_state *state);
+void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
+		struct xhci_ring *ep_ring, unsigned int slot_id,
+		unsigned int ep_index, struct xhci_dequeue_state *deq_state);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit d115b04818e57bdbc7ccde4d0660b15e33013dc8
Author: John Youn <johnyoun@synopsys.com>
Date:   Mon Jul 27 12:05:15 2009 -0700

    USB: xhci: Support for 64-byte contexts
    
    Adds support for controllers that use 64-byte contexts.  The following context
    data structures are affected by this: Device, Input, Input Control, Endpoint,
    and Slot.  To accommodate the use of either 32 or 64-byte contexts, a Device or
    Input context can only be accessed through functions which look-up and return
    pointers to their contained contexts.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index d4d3c7777fb8..9c108c632704 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -446,6 +446,27 @@ struct xhci_doorbell_array {
 #define EPI_TO_DB(p)		(((p) + 1) & 0xff)
 
 
+/**
+ * struct xhci_container_ctx
+ * @type: Type of context.  Used to calculated offsets to contained contexts.
+ * @size: Size of the context data
+ * @bytes: The raw context data given to HW
+ * @dma: dma address of the bytes
+ *
+ * Represents either a Device or Input context.  Holds a pointer to the raw
+ * memory used for the context (bytes) and dma address of it (dma).
+ */
+struct xhci_container_ctx {
+	unsigned type;
+#define XHCI_CTX_TYPE_DEVICE  0x1
+#define XHCI_CTX_TYPE_INPUT   0x2
+
+	int size;
+
+	u8 *bytes;
+	dma_addr_t dma;
+};
+
 /**
  * struct xhci_slot_ctx
  * @dev_info:	Route string, device speed, hub info, and last valid endpoint
@@ -583,32 +604,16 @@ struct xhci_ep_ctx {
 
 
 /**
- * struct xhci_device_control
- * Input context; see section 6.2.5.
+ * struct xhci_input_control_context
+ * Input control context; see section 6.2.5.
  *
  * @drop_context:	set the bit of the endpoint context you want to disable
  * @add_context:	set the bit of the endpoint context you want to enable
  */
-struct xhci_device_control {
-	/* Input control context */
+struct xhci_input_control_ctx {
 	u32	drop_flags;
 	u32	add_flags;
-	u32	rsvd[6];
-	/* Copy of device context */
-	struct xhci_slot_ctx	slot;
-	struct xhci_ep_ctx	ep[31];
-};
-
-/**
- * struct xhci_device_ctx
- * Device context; see section 6.2.1.
- *
- * @slot:		slot context for the device.
- * @ep:			array of endpoint contexts for the device.
- */
-struct xhci_device_ctx {
-	struct xhci_slot_ctx	slot;
-	struct xhci_ep_ctx	ep[31];
+	u32	rsvd2[6];
 };
 
 /* drop context bitmasks */
@@ -616,7 +621,6 @@ struct xhci_device_ctx {
 /* add context bitmasks */
 #define	ADD_EP(x)	(0x1 << x)
 
-
 struct xhci_virt_device {
 	/*
 	 * Commands to the hardware are passed an "input context" that
@@ -626,11 +630,10 @@ struct xhci_virt_device {
 	 * track of input and output contexts separately because
 	 * these commands might fail and we don't trust the hardware.
 	 */
-	struct xhci_device_ctx		*out_ctx;
-	dma_addr_t			out_ctx_dma;
+	struct xhci_container_ctx       *out_ctx;
 	/* Used for addressing devices and configuration changes */
-	struct xhci_device_control	*in_ctx;
-	dma_addr_t			in_ctx_dma;
+	struct xhci_container_ctx       *in_ctx;
+
 	/* FIXME when stream support is added */
 	struct xhci_ring		*ep_rings[31];
 	/* Temporary storage in case the configure endpoint command fails and we
@@ -1139,8 +1142,7 @@ void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
-void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_device_control *ctx, dma_addr_t dma, unsigned int last_ep);
-void xhci_dbg_device_ctx(struct xhci_hcd *xhci, struct xhci_device_ctx *ctx, dma_addr_t dma, unsigned int last_ep);
+void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int last_ep);
 
 /* xHCI memory managment */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
@@ -1207,4 +1209,9 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		char *buf, u16 wLength);
 int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
 
+/* xHCI contexts */
+struct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
+struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);
+struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);
+
 #endif /* __LINUX_XHCI_HCD_H */

commit 28c2d2efb48dec2f0b050affae6d5787d6449e47
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:05:08 2009 -0700

    USB: xhci: Always align output device contexts to 64 bytes.
    
    Make sure the xHCI output device context is 64-byte aligned.  Previous
    code was using the same structure for both the output device context and
    the input control context.  Since the structure had 32 bytes of flags
    before the device context, the output device context wouldn't be 64-byte
    aligned.  Define a new structure to use for the output device context and
    clean up the debugging for these two structures.
    
    The copy of the device context in the input control context does *not*
    need to be 64-byte aligned.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5a09b9a26e0d..d4d3c7777fb8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -584,15 +584,29 @@ struct xhci_ep_ctx {
 
 /**
  * struct xhci_device_control
- * Input/Output context; see section 6.2.5.
+ * Input context; see section 6.2.5.
  *
  * @drop_context:	set the bit of the endpoint context you want to disable
  * @add_context:	set the bit of the endpoint context you want to enable
  */
 struct xhci_device_control {
+	/* Input control context */
 	u32	drop_flags;
 	u32	add_flags;
 	u32	rsvd[6];
+	/* Copy of device context */
+	struct xhci_slot_ctx	slot;
+	struct xhci_ep_ctx	ep[31];
+};
+
+/**
+ * struct xhci_device_ctx
+ * Device context; see section 6.2.1.
+ *
+ * @slot:		slot context for the device.
+ * @ep:			array of endpoint contexts for the device.
+ */
+struct xhci_device_ctx {
 	struct xhci_slot_ctx	slot;
 	struct xhci_ep_ctx	ep[31];
 };
@@ -612,7 +626,7 @@ struct xhci_virt_device {
 	 * track of input and output contexts separately because
 	 * these commands might fail and we don't trust the hardware.
 	 */
-	struct xhci_device_control	*out_ctx;
+	struct xhci_device_ctx		*out_ctx;
 	dma_addr_t			out_ctx_dma;
 	/* Used for addressing devices and configuration changes */
 	struct xhci_device_control	*in_ctx;
@@ -1126,6 +1140,7 @@ void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_device_control *ctx, dma_addr_t dma, unsigned int last_ep);
+void xhci_dbg_device_ctx(struct xhci_hcd *xhci, struct xhci_device_ctx *ctx, dma_addr_t dma, unsigned int last_ep);
 
 /* xHCI memory managment */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);

commit 254c80a3a0eb811489f7410c3291f01a60e8e42f
Author: John Youn <johnyoun@synopsys.com>
Date:   Mon Jul 27 12:05:03 2009 -0700

    USB: xhci: Scratchpad buffer allocation
    
    Allocates and initializes the scratchpad buffer array (XHCI 4.20).  This is an
    array of 64-bit DMA addresses to scratch pages that the controller may use
    during operation.  The number of pages is specified in the "Max Scratchpad
    Buffers" field of HCSPARAMS2.  The DMA address of this array is written into
    slot 0 of the DCBAA.
    
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 074728e10225..5a09b9a26e0d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -89,6 +89,7 @@ struct xhci_cap_regs {
 #define HCS_ERST_MAX(p)		(((p) >> 4) & 0xf)
 /* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
 /* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */
+#define HCS_MAX_SCRATCHPAD(p)   (((p) >> 27) & 0x1f)
 
 /* HCSPARAMS3 - hcs_params3 - bitmasks */
 /* bits 0:7, Max U1 to U0 latency for the roothub ports */
@@ -951,6 +952,13 @@ struct xhci_erst {
 	unsigned int		erst_size;
 };
 
+struct xhci_scratchpad {
+	u64 *sp_array;
+	dma_addr_t sp_dma;
+	void **sp_buffers;
+	dma_addr_t *sp_dma_buffers;
+};
+
 /*
  * Each segment table entry is 4*32bits long.  1K seems like an ok size:
  * (1K bytes * 8bytes/bit) / (4*32 bits) = 64 segment entries in the table,
@@ -1005,6 +1013,9 @@ struct xhci_hcd {
 	struct xhci_ring	*cmd_ring;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
+	/* Scratchpad */
+	struct xhci_scratchpad  *scratchpad;
+
 	/* slot enabling and address device helpers */
 	struct completion	addr_dev;
 	int slot_id;

commit 66e49d8774fa03539713e8f91169c37c05df1e94
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:03:46 2009 -0700

    USB: xhci: Make debugging more verbose.
    
    Add more debugging to the irq handler, slot context initialization, ring
    operations, URB cancellation, and MMIO writes.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 60770c89132b..074728e10225 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1065,10 +1065,9 @@ static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
 static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __u32 __iomem *regs)
 {
-	if (!in_interrupt())
-		xhci_dbg(xhci,
-			 "`MEM_WRITE_DWORD(3'b000, 32'h%p, 32'h%0x, 4'hf);\n",
-			 regs, val);
+	xhci_dbg(xhci,
+			"`MEM_WRITE_DWORD(3'b000, 32'h%p, 32'h%0x, 4'hf);\n",
+			regs, val);
 	writel(val, regs);
 }
 
@@ -1096,10 +1095,9 @@ static inline void xhci_write_64(struct xhci_hcd *xhci,
 	u32 val_lo = lower_32_bits(val);
 	u32 val_hi = upper_32_bits(val);
 
-	if (!in_interrupt())
-		xhci_dbg(xhci,
-			 "`MEM_WRITE_DWORD(3'b000, 64'h%p, 64'h%0lx, 4'hf);\n",
-			 regs, (long unsigned int) val);
+	xhci_dbg(xhci,
+			"`MEM_WRITE_DWORD(3'b000, 64'h%p, 64'h%0lx, 4'hf);\n",
+			regs, (long unsigned int) val);
 	writel(val_lo, ptr);
 	writel(val_hi, ptr + 1);
 }

commit 8e595a5d30a5ee4bb745d4da6439d73ed7d91054
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:03:31 2009 -0700

    USB: xhci: Represent 64-bit addresses with one u64.
    
    There are several xHCI data structures that use two 32-bit fields to
    represent a 64-bit address.  Since some architectures don't support 64-bit
    PCI writes, the fields need to be written in two 32-bit writes.  The xHCI
    specification says that if a platform is incapable of generating 64-bit
    writes, software must write the low 32-bits first, then the high 32-bits.
    Hardware that supports 64-bit addressing will wait for the high 32-bit
    write before reading the revised value, and hardware that only supports
    32-bit writes will ignore the high 32-bit write.
    
    Previous xHCI code represented 64-bit addresses with two u32 values.  This
    lead to buggy code that would write the 32-bits in the wrong order, or
    forget to write the upper 32-bits.  Change the two u32s to one u64 and
    create a function call to write all 64-bit addresses in the proper order.
    This new function could be modified in the future if all platforms support
    64-bit writes.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index cde648a524f5..60770c89132b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -25,6 +25,7 @@
 
 #include <linux/usb.h>
 #include <linux/timer.h>
+#include <linux/kernel.h>
 
 #include "../core/hcd.h"
 /* Code sharing between pci-quirks and xhci hcd */
@@ -42,14 +43,6 @@
  * xHCI register interface.
  * This corresponds to the eXtensible Host Controller Interface (xHCI)
  * Revision 0.95 specification
- *
- * Registers should always be accessed with double word or quad word accesses.
- *
- * Some xHCI implementations may support 64-bit address pointers.  Registers
- * with 64-bit address pointers should be written to with dword accesses by
- * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
- * xHCI implementations that do not support 64-bit address pointers will ignore
- * the high dword, and write order is irrelevant.
  */
 
 /**
@@ -166,10 +159,10 @@ struct xhci_op_regs {
 	u32	reserved1;
 	u32	reserved2;
 	u32	dev_notification;
-	u32	cmd_ring[2];
+	u64	cmd_ring;
 	/* rsvd: offset 0x20-2F */
 	u32	reserved3[4];
-	u32	dcbaa_ptr[2];
+	u64	dcbaa_ptr;
 	u32	config_reg;
 	/* rsvd: offset 0x3C-3FF */
 	u32	reserved4[241];
@@ -254,7 +247,7 @@ struct xhci_op_regs {
 #define CMD_RING_RUNNING	(1 << 3)
 /* bits 4:5 reserved and should be preserved */
 /* Command Ring pointer - bit mask for the lower 32 bits. */
-#define CMD_RING_ADDR_MASK	(0xffffffc0)
+#define CMD_RING_RSVD_BITS	(0x3f)
 
 /* CONFIG - Configure Register - config_reg bitmasks */
 /* bits 0:7 - maximum number of device slots enabled (NumSlotsEn) */
@@ -382,8 +375,8 @@ struct xhci_intr_reg {
 	u32	irq_control;
 	u32	erst_size;
 	u32	rsvd;
-	u32	erst_base[2];
-	u32	erst_dequeue[2];
+	u64	erst_base;
+	u64	erst_dequeue;
 };
 
 /* irq_pending bitmasks */
@@ -538,7 +531,7 @@ struct xhci_slot_ctx {
 struct xhci_ep_ctx {
 	u32	ep_info;
 	u32	ep_info2;
-	u32	deq[2];
+	u64	deq;
 	u32	tx_info;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
 	u32	reserved[3];
@@ -641,7 +634,7 @@ struct xhci_virt_device {
  */
 struct xhci_device_context_array {
 	/* 64-bit device addresses; we only write 32-bit addresses */
-	u32			dev_context_ptrs[2*MAX_HC_SLOTS];
+	u64			dev_context_ptrs[MAX_HC_SLOTS];
 	/* private xHCD pointers */
 	dma_addr_t	dma;
 };
@@ -654,7 +647,7 @@ struct xhci_device_context_array {
 
 struct xhci_stream_ctx {
 	/* 64-bit stream ring address, cycle state, and stream type */
-	u32	stream_ring[2];
+	u64	stream_ring;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
 	u32	reserved[2];
 };
@@ -662,7 +655,7 @@ struct xhci_stream_ctx {
 
 struct xhci_transfer_event {
 	/* 64-bit buffer address, or immediate data */
-	u32	buffer[2];
+	u64	buffer;
 	u32	transfer_len;
 	/* This field is interpreted differently based on the type of TRB */
 	u32	flags;
@@ -744,7 +737,7 @@ struct xhci_transfer_event {
 
 struct xhci_link_trb {
 	/* 64-bit segment pointer*/
-	u32 segment_ptr[2];
+	u64 segment_ptr;
 	u32 intr_target;
 	u32 control;
 };
@@ -755,7 +748,7 @@ struct xhci_link_trb {
 /* Command completion event TRB */
 struct xhci_event_cmd {
 	/* Pointer to command TRB, or the value passed by the event data trb */
-	u32 cmd_trb[2];
+	u64 cmd_trb;
 	u32 status;
 	u32 flags;
 };
@@ -943,7 +936,7 @@ struct xhci_ring {
 
 struct xhci_erst_entry {
 	/* 64-bit event ring segment address */
-	u32	seg_addr[2];
+	u64	seg_addr;
 	u32	seg_size;
 	/* Set to zero */
 	u32	rsvd;
@@ -1079,6 +1072,38 @@ static inline void xhci_writel(struct xhci_hcd *xhci,
 	writel(val, regs);
 }
 
+/*
+ * Registers should always be accessed with double word or quad word accesses.
+ *
+ * Some xHCI implementations may support 64-bit address pointers.  Registers
+ * with 64-bit address pointers should be written to with dword accesses by
+ * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
+ * xHCI implementations that do not support 64-bit address pointers will ignore
+ * the high dword, and write order is irrelevant.
+ */
+static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
+		__u64 __iomem *regs)
+{
+	__u32 __iomem *ptr = (__u32 __iomem *) regs;
+	u64 val_lo = readl(ptr);
+	u64 val_hi = readl(ptr + 1);
+	return val_lo + (val_hi << 32);
+}
+static inline void xhci_write_64(struct xhci_hcd *xhci,
+		const u64 val, __u64 __iomem *regs)
+{
+	__u32 __iomem *ptr = (__u32 __iomem *) regs;
+	u32 val_lo = lower_32_bits(val);
+	u32 val_hi = upper_32_bits(val);
+
+	if (!in_interrupt())
+		xhci_dbg(xhci,
+			 "`MEM_WRITE_DWORD(3'b000, 64'h%p, 64'h%0lx, 4'hf);\n",
+			 regs, (long unsigned int) val);
+	writel(val_lo, ptr);
+	writel(val_hi, ptr + 1);
+}
+
 /* xHCI debugging */
 void xhci_print_ir_set(struct xhci_hcd *xhci, struct xhci_intr_reg *ir_set, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);

commit a1587d97ce3e53816c88b513a2038f6c5e5babd7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jul 27 12:03:15 2009 -0700

    USB: xhci: Deal with stalled endpoints.
    
    When an endpoint on a device under an xHCI host controller stalls, the
    host controller driver must let the hardware know that the USB core has
    successfully cleared the halt condition.  The HCD submits a Reset Endpoint
    Command, which will clear the toggle bit for USB 2.0 devices, and set the
    sequence number to zero for USB 3.0 devices.
    
    The xHCI urb_enqueue will accept new URBs while the endpoint is halted,
    and will queue them to the hardware rings.  However, the endpoint doorbell
    will not be rung until the Reset Endpoint Command completes.
    
    Don't queue a reset endpoint command for root hubs.  khubd clears halt
    conditions on the roothub during the initialization process, but the roothub
    isn't a real device, so the xHCI host controller doesn't need to know about the
    cleared halt.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 8936eeb5588b..cde648a524f5 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -848,8 +848,8 @@ union xhci_trb {
 #define TRB_CONFIG_EP		12
 /* Evaluate Context Command */
 #define TRB_EVAL_CONTEXT	13
-/* Reset Transfer Ring Command */
-#define TRB_RESET_RING		14
+/* Reset Endpoint Command */
+#define TRB_RESET_EP		14
 /* Stop Transfer Ring Command */
 #define TRB_STOP_RING		15
 /* Set Transfer Ring Dequeue Pointer Command */
@@ -929,6 +929,7 @@ struct xhci_ring {
 	unsigned int		cancels_pending;
 	unsigned int		state;
 #define SET_DEQ_PENDING		(1 << 0)
+#define EP_HALTED		(1 << 1)
 	/* The TRB that was last reported in a stopped endpoint ring */
 	union xhci_trb		*stopped_trb;
 	struct xhci_td		*stopped_td;
@@ -1128,6 +1129,7 @@ int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
 int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
 int xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
+void xhci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
 int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
@@ -1148,6 +1150,8 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
 		int slot_id, unsigned int ep_index);
 int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
 		u32 slot_id);
+int xhci_queue_reset_ep(struct xhci_hcd *xhci, int slot_id,
+		unsigned int ep_index);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit f88ba78d9ac0e1f583da4cada80b8816ca761a3f
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu May 14 11:44:22 2009 -0700

    USB: xhci: Respect critical sections.
    
    Narrow down time spent holding the xHCI spinlock so that it's only used to
    protect the xHCI rings, not as mutual exclusion.  Stop allocating memory
    while holding the spinlock and calling xhci_alloc_virt_device() and
    xhci_endpoint_init().
    
    The USB core should have locking in it to prevent device state to be
    manipulated by more than one kernel thread.  E.g. you can't free a device
    while you're in the middle of setting a new configuration.  So removing
    the locks from the sections where xhci_alloc_dev() and
    xhci_reset_bandwidth() touch xHCI's representation of the device should be
    OK.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3e8e09c4c2bf..8936eeb5588b 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1101,7 +1101,9 @@ int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *ud
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
 void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
-int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_device *udev, struct usb_host_endpoint *ep);
+int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
+		struct usb_device *udev, struct usb_host_endpoint *ep,
+		gfp_t mem_flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 
 #ifdef CONFIG_PCI

commit 98441973105b80e133fcaa47ebf17be1e024ea30
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu May 14 11:44:18 2009 -0700

    USB: xhci: Remove packed attribute from structures.
    
    The packed attribute allows gcc to muck with the alignment of data
    structures, which may lead to byte-wise writes that break atomicity of
    writes.  Packed should only be used when the compile may add undesired
    padding to the structure.  Each element of the structure will be aligned
    by C based on its size and the size of the elements around it.  E.g. a u64
    would be aligned on an 8 byte boundary, the next u32 would be aligned on a
    four byte boundary, etc.
    
    Since most of the xHCI structures contain only u32 bit values, removing
    the packed attribute for them should be harmless.  (A future patch will
    change some of the twin 32-bit address fields to one 64-bit field, but all
    those places have an even number of 32-bit fields before them, so the
    alignment should be correct.)  Add BUILD_BUG_ON statements to check that
    the compiler doesn't add padding to the data structures that have a
    hardware-defined layout.
    
    While we're modifying the registers, change the name of intr_reg to
    xhci_intr_reg to avoid global conflicts.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index df8778e1cfc6..3e8e09c4c2bf 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -71,7 +71,7 @@ struct xhci_cap_regs {
 	u32	db_off;
 	u32	run_regs_off;
 	/* Reserved up to (CAPLENGTH - 0x1C) */
-} __attribute__ ((packed));
+};
 
 /* hc_capbase bitmasks */
 /* bits 7:0 - how long is the Capabilities register */
@@ -180,7 +180,7 @@ struct xhci_op_regs {
 	u32	reserved5;
 	/* registers for ports 2-255 */
 	u32	reserved6[NUM_PORT_REGS*254];
-} __attribute__ ((packed));
+};
 
 /* USBCMD - USB command - command bitmasks */
 /* start/stop HC execution - do not write unless HC is halted*/
@@ -361,7 +361,7 @@ struct xhci_op_regs {
 
 
 /**
- * struct intr_reg - Interrupt Register Set
+ * struct xhci_intr_reg - Interrupt Register Set
  * @irq_pending:	IMAN - Interrupt Management Register.  Used to enable
  *			interrupts and check for pending interrupts.
  * @irq_control:	IMOD - Interrupt Moderation Register.
@@ -377,14 +377,14 @@ struct xhci_op_regs {
  * position of the Enqueue Pointer." The HCD (Linux) processes those events and
  * updates the dequeue pointer.
  */
-struct intr_reg {
+struct xhci_intr_reg {
 	u32	irq_pending;
 	u32	irq_control;
 	u32	erst_size;
 	u32	rsvd;
 	u32	erst_base[2];
 	u32	erst_dequeue[2];
-} __attribute__ ((packed));
+};
 
 /* irq_pending bitmasks */
 #define	ER_IRQ_PENDING(p)	((p) & 0x1)
@@ -428,10 +428,10 @@ struct intr_reg {
  * or larger accesses"
  */
 struct xhci_run_regs {
-	u32	microframe_index;
-	u32	rsvd[7];
-	struct intr_reg	ir_set[128];
-} __attribute__ ((packed));
+	u32			microframe_index;
+	u32			rsvd[7];
+	struct xhci_intr_reg	ir_set[128];
+};
 
 /**
  * struct doorbell_array
@@ -440,7 +440,7 @@ struct xhci_run_regs {
  */
 struct xhci_doorbell_array {
 	u32	doorbell[256];
-} __attribute__ ((packed));
+};
 
 #define	DB_TARGET_MASK		0xFFFFFF00
 #define	DB_STREAM_ID_MASK	0x0000FFFF
@@ -470,7 +470,7 @@ struct xhci_slot_ctx {
 	u32	dev_state;
 	/* offset 0x10 to 0x1f reserved for HC internal use */
 	u32	reserved[4];
-} __attribute__ ((packed));
+};
 
 /* dev_info bitmasks */
 /* Route String - 0:19 */
@@ -542,7 +542,7 @@ struct xhci_ep_ctx {
 	u32	tx_info;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
 	u32	reserved[3];
-} __attribute__ ((packed));
+};
 
 /* ep_info bitmasks */
 /*
@@ -601,7 +601,7 @@ struct xhci_device_control {
 	u32	rsvd[6];
 	struct xhci_slot_ctx	slot;
 	struct xhci_ep_ctx	ep[31];
-} __attribute__ ((packed));
+};
 
 /* drop context bitmasks */
 #define	DROP_EP(x)	(0x1 << x)
@@ -644,7 +644,7 @@ struct xhci_device_context_array {
 	u32			dev_context_ptrs[2*MAX_HC_SLOTS];
 	/* private xHCD pointers */
 	dma_addr_t	dma;
-} __attribute__ ((packed));
+};
 /* TODO: write function to set the 64-bit device DMA address */
 /*
  * TODO: change this to be dynamically sized at HC mem init time since the HC
@@ -657,7 +657,7 @@ struct xhci_stream_ctx {
 	u32	stream_ring[2];
 	/* offset 0x14 - 0x1f reserved for HC internal use */
 	u32	reserved[2];
-} __attribute__ ((packed));
+};
 
 
 struct xhci_transfer_event {
@@ -666,7 +666,7 @@ struct xhci_transfer_event {
 	u32	transfer_len;
 	/* This field is interpreted differently based on the type of TRB */
 	u32	flags;
-} __attribute__ ((packed));
+};
 
 /** Transfer Event bit fields **/
 #define	TRB_TO_EP_ID(p)	(((p) >> 16) & 0x1f)
@@ -747,7 +747,7 @@ struct xhci_link_trb {
 	u32 segment_ptr[2];
 	u32 intr_target;
 	u32 control;
-} __attribute__ ((packed));
+};
 
 /* control bitfields */
 #define LINK_TOGGLE	(0x1<<1)
@@ -758,7 +758,7 @@ struct xhci_event_cmd {
 	u32 cmd_trb[2];
 	u32 status;
 	u32 flags;
-} __attribute__ ((packed));
+};
 
 /* flags bitmasks */
 /* bits 16:23 are the virtual function ID */
@@ -809,7 +809,7 @@ struct xhci_event_cmd {
 
 struct xhci_generic_trb {
 	u32 field[4];
-} __attribute__ ((packed));
+};
 
 union xhci_trb {
 	struct xhci_link_trb		link;
@@ -904,7 +904,7 @@ struct xhci_segment {
 	/* private to HCD */
 	struct xhci_segment	*next;
 	dma_addr_t		dma;
-} __attribute__ ((packed));
+};
 
 struct xhci_td {
 	struct list_head	td_list;
@@ -946,7 +946,7 @@ struct xhci_erst_entry {
 	u32	seg_size;
 	/* Set to zero */
 	u32	rsvd;
-} __attribute__ ((packed));
+};
 
 struct xhci_erst {
 	struct xhci_erst_entry	*entries;
@@ -980,7 +980,7 @@ struct xhci_hcd {
 	struct xhci_run_regs __iomem *run_regs;
 	struct xhci_doorbell_array __iomem *dba;
 	/* Our HCD's current interrupter register set */
-	struct	intr_reg __iomem *ir_set;
+	struct	xhci_intr_reg __iomem *ir_set;
 
 	/* Cached register copies of read-only HC data */
 	__u32		hcs_params1;
@@ -1079,7 +1079,7 @@ static inline void xhci_writel(struct xhci_hcd *xhci,
 }
 
 /* xHCI debugging */
-void xhci_print_ir_set(struct xhci_hcd *xhci, struct intr_reg *ir_set, int set_num);
+void xhci_print_ir_set(struct xhci_hcd *xhci, struct xhci_intr_reg *ir_set, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);
 void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);

commit 23e3be113f42790736319c049c78e5f9a4394c02
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Apr 29 19:05:20 2009 -0700

    USB: xhci: Avoid global namespace pollution.
    
    Make all globally visible functions start with xhci_ and mark functions as
    static if they're only called within the same C file.  Fix some long lines
    while we're at it.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 13c9166e758a..df8778e1cfc6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1130,18 +1130,22 @@ int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
-dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
-void ring_cmd_db(struct xhci_hcd *xhci);
-void *setup_one_noop(struct xhci_hcd *xhci);
+dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
+void xhci_ring_cmd_db(struct xhci_hcd *xhci);
+void *xhci_setup_one_noop(struct xhci_hcd *xhci);
 void xhci_handle_event(struct xhci_hcd *xhci);
-void set_hc_event_deq(struct xhci_hcd *xhci);
-int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
-int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
-int queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
+void xhci_set_hc_event_deq(struct xhci_hcd *xhci);
+int xhci_queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
+int xhci_queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
+		u32 slot_id);
+int xhci_queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
 		unsigned int ep_index);
-int queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
-int queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
-int queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
+int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
+		int slot_id, unsigned int ep_index);
+int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,
+		int slot_id, unsigned int ep_index);
+int xhci_queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr,
+		u32 slot_id);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 045f123d9c83b9a18c9d43a9afbf52bf0799640d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 29 19:12:44 2009 -0700

    USB: xhci: fix some compiler warnings in xhci.h
    
    This fixes the warning:
    drivers/usb/host/xhci.h:1083: warning: passing argument 1 of xhci_to_hcd discards qualifiers from pointer target type
    drivers/usb/host/xhci.h:1083: warning: passing argument 1 of xhci_to_hcd discards qualifiers from pointer target type
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index e57a609e381d..13c9166e758a 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1068,12 +1068,13 @@ static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
 {
 	return readl(regs);
 }
-static inline void xhci_writel(const struct xhci_hcd *xhci,
+static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __u32 __iomem *regs)
 {
 	if (!in_interrupt())
-		xhci_dbg(xhci, "`MEM_WRITE_DWORD(3'b000, 32'h%0x, 32'h%0x, 4'hf);\n",
-				(unsigned int) regs, val);
+		xhci_dbg(xhci,
+			 "`MEM_WRITE_DWORD(3'b000, 32'h%p, 32'h%0x, 4'hf);\n",
+			 regs, val);
 	writel(val, regs);
 }
 

commit b7258a4aba2b24d5c27a0f6674795e83e7771969
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Apr 29 19:02:47 2009 -0700

    USB: xhci: use xhci_handle_event instead of handle_event
    
    The former is way to generic for a global symbol.
    
    Fixes this build error:
    
    drivers/usb/built-in.o: In function `.handle_event': (.text+0x67dd0): multiple definition of `.handle_event'
    drivers/pcmcia/built-in.o:(.text+0xcfcc): first defined here
    drivers/usb/built-in.o: In function `handle_event': (.opd+0x5bc8): multiple definition of `handle_event'
    drivers/pcmcia/built-in.o:(.opd+0xed0): first defined here
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7b7103405c69..e57a609e381d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1132,7 +1132,7 @@ void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
 void ring_cmd_db(struct xhci_hcd *xhci);
 void *setup_one_noop(struct xhci_hcd *xhci);
-void handle_event(struct xhci_hcd *xhci);
+void xhci_handle_event(struct xhci_hcd *xhci);
 void set_hc_event_deq(struct xhci_hcd *xhci);
 int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);

commit ae636747146ea97efa18e04576acd3416e2514f5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Apr 29 19:02:31 2009 -0700

    USB: xhci: URB cancellation support.
    
    Add URB cancellation support to the xHCI host controller driver.  This
    currently supports cancellation for endpoints that do not have streams
    enabled.
    
    An URB is represented by a number of Transaction Request Buffers (TRBs),
    that are chained together to make one (or more) Transaction Descriptors
    (TDs) on an endpoint ring.  The ring is comprised of contiguous segments,
    linked together with Link TRBs (which may or may not be chained into a TD).
    
    To cancel an URB, we must stop the endpoint ring, make the hardware skip
    over the TDs in the URB (either by turning them into No-op TDs, or by
    moving the hardware's ring dequeue pointer past the last TRB in the last
    TD), and then restart the ring.
    
    There are times when we must drop the xHCI lock during this process, like
    when we need to complete cancelled URBs.  We must ensure that additional
    URBs can be marked as cancelled, and that new URBs can be enqueued (since
    the URB completion handlers can do either).  The new endpoint ring
    variables cancels_pending and state (which can only be modified while
    holding the xHCI lock) ensure that future cancellation and enqueueing do
    not interrupt any pending cancellation code.
    
    To facilitate cancellation, we must keep track of the starting ring
    segment, first TRB, and last TRB for each URB.  We also need to keep track
    of the list of TDs that have been marked as cancelled, separate from the
    list of TDs that are queued for this endpoint.  The new variables and
    cancellation list are stored in the xhci_td structure.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 06e07616631f..7b7103405c69 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -514,6 +514,7 @@ struct xhci_slot_ctx {
 /* bits 8:26 reserved */
 /* Slot state */
 #define SLOT_STATE	(0x1f << 27)
+#define GET_SLOT_STATE(p)	(((p) & (0x1f << 27)) >> 27)
 
 
 /**
@@ -765,6 +766,11 @@ struct xhci_event_cmd {
 #define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
 #define SLOT_ID_FOR_TRB(p)	(((p) & 0xff) << 24)
 
+/* Stop Endpoint TRB - ep_index to endpoint ID for this TRB */
+#define TRB_TO_EP_INDEX(p)		((((p) & (0x1f << 16)) >> 16) - 1)
+#define	EP_ID_FOR_TRB(p)		((((p) + 1) & 0x1f) << 16)
+
+
 /* Port Status Change Event TRB fields */
 /* Port ID - bits 31:24 */
 #define GET_PORT_ID(p)		(((p) & (0xff << 24)) >> 24)
@@ -893,12 +899,6 @@ union xhci_trb {
 #define TRB_MAX_BUFF_SHIFT		16
 #define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
 
-struct xhci_td {
-	struct list_head	td_list;
-	struct urb		*urb;
-	union xhci_trb		*last_trb;
-};
-
 struct xhci_segment {
 	union xhci_trb		*trbs;
 	/* private to HCD */
@@ -906,6 +906,15 @@ struct xhci_segment {
 	dma_addr_t		dma;
 } __attribute__ ((packed));
 
+struct xhci_td {
+	struct list_head	td_list;
+	struct list_head	cancelled_td_list;
+	struct urb		*urb;
+	struct xhci_segment	*start_seg;
+	union xhci_trb		*first_trb;
+	union xhci_trb		*last_trb;
+};
+
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
 	union  xhci_trb		*enqueue;
@@ -915,6 +924,14 @@ struct xhci_ring {
 	struct xhci_segment	*deq_seg;
 	unsigned int		deq_updates;
 	struct list_head	td_list;
+	/* ----  Related to URB cancellation ---- */
+	struct list_head	cancelled_td_list;
+	unsigned int		cancels_pending;
+	unsigned int		state;
+#define SET_DEQ_PENDING		(1 << 0)
+	/* The TRB that was last reported in a stopped endpoint ring */
+	union xhci_trb		*stopped_trb;
+	struct xhci_td		*stopped_td;
 	/*
 	 * Write the cycle state into the TRB cycle field to give ownership of
 	 * the TRB to the host controller (if we are the producer), or to check
@@ -1119,6 +1136,8 @@ void handle_event(struct xhci_hcd *xhci);
 void set_hc_event_deq(struct xhci_hcd *xhci);
 int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
+int queue_stop_endpoint(struct xhci_hcd *xhci, int slot_id,
+		unsigned int ep_index);
 int queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
 int queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
 int queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);

commit b10de142119a676552df3f0d2e3a9d647036c26a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:50 2009 -0700

    USB: xhci: Bulk transfer support
    
    Allow device drivers to submit URBs to bulk endpoints on devices under an
    xHCI host controller.  Share code between the control and bulk enqueueing
    functions when it makes sense.
    
    To get the best performance out of bulk transfers, SuperSpeed devices must
    have the bMaxBurst size copied from their endpoint companion controller
    into the xHCI device context.  This allows the host controller to "burst"
    up to 16 packets before it has to wait for the device to acknowledge the
    first packet.
    
    The buffers in Transfer Request Blocks (TRBs) can cross page boundaries,
    but they cannot cross 64KB boundaries.  The buffer must be broken into
    multiple TRBs if a 64KB boundary is crossed.
    
    The sum of buffer lengths in all the TRBs in a Transfer Descriptor (TD)
    cannot exceed 64MB.  To work around this, the enqueueing code must enqueue
    multiple TDs.  The transfer event handler may incorrectly give back the
    URB in this case, if it gets a transfer event that points somewhere in the
    first TD.  FIXME later.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 1a6fd997c343..06e07616631f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -889,6 +889,9 @@ union xhci_trb {
  */
 #define TRBS_PER_SEGMENT	64
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
+/* TRB buffer pointers can't cross 64KB boundaries */
+#define TRB_MAX_BUFF_SHIFT		16
+#define TRB_MAX_BUFF_SIZE	(1 << TRB_MAX_BUFF_SHIFT)
 
 struct xhci_td {
 	struct list_head	td_list;
@@ -1117,6 +1120,7 @@ void set_hc_event_deq(struct xhci_hcd *xhci);
 int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
 int queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
+int queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
 int queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
 
 /* xHCI roothub code */

commit f94e0186312b0fc39f41eed4e21836ed74b7efe1
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:38 2009 -0700

    USB: xhci: Bandwidth allocation support
    
    Since the xHCI host controller hardware (xHC) has an internal schedule, it
    needs a better representation of what devices are consuming bandwidth on
    the bus.  Each device is represented by a device context, with data about
    the device, endpoints, and pointers to each endpoint ring.
    
    We need to update the endpoint information for a device context before a
    new configuration or alternate interface setting is selected.  We setup an
    input device context with modified endpoint information and newly
    allocated endpoint rings, and then submit a Configure Endpoint Command to
    the hardware.
    
    The host controller can reject the new configuration if it exceeds the bus
    bandwidth, or the host controller doesn't have enough internal resources
    for the configuration.  If the command fails, we still have the older
    device context with the previous configuration.  If the command succeeds,
    we free the old endpoint rings.
    
    The root hub isn't a real device, so always say yes to any bandwidth
    changes for it.
    
    The USB core will enable, disable, and then enable endpoint 0 several
    times during the initialization sequence.  The device will always have an
    endpoint ring for endpoint 0 and bandwidth allocated for that, unless the
    device is disconnected or gets a SetAddress 0 request.  So we don't pay
    attention for when xhci_check_bandwidth() is called for a re-add of
    endpoint 0.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fc8dcd2aa770..1a6fd997c343 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -486,8 +486,6 @@ struct xhci_slot_ctx {
 #define LAST_CTX_MASK	(0x1f << 27)
 #define LAST_CTX(p)	((p) << 27)
 #define LAST_CTX_TO_EP_NUM(p)	(((p) >> 27) - 1)
-/* Plus one for the slot context flag */
-#define EPI_TO_FLAG(p)	(1 << ((p) + 1))
 #define SLOT_FLAG	(1 << 0)
 #define EP0_FLAG	(1 << 1)
 
@@ -566,7 +564,7 @@ struct xhci_ep_ctx {
 /* bits 10:14 are Max Primary Streams */
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
-#define EP_INTERVAL		(0xff << 16)
+#define EP_INTERVAL(p)		((p & 0xff) << 16)
 
 /* ep_info2 bitmasks */
 /*
@@ -626,6 +624,11 @@ struct xhci_virt_device {
 	dma_addr_t			in_ctx_dma;
 	/* FIXME when stream support is added */
 	struct xhci_ring		*ep_rings[31];
+	/* Temporary storage in case the configure endpoint command fails and we
+	 * have to restore the device state to the previous state
+	 */
+	struct xhci_ring		*new_ep_rings[31];
+	struct completion		cmd_completion;
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
 };
@@ -1075,6 +1078,10 @@ void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);
 int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device *udev, gfp_t flags);
 int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);
 unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
+unsigned int xhci_get_endpoint_flag(struct usb_endpoint_descriptor *desc);
+void xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);
+int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_device *udev, struct usb_host_endpoint *ep);
+void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 
 #ifdef CONFIG_PCI
 /* xHCI PCI glue */
@@ -1096,6 +1103,10 @@ void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
 int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
+int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
+int xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev, struct usb_host_endpoint *ep);
+int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
+void xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
@@ -1106,6 +1117,7 @@ void set_hc_event_deq(struct xhci_hcd *xhci);
 int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
 int queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
+int queue_configure_endpoint(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit d0e96f5a71a032ced0c35f521c1cbd67e816922a
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:01 2009 -0700

    USB: xhci: Control transfer support.
    
    Allow device drivers to enqueue URBs to control endpoints on devices under
    an xHCI host controller.  Each control transfer is represented by a
    series of Transfer Descriptors (TDs) written to an endpoint ring.  There
    is one TD for the Setup phase, (optionally) one TD for the Data phase, and
    one TD for the Status phase.
    
    Enqueue these TDs onto the endpoint ring that represents the control
    endpoint.  The host controller hardware will return an event on the event
    ring that points to the (DMA) address of one of the TDs on the endpoint
    ring.  If the transfer was successful, the transfer event TRB will have a
    completion code of success, and it will point to the Status phase TD.
    Anything else is considered an error.
    
    This should work for control endpoints besides the default endpoint, but
    that hasn't been tested.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 4ef6b9e88504..fc8dcd2aa770 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -448,6 +448,9 @@ struct xhci_doorbell_array {
 #define	DB_STREAM_ID_HOST	0x0
 #define	DB_MASK			(0xff << 8)
 
+/* Endpoint Target - bits 0:7 */
+#define EPI_TO_DB(p)		(((p) + 1) & 0xff)
+
 
 /**
  * struct xhci_slot_ctx
@@ -552,13 +555,18 @@ struct xhci_ep_ctx {
  * 4 - TRB error
  * 5-7 - reserved
  */
-#define EP_STATE	(0xf)
+#define EP_STATE_MASK		(0xf)
+#define EP_STATE_DISABLED	0
+#define EP_STATE_RUNNING	1
+#define EP_STATE_HALTED		2
+#define EP_STATE_STOPPED	3
+#define EP_STATE_ERROR		4
 /* Mult - Max number of burtst within an interval, in EP companion desc. */
 #define EP_MULT(p)		((p & 0x3) << 8)
 /* bits 10:14 are Max Primary Streams */
 /* bit 15 is Linear Stream Array */
 /* Interval - period between requests to an endpoint - 125u increments. */
-#define EP_INTERVAL	(0xff << 16)
+#define EP_INTERVAL		(0xff << 16)
 
 /* ep_info2 bitmasks */
 /*
@@ -618,7 +626,6 @@ struct xhci_virt_device {
 	dma_addr_t			in_ctx_dma;
 	/* FIXME when stream support is added */
 	struct xhci_ring		*ep_rings[31];
-	dma_addr_t			ep_dma[31];
 	/* Status of the last command issued for this device */
 	u32				cmd_status;
 };
@@ -657,6 +664,9 @@ struct xhci_transfer_event {
 	u32	flags;
 } __attribute__ ((packed));
 
+/** Transfer Event bit fields **/
+#define	TRB_TO_EP_ID(p)	(((p) >> 16) & 0x1f)
+
 /* Completion Code - only applicable for some types of TRBs */
 #define	COMP_CODE_MASK		(0xff << 24)
 #define GET_COMP_CODE(p)	(((p) & COMP_CODE_MASK) >> 24)
@@ -877,6 +887,12 @@ union xhci_trb {
 #define TRBS_PER_SEGMENT	64
 #define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
 
+struct xhci_td {
+	struct list_head	td_list;
+	struct urb		*urb;
+	union xhci_trb		*last_trb;
+};
+
 struct xhci_segment {
 	union xhci_trb		*trbs;
 	/* private to HCD */
@@ -892,6 +908,7 @@ struct xhci_ring {
 	union  xhci_trb		*dequeue;
 	struct xhci_segment	*deq_seg;
 	unsigned int		deq_updates;
+	struct list_head	td_list;
 	/*
 	 * Write the cycle state into the TRB cycle field to give ownership of
 	 * the TRB to the host controller (if we are the producer), or to check
@@ -1042,6 +1059,8 @@ void xhci_print_ir_set(struct xhci_hcd *xhci, struct intr_reg *ir_set, int set_n
 void xhci_print_registers(struct xhci_hcd *xhci);
 void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);
+void xhci_print_trb_offsets(struct xhci_hcd *xhci, union xhci_trb *trb);
+void xhci_debug_trb(struct xhci_hcd *xhci, union xhci_trb *trb);
 void xhci_debug_segment(struct xhci_hcd *xhci, struct xhci_segment *seg);
 void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
@@ -1055,6 +1074,7 @@ int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);
 void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);
 int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device *udev, gfp_t flags);
 int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);
+unsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);
 
 #ifdef CONFIG_PCI
 /* xHCI PCI glue */
@@ -1074,6 +1094,8 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd);
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
 void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
+int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
@@ -1083,6 +1105,7 @@ void handle_event(struct xhci_hcd *xhci);
 void set_hc_event_deq(struct xhci_hcd *xhci);
 int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
 int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
+int queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb, int slot_id, unsigned int ep_index);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 3ffbba9511b4148cbe1f6b6238686adaeaca8feb
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:38 2009 -0700

    USB: xhci: Allocate and address USB devices
    
    xHCI needs to get a "Slot ID" from the host controller and allocate other
    data structures for every USB device.  Make usb_alloc_dev() and
    usb_release_dev() allocate and free these device structures.  After
    setting up the xHC device structures, usb_alloc_dev() must wait for the
    hardware to respond to an Enable Slot command.  usb_alloc_dev() fires off
    a Disable Slot command and does not wait for it to complete.
    
    When the USB core wants to choose an address for the device, the xHCI
    driver must issue a Set Address command and wait for an event for that
    command.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 059c659d3f39..4ef6b9e88504 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -285,12 +285,21 @@ struct xhci_op_regs {
  * 4 - super speed
  * 5-15 reserved
  */
-#define DEV_SPEED_MASK		(0xf<<10)
+#define DEV_SPEED_MASK		(0xf << 10)
+#define	XDEV_FS			(0x1 << 10)
+#define	XDEV_LS			(0x2 << 10)
+#define	XDEV_HS			(0x3 << 10)
+#define	XDEV_SS			(0x4 << 10)
 #define DEV_UNDEFSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x0<<10))
-#define DEV_FULLSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x1<<10))
-#define DEV_LOWSPEED(p)		(((p) & DEV_SPEED_MASK) == (0x2<<10))
-#define DEV_HIGHSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x3<<10))
-#define DEV_SUPERSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x4<<10))
+#define DEV_FULLSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_FS)
+#define DEV_LOWSPEED(p)		(((p) & DEV_SPEED_MASK) == XDEV_LS)
+#define DEV_HIGHSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_HS)
+#define DEV_SUPERSPEED(p)	(((p) & DEV_SPEED_MASK) == XDEV_SS)
+/* Bits 20:23 in the Slot Context are the speed for the device */
+#define	SLOT_SPEED_FS		(XDEV_FS << 10)
+#define	SLOT_SPEED_LS		(XDEV_LS << 10)
+#define	SLOT_SPEED_HS		(XDEV_HS << 10)
+#define	SLOT_SPEED_SS		(XDEV_SS << 10)
 /* Port Indicator Control */
 #define PORT_LED_OFF	(0 << 14)
 #define PORT_LED_AMBER	(1 << 14)
@@ -471,14 +480,19 @@ struct xhci_slot_ctx {
 /* Set if the device is a hub - bit 26 */
 #define DEV_HUB		(0x1 << 26)
 /* Index of the last valid endpoint context in this device context - 27:31 */
-#define LAST_EP_MASK	(0x1f << 27)
-#define LAST_EP(p)	((p) << 27)
+#define LAST_CTX_MASK	(0x1f << 27)
+#define LAST_CTX(p)	((p) << 27)
+#define LAST_CTX_TO_EP_NUM(p)	(((p) >> 27) - 1)
+/* Plus one for the slot context flag */
+#define EPI_TO_FLAG(p)	(1 << ((p) + 1))
+#define SLOT_FLAG	(1 << 0)
+#define EP0_FLAG	(1 << 1)
 
 /* dev_info2 bitmasks */
 /* Max Exit Latency (ms) - worst case time to wake up all links in dev path */
 #define MAX_EXIT	(0xffff)
 /* Root hub port number that is needed to access the USB device */
-#define ROOT_HUB_PORT	(0xff << 16)
+#define ROOT_HUB_PORT(p)	(((p) & 0xff) << 16)
 
 /* tt_info bitmasks */
 /*
@@ -495,7 +509,7 @@ struct xhci_slot_ctx {
 
 /* dev_state bitmasks */
 /* USB device address - assigned by the HC */
-#define DEV_ADDR	(0xff)
+#define DEV_ADDR_MASK	(0xff)
 /* bits 8:26 reserved */
 /* Slot state */
 #define SLOT_STATE	(0x1f << 27)
@@ -507,12 +521,13 @@ struct xhci_slot_ctx {
  * @ep_info2:	information on endpoint type, max packet size, max burst size,
  * 		error count, and whether the HC will force an event for all
  * 		transactions.
- * @ep_ring:	64-bit ring address.  If the endpoint only defines one flow,
- * 		this points to the endpoint transfer ring.  Otherwise, it points
- * 		to a flow context array, which has a ring pointer for each flow.
- * @intr_target:
- * 		64-bit address of the Interrupter Target that will receive
- * 		events from this endpoint.
+ * @deq:	64-bit ring dequeue pointer address.  If the endpoint only
+ * 		defines one stream, this points to the endpoint transfer ring.
+ * 		Otherwise, it points to a stream context array, which has a
+ * 		ring pointer for each flow.
+ * @tx_info:
+ * 		Average TRB lengths for the endpoint ring and
+ * 		max payload within an Endpoint Service Interval Time (ESIT).
  *
  * Endpoint Context - section 6.2.1.2.  This assumes the HC uses 32-byte context
  * structures.  If the HC uses 64-byte contexts, there is an additional 32 bytes
@@ -521,12 +536,10 @@ struct xhci_slot_ctx {
 struct xhci_ep_ctx {
 	u32	ep_info;
 	u32	ep_info2;
-	/* 64-bit endpoint ring address */
-	u32	ep_ring[2];
-	/* 64-bit address of the interrupter target */
-	u32	intr_target[2];
+	u32	deq[2];
+	u32	tx_info;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
-	u32	reserved[2];
+	u32	reserved[3];
 } __attribute__ ((packed));
 
 /* ep_info bitmasks */
@@ -589,6 +602,28 @@ struct xhci_device_control {
 #define	ADD_EP(x)	(0x1 << x)
 
 
+struct xhci_virt_device {
+	/*
+	 * Commands to the hardware are passed an "input context" that
+	 * tells the hardware what to change in its data structures.
+	 * The hardware will return changes in an "output context" that
+	 * software must allocate for the hardware.  We need to keep
+	 * track of input and output contexts separately because
+	 * these commands might fail and we don't trust the hardware.
+	 */
+	struct xhci_device_control	*out_ctx;
+	dma_addr_t			out_ctx_dma;
+	/* Used for addressing devices and configuration changes */
+	struct xhci_device_control	*in_ctx;
+	dma_addr_t			in_ctx_dma;
+	/* FIXME when stream support is added */
+	struct xhci_ring		*ep_rings[31];
+	dma_addr_t			ep_dma[31];
+	/* Status of the last command issued for this device */
+	u32				cmd_status;
+};
+
+
 /**
  * struct xhci_device_context_array
  * @dev_context_ptr	array of 64-bit DMA addresses for device contexts
@@ -711,6 +746,11 @@ struct xhci_event_cmd {
 	u32 flags;
 } __attribute__ ((packed));
 
+/* flags bitmasks */
+/* bits 16:23 are the virtual function ID */
+/* bits 24:31 are the slot ID */
+#define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
+#define SLOT_ID_FOR_TRB(p)	(((p) & 0xff) << 24)
 
 /* Port Status Change Event TRB fields */
 /* Port ID - bits 31:24 */
@@ -931,6 +971,11 @@ struct xhci_hcd {
 	struct xhci_ring	*cmd_ring;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
+	/* slot enabling and address device helpers */
+	struct completion	addr_dev;
+	int slot_id;
+	/* Internal mirror of the HW's dcbaa */
+	struct xhci_virt_device	*devs[MAX_HC_SLOTS];
 
 	/* DMA pools */
 	struct dma_pool	*device_pool;
@@ -1002,10 +1047,14 @@ void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
+void xhci_dbg_ctx(struct xhci_hcd *xhci, struct xhci_device_control *ctx, dma_addr_t dma, unsigned int last_ep);
 
 /* xHCI memory managment */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
 int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);
+void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);
+int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device *udev, gfp_t flags);
+int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);
 
 #ifdef CONFIG_PCI
 /* xHCI PCI glue */
@@ -1022,6 +1071,9 @@ void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_get_frame(struct usb_hcd *hcd);
 irqreturn_t xhci_irq(struct usb_hcd *hcd);
+int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);
+void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev);
+int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev);
 
 /* xHCI ring, segment, TRB, and TD functions */
 dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
@@ -1029,6 +1081,8 @@ void ring_cmd_db(struct xhci_hcd *xhci);
 void *setup_one_noop(struct xhci_hcd *xhci);
 void handle_event(struct xhci_hcd *xhci);
 void set_hc_event_deq(struct xhci_hcd *xhci);
+int queue_slot_control(struct xhci_hcd *xhci, u32 trb_type, u32 slot_id);
+int queue_address_device(struct xhci_hcd *xhci, dma_addr_t in_ctx_ptr, u32 slot_id);
 
 /* xHCI roothub code */
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,

commit 0f2a79300a1471cf92ab43af165ea13555c8b0a5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:12 2009 -0700

    USB: xhci: Root hub support.
    
    Add functionality for getting port status and hub descriptor for xHCI root
    hubs.  This is WIP because the USB 3.0 hub descriptor is different from
    the USB 2.0 hub descriptor.  For now, we lie about the root hub descriptor
    because the changes won't effect how the core talks to the root hub.
    Later we will need to add the USB 3.0 hub descriptor for real hubs, and
    this code might change.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 66be134b8921..059c659d3f39 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -35,6 +35,8 @@
 
 /* Max number of USB devices for any host controller - limit in section 6.1 */
 #define MAX_HC_SLOTS		256
+/* Section 5.3.3 - MaxPorts */
+#define MAX_HC_PORTS		127
 
 /*
  * xHCI register interface.
@@ -710,6 +712,10 @@ struct xhci_event_cmd {
 } __attribute__ ((packed));
 
 
+/* Port Status Change Event TRB fields */
+/* Port ID - bits 31:24 */
+#define GET_PORT_ID(p)		(((p) & (0xff << 24)) >> 24)
+
 /* Normal TRB fields */
 /* transfer_len bitmasks - bits 0:16 */
 #define	TRB_LEN(p)		((p) & 0x1ffff)
@@ -1024,4 +1030,9 @@ void *setup_one_noop(struct xhci_hcd *xhci);
 void handle_event(struct xhci_hcd *xhci);
 void set_hc_event_deq(struct xhci_hcd *xhci);
 
+/* xHCI roothub code */
+int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
+		char *buf, u16 wLength);
+int xhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+
 #endif /* __LINUX_XHCI_HCD_H */

commit 7f84eef0dafb1d318263d8b71c38700aaf2d530d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:53:56 2009 -0700

    USB: xhci: No-op command queueing and irq handler.
    
    xHCI host controllers can optionally implement a no-op test.  This
    simple test ensures the OS has correctly setup all basic data structures
    and can correctly respond to interrupts from the host controller
    hardware.
    
    There are two rings exercised by the no-op test:  the command ring, and
    the event ring.
    
    The host controller driver writes a no-op command TRB to the command
    ring, and rings the doorbell for the command ring (the first entry in
    the doorbell array).  The hardware receives this event, places a command
    completion event on the event ring, and fires an interrupt.
    
    The host controller driver sees the interrupt, and checks the event ring
    for TRBs it can process, and sees the command completion event.  (See
    the rules in xhci-ring.c for who "owns" a TRB.  This is a simplified set
    of rules, and may not contain all the details that are in the xHCI 0.95
    spec.)
    
    A timer fires every 60 seconds to debug the state of the hardware and
    command and event rings.  This timer only runs if
    CONFIG_USB_XHCI_HCD_DEBUGGING is 'y'.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index f168fcac5999..66be134b8921 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -24,6 +24,7 @@
 #define __LINUX_XHCI_HCD_H
 
 #include <linux/usb.h>
+#include <linux/timer.h>
 
 #include "../core/hcd.h"
 /* Code sharing between pci-quirks and xhci hcd */
@@ -377,6 +378,7 @@ struct intr_reg {
 /* irq_pending bitmasks */
 #define	ER_IRQ_PENDING(p)	((p) & 0x1)
 /* bits 2:31 need to be preserved */
+/* THIS IS BUGGY - FIXME - IP IS WRITE 1 TO CLEAR */
 #define	ER_IRQ_CLEAR(p)		((p) & 0xfffffffe)
 #define	ER_IRQ_ENABLE(p)	((ER_IRQ_CLEAR(p)) | 0x2)
 #define	ER_IRQ_DISABLE(p)	((ER_IRQ_CLEAR(p)) & ~(0x2))
@@ -699,11 +701,14 @@ struct xhci_link_trb {
 /* control bitfields */
 #define LINK_TOGGLE	(0x1<<1)
 
+/* Command completion event TRB */
+struct xhci_event_cmd {
+	/* Pointer to command TRB, or the value passed by the event data trb */
+	u32 cmd_trb[2];
+	u32 status;
+	u32 flags;
+} __attribute__ ((packed));
 
-union xhci_trb {
-	struct xhci_link_trb		link;
-	struct xhci_transfer_event	trans_event;
-};
 
 /* Normal TRB fields */
 /* transfer_len bitmasks - bits 0:16 */
@@ -737,6 +742,17 @@ union xhci_trb {
 /* Control transfer TRB specific fields */
 #define TRB_DIR_IN		(1<<16)
 
+struct xhci_generic_trb {
+	u32 field[4];
+} __attribute__ ((packed));
+
+union xhci_trb {
+	struct xhci_link_trb		link;
+	struct xhci_transfer_event	trans_event;
+	struct xhci_event_cmd		event_cmd;
+	struct xhci_generic_trb		generic;
+};
+
 /* TRB bit mask */
 #define	TRB_TYPE_BITMASK	(0xfc00)
 #define TRB_TYPE(p)		((p) << 10)
@@ -825,7 +841,11 @@ struct xhci_segment {
 struct xhci_ring {
 	struct xhci_segment	*first_seg;
 	union  xhci_trb		*enqueue;
+	struct xhci_segment	*enq_seg;
+	unsigned int		enq_updates;
 	union  xhci_trb		*dequeue;
+	struct xhci_segment	*deq_seg;
+	unsigned int		deq_updates;
 	/*
 	 * Write the cycle state into the TRB cycle field to give ownership of
 	 * the TRB to the host controller (if we are the producer), or to check
@@ -861,6 +881,8 @@ struct xhci_erst {
 #define	ERST_SIZE	64
 /* Initial number of event segment rings allocated */
 #define	ERST_ENTRIES	1
+/* Poll every 60 seconds */
+#define	POLL_TIMEOUT	60
 /* XXX: Make these module parameters */
 
 
@@ -907,8 +929,21 @@ struct xhci_hcd {
 	/* DMA pools */
 	struct dma_pool	*device_pool;
 	struct dma_pool	*segment_pool;
+
+#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING
+	/* Poll the rings - for debugging */
+	struct timer_list	event_ring_timer;
+	int			zombie;
+#endif
+	/* Statistics */
+	int			noops_submitted;
+	int			noops_handled;
+	int			error_bitmask;
 };
 
+/* For testing purposes */
+#define NUM_TEST_NOOPS	0
+
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
 {
@@ -956,9 +991,11 @@ void xhci_print_ir_set(struct xhci_hcd *xhci, struct intr_reg *ir_set, int set_n
 void xhci_print_registers(struct xhci_hcd *xhci);
 void xhci_dbg_regs(struct xhci_hcd *xhci);
 void xhci_print_run_regs(struct xhci_hcd *xhci);
+void xhci_debug_segment(struct xhci_hcd *xhci, struct xhci_segment *seg);
 void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
 void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
+void xhci_dbg_ring_ptrs(struct xhci_hcd *xhci, struct xhci_ring *ring);
 
 /* xHCI memory managment */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);
@@ -978,5 +1015,13 @@ int xhci_run(struct usb_hcd *hcd);
 void xhci_stop(struct usb_hcd *hcd);
 void xhci_shutdown(struct usb_hcd *hcd);
 int xhci_get_frame(struct usb_hcd *hcd);
+irqreturn_t xhci_irq(struct usb_hcd *hcd);
+
+/* xHCI ring, segment, TRB, and TD functions */
+dma_addr_t trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);
+void ring_cmd_db(struct xhci_hcd *xhci);
+void *setup_one_noop(struct xhci_hcd *xhci);
+void handle_event(struct xhci_hcd *xhci);
+void set_hc_event_deq(struct xhci_hcd *xhci);
 
 #endif /* __LINUX_XHCI_HCD_H */

commit a74588f94655263b96dacbbf14aac0958d8b7409
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:53:42 2009 -0700

    USB: xhci: Device context array allocation.
    
    Instead of keeping a "frame list" like older host controllers, the xHCI
    host controller keeps internal representations of the USB devices, with a
    transfer ring per endpoint.  The host controller queues Transfer Request
    Blocks (TRBs) to the endpoint ring, and then "rings the doorbell" for that
    device.  The host controller processes the transfer, places a transfer
    completion event on the event ring, and interrupts the system.
    
    The device context base address array must be allocated by the xHCI host
    controller driver, along with the device contexts it points to.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ed331310f1a8..f168fcac5999 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -436,6 +436,180 @@ struct xhci_doorbell_array {
 #define	DB_MASK			(0xff << 8)
 
 
+/**
+ * struct xhci_slot_ctx
+ * @dev_info:	Route string, device speed, hub info, and last valid endpoint
+ * @dev_info2:	Max exit latency for device number, root hub port number
+ * @tt_info:	tt_info is used to construct split transaction tokens
+ * @dev_state:	slot state and device address
+ *
+ * Slot Context - section 6.2.1.1.  This assumes the HC uses 32-byte context
+ * structures.  If the HC uses 64-byte contexts, there is an additional 32 bytes
+ * reserved at the end of the slot context for HC internal use.
+ */
+struct xhci_slot_ctx {
+	u32	dev_info;
+	u32	dev_info2;
+	u32	tt_info;
+	u32	dev_state;
+	/* offset 0x10 to 0x1f reserved for HC internal use */
+	u32	reserved[4];
+} __attribute__ ((packed));
+
+/* dev_info bitmasks */
+/* Route String - 0:19 */
+#define ROUTE_STRING_MASK	(0xfffff)
+/* Device speed - values defined by PORTSC Device Speed field - 20:23 */
+#define DEV_SPEED	(0xf << 20)
+/* bit 24 reserved */
+/* Is this LS/FS device connected through a HS hub? - bit 25 */
+#define DEV_MTT		(0x1 << 25)
+/* Set if the device is a hub - bit 26 */
+#define DEV_HUB		(0x1 << 26)
+/* Index of the last valid endpoint context in this device context - 27:31 */
+#define LAST_EP_MASK	(0x1f << 27)
+#define LAST_EP(p)	((p) << 27)
+
+/* dev_info2 bitmasks */
+/* Max Exit Latency (ms) - worst case time to wake up all links in dev path */
+#define MAX_EXIT	(0xffff)
+/* Root hub port number that is needed to access the USB device */
+#define ROOT_HUB_PORT	(0xff << 16)
+
+/* tt_info bitmasks */
+/*
+ * TT Hub Slot ID - for low or full speed devices attached to a high-speed hub
+ * The Slot ID of the hub that isolates the high speed signaling from
+ * this low or full-speed device.  '0' if attached to root hub port.
+ */
+#define TT_SLOT		(0xff)
+/*
+ * The number of the downstream facing port of the high-speed hub
+ * '0' if the device is not low or full speed.
+ */
+#define TT_PORT		(0xff << 8)
+
+/* dev_state bitmasks */
+/* USB device address - assigned by the HC */
+#define DEV_ADDR	(0xff)
+/* bits 8:26 reserved */
+/* Slot state */
+#define SLOT_STATE	(0x1f << 27)
+
+
+/**
+ * struct xhci_ep_ctx
+ * @ep_info:	endpoint state, streams, mult, and interval information.
+ * @ep_info2:	information on endpoint type, max packet size, max burst size,
+ * 		error count, and whether the HC will force an event for all
+ * 		transactions.
+ * @ep_ring:	64-bit ring address.  If the endpoint only defines one flow,
+ * 		this points to the endpoint transfer ring.  Otherwise, it points
+ * 		to a flow context array, which has a ring pointer for each flow.
+ * @intr_target:
+ * 		64-bit address of the Interrupter Target that will receive
+ * 		events from this endpoint.
+ *
+ * Endpoint Context - section 6.2.1.2.  This assumes the HC uses 32-byte context
+ * structures.  If the HC uses 64-byte contexts, there is an additional 32 bytes
+ * reserved at the end of the endpoint context for HC internal use.
+ */
+struct xhci_ep_ctx {
+	u32	ep_info;
+	u32	ep_info2;
+	/* 64-bit endpoint ring address */
+	u32	ep_ring[2];
+	/* 64-bit address of the interrupter target */
+	u32	intr_target[2];
+	/* offset 0x14 - 0x1f reserved for HC internal use */
+	u32	reserved[2];
+} __attribute__ ((packed));
+
+/* ep_info bitmasks */
+/*
+ * Endpoint State - bits 0:2
+ * 0 - disabled
+ * 1 - running
+ * 2 - halted due to halt condition - ok to manipulate endpoint ring
+ * 3 - stopped
+ * 4 - TRB error
+ * 5-7 - reserved
+ */
+#define EP_STATE	(0xf)
+/* Mult - Max number of burtst within an interval, in EP companion desc. */
+#define EP_MULT(p)		((p & 0x3) << 8)
+/* bits 10:14 are Max Primary Streams */
+/* bit 15 is Linear Stream Array */
+/* Interval - period between requests to an endpoint - 125u increments. */
+#define EP_INTERVAL	(0xff << 16)
+
+/* ep_info2 bitmasks */
+/*
+ * Force Event - generate transfer events for all TRBs for this endpoint
+ * This will tell the HC to ignore the IOC and ISP flags (for debugging only).
+ */
+#define	FORCE_EVENT	(0x1)
+#define ERROR_COUNT(p)	(((p) & 0x3) << 1)
+#define EP_TYPE(p)	((p) << 3)
+#define ISOC_OUT_EP	1
+#define BULK_OUT_EP	2
+#define INT_OUT_EP	3
+#define CTRL_EP		4
+#define ISOC_IN_EP	5
+#define BULK_IN_EP	6
+#define INT_IN_EP	7
+/* bit 6 reserved */
+/* bit 7 is Host Initiate Disable - for disabling stream selection */
+#define MAX_BURST(p)	(((p)&0xff) << 8)
+#define MAX_PACKET(p)	(((p)&0xffff) << 16)
+
+
+/**
+ * struct xhci_device_control
+ * Input/Output context; see section 6.2.5.
+ *
+ * @drop_context:	set the bit of the endpoint context you want to disable
+ * @add_context:	set the bit of the endpoint context you want to enable
+ */
+struct xhci_device_control {
+	u32	drop_flags;
+	u32	add_flags;
+	u32	rsvd[6];
+	struct xhci_slot_ctx	slot;
+	struct xhci_ep_ctx	ep[31];
+} __attribute__ ((packed));
+
+/* drop context bitmasks */
+#define	DROP_EP(x)	(0x1 << x)
+/* add context bitmasks */
+#define	ADD_EP(x)	(0x1 << x)
+
+
+/**
+ * struct xhci_device_context_array
+ * @dev_context_ptr	array of 64-bit DMA addresses for device contexts
+ */
+struct xhci_device_context_array {
+	/* 64-bit device addresses; we only write 32-bit addresses */
+	u32			dev_context_ptrs[2*MAX_HC_SLOTS];
+	/* private xHCD pointers */
+	dma_addr_t	dma;
+} __attribute__ ((packed));
+/* TODO: write function to set the 64-bit device DMA address */
+/*
+ * TODO: change this to be dynamically sized at HC mem init time since the HC
+ * might not be able to handle the maximum number of devices possible.
+ */
+
+
+struct xhci_stream_ctx {
+	/* 64-bit stream ring address, cycle state, and stream type */
+	u32	stream_ring[2];
+	/* offset 0x14 - 0x1f reserved for HC internal use */
+	u32	reserved[2];
+} __attribute__ ((packed));
+
+
 struct xhci_transfer_event {
 	/* 64-bit buffer address, or immediate data */
 	u32	buffer[2];
@@ -725,6 +899,7 @@ struct xhci_hcd {
 	int		msix_count;
 	struct msix_entry	*msix_entries;
 	/* data structures */
+	struct xhci_device_context_array *dcbaa;
 	struct xhci_ring	*cmd_ring;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;

commit 0ebbab37422315a5d0cb29792271085bafdf38c0
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:52:34 2009 -0700

    USB: xhci: Ring allocation and initialization.
    
    Allocate basic xHCI host controller data structures.  For every xHC, there
    is a command ring, an event ring, and a doorbell array.
    
    The doorbell array is used to notify the host controller that work has
    been enqueued onto one of the rings.  The host controller driver enqueues
    commands on the command ring.  The HW enqueues command completion events
    on the event ring and interrupts the system (currently using PCI
    interrupts, although the xHCI HW will use MSI interrupts eventually).
    
    All rings and the doorbell array must be allocated by the xHCI host
    controller driver.
    
    Each ring is comprised of one or more segments, which consists of 16-byte
    Transfer Request Blocks (TRBs) that can be chained to form a Transfer
    Descriptor (TD) that represents a multiple-buffer request.  Segments are
    linked into a ring using Link TRBs, which means they are dynamically
    growable.
    
    The producer of the ring enqueues a TD by writing one or more TRBs in the
    ring and toggling the TRB cycle bit for each TRB.  The consumer knows it
    can process the TRB when the cycle bit matches its internal consumer cycle
    state for the ring.  The consumer cycle state is toggled an odd amount of
    times in the ring.
    
    An example ring (a ring must have a minimum of 16 TRBs on it, but that's
    too big to draw in ASCII art):
    
                  chain  cycle
                   bit    bit
     ------------------------
    | TD A TRB 1 |  1  |  1  |<-------------  <-- consumer dequeue ptr
     ------------------------               |     consumer cycle state = 1
    | TD A TRB 2 |  1  |  1  |              |
     ------------------------               |
    | TD A TRB 3 |  0  |  1  |  segment 1   |
     ------------------------               |
    | TD B TRB 1 |  1  |  1  |              |
     ------------------------               |
    | TD B TRB 2 |  0  |  1  |              |
     ------------------------               |
    | Link TRB   |  0  |  1  |-----         |
     ------------------------     |         |
                                  |         |
                  chain  cycle    |         |
                   bit    bit     |         |
     ------------------------     |         |
    | TD C TRB 1 |  0  |  1  |<----         |
     ------------------------               |
    | TD D TRB 1 |  1  |  1  |              |
     ------------------------               |
    | TD D TRB 2 |  1  |  1  |   segment 2  |
     ------------------------               |
    | TD D TRB 3 |  1  |  1  |              |
     ------------------------               |
    | TD D TRB 4 |  1  |  1  |              |
     ------------------------               |
    | Link TRB   |  1  |  1  |-----         |
     ------------------------     |         |
                                  |         |
                  chain  cycle    |         |
                   bit    bit     |         |
     ------------------------     |         |
    | TD D TRB 5 |  1  |  1  |<----         |
     ------------------------               |
    | TD D TRB 6 |  0  |  1  |              |
     ------------------------               |
    | TD E TRB 1 |  0  |  1  |   segment 3  |
     ------------------------               |
    |            |  0  |  0  |              | <-- producer enqueue ptr
     ------------------------               |
    |            |  0  |  0  |              |
     ------------------------               |
    | Link TRB   |  0  |  0  |---------------
     ------------------------
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 59fae2e5ea59..ed331310f1a8 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -241,6 +241,18 @@ struct xhci_op_regs {
  */
 #define	DEV_NOTE_FWAKE		ENABLE_DEV_NOTE(1)
 
+/* CRCR - Command Ring Control Register - cmd_ring bitmasks */
+/* bit 0 is the command ring cycle state */
+/* stop ring operation after completion of the currently executing command */
+#define CMD_RING_PAUSE		(1 << 1)
+/* stop ring immediately - abort the currently executing command */
+#define CMD_RING_ABORT		(1 << 2)
+/* true: command ring is running */
+#define CMD_RING_RUNNING	(1 << 3)
+/* bits 4:5 reserved and should be preserved */
+/* Command Ring pointer - bit mask for the lower 32 bits. */
+#define CMD_RING_ADDR_MASK	(0xffffffc0)
+
 /* CONFIG - Configure Register - config_reg bitmasks */
 /* bits 0:7 - maximum number of device slots enabled (NumSlotsEn) */
 #define MAX_DEVS(p)	((p) & 0xff)
@@ -391,6 +403,7 @@ struct intr_reg {
  * a work queue (or delayed service routine)?
  */
 #define ERST_EHB		(1 << 3)
+#define ERST_PTR_MASK		(0xf)
 
 /**
  * struct xhci_run_regs
@@ -407,6 +420,275 @@ struct xhci_run_regs {
 	struct intr_reg	ir_set[128];
 } __attribute__ ((packed));
 
+/**
+ * struct doorbell_array
+ *
+ * Section 5.6
+ */
+struct xhci_doorbell_array {
+	u32	doorbell[256];
+} __attribute__ ((packed));
+
+#define	DB_TARGET_MASK		0xFFFFFF00
+#define	DB_STREAM_ID_MASK	0x0000FFFF
+#define	DB_TARGET_HOST		0x0
+#define	DB_STREAM_ID_HOST	0x0
+#define	DB_MASK			(0xff << 8)
+
+
+struct xhci_transfer_event {
+	/* 64-bit buffer address, or immediate data */
+	u32	buffer[2];
+	u32	transfer_len;
+	/* This field is interpreted differently based on the type of TRB */
+	u32	flags;
+} __attribute__ ((packed));
+
+/* Completion Code - only applicable for some types of TRBs */
+#define	COMP_CODE_MASK		(0xff << 24)
+#define GET_COMP_CODE(p)	(((p) & COMP_CODE_MASK) >> 24)
+#define COMP_SUCCESS	1
+/* Data Buffer Error */
+#define COMP_DB_ERR	2
+/* Babble Detected Error */
+#define COMP_BABBLE	3
+/* USB Transaction Error */
+#define COMP_TX_ERR	4
+/* TRB Error - some TRB field is invalid */
+#define COMP_TRB_ERR	5
+/* Stall Error - USB device is stalled */
+#define COMP_STALL	6
+/* Resource Error - HC doesn't have memory for that device configuration */
+#define COMP_ENOMEM	7
+/* Bandwidth Error - not enough room in schedule for this dev config */
+#define COMP_BW_ERR	8
+/* No Slots Available Error - HC ran out of device slots */
+#define COMP_ENOSLOTS	9
+/* Invalid Stream Type Error */
+#define COMP_STREAM_ERR	10
+/* Slot Not Enabled Error - doorbell rung for disabled device slot */
+#define COMP_EBADSLT	11
+/* Endpoint Not Enabled Error */
+#define COMP_EBADEP	12
+/* Short Packet */
+#define COMP_SHORT_TX	13
+/* Ring Underrun - doorbell rung for an empty isoc OUT ep ring */
+#define COMP_UNDERRUN	14
+/* Ring Overrun - isoc IN ep ring is empty when ep is scheduled to RX */
+#define COMP_OVERRUN	15
+/* Virtual Function Event Ring Full Error */
+#define COMP_VF_FULL	16
+/* Parameter Error - Context parameter is invalid */
+#define COMP_EINVAL	17
+/* Bandwidth Overrun Error - isoc ep exceeded its allocated bandwidth */
+#define COMP_BW_OVER	18
+/* Context State Error - illegal context state transition requested */
+#define COMP_CTX_STATE	19
+/* No Ping Response Error - HC didn't get PING_RESPONSE in time to TX */
+#define COMP_PING_ERR	20
+/* Event Ring is full */
+#define COMP_ER_FULL	21
+/* Missed Service Error - HC couldn't service an isoc ep within interval */
+#define COMP_MISSED_INT	23
+/* Successfully stopped command ring */
+#define COMP_CMD_STOP	24
+/* Successfully aborted current command and stopped command ring */
+#define COMP_CMD_ABORT	25
+/* Stopped - transfer was terminated by a stop endpoint command */
+#define COMP_STOP	26
+/* Same as COMP_EP_STOPPED, but the transfered length in the event is invalid */
+#define COMP_STOP_INVAL	27
+/* Control Abort Error - Debug Capability - control pipe aborted */
+#define COMP_DBG_ABORT	28
+/* TRB type 29 and 30 reserved */
+/* Isoc Buffer Overrun - an isoc IN ep sent more data than could fit in TD */
+#define COMP_BUFF_OVER	31
+/* Event Lost Error - xHC has an "internal event overrun condition" */
+#define COMP_ISSUES	32
+/* Undefined Error - reported when other error codes don't apply */
+#define COMP_UNKNOWN	33
+/* Invalid Stream ID Error */
+#define COMP_STRID_ERR	34
+/* Secondary Bandwidth Error - may be returned by a Configure Endpoint cmd */
+/* FIXME - check for this */
+#define COMP_2ND_BW_ERR	35
+/* Split Transaction Error */
+#define	COMP_SPLIT_ERR	36
+
+struct xhci_link_trb {
+	/* 64-bit segment pointer*/
+	u32 segment_ptr[2];
+	u32 intr_target;
+	u32 control;
+} __attribute__ ((packed));
+
+/* control bitfields */
+#define LINK_TOGGLE	(0x1<<1)
+
+
+union xhci_trb {
+	struct xhci_link_trb		link;
+	struct xhci_transfer_event	trans_event;
+};
+
+/* Normal TRB fields */
+/* transfer_len bitmasks - bits 0:16 */
+#define	TRB_LEN(p)		((p) & 0x1ffff)
+/* TD size - number of bytes remaining in the TD (including this TRB):
+ * bits 17 - 21.  Shift the number of bytes by 10. */
+#define TD_REMAINDER(p)		((((p) >> 10) & 0x1f) << 17)
+/* Interrupter Target - which MSI-X vector to target the completion event at */
+#define TRB_INTR_TARGET(p)	(((p) & 0x3ff) << 22)
+#define GET_INTR_TARGET(p)	(((p) >> 22) & 0x3ff)
+
+/* Cycle bit - indicates TRB ownership by HC or HCD */
+#define TRB_CYCLE		(1<<0)
+/*
+ * Force next event data TRB to be evaluated before task switch.
+ * Used to pass OS data back after a TD completes.
+ */
+#define TRB_ENT			(1<<1)
+/* Interrupt on short packet */
+#define TRB_ISP			(1<<2)
+/* Set PCIe no snoop attribute */
+#define TRB_NO_SNOOP		(1<<3)
+/* Chain multiple TRBs into a TD */
+#define TRB_CHAIN		(1<<4)
+/* Interrupt on completion */
+#define TRB_IOC			(1<<5)
+/* The buffer pointer contains immediate data */
+#define TRB_IDT			(1<<6)
+
+
+/* Control transfer TRB specific fields */
+#define TRB_DIR_IN		(1<<16)
+
+/* TRB bit mask */
+#define	TRB_TYPE_BITMASK	(0xfc00)
+#define TRB_TYPE(p)		((p) << 10)
+/* TRB type IDs */
+/* bulk, interrupt, isoc scatter/gather, and control data stage */
+#define TRB_NORMAL		1
+/* setup stage for control transfers */
+#define TRB_SETUP		2
+/* data stage for control transfers */
+#define TRB_DATA		3
+/* status stage for control transfers */
+#define TRB_STATUS		4
+/* isoc transfers */
+#define TRB_ISOC		5
+/* TRB for linking ring segments */
+#define TRB_LINK		6
+#define TRB_EVENT_DATA		7
+/* Transfer Ring No-op (not for the command ring) */
+#define TRB_TR_NOOP		8
+/* Command TRBs */
+/* Enable Slot Command */
+#define TRB_ENABLE_SLOT		9
+/* Disable Slot Command */
+#define TRB_DISABLE_SLOT	10
+/* Address Device Command */
+#define TRB_ADDR_DEV		11
+/* Configure Endpoint Command */
+#define TRB_CONFIG_EP		12
+/* Evaluate Context Command */
+#define TRB_EVAL_CONTEXT	13
+/* Reset Transfer Ring Command */
+#define TRB_RESET_RING		14
+/* Stop Transfer Ring Command */
+#define TRB_STOP_RING		15
+/* Set Transfer Ring Dequeue Pointer Command */
+#define TRB_SET_DEQ		16
+/* Reset Device Command */
+#define TRB_RESET_DEV		17
+/* Force Event Command (opt) */
+#define TRB_FORCE_EVENT		18
+/* Negotiate Bandwidth Command (opt) */
+#define TRB_NEG_BANDWIDTH	19
+/* Set Latency Tolerance Value Command (opt) */
+#define TRB_SET_LT		20
+/* Get port bandwidth Command */
+#define TRB_GET_BW		21
+/* Force Header Command - generate a transaction or link management packet */
+#define TRB_FORCE_HEADER	22
+/* No-op Command - not for transfer rings */
+#define TRB_CMD_NOOP		23
+/* TRB IDs 24-31 reserved */
+/* Event TRBS */
+/* Transfer Event */
+#define TRB_TRANSFER		32
+/* Command Completion Event */
+#define TRB_COMPLETION		33
+/* Port Status Change Event */
+#define TRB_PORT_STATUS		34
+/* Bandwidth Request Event (opt) */
+#define TRB_BANDWIDTH_EVENT	35
+/* Doorbell Event (opt) */
+#define TRB_DOORBELL		36
+/* Host Controller Event */
+#define TRB_HC_EVENT		37
+/* Device Notification Event - device sent function wake notification */
+#define TRB_DEV_NOTE		38
+/* MFINDEX Wrap Event - microframe counter wrapped */
+#define TRB_MFINDEX_WRAP	39
+/* TRB IDs 40-47 reserved, 48-63 is vendor-defined */
+
+/*
+ * TRBS_PER_SEGMENT must be a multiple of 4,
+ * since the command ring is 64-byte aligned.
+ * It must also be greater than 16.
+ */
+#define TRBS_PER_SEGMENT	64
+#define SEGMENT_SIZE		(TRBS_PER_SEGMENT*16)
+
+struct xhci_segment {
+	union xhci_trb		*trbs;
+	/* private to HCD */
+	struct xhci_segment	*next;
+	dma_addr_t		dma;
+} __attribute__ ((packed));
+
+struct xhci_ring {
+	struct xhci_segment	*first_seg;
+	union  xhci_trb		*enqueue;
+	union  xhci_trb		*dequeue;
+	/*
+	 * Write the cycle state into the TRB cycle field to give ownership of
+	 * the TRB to the host controller (if we are the producer), or to check
+	 * if we own the TRB (if we are the consumer).  See section 4.9.1.
+	 */
+	u32			cycle_state;
+};
+
+struct xhci_erst_entry {
+	/* 64-bit event ring segment address */
+	u32	seg_addr[2];
+	u32	seg_size;
+	/* Set to zero */
+	u32	rsvd;
+} __attribute__ ((packed));
+
+struct xhci_erst {
+	struct xhci_erst_entry	*entries;
+	unsigned int		num_entries;
+	/* xhci->event_ring keeps track of segment dma addresses */
+	dma_addr_t		erst_dma_addr;
+	/* Num entries the ERST can contain */
+	unsigned int		erst_size;
+};
+
+/*
+ * Each segment table entry is 4*32bits long.  1K seems like an ok size:
+ * (1K bytes * 8bytes/bit) / (4*32 bits) = 64 segment entries in the table,
+ * meaning 64 ring segments.
+ * Initial allocated size of the ERST, in number of entries */
+#define	ERST_NUM_SEGS	1
+/* Initial allocated size of the ERST, in number of entries */
+#define	ERST_SIZE	64
+/* Initial number of event segment rings allocated */
+#define	ERST_ENTRIES	1
+/* XXX: Make these module parameters */
+
 
 /* There is one ehci_hci structure per controller */
 struct xhci_hcd {
@@ -414,6 +696,7 @@ struct xhci_hcd {
 	struct xhci_cap_regs __iomem *cap_regs;
 	struct xhci_op_regs __iomem *op_regs;
 	struct xhci_run_regs __iomem *run_regs;
+	struct xhci_doorbell_array __iomem *dba;
 	/* Our HCD's current interrupter register set */
 	struct	intr_reg __iomem *ir_set;
 
@@ -441,6 +724,14 @@ struct xhci_hcd {
 	/* only one MSI vector for now, but might need more later */
 	int		msix_count;
 	struct msix_entry	*msix_entries;
+	/* data structures */
+	struct xhci_ring	*cmd_ring;
+	struct xhci_ring	*event_ring;
+	struct xhci_erst	erst;
+
+	/* DMA pools */
+	struct dma_pool	*device_pool;
+	struct dma_pool	*segment_pool;
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -488,6 +779,11 @@ static inline void xhci_writel(const struct xhci_hcd *xhci,
 /* xHCI debugging */
 void xhci_print_ir_set(struct xhci_hcd *xhci, struct intr_reg *ir_set, int set_num);
 void xhci_print_registers(struct xhci_hcd *xhci);
+void xhci_dbg_regs(struct xhci_hcd *xhci);
+void xhci_print_run_regs(struct xhci_hcd *xhci);
+void xhci_debug_ring(struct xhci_hcd *xhci, struct xhci_ring *ring);
+void xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
+void xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci);
 
 /* xHCI memory managment */
 void xhci_mem_cleanup(struct xhci_hcd *xhci);

commit 66d4eadd8d067269ea8fead1a50fe87c2979a80d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:52:28 2009 -0700

    USB: xhci: BIOS handoff and HW initialization.
    
    Add PCI initialization code to take control of the xHCI host controller
    away from the BIOS, halt, and reset the host controller.  The xHCI spec
    says that BIOSes must give up the host controller within 5 seconds.
    
    Add some host controller glue functions to handle hardware initialization
    and memory allocation for the host controller.  The current xHCI
    prototypes use PCI interrupts, but the xHCI spec requires MSI-X
    interrupts.  Add code to support MSI-X interrupts, but use the PCI
    interrupts for now.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index a4d44aad0697..59fae2e5ea59 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -32,6 +32,9 @@
 /* xHCI PCI Configuration Registers */
 #define XHCI_SBRN_OFFSET	(0x60)
 
+/* Max number of USB devices for any host controller - limit in section 6.1 */
+#define MAX_HC_SLOTS		256
+
 /*
  * xHCI register interface.
  * This corresponds to the eXtensible Host Controller Interface (xHCI)
@@ -359,10 +362,35 @@ struct intr_reg {
 	u32	erst_dequeue[2];
 } __attribute__ ((packed));
 
+/* irq_pending bitmasks */
 #define	ER_IRQ_PENDING(p)	((p) & 0x1)
-#define	ER_IRQ_ENABLE(p)	((p) | 0x2)
+/* bits 2:31 need to be preserved */
+#define	ER_IRQ_CLEAR(p)		((p) & 0xfffffffe)
+#define	ER_IRQ_ENABLE(p)	((ER_IRQ_CLEAR(p)) | 0x2)
+#define	ER_IRQ_DISABLE(p)	((ER_IRQ_CLEAR(p)) & ~(0x2))
+
+/* irq_control bitmasks */
+/* Minimum interval between interrupts (in 250ns intervals).  The interval
+ * between interrupts will be longer if there are no events on the event ring.
+ * Default is 4000 (1 ms).
+ */
+#define ER_IRQ_INTERVAL_MASK	(0xffff)
+/* Counter used to count down the time to the next interrupt - HW use only */
+#define ER_IRQ_COUNTER_MASK	(0xffff << 16)
+
+/* erst_size bitmasks */
 /* Preserve bits 16:31 of erst_size */
-#define	ERST_SIZE_MASK	(0xffff<<16)
+#define	ERST_SIZE_MASK		(0xffff << 16)
+
+/* erst_dequeue bitmasks */
+/* Dequeue ERST Segment Index (DESI) - Segment number (or alias)
+ * where the current dequeue pointer lies.  This is an optional HW hint.
+ */
+#define ERST_DESI_MASK		(0x7)
+/* Event Handler Busy (EHB) - is the event ring scheduled to be serviced by
+ * a work queue (or delayed service routine)?
+ */
+#define ERST_EHB		(1 << 3)
 
 /**
  * struct xhci_run_regs
@@ -386,6 +414,8 @@ struct xhci_hcd {
 	struct xhci_cap_regs __iomem *cap_regs;
 	struct xhci_op_regs __iomem *op_regs;
 	struct xhci_run_regs __iomem *run_regs;
+	/* Our HCD's current interrupter register set */
+	struct	intr_reg __iomem *ir_set;
 
 	/* Cached register copies of read-only HC data */
 	__u32		hcs_params1;
@@ -404,7 +434,13 @@ struct xhci_hcd {
 	u8		isoc_threshold;
 	int		event_ring_max;
 	int		addr_64;
+	/* 4KB min, 128MB max */
 	int		page_size;
+	/* Valid values are 12 to 20, inclusive */
+	int		page_shift;
+	/* only one MSI vector for now, but might need more later */
+	int		msix_count;
+	struct msix_entry	*msix_entries;
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -449,4 +485,27 @@ static inline void xhci_writel(const struct xhci_hcd *xhci,
 	writel(val, regs);
 }
 
+/* xHCI debugging */
+void xhci_print_ir_set(struct xhci_hcd *xhci, struct intr_reg *ir_set, int set_num);
+void xhci_print_registers(struct xhci_hcd *xhci);
+
+/* xHCI memory managment */
+void xhci_mem_cleanup(struct xhci_hcd *xhci);
+int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);
+
+#ifdef CONFIG_PCI
+/* xHCI PCI glue */
+int xhci_register_pci(void);
+void xhci_unregister_pci(void);
+#endif
+
+/* xHCI host controller glue */
+int xhci_halt(struct xhci_hcd *xhci);
+int xhci_reset(struct xhci_hcd *xhci);
+int xhci_init(struct usb_hcd *hcd);
+int xhci_run(struct usb_hcd *hcd);
+void xhci_stop(struct usb_hcd *hcd);
+void xhci_shutdown(struct usb_hcd *hcd);
+int xhci_get_frame(struct usb_hcd *hcd);
+
 #endif /* __LINUX_XHCI_HCD_H */

commit 74c6874199af98e602bb7c5fb1beb9cffda98729
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:52:22 2009 -0700

    USB: xhci: Support xHCI host controllers and USB 3.0 devices.
    
    This is the first of many patches to add support for USB 3.0 devices and
    the hardware that implements the eXtensible Host Controller Interface
    (xHCI) 0.95 specification.  This specification is not yet publicly
    available, but companies can receive a copy by becoming an xHCI
    Contributor (see http://www.intel.com/technology/usb/xhcispec.htm).
    
    No xHCI hardware has made it onto the market yet, but these patches have
    been tested under the Fresco Logic host controller prototype.
    
    This patch adds the xHCI register sets, which are grouped into five sets:
     - Generic PCI registers
     - Host controller "capabilities" registers (cap_regs) short
     - Host controller "operational" registers (op_regs)
     - Host controller "runtime" registers (run_regs)
     - Host controller "doorbell" registers
    
    These some of these registers may be virtualized if the Linux driver is
    running under a VM.  Virtualization has not been tested for this patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
new file mode 100644
index 000000000000..a4d44aad0697
--- /dev/null
+++ b/drivers/usb/host/xhci.h
@@ -0,0 +1,452 @@
+/*
+ * xHCI host controller driver
+ *
+ * Copyright (C) 2008 Intel Corp.
+ *
+ * Author: Sarah Sharp
+ * Some code borrowed from the Linux EHCI driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_XHCI_HCD_H
+#define __LINUX_XHCI_HCD_H
+
+#include <linux/usb.h>
+
+#include "../core/hcd.h"
+/* Code sharing between pci-quirks and xhci hcd */
+#include	"xhci-ext-caps.h"
+
+/* xHCI PCI Configuration Registers */
+#define XHCI_SBRN_OFFSET	(0x60)
+
+/*
+ * xHCI register interface.
+ * This corresponds to the eXtensible Host Controller Interface (xHCI)
+ * Revision 0.95 specification
+ *
+ * Registers should always be accessed with double word or quad word accesses.
+ *
+ * Some xHCI implementations may support 64-bit address pointers.  Registers
+ * with 64-bit address pointers should be written to with dword accesses by
+ * writing the low dword first (ptr[0]), then the high dword (ptr[1]) second.
+ * xHCI implementations that do not support 64-bit address pointers will ignore
+ * the high dword, and write order is irrelevant.
+ */
+
+/**
+ * struct xhci_cap_regs - xHCI Host Controller Capability Registers.
+ * @hc_capbase:		length of the capabilities register and HC version number
+ * @hcs_params1:	HCSPARAMS1 - Structural Parameters 1
+ * @hcs_params2:	HCSPARAMS2 - Structural Parameters 2
+ * @hcs_params3:	HCSPARAMS3 - Structural Parameters 3
+ * @hcc_params:		HCCPARAMS - Capability Parameters
+ * @db_off:		DBOFF - Doorbell array offset
+ * @run_regs_off:	RTSOFF - Runtime register space offset
+ */
+struct xhci_cap_regs {
+	u32	hc_capbase;
+	u32	hcs_params1;
+	u32	hcs_params2;
+	u32	hcs_params3;
+	u32	hcc_params;
+	u32	db_off;
+	u32	run_regs_off;
+	/* Reserved up to (CAPLENGTH - 0x1C) */
+} __attribute__ ((packed));
+
+/* hc_capbase bitmasks */
+/* bits 7:0 - how long is the Capabilities register */
+#define HC_LENGTH(p)		XHCI_HC_LENGTH(p)
+/* bits 31:16	*/
+#define HC_VERSION(p)		(((p) >> 16) & 0xffff)
+
+/* HCSPARAMS1 - hcs_params1 - bitmasks */
+/* bits 0:7, Max Device Slots */
+#define HCS_MAX_SLOTS(p)	(((p) >> 0) & 0xff)
+#define HCS_SLOTS_MASK		0xff
+/* bits 8:18, Max Interrupters */
+#define HCS_MAX_INTRS(p)	(((p) >> 8) & 0x7ff)
+/* bits 24:31, Max Ports - max value is 0x7F = 127 ports */
+#define HCS_MAX_PORTS(p)	(((p) >> 24) & 0x7f)
+
+/* HCSPARAMS2 - hcs_params2 - bitmasks */
+/* bits 0:3, frames or uframes that SW needs to queue transactions
+ * ahead of the HW to meet periodic deadlines */
+#define HCS_IST(p)		(((p) >> 0) & 0xf)
+/* bits 4:7, max number of Event Ring segments */
+#define HCS_ERST_MAX(p)		(((p) >> 4) & 0xf)
+/* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
+/* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */
+
+/* HCSPARAMS3 - hcs_params3 - bitmasks */
+/* bits 0:7, Max U1 to U0 latency for the roothub ports */
+#define HCS_U1_LATENCY(p)	(((p) >> 0) & 0xff)
+/* bits 16:31, Max U2 to U0 latency for the roothub ports */
+#define HCS_U2_LATENCY(p)	(((p) >> 16) & 0xffff)
+
+/* HCCPARAMS - hcc_params - bitmasks */
+/* true: HC can use 64-bit address pointers */
+#define HCC_64BIT_ADDR(p)	((p) & (1 << 0))
+/* true: HC can do bandwidth negotiation */
+#define HCC_BANDWIDTH_NEG(p)	((p) & (1 << 1))
+/* true: HC uses 64-byte Device Context structures
+ * FIXME 64-byte context structures aren't supported yet.
+ */
+#define HCC_64BYTE_CONTEXT(p)	((p) & (1 << 2))
+/* true: HC has port power switches */
+#define HCC_PPC(p)		((p) & (1 << 3))
+/* true: HC has port indicators */
+#define HCS_INDICATOR(p)	((p) & (1 << 4))
+/* true: HC has Light HC Reset Capability */
+#define HCC_LIGHT_RESET(p)	((p) & (1 << 5))
+/* true: HC supports latency tolerance messaging */
+#define HCC_LTC(p)		((p) & (1 << 6))
+/* true: no secondary Stream ID Support */
+#define HCC_NSS(p)		((p) & (1 << 7))
+/* Max size for Primary Stream Arrays - 2^(n+1), where n is bits 12:15 */
+#define HCC_MAX_PSA		(1 << ((((p) >> 12) & 0xf) + 1))
+/* Extended Capabilities pointer from PCI base - section 5.3.6 */
+#define HCC_EXT_CAPS(p)		XHCI_HCC_EXT_CAPS(p)
+
+/* db_off bitmask - bits 0:1 reserved */
+#define	DBOFF_MASK	(~0x3)
+
+/* run_regs_off bitmask - bits 0:4 reserved */
+#define	RTSOFF_MASK	(~0x1f)
+
+
+/* Number of registers per port */
+#define	NUM_PORT_REGS	4
+
+/**
+ * struct xhci_op_regs - xHCI Host Controller Operational Registers.
+ * @command:		USBCMD - xHC command register
+ * @status:		USBSTS - xHC status register
+ * @page_size:		This indicates the page size that the host controller
+ * 			supports.  If bit n is set, the HC supports a page size
+ * 			of 2^(n+12), up to a 128MB page size.
+ * 			4K is the minimum page size.
+ * @cmd_ring:		CRP - 64-bit Command Ring Pointer
+ * @dcbaa_ptr:		DCBAAP - 64-bit Device Context Base Address Array Pointer
+ * @config_reg:		CONFIG - Configure Register
+ * @port_status_base:	PORTSCn - base address for Port Status and Control
+ * 			Each port has a Port Status and Control register,
+ * 			followed by a Port Power Management Status and Control
+ * 			register, a Port Link Info register, and a reserved
+ * 			register.
+ * @port_power_base:	PORTPMSCn - base address for
+ * 			Port Power Management Status and Control
+ * @port_link_base:	PORTLIn - base address for Port Link Info (current
+ * 			Link PM state and control) for USB 2.1 and USB 3.0
+ * 			devices.
+ */
+struct xhci_op_regs {
+	u32	command;
+	u32	status;
+	u32	page_size;
+	u32	reserved1;
+	u32	reserved2;
+	u32	dev_notification;
+	u32	cmd_ring[2];
+	/* rsvd: offset 0x20-2F */
+	u32	reserved3[4];
+	u32	dcbaa_ptr[2];
+	u32	config_reg;
+	/* rsvd: offset 0x3C-3FF */
+	u32	reserved4[241];
+	/* port 1 registers, which serve as a base address for other ports */
+	u32	port_status_base;
+	u32	port_power_base;
+	u32	port_link_base;
+	u32	reserved5;
+	/* registers for ports 2-255 */
+	u32	reserved6[NUM_PORT_REGS*254];
+} __attribute__ ((packed));
+
+/* USBCMD - USB command - command bitmasks */
+/* start/stop HC execution - do not write unless HC is halted*/
+#define CMD_RUN		XHCI_CMD_RUN
+/* Reset HC - resets internal HC state machine and all registers (except
+ * PCI config regs).  HC does NOT drive a USB reset on the downstream ports.
+ * The xHCI driver must reinitialize the xHC after setting this bit.
+ */
+#define CMD_RESET	(1 << 1)
+/* Event Interrupt Enable - a '1' allows interrupts from the host controller */
+#define CMD_EIE		XHCI_CMD_EIE
+/* Host System Error Interrupt Enable - get out-of-band signal for HC errors */
+#define CMD_HSEIE	XHCI_CMD_HSEIE
+/* bits 4:6 are reserved (and should be preserved on writes). */
+/* light reset (port status stays unchanged) - reset completed when this is 0 */
+#define CMD_LRESET	(1 << 7)
+/* FIXME: ignoring host controller save/restore state for now. */
+#define CMD_CSS		(1 << 8)
+#define CMD_CRS		(1 << 9)
+/* Enable Wrap Event - '1' means xHC generates an event when MFINDEX wraps. */
+#define CMD_EWE		XHCI_CMD_EWE
+/* MFINDEX power management - '1' means xHC can stop MFINDEX counter if all root
+ * hubs are in U3 (selective suspend), disconnect, disabled, or powered-off.
+ * '0' means the xHC can power it off if all ports are in the disconnect,
+ * disabled, or powered-off state.
+ */
+#define CMD_PM_INDEX	(1 << 11)
+/* bits 12:31 are reserved (and should be preserved on writes). */
+
+/* USBSTS - USB status - status bitmasks */
+/* HC not running - set to 1 when run/stop bit is cleared. */
+#define STS_HALT	XHCI_STS_HALT
+/* serious error, e.g. PCI parity error.  The HC will clear the run/stop bit. */
+#define STS_FATAL	(1 << 2)
+/* event interrupt - clear this prior to clearing any IP flags in IR set*/
+#define STS_EINT	(1 << 3)
+/* port change detect */
+#define STS_PORT	(1 << 4)
+/* bits 5:7 reserved and zeroed */
+/* save state status - '1' means xHC is saving state */
+#define STS_SAVE	(1 << 8)
+/* restore state status - '1' means xHC is restoring state */
+#define STS_RESTORE	(1 << 9)
+/* true: save or restore error */
+#define STS_SRE		(1 << 10)
+/* true: Controller Not Ready to accept doorbell or op reg writes after reset */
+#define STS_CNR		XHCI_STS_CNR
+/* true: internal Host Controller Error - SW needs to reset and reinitialize */
+#define STS_HCE		(1 << 12)
+/* bits 13:31 reserved and should be preserved */
+
+/*
+ * DNCTRL - Device Notification Control Register - dev_notification bitmasks
+ * Generate a device notification event when the HC sees a transaction with a
+ * notification type that matches a bit set in this bit field.
+ */
+#define	DEV_NOTE_MASK		(0xffff)
+#define ENABLE_DEV_NOTE(x)	(1 << x)
+/* Most of the device notification types should only be used for debug.
+ * SW does need to pay attention to function wake notifications.
+ */
+#define	DEV_NOTE_FWAKE		ENABLE_DEV_NOTE(1)
+
+/* CONFIG - Configure Register - config_reg bitmasks */
+/* bits 0:7 - maximum number of device slots enabled (NumSlotsEn) */
+#define MAX_DEVS(p)	((p) & 0xff)
+/* bits 8:31 - reserved and should be preserved */
+
+/* PORTSC - Port Status and Control Register - port_status_base bitmasks */
+/* true: device connected */
+#define PORT_CONNECT	(1 << 0)
+/* true: port enabled */
+#define PORT_PE		(1 << 1)
+/* bit 2 reserved and zeroed */
+/* true: port has an over-current condition */
+#define PORT_OC		(1 << 3)
+/* true: port reset signaling asserted */
+#define PORT_RESET	(1 << 4)
+/* Port Link State - bits 5:8
+ * A read gives the current link PM state of the port,
+ * a write with Link State Write Strobe set sets the link state.
+ */
+/* true: port has power (see HCC_PPC) */
+#define PORT_POWER	(1 << 9)
+/* bits 10:13 indicate device speed:
+ * 0 - undefined speed - port hasn't be initialized by a reset yet
+ * 1 - full speed
+ * 2 - low speed
+ * 3 - high speed
+ * 4 - super speed
+ * 5-15 reserved
+ */
+#define DEV_SPEED_MASK		(0xf<<10)
+#define DEV_UNDEFSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x0<<10))
+#define DEV_FULLSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x1<<10))
+#define DEV_LOWSPEED(p)		(((p) & DEV_SPEED_MASK) == (0x2<<10))
+#define DEV_HIGHSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x3<<10))
+#define DEV_SUPERSPEED(p)	(((p) & DEV_SPEED_MASK) == (0x4<<10))
+/* Port Indicator Control */
+#define PORT_LED_OFF	(0 << 14)
+#define PORT_LED_AMBER	(1 << 14)
+#define PORT_LED_GREEN	(2 << 14)
+#define PORT_LED_MASK	(3 << 14)
+/* Port Link State Write Strobe - set this when changing link state */
+#define PORT_LINK_STROBE	(1 << 16)
+/* true: connect status change */
+#define PORT_CSC	(1 << 17)
+/* true: port enable change */
+#define PORT_PEC	(1 << 18)
+/* true: warm reset for a USB 3.0 device is done.  A "hot" reset puts the port
+ * into an enabled state, and the device into the default state.  A "warm" reset
+ * also resets the link, forcing the device through the link training sequence.
+ * SW can also look at the Port Reset register to see when warm reset is done.
+ */
+#define PORT_WRC	(1 << 19)
+/* true: over-current change */
+#define PORT_OCC	(1 << 20)
+/* true: reset change - 1 to 0 transition of PORT_RESET */
+#define PORT_RC		(1 << 21)
+/* port link status change - set on some port link state transitions:
+ *  Transition				Reason
+ *  ------------------------------------------------------------------------------
+ *  - U3 to Resume			Wakeup signaling from a device
+ *  - Resume to Recovery to U0		USB 3.0 device resume
+ *  - Resume to U0			USB 2.0 device resume
+ *  - U3 to Recovery to U0		Software resume of USB 3.0 device complete
+ *  - U3 to U0				Software resume of USB 2.0 device complete
+ *  - U2 to U0				L1 resume of USB 2.1 device complete
+ *  - U0 to U0 (???)			L1 entry rejection by USB 2.1 device
+ *  - U0 to disabled			L1 entry error with USB 2.1 device
+ *  - Any state to inactive		Error on USB 3.0 port
+ */
+#define PORT_PLC	(1 << 22)
+/* port configure error change - port failed to configure its link partner */
+#define PORT_CEC	(1 << 23)
+/* bit 24 reserved */
+/* wake on connect (enable) */
+#define PORT_WKCONN_E	(1 << 25)
+/* wake on disconnect (enable) */
+#define PORT_WKDISC_E	(1 << 26)
+/* wake on over-current (enable) */
+#define PORT_WKOC_E	(1 << 27)
+/* bits 28:29 reserved */
+/* true: device is removable - for USB 3.0 roothub emulation */
+#define PORT_DEV_REMOVE	(1 << 30)
+/* Initiate a warm port reset - complete when PORT_WRC is '1' */
+#define PORT_WR		(1 << 31)
+
+/* Port Power Management Status and Control - port_power_base bitmasks */
+/* Inactivity timer value for transitions into U1, in microseconds.
+ * Timeout can be up to 127us.  0xFF means an infinite timeout.
+ */
+#define PORT_U1_TIMEOUT(p)	((p) & 0xff)
+/* Inactivity timer value for transitions into U2 */
+#define PORT_U2_TIMEOUT(p)	(((p) & 0xff) << 8)
+/* Bits 24:31 for port testing */
+
+
+/**
+ * struct intr_reg - Interrupt Register Set
+ * @irq_pending:	IMAN - Interrupt Management Register.  Used to enable
+ *			interrupts and check for pending interrupts.
+ * @irq_control:	IMOD - Interrupt Moderation Register.
+ * 			Used to throttle interrupts.
+ * @erst_size:		Number of segments in the Event Ring Segment Table (ERST).
+ * @erst_base:		ERST base address.
+ * @erst_dequeue:	Event ring dequeue pointer.
+ *
+ * Each interrupter (defined by a MSI-X vector) has an event ring and an Event
+ * Ring Segment Table (ERST) associated with it.  The event ring is comprised of
+ * multiple segments of the same size.  The HC places events on the ring and
+ * "updates the Cycle bit in the TRBs to indicate to software the current
+ * position of the Enqueue Pointer." The HCD (Linux) processes those events and
+ * updates the dequeue pointer.
+ */
+struct intr_reg {
+	u32	irq_pending;
+	u32	irq_control;
+	u32	erst_size;
+	u32	rsvd;
+	u32	erst_base[2];
+	u32	erst_dequeue[2];
+} __attribute__ ((packed));
+
+#define	ER_IRQ_PENDING(p)	((p) & 0x1)
+#define	ER_IRQ_ENABLE(p)	((p) | 0x2)
+/* Preserve bits 16:31 of erst_size */
+#define	ERST_SIZE_MASK	(0xffff<<16)
+
+/**
+ * struct xhci_run_regs
+ * @microframe_index:
+ * 		MFINDEX - current microframe number
+ *
+ * Section 5.5 Host Controller Runtime Registers:
+ * "Software should read and write these registers using only Dword (32 bit)
+ * or larger accesses"
+ */
+struct xhci_run_regs {
+	u32	microframe_index;
+	u32	rsvd[7];
+	struct intr_reg	ir_set[128];
+} __attribute__ ((packed));
+
+
+/* There is one ehci_hci structure per controller */
+struct xhci_hcd {
+	/* glue to PCI and HCD framework */
+	struct xhci_cap_regs __iomem *cap_regs;
+	struct xhci_op_regs __iomem *op_regs;
+	struct xhci_run_regs __iomem *run_regs;
+
+	/* Cached register copies of read-only HC data */
+	__u32		hcs_params1;
+	__u32		hcs_params2;
+	__u32		hcs_params3;
+	__u32		hcc_params;
+
+	spinlock_t	lock;
+
+	/* packed release number */
+	u8		sbrn;
+	u16		hci_version;
+	u8		max_slots;
+	u8		max_interrupters;
+	u8		max_ports;
+	u8		isoc_threshold;
+	int		event_ring_max;
+	int		addr_64;
+	int		page_size;
+};
+
+/* convert between an HCD pointer and the corresponding EHCI_HCD */
+static inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)
+{
+	return (struct xhci_hcd *) (hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
+{
+	return container_of((void *) xhci, struct usb_hcd, hcd_priv);
+}
+
+#ifdef CONFIG_USB_XHCI_HCD_DEBUGGING
+#define XHCI_DEBUG	1
+#else
+#define XHCI_DEBUG	0
+#endif
+
+#define xhci_dbg(xhci, fmt, args...) \
+	do { if (XHCI_DEBUG) dev_dbg(xhci_to_hcd(xhci)->self.controller , fmt , ## args); } while (0)
+#define xhci_info(xhci, fmt, args...) \
+	do { if (XHCI_DEBUG) dev_info(xhci_to_hcd(xhci)->self.controller , fmt , ## args); } while (0)
+#define xhci_err(xhci, fmt, args...) \
+	dev_err(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
+#define xhci_warn(xhci, fmt, args...) \
+	dev_warn(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
+
+/* TODO: copied from ehci.h - can be refactored? */
+/* xHCI spec says all registers are little endian */
+static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
+		__u32 __iomem *regs)
+{
+	return readl(regs);
+}
+static inline void xhci_writel(const struct xhci_hcd *xhci,
+		const unsigned int val, __u32 __iomem *regs)
+{
+	if (!in_interrupt())
+		xhci_dbg(xhci, "`MEM_WRITE_DWORD(3'b000, 32'h%0x, 32'h%0x, 4'hf);\n",
+				(unsigned int) regs, val);
+	writel(val, regs);
+}
+
+#endif /* __LINUX_XHCI_HCD_H */
