commit 7b81cb6bddd2c4f2489506771070924bd0ae9902
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:32 2019 +0200

    usb: add a HCD_DMA flag instead of guestimating DMA capabilities
    
    The usb core is the only major place in the kernel that checks for
    a non-NULL device dma_mask to see if a device is DMA capable.  This
    is generally a bad idea, as all major busses always set up a DMA mask,
    even if the device is not DMA capable - in fact bus layers like PCI
    can't even know if a device is DMA capable at enumeration time.  This
    leads to lots of workaround in HCD drivers, and also prevented us from
    setting up a DMA mask for platform devices by default last time we
    tried.
    
    Replace this guess with an explicit HCD_DMA that is set by drivers that
    appear to have DMA support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190816062435.881-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 656b8c08efc8..a2c3b4ec8a8b 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -30,7 +30,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2 | HCD_BH,
+	.flags			= HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit d214109875b419c85c596d39b032692133bf58ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:26 2017 +0100

    USB: host: ehci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index a8cffcf13451..656b8c08efc8 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -10,20 +10,6 @@
  * (c) Valentine Barshak <vbarshak@ru.mvista.com>
  * and in turn based on "ehci-ppc-soc.c" by Stefan Roese <sr@denx.de>
  * and "ohci-ppc-of.c" by Sylvain Munaut <tnt@246tNt.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/err.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 21650044b09e..a8cffcf13451 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Driver for Aeroflex Gaisler GRLIB GRUSBHC EHCI host controller
  *

commit 1d97869198a36dfc2920abd5776d91767fbead63
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Sun Dec 21 21:28:24 2014 +0100

    usb: host: drop owner assignment from platform_drivers
    
    These platform_drivers do not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 495b6fbcbcd9..21650044b09e 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -187,7 +187,6 @@ static struct platform_driver ehci_grlib_driver = {
 	.shutdown	= usb_hcd_platform_shutdown,
 	.driver = {
 		.name = "grlib-ehci",
-		.owner = THIS_MODULE,
 		.of_match_table = ehci_hcd_grlib_of_match,
 	},
 };

commit fc32f116cbcb6b37bcf35db6a05562680b597d6b
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 10 21:19:18 2013 +0900

    USB: ehci-grlib: use dev_err() instead of printk()
    
    Use dev_err() instead of printk() to provide a better message
    to userspace.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 054792c56271..495b6fbcbcd9 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -113,7 +113,8 @@ static int ehci_hcd_grlib_probe(struct platform_device *op)
 
 	irq = irq_of_parse_and_map(dn, 0);
 	if (irq == NO_IRQ) {
-		printk(KERN_ERR "%s: irq_of_parse_and_map failed\n", __FILE__);
+		dev_err(&op->dev, "%s: irq_of_parse_and_map failed\n",
+			__FILE__);
 		rv = -EBUSY;
 		goto err_irq;
 	}

commit 3c9740a117d40a74412775b5d3fe2b88a7635a0e
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Nov 5 10:46:02 2013 +0800

    usb: hcd: move controller wakeup setting initialization to individual driver
    
    Individual controller driver has different requirement for wakeup
    setting, so move it from core to itself. In order to align with
    current etting the default wakeup setting is enabled (except for
    chipidea host).
    
    Pass compile test with below commands:
            make O=outout/all allmodconfig
            make -j$CPU_NUM O=outout/all drivers/usb
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index b52a66ce92e8..054792c56271 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -140,6 +140,7 @@ static int ehci_hcd_grlib_probe(struct platform_device *op)
 	if (rv)
 		goto err_ioremap;
 
+	device_wakeup_enable(hcd->self.controller);
 	return 0;
 
 err_ioremap:

commit c04ee4b1136e462722567cf6e76bb35a181574a7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 23 13:32:51 2013 -0700

    Revert "Revert "USB: EHCI: support running URB giveback in tasklet context""
    
    This reverts commit 3b8d7321ed4b8511e17048303b806ffcc2806077, which
    brings back commit 428aac8a81058e2303677a8fbf26670229e51d3a as it should
    be working for the 3.13-rc1 merge window now that Alan's other fixes are
    here in the tree already.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 83ab51af250f..b52a66ce92e8 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -43,7 +43,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
+	.flags			= HCD_MEMORY | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit 3b8d7321ed4b8511e17048303b806ffcc2806077
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Sep 12 13:58:42 2013 -0700

    Revert "USB: EHCI: support running URB giveback in tasklet context"
    
    This reverts commit 428aac8a81058e2303677a8fbf26670229e51d3a.
    
    This isn't quite ready for 3.12, we need some more EHCI driver changes
    that are just now showing up.  So revert this for now, and queue it up
    later for 3.13.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index b52a66ce92e8..83ab51af250f 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -43,7 +43,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2 | HCD_BH,
+	.flags			= HCD_MEMORY | HCD_USB2,
 
 	/*
 	 * basic lifecycle operations

commit 428aac8a81058e2303677a8fbf26670229e51d3a
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:11 2013 +0800

    USB: EHCI: support running URB giveback in tasklet context
    
    All 4 transfer types can work well on EHCI HCD after switching to run
    URB giveback in tasklet context, so mark all HCD drivers to support
    it.
    
    Also we don't need to release ehci->lock during URB giveback any more.
    
    >From below test results on 3 machines(2 ARM and one x86), time
    consumed by EHCI interrupt handler droped much without performance
    loss.
    
    1 test description
    1.1 mass storage performance test:
    - run below command 10 times and compute the average performance
    
        dd if=/dev/sdN iflag=direct of=/dev/null bs=200M count=1
    
    - two usb mass storage device:
    A: sandisk extreme USB 3.0 16G(used in test case 1 & case 2)
    B: kingston DataTraveler G2 4GB(only used in test case 2)
    
    1.2 uvc function test:
    - run one simple capture program in the below link
    
       http://kernel.ubuntu.com/~ming/up/capture.c
    
    - capture format 640*480 and results in High Bandwidth mode on the
    uvc device: Z-Star 0x0ac8/0x3450
    
    - on T410(x86) laptop, also use guvcview to watch video capture/playback
    
    1.3 about test2 and test4
    - both two devices involved are tested concurrently by above test items
    
    1.4 how to compute irq time(the time consumed by ehci_irq)
    - use trace points of irq:irq_handler_entry and irq:irq_handler_exit
    
    1.5 kernel
    3.10.0-rc3-next-20130528
    
    1.6 test machines
    Pandaboard A1: ARM CortexA9 dural core
    Arndale board: ARM CortexA15 dural core
    T410: i5 CPU 2.67GHz quad core
    
    2 test result
    2.1 test case1: single mass storage device performance test
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  25.280(avg:145,max:772) | 25.540(avg:14, max:75)
    Arndale board:  29.700(avg:33, max:129) | 29.700(avg:10,  max:50)
    T410:           34.430(avg:17, max:154*)| 34.660(avg:12, max:155)
    ---------------------------------------------------------------------
    
    2.2 test case2: two mass storage devices' performance test
    --------------------------------------------------------------------
                    upstream                        | patched
                    perf(MB/s)+irq time(us)         | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  15.840/15.580(avg:158,max:1216) | 16.500/16.160(avg:15,max:139)
    Arndale board:  17.370/16.220(avg:33 max:234)   | 17.480/16.200(avg:11, max:91)
    T410:           21.180/19.820(avg:18 max:160)   | 21.220/19.880(avg:11, max:149)
    ---------------------------------------------------------------------
    
    2.3 test case3: one uvc streaming test
    - uvc device works well(on x86, luvcview can be used too and has
    same result with uvc capture)
    --------------------------------------------------------------------
                    upstream                | patched
                    irq time(us)            | irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  (avg:445, max:873)      | (avg:33, max:44)
    Arndale board:  (avg:316, max:630)      | (avg:20, max:27)
    T410:           (avg:39,  max:107)      | (avg:10, max:65)
    ---------------------------------------------------------------------
    
    2.4 test case4: one uvc streaming plus one mass storage device test
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  20.340(avg:259,max:1704)| 20.390(avg:24, max:101)
    Arndale board:  23.460(avg:124,max:726) | 23.370(avg:15, max:52)
    T410:           28.520(avg:27, max:169) | 28.630(avg:13, max:160)
    ---------------------------------------------------------------------
    
    2.5 test case5: read single mass storage device with small transfer
    - run below command 10 times and compute the average speed
    
     dd if=/dev/sdN iflag=direct of=/dev/null bs=4K count=4000
    
    1), test device A:
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  6.5(avg:21, max:64)     | 6.5(avg:10, max:24)
    Arndale board:  8.13(avg:12, max:23)    | 8.06(avg:7,  max:17)
    T410:           6.66(avg:13, max:131)   | 6.84(avg:11, max:149)
    ---------------------------------------------------------------------
    
    2), test device B:
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  5.5(avg:21,max:43)      | 5.49(avg:10, max:24)
    Arndale board:  5.9(avg:12, max:22)     | 5.9(avg:7, max:17)
    T410:           5.48(avg:13, max:155)   | 5.48(avg:7, max:140)
    ---------------------------------------------------------------------
    
    * On T410, sometimes read ehci status register in ehci_irq takes more
    than 100us, and the problem has been reported on the link:
    
            http://marc.info/?t=137065867300001&r=1&w=2
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 83ab51af250f..b52a66ce92e8 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -43,7 +43,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
+	.flags			= HCD_MEMORY | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit aaf6b52d50f85ed792c9c8987f5169f3dce2adea
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon Jul 22 15:04:50 2013 +0300

    USB: host: Use usb_hcd_platform_shutdown() wherever possible
    
    Most HCD drivers are doing the same thing in their ".shutdown" callback
    so it makes sense to use the generic usb_hcd_platform_shutdown()
    handler there.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index a77bd8dc33f4..83ab51af250f 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -167,15 +167,6 @@ static int ehci_hcd_grlib_remove(struct platform_device *op)
 }
 
 
-static void ehci_hcd_grlib_shutdown(struct platform_device *op)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(op);
-
-	if (hcd->driver->shutdown)
-		hcd->driver->shutdown(hcd);
-}
-
-
 static const struct of_device_id ehci_hcd_grlib_of_match[] = {
 	{
 		.name = "GAISLER_EHCI",
@@ -191,7 +182,7 @@ MODULE_DEVICE_TABLE(of, ehci_hcd_grlib_of_match);
 static struct platform_driver ehci_grlib_driver = {
 	.probe		= ehci_hcd_grlib_probe,
 	.remove		= ehci_hcd_grlib_remove,
-	.shutdown	= ehci_hcd_grlib_shutdown,
+	.shutdown	= usb_hcd_platform_shutdown,
 	.driver = {
 		.name = "grlib-ehci",
 		.owner = THIS_MODULE,

commit 477527baf6a8d4c8652f979f0aa3546216635184
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 23 19:18:39 2013 +0900

    USB: host: use platform_{get,set}_drvdata()
    
    Use the wrapper functions for getting and setting the driver data using
    platform_device instead of using dev_{get,set}_drvdata() with &pdev->dev,
    so we can directly pass a struct platform_device.
    
    Also, unnecessary dev_set_drvdata() is removed, because the driver core
    clears the driver data to NULL after device_release or on probe failure.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 5d75de9729b6..a77bd8dc33f4 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -153,9 +153,7 @@ static int ehci_hcd_grlib_probe(struct platform_device *op)
 
 static int ehci_hcd_grlib_remove(struct platform_device *op)
 {
-	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
-
-	dev_set_drvdata(&op->dev, NULL);
+	struct usb_hcd *hcd = platform_get_drvdata(op);
 
 	dev_dbg(&op->dev, "stopping GRLIB GRUSBHC EHCI USB Controller\n");
 
@@ -171,7 +169,7 @@ static int ehci_hcd_grlib_remove(struct platform_device *op)
 
 static void ehci_hcd_grlib_shutdown(struct platform_device *op)
 {
-	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+	struct usb_hcd *hcd = platform_get_drvdata(op);
 
 	if (hcd->driver->shutdown)
 		hcd->driver->shutdown(hcd);

commit 148e11349b0c9c7199fd3096254bd3ea16d59a05
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:22 2013 +0100

    usb: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 1fc89292f5d6..5d75de9729b6 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -25,7 +25,7 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-
+#include <linux/err.h>
 #include <linux/signal.h>
 
 #include <linux/of_irq.h>
@@ -118,10 +118,9 @@ static int ehci_hcd_grlib_probe(struct platform_device *op)
 		goto err_irq;
 	}
 
-	hcd->regs = devm_request_and_ioremap(&op->dev, &res);
-	if (!hcd->regs) {
-		pr_err("%s: devm_request_and_ioremap failed\n", __FILE__);
-		rv = -ENOMEM;
+	hcd->regs = devm_ioremap_resource(&op->dev, &res);
+	if (IS_ERR(hcd->regs)) {
+		rv = PTR_ERR(hcd->regs);
 		goto err_ioremap;
 	}
 

commit 41ac7b3ab7fe1d6175839947a877fdf95cbd2211
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:48 2012 -0500

    usb: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Olav Kongas <ok@artecdesign.ee>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index da4269550fba..1fc89292f5d6 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -82,7 +82,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 };
 
 
-static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
+static int ehci_hcd_grlib_probe(struct platform_device *op)
 {
 	struct device_node *dn = op->dev.of_node;
 	struct usb_hcd *hcd;

commit c73cee717e7d5da0698acb720ad1219646fe4f46
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:21:06 2012 -0400

    USB: EHCI: remove ehci_port_power() routine
    
    This patch (as1623) removes the ehci_port_power() routine and all the
    places that call it.  There's no reason for ehci-hcd to change the
    port power settings; the hub driver takes care of all that stuff.
    
    There is one exception: When the controller is resumed from
    hibernation or following a loss of power, the ports that are supposed
    to be handed over to a companion controller must be powered on first.
    Otherwise the handover won't work.  This process is not visible to the
    hub driver, so it has to be handled in ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 3180cb3624d9..da4269550fba 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -34,22 +34,6 @@
 
 #define GRUSBHC_HCIVERSION 0x0100 /* Known value of cap. reg. HCIVERSION */
 
-/* called during probe() after chip reset completes */
-static int ehci_grlib_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	int		retval;
-
-	retval = ehci_setup(hcd);
-	if (retval)
-		return retval;
-
-	ehci_port_power(ehci, 1);
-
-	return retval;
-}
-
-
 static const struct hc_driver ehci_grlib_hc_driver = {
 	.description		= hcd_name,
 	.product_desc		= "GRLIB GRUSBHC EHCI",
@@ -64,7 +48,7 @@ static const struct hc_driver ehci_grlib_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_grlib_setup,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,

commit 436f271996a1925e506d5004dcbf62bce24e5777
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Jul 29 21:46:08 2012 +0200

    drivers/usb/host/ehci-grlib.c: use devm_ functions
    
    The various devm_ functions allocate memory that is released when a driver
    detaches.  This patch uses these functions for data that is allocated in
    the probe function of a platform device and is only freed in the remove
    function.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 22ca45c079a4..3180cb3624d9 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -127,12 +127,6 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 	hcd->rsrc_start = res.start;
 	hcd->rsrc_len = resource_size(&res);
 
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		printk(KERN_ERR "%s: request_mem_region failed\n", __FILE__);
-		rv = -EBUSY;
-		goto err_rmr;
-	}
-
 	irq = irq_of_parse_and_map(dn, 0);
 	if (irq == NO_IRQ) {
 		printk(KERN_ERR "%s: irq_of_parse_and_map failed\n", __FILE__);
@@ -140,9 +134,9 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 		goto err_irq;
 	}
 
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	hcd->regs = devm_request_and_ioremap(&op->dev, &res);
 	if (!hcd->regs) {
-		printk(KERN_ERR "%s: ioremap failed\n", __FILE__);
+		pr_err("%s: devm_request_and_ioremap failed\n", __FILE__);
 		rv = -ENOMEM;
 		goto err_ioremap;
 	}
@@ -161,17 +155,13 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 
 	rv = usb_add_hcd(hcd, irq, 0);
 	if (rv)
-		goto err_ehci;
+		goto err_ioremap;
 
 	return 0;
 
-err_ehci:
-	iounmap(hcd->regs);
 err_ioremap:
 	irq_dispose_mapping(irq);
 err_irq:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err_rmr:
 	usb_put_hcd(hcd);
 
 	return rv;
@@ -188,9 +178,7 @@ static int ehci_hcd_grlib_remove(struct platform_device *op)
 
 	usb_remove_hcd(hcd);
 
-	iounmap(hcd->regs);
 	irq_dispose_mapping(hcd->irq);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 
 	usb_put_hcd(hcd);
 

commit 1a49e2ac9651df7349867a5cf44e2c83de1046af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 9 15:55:14 2012 -0400

    EHCI: centralize controller initialization
    
    This patch (as1564c) converts the EHCI platform drivers to use the
    central ehci_setup() routine for generic controller initialization
    rather than each having its own idiosyncratic approach.
    
    The major point of difficulty lies in ehci-pci's many vendor- and
    device-specific workarounds.  Some of them have to be applied before
    calling ehci_setup() and some after, which necessitates a fair amount
    of code motion.  The other platform drivers require much smaller
    changes.
    
    One point not addressed by the patch is whether ports should be
    powered on or off following initialization.  The different drivers
    appear to handle this pretty much at random.  In fact it shouldn't
    matter, because the hub driver turns on power to all ports when it
    binds to the root hub.  Straightening that out will be left for
    another day.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index fdfd8c5b639b..22ca45c079a4 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -40,18 +40,13 @@ static int ehci_grlib_setup(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 	int		retval;
 
-	retval = ehci_halt(ehci);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci->sbrn = 0x20;
 	ehci_port_power(ehci, 1);
 
-	return ehci_reset(ehci);
+	return retval;
 }
 
 
@@ -164,12 +159,6 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 		ehci->big_endian_capbase = 1;
 	}
 
-	ehci->regs = hcd->regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
 	rv = usb_add_hcd(hcd, irq, 0);
 	if (rv)
 		goto err_ehci;

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index 93b230dc51a2..fdfd8c5b639b 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -130,7 +130,7 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 		return -ENOMEM;
 
 	hcd->rsrc_start = res.start;
-	hcd->rsrc_len = res.end - res.start + 1;
+	hcd->rsrc_len = resource_size(&res);
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 		printk(KERN_ERR "%s: request_mem_region failed\n", __FILE__);

commit 9be0392989306361d4a63a06a8ee281efbead548
Author: Jan Andersson <jan@gaisler.com>
Date:   Tue May 3 20:11:58 2011 +0200

    USB: EHCI: Add bus glue for GRLIB GRUSBHC controller
    
    This patch adds support for the GRLIB GRUSBHC EHCI controller from
    Aeroflex Gaisler. The controller is typically found on LEON/GRLIB
    SoCs.
    
    Tested on GR-LEON4-ITX with with little endian interface and on
    LEON3 system on GR-PCI-XC5V development board for big endian
    controller.
    
    Signed-off-by: Jan Andersson <jan@gaisler.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
new file mode 100644
index 000000000000..93b230dc51a2
--- /dev/null
+++ b/drivers/usb/host/ehci-grlib.c
@@ -0,0 +1,242 @@
+/*
+ * Driver for Aeroflex Gaisler GRLIB GRUSBHC EHCI host controller
+ *
+ * GRUSBHC is typically found on LEON/GRLIB SoCs
+ *
+ * (c) Jan Andersson <jan@gaisler.com>
+ *
+ * Based on ehci-ppc-of.c which is:
+ * (c) Valentine Barshak <vbarshak@ru.mvista.com>
+ * and in turn based on "ehci-ppc-soc.c" by Stefan Roese <sr@denx.de>
+ * and "ohci-ppc-of.c" by Sylvain Munaut <tnt@246tNt.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include <linux/signal.h>
+
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+
+#define GRUSBHC_HCIVERSION 0x0100 /* Known value of cap. reg. HCIVERSION */
+
+/* called during probe() after chip reset completes */
+static int ehci_grlib_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+	int		retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+	ehci_port_power(ehci, 1);
+
+	return ehci_reset(ehci);
+}
+
+
+static const struct hc_driver ehci_grlib_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "GRLIB GRUSBHC EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_grlib_setup,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
+};
+
+
+static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
+{
+	struct device_node *dn = op->dev.of_node;
+	struct usb_hcd *hcd;
+	struct ehci_hcd	*ehci = NULL;
+	struct resource res;
+	u32 hc_capbase;
+	int irq;
+	int rv;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	dev_dbg(&op->dev, "initializing GRUSBHC EHCI USB Controller\n");
+
+	rv = of_address_to_resource(dn, 0, &res);
+	if (rv)
+		return rv;
+
+	/* usb_create_hcd requires dma_mask != NULL */
+	op->dev.dma_mask = &op->dev.coherent_dma_mask;
+	hcd = usb_create_hcd(&ehci_grlib_hc_driver, &op->dev,
+			"GRUSBHC EHCI USB");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res.start;
+	hcd->rsrc_len = res.end - res.start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		printk(KERN_ERR "%s: request_mem_region failed\n", __FILE__);
+		rv = -EBUSY;
+		goto err_rmr;
+	}
+
+	irq = irq_of_parse_and_map(dn, 0);
+	if (irq == NO_IRQ) {
+		printk(KERN_ERR "%s: irq_of_parse_and_map failed\n", __FILE__);
+		rv = -EBUSY;
+		goto err_irq;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		printk(KERN_ERR "%s: ioremap failed\n", __FILE__);
+		rv = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+
+	ehci->caps = hcd->regs;
+
+	/* determine endianness of this implementation */
+	hc_capbase = ehci_readl(ehci, &ehci->caps->hc_capbase);
+	if (HC_VERSION(ehci, hc_capbase) != GRUSBHC_HCIVERSION) {
+		ehci->big_endian_mmio = 1;
+		ehci->big_endian_desc = 1;
+		ehci->big_endian_capbase = 1;
+	}
+
+	ehci->regs = hcd->regs +
+		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	rv = usb_add_hcd(hcd, irq, 0);
+	if (rv)
+		goto err_ehci;
+
+	return 0;
+
+err_ehci:
+	iounmap(hcd->regs);
+err_ioremap:
+	irq_dispose_mapping(irq);
+err_irq:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err_rmr:
+	usb_put_hcd(hcd);
+
+	return rv;
+}
+
+
+static int ehci_hcd_grlib_remove(struct platform_device *op)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+
+	dev_set_drvdata(&op->dev, NULL);
+
+	dev_dbg(&op->dev, "stopping GRLIB GRUSBHC EHCI USB Controller\n");
+
+	usb_remove_hcd(hcd);
+
+	iounmap(hcd->regs);
+	irq_dispose_mapping(hcd->irq);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+
+static void ehci_hcd_grlib_shutdown(struct platform_device *op)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+
+	if (hcd->driver->shutdown)
+		hcd->driver->shutdown(hcd);
+}
+
+
+static const struct of_device_id ehci_hcd_grlib_of_match[] = {
+	{
+		.name = "GAISLER_EHCI",
+	 },
+	{
+		.name = "01_026",
+	 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_hcd_grlib_of_match);
+
+
+static struct platform_driver ehci_grlib_driver = {
+	.probe		= ehci_hcd_grlib_probe,
+	.remove		= ehci_hcd_grlib_remove,
+	.shutdown	= ehci_hcd_grlib_shutdown,
+	.driver = {
+		.name = "grlib-ehci",
+		.owner = THIS_MODULE,
+		.of_match_table = ehci_hcd_grlib_of_match,
+	},
+};
