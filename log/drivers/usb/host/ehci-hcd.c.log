commit 7b81cb6bddd2c4f2489506771070924bd0ae9902
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:32 2019 +0200

    usb: add a HCD_DMA flag instead of guestimating DMA capabilities
    
    The usb core is the only major place in the kernel that checks for
    a non-NULL device dma_mask to see if a device is DMA capable.  This
    is generally a bad idea, as all major busses always set up a DMA mask,
    even if the device is not DMA capable - in fact bus layers like PCI
    can't even know if a device is DMA capable at enumeration time.  This
    leads to lots of workaround in HCD drivers, and also prevented us from
    setting up a DMA mask for platform devices by default last time we
    tried.
    
    Replace this guess with an explicit HCD_DMA that is set by drivers that
    appear to have DMA support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190816062435.881-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9da7e22848c9..cf2b7ae93b7e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1193,7 +1193,7 @@ static const struct hc_driver ehci_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2 | HCD_BH,
+	.flags =		HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit 2d7a3dc3e24f43504b1f25eae8195e600f4cce8b
Author: Laurentiu Tudor <laurentiu.tudor@nxp.com>
Date:   Wed May 29 13:28:43 2019 +0300

    USB: drop HCD_LOCAL_MEM flag
    
    With the addition of the local memory allocator, the HCD_LOCAL_MEM
    flag can be dropped and the checks against it replaced with a check
    for the localmem_pool ptr being initialized.
    
    Signed-off-by: Laurentiu Tudor <laurentiu.tudor@nxp.com>
    Tested-by: Fredrik Noring <noring@nocrew.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cdafa97f632d..9da7e22848c9 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -559,7 +559,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->command = temp;
 
 	/* Accept arbitrarily long scatter-gather lists */
-	if (!(hcd->driver->flags & HCD_LOCAL_MEM))
+	if (!hcd->localmem_pool)
 		hcd->self.sg_tablesize = ~0;
 
 	/* Prepare for unlinking active QHs */

commit a0ef2bdfa3b1497ac3d0cb348102c87c51f041a9
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Wed Sep 19 19:48:53 2018 +0000

    usb: host: Replace empty define with do while
    
    It's dangerous to use empty code define.
    Furthermore it lead to the following warning:
    "suggest braces around empty body in an « else » statement"
    
    So let's replace emptyness by "do {} while(0)"
    
    Furthermore, as suggested by Joe Perches, rename the macro to INCR.
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e8d7667828eb..cdafa97f632d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -730,9 +730,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* normal [4.15.1.2] or error [4.15.1.1] completion */
 	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
 		if (likely ((status & STS_ERR) == 0))
-			COUNT (ehci->stats.normal);
+			INCR(ehci->stats.normal);
 		else
-			COUNT (ehci->stats.error);
+			INCR(ehci->stats.error);
 		bh = 1;
 	}
 
@@ -756,7 +756,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
 		if (ehci->iaa_in_progress)
-			COUNT(ehci->stats.iaa);
+			INCR(ehci->stats.iaa);
 		end_iaa_cycle(ehci);
 	}
 

commit 0440fa3d1b4eb3a75b806b6538a3f9547dec4eef
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed Aug 22 22:42:56 2018 +0200

    USB: EHCI: make ehci-mv a separate driver
    
    This is done do that it could be enabled alongside other platform EHCI
    glue drivers on multiplatform kernels.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8608ac513fb7..e8d7667828eb 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1286,11 +1286,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_grlib_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_MV
-#include "ehci-mv.c"
-#define        PLATFORM_DRIVER         ehci_mv_driver
-#endif
-
 static int __init ehci_hcd_init(void)
 {
 	int retval = 0;

commit 00d423c8d0132915f4204b330343420c271b9142
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 8 16:59:50 2018 -0400

    USB: ehci-hcd: Add get_resuming_ports method
    
    This patch adds support for the new get_resuming_ports HCD method to
    the ehci-hcd driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 89c47ae5c7d3..8608ac513fb7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1226,6 +1226,7 @@ static const struct hc_driver ehci_hc_driver = {
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
+	.get_resuming_ports =	ehci_get_resuming_ports,
 
 	/*
 	 * device support

commit b8fc7743406d883e68d60ad6e73a86ae9059f1e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 29 17:30:57 2018 +0200

    USB: ehci-hcd: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d927adf3afcd..89c47ae5c7d3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1311,10 +1311,6 @@ static int __init ehci_hcd_init(void)
 
 #ifdef CONFIG_DYNAMIC_DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);
-	if (!ehci_debug_root) {
-		retval = -ENOENT;
-		goto err_debug;
-	}
 #endif
 
 #ifdef PLATFORM_DRIVER
@@ -1361,7 +1357,6 @@ static int __init ehci_hcd_init(void)
 #ifdef CONFIG_DYNAMIC_DEBUG
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
-err_debug:
 #endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;

commit 03f4c9abd73284193f70e64da1a266d393650530
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 9 16:10:20 2018 +0100

    usb: host: remove tilegx platform glue
    
    The tile architecture is getting removed, so the ehci and ohci platform
    glue drivers are no longer needed. In case of ohci, this is the last
    one to define a PLATFORM_DRIVER macro, so we can remove even more.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7f0737449df7..d927adf3afcd 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1275,11 +1275,6 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
-#ifdef CONFIG_TILE_USB
-#include "ehci-tilegx.c"
-#define	PLATFORM_DRIVER		ehci_hcd_tilegx_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
 #include "ehci-pmcmsp.c"
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver

commit d214109875b419c85c596d39b032692133bf58ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:26 2017 +0100

    USB: host: ehci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74d82148954d..7f0737449df7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -5,20 +5,6 @@
  * Maintainer: Alan Stern <stern@rowland.harvard.edu>
  *
  * Copyright (c) 2000-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/module.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c560a01f4971..74d82148954d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Enhanced Host Controller Interface (EHCI) driver for USB.
  *

commit 6ecbf2e9158586e9dde1286e6f5e03d7980d0ac3
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Wed Oct 25 13:49:21 2017 -0500

    usb: host: ehci-hcd: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6e834b83a104..c560a01f4971 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1012,7 +1012,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			qh_destroy(ehci, qh);
 			break;
 		}
-		/* else FALL THROUGH */
+		/* fall through */
 	default:
 		/* caller was supposed to have unlinked any requests;
 		 * that's not our job.  just leak this memory.

commit 324c54fab707921d6c68a05e5829b9d87cc5d884
Author: Romain Perier <romain.perier@collabora.com>
Date:   Wed Mar 8 17:19:56 2017 +0100

    usb: host: Remove remaining pci_pool in comments
    
    This replaces remaining occurences of pci_pool by dma_pool, as
    this is the new API that could be used for that purpose.
    
    Signed-off-by: Romain Perier <romain.perier@collabora.com>
    Reviewed-by: Peter Senna Tschudin <peter.senna@collabora.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ac2c4eab478d..6e834b83a104 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -597,7 +597,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	/*
 	 * hcc_params controls whether ehci->regs->segment must (!!!)
 	 * be used; it constrains QH/ITD/SITD and QTD locations.
-	 * pci_pool consistent memory always uses segment zero.
+	 * dma_pool consistent memory always uses segment zero.
 	 * streaming mappings for I/O buffers, like pci_map_single(),
 	 * can return segments above 4GB, if the device allows.
 	 *

commit 5b5e0928f742cfa853b2411400a1b19fa379d758
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 27 14:30:02 2017 -0800

    lib/vsprintf.c: remove %Z support
    
    Now that %z is standartised in C99 there is no reason to support %Z.
    Unlike %L it doesn't even make format strings smaller.
    
    Use BUILD_BUG_ON in a couple ATM drivers.
    
    In case anyone didn't notice lib/vsprintf.o is about half of SLUB which
    is in my opinion is quite an achievement.  Hopefully this patch inspires
    someone else to trim vsprintf.c more.
    
    Link: http://lkml.kernel.org/r/20170103230126.GA30170@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 063064801ceb..ac2c4eab478d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1322,7 +1322,7 @@ static int __init ehci_hcd_init(void)
 		printk(KERN_WARNING "Warning! ehci_hcd should always be loaded"
 				" before uhci_hcd and ohci_hcd, not after\n");
 
-	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+	pr_debug("%s: block sizes: qh %zd qtd %zd itd %zd sitd %zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));

commit 63c8d90ca967c7e87006dbd363a8724ba31f1b57
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Aug 26 15:17:39 2016 +0100

    USB: host: ehci-sead3: Remove SEAD-3 EHCI code
    
    The SEAD-3 board is now probing its EHCI controller using the generic
    EHCI driver & its generic-ehci device tree binding. Remove the unused
    SEAD-3 specific EHCI code.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14052/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1e5f529d51a2..063064801ceb 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1308,11 +1308,6 @@ MODULE_LICENSE ("GPL");
 #define        PLATFORM_DRIVER         ehci_mv_driver
 #endif
 
-#ifdef CONFIG_MIPS_SEAD3
-#include "ehci-sead3.c"
-#define	PLATFORM_DRIVER		ehci_hcd_sead3_driver
-#endif
-
 static int __init ehci_hcd_init(void)
 {
 	int retval = 0;

commit bc337b51508beb2d039aff5074a76cfe1c212030
Author: Marc Ohlf <ohlf@mkt-sys.de>
Date:   Wed Aug 3 11:51:54 2016 +0200

    usb: ehci: change order of register cleanup during shutdown
    
    In ehci_turn_off_all_ports() all EHCI port registers are cleared to zero.
    On some hardware, this can lead to an system hang,
    when ehci_port_power() accesses the already cleared registers.
    
    This patch changes the order of cleanup.
    First call ehci_port_power() which respects the current bits in
    port status registers
    and afterwards cleanup the hard way by setting everything to zero.
    
    Signed-off-by: Marc Ohlf <ohlf@mkt-sys.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a962b89b65a6..1e5f529d51a2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -332,11 +332,11 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 	int	port = HCS_N_PORTS(ehci->hcs_params);
 
 	while (port--) {
-		ehci_writel(ehci, PORT_RWC_BITS,
-				&ehci->regs->port_status[port]);
 		spin_unlock_irq(&ehci->lock);
 		ehci_port_power(ehci, port, false);
 		spin_lock_irq(&ehci->lock);
+		ehci_writel(ehci, PORT_RWC_BITS,
+				&ehci->regs->port_status[port]);
 	}
 }
 

commit 11c011a5e777c83819078a18672543f04482b3ec
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Thu May 19 11:12:56 2016 +0100

    usb: echi-hcd: Add ehci_setup check before echi_shutdown
    
    This patch protects system from crashing at shutdown in
    cases where usb host is not added yet from OTG controller driver.
    As ehci_setup() not done yet, so stop accessing registers or
    variables initialized as part of ehci_setup().
    
    The use case is simple, for boards like DB410c where the usb host
    or device functionality is decided based on the micro-usb cable
    presence. If the board boots up with micro-usb connected, the
    OTG driver like echi-msm would not add the usb host by default.
    However a system shutdown would go and access registers and
    uninitialized variables, resulting in below crash.
    
    Unable to handle kernel NULL pointer dereference at virtual address
     00000008
    pgd = ffffffc034581000
    [00000008] *pgd=0000000000000000, *pud=0000000000000000
    CPU: 2 PID: 1957 Comm: reboot Not tainted 4.6.0+ #99
    task: ffffffc034bc0000 ti: ffffffc0345cc000 task.ti: ffffffc0345cc000
    PC is at ehci_halt+0x54/0x108
    LR is at ehci_halt+0x38/0x108
    pc : [<ffffff800869837c>] lr : [<ffffff8008698360>] pstate: a00001c5
    sp : ffffffc0345cfc60
    x29: ffffffc0345cfc60 x28: ffffffc0345cc000
    x27: ffffff8008a4d000 x26: 000000000000008e
    x25: ffffff8008d86cb0 x24: ffffff800908b040
    x23: ffffffc036068870 x22: ffffff8009d0a000
    x21: ffffffc03512a410 x20: ffffffc03512a410
    x19: ffffffc03512a338 x18: 00000000000065ba
    x17: ffffff8009b16b80 x16: 0000000000000003
    x15: 00000000000065b9 x14: 00000000000065b6
    x13: 0000000000000000 x12: 0000000000000000
    x11: 000000000000003d x10: ffffffc0345cf9e0
    x9 : 0000000000000001 x8 : ffffffc0345cc000
    x7 : ffffff8008698360 x6 : 0000000000000000
    x5 : 0000000000000080 x4 : 0000000000000001
    x3 : 0000000000000000 x2 : 0000000000000000
    x1 : 0000000000000008 x0 : ffffffc034bc0000
    
    Process reboot (pid: 1957, stack limit = 0xffffffc0345cc020)
    Stack: (0xffffffc0345cfc60 to 0xffffffc0345d0000)
    fc60: ffffffc0345cfc90 ffffff8008698448 ffffffc03512a338 ffffffc03512a338
    fc80: ffffffc03512a410 ffffff8008a3bbfc ffffffc0345cfcc0 ffffff8008698548
    fca0: ffffffc03512a338 ffffffc03512a000 ffffffc03512a410 ffffff8009d0a000
    fcc0: ffffffc0345cfcf0 ffffff800865d2bc ffffffc036068828 ffffffc036068810
    fce0: ffffffc036003810 ffffff800853f43c ffffffc0345cfd00 ffffff800854338c
    fd00: ffffffc0345cfd10 ffffff800853f45c ffffffc0345cfd60 ffffff80080e0f48
    fd20: 0000000000000000 0000000001234567 ffffff8008f8c000 ffffff8008f8c060
    fd40: 0000000000000000 0000000000000015 0000000000000120 ffffff80080e0f30
    fd60: ffffffc0345cfd70 ffffff80080e1020 ffffffc0345cfd90 ffffff80080e12fc
    fd80: 0000000000000000 0000000001234567 0000000000000000 ffffff8008085e70
    fda0: 0000000000000000 0000005592905000 ffffffffffffffff 0000007f79daf1cc
    fdc0: 0000000000000000 0000000000000000 0000007ffcbb1198 000000000000000a
    fde0: 00000055928d3f58 0000000000000001 ffffffc034900000 00000000fffffffe
    fe00: ffffffc034900000 0000007f79da902c ffffffc0345cfe40 ffffff800820af38
    fe20: 0000000000000000 0000007ffcbb1078 ffffffffffffffff ffffff80081e9b38
    fe40: ffffffc0345cfe60 ffffff80081eb410 ffffffc0345cfe60 ffffff80081eb444
    fe60: ffffffc0345cfec0 ffffff80081ec4f4 0000000000000000 0000007ffcbb1078
    fe80: ffffffffffffffff 0000000000000015 ffffffc0345cfec0 0000007ffcbb1078
    fea0: 0000000000000002 000000000000000a ffffffffffffffff 0000000000000000
    fec0: 0000000000000000 ffffff8008085e70 fffffffffee1dead 0000000028121969
    fee0: 0000000001234567 0000000000000000 ffffffffffffffff 8080800000800000
    ff00: 0000800000808080 0000007ffcbb10f0 000000000000008e fefeff54918cb8c7
    ff20: 7f7f7f7fffffffff 0101010101010101 0000000000000010 0000000000000000
    ff40: 0000000000000000 0000007f79e33588 0000005592905eb8 0000007f79daf1b0
    ff60: 0000007ffcbb1340 0000005592906000 0000005592905000 0000005592906000
    ff80: 0000005592907000 0000000000000002 0000007ffcbb1d98 0000005592906000
    ffa0: 00000055928d2000 0000000000000000 0000000000000000 0000007ffcbb1aa0
    ffc0: 00000055928b819c 0000007ffcbb1aa0 0000007f79daf1cc 0000000000000000
    ffe0: fffffffffee1dead 000000000000008e 05ef555057155555 d555544d55d775d3
    Call trace:
    Exception stack(0xffffffc0345cfaa0 to 0xffffffc0345cfbc0)
    Set corner to 6
    faa0: ffffffc03512a338 ffffffc03512a410 ffffffc0345cfc60 ffffff800869837c
    fac0: ffffff8008114210 0000000100000001 ffffff8009ce1b20 ffffff8009ce5f20
    fae0: ffffffc0345cfb80 ffffff80081145a8 ffffffc0345cfc10 ffffff800810b924
    fb00: ffffffc0345cc000 00000000000001c0 ffffffc03512a410 ffffff8009d0a000
    fb20: ffffffc036068870 ffffff800908b040 ffffff8008d86cb0 000000000000008e
    fb40: ffffffc034bc0000 0000000000000008 0000000000000000 0000000000000000
    fb60: 0000000000000001 0000000000000080 0000000000000000 ffffff8008698360
    fb80: ffffffc0345cc000 0000000000000001 ffffffc0345cf9e0 000000000000003d
    fba0: 0000000000000000 0000000000000000 00000000000065b6 00000000000065b9
    [<ffffff800869837c>] ehci_halt+0x54/0x108
    [<ffffff8008698448>] ehci_silence_controller+0x18/0xcc
    [<ffffff8008698548>] ehci_shutdown+0x4c/0x64
    [<ffffff800865d2bc>] usb_hcd_platform_shutdown+0x1c/0x24
    [<ffffff800854338c>] platform_drv_shutdown+0x20/0x28
    [<ffffff800853f45c>] device_shutdown+0xf4/0x1b0
    [<ffffff80080e0f48>] kernel_restart_prepare+0x34/0x3c
    [<ffffff80080e1020>] kernel_restart+0x14/0x74
    [<ffffff80080e12fc>] SyS_reboot+0x110/0x21c
    [<ffffff8008085e70>] el0_svc_naked+0x24/0x28
    Code: 53001c42 350000a2 d5033e9f 91002021 (b9000022)
    
    Fixes 4bb3cad7125b ("usb: host: ehci-msm: Register usb shutdown function")
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Tested-by: Pramod Gurav <pramod.gurav@linaro.org>
    Tested-by: Andy Gross <andy.gross@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ae1b6e69eb96..a962b89b65a6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -368,6 +368,15 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
+	/**
+	 * Protect the system from crashing at system shutdown in cases where
+	 * usb host is not added yet from OTG controller driver.
+	 * As ehci_setup() not done yet, so stop accessing registers or
+	 * variables initialized in ehci_setup()
+	 */
+	if (!ehci->sbrn)
+		return;
+
 	spin_lock_irq(&ehci->lock);
 	ehci->shutdown = true;
 	ehci->rh_state = EHCI_RH_STOPPING;

commit 1586ba0c218b10cce1de57c45f599dd8831a2d12
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 4 11:17:36 2016 -0500

    USB: EHCI: fix compiler warning introduced by commit 2a40f324541e
    
    Fix the following compiler warning (found by the kbuild test robot):
    
    drivers/usb/host/ehci-hcd.c:312:13: warning: 'unlink_empty_async_suspended' declared 'static' but never defined
    
    Commit 2a40f324541e ("USB: EHCI: fix regression during bus resume")
    protected the function definition with a "#ifdef CONFIG_PM" block, so
    now the declaration needs to be similarly protected.  This patch moves
    it to a better location.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a93d445b63a4..ae1b6e69eb96 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -309,7 +309,6 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 static void end_iaa_cycle(struct ehci_hcd *ehci);
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
-static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);

commit 87d61912c23a746ee9a8a8d2fe17af217c87f761
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:45:25 2016 -0500

    USB: EHCI: add a delay when unlinking an active QH
    
    Michael Reutman reports that an AMD/ATI EHCI host controller on one of
    his computers does not stop transferring data when an active bulk QH
    is unlinked from the async schedule.  Apparently that host controller
    fails to implement the IAA mechanism correctly when an active QH is
    unlinked.  This leads to data corruption, because the controller
    continues to update the QH in memory when the driver doesn't expect
    it.  As a result, the next URB submitted for that QH can hang, because
    the link pointers for the TD queue have been messed up.  This
    misbehavior is observed quite regularly.
    
    To be fair, the EHCI spec (section 4.8.2) says that active QHs should
    not be unlinked.  It goes on to recommend a procedure that involves
    waiting for the QH to go inactive before unlinking it.  In the real
    world this is impractical, not least because the QH may _never_ go
    inactive.  (What were they thinking?)  Sometimes we have no choice but
    to unlink an active QH.
    
    In an attempt to avoid the problems that can ensue, this patch changes
    how the driver decides when the unlink is complete.  In addition to
    waiting through two IAA cycles, in cases where the QH was not known to
    be inactive beforehand we now wait until a 2-ms period has elapsed
    with the host controller making no change to the QH data structure
    (the hw_current and hw_token fields in particular).  The intuition
    here is that after such a long period, the endpoint must be NAKing and
    hopefully the QH has been dropped from the host controller's internal
    cache.  There's no way to know if this reasoning is really valid --
    the spec is no help in this regard -- but at least this approach fixes
    Michael's problem.
    
    The test for whether the QH is already known to be inactive involves
    the reason for unlinking the QH originally.  If it was unlinked
    because it had halted, or it stopped in response to a short read, or
    it overlaid a dummy TD (a silicon bug), then it certainly is inactive.
    If it was unlinked because the TD queue was empty and no TDs have been
    added to the queue in the meantime, then it must be inactive.  Or if
    the hardware status indicates that the QH is currently halted (even if
    that wasn't the reason for unlinking it), then it is inactive.
    Otherwise, if none of those checks apply, we go through the 2-ms
    delay.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Michael Reutman <mreutman@epiqsolutions.com>
    Tested-by: Michael Reutman <mreutman@epiqsolutions.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 84c41262109c..a93d445b63a4 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -566,6 +566,9 @@ static int ehci_init(struct usb_hcd *hcd)
 	/* Accept arbitrarily long scatter-gather lists */
 	if (!(hcd->driver->flags & HCD_LOCAL_MEM))
 		hcd->self.sg_tablesize = ~0;
+
+	/* Prepare for unlinking active QHs */
+	ehci->old_current = ~0;
 	return 0;
 }
 

commit f96fba0dbf8f6b0eaa313b4c230f93c9bb0dd759
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:44:16 2016 -0500

    USB: EHCI: improve handling of the ehci->iaa_in_progress flag
    
    This patch improves the way ehci-hcd handles the iaa_in_progress flag.
    The current code is somewhat careless in this regard:
    
            The flag is meaningless when the root hub isn't running, most
            particularly after the root hub has been suspended.  But in
            start_iaa_cycle(), the driver checks the flag before checking
            the root hub's state.  They should be checked in the opposite
            order.
    
            That routine also sets the flag too early, before it has
            definitely committed to starting an IAA cycle.
    
            The flag is turned off in end_unlink_async().  Upcoming
            changes will call that routine at other times, not just at the
            end of an IAA cycle.  The two actions are logically separate
            (although related), so we separate out a new routine to be
            called in place of end_unlink_async() whenever an IAA cycle
            ends: end_iaa_cycle().
    
            iaa_in_progress should be turned off when the root hub is
            suspended -- we certainly don't want it still to be set when
            the root hub resumes.  Therefore the call to
            end_unlink_async() in ehci_bus_suspend() should also be
            replaced with a call to end_iaa_cycle().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c5465bf9a798..84c41262109c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -306,6 +306,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
+static void end_iaa_cycle(struct ehci_hcd *ehci);
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
 static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
@@ -758,7 +759,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
 		if (ehci->iaa_in_progress)
 			COUNT(ehci->stats.iaa);
-		end_unlink_async(ehci);
+		end_iaa_cycle(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */

commit fcc5184ec1521c7d85124421e593660c94e9a9fb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:42:04 2016 -0500

    USB: EHCI: store reason for unlinking a QH
    
    This patch replaces the "exception" bitflag in the ehci_qh structure
    with a more explicit "unlink_reason" bitmask.  This is for use in the
    following patch, where we will need to have a good idea of the
    reason for unlinking a QH, not just "something exceptional happened".
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Michael Reutman <mreutman@epiqsolutions.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 00e77cc91053..c5465bf9a798 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -911,7 +911,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		 */
 	} else {
 		qh = (struct ehci_qh *) urb->hcpriv;
-		qh->exception = 1;
+		qh->unlink_reason |= QH_UNLINK_REQUESTED;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
 			if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT)
@@ -972,10 +972,13 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto done;
 	}
 
-	qh->exception = 1;
+	qh->unlink_reason |= QH_UNLINK_REQUESTED;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:
-		WARN_ON(!list_empty(&qh->qtd_list));
+		if (list_empty(&qh->qtd_list))
+			qh->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;
+		else
+			WARN_ON(1);
 		if (usb_endpoint_type(&ep->desc) != USB_ENDPOINT_XFER_INT)
 			start_unlink_async(ehci, qh);
 		else
@@ -1042,7 +1045,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * re-linking will call qh_refresh().
 			 */
 			usb_settoggle(qh->ps.udev, epnum, is_out, 0);
-			qh->exception = 1;
+			qh->unlink_reason |= QH_UNLINK_REQUESTED;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
 			else

commit d8ff463a4ef22f090df21a3c5b34b336e80b72ca
Author: Jia-Ju Bai <baijiaju1990@163.com>
Date:   Mon Jan 4 16:14:43 2016 +0800

    ehci-hcd: Cleanup memory resources when ehci_halt fails
    
    The driver calls ehci_mem_init to allocate memory resources.
    But these resources are not freed when ehci_halt fails.
    
    This patch adds "ehci_mem_cleanup" in error handling code to fix this problem.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@163.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 14178bbf0694..00e77cc91053 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -675,8 +675,10 @@ int ehci_setup(struct usb_hcd *hcd)
 		return retval;
 
 	retval = ehci_halt(ehci);
-	if (retval)
+	if (retval) {
+		ehci_mem_cleanup(ehci);
 		return retval;
+	}
 
 	ehci_reset(ehci);
 

commit 900937c0375efcbb2c9fb2eef50ccb5c98fc99ea
Author: Geyslan G. Bem <geyslan@gmail.com>
Date:   Wed Dec 2 20:25:23 2015 -0300

    usb: ehci: ohci: fix bool assignments
    
    When assigning bool use true instead of 1. If declaring it as static and
    it's false there's no need to initialize it, since static variables are
    zeroed by default.
    
    Caught by coccinelle.
    
    Signed-off-by: Geyslan G. Bem <geyslan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 48c92bf78bd0..14178bbf0694 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -98,7 +98,7 @@ module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
 /* for flakey hardware, ignore overcurrent indicators */
-static bool ignore_oc = 0;
+static bool ignore_oc;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 

commit 0e77acef8ec21c82530214728631fb7a416e75c7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 9 14:58:18 2015 -0800

    dma: remove external references to dma_supported
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c63d82c91f10..48c92bf78bd0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -589,7 +589,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * streaming mappings for I/O buffers, like pci_map_single(),
 	 * can return segments above 4GB, if the device allows.
 	 *
-	 * NOTE:  the dma mask is visible through dma_supported(), so
+	 * NOTE:  the dma mask is visible through dev->dma_mask, so
 	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
 	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
 	 * host side drivers though.

commit 74db22cb3a16dcd782a31236eb139f5865804ae6
Author: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Date:   Fri May 29 11:28:30 2015 +0530

    drivers:usb:fsl: Fix compilation error for fsl ehci drv
    
    Fix compilation error in fsl ehci drv because ehci_reset()
    and ehci_adjust_port_wakeup_flags() were not exported, and
    are used when PM is enabled
    
    Signed-off-by: Ramneek Mehresh <ramneek.mehresh@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9dd161ce02a2..c63d82c91f10 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -239,7 +239,7 @@ static void tdi_reset (struct ehci_hcd *ehci)
  * Reset a non-running (STS_HALT == 1) controller.
  * Must be called with interrupts enabled and the lock not held.
  */
-static int ehci_reset (struct ehci_hcd *ehci)
+int ehci_reset(struct ehci_hcd *ehci)
 {
 	int	retval;
 	u32	command = ehci_readl(ehci, &ehci->regs->command);
@@ -275,6 +275,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 			ehci->resuming_ports = 0;
 	return retval;
 }
+EXPORT_SYMBOL_GPL(ehci_reset);
 
 /*
  * Idle the controller (turn off the schedules).

commit ca07e1c1e4a6aed2b2576256b1fdc53a9f87bb40
Author: Ramneek Mehresh <ramneek.mehresh@freescale.com>
Date:   Thu May 14 19:04:46 2015 +0530

    drivers:usb:fsl:Make fsl ehci drv an independent driver module
    
    Make Freescale EHCI driver an independent entity from ehci-hcd.c.
    This involves
            - using module_init/module_exit functions
            - using overrides structure
            - some necessary code cleanup
    
    Signed-off-by: Ramneek Mehresh <ramneek.mehresh@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f4d88dfb26a7..9dd161ce02a2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1250,11 +1250,6 @@ MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_USB_EHCI_FSL
-#include "ehci-fsl.c"
-#define	PLATFORM_DRIVER		ehci_fsl_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver

commit ea16328f80ca8d74434352157f37ef60e2f55ce2
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Feb 13 14:42:25 2015 -0600

    usb: host: ehci: use new USB_RESUME_TIMEOUT
    
    Make sure we're using the new macro, so our
    resume signaling will always pass certification.
    
    Cc: <stable@vger.kernel.org> # v3.10+
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 85e56d1abd23..f4d88dfb26a7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -792,12 +792,12 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 					ehci->reset_done[i] == 0))
 				continue;
 
-			/* start 20 msec resume signaling from this port,
-			 * and make hub_wq collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.  Use 5 ms extra for safety,
-			 * like usb_port_resume() does.
+			/* start USB_RESUME_TIMEOUT msec resume signaling from
+			 * this port, and make hub_wq collect
+			 * PORT_STAT_C_SUSPEND to stop that signaling.
 			 */
-			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
+			ehci->reset_done[i] = jiffies +
+				msecs_to_jiffies(USB_RESUME_TIMEOUT);
 			set_bit(i, &ehci->resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			usb_hcd_start_port_resume(&hcd->self, i);

commit 314b41b16a71ee824f55e2791fcb92997672da37
Author: Wu Liang feng <wulf@rock-chips.com>
Date:   Wed Dec 24 18:22:19 2014 +0800

    USB: ehci-platform: Support ehci reset after resume quirk
    
    The Rockchip rk3288 EHCI controller doesn't properly detect
    the case when a device is removed during suspend. Specifically,
    when usb resume from suspend, the EHCI controller maintaining
    the USB state (FLAG_CF is 1, Current Connect Status is 1),
    but a USB device (like a USB camera on rk3288) may have been
    disconnected actually.
    
    Let's add a quirk to force ehci to go into the
    usb_root_hub_lost_power() path and reset after resume.
    This should generally reset the whole controller and all
    ports and initialize everything cleanly again, and bring
    the devices back up.
    
    As part of this, rename the "hibernation" paramter of
    ehci_resume() to force_reset since hibernation is simply
    another case where we can't trust the autodetected status
    and need to force a reset of devices.
    
    Signed-off-by: Wu Liang feng <wulf@rock-chips.com>
    Reviewed-by: Julius Werner <jwerner@google.com>
    Reviewed-by: Doug Anderson <dianders@google.com>
    Reviewed-by: Tomasz Figa <tfiga@google.com>
    Reviewed-by: Pawel Osciak <posciak@google.com>
    Reviewed-by: Sonny Rao <sonnyrao@google.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Doug Anderson <dianders@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 38bfeedae1d0..85e56d1abd23 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1110,7 +1110,7 @@ int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 EXPORT_SYMBOL_GPL(ehci_suspend);
 
 /* Returns 0 if power was preserved, 1 if power was lost */
-int ehci_resume(struct usb_hcd *hcd, bool hibernated)
+int ehci_resume(struct usb_hcd *hcd, bool force_reset)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
@@ -1124,12 +1124,12 @@ int ehci_resume(struct usb_hcd *hcd, bool hibernated)
 		return 0;		/* Controller is dead */
 
 	/*
-	 * If CF is still set and we aren't resuming from hibernation
+	 * If CF is still set and reset isn't forced
 	 * then we maintained suspend power.
 	 * Just undo the effect of ehci_suspend().
 	 */
 	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
-			!hibernated) {
+			!force_reset) {
 		int	mask = INTR_MASK;
 
 		ehci_prepare_ports_for_controller_resume(ehci);

commit 2193dda5eec60373c7a061c129c6ab9d658f78e9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 25 12:28:46 2014 +0100

    USB: host: Remove ehci-octeon and ohci-octeon drivers
    
    Remove special-purpose octeon drivers and instead use ehci-platform
    and ohci-platform as suggested with
    http://marc.info/?l=linux-mips&m=140139694721623&w=2
    
    [andreas.herrmann:
        fixed compile error]
    
    Cc: David Daney <david.daney@cavium.com>
    Cc: Alex Smith <alex.smith@imgtec.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Andreas Herrmann <andreas.herrmann@caviumnetworks.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index df75b8e7d157..38bfeedae1d0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1275,11 +1275,6 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
-#ifdef CONFIG_USB_OCTEON_EHCI
-#include "ehci-octeon.c"
-#define PLATFORM_DRIVER		ehci_octeon_driver
-#endif
-
 #ifdef CONFIG_TILE_USB
 #include "ehci-tilegx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_tilegx_driver

commit 11a7e59405148c855e0a9d13588930ccec02c150
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Mon Oct 13 09:53:03 2014 +0800

    usb: ehci: add ehci_port_power interface
    
    The current EHCI implementation is prepared to toggle the
    PORT_POWER bit to enable or disable a USB-Port. In some
    cases this port power can not be just toggled by the PORT_POWER
    bit, and the gpio-regulator is needed to be toggled too.
    
    This patch defines a port power control interface ehci_port_power for
    ehci core use, it toggles PORT_POWER bit as well as calls platform
    defined .port_power if it is defined.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 15feaf924b71..df75b8e7d157 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -311,6 +311,7 @@ static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+static int ehci_port_power(struct ehci_hcd *ehci, int portnum, bool enable);
 
 #include "ehci-timer.c"
 #include "ehci-hub.c"
@@ -329,9 +330,13 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 {
 	int	port = HCS_N_PORTS(ehci->hcs_params);
 
-	while (port--)
+	while (port--) {
 		ehci_writel(ehci, PORT_RWC_BITS,
 				&ehci->regs->port_status[port]);
+		spin_unlock_irq(&ehci->lock);
+		ehci_port_power(ehci, port, false);
+		spin_lock_irq(&ehci->lock);
+	}
 }
 
 /*
@@ -1233,6 +1238,8 @@ void ehci_init_driver(struct hc_driver *drv,
 		drv->hcd_priv_size += over->extra_priv_size;
 		if (over->reset)
 			drv->reset = over->reset;
+		if (over->port_power)
+			drv->port_power = over->port_power;
 	}
 }
 EXPORT_SYMBOL_GPL(ehci_init_driver);

commit 37ebb54915dc42944f6ae92fe53b9531c3903801
Author: Petr Mladek <pmladek@suse.cz>
Date:   Fri Sep 19 17:32:23 2014 +0200

    usb: hub: rename khubd to hub_wq in documentation and comments
    
    USB hub has started to use a workqueue instead of kthread. Let's update
    the documentation and comments here and there.
    
    This patch mostly just replaces "khubd" with "hub_wq". There are only few
    exceptions where the whole sentence was updated. These more complicated
    changes can be found in the following files:
    
               Documentation/usb/hotplug.txt
               drivers/net/usb/usbnet.c
               drivers/usb/core/hcd.c
               drivers/usb/host/ohci-hcd.c
               drivers/usb/host/xhci.c
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 488a30836c36..15feaf924b71 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -788,7 +788,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 				continue;
 
 			/* start 20 msec resume signaling from this port,
-			 * and make khubd collect PORT_STAT_C_SUSPEND to
+			 * and make hub_wq collect PORT_STAT_C_SUSPEND to
 			 * stop that signaling.  Use 5 ms extra for safety,
 			 * like usb_port_resume() does.
 			 */

commit 7312b5ddd47fee2356baa78c5516ef8e04eed452
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Sep 17 11:23:54 2014 -0400

    USB: EHCI: unlink QHs even after the controller has stopped
    
    Old code in ehci-hcd tries to expedite disabling endpoints after the
    controller has stopped, by destroying the endpoint's associated QH
    without first unlinking the QH.  This was necessary back when the
    driver wasn't so careful about keeping track of the controller's
    state.
    
    But now we are careful about it, and the driver knows that when the
    controller isn't running, no unlinking delay is needed.  Furthermore,
    skipping the unlink step will trigger a BUG() in qh_destroy() when the
    preceding QH is released, because the link pointer will be non-NULL.
    
    Removing the lines that skip the unlinking step and go directly to
    QH_STATE_IDLE fixes the problem.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Joe Lawrence <joe.lawrence@stratus.com>
    Tested-by: Joe Lawrence <joe.lawrence@stratus.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 81cda09b47e3..488a30836c36 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -965,8 +965,6 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	}
 
 	qh->exception = 1;
-	if (ehci->rh_state < EHCI_RH_RUNNING)
-		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:
 		WARN_ON(!list_empty(&qh->qtd_list));

commit a1227f3c1030e96ebc51d677d2f636268845c5fb
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Wed Feb 19 10:29:01 2014 +0100

    usb: ehci: fix deadlock when threadirqs option is used
    
    ehci_irq() and ehci_hrtimer_func() can deadlock on ehci->lock when
    threadirqs option is used. To prevent the deadlock use
    spin_lock_irqsave() in ehci_irq().
    
    This change can be reverted when hrtimer callbacks become threaded.
    
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 471142725ffe..81cda09b47e3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -685,8 +685,15 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
+	unsigned long		flags;
 
-	spin_lock (&ehci->lock);
+	/*
+	 * For threadirqs option we use spin_lock_irqsave() variant to prevent
+	 * deadlock with ehci hrtimer callback, because hrtimer callbacks run
+	 * in interrupt context even when threadirqs is specified. We can go
+	 * back to spin_lock() variant when hrtimer callbacks become threaded.
+	 */
+	spin_lock_irqsave(&ehci->lock, flags);
 
 	status = ehci_readl(ehci, &ehci->regs->status);
 
@@ -704,7 +711,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* Shared IRQ? */
 	if (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {
-		spin_unlock(&ehci->lock);
+		spin_unlock_irqrestore(&ehci->lock, flags);
 		return IRQ_NONE;
 	}
 
@@ -815,7 +822,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	if (bh)
 		ehci_work (ehci);
-	spin_unlock (&ehci->lock);
+	spin_unlock_irqrestore(&ehci->lock, flags);
 	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
 	return IRQ_HANDLED;

commit c793d08ecd944b1a180c6712bb47825e37cc0626
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Nov 18 13:23:17 2013 +0100

    USB: kill #undef VERBOSE_DEBUG
    
    It is useless now. Straight removal.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1e21a3623af9..471142725ffe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -71,7 +71,6 @@
 static const char	hcd_name [] = "ehci_hcd";
 
 
-#undef VERBOSE_DEBUG
 #undef EHCI_URB_TRACE
 
 /* magic numbers that can affect system performance */

commit 1c20163d30db28552a341d5e0d6c007d4c8dc8be
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Nov 18 13:23:16 2013 +0100

    usb: kill DEBUG compile option
    
    In the drivers that no longer need it, it is removed.
    It is removed from the Makefile. Drivers not fully converted
    to dynamic debug have it shifted down into the individual
    drivers.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b57e997eb716..1e21a3623af9 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1313,7 +1313,7 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
-#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
+#ifdef CONFIG_DYNAMIC_DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);
 	if (!ehci_debug_root) {
 		retval = -ENOENT;
@@ -1362,7 +1362,7 @@ static int __init ehci_hcd_init(void)
 	platform_driver_unregister(&PLATFORM_DRIVER);
 clean0:
 #endif
-#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
+#ifdef CONFIG_DYNAMIC_DEBUG
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
 err_debug:
@@ -1386,7 +1386,7 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
-#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
+#ifdef CONFIG_DYNAMIC_DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);

commit 991fb3daac946441dbf4c237b2dd4d6c11fff633
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Nov 18 13:23:02 2013 +0100

    ehci: Remove debugging at every interrupt
    
    This is overkill. Just removeit.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e8ba4c44223a..b57e997eb716 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -714,13 +714,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	cmd = ehci_readl(ehci, &ehci->regs->command);
 	bh = 0;
 
-#ifdef	VERBOSE_DEBUG
-	/* unrequested/ignored: Frame List Rollover */
-	dbg_status (ehci, "irq", status);
-#endif
-
-	/* INT, ERR, and IAA interrupt rates can be throttled */
-
 	/* normal [4.15.1.2] or error [4.15.1.1] completion */
 	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
 		if (likely ((status & STS_ERR) == 0))

commit b8efdafb4005a79ab2305f8af31025d49292d4cf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 18 11:18:21 2013 -0400

    USB: EHCI: add check for wakeup/suspend race
    
    hcd-pci.c in usbcore contains a check for wakeup requests racing with
    controller suspend.  This check is going to be moved out of usbcore
    and into the individual controller drivers, where it can apply to all
    platforms, not just PCI.
    
    This patch adds the check to ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e66706aa9f0c..e8ba4c44223a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1095,6 +1095,14 @@ int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	spin_unlock_irq(&ehci->lock);
 
+	synchronize_irq(hcd->irq);
+
+	/* Check for race with a wakeup request */
+	if (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {
+		ehci_resume(hcd, false);
+		return -EBUSY;
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ehci_suspend);

commit b35c5009bbf619d8885b4b3c8b102d09002acfe5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 22:16:21 2013 -0400

    USB: EHCI: create per-TT bandwidth tables
    
    This patch continues the scheduling changes in ehci-hcd by adding a
    table to store the bandwidth allocation below each TT.  This will
    speed up the scheduling code, as it will no longer need to read
    through the entire schedule to compute the bandwidth currently in use.
    
    Properly speaking, the FS/LS budget calculations should be done in
    terms of full-speed bytes per microframe, as described in the USB-2
    spec.  However the driver currently uses microseconds per microframe,
    and the scheduling code isn't robust enough at this point to change
    over.  For the time being, we leave the calculations as they are.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 398e8fa3032f..e66706aa9f0c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,6 +110,9 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 #include "ehci.h"
 #include "pci-quirks.h"
 
+static void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],
+		struct ehci_tt *tt);
+
 /*
  * The MosChip MCS9990 controller updates its microframe counter
  * a little before the frame counter, and occasionally we will read
@@ -484,6 +487,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&ehci->intr_qh_list);
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
+	INIT_LIST_HEAD(&ehci->tt_list);
 
 	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
 		/* periodic schedule size can be smaller than default */
@@ -1051,6 +1055,19 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+/* Device addition and removal */
+
+static void ehci_remove_device(struct usb_hcd *hcd, struct usb_device *udev)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	spin_lock_irq(&ehci->lock);
+	drop_tt(udev);
+	spin_unlock_irq(&ehci->lock);
+}
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef	CONFIG_PM
 
 /* suspend/resume, section 4.3 */
@@ -1194,6 +1211,11 @@ static const struct hc_driver ehci_hc_driver = {
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
+
+	/*
+	 * device support
+	 */
+	.free_dev =		ehci_remove_device,
 };
 
 void ehci_init_driver(struct hc_driver *drv,

commit d0ce5c6b9208c79fc725c578eebdeb5724faf17d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:29:13 2013 -0400

    USB: EHCI: use a bandwidth-allocation table
    
    This patch significantly changes the scheduling code in ehci-hcd.
    Instead of calculating the current bandwidth utilization by trudging
    through the schedule and adding up the times used by the existing
    transfers, we will now maintain a table holding the time used for each
    of 64 microframes.  This will drastically speed up the bandwidth
    computations.
    
    In addition, it eliminates a theoretical bug.  An isochronous endpoint
    may have bandwidth reserved even at times when it has no transfers
    listed in the schedule.  The table will keep track of the reserved
    bandwidth, whereas adding up entries in the schedule would miss it.
    
    As a corollary, we can keep bandwidth reserved for endpoints even
    when they aren't in active use.  Eventually the bandwidth will be
    reserved when a new alternate setting is installed; for now the
    endpoint's reservation takes place when its first URB is submitted.
    
    A drawback of this approach is that transfers with an interval larger
    than 64 microframes will have to be charged for bandwidth as though
    the interval was 64.  In practice this shouldn't matter much;
    transfers with longer intervals tend to be rather short anyway (things
    like hubs or HID devices).
    
    Another minor drawback is that we will keep track of two different
    period and phase values: the actual ones and the ones used for
    bandwidth allocation (which are limited to 64).  This adds only a
    small amount of overhead: 3 bytes for each endpoint.
    
    The patch also adds a new debugfs file named "bandwidth" to display
    the information stored in the new table.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b2e4e4b3cfae..398e8fa3032f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -956,6 +956,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			goto idle_timeout;
 
 		/* BUG_ON(!list_empty(&stream->free_list)); */
+		reserve_release_iso_bandwidth(ehci, stream, -1);
 		kfree(stream);
 		goto done;
 	}
@@ -982,6 +983,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		if (qh->clearing_tt)
 			goto idle_timeout;
 		if (list_empty (&qh->qtd_list)) {
+			if (qh->ps.bw_uperiod)
+				reserve_release_intr_bandwidth(ehci, qh, -1);
 			qh_destroy(ehci, qh);
 			break;
 		}

commit ffa0248e643175cea3887c7058916af53104d8e5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:29:03 2013 -0400

    USB: EHCI: create a "periodic schedule info" struct
    
    This patch begins the process of unifying the scheduling parameters
    that ehci-hcd uses for interrupt and isochronous transfers.  It
    creates an ehci_per_sched structure, which will be stored in both
    ehci_qh and ehci_iso_stream structures, and will contain the common
    scheduling information needed for both.
    
    Initially we merely create the new structure and move some existing
    fields into it.  Later patches will add more fields and utilize these
    structures in improved scheduling algorithms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 652018f93632..b2e4e4b3cfae 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1029,7 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			usb_settoggle(qh->dev, epnum, is_out, 0);
+			usb_settoggle(qh->ps.udev, epnum, is_out, 0);
 			qh->exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);

commit 27c4a31d6739095d613c6e72fb44867bc28c699f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:28:44 2013 -0400

    USB: EHCI: change toggle only upon successful reset
    
    ehci-hcd uses a value of 0 in an endpoint's toggle flag to indicate
    that the endpoint has been reset (and therefore the Data Toggle bit
    needs to be cleared in the endpoint's QH overlay region).
    
    The toggle flag should be set to 0 only when ehci_endpoint_reset()
    succeeds.  This patch moves the usb_settoggle() call into the
    appropriate branch of the "if" statement.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3e3ca839e6ce..652018f93632 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1022,7 +1022,6 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * the toggle bit in the QH.
 	 */
 	if (qh) {
-		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
 		} else {
@@ -1030,6 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			usb_settoggle(qh->dev, epnum, is_out, 0);
 			qh->exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);

commit a60f4f81e4738d1b20cdb9369060211278f177a5
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Sat Sep 21 16:44:42 2013 +0530

    USB: EHCI: make ehci-w90X900 a separate driver
    
    Separate the W90X900(W90P910) on-chip host controller driver from
    ehci-hcd host code so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM;
    however, note that other changes are still needed before W90X900(W90P910)
    can be booted with a multi-platform kernel
    
    and an ehci driver that only works on one of them.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the w90X900 bus glue.
    
    This patch is rebased on greghk/usb-next 3.12 rc1.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Signed-off-by: Deepak Saxena <dsaxena@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5d6022f30ebe..3e3ca839e6ce 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1238,11 +1238,6 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
-#ifdef CONFIG_USB_W90X900_EHCI
-#include "ehci-w90x900.c"
-#define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
-#endif
-
 #ifdef CONFIG_USB_OCTEON_EHCI
 #include "ehci-octeon.c"
 #define PLATFORM_DRIVER		ehci_octeon_driver

commit c04ee4b1136e462722567cf6e76bb35a181574a7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 23 13:32:51 2013 -0700

    Revert "Revert "USB: EHCI: support running URB giveback in tasklet context""
    
    This reverts commit 3b8d7321ed4b8511e17048303b806ffcc2806077, which
    brings back commit 428aac8a81058e2303677a8fbf26670229e51d3a as it should
    be working for the 3.13-rc1 merge window now that Alan's other fixes are
    here in the tree already.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 86ab9fd9fe9e..5d6022f30ebe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1158,7 +1158,7 @@ static const struct hc_driver ehci_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2,
+	.flags =		HCD_MEMORY | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit 3b8d7321ed4b8511e17048303b806ffcc2806077
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Sep 12 13:58:42 2013 -0700

    Revert "USB: EHCI: support running URB giveback in tasklet context"
    
    This reverts commit 428aac8a81058e2303677a8fbf26670229e51d3a.
    
    This isn't quite ready for 3.12, we need some more EHCI driver changes
    that are just now showing up.  So revert this for now, and queue it up
    later for 3.13.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5d6022f30ebe..86ab9fd9fe9e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1158,7 +1158,7 @@ static const struct hc_driver ehci_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2 | HCD_BH,
+	.flags =		HCD_MEMORY | HCD_USB2,
 
 	/*
 	 * basic lifecycle operations

commit eb5ea7300d48c52b028966a6e59f9244faa930d0
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Thu Aug 29 11:45:11 2013 +0300

    ehci: remove debugging statement with ehci statistics in ehci_stop()
    
    This patch removes the ehci statictics information output in ehci_stop()
    because they do not provide interesting info. At any case, the current
    statistics can be viewed by reading the 'registers' file in debugfs.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 103d0767b673..5d6022f30ebe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -440,14 +440,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 	if (ehci->amd_pll_fix == 1)
 		usb_amd_dev_put();
 
-#ifdef	EHCI_STATS
-	ehci_dbg(ehci, "irq normal %ld err %ld iaa %ld (lost %ld)\n",
-		ehci->stats.normal, ehci->stats.error, ehci->stats.iaa,
-		ehci->stats.lost_iaa);
-	ehci_dbg (ehci, "complete %ld unlink %ld\n",
-		ehci->stats.complete, ehci->stats.unlink);
-#endif
-
 	dbg_status (ehci, "ehci_stop completed",
 		    ehci_readl(ehci, &ehci->regs->status));
 }

commit 1512c91f1c7633b031f69d43f1d3523b29e77593
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Thu Aug 29 11:45:13 2013 +0300

    ehci: enable debugging code when CONFIG_DYNAMIC_DEBUG is set
    
    The debugging code for ehci is enabled to run if the DEBUG flag is defined.
    This patch enables the debugging code also when the kernel is configured
    with dynamic debugging on.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 73c72997cd4f..103d0767b673 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1300,7 +1300,7 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
-#ifdef DEBUG
+#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
 	ehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);
 	if (!ehci_debug_root) {
 		retval = -ENOENT;
@@ -1349,7 +1349,7 @@ static int __init ehci_hcd_init(void)
 	platform_driver_unregister(&PLATFORM_DRIVER);
 clean0:
 #endif
-#ifdef DEBUG
+#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
 err_debug:
@@ -1373,7 +1373,7 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
-#ifdef DEBUG
+#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
 	debugfs_remove(ehci_debug_root);
 #endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);

commit 428aac8a81058e2303677a8fbf26670229e51d3a
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:11 2013 +0800

    USB: EHCI: support running URB giveback in tasklet context
    
    All 4 transfer types can work well on EHCI HCD after switching to run
    URB giveback in tasklet context, so mark all HCD drivers to support
    it.
    
    Also we don't need to release ehci->lock during URB giveback any more.
    
    >From below test results on 3 machines(2 ARM and one x86), time
    consumed by EHCI interrupt handler droped much without performance
    loss.
    
    1 test description
    1.1 mass storage performance test:
    - run below command 10 times and compute the average performance
    
        dd if=/dev/sdN iflag=direct of=/dev/null bs=200M count=1
    
    - two usb mass storage device:
    A: sandisk extreme USB 3.0 16G(used in test case 1 & case 2)
    B: kingston DataTraveler G2 4GB(only used in test case 2)
    
    1.2 uvc function test:
    - run one simple capture program in the below link
    
       http://kernel.ubuntu.com/~ming/up/capture.c
    
    - capture format 640*480 and results in High Bandwidth mode on the
    uvc device: Z-Star 0x0ac8/0x3450
    
    - on T410(x86) laptop, also use guvcview to watch video capture/playback
    
    1.3 about test2 and test4
    - both two devices involved are tested concurrently by above test items
    
    1.4 how to compute irq time(the time consumed by ehci_irq)
    - use trace points of irq:irq_handler_entry and irq:irq_handler_exit
    
    1.5 kernel
    3.10.0-rc3-next-20130528
    
    1.6 test machines
    Pandaboard A1: ARM CortexA9 dural core
    Arndale board: ARM CortexA15 dural core
    T410: i5 CPU 2.67GHz quad core
    
    2 test result
    2.1 test case1: single mass storage device performance test
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  25.280(avg:145,max:772) | 25.540(avg:14, max:75)
    Arndale board:  29.700(avg:33, max:129) | 29.700(avg:10,  max:50)
    T410:           34.430(avg:17, max:154*)| 34.660(avg:12, max:155)
    ---------------------------------------------------------------------
    
    2.2 test case2: two mass storage devices' performance test
    --------------------------------------------------------------------
                    upstream                        | patched
                    perf(MB/s)+irq time(us)         | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  15.840/15.580(avg:158,max:1216) | 16.500/16.160(avg:15,max:139)
    Arndale board:  17.370/16.220(avg:33 max:234)   | 17.480/16.200(avg:11, max:91)
    T410:           21.180/19.820(avg:18 max:160)   | 21.220/19.880(avg:11, max:149)
    ---------------------------------------------------------------------
    
    2.3 test case3: one uvc streaming test
    - uvc device works well(on x86, luvcview can be used too and has
    same result with uvc capture)
    --------------------------------------------------------------------
                    upstream                | patched
                    irq time(us)            | irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  (avg:445, max:873)      | (avg:33, max:44)
    Arndale board:  (avg:316, max:630)      | (avg:20, max:27)
    T410:           (avg:39,  max:107)      | (avg:10, max:65)
    ---------------------------------------------------------------------
    
    2.4 test case4: one uvc streaming plus one mass storage device test
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  20.340(avg:259,max:1704)| 20.390(avg:24, max:101)
    Arndale board:  23.460(avg:124,max:726) | 23.370(avg:15, max:52)
    T410:           28.520(avg:27, max:169) | 28.630(avg:13, max:160)
    ---------------------------------------------------------------------
    
    2.5 test case5: read single mass storage device with small transfer
    - run below command 10 times and compute the average speed
    
     dd if=/dev/sdN iflag=direct of=/dev/null bs=4K count=4000
    
    1), test device A:
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  6.5(avg:21, max:64)     | 6.5(avg:10, max:24)
    Arndale board:  8.13(avg:12, max:23)    | 8.06(avg:7,  max:17)
    T410:           6.66(avg:13, max:131)   | 6.84(avg:11, max:149)
    ---------------------------------------------------------------------
    
    2), test device B:
    --------------------------------------------------------------------
                    upstream                | patched
                    perf(MB/s)+irq time(us) | perf(MB/s)+irq time(us)
    --------------------------------------------------------------------
    Pandaboard A1:  5.5(avg:21,max:43)      | 5.49(avg:10, max:24)
    Arndale board:  5.9(avg:12, max:22)     | 5.9(avg:7, max:17)
    T410:           5.48(avg:13, max:155)   | 5.48(avg:7, max:140)
    ---------------------------------------------------------------------
    
    * On T410, sometimes read ehci status register in ehci_irq takes more
    than 100us, and the problem has been reported on the link:
    
            http://marc.info/?t=137065867300001&r=1&w=2
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7ad9ef8aedee..73c72997cd4f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1166,7 +1166,7 @@ static const struct hc_driver ehci_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2,
+	.flags =		HCD_MEMORY | HCD_USB2 | HCD_BH,
 
 	/*
 	 * basic lifecycle operations

commit 9118f9eb4f1e97a135de3f78853c411befcf9775
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:10 2013 +0800

    USB: EHCI: improve interrupt qh unlink
    
    ehci-hcd currently unlinks an interrupt QH when it becomes empty, that
    is, after its last URB completes.  This works well because in almost
    all cases, the completion handler for an interrupt URB resubmits the
    URB; therefore the QH doesn't become empty and doesn't get unlinked.
    
    When we start using tasklets for URB completion, this scheme won't work
    as well.  The resubmission won't occur until the tasklet runs, which
    will be some time after the completion is queued with the tasklet.
    During that delay, the QH will be empty and so will be unlinked
    unnecessarily.
    
    To prevent this problem, this patch adds a 5-ms time delay before empty
    interrupt QHs are unlinked.  Most often, during that time the interrupt
    URB will be resubmitted and thus we can avoid unlinking the QH.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 387cedf2b698..7ad9ef8aedee 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -487,6 +487,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&ehci->async_unlink);
 	INIT_LIST_HEAD(&ehci->async_idle);
+	INIT_LIST_HEAD(&ehci->intr_unlink_wait);
 	INIT_LIST_HEAD(&ehci->intr_unlink);
 	INIT_LIST_HEAD(&ehci->intr_qh_list);
 	INIT_LIST_HEAD(&ehci->cached_itd_list);

commit 35371e4fbc3e1863a6e7a79b8c17c25cc96a1380
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:09 2013 +0800

    USB: EHCI: improve ehci_endpoint_disable
    
    The patch does the below improvement:
    
    - think QH_STATE_COMPLETING as unlinking state since all URBs on the
    endpoint should be in unlinking or unlinked when doing endpoint_disable()
    
    - add "WARN_ON(!list_empty(&qh->qtd_list));" if qh->qh_state is
    QH_STATE_LINKED because there shouldn't be any active transfer in qh
    
    - when qh->qh_state is QH_STATE_LINKED, the QH(async or periodic)
    should be in its corresponding list, so the search through the async
    list isn't necessary.
    
    - unlink periodic QH to speed up unlinking if the QH is in linked
    state
    
    Basically, only the last one is related with this patchset because
    the assumption of "periodic qh self-unlinks on empty" isn't true
    any more when we introduce unlink-wait for periodic qh.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7abf1ce3a670..387cedf2b698 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -942,7 +942,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	unsigned long		flags;
-	struct ehci_qh		*qh, *tmp;
+	struct ehci_qh		*qh;
 
 	/* ASSERT:  any requests/urbs are being unlinked */
 	/* ASSERT:  nobody can be submitting urbs for this any more */
@@ -972,17 +972,13 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:
-	case QH_STATE_COMPLETING:
-		for (tmp = ehci->async->qh_next.qh;
-				tmp && tmp != qh;
-				tmp = tmp->qh_next.qh)
-			continue;
-		/* periodic qh self-unlinks on empty, and a COMPLETING qh
-		 * may already be unlinked.
-		 */
-		if (tmp)
+		WARN_ON(!list_empty(&qh->qtd_list));
+		if (usb_endpoint_type(&ep->desc) != USB_ENDPOINT_XFER_INT)
 			start_unlink_async(ehci, qh);
+		else
+			start_unlink_intr(ehci, qh);
 		/* FALL THROUGH */
+	case QH_STATE_COMPLETING:	/* already in unlinking */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
 idle_timeout:

commit 9fc5f24e43da17df75af75d446c9d89a4bcfce8c
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Thu Jun 13 11:24:12 2013 -0600

    USB: EHCI: make ehci-tegra a separate driver
    
    Separate the Tegra on-chip host controller driver from
    ehci-hcd host code so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    [swarren, reworked Manjunath's patches to split them more logically,
    minor re-order of added lines to better match layout of other split-up
    HCD drivers and existing code, add MODULE_DEVICE_TABLE, fix
    MODULE_LICENSE, adapted to change in earlier patches which removed the
    ehci_driver_overrides addition, removed all PM code and solved circular
    dependencies.]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e8a6f3dd7357..7abf1ce3a670 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1269,11 +1269,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_TEGRA
-#include "ehci-tegra.c"
-#define PLATFORM_DRIVER		tegra_ehci_driver
-#endif
-
 #ifdef CONFIG_SPARC_LEON
 #include "ehci-grlib.c"
 #define PLATFORM_DRIVER		ehci_grlib_driver

commit 2f3a6b86528994027c8241f9666f0fbcf3d3130b
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Thu Jun 13 11:24:09 2013 -0600

    USB: EHCI: export ehci_handshake for ehci-hcd sub-drivers
    
    In order to split ehci-hcd.c into separate modules, handshake() must be
    exported. Rename the symbol to add an ehci_ prefix, to avoid any naming
    clashes.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    [swarren, split Manjunath's patches more logically, limit this change
    to export just handshake()]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 246e124e6ac5..e8a6f3dd7357 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -139,7 +139,7 @@ static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
 /*-------------------------------------------------------------------------*/
 
 /*
- * handshake - spin reading hc until handshake completes or fails
+ * ehci_handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
  * @mask: bits to look at in result of read
  * @done: value of those bits when handshake succeeds
@@ -155,8 +155,8 @@ static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
  * before driver shutdown. But it also seems to be caused by bugs in cardbus
  * bridge shutdown:  shutting down the bridge before the devices using it.
  */
-static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
-		      u32 mask, u32 done, int usec)
+int ehci_handshake(struct ehci_hcd *ehci, void __iomem *ptr,
+		   u32 mask, u32 done, int usec)
 {
 	u32	result;
 
@@ -172,6 +172,7 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 	} while (usec > 0);
 	return -ETIMEDOUT;
 }
+EXPORT_SYMBOL_GPL(ehci_handshake);
 
 /* check TDI/ARC silicon is in host mode */
 static int tdi_in_host_mode (struct ehci_hcd *ehci)
@@ -212,7 +213,7 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	spin_unlock_irq(&ehci->lock);
 	synchronize_irq(ehci_to_hcd(ehci)->irq);
 
-	return handshake(ehci, &ehci->regs->status,
+	return ehci_handshake(ehci, &ehci->regs->status,
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
@@ -251,7 +252,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	ehci_writel(ehci, command, &ehci->regs->command);
 	ehci->rh_state = EHCI_RH_HALTED;
 	ehci->next_statechange = jiffies;
-	retval = handshake (ehci, &ehci->regs->command,
+	retval = ehci_handshake(ehci, &ehci->regs->command,
 			    CMD_RESET, 0, 250 * 1000);
 
 	if (ehci->has_hostpc) {
@@ -286,7 +287,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci->command << 10) & (STS_ASS | STS_PSS);
-	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp, 16 * 125);
+	ehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp,
+			16 * 125);
 
 	/* then disable anything that's still active */
 	spin_lock_irq(&ehci->lock);
@@ -295,7 +297,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	spin_unlock_irq(&ehci->lock);
 
 	/* hardware can take 16 microframes to turn off ... */
-	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0, 16 * 125);
+	ehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0,
+			16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/

commit 843e56c02d6066ad2d8615562b652ae74b452a0e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 2 17:16:19 2013 +0200

    USB: EHCI: remove bogus #error
    
    The EHCI host controller driver can be built standalone now,
    without enabling any of the available bus glue drivers, so
    there is not really a reason to error out here:
    
    drivers/usb/host/ehci-hcd.c:1303:2: error:
     #error "missing bus glue for ehci-hcd"  #error "missing bus glue for ehci-hcd"
    
    The alternative would be to change the Kconfig code to build
    the ehci-hcd module only if any of the symbols below are
    in fact enabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 312fc10da3c7..246e124e6ac5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1286,23 +1286,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_sead3_driver
 #endif
 
-#if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
-	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_MXC) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_HCD_ORION) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_HCD_SPEAR) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_S5P) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_HCD_AT91) && \
-	!IS_ENABLED(CONFIG_USB_EHCI_MSM) && \
-	!defined(PLATFORM_DRIVER) && \
-	!defined(PS3_SYSTEM_BUS_DRIVER) && \
-	!defined(OF_PLATFORM_DRIVER) && \
-	!defined(XILINX_OF_PLATFORM_DRIVER)
-#error "missing bus glue for ehci-hcd"
-#endif
-
 static int __init ehci_hcd_init(void)
 {
 	int retval = 0;

commit 61ac6ac8d662ac7ac67c864954d39d1b19948354
Author: Shengzhou Liu <Shengzhou.Liu@freescale.com>
Date:   Wed Apr 17 18:03:46 2013 +0800

    usb: remove redundant tdi_reset
    
    We remove the redundant tdi_reset in ehci_setup since there
    is already it in ehci_reset.
    It was observed that the duplicated tdi_reset was causing
    the PHY_CLK_VALID bit unstable.
    
    Reported-by: Michael Braun <michael-dev@fami-braun.de>
    Signed-off-by: Shengzhou Liu <Shengzhou.Liu@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org> # 3.6+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2e0c2bd6495f..312fc10da3c7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -673,9 +673,6 @@ int ehci_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
-	if (ehci_is_TDI(ehci))
-		tdi_reset(ehci);
-
 	ehci_reset(ehci);
 
 	return 0;

commit 8c68e84f3a0361bf6053a055643a6ff18c7d86d4
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue Apr 2 18:24:03 2013 +0200

    USB: EHCI: make ehci-msm a separate driver
    
    Separate the  Qualcomm QSD/MSM on-chip host controller driver from
    ehci-hcd host code so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM;
    however, note that other changes are still needed before Qualcomm QSD/MSM
    can be booted with a multi-platform kernel, which is not expected before
    3.11.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the msm bus glue.
    
    In V5 (arnd):
     - add FIXME about missing usb_add_hcd() or usb_remove_hcd() calls
    
    In V3:
     - Detailed commit message added here describing why this patch is required.
     - Arranged  #include's in alphabetical order.
     - driver.name initialized hcd_name[] = "ehci-msm" in platform_driver
       structure initialization instead of "msm-ehci", which was the reason
       why it broke in EHCI USB testing
    
    In V2:
    Tegra patch related changes removed from this patch.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brown <davidb@codeaurora.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ccc78abd4500..2e0c2bd6495f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1259,11 +1259,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_MSM
-#include "ehci-msm.c"
-#define PLATFORM_DRIVER		ehci_msm_driver
-#endif
-
 #ifdef CONFIG_TILE_USB
 #include "ehci-tilegx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_tilegx_driver
@@ -1303,6 +1298,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_SPEAR) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_S5P) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_AT91) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_MSM) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 9773696105534dd5193576adfe4a0117a6489c64
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue Apr 2 18:24:02 2013 +0200

    USB: EHCI: make ehci-atmel a separate driver
    
    Separate the Atmel host controller driver from ehci-hcd host code
    so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM;
    however, note that other changes are still needed before Atmel can be
    booted with a multi-platform kernel. This is currently planned for
    Linux-3.11.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the Atmel bus glue.
    
    In V4 (arnd):
     - reordered #include statements.
     - removed call to ehci_shutdown and the corresponding export
    
    In V3:
     - Detailed commit message added here about why this patch is required.
     - Replaced hcd_name string "ehci-atmel" to "atmel-ehci".
     - Inserted blank line in the Makefile to separate the EHCI drivers from
       the following non-EHCI drivers.
     - Exported ehci_shutdown symbol as it is needed by the Atmel driver.
     - Eliminated ehci_atmel_setup routine because hcd registers
       can be directly set in the ehci_atmel_drv_probe function.
    
    In V2:
      Resolved below compiler error.
      drivers/usb/host/ehci-atmel.c: In function 'ehci_atmel_drv_remove':
      drivers/usb/host/ehci-atmel.c:167: error: implicit declaration of function 'ehci_shutdown'
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Andrew Victor <linux@maxim.org.za>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8f1f4b489a68..ccc78abd4500 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1254,11 +1254,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
 #endif
 
-#ifdef CONFIG_ARCH_AT91
-#include "ehci-atmel.c"
-#define	PLATFORM_DRIVER		ehci_atmel_driver
-#endif
-
 #ifdef CONFIG_USB_OCTEON_EHCI
 #include "ehci-octeon.c"
 #define PLATFORM_DRIVER		ehci_octeon_driver
@@ -1307,6 +1302,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_ORION) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_SPEAR) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_S5P) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_AT91) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 7edb3daf78e5124b64a39b6eb264ec2a487e295a
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue Apr 2 18:24:01 2013 +0200

    USB: EHCI: make ehci-s5p a separate driver
    
    Separate the  Samsung S5P/EXYNOS host controller driver from ehci-hcd
    host code so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM;
    however, note that other changes are still needed before S5P/EXYNOS can
    be booted with a multi-platform kernel. We currently expect those
    to get merged for 3.10.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the s5p bus glue.
    
    In V4 (arnd)
     - revert some of the pointless changes.
     - fix allocation of s5p specific data structure.
    
    In V3:
     - Detailed commit message added here, why this patch is required.
     - MODULE_LICENSE is GPL v2.
     - Added .extra_priv_size to eliminate the separate allocation of
       the s5p_ehci_hcd structure and removed .reset function pointer
       initialization.
     - Arranged  #include's in alphabetical order.
     - After using extra_priv_size initialization, struct usb_hcd *hcd
       is redundant and can be removed from the probe function.
     - Eliminated s5p_ehci_phy_enable,contents of statements moved
       into the s5p_ehci_probe
     - Eliminated s5p_ehci_phy_disable, contents of statements moved into
       the s5p_ehci_remove.
    
    In V2:
     - Tegra patch related changes removed from this patch.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c8c70a1fabc4..8f1f4b489a68 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1284,11 +1284,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		tegra_ehci_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_S5P
-#include "ehci-s5p.c"
-#define PLATFORM_DRIVER		s5p_ehci_driver
-#endif
-
 #ifdef CONFIG_SPARC_LEON
 #include "ehci-grlib.c"
 #define PLATFORM_DRIVER		ehci_grlib_driver
@@ -1311,6 +1306,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_ORION) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_SPEAR) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_S5P) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 7675d6ba436f8439fc524ee0b42dc562cb1bc74e
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue Apr 2 18:24:00 2013 +0200

    USB: EHCI: make ehci-spear a separate driver
    
    Separate the SPEAr host controller driver from ehci-hcd host code
    so that it can be built as a separate driver module.
    This work is part of enabling multi-platform kernels on ARM;
    however, note that other changes are still needed before SPEAr can be
    booted with a multi-platform kernel, but they are queued in the
    arm-soc tree for 3.10.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the SPEAr bus glue.
    
    In V4 (arnd):
     - renamed all 'struct spear_ehci' pointers from 'ehci' to the
       less ambiguous 'sehci'.
     - folded trivial spear_start_ehci/spear_stop_ehci functions into
       callers.
     - brought back initialization of ehci->caps.
    
    In V3:
     - Detailed commit message added here about why this patch is required.
     - Eliminated ehci_spear_setup routine because hcd registers can
       be directly set in the spear_ehci_hcd_drv_probe function.
     - spear_overrides struct initialized.
     - Converted to using .extra_priv_size for allocating spear_ehci,
       and updated all users of that structure.
     - to_spear_ehci() macro modified for spear_ehci.
    
    In V2:
     - Replaced spear as SPEAr everywhere, leaving functions/variables/config options.
    
    Signed-off-by: Deepak Saxena <dsaxena@linaro.org>
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Viresh Kumar <viresh.linux@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: spear-devel@list.st.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1f97268bb5d6..c8c70a1fabc4 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1264,11 +1264,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
-#ifdef CONFIG_PLAT_SPEAR
-#include "ehci-spear.c"
-#define PLATFORM_DRIVER		spear_ehci_hcd_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_MSM
 #include "ehci-msm.c"
 #define PLATFORM_DRIVER		ehci_msm_driver
@@ -1315,6 +1310,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_MXC) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_ORION) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_SPEAR) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit a76dd463c58efa5dfd72c3dd41f5a76b196f7ab1
Author: Manjunath Goudar <manjunath.goudar@linaro.org>
Date:   Tue Apr 2 18:23:59 2013 +0200

    USB: EHCI: make ehci-orion a separate driver
    
    Separate the Orion host controller driver from ehci-hcd host
    code into its own driver module because of following reason.
    
    With the multiplatform changes in arm-soc tree, it becomes
    possible to enable the mvebu platform (which uses
    ehci-orion) at the same time as other platforms that require
    a conflicting EHCI bus glue. At the moment, this results
    in a warning like
    
    drivers/usb/host/ehci-hcd.c:1297:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1277:0: note: this is the location of the previous definition
    drivers/usb/host/ehci-orion.c:334:31: warning: 'ehci_orion_driver' defined but not used [-Wunused-variable]
    
    and an ehci driver that only works on one of them.
    
    With the infrastructure added by Alan Stern in patch 3e0232039
    "USB: EHCI: prepare to make ehci-hcd a library module", we can
    avoid this problem by turning a bus glue into a separate
    module, as we do here for the orion bus glue.
    
    An earlier version of this patch was included in 3.9 but caused
    a regression there, which has subsequently been fixed.
    
    While we are here, use the opportunity to disabiguate the two
    Marvell EHCI controller implementations in Kconfig.
    
    In V4 (arnd):
    - Improve Kconfig text
    
    In V3:
    - More detail provided in commit message regarding this patch.
    - Replaced hcd_name string "ehci-orion" into "orion-ehci".
    - MODULE_LICENSE is GPL v2.
    - In ehci_init_driver calling second argument passed  as NULL instead of
      ehci_orion_overrides because ehci_orion_overrides is removed.
    
    In V2:
    - Tegra patch related changes removed from this patch.
    
    Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b12b97d2ccaf..1f97268bb5d6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1249,11 +1249,6 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
-#ifdef CONFIG_PLAT_ORION
-#include "ehci-orion.c"
-#define	PLATFORM_DRIVER		ehci_orion_driver
-#endif
-
 #ifdef CONFIG_USB_W90X900_EHCI
 #include "ehci-w90x900.c"
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
@@ -1319,6 +1314,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_MXC) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_ORION) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit f3bc64d6d1f21c1b92d75f233a37b75d77af6963
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 27 21:44:22 2013 +0000

    USB: EHCI: DT support for generic bus glue
    
    This lets us use the ehci-platform driver on platforms without special
    requirements for their ehci controllers. In particular, this is true
    for the vt8500/wm8x50 platforms, which currently have a separate
    driver that causes problems with multiplatform configurations.
    
    Tested-by: Tony Prisk <linux@prisktech.co.nz>
    Tested-by: Peter Vasil <petervasil@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 037a4729d549..b12b97d2ccaf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1269,11 +1269,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
-#ifdef CONFIG_ARCH_VT8500
-#include "ehci-vt8500.c"
-#define	PLATFORM_DRIVER		vt8500_ehci_driver
-#endif
-
 #ifdef CONFIG_PLAT_SPEAR
 #include "ehci-spear.c"
 #define PLATFORM_DRIVER		spear_ehci_hcd_driver

commit 214ac7a0771d95d2f66d01bca5afeb2c9e8ac3c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:58 2013 -0400

    USB: EHCI: improve end_unlink_async()
    
    This patch (as1665) changes the way ehci-hcd's end_unlink_async()
    routine works in order to avoid recursive execution and to be more
    efficient:
    
            Now when an IAA cycle ends, a new one gets started up right
            away (if it is needed) instead of waiting until the
            just-unlinked QH has been processed.
    
            The async_iaa list is renamed to async_idle, which better
            expresses its new purpose: It is now the list of QHs which are
            now completely idle and are waiting to be processed by
            end_unlink_async().
    
            A new flag is added to track whether an IAA cycle is in
            progress, because the list formerly known as async_iaa no
            longer stores the QHs waiting for the IAA to finish.
    
            The decision about how many QHs to process when an IAA cycle
            ends is now made at the end of the cycle, when we know the
            current state of the hardware, rather than at the beginning.
            This means a bunch of logic got moved from start_iaa_cycle()
            to end_unlink_async().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b32323ca07d3..037a4729d549 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -483,7 +483,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&ehci->async_unlink);
-	INIT_LIST_HEAD(&ehci->async_iaa);
+	INIT_LIST_HEAD(&ehci->async_idle);
 	INIT_LIST_HEAD(&ehci->intr_unlink);
 	INIT_LIST_HEAD(&ehci->intr_qh_list);
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
@@ -752,7 +752,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (!list_empty(&ehci->async_iaa))
+		if (ehci->iaa_in_progress)
 			COUNT(ehci->stats.iaa);
 		end_unlink_async(ehci);
 	}

commit 6e018751a35f6ef7ad04eb8006b5886b6a7c47f5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:45 2013 -0400

    USB: EHCI: convert singly-linked lists to list_heads
    
    This patch (as1664) converts ehci-hcd's async_unlink, async_iaa, and
    intr_unlink from singly-linked lists to standard doubly-linked
    list_heads.  Originally it didn't seem necessary to use list_heads,
    because items are always added to and removed from these lists in FIFO
    order.  But now with more list processing going on, it's easier to use
    the standard routines than continue with a roll-your-own approach.
    
    I don't know if the code ends up being notably shorter, but the
    patterns will be more familiar to any kernel hacker.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 87fe3daaa092..b32323ca07d3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -482,6 +482,9 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&ehci->async_unlink);
+	INIT_LIST_HEAD(&ehci->async_iaa);
+	INIT_LIST_HEAD(&ehci->intr_unlink);
 	INIT_LIST_HEAD(&ehci->intr_qh_list);
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
@@ -749,7 +752,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci->async_iaa)
+		if (!list_empty(&ehci->async_iaa))
 			COUNT(ehci->stats.iaa);
 		end_unlink_async(ehci);
 	}

commit 7655e3160c78a18c2ecf7bf4dee0bbfe58575c7f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:29 2013 -0400

    USB: EHCI: consolidate code in ehci_urb_dequeue()
    
    This patch (as1668) consolidates two nearly identical code paths in
    ehci_urb_dequeue().  The test for !qh can be removed because it will
    never succeed; the fact that usb_hcd_check_unlink_urb() returned 0
    means that urb must be queued and therefore urb->hcpriv must point to
    a QH.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 93f4cd75845e..87fe3daaa092 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -896,17 +896,21 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	if (rc)
 		goto done;
 
-	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
-	default:
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		/*
+		 * We don't expedite dequeue for isochronous URBs.
+		 * Just wait until they complete normally or their
+		 * time slot expires.
+		 */
+	} else {
 		qh = (struct ehci_qh *) urb->hcpriv;
-		if (!qh)
-			break;
 		qh->exception = 1;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
-			start_unlink_async(ehci, qh);
+			if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT)
+				start_unlink_intr(ehci, qh);
+			else
+				start_unlink_async(ehci, qh);
 			break;
 		case QH_STATE_COMPLETING:
 			qh->dequeue_during_giveback = 1;
@@ -920,36 +924,6 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			qh_completions(ehci, qh);
 			break;
 		}
-		break;
-
-	case PIPE_INTERRUPT:
-		qh = (struct ehci_qh *) urb->hcpriv;
-		if (!qh)
-			break;
-		qh->exception = 1;
-		switch (qh->qh_state) {
-		case QH_STATE_LINKED:
-			start_unlink_intr(ehci, qh);
-			break;
-		case QH_STATE_COMPLETING:
-			qh->dequeue_during_giveback = 1;
-			break;
-		case QH_STATE_IDLE:
-			qh_completions (ehci, qh);
-			break;
-		default:
-			ehci_dbg (ehci, "bogus qh %p state %d\n",
-					qh, qh->qh_state);
-			goto done;
-		}
-		break;
-
-	case PIPE_ISOCHRONOUS:
-		// itd or sitd ...
-
-		// wait till next completion, do it then.
-		// completion irqs can wait up to 1024 msec,
-		break;
 	}
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);

commit 7bc782d73c7db042ecc965866b8c1c2b7d6e93d6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:11 2013 -0400

    USB: EHCI: split needs_rescan into two flags
    
    This patch (as1662) does some more QH-related cleanup in ehci-hcd.
    The qh->needs_rescan flag is currently used for two different
    purposes; the patch replaces it with two separate flags for greater
    clarity: qh->dequeue_during_giveback indicates that a completion
    handler dequeued an URB (implying that a rescan is needed), and
    qh->exception indicates that the QH is in an exceptional state
    requiring an unlink (either it encountered an I/O error or an unlink
    was requested).
    
    The new flags get set where the dequeue, exception, or unlink request
    occurred, rather than where the unlink is started.  This is so that in
    the future, if we need to, we will be able to tell apart unlinks that
    truly were required from those that were carried out merely because
    the QH wasn't being used.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 0c3314c41363..93f4cd75845e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,11 +903,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
+		qh->exception = 1;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_async(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh->dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
 			/* already started */
@@ -923,11 +926,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
+		qh->exception = 1;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_intr(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh->dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -984,6 +990,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto done;
 	}
 
+	qh->exception = 1;
 	if (ehci->rh_state < EHCI_RH_RUNNING)
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
@@ -1052,13 +1059,12 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh->qh_state == QH_STATE_LINKED ||
-				qh->qh_state == QH_STATE_COMPLETING) {
-
+		} else {
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			qh->exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
 			else

commit cf2d9500a5a0df61713b56f2f40aa0b81a6f9f63
Merge: 3f3b55bf7833 d714aaf64946
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Mar 20 16:21:47 2013 -0700

    Merge branch 'usb-linus' into usb-next
    
    This is to pick up the fixes in that branch, and let Alan fix the merge
    error in drivers/usb/host/ehci-timer.c better than I just did (as I know
    I messed it up...)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4dd405a4b0969bfec4dc9959050b46d818b6549b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 18 12:05:08 2013 -0400

    USB: EHCI: improve use of per-port status-change bits
    
    This patch (as1634) simplifies some of the code associated with the
    per-port change bits added in EHCI-1.1, and in particular it fixes a
    bug in the logic of ehci_hub_status_data().  Even if the change bit
    doesn't indicate anything happened on a particular port, we still have
    to notify the core about changes to the suspend or reset status.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 303b0222cd6d..fcf8b940e867 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -758,7 +758,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
-		u32		ppcd = 0;
+		u32		ppcd = ~0;
 
 		/* kick root hub later */
 		pcd_status = status;
@@ -775,7 +775,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			int pstatus;
 
 			/* leverage per-port change bits feature */
-			if (ehci->has_ppcd && !(ppcd & (1 << i)))
+			if (!(ppcd & (1 << i)))
 				continue;
 			pstatus = ehci_readl(ehci,
 					 &ehci->regs->port_status[i]);

commit 2a40f324541ee61c22146214349c2ce9f5c30bcf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 15 14:40:26 2013 -0400

    USB: EHCI: fix regression during bus resume
    
    This patch (as1663) fixes a regression caused by commit
    6e0c3339a6f19d748f16091d0a05adeb1e1f822b (USB: EHCI: unlink one async
    QH at a time).  In order to avoid keeping multiple QHs in an unusable
    intermediate state, that commit changed unlink_empty_async() so that
    it unlinks only one empty QH at a time.
    
    However, when the EHCI root hub is suspended, _all_ async QHs need to
    be unlinked.  ehci_bus_suspend() used to do this by calling
    unlink_empty_async(), but now this only unlinks one of the QHs, not
    all of them.
    
    The symptom is that when the root hub is resumed, USB communications
    don't work for some period of time.  This is because ehci-hcd doesn't
    realize it needs to restart the async schedule; it assumes that
    because some QHs are already on the schedule, the schedule must be
    running.
    
    The easiest way to fix the problem is add a new function that unlinks
    all the async QHs when the root hub is suspended.
    
    This patch should be applied to all kernels that have the 6e0c3339a6f1
    commit.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Adrian Bassett <adrian.bassett@hotmail.co.uk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5726cb144abf..416a6dce5e11 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -302,6 +302,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);

commit 54a419668b0f27b7982807fb2376d237e0a0ce05
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Mar 12 12:44:39 2013 +0200

    USB: EHCI: split ehci-omap out to a separate driver
    
    This patch (as1645) converts ehci-omap over to the new "ehci-hcd is a
    library" approach, so that it can coexist peacefully with other EHCI
    platform drivers and can make use of the private area allocated at
    the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..303b0222cd6d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1252,11 +1252,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_HCD_OMAP
-#include "ehci-omap.c"
-#define        PLATFORM_DRIVER         ehci_hcd_omap_driver
-#endif
-
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
@@ -1346,6 +1341,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_MXC) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 6402c796d3b4205d3d7296157956c5100a05d7d6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 1 10:50:08 2013 -0500

    USB: EHCI: work around silicon bug in Intel's EHCI controllers
    
    This patch (as1660) works around a hardware problem present in some
    (if not all) Intel EHCI controllers.  After a QH has been unlinked
    from the async schedule and the corresponding IAA interrupt has
    occurred, the controller is not supposed access the QH and its qTDs.
    There certainly shouldn't be any more DMA writes to those structures.
    Nevertheless, Intel's controllers have been observed to perform a
    final writeback to the QH's overlay region and to the most recent qTD.
    For more information and a test program to determine whether this
    problem is present in a particular controller, see
    
            http://marc.info/?l=linux-usb&m=135492071812265&w=2
            http://marc.info/?l=linux-usb&m=136182570800963&w=2
    
    This patch works around the problem by always waiting for two IAA
    cycles when unlinking an async QH.  The extra IAA delay gives the
    controller time to perform its final writeback.
    
    Surprisingly enough, the effects of this silicon bug have gone
    undetected until quite recently.  More through luck than anything
    else, it hasn't caused any apparent problems.  However, it does
    interact badly with the path that follows this one, so it needs to be
    addressed.
    
    This is the first part of a fix for the regression reported at:
    
            https://bugs.launchpad.net/bugs/1088733
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Stephen Thirlwall <sdt@dr.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..5726cb144abf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -748,11 +748,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci->async_iaa) {
+		if (ehci->async_iaa)
 			COUNT(ehci->stats.iaa);
-			end_unlink_async(ehci);
-		} else
-			ehci_dbg(ehci, "IAA with nothing unlinked?\n");
+		end_unlink_async(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */

commit f292e7f9fb0e4bec68bbd83443407d6bb7922d36
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 25 17:09:49 2013 -0500

    USB: EHCI: notify usbcore about port resumes
    
    This patch (as1650) adds calls to the new
    usb_hcd_{start,end}_port_resume() functions to ehci-hcd.  Now EHCI
    root hubs won't be runtime suspended while they are sending a resume
    signal to one of their ports.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 09537b2f1002..b416a3fc9959 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -797,6 +797,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
 			set_bit(i, &ehci->resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			usb_hcd_start_port_resume(&hcd->self, i);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}
 	}

commit dba63b2f733ebfd89bbb15e8fe8ca10fd3871a7f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jan 23 13:26:15 2013 -0500

    USB: EHCI: fix build error in ehci-mxc
    
    This patch (as1643b) fixes a build error in ehci-hcd when compiling for
    ARM with allmodconfig:
    
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    drivers/usb/host/ehci-mxc.c:280:31: warning: 'ehci_mxc_driver' defined but not used [-Wunused-variable]
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    
    The fix is to convert ehci-mxc over to the new "ehci-hcd is a library"
    scheme so that it can coexist peacefully with the ehci-platform
    driver.  As part of the conversion the ehci_mxc_priv data structure,
    which was allocated dynamically, is now placed where it belongs: in
    the private area at the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d09ff8f294fe..09537b2f1002 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1246,11 +1246,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_MXC
-#include "ehci-mxc.c"
-#define PLATFORM_DRIVER		ehci_mxc_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
@@ -1349,6 +1344,7 @@ MODULE_LICENSE ("GPL");
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_MXC) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 9ce45ef86c4c861841ba68b24341dbd9d6834c98
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 22 12:00:12 2013 -0500

    USB: EHCI: fix incorrect configuration test
    
    This patch (as1641) fixes a minor bug in ehci-hcd left over from when
    the Chipidea driver was converted to the "ehci-hcd is a library"
    scheme.  The test for whether the Chipidea platform driver is active
    should be IS_ENABLED(), not defined().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 104d6348377e..d09ff8f294fe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1348,7 +1348,7 @@ MODULE_LICENSE ("GPL");
 
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
-	!defined(CONFIG_USB_CHIPIDEA_HOST) && \
+	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit 9ec6e9d3cb5192b11074f8adcedc10a6d410528a
Author: Roger Quadros <rogerq@ti.com>
Date:   Tue Jan 22 11:59:58 2013 -0500

    USB: EHCI: Move definition of EHCI_STATS to ehci.h
    
    Without this, platform drivers e.g. ehci-omap.c will see a
    different version of struct ehci_hcd than ehci-hcd.c and
    break reference to 'debug_dir' and 'priv' members when
    CONFIG_USB_DEBUG is enabled.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c97503bb0b0e..104d6348377e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -74,10 +74,6 @@ static const char	hcd_name [] = "ehci_hcd";
 #undef VERBOSE_DEBUG
 #undef EHCI_URB_TRACE
 
-#ifdef DEBUG
-#define EHCI_STATS
-#endif
-
 /* magic numbers that can affect system performance */
 #define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
 #define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */

commit 1b36810e27a9791878e4694357ab6d4c06acc22d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 7 16:12:47 2012 -0500

    USB: EHCI: miscellaneous cleanups for the library conversion
    
    This patch (as1630) cleans up a few minor items resulting from the
    split-up of the ehci-hcd driver:
    
            Remove the product_desc string from the ehci_driver_overrides
            structure.  All drivers will use the generic "EHCI Host
            Controller" string.  (This was requested by Felipe Balbi.)
    
            Allow drivers to pass a NULL pointer to ehci_init_driver()
            if they don't have to override any settings.
    
            Remove a #define symbol that is no longer used from the
            ChipIdea host driver.
    
            Rename overrides to pci_overrides in ehci-pci.c, for
            consistency with ehci-platform.c.
    
            Mark the *_overrides structures as __initdata.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 28f694eb624b..c97503bb0b0e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1231,10 +1231,11 @@ void ehci_init_driver(struct hc_driver *drv,
 	/* Copy the generic table to drv and then apply the overrides */
 	*drv = ehci_hc_driver;
 
-	drv->product_desc = over->product_desc;
-	drv->hcd_priv_size += over->extra_priv_size;
-	if (over->reset)
-		drv->reset = over->reset;
+	if (over) {
+		drv->hcd_priv_size += over->extra_priv_size;
+		if (over->reset)
+			drv->reset = over->reset;
+	}
 }
 EXPORT_SYMBOL_GPL(ehci_init_driver);
 

commit 09f6ffde2ecef4cc4e2a5edaa303210cabd96f57
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 2 12:34:41 2012 -0400

    USB: EHCI: fix build error by making ChipIdea host a normal EHCI driver
    
    This patch (as1627) splits the ehci-hcd core code, which has become a
    separate library module, out from the ChipIdea host driver.  Instead
    of #include-ing ehci-hcd.c directly, the ChipIdea module will now use
    the ehci-hcd library in a normal fashion.
    
    This fixes a build error caused by commit
    3e0232039967d7a1a06c013d097458b4d5892af1 (USB: EHCI: prepare to make
    ehci-hcd a library module); I had forgotten about the unorthodox way
    the ChipIdea driver uses the ehci-hcd code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4a466d7730c5..28f694eb624b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1240,14 +1240,6 @@ EXPORT_SYMBOL_GPL(ehci_init_driver);
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * The EHCI in ChipIdea HDRC cannot be a separate module or device,
- * because its registers (and irq) are shared between host/gadget/otg
- * functions  and in order to facilitate role switching we cannot
- * give the ehci driver exclusive access to those.
- */
-#ifndef CHIPIDEA_EHCI
-
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
@@ -1359,6 +1351,7 @@ MODULE_LICENSE ("GPL");
 
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
+	!defined(CONFIG_USB_CHIPIDEA_HOST) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \
@@ -1464,5 +1457,3 @@ static void __exit ehci_hcd_cleanup(void)
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
-
-#endif /* CHIPIDEA_EHCI */

commit 99f91934a907df31ba878dfdd090002049dc476a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 1 11:13:08 2012 -0400

    USB: EHCI: make ehci-platform a separate driver
    
    This patch (as1626) splits the ehci-platform code from ehci-hcd out
    into its own separate driver module.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7113d6ad24f7..4a466d7730c5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1357,12 +1357,8 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_sead3_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_HCD_PLATFORM
-#include "ehci-platform.c"
-#define PLATFORM_DRIVER		ehci_platform_driver
-#endif
-
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) && \
 	!defined(PLATFORM_DRIVER) && \
 	!defined(PS3_SYSTEM_BUS_DRIVER) && \
 	!defined(OF_PLATFORM_DRIVER) && \

commit adfa79d1c06a32650332930ca4c488ca570b3407
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 1 11:13:04 2012 -0400

    USB: EHCI: make ehci-pci a separate driver
    
    This patch (as1625) splits the PCI portion of ehci-hcd out into its
    own separate driver module, called ehci-pci.  Consistently with the
    current practice, the decision whether to build this module is not
    user-configurable.  If EHCI and PCI are enabled then the module will
    be built, always.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index dee3541bfae8..7113d6ad24f7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1252,11 +1252,6 @@ MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
-#include "ehci-pci.c"
-#define	PCI_DRIVER		ehci_pci_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_FSL
 #include "ehci-fsl.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
@@ -1367,9 +1362,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_platform_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
-    !defined(XILINX_OF_PLATFORM_DRIVER)
+#if !IS_ENABLED(CONFIG_USB_EHCI_PCI) && \
+	!defined(PLATFORM_DRIVER) && \
+	!defined(PS3_SYSTEM_BUS_DRIVER) && \
+	!defined(OF_PLATFORM_DRIVER) && \
+	!defined(XILINX_OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
@@ -1406,12 +1403,6 @@ static int __init ehci_hcd_init(void)
 		goto clean0;
 #endif
 
-#ifdef PCI_DRIVER
-	retval = pci_register_driver(&PCI_DRIVER);
-	if (retval < 0)
-		goto clean1;
-#endif
-
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
 	if (retval < 0)
@@ -1443,10 +1434,6 @@ static int __init ehci_hcd_init(void)
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 clean2:
 #endif
-#ifdef PCI_DRIVER
-	pci_unregister_driver(&PCI_DRIVER);
-clean1:
-#endif
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);
 clean0:
@@ -1472,9 +1459,6 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
-#ifdef PCI_DRIVER
-	pci_unregister_driver(&PCI_DRIVER);
-#endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif

commit 3e0232039967d7a1a06c013d097458b4d5892af1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 1 11:12:58 2012 -0400

    USB: EHCI: prepare to make ehci-hcd a library module
    
    This patch (as1624) prepares ehci-hcd for being split up into a core
    library and separate platform driver modules.  A generic
    ehci_hc_driver structure is created, containing all the "standard"
    values, and a new mechanism is added whereby a driver module can
    specify a set of overrides to those values.  In addition the
    ehci_setup(), ehci_suspend(), and ehci_resume() routines need to be
    EXPORTed for use by the drivers.
    
    As a side effect of this change, a few routines no longer need to be
    marked __maybe_unused.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ab4a769a4104..dee3541bfae8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -649,7 +649,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	return 0;
 }
 
-static int ehci_setup(struct usb_hcd *hcd)
+int ehci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
@@ -680,6 +680,7 @@ static int ehci_setup(struct usb_hcd *hcd)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ehci_setup);
 
 /*-------------------------------------------------------------------------*/
 
@@ -1085,7 +1086,7 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /* These routines handle the generic parts of controller suspend/resume */
 
-static int __maybe_unused ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
@@ -1108,9 +1109,10 @@ static int __maybe_unused ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ehci_suspend);
 
 /* Returns 0 if power was preserved, 1 if power was lost */
-static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
+int ehci_resume(struct usb_hcd *hcd, bool hibernated)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 
@@ -1168,11 +1170,76 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 
 	return 1;
 }
+EXPORT_SYMBOL_GPL(ehci_resume);
 
 #endif
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * Generic structure: This gets copied for platform drivers so that
+ * individual entries can be overridden as needed.
+ */
+
+static const struct hc_driver ehci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ehci_setup,
+	.start =		ehci_run,
+	.stop =			ehci_stop,
+	.shutdown =		ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+	.endpoint_reset =	ehci_endpoint_reset,
+	.clear_tt_buffer_complete =	ehci_clear_tt_buffer_complete,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.bus_suspend =		ehci_bus_suspend,
+	.bus_resume =		ehci_bus_resume,
+	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
+};
+
+void ehci_init_driver(struct hc_driver *drv,
+		const struct ehci_driver_overrides *over)
+{
+	/* Copy the generic table to drv and then apply the overrides */
+	*drv = ehci_hc_driver;
+
+	drv->product_desc = over->product_desc;
+	drv->hcd_priv_size += over->extra_priv_size;
+	if (over->reset)
+		drv->reset = over->reset;
+}
+EXPORT_SYMBOL_GPL(ehci_init_driver);
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * The EHCI in ChipIdea HDRC cannot be a separate module or device,
  * because its registers (and irq) are shared between host/gadget/otg

commit c73cee717e7d5da0698acb720ad1219646fe4f46
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:21:06 2012 -0400

    USB: EHCI: remove ehci_port_power() routine
    
    This patch (as1623) removes the ehci_port_power() routine and all the
    places that call it.  There's no reason for ehci-hcd to change the
    port power settings; the hub driver takes care of all that stuff.
    
    There is one exception: When the controller is resumed from
    hibernation or following a loss of power, the ports that are supposed
    to be handed over to a companion controller must be powered on first.
    Otherwise the handover won't work.  This process is not visible to the
    hub driver, so it has to be handled in ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 68dd1c99b1f5..ab4a769a4104 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -371,24 +371,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	hrtimer_cancel(&ehci->hrtimer);
 }
 
-static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
-{
-	unsigned port;
-
-	if (!HCS_PPC (ehci->hcs_params))
-		return;
-
-	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
-		(void) ehci_hub_control(ehci_to_hcd(ehci),
-				is_on ? SetPortFeature : ClearPortFeature,
-				USB_PORT_FEAT_POWER,
-				port--, NULL, 0);
-	/* Flush those writes */
-	ehci_readl(ehci, &ehci->regs->command);
-	msleep(20);
-}
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1184,9 +1166,6 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	ehci->rh_state = EHCI_RH_SUSPENDED;
 	spin_unlock_irq(&ehci->lock);
 
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
 	return 1;
 }
 

commit 4968f951913997adc8c68c4e986e8168ee1d2998
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 31 13:12:11 2012 -0400

    USB: EHCI: remove unused Link Power Management code
    
    This patch (as1622) removes the USB-2.1 Link Power Management code
    from the ehci-hcd driver.  This code was never integrated with
    usbcore, it is full of bugs, and it was not getting used by anybody.
    
    However, the debugging code for dumping the LPM-related fields in the
    EHCI registers is left in place.  In theory it might be useful to see
    these values, even though we don't use them.
    
    This essentially amounts to a partial revert of commit
    aa4d8342988d0c1a79ff19b2ede1e81dfbb16ea5 (USB: EHCI: EHCI 1.1
    addendum: preparation) and an almost full revert of commit
    48f24970144479c29b8cee6d2e1dbedf6dcf9cfb (USB: EHCI: EHCI 1.1
    addendum: Basic LPM feature support) plus its follow-ons.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9c2afb516fe5..68dd1c99b1f5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -39,7 +39,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/slab.h>
-#include <linux/uaccess.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -108,11 +107,6 @@ static bool ignore_oc = 0;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
-/* for link power management(LPM) feature */
-static unsigned int hird;
-module_param(hird, int, S_IRUGO);
-MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
-
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
 /*-------------------------------------------------------------------------*/
@@ -318,7 +312,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 #include "ehci-timer.c"
 #include "ehci-hub.c"
-#include "ehci-lpm.c"
 #include "ehci-mem.c"
 #include "ehci-q.c"
 #include "ehci-sched.c"
@@ -580,17 +573,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		temp &= ~(3 << 2);
 		temp |= (EHCI_TUNE_FLS << 2);
 	}
-	if (HCC_LPM(hcc_params)) {
-		/* support link power management EHCI 1.1 addendum */
-		ehci_dbg(ehci, "support lpm\n");
-		ehci->has_lpm = 1;
-		if (hird > 0xf) {
-			ehci_dbg(ehci, "hird %d invalid, use default 0",
-			hird);
-			hird = 0;
-		}
-		temp |= hird << 24;
-	}
 	ehci->command = temp;
 
 	/* Accept arbitrarily long scatter-gather lists */

commit acc08503406f97ce6582c92fd8c8139f1e871a96
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 10 15:07:39 2012 -0400

    USB: EHCI: make ehci_read_frame_index platform independent
    
    In preparation for splitting the ehci-hcd driver into a core library
    and separate platform-specific driver modules, this patch (as1617)
    changes the way ehci_read_frame_index() is handled.
    
    Since the same core library will have to work with both PCI and
    non-PCI platforms, the quirk handler routine will be compiled
    unconditionally.  The decision about whether to call it or simply to
    read the frame index register is made at run time, based on whether
    the frame_index_bug quirk flag is set.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 28fb5ddaf786..9c2afb516fe5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -118,9 +118,34 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 /*-------------------------------------------------------------------------*/
 
 #include "ehci.h"
-#include "ehci-dbg.c"
 #include "pci-quirks.h"
 
+/*
+ * The MosChip MCS9990 controller updates its microframe counter
+ * a little before the frame counter, and occasionally we will read
+ * the invalid intermediate value.  Avoid problems by checking the
+ * microframe number (the low-order 3 bits); if they are 0 then
+ * re-read the register to get the correct value.
+ */
+static unsigned ehci_moschip_read_frame_index(struct ehci_hcd *ehci)
+{
+	unsigned uf;
+
+	uf = ehci_readl(ehci, &ehci->regs->frame_index);
+	if (unlikely((uf & 7) == 0))
+		uf = ehci_readl(ehci, &ehci->regs->frame_index);
+	return uf;
+}
+
+static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
+{
+	if (ehci->frame_index_bug)
+		return ehci_moschip_read_frame_index(ehci);
+	return ehci_readl(ehci, &ehci->regs->frame_index);
+}
+
+#include "ehci-dbg.c"
+
 /*-------------------------------------------------------------------------*/
 
 /*

commit f3a958d30dd1ceac83a3b82b5260475c7697d53a
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:25 2012 +0200

    USB: EHCI: remove CNS3xxx EHCI platform driver
    
    The users have been converted to use the ehci platform driver instead, thus
    making the ehci-cns3xxx driver obsolete, so remove it.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index add37bc4bc18..28fb5ddaf786 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1259,11 +1259,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
-#ifdef CONFIG_USB_CNS3XXX_EHCI
-#include "ehci-cns3xxx.c"
-#define PLATFORM_DRIVER		cns3xxx_ehci_driver
-#endif
-
 #ifdef CONFIG_ARCH_VT8500
 #include "ehci-vt8500.c"
 #define	PLATFORM_DRIVER		vt8500_ehci_driver

commit 1de7d89c76350de456143503d52447a466b4025e
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:23 2012 +0200

    USB: EHCI: remove Alchemy EHCI driver
    
    The platform code has been converted to use the ehci-platform driver instead
    thus obsoleting the ehci-au1xxx driver, which can be removed.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6202407b2a62..add37bc4bc18 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1219,11 +1219,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif
 
-#ifdef CONFIG_MIPS_ALCHEMY
-#include "ehci-au1xxx.c"
-#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_HCD_OMAP
 #include "ehci-omap.c"
 #define        PLATFORM_DRIVER         ehci_hcd_omap_driver

commit 6d39944ee85fb46cd499b16231cbb10a00e3d878
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:20 2012 +0200

    USB: EHCI: remove Netlogic XLS EHCI driver
    
    The platform code has been migrated to register the ehci-platform driver, thus
    obsoleting the ehci-xls driver, which can be removed.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1f7c14b8a325..6202407b2a62 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1309,11 +1309,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_grlib_driver
 #endif
 
-#ifdef CONFIG_CPU_XLR
-#include "ehci-xls.c"
-#define PLATFORM_DRIVER		ehci_xls_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_MV
 #include "ehci-mv.c"
 #define        PLATFORM_DRIVER         ehci_mv_driver

commit ead92fae12902e3cfb79e8747c20b85c4b1f5414
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:18 2012 +0200

    USB: EHCI: remove Loongson 1B EHCI driver.
    
    The platform code registering the Loongson 1B EHCI driver has now been
    converted to register the ehci-platform driver instead, thus obsoleting the
    ehci-ls1x driver, which can be removed.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 01227000c3e0..1f7c14b8a325 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1319,11 +1319,6 @@ MODULE_LICENSE ("GPL");
 #define        PLATFORM_DRIVER         ehci_mv_driver
 #endif
 
-#ifdef CONFIG_MACH_LOONGSON1
-#include "ehci-ls1x.c"
-#define PLATFORM_DRIVER		ehci_ls1x_driver
-#endif
-
 #ifdef CONFIG_MIPS_SEAD3
 #include "ehci-sead3.c"
 #define	PLATFORM_DRIVER		ehci_hcd_sead3_driver

commit 6efd0f73cc8d748bfcccb23a5ee0b7e000441940
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Oct 8 15:11:15 2012 +0200

    USB: EHCI: remove IXP4xx EHCI driver
    
    This driver is not registered by any in-tree user. If needed it the EHCI
    driver can be reinstatied using the ehci-platform driver with caps_offset to
    0x100.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 61eac96441de..01227000c3e0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1249,11 +1249,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_orion_driver
 #endif
 
-#ifdef CONFIG_ARCH_IXP4XX
-#include "ehci-ixp4xx.c"
-#define	PLATFORM_DRIVER		ixp4xx_ehci_driver
-#endif
-
 #ifdef CONFIG_USB_W90X900_EHCI
 #include "ehci-w90x900.c"
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver

commit 98cae42d82fe9c9e2b5dacdf391edaa007e147e5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Sep 28 16:01:34 2012 -0400

    EHCI: use the isochronous scheduling threshold
    
    This patch (as1609) changes the way ehci-hcd uses the "Isochronous
    Scheduling Threshold" in its calculations.  Until now the code has
    ignored the threshold except for certain Intel PCI-based controllers.
    This violates the EHCI spec.
    
    The new code takes the threshold into account always, removing the
    need for the fs_i_thresh quirk flag.  In addition it implements the
    "full frame cache" setting more efficiently, moving forward only as
    far as the next frame boundary instead of always moving forward 8
    microframes.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6bf6c42481e8..61eac96441de 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -503,7 +503,7 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	/* controllers may cache some of the periodic schedule ... */
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
-		ehci->i_thresh = 2 + 8;
+		ehci->i_thresh = 0;
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 

commit 9fa5780beea1274d498a224822397100022da7d4
Author: Jan Beulich <JBeulich@suse.com>
Date:   Tue Sep 18 12:23:02 2012 +0100

    USB EHCI/Xen: propagate controller reset information to hypervisor
    
    Just like for the in-tree early console debug port driver, the
    hypervisor - when using a debug port based console - also needs to be
    told about controller resets, so it can suppress using and then
    re-initialize the debug port accordingly.
    
    Other than the in-tree driver, the hypervisor driver actually cares
    about doing this only for the device where the debug is port actually
    in use, i.e. it needs to be told the coordinates of the device being
    reset (quite obviously, leveraging the addition done for that would
    likely benefit the in-tree driver too).
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b05c6865b610..6bf6c42481e8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -228,7 +228,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 
 	/* If the EHCI debug controller is active, special care must be
 	 * taken before and after a host controller reset */
-	if (ehci->debug && !dbgp_reset_prep())
+	if (ehci->debug && !dbgp_reset_prep(ehci_to_hcd(ehci)))
 		ehci->debug = NULL;
 
 	command |= CMD_RESET;
@@ -251,7 +251,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 		tdi_reset (ehci);
 
 	if (ehci->debug)
-		dbgp_external_startup();
+		dbgp_external_startup(ehci_to_hcd(ehci));
 
 	ehci->port_c_suspend = ehci->suspended_ports =
 			ehci->resuming_ports = 0;

commit 9fc377799bc9bfd8d5cb35d0d1ea2e2458cbdbb3
Merge: 5e23ae49960d e387ef5c47dd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 10:23:47 2012 -0700

    Merge tag 'usb-3.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB patches from Greg Kroah-Hartman:
     "Here's the big USB patch set for the 3.6-rc1 merge window.
    
      Lots of little changes in here, primarily for gadget controllers and
      drivers.  There's some scsi changes that I think also went in through
      the scsi tree, but they merge just fine.  All of these patches have
      been in the linux-next tree for a while now.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fix up trivial conflicts in include/scsi/scsi_device.h (same libata
    conflict that Jeff had already encountered)
    
    * tag 'usb-3.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (207 commits)
      usb: Add USB_QUIRK_RESET_RESUME for all Logitech UVC webcams
      usb: Add quirk detection based on interface information
      usb: s3c-hsotg: Add header file protection macros in s3c-hsotg.h
      USB: ehci-s5p: Add vbus setup function to the s5p ehci glue layer
      USB: add USB_VENDOR_AND_INTERFACE_INFO() macro
      USB: notify phy when root hub port connect change
      USB: remove 8 bytes of padding from usb_host_interface on 64 bit builds
      USB: option: add ZTE MF821D
      USB: sierra: QMI mode MC7710 moved to qcserial
      USB: qcserial: adding Sierra Wireless devices
      USB: qcserial: support generic Qualcomm serial ports
      USB: qcserial: make probe more flexible
      USB: qcserial: centralize probe exit path
      USB: qcserial: consolidate usb_set_interface calls
      USB: ehci-s5p: Add support for device tree
      USB: ohci-exynos: Add support for device tree
      USB: ehci-omap: fix compile failure(v1)
      usb: host: tegra: pass correct pointer in ehci_setup()
      USB: ehci-fsl: Update ifdef check to work on 64-bit ppc
      USB: serial: keyspan: Removed unrequired parentheses.
      ...

commit 47fc28bff82a4dd5f6b41c97e335d10fc78a8e9a
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Wed May 9 13:58:14 2012 -0400

    usb: add host support for the tilegx architecture
    
    This change adds OHCI and EHCI support for the tilegx's on-chip
    USB hardware.
    
    Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 800be38c78b4..1d9401e0990a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1349,6 +1349,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_msm_driver
 #endif
 
+#ifdef CONFIG_TILE_USB
+#include "ehci-tilegx.c"
+#define	PLATFORM_DRIVER		ehci_hcd_tilegx_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
 #include "ehci-pmcmsp.c"
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver

commit 43fe3a99d9caf10b25f9c596e9854cdae30db418
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:16 2012 -0400

    USB: EHCI: resolve some unlikely races
    
    This patch (as1589) resolves some unlikely races involving system
    shutdown or controller death in ehci-hcd:
    
            Shutdown races with both root-hub resume and controller
            resume.
    
            Controller death races with root-hub suspend.
    
    A new bitflag is added to indicate that the controller has been shut
    down (whether for system shutdown or because it died).  Tests are
    added in the suspend and resume pathways to avoid reactivating the
    controller after any sort of shutdown.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ac4c8ddde20a..e44ca5453aa2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -343,6 +343,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	spin_lock_irq(&ehci->lock);
+	ehci->shutdown = true;
 	ehci->rh_state = EHCI_RH_STOPPING;
 	ehci->enabled_hrtimer_events = 0;
 	spin_unlock_irq(&ehci->lock);
@@ -823,6 +824,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		usb_hc_died(hcd);
 
 		/* Don't let the controller do anything more */
+		ehci->shutdown = true;
 		ehci->rh_state = EHCI_RH_STOPPING;
 		ehci->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);
 		ehci_writel(ehci, ehci->command, &ehci->regs->command);
@@ -1129,6 +1131,9 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* Mark hardware accessible again as we are back to full power by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
+	if (ehci->shutdown)
+		return 0;		/* Controller is dead */
+
 	/*
 	 * If CF is still set and we aren't resuming from hibernation
 	 * then we maintained suspend power.
@@ -1139,10 +1144,17 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 		int	mask = INTR_MASK;
 
 		ehci_prepare_ports_for_controller_resume(ehci);
+
+		spin_lock_irq(&ehci->lock);
+		if (ehci->shutdown)
+			goto skip;
+
 		if (!hcd->self.root_hub->do_remote_wakeup)
 			mask &= ~STS_PCD;
 		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
 		ehci_readl(ehci, &ehci->regs->intr_enable);
+ skip:
+		spin_unlock_irq(&ehci->lock);
 		return 0;
 	}
 
@@ -1154,14 +1166,20 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
 
+	spin_lock_irq(&ehci->lock);
+	if (ehci->shutdown)
+		goto skip;
+
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 
+	ehci->rh_state = EHCI_RH_SUSPENDED;
+	spin_unlock_irq(&ehci->lock);
+
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	ehci->rh_state = EHCI_RH_SUSPENDED;
 	return 1;
 }
 

commit c4f3476436f7452b97c8accb5dd7d53219a11a3f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:10 2012 -0400

    USB: EHCI: fix up locking
    
    This patch (as1588) adjusts the locking in ehci-hcd's various halt,
    shutdown, and suspend/resume pathways.  We want to hold the spinlock
    while writing device registers and accessing shared variables, but not
    while polling in a loop.
    
    In addition, there's no need to call ehci_work() at times when no URBs
    can be active, i.e., in ehci_stop() and ehci_bus_suspend().
    
    Finally, ehci_adjust_port_wakeup_flags() is called only in situations
    where interrupts are enabled; therefore it can use spin_lock_irq
    rather than spin_lock_irqsave.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 340c9c4894bf..ac4c8ddde20a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -167,21 +167,24 @@ static int tdi_in_host_mode (struct ehci_hcd *ehci)
 	return (tmp & 3) == USBMODE_CM_HC;
 }
 
-/* force HC to halt state from unknown (EHCI spec section 2.3) */
+/*
+ * Force HC to halt state from unknown (EHCI spec section 2.3).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
-	u32	temp = ehci_readl(ehci, &ehci->regs->status);
+	u32	temp;
+
+	spin_lock_irq(&ehci->lock);
 
 	/* disable any irqs left enabled by previous code */
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 
-	if (ehci_is_TDI(ehci) && tdi_in_host_mode(ehci) == 0) {
+	if (ehci_is_TDI(ehci) && !tdi_in_host_mode(ehci)) {
+		spin_unlock_irq(&ehci->lock);
 		return 0;
 	}
 
-	if ((temp & STS_HALT) != 0)
-		return 0;
-
 	/*
 	 * This routine gets called during probe before ehci->command
 	 * has been initialized, so we can't rely on its value.
@@ -190,7 +193,11 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	temp = ehci_readl(ehci, &ehci->regs->command);
 	temp &= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &ehci->regs->command);
-	return handshake (ehci, &ehci->regs->status,
+
+	spin_unlock_irq(&ehci->lock);
+	synchronize_irq(ehci_to_hcd(ehci)->irq);
+
+	return handshake(ehci, &ehci->regs->status,
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
@@ -210,7 +217,10 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	ehci_writel(ehci, tmp, &ehci->regs->usbmode);
 }
 
-/* reset a non-running (STS_HALT == 1) controller */
+/*
+ * Reset a non-running (STS_HALT == 1) controller.
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_reset (struct ehci_hcd *ehci)
 {
 	int	retval;
@@ -248,7 +258,10 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	return retval;
 }
 
-/* idle the controller (from running) */
+/*
+ * Idle the controller (turn off the schedules).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static void ehci_quiesce (struct ehci_hcd *ehci)
 {
 	u32	temp;
@@ -261,8 +274,10 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
+	spin_lock_irq(&ehci->lock);
 	ehci->command &= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	spin_unlock_irq(&ehci->lock);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0, 16 * 125);
@@ -301,11 +316,14 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 
 /*
  * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
- * Should be called with ehci->lock held.
+ * Must be called with interrupts enabled and the lock not held.
  */
 static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
 	ehci_halt(ehci);
+
+	spin_lock_irq(&ehci->lock);
+	ehci->rh_state = EHCI_RH_HALTED;
 	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
@@ -313,6 +331,7 @@ static void ehci_silence_controller(struct ehci_hcd *ehci)
 
 	/* unblock posted writes */
 	ehci_readl(ehci, &ehci->regs->configured_flag);
+	spin_unlock_irq(&ehci->lock);
 }
 
 /* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
@@ -325,10 +344,11 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 
 	spin_lock_irq(&ehci->lock);
 	ehci->rh_state = EHCI_RH_STOPPING;
-	ehci_silence_controller(ehci);
 	ehci->enabled_hrtimer_events = 0;
 	spin_unlock_irq(&ehci->lock);
 
+	ehci_silence_controller(ehci);
+
 	hrtimer_cancel(&ehci->hrtimer);
 }
 
@@ -400,11 +420,11 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	spin_lock_irq(&ehci->lock);
 	ehci->enabled_hrtimer_events = 0;
-	ehci_quiesce(ehci);
+	spin_unlock_irq(&ehci->lock);
 
+	ehci_quiesce(ehci);
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
-	spin_unlock_irq(&ehci->lock);
 
 	hrtimer_cancel(&ehci->hrtimer);
 	remove_sysfs_files(ehci);
@@ -412,8 +432,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&ehci->lock);
-	if (ehci->async)
-		ehci_work (ehci);
 	end_free_itds(ehci);
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);

commit f42890782241a60d107f23d08089a4a12b507a11
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:07 2012 -0400

    USB: EHCI: simplify isochronous scanning
    
    This patch (as1587) simplifies ehci-hcd's scan_isoc() routine by
    eliminating some local variables, declaring boolean-valued values as
    bool rather than unsigned, changing variable names to make more sense,
    and so on.
    
    The logic at the end of the routine is cut down significantly.  The
    scanning doesn't have to catch up all the way to where the hardware
    is; it merely has to catch up to where the hardware was when the last
    interrupt occurred.  If the hardware has made more progress since then
    and issued another interrupt, a rescan will catch up to it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9f26080889f5..340c9c4894bf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -488,9 +488,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
-	ehci->next_uframe = -1;
-	ehci->clock_frame = -1;
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it

commit 18aafe64d75d0e27dae206cacf4171e4e485d285
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:04 2012 -0400

    USB: EHCI: use hrtimer for the I/O watchdog
    
    This patch (as1586) replaces the kernel timer used by ehci-hcd as an
    I/O watchdog with an hrtimer event.
    
    Unlike in the current code, the watchdog event is now always enabled
    whenever any isochronous URBs are active.  This will prevent bugs
    caused by the periodic schedule wrapping around with no completion
    interrupts; the watchdog handler is guaranteed to scan the isochronous
    transfers at least once during each iteration of the schedule.  The
    extra overhead will be negligible: one timer interrupt every 100 ms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c13dad8a8503..9f26080889f5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,8 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
-
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
 module_param (log2_irq_thresh, int, S_IRUGO);
@@ -125,25 +123,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 
 /*-------------------------------------------------------------------------*/
 
-static void
-timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	if (!test_and_set_bit(action, &ehci->actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IO_WATCHDOG:
-			if (!ehci->need_io_watchdog)
-				return;
-			t = EHCI_IO_JIFFIES;
-			break;
-		}
-		mod_timer(&ehci->watchdog, t + jiffies);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
@@ -307,19 +286,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave(&ehci->lock, flags);
-
-	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci);
-
-	spin_unlock_irqrestore (&ehci->lock, flags);
-}
-
 /* On some systems, leaving remote wakeup enabled prevents system shutdown.
  * The firmware seems to think that powering off is a wakeup event!
  * This routine turns off remote wakeup and everything else, on all ports.
@@ -357,8 +323,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
-	del_timer_sync(&ehci->watchdog);
-
 	spin_lock_irq(&ehci->lock);
 	ehci->rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
@@ -394,8 +358,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
  */
 static void ehci_work (struct ehci_hcd *ehci)
 {
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
@@ -422,10 +384,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (ehci->rh_state == EHCI_RH_RUNNING &&
-			(ehci->async->qh_next.ptr != NULL ||
-			 ehci->periodic_count != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
+	turn_on_io_watchdog(ehci);
 }
 
 /*
@@ -438,7 +397,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_dbg (ehci, "stop\n");
 
 	/* no more interrupts ... */
-	del_timer_sync (&ehci->watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	ehci->enabled_hrtimer_events = 0;
@@ -490,9 +448,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * keep io watchdog by default, those good HCDs could turn off it later
 	 */
 	ehci->need_io_watchdog = 1;
-	init_timer(&ehci->watchdog);
-	ehci->watchdog.function = ehci_watchdog;
-	ehci->watchdog.data = (unsigned long) ehci;
 
 	hrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci->hrtimer.function = ehci_hrtimer_func;

commit 569b394f53f0abd177cc665c9b4ace89e3f4c7fb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:00 2012 -0400

    USB: EHCI: always scan each interrupt QH
    
    This patch (as1585) fixes a bug in ehci-hcd's scheme for scanning
    interrupt QHs.
    
    Currently a single routine takes care of scanning everything on the
    periodic schedule.  Whenever an interrupt occurs, it scans all
    isochronous and interrupt URBs scheduled for frames that have elapsed
    since the last scan.
    
    This has two disadvantages.  The first is relatively minor: An
    interrupt QH is likely to end up getting scanned multiple times,
    particularly if the last scan was not fairly recent.  (The current
    code avoids this by maintaining a periodic_stamp in each interrupt
    QH.)
    
    The second is more serious.  The periodic schedule wraps around.  If
    the last scan occurred during frame N, and the next scan occurs when
    the schedule has gone through an entire cycle and is back at frame N,
    the scanning code won't look at any frames other than N.  Consequently
    it won't see any QHs that completed during frame N-1 or earlier.
    
    The patch replaces the entire frame-based approach for scanning
    interrupt QHs with a new routine using a list-based approach, the same
    as for async QHs.  This has a slight disadvantage, because it means
    that all interrupt QHs have to be scanned every time.  But it is more
    robust than the current approach.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f6cf1d178107..c13dad8a8503 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -410,8 +410,10 @@ static void ehci_work (struct ehci_hcd *ehci)
 	ehci->need_rescan = false;
 	if (ehci->async_count)
 		scan_async(ehci);
-	if (ehci->next_uframe != -1)
-		scan_periodic (ehci);
+	if (ehci->intr_count > 0)
+		scan_intr(ehci);
+	if (ehci->isoc_count > 0)
+		scan_isoc(ehci);
 	if (ehci->need_rescan)
 		goto rescan;
 	ehci->scanning = false;
@@ -509,6 +511,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&ehci->intr_qh_list);
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
 

commit 361aabf395e4a23cf554cf4ec0c0c6963b8beb01
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:57 2012 -0400

    USB: EHCI: don't lose events during a scan
    
    This patch (as1584) fixes a minor bug that has been present in
    ehci-hcd since the beginning.
    
    Scanning the schedules for URB completions is single-threaded.  If a
    completion interrupt occurs while an URB is being given back, the
    interrupt handler realizes that a scan is in progress on another CPU
    and avoids starting a new one.
    
    This means that completion events can be lost.  If an URB completes
    after it has been scanned but while a scan is still in progress, the
    driver won't notice and won't rescan the completed URB.
    
    The patch fixes the problem by adding a new flag to indicate that
    another scan is needed after the current scan is done.  The flag gets
    set whenever a completion interrupt occurs while a scan is in
    progress.  The rescan will see the completion, thus preventing it from
    getting lost.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74ffd20edff8..f6cf1d178107 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -400,14 +400,21 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
 	 */
-	if (ehci->scanning)
+	if (ehci->scanning) {
+		ehci->need_rescan = true;
 		return;
-	ehci->scanning = 1;
+	}
+	ehci->scanning = true;
+
+ rescan:
+	ehci->need_rescan = false;
 	if (ehci->async_count)
 		scan_async(ehci);
 	if (ehci->next_uframe != -1)
 		scan_periodic (ehci);
-	ehci->scanning = 0;
+	if (ehci->need_rescan)
+		goto rescan;
+	ehci->scanning = false;
 
 	/* the IO watchdog guards against hardware or driver bugs that
 	 * misplace IRQs, and should let us run completely without IRQs.

commit 32830f207691176234b4c4dd17f0d7ab6d87d94b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:53 2012 -0400

    USB: EHCI: use hrtimer for unlinking empty async QHs
    
    This patch (as1583) changes ehci-hcd to use an hrtimer event for
    unlinking empty (unused) async QHs instead of using a kernel timer.
    
    The check for empty QHs is moved to a new routine, where it doesn't
    require going through an entire scan of both the async and periodic
    schedules.  And it can unlink multiple QHs at once, unlike the current
    code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 86e8ee169c67..74ffd20edff8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -94,8 +94,6 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
-#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
-						/* 5-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -130,15 +128,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 static void
 timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 {
-	/* Don't override timeouts which shrink or (later) disable
-	 * the async ring; just the I/O watchdog.  Note that if a
-	 * SHRINK were pending, OFF would never be requested.
-	 */
-	if (timer_pending(&ehci->watchdog)
-			&& (BIT(TIMER_ASYNC_SHRINK)
-				& ehci->actions))
-		return;
-
 	if (!test_and_set_bit(action, &ehci->actions)) {
 		unsigned long t;
 
@@ -148,10 +137,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		/* case TIMER_ASYNC_SHRINK: */
-		default:
-			t = EHCI_SHRINK_JIFFIES;
-			break;
 		}
 		mod_timer(&ehci->watchdog, t + jiffies);
 	}
@@ -307,6 +292,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 /*-------------------------------------------------------------------------*/
 
 static void end_unlink_async(struct ehci_hcd *ehci);
+static void unlink_empty_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);

commit 3c273a056bf46167f0a1309c2ba72282a17d2541
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:49 2012 -0400

    USB: EHCI: unlink multiple async QHs together
    
    This patch (as1582) changes ehci-hcd's strategy for unlinking async
    QHs.  Currently the driver never unlinks more than one QH at a time.
    This can be inefficient and cause unnecessary delays, since a QH
    cannot be reused while it is waiting to be unlinked.
    
    The new strategy unlinks all the waiting QHs at once.  In practice the
    improvement won't be very big, because it's somewhat uncommon to have
    two or more QHs waiting to be unlinked at any time.  But it does
    happen, and in any case, doing things this way makes more sense IMO.
    
    The change requires the async unlinking code to be refactored
    slightly.  Now in addition to the routines for starting and ending an
    unlink, there are new routines for unlinking a single QH and starting
    an IAA cycle.  This approach is needed because there are two separate
    paths for unlinking async QHs:
    
            When a transfer error occurs or an URB is cancelled, the QH
            must be unlinked right away;
    
            When a QH has been idle sufficiently long, it is unlinked
            to avoid consuming DMA bandwidth uselessly.
    
    In the first case we want the unlink to proceed as quickly as
    possible, whereas in the second case we can afford to batch several
    QHs together and unlink them all at once.  Hence the division of
    labor.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f74ba277c22d..86e8ee169c67 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -795,7 +795,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci->async_unlink) {
+		if (ehci->async_iaa) {
 			COUNT(ehci->stats.iaa);
 			end_unlink_async(ehci);
 		} else
@@ -926,33 +926,6 @@ static int ehci_urb_enqueue (
 	}
 }
 
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	/* failfast */
-	if (ehci->rh_state < EHCI_RH_RUNNING && ehci->async_unlink)
-		end_unlink_async(ehci);
-
-	/* If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh->qh_state != QH_STATE_LINKED) {
-		if (qh->qh_state == QH_STATE_COMPLETING)
-			qh->needs_rescan = 1;
-		return;
-	}
-
-	/* defer till later if busy */
-	if (ehci->async_unlink) {
-		qh->qh_state = QH_STATE_UNLINK_WAIT;
-		ehci->async_unlink_last->unlink_next = qh;
-		ehci->async_unlink_last = qh;
-
-	/* start IAA cycle */
-	} else
-		start_unlink_async (ehci, qh);
-}
-
 /* remove from hardware lists
  * completions normally happen asynchronously
  */
@@ -979,7 +952,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
@@ -1070,7 +1043,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		 * may already be unlinked.
 		 */
 		if (tmp)
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
@@ -1133,7 +1106,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * re-linking will call qh_refresh().
 			 */
 			if (eptype == USB_ENDPOINT_XFER_BULK)
-				unlink_async(ehci, qh);
+				start_unlink_async(ehci, qh);
 			else
 				start_unlink_intr(ehci, qh);
 		}

commit 9d9387475af261949f61a5ec465e1f762d7be08a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:44 2012 -0400

    USB: EHCI: use hrtimer for the IAA watchdog
    
    This patch (as1581) replaces the iaa_watchdog kernel timer used by
    ehci-hcd with an hrtimer event, in keeping with the general conversion
    to high-res timers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fb1966cf5649..f74ba277c22d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,7 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
@@ -322,51 +321,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_iaa_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-
-	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
-	 * So we need this watchdog, but must protect it against both
-	 * (a) SMP races against real IAA firing and retriggering, and
-	 * (b) clean HC shutdown, when IAA watchdog was pending.
-	 */
-	if (ehci->async_unlink
-			&& !timer_pending(&ehci->iaa_watchdog)
-			&& ehci->rh_state == EHCI_RH_RUNNING) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &ehci->regs->command);
-
-		/* If IAA is set here it either legitimately triggered
-		 * before we cleared IAAD above (but _way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &ehci->regs->status);
-		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
-			COUNT (ehci->stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
-		}
-
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
-	}
-
-	spin_unlock_irqrestore(&ehci->lock, flags);
-}
-
 static void ehci_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -418,7 +372,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	del_timer_sync(&ehci->watchdog);
-	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	ehci->rh_state = EHCI_RH_STOPPING;
@@ -491,7 +444,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
-	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	ehci->enabled_hrtimer_events = 0;
@@ -547,10 +499,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
-	init_timer(&ehci->iaa_watchdog);
-	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
-	ehci->iaa_watchdog.data = (unsigned long) ehci;
-
 	hrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci->hrtimer.function = ehci_hrtimer_func;
 	ehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
@@ -830,6 +778,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
+
+		/* Turn off the IAA watchdog */
+		ehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);
+
+		/*
+		 * Mild optimization: Allow another IAAD to reset the
+		 * hrtimer, if one occurs before the next expiration.
+		 * In theory we could always cancel the hrtimer, but
+		 * tests show that about half the time it will be reset
+		 * for some other event anyway.
+		 */
+		if (ehci->next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)
+			++ehci->next_hrtimer_event;
+
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");

commit 8c5bf7be56f1a8aecc1f802f132d53f556a9bc45
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:39 2012 -0400

    USB: EHCI: don't refcount iso_stream structures
    
    This patch (as1580) makes ehci_iso_stream structures behave more like
    QHs, in that they will remain allocated until their isochronous
    endpoint is disabled.  This will come in useful in the future, when
    periodic bandwidth gets allocated as an altsetting is installed rather
    than on-the-fly.
    
    For now, the change to the ehci_iso_stream lifetimes means that each
    structure is always deallocated at exactly one spot in
    ehci_endpoint_disable() and never used again.  As a result, it is no
    longer necessary to use reference counting on these things, and the
    patch removes it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 98b945840c9e..fb1966cf5649 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1085,8 +1085,14 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * accelerate iso completions ... so spin a while.
 	 */
 	if (qh->hw == NULL) {
-		ehci_vdbg (ehci, "iso delay\n");
-		goto idle_timeout;
+		struct ehci_iso_stream	*stream = ep->hcpriv;
+
+		if (!list_empty(&stream->td_list))
+			goto idle_timeout;
+
+		/* BUG_ON(!list_empty(&stream->free_list)); */
+		kfree(stream);
+		goto done;
 	}
 
 	if (ehci->rh_state < EHCI_RH_RUNNING)
@@ -1127,8 +1133,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			list_empty (&qh->qtd_list) ? "" : "(has tds)");
 		break;
 	}
+ done:
 	ep->hcpriv = NULL;
-done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 

commit 55934eb3b9fa52eb53b9d7342267fc73c38206aa
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:35 2012 -0400

    USB: EHCI: use hrtimer for (s)iTD deallocation
    
    This patch (as1579) adds an hrtimer event to handle deallocation of
    iTDs and siTDs in ehci-hcd.
    
    Because of the frame-oriented approach used by the EHCI periodic
    schedule, the hardware can continue to access the Transfer Descriptor
    for isochronous (or split-isochronous) transactions for up to a
    millisecond after the transaction completes.  The iTD (or siTD) must
    not be reused before then.
    
    The strategy currently used involves putting completed iTDs on a list
    of cached entries and every so often returning them to the endpoint's
    free list.  The new strategy reduces overhead by putting completed
    iTDs back on the free list immediately, although they are not reused
    until it is safe to do so.
    
    When the isochronous endpoint stops (its queue becomes empty), the
    iTDs on its free list get moved to a global list, from which they will
    be deallocated after a minimum of 2 ms.  This delay is what the new
    hrtimer event is for.
    
    Overall this may not be a tremendous improvement over the current
    code, but to me it seems a lot more clear and logical.  In addition,
    it removes the need for each iTD to keep a reference to the
    ehci_iso_stream it belongs to, since the iTD never needs to be moved
    back to the stream's free list from the global list.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1676c66b8530..98b945840c9e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -509,6 +509,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	spin_lock_irq (&ehci->lock);
 	if (ehci->async)
 		ehci_work (ehci);
+	end_free_itds(ehci);
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 

commit bf6387bcd16975ba8952b094f262a359d74e1c8a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:31 2012 -0400

    USB: EHCI: use hrtimer for controller death
    
    This patch (as1578) adds an hrtimer event to handle the death of an
    EHCI controller.  When a controller dies, it doesn't necessarily stop
    running right away.  The new event polls at 1-ms intervals to see when
    all activity has safely stopped.  This replaces a busy-wait polling
    loop in the current code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index edcfd2c4295e..1676c66b8530 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -888,20 +888,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
-		ehci->rh_state = EHCI_RH_STOPPING;
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
-		ehci_halt(ehci);
 dead:
-		ehci->enabled_hrtimer_events = 0;
-		hrtimer_try_to_cancel(&ehci->hrtimer);
-		ehci_reset(ehci);
-		ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 		usb_hc_died(hcd);
-		/* generic layer kills/unlinks all urbs, then
-		 * uses ehci_stop to clean up the rest
-		 */
-		bh = 1;
+
+		/* Don't let the controller do anything more */
+		ehci->rh_state = EHCI_RH_STOPPING;
+		ehci->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);
+		ehci_writel(ehci, ehci->command, &ehci->regs->command);
+		ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+		ehci_handle_controller_death(ehci);
+
+		/* Handle completions when the controller stops */
+		bh = 0;
 	}
 
 	if (bh)

commit df2022553dd8d34d49e16c19d851ea619438f0ef
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:26 2012 -0400

    USB: EHCI: use hrtimer for interrupt QH unlink
    
    This patch (as1577) adds hrtimer support for unlinking interrupt QHs
    in ehci-hcd.  The current code relies on a fixed delay of either 2 or
    55 us, which is not always adequate and in any case is totally bogus.
    Thanks to internal caching, the EHCI hardware may continue to access
    an interrupt QH for more than a millisecond after it has been unlinked.
    
    In fact, the EHCI spec doesn't say how long to wait before using an
    unlinked interrupt QH.  The patch sets the delay to 9 microframes
    minimum, which ought to be adequate.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 21d6fbc0a327..edcfd2c4295e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -309,6 +309,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 #include "ehci-timer.c"
 #include "ehci-hub.c"
@@ -1034,7 +1036,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			intr_deschedule (ehci, qh);
+			start_unlink_intr(ehci, qh);
 			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
@@ -1164,7 +1166,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
 			else
-				intr_deschedule(ehci, qh);
+				start_unlink_intr(ehci, qh);
 		}
 	}
 	spin_unlock_irqrestore(&ehci->lock, flags);

commit 314466101c6ae14f6f5db8a86eda1509ba2c02a8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:21 2012 -0400

    USB: EHCI: use hrtimer for async schedule
    
    This patch (as1576) adds hrtimer support for managing ehci-hcd's
    async schedule.  Just as with the earlier change to the periodic
    schedule management, two new hrtimer events take care of everything.
    
    One event polls at 1-ms intervals to see when the Asynchronous
    Schedule Status (ASS) flag matches the Asynchronous Schedule Enable
    (ASE) value; the schedule's state must not be changed until it does.
    The other event delays for 15 ms after the async schedule becomes
    empty before turning it off.
    
    The new events replace a busy-wait poll and a kernel timer usage.
    They also replace the rather illogical method currently used for
    indicating the async schedule should be turned off: attempting to
    unlink the dedicated QH at the head of the async list.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fd7ae16f77be..21d6fbc0a327 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -95,7 +95,6 @@ static const char	hcd_name [] = "ehci_hcd";
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
-#define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
 
@@ -137,7 +136,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 	 * SHRINK were pending, OFF would never be requested.
 	 */
 	if (timer_pending(&ehci->watchdog)
-			&& ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+			&& (BIT(TIMER_ASYNC_SHRINK)
 				& ehci->actions))
 		return;
 
@@ -150,9 +149,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
 			t = EHCI_SHRINK_JIFFIES;
@@ -376,10 +372,6 @@ static void ehci_watchdog(unsigned long param)
 
 	spin_lock_irqsave(&ehci->lock, flags);
 
-	/* stop async processing after it's idled a bit */
-	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
-		start_unlink_async (ehci, ehci->async);
-
 	/* ehci could run by timer, without IRQs ... */
 	ehci_work (ehci);
 
@@ -470,7 +462,8 @@ static void ehci_work (struct ehci_hcd *ehci)
 	if (ehci->scanning)
 		return;
 	ehci->scanning = 1;
-	scan_async (ehci);
+	if (ehci->async_count)
+		scan_async(ehci);
 	if (ehci->next_uframe != -1)
 		scan_periodic (ehci);
 	ehci->scanning = 0;

commit 9671cd7a91059bcd27665a884ee6568d31ef6857
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:16 2012 -0400

    USB: EHCI: remove PS3 status polling
    
    This patch (as1575) removes special code added for status polling of
    the EHCI controller in PS3 systems.  While the controller is running,
    the polling is now carried out by an hrtimer handler.  When the
    controller is suspending or stopping, we use the same polling routine
    as the old code -- but in neither case do we need to conclude that the
    controller has died if the polling goes on for too long.
    
    As a result the entire handshake_on_error_set_halt() routine is now
    unused, so it is removed from the driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7e00ca095cea..fd7ae16f77be 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -235,68 +235,6 @@ static int ehci_halt (struct ehci_hcd *ehci)
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
-#if defined(CONFIG_USB_SUSPEND) && defined(CONFIG_PPC_PS3)
-
-/*
- * The EHCI controller of the Cell Super Companion Chip used in the
- * PS3 will stop the root hub after all root hub ports are suspended.
- * When in this condition handshake will return -ETIMEDOUT.  The
- * STS_HLT bit will not be set, so inspection of the frame index is
- * used here to test for the condition.  If the condition is found
- * return success to allow the USB suspend to complete.
- */
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	unsigned int old_index;
-	int error;
-
-	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
-		return -ETIMEDOUT;
-
-	old_index = ehci_read_frame_index(ehci);
-
-	error = handshake(ehci, ptr, mask, done, usec);
-
-	if (error == -ETIMEDOUT && ehci_read_frame_index(ehci) == old_index)
-		return 0;
-
-	return error;
-}
-
-#else
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	return -ETIMEDOUT;
-}
-
-#endif
-
-static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
-				       u32 mask, u32 done, int usec)
-{
-	int error;
-
-	error = handshake(ehci, ptr, mask, done, usec);
-	if (error == -ETIMEDOUT)
-		error = handshake_for_broken_root_hub(ehci, ptr, mask, done,
-						      usec);
-
-	if (error) {
-		ehci_halt(ehci);
-		ehci->rh_state = EHCI_RH_HALTED;
-		ehci_err(ehci, "force halt; handshake %p %08x %08x -> %d\n",
-			ptr, mask, done, error);
-	}
-
-	return error;
-}
-
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
@@ -361,17 +299,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci->command << 10) & (STS_ASS | STS_PSS);
-	if (handshake_on_error_set_halt(ehci, &ehci->regs->status,
-					STS_ASS | STS_PSS, temp, 16 * 125))
-		return;
+	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
 	ehci->command &= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	handshake_on_error_set_halt(ehci, &ehci->regs->status,
-				    STS_ASS | STS_PSS, 0, 16 * 125);
+	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0, 16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/

commit 3ca9aebac2ebb8f56d2d097636b8c568320a9f87
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:05 2012 -0400

    USB: EHCI: use hrtimer for the periodic schedule
    
    This patch (as1573) adds hrtimer support for managing ehci-hcd's
    periodic schedule.  There are two issues to deal with.
    
    First, the schedule's state (on or off) must not be changed until the
    hardware status has caught up with the current command.  This is
    handled by an hrtimer event that polls at 1-ms intervals to see when
    the Periodic Schedule Status (PSS) flag matches the Periodic Schedule
    Enable (PSE) value.
    
    Second, the schedule should not be turned off as soon as it becomes
    empty.  Turning the schedule on and off takes time, so we want to wait
    until the schedule has been empty for a suitable period before turning
    it off.  This is handled by an hrtimer event that gets set to expire
    10 ms after the periodic schedule becomes empty.
    
    The existing code polls (for up to 1125 us and with interrupts
    disabled!) to check the status, and doesn't implement a delay before
    turning off the schedule.  Furthermore, if the polling fails then the
    driver decides that the controller has died.  This has caused problems
    for several people; some controllers can take 10 ms or more to turn
    off their periodic schedules.
    
    This patch fixes these issues.  It also makes the "broken_periodic"
    workaround unnecessary; there is no longer any danger of turning off
    the periodic schedule after it has been on for less than 1 ms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f8fed163a23a..7e00ca095cea 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -546,7 +546,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 */
 	if (ehci->rh_state == EHCI_RH_RUNNING &&
 			(ehci->async->qh_next.ptr != NULL ||
-			 ehci->periodic_sched != 0))
+			 ehci->periodic_count != 0))
 		timer_action (ehci, TIMER_IO_WATCHDOG);
 }
 

commit d58b4bcc6df8046cf9c3c59f9ff84d2cd86b93eb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:54 2012 -0400

    USB: EHCI: introduce high-res timer
    
    This patch (as1572) begins the conversion of ehci-hcd over to using
    high-resolution timers rather than old-fashioned low-resolution kernel
    timers.  This reduces overhead caused by timer roundoff on systems
    where HZ is smaller than 1000.  Also, the new timer framework
    introduced here is much more logical and easily extended than the
    ad-hoc approach ehci-hcd currently uses for timers.
    
    An hrtimer structure is added to ehci_hcd, along with a bitflag array
    and an array of ktime_t values, to keep track of which timing events
    are pending and what their expiration times are.
    
    Only the infrastructure for the timing operations is added in this
    patch.  Later patches will add routines for handling each of the
    various timing events the driver needs.  In some cases the new hrtimer
    handlers will replace the existing handlers for ehci-hcd's kernel
    timers; as this happens the old timers will be removed.  In other
    cases the new timing events will replace busy-wait loops.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bc94822f4c5d..f8fed163a23a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -30,8 +30,7 @@
 #include <linux/vmalloc.h>
 #include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/ktime.h>
+#include <linux/hrtimer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
 #include <linux/usb.h>
@@ -380,6 +379,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
+#include "ehci-timer.c"
 #include "ehci-hub.c"
 #include "ehci-lpm.c"
 #include "ehci-mem.c"
@@ -494,7 +494,10 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	spin_lock_irq(&ehci->lock);
 	ehci->rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
+	ehci->enabled_hrtimer_events = 0;
 	spin_unlock_irq(&ehci->lock);
+
+	hrtimer_cancel(&ehci->hrtimer);
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
@@ -561,12 +564,14 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
+	ehci->enabled_hrtimer_events = 0;
 	ehci_quiesce(ehci);
 
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
 	spin_unlock_irq(&ehci->lock);
 
+	hrtimer_cancel(&ehci->hrtimer);
 	remove_sysfs_files(ehci);
 	remove_debug_files (ehci);
 
@@ -615,6 +620,10 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
 	ehci->iaa_watchdog.data = (unsigned long) ehci;
 
+	hrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	ehci->hrtimer.function = ehci_hrtimer_func;
+	ehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
+
 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 
 	/*
@@ -954,6 +963,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		dbg_status(ehci, "fatal", status);
 		ehci_halt(ehci);
 dead:
+		ehci->enabled_hrtimer_events = 0;
+		hrtimer_try_to_cancel(&ehci->hrtimer);
 		ehci_reset(ehci);
 		ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 		usb_hc_died(hcd);

commit c0c53dbc32ea05a1e1dd9dba4772327da9a11750
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:48 2012 -0400

    USB: EHCI: add new root-hub state: STOPPING
    
    This patch (as1571) adds a new state for ehci-hcd's root hubs:
    EHCI_RH_STOPPING.  This value is used at times when the root hub is
    being stopped and we don't know whether or not the hardware has
    finished all its DMA yet.
    
    Although the purpose may not be apparent, this distinction will come
    in useful later on.  Future patches will avoid actions that depend on
    the root hub being operational (like turning on the async or periodic
    schedules) when they see the state is EHCI_RH_STOPPING.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8b75e4279a47..bc94822f4c5d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -357,10 +357,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 {
 	u32	temp;
 
-#ifdef DEBUG
 	if (ehci->rh_state != EHCI_RH_RUNNING)
-		BUG ();
-#endif
+		return;
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci->command << 10) & (STS_ASS | STS_PSS);
@@ -494,6 +492,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
+	ehci->rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
 	spin_unlock_irq(&ehci->lock);
 }
@@ -562,8 +561,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
-	if (ehci->rh_state == EHCI_RH_RUNNING)
-		ehci_quiesce (ehci);
+	ehci_quiesce(ehci);
 
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
@@ -951,6 +949,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
+		ehci->rh_state = EHCI_RH_STOPPING;
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
 		ehci_halt(ehci);
@@ -1026,7 +1025,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (ehci->rh_state != EHCI_RH_RUNNING && ehci->async_unlink)
+	if (ehci->rh_state < EHCI_RH_RUNNING && ehci->async_unlink)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1148,7 +1147,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto idle_timeout;
 	}
 
-	if (ehci->rh_state != EHCI_RH_RUNNING)
+	if (ehci->rh_state < EHCI_RH_RUNNING)
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:

commit 2f5bb665ba7a14c5842fa2e1cde2be039843a2a2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:43 2012 -0400

    USB: EHCI: add pointer to end of async-unlink list
    
    This patch (as1570) adds a pointer for the end of ehci-hcd's
    async-unlink list.  The list (which is actually a queue) is singly
    linked, so having a pointer to its end makes adding new entries easier
    -- there's no longer any need to scan through the whole list.
    
    In principle it could be changed to a standard doubly-linked list.  It
    turns out that doing so actually makes the code less clear, so I'm
    leaving it as is.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index efee426a2465..8b75e4279a47 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1041,14 +1041,9 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* defer till later if busy */
 	if (ehci->async_unlink) {
-		struct ehci_qh		*last;
-
-		for (last = ehci->async_unlink;
-				last->unlink_next;
-				last = last->unlink_next)
-			continue;
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
-		last->unlink_next = qh;
+		ehci->async_unlink_last->unlink_next = qh;
+		ehci->async_unlink_last = qh;
 
 	/* start IAA cycle */
 	} else

commit 99ac5b1e9536f142461681fa6143a947d66b4279
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:38 2012 -0400

    USB: EHCI: rename "reclaim"
    
    This patch (as1569) renames the ehci->reclaim list in ehci-hcd.  The
    word "reclaim" is used in the EHCI specification to mean something
    quite different, and "unlink_next" is more descriptive of the list's
    purpose anyway.
    
    Similarly, the "reclaim" field in the ehci_stats structure is renamed
    "iaa", which is more meaningful (to experts, anyway) and is a better
    match for the "lost_iaa" field.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cdb15769468a..efee426a2465 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -403,7 +403,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci->reclaim
+	if (ehci->async_unlink
 			&& !timer_pending(&ehci->iaa_watchdog)
 			&& ehci->rh_state == EHCI_RH_RUNNING) {
 		u32 cmd, status;
@@ -583,8 +583,8 @@ static void ehci_stop (struct usb_hcd *hcd)
 		usb_amd_dev_put();
 
 #ifdef	EHCI_STATS
-	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
+	ehci_dbg(ehci, "irq normal %ld err %ld iaa %ld (lost %ld)\n",
+		ehci->stats.normal, ehci->stats.error, ehci->stats.iaa,
 		ehci->stats.lost_iaa);
 	ehci_dbg (ehci, "complete %ld unlink %ld\n",
 		ehci->stats.complete, ehci->stats.unlink);
@@ -651,7 +651,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
-	ehci->reclaim = NULL;
 	ehci->next_uframe = -1;
 	ehci->clock_frame = -1;
 
@@ -896,11 +895,11 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci->reclaim) {
-			COUNT(ehci->stats.reclaim);
+		if (ehci->async_unlink) {
+			COUNT(ehci->stats.iaa);
 			end_unlink_async(ehci);
 		} else
-			ehci_dbg(ehci, "IAA with nothing to reclaim?\n");
+			ehci_dbg(ehci, "IAA with nothing unlinked?\n");
 	}
 
 	/* remote wakeup [4.3.1] */
@@ -1027,7 +1026,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (ehci->rh_state != EHCI_RH_RUNNING && ehci->reclaim)
+	if (ehci->rh_state != EHCI_RH_RUNNING && ehci->async_unlink)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1041,15 +1040,15 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* defer till later if busy */
-	if (ehci->reclaim) {
+	if (ehci->async_unlink) {
 		struct ehci_qh		*last;
 
-		for (last = ehci->reclaim;
-				last->reclaim;
-				last = last->reclaim)
+		for (last = ehci->async_unlink;
+				last->unlink_next;
+				last = last->unlink_next)
 			continue;
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
-		last->reclaim = qh;
+		last->unlink_next = qh;
 
 	/* start IAA cycle */
 	} else

commit 4c53de72109759c931744734ca75f9cecb3baef1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:32 2012 -0400

    USB: EHCI: add symbolic constants for QHs
    
    This patch (as1568) introduces symbolic constants for some of the
    less-frequently used bitfields in the QH structure.  This makes the
    code a little easier to read and understand.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1f8f792eec86..cdb15769468a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -667,7 +667,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
 	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
 #if defined(CONFIG_PPC_PS3)
-	hw->hw_info1 |= cpu_to_hc32(ehci, (1 << 7));	/* I = 1 */
+	hw->hw_info1 |= cpu_to_hc32(ehci, QH_INACTIVATE);
 #endif
 	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	hw->hw_qtd_next = EHCI_LIST_END(ehci);

commit c83e1a9ff68a6535b81c40dc8fda99348ab480fb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:25 2012 -0400

    USB: EHCI: don't refcount QHs
    
    This patch (as1567) removes ehci-hcd's reference counting of QH
    structures.  It's not necessary to refcount these things because they
    always get deallocated at exactly one spot in ehci_endpoint_disable()
    (except for two special QHs, ehci->async and ehci->dummy) and are
    never used again.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ab7306de8d16..1f8f792eec86 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1179,7 +1179,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		if (qh->clearing_tt)
 			goto idle_timeout;
 		if (list_empty (&qh->qtd_list)) {
-			qh_put (qh);
+			qh_destroy(ehci, qh);
 			break;
 		}
 		/* else FALL THROUGH */

commit 15be105b4a18c461b95fa683907f6da6deae1b75
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:17 2012 -0400

    USB: EHCI: remove unneeded suspend/resume code
    
    This patch (as1566) removes the code in ehci-hcd's resume routines
    which tries to restart or cancel any transfers left active while the
    root hub or controller was asleep.  This code isn't necessary, because
    all URBs are terminated before the root hub is suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8727f4ea343f..ab7306de8d16 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1312,13 +1312,6 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
 
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&ehci->lock);
-	if (ehci->reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&ehci->lock);
-
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */

commit 631fe9d9d20e28fffdf750d12dd2cd275bd654e9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:09 2012 -0400

    USB: EHCI: initialize data before resetting hardware
    
    Currently, EHCI initialization turns off the controller (in case it
    was left running by the firmware) before setting up the ehci_hcd data
    structure.  This patch (as1565) reverses that order.
    
    Although it doesn't matter now, it will matter later on when future
    additions to ehci_halt() will want to acquire a spinlock that gets
    initialized by ehci_init().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f9a783bfa1fe..8727f4ea343f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -823,12 +823,12 @@ static int ehci_setup(struct usb_hcd *hcd)
 
 	ehci->sbrn = HCD_USB2;
 
-	retval = ehci_halt(ehci);
+	/* data structure init */
+	retval = ehci_init(hcd);
 	if (retval)
 		return retval;
 
-	/* data structure init */
-	retval = ehci_init(hcd);
+	retval = ehci_halt(ehci);
 	if (retval)
 		return retval;
 

commit 1a49e2ac9651df7349867a5cf44e2c83de1046af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 9 15:55:14 2012 -0400

    EHCI: centralize controller initialization
    
    This patch (as1564c) converts the EHCI platform drivers to use the
    central ehci_setup() routine for generic controller initialization
    rather than each having its own idiosyncratic approach.
    
    The major point of difficulty lies in ehci-pci's many vendor- and
    device-specific workarounds.  Some of them have to be applied before
    calling ehci_setup() and some after, which necessitates a fair amount
    of code motion.  The other platform drivers require much smaller
    changes.
    
    One point not addressed by the patch is whether ports should be
    powered on or off following initialization.  The different drivers
    appear to handle this pretty much at random.  In fact it shouldn't
    matter, because the hub driver turns on power to all ports when it
    binds to the root hub.  Straightening that out will be left for
    another day.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e6823a0cf642..f9a783bfa1fe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -808,7 +808,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	return 0;
 }
 
-static int __maybe_unused ehci_setup (struct usb_hcd *hcd)
+static int ehci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
@@ -832,6 +832,9 @@ static int __maybe_unused ehci_setup (struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
+	if (ehci_is_TDI(ehci))
+		tdi_reset(ehci);
+
 	ehci_reset(ehci);
 
 	return 0;

commit c5cf9212a368d88fe1e25797699b167f6daa64a5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 28 11:19:02 2012 -0400

    EHCI: centralize controller suspend/resume
    
    This patch (as1563) removes a lot of duplicated code by moving the
    EHCI controller suspend/resume routines into the core driver, where
    the various platform drivers can invoke them as needed.
    
    Not only does this simplify these platform drivers, this also makes it
    easier for other platform drivers to add suspend/resume support in the
    future.
    
    Note: The patch does not touch the ehci-fsl.c file, because its
    approach to suspend and resume is so different from all the others.
    It will have to be handled specially by its maintainer.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c49fc1e7895d..e6823a0cf642 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1242,6 +1242,95 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 }
 
 /*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+
+/* suspend/resume, section 4.3 */
+
+/* These routines handle the generic parts of controller suspend/resume */
+
+static int __maybe_unused ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(10);
+
+	/*
+	 * Root hub was already suspended.  Disable IRQ emission and
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
+	 */
+	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
+
+	spin_lock_irq(&ehci->lock);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void) ehci_readl(ehci, &ehci->regs->intr_enable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	spin_unlock_irq(&ehci->lock);
+
+	return 0;
+}
+
+/* Returns 0 if power was preserved, 1 if power was lost */
+static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(100);
+
+	/* Mark hardware accessible again as we are back to full power by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/*
+	 * If CF is still set and we aren't resuming from hibernation
+	 * then we maintained suspend power.
+	 * Just undo the effect of ehci_suspend().
+	 */
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
+			!hibernated) {
+		int	mask = INTR_MASK;
+
+		ehci_prepare_ports_for_controller_resume(ehci);
+		if (!hcd->self.root_hub->do_remote_wakeup)
+			mask &= ~STS_PCD;
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
+		return 0;
+	}
+
+	/*
+	 * Else reset, to cope with power loss or resume from hibernation
+	 * having let the firmware kick in during reboot.
+	 */
+	usb_root_hub_lost_power(hcd->self.root_hub);
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq(&ehci->lock);
+	if (ehci->reclaim)
+		end_unlink_async(ehci);
+	ehci_work(ehci);
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	ehci->rh_state = EHCI_RH_SUSPENDED;
+	return 1;
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * The EHCI in ChipIdea HDRC cannot be a separate module or device,
  * because its registers (and irq) are shared between host/gadget/otg

commit a46af4ebf9ffec35eea0390e89935197b833dc61
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 25 12:19:03 2012 -0400

    USB: EHCI: define extension registers like normal ones
    
    This patch (as1562) cleans up the definitions of the EHCI extended
    registers to be consistent with the definitions of the standard
    registers.  This makes the code look a lot nicer, with no functional
    change.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 800be38c78b4..c49fc1e7895d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -203,11 +203,9 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 /* check TDI/ARC silicon is in host mode */
 static int tdi_in_host_mode (struct ehci_hcd *ehci)
 {
-	u32 __iomem	*reg_ptr;
 	u32		tmp;
 
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
-	tmp = ehci_readl(ehci, reg_ptr);
+	tmp = ehci_readl(ehci, &ehci->regs->usbmode);
 	return (tmp & 3) == USBMODE_CM_HC;
 }
 
@@ -303,11 +301,9 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
-	u32 __iomem	*reg_ptr;
 	u32		tmp;
 
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
-	tmp = ehci_readl(ehci, reg_ptr);
+	tmp = ehci_readl(ehci, &ehci->regs->usbmode);
 	tmp |= USBMODE_CM_HC;
 	/* The default byte access to MMR space is LE after
 	 * controller reset. Set the required endian mode
@@ -315,7 +311,7 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	 */
 	if (ehci_big_endian_mmio(ehci))
 		tmp |= USBMODE_BE;
-	ehci_writel(ehci, tmp, reg_ptr);
+	ehci_writel(ehci, tmp, &ehci->regs->usbmode);
 }
 
 /* reset a non-running (STS_HALT == 1) controller */
@@ -339,9 +335,8 @@ static int ehci_reset (struct ehci_hcd *ehci)
 
 	if (ehci->has_hostpc) {
 		ehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,
-			(u32 __iomem *)(((u8 *)ehci->regs) + USBMODE_EX));
-		ehci_writel(ehci, TXFIFO_DEFAULT,
-			(u32 __iomem *)(((u8 *)ehci->regs) + TXFILLTUNING));
+				&ehci->regs->usbmode_ex);
+		ehci_writel(ehci, TXFIFO_DEFAULT, &ehci->regs->txfill_tuning);
 	}
 	if (retval)
 		return retval;

commit 4f7a67e2dd49fbfba002c453bc24bf00e701cc71
Author: Ricardo Martins <rasm@fe.up.pt>
Date:   Tue May 22 18:02:03 2012 +0100

    USB: fix PS3 EHCI systems
    
    After commit aaa0ef289afe9186f81e2340114ea413eef0492a "PS3 EHCI QH
    read work-around", Terratec Grabby (em28xx) stopped working with AMD
    Geode LX 800 (USB controller AMD CS5536). Since this is a PS3 only
    fix, the following patch adds a conditional block around it.
    
    Signed-off-by: Ricardo Martins <rasm@fe.up.pt>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b100f5f9f4b6..800be38c78b4 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -671,7 +671,9 @@ static int ehci_init(struct usb_hcd *hcd)
 	hw = ehci->async->hw;
 	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
 	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+#if defined(CONFIG_PPC_PS3)
 	hw->hw_info1 |= cpu_to_hc32(ehci, (1 << 7));	/* I = 1 */
+#endif
 	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	hw->hw_qtd_next = EHCI_LIST_END(ehci);
 	ehci->async->qh_state = QH_STATE_LINKED;

commit 8e192910d96615a32646b8978b201b650f62ef34
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 21 08:54:43 2012 -0700

    Revert "USB: EHCI: work around bug in the Philips ISP1562 controller"
    
    This reverts commit 1996e6c572969a8cf6d7fa97eef621219acd94a9.
    
    It turned out to not be needed, now that the real fix has been
    committed.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5597e6099592..b100f5f9f4b6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -638,7 +638,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
 
-	if (HCC_PGM_FRAMELISTLEN(hcc_params) && !ehci->sched_size_bug) {
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
 		/* periodic schedule size can be smaller than default */
 		switch (EHCI_TUNE_FLS) {
 		case 0: ehci->periodic_size = 1024; break;

commit 1c01f1d9a603ecf1744ae2d1a015c4b27c2b9fa0
Author: Ming Lei <ming.lei@canonical.com>
Date:   Sat May 19 23:11:19 2012 +0800

    USB: EHCI: fix command register configuration lost problem
    
    The 3d9545cc375d117554a9b35dfddadf9189c62775(EHCI: maintain the
    ehci->command value properly) introducs one command register
    configuration lost problem by the below line in ehci_reset:
    
            ehci->command = ehci_readl(ehci, &ehci->regs->command);
    
    After writting RESET into command register, it is restored to
    its default value per EHCI spec[1], so the previous configuration
    will be lost, and may introduce some problems reported recently:
            - imx51 Babbage board detect usb hub failed[2], reported
            by Richard Zhao.
            - mouse and keyboard hangs in linux-next found by
            Dan Carpenter and Greg-KH.
    
    So this patch just removes the line to fix these problems, and
    keep configurating command register consistent as before the commit
    3d9545cc(EHCI: maintain the ehci->command value properly).
    
    [1], 4.1 Host Controller Initialization of EHCI Specification 1.0
    [2], failed dmesg log:
            usb 1-1: new high-speed USB device number 2 using mxc-ehci
            hub 1-1:1.0: USB hub found
            hub 1-1:1.0: 7 ports detected
            mxc-ehci mxc-ehci.1: fatal error
            mxc-ehci mxc-ehci.1: HC died; cleaning up
            mxc-ehci mxc-ehci.1: force halt; handshake f5780344 00004000 00004000 -> -110
            mxc-ehci mxc-ehci.1: HC died; cleaning up
            usb 1-1: USB disconnect, device number 2
    
    Reported-by: Richard Zhao <richard.zhao@freescale.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Chen Peter-B29397 <B29397@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f644ba9529ed..5597e6099592 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -352,7 +352,6 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci->debug)
 		dbgp_external_startup();
 
-	ehci->command = ehci_readl(ehci, &ehci->regs->command);
 	ehci->port_c_suspend = ehci->suspended_ports =
 			ehci->resuming_ports = 0;
 	return retval;

commit 1996e6c572969a8cf6d7fa97eef621219acd94a9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 14 13:48:16 2012 -0400

    USB: EHCI: work around bug in the Philips ISP1562 controller
    
    This patch (as1556) works around a bug in the Philips ISP1562 EHCI
    controller.  Although the controller claims to support frame-list
    lengths smaller than the default of 1024 for its periodic schedule, in
    fact smaller values don't work.  A new quirk flag is added to indicate
    when the bug is present, and if it is then the schedule size is left
    at the default value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5cb775b1802d..f644ba9529ed 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -639,7 +639,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
 
-	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+	if (HCC_PGM_FRAMELISTLEN(hcc_params) && !ehci->sched_size_bug) {
 		/* periodic schedule size can be smaller than default */
 		switch (EHCI_TUNE_FLS) {
 		case 0: ehci->periodic_size = 1024; break;

commit eb70e5ab8f95a81283623c03d2c99dfc59fcb319
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:54 2012 +0300

    usb: chipidea: add host role
    
    This adds EHCI host support to the chipidea driver. We want it to be
    part of the hdrc driver and not a standalone (sub-)driver module, as
    the structure of ehci-hcd.c suggests, so for chipidea controller we
    hack it to not provide platform-related code, but only the ehci hcd.
    
    The ehci-platform driver won't work for us here too, because the
    controller uses the same registers for both device and host mode and
    also otg-related bits, so it's not really possible to put ehci registers
    into a separate resource.
    
    This is not a pretty solution, but the alternative is exporting symbols
    from the chipidea driver to a ehci-chipidea driver and doing all the
    module refcounting.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index de1e689d3df0..5cb775b1802d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1246,6 +1246,13 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 }
 
 /*-------------------------------------------------------------------------*/
+/*
+ * The EHCI in ChipIdea HDRC cannot be a separate module or device,
+ * because its registers (and irq) are shared between host/gadget/otg
+ * functions  and in order to facilitate role switching we cannot
+ * give the ehci driver exclusive access to those.
+ */
+#ifndef CHIPIDEA_EHCI
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
@@ -1504,3 +1511,4 @@ static void __exit ehci_hcd_cleanup(void)
 }
 module_exit(ehci_hcd_cleanup);
 
+#endif /* CHIPIDEA_EHCI */

commit 3d9545cc375d117554a9b35dfddadf9189c62775
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 23 13:54:36 2012 -0400

    EHCI: maintain the ehci->command value properly
    
    The ehci-hcd driver is a little haphazard about keeping track of the
    state of the USBCMD register.  The ehci->command field is supposed to
    hold the register's value (apart from a few special bits) at all
    times, but it isn't maintained properly.
    
    This patch (as1543) cleans up the situation.  It keeps ehci->command
    up-to-date, and uses that value rather than reading the register from
    the hardware whenever possible.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a87c0573c860..de1e689d3df0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -226,8 +226,13 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	if ((temp & STS_HALT) != 0)
 		return 0;
 
+	/*
+	 * This routine gets called during probe before ehci->command
+	 * has been initialized, so we can't rely on its value.
+	 */
+	ehci->command &= ~CMD_RUN;
 	temp = ehci_readl(ehci, &ehci->regs->command);
-	temp &= ~CMD_RUN;
+	temp &= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &ehci->regs->command);
 	return handshake (ehci, &ehci->regs->status,
 			  STS_HALT, STS_HALT, 16 * 125);
@@ -347,6 +352,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci->debug)
 		dbgp_external_startup();
 
+	ehci->command = ehci_readl(ehci, &ehci->regs->command);
 	ehci->port_c_suspend = ehci->suspended_ports =
 			ehci->resuming_ports = 0;
 	return retval;
@@ -363,16 +369,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 #endif
 
 	/* wait for any schedule enables/disables to take effect */
-	temp = ehci_readl(ehci, &ehci->regs->command) << 10;
-	temp &= STS_ASS | STS_PSS;
+	temp = (ehci->command << 10) & (STS_ASS | STS_PSS);
 	if (handshake_on_error_set_halt(ehci, &ehci->regs->status,
 					STS_ASS | STS_PSS, temp, 16 * 125))
 		return;
 
 	/* then disable anything that's still active */
-	temp = ehci_readl(ehci, &ehci->regs->command);
-	temp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
-	ehci_writel(ehci, temp, &ehci->regs->command);
+	ehci->command &= ~(CMD_ASE | CMD_PSE);
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake_on_error_set_halt(ehci, &ehci->regs->status,

commit 09091a4d5f2dd378dcf71de50b48cdacc58a8ac0
Merge: 66f75a5d028b 3a1c2a82204f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 22 15:25:26 2012 -0700

    Merge 3.4-rc4 into usb-next.
    
    This resolves the conflict in:
            drivers/usb/host/ehci-fsl.c
    And picks up loads of xhci bugfixes to make it easier for others to test
    with.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c256667f0468ebb353c9b11b7feed5c5cba1bd9a
Author: Steven J. Hill <sjhill@mips.com>
Date:   Thu Apr 19 12:57:31 2012 -0500

    usb: host: mips: sead3: USB Host controller support for SEAD-3 platform.
    
    Add EHCI driver for MIPS SEAD-3 development platform.
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 343f40c23b5f..9ca6359c4ff1 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1364,6 +1364,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_ls1x_driver
 #endif
 
+#ifdef CONFIG_MIPS_SEAD3
+#include "ehci-sead3.c"
+#define	PLATFORM_DRIVER		ehci_hcd_sead3_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_HCD_PLATFORM
 #include "ehci-platform.c"
 #define PLATFORM_DRIVER		ehci_platform_driver

commit 6feff1b92bedab133c5835e510d11f62e843b257
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 17 15:23:25 2012 -0400

    EHCI: don't try to clear the IAAD bit
    
    This patch (as1541) corrects a small mistake in ehci-hcd.  The IAAD
    (Interrupt on Async Advance Doorbell) bit in the USBCMD register is
    designed, as its name says, to act as a "doorbell".  That is, the
    driver activates the bit by setting it to 1, and the hardware
    deactivates it later by setting it back to 0.  The driver cannot clear
    the bit by writing a 0 to it; such writes are simply ignored.
    
    Therefore there is no reason for ehci-hcd to try to clear the bit.
    The patch removes the two instances where such attempts occur.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 057cdda7a489..343f40c23b5f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -415,9 +415,6 @@ static void ehci_iaa_watchdog(unsigned long param)
 		 * CMD_IAAD when it sets STS_IAA.)
 		 */
 		cmd = ehci_readl(ehci, &ehci->regs->command);
-		if (cmd & CMD_IAAD)
-			ehci_writel(ehci, cmd & ~CMD_IAAD,
-					&ehci->regs->command);
 
 		/* If IAA is set here it either legitimately triggered
 		 * before we cleared IAAD above (but _way_ late, so we'll
@@ -887,11 +884,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
 		/* guard against (alleged) silicon errata */
-		if (cmd & CMD_IAAD) {
-			ehci_writel(ehci, cmd & ~CMD_IAAD,
-					&ehci->regs->command);
+		if (cmd & CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		}
 		if (ehci->reclaim) {
 			COUNT(ehci->stats.reclaim);
 			end_unlink_async(ehci);

commit 2fbe2bf1fd37f9d99950bd8d8093623cf22cf08b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Apr 18 11:33:00 2012 -0400

    EHCI: always clear the STS_FLR status bit
    
    This patch (as1544) fixes a problem affecting some EHCI controllers.
    They can generate interrupts whenever the STS_FLR status bit is turned
    on, even though that bit is masked out in the Interrupt Enable
    register.
    
    Since the driver doesn't use STS_FLR anyway, the patch changes the
    interrupt routine to clear that bit whenever it is set, rather than
    leaving it alone.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Tomoya MORINAGA <tomoya.rohm@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 95ca07a8e1b5..4a3bc5b7a06f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -858,8 +858,13 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		goto dead;
 	}
 
+	/*
+	 * We don't use STS_FLR, but some controllers don't like it to
+	 * remain on, so mask it out along with the other status bits.
+	 */
+	masked_status = status & (INTR_MASK | STS_FLR);
+
 	/* Shared IRQ? */
-	masked_status = status & INTR_MASK;
 	if (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {
 		spin_unlock(&ehci->lock);
 		return IRQ_NONE;

commit dc75ce9d929aabeb0843a6b1a4ab320e58ba1597
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 17 15:24:15 2012 -0400

    EHCI: fix criterion for resuming the root hub
    
    This patch (as1542) changes the criterion ehci-hcd uses to tell when
    it needs to resume the controller's root hub.  A resume is needed when
    a port status change is detected, obviously, but only if the root hub
    is currently suspended.
    
    Right now the driver tests whether the root hub is running, and that
    is not the correct test.  In particular, if the controller has died
    then the root hub should not be restarted.  In addition, some buggy
    hardware occasionally requires the root hub to be running and
    sending out SOF packets even while it is nominally supposed to be
    suspended.
    
    In the end, the test needs to be changed.  Rather than checking whether
    the root hub is currently running, the driver will now check whether
    the root hub is currently suspended.  This will yield the correct
    behavior in all cases.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <B29397@freescale.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 806cc95317aa..95ca07a8e1b5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -910,7 +910,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		pcd_status = status;
 
 		/* resume root hub? */
-		if (!(cmd & CMD_RUN))
+		if (ehci->rh_state == EHCI_RH_SUSPENDED)
 			usb_hcd_resume_root_hub(hcd);
 
 		/* get per-port change detect bits */

commit a448e4dc25303fe551e4dafe16c8c7c34f1b9d82
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 3 15:24:30 2012 -0400

    EHCI: keep track of ports being resumed and indicate in hub_status_data
    
    This patch (as1537) adds a bit-array to ehci-hcd for keeping track of
    which ports are undergoing a resume transition.  If any of the bits
    are set when ehci_hub_status_data() is called, the routine will return
    a nonzero value even if no ports have any status changes pending.
    This will allow usbcore to handle races between root-hub suspend and
    port wakeup.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    CC: Chen Peter-B29397 <B29397@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 057cdda7a489..806cc95317aa 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -347,6 +347,8 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci->debug)
 		dbgp_external_startup();
 
+	ehci->port_c_suspend = ehci->suspended_ports =
+			ehci->resuming_ports = 0;
 	return retval;
 }
 
@@ -939,6 +941,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 * like usb_port_resume() does.
 			 */
 			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
+			set_bit(i, &ehci->resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index aede6374e4b6..057cdda7a489 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -45,7 +45,6 @@
 #include <asm/byteorder.h>
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/system.h>
 #include <asm/unaligned.h>
 
 #if defined(CONFIG_PPC_PS3)

commit 5d98cd4e1df9587963ade40ef29bef604fb3920a
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Tue Mar 13 01:04:53 2012 +0100

    USB: use generic platform driver on ath79
    
    The ath79 usb driver doesn't do anything special and is now converted
    to the generic ehci and ohci driver.
    This was tested on a TP-Link TL-WR1043ND (AR9132)
    
    Acked-by: Gabor Juhos <juhosg@openwrt.org>
    CC: Imre Kaloz <kaloz@openwrt.org>
    CC: linux-mips@linux-mips.org
    CC: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c97b2b6378d6..aede6374e4b6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1351,11 +1351,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		s5p_ehci_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_ATH79
-#include "ehci-ath79.c"
-#define PLATFORM_DRIVER		ehci_ath79_driver
-#endif
-
 #ifdef CONFIG_SPARC_LEON
 #include "ehci-grlib.c"
 #define PLATFORM_DRIVER		ehci_grlib_driver

commit 7a7a4a592f42d9abf3b6cc40620b3f79fef49246
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Tue Mar 13 01:04:48 2012 +0100

    USB: EHCI: Add a generic platform device driver
    
    This adds a generic driver for platform devices. It works like the PCI
    driver and is based on it. This is for devices which do not have an own
    bus but their EHCI controller works like a PCI controller. It will be
    used for the Broadcom bcma and ssb USB EHCI controller.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 06e2548b549c..c97b2b6378d6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1376,6 +1376,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_ls1x_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_HCD_PLATFORM
+#include "ehci-platform.c"
+#define PLATFORM_DRIVER		ehci_platform_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 0cedc4e1c870d5d4811b3ed2aca98b41334f10e4
Author: Neil Zhang <zhangwm@marvell.com>
Date:   Fri Feb 24 10:14:40 2012 +0800

    usb: host: remove ehci-pxa168.c
    
    Since ehci-mv.c can cover Marvell PXA and MMP series including PXA168,
    so this driver seems redundant now.
    
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Cc: <tanmay.upadhyay@einfochips.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4918b0c59af9..06e2548b549c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1361,11 +1361,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_grlib_driver
 #endif
 
-#ifdef CONFIG_USB_PXA168_EHCI
-#include "ehci-pxa168.c"
-#define PLATFORM_DRIVER		ehci_pxa168_driver
-#endif
-
 #ifdef CONFIG_CPU_XLR
 #include "ehci-xls.c"
 #define PLATFORM_DRIVER		ehci_xls_driver

commit f30cdbcb2e6a7b9cdebe2117a7b623a5b3832a75
Author: Kelvin Cheung <keguang.zhang@gmail.com>
Date:   Wed Jan 18 14:41:16 2012 +0800

    USB: Add EHCI bus glue for Loongson1x SoCs (UPDATED)
    
    Use ehci_setup() in ehci_ls1x_reset().
    
    The Loongson1x SoCs have a built-in EHCI controller.
    This patch adds the necessary glue code to make the generic EHCI
    driver usable for them.
    
    Signed-off-by: Kelvin Cheung <keguang.zhang@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a007a9fe0f87..4918b0c59af9 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1376,6 +1376,11 @@ MODULE_LICENSE ("GPL");
 #define        PLATFORM_DRIVER         ehci_mv_driver
 #endif
 
+#ifdef CONFIG_MACH_LOONGSON1
+#include "ehci-ls1x.c"
+#define PLATFORM_DRIVER		ehci_ls1x_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e311a511529b..a007a9fe0f87 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -112,7 +112,7 @@ module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
 /* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc = 0;
+static bool ignore_oc = 0;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 

commit ee0db58ade2c60342a7d648f375d0a4107c39527
Merge: eea9fc7ddda8 eeb720fb21d6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 22 14:05:01 2011 -0800

    Merge branch 'for-gadget/next' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    * 'for-gadget/next' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (24 commits)
      usb: dwc3: gadget: add support for SG lists
      usb: dwc3: gadget: don't force 'LST' always
      usb: dwc3: gadget: don't return anything on prepare trbs
      usb: dwc3: gadget: re-factor dwc3_prepare_trbs()
      usb: gadget: introduce support for sg lists
      usb: renesas: pipe: convert a long if into a XOR operation
      usb: gadget: remove useless depends on Kconfig
      usb: gadget: s3c-hsudc: remove the_controller global
      usb: gadget: s3c-hsudc: use release_mem_region instead of release_resource
      usb: gadget: s3c-hsudc: Add regulator handling
      usb: gadget: s3c-hsudc: use udc_start and udc_stop functions
      usb: gadget: s3c-hsudc: move device registration to probe
      usb: gadget: s3c-hsudc: add missing otg_put_transceiver in probe
      usb: gadget: s3c-hsudc: add __devinit to probe function
      usb: gadget: s3c-hsudc: move platform_data struct to global header
      USB: EHCI: Add Marvell Host Controller driver
      USB: OTG: add Marvell usb OTG driver support
      usb: gadget: mv_udc: drop ARCH dependency
      usb: gadget: mv_udc: fix bug in ep_dequeue
      usb: gadget: enlarge maxburst bit width.
      ...

commit 3a082ec9b2f544a81e977cfa259e3f990a995dc8
Author: Neil Zhang <zhangwm@marvell.com>
Date:   Tue Dec 20 13:20:23 2011 +0800

    USB: EHCI: Add Marvell Host Controller driver
    
    This patch adds support for EHCI compliant HSUSB Host controller found
    on Marvell Socs.
    
    It fits both OTG and SPH controller on marvell Socs, including
    PXA9xx/MMP2/MMP3/MGx.
    
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3ff9f82f7263..b05e7533d08f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1329,6 +1329,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_xls_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MV
+#include "ehci-mv.c"
+#define        PLATFORM_DRIVER         ehci_mv_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 332ceddb8c4ba2367abcb9a94a69386b2785441b
Merge: a36ae95c4e22 aaa0ef289afe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Dec 9 16:09:49 2011 -0800

    Merge branch 'for-usb' of git://git.kernel.org/pub/scm/linux/kernel/git/geoff/ps3-linux into usb-next
    
    * 'for-usb' of git://git.kernel.org/pub/scm/linux/kernel/git/geoff/ps3-linux:
      usb: PS3 EHCI QH read work-around
      usb: Fix PS3 EHCI suspend
      usb: PS3 EHCI HC reset work-around
      usb: Remove ehci_reset call from ehci_run

commit aaa0ef289afe9186f81e2340114ea413eef0492a
Author: Geoff Levand <geoff@infradead.org>
Date:   Tue Nov 8 16:01:18 2011 -0800

    usb: PS3 EHCI QH read work-around
    
    PS3 EHCI HC errata fix 244.  The SCC EHCI HC will not correctly perform QH
    reads that occur near or span a micro-frame boundry.  This is due to a problem
    in the Nak Count Reload Control logic (EHCI Specification 1.0 Section 4.9.1).
    
    The work-around for this problem is for the HC driver to set I=1 (inactive) for
    QHs with H=1 (list head).
    
    Signed-off-by: Geoff Levand <geoff@infradead.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e0ca9955880b..9496b7d7ab25 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -670,6 +670,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	hw = ehci->async->hw;
 	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
 	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+	hw->hw_info1 |= cpu_to_hc32(ehci, (1 << 7));	/* I = 1 */
 	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	hw->hw_qtd_next = EHCI_LIST_END(ehci);
 	ehci->async->qh_state = QH_STATE_LINKED;

commit df7c1ca229ebffe14a6fb3f13d16b1dd2a1731cb
Author: Geoff Levand <geoff@infradead.org>
Date:   Wed Nov 30 16:40:57 2011 -0800

    usb: Fix PS3 EHCI suspend
    
    The EHCI USB controller of the Cell Super Companion Chip used in the PS3
    will stop the root hub after all root hub ports are suspended.  When in
    this condition the ehci-hcd handshake routine will return -ETIMEDOUT and
    the USB runtime suspend sequence will fail.  The STS_HLT bit will not be
    set, so inspection of the frame index is used to test for the condition.
    
    Add a new routine handshake_for_broken_root_hub() that is called after
    an unsuccessful -ETIMEDOUT handshake.  On PS3 handshake_for_broken_root_hub()
    will test for the condition, and if found will return success to allow the
    USB suspend to complete.  For all other platforms
    handshake_for_broken_root_hub() will return -ETIMEDOUT
    
    Signed-off-by: Geoff Levand <geoff@infradead.org>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 46dccbf85c1a..e0ca9955880b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -48,6 +48,10 @@
 #include <asm/system.h>
 #include <asm/unaligned.h>
 
+#if defined(CONFIG_PPC_PS3)
+#include <asm/firmware.h>
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -230,12 +234,58 @@ static int ehci_halt (struct ehci_hcd *ehci)
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
+#if defined(CONFIG_USB_SUSPEND) && defined(CONFIG_PPC_PS3)
+
+/*
+ * The EHCI controller of the Cell Super Companion Chip used in the
+ * PS3 will stop the root hub after all root hub ports are suspended.
+ * When in this condition handshake will return -ETIMEDOUT.  The
+ * STS_HLT bit will not be set, so inspection of the frame index is
+ * used here to test for the condition.  If the condition is found
+ * return success to allow the USB suspend to complete.
+ */
+
+static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
+					 void __iomem *ptr, u32 mask, u32 done,
+					 int usec)
+{
+	unsigned int old_index;
+	int error;
+
+	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
+		return -ETIMEDOUT;
+
+	old_index = ehci_read_frame_index(ehci);
+
+	error = handshake(ehci, ptr, mask, done, usec);
+
+	if (error == -ETIMEDOUT && ehci_read_frame_index(ehci) == old_index)
+		return 0;
+
+	return error;
+}
+
+#else
+
+static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
+					 void __iomem *ptr, u32 mask, u32 done,
+					 int usec)
+{
+	return -ETIMEDOUT;
+}
+
+#endif
+
 static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 				       u32 mask, u32 done, int usec)
 {
 	int error;
 
 	error = handshake(ehci, ptr, mask, done, usec);
+	if (error == -ETIMEDOUT)
+		error = handshake_for_broken_root_hub(ehci, ptr, mask, done,
+						      usec);
+
 	if (error) {
 		ehci_halt(ehci);
 		ehci->rh_state = EHCI_RH_HALTED;

commit 876e0df902c726408c84b75dab673a90fd492e1d
Author: Geoff Levand <geoff@infradead.org>
Date:   Tue Nov 22 18:04:45 2011 -0800

    usb: Remove ehci_reset call from ehci_run
    
    Remove the ehci_reset() call done in the ehci_run() routine of the
    USB EHCI host controller driver and add an ehci_reset() call to the
    probe processing of all EHCI platform drivers that do not already call
    ehci_reset().
    
    The call to ehci_reset() from ehci_run() was problematic for several
    platform drivers, and unnecessary for others.  This change moves the
    decision to call ehci_reset() at driver startup to the platform
    driver code.
    
    Signed-off-by: Geoff Levand <geoff@infradead.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3ff9f82f7263..46dccbf85c1a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -677,22 +677,13 @@ static int ehci_init(struct usb_hcd *hcd)
 static int ehci_run (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	int			retval;
 	u32			temp;
 	u32			hcc_params;
 
 	hcd->uses_new_polling = 1;
 
 	/* EHCI spec section 4.1 */
-	/*
-	 * TDI driver does the ehci_reset in their reset callback.
-	 * Don't reset here, because configuration settings will
-	 * vanish.
-	 */
-	if (!ehci_is_TDI(ehci) && (retval = ehci_reset(ehci)) != 0) {
-		ehci_mem_cleanup(ehci);
-		return retval;
-	}
+
 	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
 	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
 

commit 3af5154a869bc278a829bb03e65a709480e821b0
Author: Jayachandran C <jayachandranc@netlogicmicro.com>
Date:   Fri Nov 18 12:12:42 2011 +0530

    usb: Netlogic: Use CPU_XLR in place of NLM_XLR
    
    Use CONFIG_CPU_XLR instead of CONFIG_NLM_XLR, the NLM_XLR config
    option is redundant and is being removed.
    
    Signed-off-by: Jayachandran C <jayachandranc@netlogicmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3ff9f82f7263..0f15d392aae1 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1324,7 +1324,7 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_pxa168_driver
 #endif
 
-#ifdef CONFIG_NLM_XLR
+#ifdef CONFIG_CPU_XLR
 #include "ehci-xls.c"
 #define PLATFORM_DRIVER		ehci_xls_driver
 #endif

commit d6748066ad0e8b2514545998f8367ebb3906f299
Merge: f04c045f8ce6 3ba1e543ab4b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 3 13:28:14 2011 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (37 commits)
      MIPS: O32: Provide definition of registers ta0 .. ta3.
      MIPS: perf: Add Octeon support for hardware perf.
      MIPS: perf: Add support for 64-bit perf counters.
      MIPS: perf: Reorganize contents of perf support files.
      MIPS: perf: Cleanup formatting in arch/mips/kernel/perf_event.c
      MIPS: Add accessor macros for 64-bit performance counter registers.
      MIPS: Add probes for more Octeon II CPUs.
      MIPS: Add more CPU identifiers for Octeon II CPUs.
      MIPS: XLR, XLS: Add comment for smp setup
      MIPS: JZ4740: GPIO: Check correct IRQ in demux handler
      MIPS: JZ4740: GPIO: Simplify IRQ demuxer
      MIPS: JZ4740: Use generic irq chip
      MIPS: Alchemy: remove all CONFIG_SOC_AU1??? defines
      MIPS: Alchemy: kill au1xxx.h header
      MIPS: Alchemy: clean DMA code of CONFIG_SOC_AU1??? defines
      MIPS, IDE: Alchem, au1xxx-ide: Remove pb1200/db1200 header dep
      MIPS: Alchemy: Redo PCI as platform driver
      MIPS: Alchemy: more base address cleanup
      MIPS: Alchemy: rewrite USB platform setup.
      MIPS: Alchemy: abstract USB block control register access
      ...
    
    Fix up trivial conflicts in:
            arch/mips/alchemy/devboards/db1x00/platform.c
            drivers/ide/Kconfig
            drivers/mmc/host/au1xmmc.c
            drivers/video/Kconfig
            sound/mips/Kconfig

commit 3766386037827fe7064f57f9aec27b3b5e9417aa
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:45 2011 +0200

    MIPS: Alchemy: remove all CONFIG_SOC_AU1??? defines
    
    Now that no driver any longer depends on the CONFIG_SOC_AU1???  symbols,
    it's time to get rid of them: Move some of the platform devices to the
    boards which can use them, Rename a few (unused) constants in the header,
    Replace them with MIPS_ALCHEMY in the various Kconfig files.  Finally
    delete them altogether from the Alchemy Kconfig file.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2707/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f72ae0b6ee7f..47aa22d43d63 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1196,7 +1196,7 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif
 
-#ifdef CONFIG_SOC_AU1200
+#ifdef CONFIG_MIPS_ALCHEMY
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif

commit 68aa95d5d4de31c9348c1628ffa85c805305ebc5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 12 10:39:14 2011 -0400

    EHCI: workaround for MosChip controller bug
    
    This patch (as1489) works around a hardware bug in MosChip EHCI
    controllers.  Evidently when one of these controllers increments the
    frame-index register, it changes the three low-order bits (the
    microframe counter) before changing the higher order bits (the frame
    counter).  If the register is read at just the wrong time, the value
    obtained is too low by 8.
    
    When the appropriate quirk flag is set, we work around this problem by
    reading the frame-index register a second time if the first value's
    three low-order bits are all 0.  This gives the hardware a chance to
    finish updating the register, yielding the correct value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Jason N Pitt <jpitt@fhcrc.org>
    CC: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 05abbcd93cf4..59e81615e09c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1195,8 +1195,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 static int ehci_get_frame (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	return (ehci_readl(ehci, &ehci->regs->frame_index) >> 3) %
-		ehci->periodic_size;
+	return (ehci_read_frame_index(ehci) >> 3) % ehci->periodic_size;
 }
 
 /*-------------------------------------------------------------------------*/

commit 2093c6b49c8f1dc581d8953aca71297d4cace55e
Author: Matthieu CASTET <castet.matthieu@free.fr>
Date:   Sat Jul 2 19:47:33 2011 +0200

    EHCI : introduce a common ehci_setup
    
    This allow to clean duplicated code in most of SOC driver.
    
    Signed-off-by: Matthieu CASTET <castet.matthieu@free.fr>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>  # fixes 3.1 build error
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2f0cf863b379..05abbcd93cf4 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -768,6 +768,35 @@ static int ehci_run (struct usb_hcd *hcd)
 	return 0;
 }
 
+static int __maybe_unused ehci_setup (struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	ehci->regs = (void __iomem *)ehci->caps +
+	    HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	ehci->sbrn = HCD_USB2;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci_reset(ehci);
+
+	return 0;
+}
+
 /*-------------------------------------------------------------------------*/
 
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)

commit fcda37cb42cc0aa039a2d1e06ec801e4e9f417f4
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Mon Sep 5 21:05:57 2011 +0800

    usb: ehci: fix comment for EHCI_SHRINK_JIFFIES
    
    EHCI_SHRINK_JIFFIES should be 5ms, which was just used originally,
    and not 200ms, so fix it.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8696489cde56..2f0cf863b379 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -95,7 +95,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
-						/* 200-ms async qh unlink delay */
+						/* 5-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6

commit e8799906045302776b35b66b16495c575db3b69c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 18 16:31:30 2011 -0400

    USB: EHCI: remove usages of hcd->state
    
    This patch (as1483) improves the ehci-hcd driver family by getting rid
    of the reliance on the hcd->state variable.  It has no clear owner and
    it isn't protected by the usual HCD locks.  In its place, the patch
    adds a new, private ehci->rh_state field to record the state of the
    root hub.
    
    Along the way, the patch removes a couple of lines containing
    redundant assignments to the state variable.  Also, the QUIESCING
    state simply gets changed to the RUNNING state, because the driver
    doesn't make any distinction between them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2af3e2a89efc..8696489cde56 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -238,7 +238,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 	error = handshake(ehci, ptr, mask, done, usec);
 	if (error) {
 		ehci_halt(ehci);
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+		ehci->rh_state = EHCI_RH_HALTED;
 		ehci_err(ehci, "force halt; handshake %p %08x %08x -> %d\n",
 			ptr, mask, done, error);
 	}
@@ -278,7 +278,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
 	ehci_writel(ehci, command, &ehci->regs->command);
-	ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	ehci->rh_state = EHCI_RH_HALTED;
 	ehci->next_statechange = jiffies;
 	retval = handshake (ehci, &ehci->regs->command,
 			    CMD_RESET, 0, 250 * 1000);
@@ -307,7 +307,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	u32	temp;
 
 #ifdef DEBUG
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
+	if (ehci->rh_state != EHCI_RH_RUNNING)
 		BUG ();
 #endif
 
@@ -356,7 +356,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	 */
 	if (ehci->reclaim
 			&& !timer_pending(&ehci->iaa_watchdog)
-			&& HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
+			&& ehci->rh_state == EHCI_RH_RUNNING) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely
@@ -496,7 +496,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
+	if (ehci->rh_state == EHCI_RH_RUNNING &&
 			(ehci->async->qh_next.ptr != NULL ||
 			 ehci->periodic_sched != 0))
 		timer_action (ehci, TIMER_IO_WATCHDOG);
@@ -516,7 +516,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
-	if (HC_IS_RUNNING (hcd->state))
+	if (ehci->rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
 
 	ehci_silence_controller(ehci);
@@ -741,7 +741,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * be started before the port switching actions could complete.
 	 */
 	down_write(&ehci_cf_port_reset_rwsem);
-	hcd->state = HC_STATE_RUNNING;
+	ehci->rh_state = EHCI_RH_RUNNING;
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 	msleep(5);
@@ -788,7 +788,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* Shared IRQ? */
 	masked_status = status & INTR_MASK;
-	if (!masked_status || unlikely(hcd->state == HC_STATE_HALT)) {
+	if (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {
 		spin_unlock(&ehci->lock);
 		return IRQ_NONE;
 	}
@@ -952,7 +952,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state) && ehci->reclaim)
+	if (ehci->rh_state != EHCI_RH_RUNNING && ehci->reclaim)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1079,7 +1079,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto idle_timeout;
 	}
 
-	if (!HC_IS_RUNNING (hcd->state))
+	if (ehci->rh_state != EHCI_RH_RUNNING)
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:

commit 23106343db66171c94ae486d2035478ec575b228
Author: Jayachandran C <jayachandranc@netlogicmicro.com>
Date:   Fri Aug 5 01:28:22 2011 +0530

    usb: OHCI/EHCI support for Netlogic XLS processor.
    
    Add supprt for on-chip USB controller for Netlogic XLS MIPS64
    SoC processor family.
    Changes are:
     - update ehci-hcd.c and ohci-hcd.c to add XLS hcds
     - add ehci-xls.c: EHCI support for Netlogic XLS.
     - add ohci-xls.c: OHCI support for Netlogic XLS.
    
    Signed-off-by: Jayachandran C <jayachandranc@netlogicmicro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 750f60fe6a9f..2af3e2a89efc 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1296,6 +1296,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_pxa168_driver
 #endif
 
+#ifdef CONFIG_NLM_XLR
+#include "ehci-xls.c"
+#define PLATFORM_DRIVER		ehci_xls_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 3abd7f68b28dcf6394c71c998376fc7bc92342c4
Author: Tanmay Upadhyay <tanmay.upadhyay@einfochips.com>
Date:   Wed Jul 20 10:00:58 2011 +0530

    USB: pxa168: Add onchip USB host controller support
    
    - Add EHCI Host controller driver
    - Add wrapper that creates resources for host controller driver
    
    v2 - Call clk_put() after clk_disable() in probe function
    
    Signed-off-by: Tanmay Upadhyay <tanmay.upadhyay@einfochips.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f72ae0b6ee7f..750f60fe6a9f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1291,6 +1291,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_grlib_driver
 #endif
 
+#ifdef CONFIG_USB_PXA168_EHCI
+#include "ehci-pxa168.c"
+#define PLATFORM_DRIVER		ehci_pxa168_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit f549953c15deab4c54708b39af86d4edecc6cddc
Merge: f0deb97ab13a e04f5f7e4230
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 23:08:32 2011 -0700

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (115 commits)
      EHCI: fix direction handling for interrupt data toggles
      USB: serial: add IDs for WinChipHead USB->RS232 adapter
      USB: OHCI: fix another regression for NVIDIA controllers
      usb: gadget: m66592-udc: add pullup function
      usb: gadget: m66592-udc: add function for external controller
      usb: gadget: r8a66597-udc: add pullup function
      usb: renesas_usbhs: support multi driver
      usb: renesas_usbhs: inaccessible pipe is not an error
      usb: renesas_usbhs: care buff alignment when dma handler
      USB: PL2303: correctly handle baudrates above 115200
      usb: r8a66597-hcd: fixup USB_PORT_STAT_C_SUSPEND shift
      usb: renesas_usbhs: compile/config are rescued
      usb: renesas_usbhs: fixup comment-out
      usb: update email address in ohci-sh and r8a66597-hcd
      usb: r8a66597-hcd: add function for external controller
      EHCI: only power off port if over-current is active
      USB: mon: Allow to use usbmon without debugfs
      USB: EHCI: go back to using the system clock for QH unlinks
      ehci: add pci quirk for Ordissimo and RM Slate 100 too
      ehci: refactor pci quirk to use standard dmi_check_system method
      ...
    
    Fix up trivial conflicts in Documentation/feature-removal-schedule.txt

commit 004c19682884d4f40000ce1ded53f4a1d0b18206
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jul 5 12:34:05 2011 -0400

    USB: EHCI: go back to using the system clock for QH unlinks
    
    This patch (as1477) fixes a problem affecting a few types of EHCI
    controller.  Contrary to what one might expect, these controllers
    automatically stop their internal frame counter when no ports are
    enabled.  Since ehci-hcd currently relies on the frame counter for
    determining when it should unlink QHs from the async schedule, those
    controllers run into trouble: The frame counter stops and the QHs
    never get unlinked.
    
    Some systems have also experienced other problems traced back to
    commit b963801164618e25fbdc0cd452ce49c3628b46c8 (USB: ehci-hcd unlink
    speedups), which made the original switch from using the system clock
    to using the frame counter.  It never became clear what the reason was
    for these problems, but evidently it is related to use of the frame
    counter.
    
    To fix all these problems, this patch more or less reverts that commit
    and goes back to using the system clock.  But this can't be done
    cleanly because other changes have since been made to the scan_async()
    subroutine.  One of these changes involved the tricky logic that tries
    to avoid rescanning QHs that have already been seen when the scanning
    loop is restarted, which happens whenever an URB is given back.
    Switching back to clock-based unlinks would make this logic even more
    complicated.
    
    Therefore the new code doesn't rescan the entire async list whenever a
    giveback occurs.  Instead it rescans only the current QH and continues
    on from there.  This requires the use of a separate pointer to keep
    track of the next QH to scan, since the current QH may be unlinked
    while the scanning is in progress.  That new pointer must be global,
    so that it can be adjusted forward whenever the _next_ QH gets
    unlinked.  (uhci-hcd uses this same trick.)
    
    Simplification of the scanning loop removes a level of indentation,
    which accounts for the size of the patch.  The amount of code changed
    is relatively small, and it isn't exactly a reversion of the
    b963801164 commit.
    
    This fixes Bugzilla #32432.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: <stable@kernel.org>
    Tested-by: Matej Kenda <matejken@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4ee62bef3723..2902199fa8ff 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -90,7 +90,8 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
+#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
+						/* 200-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -148,10 +149,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
-			/* add a jiffie since we synch against the
-			 * 8 KHz uframe counter.
-			 */
-			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			t = EHCI_SHRINK_JIFFIES;
 			break;
 		}
 		mod_timer(&ehci->watchdog, t + jiffies);

commit cc62a7eb6396e8be95b9a30053ed09191818b99b
Author: Kirill Smelkov <kirr@mns.spb.ru>
Date:   Sun Jul 3 20:36:57 2011 +0400

    USB: EHCI: Allow users to override 80% max periodic bandwidth
    
    There are cases, when 80% max isochronous bandwidth is too limiting.
    
    For example I have two USB video capture cards which stream uncompressed
    video, and to stream full NTSC + PAL videos we'd need
    
        NTSC 640x480 YUV422 @30fps      ~17.6 MB/s
        PAL  720x576 YUV422 @25fps      ~19.7 MB/s
    
    isoc bandwidth.
    
    Now, due to limited alt settings in capture devices NTSC one ends up
    streaming with max_pkt_size=2688  and  PAL with max_pkt_size=2892, both
    with interval=1. In terms of microframe time allocation this gives
    
        NTSC    ~53us
        PAL     ~57us
    
    and together
    
        ~110us  >  100us == 80% of 125us uframe time.
    
    So those two devices can't work together simultaneously because the'd
    over allocate isochronous bandwidth.
    
    80% seemed a bit arbitrary to me, and I've tried to raise it to 90% and
    both devices started to work together, so I though sometimes it would be
    a good idea for users to override hardcoded default of max 80% isoc
    bandwidth.
    
    After all, isn't it a user who should decide how to load the bus? If I
    can live with 10% or even 5% bulk bandwidth that should be ok. I'm a USB
    newcomer, but that 80% set in stone by USB 2.0 specification seems to be
    chosen pretty arbitrary to me, just to serve as a reasonable default.
    
    NOTE 1
    ~~~~~~
    
    for two streams with max_pkt_size=3072 (worst case) both time
    allocation would be 60us+60us=120us which is 96% periodic bandwidth
    leaving 4% for bulk and control.  Alan Stern suggested that bulk then
    would be problematic (less than 300*8 bittimes left per microframe), but
    I think that is still enough for control traffic.
    
    NOTE 2
    ~~~~~~
    
    Sarah Sharp expressed concern that maxing out periodic bandwidth
    could lead to vendor-specific hardware bugs on host controllers, because
    
    > It's entirely possible that you'll run into
    > vendor-specific bugs if you try to pack the schedule with isochronous
    > transfers.  I don't think any hardware designer would seriously test or
    > validate their hardware with a schedule that is basically a violation of
    > the USB bus spec (more than 80% for periodic transfers).
    
    So far I've only tested this patch on my HP Mini 5103 with N10 chipset
    
        kirr@mini:~$ lspci
        00:00.0 Host bridge: Intel Corporation N10 Family DMI Bridge
        00:02.0 VGA compatible controller: Intel Corporation N10 Family Integrated Graphics Controller
        00:02.1 Display controller: Intel Corporation N10 Family Integrated Graphics Controller
        00:1b.0 Audio device: Intel Corporation N10/ICH 7 Family High Definition Audio Controller (rev 02)
        00:1c.0 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 1 (rev 02)
        00:1c.3 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 4 (rev 02)
        00:1d.0 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #1 (rev 02)
        00:1d.1 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #2 (rev 02)
        00:1d.2 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #3 (rev 02)
        00:1d.3 USB Controller: Intel Corporation N10/ICH 7 Family USB UHCI Controller #4 (rev 02)
        00:1d.7 USB Controller: Intel Corporation N10/ICH 7 Family USB2 EHCI Controller (rev 02)
        00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev e2)
        00:1f.0 ISA bridge: Intel Corporation NM10 Family LPC Controller (rev 02)
        00:1f.2 SATA controller: Intel Corporation N10/ICH7 Family SATA AHCI Controller (rev 02)
        01:00.0 Network controller: Broadcom Corporation BCM4313 802.11b/g/n Wireless LAN Controller (rev 01)
        02:00.0 Ethernet controller: Marvell Technology Group Ltd. 88E8059 PCI-E Gigabit Ethernet Controller (rev 11)
    
    and the system works stable with 110us/uframe (~88%) isoc bandwith allocated for
    above-mentioned isochronous transfers.
    
    NOTE 3
    ~~~~~~
    
    This feature is off by default. I mean max periodic bandwidth is set to
    100us/uframe by default exactly as it was before the patch. So only those of us
    who need the extreme settings are taking the risk - normal users who do not
    alter uframe_periodic_max sysfs attribute should not see any change at all.
    
    NOTE 4
    ~~~~~~
    
    I've tried to update documentation in Documentation/ABI/ thoroughly, but
    only "TBD" was put into Documentation/usb/ehci.txt -- the text there seems
    to be outdated and much needing refreshing, before it could be amended.
    
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Kirill Smelkov <kirr@mns.spb.ru>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8306155de9e5..4ee62bef3723 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -571,6 +571,12 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 
+	/*
+	 * by default set standard 80% (== 100 usec/uframe) max periodic
+	 * bandwidth as required by USB 2.0
+	 */
+	ehci->uframe_periodic_max = 100;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.

commit 4c67045bfc2c14a1d3c6040e80eb4a62946282dd
Author: Kirill Smelkov <kirr@mns.spb.ru>
Date:   Sun Jul 3 20:36:56 2011 +0400

    USB: EHCI: Move sysfs related bits into ehci-sysfs.c
    
    The only sysfs attr implemented so far is "companion" from ehci-hub.c,
    but in the next patch we are going to add another sysfs file, so prior
    to that let's structure things and move already-in-there sysfs code to
    separate file.
    
    NOTE: All the code I'm moving into this new file was written by Alan
    Stern (in 57e06c11 "EHCI: force high-speed devices to run at full
    speed"; Jan 16 2007), that's why I'm putting
    
        Copyright (C) 2007 by Alan Stern
    
    there after explicit request from the author.
    
    Signed-off-by: Kirill Smelkov <kirr@mns.spb.ru>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e18862c5b059..8306155de9e5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -336,6 +336,7 @@ static void ehci_work(struct ehci_hcd *ehci);
 #include "ehci-mem.c"
 #include "ehci-q.c"
 #include "ehci-sched.c"
+#include "ehci-sysfs.c"
 
 /*-------------------------------------------------------------------------*/
 
@@ -520,7 +521,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_reset (ehci);
 	spin_unlock_irq(&ehci->lock);
 
-	remove_companion_file(ehci);
+	remove_sysfs_files(ehci);
 	remove_debug_files (ehci);
 
 	/* root hub is shut down separately (first, when possible) */
@@ -754,7 +755,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * since the class device isn't created that early.
 	 */
 	create_debug_files(ehci);
-	create_companion_file(ehci);
+	create_sysfs_files(ehci);
 
 	return 0;
 }

commit 578333ab95f70db13951d30a9ad6b565b61639a9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jun 15 16:32:46 2011 -0400

    USB: change maintainership of ohci-hcd and ehci-hcd
    
    Following the loss of David Brownell, I volunteer to maintain the
    ohci-hcd and ehci-hcd drivers.  This patch (as1472) makes it official.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b435ed67dd5c..f8030ee928e8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,4 +1,8 @@
 /*
+ * Enhanced Host Controller Interface (EHCI) driver for USB.
+ *
+ * Maintainer: Alan Stern <stern@rowland.harvard.edu>
+ *
  * Copyright (c) 2000-2004 by David Brownell
  *
  * This program is free software; you can redistribute it and/or modify it

commit cc55687124426e3a6a5301780c4e6bb36bb531fd
Author: Niels de Vos <ndevos@redhat.com>
Date:   Tue May 31 23:00:10 2011 +0100

    ehci-hcd: remove EOL from MODULE_PARM_DESC for 'hird' option
    
    There is no need to have a "\n" on a MODULE_PARM_DESC, remove it
    
    Signed-off-by: Niels de Vos <ndevos@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b435ed67dd5c..e18862c5b059 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,7 +110,7 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 /* for link power management(LPM) feature */
 static unsigned int hird;
 module_param(hird, int, S_IRUGO);
-MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us\n");
+MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 

commit 69fff59de4d844f8b4c2454c3c23d32b69dcbfd7
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 17 17:27:12 2011 -0400

    USB: remove remaining usages of hcd->state from usbcore and fix regression
    
    This patch (as1467) removes the last usages of hcd->state from
    usbcore.  We no longer check to see if an interrupt handler finds that
    a controller has died; instead we rely on host controller drivers to
    make an explicit call to usb_hc_died().
    
    This fixes a regression introduced by commit
    9b37596a2e860404503a3f2a6513db60c296bfdc (USB: move usbcore away from
    hcd->state).  It used to be that when a controller shared an IRQ with
    another device and an interrupt arrived while hcd->state was set to
    HC_STATE_HALT, the interrupt handler would be skipped.  The commit
    removed that test; as a result the current code doesn't skip calling
    the handler and ends up believing the controller has died, even though
    it's only temporarily stopped.  The solution is to ignore HC_STATE_HALT
    following the handler's return.
    
    As a consequence of this change, several of the host controller
    drivers need to be modified.  They can no longer implicitly rely on
    usbcore realizing that a controller has died because of hcd->state.
    The patch adds calls to usb_hc_died() in the appropriate places.
    
    The patch also changes a few of the interrupt handlers.  They don't
    expect to be called when hcd->state is equal to HC_STATE_HALT, even if
    the controller is still alive.  Early returns were added to avoid any
    confusion.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Manuel Lauss <manuel.lauss@googlemail.com>
    CC: Rodolfo Giometti <giometti@linux.it>
    CC: Olav Kongas <ok@artecdesign.ee>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c5719cd258c3..b435ed67dd5c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -777,8 +777,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		goto dead;
 	}
 
+	/* Shared IRQ? */
 	masked_status = status & INTR_MASK;
-	if (!masked_status) {		/* irq sharing? */
+	if (!masked_status || unlikely(hcd->state == HC_STATE_HALT)) {
 		spin_unlock(&ehci->lock);
 		return IRQ_NONE;
 	}
@@ -873,6 +874,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 dead:
 		ehci_reset(ehci);
 		ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+		usb_hc_died(hcd);
 		/* generic layer kills/unlinks all urbs, then
 		 * uses ehci_stop to clean up the rest
 		 */

commit 9be0392989306361d4a63a06a8ee281efbead548
Author: Jan Andersson <jan@gaisler.com>
Date:   Tue May 3 20:11:58 2011 +0200

    USB: EHCI: Add bus glue for GRLIB GRUSBHC controller
    
    This patch adds support for the GRLIB GRUSBHC EHCI controller from
    Aeroflex Gaisler. The controller is typically found on LEON/GRLIB
    SoCs.
    
    Tested on GR-LEON4-ITX with with little endian interface and on
    LEON3 system on GR-PCI-XC5V development board for big endian
    controller.
    
    Signed-off-by: Jan Andersson <jan@gaisler.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8164ffafd10a..c5719cd258c3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1275,6 +1275,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_ath79_driver
 #endif
 
+#ifdef CONFIG_SPARC_LEON
+#include "ehci-grlib.c"
+#define PLATFORM_DRIVER		ehci_grlib_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit c430131a02d677aa708f56342c1565edfdacb3c0
Author: Jan Andersson <jan@gaisler.com>
Date:   Tue May 3 20:11:57 2011 +0200

    USB: EHCI: Support controllers with big endian capability regs
    
    The two first HC capability registers (CAPLENGTH and HCIVERSION)
    are defined as one 8-bit and one 16-bit register. Most HC
    implementations have selected to treat these registers as part
    of a 32-bit register, giving the same layout for both big and
    small endian systems.
    
    This patch adds a new quirk, big_endian_capbase, to support
    controllers with big endian register interfaces that treat
    HCIVERSION and CAPLENGTH as individual registers.
    
    Signed-off-by: Jan Andersson <jan@gaisler.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 83b7d5f02a15..8164ffafd10a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -739,7 +739,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	up_write(&ehci_cf_port_reset_rwsem);
 	ehci->last_periodic_enable = ktime_get_real();
 
-	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	temp = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,
 		"USB %x.%x started, EHCI %x.%02x%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),

commit 502fa84195f47a79d7220470ebaa85a773659755
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Apr 13 10:54:22 2011 +0200

    USB: ehci: add bus glue for the Atheros AR71XX/AR724X/AR91XX SoCs
    
    The Atheros AR71XX/AR91XX SoCs have a built-in EHCI controller.
    This patch adds the necessary glue code to make the generic EHCI
    driver usable for them.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6b20b3b12d65..83b7d5f02a15 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1270,6 +1270,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		s5p_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_ATH79
+#include "ehci-ath79.c"
+#define PLATFORM_DRIVER		ehci_ath79_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 1bcc5aa87f043d34522d783154d08173b435fb46
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Fri Apr 8 14:08:50 2011 +0900

    USB: Add initial S5P EHCI driver
    
    This patch adds host USB high speed driver for samsung S5P series. This
    is initial driver and we need additional implementation to support some
    functions like power management.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 78561d112c04..6b20b3b12d65 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1265,6 +1265,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		tegra_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_S5P
+#include "ehci-s5p.c"
+#define PLATFORM_DRIVER		s5p_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 4c5811bf463b0ef82fabbd1708f8bb2d753aeb18
Merge: f74b9444192c 9f15444fefdb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 17:28:10 2011 -0700

    Merge branch 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6
    
    * 'devicetree/next' of git://git.secretlab.ca/git/linux-2.6: (21 commits)
      tty: serial: altera_jtaguart: Add device tree support
      tty: serial: altera_uart: Add devicetree support
      dt: eliminate of_platform_driver shim code
      dt: Eliminate of_platform_{,un}register_driver
      dt/serial: Eliminate users of of_platform_{,un}register_driver
      dt/usb: Eliminate users of of_platform_{,un}register_driver
      dt/video: Eliminate users of of_platform_{,un}register_driver
      dt/net: Eliminate users of of_platform_{,un}register_driver
      dt/sound: Eliminate users of of_platform_{,un}register_driver
      dt/spi: Eliminate users of of_platform_{,un}register_driver
      dt: uartlite: merge platform and of_platform driver bindings
      dt: xilinx_hwicap: merge platform and of_platform driver bindings
      ipmi: convert OF driver to platform driver
      leds/leds-gpio: merge platform_driver with of_platform_driver
      dt/sparc: Eliminate users of of_platform_{,un}register_driver
      dt/powerpc: Eliminate users of of_platform_{,un}register_driver
      dt/powerpc: move of_bus_type infrastructure to ibmebus
      drivercore/dt: add a match table pointer to struct device
      dt: Typo fix.
      altera_ps2: Add devicetree support
      ...

commit 79ad3b5add4a683af02d1b51ccb699d1b01f1fbf
Author: Benoit Goby <benoit@android.com>
Date:   Wed Mar 9 16:28:56 2011 -0800

    usb: host: Add EHCI driver for NVIDIA Tegra SoCs
    
    The Tegra 2 SoC has 3 EHCI compatible USB controllers. This patch adds
    the necessary glue to allow the ehci-hcd driver to work on Tegra 2
    SoCs.
    
    The platform data is used to configure board-specific phy settings and
    to configure the operating mode, as one of the ports may be used as a otg
    port. For additional power saving, the driver supports powering down the
    phy on bus suspend when it is used, for example, to connect an internal
    device that use an out-of-band remote wakeup mechanism (e.g. a gpio).
    
    Signed-off-by: Benoit Goby <benoit@android.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cfeb24b3ee09..d30c4e08c137 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1260,6 +1260,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_TEGRA
+#include "ehci-tegra.c"
+#define PLATFORM_DRIVER		tegra_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 60b0bf0f11a02a6c288c7a923b2521aa7cfdc6c3
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Mar 1 16:58:37 2011 +0900

    usb: EHCI, OHCI: Add configuration for the SH USB controller
    
    The SH EHCI/OHCI driver hardcoded the CPU type in {ehci,ohci}-hcd.c.
    So if we will add the new CPU, we had to add to the hcd driver each time.
    The patch adds the CONFIG_USB_{EHCI,OHCI}_SH configuration. So if we
    want to use the SH EHCI/OHCI, we only enable the configuration.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e6277536f392..cfeb24b3ee09 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1180,7 +1180,7 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_mxc_driver
 #endif
 
-#ifdef CONFIG_CPU_SUBTYPE_SH7786
+#ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif

commit ad93562bdeecdded7d02eaaaf1aa5705ab57b1b7
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Tue Mar 1 14:57:05 2011 +0800

    USB host: Move AMD PLL quirk to pci-quirks.c
    
    This patch moves the AMD PLL quirk code in OHCI/EHCI driver to pci-quirks.c,
    and exports the functions to be used by xHCI driver later.
    
    AMD PLL quirk disable the optional PM feature inside specific
    SB700/SB800/Hudson-2/3 platforms under the following conditions:
    
    1. If an isochronous device is connected to OHCI/EHCI/xHCI port and is active;
    2. Optional PM feature that powers down the internal Bus PLL when the link is
       in low power state is enabled.
    
    Without AMD PLL quirk, USB isochronous stream may stutter or have breaks
    occasionally, which greatly impair the performance of audio/video streams.
    
    Currently AMD PLL quirk is implemented in OHCI and EHCI driver, and will be
    added to xHCI driver too. They are doing similar things actually, so move
    the quirk code to pci-quirks.c, which has several advantages:
    
    1. Remove duplicate defines and functions in OHCI/EHCI (and xHCI) driver and
       make them cleaner;
    2. AMD chipset information will be probed only once and then stored.
       Currently they're probed during every OHCI/EHCI initialization, move
       the detect code to pci-quirks.c saves the repeat detect cost;
    3. Build up synchronization among OHCI/EHCI/xHCI driver. In current
       code, every host controller enable/disable PLL only according to
       its own status, and may enable PLL while there is still isoc transfer on
       other HCs. Move the quirk to pci-quirks.c prevents this issue.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alex He <alex.he@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f69305d3a9b8..e6277536f392 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -114,13 +114,11 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us\n");
 
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
-/* for ASPM quirk of ISOC on AMD SB800 */
-static struct pci_dev *amd_nb_dev;
-
 /*-------------------------------------------------------------------------*/
 
 #include "ehci.h"
 #include "ehci-dbg.c"
+#include "pci-quirks.h"
 
 /*-------------------------------------------------------------------------*/
 
@@ -532,10 +530,8 @@ static void ehci_stop (struct usb_hcd *hcd)
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 
-	if (amd_nb_dev) {
-		pci_dev_put(amd_nb_dev);
-		amd_nb_dev = NULL;
-	}
+	if (ehci->amd_pll_fix == 1)
+		usb_amd_dev_put();
 
 #ifdef	EHCI_STATS
 	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",

commit d35fb6417655ebf6de93e2135dc386c3c470f545
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 21:08:34 2011 -0700

    dt/usb: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of users of of_platform_driver in drivers/usb.  The
    of_platform_{,un}register_driver functions are going away, so the
    users need to be converted to using the platform_bus_type directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74dcf49bd015..c4de2d75a3d7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1306,24 +1306,24 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef OF_PLATFORM_DRIVER
-	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
+	retval = platform_driver_register(&OF_PLATFORM_DRIVER);
 	if (retval < 0)
 		goto clean3;
 #endif
 
 #ifdef XILINX_OF_PLATFORM_DRIVER
-	retval = of_register_platform_driver(&XILINX_OF_PLATFORM_DRIVER);
+	retval = platform_driver_register(&XILINX_OF_PLATFORM_DRIVER);
 	if (retval < 0)
 		goto clean4;
 #endif
 	return retval;
 
 #ifdef XILINX_OF_PLATFORM_DRIVER
-	/* of_unregister_platform_driver(&XILINX_OF_PLATFORM_DRIVER); */
+	/* platform_driver_unregister(&XILINX_OF_PLATFORM_DRIVER); */
 clean4:
 #endif
 #ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
+	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 clean3:
 #endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
@@ -1351,10 +1351,10 @@ module_init(ehci_hcd_init);
 static void __exit ehci_hcd_cleanup(void)
 {
 #ifdef XILINX_OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&XILINX_OF_PLATFORM_DRIVER);
+	platform_driver_unregister(&XILINX_OF_PLATFORM_DRIVER);
 #endif
 #ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
+	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);

commit 22ced6874fc47bb051e7460443e454ca8efc457e
Author: Anoop <paanoop1@paanoop1-desktop.(none)>
Date:   Thu Feb 24 19:26:28 2011 +0530

    USB: EHCI bus glue for on-chip PMC MSP USB controller
    
    This patch add bus glue for USB controller commonly found in PMC-Sierra MSP71xx family of SoC's.
    
    Signed-off-by: Anoop P A <anoop.pa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4c77a818fd80..f69305d3a9b8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1259,6 +1259,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_msm_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
+#include "ehci-pmcmsp.c"
+#define	PLATFORM_DRIVER		ehci_hcd_msp_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit bcf40815e0cda371cecc242398fe39b873bb1047
Author: Matthieu CASTET <matthieu.castet@parrot.com>
Date:   Tue Feb 15 18:40:28 2011 +0100

    USB: don't run ehci_reset in ehci_run for tdi device
    
    TDI driver does the ehci_reset in their reset callback.
    Don't reset in ehci_run because configuration settings done in
    platform driver will be reset.
    
    This will allow to make msm use ehci_run.
    
    Signed-off-by: Matthieu CASTET <castet.matthieu@parrot.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74dcf49bd015..4c77a818fd80 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -679,7 +679,12 @@ static int ehci_run (struct usb_hcd *hcd)
 	hcd->uses_new_polling = 1;
 
 	/* EHCI spec section 4.1 */
-	if ((retval = ehci_reset(ehci)) != 0) {
+	/*
+	 * TDI driver does the ehci_reset in their reset callback.
+	 * Don't reset here, because configuration settings will
+	 * vanish.
+	 */
+	if (!ehci_is_TDI(ehci) && (retval = ehci_reset(ehci)) != 0) {
 		ehci_mem_cleanup(ehci);
 		return retval;
 	}

commit f75593ceaa08e6d27aec1a5de31cded19e850dd1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 6 10:17:09 2011 -0500

    USB: EHCI: fix DMA deallocation bug
    
    This patch (as1440) fixes a bug in ehci-hcd.  ehci->periodic_size is
    used to compute the size in a dma_alloc_coherent() call, but then it
    gets changed later on.  As a result, the corresponding call to
    dma_free_coherent() passes a different size from the original
    allocation.  Fix the problem by adjusting ehci->periodic_size before
    carrying out any of the memory allocations.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Larry Finger <Larry.Finger@lwfinger.net>
    CC: David Brownell <david-b@pacbell.net>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6fee3cd58efe..74dcf49bd015 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -572,6 +572,8 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
 	ehci->iaa_watchdog.data = (unsigned long) ehci;
 
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -579,11 +581,20 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	INIT_LIST_HEAD(&ehci->cached_sitd_list);
+
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		switch (EHCI_TUNE_FLS) {
+		case 0: ehci->periodic_size = 1024; break;
+		case 1: ehci->periodic_size = 512; break;
+		case 2: ehci->periodic_size = 256; break;
+		default:	BUG();
+		}
+	}
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 
 	/* controllers may cache some of the periodic schedule ... */
-	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
 		ehci->i_thresh = 2 + 8;
 	else					// N microframes cached
@@ -637,12 +648,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		/* periodic schedule size can be smaller than default */
 		temp &= ~(3 << 2);
 		temp |= (EHCI_TUNE_FLS << 2);
-		switch (EHCI_TUNE_FLS) {
-		case 0: ehci->periodic_size = 1024; break;
-		case 1: ehci->periodic_size = 512; break;
-		case 2: ehci->periodic_size = 256; break;
-		default:	BUG();
-		}
 	}
 	if (HCC_LPM(hcc_params)) {
 		/* support link power management EHCI 1.1 addendum */

commit 3e5b08cbbf78bedd316904ab0cf3b27119433ee5
Merge: da40d036fd71 2af10844eb6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 7 13:16:28 2011 -0800

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (144 commits)
      USB: add support for Dream Cheeky DL100B Webmail Notifier (1d34:0004)
      USB: serial: ftdi_sio: add support for TIOCSERGETLSR
      USB: ehci-mxc: Setup portsc register prior to accessing OTG viewport
      USB: atmel_usba_udc: fix freeing irq in usba_udc_remove()
      usb: ehci-omap: fix tll channel enable mask
      usb: ohci-omap3: fix trivial typo
      USB: gadget: ci13xxx: don't assume that PAGE_SIZE is 4096
      USB: gadget: ci13xxx: fix complete() callback for no_interrupt rq's
      USB: gadget: update ci13xxx to work with g_ether
      USB: gadgets: ci13xxx: fix probing of compiled-in gadget drivers
      Revert "USB: musb: pm: don't rely fully on clock support"
      Revert "USB: musb: blackfin: pm: make it work"
      USB: uas: Use GFP_NOIO instead of GFP_KERNEL in I/O submission path
      USB: uas: Ensure we only bind to a UAS interface
      USB: uas: Rename sense pipe and sense urb to status pipe and status urb
      USB: uas: Use kzalloc instead of kmalloc
      USB: uas: Fix up the Sense IU
      usb: musb: core: kill unneeded #include's
      DA8xx: assign name to MUSB IRQ resource
      usb: gadget: g_ncm added
      ...
    
    Manually fix up trivial conflicts in USB Kconfig changes in:
            arch/arm/mach-omap2/Kconfig
            arch/sh/Kconfig
            drivers/usb/Kconfig
            drivers/usb/host/ehci-hcd.c
    and annoying chip clock data conflicts in:
            arch/arm/mach-omap2/clock3xxx_data.c
            arch/arm/mach-omap2/clock44xx_data.c

commit 50401d77ee4904673042dd737eed436067cc23f5
Merge: 206323c18137 760efe6910d5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jan 3 10:31:38 2011 +0000

    Merge branch 'master' of git://git.infradead.org/users/cbou/linux-cns3xxx into devel-stable

commit 36facadd9ea98f8415d0dbb63e0763b7ee9d3911
Merge: 2faa83e2a519 0b83ae960cd7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 16 10:05:06 2010 -0800

    Merge branch 'usb-next' into musb-merge
    
    * usb-next: (132 commits)
      USB: uas: Use GFP_NOIO instead of GFP_KERNEL in I/O submission path
      USB: uas: Ensure we only bind to a UAS interface
      USB: uas: Rename sense pipe and sense urb to status pipe and status urb
      USB: uas: Use kzalloc instead of kmalloc
      USB: uas: Fix up the Sense IU
      usb: musb: core: kill unneeded #include's
      DA8xx: assign name to MUSB IRQ resource
      usb: gadget: g_ncm added
      usb: gadget: f_ncm.c added
      usb: gadget: u_ether: prepare for NCM
      usb: pch_udc: Fix setup transfers with data out
      usb: pch_udc: Fix compile error, warnings and checkpatch warnings
      usb: add ab8500 usb transceiver driver
      USB: gadget: Implement runtime PM for MSM bus glue driver
      USB: gadget: Implement runtime PM for ci13xxx gadget
      USB: gadget: Add USB controller driver for MSM SoC
      USB: gadget: Introduce ci13xxx_udc_driver struct
      USB: gadget: Initialize ci13xxx gadget device's coherent DMA mask
      USB: gadget: Fix "scheduling while atomic" bugs in ci13xxx_udc
      USB: gadget: Separate out PCI bus code from ci13xxx_udc
      ...

commit b0848aea10da186372582f33152efdda43944f26
Author: Pavankumar Kondeti <pkondeti@codeaurora.org>
Date:   Tue Dec 7 17:53:56 2010 +0530

    USB: EHCI: Add MSM Host Controller driver
    
    This patch adds support for EHCI compliant HSUSB Host controller found
    on MSM chips.  The root hub has a single port and TT is built into it.
    This driver depends on OTG driver for PHY initialization, clock
    management and powering up VBUS.
    
    Signed-off-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6778fbcf2416..48021d26024c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1239,6 +1239,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		spear_ehci_hcd_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MSM
+#include "ehci-msm.c"
+#define PLATFORM_DRIVER		ehci_msm_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 05570297ecbe834b1756b522412b68eaffb9ab11
Author: Alex He <alex.he@amd.com>
Date:   Tue Dec 7 10:10:08 2010 +0800

    USB: EHCI: ASPM quirk of ISOC on AMD SB800
    
    When ASPM PM Feature is enabled on UMI link, devices that use ISOC stream of
    data transfer may be exposed to longer latency causing less than optimal per-
    formance of the device. The longer latencies are normal and are due to link
    wake time coming out of low power state which happens frequently to save
    power when the link is not active.
    The following code will make exception for certain features of ASPM to be by
    passed and keep the logic normal state only when the ISOC device is connected
    and active. This change will allow the device to run at optimal performance
    yet minimize the impact on overall power savings.
    
    Signed-off-by: Alex He <alex.he@amd.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index abe8336ebffa..6778fbcf2416 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -114,6 +114,9 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us\n");
 
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
+/* for ASPM quirk of ISOC on AMD SB800 */
+static struct pci_dev *amd_nb_dev;
+
 /*-------------------------------------------------------------------------*/
 
 #include "ehci.h"
@@ -529,6 +532,11 @@ static void ehci_stop (struct usb_hcd *hcd)
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 
+	if (amd_nb_dev) {
+		pci_dev_put(amd_nb_dev);
+		amd_nb_dev = NULL;
+	}
+
 #ifdef	EHCI_STATS
 	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
 		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,

commit fe4bfb30fe5788100a70c0ed96ddd8c6186eb9c4
Merge: 367576b813ed e3e9887ee9de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Dec 3 12:12:29 2010 -0800

    Merge branch 'sh/ehci' of master.kernel.org:/pub/scm/linux/kernel/git/lethal/sh-2.6 into work
    
    * 'sh/ehci' of master.kernel.org:/pub/scm/linux/kernel/git/lethal/sh-2.6:
      sh: Convert to USB_ARCH_HAS_OHCI/EHCI selects.
      usb: ehci-sh: Add missing ehci helpers.
      usb: ehci-sh: Fix up fault in shutdown path.
      sh: Add EHCI support for SH7786.
      usb: ehci-hcd: Add support for SuperH EHCI.
      usb: ohci-sh: Set IRQ as shared.

commit 7f124f4b353672bc150af959910cfc2a9778260a
Author: Keshava Munegowda <keshava_mgowda@ti.com>
Date:   Sun Nov 21 23:23:41 2010 +0530

    usb: ehci: introduce CONFIG_USB_EHCI_HCD_OMAP
    
    Introduce the CONFIG_USB_EHCI_HCD_OMAP option to select
    EHCI support on OMAP3 and later chips. This scales better
    than having a long line of dependencies for each new OMAP
    with EHCI support.
    
    Signed-off-by: Keshava Munegowda <keshava_mgowda@ti.com>
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 87157db155f6..2f06ba471953 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1171,7 +1171,7 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
-#ifdef CONFIG_ARCH_OMAP3
+#ifdef CONFIG_USB_EHCI_HCD_OMAP
 #include "ehci-omap.c"
 #define        PLATFORM_DRIVER         ehci_hcd_omap_driver
 #endif

commit 760efe6910d5743084b586d3d0a3b65aea96fb2f
Author: Mac Lin <mkl0301@gmail.com>
Date:   Thu Nov 25 23:58:00 2010 +0800

    USB: cns3xxx: Add EHCI and OHCI bus glue for cns3xxx SOCs
    
    The CNS3XXX SOC has include USB EHCI and OHCI compatible controllers.
    This patch adds the necessary glue logic to allow ehci-hcd and ohci-hcd
    drivers to work on CNS3XXX
    
    The EHCI and OHCI controllers share a common clock control and reset
    bit, therefore additional check for the timming of enabling and disabling
    is required. The USB bit of PLL Power Down Control is also shared by OTG,
    24MHzUART clock, Crypto clock, PCIe reference clock, and Clock Scale
    Generator. Therefore we only ensure it is enabled, while not disabling it.
    
    Signed-off-by: Mac Lin <mkl0301@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 502a7e6fef42..06535405408c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1216,6 +1216,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
+#ifdef CONFIG_USB_CNS3XXX_EHCI
+#include "ehci-cns3xxx.c"
+#define PLATFORM_DRIVER		cns3xxx_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit c8c38de9d8002578599222296b90696745ac0fe3
Author: Deepak Sikri <deepak.sikri@st.com>
Date:   Wed Nov 10 14:33:18 2010 +0530

    USB host: Adding USB ehci & ohci support for spear platform
    
    This patch adds support for ehci and ohci controller in the SPEAr platform.
    
    Changes since V2:
    added clear_tt_buffer_complete in ehci_spear_hc_driver
    
    Signed-off-by: Deepak Sikri <deepak.sikri@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 10f985def70f..87157db155f6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1221,6 +1221,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		vt8500_ehci_driver
 #endif
 
+#ifdef CONFIG_PLAT_SPEAR
+#include "ehci-spear.c"
+#define PLATFORM_DRIVER		spear_ehci_hcd_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 02e2c51ba3e80acde600721ea784c3ef84da5ea1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 16 10:57:37 2010 -0500

    USB: EHCI: fix obscure race in ehci_endpoint_disable
    
    This patch (as1435) fixes an obscure and unlikely race in ehci-hcd.
    When an async URB is unlinked, the corresponding QH is removed from
    the async list.  If the QH's endpoint is then disabled while the URB
    is being given back, ehci_endpoint_disable() won't find the QH on the
    async list, causing it to believe that the QH has been lost.  This
    will lead to a memory leak at best and quite possibly to an oops.
    
    The solution is to trust usbcore not to lose track of endpoints.  If
    the QH isn't on the async list then it doesn't need to be taken off
    the list, but the driver should still wait for the QH to become IDLE
    before disabling it.
    
    In theory this fixes Bugzilla #20182.  In fact the race is so rare
    that it's not possible to tell whether the bug is still present.
    However, adding delays and making other changes to force the race
    seems to show that the patch works.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    CC: David Brownell <david-b@pacbell.net>
    CC: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 502a7e6fef42..e9062806d4a2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1063,10 +1063,11 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 				tmp && tmp != qh;
 				tmp = tmp->qh_next.qh)
 			continue;
-		/* periodic qh self-unlinks on empty */
-		if (!tmp)
-			goto nogood;
-		unlink_async (ehci, qh);
+		/* periodic qh self-unlinks on empty, and a COMPLETING qh
+		 * may already be unlinked.
+		 */
+		if (tmp)
+			unlink_async(ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
@@ -1083,7 +1084,6 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		}
 		/* else FALL THROUGH */
 	default:
-nogood:
 		/* caller was supposed to have unlinked any requests;
 		 * that's not our job.  just leak this memory.
 		 */

commit ad78acafeed26f62c9e644f96eecb7c19bd78bb4
Author: Alexey Charkov <alchark@gmail.com>
Date:   Sun Nov 7 19:28:55 2010 +0300

    usb: Add support for VIA VT8500 and compatibles in EHCI HCD
    
    VIA and WonderMedia Systems-on-Chip feature a standard EHCI host
    controller. This adds necessary glue to use the standard driver
    with these systems.
    
    Signed-off-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 502a7e6fef42..10f985def70f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1216,6 +1216,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_octeon_driver
 #endif
 
+#ifdef CONFIG_ARCH_VT8500
+#include "ehci-vt8500.c"
+#define	PLATFORM_DRIVER		vt8500_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 63c845522263b2da08f70deba760ed0ab51e841d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 1 17:03:27 2010 -0400

    usb: ehci-hcd: Add support for SuperH EHCI.
    
    This adds a trivial stub for supporting EHCI mode of the on-chip
    SH USB host controllers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 502a7e6fef42..02ffbea0c8fa 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1166,6 +1166,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_mxc_driver
 #endif
 
+#ifdef CONFIG_CPU_SUBTYPE_SH7786
+#include "ehci-sh.c"
+#define PLATFORM_DRIVER		ehci_hcd_sh_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver

commit 1643accdaad4625c2877f7ceefa39c1cb3e90117
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Oct 8 14:47:52 2010 -0700

    USB: Add EHCI and OHCH glue for OCTEON II SOCs.
    
    The OCTEON II SOC has USB EHCI and OHCI controllers connected directly
    to the internal I/O bus.  This patch adds the necessary 'glue' logic
    to allow ehci-hcd and ohci-hcd drivers to work on OCTEON II.
    
    The OCTEON normally runs big-endian, and the ehci/ohci internal
    registers have host endianness, so we need to select
    USB_EHCI_BIG_ENDIAN_MMIO.
    
    The ehci and ohci blocks share a common clocking and PHY
    infrastructure.  Initialization of the host controller and PHY clocks
    is common between the two and is factored out into the
    octeon2-common.c file.
    
    Setting of USB_ARCH_HAS_OHCI and USB_ARCH_HAS_EHCI is done in
    arch/mips/Kconfig in a following patch.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    To: linux-usb@vger.kernel.org
    To: dbrownell@users.sourceforge.net
    Patchwork: http://patchwork.linux-mips.org/patch/1675/
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2adae8e39bba..502a7e6fef42 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1211,6 +1211,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_USB_OCTEON_EHCI
+#include "ehci-octeon.c"
+#define PLATFORM_DRIVER		ehci_octeon_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)

commit 229aebb873e29726b91e076161649cf45154b0bf
Merge: 8de547e18244 50a23e6eec6f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 24 13:41:39 2010 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      Update broken web addresses in arch directory.
      Update broken web addresses in the kernel.
      Revert "drivers/usb: Remove unnecessary return's from void functions" for musb gadget
      Revert "Fix typo: configuation => configuration" partially
      ida: document IDA_BITMAP_LONGS calculation
      ext2: fix a typo on comment in ext2/inode.c
      drivers/scsi: Remove unnecessary casts of private_data
      drivers/s390: Remove unnecessary casts of private_data
      net/sunrpc/rpc_pipe.c: Remove unnecessary casts of private_data
      drivers/infiniband: Remove unnecessary casts of private_data
      drivers/gpu/drm: Remove unnecessary casts of private_data
      kernel/pm_qos_params.c: Remove unnecessary casts of private_data
      fs/ecryptfs: Remove unnecessary casts of private_data
      fs/seq_file.c: Remove unnecessary casts of private_data
      arm: uengine.c: remove C99 comments
      arm: scoop.c: remove C99 comments
      Fix typo configue => configure in comments
      Fix typo: configuation => configuration
      Fix typo interrest[ing|ed] => interest[ing|ed]
      Fix various typos of valid in comments
      ...
    
    Fix up trivial conflicts in:
            drivers/char/ipmi/ipmi_si_intf.c
            drivers/usb/gadget/rndis.c
            net/irda/irnet/irnet_ppp.c

commit 65fd42724aee31018b0bb53f4cb04971423be664
Author: Matthieu CASTET <matthieu.castet@parrot.com>
Date:   Mon Sep 6 18:26:56 2010 +0200

    USB: ehci tdi : let's tdi_reset set host mode
    
    tdi_reset is already taking care of setting host mode for tdi devices.
    Don't duplicate code in platform driver.
    
    Make ehci_halt a nop if the controller is not in host mode (otherwise it
    will fail), and let's ehci_reset do the tdi_reset.
    We need to move hcd->has_tt flags before ehci_halt, in order ehci_halt
    knows we are a tdi device.
    
    
    Before the setup routine was doing :
    - put controller in host mode
    - ehci_halt
    - ehci_init
    - hcd->has_tt = 1;
    - ehci_reset
    
    Now we do :
    - hcd->has_tt = 1;
    - ehci_halt
    - ehci_init
    - ehci_reset
    
    PS : now we handle correctly the device -> host transition.
    
    Signed-off-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 34a928d3b7d2..15fe3ecd203b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -194,6 +194,17 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 	return -ETIMEDOUT;
 }
 
+/* check TDI/ARC silicon is in host mode */
+static int tdi_in_host_mode (struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg_ptr;
+	u32		tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
+	tmp = ehci_readl(ehci, reg_ptr);
+	return (tmp & 3) == USBMODE_CM_HC;
+}
+
 /* force HC to halt state from unknown (EHCI spec section 2.3) */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
@@ -202,6 +213,10 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	/* disable any irqs left enabled by previous code */
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 
+	if (ehci_is_TDI(ehci) && tdi_in_host_mode(ehci) == 0) {
+		return 0;
+	}
+
 	if ((temp & STS_HALT) != 0)
 		return 0;
 

commit 6396fc3b3ff3f6b942992b653a62df11dcef9bea
Merge: 4785879e4d34 3d30701b5897
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Aug 11 09:36:51 2010 +0200

    Merge branch 'master' into for-next
    
    Conflicts:
            fs/exofs/inode.c

commit ffda080353979273e8aa69fc1e6134f20643ae56
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 14 11:03:46 2010 -0400

    USB: EHCI: add missing frame -> microframe conversion
    
    This patch (as1407) fixes a bug in ehci-hcd's isochronous scheduler.
    All its calculations should be done in terms of microframes, but for
    full-speed devices, sched->span is stored in frames.  It needs to be
    converted.
    
    This fix is liable to expose problems in other drivers.  The old code
    would accept URBs that should not have been accepted, so drivers have
    had no reason to avoid submitting URBs that exceeded the maximum
    schedule length.  In an attempt to partially compensate for this, the
    patch also adjusts the schedule length from a minimum of 256 frames up
    to a minimum of 512 frames.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2e704fa3cedf..34a928d3b7d2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -79,7 +79,13 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_RL_TT		0
 #define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
 #define	EHCI_TUNE_MULT_TT	1
-#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+/*
+ * Some drivers think it's safe to schedule isochronous transfers more than
+ * 256 ms into the future (partly as a result of an old bug in the scheduling
+ * code).  In an attempt to avoid trouble, we will use a minimum scheduling
+ * length of 512 frames instead of 256.
+ */
+#define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */

commit 4307a28eb0128417d9a2b9d858d2bce70ee5b383
Author: Andrea Righi <arighi@develer.com>
Date:   Mon Jun 28 16:56:45 2010 +0200

    USB: EHCI: fix NULL pointer dererence in HCDs that use HCD_LOCAL_MEM
    
    If we use the HCD_LOCAL_MEM flag and dma_declare_coherent_memory() to
    enforce the host controller's local memory utilization we also need to
    disable native scatter-gather support, otherwise hcd_alloc_coherent() in
    map_urb_for_dma() is called with urb->transfer_buffer == NULL, that
    triggers a NULL pointer dereference.
    
    We can also consider to add a WARN_ON() and return an error code to
    better catch this problem in the future.
    
    At the moment no driver seems to hit this bug, so I should
    consider this a low-priority fix.
    
    Signed-off-by: Andrea Righi <arighi@develer.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2a19336c9824..2e704fa3cedf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -629,7 +629,8 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->command = temp;
 
 	/* Accept arbitrarily long scatter-gather lists */
-	hcd->self.sg_tablesize = ~0;
+	if (!(hcd->driver->flags & HCD_LOCAL_MEM))
+		hcd->self.sg_tablesize = ~0;
 	return 0;
 }
 

commit 541c7d432f76771079e7c295d596ea47cc6a3030
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 22 16:39:10 2010 -0400

    USB: convert usb_hcd bitfields into atomic flags
    
    This patch (as1393) converts several of the single-bit fields in
    struct usb_hcd to atomic flags.  This is for safety's sake; not all
    CPUs can update bitfield values atomically, and these flags are used
    in multiple contexts.
    
    The flag fields that are set only during registration or removal can
    remain as they are, since non-atomic accesses at those times will not
    cause any problems.
    
    (Strictly speaking, the authorized_default flag should become atomic
    as well.  I didn't bother with it because it gets changed only via
    sysfs.  It can be done later, if anyone wants.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8697ad19f313..2a19336c9824 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -642,7 +642,6 @@ static int ehci_run (struct usb_hcd *hcd)
 	u32			hcc_params;
 
 	hcd->uses_new_polling = 1;
-	hcd->poll_rh = 0;
 
 	/* EHCI spec section 4.1 */
 	if ((retval = ehci_reset(ehci)) != 0) {

commit 5a9cdf332eae724b11906cb1712e3a662eba32b2
Author: Alek Du <alek.du@intel.com>
Date:   Fri Jun 4 15:47:56 2010 +0800

    USB: EHCI: EHCI 1.1 addendum: Enable Per-port change detect bits
    
    This patch will enable Per-port event feature defined in EHCI 1.1
    addendum. This feature addresses an issue where HCD is currently
    required to read and parse PORTSC for all enabled root hub ports. With
    this patch, the overhead will be reduced.
    
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index baf9b648bb1f..8697ad19f313 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -584,6 +584,11 @@ static int ehci_init(struct usb_hcd *hcd)
 	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
 		log2_irq_thresh = 0;
 	temp = 1 << (16 + log2_irq_thresh);
+	if (HCC_PER_PORT_CHANGE_EVENT(hcc_params)) {
+		ehci->has_ppcd = 1;
+		ehci_dbg(ehci, "enable per-port change event\n");
+		temp |= CMD_PPCEE;
+	}
 	if (HCC_CANPARK(hcc_params)) {
 		/* HW default park == 3, on hardware that supports it (like
 		 * NVidia and ALI silicon), maximizes throughput on the async
@@ -782,6 +787,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+		u32		ppcd = 0;
 
 		/* kick root hub later */
 		pcd_status = status;
@@ -790,9 +796,18 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		if (!(cmd & CMD_RUN))
 			usb_hcd_resume_root_hub(hcd);
 
+		/* get per-port change detect bits */
+		if (ehci->has_ppcd)
+			ppcd = status >> 16;
+
 		while (i--) {
-			int pstatus = ehci_readl(ehci,
-						 &ehci->regs->port_status [i]);
+			int pstatus;
+
+			/* leverage per-port change bits feature */
+			if (ehci->has_ppcd && !(ppcd & (1 << i)))
+				continue;
+			pstatus = ehci_readl(ehci,
+					 &ehci->regs->port_status[i]);
 
 			if (pstatus & PORT_OWNER)
 				continue;

commit 48f24970144479c29b8cee6d2e1dbedf6dcf9cfb
Author: Alek Du <alek.du@intel.com>
Date:   Fri Jun 4 15:47:55 2010 +0800

    USB: EHCI: EHCI 1.1 addendum: Basic LPM feature support
    
    With this patch, the LPM capable EHCI host controller can put device
    into L1 sleep state which is a mode that can enter/exit quickly, and
    reduce power consumption.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 20ca6a9ff213..baf9b648bb1f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -101,6 +101,11 @@ static int ignore_oc = 0;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
+/* for link power management(LPM) feature */
+static unsigned int hird;
+module_param(hird, int, S_IRUGO);
+MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us\n");
+
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
 /*-------------------------------------------------------------------------*/
@@ -305,6 +310,7 @@ static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
+#include "ehci-lpm.c"
 #include "ehci-mem.c"
 #include "ehci-q.c"
 #include "ehci-sched.c"
@@ -604,6 +610,17 @@ static int ehci_init(struct usb_hcd *hcd)
 		default:	BUG();
 		}
 	}
+	if (HCC_LPM(hcc_params)) {
+		/* support link power management EHCI 1.1 addendum */
+		ehci_dbg(ehci, "support lpm\n");
+		ehci->has_lpm = 1;
+		if (hird > 0xf) {
+			ehci_dbg(ehci, "hird %d invalid, use default 0",
+			hird);
+			hird = 0;
+		}
+		temp |= hird << 24;
+	}
 	ehci->command = temp;
 
 	/* Accept arbitrarily long scatter-gather lists */

commit aa4d8342988d0c1a79ff19b2ede1e81dfbb16ea5
Author: Alek Du <alek.du@intel.com>
Date:   Fri Jun 4 15:47:54 2010 +0800

    USB: EHCI: EHCI 1.1 addendum: preparation
    
    EHCI 1.1 addendum introduced several energy efficiency extensions for
    EHCI USB host controllers:
    1. LPM (link power management)
    2. Per-port change
    3. Shorter periodic frame list
    4. Hardware prefetching
    
    This patch is intended to define the HW bits and debug interface for
    EHCI 1.1 addendum. The LPM and Per-port change patches will be sent out
    after this patch.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a3ef2a9d9dc2..20ca6a9ff213 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -36,6 +36,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/slab.h>
+#include <linux/uaccess.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>

commit 7f26b3a7533bbc1ddd88b297c935ee4da8f74cea
Author: Joe Perches <joe@perches.com>
Date:   Wed Aug 4 10:40:08 2010 -0700

    drivers/usb: Remove unnecessary return's from void functions
    
    Greg prefers this to go through the trivial tree.
    http://lkml.org/lkml/2010/6/24/1
    
    There are about 2500 void functions in drivers/usb
    Only a few used return; at end of function.
    
    Standardize them a bit.
    
    Moved a statement down a line in drivers/usb/host/u132-hcd.c
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a3ef2a9d9dc2..6fcffe15a005 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1041,7 +1041,6 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	ep->hcpriv = NULL;
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
-	return;
 }
 
 static void

commit 1f23b2d98c11fed43c552a5dbd00c793f81a8736
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Jun 2 13:53:17 2010 -0600

    usb: fix ehci_hcd build failure when both generic-OF and xilinx is selected
    
    This patch fixes the driver to allow both CONFIG_USB_EHCI_HCD_PPC_OF and
    CONFIG_USB_ECHI_HCD_XILINX to be selected.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    CC: John Linn <john.linn@xilinx.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ef3e88f0b3c3..a3ef2a9d9dc2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1135,7 +1135,7 @@ MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_XPS_USB_HCD_XILINX
 #include "ehci-xilinx-of.c"
-#define OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
+#define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
 #ifdef CONFIG_PLAT_ORION
@@ -1159,7 +1159,8 @@ MODULE_LICENSE ("GPL");
 #endif
 
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
+    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
+    !defined(XILINX_OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
@@ -1213,10 +1214,20 @@ static int __init ehci_hcd_init(void)
 	if (retval < 0)
 		goto clean3;
 #endif
+
+#ifdef XILINX_OF_PLATFORM_DRIVER
+	retval = of_register_platform_driver(&XILINX_OF_PLATFORM_DRIVER);
+	if (retval < 0)
+		goto clean4;
+#endif
 	return retval;
 
+#ifdef XILINX_OF_PLATFORM_DRIVER
+	/* of_unregister_platform_driver(&XILINX_OF_PLATFORM_DRIVER); */
+clean4:
+#endif
 #ifdef OF_PLATFORM_DRIVER
-	/* of_unregister_platform_driver(&OF_PLATFORM_DRIVER); */
+	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
 clean3:
 #endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
@@ -1243,6 +1254,9 @@ module_init(ehci_hcd_init);
 
 static void __exit ehci_hcd_cleanup(void)
 {
+#ifdef XILINX_OF_PLATFORM_DRIVER
+	of_unregister_platform_driver(&XILINX_OF_PLATFORM_DRIVER);
+#endif
 #ifdef OF_PLATFORM_DRIVER
 	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
 #endif

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 13ead00aecd5..ef3e88f0b3c3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -31,13 +31,12 @@
 #include <linux/list.h>
 #include <linux/interrupt.h>
 #include <linux/usb.h>
+#include <linux/usb/hcd.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/slab.h>
 
-#include "../core/hcd.h"
-
 #include <asm/byteorder.h>
 #include <asm/io.h>
 #include <asm/irq.h>

commit 0e5f231bc16ff9910882fa5b9d64d80e7691cfab
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 8 16:56:37 2010 -0400

    USB: EHCI: defer reclamation of siTDs
    
    This patch (as1369) fixes a problem in ehci-hcd.  Some controllers
    occasionally run into trouble when the driver reclaims siTDs too
    quickly.  This can happen while streaming audio; it causes the
    controller to crash.
    
    The patch changes siTD reclamation to work the same way as iTD
    reclamation: Completed siTDs are stored on a list and not reused until
    at least one frame has passed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Nate Case <ncase@xes-inc.com>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 207e7a85aeb0..13ead00aecd5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -543,6 +543,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&ehci->cached_itd_list);
+	INIT_LIST_HEAD(&ehci->cached_sitd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index dc55a62859c6..207e7a85aeb0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -23,7 +23,6 @@
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/sched.h>
-#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -35,6 +34,7 @@
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
+#include <linux/slab.h>
 
 #include "../core/hcd.h"
 

commit 1082f57abfa26590b60c43f503afb24102a37016
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Mar 1 17:18:56 2010 +0100

    USB: EHCI: adjust ehci_iso_stream for changes in ehci_qh
    
    The EHCI driver stores in usb_host_endpoint.hcpriv a pointer to either
    an ehci_qh or an ehci_iso_stream structure, and uses the contents of the
    hw_info1 field to distinguish the two cases.
    
    After ehci_qh was split into hw and sw parts, ehci_iso_stream must also
    be adjusted so that it again looks like an ehci_qh structure.
    
    This fixes a NULL pointer access in ehci_endpoint_disable() when it
    tries to access qh->hw->hw_info1.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-by: Colin Fletcher <colin.m.fletcher@googlemail.com>
    Cc: stable <stable@kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d8d6d3461d32..dc55a62859c6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -995,7 +995,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	/* endpoints can be iso streams.  for now, we don't
 	 * accelerate iso completions ... so spin a while.
 	 */
-	if (qh->hw->hw_info1 == 0) {
+	if (qh->hw == NULL) {
 		ehci_vdbg (ehci, "iso delay\n");
 		goto idle_timeout;
 	}

commit a8eb7ca0cbb41c9cd379b8d2a2a5efb503aa65e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 12 12:26:48 2010 -0800

    omap3: Replace ARCH_OMAP34XX with ARCH_OMAP3
    
    Replace ARCH_OMAP34XX with ARCH_OMAP3
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1ec3857f22e6..d8d6d3461d32 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1118,7 +1118,7 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
-#ifdef CONFIG_ARCH_OMAP34XX
+#ifdef CONFIG_ARCH_OMAP3
 #include "ehci-omap.c"
 #define        PLATFORM_DRIVER         ehci_hcd_omap_driver
 #endif

commit 49d0f078f494b9d81e820a13dd8093a9bfb0b6b1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 11:18:38 2010 -0500

    USB: add missing delay during remote wakeup
    
    This patch (as1330) fixes a bug in khbud's handling of remote
    wakeups.  When a device sends a remote-wakeup request, the parent hub
    (or the host controller driver, for directly attached devices) begins
    the resume sequence and notifies khubd when the sequence finishes.  At
    this point the port's SUSPEND feature is automatically turned off.
    
    However the device needs an additional 10-ms resume-recovery time
    (TRSMRCY in the USB spec).  Khubd does not wait for this delay if the
    SUSPEND feature is off, and as a result some devices fail to behave
    properly following a remote wakeup.  This patch adds the missing
    delay to the remote-wakeup path.
    
    It also extends the resume-signalling delay used by ehci-hcd and
    uhci-hcd from 20 ms (the value in the spec) to 25 ms (the value we use
    for non-remote-wakeup resumes).  The extra time appears to help some
    devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Cc: Rickard Bellini <rickard.bellini@ericsson.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5859522d6edd..1ec3857f22e6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -787,9 +787,10 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			/* start 20 msec resume signaling from this port,
 			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
+			 * stop that signaling.  Use 5 ms extra for safety,
+			 * like usb_port_resume() does.
 			 */
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
+			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}

commit 40f8db8f8f5af2cafeb976ae15e11aca641a931d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 6 12:29:40 2009 -0500

    USB: EHCI: add native scatter-gather support
    
    This patch (as1300) adds native scatter-gather support to ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2a3265087ef3..5859522d6edd 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -605,6 +605,8 @@ static int ehci_init(struct usb_hcd *hcd)
 	}
 	ehci->command = temp;
 
+	/* Accept arbitrarily long scatter-gather lists */
+	hcd->self.sg_tablesize = ~0;
 	return 0;
 }
 

commit 7e8d5cd93fac4d3720d8f780b350c9421e8997d4
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Oct 28 01:14:59 2009 +0100

    USB: Add EHCI support for MX27 and MX31 based boards
    
    The Freescale MX27 and MX31 SoCs have a EHCI controller onboard.
    The controller is capable of USB on the go. This patch adds
    a driver to support all three of them.
    
    Users have to pass details about serial interface configuration in the
    platform data.
    
    The USB OTG core used here is the ARC core, so the driver should
    be renamed and probably be merged with ehci-fsl.c eventually.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 546ad8814008..2a3265087ef3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1105,6 +1105,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MXC
+#include "ehci-mxc.c"
+#define PLATFORM_DRIVER		ehci_mxc_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver

commit dccd574cccad950d9ed9bc192eae4089c6044d9d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Oct 27 10:55:05 2009 -0700

    USB: ehci: Respect IST when scheduling new split iTDs.
    
    The EHCI specification says that an EHCI host controller may cache part of
    the isochronous schedule.  The EHCI controller must advertise how much it
    caches in the schedule through the HCCPARAMS register isochronous
    scheduling threshold (IST) bits.
    
    In theory, adding new iTDs within the IST should be harmless.  The HW will
    follow the old cached linked list and miss the new iTD.  SW will notice HW
    missed the iTD and return 0 for the transfer length.
    
    However, Intel ICH9 chipsets (and some later chipsets) have issues when SW
    attempts to schedule a split transaction within the IST.  All transfers
    will cease being sent out that port, and the drivers will see isochronous
    packets complete with a length of zero.  Start of frames may or may not
    also disappear, causing the device to go into auto-suspend.  This "bus
    stall" will continue until a control or bulk transfer is queued to a
    device under that roothub.
    
    Most drivers will never cause this behavior, because they use multiple
    URBs with multiple packets to keep the bus busy.  If you limit the number
    of URBs to one, you may be able to hit this bug.
    
    Make sure the EHCI driver does not schedule full-speed transfers within
    the IST under an Intel chipset.  Make sure that when we fall behind the
    current microframe plus IST, we schedule the new transfer at the next
    periodic interval after the IST.
    
    Don't change the scheduling for new transfers, since the schedule slop will
    always be greater than the IST.  Allow high speed isochronous transfers to
    be scheduled within the IST, since this doesn't trigger the Intel chipset
    bug.
    
    Make sure that if the host caches the full frame, the EHCI driver's
    internal isochronous threshold (ehci->i_thresh) is set to
    8 microframes + 2 microframes wiggle room.  This is similar to what is done in
    the case where the host caches less than the full frame.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4ed2c931daeb..546ad8814008 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -549,7 +549,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	/* controllers may cache some of the periodic schedule ... */
 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
-		ehci->i_thresh = 8;
+		ehci->i_thresh = 2 + 8;
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 

commit 54ab2b02ef6a454b4cca969f546d0dd43fec7308
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Wed Oct 14 11:44:14 2009 +0300

    USB: host: ehci: introduce omap ehci-hcd driver
    
    this driver has been sitting in linux-omap tree for quite
    some time. It adds support for omap's ehci controller.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e2afb2b5faf8..4ed2c931daeb 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1110,6 +1110,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#ifdef CONFIG_ARCH_OMAP34XX
+#include "ehci-omap.c"
+#define        PLATFORM_DRIVER         ehci_hcd_omap_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver

commit 08d3c18e6674c5d46e4333a462b1e2e4c4ded1d4
Author: Julie Zhu <julie.zhu@xilinx.com>
Date:   Mon Sep 21 16:08:19 2009 -0600

    USB: Add support for Xilinx USB host controller
    
    Add bus glue driver for Xilinx USB host controller. The controller can be
    configured as HS only or HS/FS hybrid. The driver uses the device tree file
    to configure the driver according to the setting in the hardware system.
    
    This driver has been tested with usbtest using the NET2280 PCI card.
    
    Signed-off-by: Julie Zhu <julie.zhu@xilinx.com>
    Signed-off-by: John Linn <john.linn@xilinx.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d8f4aaa616f2..e2afb2b5faf8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1120,6 +1120,11 @@ MODULE_LICENSE ("GPL");
 #define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
 #endif
 
+#ifdef CONFIG_XPS_USB_HCD_XILINX
+#include "ehci-xilinx-of.c"
+#define OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
+#endif
+
 #ifdef CONFIG_PLAT_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver

commit d014d043869cdc591f3a33243d3481fa4479c2d0
Merge: 6ec22f9b037f 6070d81eb5f2
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Dec 7 18:36:35 2009 +0100

    Merge branch 'for-next' into for-linus
    
    Conflicts:
    
            kernel/irq/chip.c

commit 65cb76baa1058d17d51ce948b697cdbd5dc97421
Author: Ozan Çağlayan <ozan@pardus.org.tr>
Date:   Tue Oct 13 08:37:09 2009 +0300

    ehci-hcd: Fix typo in an error message
    
    The correct word is handshake.
    
    Signed-off-by: Ozan Çağlayan <ozan@pardus.org.tr>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9835e0713943..a68eb2c87c3e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -209,7 +209,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 	if (error) {
 		ehci_halt(ehci);
 		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		ehci_err(ehci, "force halt; handhake %p %08x %08x -> %d\n",
+		ehci_err(ehci, "force halt; handshake %p %08x %08x -> %d\n",
 			ptr, mask, done, error);
 	}
 

commit ee4ecb8ac63a5792bec448037d4b82ec4144f94b
Author: Oliver Neukum <oliver@neukum.org>
Date:   Fri Nov 27 15:17:59 2009 +0100

    USB: work around for EHCI with quirky periodic schedules
    
    a quirky chipset needs periodic schedules to run for a minimum
    time before they can be disabled again. This enforces the requirement
    with a time stamp and a calculated delay
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9835e0713943..f5f5601701c9 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -28,6 +28,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>
+#include <linux/ktime.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
 #include <linux/usb.h>
@@ -676,6 +677,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 	msleep(5);
 	up_write(&ehci_cf_port_reset_rwsem);
+	ehci->last_periodic_enable = ktime_get_real();
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,

commit 8d053c79f22462f55c02c8083580730b922cf7b4
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 20 15:39:54 2009 -0500

    USB: ehci-dbgp,ehci: Allow early or late use of the dbgp device
    
    If the EHCI debug port is initialized and in use, the EHCI host
    controller driver must follow two rules.
    
    1) If the EHCI host driver issues a controller reset, the debug
       controller driver re-initialization must get called after the reset
       is completed.
    
    2) The EHCI host driver should ignore any requests to the physical
       EHCI debug port when the EHCI debug port is in use.
    
    The code to check for the debug port was moved from ehci_pci_reinit()
    to ehci_pci_setup because it must get called prior to ehci_reset()
    which will clear the debug port registers.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: dbrownell@users.sourceforge.net
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4f89d7ffd53a..9835e0713943 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -240,6 +240,11 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	int	retval;
 	u32	command = ehci_readl(ehci, &ehci->regs->command);
 
+	/* If the EHCI debug controller is active, special care must be
+	 * taken before and after a host controller reset */
+	if (ehci->debug && !dbgp_reset_prep())
+		ehci->debug = NULL;
+
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
 	ehci_writel(ehci, command, &ehci->regs->command);
@@ -260,6 +265,9 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci_is_TDI(ehci))
 		tdi_reset (ehci);
 
+	if (ehci->debug)
+		dbgp_external_startup();
+
 	return retval;
 }
 

commit a448c9d8c58ff7d3f8cc2a8f835065460099b22d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 19 12:22:44 2009 -0400

    USB: EHCI: change deschedule logic for interrupt QHs
    
    This patch (as1281) changes the way ehci-hcd deschedules interrupt
    QHs, copying the approach used for async QHs.  The caller is no longer
    responsible for rescheduling the QH if its queue is non-empty; instead
    the reschedule is done directly by intr_deschedule(), after calling
    qh_completions().  This is exactly the same as how end_unlink_async()
    works.
    
    ehci_urb_dequeue() and intr_deschedule() now correctly handle the case
    where they are called while another interrupt URB for the same QH is
    being given back.  This was a surprisingly large blind spot.  And
    scan_periodic() now respects the new needs_rescan flag.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d7e85b6231b3..4f89d7ffd53a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -934,8 +934,9 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			break;
 		switch (qh->qh_state) {
 		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
 			intr_deschedule (ehci, qh);
-			/* FALL THROUGH */
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -944,23 +945,6 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 					qh, qh->qh_state);
 			goto done;
 		}
-
-		/* reschedule QH iff another request is queued */
-		if (!list_empty (&qh->qtd_list)
-				&& HC_IS_RUNNING (hcd->state)) {
-			rc = qh_schedule(ehci, qh);
-
-			/* An error here likely indicates handshake failure
-			 * or no space left in the schedule.  Neither fault
-			 * should happen often ...
-			 *
-			 * FIXME kill the now-dysfunctional queued urbs
-			 */
-			if (rc != 0)
-				ehci_err(ehci,
-					"can't reschedule qh %p, err %d",
-					qh, rc);
-		}
 		break;
 
 	case PIPE_ISOCHRONOUS:
@@ -1079,12 +1063,10 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			if (eptype == USB_ENDPOINT_XFER_BULK) {
+			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
-			} else {
+			else
 				intr_deschedule(ehci, qh);
-				(void) qh_schedule(ehci, qh);
-			}
 		}
 	}
 	spin_unlock_irqrestore(&ehci->lock, flags);

commit 3a44494e233c0fdd818d485cfea8998500543589
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 19 12:22:06 2009 -0400

    USB: EHCI: rescan the queue after an unlink
    
    This patch (as1280) fixes an obscure bug in ehci-hcd's dequeuing logic
    for async URBs.  If a later URB is unlinked and the completion
    routine unlinks an earlier URB, then the earlier URB won't be given
    back in a timely manner because the endpoint queue isn't rescanned as
    it should be.
    
    Similar bugs occur if an endpoint is reset or a halt is cleared while
    a completion routine is running, because the subroutines don't test
    for the COMPLETING state.
    
    All these problems are solved by adding a new needs_rescan flag to the
    ehci_qh structure.  If the flag is set while scanning through an idle
    QH, the scan will be repeated.  If the QH isn't idle then an unlink
    cycle will be initiated, and the proper action will be taken when it
    becomes idle.
    
    Also, an unnecessary test is removed from qh_link_async(): That
    routine is never called if the QH's state isn't IDLE.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6887aac5e73d..d7e85b6231b3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -863,12 +863,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state) && ehci->reclaim)
 		end_unlink_async(ehci);
 
-	/* if it's not linked then there's nothing to do */
-	if (qh->qh_state != QH_STATE_LINKED)
-		;
+	/* If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh->qh_state != QH_STATE_LINKED) {
+		if (qh->qh_state == QH_STATE_COMPLETING)
+			qh->needs_rescan = 1;
+		return;
+	}
 
 	/* defer till later if busy */
-	else if (ehci->reclaim) {
+	if (ehci->reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci->reclaim;
@@ -1001,6 +1007,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		qh->qh_state = QH_STATE_IDLE;
 	switch (qh->qh_state) {
 	case QH_STATE_LINKED:
+	case QH_STATE_COMPLETING:
 		for (tmp = ehci->async->qh_next.qh;
 				tmp && tmp != qh;
 				tmp = tmp->qh_next.qh)
@@ -1065,7 +1072,8 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh->qh_state == QH_STATE_LINKED) {
+		} else if (qh->qh_state == QH_STATE_LINKED ||
+				qh->qh_state == QH_STATE_COMPLETING) {
 
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;

commit 6e23ec4ff2f2181c22ea02cf3774b882acef27e0
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Tue Jul 28 23:52:21 2009 +0530

    USB: EHCI: OHCI: Remove unnecessary includes of reboot.h
    
    EHCI: OHCI: Remove unnecessary includes of reboot.h
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c227ba46d6f3..6887aac5e73d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -30,7 +30,6 @@
 #include <linux/timer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
-#include <linux/reboot.h>
 #include <linux/usb.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>

commit 501c9c0802d9fee05efb300de06c8b3d04f17458
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Mon Jul 27 14:47:40 2009 -0700

    USB: at91: Add USB EHCI driver for at91sam9g45 series
    
    Add host USB High speed driver for at91sam9g45 series.
    The host driver is an EHCI with its companion OHCI. EHCI is
    handled by the new ehci-atmel.c whereas the OHCI is always
    handled by ohci-at91.c.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5fbc67c5a913..c227ba46d6f3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1136,6 +1136,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
 #endif
 
+#ifdef CONFIG_ARCH_AT91
+#include "ehci-atmel.c"
+#define	PLATFORM_DRIVER		ehci_atmel_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"

commit 331ac6b288d9f3689514ced1878041fb0df7e13c
Author: Alek Du <alek.du@intel.com>
Date:   Mon Jul 13 12:41:20 2009 +0800

    USB: EHCI: Add Intel Moorestown EHCI controller HOSTPCx extensions and support phy low power mode
    
    The Intel Moorestown EHCI controller supports non-standard HOSTPCx register
    extension. This register controls the LPM behaviour and controls the behaviour
    of each USB port.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7bee1638dfd7..5fbc67c5a913 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -249,6 +249,12 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	retval = handshake (ehci, &ehci->regs->command,
 			    CMD_RESET, 0, 250 * 1000);
 
+	if (ehci->has_hostpc) {
+		ehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,
+			(u32 __iomem *)(((u8 *)ehci->regs) + USBMODE_EX));
+		ehci_writel(ehci, TXFIFO_DEFAULT,
+			(u32 __iomem *)(((u8 *)ehci->regs) + TXFILLTUNING));
+	}
 	if (retval)
 		return retval;
 

commit 3807e26d69b9ad3864fe03224ebebc9610d5802e
Author: Alek Du <alek.du@intel.com>
Date:   Tue Jul 14 07:23:29 2009 +0800

    USB: EHCI: split ehci_qh into hw and sw parts
    
    The ehci_qh structure merged hw and sw together which is not good:
    1. More and more items are being added into ehci_qh, the ehci_qh software
       part are unnecessary to be allocated in DMA qh_pool.
    2. If HCD has local SRAM, the sw part will consume it too, and it won't
       bring any benefit.
    3. For non-cache-coherence system, the entire ehci_qh is uncachable, actually
       we only need the hw part to be uncacheable. Spliting them will let the sw
       part to be cacheable.
    
    Signed-off-by: Alek Du <alek.du@intel.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    CC: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2dc15f3ad143..7bee1638dfd7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -507,6 +507,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	u32			temp;
 	int			retval;
 	u32			hcc_params;
+	struct ehci_qh_hw	*hw;
 
 	spin_lock_init(&ehci->lock);
 
@@ -550,12 +551,13 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * from automatically advancing to the next td after short reads.
 	 */
 	ehci->async->qh_next.qh = NULL;
-	ehci->async->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
-	ehci->async->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
-	ehci->async->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
-	ehci->async->hw_qtd_next = EHCI_LIST_END(ehci);
+	hw = ehci->async->hw;
+	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
+	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
+	hw->hw_qtd_next = EHCI_LIST_END(ehci);
 	ehci->async->qh_state = QH_STATE_LINKED;
-	ehci->async->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);
+	hw->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);
 
 	/* clear interrupt enables, set irq latency */
 	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
@@ -985,7 +987,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	/* endpoints can be iso streams.  for now, we don't
 	 * accelerate iso completions ... so spin a while.
 	 */
-	if (qh->hw_info1 == 0) {
+	if (qh->hw->hw_info1 == 0) {
 		ehci_vdbg (ehci, "iso delay\n");
 		goto idle_timeout;
 	}

commit 403dbd36739e344d2d25f56ebbe342248487bd48
Author: Alek Du <alek.du@intel.com>
Date:   Mon Jul 13 17:30:41 2009 +0800

    USB: EHCI: add need_io_watchdog flag to ehci_hcd
    
    Basically the io watchdog is only useful for those quirk HCDs. For most
    good ones, it only brings unnecessary wakeups.  At least, I know the
    Intel EHCI HCDs should turn off the flag.
    
    Signed-off-by: Alek Du <alek.du@intel.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 54715b875759..2dc15f3ad143 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -127,6 +127,8 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 
 		switch (action) {
 		case TIMER_IO_WATCHDOG:
+			if (!ehci->need_io_watchdog)
+				return;
 			t = EHCI_IO_JIFFIES;
 			break;
 		case TIMER_ASYNC_OFF:
@@ -508,6 +510,10 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	spin_lock_init(&ehci->lock);
 
+	/*
+	 * keep io watchdog by default, those good HCDs could turn off it later
+	 */
+	ehci->need_io_watchdog = 1;
 	init_timer(&ehci->watchdog);
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;

commit 586dfc8cafc25cf785332fdfe9530f392e26f30d
Author: Wan ZongShun <mcuos.com@gmail.com>
Date:   Sat Jun 13 09:14:28 2009 +0800

    USB: Add nuvoton Ehci driver for w90p910 platform
    
    Add ehci support for w90p910 platform.
    
    Signed-off-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 11c627ce6022..54715b875759 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1117,6 +1117,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_W90X900_EHCI
+#include "ehci-w90x900.c"
+#define	PLATFORM_DRIVER		ehci_hcd_w90x900_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"

commit 7a0f0d951273eee889c2441846842348ebc00a2a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 31 10:40:22 2009 -0400

    USB: EHCI: fix two new bugs related to Clear-TT-Buffer
    
    This patch (as1273) fixes two(!) bugs introduced by the new
    Clear-TT-Buffer implementation in ehci-hcd.
    
            It is now possible for an idle QH to have some URBs on its
            queue -- this will happen if a Clear-TT-Buffer is pending for
            the QH's endpoint.  Consequently we should not issue a warning
            when someone tries to unlink an URB from an idle QH; instead
            we should process the request immediately.
    
            The refcounts for QHs could get messed up, because
            submit_async() would increment the refcount when calling
            qh_link_async() and qh_link_async() would then refuse to link
            the QH into the schedule if a Clear-TT-Buffer was pending.
            Instead we should increment the refcount only when the QH
            actually is added to the schedule.  The current code tries to
            be clever by leaving the refcount alone if an unlink is
            immediately followed by a relink; the patch changes this to an
            unconditional decrement and increment (although they occur in
            the opposite order).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Tested-by: Manuel Lauss <manuel.lauss@gmail.com>
    Tested-by: Matthijs Kooijman <matthijs@stdin.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7d03549c3339..11c627ce6022 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,7 +903,8 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			/* already started */
 			break;
 		case QH_STATE_IDLE:
-			WARN_ON(1);
+			/* QH might be waiting for a Clear-TT-Buffer */
+			qh_completions(ehci, qh);
 			break;
 		}
 		break;

commit 914b701280a76f96890ad63eb0fa99bf204b961c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:47:30 2009 -0400

    USB: EHCI: use the new clear_tt_buffer interface
    
    This patch (as1256) changes ehci-hcd and all the other drivers in the
    EHCI family to make use of the new clear_tt_buffer callbacks.  When a
    Clear-TT-Buffer request is in progress for a QH, the QH is not allowed
    to be linked into the async schedule until the request is finished.
    At that time, if there are any URBs queued for the QH, it is linked
    into the async schedule.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 99c75603ec87..7d03549c3339 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1003,6 +1003,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		schedule_timeout_uninterruptible(1);
 		goto rescan;
 	case QH_STATE_IDLE:		/* fully unlinked */
+		if (qh->clearing_tt)
+			goto idle_timeout;
 		if (list_empty (&qh->qtd_list)) {
 			qh_put (qh);
 			break;

commit a455212d19d312f6a99b3a4a86fb79fb91dd76c7
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 11 14:56:22 2009 -0400

    USB: EHCI: update toggle state for linked QHs
    
    This is an update to the "usb-ehci-update-toggle-state-for-linked-qhs"
    patch.  Since an HCD's endpoint_reset method can be called in
    interrupt context, it mustn't assume that interrupts are enabled or
    that it can sleep.
    
    So we revert to the original way of refreshing QHs' toggle bits.  Now
    the endpoint_reset method merely clears the toggle flag in the device
    structure (as was done before) and starts an async QH unlink.  When the
    QH is linked again, after the unlink finishes and an URB is queued,
    the qh_refresh() routine will update the QH's toggle bit.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: David <david@unsolicited.net>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2b72473544d3..99c75603ec87 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1030,12 +1030,14 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct ehci_qh		*qh;
 	int			eptype = usb_endpoint_type(&ep->desc);
+	int			epnum = usb_endpoint_num(&ep->desc);
+	int			is_out = usb_endpoint_dir_out(&ep->desc);
+	unsigned long		flags;
 
 	if (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)
 		return;
 
- rescan:
-	spin_lock_irq(&ehci->lock);
+	spin_lock_irqsave(&ehci->lock, flags);
 	qh = ep->hcpriv;
 
 	/* For Bulk and Interrupt endpoints we maintain the toggle state
@@ -1044,29 +1046,24 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * the toggle bit in the QH.
 	 */
 	if (qh) {
+		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh->qh_state == QH_STATE_IDLE) {
-			qh->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);
-		} else {
-			/* It's not safe to write into the overlay area
-			 * while the QH is active.  Unlink it first and
-			 * wait for the unlink to complete.
+		} else if (qh->qh_state == QH_STATE_LINKED) {
+
+			/* The toggle value in the QH can't be updated
+			 * while the QH is active.  Unlink it now;
+			 * re-linking will call qh_refresh().
 			 */
-			if (qh->qh_state == QH_STATE_LINKED) {
-				if (eptype == USB_ENDPOINT_XFER_BULK) {
-					unlink_async(ehci, qh);
-				} else {
-					intr_deschedule(ehci, qh);
-					(void) qh_schedule(ehci, qh);
-				}
+			if (eptype == USB_ENDPOINT_XFER_BULK) {
+				unlink_async(ehci, qh);
+			} else {
+				intr_deschedule(ehci, qh);
+				(void) qh_schedule(ehci, qh);
 			}
-			spin_unlock_irq(&ehci->lock);
-			schedule_timeout_uninterruptible(1);
-			goto rescan;
 		}
 	}
-	spin_unlock_irq(&ehci->lock);
+	spin_unlock_irqrestore(&ehci->lock, flags);
 }
 
 static int ehci_get_frame (struct usb_hcd *hcd)

commit b18ffd49e86102a9ed0a1cc83fdafe3891e844e5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 27 18:21:56 2009 -0400

    USB: EHCI: update toggle state for linked QHs
    
    This patch (as1245) fixes a bug in ehci-hcd.  When an URB is queued
    for an endpoint whose QH is already in the LINKED state, the QH
    doesn't get refreshed.  As a result, if usb_clear_halt() was called
    during the time that the QH was linked but idle, the data toggle value
    in the QH doesn't get reset.
    
    The symptom is that after a clear_halt, data gets lost and transfers
    time out.  This problem is starting to show up now because the
    "ehci-hcd unlink speedups" patch causes QHs with no queued URBs to
    remain linked for a suitable time.
    
    The patch utilizes the new endpoint_reset mechanism to fix the
    problem.  When an endpoint is reset, the new method forcibly unlinks
    the QH (if necessary) and safely updates the toggle value.  This
    allows qh_update() to be simplified and avoids using usb_device's
    toggle bits in a rather unintuitive way.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    Tested-by: David <david@unsolicited.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a2ca9cbf2809..2b72473544d3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1024,6 +1024,51 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	return;
 }
 
+static void
+ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	struct ehci_qh		*qh;
+	int			eptype = usb_endpoint_type(&ep->desc);
+
+	if (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)
+		return;
+
+ rescan:
+	spin_lock_irq(&ehci->lock);
+	qh = ep->hcpriv;
+
+	/* For Bulk and Interrupt endpoints we maintain the toggle state
+	 * in the hardware; the toggle bits in udev aren't used at all.
+	 * When an endpoint is reset by usb_clear_halt() we must reset
+	 * the toggle bit in the QH.
+	 */
+	if (qh) {
+		if (!list_empty(&qh->qtd_list)) {
+			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
+		} else if (qh->qh_state == QH_STATE_IDLE) {
+			qh->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);
+		} else {
+			/* It's not safe to write into the overlay area
+			 * while the QH is active.  Unlink it first and
+			 * wait for the unlink to complete.
+			 */
+			if (qh->qh_state == QH_STATE_LINKED) {
+				if (eptype == USB_ENDPOINT_XFER_BULK) {
+					unlink_async(ehci, qh);
+				} else {
+					intr_deschedule(ehci, qh);
+					(void) qh_schedule(ehci, qh);
+				}
+			}
+			spin_unlock_irq(&ehci->lock);
+			schedule_timeout_uninterruptible(1);
+			goto rescan;
+		}
+	}
+	spin_unlock_irq(&ehci->lock);
+}
+
 static int ehci_get_frame (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);

commit 08f4e586b9db4f398af1133a7b7457607539b958
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 24 15:13:18 2009 -0700

    USB: EHCI: use the new usb debugfs directory
    
    All usb debugfs files should be behind the usb directory, not at the
    root of debugfs.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c637207a1c80..a2ca9cbf2809 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1097,7 +1097,7 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
 #ifdef DEBUG
-	ehci_debug_root = debugfs_create_dir("ehci", NULL);
+	ehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);
 	if (!ehci_debug_root) {
 		retval = -ENOENT;
 		goto err_debug;

commit 6a35528a8346f6e6fd32ed7e51f04d1fa4ca2c01
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:13 2009 -0700

    dma-mapping: replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f2618d17710d..c637207a1c80 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -622,7 +622,7 @@ static int ehci_run (struct usb_hcd *hcd)
 		ehci_writel(ehci, 0, &ehci->regs->segment);
 #if 0
 // this is deeply broken on almost all architectures
-		if (!dma_set_mask(hcd->self.controller, DMA_64BIT_MASK))
+		if (!dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64)))
 			ehci_info(ehci, "enabled 64bit DMA\n");
 #endif
 	}

commit bc29847e16cb6b571157220ec9b20a7d86e58046
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Feb 11 14:26:38 2009 -0500

    USB: EHCI: Make timer_action out-of-line
    
    This patch (as1205) moves timer_action() from ehci.h to ehci-hcd.c and
    makes it out-of-line.  Over the years it has grown too big to be inline
    any more.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e551bb38852b..f2618d17710d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,6 +110,42 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
 /*-------------------------------------------------------------------------*/
 
+static void
+timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
+{
+	/* Don't override timeouts which shrink or (later) disable
+	 * the async ring; just the I/O watchdog.  Note that if a
+	 * SHRINK were pending, OFF would never be requested.
+	 */
+	if (timer_pending(&ehci->watchdog)
+			&& ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+				& ehci->actions))
+		return;
+
+	if (!test_and_set_bit(action, &ehci->actions)) {
+		unsigned long t;
+
+		switch (action) {
+		case TIMER_IO_WATCHDOG:
+			t = EHCI_IO_JIFFIES;
+			break;
+		case TIMER_ASYNC_OFF:
+			t = EHCI_ASYNC_JIFFIES;
+			break;
+		/* case TIMER_ASYNC_SHRINK: */
+		default:
+			/* add a jiffie since we synch against the
+			 * 8 KHz uframe counter.
+			 */
+			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			break;
+		}
+		mod_timer(&ehci->watchdog, t + jiffies);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read

commit 9aa09d2f8f4bc440d6db1c3414d4009642875240
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Sun Feb 8 16:07:58 2009 -0800

    USB: EHCI: slow down ITD reuse
    
    Currently ITDs are immediately recycled whenever their URB completes.
    However, EHCI hardware can sometimes remember some ITD state.  This
    means that when the ITD is reused before end-of-frame it may sometimes
    cause the hardware to reference bogus state.
    
    This patch defers reusing such ITDs by moving them into a new ehci member
    cached_itd_list. ITDs resting in cached_itd_list are moved back into their
    stream's free_list once scan_periodic() detects that the active frame has
    elapsed.
    
    This makes the snd_usb_us122l driver (in kernel since .28) work right
    when it's hooked up through EHCI.
    
    [ dbrownell@users.sourceforge.net: comment fixups ]
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Tested-by: Philippe Carriere <philippe-f.carriere@wanadoo.fr>
    Tested-by: Federico Briata <federicobriata@gmail.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4725d15d096f..e551bb38852b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -485,6 +485,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 
@@ -497,6 +498,7 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	ehci->reclaim = NULL;
 	ehci->next_uframe = -1;
+	ehci->clock_frame = -1;
 
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink

commit 67b2e029743a52670d77864723b4d0d40f7733b5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 12 17:04:53 2008 -0500

    USB: EHCI: fix handling of dead controllers
    
    This patch (as1165) makes a few small changes in the logic used by
    ehci-hcd when it encounters a controller error:
    
            Instead of printing out the masked status, it prints the
            original status as read directly from the hardware.
    
            It doesn't check for the STS_HALT status bit before taking
            action.  The mere fact that the STS_FATAL bit is set means
            that something bad has happened and the controller needs to
            be reset.  With the old code this test could never succeed
            because the STS_HALT bit was masked out from the status.
    
    I anticipate that this will prevent the occasional "irq X: nobody cared"
    problem people encounter when their EHCI controllers die.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 15a803b206b8..4725d15d096f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -643,7 +643,7 @@ static int ehci_run (struct usb_hcd *hcd)
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			status, pcd_status = 0, cmd;
+	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
 
 	spin_lock (&ehci->lock);
@@ -656,14 +656,14 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		goto dead;
 	}
 
-	status &= INTR_MASK;
-	if (!status) {			/* irq sharing? */
+	masked_status = status & INTR_MASK;
+	if (!masked_status) {		/* irq sharing? */
 		spin_unlock(&ehci->lock);
 		return IRQ_NONE;
 	}
 
 	/* clear (just) interrupts */
-	ehci_writel(ehci, status, &ehci->regs->status);
+	ehci_writel(ehci, masked_status, &ehci->regs->status);
 	cmd = ehci_readl(ehci, &ehci->regs->command);
 	bh = 0;
 
@@ -734,18 +734,17 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
+		ehci_err(ehci, "fatal error\n");
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
-		if (status & STS_HALT) {
-			ehci_err (ehci, "fatal error\n");
+		ehci_halt(ehci);
 dead:
-			ehci_reset (ehci);
-			ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-			/* generic layer kills/unlinks all urbs, then
-			 * uses ehci_stop to clean up the rest
-			 */
-			bh = 1;
-		}
+		ehci_reset(ehci);
+		ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+		/* generic layer kills/unlinks all urbs, then
+		 * uses ehci_stop to clean up the rest
+		 */
+		bh = 1;
 	}
 
 	if (bh)

commit a9b6148d25f15ddfe9d7a7f3e526fdb64e7cf7da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 14:23:29 2008 -0700

    USB: Fix unused label warnings in drivers/usb/host/ehci-hcd.c
    
    This gets rid of an annoying warning in ehci-hcd.c when DEBUG isn't
    enabled:
    
        warning: label 'err_debug' defined but not used
    
    by moving it inside the already-existing #ifdef DEBUG, so that it
    matches the goto.  And now my regular build is warning-free again.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d343afacb0b0..15a803b206b8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1111,8 +1111,8 @@ static int __init ehci_hcd_init(void)
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
-#endif
 err_debug:
+#endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }

commit eafe5b99f2135488b21cf17a262c54997c44f784
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 6 11:25:53 2008 -0400

    USB: EHCI: fix remote-wakeup support for ARC/TDI core
    
    This patch (as1147) fixes the remote-wakeup support for EHCI
    controllers using the ARC/TDI "embedded-TT" core.  These controllers
    turn off the RESUME bit by themselves when a port resume is complete;
    hence we need to keep separate track of which ports are suspended or
    in the process of resuming.
    
    The patch also makes a couple of small improvements in ehci_irq(),
    replacing reads of the command register with the value already stored
    in a local variable.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Thomas Reitmayr <treitmayr@devbase.at>
    CC: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 358df2a6c396..d343afacb0b0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -706,7 +706,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		pcd_status = status;
 
 		/* resume root hub? */
-		if (!(ehci_readl(ehci, &ehci->regs->command) & CMD_RUN))
+		if (!(cmd & CMD_RUN))
 			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
@@ -715,8 +715,11 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			if (pstatus & PORT_OWNER)
 				continue;
-			if (!(pstatus & PORT_RESUME)
-					|| ehci->reset_done [i] != 0)
+			if (!(test_bit(i, &ehci->suspended_ports) &&
+					((pstatus & PORT_RESUME) ||
+						!(pstatus & PORT_SUSPEND)) &&
+					(pstatus & PORT_PE) &&
+					ehci->reset_done[i] == 0))
 				continue;
 
 			/* start 20 msec resume signaling from this port,
@@ -731,9 +734,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
-		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
-						   &ehci->regs->command));
-		dbg_status (ehci, "fatal", status);
+		dbg_cmd(ehci, "fatal", cmd);
+		dbg_status(ehci, "fatal", status);
 		if (status & STS_HALT) {
 			ehci_err (ehci, "fatal error\n");
 dead:

commit 9beeee6584b9aa4f9192055512411484a2a624df
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Oct 2 11:48:13 2008 -0400

    USB: EHCI: log a warning if ehci-hcd is not loaded first
    
    This patch (as1139) adds a warning to the system log whenever ehci-hcd
    is loaded after ohci-hcd or uhci-hcd.  Nowadays most distributions are
    pretty good about not doing this; maybe the warning will help convince
    anyone still doing it wrong.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>  [2.6.27]
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fcbc1f2b2377..358df2a6c396 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1046,6 +1046,12 @@ static int __init ehci_hcd_init(void)
 		return -ENODEV;
 
 	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
+	set_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
+	if (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||
+			test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+		printk(KERN_WARNING "Warning! ehci_hcd should always be loaded"
+				" before uhci_hcd and ohci_hcd, not after\n");
+
 	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
@@ -1053,8 +1059,10 @@ static int __init ehci_hcd_init(void)
 
 #ifdef DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", NULL);
-	if (!ehci_debug_root)
-		return -ENOENT;
+	if (!ehci_debug_root) {
+		retval = -ENOENT;
+		goto err_debug;
+	}
 #endif
 
 #ifdef PLATFORM_DRIVER
@@ -1102,6 +1110,8 @@ static int __init ehci_hcd_init(void)
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
 #endif
+err_debug:
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ehci_hcd_init);
@@ -1123,6 +1133,7 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
 

commit 2b70f07343389cb474235def00b021a645ede916
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Oct 2 11:47:15 2008 -0400

    USB: EHCI, OHCI, UHCI: remove version numbers
    
    This patch (as1145) removes the essentially useless driver-version
    strings from ehci-hcd, ohci-hcd, and uhci-hcd.  It also unifies the
    form of the banner lines they display upon loading and adds a missing
    test for usb_disabled() to ehci-hcd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c6f9961eed3c..fcbc1f2b2377 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -60,7 +60,6 @@
  * providing early devices for those host controllers to talk to!
  */
 
-#define DRIVER_VERSION "10 Dec 2004"
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
@@ -621,9 +620,9 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
+		"USB %x.%x started, EHCI %x.%02x%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		temp >> 8, temp & 0xff, DRIVER_VERSION,
+		temp >> 8, temp & 0xff,
 		ignore_oc ? ", overcurrent ignored" : "");
 
 	ehci_writel(ehci, INTR_MASK,
@@ -995,9 +994,7 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
-MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
@@ -1045,6 +1042,10 @@ static int __init ehci_hcd_init(void)
 {
 	int retval = 0;
 
+	if (usb_disabled())
+		return -ENODEV;
+
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),

commit cede969fe21adece300300a455580635590deb47
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon Sep 22 15:00:07 2008 -0700

    usb: remove code associated with !CONFIG_PPC_MERGE
    
    Now that arch/ppc is gone we don't need CONFIG_PPC_MERGE anymore remove
    the dead code associated with !CONFIG_PPC_MERGE.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7378aa137a4a..c6f9961eed3c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1021,11 +1021,6 @@ MODULE_LICENSE ("GPL");
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
 #endif
 
-#if defined(CONFIG_440EPX) && !defined(CONFIG_PPC_MERGE)
-#include "ehci-ppc-soc.c"
-#define	PLATFORM_DRIVER		ehci_ppc_soc_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_HCD_PPC_OF
 #include "ehci-ppc-of.c"
 #define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver

commit 3c04e20ea95f9a8555456000e0ff340bdc46dea8
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Thu Sep 18 23:06:21 2008 +0800

    USB: ehci-dbg: increase debug buffer size for periodic file
    
    This patch is based on the following ideas:
    
    1. Some usb devices (such as usb video class) have endpoints of high
       interval attribute, so reading "periodic" file need more debug buffer
       to accommodate the qh or itd schedule information.  For example, 4KB
       buffer is not enough for a single interrupt qh of 2ms period.
    
    2. print a %p need 16 byte buffer on 64-bits arch, but 8 byte on 32-bits
       arch. Add a extra bonus for 64-bits arch.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8409e0705d63..7378aa137a4a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/vmalloc.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>

commit 0bcfeb3ec9467a8dfae3e906925ec28fe788afcf
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Aug 26 14:43:46 2008 -0700

    USB: ehci: fix some ehci hangs and crashes
    
    I noticed that the "Refactor "if (handshake()) state = HC_STATE_HALT"
    patch from earlier this year perpetuated a potential problem:  it can
    mark the controller as halted when it's still running (but not acting
    as, perhaps wrongly, expected).
    
    That caused some hangs and crashes, rather than more polite failure
    modes of a truly halted controller.  This patch forces a true halt,
    and emits a (previously missing) diagnostic.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d9d53f289caf..8409e0705d63 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -145,16 +145,6 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 	return -ETIMEDOUT;
 }
 
-static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
-				       u32 mask, u32 done, int usec)
-{
-	int error = handshake(ehci, ptr, mask, done, usec);
-	if (error)
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-
-	return error;
-}
-
 /* force HC to halt state from unknown (EHCI spec section 2.3) */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
@@ -173,6 +163,22 @@ static int ehci_halt (struct ehci_hcd *ehci)
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
+static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
+				       u32 mask, u32 done, int usec)
+{
+	int error;
+
+	error = handshake(ehci, ptr, mask, done, usec);
+	if (error) {
+		ehci_halt(ehci);
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+		ehci_err(ehci, "force halt; handhake %p %08x %08x -> %d\n",
+			ptr, mask, done, error);
+	}
+
+	return error;
+}
+
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {

commit b963801164618e25fbdc0cd452ce49c3628b46c8
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Jun 3 22:21:55 2008 -0700

    USB: ehci-hcd unlink speedups
    
    This patch fixes some performance bugs observed with some workloads
    when unlinking EHCI queue header (QH) descriptors from the async ring
    (control/bulk schedule).
    
    The mechanism intended to defer unlinking an empty QH (so there is no
    penalty in common cases where it's quickly reused) was not working as
    intended.  Sometimes the unlink was scheduled:
    
     - too quickly ... which can be a *strong* negative effect, since
       that QH becomes unavailable for immediate re-use;
    
     - too slowly ... wasting DMA cycles, usually a minor issue except
       for increased bus contention and power usage;
    
    Plus there was an extreme case of "too slowly":  a logical error in the
    IAA watchdog-timer conversion meant that sometimes the unlink never
    got scheduled.
    
    The fix replaces a simple counter with a timestamp derived from the
    controller's 8 KHz microframe counter, and adjusts the timer usage
    for some issues associated with HZ being less than 8K.
    
    (Based on a patch originally by Alan Stern, and good troubleshooting
    from  Leonid.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Leonid <leonidv11@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 369a8a5ea7bb..d9d53f289caf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -84,7 +84,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+#define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6

commit 21da84a89312dd8d014ca3352d1ab5c2279ec548
Author: Sarah Sharp <sarah.a.sharp@intel.com>
Date:   Tue Apr 8 14:30:18 2008 -0700

    USB: ehci shutdown refactored
    
    This patch refactors some shutdown code so it can be shared between
    ehci_stop() and ehci_shutdown().
    
    This also fixes a couple potential bugs:
     - ehci_shutdown() was not locking ehci->lock before halting the HC.
     - ehci_shutdown() didn't disable the watchdog and IAA timers.
     - ehci_stop() was resetting the host controller when it may have been
       running, which the EHCI spec says "may result in undefined behavior".
    
    ehci_stop() was calling port_power() to turn off the ports, which waited
    20ms after applying the port change.  The msleep was for the case where
    the HC might take 20ms to turn the ports on; since we're shutting them
    off, we can avoid the msleep and just use ehci_turn_off_ports().
    
    ehci_stop() doesn't need to clear the intr_enable register or revert
    ownership of the companion controllers to the BIOS, because the host
    controller reset should have done that.  There might be a buggy host
    controller that doesn't follow the reset rules, but for now we assume
    it's redundant code and remove it.
    
    [ A subsequent patch will cancel the timers later ... this version
    carries forward existing bugs where timers could get re-armed
    after they're canceled. ]
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@intel.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a02dcff5eb21..369a8a5ea7bb 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -331,17 +331,13 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 				&ehci->regs->port_status[port]);
 }
 
-/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
- * This forcibly disables dma and IRQs, helping kexec and other cases
- * where the next system software may expect clean state.
+/*
+ * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
+ * Should be called with ehci->lock held.
  */
-static void
-ehci_shutdown (struct usb_hcd *hcd)
+static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
-	struct ehci_hcd	*ehci;
-
-	ehci = hcd_to_ehci (hcd);
-	(void) ehci_halt (ehci);
+	ehci_halt(ehci);
 	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
@@ -351,6 +347,22 @@ ehci_shutdown (struct usb_hcd *hcd)
 	ehci_readl(ehci, &ehci->regs->configured_flag);
 }
 
+/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
+ * This forcibly disables dma and IRQs, helping kexec and other cases
+ * where the next system software may expect clean state.
+ */
+static void ehci_shutdown(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+
+	del_timer_sync(&ehci->watchdog);
+	del_timer_sync(&ehci->iaa_watchdog);
+
+	spin_lock_irq(&ehci->lock);
+	ehci_silence_controller(ehci);
+	spin_unlock_irq(&ehci->lock);
+}
+
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
@@ -401,15 +413,15 @@ static void ehci_work (struct ehci_hcd *ehci)
 		timer_action (ehci, TIMER_IO_WATCHDOG);
 }
 
+/*
+ * Called when the ehci_hcd module is removed.
+ */
 static void ehci_stop (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 
 	ehci_dbg (ehci, "stop\n");
 
-	/* Turn off port power on all root hub ports. */
-	ehci_port_power (ehci, 0);
-
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
 	del_timer_sync(&ehci->iaa_watchdog);
@@ -418,13 +430,10 @@ static void ehci_stop (struct usb_hcd *hcd)
 	if (HC_IS_RUNNING (hcd->state))
 		ehci_quiesce (ehci);
 
+	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	spin_unlock_irq(&ehci->lock);
 
-	/* let companion controllers work when we aren't */
-	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-
 	remove_companion_file(ehci);
 	remove_debug_files (ehci);
 

commit 25b70a8665e9854504b9196c3098dadd37c721aa
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Mar 4 15:11:07 2008 -0800

    USB: ehci: paranoia, reject large control transfers
    
    Some EHCI fault paths with large control transfers aren't coded.  Avoid
    problems by rejecting transfers that may need two qTDs (16+ KB).  This is
    mostly paranoia; even 4 KB transfers are rare, and most HCDs use lower
    limits (so it's unlikely anyone would ever try such a thing).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8c3e860bfce3..a02dcff5eb21 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -764,8 +764,14 @@ static int ehci_urb_enqueue (
 	INIT_LIST_HEAD (&qtd_list);
 
 	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
+	case PIPE_CONTROL:
+		/* qh_completions() code doesn't handle all the fault cases
+		 * in multi-TD control transfers.  Even 1KB is rare anyway.
+		 */
+		if (urb->transfer_buffer_length > (16 * 1024))
+			return -EMSGSIZE;
+		/* FALLTHROUGH */
+	/* case PIPE_BULK: */
 	default:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;

commit d1b1842c393cf322712b669ec887397b89ed2312
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Mar 5 23:37:52 2008 -0800

    USB: ehci: remove obsolete workaround for bogus IRQs
    
    It was pointed out that we found and fixed the cause of the "bogus"
    fatal IRQ reports some time ago ... this patch removes the code
    which was working around that bug ("status" got clobbered), and a
    comment which needlessly confused folk reading this code.
    
    This also includes a minor cleanup to the code which fixed that bug.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 40f7391bf2aa..8c3e860bfce3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -686,6 +686,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+
+		/* kick root hub later */
 		pcd_status = status;
 
 		/* resume root hub? */
@@ -714,8 +716,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
-		/* bogus "fatal" IRQs appear on some chips... why?  */
-		status = ehci_readl(ehci, &ehci->regs->status);
 		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
 						   &ehci->regs->command));
 		dbg_status (ehci, "fatal", status);
@@ -734,7 +734,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	if (bh)
 		ehci_work (ehci);
 	spin_unlock (&ehci->lock);
-	if (pcd_status & STS_PCD)
+	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
 	return IRQ_HANDLED;
 }

commit c765d4cad977f7e454a53d5bca5a942156b2d94c
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Sat Feb 16 13:44:42 2008 -0800

    USB: EHCI: Refactor "if (handshake()) state = HC_STATE_HALT"
    
    Refactor the EHCI "if (handshake()) state = HC_STATE_HALT" idiom,
    which appears 4 times, by replacing it with calls to a new function
    called handshake_on_error_set_halt().  Saves a few bytes too.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 360712207262..40f7391bf2aa 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -145,6 +145,16 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 	return -ETIMEDOUT;
 }
 
+static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
+				       u32 mask, u32 done, int usec)
+{
+	int error = handshake(ehci, ptr, mask, done, usec);
+	if (error)
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+
+	return error;
+}
+
 /* force HC to halt state from unknown (EHCI spec section 2.3) */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
@@ -217,11 +227,9 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	/* wait for any schedule enables/disables to take effect */
 	temp = ehci_readl(ehci, &ehci->regs->command) << 10;
 	temp &= STS_ASS | STS_PSS;
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				temp, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	if (handshake_on_error_set_halt(ehci, &ehci->regs->status,
+					STS_ASS | STS_PSS, temp, 16 * 125))
 		return;
-	}
 
 	/* then disable anything that's still active */
 	temp = ehci_readl(ehci, &ehci->regs->command);
@@ -229,11 +237,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	ehci_writel(ehci, temp, &ehci->regs->command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				0, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return;
-	}
+	handshake_on_error_set_halt(ehci, &ehci->regs->status,
+				    STS_ASS | STS_PSS, 0, 16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/

commit 9776afc8b3dc487557f3f576002520f59be334e6
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Feb 1 11:42:05 2008 -0800

    USB: ehci: minor cleanups
    
    Minor cleanups to the EHCI code:  revision history is what source
    code repositories should have.  Switch to a more standard way to
    kick in verbose debugging -- don't be EHCI-specific.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 85074cb36f38..360712207262 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -57,35 +57,6 @@
  * Special thanks to Intel and VIA for providing host controllers to
  * test this driver on, and Cypress (including In-System Design) for
  * providing early devices for those host controllers to talk to!
- *
- * HISTORY:
- *
- * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)
- * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)
- * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,
- *	<sojkam@centrum.cz>, updates by DB).
- *
- * 2002-11-29	Correct handling for hw async_next register.
- * 2002-08-06	Handling for bulk and interrupt transfers is mostly shared;
- *	only scheduling is different, no arbitrary limitations.
- * 2002-07-25	Sanity check PCI reads, mostly for better cardbus support,
- *	clean up HC run state handshaking.
- * 2002-05-24	Preliminary FS/LS interrupts, using scheduling shortcuts
- * 2002-05-11	Clear TT errors for FS/LS ctrl/bulk.  Fill in some other
- *	missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.
- * 2002-05-07	Some error path cleanups to report better errors; wmb();
- *	use non-CVS version id; better iso bandwidth claim.
- * 2002-04-19	Control/bulk/interrupt submit no longer uses giveback() on
- *	errors in submit path.  Bugfixes to interrupt scheduling/processing.
- * 2002-03-05	Initial high-speed ISO support; reduce ITD memory; shift
- *	more checking to generic hcd framework (db).  Make it work with
- *	Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).
- * 2002-01-14	Minor cleanup; version synch.
- * 2002-01-08	Fix roothub handoff of FS/LS to companion controllers.
- * 2002-01-04	Control/Bulk queuing behaves.
- *
- * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.
- * 2001-June	Works with usb-storage and NEC EHCI on 2.4
  */
 
 #define DRIVER_VERSION "10 Dec 2004"
@@ -95,7 +66,7 @@
 static const char	hcd_name [] = "ehci_hcd";
 
 
-#undef EHCI_VERBOSE_DEBUG
+#undef VERBOSE_DEBUG
 #undef EHCI_URB_TRACE
 
 #ifdef DEBUG
@@ -676,7 +647,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	cmd = ehci_readl(ehci, &ehci->regs->command);
 	bh = 0;
 
-#ifdef	EHCI_VERBOSE_DEBUG
+#ifdef	VERBOSE_DEBUG
 	/* unrequested/ignored: Frame List Rollover */
 	dbg_status (ehci, "irq", status);
 #endif

commit 705a752162768fed3e2c26fba5bffdd3a3bd04f2
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:40 2008 -0400

    plat-orion: make ehci-orion available for all Orion families
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 46ee7f4c0912..85074cb36f38 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1033,7 +1033,7 @@ MODULE_LICENSE ("GPL");
 #define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
 #endif
 
-#ifdef CONFIG_ARCH_ORION
+#ifdef CONFIG_PLAT_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver
 #endif

commit e82cc1288fa57857c6af8c57f3d07096d4bcd9d9
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Mar 7 13:49:42 2008 -0800

    USB: fix ehci unlink regressions
    
    The recent EHCI driver update to split the IAA watchdog timer out from
    the other timers made several things work better, but not everything;
    and it created a couple new issues in bugzilla.  Ergo this patch:
    
      - Handle a should-be-rare SMP race between the watchdog firing
        and (very late) IAA interrupts;
    
      - Remove a shouldn't-have-been-added WARN_ON() test;
    
      - Guard against one observed OOPS;
    
      - If this watchdog fires during clean HC shutdown, it should act
        as a NOP instead of interfering with the shutdown sequence;
    
      - Guard against silicon errata hypothesized by some vendors:
          * IAA status latch broken, but IAAD cleared OK;
          * IAAD wasn't cleared when IAA status got reported;
    
    The WARN_ON is in bugzilla as 10168; the OOPS as 10078; these are
    both regressions.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Tested-by: Gordon Farquharson <gordonfarquharson@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b8ad55aff842..46ee7f4c0912 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -281,23 +281,44 @@ static void ehci_iaa_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
-	u32			status, cmd;
 
 	spin_lock_irqsave (&ehci->lock, flags);
-	WARN_ON(!ehci->reclaim);
 
-	status = ehci_readl(ehci, &ehci->regs->status);
-	cmd = ehci_readl(ehci, &ehci->regs->command);
-	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
-
-	/* lost IAA irqs wedge things badly; seen first with a vt8235 */
-	if (ehci->reclaim) {
-		if (status & STS_IAA) {
-			ehci_vdbg (ehci, "lost IAA\n");
+	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci->reclaim
+			&& !timer_pending(&ehci->iaa_watchdog)
+			&& HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
+		u32 cmd, status;
+
+		/* If we get here, IAA is *REALLY* late.  It's barely
+		 * conceivable that the system is so busy that CMD_IAAD
+		 * is still legitimately set, so let's be sure it's
+		 * clear before we read STS_IAA.  (The HC should clear
+		 * CMD_IAAD when it sets STS_IAA.)
+		 */
+		cmd = ehci_readl(ehci, &ehci->regs->command);
+		if (cmd & CMD_IAAD)
+			ehci_writel(ehci, cmd & ~CMD_IAAD,
+					&ehci->regs->command);
+
+		/* If IAA is set here it either legitimately triggered
+		 * before we cleared IAAD above (but _way_ late, so we'll
+		 * still count it as lost) ... or a silicon erratum:
+		 * - VIA seems to set IAA without triggering the IRQ;
+		 * - IAAD potentially cleared without setting IAA.
+		 */
+		status = ehci_readl(ehci, &ehci->regs->status);
+		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
 			COUNT (ehci->stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 		}
-		ehci_writel(ehci, cmd & ~CMD_IAAD, &ehci->regs->command);
+
+		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
+				status, cmd);
 		end_unlink_async(ehci);
 	}
 
@@ -631,7 +652,7 @@ static int ehci_run (struct usb_hcd *hcd)
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			status, pcd_status = 0;
+	u32			status, pcd_status = 0, cmd;
 	int			bh;
 
 	spin_lock (&ehci->lock);
@@ -652,7 +673,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* clear (just) interrupts */
 	ehci_writel(ehci, status, &ehci->regs->status);
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted write */
+	cmd = ehci_readl(ehci, &ehci->regs->command);
 	bh = 0;
 
 #ifdef	EHCI_VERBOSE_DEBUG
@@ -673,8 +694,17 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
-		COUNT (ehci->stats.reclaim);
-		end_unlink_async(ehci);
+		/* guard against (alleged) silicon errata */
+		if (cmd & CMD_IAAD) {
+			ehci_writel(ehci, cmd & ~CMD_IAAD,
+					&ehci->regs->command);
+			ehci_dbg(ehci, "IAA with IAAD still set?\n");
+		}
+		if (ehci->reclaim) {
+			COUNT(ehci->stats.reclaim);
+			end_unlink_async(ehci);
+		} else
+			ehci_dbg(ehci, "IAA with nothing to reclaim?\n");
 	}
 
 	/* remote wakeup [4.3.1] */
@@ -781,7 +811,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))
+	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state) && ehci->reclaim)
 		end_unlink_async(ehci);
 
 	/* if it's not linked then there's nothing to do */

commit c6dd2e61d35e0fbd516c0169decc08e56619f0c6
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Thu Feb 21 22:49:13 2008 +0300

    USB: POWERPC: ehci: fix ppc build
    
    Currently, this setup:
    CONFIG_USB_ARCH_HAS_EHCI=y
    CONFIG_USB_EHCI_HCD=y
    CONFIG_USB_EHCI_HCD_PPC_OF=y
    
    Will fail to build:
      CC      drivers/usb/host/ehci-hcd.o
    drivers/usb/host/ehci-hcd.c:1018:2: error: #error "missing bus glue for ehci-hcd"
    make[3]: *** [drivers/usb/host/ehci-hcd.o] Error 1
    
    ehci-hcd.c actually contains OF_PLATFORM_DRIVER glue, so error is bogus.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d64887bfa6af..b8ad55aff842 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1014,7 +1014,7 @@ MODULE_LICENSE ("GPL");
 #endif
 
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER)
+    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 

commit e1a491429e7f9b6fb608d9f173e5807fba053d5b
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Feb 2 02:36:53 2008 -0800

    USB: fix previous sparse fix which was incorrect
    
    The previous fix for a "sparse" warning in ehci_urb_dequeue() was
    incorrect.  After rescheduling interrupt transfers it returned the
    URB's completion status, not status for the dequeue operation itself.
    
    This patch resolves that issue, cleans up the code in the reschedule
    path, and shrinks the object code by a dozen bytes.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4caa6a8b9a37..d64887bfa6af 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -862,18 +862,18 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		/* reschedule QH iff another request is queued */
 		if (!list_empty (&qh->qtd_list)
 				&& HC_IS_RUNNING (hcd->state)) {
-			int schedule_status;
-
-			schedule_status = qh_schedule (ehci, qh);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-
-			if (schedule_status != 0) {
-				// shouldn't happen often, but ...
-				// FIXME kill those tds' urbs
-				err ("can't reschedule qh %p, err %d",
-					qh, schedule_status);
-			}
-			return status;
+			rc = qh_schedule(ehci, qh);
+
+			/* An error here likely indicates handshake failure
+			 * or no space left in the schedule.  Neither fault
+			 * should happen often ...
+			 *
+			 * FIXME kill the now-dysfunctional queued urbs
+			 */
+			if (rc != 0)
+				ehci_err(ehci,
+					"can't reschedule qh %p, err %d",
+					qh, rc);
 		}
 		break;
 

commit 91bc4d31e81b15aa6e2d075307b8727041f2e2d1
Author: Vladimir Barinov <vbarinov@ru.mvista.com>
Date:   Sun Dec 30 15:21:11 2007 -0800

    USB: add ehci-ixp bus glue
    
    EHCI Glue driver for Intel IXP4XX EHCI USB controller
    
    Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 53fc97fced20..4caa6a8b9a37 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1008,6 +1008,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_orion_driver
 #endif
 
+#ifdef CONFIG_ARCH_IXP4XX
+#include "ehci-ixp4xx.c"
+#define	PLATFORM_DRIVER		ixp4xx_ehci_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER)
 #error "missing bus glue for ehci-hcd"

commit da0e8fb00b862aa10265f0c64930b432cd44420b
Author: Valentine Barshak <vbarshak@ru.mvista.com>
Date:   Sun Dec 30 15:28:50 2007 -0800

    USB: add ehci-ppc-of bus glue (device-tree aware)
    
    This adds device-tree-aware ehci-ppc-of driver.
    The code is based on the ehci-ppc-soc driver by
    Stefan Roese <sr@denx.de>.
    
    Signed-off-by: Valentine Barshak <vbarshak@ru.mvista.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Stefan Roese <sr@denx.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7c5c8796d175..53fc97fced20 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -993,11 +993,16 @@ MODULE_LICENSE ("GPL");
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
 #endif
 
-#ifdef CONFIG_440EPX
+#if defined(CONFIG_440EPX) && !defined(CONFIG_PPC_MERGE)
 #include "ehci-ppc-soc.c"
 #define	PLATFORM_DRIVER		ehci_ppc_soc_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_HCD_PPC_OF
+#include "ehci-ppc-of.c"
+#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
+#endif
+
 #ifdef CONFIG_ARCH_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver
@@ -1025,52 +1030,58 @@ static int __init ehci_hcd_init(void)
 
 #ifdef PLATFORM_DRIVER
 	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0) {
-#ifdef DEBUG
-		debugfs_remove(ehci_debug_root);
-		ehci_debug_root = NULL;
-#endif
-		return retval;
-	}
+	if (retval < 0)
+		goto clean0;
 #endif
 
 #ifdef PCI_DRIVER
 	retval = pci_register_driver(&PCI_DRIVER);
-	if (retval < 0) {
-#ifdef DEBUG
-		debugfs_remove(ehci_debug_root);
-		ehci_debug_root = NULL;
-#endif
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-		return retval;
-	}
+	if (retval < 0)
+		goto clean1;
 #endif
 
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0) {
-#ifdef DEBUG
-		debugfs_remove(ehci_debug_root);
-		ehci_debug_root = NULL;
+	if (retval < 0)
+		goto clean2;
 #endif
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
+
+#ifdef OF_PLATFORM_DRIVER
+	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
+	if (retval < 0)
+		goto clean3;
+#endif
+	return retval;
+
+#ifdef OF_PLATFORM_DRIVER
+	/* of_unregister_platform_driver(&OF_PLATFORM_DRIVER); */
+clean3:
+#endif
+#ifdef PS3_SYSTEM_BUS_DRIVER
+	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+clean2:
 #endif
 #ifdef PCI_DRIVER
-		pci_unregister_driver(&PCI_DRIVER);
+	pci_unregister_driver(&PCI_DRIVER);
+clean1:
 #endif
-		return retval;
-	}
+#ifdef PLATFORM_DRIVER
+	platform_driver_unregister(&PLATFORM_DRIVER);
+clean0:
+#endif
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+	ehci_debug_root = NULL;
 #endif
-
 	return retval;
 }
 module_init(ehci_hcd_init);
 
 static void __exit ehci_hcd_cleanup(void)
 {
+#ifdef OF_PLATFORM_DRIVER
+	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
+#endif
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif

commit e96ffe2f9debd5fdc53144259d9e5faa514736b9
Author: Tzachi Perelstein <tzachi@marvell.com>
Date:   Sat Dec 1 11:07:04 2007 -0500

    USB: add Marvell Orion USB host support
    
    Some glue bits for the on-chip USB host controller in the Marvell Orion
    family of ARM SoCs, which is basically EHCI compatible.
    
    Signed-off-by: Tzachi Perelstein <tzachi@marvell.com>
    Reviewed-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fb2b227afc4f..7c5c8796d175 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -998,6 +998,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_ppc_soc_driver
 #endif
 
+#ifdef CONFIG_ARCH_ORION
+#include "ehci-orion.c"
+#define	PLATFORM_DRIVER		ehci_orion_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER)
 #error "missing bus glue for ehci-hcd"

commit f570728f89c9d4b262f7c180e5a8e230e675af0c
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Sun Dec 16 03:25:13 2007 +0100

    USB: ehci-hcd: fix sparse warning about shadowing 'status' symbol
    
    fix warning:
    drivers/usb/host/ehci-hcd.c:832:8: warning: symbol 'status' shadows an earlier one
    drivers/usb/host/ehci-hcd.c:790:71: originally declared here
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5917c6b7ce33..fb2b227afc4f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -862,16 +862,16 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		/* reschedule QH iff another request is queued */
 		if (!list_empty (&qh->qtd_list)
 				&& HC_IS_RUNNING (hcd->state)) {
-			int status;
+			int schedule_status;
 
-			status = qh_schedule (ehci, qh);
+			schedule_status = qh_schedule (ehci, qh);
 			spin_unlock_irqrestore (&ehci->lock, flags);
 
-			if (status != 0) {
+			if (schedule_status != 0) {
 				// shouldn't happen often, but ...
 				// FIXME kill those tds' urbs
 				err ("can't reschedule qh %p, err %d",
-					qh, status);
+					qh, schedule_status);
 			}
 			return status;
 		}

commit 07d29b63ef6b39963ab37818653284d861cf55af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 11 16:05:30 2007 -0500

    USB: EHCI: add separate IAA watchdog timer
    
    This patch (as1028) was mostly written by David Brownell; I made only
    a few changes (extra log info and a small bug fix -- which might
    account for why David's version had to be reverted).  It adds a new
    watchdog timer to the ehci-hcd driver to be used exclusively for
    detecting lost or missing IAA notifications.
    
    Previously a shared timer had been used, which may have led to some
    problems as reported by Christian Hoffmann.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 264182654f4c..5917c6b7ce33 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,7 +110,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_MULT_TT	1
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
-#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
@@ -267,6 +267,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
+static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
@@ -276,25 +277,41 @@ static void ehci_work(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog (unsigned long param)
+static void ehci_iaa_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
+	u32			status, cmd;
 
 	spin_lock_irqsave (&ehci->lock, flags);
+	WARN_ON(!ehci->reclaim);
 
-	/* lost IAA irqs wedge things badly; seen with a vt8235 */
+	status = ehci_readl(ehci, &ehci->regs->status);
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
+
+	/* lost IAA irqs wedge things badly; seen first with a vt8235 */
 	if (ehci->reclaim) {
-		u32		status = ehci_readl(ehci, &ehci->regs->status);
 		if (status & STS_IAA) {
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci->stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
-			ehci->reclaim_ready = 1;
 		}
+		ehci_writel(ehci, cmd & ~CMD_IAAD, &ehci->regs->command);
+		end_unlink_async(ehci);
 	}
 
- 	/* stop async processing after it's idled a bit */
+	spin_unlock_irqrestore(&ehci->lock, flags);
+}
+
+static void ehci_watchdog(unsigned long param)
+{
+	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+
+	/* stop async processing after it's idled a bit */
 	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
 		start_unlink_async (ehci, ehci->async);
 
@@ -364,8 +381,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci->reclaim_ready)
-		end_unlink_async (ehci);
 
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -400,6 +415,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
+	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	if (HC_IS_RUNNING (hcd->state))
@@ -448,6 +464,10 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
+	init_timer(&ehci->iaa_watchdog);
+	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
+	ehci->iaa_watchdog.data = (unsigned long) ehci;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -464,7 +484,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
-	ehci->reclaim_ready = 0;
 	ehci->next_uframe = -1;
 
 	/*
@@ -655,8 +674,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
 		COUNT (ehci->stats.reclaim);
-		ehci->reclaim_ready = 1;
-		bh = 1;
+		end_unlink_async(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */
@@ -762,10 +780,16 @@ static int ehci_urb_enqueue (
 
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* if we need to use IAA and it's busy, defer */
-	if (qh->qh_state == QH_STATE_LINKED
-			&& ehci->reclaim
-			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
+	/* failfast */
+	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))
+		end_unlink_async(ehci);
+
+	/* if it's not linked then there's nothing to do */
+	if (qh->qh_state != QH_STATE_LINKED)
+		;
+
+	/* defer till later if busy */
+	else if (ehci->reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci->reclaim;
@@ -775,12 +799,8 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
 		last->reclaim = qh;
 
-	/* bypass IAA if the hc can't care */
-	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
-		end_unlink_async (ehci);
-
-	/* something else might have unlinked the qh by now */
-	if (qh->qh_state == QH_STATE_LINKED)
+	/* start IAA cycle */
+	} else
 		start_unlink_async (ehci, qh);
 }
 
@@ -807,7 +827,19 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
-		unlink_async (ehci, qh);
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			unlink_async(ehci, qh);
+			break;
+		case QH_STATE_UNLINK:
+		case QH_STATE_UNLINK_WAIT:
+			/* already started */
+			break;
+		case QH_STATE_IDLE:
+			WARN_ON(1);
+			break;
+		}
 		break;
 
 	case PIPE_INTERRUPT:
@@ -899,6 +931,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		unlink_async (ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
 		spin_unlock_irqrestore (&ehci->lock, flags);
 		schedule_timeout_uninterruptible(1);

commit 694cc2087e26f3f62b9f07c5d563564ed77ef203
Author: Tony Jones <tonyj@suse.de>
Date:   Tue Sep 11 14:07:31 2007 -0700

    USB: convert ehci debug files to use debugfs instead of sysfs
    
    We should not have multiple line files in sysfs, this moves the data to
    debugfs instead, like the UHCI driver.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5f2d74ed5ad7..264182654f4c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -33,6 +33,7 @@
 #include <linux/usb.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
 
 #include "../core/hcd.h"
 
@@ -978,15 +979,30 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
+#ifdef DEBUG
+	ehci_debug_root = debugfs_create_dir("ehci", NULL);
+	if (!ehci_debug_root)
+		return -ENOENT;
+#endif
+
 #ifdef PLATFORM_DRIVER
 	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0)
+	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root);
+		ehci_debug_root = NULL;
+#endif
 		return retval;
+	}
 #endif
 
 #ifdef PCI_DRIVER
 	retval = pci_register_driver(&PCI_DRIVER);
 	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root);
+		ehci_debug_root = NULL;
+#endif
 #ifdef PLATFORM_DRIVER
 		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
@@ -997,6 +1013,10 @@ static int __init ehci_hcd_init(void)
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
 	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root);
+		ehci_debug_root = NULL;
+#endif
 #ifdef PLATFORM_DRIVER
 		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
@@ -1022,6 +1042,9 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+#endif
 }
 module_exit(ehci_hcd_cleanup);
 

commit 1cb52658b4f5b10a9e91f8e1c21ca2bcc1b9a3ca
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Nov 13 16:22:30 2007 -0800

    USB: fix up EHCI startup synchronization
    
    A recent patch added software synchronization during EHCI startup,
    so ports aren't switched away from the companion controllers after
    resets have started.  This patch adds a short delay letting hardware
    finish that port switching before any new resets begin ... so both
    ends of that hardware race window are closed.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Dave Miller <davem@davemloft.net>
    Cc: Dely Sy <dely.l.sy@intel.com>
    Cc: stable <stable@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c1514442883e..5f2d74ed5ad7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -575,12 +575,15 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * from the companions to the EHCI controller.  If any of the
 	 * companions are in the middle of a port reset at the time, it
 	 * could cause trouble.  Write-locking ehci_cf_port_reset_rwsem
-	 * guarantees that no resets are in progress.
+	 * guarantees that no resets are in progress.  After we set CF,
+	 * a short delay lets the hardware catch up; new resets shouldn't
+	 * be started before the port switching actions could complete.
 	 */
 	down_write(&ehci_cf_port_reset_rwsem);
 	hcd->state = HC_STATE_RUNNING;
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+	msleep(5);
 	up_write(&ehci_cf_port_reset_rwsem);
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));

commit 32fe01985aa2cb2562f6fc171e526e279abe10db
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 10 16:27:07 2007 -0400

    USB: mutual exclusion for EHCI init and port resets
    
    This patch (as999) fixes a problem that sometimes shows up when host
    controller driver modules are loaded in the wrong order.  If ehci-hcd
    happens to initialize an EHCI controller while the companion OHCI or
    UHCI controller is in the middle of a port reset, the reset can fail
    and the companion may get very confused.  The patch adds an
    rw-semaphore and uses it to keep EHCI initialization and port resets
    mutually exclusive.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brownell <david-b@pacbell.net>
    Cc: David Miller <davem@davemloft.net>
    Cc: Dely L Sy <dely.l.sy@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index db00492588b6..c1514442883e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -570,10 +570,18 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * are explicitly handed to companion controller(s), so no TT is
 	 * involved with the root hub.  (Except where one is integrated,
 	 * and there's no companion controller unless maybe for USB OTG.)
+	 *
+	 * Turning on the CF flag will transfer ownership of all ports
+	 * from the companions to the EHCI controller.  If any of the
+	 * companions are in the middle of a port reset at the time, it
+	 * could cause trouble.  Write-locking ehci_cf_port_reset_rwsem
+	 * guarantees that no resets are in progress.
 	 */
+	down_write(&ehci_cf_port_reset_rwsem);
 	hcd->state = HC_STATE_RUNNING;
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+	up_write(&ehci_cf_port_reset_rwsem);
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,

commit e9df41c5c5899259541dc928872cad4d07b82076
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 8 11:48:02 2007 -0400

    USB: make HCDs responsible for managing endpoint queues
    
    This patch (as954) implements a suggestion of David Brownell's.  Now
    the host controller drivers are responsible for linking and unlinking
    URBs to/from their endpoint queues.  This eliminates the possiblity of
    strange situations where usbcore thinks an URB is linked but the HCD
    thinks it isn't.  It also means HCDs no longer have to check for URBs
    being dequeued before they were fully enqueued.
    
    In addition to the core changes, this requires changing every host
    controller driver and the root-hub URB handler.  For the most part the
    required changes are fairly small; drivers have to call
    usb_hcd_link_urb_to_ep() in their urb_enqueue method,
    usb_hcd_check_unlink_urb() in their urb_dequeue method, and
    usb_hcd_unlink_urb_from_ep() before giving URBs back.  A few HCDs make
    matters more complicated by the way they split up the flow of control.
    
    In addition some method interfaces get changed.  The endpoint argument
    for urb_enqueue is now redundant so it is removed.  The unlink status
    is required by usb_hcd_check_unlink_urb(), so it has been added to
    urb_dequeue.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    CC: Olav Kongas <ok@artecdesign.ee>
    CC: Tony Olech <tony.olech@elandigitalsystems.com>
    CC: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 35cdba10411b..db00492588b6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -719,7 +719,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
  */
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -734,12 +733,12 @@ static int ehci_urb_enqueue (
 	default:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
-		return submit_async (ehci, ep, urb, &qtd_list, mem_flags);
+		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
-		return intr_submit (ehci, ep, urb, &qtd_list, mem_flags);
+		return intr_submit(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_ISOCHRONOUS:
 		if (urb->dev->speed == USB_SPEED_HIGH)
@@ -777,13 +776,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
  * completions normally happen asynchronously
  */
 
-static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct ehci_qh		*qh;
 	unsigned long		flags;
+	int			rc;
 
 	spin_lock_irqsave (&ehci->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	switch (usb_pipetype (urb->pipe)) {
 	// case PIPE_CONTROL:
 	// case PIPE_BULK:
@@ -838,7 +842,7 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 	}
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/

commit 8eb891fc809b2300137bcd247025628c06c95a63
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Aug 20 23:38:44 2007 -0700

    Revert "USB: EHCI cpufreq fix"
    
    This reverts commit 196705c9bbc03540429b0f7cf9ee35c2f928a534.  It was
    reported to cause a regression by Daniel Exner, and Arjan van de Ven
    points out that we actually already have infrastructure in place for
    setting limits on acceptable DMA latency that would be the much more
    correct fix for the problem with some Broadcom EHCI controllers.
    
    Fixed up trivial conflicts due to the changes to support big-endian host
    controller descriptors in drivers/usb/host/{ehci-sched.c,ehci.h}.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c4e15ed1405a..35cdba10411b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -275,58 +275,6 @@ static void ehci_work(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef CONFIG_CPU_FREQ
-
-#include <linux/cpufreq.h>
-
-static void ehci_cpufreq_pause (struct ehci_hcd *ehci)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&ehci->lock, flags);
-	if (!ehci->cpufreq_changing++)
-		qh_inactivate_split_intr_qhs(ehci);
-	spin_unlock_irqrestore(&ehci->lock, flags);
-}
-
-static void ehci_cpufreq_unpause (struct ehci_hcd *ehci)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&ehci->lock, flags);
-	if (!--ehci->cpufreq_changing)
-		qh_reactivate_split_intr_qhs(ehci);
-	spin_unlock_irqrestore(&ehci->lock, flags);
-}
-
-/*
- * ehci_cpufreq_notifier is needed to avoid MMF errors that occur when
- * EHCI controllers that don't cache many uframes get delayed trying to
- * read main memory during CPU frequency transitions.  This can cause
- * split interrupt transactions to not be completed in the required uframe.
- * This has been observed on the Broadcom/ServerWorks HT1000 controller.
- */
-static int ehci_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
-				 void *data)
-{
-	struct ehci_hcd *ehci = container_of(nb, struct ehci_hcd,
-					     cpufreq_transition);
-
-	switch (val) {
-	case CPUFREQ_PRECHANGE:
-		ehci_cpufreq_pause(ehci);
-		break;
-	case CPUFREQ_POSTCHANGE:
-		ehci_cpufreq_unpause(ehci);
-		break;
-	}
-	return 0;
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 static void ehci_watchdog (unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -460,10 +408,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	spin_unlock_irq(&ehci->lock);
 
-#ifdef CONFIG_CPU_FREQ
-	cpufreq_unregister_notifier(&ehci->cpufreq_transition,
-				    CPUFREQ_TRANSITION_NOTIFIER);
-#endif
 	/* let companion controllers work when we aren't */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
@@ -569,17 +513,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	}
 	ehci->command = temp;
 
-#ifdef CONFIG_CPU_FREQ
-	INIT_LIST_HEAD(&ehci->split_intr_qhs);
-	/*
-	 * If the EHCI controller caches enough uframes, this probably
-	 * isn't needed unless there are so many low/full speed devices
-	 * that the controller's can't cache it all.
-	 */
-	ehci->cpufreq_transition.notifier_call = ehci_cpufreq_notifier;
-	cpufreq_register_notifier(&ehci->cpufreq_transition,
-				  CPUFREQ_TRANSITION_NOTIFIER);
-#endif
 	return 0;
 }
 

commit 7a4eb7fd50d4df99fc1f623e6d90680d9fca3d82
Author: Geoff Levand <geoffrey.levand@am.sony.com>
Date:   Tue Jun 5 20:04:35 2007 -0700

    USB: PS3: USB system-bus rework
    
    USB HCD glue updates to reflect the new PS3 unifed device support.
     - Fixed remove() routine.
     - Added shutdown() routine.
     - Added request_mem_region() call.
     - Fixed MODULE_ALIAS().
     - Made a proper fix for the hack done to support muti-platform in commit
       48fda45120a819ca40cadc50144b55bff1c4c78d.
    
    Signed-off-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a205a53c61ff..c4e15ed1405a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -41,10 +41,6 @@
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/unaligned.h>
-#ifdef CONFIG_PPC_PS3
-#include <asm/firmware.h>
-#endif
-
 
 /*-------------------------------------------------------------------------*/
 
@@ -1012,7 +1008,7 @@ MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
-#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_sb_driver
+#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
 #endif
 
 #ifdef CONFIG_440EPX
@@ -1051,18 +1047,15 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PS3_SYSTEM_BUS_DRIVER
-	if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
-		retval = ps3_system_bus_driver_register(
-				&PS3_SYSTEM_BUS_DRIVER);
-		if (retval < 0) {
+	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
+	if (retval < 0) {
 #ifdef PLATFORM_DRIVER
-			platform_driver_unregister(&PLATFORM_DRIVER);
+		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef PCI_DRIVER
-			pci_unregister_driver(&PCI_DRIVER);
+		pci_unregister_driver(&PCI_DRIVER);
 #endif
-			return retval;
-		}
+		return retval;
 	}
 #endif
 
@@ -1079,8 +1072,7 @@ static void __exit ehci_hcd_cleanup(void)
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
-	if (firmware_has_feature(FW_FEATURE_PS3_LV1))
-		ps3_system_bus_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
 }
 module_exit(ehci_hcd_cleanup);

commit d23a13779f14808b54181d31222e6c44532abd80
Author: Vladimir Barinov <vbarinov@ru.mvista.com>
Date:   Wed May 23 20:07:48 2007 +0400

    USB: EHCI: Safe endianness for transfer buffers after reset in case of HUB with TT
    
    This patch fixes the endianness select for transfer buffers in EHCI
    controllers that have Transaction Translator built in the hub.  Also I
    cleaned it up to make rid of magic numbers.
    
    Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
    Cc: <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 889c2027e7f7..a205a53c61ff 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -201,9 +201,15 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	u32 __iomem	*reg_ptr;
 	u32		tmp;
 
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + 0x68);
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
 	tmp = ehci_readl(ehci, reg_ptr);
-	tmp |= 0x3;
+	tmp |= USBMODE_CM_HC;
+	/* The default byte access to MMR space is LE after
+	 * controller reset. Set the required endian mode
+	 * for transfer buffers to match the host microprocessor
+	 */
+	if (ehci_big_endian_mmio(ehci))
+		tmp |= USBMODE_BE;
 	ehci_writel(ehci, tmp, reg_ptr);
 }
 

commit ba02978a48f0117b3d0aced97a30615a5d7412e2
Author: Li Yang <leoli@freescale.com>
Date:   Fri May 11 17:09:55 2007 +0800

    USB: ehci_fsl update for MPC831x support
    
    For MPC831x support, change the ehci-fsl driver to preserve
    bits set in platform code.  Add a common CONFIG_USB_EHCI_FSL
    to indicate presence of Freescale EHCI SOC.  Add FSL_USB2_DR_OTG
    operating mode support, thus both host and device can work for the
    mini-ab receptacle.  Note: this doesn't enable OTG protocol
    support.
    
    Signed-off-by: Li Yang <leoli@freescale.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f005438dedae..889c2027e7f7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -994,7 +994,7 @@ MODULE_LICENSE ("GPL");
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
-#ifdef CONFIG_MPC834x
+#ifdef CONFIG_USB_EHCI_FSL
 #include "ehci-fsl.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif

commit fc65a15f1fc0fc95c319c9bfaeb7636fef9987cc
Author: Stefan Roese <ml@stefan-roese.de>
Date:   Fri May 4 11:38:17 2007 -0700

    USB: EHCI big endian data structures support (for 440EPx)
    
    This patch adds support for the AMCC 440EPx EHCI controller whose
    in-memory data structures and the registers are represented in big-
    endian format.
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b5a7aa90209a..f005438dedae 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1009,6 +1009,11 @@ MODULE_LICENSE ("GPL");
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_sb_driver
 #endif
 
+#ifdef CONFIG_440EPX
+#include "ehci-ppc-soc.c"
+#define	PLATFORM_DRIVER		ehci_ppc_soc_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER)
 #error "missing bus glue for ehci-hcd"

commit 383975d765523a56dc43a6cd6d52e9b376800cf2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:40 2007 -0400

    USB: EHCI, OHCI: handover changes
    
    This patch (as887) changes the way ehci-hcd and ohci-hcd handle a loss
    of VBUS power during suspend.  In order for the USB-persist facility
    to work correctly, it is necessary for low- and full-speed devices
    attached to a high-speed port to be handed back to the companion
    controller during resume processing.
    
    This entails three changes: adding code to ehci-hcd to perform the
    handover, removing code from ohci-hcd to turn off ports during
    root-hub reinit, and adding code to ohci-hcd to turn on ports during
    PCI controller resume.  (Other bus glue resume methods for platforms
    supporting high-speed controllers would need a similar change, if any
    existed.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 99ab31e9778b..b5a7aa90209a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -399,6 +399,8 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 				is_on ? SetPortFeature : ClearPortFeature,
 				USB_PORT_FEAT_POWER,
 				port--, NULL, 0);
+	/* Flush those writes */
+	ehci_readl(ehci, &ehci->regs->command);
 	msleep(20);
 }
 

commit 6dbd682b7c6d58916096616cdf94852641bc09d9
Author: Stefan Roese <ml@stefan-roese.de>
Date:   Tue May 1 09:29:37 2007 -0700

    USB: EHCI support for big-endian descriptors
    
    This patch implements supports for EHCI controllers whose in-memory
    data structures are represented in big-endian format. This is needed
    (unfortunately) for the AMCC PPC440EPx SoC EHCI controller; the EHCI
    spec doesn't specify little-endian format, although that's what most
    other implementations use.
    
    The guts of the patch are to introduce the hc32 type and change all
    references from le32 to hc32.  All access routines are converted from
    cpu_to_le32(...) to cpu_to_hc32(ehci, ...) and similar for the other
    "direction".  (This is the same approach used with OHCI.)
    
    David fixed:
            Whitespace fixes; refresh against ehci cpufreq patch; move glue
            for that PPC driver to the patch adding it; fix free symbol
            capture bugs in modified "constant" macros; and make "hc32" etc
            be "le32" unless we really need the BE options, so "sparse" can
            do some real good.
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 566badb05b34..99ab31e9778b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -526,12 +526,12 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * from automatically advancing to the next td after short reads.
 	 */
 	ehci->async->qh_next.qh = NULL;
-	ehci->async->hw_next = QH_NEXT(ehci->async->qh_dma);
-	ehci->async->hw_info1 = cpu_to_le32(QH_HEAD);
-	ehci->async->hw_token = cpu_to_le32(QTD_STS_HALT);
-	ehci->async->hw_qtd_next = EHCI_LIST_END;
+	ehci->async->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
+	ehci->async->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+	ehci->async->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
+	ehci->async->hw_qtd_next = EHCI_LIST_END(ehci);
 	ehci->async->qh_state = QH_STATE_LINKED;
-	ehci->async->hw_alt_next = QTD_NEXT(ehci->async->dummy->qtd_dma);
+	ehci->async->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);
 
 	/* clear interrupt enables, set irq latency */
 	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)

commit 196705c9bbc03540429b0f7cf9ee35c2f928a534
Author: Stuart_Hayes@Dell.com <Stuart_Hayes@Dell.com>
Date:   Thu May 3 08:58:49 2007 -0700

    USB: EHCI cpufreq fix
    
    EHCI controllers that don't cache enough microframes can get MMF errors
    when CPU frequency changes occur between the start and completion of
    split interrupt transactions, due to delays in reading main memory
    (caused by CPU cache snoop delays).
    
    This patch adds a cpufreq notifier to the EHCI driver that will
    inactivate split interrupt transactions during frequency transitions.
    It was tested on Intel ICH7 and Serverworks/Broadcom HT1000 EHCI
    controllers.
    
    Signed-off-by: Stuart Hayes <stuart_hayes@dell.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 099aff64f536..566badb05b34 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -273,6 +273,58 @@ static void ehci_work(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef CONFIG_CPU_FREQ
+
+#include <linux/cpufreq.h>
+
+static void ehci_cpufreq_pause (struct ehci_hcd *ehci)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+	if (!ehci->cpufreq_changing++)
+		qh_inactivate_split_intr_qhs(ehci);
+	spin_unlock_irqrestore(&ehci->lock, flags);
+}
+
+static void ehci_cpufreq_unpause (struct ehci_hcd *ehci)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+	if (!--ehci->cpufreq_changing)
+		qh_reactivate_split_intr_qhs(ehci);
+	spin_unlock_irqrestore(&ehci->lock, flags);
+}
+
+/*
+ * ehci_cpufreq_notifier is needed to avoid MMF errors that occur when
+ * EHCI controllers that don't cache many uframes get delayed trying to
+ * read main memory during CPU frequency transitions.  This can cause
+ * split interrupt transactions to not be completed in the required uframe.
+ * This has been observed on the Broadcom/ServerWorks HT1000 controller.
+ */
+static int ehci_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+				 void *data)
+{
+	struct ehci_hcd *ehci = container_of(nb, struct ehci_hcd,
+					     cpufreq_transition);
+
+	switch (val) {
+	case CPUFREQ_PRECHANGE:
+		ehci_cpufreq_pause(ehci);
+		break;
+	case CPUFREQ_POSTCHANGE:
+		ehci_cpufreq_unpause(ehci);
+		break;
+	}
+	return 0;
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
 static void ehci_watchdog (unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -404,6 +456,10 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	spin_unlock_irq(&ehci->lock);
 
+#ifdef CONFIG_CPU_FREQ
+	cpufreq_unregister_notifier(&ehci->cpufreq_transition,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+#endif
 	/* let companion controllers work when we aren't */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
@@ -509,6 +565,17 @@ static int ehci_init(struct usb_hcd *hcd)
 	}
 	ehci->command = temp;
 
+#ifdef CONFIG_CPU_FREQ
+	INIT_LIST_HEAD(&ehci->split_intr_qhs);
+	/*
+	 * If the EHCI controller caches enough uframes, this probably
+	 * isn't needed unless there are so many low/full speed devices
+	 * that the controller's can't cache it all.
+	 */
+	ehci->cpufreq_transition.notifier_call = ehci_cpufreq_notifier;
+	cpufreq_register_notifier(&ehci->cpufreq_transition,
+				  CPUFREQ_TRANSITION_NOTIFIER);
+#endif
 	return 0;
 }
 

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c7458f7e56cc..099aff64f536 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -24,7 +24,6 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>

commit 61e8b858abe38c1042135065c59f7d339194b50b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 9 11:52:31 2007 -0400

    EHCI: fix remote wakeup regression in 2.6.21-rc
    
    There is one significant difference between the behavior of root hubs
    (as embodied in host controller hardware) and external hubs: When a
    remote-wakeup signal is received, an external hub sends an interrupt
    message at the _end_ of the resume sequence but a root hub generates
    and interrupt at the _beginning_ of the resume sequence.  The host
    system must poll for the end of the sequence.
    
    When ehci-hcd was converted to interrupt-driven operation instead of
    using polling, the remaining need for this particular poll was
    overlooked.  This patch (as894) fixes the problem.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a74056488234..c7458f7e56cc 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -669,6 +669,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 */
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}
 	}
 

commit 48fda45120a819ca40cadc50144b55bff1c4c78d
Author: Ishizaki Kou <kou.ishizaki@toshiba.co.jp>
Date:   Wed Feb 14 16:04:17 2007 +0900

    USB: ps3: don't call ps3_system_bus_driver_register on other platforms
    
    ps3_system_bus_driver_register is PS3 platform specific function.
    On other platforms, it triggers WARN_ON in kref_get.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Geoff Levand <geoffrey.levand@am.sony.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6bf909e1adf0..a74056488234 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -42,6 +42,9 @@
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/unaligned.h>
+#ifdef CONFIG_PPC_PS3
+#include <asm/firmware.h>
+#endif
 
 
 /*-------------------------------------------------------------------------*/
@@ -968,15 +971,18 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PS3_SYSTEM_BUS_DRIVER
-	retval = ps3_system_bus_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0) {
+	if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
+		retval = ps3_system_bus_driver_register(
+				&PS3_SYSTEM_BUS_DRIVER);
+		if (retval < 0) {
 #ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
+			platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef PCI_DRIVER
-		pci_unregister_driver(&PCI_DRIVER);
+			pci_unregister_driver(&PCI_DRIVER);
 #endif
-		return retval;
+			return retval;
+		}
 	}
 #endif
 
@@ -993,7 +999,8 @@ static void __exit ehci_hcd_cleanup(void)
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_system_bus_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+	if (firmware_has_feature(FW_FEATURE_PS3_LV1))
+		ps3_system_bus_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
 }
 module_exit(ehci_hcd_cleanup);

commit 8903795a5275e0366acf961190c57074ad27f9bb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Feb 13 14:55:27 2007 -0500

    EHCI: turn off remote wakeup during shutdown
    
    This patch (as850b) disables remote wakeup (and everything else!) on
    all EHCI ports when the shutdown() method is called.  If remote wakeup
    is left active then some systems will reboot instead of powering off.
    This fixes Bugzilla #7828.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 185721dba42b..6bf909e1adf0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -299,6 +299,19 @@ static void ehci_watchdog (unsigned long param)
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 
+/* On some systems, leaving remote wakeup enabled prevents system shutdown.
+ * The firmware seems to think that powering off is a wakeup event!
+ * This routine turns off remote wakeup and everything else, on all ports.
+ */
+static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
+{
+	int	port = HCS_N_PORTS(ehci->hcs_params);
+
+	while (port--)
+		ehci_writel(ehci, PORT_RWC_BITS,
+				&ehci->regs->port_status[port]);
+}
+
 /* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
  * This forcibly disables dma and IRQs, helping kexec and other cases
  * where the next system software may expect clean state.
@@ -310,9 +323,13 @@ ehci_shutdown (struct usb_hcd *hcd)
 
 	ehci = hcd_to_ehci (hcd);
 	(void) ehci_halt (ehci);
+	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+
+	/* unblock posted writes */
+	ehci_readl(ehci, &ehci->regs->configured_flag);
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)

commit 1d619f128ba911cd3e6d6ad3475f146eb92f5c27
Author: Marcelo Tosatti <marcelo@kvack.org>
Date:   Sun Jan 21 19:45:59 2007 -0200

    USB: switch ehci-hcd to new polling scheme
    
    Switch ehci-hcd to use the new polling scheme, which reports root
    hub status changes via the interrupt handler, in an asynchronous
    fashion. Doing so disables polling for status changes (whose handler is
    rh_timer_func).
    
    Tested on a Geode GX machine, which is now capable of running at =~ 5
    timer interrupts per second (in the -rt tree), resulting in significant
    power savings.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 92c62911f574..185721dba42b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -501,6 +501,9 @@ static int ehci_run (struct usb_hcd *hcd)
 	u32			temp;
 	u32			hcc_params;
 
+	hcd->uses_new_polling = 1;
+	hcd->poll_rh = 0;
+
 	/* EHCI spec section 4.1 */
 	if ((retval = ehci_reset(ehci)) != 0) {
 		ehci_mem_cleanup(ehci);
@@ -574,7 +577,7 @@ static int ehci_run (struct usb_hcd *hcd)
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			status;
+	u32			status, pcd_status = 0;
 	int			bh;
 
 	spin_lock (&ehci->lock);
@@ -624,6 +627,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+		pcd_status = status;
 
 		/* resume root hub? */
 		if (!(ehci_readl(ehci, &ehci->regs->command) & CMD_RUN))
@@ -670,6 +674,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	if (bh)
 		ehci_work (ehci);
 	spin_unlock (&ehci->lock);
+	if (pcd_status & STS_PCD)
+		usb_hcd_poll_rh_status(hcd);
 	return IRQ_HANDLED;
 }
 

commit 57e06c11372eccf5acebdd4664eb025fee76c561
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 16 11:59:45 2007 -0500

    EHCI: force high-speed devices to run at full speed
    
    This patch (as710) adds a sysfs class-device attribute file named
    "companion" for EHCI controllers.  The file contains a list of port
    numbers that are dedicated to the companion controller; by writing a
    port number to the file the user can force a high-speed device
    attached directly to the computer to run at full speed.  (As far as I
    know it is not possible to do this for a device attached to an
    external hub.)  A port is removed from the file by writing the
    negative of its port number.
    
    Several users have asked for this facility and it seems like a useful
    thing to have.  Every now and then one runs across a device which
    behaves much better at full speed than at high speed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9ec896218feb..92c62911f574 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -388,6 +388,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	/* let companion controllers work when we aren't */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
+	remove_companion_file(ehci);
 	remove_debug_files (ehci);
 
 	/* root hub is shut down separately (first, when possible) */
@@ -563,6 +564,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * since the class device isn't created that early.
 	 */
 	create_debug_files(ehci);
+	create_companion_file(ehci);
 
 	return 0;
 }

commit ad75a41085d80c8ce5e885962c15779935f8267e
Author: Geoff Levand <geoffrey.levand@am.sony.com>
Date:   Mon Jan 15 20:11:47 2007 -0800

    USB: ps3 ehci bus glue
    
    USB EHCI driver bus glue for the PS3 game console.
    
    Signed-off-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 03d567e4d00a..9ec896218feb 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -907,7 +907,13 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
+#ifdef CONFIG_PPC_PS3
+#include "ehci-ps3.c"
+#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_sb_driver
+#endif
+
+#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
+    !defined(PS3_SYSTEM_BUS_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
@@ -932,6 +938,20 @@ static int __init ehci_hcd_init(void)
 #ifdef PLATFORM_DRIVER
 		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
+		return retval;
+	}
+#endif
+
+#ifdef PS3_SYSTEM_BUS_DRIVER
+	retval = ps3_system_bus_driver_register(&PS3_SYSTEM_BUS_DRIVER);
+	if (retval < 0) {
+#ifdef PLATFORM_DRIVER
+		platform_driver_unregister(&PLATFORM_DRIVER);
+#endif
+#ifdef PCI_DRIVER
+		pci_unregister_driver(&PCI_DRIVER);
+#endif
+		return retval;
 	}
 #endif
 
@@ -947,6 +967,9 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
+#ifdef PS3_SYSTEM_BUS_DRIVER
+	ps3_system_bus_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+#endif
 }
 module_exit(ehci_hcd_cleanup);
 

commit 083522d76662cda71328df1f3d75e5a9057c7c9f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Dec 15 06:54:08 2006 +1100

    USB: Implement support for EHCI with big endian MMIO
    
    This patch implements supports for EHCI controllers whose MMIO
    registers are big endian and enables that functionality for
    the Toshiba SCC chip. It does _not_ add support for big endian
    in-memory data structures as this is not needed for that chip
    and I hope it will never be.
    
    The guts of the patch are to convert readl(...) to
    ehci_readl(ehci, ...) and similarly for register writes.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Geoff Levand <geoffrey.levand@am.sony.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 025d33313681..03d567e4d00a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -157,12 +157,13 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
  * before driver shutdown. But it also seems to be caused by bugs in cardbus
  * bridge shutdown:  shutting down the bridge before the devices using it.
  */
-static int handshake (void __iomem *ptr, u32 mask, u32 done, int usec)
+static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
+		      u32 mask, u32 done, int usec)
 {
 	u32	result;
 
 	do {
-		result = readl (ptr);
+		result = ehci_readl(ehci, ptr);
 		if (result == ~(u32)0)		/* card removed */
 			return -ENODEV;
 		result &= mask;
@@ -177,18 +178,19 @@ static int handshake (void __iomem *ptr, u32 mask, u32 done, int usec)
 /* force HC to halt state from unknown (EHCI spec section 2.3) */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
-	u32	temp = readl (&ehci->regs->status);
+	u32	temp = ehci_readl(ehci, &ehci->regs->status);
 
 	/* disable any irqs left enabled by previous code */
-	writel (0, &ehci->regs->intr_enable);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 
 	if ((temp & STS_HALT) != 0)
 		return 0;
 
-	temp = readl (&ehci->regs->command);
+	temp = ehci_readl(ehci, &ehci->regs->command);
 	temp &= ~CMD_RUN;
-	writel (temp, &ehci->regs->command);
-	return handshake (&ehci->regs->status, STS_HALT, STS_HALT, 16 * 125);
+	ehci_writel(ehci, temp, &ehci->regs->command);
+	return handshake (ehci, &ehci->regs->status,
+			  STS_HALT, STS_HALT, 16 * 125);
 }
 
 /* put TDI/ARC silicon into EHCI mode */
@@ -198,23 +200,24 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	u32		tmp;
 
 	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + 0x68);
-	tmp = readl (reg_ptr);
+	tmp = ehci_readl(ehci, reg_ptr);
 	tmp |= 0x3;
-	writel (tmp, reg_ptr);
+	ehci_writel(ehci, tmp, reg_ptr);
 }
 
 /* reset a non-running (STS_HALT == 1) controller */
 static int ehci_reset (struct ehci_hcd *ehci)
 {
 	int	retval;
-	u32	command = readl (&ehci->regs->command);
+	u32	command = ehci_readl(ehci, &ehci->regs->command);
 
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
-	writel (command, &ehci->regs->command);
+	ehci_writel(ehci, command, &ehci->regs->command);
 	ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 	ehci->next_statechange = jiffies;
-	retval = handshake (&ehci->regs->command, CMD_RESET, 0, 250 * 1000);
+	retval = handshake (ehci, &ehci->regs->command,
+			    CMD_RESET, 0, 250 * 1000);
 
 	if (retval)
 		return retval;
@@ -236,21 +239,21 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 #endif
 
 	/* wait for any schedule enables/disables to take effect */
-	temp = readl (&ehci->regs->command) << 10;
+	temp = ehci_readl(ehci, &ehci->regs->command) << 10;
 	temp &= STS_ASS | STS_PSS;
-	if (handshake (&ehci->regs->status, STS_ASS | STS_PSS,
+	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
 				temp, 16 * 125) != 0) {
 		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 		return;
 	}
 
 	/* then disable anything that's still active */
-	temp = readl (&ehci->regs->command);
+	temp = ehci_readl(ehci, &ehci->regs->command);
 	temp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
-	writel (temp, &ehci->regs->command);
+	ehci_writel(ehci, temp, &ehci->regs->command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	if (handshake (&ehci->regs->status, STS_ASS | STS_PSS,
+	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
 				0, 16 * 125) != 0) {
 		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 		return;
@@ -277,11 +280,11 @@ static void ehci_watchdog (unsigned long param)
 
 	/* lost IAA irqs wedge things badly; seen with a vt8235 */
 	if (ehci->reclaim) {
-		u32		status = readl (&ehci->regs->status);
+		u32		status = ehci_readl(ehci, &ehci->regs->status);
 		if (status & STS_IAA) {
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci->stats.lost_iaa);
-			writel (STS_IAA, &ehci->regs->status);
+			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 			ehci->reclaim_ready = 1;
 		}
 	}
@@ -309,7 +312,7 @@ ehci_shutdown (struct usb_hcd *hcd)
 	(void) ehci_halt (ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
-	writel (0, &ehci->regs->configured_flag);
+	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
@@ -379,11 +382,11 @@ static void ehci_stop (struct usb_hcd *hcd)
 		ehci_quiesce (ehci);
 
 	ehci_reset (ehci);
-	writel (0, &ehci->regs->intr_enable);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	spin_unlock_irq(&ehci->lock);
 
 	/* let companion controllers work when we aren't */
-	writel (0, &ehci->regs->configured_flag);
+	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
 	remove_debug_files (ehci);
 
@@ -402,7 +405,8 @@ static void ehci_stop (struct usb_hcd *hcd)
 		ehci->stats.complete, ehci->stats.unlink);
 #endif
 
-	dbg_status (ehci, "ehci_stop completed", readl (&ehci->regs->status));
+	dbg_status (ehci, "ehci_stop completed",
+		    ehci_readl(ehci, &ehci->regs->status));
 }
 
 /* one-time init, only for memory state */
@@ -428,7 +432,7 @@ static int ehci_init(struct usb_hcd *hcd)
 		return retval;
 
 	/* controllers may cache some of the periodic schedule ... */
-	hcc_params = readl(&ehci->caps->hcc_params);
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
 		ehci->i_thresh = 8;
 	else					// N microframes cached
@@ -501,8 +505,8 @@ static int ehci_run (struct usb_hcd *hcd)
 		ehci_mem_cleanup(ehci);
 		return retval;
 	}
-	writel(ehci->periodic_dma, &ehci->regs->frame_list);
-	writel((u32)ehci->async->qh_dma, &ehci->regs->async_next);
+	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
+	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
 
 	/*
 	 * hcc_params controls whether ehci->regs->segment must (!!!)
@@ -516,9 +520,9 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
 	 * host side drivers though.
 	 */
-	hcc_params = readl(&ehci->caps->hcc_params);
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
 	if (HCC_64BIT_ADDR(hcc_params)) {
-		writel(0, &ehci->regs->segment);
+		ehci_writel(ehci, 0, &ehci->regs->segment);
 #if 0
 // this is deeply broken on almost all architectures
 		if (!dma_set_mask(hcd->self.controller, DMA_64BIT_MASK))
@@ -531,7 +535,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	// root hub will detect new devices (why?); NEC doesn't
 	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
 	ehci->command |= CMD_RUN;
-	writel (ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 	dbg_cmd (ehci, "init", ehci->command);
 
 	/*
@@ -541,17 +545,18 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * and there's no companion controller unless maybe for USB OTG.)
 	 */
 	hcd->state = HC_STATE_RUNNING;
-	writel (FLAG_CF, &ehci->regs->configured_flag);
-	readl (&ehci->regs->command);	/* unblock posted writes */
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 
-	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
+	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,
 		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
 		temp >> 8, temp & 0xff, DRIVER_VERSION,
 		ignore_oc ? ", overcurrent ignored" : "");
 
-	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
+	ehci_writel(ehci, INTR_MASK,
+		    &ehci->regs->intr_enable); /* Turn On Interrupts */
 
 	/* GRR this is run-once init(), being done every time the HC starts.
 	 * So long as they're part of class devices, we can't do it init()
@@ -572,7 +577,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	spin_lock (&ehci->lock);
 
-	status = readl (&ehci->regs->status);
+	status = ehci_readl(ehci, &ehci->regs->status);
 
 	/* e.g. cardbus physical eject */
 	if (status == ~(u32) 0) {
@@ -587,8 +592,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	}
 
 	/* clear (just) interrupts */
-	writel (status, &ehci->regs->status);
-	readl (&ehci->regs->command);	/* unblock posted write */
+	ehci_writel(ehci, status, &ehci->regs->status);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted write */
 	bh = 0;
 
 #ifdef	EHCI_VERBOSE_DEBUG
@@ -619,11 +624,12 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 
 		/* resume root hub? */
-		if (!(readl(&ehci->regs->command) & CMD_RUN))
+		if (!(ehci_readl(ehci, &ehci->regs->command) & CMD_RUN))
 			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
-			int pstatus = readl (&ehci->regs->port_status [i]);
+			int pstatus = ehci_readl(ehci,
+						 &ehci->regs->port_status [i]);
 
 			if (pstatus & PORT_OWNER)
 				continue;
@@ -643,14 +649,15 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
 		/* bogus "fatal" IRQs appear on some chips... why?  */
-		status = readl (&ehci->regs->status);
-		dbg_cmd (ehci, "fatal", readl (&ehci->regs->command));
+		status = ehci_readl(ehci, &ehci->regs->status);
+		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
+						   &ehci->regs->command));
 		dbg_status (ehci, "fatal", status);
 		if (status & STS_HALT) {
 			ehci_err (ehci, "fatal error\n");
 dead:
 			ehci_reset (ehci);
-			writel (0, &ehci->regs->configured_flag);
+			ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 			/* generic layer kills/unlinks all urbs, then
 			 * uses ehci_stop to clean up the rest
 			 */
@@ -873,7 +880,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 static int ehci_get_frame (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	return (readl (&ehci->regs->frame_index) >> 3) % ehci->periodic_size;
+	return (ehci_readl(ehci, &ehci->regs->frame_index) >> 3) %
+		ehci->periodic_size;
 }
 
 /*-------------------------------------------------------------------------*/

commit 8c03356a559ced6fa78931f498193f776d67e445
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 9 14:42:16 2006 -0500

    EHCI: Fix root-hub and port suspend/resume problems
    
    This patch (as738b) fixes numerous problems in the controller/root-hub
    suspend/resume/remote-wakeup support in ehci-hcd:
    
            The bus_resume() routine should wake up only the ports that
            were suspended by bus_suspend().  Ports that were already
            suspended should remain that way.
    
            The interrupt mask is used to detect loss of power in the
            bus_resume() routine (if the mask is 0 then power was lost).
            However bus_suspend() always sets the mask to 0.  Instead the
            mask should retain its normal value, with port-change-detect
            interrupts disabled if remote wakeup is turned off.
    
            The interrupt mask should be reset to its correct value at the
            end of bus_resume() regardless of whether power was lost.
    
            bus_resume() reinitializes the operational registers if power
            was lost.  However those registers are not in the aux power
            well, hence they can lose their values whenever the controller
            is put into D3.  They should always be reinitialized.
    
            When a port-change interrupt occurs and the root hub is
            suspended, the interrupt handler should request a root-hub
            resume instead of starting up the controller all by itself.
    
            There's no need for the interrupt handler to request a
            root-hub resume every time a suspended port sends a
            remote-wakeup request.
    
            The pci_resume() method doesn't need to check for connected
            ports when deciding whether or not to reset the controller.
            It can make that decision based on whether Vaux power was
            maintained.
    
            Even when the controller does not need to be reset,
            pci_resume() must undo the effect of pci_suspend() by
            re-enabling the interrupt mask.
    
            If power was lost, pci_resume() must not call ehci_run().
            At this point the root hub is still supposed to be suspended,
            not running.  It's enough to rewrite the command register and
            set the configured_flag.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f2ceb5fdbeb7..025d33313681 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -619,9 +619,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 
 		/* resume root hub? */
-		status = readl (&ehci->regs->command);
-		if (!(status & CMD_RUN))
-			writel (status | CMD_RUN, &ehci->regs->command);
+		if (!(readl(&ehci->regs->command) & CMD_RUN))
+			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
 			int pstatus = readl (&ehci->regs->port_status [i]);
@@ -638,7 +637,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 */
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 

commit 93f1a47c4af34c4ee014b3d2aae70089b3b69f72
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Nov 16 23:34:58 2006 -0800

    USB: add ehci_hcd.ignore_oc parameter
    
    Certain boards seem to like to issue false overcurrent notifications, for
    example on ports that don't have anything connected to them.  This looks
    like a hardware error, at the level of noise to those ports' overcurrent
    input signals (or non-debounced VBUS comparators).  This surfaces to users
    as truly massive amounts of syslog spam from khubd (which is appropriate
    for real hardware problems, except for the volume from multiple ports).
    
    Using this new "ignore_oc" flag helps such systems work more sanely, by
    preventing such indications from getting to khubd (and spam syslog).  The
    downside is of course that true overcurrent errors will be masked; they'll
    appear as spontaneous disconnects, without the diagnostics that will let
    users troubleshoot issues like short circuited cables.
    
    Note that the bulk of these reports seem to be with VIA southbridges, but
    I think some were with Intel ones.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9030994aba98..f2ceb5fdbeb7 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -126,6 +126,11 @@ static unsigned park = 0;
 module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
+/* for flakey hardware, ignore overcurrent indicators */
+static int ignore_oc = 0;
+module_param (ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
+
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
 
 /*-------------------------------------------------------------------------*/
@@ -541,9 +546,10 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x, driver %s\n",
+		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		temp >> 8, temp & 0xff, DRIVER_VERSION);
+		temp >> 8, temp & 0xff, DRIVER_VERSION,
+		ignore_oc ? ", overcurrent ignored" : "");
 
 	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
 

commit 64f89798da35f43c6ef6afda0541e25034513458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 17 13:57:18 2006 -0700

    USB: revert EHCI VIA workaround patch
    
    This reverts 26f953fd884ea4879585287917f855c63c6b2666 which caused
    resume problems on the mac mini.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index aac6ec5dd7cf..9030994aba98 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -111,7 +111,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_MULT_TT	1
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
-#define EHCI_IAA_MSECS		10		/* arbitrary */
+#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
@@ -254,7 +254,6 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
-static void end_unlink_async (struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
@@ -264,37 +263,25 @@ static void ehci_work(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_iaa_watchdog (unsigned long param)
+static void ehci_watchdog (unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
-	u32			status;
 
 	spin_lock_irqsave (&ehci->lock, flags);
-	WARN_ON(!ehci->reclaim);
 
-	/* lost IAA irqs wedge things badly; seen first with a vt8235 */
+	/* lost IAA irqs wedge things badly; seen with a vt8235 */
 	if (ehci->reclaim) {
-		status = readl (&ehci->regs->status);
+		u32		status = readl (&ehci->regs->status);
 		if (status & STS_IAA) {
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci->stats.lost_iaa);
 			writel (STS_IAA, &ehci->regs->status);
-			end_unlink_async (ehci);
+			ehci->reclaim_ready = 1;
 		}
 	}
 
-	spin_unlock_irqrestore (&ehci->lock, flags);
-}
-
-static void ehci_watchdog (unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-
-	/* stop async processing after it's idled a bit */
+ 	/* stop async processing after it's idled a bit */
 	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
 		start_unlink_async (ehci, ehci->async);
 
@@ -345,6 +332,8 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
+	if (ehci->reclaim_ready)
+		end_unlink_async (ehci);
 
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -379,7 +368,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
-	del_timer_sync (&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	if (HC_IS_RUNNING (hcd->state))
@@ -426,10 +414,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
-	init_timer(&ehci->iaa_watchdog);
-	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
-	ehci->iaa_watchdog.data = (unsigned long) ehci;
-
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -446,6 +430,7 @@ static int ehci_init(struct usb_hcd *hcd)
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
+	ehci->reclaim_ready = 0;
 	ehci->next_uframe = -1;
 
 	/*
@@ -619,7 +604,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
 		COUNT (ehci->stats.reclaim);
-		end_unlink_async (ehci);
+		ehci->reclaim_ready = 1;
 		bh = 1;
 	}
 
@@ -723,14 +708,10 @@ static int ehci_urb_enqueue (
 
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	// BUG_ON(qh->qh_state != QH_STATE_LINKED);
-
-	/* failfast */
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		end_unlink_async (ehci);
-
-	/* defer till later if busy */
-	else if (ehci->reclaim) {
+	/* if we need to use IAA and it's busy, defer */
+	if (qh->qh_state == QH_STATE_LINKED
+			&& ehci->reclaim
+			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
 		struct ehci_qh		*last;
 
 		for (last = ehci->reclaim;
@@ -740,8 +721,12 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
 		last->reclaim = qh;
 
-	/* start IAA cycle */
-	} else
+	/* bypass IAA if the hc can't care */
+	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
+		end_unlink_async (ehci);
+
+	/* something else might have unlinked the qh by now */
+	if (qh->qh_state == QH_STATE_LINKED)
 		start_unlink_async (ehci, qh);
 }
 
@@ -763,19 +748,7 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
-		switch (qh->qh_state) {
-		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
-			unlink_async (ehci, qh);
-			break;
-		case QH_STATE_UNLINK:
-		case QH_STATE_UNLINK_WAIT:
-			/* already started */
-			break;
-		case QH_STATE_IDLE:
-			WARN_ON(1);
-			break;
-		}
+		unlink_async (ehci, qh);
 		break;
 
 	case PIPE_INTERRUPT:
@@ -867,7 +840,6 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		unlink_async (ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
-	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
 		spin_unlock_irqrestore (&ehci->lock, flags);
 		schedule_timeout_uninterruptible(1);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5ac918591131..aac6ec5dd7cf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -254,8 +254,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
-static void end_unlink_async (struct ehci_hcd *ehci, struct pt_regs *regs);
-static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
+static void end_unlink_async (struct ehci_hcd *ehci);
+static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
 #include "ehci-mem.c"
@@ -280,7 +280,7 @@ static void ehci_iaa_watchdog (unsigned long param)
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci->stats.lost_iaa);
 			writel (STS_IAA, &ehci->regs->status);
-			end_unlink_async (ehci, NULL);
+			end_unlink_async (ehci);
 		}
 	}
 
@@ -299,7 +299,7 @@ static void ehci_watchdog (unsigned long param)
 		start_unlink_async (ehci, ehci->async);
 
 	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci, NULL);
+	ehci_work (ehci);
 
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
@@ -342,7 +342,7 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
  * ehci_work is called from some interrupts, timers, and so on.
  * it calls driver completion functions, after dropping ehci->lock.
  */
-static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
+static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
 
@@ -353,9 +353,9 @@ static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
 	if (ehci->scanning)
 		return;
 	ehci->scanning = 1;
-	scan_async (ehci, regs);
+	scan_async (ehci);
 	if (ehci->next_uframe != -1)
-		scan_periodic (ehci, regs);
+		scan_periodic (ehci);
 	ehci->scanning = 0;
 
 	/* the IO watchdog guards against hardware or driver bugs that
@@ -397,7 +397,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&ehci->lock);
 	if (ehci->async)
-		ehci_work (ehci, NULL);
+		ehci_work (ehci);
 	spin_unlock_irq (&ehci->lock);
 	ehci_mem_cleanup (ehci);
 
@@ -573,7 +573,7 @@ static int ehci_run (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
+static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			status;
@@ -619,7 +619,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
 		COUNT (ehci->stats.reclaim);
-		end_unlink_async (ehci, regs);
+		end_unlink_async (ehci);
 		bh = 1;
 	}
 
@@ -670,7 +670,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 	}
 
 	if (bh)
-		ehci_work (ehci, regs);
+		ehci_work (ehci);
 	spin_unlock (&ehci->lock);
 	return IRQ_HANDLED;
 }
@@ -727,7 +727,7 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* failfast */
 	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		end_unlink_async (ehci, NULL);
+		end_unlink_async (ehci);
 
 	/* defer till later if busy */
 	else if (ehci->reclaim) {
@@ -787,7 +787,7 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 			intr_deschedule (ehci, qh);
 			/* FALL THROUGH */
 		case QH_STATE_IDLE:
-			qh_completions (ehci, qh, NULL);
+			qh_completions (ehci, qh);
 			break;
 		default:
 			ehci_dbg (ehci, "bogus qh %p state %d\n",

commit 26f953fd884ea4879585287917f855c63c6b2666
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Sep 18 17:03:16 2006 -0700

    USB: EHCI update VIA workaround
    
    This revamps handling of the hardware "async advance" IRQ, and its watchdog
    timer.  Basically it dis-entangles that important timeout from the others,
    simplifying the associated state and code to make it more robust.
    
    This reportedly improves behavior of EHCI on some systems with VIA chips,
    and AFAIK won't affect non-VIA hardware.  VIA systems need this code to
    recover from silcon bugs whereby the "async advance" IRQ isn't issued.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4e1a8c308893..5ac918591131 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -111,7 +111,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_MULT_TT	1
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
-#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
@@ -254,6 +254,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
+static void end_unlink_async (struct ehci_hcd *ehci, struct pt_regs *regs);
 static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
 
 #include "ehci-hub.c"
@@ -263,28 +264,39 @@ static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog (unsigned long param)
+static void ehci_iaa_watchdog (unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
+	u32			status;
 
 	spin_lock_irqsave (&ehci->lock, flags);
+	WARN_ON(!ehci->reclaim);
 
-	/* lost IAA irqs wedge things badly; seen with a vt8235 */
+	/* lost IAA irqs wedge things badly; seen first with a vt8235 */
 	if (ehci->reclaim) {
-		u32		status = readl (&ehci->regs->status);
-
+		status = readl (&ehci->regs->status);
 		if (status & STS_IAA) {
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci->stats.lost_iaa);
 			writel (STS_IAA, &ehci->regs->status);
-			ehci->reclaim_ready = 1;
+			end_unlink_async (ehci, NULL);
 		}
 	}
 
- 	/* stop async processing after it's idled a bit */
+	spin_unlock_irqrestore (&ehci->lock, flags);
+}
+
+static void ehci_watchdog (unsigned long param)
+{
+	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
+	unsigned long		flags;
+
+	spin_lock_irqsave (&ehci->lock, flags);
+
+	/* stop async processing after it's idled a bit */
 	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
- 		start_unlink_async (ehci, ehci->async);
+		start_unlink_async (ehci, ehci->async);
 
 	/* ehci could run by timer, without IRQs ... */
 	ehci_work (ehci, NULL);
@@ -333,8 +345,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci->reclaim_ready)
-		end_unlink_async (ehci, regs);
 
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -369,6 +379,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
+	del_timer_sync (&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	if (HC_IS_RUNNING (hcd->state))
@@ -415,6 +426,10 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
+	init_timer(&ehci->iaa_watchdog);
+	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
+	ehci->iaa_watchdog.data = (unsigned long) ehci;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -431,7 +446,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
-	ehci->reclaim_ready = 0;
 	ehci->next_uframe = -1;
 
 	/*
@@ -605,7 +619,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
 		COUNT (ehci->stats.reclaim);
-		ehci->reclaim_ready = 1;
+		end_unlink_async (ehci, regs);
 		bh = 1;
 	}
 
@@ -709,10 +723,14 @@ static int ehci_urb_enqueue (
 
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* if we need to use IAA and it's busy, defer */
-	if (qh->qh_state == QH_STATE_LINKED
-			&& ehci->reclaim
-			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
+	// BUG_ON(qh->qh_state != QH_STATE_LINKED);
+
+	/* failfast */
+	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
+		end_unlink_async (ehci, NULL);
+
+	/* defer till later if busy */
+	else if (ehci->reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci->reclaim;
@@ -722,12 +740,8 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
 		last->reclaim = qh;
 
-	/* bypass IAA if the hc can't care */
-	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
-		end_unlink_async (ehci, NULL);
-
-	/* something else might have unlinked the qh by now */
-	if (qh->qh_state == QH_STATE_LINKED)
+	/* start IAA cycle */
+	} else
 		start_unlink_async (ehci, qh);
 }
 
@@ -749,7 +763,19 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
-		unlink_async (ehci, qh);
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			unlink_async (ehci, qh);
+			break;
+		case QH_STATE_UNLINK:
+		case QH_STATE_UNLINK_WAIT:
+			/* already started */
+			break;
+		case QH_STATE_IDLE:
+			WARN_ON(1);
+			break;
+		}
 		break;
 
 	case PIPE_INTERRUPT:
@@ -841,6 +867,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		unlink_async (ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
 		spin_unlock_irqrestore (&ehci->lock, flags);
 		schedule_timeout_uninterruptible(1);

commit 53bd6a601a87bb6d0df844872bc15fd4e8d127ce
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 30 14:50:06 2006 -0700

    USB: EHCI whitespace fixes (cosmetic)
    
    [ ... when you have an editor set to remind you of whitespace bugs ... ]
    
    Cosmetic EHCI changes: remove end-of-line whitespace, spaces before tabs.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1c54b303e5fc..4e1a8c308893 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000-2004 by David Brownell
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2 of the License, or (at your
@@ -70,7 +70,7 @@
  * 2002-08-06	Handling for bulk and interrupt transfers is mostly shared;
  *	only scheduling is different, no arbitrary limitations.
  * 2002-07-25	Sanity check PCI reads, mostly for better cardbus support,
- * 	clean up HC run state handshaking.
+ *	clean up HC run state handshaking.
  * 2002-05-24	Preliminary FS/LS interrupts, using scheduling shortcuts
  * 2002-05-11	Clear TT errors for FS/LS ctrl/bulk.  Fill in some other
  *	missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.
@@ -425,7 +425,7 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	/* controllers may cache some of the periodic schedule ... */
 	hcc_params = readl(&ehci->caps->hcc_params);
-	if (HCC_ISOC_CACHE(hcc_params)) 	// full frame cache
+	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
 		ehci->i_thresh = 8;
 	else					// N microframes cached
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);

commit 64a21d025d3a979a8715f2ec7acabca7b5406c8a
Author: Aleksey Gorelov <dared1st@yahoo.com>
Date:   Tue Aug 8 17:24:08 2006 -0700

    USB: Properly unregister reboot notifier in case of failure in ehci hcd
    
    If some problem occurs during ehci startup, for instance, request_irq fails,
    echi hcd driver tries it best to cleanup, but fails to unregister reboot
    notifier, which in turn leads to crash on reboot/poweroff.
    
    The following patch resolves this problem by not using reboot notifiers
    anymore, but instead making ehci/ohci driver get its own shutdown method.  For
    PCI, it is done through pci glue, for everything else through platform driver
    glue.
    
    One downside: sa1111 does not use platform driver stuff, and does not have its
    own shutdown hook, so no 'shutdown' is called for it now.  I'm not sure if it
    is really necessary on that platform, though.
    
    Signed-off-by: Aleks Gorelov <dared1st@yahoo.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d63177a8eaea..1c54b303e5fc 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -292,21 +292,20 @@ static void ehci_watchdog (unsigned long param)
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 
-/* Reboot notifiers kick in for silicon on any bus (not just pci, etc).
+/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
  * This forcibly disables dma and IRQs, helping kexec and other cases
  * where the next system software may expect clean state.
  */
-static int
-ehci_reboot (struct notifier_block *self, unsigned long code, void *null)
+static void
+ehci_shutdown (struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci;
+	struct ehci_hcd	*ehci;
 
-	ehci = container_of (self, struct ehci_hcd, reboot_notifier);
+	ehci = hcd_to_ehci (hcd);
 	(void) ehci_halt (ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
 	writel (0, &ehci->regs->configured_flag);
-	return 0;
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
@@ -381,7 +380,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* let companion controllers work when we aren't */
 	writel (0, &ehci->regs->configured_flag);
-	unregister_reboot_notifier (&ehci->reboot_notifier);
 
 	remove_debug_files (ehci);
 
@@ -483,9 +481,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	}
 	ehci->command = temp;
 
-	ehci->reboot_notifier.notifier_call = ehci_reboot;
-	register_reboot_notifier(&ehci->reboot_notifier);
-
 	return 0;
 }
 
@@ -499,7 +494,6 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	/* EHCI spec section 4.1 */
 	if ((retval = ehci_reset(ehci)) != 0) {
-		unregister_reboot_notifier(&ehci->reboot_notifier);
 		ehci_mem_cleanup(ehci);
 		return retval;
 	}

commit a11570f2a48cbb6e10c520b46193e7b1b4b9245c
Author: Li Yang <leoli@freescale.com>
Date:   Fri Jul 14 19:58:14 2006 +0800

    USB: Fix Freescale high-speed USB host dependency
    
    The high-speed USB SOC only exists on MPC834x family not MPC83xx family.
    
    Signed-off-by: Li Yang <leoli@freescale.com>
    Acked-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 85b0b4ad4c16..d63177a8eaea 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -892,7 +892,7 @@ MODULE_LICENSE ("GPL");
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
-#ifdef CONFIG_PPC_83xx
+#ifdef CONFIG_MPC834x
 #include "ehci-fsl.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif

commit b972b68c396cfa9f8af7e0b314e22705251bc218
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Jun 30 02:34:42 2006 -0700

    [PATCH] USB: ehci: fix bogus alteration of a local variable
    
    In a rare and all-but-unused path, the EHCI driver could reuse a variable
    in a way that'd make trouble.  Specifically, if the first root hub port
    gets an overcurrent event (rare) during a remote wakeup scenario (all but
    unused in today's Linux, except for folk working with suspend-to-RAM and
    similar sleep states), that would look like a fatal error which would shut
    down the controller.  Fix by not reusing that variable.
    
    Spotted by Per Hallsmark <saxofon@musiker.nu>
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=6661
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cee6f538de0a..85b0b4ad4c16 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -625,10 +625,11 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 			writel (status | CMD_RUN, &ehci->regs->command);
 
 		while (i--) {
-			status = readl (&ehci->regs->port_status [i]);
-			if (status & PORT_OWNER)
+			int pstatus = readl (&ehci->regs->port_status [i]);
+
+			if (pstatus & PORT_OWNER)
 				continue;
-			if (!(status & PORT_RESUME)
+			if (!(pstatus & PORT_RESUME)
 					|| ehci->reset_done [i] != 0)
 				continue;
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9b37e508ada3..cee6f538de0a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -16,7 +16,6 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/dmapool.h>

commit dfbaa7d8a4056436b6a170625d64986ebb648486
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Jun 3 23:58:55 2006 +0100

    [PATCH] USB: EHCI on non-Au1200 build fix
    
    Including ehci-au1xxx.c on a non-Au1200 Alchemy only to have it throw
    an error is stupid.
    
    From: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7d7c97cf9b2f..9b37e508ada3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -897,7 +897,7 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
-#ifdef CONFIG_SOC_AU1X00
+#ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif

commit 01cced250722d22d99c2342979490f93ca886521
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Tue Apr 11 10:07:16 2006 -0500

    [PATCH] USB: allow multiple types of EHCI controllers to be built as modules
    
    In some systems we may have both a platform EHCI controller and PCI EHCI
    controller.  Previously we couldn't build the EHCI support as a module due
    to conflicting module_init() calls in the code.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 79f2d8b9bfb6..7d7c97cf9b2f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -889,19 +889,59 @@ MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PCI
 #include "ehci-pci.c"
-#define	EHCI_BUS_GLUED
+#define	PCI_DRIVER		ehci_pci_driver
 #endif
 
 #ifdef CONFIG_PPC_83xx
 #include "ehci-fsl.c"
-#define	EHCI_BUS_GLUED
+#define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
 #ifdef CONFIG_SOC_AU1X00
 #include "ehci-au1xxx.c"
-#define	EHCI_BUS_GLUED
+#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
-#ifndef	EHCI_BUS_GLUED
+#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
+
+static int __init ehci_hcd_init(void)
+{
+	int retval = 0;
+
+	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+		 hcd_name,
+		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
+		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
+
+#ifdef PLATFORM_DRIVER
+	retval = platform_driver_register(&PLATFORM_DRIVER);
+	if (retval < 0)
+		return retval;
+#endif
+
+#ifdef PCI_DRIVER
+	retval = pci_register_driver(&PCI_DRIVER);
+	if (retval < 0) {
+#ifdef PLATFORM_DRIVER
+		platform_driver_unregister(&PLATFORM_DRIVER);
+#endif
+	}
+#endif
+
+	return retval;
+}
+module_init(ehci_hcd_init);
+
+static void __exit ehci_hcd_cleanup(void)
+{
+#ifdef PLATFORM_DRIVER
+	platform_driver_unregister(&PLATFORM_DRIVER);
+#endif
+#ifdef PCI_DRIVER
+	pci_unregister_driver(&PCI_DRIVER);
+#endif
+}
+module_exit(ehci_hcd_cleanup);
+

commit 76fa9a240de4294a097235c9ddd470c21eb3449e
Author: Jordan Crouse <jordan.crouse@amd.com>
Date:   Fri Jan 20 14:06:09 2006 -0800

    [PATCH] USB: EHCI for AU1200
    
    ALCHEMY:  Add EHCI support for AU1200
    
    Updated by removing the OHCI support
    
    Signed-off-by: Jordan Crouse <jordan.crouse@amd.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8730babb5771..79f2d8b9bfb6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -889,14 +889,19 @@ MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PCI
 #include "ehci-pci.c"
+#define	EHCI_BUS_GLUED
 #endif
 
 #ifdef CONFIG_PPC_83xx
 #include "ehci-fsl.c"
+#define	EHCI_BUS_GLUED
 #endif
 
-#if !(defined(CONFIG_PCI) || \
-      defined(CONFIG_PPC_83xx) \
-     )
+#ifdef CONFIG_SOC_AU1X00
+#include "ehci-au1xxx.c"
+#define	EHCI_BUS_GLUED
+#endif
+
+#ifndef	EHCI_BUS_GLUED
 #error "missing bus glue for ehci-hcd"
 #endif

commit 80cb9aee01245b38325dd84f1359b14a3f01f10d
Author: Randy Vinson <rvinson@mvista.com>
Date:   Fri Jan 20 13:53:38 2006 -0800

    [PATCH] USB: EHCI for Freescale 83xx
    
    Adding a Host Mode USB driver for the Freescale 83xx.
    
    This driver supports both the Dual-Role (DR) controller and the
    Multi-Port-Host (MPH) controller present in the Freescale MPC8349. It has
    been tested with the MPC8349CDS reference system. This driver depends on
    platform support code for setting up the pins on the device package in a
    manner appropriate for the board in use. Note that this patch requires
    selecting the EHCI controller option under the USB Host menu.
    
    Signed-off-by: Randy Vinson <rvinson@mvista.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9dd3d14c64f3..8730babb5771 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -891,6 +891,12 @@ MODULE_LICENSE ("GPL");
 #include "ehci-pci.c"
 #endif
 
-#if !defined(CONFIG_PCI)
+#ifdef CONFIG_PPC_83xx
+#include "ehci-fsl.c"
+#endif
+
+#if !(defined(CONFIG_PCI) || \
+      defined(CONFIG_PPC_83xx) \
+     )
 #error "missing bus glue for ehci-hcd"
 #endif

commit c9a50cc9318772e62d56f2a9172bdfda72bdacbe
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Nov 7 20:45:20 2005 -0800

    [PATCH] USB: hcd uses EXTRA_CFLAGS for -DDEBUG
    
    This modifies the HCD builds to automatically "-DDEBUG" if
    CONFIG_USB_DEBUG is selected.  It's just a minor source code cleanup,
    guaranteeing consistency.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b5b57e957e5f..9dd3d14c64f3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -17,13 +17,6 @@
  */
 
 #include <linux/config.h>
-
-#ifdef CONFIG_USB_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
-
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/dmapool.h>

commit d97cc2f2e938547a47daef29bc10ab38600a3310
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Dec 22 17:05:18 2005 -0800

    [PATCH] USB: ehci fix driver model wakeup flags
    
    On some systems, EHCI seems to be getting IRQs too early during driver
    setup ... before the root hub is allocated, in particular, making trouble
    for any code chasing down root hub pointers!  In this case, it seems to
    be safe to just ignore the root hub setting.  Thanks to Rafael J. Wysocki
    for getting this properly tested.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index dd871023265c..b5b57e957e5f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -624,7 +624,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 	}
 
 	/* remote wakeup [4.3.1] */
-	if ((status & STS_PCD) && device_may_wakeup(&hcd->self.root_hub->dev)) {
+	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 
 		/* resume root hub? */

commit 2c1c3c4cd5f796b1912c65aaf3bf48c0ddf11f5e
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Nov 7 15:24:46 2005 -0800

    [PATCH] USB: EHCI updates (4/4) driver model wakeup flags
    
    This teaches the EHCI driver to use the new driver model wakeup flags,
    replacing the similar ones in the HCD glue.  It also adds a workaround
    for the current glitch whereby PCI init doesn't init the wakeup flags
    from the PCI PM capabilities.  (EHCI controllers don't worry about
    legacy mode; the PCI PM capability would always do the job.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 29f52a44b928..dd871023265c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -624,7 +624,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 	}
 
 	/* remote wakeup [4.3.1] */
-	if ((status & STS_PCD) && hcd->remote_wakeup) {
+	if ((status & STS_PCD) && device_may_wakeup(&hcd->self.root_hub->dev)) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 
 		/* resume root hub? */

commit 188075211cc75a31190de4a19a084e3d83ee1c89
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:37 2005 -0800

    [PATCH] USB: EHCI updates split init/reinit logic for resume
    
    Moving the PCI-specific parts of the EHCI driver into their own file
    created a few issues ... notably on resume paths which (like swsusp)
    require re-initializing the controller.  This patch:
    
     - Splits the EHCI startup code into run-once HCD setup code and
       separate "init the hardware" reinit code.  (That reinit code is
       a superset of the "early usb handoff" code.)
    
     - Then it makes the PCI init code run both, and the resume code only
       run the reinit code.
    
     - It also removes needless pci wrappers around EHCI start/stop methods.
    
     - Removes a byteswap issue that would be seen on big-endian hardware.
    
    The HCD glue still doesn't actually provide a good way to do all this
    run-one init stuff in one place though.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f15144e96e14..29f52a44b928 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -411,50 +411,39 @@ static void ehci_stop (struct usb_hcd *hcd)
 	dbg_status (ehci, "ehci_stop completed", readl (&ehci->regs->status));
 }
 
-static int ehci_run (struct usb_hcd *hcd)
+/* one-time init, only for memory state */
+static int ehci_init(struct usb_hcd *hcd)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	u32			temp;
 	int			retval;
 	u32			hcc_params;
-	int			first;
-
-	/* skip some things on restart paths */
-	first = (ehci->watchdog.data == 0);
-	if (first) {
-		init_timer (&ehci->watchdog);
-		ehci->watchdog.function = ehci_watchdog;
-		ehci->watchdog.data = (unsigned long) ehci;
-	}
+
+	spin_lock_init(&ehci->lock);
+
+	init_timer(&ehci->watchdog);
+	ehci->watchdog.function = ehci_watchdog;
+	ehci->watchdog.data = (unsigned long) ehci;
 
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
-	if (first && (retval = ehci_mem_init (ehci, GFP_KERNEL)) < 0)
+	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 
 	/* controllers may cache some of the periodic schedule ... */
-	hcc_params = readl (&ehci->caps->hcc_params);
-	if (HCC_ISOC_CACHE (hcc_params)) 	// full frame cache
+	hcc_params = readl(&ehci->caps->hcc_params);
+	if (HCC_ISOC_CACHE(hcc_params)) 	// full frame cache
 		ehci->i_thresh = 8;
 	else					// N microframes cached
-		ehci->i_thresh = 2 + HCC_ISOC_THRES (hcc_params);
+		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
 	ehci->reclaim_ready = 0;
 	ehci->next_uframe = -1;
 
-	/* controller state:  unknown --> reset */
-
-	/* EHCI spec section 4.1 */
-	if ((retval = ehci_reset (ehci)) != 0) {
-		ehci_mem_cleanup (ehci);
-		return retval;
-	}
-	writel (ehci->periodic_dma, &ehci->regs->frame_list);
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it
@@ -462,37 +451,13 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
 	 * from automatically advancing to the next td after short reads.
 	 */
-	if (first) {
-		ehci->async->qh_next.qh = NULL;
-		ehci->async->hw_next = QH_NEXT (ehci->async->qh_dma);
-		ehci->async->hw_info1 = cpu_to_le32 (QH_HEAD);
-		ehci->async->hw_token = cpu_to_le32 (QTD_STS_HALT);
-		ehci->async->hw_qtd_next = EHCI_LIST_END;
-		ehci->async->qh_state = QH_STATE_LINKED;
-		ehci->async->hw_alt_next = QTD_NEXT (ehci->async->dummy->qtd_dma);
-	}
-	writel ((u32)ehci->async->qh_dma, &ehci->regs->async_next);
-
-	/*
-	 * hcc_params controls whether ehci->regs->segment must (!!!)
-	 * be used; it constrains QH/ITD/SITD and QTD locations.
-	 * pci_pool consistent memory always uses segment zero.
-	 * streaming mappings for I/O buffers, like pci_map_single(),
-	 * can return segments above 4GB, if the device allows.
-	 *
-	 * NOTE:  the dma mask is visible through dma_supported(), so
-	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
-	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
-	 * host side drivers though.
-	 */
-	if (HCC_64BIT_ADDR (hcc_params)) {
-		writel (0, &ehci->regs->segment);
-#if 0
-// this is deeply broken on almost all architectures
-		if (!dma_set_mask (hcd->self.controller, DMA_64BIT_MASK))
-			ehci_info (ehci, "enabled 64bit DMA\n");
-#endif
-	}
+	ehci->async->qh_next.qh = NULL;
+	ehci->async->hw_next = QH_NEXT(ehci->async->qh_dma);
+	ehci->async->hw_info1 = cpu_to_le32(QH_HEAD);
+	ehci->async->hw_token = cpu_to_le32(QTD_STS_HALT);
+	ehci->async->hw_qtd_next = EHCI_LIST_END;
+	ehci->async->qh_state = QH_STATE_LINKED;
+	ehci->async->hw_alt_next = QTD_NEXT(ehci->async->dummy->qtd_dma);
 
 	/* clear interrupt enables, set irq latency */
 	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
@@ -507,13 +472,13 @@ static int ehci_run (struct usb_hcd *hcd)
 		 * make problems:  throughput reduction (!), data errors...
 		 */
 		if (park) {
-			park = min (park, (unsigned) 3);
+			park = min(park, (unsigned) 3);
 			temp |= CMD_PARK;
 			temp |= park << 8;
 		}
-		ehci_info (ehci, "park %d\n", park);
+		ehci_dbg(ehci, "park %d\n", park);
 	}
-	if (HCC_PGM_FRAMELISTLEN (hcc_params)) {
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
 		/* periodic schedule size can be smaller than default */
 		temp &= ~(3 << 2);
 		temp |= (EHCI_TUNE_FLS << 2);
@@ -521,16 +486,63 @@ static int ehci_run (struct usb_hcd *hcd)
 		case 0: ehci->periodic_size = 1024; break;
 		case 1: ehci->periodic_size = 512; break;
 		case 2: ehci->periodic_size = 256; break;
-		default:	BUG ();
+		default:	BUG();
 		}
 	}
+	ehci->command = temp;
+
+	ehci->reboot_notifier.notifier_call = ehci_reboot;
+	register_reboot_notifier(&ehci->reboot_notifier);
+
+	return 0;
+}
+
+/* start HC running; it's halted, ehci_init() has been run (once) */
+static int ehci_run (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	int			retval;
+	u32			temp;
+	u32			hcc_params;
+
+	/* EHCI spec section 4.1 */
+	if ((retval = ehci_reset(ehci)) != 0) {
+		unregister_reboot_notifier(&ehci->reboot_notifier);
+		ehci_mem_cleanup(ehci);
+		return retval;
+	}
+	writel(ehci->periodic_dma, &ehci->regs->frame_list);
+	writel((u32)ehci->async->qh_dma, &ehci->regs->async_next);
+
+	/*
+	 * hcc_params controls whether ehci->regs->segment must (!!!)
+	 * be used; it constrains QH/ITD/SITD and QTD locations.
+	 * pci_pool consistent memory always uses segment zero.
+	 * streaming mappings for I/O buffers, like pci_map_single(),
+	 * can return segments above 4GB, if the device allows.
+	 *
+	 * NOTE:  the dma mask is visible through dma_supported(), so
+	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
+	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
+	 * host side drivers though.
+	 */
+	hcc_params = readl(&ehci->caps->hcc_params);
+	if (HCC_64BIT_ADDR(hcc_params)) {
+		writel(0, &ehci->regs->segment);
+#if 0
+// this is deeply broken on almost all architectures
+		if (!dma_set_mask(hcd->self.controller, DMA_64BIT_MASK))
+			ehci_info(ehci, "enabled 64bit DMA\n");
+#endif
+	}
+
+
 	// Philips, Intel, and maybe others need CMD_RUN before the
 	// root hub will detect new devices (why?); NEC doesn't
-	temp |= CMD_RUN;
-	writel (temp, &ehci->regs->command);
-	dbg_cmd (ehci, "init", temp);
-
-	/* set async sleep time = 10 us ... ? */
+	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
+	ehci->command |= CMD_RUN;
+	writel (ehci->command, &ehci->regs->command);
+	dbg_cmd (ehci, "init", ehci->command);
 
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
@@ -538,26 +550,23 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * involved with the root hub.  (Except where one is integrated,
 	 * and there's no companion controller unless maybe for USB OTG.)
 	 */
-	if (first) {
-		ehci->reboot_notifier.notifier_call = ehci_reboot;
-		register_reboot_notifier (&ehci->reboot_notifier);
-	}
-
 	hcd->state = HC_STATE_RUNNING;
 	writel (FLAG_CF, &ehci->regs->configured_flag);
-	readl (&ehci->regs->command);	/* unblock posted write */
+	readl (&ehci->regs->command);	/* unblock posted writes */
 
 	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x %s, EHCI %x.%02x, driver %s\n",
+		"USB %x.%x started, EHCI %x.%02x, driver %s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		first ? "initialized" : "restarted",
 		temp >> 8, temp & 0xff, DRIVER_VERSION);
 
 	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
 
-	if (first)
-		create_debug_files (ehci);
+	/* GRR this is run-once init(), being done every time the HC starts.
+	 * So long as they're part of class devices, we can't do it init()
+	 * since the class device isn't created that early.
+	 */
+	create_debug_files(ehci);
 
 	return 0;
 }

commit f03c17fc9abe8582d6ad830290b3093fdf1eea61
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Nov 23 15:45:28 2005 -0800

    [PATCH] USB: EHCI updates
    
    This fixes some bugs in EHCI suspend/resume that joined us over the past
    few releases (as usbcore, PCI, pmcore, and other components evolved):
    
      - Removes suspend and resume recursion from the EHCI driver, getting
        rid of the USB_SUSPEND special casing.
    
      - Updates the wakeup mechanism to work again; there's a newish usbcore
        call it needs to use.
    
      - Provide simpler tests for "do we need to restart from scratch", to
        address another case where PCI Vaux was lost.  (In this case it was
        restoring a swsusp snapshot, but there could be others.)
    
    Un-exports a symbol that was temporarily exported.
    
    A notable change from previous version is that this doesn't move
    the spinlock init, so there's still a resume/reinit path bug.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index af3c05eb86fc..f15144e96e14 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -636,9 +636,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
 			 * stop that signaling.
 			 */
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-			mod_timer (&hcd->rh_timer,
-					ehci->reset_done [i] + 1);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 

commit 7ff71d6adf81a43505b7cbaa034e4063d3439182
Author: Matt Porter <mporter@kernel.crashing.org>
Date:   Thu Sep 22 22:31:15 2005 -0700

    [PATCH] EHCI, split out PCI glue
    
    This splits BIOS and PCI specific support out of ehci-hcd.c into
    ehci-pci.c.  It follows the model already used in the OHCI driver
    so support for non-PCI EHCI controllers can be more easily added.
    
    Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/host/ehci-hcd.c |  543 ++++++--------------------------------------
     drivers/usb/host/ehci-pci.c |  414 +++++++++++++++++++++++++++++++++
     drivers/usb/host/ehci.h     |    1
     3 files changed, 492 insertions(+), 466 deletions(-)

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 513fccbb8e43..af3c05eb86fc 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -300,44 +300,6 @@ static void ehci_watchdog (unsigned long param)
 	spin_unlock_irqrestore (&ehci->lock, flags);
 }
 
-#ifdef	CONFIG_PCI
-
-/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
- * off the controller (maybe it can boot from highspeed USB disks).
- */
-static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
-{
-	struct pci_dev *pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
-
-	/* always say Linux will own the hardware */
-	pci_write_config_byte(pdev, where + 3, 1);
-
-	/* maybe wait a while for BIOS to respond */
-	if (cap & (1 << 16)) {
-		int msec = 5000;
-
-		do {
-			msleep(10);
-			msec -= 10;
-			pci_read_config_dword(pdev, where, &cap);
-		} while ((cap & (1 << 16)) && msec);
-		if (cap & (1 << 16)) {
-			ehci_err(ehci, "BIOS handoff failed (%d, %08x)\n",
-				where, cap);
-			// some BIOS versions seem buggy...
-			// return 1;
-			ehci_warn (ehci, "continuing after BIOS bug...\n");
-			/* disable all SMIs, and clear "BIOS owns" flag */
-			pci_write_config_dword(pdev, where + 4, 0);
-			pci_write_config_byte(pdev, where + 2, 0);
-		} else
-			ehci_dbg(ehci, "BIOS handoff succeeded\n");
-	}
-	return 0;
-}
-
-#endif
-
 /* Reboot notifiers kick in for silicon on any bus (not just pci, etc).
  * This forcibly disables dma and IRQs, helping kexec and other cases
  * where the next system software may expect clean state.
@@ -371,156 +333,90 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 	msleep(20);
 }
 
+/*-------------------------------------------------------------------------*/
 
-/* called by khubd or root hub init threads */
+/*
+ * ehci_work is called from some interrupts, timers, and so on.
+ * it calls driver completion functions, after dropping ehci->lock.
+ */
+static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
+{
+	timer_action_done (ehci, TIMER_IO_WATCHDOG);
+	if (ehci->reclaim_ready)
+		end_unlink_async (ehci, regs);
+
+	/* another CPU may drop ehci->lock during a schedule scan while
+	 * it reports urb completions.  this flag guards against bogus
+	 * attempts at re-entrant schedule scanning.
+	 */
+	if (ehci->scanning)
+		return;
+	ehci->scanning = 1;
+	scan_async (ehci, regs);
+	if (ehci->next_uframe != -1)
+		scan_periodic (ehci, regs);
+	ehci->scanning = 0;
+
+	/* the IO watchdog guards against hardware or driver bugs that
+	 * misplace IRQs, and should let us run completely without IRQs.
+	 * such lossage has been observed on both VT6202 and VT8235.
+	 */
+	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
+			(ehci->async->qh_next.ptr != NULL ||
+			 ehci->periodic_sched != 0))
+		timer_action (ehci, TIMER_IO_WATCHDOG);
+}
 
-static int ehci_hc_reset (struct usb_hcd *hcd)
+static void ehci_stop (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			temp;
-	unsigned		count = 256/4;
 
-	spin_lock_init (&ehci->lock);
+	ehci_dbg (ehci, "stop\n");
 
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH (readl (&ehci->caps->hc_capbase));
-	dbg_hcs_params (ehci, "reset");
-	dbg_hcc_params (ehci, "reset");
+	/* Turn off port power on all root hub ports. */
+	ehci_port_power (ehci, 0);
 
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+	/* no more interrupts ... */
+	del_timer_sync (&ehci->watchdog);
 
-#ifdef	CONFIG_PCI
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev	*pdev = to_pci_dev(hcd->self.controller);
+	spin_lock_irq(&ehci->lock);
+	if (HC_IS_RUNNING (hcd->state))
+		ehci_quiesce (ehci);
 
-		switch (pdev->vendor) {
-		case PCI_VENDOR_ID_TDI:
-			if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
-				ehci->is_tdi_rh_tt = 1;
-				tdi_reset (ehci);
-			}
-			break;
-		case PCI_VENDOR_ID_AMD:
-			/* AMD8111 EHCI doesn't work, according to AMD errata */
-			if (pdev->device == 0x7463) {
-				ehci_info (ehci, "ignoring AMD8111 (errata)\n");
-				return -EIO;
-			}
-			break;
-		case PCI_VENDOR_ID_NVIDIA:
-			/* NVidia reports that certain chips don't handle
-			 * QH, ITD, or SITD addresses above 2GB.  (But TD,
-			 * data buffer, and periodic schedule are normal.)
-			 */
-			switch (pdev->device) {
-			case 0x003c:	/* MCP04 */
-			case 0x005b:	/* CK804 */
-			case 0x00d8:	/* CK8 */
-			case 0x00e8:	/* CK8S */
-				if (pci_set_consistent_dma_mask(pdev,
-							DMA_31BIT_MASK) < 0)
-					ehci_warn (ehci, "can't enable NVidia "
-						"workaround for >2GB RAM\n");
-				break;
-			}
-			break;
-		}
+	ehci_reset (ehci);
+	writel (0, &ehci->regs->intr_enable);
+	spin_unlock_irq(&ehci->lock);
 
-		/* optional debug port, normally in the first BAR */
-		temp = pci_find_capability (pdev, 0x0a);
-		if (temp) {
-			pci_read_config_dword(pdev, temp, &temp);
-			temp >>= 16;
-			if ((temp & (3 << 13)) == (1 << 13)) {
-				temp &= 0x1fff;
-				ehci->debug = hcd->regs + temp;
-				temp = readl (&ehci->debug->control);
-				ehci_info (ehci, "debug port %d%s\n",
-					HCS_DEBUG_PORT(ehci->hcs_params),
-					(temp & DBGP_ENABLED)
-						? " IN USE"
-						: "");
-				if (!(temp & DBGP_ENABLED))
-					ehci->debug = NULL;
-			}
-		}
+	/* let companion controllers work when we aren't */
+	writel (0, &ehci->regs->configured_flag);
+	unregister_reboot_notifier (&ehci->reboot_notifier);
 
-		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
-	} else
-		temp = 0;
-
-	/* EHCI 0.96 and later may have "extended capabilities" */
-	while (temp && count--) {
-		u32		cap;
-
-		pci_read_config_dword (to_pci_dev(hcd->self.controller),
-				temp, &cap);
-		ehci_dbg (ehci, "capability %04x at %02x\n", cap, temp);
-		switch (cap & 0xff) {
-		case 1:			/* BIOS/SMM/... handoff */
-			if (bios_handoff (ehci, temp, cap) != 0)
-				return -EOPNOTSUPP;
-			break;
-		case 0:			/* illegal reserved capability */
-			ehci_warn (ehci, "illegal capability!\n");
-			cap = 0;
-			/* FALLTHROUGH */
-		default:		/* unknown */
-			break;
-		}
-		temp = (cap >> 8) & 0xff;
-	}
-	if (!count) {
-		ehci_err (ehci, "bogus capabilities ... PCI problems!\n");
-		return -EIO;
-	}
-	if (ehci_is_TDI(ehci))
-		ehci_reset (ehci);
-#endif
+	remove_debug_files (ehci);
 
-	ehci_port_power (ehci, 0);
+	/* root hub is shut down separately (first, when possible) */
+	spin_lock_irq (&ehci->lock);
+	if (ehci->async)
+		ehci_work (ehci, NULL);
+	spin_unlock_irq (&ehci->lock);
+	ehci_mem_cleanup (ehci);
 
-	/* at least the Genesys GL880S needs fixup here */
-	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
-	temp &= 0x0f;
-	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
-		ehci_dbg (ehci, "bogus port configuration: "
-			"cc=%d x pcc=%d < ports=%d\n",
-			HCS_N_CC(ehci->hcs_params),
-			HCS_N_PCC(ehci->hcs_params),
-			HCS_N_PORTS(ehci->hcs_params));
-
-#ifdef	CONFIG_PCI
-		if (hcd->self.controller->bus == &pci_bus_type) {
-			struct pci_dev	*pdev;
-
-			pdev = to_pci_dev(hcd->self.controller);
-			switch (pdev->vendor) {
-			case 0x17a0:		/* GENESYS */
-				/* GL880S: should be PORTS=2 */
-				temp |= (ehci->hcs_params & ~0xf);
-				ehci->hcs_params = temp;
-				break;
-			case PCI_VENDOR_ID_NVIDIA:
-				/* NF4: should be PCC=10 */
-				break;
-			}
-		}
+#ifdef	EHCI_STATS
+	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
+		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
+		ehci->stats.lost_iaa);
+	ehci_dbg (ehci, "complete %ld unlink %ld\n",
+		ehci->stats.complete, ehci->stats.unlink);
 #endif
-	}
 
-	/* force HC to halt state */
-	return ehci_halt (ehci);
+	dbg_status (ehci, "ehci_stop completed", readl (&ehci->regs->status));
 }
 
-static int ehci_start (struct usb_hcd *hcd)
+static int ehci_run (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
 	int			retval;
 	u32			hcc_params;
-	u8                      sbrn = 0;
 	int			first;
 
 	/* skip some things on restart paths */
@@ -559,27 +455,6 @@ static int ehci_start (struct usb_hcd *hcd)
 	}
 	writel (ehci->periodic_dma, &ehci->regs->frame_list);
 
-#ifdef	CONFIG_PCI
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev		*pdev;
-		u16			port_wake;
-
-		pdev = to_pci_dev(hcd->self.controller);
-
-		/* Serial Bus Release Number is at PCI 0x60 offset */
-		pci_read_config_byte(pdev, 0x60, &sbrn);
-
-		/* port wake capability, reported by boot firmware */
-		pci_read_config_word(pdev, 0x62, &port_wake);
-		hcd->can_wakeup = (port_wake & 1) != 0;
-
-		/* help hc dma work well with cachelines */
-		retval = pci_set_mwi(pdev);
-		if (retval)
-			ehci_dbg(ehci, "unable to enable MWI - not fatal.\n");
-	}
-#endif
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it
@@ -675,7 +550,7 @@ static int ehci_start (struct usb_hcd *hcd)
 	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
 	ehci_info (ehci,
 		"USB %x.%x %s, EHCI %x.%02x, driver %s\n",
-		((sbrn & 0xf0)>>4), (sbrn & 0x0f),
+		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
 		first ? "initialized" : "restarted",
 		temp >> 8, temp & 0xff, DRIVER_VERSION);
 
@@ -687,188 +562,6 @@ static int ehci_start (struct usb_hcd *hcd)
 	return 0;
 }
 
-/* always called by thread; normally rmmod */
-
-static void ehci_stop (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-
-	ehci_dbg (ehci, "stop\n");
-
-	/* Turn off port power on all root hub ports. */
-	ehci_port_power (ehci, 0);
-
-	/* no more interrupts ... */
-	del_timer_sync (&ehci->watchdog);
-
-	spin_lock_irq(&ehci->lock);
-	if (HC_IS_RUNNING (hcd->state))
-		ehci_quiesce (ehci);
-
-	ehci_reset (ehci);
-	writel (0, &ehci->regs->intr_enable);
-	spin_unlock_irq(&ehci->lock);
-
-	/* let companion controllers work when we aren't */
-	writel (0, &ehci->regs->configured_flag);
-	unregister_reboot_notifier (&ehci->reboot_notifier);
-
-	remove_debug_files (ehci);
-
-	/* root hub is shut down separately (first, when possible) */
-	spin_lock_irq (&ehci->lock);
-	if (ehci->async)
-		ehci_work (ehci, NULL);
-	spin_unlock_irq (&ehci->lock);
-	ehci_mem_cleanup (ehci);
-
-#ifdef	EHCI_STATS
-	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
-		ehci->stats.lost_iaa);
-	ehci_dbg (ehci, "complete %ld unlink %ld\n",
-		ehci->stats.complete, ehci->stats.unlink);
-#endif
-
-	dbg_status (ehci, "ehci_stop completed", readl (&ehci->regs->status));
-}
-
-static int ehci_get_frame (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	return (readl (&ehci->regs->frame_index) >> 3) % ehci->periodic_size;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_PM
-
-/* suspend/resume, section 4.3 */
-
-/* These routines rely on the bus (pci, platform, etc)
- * to handle powerdown and wakeup, and currently also on
- * transceivers that don't need any software attention to set up
- * the right sort of wakeup.  
- */
-
-static int ehci_suspend (struct usb_hcd *hcd, pm_message_t message)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
-
-#ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub);
-#else
-	usb_lock_device (hcd->self.root_hub);
-	(void) ehci_hub_suspend (hcd);
-	usb_unlock_device (hcd->self.root_hub);
-#endif
-
-	// save (PCI) FLADJ in case of Vaux power loss
-	// ... we'd only use it to handle clock skew
-
-	return 0;
-}
-
-static int ehci_resume (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	unsigned		port;
-	struct usb_device	*root = hcd->self.root_hub;
-	int			retval = -EINVAL;
-
-	// maybe restore (PCI) FLADJ
-
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep (100);
-
-	/* If any port is suspended (or owned by the companion),
-	 * we know we can/must resume the HC (and mustn't reset it).
-	 */
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
-		u32	status;
-		port--;
-		status = readl (&ehci->regs->port_status [port]);
-		if (!(status & PORT_POWER))
-			continue;
-		if (status & (PORT_SUSPEND | PORT_OWNER)) {
-			down (&hcd->self.root_hub->serialize);
-			retval = ehci_hub_resume (hcd);
-			up (&hcd->self.root_hub->serialize);
-			break;
-		}
-		if (!root->children [port])
-			continue;
-		dbg_port (ehci, __FUNCTION__, port + 1, status);
-		usb_set_device_state (root->children[port],
-					USB_STATE_NOTATTACHED);
-	}
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having activated BIOS during reboot.
-	 */
-	if (port == 0) {
-		(void) ehci_halt (ehci);
-		(void) ehci_reset (ehci);
-		(void) ehci_hc_reset (hcd);
-
-		/* emptying the schedule aborts any urbs */
-		spin_lock_irq (&ehci->lock);
-		if (ehci->reclaim)
-			ehci->reclaim_ready = 1;
-		ehci_work (ehci, NULL);
-		spin_unlock_irq (&ehci->lock);
-
-		/* restart; khubd will disconnect devices */
-		retval = ehci_start (hcd);
-
-		/* here we "know" root ports should always stay powered;
-		 * but some controllers may lose all power.
-		 */
-		ehci_port_power (ehci, 1);
-	}
-
-	return retval;
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * ehci_work is called from some interrupts, timers, and so on.
- * it calls driver completion functions, after dropping ehci->lock.
- */
-static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
-{
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci->reclaim_ready)
-		end_unlink_async (ehci, regs);
-
-	/* another CPU may drop ehci->lock during a schedule scan while
-	 * it reports urb completions.  this flag guards against bogus
-	 * attempts at re-entrant schedule scanning.
-	 */
-	if (ehci->scanning)
-		return;
-	ehci->scanning = 1;
-	scan_async (ehci, regs);
-	if (ehci->next_uframe != -1)
-		scan_periodic (ehci, regs);
-	ehci->scanning = 0;
-
-	/* the IO watchdog guards against hardware or driver bugs that
-	 * misplace IRQs, and should let us run completely without IRQs.
-	 * such lossage has been observed on both VT6202 and VT8235. 
-	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
-			(ehci->async->qh_next.ptr != NULL ||
-			 ehci->periodic_sched != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
-}
-
 /*-------------------------------------------------------------------------*/
 
 static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
@@ -1179,106 +872,24 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	return;
 }
 
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ehci_driver = {
-	.description =		hcd_name,
-	.product_desc =		"EHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		ehci_hc_reset,
-	.start =		ehci_start,
-#ifdef	CONFIG_PM
-	.suspend =		ehci_suspend,
-	.resume =		ehci_resume,
-#endif
-	.stop =			ehci_stop,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ehci_urb_enqueue,
-	.urb_dequeue =		ehci_urb_dequeue,
-	.endpoint_disable =	ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ehci_hub_status_data,
-	.hub_control =		ehci_hub_control,
-	.hub_suspend =		ehci_hub_suspend,
-	.hub_resume =		ehci_hub_resume,
-};
+static int ehci_get_frame (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	return (readl (&ehci->regs->frame_index) >> 3) % ehci->periodic_size;
+}
 
 /*-------------------------------------------------------------------------*/
 
-/* EHCI 1.0 doesn't require PCI */
-
-#ifdef	CONFIG_PCI
-
-/* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id pci_ids [] = { {
-	/* handle any USB 2.0 EHCI controller */
-	PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x20), ~0),
-	.driver_data =	(unsigned long) &ehci_driver,
-	},
-	{ /* end: all zeroes */ }
-};
-MODULE_DEVICE_TABLE (pci, pci_ids);
-
-/* pci driver glue; this is a "new style" PCI driver module */
-static struct pci_driver ehci_pci_driver = {
-	.name =		(char *) hcd_name,
-	.id_table =	pci_ids,
-
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
-#endif
-};
-
-#endif	/* PCI */
-
-
 #define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
 
 MODULE_DESCRIPTION (DRIVER_INFO);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-static int __init init (void) 
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	pr_debug ("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
-		hcd_name,
-		sizeof (struct ehci_qh), sizeof (struct ehci_qtd),
-		sizeof (struct ehci_itd), sizeof (struct ehci_sitd));
-
-	return pci_register_driver (&ehci_pci_driver);
-}
-module_init (init);
+#ifdef CONFIG_PCI
+#include "ehci-pci.c"
+#endif
 
-static void __exit cleanup (void) 
-{	
-	pci_unregister_driver (&ehci_pci_driver);
-}
-module_exit (cleanup);
+#if !defined(CONFIG_PCI)
+#error "missing bus glue for ehci-hcd"
+#endif

commit 390a8c345e6415cbf811232feedac70b56c9fc8d
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:57:27 2005 -0700

    [PATCH] remove usb_suspend_device() parameter
    
    This patch removes the extra usb_suspend_device() parameter.  The original
    reason to pass that parameter was so that this routine could suspend any
    active children.  A previous patch removed that functionality ... leaving
    no reason to pass the parameter.  A close analogy is pci_set_power_state,
    which doesn't need a pm_message_t either.
    
    On the internal code path that comes through the driver model, the parameter
    is now used to distinguish cases where USB devices need to "freeze" but not
    suspend.   It also checks for an error case that's accessible through sysfs:
    attempting to suspend a device before its interfaces (or for hubs, ports).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c         |   34 +++++++++++++++++++++-------------
     drivers/usb/core/usb.c         |   23 +++++++++++++++++++++--
     drivers/usb/host/ehci-hcd.c    |    2 +-
     drivers/usb/host/isp116x-hcd.c |    2 +-
     drivers/usb/host/ohci-pci.c    |    2 +-
     include/linux/usb.h            |    2 +-
     6 files changed, 46 insertions(+), 19 deletions(-)

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b3eb02613bff..513fccbb8e43 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -759,7 +759,7 @@ static int ehci_suspend (struct usb_hcd *hcd, pm_message_t message)
 		msleep (100);
 
 #ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, message);
+	(void) usb_suspend_device (hcd->self.root_hub);
 #else
 	usb_lock_device (hcd->self.root_hub);
 	(void) ehci_hub_suspend (hcd);

commit 72f30b6f2f5f68dd426e9fe83817b882c2d04e50
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 27 10:19:39 2005 -0700

    [PATCH] USB: ehci.patch (earlier irq disable)
    
    This tweaks the EHCI reboot notifier to also halt the EHCI controller, and
    makes that halt code force IRQs off.  Both should always have been done.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/host/ehci-hcd.c |    8 ++++++++
     1 file changed, 8 insertions(+)

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f5eb9e7b5b18..b3eb02613bff 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -182,6 +182,9 @@ static int ehci_halt (struct ehci_hcd *ehci)
 {
 	u32	temp = readl (&ehci->regs->status);
 
+	/* disable any irqs left enabled by previous code */
+	writel (0, &ehci->regs->intr_enable);
+
 	if ((temp & STS_HALT) != 0)
 		return 0;
 
@@ -335,12 +338,17 @@ static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
 
 #endif
 
+/* Reboot notifiers kick in for silicon on any bus (not just pci, etc).
+ * This forcibly disables dma and IRQs, helping kexec and other cases
+ * where the next system software may expect clean state.
+ */
 static int
 ehci_reboot (struct notifier_block *self, unsigned long code, void *null)
 {
 	struct ehci_hcd		*ehci;
 
 	ehci = container_of (self, struct ehci_hcd, reboot_notifier);
+	(void) ehci_halt (ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
 	writel (0, &ehci->regs->configured_flag);

commit 55016f10e31bb15b85d8c500f979dfdceb37d548
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:21:58 2005 -0400

    [PATCH] gfp_t: drivers/usb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b948ffd94f45..f5eb9e7b5b18 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -983,7 +983,7 @@ static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
 	struct usb_host_endpoint *ep,
 	struct urb	*urb,
-	unsigned	mem_flags
+	gfp_t		mem_flags
 ) {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct list_head	qtd_list;

commit 22c438632850c0d6257b45c90afed0cea6953afc
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Aug 15 11:30:11 2005 -0700

    [PATCH] drivers/usb: fix-up schedule_timeout() usage
    
    Description: Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ae5ba4ddfb40..b948ffd94f45 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1147,8 +1147,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 idle_timeout:
 		spin_unlock_irqrestore (&ehci->lock, flags);
-		set_current_state (TASK_UNINTERRUPTIBLE);
-		schedule_timeout (1);
+		schedule_timeout_uninterruptible(1);
 		goto rescan;
 	case QH_STATE_IDLE:		/* fully unlinked */
 		if (list_empty (&qh->qtd_list)) {

commit f7201c3dcd7799f2aa3d6ec427b194225360ecee
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Sep 2 18:58:09 2005 -0700

    [PATCH] USB: EHCI workaround for NForce and mem > 2GB
    
    NVidia reports (via Mark Overby) that some of their EHCI controllers
    don't like certain data structure addresses beyond the 2GB mark.
    He provided an earlier version of this patch.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2f7037c62e88..ae5ba4ddfb40 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -400,6 +400,23 @@ static int ehci_hc_reset (struct usb_hcd *hcd)
 				return -EIO;
 			}
 			break;
+		case PCI_VENDOR_ID_NVIDIA:
+			/* NVidia reports that certain chips don't handle
+			 * QH, ITD, or SITD addresses above 2GB.  (But TD,
+			 * data buffer, and periodic schedule are normal.)
+			 */
+			switch (pdev->device) {
+			case 0x003c:	/* MCP04 */
+			case 0x005b:	/* CK804 */
+			case 0x00d8:	/* CK8 */
+			case 0x00e8:	/* CK8S */
+				if (pci_set_consistent_dma_mask(pdev,
+							DMA_31BIT_MASK) < 0)
+					ehci_warn (ehci, "can't enable NVidia "
+						"workaround for >2GB RAM\n");
+				break;
+			}
+			break;
 		}
 
 		/* optional debug port, normally in the first BAR */

commit 10f6524a8ef1413a8cbd952673997013183fe2a9
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 31 10:55:38 2005 -0700

    [PATCH] USB: EHCI port tweaks
    
    One change may improve some S1 or S3 resume cases, and the other
    seems mostly to explain some strange state "lsusb" would show.
    Two fixes:
    
      - On resume, don't think about resuming any unpowered port, or
        resetting any port with OWNER set to the OHCI/UHCI companion.
        This will make some S1 and S3 resume scenarios work better.
    
      - PORT_CSC was not being cleared correctly in ehci_hub_status_data.
        This was visible at least through current versions of "lsusb",
        and might have caused some other hub related strangeness.
    
        The fix addresses all three write-to-clear bits, using the same
        approach that UHCI happens to use:  a mask of bits that are
        cleared in most writes to that port status register.
    
    Original patch seems to have been from from William.Morrow@amd.com
    and this version (from David) finishes the write-to-clear changes.
    
    Signed-off-by: Jordan Crouse <jordan.crouse@amd.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2507e898af09..2f7037c62e88 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -759,12 +759,16 @@ static int ehci_resume (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci->next_statechange))
 		msleep (100);
 
-	/* If any port is suspended, we know we can/must resume the HC. */
+	/* If any port is suspended (or owned by the companion),
+	 * we know we can/must resume the HC (and mustn't reset it).
+	 */
 	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
 		u32	status;
 		port--;
 		status = readl (&ehci->regs->port_status [port]);
-		if (status & PORT_SUSPEND) {
+		if (!(status & PORT_POWER))
+			continue;
+		if (status & (PORT_SUSPEND | PORT_OWNER)) {
 			down (&hcd->self.root_hub->serialize);
 			retval = ehci_hub_resume (hcd);
 			up (&hcd->self.root_hub->serialize);

commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 28 11:37:33 2005 -0700

    [PATCH] PCI: start paying attention to a lot of pci function return values
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 149b13fc0a71..2507e898af09 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -549,7 +549,9 @@ static int ehci_start (struct usb_hcd *hcd)
 		hcd->can_wakeup = (port_wake & 1) != 0;
 
 		/* help hc dma work well with cachelines */
-		pci_set_mwi (pdev);
+		retval = pci_set_mwi(pdev);
+		if (retval)
+			ehci_dbg(ehci, "unable to enable MWI - not fatal.\n");
 	}
 #endif
 

commit 5db539e49fc7471e23bf3c94ca304f008cb7b7f3
Author: Olav Kongas <ok@artecdesign.ee>
Date:   Thu Jun 23 20:25:36 2005 +0300

    [PATCH] USB: Fix kmalloc's flags type in USB
    
    Greg,
    
    This patch fixes the kmalloc() flags argument type in USB
    subsystem; hopefully all of its occurences. The patch was
    made against patch-2.6.12-git2 from Jun 20.
    
    Cleanup of flags for kmalloc() in USB subsystem.
    
    Signed-off-by: Olav Kongas <ok@artecdesign.ee>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 35248a37b717..149b13fc0a71 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -960,7 +960,7 @@ static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
 	struct usb_host_endpoint *ep,
 	struct urb	*urb,
-	int		mem_flags
+	unsigned	mem_flags
 ) {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct list_head	qtd_list;

commit d49d431744007cec0ee1a3ade96f9e0f100c7907
Author: David Brownell <david-b@pacbell.net>
Date:   Sat May 7 13:21:50 2005 -0700

    [PATCH] USB: misc ehci updates
    
    Various minor EHCI updates
    
       * Dump some more info in the debug dumps, notably the product
         description (e.g. chip vendor), BIOS handhake flags, and
         debug port status (when it's not managed by the HCD).
    
       * Minor updates to the BIOS handoff code:  always flag the HCD
         as owned by Linux (in case BIOS doesn't grab it "early"),
         and on the buggy-BIOS path always match the "early handoff"
         code and forcibly disable SMI IRQs.
    
       * For the disabled 64bit DMA support, there's now a constant
         to use for the mask; use it.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 527abc693b17..35248a37b717 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -304,30 +304,31 @@ static void ehci_watchdog (unsigned long param)
  */
 static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
 {
+	struct pci_dev *pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
+
+	/* always say Linux will own the hardware */
+	pci_write_config_byte(pdev, where + 3, 1);
+
+	/* maybe wait a while for BIOS to respond */
 	if (cap & (1 << 16)) {
 		int msec = 5000;
-		struct pci_dev *pdev =
-				to_pci_dev(ehci_to_hcd(ehci)->self.controller);
 
-		/* request handoff to OS */
-		cap |= 1 << 24;
-		pci_write_config_dword(pdev, where, cap);
-
-		/* and wait a while for it to happen */
 		do {
 			msleep(10);
 			msec -= 10;
 			pci_read_config_dword(pdev, where, &cap);
 		} while ((cap & (1 << 16)) && msec);
 		if (cap & (1 << 16)) {
-			ehci_err (ehci, "BIOS handoff failed (%d, %04x)\n",
+			ehci_err(ehci, "BIOS handoff failed (%d, %08x)\n",
 				where, cap);
 			// some BIOS versions seem buggy...
 			// return 1;
 			ehci_warn (ehci, "continuing after BIOS bug...\n");
-			return 0;
-		} 
-		ehci_dbg (ehci, "BIOS handoff succeeded\n");
+			/* disable all SMIs, and clear "BIOS owns" flag */
+			pci_write_config_dword(pdev, where + 4, 0);
+			pci_write_config_byte(pdev, where + 2, 0);
+		} else
+			ehci_dbg(ehci, "BIOS handoff succeeded\n");
 	}
 	return 0;
 }
@@ -586,8 +587,8 @@ static int ehci_start (struct usb_hcd *hcd)
 		writel (0, &ehci->regs->segment);
 #if 0
 // this is deeply broken on almost all architectures
-		if (!pci_set_dma_mask (to_pci_dev(hcd->self.controller), 0xffffffffffffffffULL))
-			ehci_info (ehci, "enabled 64bit PCI DMA\n");
+		if (!dma_set_mask (hcd->self.controller, DMA_64BIT_MASK))
+			ehci_info (ehci, "enabled 64bit DMA\n");
 #endif
 	}
 

commit 247f3105636caa9d1d8a4c3dfb755de42633bc80
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 25 11:28:04 2005 -0400

    [PATCH] USB HCDs: no longer need to register root hub
    
    This patch changes the host controller drivers; they no longer need to
    register their root hubs because usbcore will take care of it for them.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bc69bd7acebe..527abc693b17 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -492,8 +492,6 @@ static int ehci_start (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
-	struct usb_device	*udev;
-	struct usb_bus		*bus;
 	int			retval;
 	u32			hcc_params;
 	u8                      sbrn = 0;
@@ -631,17 +629,6 @@ static int ehci_start (struct usb_hcd *hcd)
 
 	/* set async sleep time = 10 us ... ? */
 
-	/* wire up the root hub */
-	bus = hcd_to_bus (hcd);
-	udev = first ? usb_alloc_dev (NULL, bus, 0) : bus->root_hub;
-	if (!udev) {
-done2:
-		ehci_mem_cleanup (ehci);
-		return -ENOMEM;
-	}
-	udev->speed = USB_SPEED_HIGH;
-	udev->state = first ? USB_STATE_ATTACHED : USB_STATE_CONFIGURED;
-
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
 	 * are explicitly handed to companion controller(s), so no TT is
@@ -664,24 +651,6 @@ static int ehci_start (struct usb_hcd *hcd)
 		first ? "initialized" : "restarted",
 		temp >> 8, temp & 0xff, DRIVER_VERSION);
 
-	/*
-	 * From here on, khubd concurrently accesses the root
-	 * hub; drivers will be talking to enumerated devices.
-	 * (On restart paths, khubd already knows about the root
-	 * hub and could find work as soon as we wrote FLAG_CF.)
-	 *
-	 * Before this point the HC was idle/ready.  After, khubd
-	 * and device drivers may start it running.
-	 */
-	if (first && usb_hcd_register_root_hub (udev, hcd) != 0) {
-		if (hcd->state == HC_STATE_RUNNING)
-			ehci_quiesce (ehci);
-		ehci_reset (ehci);
-		usb_put_dev (udev); 
-		retval = -ENODEV;
-		goto done2;
-	}
-
 	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
 
 	if (first)

commit 56c1e26d75008d39f1067f453719857a81109d9f
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Apr 9 09:00:29 2005 -0700

    [PATCH] USB: ehci power fixes
    
    Miscellaneous updates for EHCI.
    
     - Mostly updates the power switching on EHCI controllers.  One routine
       centralizes the "power on/off all ports" logic, and the capability to
       do that is reported more correctly.
    
     - Courtesy Colin Leroy, a patch to always power up ports after resumes
       which didn't keep a USB device suspended.  The reset-everything logic
       powers down those ports (on some hardware) so something needs to turn
       them back on.
    
     - Minor tweaks/bugfixes for the debug port support.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 84d2b93aca37..bc69bd7acebe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -346,6 +346,22 @@ ehci_reboot (struct notifier_block *self, unsigned long code, void *null)
 	return 0;
 }
 
+static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
+{
+	unsigned port;
+
+	if (!HCS_PPC (ehci->hcs_params))
+		return;
+
+	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
+		(void) ehci_hub_control(ehci_to_hcd(ehci),
+				is_on ? SetPortFeature : ClearPortFeature,
+				USB_PORT_FEAT_POWER,
+				port--, NULL, 0);
+	msleep(20);
+}
+
 
 /* called by khubd or root hub init threads */
 
@@ -362,8 +378,10 @@ static int ehci_hc_reset (struct usb_hcd *hcd)
 	dbg_hcs_params (ehci, "reset");
 	dbg_hcc_params (ehci, "reset");
 
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+
 #ifdef	CONFIG_PCI
-	/* EHCI 0.96 and later may have "extended capabilities" */
 	if (hcd->self.controller->bus == &pci_bus_type) {
 		struct pci_dev	*pdev = to_pci_dev(hcd->self.controller);
 
@@ -383,9 +401,30 @@ static int ehci_hc_reset (struct usb_hcd *hcd)
 			break;
 		}
 
+		/* optional debug port, normally in the first BAR */
+		temp = pci_find_capability (pdev, 0x0a);
+		if (temp) {
+			pci_read_config_dword(pdev, temp, &temp);
+			temp >>= 16;
+			if ((temp & (3 << 13)) == (1 << 13)) {
+				temp &= 0x1fff;
+				ehci->debug = hcd->regs + temp;
+				temp = readl (&ehci->debug->control);
+				ehci_info (ehci, "debug port %d%s\n",
+					HCS_DEBUG_PORT(ehci->hcs_params),
+					(temp & DBGP_ENABLED)
+						? " IN USE"
+						: "");
+				if (!(temp & DBGP_ENABLED))
+					ehci->debug = NULL;
+			}
+		}
+
 		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
 	} else
 		temp = 0;
+
+	/* EHCI 0.96 and later may have "extended capabilities" */
 	while (temp && count--) {
 		u32		cap;
 
@@ -414,8 +453,7 @@ static int ehci_hc_reset (struct usb_hcd *hcd)
 		ehci_reset (ehci);
 #endif
 
-	/* cache this readonly data; minimize PCI reads */
-	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+	ehci_port_power (ehci, 0);
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
@@ -657,16 +695,11 @@ static int ehci_start (struct usb_hcd *hcd)
 static void ehci_stop (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u8			rh_ports, port;
 
 	ehci_dbg (ehci, "stop\n");
 
 	/* Turn off port power on all root hub ports. */
-	rh_ports = HCS_N_PORTS (ehci->hcs_params);
-	for (port = 1; port <= rh_ports; port++)
-		(void) ehci_hub_control(hcd,
-			ClearPortFeature, USB_PORT_FEAT_POWER,
-			port, NULL, 0);
+	ehci_port_power (ehci, 0);
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
@@ -748,7 +781,6 @@ static int ehci_resume (struct usb_hcd *hcd)
 	unsigned		port;
 	struct usb_device	*root = hcd->self.root_hub;
 	int			retval = -EINVAL;
-	int			powerup = 0;
 
 	// maybe restore (PCI) FLADJ
 
@@ -766,8 +798,6 @@ static int ehci_resume (struct usb_hcd *hcd)
 			up (&hcd->self.root_hub->serialize);
 			break;
 		}
-		if ((status & PORT_POWER) == 0)
-			powerup = 1;
 		if (!root->children [port])
 			continue;
 		dbg_port (ehci, __FUNCTION__, port + 1, status);
@@ -794,16 +824,9 @@ static int ehci_resume (struct usb_hcd *hcd)
 		retval = ehci_start (hcd);
 
 		/* here we "know" root ports should always stay powered;
-		 * but some controllers may lost all power.
+		 * but some controllers may lose all power.
 		 */
-		if (powerup) {
-			ehci_dbg (ehci, "...powerup ports...\n");
-			for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
-				(void) ehci_hub_control(hcd,
-					SetPortFeature, USB_PORT_FEAT_POWER,
-						port--, NULL, 0);
-			msleep(20);
-		}
+		ehci_port_power (ehci, 1);
 	}
 
 	return retval;

commit 9a5d3e98dd31abcecbf4533b81866d440cc0f106
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 18 17:39:23 2005 -0700

    [PATCH] USB: hcd suspend uses pm_message_t
    
    This patch includes minor "sparse -Wbitwise" updates for the PCI based
    HCDs.  Almost all of them involve just changing the second parameter of the
    suspend() method to a pm_message_t ...  the others relate to how the EHCI
    code walks in-memory data structures.  (There's a minor bug fixed there too
    ...  affecting the big-endian sysfs async schedule dump.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    
    Index: gregkh-2.6/drivers/usb/core/hcd.h
    ===================================================================

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a63bb792e2c7..84d2b93aca37 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -721,7 +721,7 @@ static int ehci_get_frame (struct usb_hcd *hcd)
  * the right sort of wakeup.  
  */
 
-static int ehci_suspend (struct usb_hcd *hcd, u32 state)
+static int ehci_suspend (struct usb_hcd *hcd, pm_message_t message)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 
@@ -729,7 +729,7 @@ static int ehci_suspend (struct usb_hcd *hcd, u32 state)
 		msleep (100);
 
 #ifdef	CONFIG_USB_SUSPEND
-	(void) usb_suspend_device (hcd->self.root_hub, state);
+	(void) usb_suspend_device (hcd->self.root_hub, message);
 #else
 	usb_lock_device (hcd->self.root_hub);
 	(void) ehci_hub_suspend (hcd);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
new file mode 100644
index 000000000000..a63bb792e2c7
--- /dev/null
+++ b/drivers/usb/host/ehci-hcd.c
@@ -0,0 +1,1261 @@
+/*
+ * Copyright (c) 2000-2004 by David Brownell
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_USB_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/dmapool.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/usb.h>
+#include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
+
+#include "../core/hcd.h"
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * EHCI hc_driver implementation ... experimental, incomplete.
+ * Based on the final 1.0 register interface specification.
+ *
+ * USB 2.0 shows up in upcoming www.pcmcia.org technology.
+ * First was PCMCIA, like ISA; then CardBus, which is PCI.
+ * Next comes "CardBay", using USB 2.0 signals.
+ *
+ * Contains additional contributions by Brad Hards, Rory Bolt, and others.
+ * Special thanks to Intel and VIA for providing host controllers to
+ * test this driver on, and Cypress (including In-System Design) for
+ * providing early devices for those host controllers to talk to!
+ *
+ * HISTORY:
+ *
+ * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)
+ * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)
+ * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,
+ *	<sojkam@centrum.cz>, updates by DB).
+ *
+ * 2002-11-29	Correct handling for hw async_next register.
+ * 2002-08-06	Handling for bulk and interrupt transfers is mostly shared;
+ *	only scheduling is different, no arbitrary limitations.
+ * 2002-07-25	Sanity check PCI reads, mostly for better cardbus support,
+ * 	clean up HC run state handshaking.
+ * 2002-05-24	Preliminary FS/LS interrupts, using scheduling shortcuts
+ * 2002-05-11	Clear TT errors for FS/LS ctrl/bulk.  Fill in some other
+ *	missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.
+ * 2002-05-07	Some error path cleanups to report better errors; wmb();
+ *	use non-CVS version id; better iso bandwidth claim.
+ * 2002-04-19	Control/bulk/interrupt submit no longer uses giveback() on
+ *	errors in submit path.  Bugfixes to interrupt scheduling/processing.
+ * 2002-03-05	Initial high-speed ISO support; reduce ITD memory; shift
+ *	more checking to generic hcd framework (db).  Make it work with
+ *	Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).
+ * 2002-01-14	Minor cleanup; version synch.
+ * 2002-01-08	Fix roothub handoff of FS/LS to companion controllers.
+ * 2002-01-04	Control/Bulk queuing behaves.
+ *
+ * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.
+ * 2001-June	Works with usb-storage and NEC EHCI on 2.4
+ */
+
+#define DRIVER_VERSION "10 Dec 2004"
+#define DRIVER_AUTHOR "David Brownell"
+#define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
+
+static const char	hcd_name [] = "ehci_hcd";
+
+
+#undef EHCI_VERBOSE_DEBUG
+#undef EHCI_URB_TRACE
+
+#ifdef DEBUG
+#define EHCI_STATS
+#endif
+
+/* magic numbers that can affect system performance */
+#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define	EHCI_TUNE_RL_TT		0
+#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define	EHCI_TUNE_MULT_TT	1
+#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+
+#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
+#define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
+#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+
+/* Initial IRQ latency:  faster than hw default */
+static int log2_irq_thresh = 0;		// 0 to 6
+module_param (log2_irq_thresh, int, S_IRUGO);
+MODULE_PARM_DESC (log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
+
+/* initial park setting:  slower than hw default */
+static unsigned park = 0;
+module_param (park, uint, S_IRUGO);
+MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
+
+#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
+
+/*-------------------------------------------------------------------------*/
+
+#include "ehci.h"
+#include "ehci-dbg.c"
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * handshake - spin reading hc until handshake completes or fails
+ * @ptr: address of hc register to be read
+ * @mask: bits to look at in result of read
+ * @done: value of those bits when handshake succeeds
+ * @usec: timeout in microseconds
+ *
+ * Returns negative errno, or zero on success
+ *
+ * Success happens when the "mask" bits have the specified value (hardware
+ * handshake done).  There are two failure modes:  "usec" have passed (major
+ * hardware flakeout), or the register reads as all-ones (hardware removed).
+ *
+ * That last failure should_only happen in cases like physical cardbus eject
+ * before driver shutdown. But it also seems to be caused by bugs in cardbus
+ * bridge shutdown:  shutting down the bridge before the devices using it.
+ */
+static int handshake (void __iomem *ptr, u32 mask, u32 done, int usec)
+{
+	u32	result;
+
+	do {
+		result = readl (ptr);
+		if (result == ~(u32)0)		/* card removed */
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay (1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* force HC to halt state from unknown (EHCI spec section 2.3) */
+static int ehci_halt (struct ehci_hcd *ehci)
+{
+	u32	temp = readl (&ehci->regs->status);
+
+	if ((temp & STS_HALT) != 0)
+		return 0;
+
+	temp = readl (&ehci->regs->command);
+	temp &= ~CMD_RUN;
+	writel (temp, &ehci->regs->command);
+	return handshake (&ehci->regs->status, STS_HALT, STS_HALT, 16 * 125);
+}
+
+/* put TDI/ARC silicon into EHCI mode */
+static void tdi_reset (struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg_ptr;
+	u32		tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + 0x68);
+	tmp = readl (reg_ptr);
+	tmp |= 0x3;
+	writel (tmp, reg_ptr);
+}
+
+/* reset a non-running (STS_HALT == 1) controller */
+static int ehci_reset (struct ehci_hcd *ehci)
+{
+	int	retval;
+	u32	command = readl (&ehci->regs->command);
+
+	command |= CMD_RESET;
+	dbg_cmd (ehci, "reset", command);
+	writel (command, &ehci->regs->command);
+	ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	ehci->next_statechange = jiffies;
+	retval = handshake (&ehci->regs->command, CMD_RESET, 0, 250 * 1000);
+
+	if (retval)
+		return retval;
+
+	if (ehci_is_TDI(ehci))
+		tdi_reset (ehci);
+
+	return retval;
+}
+
+/* idle the controller (from running) */
+static void ehci_quiesce (struct ehci_hcd *ehci)
+{
+	u32	temp;
+
+#ifdef DEBUG
+	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
+		BUG ();
+#endif
+
+	/* wait for any schedule enables/disables to take effect */
+	temp = readl (&ehci->regs->command) << 10;
+	temp &= STS_ASS | STS_PSS;
+	if (handshake (&ehci->regs->status, STS_ASS | STS_PSS,
+				temp, 16 * 125) != 0) {
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+		return;
+	}
+
+	/* then disable anything that's still active */
+	temp = readl (&ehci->regs->command);
+	temp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
+	writel (temp, &ehci->regs->command);
+
+	/* hardware can take 16 microframes to turn off ... */
+	if (handshake (&ehci->regs->status, STS_ASS | STS_PSS,
+				0, 16 * 125) != 0) {
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+		return;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void ehci_work(struct ehci_hcd *ehci, struct pt_regs *regs);
+
+#include "ehci-hub.c"
+#include "ehci-mem.c"
+#include "ehci-q.c"
+#include "ehci-sched.c"
+
+/*-------------------------------------------------------------------------*/
+
+static void ehci_watchdog (unsigned long param)
+{
+	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
+	unsigned long		flags;
+
+	spin_lock_irqsave (&ehci->lock, flags);
+
+	/* lost IAA irqs wedge things badly; seen with a vt8235 */
+	if (ehci->reclaim) {
+		u32		status = readl (&ehci->regs->status);
+
+		if (status & STS_IAA) {
+			ehci_vdbg (ehci, "lost IAA\n");
+			COUNT (ehci->stats.lost_iaa);
+			writel (STS_IAA, &ehci->regs->status);
+			ehci->reclaim_ready = 1;
+		}
+	}
+
+ 	/* stop async processing after it's idled a bit */
+	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
+ 		start_unlink_async (ehci, ehci->async);
+
+	/* ehci could run by timer, without IRQs ... */
+	ehci_work (ehci, NULL);
+
+	spin_unlock_irqrestore (&ehci->lock, flags);
+}
+
+#ifdef	CONFIG_PCI
+
+/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...
+ * off the controller (maybe it can boot from highspeed USB disks).
+ */
+static int bios_handoff (struct ehci_hcd *ehci, int where, u32 cap)
+{
+	if (cap & (1 << 16)) {
+		int msec = 5000;
+		struct pci_dev *pdev =
+				to_pci_dev(ehci_to_hcd(ehci)->self.controller);
+
+		/* request handoff to OS */
+		cap |= 1 << 24;
+		pci_write_config_dword(pdev, where, cap);
+
+		/* and wait a while for it to happen */
+		do {
+			msleep(10);
+			msec -= 10;
+			pci_read_config_dword(pdev, where, &cap);
+		} while ((cap & (1 << 16)) && msec);
+		if (cap & (1 << 16)) {
+			ehci_err (ehci, "BIOS handoff failed (%d, %04x)\n",
+				where, cap);
+			// some BIOS versions seem buggy...
+			// return 1;
+			ehci_warn (ehci, "continuing after BIOS bug...\n");
+			return 0;
+		} 
+		ehci_dbg (ehci, "BIOS handoff succeeded\n");
+	}
+	return 0;
+}
+
+#endif
+
+static int
+ehci_reboot (struct notifier_block *self, unsigned long code, void *null)
+{
+	struct ehci_hcd		*ehci;
+
+	ehci = container_of (self, struct ehci_hcd, reboot_notifier);
+
+	/* make BIOS/etc use companion controller during reboot */
+	writel (0, &ehci->regs->configured_flag);
+	return 0;
+}
+
+
+/* called by khubd or root hub init threads */
+
+static int ehci_hc_reset (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			temp;
+	unsigned		count = 256/4;
+
+	spin_lock_init (&ehci->lock);
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH (readl (&ehci->caps->hc_capbase));
+	dbg_hcs_params (ehci, "reset");
+	dbg_hcc_params (ehci, "reset");
+
+#ifdef	CONFIG_PCI
+	/* EHCI 0.96 and later may have "extended capabilities" */
+	if (hcd->self.controller->bus == &pci_bus_type) {
+		struct pci_dev	*pdev = to_pci_dev(hcd->self.controller);
+
+		switch (pdev->vendor) {
+		case PCI_VENDOR_ID_TDI:
+			if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
+				ehci->is_tdi_rh_tt = 1;
+				tdi_reset (ehci);
+			}
+			break;
+		case PCI_VENDOR_ID_AMD:
+			/* AMD8111 EHCI doesn't work, according to AMD errata */
+			if (pdev->device == 0x7463) {
+				ehci_info (ehci, "ignoring AMD8111 (errata)\n");
+				return -EIO;
+			}
+			break;
+		}
+
+		temp = HCC_EXT_CAPS (readl (&ehci->caps->hcc_params));
+	} else
+		temp = 0;
+	while (temp && count--) {
+		u32		cap;
+
+		pci_read_config_dword (to_pci_dev(hcd->self.controller),
+				temp, &cap);
+		ehci_dbg (ehci, "capability %04x at %02x\n", cap, temp);
+		switch (cap & 0xff) {
+		case 1:			/* BIOS/SMM/... handoff */
+			if (bios_handoff (ehci, temp, cap) != 0)
+				return -EOPNOTSUPP;
+			break;
+		case 0:			/* illegal reserved capability */
+			ehci_warn (ehci, "illegal capability!\n");
+			cap = 0;
+			/* FALLTHROUGH */
+		default:		/* unknown */
+			break;
+		}
+		temp = (cap >> 8) & 0xff;
+	}
+	if (!count) {
+		ehci_err (ehci, "bogus capabilities ... PCI problems!\n");
+		return -EIO;
+	}
+	if (ehci_is_TDI(ehci))
+		ehci_reset (ehci);
+#endif
+
+	/* cache this readonly data; minimize PCI reads */
+	ehci->hcs_params = readl (&ehci->caps->hcs_params);
+
+	/* at least the Genesys GL880S needs fixup here */
+	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+	temp &= 0x0f;
+	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
+		ehci_dbg (ehci, "bogus port configuration: "
+			"cc=%d x pcc=%d < ports=%d\n",
+			HCS_N_CC(ehci->hcs_params),
+			HCS_N_PCC(ehci->hcs_params),
+			HCS_N_PORTS(ehci->hcs_params));
+
+#ifdef	CONFIG_PCI
+		if (hcd->self.controller->bus == &pci_bus_type) {
+			struct pci_dev	*pdev;
+
+			pdev = to_pci_dev(hcd->self.controller);
+			switch (pdev->vendor) {
+			case 0x17a0:		/* GENESYS */
+				/* GL880S: should be PORTS=2 */
+				temp |= (ehci->hcs_params & ~0xf);
+				ehci->hcs_params = temp;
+				break;
+			case PCI_VENDOR_ID_NVIDIA:
+				/* NF4: should be PCC=10 */
+				break;
+			}
+		}
+#endif
+	}
+
+	/* force HC to halt state */
+	return ehci_halt (ehci);
+}
+
+static int ehci_start (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			temp;
+	struct usb_device	*udev;
+	struct usb_bus		*bus;
+	int			retval;
+	u32			hcc_params;
+	u8                      sbrn = 0;
+	int			first;
+
+	/* skip some things on restart paths */
+	first = (ehci->watchdog.data == 0);
+	if (first) {
+		init_timer (&ehci->watchdog);
+		ehci->watchdog.function = ehci_watchdog;
+		ehci->watchdog.data = (unsigned long) ehci;
+	}
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	ehci->periodic_size = DEFAULT_I_TDPS;
+	if (first && (retval = ehci_mem_init (ehci, GFP_KERNEL)) < 0)
+		return retval;
+
+	/* controllers may cache some of the periodic schedule ... */
+	hcc_params = readl (&ehci->caps->hcc_params);
+	if (HCC_ISOC_CACHE (hcc_params)) 	// full frame cache
+		ehci->i_thresh = 8;
+	else					// N microframes cached
+		ehci->i_thresh = 2 + HCC_ISOC_THRES (hcc_params);
+
+	ehci->reclaim = NULL;
+	ehci->reclaim_ready = 0;
+	ehci->next_uframe = -1;
+
+	/* controller state:  unknown --> reset */
+
+	/* EHCI spec section 4.1 */
+	if ((retval = ehci_reset (ehci)) != 0) {
+		ehci_mem_cleanup (ehci);
+		return retval;
+	}
+	writel (ehci->periodic_dma, &ehci->regs->frame_list);
+
+#ifdef	CONFIG_PCI
+	if (hcd->self.controller->bus == &pci_bus_type) {
+		struct pci_dev		*pdev;
+		u16			port_wake;
+
+		pdev = to_pci_dev(hcd->self.controller);
+
+		/* Serial Bus Release Number is at PCI 0x60 offset */
+		pci_read_config_byte(pdev, 0x60, &sbrn);
+
+		/* port wake capability, reported by boot firmware */
+		pci_read_config_word(pdev, 0x62, &port_wake);
+		hcd->can_wakeup = (port_wake & 1) != 0;
+
+		/* help hc dma work well with cachelines */
+		pci_set_mwi (pdev);
+	}
+#endif
+
+	/*
+	 * dedicate a qh for the async ring head, since we couldn't unlink
+	 * a 'real' qh without stopping the async schedule [4.8].  use it
+	 * as the 'reclamation list head' too.
+	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
+	 * from automatically advancing to the next td after short reads.
+	 */
+	if (first) {
+		ehci->async->qh_next.qh = NULL;
+		ehci->async->hw_next = QH_NEXT (ehci->async->qh_dma);
+		ehci->async->hw_info1 = cpu_to_le32 (QH_HEAD);
+		ehci->async->hw_token = cpu_to_le32 (QTD_STS_HALT);
+		ehci->async->hw_qtd_next = EHCI_LIST_END;
+		ehci->async->qh_state = QH_STATE_LINKED;
+		ehci->async->hw_alt_next = QTD_NEXT (ehci->async->dummy->qtd_dma);
+	}
+	writel ((u32)ehci->async->qh_dma, &ehci->regs->async_next);
+
+	/*
+	 * hcc_params controls whether ehci->regs->segment must (!!!)
+	 * be used; it constrains QH/ITD/SITD and QTD locations.
+	 * pci_pool consistent memory always uses segment zero.
+	 * streaming mappings for I/O buffers, like pci_map_single(),
+	 * can return segments above 4GB, if the device allows.
+	 *
+	 * NOTE:  the dma mask is visible through dma_supported(), so
+	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
+	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
+	 * host side drivers though.
+	 */
+	if (HCC_64BIT_ADDR (hcc_params)) {
+		writel (0, &ehci->regs->segment);
+#if 0
+// this is deeply broken on almost all architectures
+		if (!pci_set_dma_mask (to_pci_dev(hcd->self.controller), 0xffffffffffffffffULL))
+			ehci_info (ehci, "enabled 64bit PCI DMA\n");
+#endif
+	}
+
+	/* clear interrupt enables, set irq latency */
+	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
+		log2_irq_thresh = 0;
+	temp = 1 << (16 + log2_irq_thresh);
+	if (HCC_CANPARK(hcc_params)) {
+		/* HW default park == 3, on hardware that supports it (like
+		 * NVidia and ALI silicon), maximizes throughput on the async
+		 * schedule by avoiding QH fetches between transfers.
+		 *
+		 * With fast usb storage devices and NForce2, "park" seems to
+		 * make problems:  throughput reduction (!), data errors...
+		 */
+		if (park) {
+			park = min (park, (unsigned) 3);
+			temp |= CMD_PARK;
+			temp |= park << 8;
+		}
+		ehci_info (ehci, "park %d\n", park);
+	}
+	if (HCC_PGM_FRAMELISTLEN (hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		temp &= ~(3 << 2);
+		temp |= (EHCI_TUNE_FLS << 2);
+		switch (EHCI_TUNE_FLS) {
+		case 0: ehci->periodic_size = 1024; break;
+		case 1: ehci->periodic_size = 512; break;
+		case 2: ehci->periodic_size = 256; break;
+		default:	BUG ();
+		}
+	}
+	// Philips, Intel, and maybe others need CMD_RUN before the
+	// root hub will detect new devices (why?); NEC doesn't
+	temp |= CMD_RUN;
+	writel (temp, &ehci->regs->command);
+	dbg_cmd (ehci, "init", temp);
+
+	/* set async sleep time = 10 us ... ? */
+
+	/* wire up the root hub */
+	bus = hcd_to_bus (hcd);
+	udev = first ? usb_alloc_dev (NULL, bus, 0) : bus->root_hub;
+	if (!udev) {
+done2:
+		ehci_mem_cleanup (ehci);
+		return -ENOMEM;
+	}
+	udev->speed = USB_SPEED_HIGH;
+	udev->state = first ? USB_STATE_ATTACHED : USB_STATE_CONFIGURED;
+
+	/*
+	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
+	 * are explicitly handed to companion controller(s), so no TT is
+	 * involved with the root hub.  (Except where one is integrated,
+	 * and there's no companion controller unless maybe for USB OTG.)
+	 */
+	if (first) {
+		ehci->reboot_notifier.notifier_call = ehci_reboot;
+		register_reboot_notifier (&ehci->reboot_notifier);
+	}
+
+	hcd->state = HC_STATE_RUNNING;
+	writel (FLAG_CF, &ehci->regs->configured_flag);
+	readl (&ehci->regs->command);	/* unblock posted write */
+
+	temp = HC_VERSION(readl (&ehci->caps->hc_capbase));
+	ehci_info (ehci,
+		"USB %x.%x %s, EHCI %x.%02x, driver %s\n",
+		((sbrn & 0xf0)>>4), (sbrn & 0x0f),
+		first ? "initialized" : "restarted",
+		temp >> 8, temp & 0xff, DRIVER_VERSION);
+
+	/*
+	 * From here on, khubd concurrently accesses the root
+	 * hub; drivers will be talking to enumerated devices.
+	 * (On restart paths, khubd already knows about the root
+	 * hub and could find work as soon as we wrote FLAG_CF.)
+	 *
+	 * Before this point the HC was idle/ready.  After, khubd
+	 * and device drivers may start it running.
+	 */
+	if (first && usb_hcd_register_root_hub (udev, hcd) != 0) {
+		if (hcd->state == HC_STATE_RUNNING)
+			ehci_quiesce (ehci);
+		ehci_reset (ehci);
+		usb_put_dev (udev); 
+		retval = -ENODEV;
+		goto done2;
+	}
+
+	writel (INTR_MASK, &ehci->regs->intr_enable); /* Turn On Interrupts */
+
+	if (first)
+		create_debug_files (ehci);
+
+	return 0;
+}
+
+/* always called by thread; normally rmmod */
+
+static void ehci_stop (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u8			rh_ports, port;
+
+	ehci_dbg (ehci, "stop\n");
+
+	/* Turn off port power on all root hub ports. */
+	rh_ports = HCS_N_PORTS (ehci->hcs_params);
+	for (port = 1; port <= rh_ports; port++)
+		(void) ehci_hub_control(hcd,
+			ClearPortFeature, USB_PORT_FEAT_POWER,
+			port, NULL, 0);
+
+	/* no more interrupts ... */
+	del_timer_sync (&ehci->watchdog);
+
+	spin_lock_irq(&ehci->lock);
+	if (HC_IS_RUNNING (hcd->state))
+		ehci_quiesce (ehci);
+
+	ehci_reset (ehci);
+	writel (0, &ehci->regs->intr_enable);
+	spin_unlock_irq(&ehci->lock);
+
+	/* let companion controllers work when we aren't */
+	writel (0, &ehci->regs->configured_flag);
+	unregister_reboot_notifier (&ehci->reboot_notifier);
+
+	remove_debug_files (ehci);
+
+	/* root hub is shut down separately (first, when possible) */
+	spin_lock_irq (&ehci->lock);
+	if (ehci->async)
+		ehci_work (ehci, NULL);
+	spin_unlock_irq (&ehci->lock);
+	ehci_mem_cleanup (ehci);
+
+#ifdef	EHCI_STATS
+	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
+		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
+		ehci->stats.lost_iaa);
+	ehci_dbg (ehci, "complete %ld unlink %ld\n",
+		ehci->stats.complete, ehci->stats.unlink);
+#endif
+
+	dbg_status (ehci, "ehci_stop completed", readl (&ehci->regs->status));
+}
+
+static int ehci_get_frame (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	return (readl (&ehci->regs->frame_index) >> 3) % ehci->periodic_size;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.  
+ */
+
+static int ehci_suspend (struct usb_hcd *hcd, u32 state)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+
+	if (time_before (jiffies, ehci->next_statechange))
+		msleep (100);
+
+#ifdef	CONFIG_USB_SUSPEND
+	(void) usb_suspend_device (hcd->self.root_hub, state);
+#else
+	usb_lock_device (hcd->self.root_hub);
+	(void) ehci_hub_suspend (hcd);
+	usb_unlock_device (hcd->self.root_hub);
+#endif
+
+	// save (PCI) FLADJ in case of Vaux power loss
+	// ... we'd only use it to handle clock skew
+
+	return 0;
+}
+
+static int ehci_resume (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	unsigned		port;
+	struct usb_device	*root = hcd->self.root_hub;
+	int			retval = -EINVAL;
+	int			powerup = 0;
+
+	// maybe restore (PCI) FLADJ
+
+	if (time_before (jiffies, ehci->next_statechange))
+		msleep (100);
+
+	/* If any port is suspended, we know we can/must resume the HC. */
+	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; ) {
+		u32	status;
+		port--;
+		status = readl (&ehci->regs->port_status [port]);
+		if (status & PORT_SUSPEND) {
+			down (&hcd->self.root_hub->serialize);
+			retval = ehci_hub_resume (hcd);
+			up (&hcd->self.root_hub->serialize);
+			break;
+		}
+		if ((status & PORT_POWER) == 0)
+			powerup = 1;
+		if (!root->children [port])
+			continue;
+		dbg_port (ehci, __FUNCTION__, port + 1, status);
+		usb_set_device_state (root->children[port],
+					USB_STATE_NOTATTACHED);
+	}
+
+	/* Else reset, to cope with power loss or flush-to-storage
+	 * style "resume" having activated BIOS during reboot.
+	 */
+	if (port == 0) {
+		(void) ehci_halt (ehci);
+		(void) ehci_reset (ehci);
+		(void) ehci_hc_reset (hcd);
+
+		/* emptying the schedule aborts any urbs */
+		spin_lock_irq (&ehci->lock);
+		if (ehci->reclaim)
+			ehci->reclaim_ready = 1;
+		ehci_work (ehci, NULL);
+		spin_unlock_irq (&ehci->lock);
+
+		/* restart; khubd will disconnect devices */
+		retval = ehci_start (hcd);
+
+		/* here we "know" root ports should always stay powered;
+		 * but some controllers may lost all power.
+		 */
+		if (powerup) {
+			ehci_dbg (ehci, "...powerup ports...\n");
+			for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
+				(void) ehci_hub_control(hcd,
+					SetPortFeature, USB_PORT_FEAT_POWER,
+						port--, NULL, 0);
+			msleep(20);
+		}
+	}
+
+	return retval;
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * ehci_work is called from some interrupts, timers, and so on.
+ * it calls driver completion functions, after dropping ehci->lock.
+ */
+static void ehci_work (struct ehci_hcd *ehci, struct pt_regs *regs)
+{
+	timer_action_done (ehci, TIMER_IO_WATCHDOG);
+	if (ehci->reclaim_ready)
+		end_unlink_async (ehci, regs);
+
+	/* another CPU may drop ehci->lock during a schedule scan while
+	 * it reports urb completions.  this flag guards against bogus
+	 * attempts at re-entrant schedule scanning.
+	 */
+	if (ehci->scanning)
+		return;
+	ehci->scanning = 1;
+	scan_async (ehci, regs);
+	if (ehci->next_uframe != -1)
+		scan_periodic (ehci, regs);
+	ehci->scanning = 0;
+
+	/* the IO watchdog guards against hardware or driver bugs that
+	 * misplace IRQs, and should let us run completely without IRQs.
+	 * such lossage has been observed on both VT6202 and VT8235. 
+	 */
+	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
+			(ehci->async->qh_next.ptr != NULL ||
+			 ehci->periodic_sched != 0))
+		timer_action (ehci, TIMER_IO_WATCHDOG);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t ehci_irq (struct usb_hcd *hcd, struct pt_regs *regs)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			status;
+	int			bh;
+
+	spin_lock (&ehci->lock);
+
+	status = readl (&ehci->regs->status);
+
+	/* e.g. cardbus physical eject */
+	if (status == ~(u32) 0) {
+		ehci_dbg (ehci, "device removed\n");
+		goto dead;
+	}
+
+	status &= INTR_MASK;
+	if (!status) {			/* irq sharing? */
+		spin_unlock(&ehci->lock);
+		return IRQ_NONE;
+	}
+
+	/* clear (just) interrupts */
+	writel (status, &ehci->regs->status);
+	readl (&ehci->regs->command);	/* unblock posted write */
+	bh = 0;
+
+#ifdef	EHCI_VERBOSE_DEBUG
+	/* unrequested/ignored: Frame List Rollover */
+	dbg_status (ehci, "irq", status);
+#endif
+
+	/* INT, ERR, and IAA interrupt rates can be throttled */
+
+	/* normal [4.15.1.2] or error [4.15.1.1] completion */
+	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
+		if (likely ((status & STS_ERR) == 0))
+			COUNT (ehci->stats.normal);
+		else
+			COUNT (ehci->stats.error);
+		bh = 1;
+	}
+
+	/* complete the unlinking of some qh [4.15.2.3] */
+	if (status & STS_IAA) {
+		COUNT (ehci->stats.reclaim);
+		ehci->reclaim_ready = 1;
+		bh = 1;
+	}
+
+	/* remote wakeup [4.3.1] */
+	if ((status & STS_PCD) && hcd->remote_wakeup) {
+		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+
+		/* resume root hub? */
+		status = readl (&ehci->regs->command);
+		if (!(status & CMD_RUN))
+			writel (status | CMD_RUN, &ehci->regs->command);
+
+		while (i--) {
+			status = readl (&ehci->regs->port_status [i]);
+			if (status & PORT_OWNER)
+				continue;
+			if (!(status & PORT_RESUME)
+					|| ehci->reset_done [i] != 0)
+				continue;
+
+			/* start 20 msec resume signaling from this port,
+			 * and make khubd collect PORT_STAT_C_SUSPEND to
+			 * stop that signaling.
+			 */
+			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
+			mod_timer (&hcd->rh_timer,
+					ehci->reset_done [i] + 1);
+			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+		}
+	}
+
+	/* PCI errors [4.15.2.4] */
+	if (unlikely ((status & STS_FATAL) != 0)) {
+		/* bogus "fatal" IRQs appear on some chips... why?  */
+		status = readl (&ehci->regs->status);
+		dbg_cmd (ehci, "fatal", readl (&ehci->regs->command));
+		dbg_status (ehci, "fatal", status);
+		if (status & STS_HALT) {
+			ehci_err (ehci, "fatal error\n");
+dead:
+			ehci_reset (ehci);
+			writel (0, &ehci->regs->configured_flag);
+			/* generic layer kills/unlinks all urbs, then
+			 * uses ehci_stop to clean up the rest
+			 */
+			bh = 1;
+		}
+	}
+
+	if (bh)
+		ehci_work (ehci, regs);
+	spin_unlock (&ehci->lock);
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * non-error returns are a promise to giveback() the urb later
+ * we drop ownership so next owner (or urb unlink) can get it
+ *
+ * urb + dev is in hcd.self.controller.urb_list
+ * we're queueing TDs onto software and hardware lists
+ *
+ * hcd-specific init for hcpriv hasn't been done yet
+ *
+ * NOTE:  control, bulk, and interrupt share the same code to append TDs
+ * to a (possibly active) QH, and the same QH scanning code.
+ */
+static int ehci_urb_enqueue (
+	struct usb_hcd	*hcd,
+	struct usb_host_endpoint *ep,
+	struct urb	*urb,
+	int		mem_flags
+) {
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct list_head	qtd_list;
+
+	INIT_LIST_HEAD (&qtd_list);
+
+	switch (usb_pipetype (urb->pipe)) {
+	// case PIPE_CONTROL:
+	// case PIPE_BULK:
+	default:
+		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return submit_async (ehci, ep, urb, &qtd_list, mem_flags);
+
+	case PIPE_INTERRUPT:
+		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return intr_submit (ehci, ep, urb, &qtd_list, mem_flags);
+
+	case PIPE_ISOCHRONOUS:
+		if (urb->dev->speed == USB_SPEED_HIGH)
+			return itd_submit (ehci, urb, mem_flags);
+		else
+			return sitd_submit (ehci, urb, mem_flags);
+	}
+}
+
+static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
+{
+	/* if we need to use IAA and it's busy, defer */
+	if (qh->qh_state == QH_STATE_LINKED
+			&& ehci->reclaim
+			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
+		struct ehci_qh		*last;
+
+		for (last = ehci->reclaim;
+				last->reclaim;
+				last = last->reclaim)
+			continue;
+		qh->qh_state = QH_STATE_UNLINK_WAIT;
+		last->reclaim = qh;
+
+	/* bypass IAA if the hc can't care */
+	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
+		end_unlink_async (ehci, NULL);
+
+	/* something else might have unlinked the qh by now */
+	if (qh->qh_state == QH_STATE_LINKED)
+		start_unlink_async (ehci, qh);
+}
+
+/* remove from hardware lists
+ * completions normally happen asynchronously
+ */
+
+static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_qh		*qh;
+	unsigned long		flags;
+
+	spin_lock_irqsave (&ehci->lock, flags);
+	switch (usb_pipetype (urb->pipe)) {
+	// case PIPE_CONTROL:
+	// case PIPE_BULK:
+	default:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		unlink_async (ehci, qh);
+		break;
+
+	case PIPE_INTERRUPT:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+			intr_deschedule (ehci, qh);
+			/* FALL THROUGH */
+		case QH_STATE_IDLE:
+			qh_completions (ehci, qh, NULL);
+			break;
+		default:
+			ehci_dbg (ehci, "bogus qh %p state %d\n",
+					qh, qh->qh_state);
+			goto done;
+		}
+
+		/* reschedule QH iff another request is queued */
+		if (!list_empty (&qh->qtd_list)
+				&& HC_IS_RUNNING (hcd->state)) {
+			int status;
+
+			status = qh_schedule (ehci, qh);
+			spin_unlock_irqrestore (&ehci->lock, flags);
+
+			if (status != 0) {
+				// shouldn't happen often, but ...
+				// FIXME kill those tds' urbs
+				err ("can't reschedule qh %p, err %d",
+					qh, status);
+			}
+			return status;
+		}
+		break;
+
+	case PIPE_ISOCHRONOUS:
+		// itd or sitd ...
+
+		// wait till next completion, do it then.
+		// completion irqs can wait up to 1024 msec,
+		break;
+	}
+done:
+	spin_unlock_irqrestore (&ehci->lock, flags);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+// bulk qh holds the data toggle
+
+static void
+ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	unsigned long		flags;
+	struct ehci_qh		*qh, *tmp;
+
+	/* ASSERT:  any requests/urbs are being unlinked */
+	/* ASSERT:  nobody can be submitting urbs for this any more */
+
+rescan:
+	spin_lock_irqsave (&ehci->lock, flags);
+	qh = ep->hcpriv;
+	if (!qh)
+		goto done;
+
+	/* endpoints can be iso streams.  for now, we don't
+	 * accelerate iso completions ... so spin a while.
+	 */
+	if (qh->hw_info1 == 0) {
+		ehci_vdbg (ehci, "iso delay\n");
+		goto idle_timeout;
+	}
+
+	if (!HC_IS_RUNNING (hcd->state))
+		qh->qh_state = QH_STATE_IDLE;
+	switch (qh->qh_state) {
+	case QH_STATE_LINKED:
+		for (tmp = ehci->async->qh_next.qh;
+				tmp && tmp != qh;
+				tmp = tmp->qh_next.qh)
+			continue;
+		/* periodic qh self-unlinks on empty */
+		if (!tmp)
+			goto nogood;
+		unlink_async (ehci, qh);
+		/* FALL THROUGH */
+	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+idle_timeout:
+		spin_unlock_irqrestore (&ehci->lock, flags);
+		set_current_state (TASK_UNINTERRUPTIBLE);
+		schedule_timeout (1);
+		goto rescan;
+	case QH_STATE_IDLE:		/* fully unlinked */
+		if (list_empty (&qh->qtd_list)) {
+			qh_put (qh);
+			break;
+		}
+		/* else FALL THROUGH */
+	default:
+nogood:
+		/* caller was supposed to have unlinked any requests;
+		 * that's not our job.  just leak this memory.
+		 */
+		ehci_err (ehci, "qh %p (#%02x) state %d%s\n",
+			qh, ep->desc.bEndpointAddress, qh->qh_state,
+			list_empty (&qh->qtd_list) ? "" : "(has tds)");
+		break;
+	}
+	ep->hcpriv = NULL;
+done:
+	spin_unlock_irqrestore (&ehci->lock, flags);
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_driver = {
+	.description =		hcd_name,
+	.product_desc =		"EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ehci_hc_reset,
+	.start =		ehci_start,
+#ifdef	CONFIG_PM
+	.suspend =		ehci_suspend,
+	.resume =		ehci_resume,
+#endif
+	.stop =			ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.hub_suspend =		ehci_hub_suspend,
+	.hub_resume =		ehci_hub_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* EHCI 1.0 doesn't require PCI */
+
+#ifdef	CONFIG_PCI
+
+/* PCI driver selection metadata; PCI hotplugging uses this */
+static const struct pci_device_id pci_ids [] = { {
+	/* handle any USB 2.0 EHCI controller */
+	PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x20), ~0),
+	.driver_data =	(unsigned long) &ehci_driver,
+	},
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE (pci, pci_ids);
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver ehci_pci_driver = {
+	.name =		(char *) hcd_name,
+	.id_table =	pci_ids,
+
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
+
+#ifdef	CONFIG_PM
+	.suspend =	usb_hcd_pci_suspend,
+	.resume =	usb_hcd_pci_resume,
+#endif
+};
+
+#endif	/* PCI */
+
+
+#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
+
+MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("GPL");
+
+static int __init init (void) 
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug ("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+		hcd_name,
+		sizeof (struct ehci_qh), sizeof (struct ehci_qtd),
+		sizeof (struct ehci_itd), sizeof (struct ehci_sitd));
+
+	return pci_register_driver (&ehci_pci_driver);
+}
+module_init (init);
+
+static void __exit cleanup (void) 
+{	
+	pci_unregister_driver (&ehci_pci_driver);
+}
+module_exit (cleanup);
