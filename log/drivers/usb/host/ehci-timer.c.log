commit a0ef2bdfa3b1497ac3d0cb348102c87c51f041a9
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Wed Sep 19 19:48:53 2018 +0000

    usb: host: Replace empty define with do while
    
    It's dangerous to use empty code define.
    Furthermore it lead to the following warning:
    "suggest braces around empty body in an « else » statement"
    
    So let's replace emptyness by "do {} while(0)"
    
    Furthermore, as suggested by Joe Perches, rename the macro to INCR.
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 4fcebda4b79d..a79c8ac0a55f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -347,7 +347,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 */
 	status = ehci_readl(ehci, &ehci->regs->status);
 	if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
-		COUNT(ehci->stats.lost_iaa);
+		INCR(ehci->stats.lost_iaa);
 		ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 	}
 

commit d214109875b419c85c596d39b032692133bf58ba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:26 2017 +0100

    USB: host: ehci: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 047a5b131717..4fcebda4b79d 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -1,16 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2012 by Alan Stern
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
  */
 
 /* This file is part of ehci-hcd.c */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0b6cdb723192..047a5b131717 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2012 by Alan Stern
  *

commit fa72e6afa795dbb35d0cc6332606e83e4415e45e
Author: Mariusz Skamra <mariuszx.skamra@intel.com>
Date:   Fri May 26 12:15:59 2017 +0200

    usb: Make use of ktime_* comparison functions
    
    Start using ktime_* compare functions to make the code backportable.
    Now that may be a bit tricky due to recent change of ktime_t.
    
    Signed-off-by: Mariusz Skamra <mariuszx.skamra@intel.com>
    Acked-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 3893b5bafd87..0b6cdb723192 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -424,7 +424,7 @@ static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
 	 */
 	now = ktime_get();
 	for_each_set_bit(e, &events, EHCI_HRTIMER_NUM_EVENTS) {
-		if (now >= ehci->hr_timeouts[e])
+		if (ktime_compare(now, ehci->hr_timeouts[e]) >= 0)
 			event_handlers[e](ehci);
 		else
 			ehci_enable_event(ehci, e, false);

commit 8b0e195314fabd58a331c4f7b6db75a1565535d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 25 12:30:41 2016 +0100

    ktime: Cleanup ktime_set() usage
    
    ktime_set(S,N) was required for the timespec storage type and is still
    useful for situations where a Seconds and Nanoseconds part of a time value
    needs to be converted. For anything where the Seconds argument is 0, this
    is pointless and can be replaced with a simple assignment.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 262e10cacc8c..3893b5bafd87 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -88,8 +88,7 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 	ktime_t		*timeout = &ehci->hr_timeouts[event];
 
 	if (resched)
-		*timeout = ktime_add(ktime_get(),
-				ktime_set(0, event_delays_ns[event]));
+		*timeout = ktime_add(ktime_get(), event_delays_ns[event]);
 	ehci->enabled_hrtimer_events |= (1 << event);
 
 	/* Track only the lowest-numbered pending event */

commit 2456e855354415bfaeb7badaa14e11b3e02c8466
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 25 11:38:40 2016 +0100

    ktime: Get rid of the union
    
    ktime is a union because the initial implementation stored the time in
    scalar nanoseconds on 64 bit machine and in a endianess optimized timespec
    variant for 32bit machines. The Y2038 cleanup removed the timespec variant
    and switched everything to scalar nanoseconds. The union remained, but
    become completely pointless.
    
    Get rid of the union and just keep ktime_t as simple typedef of type s64.
    
    The conversion was done with coccinelle and some manual mopping up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 69f50e6533a6..262e10cacc8c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -425,7 +425,7 @@ static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
 	 */
 	now = ktime_get();
 	for_each_set_bit(e, &events, EHCI_HRTIMER_NUM_EVENTS) {
-		if (now.tv64 >= ehci->hr_timeouts[e].tv64)
+		if (now >= ehci->hr_timeouts[e])
 			event_handlers[e](ehci);
 		else
 			ehci_enable_event(ehci, e, false);

commit 87d61912c23a746ee9a8a8d2fe17af217c87f761
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:45:25 2016 -0500

    USB: EHCI: add a delay when unlinking an active QH
    
    Michael Reutman reports that an AMD/ATI EHCI host controller on one of
    his computers does not stop transferring data when an active bulk QH
    is unlinked from the async schedule.  Apparently that host controller
    fails to implement the IAA mechanism correctly when an active QH is
    unlinked.  This leads to data corruption, because the controller
    continues to update the QH in memory when the driver doesn't expect
    it.  As a result, the next URB submitted for that QH can hang, because
    the link pointers for the TD queue have been messed up.  This
    misbehavior is observed quite regularly.
    
    To be fair, the EHCI spec (section 4.8.2) says that active QHs should
    not be unlinked.  It goes on to recommend a procedure that involves
    waiting for the QH to go inactive before unlinking it.  In the real
    world this is impractical, not least because the QH may _never_ go
    inactive.  (What were they thinking?)  Sometimes we have no choice but
    to unlink an active QH.
    
    In an attempt to avoid the problems that can ensue, this patch changes
    how the driver decides when the unlink is complete.  In addition to
    waiting through two IAA cycles, in cases where the QH was not known to
    be inactive beforehand we now wait until a 2-ms period has elapsed
    with the host controller making no change to the QH data structure
    (the hw_current and hw_token fields in particular).  The intuition
    here is that after such a long period, the endpoint must be NAKing and
    hopefully the QH has been dropped from the host controller's internal
    cache.  There's no way to know if this reasoning is really valid --
    the spec is no help in this regard -- but at least this approach fixes
    Michael's problem.
    
    The test for whether the QH is already known to be inactive involves
    the reason for unlinking the QH originally.  If it was unlinked
    because it had halted, or it stopped in response to a short read, or
    it overlaid a dummy TD (a silicon bug), then it certainly is inactive.
    If it was unlinked because the TD queue was empty and no TDs have been
    added to the queue in the meantime, then it must be inactive.  Or if
    the hardware status indicates that the QH is currently halted (even if
    that wasn't the reason for unlinking it), then it is inactive.
    Otherwise, if none of those checks apply, we go through the 2-ms
    delay.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Michael Reutman <mreutman@epiqsolutions.com>
    Tested-by: Michael Reutman <mreutman@epiqsolutions.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 6bea4d553ec5..69f50e6533a6 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ACTIVE_UNLINK */
 	5 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
@@ -395,6 +396,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	end_unlink_async,		/* EHCI_HRTIMER_ACTIVE_UNLINK */
 	ehci_handle_start_intr_unlinks,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */

commit f96fba0dbf8f6b0eaa313b4c230f93c9bb0dd759
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:44:16 2016 -0500

    USB: EHCI: improve handling of the ehci->iaa_in_progress flag
    
    This patch improves the way ehci-hcd handles the iaa_in_progress flag.
    The current code is somewhat careless in this regard:
    
            The flag is meaningless when the root hub isn't running, most
            particularly after the root hub has been suspended.  But in
            start_iaa_cycle(), the driver checks the flag before checking
            the root hub's state.  They should be checked in the opposite
            order.
    
            That routine also sets the flag too early, before it has
            definitely committed to starting an IAA cycle.
    
            The flag is turned off in end_unlink_async().  Upcoming
            changes will call that routine at other times, not just at the
            end of an IAA cycle.  The two actions are logically separate
            (although related), so we separate out a new routine to be
            called in place of end_unlink_async() whenever an IAA cycle
            ends: end_iaa_cycle().
    
            iaa_in_progress should be turned off when the root hub is
            suspended -- we certainly don't want it still to be set when
            the root hub resumes.  Therefore the call to
            end_unlink_async() in ehci_bus_suspend() should also be
            replaced with a call to end_iaa_cycle().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 37a3e0dece84..6bea4d553ec5 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -361,7 +361,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	}
 
 	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
-	end_unlink_async(ehci);
+	end_iaa_cycle(ehci);
 }
 
 

commit fcc5184ec1521c7d85124421e593660c94e9a9fb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jan 25 15:42:04 2016 -0500

    USB: EHCI: store reason for unlinking a QH
    
    This patch replaces the "exception" bitflag in the ehci_qh structure
    with a more explicit "unlink_reason" bitmask.  This is for use in the
    following patch, where we will need to have a good idea of the
    reason for unlinking a QH, not just "something exceptional happened".
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Michael Reutman <mreutman@epiqsolutions.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 424ac5d83714..37a3e0dece84 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -237,6 +237,7 @@ static void ehci_handle_start_intr_unlinks(struct ehci_hcd *ehci)
 				ehci->intr_unlink_wait_cycle))
 			break;
 		list_del_init(&qh->unlink_node);
+		qh->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;
 		start_unlink_intr(ehci, qh);
 	}
 

commit 9118f9eb4f1e97a135de3f78853c411befcf9775
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:10 2013 +0800

    USB: EHCI: improve interrupt qh unlink
    
    ehci-hcd currently unlinks an interrupt QH when it becomes empty, that
    is, after its last URB completes.  This works well because in almost
    all cases, the completion handler for an interrupt URB resubmits the
    URB; therefore the QH doesn't become empty and doesn't get unlinked.
    
    When we start using tasklets for URB completion, this scheme won't work
    as well.  The resubmission won't occur until the tasklet runs, which
    will be some time after the completion is queued with the tasklet.
    During that delay, the QH will be empty and so will be unlinked
    unnecessarily.
    
    To prevent this problem, this patch adds a 5-ms time delay before empty
    interrupt QHs are unlinked.  Most often, during that time the interrupt
    URB will be resubmitted and thus we can avoid unlinking the QH.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 11e5b32f73e9..424ac5d83714 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	5 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
@@ -215,6 +216,36 @@ static void ehci_handle_controller_death(struct ehci_hcd *ehci)
 	/* Not in process context, so don't try to reset the controller */
 }
 
+/* start to unlink interrupt QHs  */
+static void ehci_handle_start_intr_unlinks(struct ehci_hcd *ehci)
+{
+	bool		stopped = (ehci->rh_state < EHCI_RH_RUNNING);
+
+	/*
+	 * Process all the QHs on the intr_unlink list that were added
+	 * before the current unlink cycle began.  The list is in
+	 * temporal order, so stop when we reach the first entry in the
+	 * current cycle.  But if the root hub isn't running then
+	 * process all the QHs on the list.
+	 */
+	while (!list_empty(&ehci->intr_unlink_wait)) {
+		struct ehci_qh	*qh;
+
+		qh = list_first_entry(&ehci->intr_unlink_wait,
+				struct ehci_qh, unlink_node);
+		if (!stopped && (qh->unlink_cycle ==
+				ehci->intr_unlink_wait_cycle))
+			break;
+		list_del_init(&qh->unlink_node);
+		start_unlink_intr(ehci, qh);
+	}
+
+	/* Handle remaining entries later */
+	if (!list_empty(&ehci->intr_unlink_wait)) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_START_UNLINK_INTR, true);
+		++ehci->intr_unlink_wait_cycle;
+	}
+}
 
 /* Handle unlinked interrupt QHs once they are gone from the hardware */
 static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
@@ -236,7 +267,7 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 				unlink_node);
 		if (!stopped && qh->unlink_cycle == ehci->intr_unlink_cycle)
 			break;
-		list_del(&qh->unlink_node);
+		list_del_init(&qh->unlink_node);
 		end_unlink_intr(ehci, qh);
 	}
 
@@ -363,6 +394,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	ehci_handle_start_intr_unlinks,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */

commit 214ac7a0771d95d2f66d01bca5afeb2c9e8ac3c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:58 2013 -0400

    USB: EHCI: improve end_unlink_async()
    
    This patch (as1665) changes the way ehci-hcd's end_unlink_async()
    routine works in order to avoid recursive execution and to be more
    efficient:
    
            Now when an IAA cycle ends, a new one gets started up right
            away (if it is needed) instead of waiting until the
            just-unlinked QH has been processed.
    
            The async_iaa list is renamed to async_idle, which better
            expresses its new purpose: It is now the list of QHs which are
            now completely idle and are waiting to be processed by
            end_unlink_async().
    
            A new flag is added to track whether an IAA cycle is in
            progress, because the list formerly known as async_iaa no
            longer stores the QHs waiting for the IAA to finish.
    
            The decision about how many QHs to process when an IAA cycle
            ends is now made at the end of the cycle, when we know the
            current state of the hardware, rather than at the beginning.
            This means a bunch of logic got moved from start_iaa_cycle()
            to end_unlink_async().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f63a98353efd..11e5b32f73e9 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -304,7 +304,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci->rh_state != EHCI_RH_RUNNING)
+	if (!ehci->iaa_in_progress || ehci->rh_state != EHCI_RH_RUNNING)
 		return;
 
 	/* If we get here, IAA is *REALLY* late.  It's barely

commit 6e018751a35f6ef7ad04eb8006b5886b6a7c47f5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 22 13:31:45 2013 -0400

    USB: EHCI: convert singly-linked lists to list_heads
    
    This patch (as1664) converts ehci-hcd's async_unlink, async_iaa, and
    intr_unlink from singly-linked lists to standard doubly-linked
    list_heads.  Originally it didn't seem necessary to use list_heads,
    because items are always added to and removed from these lists in FIFO
    order.  But now with more list processing going on, it's easier to use
    the standard routines than continue with a roll-your-own approach.
    
    I don't know if the code ends up being notably shorter, but the
    patterns will be more familiar to any kernel hacker.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index e7363332887e..f63a98353efd 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -229,18 +229,19 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 	 * process all the QHs on the list.
 	 */
 	ehci->intr_unlinking = true;
-	while (ehci->intr_unlink) {
-		struct ehci_qh	*qh = ehci->intr_unlink;
+	while (!list_empty(&ehci->intr_unlink)) {
+		struct ehci_qh	*qh;
 
+		qh = list_first_entry(&ehci->intr_unlink, struct ehci_qh,
+				unlink_node);
 		if (!stopped && qh->unlink_cycle == ehci->intr_unlink_cycle)
 			break;
-		ehci->intr_unlink = qh->unlink_next;
-		qh->unlink_next = NULL;
+		list_del(&qh->unlink_node);
 		end_unlink_intr(ehci, qh);
 	}
 
 	/* Handle remaining entries later */
-	if (ehci->intr_unlink) {
+	if (!list_empty(&ehci->intr_unlink)) {
 		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
 		++ehci->intr_unlink_cycle;
 	}

commit 417c765af914106f5e76c4e0181dd555fe6a89a0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 21 12:48:42 2013 -0400

    USB: EHCI: fix up incorrect merge resolution
    
    This patch (as1671) fixes up an incorrect resolution of a merge
    conflict between Greg KH's usb-linus branch and his usb-next branch.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index dca8fc42b8d7..e7363332887e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -297,6 +297,15 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
 	u32 cmd, status;
 
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
 	/* If we get here, IAA is *REALLY* late.  It's barely
 	 * conceivable that the system is so busy that CMD_IAAD
 	 * is still legitimately set, so let's be sure it's

commit cf2d9500a5a0df61713b56f2f40aa0b81a6f9f63
Merge: 3f3b55bf7833 d714aaf64946
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Mar 20 16:21:47 2013 -0700

    Merge branch 'usb-linus' into usb-next
    
    This is to pick up the fixes in that branch, and let Alan fix the merge
    error in drivers/usb/host/ehci-timer.c better than I just did (as I know
    I messed it up...)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d714aaf649460cbfd5e82e75520baa856b4fa0a0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 20 15:07:26 2013 -0400

    USB: EHCI: fix regression in QH unlinking
    
    This patch (as1670) fixes a regression caused by commit
    6402c796d3b4205d3d7296157956c5100a05d7d6 (USB: EHCI: work around
    silicon bug in Intel's EHCI controllers).  The workaround goes through
    two IAA cycles for each QH being unlinked.  During the first cycle,
    the QH is not added to the async_iaa list (because it isn't fully gone
    from the hardware yet), which means that list will be empty.
    
    Unfortunately, I forgot to update the IAA watchdog timer routine.  It
    thinks that an empty async_iaa list means the timer expiration was an
    error, which isn't true any more.  This problem didn't show up during
    initial testing because the controllers being tested all had working
    IAA interrupts.  But not all controllers do, and when the watchdog
    timer expires, the empty-list check prevents the second IAA cycle from
    starting.  As a result, URB unlinks never complete.  The check needs
    to be removed.
    
    Among the symptoms of the regression are processes stuck in D wait
    states and hangs during system shutdown.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Reported-and-tested-by: Sven Joachim <svenjoac@gmx.de>
    Reported-by: Andreas Bombe <aeb@debian.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..c3fa1305f830 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -304,7 +304,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci->async_iaa) {
+	if (1) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely

commit 60fd4aa742a0c4f01dafeb0d125fed54e91e3657
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 18 12:05:19 2013 -0400

    USB: EHCI: reorganize ehci_iaa_watchdog()
    
    This patch (as1635) rearranges the control-flow logic in
    ehci_iaa_watchdog() slightly to agree better with the comments.  It
    also changes a verbose-debug message to a regular debug message.
    Expiration of the IAA watchdog is an unusual event and can lead to
    problems; we need to know about it if it happens during debugging.  It
    should not be necessary to set a "verbose" compilation option.
    
    No behavioral changes other than the debug message.  Lots of apparent
    changes to the source text, though, because the indentation level was
    decreased.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index cc9ad5892d19..97815d0fc97c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -295,8 +295,7 @@ static void end_free_itds(struct ehci_hcd *ehci)
 /* Handle lost (or very late) IAA interrupts */
 static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
-	if (ehci->rh_state != EHCI_RH_RUNNING)
-		return;
+	u32 cmd, status;
 
 	/*
 	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
@@ -304,34 +303,32 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci->async_iaa) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &ehci->regs->command);
-
-		/*
-		 * If IAA is set here it either legitimately triggered
-		 * after the watchdog timer expired (_way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &ehci->regs->status);
-		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
-			COUNT(ehci->stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
-		}
+	if (!ehci->async_iaa || ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/* If we get here, IAA is *REALLY* late.  It's barely
+	 * conceivable that the system is so busy that CMD_IAAD
+	 * is still legitimately set, so let's be sure it's
+	 * clear before we read STS_IAA.  (The HC should clear
+	 * CMD_IAAD when it sets STS_IAA.)
+	 */
+	cmd = ehci_readl(ehci, &ehci->regs->command);
 
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
+	/*
+	 * If IAA is set here it either legitimately triggered
+	 * after the watchdog timer expired (_way_ late, so we'll
+	 * still count it as lost) ... or a silicon erratum:
+	 * - VIA seems to set IAA without triggering the IRQ;
+	 * - IAAD potentially cleared without setting IAA.
+	 */
+	status = ehci_readl(ehci, &ehci->regs->status);
+	if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
+		COUNT(ehci->stats.lost_iaa);
+		ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 	}
+
+	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
+	end_unlink_async(ehci);
 }
 
 

commit 6d5df8976266d8e40603601f7695537f9f3dc9e2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 18 12:04:54 2013 -0400

    USB: EHCI: decrease schedule-status poll timeout
    
    This patch (as1657) decreases the timeout used by ehci-hcd for polling
    the async and periodic schedule statuses.  The timeout is currently
    set to 20 ms, which is much too high.  Controllers should always
    update the schedule status within one or two ms of being told to do
    so; if they don't then something is wrong.
    
    Furthermore, bug reports have shown that sometimes controllers
    (particularly those made by VIA) don't update the status bit at all,
    even when the schedule does change state.  When this happens, polling
    for 20 ms would cause an unnecessarily long delay.
    
    The delay is reduced to somewhere between 2 and 4 ms, depending on the
    slop allowed by the kernel's high-res timers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..cc9ad5892d19 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,8 +113,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci->ASS_poll_count++ < 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci->ASS_poll_count++ < 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
@@ -159,8 +159,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci->PSS_poll_count++ < 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci->PSS_poll_count++ < 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}

commit 221f8dfca89276d8aec54c6d07fbe20c281668f0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Feb 26 13:43:41 2013 -0500

    USB: EHCI: revert "remove ASS/PSS polling timeout"
    
    This patch (as1649) reverts commit
    55bcdce8a8228223ec4d17d8ded8134ed265d2c5 (USB: EHCI: remove ASS/PSS
    polling timeout).  That commit was written under the assumption that
    some controllers may take a very long time to turn off their async and
    periodic schedules.  It now appears that in fact the schedules do get
    turned off reasonably quickly, but some controllers occasionally leave
    the schedules' status bits turned on and consequently ehci-hcd can't
    tell that the schedules are off.
    
    VIA controllers in particular have this problem.  ehci-hcd tells the
    hardware to turn off the async schedule, the schedule does get turned
    off, but the status bit remains on.  Since the EHCI spec requires that
    the schedules not be re-enabled until the previous disable has taken
    effect, with an unlimited timeout the async schedule never gets turned
    back on.  The resulting symptom is that the system is unable to
    communicate with USB devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Ronald <ronald645@gmail.com>
    Reported-and-tested-by: Paul Hartman <paul.hartman@gmail.com>
    Reported-and-tested-by: Dieter Nützel <dieter@nuetzel-hh.de>
    Reported-and-tested-by: Jean Delvare <khali@linux-fr.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f904071d70df..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,15 +113,14 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-		++ehci->ASS_poll_count;
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci->ASS_poll_count++ < 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci->ASS_poll_count > 20)
-		ehci_dbg(ehci, "ASS poll count reached %d\n",
-				ehci->ASS_poll_count);
 	ehci->ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -160,14 +159,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci->PSS_poll_count++ < 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci->PSS_poll_count > 20)
-		ehci_dbg(ehci, "PSS poll count reached %d\n",
-				ehci->PSS_poll_count);
 	ehci->PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */

commit 55bcdce8a8228223ec4d17d8ded8134ed265d2c5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 25 16:52:45 2013 -0500

    USB: EHCI: remove ASS/PSS polling timeout
    
    This patch (as1647) attempts to work around a problem that seems to
    affect some nVidia EHCI controllers.  They sometimes take a very long
    time to turn off their async or periodic schedules.  I don't know if
    this is a result of other problems, but in any case it seems wise not
    to depend on schedule enables or disables taking effect in any
    specific length of time.
    
    The patch removes the existing 20-ms timeout for enabling and
    disabling the schedules.  The driver will now continue to poll the
    schedule state at 1-ms intervals until the controller finally decides
    to obey the most recent command issued by the driver.  Just in case
    this hides a problem, a debugging message will be logged if the
    controller takes longer than 20 polls.
    
    I don't know if this will actually fix anything, but it can't hurt.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Piergiorgio Sartor <piergiorgio.sartor@nexgo.de>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..f904071d70df 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,14 +113,15 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci->ASS_poll_count++ < 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+		++ehci->ASS_poll_count;
+		return;
 	}
+
+	if (ehci->ASS_poll_count > 20)
+		ehci_dbg(ehci, "ASS poll count reached %d\n",
+				ehci->ASS_poll_count);
 	ehci->ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -159,14 +160,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci->PSS_poll_count++ < 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+		return;
 	}
+
+	if (ehci->PSS_poll_count > 20)
+		ehci_dbg(ehci, "PSS poll count reached %d\n",
+				ehci->PSS_poll_count);
 	ehci->PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */

commit d16ba48774913d244c7eb894d28d8ae2c019a827
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Sep 19 17:02:29 2012 -0400

    USB: EHCI: convert warning messages to debug-level
    
    This patch (as1606) converts two warning messages in the ehci-hcd
    driver to debug messages, and adds a little extra information to each.
    
    The log messages occur when an EHCI controller takes too long (more
    than 20 ms) to turn its async or periodic schedule on or off.  If this
    happens at all, it's liable to happen quite often and there's no point
    spamming the system log with these warnings.  Furthermore, there's
    nothing much we can do about it when the problem happens.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Thomas Voegtle <tv@lio96.de>
    Cc: stable <stable@vger.kernel.org> # [3.6]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index eb896a2c8f2e..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -118,7 +118,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci->ASS_poll_count = 0;
 
@@ -163,7 +164,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the periodic schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci->PSS_poll_count = 0;
 

commit 18aafe64d75d0e27dae206cacf4171e4e485d285
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:04 2012 -0400

    USB: EHCI: use hrtimer for the I/O watchdog
    
    This patch (as1586) replaces the kernel timer used by ehci-hcd as an
    I/O watchdog with an hrtimer event.
    
    Unlike in the current code, the watchdog event is now always enabled
    whenever any isochronous URBs are active.  This will prevent bugs
    caused by the periodic schedule wrapping around with no completion
    interrupts; the watchdog handler is guaranteed to scan the isochronous
    transfers at least once during each iteration of the schedule.  The
    extra overhead will be negligible: one timer interrupt every 100 ms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0e28bae78d18..eb896a2c8f2e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -76,6 +76,7 @@ static unsigned event_delays_ns[] = {
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
+	100 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 /* Enable a pending hrtimer event */
@@ -332,6 +333,25 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 }
 
 
+/* Enable the I/O watchdog, if appropriate */
+static void turn_on_io_watchdog(struct ehci_hcd *ehci)
+{
+	/* Not needed if the controller isn't running or it's already enabled */
+	if (ehci->rh_state != EHCI_RH_RUNNING ||
+			(ehci->enabled_hrtimer_events &
+				BIT(EHCI_HRTIMER_IO_WATCHDOG)))
+		return;
+
+	/*
+	 * Isochronous transfers always need the watchdog.
+	 * For other sorts we use it only if the flag is set.
+	 */
+	if (ehci->isoc_count > 0 || (ehci->need_io_watchdog &&
+			ehci->async_count + ehci->intr_count > 0))
+		ehci_enable_event(ehci, EHCI_HRTIMER_IO_WATCHDOG, true);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -347,6 +367,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
+	ehci_work,			/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)

commit 569b394f53f0abd177cc665c9b4ace89e3f4c7fb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:23:00 2012 -0400

    USB: EHCI: always scan each interrupt QH
    
    This patch (as1585) fixes a bug in ehci-hcd's scheme for scanning
    interrupt QHs.
    
    Currently a single routine takes care of scanning everything on the
    periodic schedule.  Whenever an interrupt occurs, it scans all
    isochronous and interrupt URBs scheduled for frames that have elapsed
    since the last scan.
    
    This has two disadvantages.  The first is relatively minor: An
    interrupt QH is likely to end up getting scanned multiple times,
    particularly if the last scan was not fairly recent.  (The current
    code avoids this by maintaining a periodic_stamp in each interrupt
    QH.)
    
    The second is more serious.  The periodic schedule wraps around.  If
    the last scan occurred during frame N, and the next scan occurs when
    the schedule has gone through an entire cycle and is back at frame N,
    the scanning code won't look at any frames other than N.  Consequently
    it won't see any QHs that completed during frame N-1 or earlier.
    
    The patch replaces the entire frame-based approach for scanning
    interrupt QHs with a new routine using a list-based approach, the same
    as for async QHs.  This has a slight disadvantage, because it means
    that all interrupt QHs have to be scanned every time.  But it is more
    robust than the current approach.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index a823290b5139..0e28bae78d18 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -168,13 +168,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		if (ehci->periodic_count > 0) {
-
-			/* make sure ehci_work scans these */
-			ehci->next_uframe = ehci_read_frame_index(ehci)
-					& ((ehci->periodic_size << 3) - 1);
+		if (ehci->periodic_count > 0)
 			ehci_set_command_bit(ehci, CMD_PSE);
-		}
 
 	} else {		/* Running */
 		if (ehci->periodic_count == 0) {

commit 32830f207691176234b4c4dd17f0d7ab6d87d94b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:53 2012 -0400

    USB: EHCI: use hrtimer for unlinking empty async QHs
    
    This patch (as1583) changes ehci-hcd to use an hrtimer event for
    unlinking empty (unused) async QHs instead of using a kernel timer.
    
    The check for empty QHs is moved to a new routine, where it doesn't
    require going through an entire scan of both the async and periodic
    schedules.  And it can unlink multiple QHs at once, unlike the current
    code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8ca5f152f5bd..a823290b5139 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -347,6 +348,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */

commit 3c273a056bf46167f0a1309c2ba72282a17d2541
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:49 2012 -0400

    USB: EHCI: unlink multiple async QHs together
    
    This patch (as1582) changes ehci-hcd's strategy for unlinking async
    QHs.  Currently the driver never unlinks more than one QH at a time.
    This can be inefficient and cause unnecessary delays, since a QH
    cannot be reused while it is waiting to be unlinked.
    
    The new strategy unlinks all the waiting QHs at once.  In practice the
    improvement won't be very big, because it's somewhat uncommon to have
    two or more QHs waiting to be unlinked at any time.  But it does
    happen, and in any case, doing things this way makes more sense IMO.
    
    The change requires the async unlinking code to be refactored
    slightly.  Now in addition to the routines for starting and ending an
    unlink, there are new routines for unlinking a single QH and starting
    an IAA cycle.  This approach is needed because there are two separate
    paths for unlinking async QHs:
    
            When a transfer error occurs or an URB is cancelled, the QH
            must be unlinked right away;
    
            When a QH has been idle sufficiently long, it is unlinked
            to avoid consuming DMA bandwidth uselessly.
    
    In the first case we want the unlink to proceed as quickly as
    possible, whereas in the second case we can afford to batch several
    QHs together and unlink them all at once.  Hence the division of
    labor.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index aab042064226..8ca5f152f5bd 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -211,6 +211,7 @@ static void ehci_handle_controller_death(struct ehci_hcd *ehci)
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	ehci_work(ehci);
+	end_unlink_async(ehci);
 
 	/* Not in process context, so don't try to reset the controller */
 }
@@ -304,7 +305,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci->async_unlink) {
+	if (ehci->async_iaa) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely

commit 9d9387475af261949f61a5ec465e1f762d7be08a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:44 2012 -0400

    USB: EHCI: use hrtimer for the IAA watchdog
    
    This patch (as1581) replaces the iaa_watchdog kernel timer used by
    ehci-hcd with an hrtimer event, in keeping with the general conversion
    to high-res timers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8feb60ff4228..aab042064226 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -291,6 +292,49 @@ static void end_free_itds(struct ehci_hcd *ehci)
 }
 
 
+/* Handle lost (or very late) IAA interrupts */
+static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
+{
+	if (ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci->async_unlink) {
+		u32 cmd, status;
+
+		/* If we get here, IAA is *REALLY* late.  It's barely
+		 * conceivable that the system is so busy that CMD_IAAD
+		 * is still legitimately set, so let's be sure it's
+		 * clear before we read STS_IAA.  (The HC should clear
+		 * CMD_IAAD when it sets STS_IAA.)
+		 */
+		cmd = ehci_readl(ehci, &ehci->regs->command);
+
+		/*
+		 * If IAA is set here it either legitimately triggered
+		 * after the watchdog timer expired (_way_ late, so we'll
+		 * still count it as lost) ... or a silicon erratum:
+		 * - VIA seems to set IAA without triggering the IRQ;
+		 * - IAAD potentially cleared without setting IAA.
+		 */
+		status = ehci_readl(ehci, &ehci->regs->status);
+		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
+			COUNT(ehci->stats.lost_iaa);
+			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
+		}
+
+		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
+				status, cmd);
+		end_unlink_async(ehci);
+	}
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -302,6 +346,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };

commit 55934eb3b9fa52eb53b9d7342267fc73c38206aa
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:35 2012 -0400

    USB: EHCI: use hrtimer for (s)iTD deallocation
    
    This patch (as1579) adds an hrtimer event to handle deallocation of
    iTDs and siTDs in ehci-hcd.
    
    Because of the frame-oriented approach used by the EHCI periodic
    schedule, the hardware can continue to access the Transfer Descriptor
    for isochronous (or split-isochronous) transactions for up to a
    millisecond after the transaction completes.  The iTD (or siTD) must
    not be reused before then.
    
    The strategy currently used involves putting completed iTDs on a list
    of cached entries and every so often returning them to the endpoint's
    free list.  The new strategy reduces overhead by putting completed
    iTDs back on the free list immediately, although they are not reused
    until it is safe to do so.
    
    When the isochronous endpoint stops (its queue becomes empty), the
    iTDs on its free list get moved to a global list, from which they will
    be deallocated after a minimum of 2 ms.  This delay is what the new
    hrtimer event is for.
    
    Overall this may not be a tremendous improvement over the current
    code, but to me it seems a lot more clear and logical.  In addition,
    it removes the need for each iTD to keep a reference to the
    ehci_iso_stream it belongs to, since the iTD never needs to be moved
    back to the stream's free list from the global list.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0c5326a8883c..8feb60ff4228 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -71,6 +71,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
+	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -165,7 +166,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		free_cached_lists(ehci);
 		if (ehci->periodic_count > 0) {
 
 			/* make sure ehci_work scans these */
@@ -188,9 +188,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 static void ehci_disable_PSE(struct ehci_hcd *ehci)
 {
 	ehci_clear_command_bit(ehci, CMD_PSE);
-
-	/* Poll to see when it actually stops */
-	ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 }
 
 
@@ -250,6 +247,50 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 }
 
 
+/* Start another free-iTDs/siTDs cycle */
+static void start_free_itds(struct ehci_hcd *ehci)
+{
+	if (!(ehci->enabled_hrtimer_events & BIT(EHCI_HRTIMER_FREE_ITDS))) {
+		ehci->last_itd_to_free = list_entry(
+				ehci->cached_itd_list.prev,
+				struct ehci_itd, itd_list);
+		ehci->last_sitd_to_free = list_entry(
+				ehci->cached_sitd_list.prev,
+				struct ehci_sitd, sitd_list);
+		ehci_enable_event(ehci, EHCI_HRTIMER_FREE_ITDS, true);
+	}
+}
+
+/* Wait for controller to stop using old iTDs and siTDs */
+static void end_free_itds(struct ehci_hcd *ehci)
+{
+	struct ehci_itd		*itd, *n;
+	struct ehci_sitd	*sitd, *sn;
+
+	if (ehci->rh_state < EHCI_RH_RUNNING) {
+		ehci->last_itd_to_free = NULL;
+		ehci->last_sitd_to_free = NULL;
+	}
+
+	list_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {
+		list_del(&itd->itd_list);
+		dma_pool_free(ehci->itd_pool, itd, itd->itd_dma);
+		if (itd == ehci->last_itd_to_free)
+			break;
+	}
+	list_for_each_entry_safe(sitd, sn, &ehci->cached_sitd_list, sitd_list) {
+		list_del(&sitd->sitd_list);
+		dma_pool_free(ehci->sitd_pool, sitd, sitd->sitd_dma);
+		if (sitd == ehci->last_sitd_to_free)
+			break;
+	}
+
+	if (!list_empty(&ehci->cached_itd_list) ||
+			!list_empty(&ehci->cached_sitd_list))
+		start_free_itds(ehci);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -260,6 +301,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
+	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };

commit bf6387bcd16975ba8952b094f262a359d74e1c8a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:31 2012 -0400

    USB: EHCI: use hrtimer for controller death
    
    This patch (as1578) adds an hrtimer event to handle the death of an
    EHCI controller.  When a controller dies, it doesn't necessarily stop
    running right away.  The new event polls at 1-ms intervals to see when
    all activity has safely stopped.  This replaces a busy-wait polling
    loop in the current code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index bd8b591771b0..0c5326a8883c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -193,6 +194,30 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Poll the STS_HALT status bit; see when a dead controller stops */
+static void ehci_handle_controller_death(struct ehci_hcd *ehci)
+{
+	if (!(ehci_readl(ehci, &ehci->regs->status) & STS_HALT)) {
+
+		/* Give up after a few milliseconds */
+		if (ehci->died_poll_count++ < 5) {
+			/* Try again later */
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_DEAD, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the controller to stop, giving up\n");
+	}
+
+	/* Clean up the mess */
+	ehci->rh_state = EHCI_RH_HALTED;
+	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	ehci_work(ehci);
+
+	/* Not in process context, so don't try to reset the controller */
+}
+
+
 /* Handle unlinked interrupt QHs once they are gone from the hardware */
 static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 {
@@ -233,6 +258,7 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */

commit df2022553dd8d34d49e16c19d851ea619438f0ef
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:26 2012 -0400

    USB: EHCI: use hrtimer for interrupt QH unlink
    
    This patch (as1577) adds hrtimer support for unlinking interrupt QHs
    in ehci-hcd.  The current code relies on a fixed delay of either 2 or
    55 us, which is not always adequate and in any case is totally bogus.
    Thanks to internal caching, the EHCI hardware may continue to access
    an interrupt QH for more than a millisecond after it has been unlinked.
    
    In fact, the EHCI spec doesn't say how long to wait before using an
    unlinked interrupt QH.  The patch sets the delay to 9 microframes
    minimum, which ought to be adequate.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 1e907dd3bb1b..bd8b591771b0 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -192,6 +193,38 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Handle unlinked interrupt QHs once they are gone from the hardware */
+static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
+{
+	bool		stopped = (ehci->rh_state < EHCI_RH_RUNNING);
+
+	/*
+	 * Process all the QHs on the intr_unlink list that were added
+	 * before the current unlink cycle began.  The list is in
+	 * temporal order, so stop when we reach the first entry in the
+	 * current cycle.  But if the root hub isn't running then
+	 * process all the QHs on the list.
+	 */
+	ehci->intr_unlinking = true;
+	while (ehci->intr_unlink) {
+		struct ehci_qh	*qh = ehci->intr_unlink;
+
+		if (!stopped && qh->unlink_cycle == ehci->intr_unlink_cycle)
+			break;
+		ehci->intr_unlink = qh->unlink_next;
+		qh->unlink_next = NULL;
+		end_unlink_intr(ehci, qh);
+	}
+
+	/* Handle remaining entries later */
+	if (ehci->intr_unlink) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
+		++ehci->intr_unlink_cycle;
+	}
+	ehci->intr_unlinking = false;
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -200,6 +233,7 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };

commit 314466101c6ae14f6f5db8a86eda1509ba2c02a8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:21 2012 -0400

    USB: EHCI: use hrtimer for async schedule
    
    This patch (as1576) adds hrtimer support for managing ehci-hcd's
    async schedule.  Just as with the earlier change to the periodic
    schedule management, two new hrtimer events take care of everything.
    
    One event polls at 1-ms intervals to see when the Asynchronous
    Schedule Status (ASS) flag matches the Asynchronous Schedule Enable
    (ASE) value; the schedule's state must not be changed until it does.
    The other event delays for 15 ms after the async schedule becomes
    empty before turning it off.
    
    The new events replace a busy-wait poll and a kernel timer usage.
    They also replace the rather illogical method currently used for
    indicating the async schedule should be turned off: attempting to
    unlink the dedicated QH at the head of the async list.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index ecd3296157c6..1e907dd3bb1b 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -67,8 +67,10 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
  * the event types indexed by enum ehci_hrtimer_event in ehci.h.
  */
 static unsigned event_delays_ns[] = {
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 /* Enable a pending hrtimer event */
@@ -91,6 +93,51 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 }
 
 
+/* Poll the STS_ASS status bit; see when it agrees with CMD_ASE */
+static void ehci_poll_ASS(struct ehci_hcd *ehci)
+{
+	unsigned	actual, want;
+
+	/* Don't enable anything if the controller isn't running (e.g., died) */
+	if (ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
+	want = (ehci->command & CMD_ASE) ? STS_ASS : 0;
+	actual = ehci_readl(ehci, &ehci->regs->status) & STS_ASS;
+
+	if (want != actual) {
+
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci->ASS_poll_count++ < 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+	}
+	ehci->ASS_poll_count = 0;
+
+	/* The status is up-to-date; restart or stop the schedule as needed */
+	if (want == 0) {	/* Stopped */
+		if (ehci->async_count > 0)
+			ehci_set_command_bit(ehci, CMD_ASE);
+
+	} else {		/* Running */
+		if (ehci->async_count == 0) {
+
+			/* Turn off the schedule after a while */
+			ehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_ASYNC,
+					true);
+		}
+	}
+}
+
+/* Turn off the async schedule after a brief delay */
+static void ehci_disable_ASE(struct ehci_hcd *ehci)
+{
+	ehci_clear_command_bit(ehci, CMD_ASE);
+}
+
+
 /* Poll the STS_PSS status bit; see when it agrees with CMD_PSE */
 static void ehci_poll_PSS(struct ehci_hcd *ehci)
 {
@@ -151,8 +198,10 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
  * enum ehci_hrtimer_event in ehci.h.
  */
 static void (*event_handlers[])(struct ehci_hcd *) = {
+	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)

commit 3ca9aebac2ebb8f56d2d097636b8c568320a9f87
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:22:05 2012 -0400

    USB: EHCI: use hrtimer for the periodic schedule
    
    This patch (as1573) adds hrtimer support for managing ehci-hcd's
    periodic schedule.  There are two issues to deal with.
    
    First, the schedule's state (on or off) must not be changed until the
    hardware status has caught up with the current command.  This is
    handled by an hrtimer event that polls at 1-ms intervals to see when
    the Periodic Schedule Status (PSS) flag matches the Periodic Schedule
    Enable (PSE) value.
    
    Second, the schedule should not be turned off as soon as it becomes
    empty.  Turning the schedule on and off takes time, so we want to wait
    until the schedule has been empty for a suitable period before turning
    it off.  This is handled by an hrtimer event that gets set to expire
    10 ms after the periodic schedule becomes empty.
    
    The existing code polls (for up to 1125 us and with interrupts
    disabled!) to check the status, and doesn't implement a delay before
    turning off the schedule.  Furthermore, if the polling fails then the
    driver decides that the controller has died.  This has caused problems
    for several people; some controllers can take 10 ms or more to turn
    off their periodic schedules.
    
    This patch fixes these issues.  It also makes the "broken_periodic"
    workaround unnecessary; there is no longer any danger of turning off
    the periodic schedule after it has been on for less than 1 ms.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f6279e2883a8..ecd3296157c6 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -16,6 +16,28 @@
 
 /*-------------------------------------------------------------------------*/
 
+/* Set a bit in the USBCMD register */
+static void ehci_set_command_bit(struct ehci_hcd *ehci, u32 bit)
+{
+	ehci->command |= bit;
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+
+	/* unblock posted write */
+	ehci_readl(ehci, &ehci->regs->command);
+}
+
+/* Clear a bit in the USBCMD register */
+static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
+{
+	ehci->command &= ~bit;
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+
+	/* unblock posted write */
+	ehci_readl(ehci, &ehci->regs->command);
+}
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * EHCI timer support...  Now using hrtimers.
  *
@@ -45,6 +67,8 @@
  * the event types indexed by enum ehci_hrtimer_event in ehci.h.
  */
 static unsigned event_delays_ns[] = {
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 };
 
 /* Enable a pending hrtimer event */
@@ -67,12 +91,68 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 }
 
 
+/* Poll the STS_PSS status bit; see when it agrees with CMD_PSE */
+static void ehci_poll_PSS(struct ehci_hcd *ehci)
+{
+	unsigned	actual, want;
+
+	/* Don't do anything if the controller isn't running (e.g., died) */
+	if (ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
+	want = (ehci->command & CMD_PSE) ? STS_PSS : 0;
+	actual = ehci_readl(ehci, &ehci->regs->status) & STS_PSS;
+
+	if (want != actual) {
+
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci->PSS_poll_count++ < 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the periodic schedule status, giving up\n");
+	}
+	ehci->PSS_poll_count = 0;
+
+	/* The status is up-to-date; restart or stop the schedule as needed */
+	if (want == 0) {	/* Stopped */
+		free_cached_lists(ehci);
+		if (ehci->periodic_count > 0) {
+
+			/* make sure ehci_work scans these */
+			ehci->next_uframe = ehci_read_frame_index(ehci)
+					& ((ehci->periodic_size << 3) - 1);
+			ehci_set_command_bit(ehci, CMD_PSE);
+		}
+
+	} else {		/* Running */
+		if (ehci->periodic_count == 0) {
+
+			/* Turn off the schedule after a while */
+			ehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_PERIODIC,
+					true);
+		}
+	}
+}
+
+/* Turn off the periodic schedule after a brief delay */
+static void ehci_disable_PSE(struct ehci_hcd *ehci)
+{
+	ehci_clear_command_bit(ehci, CMD_PSE);
+
+	/* Poll to see when it actually stops */
+	ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
  * enum ehci_hrtimer_event in ehci.h.
  */
 static void (*event_handlers[])(struct ehci_hcd *) = {
+	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)

commit d58b4bcc6df8046cf9c3c59f9ff84d2cd86b93eb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 11 11:21:54 2012 -0400

    USB: EHCI: introduce high-res timer
    
    This patch (as1572) begins the conversion of ehci-hcd over to using
    high-resolution timers rather than old-fashioned low-resolution kernel
    timers.  This reduces overhead caused by timer roundoff on systems
    where HZ is smaller than 1000.  Also, the new timer framework
    introduced here is much more logical and easily extended than the
    ad-hoc approach ehci-hcd currently uses for timers.
    
    An hrtimer structure is added to ehci_hcd, along with a bitflag array
    and an array of ktime_t values, to keep track of which timing events
    are pending and what their expiration times are.
    
    Only the infrastructure for the timing operations is added in this
    patch.  Later patches will add routines for handling each of the
    various timing events the driver needs.  In some cases the new hrtimer
    handlers will replace the existing handlers for ehci-hcd's kernel
    timers; as this happens the old timers will be removed.  In other
    cases the new timing events will replace busy-wait loops.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
new file mode 100644
index 000000000000..f6279e2883a8
--- /dev/null
+++ b/drivers/usb/host/ehci-timer.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 by Alan Stern
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/* This file is part of ehci-hcd.c */
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * EHCI timer support...  Now using hrtimers.
+ *
+ * Lots of different events are triggered from ehci->hrtimer.  Whenever
+ * the timer routine runs, it checks each possible event; events that are
+ * currently enabled and whose expiration time has passed get handled.
+ * The set of enabled events is stored as a collection of bitflags in
+ * ehci->enabled_hrtimer_events, and they are numbered in order of
+ * increasing delay values (ranging between 1 ms and 100 ms).
+ *
+ * Rather than implementing a sorted list or tree of all pending events,
+ * we keep track only of the lowest-numbered pending event, in
+ * ehci->next_hrtimer_event.  Whenever ehci->hrtimer gets restarted, its
+ * expiration time is set to the timeout value for this event.
+ *
+ * As a result, events might not get handled right away; the actual delay
+ * could be anywhere up to twice the requested delay.  This doesn't
+ * matter, because none of the events are especially time-critical.  The
+ * ones that matter most all have a delay of 1 ms, so they will be
+ * handled after 2 ms at most, which is okay.  In addition to this, we
+ * allow for an expiration range of 1 ms.
+ */
+
+/*
+ * Delay lengths for the hrtimer event types.
+ * Keep this list sorted by delay length, in the same order as
+ * the event types indexed by enum ehci_hrtimer_event in ehci.h.
+ */
+static unsigned event_delays_ns[] = {
+};
+
+/* Enable a pending hrtimer event */
+static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
+		bool resched)
+{
+	ktime_t		*timeout = &ehci->hr_timeouts[event];
+
+	if (resched)
+		*timeout = ktime_add(ktime_get(),
+				ktime_set(0, event_delays_ns[event]));
+	ehci->enabled_hrtimer_events |= (1 << event);
+
+	/* Track only the lowest-numbered pending event */
+	if (event < ehci->next_hrtimer_event) {
+		ehci->next_hrtimer_event = event;
+		hrtimer_start_range_ns(&ehci->hrtimer, *timeout,
+				NSEC_PER_MSEC, HRTIMER_MODE_ABS);
+	}
+}
+
+
+/*
+ * Handler functions for the hrtimer event types.
+ * Keep this array in the same order as the event types indexed by
+ * enum ehci_hrtimer_event in ehci.h.
+ */
+static void (*event_handlers[])(struct ehci_hcd *) = {
+};
+
+static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
+{
+	struct ehci_hcd	*ehci = container_of(t, struct ehci_hcd, hrtimer);
+	ktime_t		now;
+	unsigned long	events;
+	unsigned long	flags;
+	unsigned	e;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+
+	events = ehci->enabled_hrtimer_events;
+	ehci->enabled_hrtimer_events = 0;
+	ehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
+
+	/*
+	 * Check each pending event.  If its time has expired, handle
+	 * the event; otherwise re-enable it.
+	 */
+	now = ktime_get();
+	for_each_set_bit(e, &events, EHCI_HRTIMER_NUM_EVENTS) {
+		if (now.tv64 >= ehci->hr_timeouts[e].tv64)
+			event_handlers[e](ehci);
+		else
+			ehci_enable_event(ehci, e, false);
+	}
+
+	spin_unlock_irqrestore(&ehci->lock, flags);
+	return HRTIMER_NORESTART;
+}
