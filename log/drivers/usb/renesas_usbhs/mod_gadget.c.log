commit 16c8373ecf7b3c723a8e765d798ea413bc8345a6
Merge: d19f1d44e743 a99d8080aaf3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 4 06:41:09 2019 +0100

    Merge 5.4-rc6 into usb-next
    
    We need the USB fixes in here to build on top of.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e92f30ac37d12756aeb733538ad85df2be7e139f
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Oct 15 16:30:17 2019 +0100

    usb: renesas_usbhs: fix type of buf
    
    Fix the type of buf in __usbhsg_recip_send_status to
    be __le16 to avoid the following sparse warning:
    
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14: warning: incorrect type in assignment (different base types)
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14:    expected unsigned short
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14:    got restricted __le16 [usertype]
    
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index efc40bc1f68c..cd38d74b3223 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -315,7 +315,7 @@ static void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usb_request *req;
-	unsigned short *buf;
+	__le16 *buf;
 
 	/* alloc new usb_request for recip */
 	req = usb_ep_alloc_request(&dcp->ep, GFP_ATOMIC);

commit 20ee71cc374a4933808f735354cb4fd949d657c7
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Oct 16 13:14:33 2019 +0900

    usb: renesas_usbhs: Fix warnings in usbhsg_recip_handler_std_set_device()
    
    This patch fixes the following sparse warnings by shifting 8-bits after
    le16_to_cpu().
    
    drivers/usb/renesas_usbhs/mod_gadget.c:268:47: warning: restricted __le16 degrades to integer
    drivers/usb/renesas_usbhs/mod_gadget.c:268:47: warning: cast to restricted __le16
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index e5ef56991dba..efc40bc1f68c 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -265,7 +265,7 @@ static int usbhsg_recip_handler_std_set_device(struct usbhs_priv *priv,
 	case USB_DEVICE_TEST_MODE:
 		usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
 		udelay(100);
-		usbhs_sys_set_test_mode(priv, le16_to_cpu(ctrl->wIndex >> 8));
+		usbhs_sys_set_test_mode(priv, le16_to_cpu(ctrl->wIndex) >> 8);
 		break;
 	default:
 		usbhsg_recip_handler_std_control_done(priv, uep, ctrl);

commit 67f195806afcb17e46a4578130526602d3465781
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Oct 15 16:30:17 2019 +0100

    usb: renesas_usbhs: fix type of buf
    
    Fix the type of buf in __usbhsg_recip_send_status to
    be __le16 to avoid the following sparse warning:
    
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14: warning: incorrect type in assignment (different base types)
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14:    expected unsigned short
    drivers/usb/renesas_usbhs/mod_gadget.c:335:14:    got restricted __le16 [usertype]
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Link: https://lore.kernel.org/r/20191015153017.10858-1-ben.dooks@codethink.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index b47e70ffeda6..72eda9f926fe 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -315,7 +315,7 @@ static void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usb_request *req;
-	unsigned short *buf;
+	__le16 *buf;
 
 	/* alloc new usb_request for recip */
 	req = usb_ep_alloc_request(&dcp->ep, GFP_ATOMIC);

commit bf7c1d95af67254957d1820ac112397001e1a9a9
Merge: 1141a7522e39 4f5cafb5cb84
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 14 07:09:59 2019 +0200

    Merge 5.4-rc3 into usb-next
    
    we want the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d599cd3a097a85a5c68a2c82b9a48cddf9953ec
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Oct 1 19:10:33 2019 +0900

    usb: renesas_usbhs: gadget: Fix usb_ep_set_{halt,wedge}() behavior
    
    According to usb_ep_set_halt()'s description,
    __usbhsg_ep_set_halt_wedge() should return -EAGAIN if the IN endpoint
    has any queue or data. Otherwise, this driver is possible to cause
    just STALL without sending a short packet data on g_mass_storage driver,
    and then a few resetting a device happens on a host side during
    a usb enumaration.
    
    Fixes: 2f98382dcdfe ("usb: renesas_usbhs: Add Renesas USBHS Gadget")
    Cc: <stable@vger.kernel.org> # v3.0+
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/1569924633-322-3-git-send-email-yoshihiro.shimoda.uh@renesas.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 2c7523a211c0..e5ef56991dba 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -722,6 +722,7 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	unsigned long flags;
+	int ret = 0;
 
 	dev_dbg(dev, "set halt %d (pipe %d)\n",
 		halt, usbhs_pipe_number(pipe));
@@ -729,6 +730,18 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	/********************  spin lock ********************/
 	usbhs_lock(priv, flags);
 
+	/*
+	 * According to usb_ep_set_halt()'s description, this function should
+	 * return -EAGAIN if the IN endpoint has any queue or data. Note
+	 * that the usbhs_pipe_is_dir_in() returns false if the pipe is an
+	 * IN endpoint in the gadget mode.
+	 */
+	if (!usbhs_pipe_is_dir_in(pipe) && (__usbhsf_pkt_get(pipe) ||
+	    usbhs_pipe_contains_transmittable_data(pipe))) {
+		ret = -EAGAIN;
+		goto out;
+	}
+
 	if (halt)
 		usbhs_pipe_stall(pipe);
 	else
@@ -739,10 +752,11 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	else
 		usbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);
 
+out:
 	usbhs_unlock(priv, flags);
 	/********************  spin unlock ******************/
 
-	return 0;
+	return ret;
 }
 
 static int usbhsg_ep_set_halt(struct usb_ep *ep, int value)

commit 1aae1394294cb71c6aa0bc904a94a7f2f1e75936
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Oct 1 19:10:32 2019 +0900

    usb: renesas_usbhs: gadget: Do not discard queues in usb_ep_set_{halt,wedge}()
    
    The commit 97664a207bc2 ("usb: renesas_usbhs: shrink spin lock area")
    had added a usbhsg_pipe_disable() calling into
    __usbhsg_ep_set_halt_wedge() accidentally. But, this driver should
    not call the usbhsg_pipe_disable() because the function discards
    all queues. So, this patch removes it.
    
    Fixes: 97664a207bc2 ("usb: renesas_usbhs: shrink spin lock area")
    Cc: <stable@vger.kernel.org> # v3.1+
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/1569924633-322-2-git-send-email-yoshihiro.shimoda.uh@renesas.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 4d571a5205e2..2c7523a211c0 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -723,8 +723,6 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	unsigned long flags;
 
-	usbhsg_pipe_disable(uep);
-
 	dev_dbg(dev, "set halt %d (pipe %d)\n",
 		halt, usbhs_pipe_number(pipe));
 

commit 39abcc84846bbc0538f13c190b6a9c7e36890cd2
Author: Veeraiyan Chidambaram <veeraiyan.chidambaram@in.bosch.com>
Date:   Wed Sep 11 15:15:56 2019 +0200

    usb: renesas_usbhs: add suspend event support in gadget mode
    
    When R-Car Gen3 USB 2.0 is in Gadget mode, if host is detached an interrupt
    will be generated and Suspended state bit is set in interrupt status
    register. Interrupt handler will call driver->suspend(composite_suspend)
    if suspended state bit is set. composite_suspend will call
    ffs_func_suspend which will post FUNCTIONFS_SUSPEND and will be consumed
    by user space application via /dev/ep0.
    
    To be able to detect host detach, extend the DVSQ_MASK to cover the
    Suspended bit of the DVSQ[2:0] bitfield from the Interrupt Status
    Register 0 (INTSTS0) register and perform appropriate action in the
    DVST interrupt handler (usbhsg_irq_dev_state).
    
    Without this commit, disconnection of the phone from R-Car-H3 ES2.0
    Salvator-X CN9 port is not recognized and reverse role switch does
    not happen. If phone is connected again it does not enumerate.
    
    With this commit, disconnection will be recognized and reverse role
    switch will happen by a user space application. If phone is connected
    again it will enumerate properly and will become visible in the output
    of 'lsusb'.
    
    Signed-off-by: Veeraiyan Chidambaram <veeraiyan.chidambaram@in.bosch.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Link: https://lore.kernel.org/r/1568207756-22325-3-git-send-email-external.veeraiyan.c@de.adit-jv.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 4d571a5205e2..1235f3c1f62a 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -457,12 +457,18 @@ static int usbhsg_irq_dev_state(struct usbhs_priv *priv,
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	int state = usbhs_status_get_device_state(irq_state);
 
 	gpriv->gadget.speed = usbhs_bus_get_speed(priv);
 
-	dev_dbg(dev, "state = %x : speed : %d\n",
-		usbhs_status_get_device_state(irq_state),
-		gpriv->gadget.speed);
+	dev_dbg(dev, "state = %x : speed : %d\n", state, gpriv->gadget.speed);
+
+	if (gpriv->gadget.speed != USB_SPEED_UNKNOWN &&
+	    (state & SUSPENDED_STATE)) {
+		if (gpriv->driver && gpriv->driver->suspend)
+			gpriv->driver->suspend(&gpriv->gadget);
+		usb_gadget_set_state(&gpriv->gadget, USB_STATE_SUSPENDED);
+	}
 
 	return 0;
 }

commit ccc3264c2481c9bcbacfe935dc024aaab4423204
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Jun 25 14:38:48 2019 +0900

    usb: renesas_usbhs: Avoid to write platform_data's value
    
    The very old commit 482982062f1b ("usb: gadget: renesas_usbhs:
    bugfix: don't modify platform data") changed to use copied whole
    structures values to fix the "hung-up" issue. However, we also
    can fix the issue if the driver copies the get_vbus function
    pointer to the driver's value.
    
    So, this patch adds get_vbus member into struct usbhs_mod_info and
    use the pointer instead of struct renesas_usbhs_platform_callback.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 0c1e8fa528fc..4d571a5205e2 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -915,8 +915,8 @@ static void usbhs_mod_phy_mode(struct usbhs_priv *priv)
 {
 	struct usbhs_mod_info *info = &priv->mod_info;
 
-	info->irq_vbus		= NULL;
-	priv->pfunc.get_vbus	= usbhsm_phy_get_vbus;
+	info->irq_vbus = NULL;
+	info->get_vbus = usbhsm_phy_get_vbus;
 
 	usbhs_irq_callback_update(priv, NULL);
 }

commit 0966648dd5a5f4037d29d233866b7a4db39d07f7
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Jun 25 14:38:46 2019 +0900

    usb: renesas_usbhs: remove notify_hotplug callback
    
    The notify_hotplug callback was supported in v3.10, but the last user
    (armadillo800eva) was removed by the commit 1fa59bda21c7 ("ARM: shmobile:
    Remove legacy board code for Armadillo-800 EVA"). So, this patch
    removes it.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 59cac40aafcc..0c1e8fa528fc 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -3,6 +3,7 @@
  * Renesas USB driver
  *
  * Copyright (C) 2011 Renesas Solutions Corp.
+ * Copyright (C) 2019 Renesas Electronics Corporation
  * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
  */
 #include <linux/delay.h>
@@ -1023,7 +1024,7 @@ static int usbhsg_vbus_session(struct usb_gadget *gadget, int is_active)
 
 	gpriv->vbus_active = !!is_active;
 
-	renesas_usbhs_call_notify_hotplug(pdev);
+	usbhsc_schedule_notify_hotplug(pdev);
 
 	return 0;
 }

commit 25b22e353c1f8d48e69fdef70a31be2f0d2bc410
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Jun 28 13:37:22 2018 -0500

    USB: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 33d059c40616..59cac40aafcc 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -502,6 +502,7 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 	case READ_STATUS_STAGE:
 	case WRITE_STATUS_STAGE:
 		usbhs_dcp_control_transfer_done(pipe);
+		/* fall through */
 	default:
 		return ret;
 	}

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 34ee9ebe12a3..33d059c40616 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1068,7 +1068,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	if (!gpriv)
 		return -ENOMEM;
 
-	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
+	uep = kcalloc(pipe_size, sizeof(struct usbhsg_uep), GFP_KERNEL);
 	if (!uep) {
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;

commit 1250413a81612f49a0ae9f89342108c625779280
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:12 2017 +0100

    USB: renesas_usbhs: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Simon Horman <horms+renesas@verge.net.au>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chanwoo Choi <cw00.choi@samsung.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    Cc: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 019bbc8bf9b2..34ee9ebe12a3 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -4,16 +4,6 @@
  *
  * Copyright (C) 2011 Renesas Solutions Corp.
  * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  */
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c068b673420b..019bbc8bf9b2 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-1.0+
 /*
  * Renesas USB driver
  *

commit 34a0036748257dd97b22b76ef64aa44559f2ef6f
Merge: a85c0f8db332 0852659ef071
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 22 13:16:06 2017 -0700

    Merge tag 'usb-for-v4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: changes for v4.14 merge window
    
    Not a big pull request this time around. Only 49 non-merge
    commits. This pull request is, however, all over the place. Most of
    the changes are in the bdc driver adding support for USB Phy layer and
    PM.
    
    Renesas adds support for R-Car H3 ES2.0 and R-Car M3-W SoCs.
    
    Also here is PM_RUNTIME support for dwc3-keystone.
    
    UDC Core got a DMA unmap fix to make sure we only unmap requests that
    were, indeed, mapped.
    
    Other than these, we have a lot of cleanups, many of them adding
    'const' to several places.

commit 14a8d4bfc2102f85ce097563d151370c91c1898a
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Aug 9 19:55:24 2017 +0900

    usb: renesas_usbhs: gadget: fix spin_lock_init() for &uep->lock
    
    This patch fixes an issue that the spin_lock_init() is not called
    for almost all pipes. Otherwise, the lockdep output the following
    message when we connect a usb cable using g_ncm:
    
     INFO: trying to register non-static key.
     the code is fine but needs lockdep annotation.
     turning off the locking correctness validator.
    
    Reported-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    Fixes: b8b9c974afee ("usb: renesas_usbhs: gadget: disable all eps when the driver stops")
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index b45b9f1e3d9d..ea9c5451d3f8 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1085,7 +1085,6 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}
-	spin_lock_init(&uep->lock);
 
 	gpriv->transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
 	dev_info(dev, "%stransceiver found\n",
@@ -1135,6 +1134,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		uep->ep.name		= uep->ep_name;
 		uep->ep.ops		= &usbhsg_ep_ops;
 		INIT_LIST_HEAD(&uep->ep.ep_list);
+		spin_lock_init(&uep->lock);
 
 		/* init DCP */
 		if (usbhsg_is_dcp(uep)) {

commit 7fc461378cad592e8e606cce2b05b917982539fc
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 17:34:53 2017 +0530

    usb: renesas_usbhs: gadget: make usb_ep_ops const
    
    Make the structure const as it is only stored in the ops field of a
    usb_ep structure, which is of type const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 93fba9033b00..b45b9f1e3d9d 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -767,7 +767,7 @@ static int usbhsg_ep_set_wedge(struct usb_ep *ep)
 	return __usbhsg_ep_set_halt_wedge(ep, 1, 1);
 }
 
-static struct usb_ep_ops usbhsg_ep_ops = {
+static const struct usb_ep_ops usbhsg_ep_ops = {
 	.enable		= usbhsg_ep_enable,
 	.disable	= usbhsg_ep_disable,
 

commit b7d44c36a6f6d956e1539e0dd42f98b26e5a4684
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Fri Jul 28 19:28:57 2017 +0900

    usb: renesas_usbhs: gadget: fix unused-but-set-variable warning
    
    The commit b8b9c974afee ("usb: renesas_usbhs: gadget: disable all eps
    when the driver stops") causes the unused-but-set-variable warning.
    But, if the usbhsg_ep_disable() will return non-zero value, udc/core.c
    doesn't clear the ep->enabled flag. So, this driver should not return
    non-zero value, if the pipe is zero because this means the pipe is
    already disabled. Otherwise, the ep->enabled flag is never cleared
    when the usbhsg_ep_disable() is called by the renesas_usbhs driver first.
    
    Fixes: b8b9c974afee ("usb: renesas_usbhs: gadget: disable all eps when the driver stops")
    Fixes: 11432050f070 ("usb: renesas_usbhs: gadget: fix NULL pointer dereference in ep_disable()")
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 93fba9033b00..2c8161bcf5b5 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -639,14 +639,11 @@ static int usbhsg_ep_disable(struct usb_ep *ep)
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhs_pipe *pipe;
 	unsigned long flags;
-	int ret = 0;
 
 	spin_lock_irqsave(&uep->lock, flags);
 	pipe = usbhsg_uep_to_pipe(uep);
-	if (!pipe) {
-		ret = -EINVAL;
+	if (!pipe)
 		goto out;
-	}
 
 	usbhsg_pipe_disable(uep);
 	usbhs_pipe_free(pipe);

commit b8b9c974afee685789fcbb191b52d1790be3608c
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Jul 19 16:16:55 2017 +0900

    usb: renesas_usbhs: gadget: disable all eps when the driver stops
    
    A gadget driver will not disable eps immediately when ->disconnect()
    is called. But, since this driver assumes all eps stop after
    the ->disconnect(), unexpected behavior happens (especially in system
    suspend).
    So, this patch disables all eps in usbhsg_try_stop(). After disabling
    eps by renesas_usbhs driver, since some functions will be called by
    both a gadget and renesas_usbhs driver, renesas_usbhs driver should
    protect uep->pipe. To protect uep->pipe easily, this patch adds a new
    lock in struct usbhsg_uep.
    
    Fixes: 2f98382dc ("usb: renesas_usbhs: Add Renesas USBHS Gadget")
    Cc: <stable@vger.kernel.org> # v3.0+
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 5bc7a6138855..93fba9033b00 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -37,6 +37,7 @@ struct usbhsg_gpriv;
 struct usbhsg_uep {
 	struct usb_ep		 ep;
 	struct usbhs_pipe	*pipe;
+	spinlock_t		lock;	/* protect the pipe */
 
 	char ep_name[EP_NAME_SIZE];
 
@@ -636,10 +637,16 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pipe *pipe;
+	unsigned long flags;
+	int ret = 0;
 
-	if (!pipe)
-		return -EINVAL;
+	spin_lock_irqsave(&uep->lock, flags);
+	pipe = usbhsg_uep_to_pipe(uep);
+	if (!pipe) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	usbhsg_pipe_disable(uep);
 	usbhs_pipe_free(pipe);
@@ -647,6 +654,9 @@ static int usbhsg_ep_disable(struct usb_ep *ep)
 	uep->pipe->mod_private	= NULL;
 	uep->pipe		= NULL;
 
+out:
+	spin_unlock_irqrestore(&uep->lock, flags);
+
 	return 0;
 }
 
@@ -696,8 +706,11 @@ static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pipe *pipe;
+	unsigned long flags;
 
+	spin_lock_irqsave(&uep->lock, flags);
+	pipe = usbhsg_uep_to_pipe(uep);
 	if (pipe)
 		usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));
 
@@ -706,6 +719,7 @@ static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 	 * even if the pipe is NULL.
 	 */
 	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
+	spin_unlock_irqrestore(&uep->lock, flags);
 
 	return 0;
 }
@@ -852,10 +866,10 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
-	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct usbhsg_uep *uep;
 	struct device *dev = usbhs_priv_to_dev(priv);
 	unsigned long flags;
-	int ret = 0;
+	int ret = 0, i;
 
 	/********************  spin lock ********************/
 	usbhs_lock(priv, flags);
@@ -887,7 +901,9 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	usbhs_sys_set_test_mode(priv, 0);
 	usbhs_sys_function_ctrl(priv, 0);
 
-	usbhsg_ep_disable(&dcp->ep);
+	/* disable all eps */
+	usbhsg_for_each_uep_with_dcp(uep, gpriv, i)
+		usbhsg_ep_disable(&uep->ep);
 
 	dev_dbg(dev, "stop gadget\n");
 
@@ -1069,6 +1085,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}
+	spin_lock_init(&uep->lock);
 
 	gpriv->transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
 	dev_info(dev, "%stransceiver found\n",

commit 81522637485dd6ec9de4279c9714d58f884b6091
Merge: 54a2ec67f1db e6be244a8321
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Sep 14 20:37:50 2016 +0200

    Merge tag 'usb-for-v4.9' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v4.9 merge window
    
    This time around we have 92 non-merge commits. Most
    of the changes are in drivers/usb/gadget (40.3%)
    with drivers/usb/gadget/function being the most
    active directory (27.2%).
    
    As for UDC drivers, only dwc3 (26.5%) and dwc2
    (12.7%) have really been active.
    
    The most important changes for dwc3 are better
    support for scatterlist and, again, throughput
    improvements. While on dwc2 got some minor stability
    fixes related to soft reset and FIFO usage.
    
    Felipe Tonello has done some good work fixing up our
    f_midi gadget and Tal Shorer has implemented a nice
    API change for our ULPI bus.
    
    Apart from these, we have our usual set of
    non-critical fixes, spelling fixes, build warning
    fixes, etc.

commit 9b0dd49e3565ddc71346ba7d57079ee6233d0780
Merge: 3112fdde68fa c6935931c189
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 5 08:07:58 2016 +0200

    Merge 4.8-rc5 into usb-testing
    
    We want the USB fixes in here for testing and merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ee5acabf5805612c72084276e0c215367a042d71
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Aug 22 17:48:28 2016 +0900

    usb: renesas_usbhs: set quirk_avoids_skb_reserve if USB-DMAC is used
    
    This patch sets the quirk_avoids_skb_reserve flag to improve performance
    of a network gadget driver (e.g. f_ncm.c) if USB-DMAC is used.
    
    For example (on r8a7795 board + f_ncm.c + iperf udp mode / receiving):
      - without this patch:  90.3 Mbits/sec
      - with    this patch: 273   Mbits/sec
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 8e326ac00c9f..5732998de92a 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1102,6 +1102,8 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.max_speed		= USB_SPEED_HIGH;
+	gpriv->gadget.quirk_avoids_skb_reserve = usbhs_get_dparam(priv,
+								has_usb_dmac);
 
 	INIT_LIST_HEAD(&gpriv->gadget.ep_list);
 

commit 7d80e4be1e50d2c5c6e314c9c555810374305f82
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 25 19:39:28 2016 +0200

    usb: renesas_usbhs: mod_gadget: don't print on ENOMEM
    
    All kmalloc-based functions print enough information on failures.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 92bc83b92d10..8e326ac00c9f 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -335,7 +335,6 @@ static void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,
 	buf = kmalloc(sizeof(*buf), GFP_ATOMIC);
 	if (!buf) {
 		usb_ep_free_request(&dcp->ep, req);
-		dev_err(dev, "recip data allocation fail\n");
 		return;
 	}
 
@@ -1062,14 +1061,11 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	int ret;
 
 	gpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);
-	if (!gpriv) {
-		dev_err(dev, "Could not allocate gadget priv\n");
+	if (!gpriv)
 		return -ENOMEM;
-	}
 
 	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
 	if (!uep) {
-		dev_err(dev, "Could not allocate ep\n");
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}

commit cb73db7d719b29e944e1394808fc5891604b908a
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 25 19:39:28 2016 +0200

    usb: renesas_usbhs: mod_gadget: don't print on ENOMEM
    
    All kmalloc-based functions print enough information on failures.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 92bc83b92d10..8e326ac00c9f 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -335,7 +335,6 @@ static void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,
 	buf = kmalloc(sizeof(*buf), GFP_ATOMIC);
 	if (!buf) {
 		usb_ep_free_request(&dcp->ep, req);
-		dev_err(dev, "recip data allocation fail\n");
 		return;
 	}
 
@@ -1062,14 +1061,11 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	int ret;
 
 	gpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);
-	if (!gpriv) {
-		dev_err(dev, "Could not allocate gadget priv\n");
+	if (!gpriv)
 		return -ENOMEM;
-	}
 
 	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
 	if (!uep) {
-		dev_err(dev, "Could not allocate ep\n");
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}

commit 3295235fd70ed6d594aadee8c892a14f6a4b2d2e
Author: Wei Yongjun <weiyj.lk@gmail.com>
Date:   Sat Aug 13 01:28:24 2016 +0000

    usb: renesas_usbhs: gadget: fix return value check in usbhs_mod_gadget_probe()
    
    In case of error, the function usb_get_phy() returns ERR_PTR() and never
    returns NULL. The NULL test in the return value check should be replaced
    with IS_ERR().
    
    Fixes: b5a2875605ca ("usb: renesas_usbhs: Allow an OTG PHY driver to
            provide VBUS")
    Cc: <stable@vger.kernel.org> # v4.3+
    Acked-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Wei Yongjun <weiyj.lk@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 92bc83b92d10..c4c64740a3e7 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1076,7 +1076,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 
 	gpriv->transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
 	dev_info(dev, "%stransceiver found\n",
-		 gpriv->transceiver ? "" : "no ");
+		 !IS_ERR(gpriv->transceiver) ? "" : "no ");
 
 	/*
 	 * CAUTION

commit 9ab967e6db7412b675ecbff80d5371d53c82cb2e
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Aug 8 21:50:52 2016 +0900

    usb: renesas_usbhs: clear the BRDYSTS in usbhsg_ep_enable()
    
    This patch fixes an issue that unexpected BRDY interruption happens
    when the usb_ep_{enable,disable}() are called with different direction.
    In this case, the driver will cause the following message:
    
     renesas_usbhs e6590000.usb: irq_ready run_error 1 : -16
    
    This issue causes the followings:
     1) A pipe is enabled as transmission
     2) The pipe sent a data
     3) The pipe is disabled and re-enabled as reception.
     4) The pipe got a queue
    
    Since the driver doesn't clear the BRDYSTS flags after 2) above, the issue
    happens. If we add such clearing the flags into the driver, the code will
    become complicate. So, this patch clears the BRDYSTS flag of reception in
    usbhsg_ep_enable() to avoid complicate.
    
    Cc: <stable@vger.kernel.org> # v4.1+ (usbhs_xxxsts_clear() is needed)
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 50f3363cc382..92bc83b92d10 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -617,10 +617,13 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		 * use dmaengine if possible.
 		 * It will use pio handler if impossible.
 		 */
-		if (usb_endpoint_dir_in(desc))
+		if (usb_endpoint_dir_in(desc)) {
 			pipe->handler = &usbhs_fifo_dma_push_handler;
-		else
+		} else {
 			pipe->handler = &usbhs_fifo_dma_pop_handler;
+			usbhs_xxxsts_clear(priv, BRDYSTS,
+					   usbhs_pipe_number(pipe));
+		}
 
 		ret = 0;
 	}

commit 15e4292a2d21e9997fdb2b8c014cc461b3f268f0
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Jun 8 16:32:50 2016 +0900

    usb: renesas_usbhs: protect the CFIFOSEL setting in usbhsg_ep_enable()
    
    This patch fixes an issue that the CFIFOSEL register value is possible
    to be changed by usbhsg_ep_enable() wrongly. And then, a data transfer
    using CFIFO may not work correctly.
    
    For example:
     # modprobe g_multi file=usb-storage.bin
     # ifconfig usb0 192.168.1.1 up
     (During the USB host is sending file to the mass storage)
     # ifconfig usb0 down
    
    In this case, since the u_ether.c may call usb_ep_enable() in
    eth_stop(), if the renesas_usbhs driver is also using CFIFO for
    mass storage, the mass storage may not work correctly.
    
    So, this patch adds usbhs_lock() and usbhs_unlock() calling in
    usbhsg_ep_enable() to protect CFIFOSEL register. This is because:
     - CFIFOSEL.CURPIPE = 0 is also needed for the pipe configuration
     - The CFIFOSEL (fifo->sel) is already protected by usbhs_lock()
    
    Fixes: 97664a207bc2 ("usb: renesas_usbhs: shrink spin lock area")
    Cc: <stable@vger.kernel.org> # v3.1+
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 30345c2d01be..50f3363cc382 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -585,6 +585,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
+	unsigned long flags;
+
+	usbhs_lock(priv, flags);
 
 	/*
 	 * if it already have pipe,
@@ -593,7 +596,8 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	if (uep->pipe) {
 		usbhs_pipe_clear(uep->pipe);
 		usbhs_pipe_sequence_data0(uep->pipe);
-		return 0;
+		ret = 0;
+		goto usbhsg_ep_enable_end;
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
@@ -621,6 +625,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		ret = 0;
 	}
 
+usbhsg_ep_enable_end:
+	usbhs_unlock(priv, flags);
+
 	return ret;
 }
 

commit b41d8a6a014fba420a428244e04699b9c77a44f1
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Apr 18 16:53:42 2016 +0900

    usb: renesas_usbhs: use usb_gadget_{un}map_request_by_dev() for IPMMU
    
    The previous code could use the first USB-DMAC with IPMMU if iommus
    property was set into this device node. However, in this case, it
    could not control the second USB-DMAC with IPMMU because a parameter
    of IPMMU (micro-TLB id) is different with each USB-DMAC.
    
    So, this patch uses the usb_gadget_{un}map_request_by_dev() APIs for
    IPMMU. (Then, iommus property should be set into USB-DMAC node(s).)
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index d701ae643ace..30345c2d01be 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -197,8 +197,6 @@ static int usbhsg_dma_map_ctrl(struct device *dma_dev, struct usbhs_pkt *pkt,
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
 	struct usb_request *req = &ureq->req;
 	struct usbhs_pipe *pipe = pkt->pipe;
-	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	enum dma_data_direction dir;
 	int ret = 0;
 
@@ -208,13 +206,13 @@ static int usbhsg_dma_map_ctrl(struct device *dma_dev, struct usbhs_pkt *pkt,
 		/* it can not use scatter/gather */
 		WARN_ON(req->num_sgs);
 
-		ret = usb_gadget_map_request(&gpriv->gadget, req, dir);
+		ret = usb_gadget_map_request_by_dev(dma_dev, req, dir);
 		if (ret < 0)
 			return ret;
 
 		pkt->dma = req->dma;
 	} else {
-		usb_gadget_unmap_request(&gpriv->gadget, req, dir);
+		usb_gadget_unmap_request_by_dev(dma_dev, req, dir);
 	}
 
 	return ret;

commit c3cdcac786ae8ce9221a05609952d14aa57c27f7
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Apr 18 16:53:41 2016 +0900

    usb: renesas_usbhs: change arguments of dma_map_ctrl()
    
    Since usbhsg_dma_map_ctrl() needs DMA device structure in the near future,
    this patch changes arguments of dma_map_ctrl() to give such data.
    (This patch is only change the argument.)
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 53d104b56ef1..d701ae643ace 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -191,7 +191,8 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 /*
  *		dma map/unmap
  */
-static int usbhsg_dma_map_ctrl(struct usbhs_pkt *pkt, int map)
+static int usbhsg_dma_map_ctrl(struct device *dma_dev, struct usbhs_pkt *pkt,
+			       int map)
 {
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
 	struct usb_request *req = &ureq->req;

commit 4fccb0767fdbdb781a9c5b5c15ee7b219443c89d
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Apr 4 20:40:20 2016 +0900

    usb: renesas_usbhs: fix to avoid using a disabled ep in usbhsg_queue_done()
    
    This patch fixes an issue that usbhsg_queue_done() may cause kernel
    panic when dma callback is running and usb_ep_disable() is called
    by interrupt handler. (Especially, we can reproduce this issue using
    g_audio with usb-dmac driver.)
    
    For example of a flow:
     usbhsf_dma_complete (on tasklet)
      --> usbhsf_pkt_handler (on tasklet)
       --> usbhsg_queue_done (on tasklet)
        *** interrupt happened and usb_ep_disable() is called ***
        --> usbhsg_queue_pop (on tasklet)
         Then, oops happened.
    
    Fixes: e73a989 ("usb: renesas_usbhs: add DMAEngine support")
    Cc: <stable@vger.kernel.org> # v3.1+
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 664b263e4b20..53d104b56ef1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -158,10 +158,14 @@ static void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
+	unsigned long flags;
 
 	ureq->req.actual = pkt->actual;
 
-	usbhsg_queue_pop(uep, ureq, 0);
+	usbhs_lock(priv, flags);
+	if (uep)
+		__usbhsg_queue_pop(uep, ureq, 0);
+	usbhs_unlock(priv, flags);
 }
 
 static void usbhsg_queue_push(struct usbhsg_uep *uep,

commit 11ebf3ad3b871d262491790e3b273e963d4c3c28
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Thu Mar 3 18:35:51 2016 +0900

    usb: renesas_usbhs: gadget: fix giveback status code in usbhsg_pipe_disable()
    
    A udc driver should set the giveback status to -ESHUTDOWN in
    usb_ep_disable(). Otherwise, a gadget driver (e.g. g_serial) might
    request next data wrongly and it is possible to cause kernel panic.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 657f9672ceba..664b263e4b20 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -561,7 +561,7 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 		if (!pkt)
 			break;
 
-		usbhsg_queue_pop(uep, usbhsg_pkt_to_ureq(pkt), -ECONNRESET);
+		usbhsg_queue_pop(uep, usbhsg_pkt_to_ureq(pkt), -ESHUTDOWN);
 	}
 
 	usbhs_pipe_disable(pipe);

commit 64c5f48b100e92f189a32b6d660e3329681ec9b5
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Nov 18 14:34:10 2015 +0900

    usb: renesas_usbhs: Modify ep.caps.type_xxx and usb_ep_maxpacket_limit()
    
    This patch modifies the ep.caps.type_{iso,bulk,int} setting and
    the second argument of usb_ep_maxpacket_limit() using
    the dparam.pipe_configs.
    
    In the previous code, all the type_{iso,bulk,int} were set to true.
    However, to avoid waste time for finding suitable pipe in usb_ep_enable(),
    this driver should set correct type.
    Also the second argument of usb_ep_maxpacket_limit() was set to 512
    even if the pipe is isochronous or interrupt. So, this driver could
    not bind a gadget driver like the g_audio driver.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 8f7a78e70975..657f9672ceba 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1042,6 +1042,8 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	struct usbhsg_gpriv *gpriv;
 	struct usbhsg_uep *uep;
 	struct device *dev = usbhs_priv_to_dev(priv);
+	struct renesas_usbhs_driver_pipe_config *pipe_configs =
+					usbhs_get_dparam(priv, pipe_configs);
 	int pipe_size = usbhs_get_dparam(priv, pipe_size);
 	int i;
 	int ret;
@@ -1111,13 +1113,16 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 			gpriv->gadget.ep0 = &uep->ep;
 			usb_ep_set_maxpacket_limit(&uep->ep, 64);
 			uep->ep.caps.type_control = true;
-		}
-		/* init normal pipe */
-		else {
-			usb_ep_set_maxpacket_limit(&uep->ep, 512);
-			uep->ep.caps.type_iso = true;
-			uep->ep.caps.type_bulk = true;
-			uep->ep.caps.type_int = true;
+		} else {
+			/* init normal pipe */
+			if (pipe_configs[i].type == USB_ENDPOINT_XFER_ISOC)
+				uep->ep.caps.type_iso = true;
+			if (pipe_configs[i].type == USB_ENDPOINT_XFER_BULK)
+				uep->ep.caps.type_bulk = true;
+			if (pipe_configs[i].type == USB_ENDPOINT_XFER_INT)
+				uep->ep.caps.type_int = true;
+			usb_ep_set_maxpacket_limit(&uep->ep,
+						   pipe_configs[i].bufsize);
 			list_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);
 		}
 		uep->ep.caps.dir_in = true;

commit c9eb29503e9655e70448bbbf3697d08a56d24854
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Nov 18 14:33:35 2015 +0900

    usb: renesas_usbhs: gadget: Fix NULL pointer dereference in usbhsg_ep_dequeue()
    
    This patch fixes an issue that NULL pointer dereference happens when
    a gadget driver calls usb_ep_dequeue() for ep0 after disconnected
    a usb cable. This is because that usbhsg_try_stop() will call
    usbhsg_ep_disable(&dcp->ep) when a usb cable is disconnected and
    the pipe of dcp (ep0) is set to NULL.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index de4f97d84a82..8f7a78e70975 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -131,7 +131,8 @@ static void __usbhsg_queue_pop(struct usbhsg_uep *uep,
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
-	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
+	if (pipe)
+		dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
 
 	ureq->req.status = status;
 	spin_unlock(usbhs_priv_to_lock(priv));
@@ -685,7 +686,13 @@ static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 
-	usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));
+	if (pipe)
+		usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));
+
+	/*
+	 * To dequeue a request, this driver should call the usbhsg_queue_pop()
+	 * even if the pipe is NULL.
+	 */
 	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
 
 	return 0;

commit 916f7ac5dbc312969a90bc35a5f4fcbfc2965d60
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Jul 31 16:00:47 2015 +0200

    usb: renesas: gadget: add ep capabilities support
    
    Convert endpoint configuration to new capabilities model.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 494dfe06bb27..de4f97d84a82 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1103,12 +1103,18 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		if (usbhsg_is_dcp(uep)) {
 			gpriv->gadget.ep0 = &uep->ep;
 			usb_ep_set_maxpacket_limit(&uep->ep, 64);
+			uep->ep.caps.type_control = true;
 		}
 		/* init normal pipe */
 		else {
 			usb_ep_set_maxpacket_limit(&uep->ep, 512);
+			uep->ep.caps.type_iso = true;
+			uep->ep.caps.type_bulk = true;
+			uep->ep.caps.type_int = true;
 			list_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);
 		}
+		uep->ep.caps.dir_in = true;
+		uep->ep.caps.dir_out = true;
 	}
 
 	ret = usb_add_gadget_udc(dev, &gpriv->gadget);

commit b5a2875605cac14a7d7744ec8254547a26c02612
Author: Phil Edworthy <phil.edworthy@renesas.com>
Date:   Mon Jul 13 16:30:18 2015 +0100

    usb: renesas_usbhs: Allow an OTG PHY driver to provide VBUS
    
    These changes allow a PHY driver to trigger a VBUS interrupt and
    to provide the value of VBUS.
    
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Phil Edworthy <phil.edworthy@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index dc2aa3261202..494dfe06bb27 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -21,6 +21,7 @@
 #include <linux/platform_device.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
 #include "common.h"
 
 /*
@@ -50,6 +51,8 @@ struct usbhsg_gpriv {
 	int			 uep_size;
 
 	struct usb_gadget_driver	*driver;
+	struct usb_phy		*transceiver;
+	bool			 vbus_active;
 
 	u32	status;
 #define USBHSG_STATUS_STARTED		(1 << 0)
@@ -872,6 +875,27 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	return 0;
 }
 
+/*
+ * VBUS provided by the PHY
+ */
+static int usbhsm_phy_get_vbus(struct platform_device *pdev)
+{
+	struct usbhs_priv *priv = usbhs_pdev_to_priv(pdev);
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+
+	return  gpriv->vbus_active;
+}
+
+static void usbhs_mod_phy_mode(struct usbhs_priv *priv)
+{
+	struct usbhs_mod_info *info = &priv->mod_info;
+
+	info->irq_vbus		= NULL;
+	priv->pfunc.get_vbus	= usbhsm_phy_get_vbus;
+
+	usbhs_irq_callback_update(priv, NULL);
+}
+
 /*
  *
  *		linux usb function
@@ -882,12 +906,28 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	struct device *dev = usbhs_priv_to_dev(priv);
+	int ret;
 
 	if (!driver		||
 	    !driver->setup	||
 	    driver->max_speed < USB_SPEED_FULL)
 		return -EINVAL;
 
+	/* connect to bus through transceiver */
+	if (!IS_ERR_OR_NULL(gpriv->transceiver)) {
+		ret = otg_set_peripheral(gpriv->transceiver->otg,
+					&gpriv->gadget);
+		if (ret) {
+			dev_err(dev, "%s: can't bind to transceiver\n",
+				gpriv->gadget.name);
+			return ret;
+		}
+
+		/* get vbus using phy versions */
+		usbhs_mod_phy_mode(priv);
+	}
+
 	/* first hook up the driver ... */
 	gpriv->driver = driver;
 
@@ -900,6 +940,10 @@ static int usbhsg_gadget_stop(struct usb_gadget *gadget)
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
 	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
+
+	if (!IS_ERR_OR_NULL(gpriv->transceiver))
+		otg_set_peripheral(gpriv->transceiver->otg, NULL);
+
 	gpriv->driver = NULL;
 
 	return 0;
@@ -947,12 +991,26 @@ static int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)
 	return 0;
 }
 
+static int usbhsg_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	struct platform_device *pdev = usbhs_priv_to_pdev(priv);
+
+	gpriv->vbus_active = !!is_active;
+
+	renesas_usbhs_call_notify_hotplug(pdev);
+
+	return 0;
+}
+
 static const struct usb_gadget_ops usbhsg_gadget_ops = {
 	.get_frame		= usbhsg_get_frame,
 	.set_selfpowered	= usbhsg_set_selfpowered,
 	.udc_start		= usbhsg_gadget_start,
 	.udc_stop		= usbhsg_gadget_stop,
 	.pullup			= usbhsg_pullup,
+	.vbus_session		= usbhsg_vbus_session,
 };
 
 static int usbhsg_start(struct usbhs_priv *priv)
@@ -994,6 +1052,10 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}
 
+	gpriv->transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
+	dev_info(dev, "%stransceiver found\n",
+		 gpriv->transceiver ? "" : "no ");
+
 	/*
 	 * CAUTION
 	 *

commit 00f30d29b497577954b20237b405e9d22b5286c2
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Mon Mar 16 16:36:48 2015 +0900

    usb: renesas_usbhs: fix spinlock suspected in a gadget complete function
    
    According to the gadget.h, a "complete" function will always be called
    with interrupts disabled. However, sometimes usbhsg_queue_pop() function
    is called with interrupts enabled. So, this function should be held by
    usbhs_lock() to disable interruption. Also, this driver has to call
    spin_unlock() to avoid spinlock recursion by this driver before calling
    usb_gadget_giveback_request().
    Otherwise, there is possible to cause a spinlock suspected in a gadget
    complete function.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index e0384af77e56..dc2aa3261202 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -119,18 +119,34 @@ struct usbhsg_recip_handle {
 /*
  *		queue push/pop
  */
-static void usbhsg_queue_pop(struct usbhsg_uep *uep,
-			     struct usbhsg_request *ureq,
-			     int status)
+static void __usbhsg_queue_pop(struct usbhsg_uep *uep,
+			       struct usbhsg_request *ureq,
+			       int status)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
 	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
 
 	ureq->req.status = status;
+	spin_unlock(usbhs_priv_to_lock(priv));
 	usb_gadget_giveback_request(&uep->ep, &ureq->req);
+	spin_lock(usbhs_priv_to_lock(priv));
+}
+
+static void usbhsg_queue_pop(struct usbhsg_uep *uep,
+			     struct usbhsg_request *ureq,
+			     int status)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	unsigned long flags;
+
+	usbhs_lock(priv, flags);
+	__usbhsg_queue_pop(uep, ureq, status);
+	usbhs_unlock(priv, flags);
 }
 
 static void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)

commit a17fd41206a6d3efc565d8319405692325874884
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Jan 28 16:32:28 2015 +0800

    usb: renesas_usbhs: gadget: set value for common is_selfpowered
    
    Set value for common is_selfpowered.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 8697e6efcabf..e0384af77e56 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -926,6 +926,8 @@ static int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)
 	else
 		usbhsg_status_clr(gpriv, USBHSG_STATUS_SELF_POWERED);
 
+	gadget->is_selfpowered = (is_self != 0);
+
 	return 0;
 }
 

commit cdeb79431331ff0eb5a8b6a31923497aa56d25a7
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Nov 4 10:05:45 2014 +0900

    usb: renesas_usbhs: fix usbhs_pipe_clear() for DCP PIPE
    
    Since the DCPCTR doesn't have the ACLRM bit, the usbus_pipe_clear()
    should not call the usbhsp_pipectrl_set() with ACLRM.
    So, this patch fixes this issue to add the usbhs_fifo_clear_dcp()
    in fifo.c because the controller needs the CFIFO to clear the
    the DCP PIPE.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 2457306e0924..8697e6efcabf 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -782,9 +782,9 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	/*
 	 * pipe initialize and enable DCP
 	 */
+	usbhs_fifo_init(priv);
 	usbhs_pipe_init(priv,
 			usbhsg_dma_map_ctrl);
-	usbhs_fifo_init(priv);
 
 	/* dcp init instead of usbhsg_ep_enable() */
 	dcp->pipe		= usbhs_dcp_malloc(priv);

commit 4ef35b10bff24304a5cbbf78719ce5f24d311d1f
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Nov 4 10:05:44 2014 +0900

    usb: renesas_usbhs: fix the timing of dcp_control_transfer_done
    
    According to the datasheet, this driver should clear the INTSTS0.CTRT
    bit before this controller detects the next stage transition. Otherwise,
    the driver may not be able to clear the bit after the controller went to
    the next stage transition. After that, the driver will not be able to
    clear the INTSTS0.VALID, and a usb control transfer will not finish
    finally.
    
    If we use the testusb tool, it is easy to reproduce this issue:
    
     # testusb -a -t 10
    
    Since the previous code handled a data stage and a status stage in
    the usbhsf_pio_try_push(), it may not clear the INTSTS0.CTRT at the
    right timing.
    So, this patch change the timing of usbhs_dcp_control_transfer_done()
    to the usbhsg_irq_ctrl_stage().
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index cb2d529e3a33..2457306e0924 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -485,6 +485,9 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 	case NODATA_STATUS_STAGE:
 		pipe->handler = &usbhs_ctrl_stage_end_handler;
 		break;
+	case READ_STATUS_STAGE:
+	case WRITE_STATUS_STAGE:
+		usbhs_dcp_control_transfer_done(pipe);
 	default:
 		return ret;
 	}

commit 04a5def3df1cea758662615e075f64677690c75f
Author: Takeshi Kihara <takeshi.kihara.df@renesas.com>
Date:   Tue Nov 4 10:05:43 2014 +0900

    usb: renesas_usbhs: gadget: fix the behavior of pullup
    
    This patch fixes an issue that this driver always enable the D+ pullup
    after it detected the VBUS connection even though this usb controller
    can control the D+ pullup timing by software. So, this driver should
    enable the D+ pullup after a gadget driver called usb_gadget_connect().
    
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    Signed-off-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ac51b594590d..cb2d529e3a33 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -56,6 +56,7 @@ struct usbhsg_gpriv {
 #define USBHSG_STATUS_REGISTERD		(1 << 1)
 #define USBHSG_STATUS_WEDGE		(1 << 2)
 #define USBHSG_STATUS_SELF_POWERED	(1 << 3)
+#define USBHSG_STATUS_SOFT_CONNECT	(1 << 4)
 };
 
 struct usbhsg_recip_handle {
@@ -725,6 +726,25 @@ static struct usb_ep_ops usbhsg_ep_ops = {
 	.set_wedge	= usbhsg_ep_set_wedge,
 };
 
+/*
+ *		pullup control
+ */
+static int usbhsg_can_pullup(struct usbhs_priv *priv)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+
+	return gpriv->driver &&
+	       usbhsg_status_has(gpriv, USBHSG_STATUS_SOFT_CONNECT);
+}
+
+static void usbhsg_update_pullup(struct usbhs_priv *priv)
+{
+	if (usbhsg_can_pullup(priv))
+		usbhs_sys_function_pullup(priv, 1);
+	else
+		usbhs_sys_function_pullup(priv, 0);
+}
+
 /*
  *		usb module start/end
  */
@@ -775,6 +795,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * - usb module
 	 */
 	usbhs_sys_function_ctrl(priv, 1);
+	usbhsg_update_pullup(priv);
 
 	/*
 	 * enable irq callback
@@ -880,8 +901,15 @@ static int usbhsg_pullup(struct usb_gadget *gadget, int is_on)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	unsigned long flags;
 
-	usbhs_sys_function_pullup(priv, is_on);
+	usbhs_lock(priv, flags);
+	if (is_on)
+		usbhsg_status_set(gpriv, USBHSG_STATUS_SOFT_CONNECT);
+	else
+		usbhsg_status_clr(gpriv, USBHSG_STATUS_SOFT_CONNECT);
+	usbhsg_update_pullup(priv);
+	usbhs_unlock(priv, flags);
 
 	return 0;
 }

commit 11432050f070810ba139d0226344eef120c3a559
Author: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
Date:   Tue Nov 4 10:05:42 2014 +0900

    usb: renesas_usbhs: gadget: fix NULL pointer dereference in ep_disable()
    
    This patch fixes an issue that the NULL pointer dereference happens
    when we uses g_audio driver. Since the g_audio driver will call
    usb_ep_disable() in afunc_set_alt() before it calls usb_ep_enable(),
    the uep->pipe of renesas usbhs driver will be NULL. So, this patch
    adds a condition to avoid the oops.
    
    Signed-off-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Fixes: 2f98382dc (usb: renesas_usbhs: Add Renesas USBHS Gadget)
    Cc: <stable@vger.kernel.org> # v3.0+
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 7a4521030505..ac51b594590d 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -602,6 +602,9 @@ static int usbhsg_ep_disable(struct usb_ep *ep)
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 
+	if (!pipe)
+		return -EINVAL;
+
 	usbhsg_pipe_disable(uep);
 	usbhs_pipe_free(pipe);
 

commit 22835b807e7ca946a4d1fbd4c7af56aa09cd273e
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Oct 17 12:05:12 2014 -0500

    usb: gadget: remove unnecessary 'driver' argument
    
    now that no UDC driver relies on the extra
    'driver' argument to ->udc_stop(), we can
    safely remove it.
    
    This commit is based on previous work by
    Robert Baldyga <r.baldyga@samsung.com> which
    can be found at [1]; however that patch turned
    out to have a high probability of regressing
    many UDC drivers because of a blind search & replace
    s/driver/$udc->driver/ which caused the 'driver'
    argument to stop_activity() to be a valid non-NULL
    pointer when it should be NULL, thus causing UDCs
    to mistakenly call gadget driver's ->disconnect()
    callback.
    
    [1] http://markmail.org/message/x5zneg4xea4zntab
    
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 2d17c10a0428..7a4521030505 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -851,8 +851,7 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 	return usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);
 }
 
-static int usbhsg_gadget_stop(struct usb_gadget *gadget,
-		struct usb_gadget_driver *driver)
+static int usbhsg_gadget_stop(struct usb_gadget *gadget)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);

commit 304f7e5e1d08fa2f5674c1323bd0ebd806c86b81
Author: Michal Sojka <sojka@merica.cz>
Date:   Wed Sep 24 22:43:19 2014 +0200

    usb: gadget: Refactor request completion
    
    Use the recently introduced usb_gadget_giveback_request() in favor of
    direct invocation of the completion routine.
    
    All places in drivers/usb/ matching "[-.]complete(" were replaced with a
    call to usb_gadget_giveback_request(). This was compile-tested with all
    ARM drivers enabled and runtime-tested for musb.
    
    Signed-off-by: Michal Sojka <sojka@merica.cz>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 04e6505777d0..2d17c10a0428 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -129,7 +129,7 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
 
 	ureq->req.status = status;
-	ureq->req.complete(&uep->ep, &ureq->req);
+	usb_gadget_giveback_request(&uep->ep, &ureq->req);
 }
 
 static void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)

commit dfb87b8bfe09f933abaf387693992089f6f9053e
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Jul 9 20:30:13 2014 +0900

    usb: renesas_usbhs: gadget: fix re-enabling pipe without re-connecting
    
    This patch fixes an issue that the renesas_usbhs driver in gadget mode
    cannot work correctly even if I disabled DMAC of the driver when I used
    the g_zero driver and the testusb tool.
    
    When a usb cable is re-connected, the renesas_usbhs driver calls the
    usbhsp_flags_init() (via usbhs_hotplug() --> usbhs_mod_call(start) -->
    usbhsg_try_start() --> usbhs_pipe_init()). However, the driver doesn't
    call the usbhsp_flags_init() when usbhsg_ep_disable() is called.
    So, if a gadget driver calls usb_ep_enable() and usb_ep_disable() again
    and again, the renesas_usbhs driver will output the following log:
    
      renesas_usbhs renesas_usbhs: can't get pipe (BULK)
      renesas_usbhs renesas_usbhs: wrong recip request
    
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 458f3766bef1..04e6505777d0 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -600,8 +600,10 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 
 	usbhsg_pipe_disable(uep);
+	usbhs_pipe_free(pipe);
 
 	uep->pipe->mod_private	= NULL;
 	uep->pipe		= NULL;

commit e117e742d310683b410951faeab4b13b6c3c609f
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Fri Dec 13 12:23:38 2013 +0100

    usb: gadget: add "maxpacket_limit" field to struct usb_ep
    
    This patch adds "maxpacket_limit" to struct usb_ep. This field contains
    maximum value of maxpacket supported by driver, and is set in driver probe.
    This value should be used by autoconfig() function, because value of field
    "maxpacket" is set to value from endpoint descriptor when endpoint becomes
    enabled. So when autoconfig() function will be called again for this endpoint,
    "maxpacket" value will contain wMaxPacketSize from descriptior instead of
    maximum packet size for this endpoint.
    
    For this reason this patch adds new field "maxpacket_limit" which contains
    value of maximum packet size (which defines maximum endpoint capabilities).
    This value is used in ep_matches() function used by autoconfig().
    
    Value of "maxpacket_limit" should be set in UDC driver probe function, using
    usb_ep_set_maxpacket_limit() function, defined in gadget.h. This function
    set choosen value to both "maxpacket_limit" and "maxpacket" fields.
    
    This patch modifies UDC drivers by adding support for maxpacket_limit.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 3385aeb5a364..458f3766bef1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -987,11 +987,11 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		/* init DCP */
 		if (usbhsg_is_dcp(uep)) {
 			gpriv->gadget.ep0 = &uep->ep;
-			uep->ep.maxpacket = 64;
+			usb_ep_set_maxpacket_limit(&uep->ep, 64);
 		}
 		/* init normal pipe */
 		else {
-			uep->ep.maxpacket = 512;
+			usb_ep_set_maxpacket_limit(&uep->ep, 512);
 			list_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);
 		}
 	}

commit 925403f425a4a9c503f2fc295652647b1eb10d82
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jul 11 22:32:31 2013 -0700

    usb: renesas_usbhs: tidyup original usbhsx_for_each_xxx macro
    
    Current usbhsx_for_each_xxx macro will read out-of-array's
    memory after last loop operation.
    It was not good C language operation, and the binary which was
    compiled by (at least) gcc 4.8.1 is broken
    This patch tidyup these issues
    
    Reported-by: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Reviewed-by: Takashi Yoshii <takashi.yoshii.zj@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 805940c37353..3385aeb5a364 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -77,9 +77,9 @@ struct usbhsg_recip_handle {
 		struct usbhsg_gpriv, mod)
 
 #define __usbhsg_for_each_uep(start, pos, g, i)	\
-	for (i = start, pos = (g)->uep + i;	\
-	     i < (g)->uep_size;			\
-	     i++, pos = (g)->uep + i)
+	for ((i) = start;					\
+	     ((i) < (g)->uep_size) && ((pos) = (g)->uep + (i));	\
+	     (i)++)
 
 #define usbhsg_for_each_uep(pos, gpriv, i)	\
 	__usbhsg_for_each_uep(1, pos, gpriv, i)

commit 8047806e64ea7b33fcede5b93f7276568a6119e8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 8 22:47:37 2013 -0700

    usb: renesas_usbhs: gadget: remove extra check on udc_stop
    
    usb_gadget_ops :: udc_stop might be called with driver = NULL since
    511f3c5326eabe1ece35202a404c24c0aeacc246
    (usb: gadget: udc-core: fix a regression during gadget driver unbinding)
    
    Because of that, 2nd times insmod goes fail.
    This patch fixes it up.
    
    Reported-by: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ed4949faa70d..805940c37353 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -855,10 +855,6 @@ static int usbhsg_gadget_stop(struct usb_gadget *gadget,
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
-	if (!driver		||
-	    !driver->unbind)
-		return -EINVAL;
-
 	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
 	gpriv->driver = NULL;
 

commit 225da3e3cb1f0db9e4cb7fa2a7dc3a360d1cf788
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Mar 31 18:34:43 2013 -0700

    usb: renesas_usbhs: fixup sparse errors for common.c
    
    This patch fixup below sparse errors
    
    CHECK   ${RENESAS_USB}/common.c
    ${RENESAS_USB}/common.c:313:17: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:322:17: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:384:17: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:524:9: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:545:9: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:574:9: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/common.c:606:9: error: incompatible types in conditional expression (different base types)
    ${RENESAS_USB}/mod_gadget.c:233:28: warning: symbol 'req_clear_feature' was not declared. Should it be static?
    ${RENESAS_USB}/mod_gadget.c:274:28: warning: symbol 'req_set_feature' was not declared. Should it be static?
    ${RENESAS_USB}/mod_gadget.c:375:28: warning: symbol 'req_get_status' was not declared. Should it be static?
    
    [ balbi@ti.com : added three sparse fixes to mod_gadget.c ]
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c2781bc9dabe..ed4949faa70d 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -230,7 +230,7 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 	return 0;
 }
 
-struct usbhsg_recip_handle req_clear_feature = {
+static struct usbhsg_recip_handle req_clear_feature = {
 	.name		= "clear feature",
 	.device		= usbhsg_recip_handler_std_control_done,
 	.interface	= usbhsg_recip_handler_std_control_done,
@@ -271,7 +271,7 @@ static int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,
 	return 0;
 }
 
-struct usbhsg_recip_handle req_set_feature = {
+static struct usbhsg_recip_handle req_set_feature = {
 	.name		= "set feature",
 	.device		= usbhsg_recip_handler_std_set_device,
 	.interface	= usbhsg_recip_handler_std_control_done,
@@ -372,7 +372,7 @@ static int usbhsg_recip_handler_std_get_endpoint(struct usbhs_priv *priv,
 	return 0;
 }
 
-struct usbhsg_recip_handle req_get_status = {
+static struct usbhsg_recip_handle req_get_status = {
 	.name		= "get status",
 	.device		= usbhsg_recip_handler_std_get_device,
 	.interface	= usbhsg_recip_handler_std_get_interface,

commit 3920193d8e71d1f7e0d077aa71624b64fa3499ac
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Feb 26 15:15:51 2013 +0200

    usb: renesas: gadget: don't assign gadget.dev.release directly
    
    udc-core provides a better way to handle release
    methods, let's use it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 883b0120b454..c2781bc9dabe 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -923,11 +923,6 @@ static int usbhsg_stop(struct usbhs_priv *priv)
 	return usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);
 }
 
-static void usbhs_mod_gadget_release(struct device *pdev)
-{
-	/* do nothing */
-}
-
 int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv;
@@ -975,7 +970,6 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	 * init gadget
 	 */
 	gpriv->gadget.dev.parent	= dev;
-	gpriv->gadget.dev.release	= usbhs_mod_gadget_release;
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.max_speed		= USB_SPEED_HIGH;

commit 8707d5abbd96f7a124647357005511bee8d3ccdd
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Feb 26 14:37:17 2013 +0200

    usb: renesas: gadget: don't touch gadget.dev.driver
    
    udc-core now handles that for us, which means
    we can remove it from our driver.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 6a3afa9b764c..883b0120b454 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -845,7 +845,6 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 
 	/* first hook up the driver ... */
 	gpriv->driver = driver;
-	gpriv->gadget.dev.driver = &driver->driver;
 
 	return usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);
 }
@@ -861,7 +860,6 @@ static int usbhsg_gadget_stop(struct usb_gadget *gadget,
 		return -EINVAL;
 
 	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
-	gpriv->gadget.dev.driver = NULL;
 	gpriv->driver = NULL;
 
 	return 0;

commit 7bce401cc6db5508ef2517e45bd8caf7ce0a15ee
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jan 24 17:41:00 2013 +0200

    usb: gadget: drop now unnecessary flag
    
    We don't need the ->register_my_device flag
    anymore because all UDC drivers have been
    properly converted.
    
    Let's remove every history of it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 5d5fab0ad0d1..6a3afa9b764c 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -981,7 +981,6 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.max_speed		= USB_SPEED_HIGH;
-	gpriv->gadget.register_my_device = true;
 
 	INIT_LIST_HEAD(&gpriv->gadget.ep_list);
 

commit 0972ef71b4841a59fab6f998d6e6c2c684443583
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jan 24 17:08:01 2013 +0200

    usb: renesas_usbhs: gadget: let udc-core manage gadget->dev
    
    By simply setting a flag, we can drop some
    boilerplate code.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 78fca978b2d0..5d5fab0ad0d1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -976,15 +976,12 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	/*
 	 * init gadget
 	 */
-	dev_set_name(&gpriv->gadget.dev, "gadget");
 	gpriv->gadget.dev.parent	= dev;
 	gpriv->gadget.dev.release	= usbhs_mod_gadget_release;
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.max_speed		= USB_SPEED_HIGH;
-	ret = device_register(&gpriv->gadget.dev);
-	if (ret < 0)
-		goto err_add_udc;
+	gpriv->gadget.register_my_device = true;
 
 	INIT_LIST_HEAD(&gpriv->gadget.ep_list);
 
@@ -1014,15 +1011,13 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 
 	ret = usb_add_gadget_udc(dev, &gpriv->gadget);
 	if (ret)
-		goto err_register;
+		goto err_add_udc;
 
 
 	dev_info(dev, "gadget probed\n");
 
 	return 0;
 
-err_register:
-	device_unregister(&gpriv->gadget.dev);
 err_add_udc:
 	kfree(gpriv->uep);
 
@@ -1038,8 +1033,6 @@ void usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 
 	usb_del_gadget_udc(&gpriv->gadget);
 
-	device_unregister(&gpriv->gadget.dev);
-
 	kfree(gpriv->uep);
 	kfree(gpriv);
 }

commit cba6c85027057d4bf7029d32c64e2647859be07a
Merge: a9b8676c17ce eeef45876631
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 25 09:08:05 2013 -0800

    Merge tag 'gadget-for-v3.9' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
            usb: gadget: patches for v3.9 merge window
    
            finally getting rid of the old ->start()/->stop() methods
            in favor of the better and improved ->udc_start()/->udc_stop().
    
            There were surprisingly quite a few users left, but all of them
            have been converted.
    
            f_mass_storage removed some dead code, which is always great ;-)
    
            There's also a big cleanup to the gadget framework from Sebastian
            which gets us a lot closer to having only function drivers in
            kernel and move over to configfs-based binding.
    
            Other than these, there's the usual set of cleanups: s3c UDCs are
            moving over to devm_regulator_bulk_get() API, at91_udc removed
            an unnecessary check for work_pending() before scheduling and
            there's the removal of an unused variable from uac2_pcm_trigger().

commit eeef45876631a446eaedce16675f4ff344e16cf0
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jan 24 17:58:16 2013 +0200

    usb: gadget: constify all struct usb_gadget_ops
    
    Add the missing 'const' keyword to all struct
    usb_gadget_ops in the gadget framework.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index dd41f61893ef..809745072c11 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -905,7 +905,7 @@ static int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)
 	return 0;
 }
 
-static struct usb_gadget_ops usbhsg_gadget_ops = {
+static const struct usb_gadget_ops usbhsg_gadget_ops = {
 	.get_frame		= usbhsg_get_frame,
 	.set_selfpowered	= usbhsg_set_selfpowered,
 	.udc_start		= usbhsg_gadget_start,

commit d9fa298f215e050dbb28a6f75fe76459ebd2e7f0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Dec 10 22:44:07 2012 -0800

    usb: renesas_usbhs: gadget: usbhsg_ep_disable() care pipe settings
    
    Current usbhsg_ep_disable() didn't care
    uep->pipe and pipe->mod_private variable which is used on usbhsg_ep_enable().
    It breaks renesas_usbhs gadget when resume.
    This patch fixes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c6942d7fec47..f2985cd88021 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -601,7 +601,12 @@ static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 
-	return usbhsg_pipe_disable(uep);
+	usbhsg_pipe_disable(uep);
+
+	uep->pipe->mod_private	= NULL;
+	uep->pipe		= NULL;
+
+	return 0;
 }
 
 static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
@@ -753,7 +758,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 			usbhsg_dma_map_ctrl);
 	usbhs_fifo_init(priv);
 
-	/* dcp init */
+	/* dcp init instead of usbhsg_ep_enable() */
 	dcp->pipe		= usbhs_dcp_malloc(priv);
 	dcp->pipe->mod_private	= dcp;
 	usbhs_pipe_config_update(dcp->pipe, 0, 0, 64);
@@ -815,7 +820,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	usbhs_sys_set_test_mode(priv, 0);
 	usbhs_sys_function_ctrl(priv, 0);
 
-	usbhsg_pipe_disable(dcp);
+	usbhsg_ep_disable(&dcp->ep);
 
 	dev_dbg(dev, "stop gadget\n");
 

commit 584829459bd4421f0f57d11a6ceeef096ec81d08
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Dec 10 22:43:45 2012 -0800

    usb: renesas_usbhs: gadget: remove usbhsg_uep_init()
    
    Current driver always initialized uep->pipe to NULL on usbhsg_try_start().
    But it breaks relationship with
    usb_ep_ops :: enable/disable functions when suspend/resume.
    This patch solved this issue by initializing uep->pipe on probe()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index dd41f61893ef..c6942d7fec47 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -545,15 +545,6 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 	return 0;
 }
 
-static void usbhsg_uep_init(struct usbhsg_gpriv *gpriv)
-{
-	int i;
-	struct usbhsg_uep *uep;
-
-	usbhsg_for_each_uep_with_dcp(uep, gpriv, i)
-		uep->pipe = NULL;
-}
-
 /*
  *
  *		usb_ep_ops
@@ -761,7 +752,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	usbhs_pipe_init(priv,
 			usbhsg_dma_map_ctrl);
 	usbhs_fifo_init(priv);
-	usbhsg_uep_init(gpriv);
 
 	/* dcp init */
 	dcp->pipe		= usbhs_dcp_malloc(priv);
@@ -998,6 +988,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	 */
 	usbhsg_for_each_uep_with_dcp(uep, gpriv, i) {
 		uep->gpriv	= gpriv;
+		uep->pipe	= NULL;
 		snprintf(uep->ep_name, EP_NAME_SIZE, "ep%d", i);
 
 		uep->ep.name		= uep->ep_name;

commit 4cd2f5998757a41038deb55a0cb8319bdf67575a
Author: kuninori.morimoto.gx@renesas.com <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 15 23:24:19 2012 -0700

    usb: renesas_usbhs: gadget: add usb_gadget_ops :: pullup support
    
    This patch adds usbhs_sys_function_pullup() to control
    D+ line for USB function, and enabled pullup support on mod_gadget.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 28478ce26c34..dd41f61893ef 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -883,6 +883,16 @@ static int usbhsg_get_frame(struct usb_gadget *gadget)
 	return usbhs_frame_get_num(priv);
 }
 
+static int usbhsg_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+
+	usbhs_sys_function_pullup(priv, is_on);
+
+	return 0;
+}
+
 static int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
@@ -900,6 +910,7 @@ static struct usb_gadget_ops usbhsg_gadget_ops = {
 	.set_selfpowered	= usbhsg_set_selfpowered,
 	.udc_start		= usbhsg_gadget_start,
 	.udc_stop		= usbhsg_gadget_stop,
+	.pullup			= usbhsg_pullup,
 };
 
 static int usbhsg_start(struct usbhs_priv *priv)

commit cac402dd0832e9c63929eff70d6766cd8623e5fc
Author: Shimoda, Yoshihiro <yoshihiro.shimoda.uh@renesas.com>
Date:   Fri Mar 16 13:10:15 2012 +0900

    usb: renesas_usbhs: gadget: add support for set_selfpowered
    
    The previous code always set to USB_DEVICE_SELF_POWERED in GET_STATUS.
    So, this patch adds set_selfpowered().
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 00bd2a5e0362..28478ce26c34 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -55,6 +55,7 @@ struct usbhsg_gpriv {
 #define USBHSG_STATUS_STARTED		(1 << 0)
 #define USBHSG_STATUS_REGISTERD		(1 << 1)
 #define USBHSG_STATUS_WEDGE		(1 << 2)
+#define USBHSG_STATUS_SELF_POWERED	(1 << 3)
 };
 
 struct usbhsg_recip_handle {
@@ -333,7 +334,10 @@ static int usbhsg_recip_handler_std_get_device(struct usbhs_priv *priv,
 					       struct usb_ctrlrequest *ctrl)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	unsigned short status = 1 << USB_DEVICE_SELF_POWERED;
+	unsigned short status = 0;
+
+	if (usbhsg_status_has(gpriv, USBHSG_STATUS_SELF_POWERED))
+		status = 1 << USB_DEVICE_SELF_POWERED;
 
 	__usbhsg_recip_send_status(gpriv, status);
 
@@ -879,8 +883,21 @@ static int usbhsg_get_frame(struct usb_gadget *gadget)
 	return usbhs_frame_get_num(priv);
 }
 
+static int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
+
+	if (is_self)
+		usbhsg_status_set(gpriv, USBHSG_STATUS_SELF_POWERED);
+	else
+		usbhsg_status_clr(gpriv, USBHSG_STATUS_SELF_POWERED);
+
+	return 0;
+}
+
 static struct usb_gadget_ops usbhsg_gadget_ops = {
 	.get_frame		= usbhsg_get_frame,
+	.set_selfpowered	= usbhsg_set_selfpowered,
 	.udc_start		= usbhsg_gadget_start,
 	.udc_stop		= usbhsg_gadget_stop,
 };

commit f9b0f5170918695891f42645737682ccb452ee13
Merge: 8062d94a5454 6440093f5eae
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Mar 1 09:20:28 2012 -0800

    Merge tag 'gadget-for-v3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    USB: Gadget: changes for 3.4
    
    This merge is rather big. Here's what it contains:
    
    For am5536udc we have just simple coding style fixes. Nothing that has any
    potential to cause any issues going forward.
    
    With mv_udc, there's only one single change removing an unneeded NULL check.
    
    at91_udc also only saw a single change this merge window, and that's only
    removing a duplicated header.
    
    The Renesas controller has a few more involved changes. Support for SUDMAC was
    added, there's now a special handling of IRQ resources for when the IRQ line is
    shared between Renesas controller and SUDMAC, we also had a bug fix where
    Renesas controller would sleep in atomic context while doing DMA transfers from
    a tasklet. There were also a set of minor cleanups.
    
    The FSL UDC also had a scheduling in atomic context bug fix, but that's all.
    
    Thanks to Sebastian, the dummy_hcd now works better than ever with support for
    scatterlists and streams. Sebastian also added SuperSpeed descriptors to the
    serial gadgets.
    
    The highlight on this merge is the addition of a generic API for mapping and
    unmapping usb_requests. This will avoid code duplication on all UDC controllers
    and also kills all the defines for DMA_ADDR_INVALID which UDC controllers
    sprinkled around. A few of the UDC controllers were already converted to use
    this new API.
    
    Conflicts:
            drivers/usb/dwc3/gadget.c

commit ade78f9feb2ee3e03460ef3730d7656c4903d999
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Dec 19 11:57:16 2011 +0200

    usb: renesas: gadget: use generic map/unmap routines
    
    those routines have everything we need to map/unmap
    USB requests and it's better to use them.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index f37b20c82c80..937f2d40c747 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -165,69 +165,32 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 /*
  *		dma map/unmap
  */
-static int usbhsg_dma_map(struct device *dev,
-			  struct usbhs_pkt *pkt,
-			  enum dma_data_direction dir)
-{
-	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
-	struct usb_request *req = &ureq->req;
-
-	if (pkt->dma != DMA_ADDR_INVALID) {
-		dev_err(dev, "dma is already mapped\n");
-		return -EIO;
-	}
-
-	if (req->dma == DMA_ADDR_INVALID) {
-		pkt->dma = dma_map_single(dev, pkt->buf, pkt->length, dir);
-	} else {
-		dma_sync_single_for_device(dev, req->dma, req->length, dir);
-		pkt->dma = req->dma;
-	}
-
-	if (dma_mapping_error(dev, pkt->dma)) {
-		dev_err(dev, "dma mapping error %llx\n", (u64)pkt->dma);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static int usbhsg_dma_unmap(struct device *dev,
-			    struct usbhs_pkt *pkt,
-			    enum dma_data_direction dir)
+static int usbhsg_dma_map_ctrl(struct usbhs_pkt *pkt, int map)
 {
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
 	struct usb_request *req = &ureq->req;
-
-	if (pkt->dma == DMA_ADDR_INVALID) {
-		dev_err(dev, "dma is not mapped\n");
-		return -EIO;
-	}
-
-	if (req->dma == DMA_ADDR_INVALID)
-		dma_unmap_single(dev, pkt->dma, pkt->length, dir);
-	else
-		dma_sync_single_for_cpu(dev, req->dma, req->length, dir);
-
-	pkt->dma = DMA_ADDR_INVALID;
-
-	return 0;
-}
-
-static int usbhsg_dma_map_ctrl(struct usbhs_pkt *pkt, int map)
-{
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	enum dma_data_direction dir;
+	int ret = 0;
 
-	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	dir = usbhs_pipe_is_dir_host(pipe);
 
-	if (map)
-		return usbhsg_dma_map(dev, pkt, dir);
-	else
-		return usbhsg_dma_unmap(dev, pkt, dir);
+	if (map) {
+		/* it can not use scatter/gather */
+		WARN_ON(req->num_sgs);
+
+		ret = usb_gadget_map_request(&gpriv->gadget, req, dir);
+		if (ret < 0)
+			return ret;
+
+		pkt->dma = req->dma;
+	} else {
+		usb_gadget_unmap_request(&gpriv->gadget, req, dir);
+	}
+
+	return ret;
 }
 
 /*
@@ -657,8 +620,6 @@ static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
 
 	usbhs_pkt_init(usbhsg_ureq_to_pkt(ureq));
 
-	ureq->req.dma = DMA_ADDR_INVALID;
-
 	return &ureq->req;
 }
 

commit 3b2a2e47174cd978258bbb0fdf2e2b1b5ec2144c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 20 17:35:50 2012 -0800

    usb: renesas_usbhs: bugfix: add .release function to gpriv->gadget.dev
    
    This patch fixup below warning on device_unregister()
    
    renesas_usbhs renesas_usbhs.1: host probed
    renesas_usbhs renesas_usbhs.1: gadget probed
    renesas_usbhs renesas_usbhs.1: irq request err
    ------------[ cut here ]------------
    WARNING: at ${LINUX}/drivers/base/core.c:1)
    Device 'gadget' does not have a release() function, it is broken and must be fi.
    Modules linked in:
    [<c000e25c>] (unwind_backtrace+0x0/0xe4) from [<c0016960>] (warn_slowpath_commo)
    [<c0016960>] (warn_slowpath_common+0x4c/0x64) from [<c00169f8>] (warn_slowpath_)
    [<c00169f8>] (warn_slowpath_fmt+0x2c/0x3c) from [<c0185b80>] (device_release+0x)
    [<c0185b80>] (device_release+0x70/0x84) from [<c013e300>] (kobject_cleanup+0x58)
    [<c013e300>] (kobject_cleanup+0x58/0x6c) from [<c01cba14>] (usbhs_mod_gadget_re)
    [<c01cba14>] (usbhs_mod_gadget_remove+0x3c/0x6c) from [<c01c8384>] (usbhs_mod_p)
    [<c01c8384>] (usbhs_mod_probe+0x68/0x80) from [<c01c7f84>] (usbhs_probe+0x1cc/0)
    ...
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 528691d5f3e2..f37b20c82c80 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -941,6 +941,11 @@ static int usbhsg_stop(struct usbhs_priv *priv)
 	return usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);
 }
 
+static void usbhs_mod_gadget_release(struct device *pdev)
+{
+	/* do nothing */
+}
+
 int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv;
@@ -989,6 +994,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	 */
 	dev_set_name(&gpriv->gadget.dev, "gadget");
 	gpriv->gadget.dev.parent	= dev;
+	gpriv->gadget.dev.release	= usbhs_mod_gadget_release;
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.max_speed		= USB_SPEED_HIGH;

commit 7983bc74fc0bc91f026c7ba0654b08073d843657
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Jan 16 22:42:10 2012 +0100

    usb: renesas: silence uninitialized variable report in usbhsg_recip_run_handle()
    
    In drivers/usb/renesas_usbhs/mod_gadget.c::usbhsg_recip_run_handle()
    the Coverity Prevent checker currently flags a warning about possibly
    uninitialized use of 'ret' i usbhsg_recip_run_handle(). It does this
    since it assumes we take one of the non-default branches in the switch
    and then subsequently take the false branch in the 'if (func)' case
    below. This exact scenario will never happen, but Coverity can't see
    that for some reason. This patch initializes 'ret' to '0' when it is
    declared which should shut up this report and won't really hurt - so
    why not? At least then it's clear that 'ret' is always initialized..
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 528691d5f3e2..7542aa94a462 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -425,7 +425,7 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	struct usbhs_pipe *pipe;
 	int recip = ctrl->bRequestType & USB_RECIP_MASK;
 	int nth = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;
-	int ret;
+	int ret = 0;
 	int (*func)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
 		    struct usb_ctrlrequest *ctrl);
 	char *msg;

commit 8418153a4ccd38a3bc3229bc4bd161e3e5db88d2
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Dec 15 14:31:37 2011 +0300

    usb: renesas_usbhs: silence a gcc warning
    
    Gcc complains about this printk:
    drivers/usb/renesas_usbhs/mod_gadget.c:188:3: warning: format %x
            expects argument of type unsigned int, but argument 3 has type
            dma_addr_t [-Wformat]
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index db2a1c6a0866..528691d5f3e2 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -185,7 +185,7 @@ static int usbhsg_dma_map(struct device *dev,
 	}
 
 	if (dma_mapping_error(dev, pkt->dma)) {
-		dev_err(dev, "dma mapping error %x\n", pkt->dma);
+		dev_err(dev, "dma mapping error %llx\n", (u64)pkt->dma);
 		return -EIO;
 	}
 

commit 3edeee3893b107364fe4ed8535245773b1e1e72b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 8 18:28:54 2011 -0800

    usb: renesas_usbhs: care pipe sequence
    
    driver has to re-use the limited pipe for each device/endpoint
    when it is USB host hub mode, since number of pipe has limitation.
    
    Then, each pipe should care own pipe sequence for next packet.
    This patch adds sequence control.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index cf3141c330a3..db2a1c6a0866 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -154,7 +154,7 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	req->actual = 0;
 	req->status = -EINPROGRESS;
 	usbhs_pkt_push(pipe, pkt, usbhsg_queue_done,
-		       req->buf, req->length, req->zero);
+		       req->buf, req->length, req->zero, -1);
 	usbhs_pkt_start(pipe);
 
 	dev_dbg(dev, "pipe %d : queue push (%d)\n",

commit b294b203361d2cf5f006a0233d2065ed0e0b5b76
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:28:45 2011 -0800

    usb: renesas_usbhs: remove the_controller_link
    
    current renesas_usbhs is using new style udc_start/stop from
    af1d7056a5c1e5eaaf807ddd1423101db84668d0
    (usb: gadget: renesas: convert to new style).
    
    with this patch we can finally remove the global "the_controller_link"
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 1951de02957e..cf3141c330a3 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -45,7 +45,6 @@ struct usbhsg_uep {
 struct usbhsg_gpriv {
 	struct usb_gadget	 gadget;
 	struct usbhs_mod	 mod;
-	struct list_head	 link;
 
 	struct usbhsg_uep	*uep;
 	int			 uep_size;
@@ -115,16 +114,6 @@ struct usbhsg_recip_handle {
 #define usbhsg_status_clr(gp, b) (gp->status &= ~b)
 #define usbhsg_status_has(gp, b) (gp->status &   b)
 
-/* controller */
-LIST_HEAD(the_controller_link);
-
-#define usbhsg_for_each_controller(gpriv)\
-	list_for_each_entry(gpriv, &the_controller_link, link)
-#define usbhsg_controller_register(gpriv)\
-	list_add_tail(&(gpriv)->link, &the_controller_link)
-#define usbhsg_controller_unregister(gpriv)\
-	list_del_init(&(gpriv)->link)
-
 /*
  *		queue push/pop
  */
@@ -1032,8 +1021,6 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		}
 	}
 
-	usbhsg_controller_register(gpriv);
-
 	ret = usb_add_gadget_udc(dev, &gpriv->gadget);
 	if (ret)
 		goto err_register;
@@ -1062,8 +1049,6 @@ void usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 
 	device_unregister(&gpriv->gadget.dev);
 
-	usbhsg_controller_unregister(gpriv);
-
 	kfree(gpriv->uep);
 	kfree(gpriv);
 }

commit dfbb7f4fba47153de4be9ed6092804ebfd16bfbb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:28:35 2011 -0800

    usb: renesas_usbhs: add test-mode support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index dba15e07fbd2..1951de02957e 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -14,6 +14,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  */
+#include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -286,6 +287,24 @@ struct usbhsg_recip_handle req_clear_feature = {
 /*
  *		USB_TYPE_STANDARD / set feature functions
  */
+static int usbhsg_recip_handler_std_set_device(struct usbhs_priv *priv,
+						 struct usbhsg_uep *uep,
+						 struct usb_ctrlrequest *ctrl)
+{
+	switch (le16_to_cpu(ctrl->wValue)) {
+	case USB_DEVICE_TEST_MODE:
+		usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
+		udelay(100);
+		usbhs_sys_set_test_mode(priv, le16_to_cpu(ctrl->wIndex >> 8));
+		break;
+	default:
+		usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
+		break;
+	}
+
+	return 0;
+}
+
 static int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,
 						 struct usbhsg_uep *uep,
 						 struct usb_ctrlrequest *ctrl)
@@ -301,7 +320,7 @@ static int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,
 
 struct usbhsg_recip_handle req_set_feature = {
 	.name		= "set feature",
-	.device		= usbhsg_recip_handler_std_control_done,
+	.device		= usbhsg_recip_handler_std_set_device,
 	.interface	= usbhsg_recip_handler_std_control_done,
 	.endpoint	= usbhsg_recip_handler_std_set_endpoint,
 };
@@ -849,6 +868,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	gpriv->gadget.speed = USB_SPEED_UNKNOWN;
 
 	/* disable sys */
+	usbhs_sys_set_test_mode(priv, 0);
 	usbhs_sys_function_ctrl(priv, 0);
 
 	usbhsg_pipe_disable(dcp);

commit 91b158f4d11164bfe5710873c8e162cf8c8d132b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:28:26 2011 -0800

    usb: renesas_usbhs: call usbhsg_queue_pop() when pipe disable.
    
    When poping packet from queue, it needs correct end procedure.
    This patch call usbhsg_queue_pop() in usbhsg_pipe_disable().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 16484060a24c..dba15e07fbd2 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -557,14 +557,16 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhs_pkt *pkt;
 
-	usbhs_pipe_disable(pipe);
-
 	while (1) {
 		pkt = usbhs_pkt_pop(pipe, NULL);
 		if (!pkt)
 			break;
+
+		usbhsg_queue_pop(uep, usbhsg_pkt_to_ureq(pkt), -ECONNRESET);
 	}
 
+	usbhs_pipe_disable(pipe);
+
 	return 0;
 }
 

commit 25fa70795bf11ef6f5b147f0b231a43880ba96ca
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:28:17 2011 -0800

    usb: renesas_usbhs: send packet in necessary timing.
    
    Current renesas_usbhs driver always tries to send packet in end of recip handler.
    But it breaks chapter 9 EndpointHalt test.
    This patch fixup this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 812960ba95e1..16484060a24c 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -271,6 +271,8 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 
 	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
 
+	usbhs_pkt_start(pipe);
+
 	return 0;
 }
 
@@ -424,8 +426,7 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	pipe = usbhsg_uep_to_pipe(uep);
 	if (!pipe) {
 		dev_err(dev, "wrong recip request\n");
-		ret = -EINVAL;
-		goto usbhsg_recip_run_handle_end;
+		return -EINVAL;
 	}
 
 	switch (recip) {
@@ -452,9 +453,6 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 		ret = func(priv, uep, ctrl);
 	}
 
-usbhsg_recip_run_handle_end:
-	usbhs_pkt_start(pipe);
-
 	return ret;
 }
 

commit 17f7f76940214af91bfefcf9a2ca156701d905e6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:28:04 2011 -0800

    usb: renesas_usbhs: add basic USB_REQ_GET_STATUS support
    
    This patch adds basic get-status support for chapter 9 test.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 3130089eacff..812960ba95e1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -304,6 +304,104 @@ struct usbhsg_recip_handle req_set_feature = {
 	.endpoint	= usbhsg_recip_handler_std_set_endpoint,
 };
 
+/*
+ *		USB_TYPE_STANDARD / get status functions
+ */
+static void __usbhsg_recip_send_complete(struct usb_ep *ep,
+					 struct usb_request *req)
+{
+	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
+
+	/* free allocated recip-buffer/usb_request */
+	kfree(ureq->pkt.buf);
+	usb_ep_free_request(ep, req);
+}
+
+static void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,
+				       unsigned short status)
+{
+	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usb_request *req;
+	unsigned short *buf;
+
+	/* alloc new usb_request for recip */
+	req = usb_ep_alloc_request(&dcp->ep, GFP_ATOMIC);
+	if (!req) {
+		dev_err(dev, "recip request allocation fail\n");
+		return;
+	}
+
+	/* alloc recip data buffer */
+	buf = kmalloc(sizeof(*buf), GFP_ATOMIC);
+	if (!buf) {
+		usb_ep_free_request(&dcp->ep, req);
+		dev_err(dev, "recip data allocation fail\n");
+		return;
+	}
+
+	/* recip data is status */
+	*buf = cpu_to_le16(status);
+
+	/* allocated usb_request/buffer will be freed */
+	req->complete	= __usbhsg_recip_send_complete;
+	req->buf	= buf;
+	req->length	= sizeof(*buf);
+	req->zero	= 0;
+
+	/* push packet */
+	pipe->handler = &usbhs_fifo_pio_push_handler;
+	usbhsg_queue_push(dcp, usbhsg_req_to_ureq(req));
+}
+
+static int usbhsg_recip_handler_std_get_device(struct usbhs_priv *priv,
+					       struct usbhsg_uep *uep,
+					       struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	unsigned short status = 1 << USB_DEVICE_SELF_POWERED;
+
+	__usbhsg_recip_send_status(gpriv, status);
+
+	return 0;
+}
+
+static int usbhsg_recip_handler_std_get_interface(struct usbhs_priv *priv,
+						  struct usbhsg_uep *uep,
+						  struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	unsigned short status = 0;
+
+	__usbhsg_recip_send_status(gpriv, status);
+
+	return 0;
+}
+
+static int usbhsg_recip_handler_std_get_endpoint(struct usbhs_priv *priv,
+						 struct usbhsg_uep *uep,
+						 struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	unsigned short status = 0;
+
+	if (usbhs_pipe_is_stall(pipe))
+		status = 1 << USB_ENDPOINT_HALT;
+
+	__usbhsg_recip_send_status(gpriv, status);
+
+	return 0;
+}
+
+struct usbhsg_recip_handle req_get_status = {
+	.name		= "get status",
+	.device		= usbhsg_recip_handler_std_get_device,
+	.interface	= usbhsg_recip_handler_std_get_interface,
+	.endpoint	= usbhsg_recip_handler_std_get_endpoint,
+};
+
 /*
  *		USB_TYPE handler
  */
@@ -431,6 +529,9 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 		case USB_REQ_SET_FEATURE:
 			recip_handler = &req_set_feature;
 			break;
+		case USB_REQ_GET_STATUS:
+			recip_handler = &req_get_status;
+			break;
 		}
 	}
 

commit ced6e09e6ec4f52c9bd76d6b8debd67517fdcc1c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:27:50 2011 -0800

    usb: renesas_usbhs: add basic USB_REQ_SET_FEATURE support
    
    This patch adds basic set-feature support for chapter 9 test.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 9a9e36378e87..3130089eacff 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -281,6 +281,29 @@ struct usbhsg_recip_handle req_clear_feature = {
 	.endpoint	= usbhsg_recip_handler_std_clear_endpoint,
 };
 
+/*
+ *		USB_TYPE_STANDARD / set feature functions
+ */
+static int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,
+						 struct usbhsg_uep *uep,
+						 struct usb_ctrlrequest *ctrl)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+
+	usbhs_pipe_stall(pipe);
+
+	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
+
+	return 0;
+}
+
+struct usbhsg_recip_handle req_set_feature = {
+	.name		= "set feature",
+	.device		= usbhsg_recip_handler_std_control_done,
+	.interface	= usbhsg_recip_handler_std_control_done,
+	.endpoint	= usbhsg_recip_handler_std_set_endpoint,
+};
+
 /*
  *		USB_TYPE handler
  */
@@ -405,6 +428,9 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 		case USB_REQ_CLEAR_FEATURE:
 			recip_handler = &req_clear_feature;
 			break;
+		case USB_REQ_SET_FEATURE:
+			recip_handler = &req_set_feature;
+			break;
 		}
 	}
 

commit 4b815932013c9f94f852df9d136dcd5c0008afe2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 24 17:27:19 2011 -0800

    usb: renesas_usbhs: remove superfluous usbhs_lock from recip handler
    
    recip handler will call various functions which are holding
    usbhs_lock.
    
    This patch removes superfluous usbhs_lock from recip handler
    to escape double lock.
    
    [ balbi@ti.com : brushed up commit log a bit ]
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c307c8f5bd3a..9a9e36378e87 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -327,15 +327,8 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	}
 
 	if (func) {
-		unsigned long flags;
-
 		dev_dbg(dev, "%s (pipe %d :%s)\n", handler->name, nth, msg);
-
-		/********************  spin lock ********************/
-		usbhs_lock(priv, flags);
 		ret = func(priv, uep, ctrl);
-		usbhs_unlock(priv, flags);
-		/********************  spin unlock ******************/
 	}
 
 usbhsg_recip_run_handle_end:

commit 7177aed44f515d949f587170e0e177ce17e74793
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sat Nov 19 18:27:38 2011 +0100

    usb: gadget: rename usb_gadget_driver::speed to max_speed
    
    This commit renames the speedfield of the usb_gadget_driver
    structure to max_speed.  This is so that to make it more
    apparent that the field represents the maximum speed gadget
    driver can support.
    
    This also make the field look more like fields with the same
    name in usb_gadget and usb_composite_driver structures.  All
    of those represent the *maximal* speed given entity supports.
    
    After this commit, there are the following fields in various
    structures:
    * usb_gadget::speed - the current connection speed,
    * usb_gadget::max_speed - maximal speed UDC supports,
    * usb_gadget_driver::max_speed - maximal speed gadget driver
      supports, and
    * usb_composite_driver::max_speed - maximal speed composite
      gadget supports.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 43c67e5cde26..c307c8f5bd3a 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -751,7 +751,7 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 
 	if (!driver		||
 	    !driver->setup	||
-	    driver->speed < USB_SPEED_FULL)
+	    driver->max_speed < USB_SPEED_FULL)
 		return -EINVAL;
 
 	/* first hook up the driver ... */

commit d327ab5b6d660d6fe22b073b743fde1668e593bb
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sat Nov 19 18:27:37 2011 +0100

    usb: gadget: replace usb_gadget::is_dualspeed with max_speed
    
    This commit replaces usb_gadget's is_dualspeed field with
    a max_speed field.
    
    [ balbi@ti.com : Fixed DWC3 driver ]
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 8fb9056ff48d..43c67e5cde26 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -862,7 +862,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	gpriv->gadget.dev.parent	= dev;
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
-	gpriv->gadget.is_dualspeed	= 1;
+	gpriv->gadget.max_speed		= USB_SPEED_HIGH;
 	ret = device_register(&gpriv->gadget.dev);
 	if (ret < 0)
 		goto err_add_udc;

commit 3244a7b43f13682c3323ee0d781f0cb212e8b3e7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Oct 23 19:56:30 2011 -0700

    usb: gadget: renesas_usbhs: remove usbhs_sys_usb_ctrl()
    
    usbhs_sys_usb_ctrl() can collect into usbhs_sys_host/function_ctrl().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index f23839ddd62c..8fb9056ff48d 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -682,7 +682,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * - usb module
 	 */
 	usbhs_sys_function_ctrl(priv, 1);
-	usbhs_sys_usb_ctrl(priv, 1);
 
 	/*
 	 * enable irq callback
@@ -731,7 +730,6 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 
 	/* disable sys */
 	usbhs_sys_function_ctrl(priv, 0);
-	usbhs_sys_usb_ctrl(priv, 0);
 
 	usbhsg_pipe_disable(dcp);
 

commit 2288e109931577582f09d6295029bbf098c6f939
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Oct 23 19:55:47 2011 -0700

    usb: gadget: renesas_usbhs: remove usbhs_sys_hispeed_ctrl()
    
    usbhs_sys_hispeed_ctrl() can collect into usbhs_sys_host/function_ctrl().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 7f4e80338570..f23839ddd62c 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -681,7 +681,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * - function
 	 * - usb module
 	 */
-	usbhs_sys_hispeed_ctrl(priv, 1);
 	usbhs_sys_function_ctrl(priv, 1);
 	usbhs_sys_usb_ctrl(priv, 1);
 
@@ -731,7 +730,6 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	gpriv->gadget.speed = USB_SPEED_UNKNOWN;
 
 	/* disable sys */
-	usbhs_sys_hispeed_ctrl(priv, 0);
 	usbhs_sys_function_ctrl(priv, 0);
 	usbhs_sys_usb_ctrl(priv, 0);
 

commit 89f829a50f7d0d0f3a15c482a7a65dd0b133a5f5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 17 18:20:44 2011 -0800

    usb: renesas_usbhs: fixup driver speed
    
    This patch cares latest USB_SPEED_SUPER support.
    renesas_usbhs can not use super-speed, but can use full/high speed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 2be73817e47f..7f4e80338570 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -755,7 +755,7 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 
 	if (!driver		||
 	    !driver->setup	||
-	    driver->speed != USB_SPEED_HIGH)
+	    driver->speed < USB_SPEED_FULL)
 		return -EINVAL;
 
 	/* first hook up the driver ... */

commit 0cdd7d4b66aa740ce62aeeaf7fbd495130c2864f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 17 18:19:56 2011 -0800

    usb: renesas_usbhs: fixup gadget.dev.driver when udc_stop.
    
    current renesas_usbhs is using new style udc_start/stop from
    af1d7056a5c1e5eaaf807ddd1423101db84668d0
    (usb: gadget: renesas: convert to new style).
    
    But current renesas_usbhs driver didn't care about gadget.dev.driver
    when udc_stop. it cause rmmod oops.
    This patch care it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index f4b032ed326a..2be73817e47f 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -776,6 +776,7 @@ static int usbhsg_gadget_stop(struct usb_gadget *gadget,
 		return -EINVAL;
 
 	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
+	gpriv->gadget.dev.driver = NULL;
 	gpriv->driver = NULL;
 
 	return 0;

commit 8885a897c26b2f63e1bbb6fa7bd9da3a73a09113
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 17 18:19:38 2011 -0800

    usb: renesas_usbhs: fixup signal the driver that cable was disconnected
    
    current renesas_usbhs is using new style udc_start/stop from
    af1d7056a5c1e5eaaf807ddd1423101db84668d0
    (usb: gadget: renesas: convert to new style).
    
    cable disconnected signal was needed.
    This patch fixup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ef82274ce70b..f4b032ed326a 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -805,6 +805,13 @@ static int usbhsg_start(struct usbhs_priv *priv)
 
 static int usbhsg_stop(struct usbhs_priv *priv)
 {
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+
+	/* cable disconnect */
+	if (gpriv->driver &&
+	    gpriv->driver->disconnect)
+		gpriv->driver->disconnect(&gpriv->gadget);
+
 	return usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);
 }
 

commit f8eff0a06116aee127152674e9ea9c51aecf6b69
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 17 18:19:06 2011 -0800

    usb: renesas_usbhs: fixup device_register timing
    
    current renesas_usbhs is using new style udc_start/stop from
    af1d7056a5c1e5eaaf807ddd1423101db84668d0
    (usb: gadget: renesas: convert to new style).
    
    But bind() function will fail if it was called before
    device_register() (or device_add()).
    This patch modifies this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index d9717e0bc1ff..ef82274ce70b 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -751,53 +751,31 @@ static int usbhsg_gadget_start(struct usb_gadget *gadget,
 		struct usb_gadget_driver *driver)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
-	struct usbhs_priv *priv;
-	struct device *dev;
-	int ret;
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
 	if (!driver		||
 	    !driver->setup	||
 	    driver->speed != USB_SPEED_HIGH)
 		return -EINVAL;
 
-	dev  = usbhsg_gpriv_to_dev(gpriv);
-	priv = usbhsg_gpriv_to_priv(gpriv);
-
 	/* first hook up the driver ... */
 	gpriv->driver = driver;
 	gpriv->gadget.dev.driver = &driver->driver;
 
-	ret = device_add(&gpriv->gadget.dev);
-	if (ret) {
-		dev_err(dev, "device_add error %d\n", ret);
-		goto add_fail;
-	}
-
 	return usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);
-
-add_fail:
-	gpriv->driver = NULL;
-	gpriv->gadget.dev.driver = NULL;
-
-	return ret;
 }
 
 static int usbhsg_gadget_stop(struct usb_gadget *gadget,
 		struct usb_gadget_driver *driver)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
-	struct usbhs_priv *priv;
-	struct device *dev;
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 
 	if (!driver		||
 	    !driver->unbind)
 		return -EINVAL;
 
-	dev  = usbhsg_gpriv_to_dev(gpriv);
-	priv = usbhsg_gpriv_to_priv(gpriv);
-
 	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
-	device_del(&gpriv->gadget.dev);
 	gpriv->driver = NULL;
 
 	return 0;
@@ -876,12 +854,14 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	/*
 	 * init gadget
 	 */
-	device_initialize(&gpriv->gadget.dev);
 	dev_set_name(&gpriv->gadget.dev, "gadget");
 	gpriv->gadget.dev.parent	= dev;
 	gpriv->gadget.name		= "renesas_usbhs_udc";
 	gpriv->gadget.ops		= &usbhsg_gadget_ops;
 	gpriv->gadget.is_dualspeed	= 1;
+	ret = device_register(&gpriv->gadget.dev);
+	if (ret < 0)
+		goto err_add_udc;
 
 	INIT_LIST_HEAD(&gpriv->gadget.ep_list);
 
@@ -912,12 +892,15 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 
 	ret = usb_add_gadget_udc(dev, &gpriv->gadget);
 	if (ret)
-		goto err_add_udc;
+		goto err_register;
 
 
 	dev_info(dev, "gadget probed\n");
 
 	return 0;
+
+err_register:
+	device_unregister(&gpriv->gadget.dev);
 err_add_udc:
 	kfree(gpriv->uep);
 
@@ -933,6 +916,8 @@ void usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 
 	usb_del_gadget_udc(&gpriv->gadget);
 
+	device_unregister(&gpriv->gadget.dev);
+
 	usbhsg_controller_unregister(gpriv);
 
 	kfree(gpriv->uep);

commit b7a8d17db9a86db1040862600cf3a02848f83844
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 26 19:33:49 2011 -0700

    usb: gadget: renesas_usbhs: fixup section mismatch warning
    
    Fix up the following section mismatch warnings:
    
    WARNING: drivers/usb/renesas_usbhs/renesas_usbhs.o(.text+0xf5d): Section
    mismatch in reference from the function usbhs_mod_probe() to the function
    .devinit.text:usbhs_mod_host_probe() The function usbhs_mod_probe() references
    the function __devinit usbhs_mod_host_probe().  This is often because
    usbhs_mod_probe lacks a __devinit annotation or the annotation of
    usbhs_mod_host_probe is wrong.
    
    WARNING: drivers/usb/renesas_usbhs/renesas_usbhs.o(.text+0xfd7): Section
    mismatch in reference from the function usbhs_mod_probe() to the function
    .devexit.text:usbhs_mod_host_remove() The function usbhs_mod_probe() references
    a function in an exit section.  Often the function usbhs_mod_host_remove() has
    valid usage outside the exit section and the fix is to remove the __devexit
    annotation of usbhs_mod_host_remove.
    
    WARNING: drivers/usb/renesas_usbhs/renesas_usbhs.o(.text+0x1005): Section
    mismatch in reference from the function usbhs_mod_remove() to the function
    .devexit.text:usbhs_mod_host_remove() The function usbhs_mod_remove()
    references a function in an exit section.  Often the function
    usbhs_mod_host_remove() has valid usage outside the exit section and the fix is
    to remove the __devexit annotation of usbhs_mod_host_remove.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 4cc7ee0babc6..d9717e0bc1ff 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -830,7 +830,7 @@ static int usbhsg_stop(struct usbhs_priv *priv)
 	return usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);
 }
 
-int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
+int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv;
 	struct usbhsg_uep *uep;
@@ -927,7 +927,7 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	return ret;
 }
 
-void __devexit usbhs_mod_gadget_remove(struct usbhs_priv *priv)
+void usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 

commit 6e6db82ba9bf2d5912897f77ccf6902cb8543372
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:05:30 2011 -0700

    usb: gadget: renesas_usbhs: modify pipe sequence settings
    
    renesas_usbhs can manually set DATA0/DATA1.
    This patch is prepare for mod_host support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index d3d833bce5f4..4cc7ee0babc6 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -265,7 +265,7 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 
 	if (!usbhsg_status_has(gpriv, USBHSG_STATUS_WEDGE)) {
 		usbhs_pipe_disable(pipe);
-		usbhs_pipe_clear_sequence(pipe);
+		usbhs_pipe_sequence_data0(pipe);
 		usbhs_pipe_enable(pipe);
 	}
 
@@ -479,7 +479,7 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	 */
 	if (uep->pipe) {
 		usbhs_pipe_clear(uep->pipe);
-		usbhs_pipe_clear_sequence(uep->pipe);
+		usbhs_pipe_sequence_data0(uep->pipe);
 		return 0;
 	}
 

commit 654c35ab5e643aa7ff34fbc11315f4a6e3a3e1f5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:04:53 2011 -0700

    usb: gadget: renesas_usbhs: disable auto paket start on usbhs_pkt_push()
    
    Automatically packet start by usbhs_pkt_push() was useful.
    But the pushed packet will be called twice
    if new packet was pushed on usbhs_pkt :: done callback.
    (1st is called by usbhs_pkt_push(), 2nd is called by usbhsf_pkt_handler())
    
    This patch disables automatic packet start,
    and clarified packet start timing.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 563128531e65..d3d833bce5f4 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -165,6 +165,7 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	req->status = -EINPROGRESS;
 	usbhs_pkt_push(pipe, pkt, usbhsg_queue_done,
 		       req->buf, req->length, req->zero);
+	usbhs_pkt_start(pipe);
 
 	dev_dbg(dev, "pipe %d : queue push (%d)\n",
 		usbhs_pipe_number(pipe),

commit b331872b85c2ab388129af3343474e02e89498af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:04:41 2011 -0700

    usb: gadget: renesas_usbhs: move done callback to struct usbhs_pkt
    
    transfer done function was registered in struct struct usbhs_pipe_info.
    It was good for mod_gadget, but not good for mod_host.
    This function move it to struct usbhs_pkt.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index d5f80c4457e5..563128531e65 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -127,24 +127,6 @@ LIST_HEAD(the_controller_link);
 /*
  *		queue push/pop
  */
-static void usbhsg_queue_push(struct usbhsg_uep *uep,
-			      struct usbhsg_request *ureq)
-{
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
-	struct usb_request *req = &ureq->req;
-
-	req->actual = 0;
-	req->status = -EINPROGRESS;
-	usbhs_pkt_push(pipe, pkt, req->buf, req->length, req->zero);
-
-	dev_dbg(dev, "pipe %d : queue push (%d)\n",
-		usbhs_pipe_number(pipe),
-		req->length);
-}
-
 static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 			     struct usbhsg_request *ureq,
 			     int status)
@@ -170,6 +152,25 @@ static void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)
 	usbhsg_queue_pop(uep, ureq, 0);
 }
 
+static void usbhsg_queue_push(struct usbhsg_uep *uep,
+			      struct usbhsg_request *ureq)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
+	struct usb_request *req = &ureq->req;
+
+	req->actual = 0;
+	req->status = -EINPROGRESS;
+	usbhs_pkt_push(pipe, pkt, usbhsg_queue_done,
+		       req->buf, req->length, req->zero);
+
+	dev_dbg(dev, "pipe %d : queue push (%d)\n",
+		usbhs_pipe_number(pipe),
+		req->length);
+}
+
 /*
  *		dma map/unmap
  */
@@ -664,7 +665,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * pipe initialize and enable DCP
 	 */
 	usbhs_pipe_init(priv,
-			usbhsg_queue_done,
 			usbhsg_dma_map_ctrl);
 	usbhs_fifo_init(priv);
 	usbhsg_uep_init(gpriv);

commit bc6fbf59df75c4e3533d0daf7873f783c835bd53
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:04:00 2011 -0700

    usb: gadget: renesas_usbhs: add device select support in usbhs_pipe_config_update()
    
    device select method will be used on mod_host
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index dd4ca37fbab3..d5f80c4457e5 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -489,7 +489,7 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		pipe->mod_private	= uep;
 
 		/* set epnum / maxp */
-		usbhs_pipe_config_update(pipe,
+		usbhs_pipe_config_update(pipe, 0,
 					 usb_endpoint_num(desc),
 					 usb_endpoint_maxp(desc));
 
@@ -672,7 +672,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	/* dcp init */
 	dcp->pipe		= usbhs_dcp_malloc(priv);
 	dcp->pipe->mod_private	= dcp;
-	usbhs_pipe_config_update(dcp->pipe, 0, 64);
+	usbhs_pipe_config_update(dcp->pipe, 0, 0, 64);
 
 	/*
 	 * system config enble

commit 2cc971978c0cabcd7760f4431270088cda72d8df
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:03:39 2011 -0700

    usb: gadget: renesas_usbhs: add struct usbhs_priv to packet done function
    
    There was no method to get struct usbhs_priv when
    packet transfer done function was called.
    This patch allow that callback function receive it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ae7d816c23d9..dd4ca37fbab3 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -159,7 +159,7 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 	ureq->req.complete(&uep->ep, &ureq->req);
 }
 
-static void usbhsg_queue_done(struct usbhs_pkt *pkt)
+static void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)
 {
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);

commit 75587f52c7b0d6c319515138a495a619b552a670
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:01:51 2011 -0700

    usb: gadget: renesas_usbhs: add usbhs_bus_get_speed()
    
    current mod_gadget had got usb speed on
    usbhsg_irq_dev_state() which is status change interrupt callback function.
    And the usb speed data was included in its parameter.
    
    But this style works for mod_gadget,
    but doesn't work for mod_host which
    isn't interrupted when device status was changed.
    
    This patch add usbhs_bus_get_speed() to solve this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index babd90c979c1..ae7d816c23d9 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -353,7 +353,7 @@ static int usbhsg_irq_dev_state(struct usbhs_priv *priv,
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 
-	gpriv->gadget.speed = usbhs_status_get_usb_speed(irq_state);
+	gpriv->gadget.speed = usbhs_bus_get_speed(priv);
 
 	dev_dbg(dev, "state = %x : speed : %d\n",
 		usbhs_status_get_device_state(irq_state),

commit 0c6ef985ced753b60ecdc091fa49c3f5fa4a4f79
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 22:00:59 2011 -0700

    usb: gadget: renesas_usbhs: struct usbhs_pipe hold handler
    
    packet handler had moved to struct usbhs_pipe from struct usbhsg_uep.
    it is preparation of mod_host support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 5a697b76ff12..babd90c979c1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -39,7 +39,6 @@ struct usbhsg_uep {
 	char ep_name[EP_NAME_SIZE];
 
 	struct usbhsg_gpriv *gpriv;
-	struct usbhs_pkt_handle *handler;
 };
 
 struct usbhsg_gpriv {
@@ -139,8 +138,7 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 
 	req->actual = 0;
 	req->status = -EINPROGRESS;
-	usbhs_pkt_push(pipe, pkt, uep->handler,
-		       req->buf, req->length, req->zero);
+	usbhs_pkt_push(pipe, pkt, req->buf, req->length, req->zero);
 
 	dev_dbg(dev, "pipe %d : queue push (%d)\n",
 		usbhs_pipe_number(pipe),
@@ -389,13 +387,13 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 
 	switch (stage) {
 	case READ_DATA_STAGE:
-		dcp->handler = &usbhs_fifo_pio_push_handler;
+		pipe->handler = &usbhs_fifo_pio_push_handler;
 		break;
 	case WRITE_DATA_STAGE:
-		dcp->handler = &usbhs_fifo_pio_pop_handler;
+		pipe->handler = &usbhs_fifo_pio_pop_handler;
 		break;
 	case NODATA_STATUS_STAGE:
-		dcp->handler = &usbhs_ctrl_stage_end_handler;
+		pipe->handler = &usbhs_ctrl_stage_end_handler;
 		break;
 	default:
 		return ret;
@@ -501,9 +499,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		 * It will use pio handler if impossible.
 		 */
 		if (usb_endpoint_dir_in(desc))
-			uep->handler = &usbhs_fifo_dma_push_handler;
+			pipe->handler = &usbhs_fifo_dma_push_handler;
 		else
-			uep->handler = &usbhs_fifo_dma_pop_handler;
+			pipe->handler = &usbhs_fifo_dma_pop_handler;
 
 		ret = 0;
 	}

commit f5aa889f725b56934171f9845cf00a17de9cc76c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 10 21:59:46 2011 -0700

    usb: gadget: renesas_usbhs: remove desc from usbhs_pipe_malloc
    
    Current usbhs_pipe_malloc() used usb_endpoint_descriptor to
    get necessary information.
    It was very good for mod_gadget which allocate pipe in runtime,
    but is not good for mod_host which allocate pipe in initial timing.
    This patch remove usb_endpoint_descriptor from usbhs_pipe_malloc()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c5c9ee5abb7a..5a697b76ff12 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -483,11 +483,18 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		return 0;
 	}
 
-	pipe = usbhs_pipe_malloc(priv, desc);
+	pipe = usbhs_pipe_malloc(priv,
+				 usb_endpoint_type(desc),
+				 usb_endpoint_dir_in(desc));
 	if (pipe) {
 		uep->pipe		= pipe;
 		pipe->mod_private	= uep;
 
+		/* set epnum / maxp */
+		usbhs_pipe_config_update(pipe,
+					 usb_endpoint_num(desc),
+					 usb_endpoint_maxp(desc));
+
 		/*
 		 * usbhs_fifo_dma_push/pop_handler try to
 		 * use dmaengine if possible.
@@ -667,6 +674,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	/* dcp init */
 	dcp->pipe		= usbhs_dcp_malloc(priv);
 	dcp->pipe->mod_private	= dcp;
+	usbhs_pipe_config_update(dcp->pipe, 0, 64);
 
 	/*
 	 * system config enble

commit af1d7056a5c1e5eaaf807ddd1423101db84668d0
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Oct 10 17:11:20 2011 +0300

    usb: gadget: renesas: convert to new style
    
    using udc_start()/udc_stop() as we should.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index cb2d451d511e..c5c9ee5abb7a 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -730,10 +730,6 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 
 	usbhsg_pipe_disable(dcp);
 
-	if (gpriv->driver &&
-	    gpriv->driver->disconnect)
-		gpriv->driver->disconnect(&gpriv->gadget);
-
 	dev_dbg(dev, "stop gadget\n");
 
 	return 0;
@@ -744,31 +740,19 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
  *		linux usb function
  *
  */
-static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
-			    int (*bind)(struct usb_gadget *))
+static int usbhsg_gadget_start(struct usb_gadget *gadget,
+		struct usb_gadget_driver *driver)
 {
-	struct usbhsg_gpriv *gpriv;
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv;
 	struct device *dev;
 	int ret;
 
-	if (!bind		||
-	    !driver		||
+	if (!driver		||
 	    !driver->setup	||
 	    driver->speed != USB_SPEED_HIGH)
 		return -EINVAL;
 
-	/*
-	 * find unused controller
-	 */
-	usbhsg_for_each_controller(gpriv) {
-		if (!gpriv->driver)
-			goto find_unused_controller;
-	}
-	return -ENODEV;
-
-find_unused_controller:
-
 	dev  = usbhsg_gpriv_to_dev(gpriv);
 	priv = usbhsg_gpriv_to_priv(gpriv);
 
@@ -782,19 +766,8 @@ static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 		goto add_fail;
 	}
 
-	ret = bind(&gpriv->gadget);
-	if (ret) {
-		dev_err(dev, "bind to driver %s error %d\n",
-			driver->driver.name, ret);
-		goto bind_fail;
-	}
-
-	dev_dbg(dev, "bind %s\n", driver->driver.name);
-
 	return usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);
 
-bind_fail:
-	device_del(&gpriv->gadget.dev);
 add_fail:
 	gpriv->driver = NULL;
 	gpriv->gadget.dev.driver = NULL;
@@ -802,9 +775,10 @@ static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 	return ret;
 }
 
-static int usbhsg_gadget_stop(struct usb_gadget_driver *driver)
+static int usbhsg_gadget_stop(struct usb_gadget *gadget,
+		struct usb_gadget_driver *driver)
 {
-	struct usbhsg_gpriv *gpriv;
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
 	struct usbhs_priv *priv;
 	struct device *dev;
 
@@ -812,17 +786,6 @@ static int usbhsg_gadget_stop(struct usb_gadget_driver *driver)
 	    !driver->unbind)
 		return -EINVAL;
 
-	/*
-	 * find controller
-	 */
-	usbhsg_for_each_controller(gpriv) {
-		if (gpriv->driver == driver)
-			goto find_matching_controller;
-	}
-	return -ENODEV;
-
-find_matching_controller:
-
 	dev  = usbhsg_gpriv_to_dev(gpriv);
 	priv = usbhsg_gpriv_to_priv(gpriv);
 
@@ -830,12 +793,6 @@ static int usbhsg_gadget_stop(struct usb_gadget_driver *driver)
 	device_del(&gpriv->gadget.dev);
 	gpriv->driver = NULL;
 
-	if (driver->disconnect)
-		driver->disconnect(&gpriv->gadget);
-
-	driver->unbind(&gpriv->gadget);
-	dev_dbg(dev, "unbind %s\n", driver->driver.name);
-
 	return 0;
 }
 
@@ -852,8 +809,8 @@ static int usbhsg_get_frame(struct usb_gadget *gadget)
 
 static struct usb_gadget_ops usbhsg_gadget_ops = {
 	.get_frame		= usbhsg_get_frame,
-	.start			= usbhsg_gadget_start,
-	.stop			= usbhsg_gadget_stop,
+	.udc_start		= usbhsg_gadget_start,
+	.udc_stop		= usbhsg_gadget_stop,
 };
 
 static int usbhsg_start(struct usbhs_priv *priv)

commit e94c587e78811d95a5b0db094f984eeb99f86388
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jul 12 22:01:29 2011 -0700

    usb: renesas_usbhs: fixup usbhsg_for_each_uep 1st pos
    
    1st pos of __usbhsg_for_each_uep() was wrong.
    Expected uep were ep1, ep2, ep3...
    but each uep were ep0, ep2, ep3 ...
    This patch modify it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index e7101dc31e41..cb2d451d511e 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -77,7 +77,7 @@ struct usbhsg_recip_handle {
 		struct usbhsg_gpriv, mod)
 
 #define __usbhsg_for_each_uep(start, pos, g, i)	\
-	for (i = start, pos = (g)->uep;		\
+	for (i = start, pos = (g)->uep + i;	\
 	     i < (g)->uep_size;			\
 	     i++, pos = (g)->uep + i)
 

commit d128a259ea4ef7cab39f14b681ee466a7dc6153c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 3 21:41:26 2011 -0700

    usb: renesas_usbhs: fix DMA build by including dma-mapping.h
    
    Include dma-mapping.h to fix build of the renesas_usbhs driver
    
    CC      drivers/usb/renesas_usbhs/mod_gadget.o
    drivers/usb/renesas_usbhs/mod_gadget.c: In function 'usbhsg_dma_map':
    drivers/usb/renesas_usbhs/mod_gadget.c:190: error: implicit declaration of function 'dma_map_single'
    drivers/usb/renesas_usbhs/mod_gadget.c:192: error: implicit declaration of function 'dma_sync_single_for_device'
    drivers/usb/renesas_usbhs/mod_gadget.c:196: error: implicit declaration of function 'dma_mapping_error'
    drivers/usb/renesas_usbhs/mod_gadget.c: In function 'usbhsg_dma_unmap':
    drivers/usb/renesas_usbhs/mod_gadget.c:217: error: implicit declaration of function 'dma_unmap_single'
    drivers/usb/renesas_usbhs/mod_gadget.c:219: error: implicit declaration of function 'dma_sync_single_for_cpu'
    make[5]: *** [drivers/usb/renesas_usbhs/mod_gadget.o] Error 1
    make[4]: *** [drivers/usb/renesas_usbhs] Error 2
    
    Reported-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ba79dbf5adbc..e7101dc31e41 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -14,6 +14,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  */
+#include <linux/dma-mapping.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>

commit 3b87218829a4182850cc62f8c0c28abcecfdf8e6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 3 17:42:35 2011 -0700

    usb: renesas_usbhs: support multi driver
    
    Some SuperH/board has multi USBHS on it.
    This patch supports multi register for renesas_usbhs
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index cc3ad634d4f7..ba79dbf5adbc 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -44,6 +44,7 @@ struct usbhsg_uep {
 struct usbhsg_gpriv {
 	struct usb_gadget	 gadget;
 	struct usbhs_mod	 mod;
+	struct list_head	 link;
 
 	struct usbhsg_uep	*uep;
 	int			 uep_size;
@@ -113,6 +114,16 @@ struct usbhsg_recip_handle {
 #define usbhsg_status_clr(gp, b) (gp->status &= ~b)
 #define usbhsg_status_has(gp, b) (gp->status &   b)
 
+/* controller */
+LIST_HEAD(the_controller_link);
+
+#define usbhsg_for_each_controller(gpriv)\
+	list_for_each_entry(gpriv, &the_controller_link, link)
+#define usbhsg_controller_register(gpriv)\
+	list_add_tail(&(gpriv)->link, &the_controller_link)
+#define usbhsg_controller_unregister(gpriv)\
+	list_del_init(&(gpriv)->link)
+
 /*
  *		queue push/pop
  */
@@ -732,11 +743,10 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
  *		linux usb function
  *
  */
-struct usbhsg_gpriv *the_controller;
 static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 			    int (*bind)(struct usb_gadget *))
 {
-	struct usbhsg_gpriv *gpriv = the_controller;
+	struct usbhsg_gpriv *gpriv;
 	struct usbhs_priv *priv;
 	struct device *dev;
 	int ret;
@@ -746,10 +756,17 @@ static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 	    !driver->setup	||
 	    driver->speed != USB_SPEED_HIGH)
 		return -EINVAL;
-	if (!gpriv)
-		return -ENODEV;
-	if (gpriv->driver)
-		return -EBUSY;
+
+	/*
+	 * find unused controller
+	 */
+	usbhsg_for_each_controller(gpriv) {
+		if (!gpriv->driver)
+			goto find_unused_controller;
+	}
+	return -ENODEV;
+
+find_unused_controller:
 
 	dev  = usbhsg_gpriv_to_dev(gpriv);
 	priv = usbhsg_gpriv_to_priv(gpriv);
@@ -786,18 +803,25 @@ static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 
 static int usbhsg_gadget_stop(struct usb_gadget_driver *driver)
 {
-	struct usbhsg_gpriv *gpriv = the_controller;
+	struct usbhsg_gpriv *gpriv;
 	struct usbhs_priv *priv;
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-
-	if (!gpriv)
-		return -ENODEV;
+	struct device *dev;
 
 	if (!driver		||
-	    !driver->unbind	||
-	    driver != gpriv->driver)
+	    !driver->unbind)
 		return -EINVAL;
 
+	/*
+	 * find controller
+	 */
+	usbhsg_for_each_controller(gpriv) {
+		if (gpriv->driver == driver)
+			goto find_matching_controller;
+	}
+	return -ENODEV;
+
+find_matching_controller:
+
 	dev  = usbhsg_gpriv_to_dev(gpriv);
 	priv = usbhsg_gpriv_to_priv(gpriv);
 
@@ -919,7 +943,7 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		}
 	}
 
-	the_controller = gpriv;
+	usbhsg_controller_register(gpriv);
 
 	ret = usb_add_gadget_udc(dev, &gpriv->gadget);
 	if (ret)
@@ -943,6 +967,9 @@ void __devexit usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 
 	usb_del_gadget_udc(&gpriv->gadget);
+
+	usbhsg_controller_unregister(gpriv);
+
 	kfree(gpriv->uep);
 	kfree(gpriv);
 }

commit 233f519d273454e3e804e21363d5ef0bd031acfe
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jul 7 00:23:24 2011 -0700

    usb: renesas_usbhs: fixup comment-out
    
    This patch add/modify comment-out of renesas_usbhs.
    On this process, usbhs_pkt_init was moved because it was placed under
    usbhsf_null_handler which has no relationship it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 9a8e2e9141b2..cc3ad634d4f7 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -114,7 +114,7 @@ struct usbhsg_recip_handle {
 #define usbhsg_status_has(gp, b) (gp->status &   b)
 
 /*
- *		list push/pop
+ *		queue push/pop
  */
 static void usbhsg_queue_push(struct usbhsg_uep *uep,
 			      struct usbhsg_request *ureq)
@@ -160,6 +160,9 @@ static void usbhsg_queue_done(struct usbhs_pkt *pkt)
 	usbhsg_queue_pop(uep, ureq, 0);
 }
 
+/*
+ *		dma map/unmap
+ */
 static int usbhsg_dma_map(struct device *dev,
 			  struct usbhs_pkt *pkt,
 			  enum dma_data_direction dir)
@@ -473,6 +476,11 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		uep->pipe		= pipe;
 		pipe->mod_private	= uep;
 
+		/*
+		 * usbhs_fifo_dma_push/pop_handler try to
+		 * use dmaengine if possible.
+		 * It will use pio handler if impossible.
+		 */
 		if (usb_endpoint_dir_in(desc))
 			uep->handler = &usbhs_fifo_dma_push_handler;
 		else

commit 6d721b2946a18373f45837e899fc32bb550eaa56
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 21 15:09:19 2011 +0900

    usb: renesas_usbhs: use dma handler
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index c9c56e7a1b18..9a8e2e9141b2 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -474,9 +474,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		pipe->mod_private	= uep;
 
 		if (usb_endpoint_dir_in(desc))
-			uep->handler = &usbhs_fifo_pio_push_handler;
+			uep->handler = &usbhs_fifo_dma_push_handler;
 		else
-			uep->handler = &usbhs_fifo_pio_pop_handler;
+			uep->handler = &usbhs_fifo_dma_pop_handler;
 
 		ret = 0;
 	}

commit 0f91349b89f37dfad7b77f7829a105b6a0f526ec
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Jun 28 16:33:47 2011 +0300

    usb: gadget: convert all users to the new udc infrastructure
    
    peripheral drivers are using usb_add_gadget()/usb_del_gadget() to
    register/unregister to the udc-core.
    
    The udc-core will take the first available gadget driver and attach
    function driver which is calling usb_gadget_register_driver(). This is
    the same behaviour we have right now.
    
    Only dummy_hcd was tested, the others were compiled tested.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Anton Tikhomirov <av.tikhomirov@samsung.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Jingoo Han <jg1.han@samsung.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Cc: Roy Huang <roy.huang@analog.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Toshiharu Okada <toshiharu-linux@dsn.okisemi.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Cc: Yuan-Hsin Chen <yhchen@faraday-tech.com>
    Cc: cxie4 <cxie4@marvell.com>
    Cc: linux-geode@lists.infradead.org
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index aa591b663835..c9c56e7a1b18 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -725,7 +725,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
  *
  */
 struct usbhsg_gpriv *the_controller;
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
+static int usbhsg_gadget_start(struct usb_gadget_driver *driver,
 			    int (*bind)(struct usb_gadget *))
 {
 	struct usbhsg_gpriv *gpriv = the_controller;
@@ -775,9 +775,8 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
 
 	return ret;
 }
-EXPORT_SYMBOL(usb_gadget_probe_driver);
 
-int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+static int usbhsg_gadget_stop(struct usb_gadget_driver *driver)
 {
 	struct usbhsg_gpriv *gpriv = the_controller;
 	struct usbhs_priv *priv;
@@ -806,7 +805,6 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 
 	return 0;
 }
-EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
 /*
  *		usb gadget ops
@@ -821,6 +819,8 @@ static int usbhsg_get_frame(struct usb_gadget *gadget)
 
 static struct usb_gadget_ops usbhsg_gadget_ops = {
 	.get_frame		= usbhsg_get_frame,
+	.start			= usbhsg_gadget_start,
+	.stop			= usbhsg_gadget_stop,
 };
 
 static int usbhsg_start(struct usbhs_priv *priv)
@@ -840,6 +840,7 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	struct device *dev = usbhs_priv_to_dev(priv);
 	int pipe_size = usbhs_get_dparam(priv, pipe_size);
 	int i;
+	int ret;
 
 	gpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);
 	if (!gpriv) {
@@ -850,6 +851,7 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
 	if (!uep) {
 		dev_err(dev, "Could not allocate ep\n");
+		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}
 
@@ -911,20 +913,28 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 
 	the_controller = gpriv;
 
+	ret = usb_add_gadget_udc(dev, &gpriv->gadget);
+	if (ret)
+		goto err_add_udc;
+
+
 	dev_info(dev, "gadget probed\n");
 
 	return 0;
+err_add_udc:
+	kfree(gpriv->uep);
 
 usbhs_mod_gadget_probe_err_gpriv:
 	kfree(gpriv);
 
-	return -ENOMEM;
+	return ret;
 }
 
 void __devexit usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 
+	usb_del_gadget_udc(&gpriv->gadget);
 	kfree(gpriv->uep);
 	kfree(gpriv);
 }

commit 08e6c611123ab499757e4133df7ddc0875c0dccf
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Thu Jun 9 16:48:25 2011 +0900

    usb: renesas_usbhs: fixup connection fail
    
    Sometimes the connection fail happen on renesas_usbhs.
    This patch fix it up.
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 46e247ad14f3..aa591b663835 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -462,8 +462,11 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	 * if it already have pipe,
 	 * nothing to do
 	 */
-	if (uep->pipe)
+	if (uep->pipe) {
+		usbhs_pipe_clear(uep->pipe);
+		usbhs_pipe_clear_sequence(uep->pipe);
 		return 0;
+	}
 
 	pipe = usbhs_pipe_malloc(priv, desc);
 	if (pipe) {

commit dcc854579059ff9633db4dc41c681371d22f794e
Merge: e73a9891b3a1 2c53b436a308
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 14 06:51:10 2011 -0700

    Merge 3.0-rc2 into usb-linus as it's needed by some USB patches
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e73a9891b3a1c9fc0970e0c9dbe2cc47933ad752
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:19:03 2011 +0900

    usb: renesas_usbhs: add DMAEngine support
    
    USB DMA was installed on "normal DMAC" when SH7724 or older SuperH,
    but the "USB-DMAC" was prepared on recent SuperH.
    These 2 DMAC have a little bit different behavior.
    
    This patch add DMAEngine code for "normal DMAC",
    but it is still using PIO fifo.
    The DMA fifo will be formally supported in the future.
    
    You can enable DMA fifo by local fixup
    usbhs_fifo_pio_push_handler -> usbhs_fifo_dma_push_handler
    usbhs_fifo_pio_pop_handler  -> usbhs_fifo_dma_pop_handler
    on usbhsg_ep_enable.
    
    This DMAEngine was tested by g_file_storage on SH7724 Ecovec board
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 89d2b16fbb10..31d28dc78aa3 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -160,6 +160,71 @@ static void usbhsg_queue_done(struct usbhs_pkt *pkt)
 	usbhsg_queue_pop(uep, ureq, 0);
 }
 
+static int usbhsg_dma_map(struct device *dev,
+			  struct usbhs_pkt *pkt,
+			  enum dma_data_direction dir)
+{
+	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
+	struct usb_request *req = &ureq->req;
+
+	if (pkt->dma != DMA_ADDR_INVALID) {
+		dev_err(dev, "dma is already mapped\n");
+		return -EIO;
+	}
+
+	if (req->dma == DMA_ADDR_INVALID) {
+		pkt->dma = dma_map_single(dev, pkt->buf, pkt->length, dir);
+	} else {
+		dma_sync_single_for_device(dev, req->dma, req->length, dir);
+		pkt->dma = req->dma;
+	}
+
+	if (dma_mapping_error(dev, pkt->dma)) {
+		dev_err(dev, "dma mapping error %x\n", pkt->dma);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int usbhsg_dma_unmap(struct device *dev,
+			    struct usbhs_pkt *pkt,
+			    enum dma_data_direction dir)
+{
+	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
+	struct usb_request *req = &ureq->req;
+
+	if (pkt->dma == DMA_ADDR_INVALID) {
+		dev_err(dev, "dma is not mapped\n");
+		return -EIO;
+	}
+
+	if (req->dma == DMA_ADDR_INVALID)
+		dma_unmap_single(dev, pkt->dma, pkt->length, dir);
+	else
+		dma_sync_single_for_cpu(dev, req->dma, req->length, dir);
+
+	pkt->dma = DMA_ADDR_INVALID;
+
+	return 0;
+}
+
+static int usbhsg_dma_map_ctrl(struct usbhs_pkt *pkt, int map)
+{
+	struct usbhs_pipe *pipe = pkt->pipe;
+	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	enum dma_data_direction dir;
+
+	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	if (map)
+		return usbhsg_dma_map(dev, pkt, dir);
+	else
+		return usbhsg_dma_unmap(dev, pkt, dir);
+}
+
 /*
  *		USB_TYPE_STANDARD / clear feature functions
  */
@@ -434,6 +499,8 @@ static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
 
 	usbhs_pkt_init(usbhsg_ureq_to_pkt(ureq));
 
+	ureq->req.dma = DMA_ADDR_INVALID;
+
 	return &ureq->req;
 }
 
@@ -569,7 +636,8 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * pipe initialize and enable DCP
 	 */
 	usbhs_pipe_init(priv,
-			usbhsg_queue_done);
+			usbhsg_queue_done,
+			usbhsg_dma_map_ctrl);
 	usbhs_fifo_init(priv);
 	usbhsg_uep_init(gpriv);
 

commit 0cb7e61d16ac68a2c5dd73a00e211287848d16e7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:58 2011 +0900

    usb: renesas_usbhs: tidyup pio handler name
    
    This patch tidyup PIO packet handler name.
    This is a preparation for DMAEngine support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 3c582482ec44..89d2b16fbb10 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -309,10 +309,10 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 
 	switch (stage) {
 	case READ_DATA_STAGE:
-		dcp->handler = &usbhs_fifo_push_handler;
+		dcp->handler = &usbhs_fifo_pio_push_handler;
 		break;
 	case WRITE_DATA_STAGE:
-		dcp->handler = &usbhs_fifo_pop_handler;
+		dcp->handler = &usbhs_fifo_pio_pop_handler;
 		break;
 	case NODATA_STATUS_STAGE:
 		dcp->handler = &usbhs_ctrl_stage_end_handler;
@@ -406,9 +406,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		pipe->mod_private	= uep;
 
 		if (usb_endpoint_dir_in(desc))
-			uep->handler = &usbhs_fifo_push_handler;
+			uep->handler = &usbhs_fifo_pio_push_handler;
 		else
-			uep->handler = &usbhs_fifo_pop_handler;
+			uep->handler = &usbhs_fifo_pio_pop_handler;
 
 		ret = 0;
 	}

commit 0432eed008024e0e90f16207ab406ac6ec877cac
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:54 2011 +0900

    usb: renesas_usbhs: tifyup packet start timing
    
    packet transfer timing are controlled in mod_gadget on current renesas_usbhs,
    and this style will be imitated on mod_host.
    But it need not be managed with host/gadget if it is general transfer.
    By this patch, the packet transfer timing is managed in fifo.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index b5a5ba7efb5e..3c582482ec44 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -125,23 +125,16 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 	struct usb_request *req = &ureq->req;
 
-	usbhs_pkt_push(pipe, pkt, uep->handler,
-		       req->buf, req->length, req->zero);
 	req->actual = 0;
 	req->status = -EINPROGRESS;
+	usbhs_pkt_push(pipe, pkt, uep->handler,
+		       req->buf, req->length, req->zero);
 
 	dev_dbg(dev, "pipe %d : queue push (%d)\n",
 		usbhs_pipe_number(pipe),
 		req->length);
 }
 
-static void usbhsg_queue_start(struct usbhsg_uep *uep)
-{
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-
-	usbhs_pkt_start(pipe);
-}
-
 static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 			     struct usbhsg_request *ureq,
 			     int status)
@@ -154,10 +147,6 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 
 	ureq->req.status = status;
 	ureq->req.complete(&uep->ep, &ureq->req);
-
-	/* more request ? */
-	if (0 == status)
-		usbhsg_queue_start(uep);
 }
 
 static void usbhsg_queue_done(struct usbhs_pkt *pkt)
@@ -222,6 +211,7 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usbhsg_uep *uep;
+	struct usbhs_pipe *pipe;
 	int recip = ctrl->bRequestType & USB_RECIP_MASK;
 	int nth = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;
 	int ret;
@@ -230,7 +220,8 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	char *msg;
 
 	uep = usbhsg_gpriv_to_nth_uep(gpriv, nth);
-	if (!usbhsg_uep_to_pipe(uep)) {
+	pipe = usbhsg_uep_to_pipe(uep);
+	if (!pipe) {
 		dev_err(dev, "wrong recip request\n");
 		ret = -EINVAL;
 		goto usbhsg_recip_run_handle_end;
@@ -268,7 +259,7 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	}
 
 usbhsg_recip_run_handle_end:
-	usbhsg_queue_start(uep);
+	usbhs_pkt_start(pipe);
 
 	return ret;
 }
@@ -470,7 +461,6 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 		return -ESHUTDOWN;
 
 	usbhsg_queue_push(uep, ureq);
-	usbhsg_queue_start(uep);
 
 	return 0;
 }

commit 97664a207bc2601a03a300f00e6922038cd5b99c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:38 2011 +0900

    usb: renesas_usbhs: shrink spin lock area
    
    spin lock was very effective while doing 1 packet send/recv on
    current renesas_usbhs driver.
    But this lock is enough only
     - modify packet/pipe link
     - modify interrpt mask
     - modify fifo access
    This patch shrink spin lock area
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 28b2b37f9661..b5a5ba7efb5e 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -92,7 +92,6 @@ struct usbhsg_recip_handle {
 	container_of(r, struct usbhsg_request, req)
 
 #define usbhsg_ep_to_uep(e)		container_of(e, struct usbhsg_uep, ep)
-#define usbhsg_gpriv_to_lock(gp)	usbhs_priv_to_lock((gp)->mod.priv)
 #define usbhsg_gpriv_to_dev(gp)		usbhs_priv_to_dev((gp)->mod.priv)
 #define usbhsg_gpriv_to_priv(gp)	((gp)->mod.priv)
 #define usbhsg_gpriv_to_dcp(gp)		((gp)->uep)
@@ -114,35 +113,6 @@ struct usbhsg_recip_handle {
 #define usbhsg_status_clr(gp, b) (gp->status &= ~b)
 #define usbhsg_status_has(gp, b) (gp->status &   b)
 
-/*
- *		usbhsg_trylock
- *
- * This driver don't use spin_try_lock
- * to avoid warning of CONFIG_DEBUG_SPINLOCK
- */
-static spinlock_t *usbhsg_trylock(struct usbhsg_gpriv *gpriv,
-				  unsigned long *flags)
-{
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
-
-	/* check spin lock status
-	 * to avoid deadlock/nest */
-	if (spin_is_locked(lock))
-		return NULL;
-
-	spin_lock_irqsave(lock, *flags);
-
-	return lock;
-}
-
-static void usbhsg_unlock(spinlock_t *lock, unsigned long *flags)
-{
-	if (!lock)
-		return;
-
-	spin_unlock_irqrestore(lock, *flags);
-}
-
 /*
  *		list push/pop
  */
@@ -155,9 +125,6 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 	struct usb_request *req = &ureq->req;
 
-	/*
-	 *********  assume under spin lock  *********
-	 */
 	usbhs_pkt_push(pipe, pkt, uep->handler,
 		       req->buf, req->length, req->zero);
 	req->actual = 0;
@@ -168,44 +135,11 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 		req->length);
 }
 
-static int usbhsg_queue_start(struct usbhsg_uep *uep)
+static void usbhsg_queue_start(struct usbhsg_uep *uep)
 {
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	struct usbhs_pkt *pkt;
-	spinlock_t *lock;
-	unsigned long flags;
-	int ret = 0;
-
-	/*
-	 * CAUTION [*queue handler*]
-	 *
-	 * This function will be called for start/restart queue operation.
-	 * OTOH the most much worry for USB driver is spinlock nest.
-	 * Specially it are
-	 *   - usb_ep_ops  :: queue
-	 *   - usb_request :: complete
-	 *
-	 * But the caller of this function need not care about spinlock.
-	 * This function is using usbhsg_trylock for it.
-	 * if "is_locked" is 1, this mean this function lock it.
-	 * but if it is 0, this mean it is already under spin lock.
-	 * see also
-	 *   CAUTION [*endpoint queue*]
-	 *   CAUTION [*request complete*]
-	 */
-
-	/******************  spin try lock *******************/
-	lock = usbhsg_trylock(gpriv, &flags);
-
-	pkt = usbhs_pkt_get(pipe);
-	if (pkt)
-		ret = usbhs_pkt_start(pkt);
-
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ******************/
 
-	return ret;
+	usbhs_pkt_start(pipe);
 }
 
 static void usbhsg_queue_pop(struct usbhsg_uep *uep,
@@ -215,34 +149,9 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	/*
-	 * CAUTION [*request complete*]
-	 *
-	 * There is a possibility not to be called in correct order
-	 * if "complete" is called without spinlock.
-	 *
-	 * So, this function assume it is under spinlock,
-	 * and call usb_request :: complete.
-	 *
-	 * But this "complete" will push next usb_request.
-	 * It mean "usb_ep_ops :: queue" which is using spinlock is called
-	 * under spinlock.
-	 *
-	 * To avoid dead-lock, this driver is using usbhsg_trylock.
-	 *   CAUTION [*endpoint queue*]
-	 *   CAUTION [*queue handler*]
-	 */
 
 	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
 
-	usbhs_pkt_pop(pkt);
-
 	ureq->req.status = status;
 	ureq->req.complete(&uep->ep, &ureq->req);
 
@@ -293,8 +202,6 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 
 	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
 
-	usbhsg_queue_start(uep);
-
 	return 0;
 }
 
@@ -325,7 +232,8 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	uep = usbhsg_gpriv_to_nth_uep(gpriv, nth);
 	if (!usbhsg_uep_to_pipe(uep)) {
 		dev_err(dev, "wrong recip request\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto usbhsg_recip_run_handle_end;
 	}
 
 	switch (recip) {
@@ -348,10 +256,20 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	}
 
 	if (func) {
+		unsigned long flags;
+
 		dev_dbg(dev, "%s (pipe %d :%s)\n", handler->name, nth, msg);
+
+		/********************  spin lock ********************/
+		usbhs_lock(priv, flags);
 		ret = func(priv, uep, ctrl);
+		usbhs_unlock(priv, flags);
+		/********************  spin unlock ******************/
 	}
 
+usbhsg_recip_run_handle_end:
+	usbhsg_queue_start(uep);
+
 	return ret;
 }
 
@@ -445,44 +363,17 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
  *		usb_dcp_ops
  *
  */
-static int usbhsg_dcp_enable(struct usbhsg_uep *uep)
-{
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
-	struct usbhs_pipe *pipe;
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	pipe = usbhs_dcp_malloc(priv);
-	if (!pipe)
-		return -EIO;
-
-	uep->pipe		= pipe;
-	uep->pipe->mod_private	= uep;
-
-	return 0;
-}
-
-#define usbhsg_dcp_disable usbhsg_pipe_disable
 static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 {
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhs_pkt *pkt;
 
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
 	usbhs_pipe_disable(pipe);
 
 	while (1) {
-		pkt = usbhs_pkt_get(pipe);
+		pkt = usbhs_pkt_pop(pipe, NULL);
 		if (!pkt)
 			break;
-
-		usbhs_pkt_pop(pkt);
 	}
 
 	return 0;
@@ -509,8 +400,6 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
-	spinlock_t *lock;
-	unsigned long flags;
 	int ret = -EIO;
 
 	/*
@@ -520,9 +409,6 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	if (uep->pipe)
 		return 0;
 
-	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
-
 	pipe = usbhs_pipe_malloc(priv, desc);
 	if (pipe) {
 		uep->pipe		= pipe;
@@ -536,29 +422,14 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		ret = 0;
 	}
 
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ******************/
-
 	return ret;
 }
 
 static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	spinlock_t *lock;
-	unsigned long flags;
-	int ret;
 
-	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
-
-	ret = usbhsg_pipe_disable(uep);
-
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ******************/
-
-	return ret;
+	return usbhsg_pipe_disable(uep);
 }
 
 static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
@@ -591,69 +462,28 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	spinlock_t *lock;
-	unsigned long flags;
-	int ret = 0;
-
-	/*
-	 * CAUTION [*endpoint queue*]
-	 *
-	 * This function will be called from usb_request :: complete
-	 * or usb driver timing.
-	 * If this function is called from usb_request :: complete,
-	 * it is already under spinlock on this driver.
-	 * but it is called frm usb driver, this function should call spinlock.
-	 *
-	 * This function is using usbshg_trylock to solve this issue.
-	 * if "is_locked" is 1, this mean this function lock it.
-	 * but if it is 0, this mean it is already under spin lock.
-	 * see also
-	 *   CAUTION [*queue handler*]
-	 *   CAUTION [*request complete*]
-	 */
-
-	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
 
 	/* param check */
 	if (usbhsg_is_not_connected(gpriv)	||
 	    unlikely(!gpriv->driver)		||
 	    unlikely(!pipe))
-		ret = -ESHUTDOWN;
-	else
-		usbhsg_queue_push(uep, ureq);
-
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ******************/
+		return -ESHUTDOWN;
 
+	usbhsg_queue_push(uep, ureq);
 	usbhsg_queue_start(uep);
 
-	return ret;
+	return 0;
 }
 
 static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	spinlock_t *lock;
-	unsigned long flags;
-
-	/*
-	 * see
-	 *   CAUTION [*queue handler*]
-	 *   CAUTION [*endpoint queue*]
-	 *   CAUTION [*request complete*]
-	 */
-
-	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 
+	usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));
 	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
 
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ******************/
-
 	return 0;
 }
 
@@ -662,42 +492,32 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	spinlock_t *lock;
 	unsigned long flags;
-	int ret = -EAGAIN;
 
-	/*
-	 * see
-	 *   CAUTION [*queue handler*]
-	 *   CAUTION [*endpoint queue*]
-	 *   CAUTION [*request complete*]
-	 */
-
-	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
-	if (!usbhs_pkt_get(pipe)) {
+	usbhsg_pipe_disable(uep);
 
-		dev_dbg(dev, "set halt %d (pipe %d)\n",
-			halt, usbhs_pipe_number(pipe));
+	dev_dbg(dev, "set halt %d (pipe %d)\n",
+		halt, usbhs_pipe_number(pipe));
 
-		if (halt)
-			usbhs_pipe_stall(pipe);
-		else
-			usbhs_pipe_disable(pipe);
+	/********************  spin lock ********************/
+	usbhs_lock(priv, flags);
 
-		if (halt && wedge)
-			usbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);
-		else
-			usbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);
+	if (halt)
+		usbhs_pipe_stall(pipe);
+	else
+		usbhs_pipe_disable(pipe);
 
-		ret = 0;
-	}
+	if (halt && wedge)
+		usbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);
+	else
+		usbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);
 
-	usbhsg_unlock(lock, &flags);
+	usbhs_unlock(priv, flags);
 	/********************  spin unlock ******************/
 
-	return ret;
+	return 0;
 }
 
 static int usbhsg_ep_set_halt(struct usb_ep *ep, int value)
@@ -733,20 +553,26 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
 	struct device *dev = usbhs_priv_to_dev(priv);
-	spinlock_t *lock;
 	unsigned long flags;
+	int ret = 0;
 
 	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
+	usbhs_lock(priv, flags);
 
-	/*
-	 * enable interrupt and systems if ready
-	 */
 	usbhsg_status_set(gpriv, status);
 	if (!(usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&
 	      usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD)))
-		goto usbhsg_try_start_unlock;
+		ret = -1; /* not ready */
+
+	usbhs_unlock(priv, flags);
+	/********************  spin unlock ********************/
+
+	if (ret < 0)
+		return 0; /* not ready is not error */
 
+	/*
+	 * enable interrupt and systems if ready
+	 */
 	dev_dbg(dev, "start gadget\n");
 
 	/*
@@ -756,7 +582,10 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 			usbhsg_queue_done);
 	usbhs_fifo_init(priv);
 	usbhsg_uep_init(gpriv);
-	usbhsg_dcp_enable(dcp);
+
+	/* dcp init */
+	dcp->pipe		= usbhs_dcp_malloc(priv);
+	dcp->pipe->mod_private	= dcp;
 
 	/*
 	 * system config enble
@@ -775,10 +604,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	mod->irq_ctrl_stage	= usbhsg_irq_ctrl_stage;
 	usbhs_irq_callback_update(priv, mod);
 
-usbhsg_try_start_unlock:
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ********************/
-
 	return 0;
 }
 
@@ -788,20 +613,26 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
 	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
 	struct device *dev = usbhs_priv_to_dev(priv);
-	spinlock_t *lock;
 	unsigned long flags;
+	int ret = 0;
 
 	/********************  spin lock ********************/
-	lock = usbhsg_trylock(gpriv, &flags);
+	usbhs_lock(priv, flags);
 
-	/*
-	 * disable interrupt and systems if 1st try
-	 */
 	usbhsg_status_clr(gpriv, status);
 	if (!usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&
 	    !usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD))
-		goto usbhsg_try_stop_unlock;
+		ret = -1; /* already done */
+
+	usbhs_unlock(priv, flags);
+	/********************  spin unlock ********************/
+
+	if (ret < 0)
+		return 0; /* already done is not error */
 
+	/*
+	 * disable interrupt and systems if 1st try
+	 */
 	usbhs_fifo_quit(priv);
 
 	/* disable all irq */
@@ -809,8 +640,6 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	mod->irq_ctrl_stage	= NULL;
 	usbhs_irq_callback_update(priv, mod);
 
-	usbhsg_dcp_disable(dcp);
-
 	gpriv->gadget.speed = USB_SPEED_UNKNOWN;
 
 	/* disable sys */
@@ -818,8 +647,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	usbhs_sys_function_ctrl(priv, 0);
 	usbhs_sys_usb_ctrl(priv, 0);
 
-	usbhsg_unlock(lock, &flags);
-	/********************  spin unlock ********************/
+	usbhsg_pipe_disable(dcp);
 
 	if (gpriv->driver &&
 	    gpriv->driver->disconnect)
@@ -827,11 +655,6 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 
 	dev_dbg(dev, "stop gadget\n");
 
-	return 0;
-
-usbhsg_try_stop_unlock:
-	usbhsg_unlock(lock, &flags);
-
 	return 0;
 }
 

commit 8a2c225ddb2d23a9b3f70af2ec70d28e4abd0b8e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:33 2011 +0900

    usb: renesas_usbhs: remove usbhsg_queue_get
    
    usbhsg_queue_get is no longer needed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 50c7566369eb..28b2b37f9661 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -168,20 +168,6 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 		req->length);
 }
 
-static struct usbhsg_request *usbhsg_queue_get(struct usbhsg_uep *uep)
-{
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	struct usbhs_pkt *pkt = usbhs_pkt_get(pipe);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-	if (!pkt)
-		return 0;
-
-	return usbhsg_pkt_to_ureq(pkt);
-}
-
 static int usbhsg_queue_start(struct usbhsg_uep *uep)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
@@ -483,7 +469,7 @@ static int usbhsg_dcp_enable(struct usbhsg_uep *uep)
 static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 {
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	struct usbhsg_request *ureq;
+	struct usbhs_pkt *pkt;
 
 	/*
 	 *********  assume under spin lock  *********
@@ -492,11 +478,11 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 	usbhs_pipe_disable(pipe);
 
 	while (1) {
-		ureq = usbhsg_queue_get(uep);
-		if (!ureq)
+		pkt = usbhs_pkt_get(pipe);
+		if (!pkt)
 			break;
 
-		usbhsg_queue_pop(uep, ureq, -ECONNRESET);
+		usbhs_pkt_pop(pkt);
 	}
 
 	return 0;
@@ -690,7 +676,7 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 
 	/********************  spin lock ********************/
 	lock = usbhsg_trylock(gpriv, &flags);
-	if (!usbhsg_queue_get(uep)) {
+	if (!usbhs_pkt_get(pipe)) {
 
 		dev_dbg(dev, "set halt %d (pipe %d)\n",
 			halt, usbhs_pipe_number(pipe));

commit dad67397f2090b29cd1f169e6a4ac6f3532c6858
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:28 2011 +0900

    usb: renesas_usbhs: modify data transfer interrupt
    
    On current driver, overall data transfer method was implemented in fifo.c,
    but its interrupt which is member of packet queue control
    was still in mod_gadget.c.
    This patch move it into fifo.c.
    By this patch, the packet/fifo control is independent from mod_gadget.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 298984f533dd..50c7566369eb 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -31,7 +31,6 @@ struct usbhsg_request {
 
 #define EP_NAME_SIZE 8
 struct usbhsg_gpriv;
-struct usbhsg_pipe_handle;
 struct usbhsg_uep {
 	struct usb_ep		 ep;
 	struct usbhs_pipe	*pipe;
@@ -39,7 +38,7 @@ struct usbhsg_uep {
 	char ep_name[EP_NAME_SIZE];
 
 	struct usbhsg_gpriv *gpriv;
-	struct usbhsg_pipe_handle *handler;
+	struct usbhs_pkt_handle *handler;
 };
 
 struct usbhsg_gpriv {
@@ -57,11 +56,6 @@ struct usbhsg_gpriv {
 #define USBHSG_STATUS_WEDGE		(1 << 2)
 };
 
-struct usbhsg_pipe_handle {
-	int (*prepare)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
-	int (*try_run)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
-};
-
 struct usbhsg_recip_handle {
 	char *name;
 	int (*device)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
@@ -164,7 +158,8 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	/*
 	 *********  assume under spin lock  *********
 	 */
-	usbhs_pkt_push(pipe, pkt, req->buf, req->length, req->zero);
+	usbhs_pkt_push(pipe, pkt, uep->handler,
+		       req->buf, req->length, req->zero);
 	req->actual = 0;
 	req->status = -EINPROGRESS;
 
@@ -187,22 +182,15 @@ static struct usbhsg_request *usbhsg_queue_get(struct usbhsg_uep *uep)
 	return usbhsg_pkt_to_ureq(pkt);
 }
 
-#define usbhsg_queue_prepare(uep) __usbhsg_queue_handler(uep, 1);
-#define usbhsg_queue_handle(uep)  __usbhsg_queue_handler(uep, 0);
-static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
+static int usbhsg_queue_start(struct usbhsg_uep *uep)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	struct usbhsg_request *ureq;
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pkt *pkt;
 	spinlock_t *lock;
 	unsigned long flags;
 	int ret = 0;
 
-	if (!uep->handler) {
-		dev_err(dev, "no handler function\n");
-		return -EIO;
-	}
-
 	/*
 	 * CAUTION [*queue handler*]
 	 *
@@ -224,13 +212,10 @@ static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
 	/******************  spin try lock *******************/
 	lock = usbhsg_trylock(gpriv, &flags);
 
-	ureq = usbhsg_queue_get(uep);
-	if (ureq) {
-		if (prepare)
-			ret = uep->handler->prepare(uep, ureq);
-		else
-			ret = uep->handler->try_run(uep, ureq);
-	}
+	pkt = usbhs_pkt_get(pipe);
+	if (pkt)
+		ret = usbhs_pkt_start(pkt);
+
 	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
@@ -277,59 +262,10 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 
 	/* more request ? */
 	if (0 == status)
-		usbhsg_queue_prepare(uep);
+		usbhsg_queue_start(uep);
 }
 
-/*
- *		irq enable/disable function
- */
-#define usbhsg_irq_callback_ctrl(uep, status, enable)			\
-	({								\
-		struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);	\
-		struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);	\
-		struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);	\
-		struct usbhs_mod *mod = usbhs_mod_get_current(priv);	\
-		if (!mod)						\
-			return;						\
-		if (enable)						\
-			mod->irq_##status |= (1 << usbhs_pipe_number(pipe)); \
-		else							\
-			mod->irq_##status &= ~(1 << usbhs_pipe_number(pipe)); \
-		usbhs_irq_callback_update(priv, mod);			\
-	})
-
-static void usbhsg_irq_empty_ctrl(struct usbhsg_uep *uep, int enable)
-{
-	usbhsg_irq_callback_ctrl(uep, bempsts, enable);
-}
-
-static void usbhsg_irq_ready_ctrl(struct usbhsg_uep *uep, int enable)
-{
-	usbhsg_irq_callback_ctrl(uep, brdysts, enable);
-}
-
-/*
- *		handler function
- */
-static int usbhsg_try_run_ctrl_stage_end(struct usbhsg_uep *uep,
-					 struct usbhsg_request *ureq)
-{
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	usbhs_dcp_control_transfer_done(pipe);
-	usbhsg_queue_pop(uep, ureq, 0);
-
-	return 0;
-}
-
-/*
- *		packet send hander
- */
-static void usbhsg_send_packet_done(struct usbhs_pkt *pkt)
+static void usbhsg_queue_done(struct usbhs_pkt *pkt)
 {
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
@@ -340,108 +276,6 @@ static void usbhsg_send_packet_done(struct usbhs_pkt *pkt)
 	usbhsg_queue_pop(uep, ureq, 0);
 }
 
-static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
-				      struct usbhsg_request *ureq)
-{
-	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	usbhs_fifo_write(pkt);
-
-	return 0;
-}
-
-static int usbhsg_prepare_send_packet(struct usbhsg_uep *uep,
-				      struct usbhsg_request *ureq)
-{
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	usbhs_fifo_prepare_write(pipe);
-	usbhsg_try_run_send_packet(uep, ureq);
-
-	return 0;
-}
-
-/*
- *		packet recv hander
- */
-static void usbhsg_receive_packet_done(struct usbhs_pkt *pkt)
-{
-	struct usbhs_pipe *pipe = pkt->pipe;
-	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
-	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
-
-	ureq->req.actual = pkt->actual;
-
-	usbhsg_queue_pop(uep, ureq, 0);
-}
-
-static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
-					 struct usbhsg_request *ureq)
-{
-	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	return usbhs_fifo_read(pkt);
-}
-
-static int usbhsg_prepare_receive_packet(struct usbhsg_uep *uep,
-					 struct usbhsg_request *ureq)
-{
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	return usbhs_fifo_prepare_read(pipe);
-}
-
-static struct usbhsg_pipe_handle usbhsg_handler_send_by_empty = {
-	.prepare	= usbhsg_prepare_send_packet,
-	.try_run	= usbhsg_try_run_send_packet,
-};
-
-static struct usbhsg_pipe_handle usbhsg_handler_send_by_ready = {
-	.prepare	= usbhsg_prepare_send_packet,
-	.try_run	= usbhsg_try_run_send_packet,
-};
-
-static struct usbhsg_pipe_handle usbhsg_handler_recv_by_ready = {
-	.prepare	= usbhsg_prepare_receive_packet,
-	.try_run	= usbhsg_try_run_receive_packet,
-};
-
-static struct usbhsg_pipe_handle usbhsg_handler_ctrl_stage_end = {
-	.prepare	= usbhsg_try_run_ctrl_stage_end,
-	.try_run	= usbhsg_try_run_ctrl_stage_end,
-};
-
-/*
- * DCP pipe can NOT use "ready interrupt" for "send"
- * it should use "empty" interrupt.
- * see
- *   "Operation" - "Interrupt Function" - "BRDY Interrupt"
- *
- * on the other hand, normal pipe can use "ready interrupt" for "send"
- * even though it is single/double buffer
- */
-#define usbhsg_handler_send_ctrl	usbhsg_handler_send_by_empty
-#define usbhsg_handler_recv_ctrl	usbhsg_handler_recv_by_ready
-
-#define usbhsg_handler_send_packet	usbhsg_handler_send_by_ready
-#define usbhsg_handler_recv_packet	usbhsg_handler_recv_by_ready
-
 /*
  *		USB_TYPE_STANDARD / clear feature functions
  */
@@ -473,7 +307,7 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 
 	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
 
-	usbhsg_queue_prepare(uep);
+	usbhsg_queue_start(uep);
 
 	return 0;
 }
@@ -580,13 +414,13 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 
 	switch (stage) {
 	case READ_DATA_STAGE:
-		dcp->handler = &usbhsg_handler_send_ctrl;
+		dcp->handler = &usbhs_fifo_push_handler;
 		break;
 	case WRITE_DATA_STAGE:
-		dcp->handler = &usbhsg_handler_recv_ctrl;
+		dcp->handler = &usbhs_fifo_pop_handler;
 		break;
 	case NODATA_STATUS_STAGE:
-		dcp->handler = &usbhsg_handler_ctrl_stage_end;
+		dcp->handler = &usbhs_ctrl_stage_end_handler;
 		break;
 	default:
 		return ret;
@@ -620,72 +454,6 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 	return ret;
 }
 
-static int usbhsg_irq_empty(struct usbhs_priv *priv,
-			    struct usbhs_irq_state *irq_state)
-{
-	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
-	struct usbhsg_uep *uep;
-	struct usbhs_pipe *pipe;
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	int i, ret;
-
-	if (!irq_state->bempsts) {
-		dev_err(dev, "debug %s !!\n", __func__);
-		return -EIO;
-	}
-
-	dev_dbg(dev, "irq empty [0x%04x]\n", irq_state->bempsts);
-
-	/*
-	 * search interrupted "pipe"
-	 * not "uep".
-	 */
-	usbhs_for_each_pipe_with_dcp(pipe, priv, i) {
-		if (!(irq_state->bempsts & (1 << i)))
-			continue;
-
-		uep	= usbhsg_pipe_to_uep(pipe);
-		ret	= usbhsg_queue_handle(uep);
-		if (ret < 0)
-			dev_err(dev, "send error %d : %d\n", i, ret);
-	}
-
-	return 0;
-}
-
-static int usbhsg_irq_ready(struct usbhs_priv *priv,
-			    struct usbhs_irq_state *irq_state)
-{
-	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
-	struct usbhsg_uep *uep;
-	struct usbhs_pipe *pipe;
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	int i, ret;
-
-	if (!irq_state->brdysts) {
-		dev_err(dev, "debug %s !!\n", __func__);
-		return -EIO;
-	}
-
-	dev_dbg(dev, "irq ready [0x%04x]\n", irq_state->brdysts);
-
-	/*
-	 * search interrupted "pipe"
-	 * not "uep".
-	 */
-	usbhs_for_each_pipe_with_dcp(pipe, priv, i) {
-		if (!(irq_state->brdysts & (1 << i)))
-			continue;
-
-		uep	= usbhsg_pipe_to_uep(pipe);
-		ret	= usbhsg_queue_handle(uep);
-		if (ret < 0)
-			dev_err(dev, "receive error %d : %d\n", i, ret);
-	}
-
-	return 0;
-}
-
 /*
  *
  *		usb_dcp_ops
@@ -716,7 +484,6 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 {
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhsg_request *ureq;
-	int disable = 0;
 
 	/*
 	 *********  assume under spin lock  *********
@@ -724,12 +491,6 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 
 	usbhs_pipe_disable(pipe);
 
-	/*
-	 * disable pipe irq
-	 */
-	usbhsg_irq_empty_ctrl(uep, disable);
-	usbhsg_irq_ready_ctrl(uep, disable);
-
 	while (1) {
 		ureq = usbhsg_queue_get(uep);
 		if (!ureq)
@@ -782,9 +543,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		pipe->mod_private	= uep;
 
 		if (usb_endpoint_dir_in(desc))
-			uep->handler = &usbhsg_handler_send_packet;
+			uep->handler = &usbhs_fifo_push_handler;
 		else
-			uep->handler = &usbhsg_handler_recv_packet;
+			uep->handler = &usbhs_fifo_pop_handler;
 
 		ret = 0;
 	}
@@ -879,7 +640,7 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
-	usbhsg_queue_prepare(uep);
+	usbhsg_queue_start(uep);
 
 	return ret;
 }
@@ -1006,8 +767,8 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * pipe initialize and enable DCP
 	 */
 	usbhs_pipe_init(priv,
-			usbhsg_send_packet_done,
-			usbhsg_receive_packet_done);
+			usbhsg_queue_done);
+	usbhs_fifo_init(priv);
 	usbhsg_uep_init(gpriv);
 	usbhsg_dcp_enable(dcp);
 
@@ -1026,10 +787,6 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 */
 	mod->irq_dev_state	= usbhsg_irq_dev_state;
 	mod->irq_ctrl_stage	= usbhsg_irq_ctrl_stage;
-	mod->irq_empty		= usbhsg_irq_empty;
-	mod->irq_ready		= usbhsg_irq_ready;
-	mod->irq_bempsts	= 0;
-	mod->irq_brdysts	= 0;
 	usbhs_irq_callback_update(priv, mod);
 
 usbhsg_try_start_unlock:
@@ -1059,13 +816,11 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	    !usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD))
 		goto usbhsg_try_stop_unlock;
 
+	usbhs_fifo_quit(priv);
+
 	/* disable all irq */
 	mod->irq_dev_state	= NULL;
 	mod->irq_ctrl_stage	= NULL;
-	mod->irq_empty		= NULL;
-	mod->irq_ready		= NULL;
-	mod->irq_bempsts	= 0;
-	mod->irq_brdysts	= 0;
 	usbhs_irq_callback_update(priv, mod);
 
 	usbhsg_dcp_disable(dcp);

commit 659d495404d20ff8f96644fca82c772455f1226c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:23 2011 +0900

    usb: renesas_usbhs: modify data transfer method
    
    On current driver, main data transfer function was implemented in fifo.c,
    but the overall controlling was implementing in mod_gadget.c.
    This style is not useful to support host and DMAEngine in the future.
    
    But the interrupt for data transfer cannot separate easily for now,
    because it is deeply related to mod_gadget.
    
    This patch move the overall data transfer method
    into fifo.c except interrupt.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index a3818773dec1..298984f533dd 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -60,7 +60,6 @@ struct usbhsg_gpriv {
 struct usbhsg_pipe_handle {
 	int (*prepare)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
 	int (*try_run)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
-	void (*irq_mask)(struct usbhsg_uep *uep, int enable);
 };
 
 struct usbhsg_recip_handle {
@@ -160,17 +159,18 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
+	struct usb_request *req = &ureq->req;
 
 	/*
 	 *********  assume under spin lock  *********
 	 */
-	usbhs_pkt_push(pipe, pkt);
-	ureq->req.actual = 0;
-	ureq->req.status = -EINPROGRESS;
+	usbhs_pkt_push(pipe, pkt, req->buf, req->length, req->zero);
+	req->actual = 0;
+	req->status = -EINPROGRESS;
 
 	dev_dbg(dev, "pipe %d : queue push (%d)\n",
 		usbhs_pipe_number(pipe),
-		ureq->req.length);
+		req->length);
 }
 
 static struct usbhsg_request *usbhsg_queue_get(struct usbhsg_uep *uep)
@@ -329,83 +329,27 @@ static int usbhsg_try_run_ctrl_stage_end(struct usbhsg_uep *uep,
 /*
  *		packet send hander
  */
-static void usbhsg_try_run_send_packet_bh(struct usbhs_pkt *pkt)
+static void usbhsg_send_packet_done(struct usbhs_pkt *pkt)
 {
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
-	struct usb_request *req = &ureq->req;
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	int remainder, send, maxp;
-	int is_done = 0;
-	int enable;
 
-	maxp		= pkt->maxp;
-	send		= pkt->actual;
-	remainder	= pkt->length;
+	ureq->req.actual = pkt->actual;
 
-	/*
-	 * send = 0 : send zero packet
-	 * send > 0 : send data
-	 *
-	 * send <= max_packet
-	 */
-	req->actual += send;
-
-	/* send all packet ? */
-	if (send < remainder)
-		is_done = 0;		/* there are remainder data */
-	else if (send < maxp)
-		is_done = 1;		/* short packet */
-	else
-		is_done = !req->zero;	/* send zero packet ? */
-
-	dev_dbg(dev, "  send %d (%d/ %d/ %d/ %d)\n",
-		usbhs_pipe_number(pipe),
-		remainder, send, is_done, req->zero);
-
-	/*
-	 * enable interrupt and send again in irq handler
-	 * if it still have remainder data which should be sent.
-	 */
-	enable = !is_done;
-	uep->handler->irq_mask(uep, enable);
-
-	/*
-	 * all data were sent ?
-	 */
-	if (is_done) {
-		/* it care below call in
-		   "function mode" */
-		if (usbhsg_is_dcp(uep))
-			usbhs_dcp_control_transfer_done(pipe);
-
-		usbhsg_queue_pop(uep, ureq, 0);
-	}
+	usbhsg_queue_pop(uep, ureq, 0);
 }
 
 static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 				      struct usbhsg_request *ureq)
 {
-	struct usb_request *req = &ureq->req;
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
-	int ret;
 
 	/*
 	 *********  assume under spin lock  *********
 	 */
 
-	usbhs_pkt_update(pkt,
-			 req->buf    + req->actual,
-			 req->length - req->actual);
-
-	ret = usbhs_fifo_write(pkt);
-	if (ret < 0) {
-		/* pipe is busy.
-		 * retry in interrupt */
-		uep->handler->irq_mask(uep, 1);
-	}
+	usbhs_fifo_write(pkt);
 
 	return 0;
 }
@@ -428,63 +372,26 @@ static int usbhsg_prepare_send_packet(struct usbhsg_uep *uep,
 /*
  *		packet recv hander
  */
-static void usbhsg_try_run_receive_packet_bh(struct usbhs_pkt *pkt)
+static void usbhsg_receive_packet_done(struct usbhs_pkt *pkt)
 {
 	struct usbhs_pipe *pipe = pkt->pipe;
 	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
 	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
-	struct usb_request *req = &ureq->req;
-	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	int remainder, recv, maxp;
-	int is_done = 0;
-
-	maxp		= pkt->maxp;
-	remainder	= pkt->length;
-	recv		= pkt->actual;
-
-	/*
-	 * recv < 0  : pipe busy
-	 * recv >= 0 : receive data
-	 *
-	 * recv <= max_packet
-	 */
-
-	/* update parameters */
-	req->actual += recv;
-
-	if ((recv == remainder) ||	/* receive all data */
-	    (recv < maxp))		/* short packet */
-		is_done = 1;
 
-	dev_dbg(dev, "  recv %d (%d/ %d/ %d/ %d)\n",
-		usbhs_pipe_number(pipe),
-		remainder, recv, is_done, req->zero);
-
-	/* read all data ? */
-	if (is_done) {
-		int disable = 0;
+	ureq->req.actual = pkt->actual;
 
-		uep->handler->irq_mask(uep, disable);
-		usbhs_pipe_disable(pipe);
-		usbhsg_queue_pop(uep, ureq, 0);
-	}
+	usbhsg_queue_pop(uep, ureq, 0);
 }
 
 static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
 					 struct usbhsg_request *ureq)
 {
-	struct usb_request *req = &ureq->req;
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 
 	/*
 	 *********  assume under spin lock  *********
 	 */
 
-	usbhs_pkt_update(pkt,
-			 req->buf    + req->actual,
-			 req->length - req->actual);
-
 	return usbhs_fifo_read(pkt);
 }
 
@@ -492,41 +399,27 @@ static int usbhsg_prepare_receive_packet(struct usbhsg_uep *uep,
 					 struct usbhsg_request *ureq)
 {
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	int enable = 1;
-	int ret;
 
 	/*
 	 *********  assume under spin lock  *********
 	 */
 
-	ret = usbhs_fifo_prepare_read(pipe);
-	if (ret < 0)
-		return ret;
-
-	/*
-	 * data will be read in interrupt handler
-	 */
-	uep->handler->irq_mask(uep, enable);
-
-	return ret;
+	return usbhs_fifo_prepare_read(pipe);
 }
 
 static struct usbhsg_pipe_handle usbhsg_handler_send_by_empty = {
 	.prepare	= usbhsg_prepare_send_packet,
 	.try_run	= usbhsg_try_run_send_packet,
-	.irq_mask	= usbhsg_irq_empty_ctrl,
 };
 
 static struct usbhsg_pipe_handle usbhsg_handler_send_by_ready = {
 	.prepare	= usbhsg_prepare_send_packet,
 	.try_run	= usbhsg_try_run_send_packet,
-	.irq_mask	= usbhsg_irq_ready_ctrl,
 };
 
 static struct usbhsg_pipe_handle usbhsg_handler_recv_by_ready = {
 	.prepare	= usbhsg_prepare_receive_packet,
 	.try_run	= usbhsg_try_run_receive_packet,
-	.irq_mask	= usbhsg_irq_ready_ctrl,
 };
 
 static struct usbhsg_pipe_handle usbhsg_handler_ctrl_stage_end = {
@@ -1113,8 +1006,8 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * pipe initialize and enable DCP
 	 */
 	usbhs_pipe_init(priv,
-			usbhsg_try_run_send_packet_bh,
-			usbhsg_try_run_receive_packet_bh);
+			usbhsg_send_packet_done,
+			usbhsg_receive_packet_done);
 	usbhsg_uep_init(gpriv);
 	usbhsg_dcp_enable(dcp);
 

commit 6acb95d4e0709a582023e87f9b3537fb4d837fd0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:16 2011 +0900

    usb: renesas_usbhs: modify packet queue control method
    
    Current renesas_usbhs driver is controlling packet queue on mod_gadget.c.
    But it has relationship with pipe/fifo, not host/gadget.
    So, controlling USB packet queue in pipe.c/fifo.c is
    more convenient than in mod_gadget.c.
    This patch modify it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 4a1d1fcc90fd..a3818773dec1 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -26,7 +26,6 @@
  */
 struct usbhsg_request {
 	struct usb_request	req;
-	struct list_head	node;
 	struct usbhs_pkt	pkt;
 };
 
@@ -36,7 +35,6 @@ struct usbhsg_pipe_handle;
 struct usbhsg_uep {
 	struct usb_ep		 ep;
 	struct usbhs_pipe	*pipe;
-	struct list_head	 list;
 
 	char ep_name[EP_NAME_SIZE];
 
@@ -161,12 +159,12 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 
 	/*
 	 *********  assume under spin lock  *********
 	 */
-	list_del_init(&ureq->node);
-	list_add_tail(&ureq->node, &uep->list);
+	usbhs_pkt_push(pipe, pkt);
 	ureq->req.actual = 0;
 	ureq->req.status = -EINPROGRESS;
 
@@ -177,13 +175,16 @@ static void usbhsg_queue_push(struct usbhsg_uep *uep,
 
 static struct usbhsg_request *usbhsg_queue_get(struct usbhsg_uep *uep)
 {
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pkt *pkt = usbhs_pkt_get(pipe);
+
 	/*
 	 *********  assume under spin lock  *********
 	 */
-	if (list_empty(&uep->list))
-		return NULL;
+	if (!pkt)
+		return 0;
 
-	return list_entry(uep->list.next, struct usbhsg_request, node);
+	return usbhsg_pkt_to_ureq(pkt);
 }
 
 #define usbhsg_queue_prepare(uep) __usbhsg_queue_handler(uep, 1);
@@ -243,6 +244,7 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 
 	/*
 	 *********  assume under spin lock  *********
@@ -268,7 +270,7 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 
 	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
 
-	list_del_init(&ureq->node);
+	usbhs_pkt_pop(pkt);
 
 	ureq->req.status = status;
 	ureq->req.complete(&uep->ep, &ureq->req);
@@ -386,7 +388,6 @@ static void usbhsg_try_run_send_packet_bh(struct usbhs_pkt *pkt)
 static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 				      struct usbhsg_request *ureq)
 {
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usb_request *req = &ureq->req;
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 	int ret;
@@ -395,7 +396,7 @@ static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 	 *********  assume under spin lock  *********
 	 */
 
-	usbhs_pkt_update(pkt, pipe,
+	usbhs_pkt_update(pkt,
 			 req->buf    + req->actual,
 			 req->length - req->actual);
 
@@ -473,7 +474,6 @@ static void usbhsg_try_run_receive_packet_bh(struct usbhs_pkt *pkt)
 static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
 					 struct usbhsg_request *ureq)
 {
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usb_request *req = &ureq->req;
 	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
 
@@ -481,7 +481,7 @@ static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
 	 *********  assume under spin lock  *********
 	 */
 
-	usbhs_pkt_update(pkt, pipe,
+	usbhs_pkt_update(pkt,
 			 req->buf    + req->actual,
 			 req->length - req->actual);
 
@@ -814,7 +814,6 @@ static int usbhsg_dcp_enable(struct usbhsg_uep *uep)
 
 	uep->pipe		= pipe;
 	uep->pipe->mod_private	= uep;
-	INIT_LIST_HEAD(&uep->list);
 
 	return 0;
 }
@@ -888,7 +887,6 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	if (pipe) {
 		uep->pipe		= pipe;
 		pipe->mod_private	= uep;
-		INIT_LIST_HEAD(&uep->list);
 
 		if (usb_endpoint_dir_in(desc))
 			uep->handler = &usbhsg_handler_send_packet;
@@ -932,7 +930,8 @@ static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
 	if (!ureq)
 		return NULL;
 
-	INIT_LIST_HEAD(&ureq->node);
+	usbhs_pkt_init(usbhsg_ureq_to_pkt(ureq));
+
 	return &ureq->req;
 }
 
@@ -941,7 +940,7 @@ static void usbhsg_ep_free_request(struct usb_ep *ep,
 {
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
 
-	WARN_ON(!list_empty(&ureq->node));
+	WARN_ON(!list_empty(&ureq->pkt.node));
 	kfree(ureq);
 }
 
@@ -1379,7 +1378,6 @@ int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		uep->ep.name		= uep->ep_name;
 		uep->ep.ops		= &usbhsg_ep_ops;
 		INIT_LIST_HEAD(&uep->ep.ep_list);
-		INIT_LIST_HEAD(&uep->list);
 
 		/* init DCP */
 		if (usbhsg_is_dcp(uep)) {

commit 4bd0481152d0d5e8326d7e24329b0069713ed718
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:07 2011 +0900

    usb: renesas_usbhs: divide data transfer functions
    
    DMAEngine will be supported to this driver in the future.
    Then, both PIO and DMA data transfer method should be supported.
    But, the transfer function can returns the result immediately
    in PIO version, but it can't in DMA version.
    This patch divides data transfer functions into top/bottom half
    in preparation for DMAEngine support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 128c8da8db85..4a1d1fcc90fd 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -27,6 +27,7 @@
 struct usbhsg_request {
 	struct usb_request	req;
 	struct list_head	node;
+	struct usbhs_pkt	pkt;
 };
 
 #define EP_NAME_SIZE 8
@@ -110,6 +111,10 @@ struct usbhsg_recip_handle {
 #define usbhsg_pipe_to_uep(p)		((p)->mod_private)
 #define usbhsg_is_dcp(u)		((u) == usbhsg_gpriv_to_dcp((u)->gpriv))
 
+#define usbhsg_ureq_to_pkt(u)		(&(u)->pkt)
+#define usbhsg_pkt_to_ureq(i)	\
+	container_of(i, struct usbhsg_request, pkt)
+
 #define usbhsg_is_not_connected(gp) ((gp)->gadget.speed == USB_SPEED_UNKNOWN)
 
 /* status */
@@ -319,38 +324,32 @@ static int usbhsg_try_run_ctrl_stage_end(struct usbhsg_uep *uep,
 	return 0;
 }
 
-static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
-				      struct usbhsg_request *ureq)
+/*
+ *		packet send hander
+ */
+static void usbhsg_try_run_send_packet_bh(struct usbhs_pkt *pkt)
 {
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pipe *pipe = pkt->pipe;
+	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
+	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
 	struct usb_request *req = &ureq->req;
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	void *buf;
-	int remainder, send;
+	int remainder, send, maxp;
 	int is_done = 0;
 	int enable;
-	int maxp;
 
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	maxp		= usbhs_pipe_get_maxpacket(pipe);
-	buf		= req->buf    + req->actual;
-	remainder	= req->length - req->actual;
-
-	send = usbhs_fifo_write(pipe, buf, remainder);
+	maxp		= pkt->maxp;
+	send		= pkt->actual;
+	remainder	= pkt->length;
 
 	/*
-	 * send < 0 : pipe busy
 	 * send = 0 : send zero packet
 	 * send > 0 : send data
 	 *
 	 * send <= max_packet
 	 */
-	if (send > 0)
-		req->actual += send;
+	req->actual += send;
 
 	/* send all packet ? */
 	if (send < remainder)
@@ -371,13 +370,6 @@ static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 	enable = !is_done;
 	uep->handler->irq_mask(uep, enable);
 
-	/*
-	 * usbhs_fifo_enable execute
-	 *  - after callback_update,
-	 *  - before queue_pop / stage_end
-	 */
-	usbhs_pipe_enable(pipe);
-
 	/*
 	 * all data were sent ?
 	 */
@@ -389,6 +381,30 @@ static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 
 		usbhsg_queue_pop(uep, ureq, 0);
 	}
+}
+
+static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
+				      struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usb_request *req = &ureq->req;
+	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
+	int ret;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	usbhs_pkt_update(pkt, pipe,
+			 req->buf    + req->actual,
+			 req->length - req->actual);
+
+	ret = usbhs_fifo_write(pkt);
+	if (ret < 0) {
+		/* pipe is busy.
+		 * retry in interrupt */
+		uep->handler->irq_mask(uep, 1);
+	}
 
 	return 0;
 }
@@ -408,35 +424,30 @@ static int usbhsg_prepare_send_packet(struct usbhsg_uep *uep,
 	return 0;
 }
 
-static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
-					 struct usbhsg_request *ureq)
+/*
+ *		packet recv hander
+ */
+static void usbhsg_try_run_receive_packet_bh(struct usbhs_pkt *pkt)
 {
-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhs_pipe *pipe = pkt->pipe;
+	struct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);
+	struct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);
 	struct usb_request *req = &ureq->req;
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	void *buf;
-	int maxp;
-	int remainder, recv;
+	int remainder, recv, maxp;
 	int is_done = 0;
 
-	/*
-	 *********  assume under spin lock  *********
-	 */
-
-	maxp		= usbhs_pipe_get_maxpacket(pipe);
-	buf		= req->buf    + req->actual;
-	remainder	= req->length - req->actual;
+	maxp		= pkt->maxp;
+	remainder	= pkt->length;
+	recv		= pkt->actual;
 
-	recv = usbhs_fifo_read(pipe, buf, remainder);
 	/*
 	 * recv < 0  : pipe busy
 	 * recv >= 0 : receive data
 	 *
 	 * recv <= max_packet
 	 */
-	if (recv < 0)
-		return -EBUSY;
 
 	/* update parameters */
 	req->actual += recv;
@@ -457,8 +468,24 @@ static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
 		usbhs_pipe_disable(pipe);
 		usbhsg_queue_pop(uep, ureq, 0);
 	}
+}
 
-	return 0;
+static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
+					 struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usb_request *req = &ureq->req;
+	struct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	usbhs_pkt_update(pkt, pipe,
+			 req->buf    + req->actual,
+			 req->length - req->actual);
+
+	return usbhs_fifo_read(pkt);
 }
 
 static int usbhsg_prepare_receive_packet(struct usbhsg_uep *uep,
@@ -1086,7 +1113,9 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	/*
 	 * pipe initialize and enable DCP
 	 */
-	usbhs_pipe_init(priv);
+	usbhs_pipe_init(priv,
+			usbhsg_try_run_send_packet_bh,
+			usbhsg_try_run_receive_packet_bh);
 	usbhsg_uep_init(gpriv);
 	usbhsg_dcp_enable(dcp);
 

commit e8d548d549688d335236f7f6f8bcee141a207ff8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 6 14:18:03 2011 +0900

    usb: renesas_usbhs: fifo became independent from pipe.
    
    Current renesas_usbhs has PIO data transfer mode which controls CFIFO.
    And it was implemented in pipe.c.
    But, fifo control method needs more flexible implementation
    to support DMAEngine.
    This patch create fifo.c, and it became independent from pipe.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 206cfabc9286..128c8da8db85 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -376,7 +376,7 @@ static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
 	 *  - after callback_update,
 	 *  - before queue_pop / stage_end
 	 */
-	usbhs_fifo_enable(pipe);
+	usbhs_pipe_enable(pipe);
 
 	/*
 	 * all data were sent ?
@@ -454,7 +454,7 @@ static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
 		int disable = 0;
 
 		uep->handler->irq_mask(uep, disable);
-		usbhs_fifo_disable(pipe);
+		usbhs_pipe_disable(pipe);
 		usbhsg_queue_pop(uep, ureq, 0);
 	}
 
@@ -546,9 +546,9 @@ static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 
 	if (!usbhsg_status_has(gpriv, USBHSG_STATUS_WEDGE)) {
-		usbhs_fifo_disable(pipe);
+		usbhs_pipe_disable(pipe);
 		usbhs_pipe_clear_sequence(pipe);
-		usbhs_fifo_enable(pipe);
+		usbhs_pipe_enable(pipe);
 	}
 
 	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
@@ -695,7 +695,7 @@ static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
 		ret = gpriv->driver->setup(&gpriv->gadget, &ctrl);
 
 	if (ret < 0)
-		usbhs_fifo_stall(pipe);
+		usbhs_pipe_stall(pipe);
 
 	return ret;
 }
@@ -803,7 +803,7 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 	 *********  assume under spin lock  *********
 	 */
 
-	usbhs_fifo_disable(pipe);
+	usbhs_pipe_disable(pipe);
 
 	/*
 	 * disable pipe irq
@@ -1016,9 +1016,9 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 			halt, usbhs_pipe_number(pipe));
 
 		if (halt)
-			usbhs_fifo_stall(pipe);
+			usbhs_pipe_stall(pipe);
 		else
-			usbhs_fifo_disable(pipe);
+			usbhs_pipe_disable(pipe);
 
 		if (halt && wedge)
 			usbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);

commit 3af51ac9c0889a188aaa3defe5134ef97c80d7c5
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Jun 3 19:50:48 2011 +0200

    usb/renesas_usbhs: free uep on removal
    
    Can't find evidence that this is actually done.
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 206cfabc9286..547486ccd059 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -1380,5 +1380,6 @@ void __devexit usbhs_mod_gadget_remove(struct usbhs_priv *priv)
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 
+	kfree(gpriv->uep);
 	kfree(gpriv);
 }

commit 9a28b7bd4f1fb388a15b12fb425a589ba6188425
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 21 14:10:12 2011 +0900

    usb: renesas_usbhs: return error if wrong recip request
    
    There are some USB Host which doesn't notice disconnection at once.
    And it might try some request after reconnection with old settings.
    Current renesas_usbhs will crash in such case.
    This patch prevent this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index d027c80ab359..206cfabc9286 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -583,6 +583,10 @@ static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
 	char *msg;
 
 	uep = usbhsg_gpriv_to_nth_uep(gpriv, nth);
+	if (!usbhsg_uep_to_pipe(uep)) {
+		dev_err(dev, "wrong recip request\n");
+		return -EINVAL;
+	}
 
 	switch (recip) {
 	case USB_RECIP_DEVICE:

commit cb96632c185f13f746d009ec1125539e0b5cd899
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 21 14:10:08 2011 +0900

    usb: renesas_usbhs: modify spinlock method
    
    Current renesas_usbhs driver was using spin_trylock to avoid
    dead lock / nest lock.
    But acording to CONFIG_DEBUG_SPINLOCK, it is BUG under UP environment.
    This patch add usbhsg_trylock to avoid this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 8c721d86bac8..d027c80ab359 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -118,6 +118,35 @@ struct usbhsg_recip_handle {
 #define usbhsg_status_clr(gp, b) (gp->status &= ~b)
 #define usbhsg_status_has(gp, b) (gp->status &   b)
 
+/*
+ *		usbhsg_trylock
+ *
+ * This driver don't use spin_try_lock
+ * to avoid warning of CONFIG_DEBUG_SPINLOCK
+ */
+static spinlock_t *usbhsg_trylock(struct usbhsg_gpriv *gpriv,
+				  unsigned long *flags)
+{
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+
+	/* check spin lock status
+	 * to avoid deadlock/nest */
+	if (spin_is_locked(lock))
+		return NULL;
+
+	spin_lock_irqsave(lock, *flags);
+
+	return lock;
+}
+
+static void usbhsg_unlock(spinlock_t *lock, unsigned long *flags)
+{
+	if (!lock)
+		return;
+
+	spin_unlock_irqrestore(lock, *flags);
+}
+
 /*
  *		list push/pop
  */
@@ -159,9 +188,8 @@ static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 	struct usbhsg_request *ureq;
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
-	int is_locked;
 	int ret = 0;
 
 	if (!uep->handler) {
@@ -179,7 +207,7 @@ static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
 	 *   - usb_request :: complete
 	 *
 	 * But the caller of this function need not care about spinlock.
-	 * This function is using spin_trylock_irqsave for it.
+	 * This function is using usbhsg_trylock for it.
 	 * if "is_locked" is 1, this mean this function lock it.
 	 * but if it is 0, this mean it is already under spin lock.
 	 * see also
@@ -188,7 +216,8 @@ static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
 	 */
 
 	/******************  spin try lock *******************/
-	is_locked = spin_trylock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
+
 	ureq = usbhsg_queue_get(uep);
 	if (ureq) {
 		if (prepare)
@@ -196,8 +225,7 @@ static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
 		else
 			ret = uep->handler->try_run(uep, ureq);
 	}
-	if (is_locked)
-		spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	return ret;
@@ -228,7 +256,7 @@ static void usbhsg_queue_pop(struct usbhsg_uep *uep,
 	 * It mean "usb_ep_ops :: queue" which is using spinlock is called
 	 * under spinlock.
 	 *
-	 * To avoid dead-lock, this driver is using spin_trylock.
+	 * To avoid dead-lock, this driver is using usbhsg_trylock.
 	 *   CAUTION [*endpoint queue*]
 	 *   CAUTION [*queue handler*]
 	 */
@@ -811,7 +839,7 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 	int ret = -EIO;
 
@@ -823,7 +851,7 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		return 0;
 
 	/********************  spin lock ********************/
-	spin_lock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 
 	pipe = usbhs_pipe_malloc(priv, desc);
 	if (pipe) {
@@ -838,7 +866,8 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 
 		ret = 0;
 	}
-	spin_unlock_irqrestore(lock, flags);
+
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	return ret;
@@ -848,14 +877,16 @@ static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 	int ret;
 
 	/********************  spin lock ********************/
-	spin_lock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
+
 	ret = usbhsg_pipe_disable(uep);
-	spin_unlock_irqrestore(lock, flags);
+
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	return ret;
@@ -890,10 +921,9 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 	int ret = 0;
-	int is_locked;
 
 	/*
 	 * CAUTION [*endpoint queue*]
@@ -904,7 +934,7 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	 * it is already under spinlock on this driver.
 	 * but it is called frm usb driver, this function should call spinlock.
 	 *
-	 * This function is using spin_trylock_irqsave to solve this issue.
+	 * This function is using usbshg_trylock to solve this issue.
 	 * if "is_locked" is 1, this mean this function lock it.
 	 * but if it is 0, this mean it is already under spin lock.
 	 * see also
@@ -913,7 +943,7 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	 */
 
 	/********************  spin lock ********************/
-	is_locked = spin_trylock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 
 	/* param check */
 	if (usbhsg_is_not_connected(gpriv)	||
@@ -923,8 +953,7 @@ static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
 	else
 		usbhsg_queue_push(uep, ureq);
 
-	if (is_locked)
-		spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	usbhsg_queue_prepare(uep);
@@ -937,9 +966,8 @@ static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
-	int is_locked;
 
 	/*
 	 * see
@@ -949,12 +977,11 @@ static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 	 */
 
 	/********************  spin lock ********************/
-	is_locked = spin_trylock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 
 	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
 
-	if (is_locked)
-		spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	return 0;
@@ -966,10 +993,9 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 	int ret = -EAGAIN;
-	int is_locked;
 
 	/*
 	 * see
@@ -979,7 +1005,7 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 	 */
 
 	/********************  spin lock ********************/
-	is_locked = spin_trylock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 	if (!usbhsg_queue_get(uep)) {
 
 		dev_dbg(dev, "set halt %d (pipe %d)\n",
@@ -998,8 +1024,7 @@ static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
 		ret = 0;
 	}
 
-	if (is_locked)
-		spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ******************/
 
 	return ret;
@@ -1038,11 +1063,11 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
 	struct device *dev = usbhs_priv_to_dev(priv);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 
 	/********************  spin lock ********************/
-	spin_lock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 
 	/*
 	 * enable interrupt and systems if ready
@@ -1083,7 +1108,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	usbhs_irq_callback_update(priv, mod);
 
 usbhsg_try_start_unlock:
-	spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ********************/
 
 	return 0;
@@ -1095,11 +1120,11 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
 	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
 	struct device *dev = usbhs_priv_to_dev(priv);
-	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	spinlock_t *lock;
 	unsigned long flags;
 
 	/********************  spin lock ********************/
-	spin_lock_irqsave(lock, flags);
+	lock = usbhsg_trylock(gpriv, &flags);
 
 	/*
 	 * disable interrupt and systems if 1st try
@@ -1127,7 +1152,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	usbhs_sys_function_ctrl(priv, 0);
 	usbhs_sys_usb_ctrl(priv, 0);
 
-	spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 	/********************  spin unlock ********************/
 
 	if (gpriv->driver &&
@@ -1139,7 +1164,7 @@ static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
 	return 0;
 
 usbhsg_try_stop_unlock:
-	spin_unlock_irqrestore(lock, flags);
+	usbhsg_unlock(lock, &flags);
 
 	return 0;
 }

commit 409ba9e7c023bdbfd2ecab960532523124de5c81
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Apr 26 09:21:35 2011 +0900

    usb: renesas_usbhs: don't re-allocation pipe buffer
    
    Because pipe buffer allocation is very picky and difficult,
    current renesas_usbhs driver is not caring pipe re-allocation.
    
    In this situation, driver will create new pipe without caring old pipe
    if "usbhsg_ep_enable" is called after "usbhsg_ep_disable" on current driver.
    This mean the limited pipe and buffer will be used as waste.
    But it is possible to re-use same buffer to same pipe.
    
    By this patch, driver will initialize pipe when it detected new connection or
    new gadget, and doesn't try re-allocation for same pipe in above case.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index 9a5ac02077b9..8c721d86bac8 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -787,12 +787,18 @@ static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
 		usbhsg_queue_pop(uep, ureq, -ECONNRESET);
 	}
 
-	uep->pipe->mod_private	= NULL;
-	uep->pipe		= NULL;
-
 	return 0;
 }
 
+static void usbhsg_uep_init(struct usbhsg_gpriv *gpriv)
+{
+	int i;
+	struct usbhsg_uep *uep;
+
+	usbhsg_for_each_uep_with_dcp(uep, gpriv, i)
+		uep->pipe = NULL;
+}
+
 /*
  *
  *		usb_ep_ops
@@ -809,6 +815,13 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	unsigned long flags;
 	int ret = -EIO;
 
+	/*
+	 * if it already have pipe,
+	 * nothing to do
+	 */
+	if (uep->pipe)
+		return 0;
+
 	/********************  spin lock ********************/
 	spin_lock_irqsave(lock, flags);
 
@@ -1045,6 +1058,7 @@ static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
 	 * pipe initialize and enable DCP
 	 */
 	usbhs_pipe_init(priv);
+	usbhsg_uep_init(gpriv);
 	usbhsg_dcp_enable(dcp);
 
 	/*

commit 2f98382dcdfe1f0048b447da35f34507ffb514dc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Apr 5 11:40:54 2011 +0900

    usb: renesas_usbhs: Add Renesas USBHS Gadget
    
    This patch add usb gadget code to SuperH USBHS.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
new file mode 100644
index 000000000000..9a5ac02077b9
--- /dev/null
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -0,0 +1,1341 @@
+/*
+ * Renesas USB driver
+ *
+ * Copyright (C) 2011 Renesas Solutions Corp.
+ * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include "common.h"
+
+/*
+ *		struct
+ */
+struct usbhsg_request {
+	struct usb_request	req;
+	struct list_head	node;
+};
+
+#define EP_NAME_SIZE 8
+struct usbhsg_gpriv;
+struct usbhsg_pipe_handle;
+struct usbhsg_uep {
+	struct usb_ep		 ep;
+	struct usbhs_pipe	*pipe;
+	struct list_head	 list;
+
+	char ep_name[EP_NAME_SIZE];
+
+	struct usbhsg_gpriv *gpriv;
+	struct usbhsg_pipe_handle *handler;
+};
+
+struct usbhsg_gpriv {
+	struct usb_gadget	 gadget;
+	struct usbhs_mod	 mod;
+
+	struct usbhsg_uep	*uep;
+	int			 uep_size;
+
+	struct usb_gadget_driver	*driver;
+
+	u32	status;
+#define USBHSG_STATUS_STARTED		(1 << 0)
+#define USBHSG_STATUS_REGISTERD		(1 << 1)
+#define USBHSG_STATUS_WEDGE		(1 << 2)
+};
+
+struct usbhsg_pipe_handle {
+	int (*prepare)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
+	int (*try_run)(struct usbhsg_uep *uep, struct usbhsg_request *ureq);
+	void (*irq_mask)(struct usbhsg_uep *uep, int enable);
+};
+
+struct usbhsg_recip_handle {
+	char *name;
+	int (*device)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
+		      struct usb_ctrlrequest *ctrl);
+	int (*interface)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
+			 struct usb_ctrlrequest *ctrl);
+	int (*endpoint)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
+			struct usb_ctrlrequest *ctrl);
+};
+
+/*
+ *		macro
+ */
+#define usbhsg_priv_to_gpriv(priv)			\
+	container_of(					\
+		usbhs_mod_get(priv, USBHS_GADGET),	\
+		struct usbhsg_gpriv, mod)
+
+#define __usbhsg_for_each_uep(start, pos, g, i)	\
+	for (i = start, pos = (g)->uep;		\
+	     i < (g)->uep_size;			\
+	     i++, pos = (g)->uep + i)
+
+#define usbhsg_for_each_uep(pos, gpriv, i)	\
+	__usbhsg_for_each_uep(1, pos, gpriv, i)
+
+#define usbhsg_for_each_uep_with_dcp(pos, gpriv, i)	\
+	__usbhsg_for_each_uep(0, pos, gpriv, i)
+
+#define usbhsg_gadget_to_gpriv(g)\
+	container_of(g, struct usbhsg_gpriv, gadget)
+
+#define usbhsg_req_to_ureq(r)\
+	container_of(r, struct usbhsg_request, req)
+
+#define usbhsg_ep_to_uep(e)		container_of(e, struct usbhsg_uep, ep)
+#define usbhsg_gpriv_to_lock(gp)	usbhs_priv_to_lock((gp)->mod.priv)
+#define usbhsg_gpriv_to_dev(gp)		usbhs_priv_to_dev((gp)->mod.priv)
+#define usbhsg_gpriv_to_priv(gp)	((gp)->mod.priv)
+#define usbhsg_gpriv_to_dcp(gp)		((gp)->uep)
+#define usbhsg_gpriv_to_nth_uep(gp, i)	((gp)->uep + i)
+#define usbhsg_uep_to_gpriv(u)		((u)->gpriv)
+#define usbhsg_uep_to_pipe(u)		((u)->pipe)
+#define usbhsg_pipe_to_uep(p)		((p)->mod_private)
+#define usbhsg_is_dcp(u)		((u) == usbhsg_gpriv_to_dcp((u)->gpriv))
+
+#define usbhsg_is_not_connected(gp) ((gp)->gadget.speed == USB_SPEED_UNKNOWN)
+
+/* status */
+#define usbhsg_status_init(gp)   do {(gp)->status = 0; } while (0)
+#define usbhsg_status_set(gp, b) (gp->status |=  b)
+#define usbhsg_status_clr(gp, b) (gp->status &= ~b)
+#define usbhsg_status_has(gp, b) (gp->status &   b)
+
+/*
+ *		list push/pop
+ */
+static void usbhsg_queue_push(struct usbhsg_uep *uep,
+			      struct usbhsg_request *ureq)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+	list_del_init(&ureq->node);
+	list_add_tail(&ureq->node, &uep->list);
+	ureq->req.actual = 0;
+	ureq->req.status = -EINPROGRESS;
+
+	dev_dbg(dev, "pipe %d : queue push (%d)\n",
+		usbhs_pipe_number(pipe),
+		ureq->req.length);
+}
+
+static struct usbhsg_request *usbhsg_queue_get(struct usbhsg_uep *uep)
+{
+	/*
+	 *********  assume under spin lock  *********
+	 */
+	if (list_empty(&uep->list))
+		return NULL;
+
+	return list_entry(uep->list.next, struct usbhsg_request, node);
+}
+
+#define usbhsg_queue_prepare(uep) __usbhsg_queue_handler(uep, 1);
+#define usbhsg_queue_handle(uep)  __usbhsg_queue_handler(uep, 0);
+static int __usbhsg_queue_handler(struct usbhsg_uep *uep, int prepare)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhsg_request *ureq;
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int is_locked;
+	int ret = 0;
+
+	if (!uep->handler) {
+		dev_err(dev, "no handler function\n");
+		return -EIO;
+	}
+
+	/*
+	 * CAUTION [*queue handler*]
+	 *
+	 * This function will be called for start/restart queue operation.
+	 * OTOH the most much worry for USB driver is spinlock nest.
+	 * Specially it are
+	 *   - usb_ep_ops  :: queue
+	 *   - usb_request :: complete
+	 *
+	 * But the caller of this function need not care about spinlock.
+	 * This function is using spin_trylock_irqsave for it.
+	 * if "is_locked" is 1, this mean this function lock it.
+	 * but if it is 0, this mean it is already under spin lock.
+	 * see also
+	 *   CAUTION [*endpoint queue*]
+	 *   CAUTION [*request complete*]
+	 */
+
+	/******************  spin try lock *******************/
+	is_locked = spin_trylock_irqsave(lock, flags);
+	ureq = usbhsg_queue_get(uep);
+	if (ureq) {
+		if (prepare)
+			ret = uep->handler->prepare(uep, ureq);
+		else
+			ret = uep->handler->try_run(uep, ureq);
+	}
+	if (is_locked)
+		spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	return ret;
+}
+
+static void usbhsg_queue_pop(struct usbhsg_uep *uep,
+			     struct usbhsg_request *ureq,
+			     int status)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	/*
+	 * CAUTION [*request complete*]
+	 *
+	 * There is a possibility not to be called in correct order
+	 * if "complete" is called without spinlock.
+	 *
+	 * So, this function assume it is under spinlock,
+	 * and call usb_request :: complete.
+	 *
+	 * But this "complete" will push next usb_request.
+	 * It mean "usb_ep_ops :: queue" which is using spinlock is called
+	 * under spinlock.
+	 *
+	 * To avoid dead-lock, this driver is using spin_trylock.
+	 *   CAUTION [*endpoint queue*]
+	 *   CAUTION [*queue handler*]
+	 */
+
+	dev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));
+
+	list_del_init(&ureq->node);
+
+	ureq->req.status = status;
+	ureq->req.complete(&uep->ep, &ureq->req);
+
+	/* more request ? */
+	if (0 == status)
+		usbhsg_queue_prepare(uep);
+}
+
+/*
+ *		irq enable/disable function
+ */
+#define usbhsg_irq_callback_ctrl(uep, status, enable)			\
+	({								\
+		struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);	\
+		struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);	\
+		struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);	\
+		struct usbhs_mod *mod = usbhs_mod_get_current(priv);	\
+		if (!mod)						\
+			return;						\
+		if (enable)						\
+			mod->irq_##status |= (1 << usbhs_pipe_number(pipe)); \
+		else							\
+			mod->irq_##status &= ~(1 << usbhs_pipe_number(pipe)); \
+		usbhs_irq_callback_update(priv, mod);			\
+	})
+
+static void usbhsg_irq_empty_ctrl(struct usbhsg_uep *uep, int enable)
+{
+	usbhsg_irq_callback_ctrl(uep, bempsts, enable);
+}
+
+static void usbhsg_irq_ready_ctrl(struct usbhsg_uep *uep, int enable)
+{
+	usbhsg_irq_callback_ctrl(uep, brdysts, enable);
+}
+
+/*
+ *		handler function
+ */
+static int usbhsg_try_run_ctrl_stage_end(struct usbhsg_uep *uep,
+					 struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	usbhs_dcp_control_transfer_done(pipe);
+	usbhsg_queue_pop(uep, ureq, 0);
+
+	return 0;
+}
+
+static int usbhsg_try_run_send_packet(struct usbhsg_uep *uep,
+				      struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usb_request *req = &ureq->req;
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	void *buf;
+	int remainder, send;
+	int is_done = 0;
+	int enable;
+	int maxp;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	maxp		= usbhs_pipe_get_maxpacket(pipe);
+	buf		= req->buf    + req->actual;
+	remainder	= req->length - req->actual;
+
+	send = usbhs_fifo_write(pipe, buf, remainder);
+
+	/*
+	 * send < 0 : pipe busy
+	 * send = 0 : send zero packet
+	 * send > 0 : send data
+	 *
+	 * send <= max_packet
+	 */
+	if (send > 0)
+		req->actual += send;
+
+	/* send all packet ? */
+	if (send < remainder)
+		is_done = 0;		/* there are remainder data */
+	else if (send < maxp)
+		is_done = 1;		/* short packet */
+	else
+		is_done = !req->zero;	/* send zero packet ? */
+
+	dev_dbg(dev, "  send %d (%d/ %d/ %d/ %d)\n",
+		usbhs_pipe_number(pipe),
+		remainder, send, is_done, req->zero);
+
+	/*
+	 * enable interrupt and send again in irq handler
+	 * if it still have remainder data which should be sent.
+	 */
+	enable = !is_done;
+	uep->handler->irq_mask(uep, enable);
+
+	/*
+	 * usbhs_fifo_enable execute
+	 *  - after callback_update,
+	 *  - before queue_pop / stage_end
+	 */
+	usbhs_fifo_enable(pipe);
+
+	/*
+	 * all data were sent ?
+	 */
+	if (is_done) {
+		/* it care below call in
+		   "function mode" */
+		if (usbhsg_is_dcp(uep))
+			usbhs_dcp_control_transfer_done(pipe);
+
+		usbhsg_queue_pop(uep, ureq, 0);
+	}
+
+	return 0;
+}
+
+static int usbhsg_prepare_send_packet(struct usbhsg_uep *uep,
+				      struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	usbhs_fifo_prepare_write(pipe);
+	usbhsg_try_run_send_packet(uep, ureq);
+
+	return 0;
+}
+
+static int usbhsg_try_run_receive_packet(struct usbhsg_uep *uep,
+					 struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usb_request *req = &ureq->req;
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	void *buf;
+	int maxp;
+	int remainder, recv;
+	int is_done = 0;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	maxp		= usbhs_pipe_get_maxpacket(pipe);
+	buf		= req->buf    + req->actual;
+	remainder	= req->length - req->actual;
+
+	recv = usbhs_fifo_read(pipe, buf, remainder);
+	/*
+	 * recv < 0  : pipe busy
+	 * recv >= 0 : receive data
+	 *
+	 * recv <= max_packet
+	 */
+	if (recv < 0)
+		return -EBUSY;
+
+	/* update parameters */
+	req->actual += recv;
+
+	if ((recv == remainder) ||	/* receive all data */
+	    (recv < maxp))		/* short packet */
+		is_done = 1;
+
+	dev_dbg(dev, "  recv %d (%d/ %d/ %d/ %d)\n",
+		usbhs_pipe_number(pipe),
+		remainder, recv, is_done, req->zero);
+
+	/* read all data ? */
+	if (is_done) {
+		int disable = 0;
+
+		uep->handler->irq_mask(uep, disable);
+		usbhs_fifo_disable(pipe);
+		usbhsg_queue_pop(uep, ureq, 0);
+	}
+
+	return 0;
+}
+
+static int usbhsg_prepare_receive_packet(struct usbhsg_uep *uep,
+					 struct usbhsg_request *ureq)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	int enable = 1;
+	int ret;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	ret = usbhs_fifo_prepare_read(pipe);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * data will be read in interrupt handler
+	 */
+	uep->handler->irq_mask(uep, enable);
+
+	return ret;
+}
+
+static struct usbhsg_pipe_handle usbhsg_handler_send_by_empty = {
+	.prepare	= usbhsg_prepare_send_packet,
+	.try_run	= usbhsg_try_run_send_packet,
+	.irq_mask	= usbhsg_irq_empty_ctrl,
+};
+
+static struct usbhsg_pipe_handle usbhsg_handler_send_by_ready = {
+	.prepare	= usbhsg_prepare_send_packet,
+	.try_run	= usbhsg_try_run_send_packet,
+	.irq_mask	= usbhsg_irq_ready_ctrl,
+};
+
+static struct usbhsg_pipe_handle usbhsg_handler_recv_by_ready = {
+	.prepare	= usbhsg_prepare_receive_packet,
+	.try_run	= usbhsg_try_run_receive_packet,
+	.irq_mask	= usbhsg_irq_ready_ctrl,
+};
+
+static struct usbhsg_pipe_handle usbhsg_handler_ctrl_stage_end = {
+	.prepare	= usbhsg_try_run_ctrl_stage_end,
+	.try_run	= usbhsg_try_run_ctrl_stage_end,
+};
+
+/*
+ * DCP pipe can NOT use "ready interrupt" for "send"
+ * it should use "empty" interrupt.
+ * see
+ *   "Operation" - "Interrupt Function" - "BRDY Interrupt"
+ *
+ * on the other hand, normal pipe can use "ready interrupt" for "send"
+ * even though it is single/double buffer
+ */
+#define usbhsg_handler_send_ctrl	usbhsg_handler_send_by_empty
+#define usbhsg_handler_recv_ctrl	usbhsg_handler_recv_by_ready
+
+#define usbhsg_handler_send_packet	usbhsg_handler_send_by_ready
+#define usbhsg_handler_recv_packet	usbhsg_handler_recv_by_ready
+
+/*
+ *		USB_TYPE_STANDARD / clear feature functions
+ */
+static int usbhsg_recip_handler_std_control_done(struct usbhs_priv *priv,
+						 struct usbhsg_uep *uep,
+						 struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);
+
+	usbhs_dcp_control_transfer_done(pipe);
+
+	return 0;
+}
+
+static int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,
+						   struct usbhsg_uep *uep,
+						   struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+
+	if (!usbhsg_status_has(gpriv, USBHSG_STATUS_WEDGE)) {
+		usbhs_fifo_disable(pipe);
+		usbhs_pipe_clear_sequence(pipe);
+		usbhs_fifo_enable(pipe);
+	}
+
+	usbhsg_recip_handler_std_control_done(priv, uep, ctrl);
+
+	usbhsg_queue_prepare(uep);
+
+	return 0;
+}
+
+struct usbhsg_recip_handle req_clear_feature = {
+	.name		= "clear feature",
+	.device		= usbhsg_recip_handler_std_control_done,
+	.interface	= usbhsg_recip_handler_std_control_done,
+	.endpoint	= usbhsg_recip_handler_std_clear_endpoint,
+};
+
+/*
+ *		USB_TYPE handler
+ */
+static int usbhsg_recip_run_handle(struct usbhs_priv *priv,
+				   struct usbhsg_recip_handle *handler,
+				   struct usb_ctrlrequest *ctrl)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usbhsg_uep *uep;
+	int recip = ctrl->bRequestType & USB_RECIP_MASK;
+	int nth = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;
+	int ret;
+	int (*func)(struct usbhs_priv *priv, struct usbhsg_uep *uep,
+		    struct usb_ctrlrequest *ctrl);
+	char *msg;
+
+	uep = usbhsg_gpriv_to_nth_uep(gpriv, nth);
+
+	switch (recip) {
+	case USB_RECIP_DEVICE:
+		msg	= "DEVICE";
+		func	= handler->device;
+		break;
+	case USB_RECIP_INTERFACE:
+		msg	= "INTERFACE";
+		func	= handler->interface;
+		break;
+	case USB_RECIP_ENDPOINT:
+		msg	= "ENDPOINT";
+		func	= handler->endpoint;
+		break;
+	default:
+		dev_warn(dev, "unsupported RECIP(%d)\n", recip);
+		func = NULL;
+		ret = -EINVAL;
+	}
+
+	if (func) {
+		dev_dbg(dev, "%s (pipe %d :%s)\n", handler->name, nth, msg);
+		ret = func(priv, uep, ctrl);
+	}
+
+	return ret;
+}
+
+/*
+ *		irq functions
+ *
+ * it will be called from usbhs_interrupt
+ */
+static int usbhsg_irq_dev_state(struct usbhs_priv *priv,
+				struct usbhs_irq_state *irq_state)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+
+	gpriv->gadget.speed = usbhs_status_get_usb_speed(irq_state);
+
+	dev_dbg(dev, "state = %x : speed : %d\n",
+		usbhs_status_get_device_state(irq_state),
+		gpriv->gadget.speed);
+
+	return 0;
+}
+
+static int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,
+				 struct usbhs_irq_state *irq_state)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	struct usb_ctrlrequest ctrl;
+	struct usbhsg_recip_handle *recip_handler = NULL;
+	int stage = usbhs_status_get_ctrl_stage(irq_state);
+	int ret = 0;
+
+	dev_dbg(dev, "stage = %d\n", stage);
+
+	/*
+	 * see Manual
+	 *
+	 *  "Operation"
+	 *  - "Interrupt Function"
+	 *    - "Control Transfer Stage Transition Interrupt"
+	 *      - Fig. "Control Transfer Stage Transitions"
+	 */
+
+	switch (stage) {
+	case READ_DATA_STAGE:
+		dcp->handler = &usbhsg_handler_send_ctrl;
+		break;
+	case WRITE_DATA_STAGE:
+		dcp->handler = &usbhsg_handler_recv_ctrl;
+		break;
+	case NODATA_STATUS_STAGE:
+		dcp->handler = &usbhsg_handler_ctrl_stage_end;
+		break;
+	default:
+		return ret;
+	}
+
+	/*
+	 * get usb request
+	 */
+	usbhs_usbreq_get_val(priv, &ctrl);
+
+	switch (ctrl.bRequestType & USB_TYPE_MASK) {
+	case USB_TYPE_STANDARD:
+		switch (ctrl.bRequest) {
+		case USB_REQ_CLEAR_FEATURE:
+			recip_handler = &req_clear_feature;
+			break;
+		}
+	}
+
+	/*
+	 * setup stage / run recip
+	 */
+	if (recip_handler)
+		ret = usbhsg_recip_run_handle(priv, recip_handler, &ctrl);
+	else
+		ret = gpriv->driver->setup(&gpriv->gadget, &ctrl);
+
+	if (ret < 0)
+		usbhs_fifo_stall(pipe);
+
+	return ret;
+}
+
+static int usbhsg_irq_empty(struct usbhs_priv *priv,
+			    struct usbhs_irq_state *irq_state)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhsg_uep *uep;
+	struct usbhs_pipe *pipe;
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	int i, ret;
+
+	if (!irq_state->bempsts) {
+		dev_err(dev, "debug %s !!\n", __func__);
+		return -EIO;
+	}
+
+	dev_dbg(dev, "irq empty [0x%04x]\n", irq_state->bempsts);
+
+	/*
+	 * search interrupted "pipe"
+	 * not "uep".
+	 */
+	usbhs_for_each_pipe_with_dcp(pipe, priv, i) {
+		if (!(irq_state->bempsts & (1 << i)))
+			continue;
+
+		uep	= usbhsg_pipe_to_uep(pipe);
+		ret	= usbhsg_queue_handle(uep);
+		if (ret < 0)
+			dev_err(dev, "send error %d : %d\n", i, ret);
+	}
+
+	return 0;
+}
+
+static int usbhsg_irq_ready(struct usbhs_priv *priv,
+			    struct usbhs_irq_state *irq_state)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhsg_uep *uep;
+	struct usbhs_pipe *pipe;
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	int i, ret;
+
+	if (!irq_state->brdysts) {
+		dev_err(dev, "debug %s !!\n", __func__);
+		return -EIO;
+	}
+
+	dev_dbg(dev, "irq ready [0x%04x]\n", irq_state->brdysts);
+
+	/*
+	 * search interrupted "pipe"
+	 * not "uep".
+	 */
+	usbhs_for_each_pipe_with_dcp(pipe, priv, i) {
+		if (!(irq_state->brdysts & (1 << i)))
+			continue;
+
+		uep	= usbhsg_pipe_to_uep(pipe);
+		ret	= usbhsg_queue_handle(uep);
+		if (ret < 0)
+			dev_err(dev, "receive error %d : %d\n", i, ret);
+	}
+
+	return 0;
+}
+
+/*
+ *
+ *		usb_dcp_ops
+ *
+ */
+static int usbhsg_dcp_enable(struct usbhsg_uep *uep)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	struct usbhs_pipe *pipe;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	pipe = usbhs_dcp_malloc(priv);
+	if (!pipe)
+		return -EIO;
+
+	uep->pipe		= pipe;
+	uep->pipe->mod_private	= uep;
+	INIT_LIST_HEAD(&uep->list);
+
+	return 0;
+}
+
+#define usbhsg_dcp_disable usbhsg_pipe_disable
+static int usbhsg_pipe_disable(struct usbhsg_uep *uep)
+{
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhsg_request *ureq;
+	int disable = 0;
+
+	/*
+	 *********  assume under spin lock  *********
+	 */
+
+	usbhs_fifo_disable(pipe);
+
+	/*
+	 * disable pipe irq
+	 */
+	usbhsg_irq_empty_ctrl(uep, disable);
+	usbhsg_irq_ready_ctrl(uep, disable);
+
+	while (1) {
+		ureq = usbhsg_queue_get(uep);
+		if (!ureq)
+			break;
+
+		usbhsg_queue_pop(uep, ureq, -ECONNRESET);
+	}
+
+	uep->pipe->mod_private	= NULL;
+	uep->pipe		= NULL;
+
+	return 0;
+}
+
+/*
+ *
+ *		usb_ep_ops
+ *
+ */
+static int usbhsg_ep_enable(struct usb_ep *ep,
+			 const struct usb_endpoint_descriptor *desc)
+{
+	struct usbhsg_uep *uep   = usbhsg_ep_to_uep(ep);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+	struct usbhs_pipe *pipe;
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int ret = -EIO;
+
+	/********************  spin lock ********************/
+	spin_lock_irqsave(lock, flags);
+
+	pipe = usbhs_pipe_malloc(priv, desc);
+	if (pipe) {
+		uep->pipe		= pipe;
+		pipe->mod_private	= uep;
+		INIT_LIST_HEAD(&uep->list);
+
+		if (usb_endpoint_dir_in(desc))
+			uep->handler = &usbhsg_handler_send_packet;
+		else
+			uep->handler = &usbhsg_handler_recv_packet;
+
+		ret = 0;
+	}
+	spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	return ret;
+}
+
+static int usbhsg_ep_disable(struct usb_ep *ep)
+{
+	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int ret;
+
+	/********************  spin lock ********************/
+	spin_lock_irqsave(lock, flags);
+	ret = usbhsg_pipe_disable(uep);
+	spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	return ret;
+}
+
+static struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,
+						   gfp_t gfp_flags)
+{
+	struct usbhsg_request *ureq;
+
+	ureq = kzalloc(sizeof *ureq, gfp_flags);
+	if (!ureq)
+		return NULL;
+
+	INIT_LIST_HEAD(&ureq->node);
+	return &ureq->req;
+}
+
+static void usbhsg_ep_free_request(struct usb_ep *ep,
+				   struct usb_request *req)
+{
+	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
+
+	WARN_ON(!list_empty(&ureq->node));
+	kfree(ureq);
+}
+
+static int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,
+			  gfp_t gfp_flags)
+{
+	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int ret = 0;
+	int is_locked;
+
+	/*
+	 * CAUTION [*endpoint queue*]
+	 *
+	 * This function will be called from usb_request :: complete
+	 * or usb driver timing.
+	 * If this function is called from usb_request :: complete,
+	 * it is already under spinlock on this driver.
+	 * but it is called frm usb driver, this function should call spinlock.
+	 *
+	 * This function is using spin_trylock_irqsave to solve this issue.
+	 * if "is_locked" is 1, this mean this function lock it.
+	 * but if it is 0, this mean it is already under spin lock.
+	 * see also
+	 *   CAUTION [*queue handler*]
+	 *   CAUTION [*request complete*]
+	 */
+
+	/********************  spin lock ********************/
+	is_locked = spin_trylock_irqsave(lock, flags);
+
+	/* param check */
+	if (usbhsg_is_not_connected(gpriv)	||
+	    unlikely(!gpriv->driver)		||
+	    unlikely(!pipe))
+		ret = -ESHUTDOWN;
+	else
+		usbhsg_queue_push(uep, ureq);
+
+	if (is_locked)
+		spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	usbhsg_queue_prepare(uep);
+
+	return ret;
+}
+
+static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
+{
+	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
+	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int is_locked;
+
+	/*
+	 * see
+	 *   CAUTION [*queue handler*]
+	 *   CAUTION [*endpoint queue*]
+	 *   CAUTION [*request complete*]
+	 */
+
+	/********************  spin lock ********************/
+	is_locked = spin_trylock_irqsave(lock, flags);
+
+	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
+
+	if (is_locked)
+		spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	return 0;
+}
+
+static int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)
+{
+	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
+	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
+	struct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+	int ret = -EAGAIN;
+	int is_locked;
+
+	/*
+	 * see
+	 *   CAUTION [*queue handler*]
+	 *   CAUTION [*endpoint queue*]
+	 *   CAUTION [*request complete*]
+	 */
+
+	/********************  spin lock ********************/
+	is_locked = spin_trylock_irqsave(lock, flags);
+	if (!usbhsg_queue_get(uep)) {
+
+		dev_dbg(dev, "set halt %d (pipe %d)\n",
+			halt, usbhs_pipe_number(pipe));
+
+		if (halt)
+			usbhs_fifo_stall(pipe);
+		else
+			usbhs_fifo_disable(pipe);
+
+		if (halt && wedge)
+			usbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);
+		else
+			usbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);
+
+		ret = 0;
+	}
+
+	if (is_locked)
+		spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ******************/
+
+	return ret;
+}
+
+static int usbhsg_ep_set_halt(struct usb_ep *ep, int value)
+{
+	return __usbhsg_ep_set_halt_wedge(ep, value, 0);
+}
+
+static int usbhsg_ep_set_wedge(struct usb_ep *ep)
+{
+	return __usbhsg_ep_set_halt_wedge(ep, 1, 1);
+}
+
+static struct usb_ep_ops usbhsg_ep_ops = {
+	.enable		= usbhsg_ep_enable,
+	.disable	= usbhsg_ep_disable,
+
+	.alloc_request	= usbhsg_ep_alloc_request,
+	.free_request	= usbhsg_ep_free_request,
+
+	.queue		= usbhsg_ep_queue,
+	.dequeue	= usbhsg_ep_dequeue,
+
+	.set_halt	= usbhsg_ep_set_halt,
+	.set_wedge	= usbhsg_ep_set_wedge,
+};
+
+/*
+ *		usb module start/end
+ */
+static int usbhsg_try_start(struct usbhs_priv *priv, u32 status)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
+	struct device *dev = usbhs_priv_to_dev(priv);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+
+	/********************  spin lock ********************/
+	spin_lock_irqsave(lock, flags);
+
+	/*
+	 * enable interrupt and systems if ready
+	 */
+	usbhsg_status_set(gpriv, status);
+	if (!(usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&
+	      usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD)))
+		goto usbhsg_try_start_unlock;
+
+	dev_dbg(dev, "start gadget\n");
+
+	/*
+	 * pipe initialize and enable DCP
+	 */
+	usbhs_pipe_init(priv);
+	usbhsg_dcp_enable(dcp);
+
+	/*
+	 * system config enble
+	 * - HI speed
+	 * - function
+	 * - usb module
+	 */
+	usbhs_sys_hispeed_ctrl(priv, 1);
+	usbhs_sys_function_ctrl(priv, 1);
+	usbhs_sys_usb_ctrl(priv, 1);
+
+	/*
+	 * enable irq callback
+	 */
+	mod->irq_dev_state	= usbhsg_irq_dev_state;
+	mod->irq_ctrl_stage	= usbhsg_irq_ctrl_stage;
+	mod->irq_empty		= usbhsg_irq_empty;
+	mod->irq_ready		= usbhsg_irq_ready;
+	mod->irq_bempsts	= 0;
+	mod->irq_brdysts	= 0;
+	usbhs_irq_callback_update(priv, mod);
+
+usbhsg_try_start_unlock:
+	spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ********************/
+
+	return 0;
+}
+
+static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
+	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);
+	struct device *dev = usbhs_priv_to_dev(priv);
+	spinlock_t *lock = usbhsg_gpriv_to_lock(gpriv);
+	unsigned long flags;
+
+	/********************  spin lock ********************/
+	spin_lock_irqsave(lock, flags);
+
+	/*
+	 * disable interrupt and systems if 1st try
+	 */
+	usbhsg_status_clr(gpriv, status);
+	if (!usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&
+	    !usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD))
+		goto usbhsg_try_stop_unlock;
+
+	/* disable all irq */
+	mod->irq_dev_state	= NULL;
+	mod->irq_ctrl_stage	= NULL;
+	mod->irq_empty		= NULL;
+	mod->irq_ready		= NULL;
+	mod->irq_bempsts	= 0;
+	mod->irq_brdysts	= 0;
+	usbhs_irq_callback_update(priv, mod);
+
+	usbhsg_dcp_disable(dcp);
+
+	gpriv->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* disable sys */
+	usbhs_sys_hispeed_ctrl(priv, 0);
+	usbhs_sys_function_ctrl(priv, 0);
+	usbhs_sys_usb_ctrl(priv, 0);
+
+	spin_unlock_irqrestore(lock, flags);
+	/********************  spin unlock ********************/
+
+	if (gpriv->driver &&
+	    gpriv->driver->disconnect)
+		gpriv->driver->disconnect(&gpriv->gadget);
+
+	dev_dbg(dev, "stop gadget\n");
+
+	return 0;
+
+usbhsg_try_stop_unlock:
+	spin_unlock_irqrestore(lock, flags);
+
+	return 0;
+}
+
+/*
+ *
+ *		linux usb function
+ *
+ */
+struct usbhsg_gpriv *the_controller;
+int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
+			    int (*bind)(struct usb_gadget *))
+{
+	struct usbhsg_gpriv *gpriv = the_controller;
+	struct usbhs_priv *priv;
+	struct device *dev;
+	int ret;
+
+	if (!bind		||
+	    !driver		||
+	    !driver->setup	||
+	    driver->speed != USB_SPEED_HIGH)
+		return -EINVAL;
+	if (!gpriv)
+		return -ENODEV;
+	if (gpriv->driver)
+		return -EBUSY;
+
+	dev  = usbhsg_gpriv_to_dev(gpriv);
+	priv = usbhsg_gpriv_to_priv(gpriv);
+
+	/* first hook up the driver ... */
+	gpriv->driver = driver;
+	gpriv->gadget.dev.driver = &driver->driver;
+
+	ret = device_add(&gpriv->gadget.dev);
+	if (ret) {
+		dev_err(dev, "device_add error %d\n", ret);
+		goto add_fail;
+	}
+
+	ret = bind(&gpriv->gadget);
+	if (ret) {
+		dev_err(dev, "bind to driver %s error %d\n",
+			driver->driver.name, ret);
+		goto bind_fail;
+	}
+
+	dev_dbg(dev, "bind %s\n", driver->driver.name);
+
+	return usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);
+
+bind_fail:
+	device_del(&gpriv->gadget.dev);
+add_fail:
+	gpriv->driver = NULL;
+	gpriv->gadget.dev.driver = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL(usb_gadget_probe_driver);
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct usbhsg_gpriv *gpriv = the_controller;
+	struct usbhs_priv *priv;
+	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
+
+	if (!gpriv)
+		return -ENODEV;
+
+	if (!driver		||
+	    !driver->unbind	||
+	    driver != gpriv->driver)
+		return -EINVAL;
+
+	dev  = usbhsg_gpriv_to_dev(gpriv);
+	priv = usbhsg_gpriv_to_priv(gpriv);
+
+	usbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);
+	device_del(&gpriv->gadget.dev);
+	gpriv->driver = NULL;
+
+	if (driver->disconnect)
+		driver->disconnect(&gpriv->gadget);
+
+	driver->unbind(&gpriv->gadget);
+	dev_dbg(dev, "unbind %s\n", driver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*
+ *		usb gadget ops
+ */
+static int usbhsg_get_frame(struct usb_gadget *gadget)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);
+	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
+
+	return usbhs_frame_get_num(priv);
+}
+
+static struct usb_gadget_ops usbhsg_gadget_ops = {
+	.get_frame		= usbhsg_get_frame,
+};
+
+static int usbhsg_start(struct usbhs_priv *priv)
+{
+	return usbhsg_try_start(priv, USBHSG_STATUS_STARTED);
+}
+
+static int usbhsg_stop(struct usbhs_priv *priv)
+{
+	return usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);
+}
+
+int __devinit usbhs_mod_gadget_probe(struct usbhs_priv *priv)
+{
+	struct usbhsg_gpriv *gpriv;
+	struct usbhsg_uep *uep;
+	struct device *dev = usbhs_priv_to_dev(priv);
+	int pipe_size = usbhs_get_dparam(priv, pipe_size);
+	int i;
+
+	gpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);
+	if (!gpriv) {
+		dev_err(dev, "Could not allocate gadget priv\n");
+		return -ENOMEM;
+	}
+
+	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
+	if (!uep) {
+		dev_err(dev, "Could not allocate ep\n");
+		goto usbhs_mod_gadget_probe_err_gpriv;
+	}
+
+	/*
+	 * CAUTION
+	 *
+	 * There is no guarantee that it is possible to access usb module here.
+	 * Don't accesses to it.
+	 * The accesse will be enable after "usbhsg_start"
+	 */
+
+	/*
+	 * register itself
+	 */
+	usbhs_mod_register(priv, &gpriv->mod, USBHS_GADGET);
+
+	/* init gpriv */
+	gpriv->mod.name		= "gadget";
+	gpriv->mod.start	= usbhsg_start;
+	gpriv->mod.stop		= usbhsg_stop;
+	gpriv->uep		= uep;
+	gpriv->uep_size		= pipe_size;
+	usbhsg_status_init(gpriv);
+
+	/*
+	 * init gadget
+	 */
+	device_initialize(&gpriv->gadget.dev);
+	dev_set_name(&gpriv->gadget.dev, "gadget");
+	gpriv->gadget.dev.parent	= dev;
+	gpriv->gadget.name		= "renesas_usbhs_udc";
+	gpriv->gadget.ops		= &usbhsg_gadget_ops;
+	gpriv->gadget.is_dualspeed	= 1;
+
+	INIT_LIST_HEAD(&gpriv->gadget.ep_list);
+
+	/*
+	 * init usb_ep
+	 */
+	usbhsg_for_each_uep_with_dcp(uep, gpriv, i) {
+		uep->gpriv	= gpriv;
+		snprintf(uep->ep_name, EP_NAME_SIZE, "ep%d", i);
+
+		uep->ep.name		= uep->ep_name;
+		uep->ep.ops		= &usbhsg_ep_ops;
+		INIT_LIST_HEAD(&uep->ep.ep_list);
+		INIT_LIST_HEAD(&uep->list);
+
+		/* init DCP */
+		if (usbhsg_is_dcp(uep)) {
+			gpriv->gadget.ep0 = &uep->ep;
+			uep->ep.maxpacket = 64;
+		}
+		/* init normal pipe */
+		else {
+			uep->ep.maxpacket = 512;
+			list_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);
+		}
+	}
+
+	the_controller = gpriv;
+
+	dev_info(dev, "gadget probed\n");
+
+	return 0;
+
+usbhs_mod_gadget_probe_err_gpriv:
+	kfree(gpriv);
+
+	return -ENOMEM;
+}
+
+void __devexit usbhs_mod_gadget_remove(struct usbhs_priv *priv)
+{
+	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
+
+	kfree(gpriv);
+}
