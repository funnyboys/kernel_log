commit 3b1261fb72c7dc6a9e4604ef1ea01d6bb67cc3d1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Sep 4 15:19:56 2019 +0200

    bus: imx-weim: remove incorrect __init annotations
    
    The probe function is no longer __init, so anything it calls now
    must also be available at runtime, as Kbuild points out when building
    with clang-9:
    
    WARNING: vmlinux.o(.text+0x6e7040): Section mismatch in reference from the function weim_probe() to the function .init.text:imx_weim_gpr_setup()
    The function weim_probe() references
    the function __init imx_weim_gpr_setup().
    This is often because weim_probe lacks a __init
    annotation or the annotation of imx_weim_gpr_setup is wrong.
    
    WARNING: vmlinux.o(.text+0x6e70f0): Section mismatch in reference from the function weim_probe() to the function .init.text:weim_timing_setup()
    The function weim_probe() references
    the function __init weim_timing_setup().
    This is often because weim_probe lacks a __init
    annotation or the annotation of weim_timing_setup is wrong.
    
    Remove the remaining __init markings that are now wrong.
    
    Fixes: 4a92f07816ba ("bus: imx-weim: use module_platform_driver()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 79af0c27f5a3..28bb65a5613f 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -76,7 +76,7 @@ static const struct of_device_id weim_id_table[] = {
 };
 MODULE_DEVICE_TABLE(of, weim_id_table);
 
-static int __init imx_weim_gpr_setup(struct platform_device *pdev)
+static int imx_weim_gpr_setup(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct property *prop;
@@ -126,10 +126,10 @@ static int __init imx_weim_gpr_setup(struct platform_device *pdev)
 }
 
 /* Parse and set the timing for this device. */
-static int __init weim_timing_setup(struct device *dev,
-				    struct device_node *np, void __iomem *base,
-				    const struct imx_weim_devtype *devtype,
-				    struct cs_timing_state *ts)
+static int weim_timing_setup(struct device *dev,
+			     struct device_node *np, void __iomem *base,
+			     const struct imx_weim_devtype *devtype,
+			     struct cs_timing_state *ts)
 {
 	u32 cs_idx, value[MAX_CS_REGS_COUNT];
 	int i, ret;

commit 4a92f07816ba3020c690cc0f6e9627fec15b335e
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Aug 14 10:23:16 2019 +0200

    bus: imx-weim: use module_platform_driver()
    
    Switch from module_platform_driver_probe() to module_platform_driver().
    The former is not suitable for booting with device tree as the driver
    will be registered before the device and thus won't be probed again
    when the device is present.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index cb7d5504a22a..79af0c27f5a3 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -187,8 +187,7 @@ static int __init weim_timing_setup(struct device *dev,
 	return 0;
 }
 
-static int __init weim_parse_dt(struct platform_device *pdev,
-				void __iomem *base)
+static int weim_parse_dt(struct platform_device *pdev, void __iomem *base)
 {
 	const struct of_device_id *of_id = of_match_device(weim_id_table,
 							   &pdev->dev);
@@ -233,7 +232,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	return ret;
 }
 
-static int __init weim_probe(struct platform_device *pdev)
+static int weim_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct clk *clk;
@@ -270,8 +269,9 @@ static struct platform_driver weim_driver = {
 		.name		= "imx-weim",
 		.of_match_table	= weim_id_table,
 	},
+	.probe = weim_probe,
 };
-module_platform_driver_probe(weim_driver, weim_probe);
+module_platform_driver(weim_driver);
 
 MODULE_AUTHOR("Freescale Semiconductor Inc.");
 MODULE_DESCRIPTION("i.MX EIM Controller Driver");

commit 77266e722feabb6eefc8a7e84ac2415837d91c5f
Author: Sven Van Asbroeck <thesven73@gmail.com>
Date:   Fri Jul 12 16:43:15 2019 -0400

    bus: imx-weim: optionally enable burst clock mode
    
    To enable burst clock mode, add the fsl,burst-clk-enable
    property to the weim bus's devicetree node.
    
    Example:
    weim: weim@21b8000 {
            compatible = "fsl,imx6q-weim";
            reg = <0x021b8000 0x4000>;
            clocks = <&clks 196>;
            #address-cells = <2>;
            #size-cells = <1>;
            ranges = <0 0 0x08000000 0x08000000>;
            fsl,weim-cs-gpr = <&gpr>;
            fsl,burst-clk-enable;
    
            client-device@0,0 {
                    compatible = "something";
                    reg = <0 0 0x02000000>;
                    #address-cells = <1>;
                    #size-cells = <1>;
                    bank-width = <2>;
                    fsl,weim-cs-timing = <0x00620081 0x00000001 0x1c022000
                                    0x0000c000 0x1404a38e 0x00000000>;
            };
    };
    
    Signed-off-by: Sven Van Asbroeck <TheSven73@gmail.com>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index db74334ca5ef..cb7d5504a22a 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -19,6 +19,8 @@ struct imx_weim_devtype {
 	unsigned int	cs_count;
 	unsigned int	cs_regs_count;
 	unsigned int	cs_stride;
+	unsigned int	wcr_offset;
+	unsigned int	wcr_bcm;
 };
 
 static const struct imx_weim_devtype imx1_weim_devtype = {
@@ -37,6 +39,8 @@ static const struct imx_weim_devtype imx50_weim_devtype = {
 	.cs_count	= 4,
 	.cs_regs_count	= 6,
 	.cs_stride	= 0x18,
+	.wcr_offset	= 0x90,
+	.wcr_bcm	= BIT(0),
 };
 
 static const struct imx_weim_devtype imx51_weim_devtype = {
@@ -192,6 +196,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	struct device_node *child;
 	int ret, have_child = 0;
 	struct cs_timing_state ts = {};
+	u32 reg;
 
 	if (devtype == &imx50_weim_devtype) {
 		ret = imx_weim_gpr_setup(pdev);
@@ -199,6 +204,17 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 			return ret;
 	}
 
+	if (of_property_read_bool(pdev->dev.of_node, "fsl,burst-clk-enable")) {
+		if (devtype->wcr_bcm) {
+			reg = readl(base + devtype->wcr_offset);
+			writel(reg | devtype->wcr_bcm,
+				base + devtype->wcr_offset);
+		} else {
+			dev_err(&pdev->dev, "burst clk mode not supported.\n");
+			return -EINVAL;
+		}
+	}
+
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		ret = weim_timing_setup(&pdev->dev, child, base, devtype, &ts);
 		if (ret)

commit c7995bcb36ef61e8b4136efab31ecf3c9b1633f9
Author: Sven Van Asbroeck <thesven73@gmail.com>
Date:   Mon Dec 17 10:48:00 2018 -0500

    bus: imx-weim: guard against timing configuration conflicts
    
    When specifying weim child devices, there is a risk that more than
    one timing setting is specified for the same chip select.
    
    The driver cannot support such a configuration.
    
    In case of conflict, this patch will print a warning to the log,
    and will ignore the child node in question.
    
    In this example, node acme@1 will be ignored, as it tries to modify
    timing settings for CS0:
    
    &weim {
            acme@0 {
                    compatible = "acme,whatever";
                    reg = <0 0 0x100>;
                    fsl,weim-cs-timing = <something>;
            };
            acme@1 {
                    compatible = "acme,whatnot";
                    reg = <0 0x500 0x100>;
                    fsl,weim-cs-timing = <something else>;
            };
    };
    
    However in this example, the driver will be happy:
    
    &weim {
            acme@0 {
                    compatible = "acme,whatever";
                    reg = <0 0 0x100>;
                    fsl,weim-cs-timing = <something>;
            };
            acme@1 {
                    compatible = "acme,whatnot";
                    reg = <0 0x500 0x100>;
                    fsl,weim-cs-timing = <something>;
            };
    };
    
    Signed-off-by: Sven Van Asbroeck <TheSven73@googlemail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 1a0e0277a404..db74334ca5ef 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -46,8 +46,18 @@ static const struct imx_weim_devtype imx51_weim_devtype = {
 };
 
 #define MAX_CS_REGS_COUNT	6
+#define MAX_CS_COUNT		6
 #define OF_REG_SIZE		3
 
+struct cs_timing {
+	bool is_applied;
+	u32 regs[MAX_CS_REGS_COUNT];
+};
+
+struct cs_timing_state {
+	struct cs_timing cs[MAX_CS_COUNT];
+};
+
 static const struct of_device_id weim_id_table[] = {
 	/* i.MX1/21 */
 	{ .compatible = "fsl,imx1-weim", .data = &imx1_weim_devtype, },
@@ -112,15 +122,20 @@ static int __init imx_weim_gpr_setup(struct platform_device *pdev)
 }
 
 /* Parse and set the timing for this device. */
-static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
-				    const struct imx_weim_devtype *devtype)
+static int __init weim_timing_setup(struct device *dev,
+				    struct device_node *np, void __iomem *base,
+				    const struct imx_weim_devtype *devtype,
+				    struct cs_timing_state *ts)
 {
 	u32 cs_idx, value[MAX_CS_REGS_COUNT];
 	int i, ret;
 	int reg_idx, num_regs;
+	struct cs_timing *cst;
 
 	if (WARN_ON(devtype->cs_regs_count > MAX_CS_REGS_COUNT))
 		return -EINVAL;
+	if (WARN_ON(devtype->cs_count > MAX_CS_COUNT))
+		return -EINVAL;
 
 	ret = of_property_read_u32_array(np, "fsl,weim-cs-timing",
 					 value, devtype->cs_regs_count);
@@ -146,10 +161,23 @@ static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
 		if (cs_idx >= devtype->cs_count)
 			return -EINVAL;
 
+		/* prevent re-configuring a CS that's already been configured */
+		cst = &ts->cs[cs_idx];
+		if (cst->is_applied && memcmp(value, cst->regs,
+					devtype->cs_regs_count * sizeof(u32))) {
+			dev_err(dev, "fsl,weim-cs-timing conflict on %pOF", np);
+			return -EINVAL;
+		}
+
 		/* set the timing for WEIM */
 		for (i = 0; i < devtype->cs_regs_count; i++)
 			writel(value[i],
 				base + cs_idx * devtype->cs_stride + i * 4);
+		if (!cst->is_applied) {
+			cst->is_applied = true;
+			memcpy(cst->regs, value,
+				devtype->cs_regs_count * sizeof(u32));
+		}
 	}
 
 	return 0;
@@ -163,6 +191,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	const struct imx_weim_devtype *devtype = of_id->data;
 	struct device_node *child;
 	int ret, have_child = 0;
+	struct cs_timing_state ts = {};
 
 	if (devtype == &imx50_weim_devtype) {
 		ret = imx_weim_gpr_setup(pdev);
@@ -171,7 +200,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	}
 
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
-		ret = weim_timing_setup(child, base, devtype);
+		ret = weim_timing_setup(&pdev->dev, child, base, devtype, &ts);
 		if (ret)
 			dev_warn(&pdev->dev, "%pOF set timing failed.\n",
 				child);

commit 8b8cb52af34da2faa293614b2554c8eac30faeaa
Author: Sven Van Asbroeck <thesven73@gmail.com>
Date:   Mon Dec 17 10:47:59 2018 -0500

    bus: imx-weim: support multiple address ranges per child node
    
    Ensure that timing values for the child node are applied to
    all chip selects in the child's address ranges.
    
    Note that this does not support multiple timing settings per
    child; this can be added in the future if required.
    
    Example:
    &weim {
            acme@0 {
                    compatible = "acme,whatever";
                    reg = <0 0 0x100>, <0 0x400000 0x800>,
                                    <1 0x400000 0x800>;
                    fsl,weim-cs-timing = <0x024400b1 0x00001010 0x20081100
                                    0x00000000 0xa0000240 0x00000000>;
            };
    };
    
    Signed-off-by: Sven Van Asbroeck <TheSven73@googlemail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index d84996a4528e..1a0e0277a404 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -46,6 +46,7 @@ static const struct imx_weim_devtype imx51_weim_devtype = {
 };
 
 #define MAX_CS_REGS_COUNT	6
+#define OF_REG_SIZE		3
 
 static const struct of_device_id weim_id_table[] = {
 	/* i.MX1/21 */
@@ -116,26 +117,40 @@ static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
 {
 	u32 cs_idx, value[MAX_CS_REGS_COUNT];
 	int i, ret;
+	int reg_idx, num_regs;
 
 	if (WARN_ON(devtype->cs_regs_count > MAX_CS_REGS_COUNT))
 		return -EINVAL;
 
-	/* get the CS index from this child node's "reg" property. */
-	ret = of_property_read_u32(np, "reg", &cs_idx);
+	ret = of_property_read_u32_array(np, "fsl,weim-cs-timing",
+					 value, devtype->cs_regs_count);
 	if (ret)
 		return ret;
 
-	if (cs_idx >= devtype->cs_count)
+	/*
+	 * the child node's "reg" property may contain multiple address ranges,
+	 * extract the chip select for each.
+	 */
+	num_regs = of_property_count_elems_of_size(np, "reg", OF_REG_SIZE);
+	if (num_regs < 0)
+		return num_regs;
+	if (!num_regs)
 		return -EINVAL;
+	for (reg_idx = 0; reg_idx < num_regs; reg_idx++) {
+		/* get the CS index from this child node's "reg" property. */
+		ret = of_property_read_u32_index(np, "reg",
+					reg_idx * OF_REG_SIZE, &cs_idx);
+		if (ret)
+			break;
 
-	ret = of_property_read_u32_array(np, "fsl,weim-cs-timing",
-					 value, devtype->cs_regs_count);
-	if (ret)
-		return ret;
+		if (cs_idx >= devtype->cs_count)
+			return -EINVAL;
 
-	/* set the timing for WEIM */
-	for (i = 0; i < devtype->cs_regs_count; i++)
-		writel(value[i], base + cs_idx * devtype->cs_stride + i * 4);
+		/* set the timing for WEIM */
+		for (i = 0; i < devtype->cs_regs_count; i++)
+			writel(value[i],
+				base + cs_idx * devtype->cs_stride + i * 4);
+	}
 
 	return 0;
 }

commit b1a23445364d321bfe8d8aa432c955d07ed38b47
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 29 15:02:58 2018 -0500

    bus: imx-weim: drop unnecessary DT node name NULL check
    
    Checking the child node names is pointless as the DT node name can
    never be NULL, so remove it.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 6a94aa6a22c2..d84996a4528e 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -156,9 +156,6 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	}
 
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
-		if (!child->name)
-			continue;
-
 		ret = weim_timing_setup(child, base, devtype);
 		if (ret)
 			dev_warn(&pdev->dev, "%pOF set timing failed.\n",

commit d8dfa59f5a512a536b80a4a8f12fa993683f48df
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jun 28 17:04:21 2018 -0700

    bus: imx-weim: Remove VLA usage
    
    In the quest to remove all stack VLA usage from the kernel[1], this
    switches to using a maximum size and adds a sanity check.
    
    [1] https://lkml.kernel.org/r/CA+55aFzCG-zNmZwX4A2FQpadafLfEzK6CC=qPXydAacU1RqZWA@mail.gmail.com
    
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 3d56ebcda720..6a94aa6a22c2 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -45,6 +45,8 @@ static const struct imx_weim_devtype imx51_weim_devtype = {
 	.cs_stride	= 0x18,
 };
 
+#define MAX_CS_REGS_COUNT	6
+
 static const struct of_device_id weim_id_table[] = {
 	/* i.MX1/21 */
 	{ .compatible = "fsl,imx1-weim", .data = &imx1_weim_devtype, },
@@ -112,9 +114,12 @@ static int __init imx_weim_gpr_setup(struct platform_device *pdev)
 static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
 				    const struct imx_weim_devtype *devtype)
 {
-	u32 cs_idx, value[devtype->cs_regs_count];
+	u32 cs_idx, value[MAX_CS_REGS_COUNT];
 	int i, ret;
 
+	if (WARN_ON(devtype->cs_regs_count > MAX_CS_REGS_COUNT))
+		return -EINVAL;
+
 	/* get the CS index from this child node's "reg" property. */
 	ret = of_property_read_u32(np, "reg", &cs_idx);
 	if (ret)

commit 9c0982d809fd81cc63438926c465e5919fd97acd
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:42:51 2017 -0500

    bus: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 4bd361d64270..3d56ebcda720 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -156,8 +156,8 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 
 		ret = weim_timing_setup(child, base, devtype);
 		if (ret)
-			dev_warn(&pdev->dev, "%s set timing failed.\n",
-				child->full_name);
+			dev_warn(&pdev->dev, "%pOF set timing failed.\n",
+				child);
 		else
 			have_child = 1;
 	}
@@ -166,8 +166,8 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 		ret = of_platform_default_populate(pdev->dev.of_node,
 						   NULL, &pdev->dev);
 	if (ret)
-		dev_err(&pdev->dev, "%s fail to create devices.\n",
-			pdev->dev.of_node->full_name);
+		dev_err(&pdev->dev, "%pOF fail to create devices.\n",
+			pdev->dev.of_node);
 	return ret;
 }
 

commit 39ec8d3809fdf5228f9cb9fa3d3f2bfb4ee57956
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Jun 1 14:53:07 2016 +0800

    bus: imx-weim: use of_platform_default_populate() to populate default bus
    
    Use helper of_platform_default_populate() in linux/of_platform
    when possible, instead of calling of_platform_populate() with
    the default match table.
    
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Signed-off-by: Huang Shijie <b32955@freescale.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 1827fc4d15c1..4bd361d64270 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -163,9 +163,8 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	}
 
 	if (have_child)
-		ret = of_platform_populate(pdev->dev.of_node,
-				   of_default_bus_match_table,
-				   NULL, &pdev->dev);
+		ret = of_platform_default_populate(pdev->dev.of_node,
+						   NULL, &pdev->dev);
 	if (ret)
 		dev_err(&pdev->dev, "%s fail to create devices.\n",
 			pdev->dev.of_node->full_name);

commit 33b96d2c9579213cf3f36d7b29841b1e464750c4
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Mon Feb 22 09:01:53 2016 -0300

    bus: imx-weim: Take the 'status' property value into account
    
    Currently we have an incorrect behaviour when multiple devices
    are present under the weim node. For example:
    
    &weim {
            ...
            status = "okay";
    
            sram@0,0 {
                    ...
                    status = "okay";
            };
    
            mram@0,0 {
                    ...
                    status = "disabled";
            };
    };
    
    In this case only the 'sram' device should be probed and not 'mram'.
    
    However what happens currently is that the status variable is ignored,
    causing the 'sram' device to be disabled and 'mram' to be enabled.
    
    Change the weim_parse_dt() function to use
    for_each_available_child_of_node()so that the devices marked with
    'status = disabled' are not probed.
    
    Cc: <stable@vger.kernel.org>
    Suggested-by: Wolfgang Netbal <wolfgang.netbal@sigmatek.at>
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Reviewed-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index e98d15eaa799..1827fc4d15c1 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -150,7 +150,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 			return ret;
 	}
 
-	for_each_child_of_node(pdev->dev.of_node, child) {
+	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		if (!child->name)
 			continue;
 

commit 52c47b63412b0946fcf3c04b5e152df41fc7eca5
Author: Alison Chaiken <alison_chaiken@mentor.com>
Date:   Wed Feb 18 23:24:10 2015 -0800

    bus: imx-weim: improve error handling upon child probe-failure
    
    Probe all children of the WEIM node, reporting any failures.  Report
    failure from parsing of WEIM node itself if probes of all children fail.
    
    Signed-off-by: Alison Chaiken <alison_chaiken@mentor.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 0958b6981773..e98d15eaa799 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -142,7 +142,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 							   &pdev->dev);
 	const struct imx_weim_devtype *devtype = of_id->data;
 	struct device_node *child;
-	int ret;
+	int ret, have_child = 0;
 
 	if (devtype == &imx50_weim_devtype) {
 		ret = imx_weim_gpr_setup(pdev);
@@ -155,14 +155,15 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 			continue;
 
 		ret = weim_timing_setup(child, base, devtype);
-		if (ret) {
-			dev_err(&pdev->dev, "%s set timing failed.\n",
+		if (ret)
+			dev_warn(&pdev->dev, "%s set timing failed.\n",
 				child->full_name);
-			return ret;
-		}
+		else
+			have_child = 1;
 	}
 
-	ret = of_platform_populate(pdev->dev.of_node,
+	if (have_child)
+		ret = of_platform_populate(pdev->dev.of_node,
 				   of_default_bus_match_table,
 				   NULL, &pdev->dev);
 	if (ret)

commit 571b8c6adb1b48046ee2dc5e67ed161a4b5c33cf
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:19 2014 +0200

    bus: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 75c9681f8021..0958b6981773 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -206,7 +206,6 @@ static int __init weim_probe(struct platform_device *pdev)
 static struct platform_driver weim_driver = {
 	.driver = {
 		.name		= "imx-weim",
-		.owner		= THIS_MODULE,
 		.of_match_table	= weim_id_table,
 	},
 };

commit 26651c4376454b8a9422577e57c59b6cc37c603d
Author: Liu Ying <Ying.Liu@freescale.com>
Date:   Fri Jul 4 17:00:41 2014 +0800

    bus: imx-weim: populate devices on a simple bus
    
    There could be some memory map devices located in
    a certain chip select region of the i.MX WEIM.
    The devices could be attached to a simple bus(for
    example, a AXI bus) whose root node is one child
    device tree node of the i.MX WEIM device tree node.
    There should be a bridge(very likely, software
    transparent) bewteen the i.MX WEIM and the simple bus.
    This patch makes the i.MX WEIM driver possible to
    populate devices on a simple bus.  In this way, people
    may try various IPs(in a FPGA, maybe) outside of i.MX
    chips with the i.MX WEIM embedded.
    
    Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index f8ee13c7bf7b..75c9681f8021 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -162,7 +162,9 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 		}
 	}
 
-	ret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
+	ret = of_platform_populate(pdev->dev.of_node,
+				   of_default_bus_match_table,
+				   NULL, &pdev->dev);
 	if (ret)
 		dev_err(&pdev->dev, "%s fail to create devices.\n",
 			pdev->dev.of_node->full_name);

commit 8d9ee21e98205eebc7fc6caf08a764c9e12c7d68
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 11 09:52:09 2014 +0800

    bus: imx-weim: support CS GPR configuration
    
    For imx50-weim and imx6q-weim type of devices, there might a WEIM CS
    space configuration register in General Purpose Register controller,
    e.g. IOMUXC_GPR1 on i.MX6Q.
    
    Depending on which configuration of the following 4 is chosen for given
    system, IOMUXC_GPR1[11:0] should be set up as 05, 033, 0113 or 01111
    correspondingly.
    
            CS0(128M) CS1(0M)  CS2(0M)  CS3(0M)
            CS0(64M)  CS1(64M) CS2(0M)  CS3(0M)
            CS0(64M)  CS1(32M) CS2(32M) CS3(0M)
            CS0(32M)  CS1(32M) CS2(32M) CS3(32M)
    
    The patch creates a function for such type of devices, which scans
    'ranges' property of WEIM node and build the GPR value incrementally.
    Thus the WEIM CS GPR can be set up automatically at boot time.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Philippe De Muyter <phdm@macqel.be>
    Tested-by: Philippe De Muyter <phdm@macqel.be>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 3ef58c8dbf11..f8ee13c7bf7b 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -11,6 +11,9 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/of_device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/regmap.h>
 
 struct imx_weim_devtype {
 	unsigned int	cs_count;
@@ -56,6 +59,55 @@ static const struct of_device_id weim_id_table[] = {
 };
 MODULE_DEVICE_TABLE(of, weim_id_table);
 
+static int __init imx_weim_gpr_setup(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct property *prop;
+	const __be32 *p;
+	struct regmap *gpr;
+	u32 gprvals[4] = {
+		05,	/* CS0(128M) CS1(0M)  CS2(0M)  CS3(0M)  */
+		033,	/* CS0(64M)  CS1(64M) CS2(0M)  CS3(0M)  */
+		0113,	/* CS0(64M)  CS1(32M) CS2(32M) CS3(0M)  */
+		01111,	/* CS0(32M)  CS1(32M) CS2(32M) CS3(32M) */
+	};
+	u32 gprval = 0;
+	u32 val;
+	int cs = 0;
+	int i = 0;
+
+	gpr = syscon_regmap_lookup_by_phandle(np, "fsl,weim-cs-gpr");
+	if (IS_ERR(gpr)) {
+		dev_dbg(&pdev->dev, "failed to find weim-cs-gpr\n");
+		return 0;
+	}
+
+	of_property_for_each_u32(np, "ranges", prop, p, val) {
+		if (i % 4 == 0) {
+			cs = val;
+		} else if (i % 4 == 3 && val) {
+			val = (val / SZ_32M) | 1;
+			gprval |= val << cs * 3;
+		}
+		i++;
+	}
+
+	if (i == 0 || i % 4)
+		goto err;
+
+	for (i = 0; i < ARRAY_SIZE(gprvals); i++) {
+		if (gprval == gprvals[i]) {
+			/* Found it. Set up IOMUXC_GPR1[11:0] with it. */
+			regmap_update_bits(gpr, IOMUXC_GPR1, 0xfff, gprval);
+			return 0;
+		}
+	}
+
+err:
+	dev_err(&pdev->dev, "Invalid 'ranges' configuration\n");
+	return -EINVAL;
+}
+
 /* Parse and set the timing for this device. */
 static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
 				    const struct imx_weim_devtype *devtype)
@@ -92,6 +144,12 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 	struct device_node *child;
 	int ret;
 
+	if (devtype == &imx50_weim_devtype) {
+		ret = imx_weim_gpr_setup(pdev);
+		if (ret)
+			return ret;
+	}
+
 	for_each_child_of_node(pdev->dev.of_node, child) {
 		if (!child->name)
 			continue;

commit 3f98b6baad63b181da4e859d81953e88ce8a50ec
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jun 29 08:27:54 2013 +0400

    drivers: bus: imx-weim: Add support for i.MX1/21/25/27/31/35/50/51/53
    
    This patch adds WEIM support for all i.MX CPUs supported by the kernel.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index dc860a411343..3ef58c8dbf11 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -12,46 +12,83 @@
 #include <linux/io.h>
 #include <linux/of_device.h>
 
+struct imx_weim_devtype {
+	unsigned int	cs_count;
+	unsigned int	cs_regs_count;
+	unsigned int	cs_stride;
+};
+
+static const struct imx_weim_devtype imx1_weim_devtype = {
+	.cs_count	= 6,
+	.cs_regs_count	= 2,
+	.cs_stride	= 0x08,
+};
+
+static const struct imx_weim_devtype imx27_weim_devtype = {
+	.cs_count	= 6,
+	.cs_regs_count	= 3,
+	.cs_stride	= 0x10,
+};
+
+static const struct imx_weim_devtype imx50_weim_devtype = {
+	.cs_count	= 4,
+	.cs_regs_count	= 6,
+	.cs_stride	= 0x18,
+};
+
+static const struct imx_weim_devtype imx51_weim_devtype = {
+	.cs_count	= 6,
+	.cs_regs_count	= 6,
+	.cs_stride	= 0x18,
+};
+
 static const struct of_device_id weim_id_table[] = {
-	{ .compatible = "fsl,imx6q-weim", },
-	{}
+	/* i.MX1/21 */
+	{ .compatible = "fsl,imx1-weim", .data = &imx1_weim_devtype, },
+	/* i.MX25/27/31/35 */
+	{ .compatible = "fsl,imx27-weim", .data = &imx27_weim_devtype, },
+	/* i.MX50/53/6Q */
+	{ .compatible = "fsl,imx50-weim", .data = &imx50_weim_devtype, },
+	{ .compatible = "fsl,imx6q-weim", .data = &imx50_weim_devtype, },
+	/* i.MX51 */
+	{ .compatible = "fsl,imx51-weim", .data = &imx51_weim_devtype, },
+	{ }
 };
 MODULE_DEVICE_TABLE(of, weim_id_table);
 
-#define CS_TIMING_LEN 6
-#define CS_REG_RANGE  0x18
-
 /* Parse and set the timing for this device. */
-static int __init weim_timing_setup(struct device_node *np, void __iomem *base)
+static int __init weim_timing_setup(struct device_node *np, void __iomem *base,
+				    const struct imx_weim_devtype *devtype)
 {
-	u32 value[CS_TIMING_LEN];
-	u32 cs_idx;
-	int ret;
-	int i;
+	u32 cs_idx, value[devtype->cs_regs_count];
+	int i, ret;
 
 	/* get the CS index from this child node's "reg" property. */
 	ret = of_property_read_u32(np, "reg", &cs_idx);
 	if (ret)
 		return ret;
 
-	/* The weim has four chip selects. */
-	if (cs_idx > 3)
+	if (cs_idx >= devtype->cs_count)
 		return -EINVAL;
 
 	ret = of_property_read_u32_array(np, "fsl,weim-cs-timing",
-					value, CS_TIMING_LEN);
+					 value, devtype->cs_regs_count);
 	if (ret)
 		return ret;
 
 	/* set the timing for WEIM */
-	for (i = 0; i < CS_TIMING_LEN; i++)
-		writel(value[i], base + cs_idx * CS_REG_RANGE + i * 4);
+	for (i = 0; i < devtype->cs_regs_count; i++)
+		writel(value[i], base + cs_idx * devtype->cs_stride + i * 4);
+
 	return 0;
 }
 
 static int __init weim_parse_dt(struct platform_device *pdev,
 				void __iomem *base)
 {
+	const struct of_device_id *of_id = of_match_device(weim_id_table,
+							   &pdev->dev);
+	const struct imx_weim_devtype *devtype = of_id->data;
 	struct device_node *child;
 	int ret;
 
@@ -59,7 +96,7 @@ static int __init weim_parse_dt(struct platform_device *pdev,
 		if (!child->name)
 			continue;
 
-		ret = weim_timing_setup(child, base);
+		ret = weim_timing_setup(child, base, devtype);
 		if (ret) {
 			dev_err(&pdev->dev, "%s set timing failed.\n",
 				child->full_name);

commit fc608c745cf71a7abb673d891104597120042f21
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jun 29 08:27:53 2013 +0400

    drivers: bus: imx-weim: Add missing platform_driver.owner field
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index f8729247e48e..dc860a411343 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -108,8 +108,9 @@ static int __init weim_probe(struct platform_device *pdev)
 
 static struct platform_driver weim_driver = {
 	.driver = {
-		.name = "imx-weim",
-		.of_match_table = weim_id_table,
+		.name		= "imx-weim",
+		.owner		= THIS_MODULE,
+		.of_match_table	= weim_id_table,
 	},
 };
 module_platform_driver_probe(weim_driver, weim_probe);

commit 29e54970c2681ad621d13df739d0cddf052acf9d
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jun 29 08:27:52 2013 +0400

    drivers: bus: imx-weim: use module_platform_driver_probe()
    
    Driver should be called only once at startup, so code converted
    to using module_platform_driver_probe().
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 0f4b08112afb..f8729247e48e 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -22,7 +22,7 @@ MODULE_DEVICE_TABLE(of, weim_id_table);
 #define CS_REG_RANGE  0x18
 
 /* Parse and set the timing for this device. */
-static int weim_timing_setup(struct device_node *np, void __iomem *base)
+static int __init weim_timing_setup(struct device_node *np, void __iomem *base)
 {
 	u32 value[CS_TIMING_LEN];
 	u32 cs_idx;
@@ -49,7 +49,8 @@ static int weim_timing_setup(struct device_node *np, void __iomem *base)
 	return 0;
 }
 
-static int weim_parse_dt(struct platform_device *pdev, void __iomem *base)
+static int __init weim_parse_dt(struct platform_device *pdev,
+				void __iomem *base)
 {
 	struct device_node *child;
 	int ret;
@@ -73,7 +74,7 @@ static int weim_parse_dt(struct platform_device *pdev, void __iomem *base)
 	return ret;
 }
 
-static int weim_probe(struct platform_device *pdev)
+static int __init weim_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct clk *clk;
@@ -110,10 +111,9 @@ static struct platform_driver weim_driver = {
 		.name = "imx-weim",
 		.of_match_table = weim_id_table,
 	},
-	.probe   = weim_probe,
 };
+module_platform_driver_probe(weim_driver, weim_probe);
 
-module_platform_driver(weim_driver);
 MODULE_AUTHOR("Freescale Semiconductor Inc.");
 MODULE_DESCRIPTION("i.MX EIM Controller Driver");
 MODULE_LICENSE("GPL");

commit b2d1fb7332f2bb8c0630f224d8e2151c0e157004
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jun 29 08:27:51 2013 +0400

    drivers: bus: imx-weim: Simplify error path
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 0c0e6fea129f..0f4b08112afb 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -78,36 +78,30 @@ static int weim_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct clk *clk;
 	void __iomem *base;
-	int ret = -EINVAL;
+	int ret;
 
 	/* get the resource */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base)) {
-		ret = PTR_ERR(base);
-		goto weim_err;
-	}
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
 	/* get the clock */
 	clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(clk))
-		goto weim_err;
+		return PTR_ERR(clk);
 
 	ret = clk_prepare_enable(clk);
 	if (ret)
-		goto weim_err;
+		return ret;
 
 	/* parse the device node */
 	ret = weim_parse_dt(pdev, base);
-	if (ret) {
+	if (ret)
 		clk_disable_unprepare(clk);
-		goto weim_err;
-	}
-
-	dev_info(&pdev->dev, "WEIM driver registered.\n");
-	return 0;
+	else
+		dev_info(&pdev->dev, "Driver registered.\n");
 
-weim_err:
 	return ret;
 }
 

commit 70ac98da780f7085d8c5f0e89bd0438a7f286d20
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jun 29 08:27:50 2013 +0400

    drivers: bus: imx-weim: Remove private driver data
    
    Driver uses only probe function so no reason to keep variables
    in private driver data.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
index 349f14e886b7..0c0e6fea129f 100644
--- a/drivers/bus/imx-weim.c
+++ b/drivers/bus/imx-weim.c
@@ -12,11 +12,6 @@
 #include <linux/io.h>
 #include <linux/of_device.h>
 
-struct imx_weim {
-	void __iomem *base;
-	struct clk *clk;
-};
-
 static const struct of_device_id weim_id_table[] = {
 	{ .compatible = "fsl,imx6q-weim", },
 	{}
@@ -27,10 +22,8 @@ MODULE_DEVICE_TABLE(of, weim_id_table);
 #define CS_REG_RANGE  0x18
 
 /* Parse and set the timing for this device. */
-static int
-weim_timing_setup(struct platform_device *pdev, struct device_node *np)
+static int weim_timing_setup(struct device_node *np, void __iomem *base)
 {
-	struct imx_weim *weim = platform_get_drvdata(pdev);
 	u32 value[CS_TIMING_LEN];
 	u32 cs_idx;
 	int ret;
@@ -52,11 +45,11 @@ weim_timing_setup(struct platform_device *pdev, struct device_node *np)
 
 	/* set the timing for WEIM */
 	for (i = 0; i < CS_TIMING_LEN; i++)
-		writel(value[i], weim->base + cs_idx * CS_REG_RANGE + i * 4);
+		writel(value[i], base + cs_idx * CS_REG_RANGE + i * 4);
 	return 0;
 }
 
-static int weim_parse_dt(struct platform_device *pdev)
+static int weim_parse_dt(struct platform_device *pdev, void __iomem *base)
 {
 	struct device_node *child;
 	int ret;
@@ -65,7 +58,7 @@ static int weim_parse_dt(struct platform_device *pdev)
 		if (!child->name)
 			continue;
 
-		ret = weim_timing_setup(pdev, child);
+		ret = weim_timing_setup(child, base);
 		if (ret) {
 			dev_err(&pdev->dev, "%s set timing failed.\n",
 				child->full_name);
@@ -82,38 +75,32 @@ static int weim_parse_dt(struct platform_device *pdev)
 
 static int weim_probe(struct platform_device *pdev)
 {
-	struct imx_weim *weim;
 	struct resource *res;
+	struct clk *clk;
+	void __iomem *base;
 	int ret = -EINVAL;
 
-	weim = devm_kzalloc(&pdev->dev, sizeof(*weim), GFP_KERNEL);
-	if (!weim) {
-		ret = -ENOMEM;
-		goto weim_err;
-	}
-	platform_set_drvdata(pdev, weim);
-
 	/* get the resource */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	weim->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(weim->base)) {
-		ret = PTR_ERR(weim->base);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		ret = PTR_ERR(base);
 		goto weim_err;
 	}
 
 	/* get the clock */
-	weim->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(weim->clk))
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk))
 		goto weim_err;
 
-	ret = clk_prepare_enable(weim->clk);
+	ret = clk_prepare_enable(clk);
 	if (ret)
 		goto weim_err;
 
 	/* parse the device node */
-	ret = weim_parse_dt(pdev);
+	ret = weim_parse_dt(pdev, base);
 	if (ret) {
-		clk_disable_unprepare(weim->clk);
+		clk_disable_unprepare(clk);
 		goto weim_err;
 	}
 

commit 85bf6d4e4b100efda8169f6f98fd65d0029c7813
Author: Huang Shijie <b32955@freescale.com>
Date:   Tue May 28 14:20:07 2013 +0800

    drivers: bus: add a new driver for WEIM
    
    The WEIM(Wireless External Interface Module) works like a bus.
    You can attach many different devices on it, such as NOR, onenand.
    
    In the case of i.MX6q-sabreauto, the NOR is connected to WEIM.
    
    This patch also adds the devicetree binding document.
    The driver only works when the devicetree is enabled.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c
new file mode 100644
index 000000000000..349f14e886b7
--- /dev/null
+++ b/drivers/bus/imx-weim.c
@@ -0,0 +1,138 @@
+/*
+ * EIM driver for Freescale's i.MX chips
+ *
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+
+struct imx_weim {
+	void __iomem *base;
+	struct clk *clk;
+};
+
+static const struct of_device_id weim_id_table[] = {
+	{ .compatible = "fsl,imx6q-weim", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, weim_id_table);
+
+#define CS_TIMING_LEN 6
+#define CS_REG_RANGE  0x18
+
+/* Parse and set the timing for this device. */
+static int
+weim_timing_setup(struct platform_device *pdev, struct device_node *np)
+{
+	struct imx_weim *weim = platform_get_drvdata(pdev);
+	u32 value[CS_TIMING_LEN];
+	u32 cs_idx;
+	int ret;
+	int i;
+
+	/* get the CS index from this child node's "reg" property. */
+	ret = of_property_read_u32(np, "reg", &cs_idx);
+	if (ret)
+		return ret;
+
+	/* The weim has four chip selects. */
+	if (cs_idx > 3)
+		return -EINVAL;
+
+	ret = of_property_read_u32_array(np, "fsl,weim-cs-timing",
+					value, CS_TIMING_LEN);
+	if (ret)
+		return ret;
+
+	/* set the timing for WEIM */
+	for (i = 0; i < CS_TIMING_LEN; i++)
+		writel(value[i], weim->base + cs_idx * CS_REG_RANGE + i * 4);
+	return 0;
+}
+
+static int weim_parse_dt(struct platform_device *pdev)
+{
+	struct device_node *child;
+	int ret;
+
+	for_each_child_of_node(pdev->dev.of_node, child) {
+		if (!child->name)
+			continue;
+
+		ret = weim_timing_setup(pdev, child);
+		if (ret) {
+			dev_err(&pdev->dev, "%s set timing failed.\n",
+				child->full_name);
+			return ret;
+		}
+	}
+
+	ret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
+	if (ret)
+		dev_err(&pdev->dev, "%s fail to create devices.\n",
+			pdev->dev.of_node->full_name);
+	return ret;
+}
+
+static int weim_probe(struct platform_device *pdev)
+{
+	struct imx_weim *weim;
+	struct resource *res;
+	int ret = -EINVAL;
+
+	weim = devm_kzalloc(&pdev->dev, sizeof(*weim), GFP_KERNEL);
+	if (!weim) {
+		ret = -ENOMEM;
+		goto weim_err;
+	}
+	platform_set_drvdata(pdev, weim);
+
+	/* get the resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	weim->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(weim->base)) {
+		ret = PTR_ERR(weim->base);
+		goto weim_err;
+	}
+
+	/* get the clock */
+	weim->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(weim->clk))
+		goto weim_err;
+
+	ret = clk_prepare_enable(weim->clk);
+	if (ret)
+		goto weim_err;
+
+	/* parse the device node */
+	ret = weim_parse_dt(pdev);
+	if (ret) {
+		clk_disable_unprepare(weim->clk);
+		goto weim_err;
+	}
+
+	dev_info(&pdev->dev, "WEIM driver registered.\n");
+	return 0;
+
+weim_err:
+	return ret;
+}
+
+static struct platform_driver weim_driver = {
+	.driver = {
+		.name = "imx-weim",
+		.of_match_table = weim_id_table,
+	},
+	.probe   = weim_probe,
+};
+
+module_platform_driver(weim_driver);
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
+MODULE_DESCRIPTION("i.MX EIM Controller Driver");
+MODULE_LICENSE("GPL");
