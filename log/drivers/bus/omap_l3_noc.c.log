commit be60566ea9b07c61c1b3cc586a95c1927cdaf3fb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jan 11 10:36:51 2018 +0100

    bus: omap: add MODULE_LICENSE tags
    
    linux-4.15 warns about missing MODULE_LICENSE tags such as these
    
    WARNING: modpost: missing MODULE_LICENSE() in drivers/bus/omap_l3_noc.o
    WARNING: modpost: missing MODULE_LICENSE() in drivers/bus/omap_l3_smx.o
    
    For completeness, I'm also adding MODULE_AUTHOR and MODULE_DESCRIPTION
    tags, but I decided to leave out the email addresses, as all three
    authors are working for other companies now.
    
    Cc: Sricharan R <sricharan@codeaurora.org>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 5012e3ad1225..b040447575ad 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -375,3 +375,8 @@ static void __exit omap_l3_exit(void)
 	platform_driver_unregister(&omap_l3_driver);
 }
 module_exit(omap_l3_exit);
+
+MODULE_AUTHOR("Santosh Shilimkar");
+MODULE_AUTHOR("Sricharan R");
+MODULE_DESCRIPTION("OMAP L3 Interconnect error handling driver");
+MODULE_LICENSE("GPL v2");

commit ab232ba57043ca85b55ffd7125f3f2c2d7e732ec
Merge: 8ced6789da03 32e8d689dc12 56f487c78015
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:18:02 2015 +0200

    Merge branches 'pm-sleep' and 'pm-runtime'
    
    * pm-sleep:
      PM / sleep: trace_device_pm_callback coverage in dpm_prepare/complete
      PM / wakeup: add a dummy wakeup_source to record statistics
      PM / sleep: Make suspend-to-idle-specific code depend on CONFIG_SUSPEND
      PM / sleep: Return -EBUSY from suspend_enter() on wakeup detection
      PM / tick: Add tracepoints for suspend-to-idle diagnostics
      PM / sleep: Fix symbol name in a comment in kernel/power/main.c
      leds / PM: fix hibernation on arm when gpio-led used with CPU led trigger
      ARM: omap-device: use SET_NOIRQ_SYSTEM_SLEEP_PM_OPS
      bus: omap_l3_noc: add missed callbacks for suspend-to-disk
      PM / sleep: Add macro to define common noirq system PM callbacks
      PM / sleep: Refine diagnostic messages in enter_state()
      PM / wakeup: validate wakeup source before activating it.
    
    * pm-runtime:
      PM / Runtime: Update last_busy in rpm_resume
      PM / runtime: add note about re-calling in during device probe()

commit 258d2a1095eebd1d061f84925b05f0d13bd5fcad
Author: Grygorii Strashko <Grygorii.Strashko@linaro.org>
Date:   Mon Apr 27 21:24:31 2015 +0300

    bus: omap_l3_noc: add missed callbacks for suspend-to-disk
    
    Add missed callbacks needed for proper supporting of suspend-to-disk
    by using recently introduced macro SET_NOIRQ_SYSTEM_SLEEP_PM_OPS.
    
    Signed-off-by: Grygorii Strashko <Grygorii.Strashko@linaro.org>
    Acked-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 11f7982cbdb3..6ae38848719e 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -300,7 +300,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 	return ret;
 }
 
-#ifdef	CONFIG_PM
+#ifdef	CONFIG_PM_SLEEP
 
 /**
  * l3_resume_noirq() - resume function for l3_noc
@@ -346,7 +346,7 @@ static int l3_resume_noirq(struct device *dev)
 }
 
 static const struct dev_pm_ops l3_dev_pm_ops = {
-	.resume_noirq		= l3_resume_noirq,
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, l3_resume_noirq)
 };
 
 #define L3_DEV_PM_OPS (&l3_dev_pm_ops)

commit e7309c2673a389a495fcfad70376d3bae8b9bc89
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Apr 24 12:54:20 2015 -0500

    bus: omap_l3_noc: Fix master id address decoding for OMAP5
    
    The L3 Error handling on OMAP5 for the most part is very similar
    to that of OMAP4, and had leveraged common data structures and
    register layout definitions so far. Upon closer inspection, there
    are a few minor differences causing an incorrect decoding and
    reporting of the master NIU upon an error:
    
      1. The L3_TARG_STDERRLOG_MSTADDR.STDERRLOG_MSTADDR occupies
         11 bits on OMAP5 as against 8 bits on OMAP4, with the master
         NIU connID encoded in the 6 MSBs of the STDERRLOG_MSTADDR
         field.
      2. The CLK3 FlagMux component has 1 input source on OMAP4 and 3
         input sources on OMAP5. The common DEBUGSS source is at a
         different input on each SoC.
    
    Fix the above issues by using a OMAP5-specific compatible property
    and using SoC-specific data where there are differences.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 11f7982cbdb3..ebee57d715d2 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -1,7 +1,7 @@
 /*
  * OMAP L3 Interconnect error handling driver
  *
- * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2011-2015 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
  *	Sricharan <r.sricharan@ti.com>
  *
@@ -233,7 +233,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 }
 
 static const struct of_device_id l3_noc_match[] = {
-	{.compatible = "ti,omap4-l3-noc", .data = &omap_l3_data},
+	{.compatible = "ti,omap4-l3-noc", .data = &omap4_l3_data},
+	{.compatible = "ti,omap5-l3-noc", .data = &omap5_l3_data},
 	{.compatible = "ti,dra7-l3-noc", .data = &dra_l3_data},
 	{.compatible = "ti,am4372-l3-noc", .data = &am4372_l3_data},
 	{},

commit d8bf368d0631d4bc2612d8bf2e4e8e74e620d0cc
Author: Valentin Rothberg <valentinrothberg@gmail.com>
Date:   Thu Mar 5 15:23:08 2015 +0100

    genirq: Remove the deprecated 'IRQF_DISABLED' request_irq() flag entirely
    
    The IRQF_DISABLED flag is a NOOP and has been scheduled for removal
    since Linux v2.6.36 by commit 6932bf37bed4 ("genirq: Remove
    IRQF_DISABLED from core code").
    
    According to commit e58aa3d2d0cc ("genirq: Run irq handlers with
    interrupts disabled"), running IRQ handlers with interrupts
    enabled can cause stack overflows when the interrupt line of the
    issuing device is still active.
    
    This patch ends the grace period for IRQF_DISABLED (i.e.,
    SA_INTERRUPT in older versions of Linux) and removes the
    definition and all remaining usages of this flag.
    
    There's still a few non-functional references left in the kernel
    source:
    
      - The bigger hunk in Documentation/scsi/ncr53c8xx.txt is removed entirely
        as IRQF_DISABLED is gone now; the usage in older kernel versions
        (including the old SA_INTERRUPT flag) should be discouraged.  The
        trouble of using IRQF_SHARED is a general problem and not specific to
        any driver.
    
      - I left the reference in Documentation/PCI/MSI-HOWTO.txt untouched since
        it has already been removed in linux-next.
    
      - All remaining references are changelogs that I suggest to keep.
    
    Signed-off-by: Valentin Rothberg <valentinrothberg@gmail.com>
    Cc: Afzal Mohammed <afzal@ti.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Ewan Milne <emilne@redhat.com>
    Cc: Eyal Perry <eyalpe@mellanox.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Hongliang Tao <taohl@lemote.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Quentin Lambert <lambert.quentin@gmail.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Sricharan R <r.sricharan@ti.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Zhou Wang <wangzhou1@hisilicon.com>
    Cc: iss_storagedev@hp.com
    Cc: linux-mips@linux-mips.org
    Cc: linux-mtd@lists.infradead.org
    Link: http://lkml.kernel.org/r/1425565425-12604-1-git-send-email-valentinrothberg@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 029bc73de001..11f7982cbdb3 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -284,7 +284,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 	 */
 	l3->debug_irq = platform_get_irq(pdev, 0);
 	ret = devm_request_irq(l3->dev, l3->debug_irq, l3_interrupt_handler,
-			       IRQF_DISABLED, "l3-dbg-irq", l3);
+			       0x0, "l3-dbg-irq", l3);
 	if (ret) {
 		dev_err(l3->dev, "request_irq failed for %d\n",
 			l3->debug_irq);
@@ -293,7 +293,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 
 	l3->app_irq = platform_get_irq(pdev, 1);
 	ret = devm_request_irq(l3->dev, l3->app_irq, l3_interrupt_handler,
-			       IRQF_DISABLED, "l3-app-irq", l3);
+			       0x0, "l3-app-irq", l3);
 	if (ret)
 		dev_err(l3->dev, "request_irq failed for %d\n", l3->app_irq);
 

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit c4cf0935a2d8fe6d186bf4253ea3c4b4a8a8a710
Author: Keerthy <j-keerthy@ti.com>
Date:   Mon Nov 10 23:49:48 2014 +0530

    bus: omap_l3_noc: Correct returning IRQ_HANDLED unconditionally in the irq handler
    
    Correct returning IRQ_HANDLED unconditionally in the irq handler.
    Return IRQ_NONE for some interrupt which we do not expect to be
    handled in this handler. This prevents kernel stalling with back
    to back spurious interrupts.
    
    Fixes: 2722e56de6 ("OMAP4: l3: Introduce l3-interconnect error handling driver")
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index b5eac29d8f6e..17d86595951c 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -222,10 +222,14 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			}
 
 			/* Error found so break the for loop */
-			break;
+			return IRQ_HANDLED;
 		}
 	}
-	return IRQ_HANDLED;
+
+	dev_err(l3->dev, "L3 %s IRQ not handled!!\n",
+		inttype ? "debug" : "application");
+
+	return IRQ_NONE;
 }
 
 static const struct of_device_id l3_noc_match[] = {

commit 61b43d4e919e8fa5e10c77ee32ba328da07e0264
Author: Keerthy <j-keerthy@ti.com>
Date:   Mon Nov 10 23:49:47 2014 +0530

    bus: omap_l3_noc: Add resume hook to restore context
    
    On certain SoCs such as AM437x SoC, L3_noc error registers are
    maintained in power domain such as per domain which looses context as part
    of low power state such as RTC+DDR mode. On these platforms when we
    mask interrupts which we cannot handle, the source of these interrupts
    still remain on resume, however, the flag mux registers now contain
    their reset value (unmasked) - this breaks the system with infinite
    interrupts since we do not these interrupts to take place ever again.
    
    To handle this: restore the masking of interrupts which we have
    already recorded in the system as ones we cannot handle.
    
    Fixes: 2100b595b7 ("bus: omap_l3_noc: ignore masked out unclearable targets")
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 531ae591783b..b5eac29d8f6e 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -296,11 +296,66 @@ static int omap_l3_probe(struct platform_device *pdev)
 	return ret;
 }
 
+#ifdef	CONFIG_PM
+
+/**
+ * l3_resume_noirq() - resume function for l3_noc
+ * @dev:	pointer to l3_noc device structure
+ *
+ * We only have the resume handler only since we
+ * have already maintained the delta register
+ * configuration as part of configuring the system
+ */
+static int l3_resume_noirq(struct device *dev)
+{
+	struct omap_l3 *l3 = dev_get_drvdata(dev);
+	int i;
+	struct l3_flagmux_data *flag_mux;
+	void __iomem *base, *mask_regx = NULL;
+	u32 mask_val;
+
+	for (i = 0; i < l3->num_modules; i++) {
+		base = l3->l3_base[i];
+		flag_mux = l3->l3_flagmux[i];
+		if (!flag_mux->mask_app_bits && !flag_mux->mask_dbg_bits)
+			continue;
+
+		mask_regx = base + flag_mux->offset + L3_FLAGMUX_MASK0 +
+			   (L3_APPLICATION_ERROR << 3);
+		mask_val = readl_relaxed(mask_regx);
+		mask_val &= ~(flag_mux->mask_app_bits);
+
+		writel_relaxed(mask_val, mask_regx);
+		mask_regx = base + flag_mux->offset + L3_FLAGMUX_MASK0 +
+			   (L3_DEBUG_ERROR << 3);
+		mask_val = readl_relaxed(mask_regx);
+		mask_val &= ~(flag_mux->mask_dbg_bits);
+
+		writel_relaxed(mask_val, mask_regx);
+	}
+
+	/* Dummy read to force OCP barrier */
+	if (mask_regx)
+		(void)readl(mask_regx);
+
+	return 0;
+}
+
+static const struct dev_pm_ops l3_dev_pm_ops = {
+	.resume_noirq		= l3_resume_noirq,
+};
+
+#define L3_DEV_PM_OPS (&l3_dev_pm_ops)
+#else
+#define L3_DEV_PM_OPS NULL
+#endif
+
 static struct platform_driver omap_l3_driver = {
 	.probe		= omap_l3_probe,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,
+		.pm		= L3_DEV_PM_OPS,
 		.of_match_table = of_match_ptr(l3_noc_match),
 	},
 };

commit 571b8c6adb1b48046ee2dc5e67ed161a4b5c33cf
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:19 2014 +0200

    bus: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 531ae591783b..1ff1863415c5 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -300,7 +300,6 @@ static struct platform_driver omap_l3_driver = {
 	.probe		= omap_l3_probe,
 	.driver		= {
 		.name		= "omap_l3_noc",
-		.owner		= THIS_MODULE,
 		.of_match_table = of_match_ptr(l3_noc_match),
 	},
 };

commit 27b7d5f3cc49f2e5cd6c005d73696058b7140c5c
Author: Afzal Mohammed <afzal@ti.com>
Date:   Mon Dec 2 17:48:57 2013 +0530

    bus: omap_l3_noc: Add AM4372 interconnect error data
    
    Add AM4372 information to handle L3 error.
    
    AM4372 has two clk domains 100f and 200s. Provide flagmux and data
    associated with it.
    
    NOTE: Timeout doesn't have STDERRLOG_MAIN register. And per hardware
    team, L3 timeout error cannot be cleared the normal way (by setting
    bit 31 in STDERRLOG_MAIN), instead it may be required to do system
    reset. L3 error handler can't help in such scenarios.
    
    Hence indicate timeout target offset as L3_TARGET_NOT_SUPPORTED as
    done for undocumented bits.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 6cdd02ef0909..531ae591783b 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -231,6 +231,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 static const struct of_device_id l3_noc_match[] = {
 	{.compatible = "ti,omap4-l3-noc", .data = &omap_l3_data},
 	{.compatible = "ti,dra7-l3-noc", .data = &dra_l3_data},
+	{.compatible = "ti,am4372-l3-noc", .data = &am4372_l3_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, l3_noc_match);

commit 53a848be0a65c6fb105eb5ecb8b8b3edfa0f91ad
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Thu Apr 10 11:33:13 2014 -0500

    bus: omap_l3_noc: Add DRA7 interconnect error data
    
    DRA7 is distinctly different from OMAP4 in terms of masters and clock
    domain organization. There two main clock domains which is divided as
    follows:
         <0x44000000 0x1000000> is clk1 and clk2 is the sub clock domain
         <0x45000000 0x1000> is clk3
    
    Add all the data needed to handle L3 error handling on DRA7 devices
    and mark clk2 as subdomain and provide a compatible flag for
    functionality. Other than the data difference the hardware blocks
    involved are essentially the same.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [nm@ti.com: bugfixes and generic improvements, documentation]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 0eba07ac6008..6cdd02ef0909 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -230,6 +230,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 static const struct of_device_id l3_noc_match[] = {
 	{.compatible = "ti,omap4-l3-noc", .data = &omap_l3_data},
+	{.compatible = "ti,dra7-l3-noc", .data = &dra_l3_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, l3_noc_match);

commit f33ddf745cbcd4145fcb2f8239f5dbba089fb8ff
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 14:37:03 2014 -0500

    bus: omap_l3_noc: introduce concept of submodule
    
    While OMAP4 and OMAP5 had 3 separate clock domains, DRA7 has only 2
    and the first one then is internally divided into 2 sub clock domains.
    
    To better represent this in the driver, we use the concept of submodule.
    
    The address defintions in the devicetree is as per the high level
    clock domain(module) base, the sub clockdomain/subdomain which shares
    the same register space of a clockdomain is marked in the SoC data as
    L3_BASE_IS_SUBMODULE.
    
    L3_BASE_IS_SUBMODULE is used as an indication that it's base address is
    the same as the parent module and offsets are considered from the same
    base address as they are usually intermingled.
    
    Other than the base address, the submodule is same as a module as it is
    functionally so.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 08344b03fda6..0eba07ac6008 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -238,7 +238,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id;
 	static struct omap_l3 *l3;
-	int ret, i;
+	int ret, i, res_idx;
 
 	of_id = of_match_device(l3_noc_match, &pdev->dev);
 	if (!of_id) {
@@ -255,15 +255,22 @@ static int omap_l3_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, l3);
 
 	/* Get mem resources */
-	for (i = 0; i < l3->num_modules; i++) {
-		struct resource	*res = platform_get_resource(pdev,
-							     IORESOURCE_MEM, i);
-
+	for (i = 0, res_idx = 0; i < l3->num_modules; i++) {
+		struct resource	*res;
+
+		if (l3->l3_base[i] == L3_BASE_IS_SUBMODULE) {
+			/* First entry cannot be submodule */
+			BUG_ON(i == 0);
+			l3->l3_base[i] = l3->l3_base[i - 1];
+			continue;
+		}
+		res = platform_get_resource(pdev, IORESOURCE_MEM, res_idx);
 		l3->l3_base[i] = devm_ioremap_resource(&pdev->dev, res);
 		if (IS_ERR(l3->l3_base[i])) {
 			dev_err(l3->dev, "ioremap %d failed\n", i);
 			return PTR_ERR(l3->l3_base[i]);
 		}
+		res_idx++;
 	}
 
 	/*

commit cf52b2ecd719ca7acb19c0fd74bcfcce9dc6a362
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 17:23:33 2014 -0500

    bus: omap_l3_noc: Add information about the context of operation
    
    L3 error may be triggered using Debug interface (example JTAG) or
    due to other errors, for example an opcode fetch (due to function
    pointer or stack corruption) or a data access (due to some other
    failure). NOC registers contain additional information to help aid
    debug information.
    
    With this, we can enhance the error information to more detailed form:
    "
    L3 Custom Error: MASTER MPU TARGET L4PER2 (Read): Data Access in User mode
    during Functional access
    "
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 9d021d002bec..08344b03fda6 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -60,15 +60,16 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 {
 	int k;
 	u32 std_err_main, clear, masterid;
-	u8 op_code;
+	u8 op_code, m_req_info;
 	void __iomem *l3_targ_base;
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
-	void __iomem *l3_targ_hdr;
+	void __iomem *l3_targ_hdr, *l3_targ_info;
 	struct l3_target_data *l3_targ_inst;
 	struct l3_masters_data *master;
 	char *target_name, *master_name = "UN IDENTIFIED";
 	char *err_description;
 	char err_string[30] = { 0 };
+	char info_string[60] = { 0 };
 
 	/* We DONOT expect err_src to go out of bounds */
 	BUG_ON(err_src > MAX_CLKDM_TARGETS);
@@ -99,6 +100,7 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 
 		l3_targ_mstaddr = l3_targ_base + L3_TARG_STDERRLOG_MSTADDR;
 		l3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_HDR;
+		l3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_INFO;
 		break;
 
 	case CUSTOM_ERROR:
@@ -107,6 +109,7 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 		l3_targ_mstaddr = l3_targ_base +
 				  L3_TARG_STDERRLOG_CINFO_MSTADDR;
 		l3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_CINFO_OPCODE;
+		l3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_CINFO_INFO;
 		break;
 
 	default:
@@ -128,13 +131,20 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 
 	op_code = readl_relaxed(l3_targ_hdr) & 0x7;
 
+	m_req_info = readl_relaxed(l3_targ_info) & 0xF;
+	snprintf(info_string, sizeof(info_string),
+		 ": %s in %s mode during %s access",
+		 (m_req_info & BIT(0)) ? "Opcode Fetch" : "Data Access",
+		 (m_req_info & BIT(1)) ? "Supervisor" : "User",
+		 (m_req_info & BIT(3)) ? "Debug" : "Functional");
+
 	WARN(true,
-	     "%s:L3 %s Error: MASTER %s TARGET %s (%s)%s\n",
+	     "%s:L3 %s Error: MASTER %s TARGET %s (%s)%s%s\n",
 	     dev_name(l3->dev),
 	     err_description,
 	     master_name, target_name,
 	     l3_transaction_type[op_code],
-	     err_string);
+	     err_string, info_string);
 
 	/* clear the std error log*/
 	clear = std_err_main | CLEAR_STDERR_LOG;

commit 7f9de02d603c439890c4c94631a326c73e2b5b4c
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 15:47:28 2014 -0500

    bus: omap_l3_noc: add information about the type of operation
    
    Today we get error such as
    L3 Custom Error: MASTER MPU TARGET L4PER2
    
    But since the actual instruction triggerring the error Vs the point
    at which we report error may not be aligned, it makes sense to try
    and provide additional information - example the type of operation
    that was attempted to being performed can help narrow the debug down
    further.
    
    This helps provide log such as:
    L3 Custom Error: MASTER MPU TARGET L4PER2 (Read)
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 00e4fed4a39b..9d021d002bec 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -60,8 +60,10 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 {
 	int k;
 	u32 std_err_main, clear, masterid;
+	u8 op_code;
 	void __iomem *l3_targ_base;
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
+	void __iomem *l3_targ_hdr;
 	struct l3_target_data *l3_targ_inst;
 	struct l3_masters_data *master;
 	char *target_name, *master_name = "UN IDENTIFIED";
@@ -96,6 +98,7 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 			 readl_relaxed(l3_targ_slvofslsb));
 
 		l3_targ_mstaddr = l3_targ_base + L3_TARG_STDERRLOG_MSTADDR;
+		l3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_HDR;
 		break;
 
 	case CUSTOM_ERROR:
@@ -103,6 +106,7 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 
 		l3_targ_mstaddr = l3_targ_base +
 				  L3_TARG_STDERRLOG_CINFO_MSTADDR;
+		l3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_CINFO_OPCODE;
 		break;
 
 	default:
@@ -122,11 +126,14 @@ static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
 		}
 	}
 
+	op_code = readl_relaxed(l3_targ_hdr) & 0x7;
+
 	WARN(true,
-	     "%s:L3 %s Error: MASTER %s TARGET %s%s\n",
+	     "%s:L3 %s Error: MASTER %s TARGET %s (%s)%s\n",
 	     dev_name(l3->dev),
 	     err_description,
 	     master_name, target_name,
+	     l3_transaction_type[op_code],
 	     err_string);
 
 	/* clear the std error log*/

commit 2100b595b756db29a0b71de49c3bf73ae76c679b
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Apr 25 17:38:11 2014 -0500

    bus: omap_l3_noc: ignore masked out unclearable targets
    
    Errors that cannot be cleared (determined by reading REGERR register)
    are currently handled by masking it. Documentation states that REGERR
    "Checks which application/debug error sources are active" - it does not
    indicate that this is "interrupt status" - masked out status represented
    eventually in the irq line to MPU.
    For example:
    
    Lets say module 0 bit 8(0x100) was unclearable, we do the mask it from
    generating further errors. However in the following cases:
    a) bit 9 of Module 0
    OR
    b) any bit of Module 1+
    occur, the interrupt handler wrongly assumes that the raw interrupt
    status of module 0 bit 8 is the root cause of the interrupt, and
    returns. This causes unhandled interrupt and resultant infinite
    interrupts.
    
    Fix this scenario by storing the events we masked out and masking raw
    status with masked ones before identifying and handling the error.
    
    Reported-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 0691e6d9c1e4..00e4fed4a39b 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -169,6 +169,9 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		err_reg = readl_relaxed(base + flag_mux->offset +
 					L3_FLAGMUX_REGERR0 + (inttype << 3));
 
+		err_reg &= ~(inttype ? flag_mux->mask_app_bits :
+				flag_mux->mask_dbg_bits);
+
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
 			/* Identify the source from control status register */
@@ -193,6 +196,12 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 				mask_val = readl_relaxed(mask_reg);
 				mask_val &= ~(1 << err_src);
 				writel_relaxed(mask_val, mask_reg);
+
+				/* Mark these bits as to be ignored */
+				if (inttype)
+					flag_mux->mask_app_bits |= 1 << err_src;
+				else
+					flag_mux->mask_dbg_bits |= 1 << err_src;
 			}
 
 			/* Error found so break the for loop */

commit e4be3f3a040432398225d3634d44fc21f4807b7a
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Apr 17 12:33:50 2014 -0500

    bus: omap_l3_noc: improve readability by using helper for slave event parsing
    
    Current interrupt handler does the first level parse to identify the
    slave and then handles the slave even identification, reporting and
    clearing of event as well. It is hence logical to split the handler
    into two where the primary handler just parses the flagmux till it
    identifies a slave and the slave handling, reporting and clearing is
    done in a helper function.
    
    While at it update the documentation in kerneldoc style.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 42e411457494..0691e6d9c1e4 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -26,14 +26,20 @@
 
 #include "omap_l3_noc.h"
 
-/*
- * Interrupt Handler for L3 error detection.
- *	1) Identify the L3 clockdomain partition to which the error belongs to.
- *	2) Identify the slave where the error information is logged
- *	3) Print the logged information.
- *	4) Add dump stack to provide kernel trace.
+/**
+ * l3_handle_target() - Handle Target specific parse and reporting
+ * @l3:		pointer to l3 struct
+ * @base:	base address of clkdm
+ * @flag_mux:	flagmux corresponding to the event
+ * @err_src:	error source index of the slave (target)
  *
- * Two Types of errors :
+ * This does the second part of the error interrupt handling:
+ *	3) Parse in the slave information
+ *	4) Print the logged information.
+ *	5) Add dump stack to provide kernel trace.
+ *	6) Clear the source if known.
+ *
+ * This handles two types of errors:
  *	1) Custom errors in L3 :
  *		Target like DMM/FW/EMIF generates SRESP=ERR error
  *	2) Standard L3 error:
@@ -49,22 +55,107 @@
  *	can be trapped as well. But the trapping is implemented as part
  *	secure software and hence need not be implemented here.
  */
-static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
+static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,
+			    struct l3_flagmux_data *flag_mux, int err_src)
 {
-
-	struct omap_l3 *l3 = _l3;
-	int inttype, i, k;
-	int err_src = 0;
-	u32 std_err_main, err_reg, clear, masterid;
-	void __iomem *base, *l3_targ_base;
+	int k;
+	u32 std_err_main, clear, masterid;
+	void __iomem *l3_targ_base;
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
-	char *target_name, *master_name = "UN IDENTIFIED";
 	struct l3_target_data *l3_targ_inst;
-	struct l3_flagmux_data *flag_mux;
 	struct l3_masters_data *master;
+	char *target_name, *master_name = "UN IDENTIFIED";
 	char *err_description;
 	char err_string[30] = { 0 };
 
+	/* We DONOT expect err_src to go out of bounds */
+	BUG_ON(err_src > MAX_CLKDM_TARGETS);
+
+	if (err_src < flag_mux->num_targ_data) {
+		l3_targ_inst = &flag_mux->l3_targ[err_src];
+		target_name = l3_targ_inst->name;
+		l3_targ_base = base + l3_targ_inst->offset;
+	} else {
+		target_name = L3_TARGET_NOT_SUPPORTED;
+	}
+
+	if (target_name == L3_TARGET_NOT_SUPPORTED)
+		return -ENODEV;
+
+	/* Read the stderrlog_main_source from clk domain */
+	l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
+	l3_targ_slvofslsb = l3_targ_base + L3_TARG_STDERRLOG_SLVOFSLSB;
+
+	std_err_main = readl_relaxed(l3_targ_stderr);
+
+	switch (std_err_main & CUSTOM_ERROR) {
+	case STANDARD_ERROR:
+		err_description = "Standard";
+		snprintf(err_string, sizeof(err_string),
+			 ": At Address: 0x%08X ",
+			 readl_relaxed(l3_targ_slvofslsb));
+
+		l3_targ_mstaddr = l3_targ_base + L3_TARG_STDERRLOG_MSTADDR;
+		break;
+
+	case CUSTOM_ERROR:
+		err_description = "Custom";
+
+		l3_targ_mstaddr = l3_targ_base +
+				  L3_TARG_STDERRLOG_CINFO_MSTADDR;
+		break;
+
+	default:
+		/* Nothing to be handled here as of now */
+		return 0;
+	}
+
+	/* STDERRLOG_MSTADDR Stores the NTTP master address. */
+	masterid = (readl_relaxed(l3_targ_mstaddr) &
+		    l3->mst_addr_mask) >> __ffs(l3->mst_addr_mask);
+
+	for (k = 0, master = l3->l3_masters; k < l3->num_masters;
+	     k++, master++) {
+		if (masterid == master->id) {
+			master_name = master->name;
+			break;
+		}
+	}
+
+	WARN(true,
+	     "%s:L3 %s Error: MASTER %s TARGET %s%s\n",
+	     dev_name(l3->dev),
+	     err_description,
+	     master_name, target_name,
+	     err_string);
+
+	/* clear the std error log*/
+	clear = std_err_main | CLEAR_STDERR_LOG;
+	writel_relaxed(clear, l3_targ_stderr);
+
+	return 0;
+}
+
+/**
+ * l3_interrupt_handler() - interrupt handler for l3 events
+ * @irq:	irq number
+ * @_l3:	pointer to l3 structure
+ *
+ * Interrupt Handler for L3 error detection.
+ *	1) Identify the L3 clockdomain partition to which the error belongs to.
+ *	2) Identify the slave where the error information is logged
+ *	... handle the slave event..
+ *	7) if the slave is unknown, mask out the slave.
+ */
+static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
+{
+	struct omap_l3 *l3 = _l3;
+	int inttype, i, ret;
+	int err_src = 0;
+	u32 err_reg, mask_val;
+	void __iomem *base, *mask_reg;
+	struct l3_flagmux_data *flag_mux;
+
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
 
@@ -80,35 +171,18 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
-			bool std_err = true;
-
 			/* Identify the source from control status register */
 			err_src = __ffs(err_reg);
 
-			/* We DONOT expect err_src to go out of bounds */
-			BUG_ON(err_src > MAX_CLKDM_TARGETS);
-
-			if (err_src < flag_mux->num_targ_data) {
-				l3_targ_inst = &flag_mux->l3_targ[err_src];
-				target_name = l3_targ_inst->name;
-				l3_targ_base = base + l3_targ_inst->offset;
-			} else {
-				target_name = L3_TARGET_NOT_SUPPORTED;
-			}
+			ret = l3_handle_target(l3, base, flag_mux, err_src);
 
 			/*
-			 * If we do not know of a register offset to decode
-			 * and clear, then mask.
+			 * Certain plaforms may have "undocumented" status
+			 * pending on boot. So dont generate a severe warning
+			 * here. Just mask it off to prevent the error from
+			 * reoccuring and locking up the system.
 			 */
-			if (target_name == L3_TARGET_NOT_SUPPORTED) {
-				u32 mask_val;
-				void __iomem *mask_reg;
-
-				/*
-				 * Certain plaforms may have "undocumented"
-				 * status pending on boot.. So dont generate
-				 * a severe warning here.
-				 */
+			if (ret) {
 				dev_err(l3->dev,
 					"L3 %s error: target %d mod:%d %s\n",
 					inttype ? "debug" : "application",
@@ -119,67 +193,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 				mask_val = readl_relaxed(mask_reg);
 				mask_val &= ~(1 << err_src);
 				writel_relaxed(mask_val, mask_reg);
-
-				break;
 			}
 
-			/* Read the stderrlog_main_source from clk domain */
-			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
-			l3_targ_slvofslsb = l3_targ_base +
-					    L3_TARG_STDERRLOG_SLVOFSLSB;
-
-			std_err_main = readl_relaxed(l3_targ_stderr);
-
-			switch (std_err_main & CUSTOM_ERROR) {
-			case STANDARD_ERROR:
-				err_description = "Standard";
-				snprintf(err_string, sizeof(err_string),
-					 ": At Address: 0x%08X ",
-					 readl_relaxed(l3_targ_slvofslsb));
-
-				l3_targ_mstaddr = l3_targ_base +
-						L3_TARG_STDERRLOG_MSTADDR;
-				break;
-
-			case CUSTOM_ERROR:
-				err_description = "Custom";
-
-				l3_targ_mstaddr = l3_targ_base +
-						L3_TARG_STDERRLOG_CINFO_MSTADDR;
-				break;
-
-			default:
-				std_err = false;
-				/* Nothing to be handled here as of now */
-				break;
-			}
-
-			if (!std_err)
-				break;
-
-			/* STDERRLOG_MSTADDR Stores the NTTP master address. */
-			masterid = (readl_relaxed(l3_targ_mstaddr) &
-				    l3->mst_addr_mask) >>
-					__ffs(l3->mst_addr_mask);
-
-			for (k = 0, master = l3->l3_masters;
-			     k < l3->num_masters; k++, master++) {
-				if (masterid == master->id) {
-					master_name = master->name;
-					break;
-				}
-			}
-
-			WARN(true,
-			     "%s:L3 %s Error: MASTER %s TARGET %s%s\n",
-			     dev_name(l3->dev),
-			     err_description,
-			     master_name, target_name,
-			     err_string);
-			/* clear the std error log*/
-			clear = std_err_main | CLEAR_STDERR_LOG;
-			writel_relaxed(clear, l3_targ_stderr);
-
 			/* Error found so break the for loop */
 			break;
 		}

commit c98aa7aaa24b7687a170b93c4bf3111a6d166069
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 12:24:56 2014 -0500

    bus: omap_l3_noc: make error reporting and handling common
    
    The logic between handling CUSTOM_ERROR and STANDARD_ERROR is just the
    reporting style.
    
    So make it generic, simplify and standardize the reporting with both
    master and target information printed to log.
    
    Handle the register address difference for master code for standard
    error and custom error as well.
    
    While at it, fix a minor indentation error.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 8a1926daacd7..42e411457494 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -62,6 +62,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	struct l3_target_data *l3_targ_inst;
 	struct l3_flagmux_data *flag_mux;
 	struct l3_masters_data *master;
+	char *err_description;
+	char err_string[30] = { 0 };
 
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
@@ -78,6 +80,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
+			bool std_err = true;
+
 			/* Identify the source from control status register */
 			err_src = __ffs(err_reg);
 
@@ -123,47 +127,61 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
 			l3_targ_slvofslsb = l3_targ_base +
 					    L3_TARG_STDERRLOG_SLVOFSLSB;
-			l3_targ_mstaddr = l3_targ_base +
-					  L3_TARG_STDERRLOG_MSTADDR;
 
 			std_err_main = readl_relaxed(l3_targ_stderr);
 
-			/* STDERRLOG_MSTADDR Stores the NTTP master address. */
-			masterid = (readl_relaxed(l3_targ_mstaddr) &
-				    l3->mst_addr_mask) >>
-					__ffs(l3->mst_addr_mask);
-
 			switch (std_err_main & CUSTOM_ERROR) {
 			case STANDARD_ERROR:
-				WARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",
-					target_name,
-					readl_relaxed(l3_targ_slvofslsb));
-				/* clear the std error log*/
-				clear = std_err_main | CLEAR_STDERR_LOG;
-				writel_relaxed(clear, l3_targ_stderr);
+				err_description = "Standard";
+				snprintf(err_string, sizeof(err_string),
+					 ": At Address: 0x%08X ",
+					 readl_relaxed(l3_targ_slvofslsb));
+
+				l3_targ_mstaddr = l3_targ_base +
+						L3_TARG_STDERRLOG_MSTADDR;
 				break;
 
 			case CUSTOM_ERROR:
-				for (k = 0, master = l3->l3_masters;
-				     k < l3->num_masters; k++, master++) {
-					if (masterid == master->id) {
-						master_name = master->name;
-						break;
-					}
-				}
-				WARN(true, "L3 custom error: MASTER:%s TARGET:%s\n",
-					master_name, target_name);
-				/* clear the std error log*/
-				clear = std_err_main | CLEAR_STDERR_LOG;
-				writel_relaxed(clear, l3_targ_stderr);
+				err_description = "Custom";
+
+				l3_targ_mstaddr = l3_targ_base +
+						L3_TARG_STDERRLOG_CINFO_MSTADDR;
 				break;
 
 			default:
+				std_err = false;
 				/* Nothing to be handled here as of now */
 				break;
 			}
-		/* Error found so break the for loop */
-		break;
+
+			if (!std_err)
+				break;
+
+			/* STDERRLOG_MSTADDR Stores the NTTP master address. */
+			masterid = (readl_relaxed(l3_targ_mstaddr) &
+				    l3->mst_addr_mask) >>
+					__ffs(l3->mst_addr_mask);
+
+			for (k = 0, master = l3->l3_masters;
+			     k < l3->num_masters; k++, master++) {
+				if (masterid == master->id) {
+					master_name = master->name;
+					break;
+				}
+			}
+
+			WARN(true,
+			     "%s:L3 %s Error: MASTER %s TARGET %s%s\n",
+			     dev_name(l3->dev),
+			     err_description,
+			     master_name, target_name,
+			     err_string);
+			/* clear the std error log*/
+			clear = std_err_main | CLEAR_STDERR_LOG;
+			writel_relaxed(clear, l3_targ_stderr);
+
+			/* Error found so break the for loop */
+			break;
 		}
 	}
 	return IRQ_HANDLED;

commit d4d8819e205854cc102e366f30b8eadd60a58e97
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 11:01:02 2014 -0500

    bus: omap_l3_noc: fix masterid detection
    
    As per Documentation (OMAP4+), then masterid is infact encoded as
    follows:
    "L3_TARG_STDERRLOG_MSTADDR[7:0] STDERRLOG_MSTADDR stores the NTTP
    master address. The master address is the concatenation of Prefix &
    Initiator ConnID. It is defined on 8 bits. The 6 MSBs are used to
    distinguish the different initiators."
    
    So, when we matchup currently with the master ID list, we never get a
    proper match other than when MPU is the master (thanks to 0).
    
    Now, on other platforms such as AM437x, this tends to be bits[5:0].
    
    Fix this by using the relevant 6MSBits to identify the master ID for
    standard and custom errors.
    
    Reported-by: Darren Etheridge <detheridge@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 9524452ee12c..8a1926daacd7 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -127,7 +127,11 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					  L3_TARG_STDERRLOG_MSTADDR;
 
 			std_err_main = readl_relaxed(l3_targ_stderr);
-			masterid = readl_relaxed(l3_targ_mstaddr);
+
+			/* STDERRLOG_MSTADDR Stores the NTTP master address. */
+			masterid = (readl_relaxed(l3_targ_mstaddr) &
+				    l3->mst_addr_mask) >>
+					__ffs(l3->mst_addr_mask);
 
 			switch (std_err_main & CUSTOM_ERROR) {
 			case STANDARD_ERROR:

commit 97708c08c9955306742872ff7f2e47faec864ee7
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Apr 14 09:57:50 2014 -0500

    bus: omap_l3_noc: convert flagmux information into a structure
    
    This allows us to encompass target information and flag mux offset that
    points to the target information into a singular structure. This saves
    us the need to look up two different arrays indexed by module ID for
    information.
    
    This allows us to reduce the static target information allocation to
    just the ones that are documented.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 7e0a988ad579..9524452ee12c 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -60,6 +60,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
 	char *target_name, *master_name = "UN IDENTIFIED";
 	struct l3_target_data *l3_targ_inst;
+	struct l3_flagmux_data *flag_mux;
 	struct l3_masters_data *master;
 
 	/* Get the Type of interrupt */
@@ -71,7 +72,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		 * to determine the source
 		 */
 		base = l3->l3_base[i];
-		err_reg = readl_relaxed(base + l3->l3_flagmux[i] +
+		flag_mux = l3->l3_flagmux[i];
+		err_reg = readl_relaxed(base + flag_mux->offset +
 					L3_FLAGMUX_REGERR0 + (inttype << 3));
 
 		/* Get the corresponding error and analyse */
@@ -82,9 +84,13 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			/* We DONOT expect err_src to go out of bounds */
 			BUG_ON(err_src > MAX_CLKDM_TARGETS);
 
-			l3_targ_inst = &l3->l3_targ[i][err_src];
-			target_name = l3_targ_inst->name;
-			l3_targ_base = base + l3_targ_inst->offset;
+			if (err_src < flag_mux->num_targ_data) {
+				l3_targ_inst = &flag_mux->l3_targ[err_src];
+				target_name = l3_targ_inst->name;
+				l3_targ_base = base + l3_targ_inst->offset;
+			} else {
+				target_name = L3_TARGET_NOT_SUPPORTED;
+			}
 
 			/*
 			 * If we do not know of a register offset to decode
@@ -104,7 +110,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					inttype ? "debug" : "application",
 					err_src, i, "(unclearable)");
 
-				mask_reg = base + l3->l3_flagmux[i] +
+				mask_reg = base + flag_mux->offset +
 					   L3_FLAGMUX_MASK0 + (inttype << 3);
 				mask_val = readl_relaxed(mask_reg);
 				mask_val &= ~(1 << err_src);

commit 0659452dd2b2602058b80cfdcc673e98f2a67184
Author: Sricharan R <r.sricharan@ti.com>
Date:   Tue Nov 26 07:38:23 2013 -0600

    bus: omap_l3_noc: use of_match_data to pick up SoC information
    
    DRA7xx SoC has the same l3-noc interconnect ip (as OMAP4 and OMAP5), but
    AM437x SoC has just 2 modules instead of 3 which other SoCs have.
    
    So, stop using direct access of array indices and use of->match data and
    simplify implementation to benefit future usage.
    
    While at it, rename a few very generic variables to make them omap
    specific. This helps us differentiate from DRA7 and AM43xx data in the
    future.
    
    NOTE: None of the platforms that use omap_l3_noc are non-device tree
    anymore. So, it is safe to assume OF match here.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [nm@ti.com: split, refactor and optimize logic]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 7743e86e88b1..7e0a988ad579 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -14,12 +14,14 @@
  * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 
 #include "omap_l3_noc.h"
@@ -58,17 +60,18 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
 	char *target_name, *master_name = "UN IDENTIFIED";
 	struct l3_target_data *l3_targ_inst;
+	struct l3_masters_data *master;
 
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
 
-	for (i = 0; i < L3_MODULES; i++) {
+	for (i = 0; i < l3->num_modules; i++) {
 		/*
 		 * Read the regerr register of the clock domain
 		 * to determine the source
 		 */
 		base = l3->l3_base[i];
-		err_reg = readl_relaxed(base + l3_flagmux[i] +
+		err_reg = readl_relaxed(base + l3->l3_flagmux[i] +
 					L3_FLAGMUX_REGERR0 + (inttype << 3));
 
 		/* Get the corresponding error and analyse */
@@ -79,7 +82,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			/* We DONOT expect err_src to go out of bounds */
 			BUG_ON(err_src > MAX_CLKDM_TARGETS);
 
-			l3_targ_inst = &l3_targ[i][err_src];
+			l3_targ_inst = &l3->l3_targ[i][err_src];
 			target_name = l3_targ_inst->name;
 			l3_targ_base = base + l3_targ_inst->offset;
 
@@ -101,7 +104,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					inttype ? "debug" : "application",
 					err_src, i, "(unclearable)");
 
-				mask_reg = base + l3_flagmux[i] +
+				mask_reg = base + l3->l3_flagmux[i] +
 					   L3_FLAGMUX_MASK0 + (inttype << 3);
 				mask_val = readl_relaxed(mask_reg);
 				mask_val &= ~(1 << err_src);
@@ -131,10 +134,12 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 				break;
 
 			case CUSTOM_ERROR:
-				for (k = 0; k < NUM_OF_L3_MASTERS; k++) {
-					if (masterid == l3_masters[k].id)
-						master_name =
-							l3_masters[k].name;
+				for (k = 0, master = l3->l3_masters;
+				     k < l3->num_masters; k++, master++) {
+					if (masterid == master->id) {
+						master_name = master->name;
+						break;
+					}
 				}
 				WARN(true, "L3 custom error: MASTER:%s TARGET:%s\n",
 					master_name, target_name);
@@ -154,20 +159,34 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	return IRQ_HANDLED;
 }
 
+static const struct of_device_id l3_noc_match[] = {
+	{.compatible = "ti,omap4-l3-noc", .data = &omap_l3_data},
+	{},
+};
+MODULE_DEVICE_TABLE(of, l3_noc_match);
+
 static int omap_l3_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *of_id;
 	static struct omap_l3 *l3;
 	int ret, i;
 
+	of_id = of_match_device(l3_noc_match, &pdev->dev);
+	if (!of_id) {
+		dev_err(&pdev->dev, "OF data missing\n");
+		return -EINVAL;
+	}
+
 	l3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);
 	if (!l3)
 		return -ENOMEM;
 
+	memcpy(l3, of_id->data, sizeof(*l3));
 	l3->dev = &pdev->dev;
 	platform_set_drvdata(pdev, l3);
 
 	/* Get mem resources */
-	for (i = 0; i < L3_MODULES; i++) {
+	for (i = 0; i < l3->num_modules; i++) {
 		struct resource	*res = platform_get_resource(pdev,
 							     IORESOURCE_MEM, i);
 
@@ -199,22 +218,12 @@ static int omap_l3_probe(struct platform_device *pdev)
 	return ret;
 }
 
-#if defined(CONFIG_OF)
-static const struct of_device_id l3_noc_match[] = {
-	{.compatible = "ti,omap4-l3-noc", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, l3_noc_match);
-#else
-#define l3_noc_match NULL
-#endif
-
 static struct platform_driver omap_l3_driver = {
 	.probe		= omap_l3_probe,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,
-		.of_match_table = l3_noc_match,
+		.of_match_table = of_match_ptr(l3_noc_match),
 	},
 };
 

commit 3340d739f8e1273abd408c59ad1843ea2ac35566
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Thu Apr 10 11:31:33 2014 -0500

    bus: omap_l3_noc: Add support for discountinous flag mux input numbers
    
    On DRA7, unlike on OMAP4 and OMAP5, the flag mux input numbers used
    to indicate the source of errors are not continous. Have a way in the
    driver to catch these and WARN the user of the flag mux input thats
    either undocumented or wrong.
    
    In the similar vein, Timeout errors in AM43x can't be cleared per h/w
    team, neither does it have a STDERRLOG_MAIN to clear the error.
    
    Further, the mux bit offset might not even be indexed into our array
    of known mux input description, in which case we'd have a abort.
    
    So, define a static range check for bit description and any definition
    which has target_name set to NULL (the ones that are not populated or
    ones that are specifically marked in the case of discontinous input
    numbers), can handle the same gracefully. Upon occurance of error from
    such sources, mask it. Otherwise, we'd have an infinite interrupt
    source without any means to clear it.
    
    NOTE: follow on patch ensures that these masked bits are ignored.
    
    [nm@ti.com: rebase, squash and improve]
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 343f002a06f7..7743e86e88b1 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -75,10 +75,41 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		if (err_reg) {
 			/* Identify the source from control status register */
 			err_src = __ffs(err_reg);
+
+			/* We DONOT expect err_src to go out of bounds */
+			BUG_ON(err_src > MAX_CLKDM_TARGETS);
+
 			l3_targ_inst = &l3_targ[i][err_src];
 			target_name = l3_targ_inst->name;
 			l3_targ_base = base + l3_targ_inst->offset;
 
+			/*
+			 * If we do not know of a register offset to decode
+			 * and clear, then mask.
+			 */
+			if (target_name == L3_TARGET_NOT_SUPPORTED) {
+				u32 mask_val;
+				void __iomem *mask_reg;
+
+				/*
+				 * Certain plaforms may have "undocumented"
+				 * status pending on boot.. So dont generate
+				 * a severe warning here.
+				 */
+				dev_err(l3->dev,
+					"L3 %s error: target %d mod:%d %s\n",
+					inttype ? "debug" : "application",
+					err_src, i, "(unclearable)");
+
+				mask_reg = base + l3_flagmux[i] +
+					   L3_FLAGMUX_MASK0 + (inttype << 3);
+				mask_val = readl_relaxed(mask_reg);
+				mask_val &= ~(1 << err_src);
+				writel_relaxed(mask_val, mask_reg);
+
+				break;
+			}
+
 			/* Read the stderrlog_main_source from clk domain */
 			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
 			l3_targ_slvofslsb = l3_targ_base +

commit 3ae9af7c90f8113365cf2600797115ee35e42d0d
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 11:38:10 2014 -0500

    bus: omap_l3_noc: convert target information into a structure
    
    Currently the target instance information is organized indexed by bit
    field offset into multiple arrays.
    
    1. We currently have offsets specific to each target associated with each
    clock domains are in seperate arrays:
    
    l3_targ_inst_clk1
    l3_targ_inst_clk2
    l3_targ_inst_clk3
    
    2. Then they are organized per master index in l3_targ.
    
    3. We have names in l3_targ_inst_name as an array to array of strings
    corresponding to the above with offsets.
    
    Simplify the same by defining a structure for information containing
    both target offset and name. this is then stored in arrays per domain
    and organized into an array indexed off domain.
    
    The array is still indexed based on bit field offset.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index f7d3bf4f7284..343f002a06f7 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -57,6 +57,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	void __iomem *base, *l3_targ_base;
 	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
 	char *target_name, *master_name = "UN IDENTIFIED";
+	struct l3_target_data *l3_targ_inst;
 
 	/* Get the Type of interrupt */
 	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
@@ -74,9 +75,11 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		if (err_reg) {
 			/* Identify the source from control status register */
 			err_src = __ffs(err_reg);
+			l3_targ_inst = &l3_targ[i][err_src];
+			target_name = l3_targ_inst->name;
+			l3_targ_base = base + l3_targ_inst->offset;
 
 			/* Read the stderrlog_main_source from clk domain */
-			l3_targ_base = base + l3_targ[i][err_src];
 			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
 			l3_targ_slvofslsb = l3_targ_base +
 					    L3_TARG_STDERRLOG_SLVOFSLSB;
@@ -88,8 +91,6 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 			switch (std_err_main & CUSTOM_ERROR) {
 			case STANDARD_ERROR:
-				target_name =
-					l3_targ_inst_name[i][err_src];
 				WARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",
 					target_name,
 					readl_relaxed(l3_targ_slvofslsb));
@@ -99,8 +100,6 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 				break;
 
 			case CUSTOM_ERROR:
-				target_name =
-					l3_targ_inst_name[i][err_src];
 				for (k = 0; k < NUM_OF_L3_MASTERS; k++) {
 					if (masterid == l3_masters[k].id)
 						master_name =

commit add6f74b9baf6676c4465b99967c972c464e59cc
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 11:24:42 2014 -0500

    bus: omap_l3_noc: un-obfuscate l3_targ address computation
    
    just simplify derefencing that is equivalent.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index c8facb00bb53..f7d3bf4f7284 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -76,7 +76,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 			err_src = __ffs(err_reg);
 
 			/* Read the stderrlog_main_source from clk domain */
-			l3_targ_base = base + *(l3_targ[i] + err_src);
+			l3_targ_base = base + l3_targ[i][err_src];
 			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
 			l3_targ_slvofslsb = l3_targ_base +
 					    L3_TARG_STDERRLOG_SLVOFSLSB;

commit 9e224c8ff19e4c4a9c9272171d5a0169d5cb1bef
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 11:21:47 2014 -0500

    bus: omap_l3_noc: switch over to relaxed variants of readl/writel
    
    Currently we use __raw_readl and writel in this driver. Considering
    there is no specific need for a memory barrier, replacing writel
    with endian-neutral writel_relaxed and replacing __raw_readls with
    the corresponding endian-neutral readl_relaxed allows us to have a
    standard set of register operations for the driver.
    
    While at it, simplify address computation using variables for
    register.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 37d71b715053..c8facb00bb53 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -55,6 +55,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	int err_src = 0;
 	u32 std_err_main, err_reg, clear, masterid;
 	void __iomem *base, *l3_targ_base;
+	void __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;
 	char *target_name, *master_name = "UN IDENTIFIED";
 
 	/* Get the Type of interrupt */
@@ -66,8 +67,8 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		 * to determine the source
 		 */
 		base = l3->l3_base[i];
-		err_reg = __raw_readl(base + l3_flagmux[i] +
-					+ L3_FLAGMUX_REGERR0 + (inttype << 3));
+		err_reg = readl_relaxed(base + l3_flagmux[i] +
+					L3_FLAGMUX_REGERR0 + (inttype << 3));
 
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
@@ -76,10 +77,14 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 
 			/* Read the stderrlog_main_source from clk domain */
 			l3_targ_base = base + *(l3_targ[i] + err_src);
-			std_err_main =  __raw_readl(l3_targ_base +
-					L3_TARG_STDERRLOG_MAIN);
-			masterid = __raw_readl(l3_targ_base +
-					L3_TARG_STDERRLOG_MSTADDR);
+			l3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;
+			l3_targ_slvofslsb = l3_targ_base +
+					    L3_TARG_STDERRLOG_SLVOFSLSB;
+			l3_targ_mstaddr = l3_targ_base +
+					  L3_TARG_STDERRLOG_MSTADDR;
+
+			std_err_main = readl_relaxed(l3_targ_stderr);
+			masterid = readl_relaxed(l3_targ_mstaddr);
 
 			switch (std_err_main & CUSTOM_ERROR) {
 			case STANDARD_ERROR:
@@ -87,12 +92,10 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					l3_targ_inst_name[i][err_src];
 				WARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",
 					target_name,
-					__raw_readl(l3_targ_base +
-						L3_TARG_STDERRLOG_SLVOFSLSB));
+					readl_relaxed(l3_targ_slvofslsb));
 				/* clear the std error log*/
 				clear = std_err_main | CLEAR_STDERR_LOG;
-				writel(clear, l3_targ_base +
-					L3_TARG_STDERRLOG_MAIN);
+				writel_relaxed(clear, l3_targ_stderr);
 				break;
 
 			case CUSTOM_ERROR:
@@ -107,8 +110,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 					master_name, target_name);
 				/* clear the std error log*/
 				clear = std_err_main | CLEAR_STDERR_LOG;
-				writel(clear, l3_targ_base +
-					L3_TARG_STDERRLOG_MAIN);
+				writel_relaxed(clear, l3_targ_stderr);
 				break;
 
 			default:

commit ca6a34935c2c95482b901d76116f785ea356412c
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 12:04:01 2014 -0500

    bus: omap_l3_noc: populate l3->dev and use it
    
    l3->dev is not populated, so populate it and use it to print information
    relevant to the device instead of using a generic pr_*.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 800486c88cc3..37d71b715053 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -131,6 +131,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 	if (!l3)
 		return -ENOMEM;
 
+	l3->dev = &pdev->dev;
 	platform_set_drvdata(pdev, l3);
 
 	/* Get mem resources */
@@ -140,7 +141,7 @@ static int omap_l3_probe(struct platform_device *pdev)
 
 		l3->l3_base[i] = devm_ioremap_resource(&pdev->dev, res);
 		if (IS_ERR(l3->l3_base[i])) {
-			dev_err(&pdev->dev, "ioremap %d failed\n", i);
+			dev_err(l3->dev, "ioremap %d failed\n", i);
 			return PTR_ERR(l3->l3_base[i]);
 		}
 	}
@@ -149,19 +150,19 @@ static int omap_l3_probe(struct platform_device *pdev)
 	 * Setup interrupt Handlers
 	 */
 	l3->debug_irq = platform_get_irq(pdev, 0);
-	ret = devm_request_irq(&pdev->dev, l3->debug_irq, l3_interrupt_handler,
+	ret = devm_request_irq(l3->dev, l3->debug_irq, l3_interrupt_handler,
 			       IRQF_DISABLED, "l3-dbg-irq", l3);
 	if (ret) {
-		dev_err(&pdev->dev, "request_irq failed for %d\n",
+		dev_err(l3->dev, "request_irq failed for %d\n",
 			l3->debug_irq);
 		return ret;
 	}
 
 	l3->app_irq = platform_get_irq(pdev, 1);
-	ret = devm_request_irq(&pdev->dev, l3->app_irq, l3_interrupt_handler,
+	ret = devm_request_irq(l3->dev, l3->app_irq, l3_interrupt_handler,
 			       IRQF_DISABLED, "l3-app-irq", l3);
 	if (ret)
-		dev_err(&pdev->dev, "request_irq failed for %d\n", l3->app_irq);
+		dev_err(l3->dev, "request_irq failed for %d\n", l3->app_irq);
 
 	return ret;
 }

commit c10d5c9e1200e2b8c23329173f279caa86c6af45
Author: Sricharan R <r.sricharan@ti.com>
Date:   Fri Apr 11 13:09:36 2014 -0500

    bus: omap_l3_noc: rename functions and data to omap_l3
    
    Since omap_l3_noc driver is now being used for OMAP5 and reusable with
    DRA7 and AM437x, using omap4 specific naming is misleading.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 1eb6d85c19dc..800486c88cc3 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -1,5 +1,5 @@
 /*
- * OMAP4XXX L3 Interconnect error handling driver
+ * OMAP L3 Interconnect error handling driver
  *
  * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
@@ -50,7 +50,7 @@
 static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 {
 
-	struct omap4_l3 *l3 = _l3;
+	struct omap_l3 *l3 = _l3;
 	int inttype, i, k;
 	int err_src = 0;
 	u32 std_err_main, err_reg, clear, masterid;
@@ -122,9 +122,9 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	return IRQ_HANDLED;
 }
 
-static int omap4_l3_probe(struct platform_device *pdev)
+static int omap_l3_probe(struct platform_device *pdev)
 {
-	static struct omap4_l3 *l3;
+	static struct omap_l3 *l3;
 	int ret, i;
 
 	l3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);
@@ -176,8 +176,8 @@ MODULE_DEVICE_TABLE(of, l3_noc_match);
 #define l3_noc_match NULL
 #endif
 
-static struct platform_driver omap4_l3_driver = {
-	.probe		= omap4_l3_probe,
+static struct platform_driver omap_l3_driver = {
+	.probe		= omap_l3_probe,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,
@@ -185,14 +185,14 @@ static struct platform_driver omap4_l3_driver = {
 	},
 };
 
-static int __init omap4_l3_init(void)
+static int __init omap_l3_init(void)
 {
-	return platform_driver_register(&omap4_l3_driver);
+	return platform_driver_register(&omap_l3_driver);
 }
-postcore_initcall_sync(omap4_l3_init);
+postcore_initcall_sync(omap_l3_init);
 
-static void __exit omap4_l3_exit(void)
+static void __exit omap_l3_exit(void)
 {
-	platform_driver_unregister(&omap4_l3_driver);
+	platform_driver_unregister(&omap_l3_driver);
 }
-module_exit(omap4_l3_exit);
+module_exit(omap_l3_exit);

commit c5f2aea0ef47b2934b46374abfac9015de79aecb
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 13:15:43 2014 -0500

    bus: omap_l3_noc: Fix copyright information
    
    This is an embarrassing patch :(.
    
    Texas Corporation does not make OMAP. Texas Instruments Inc does.
    
    For that matter I dont seem to be able to find a Texas Corporation on
    the internet either.
    
    While at it, update coverage to the current year and update the template
    to remove redundant information and use the standard boiler plate
    licensing.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 972691a668a3..1eb6d85c19dc 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -1,24 +1,18 @@
 /*
  * OMAP4XXX L3 Interconnect error handling driver
  *
- * Copyright (C) 2011 Texas Corporation
+ * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
  *	Sricharan <r.sricharan@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
  */
 #include <linux/module.h>
 #include <linux/init.h>

commit ae22598a1199c1257b2de5643695221434ace1c3
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Apr 1 16:23:50 2014 +0300

    drivers: bus: omap_l3: Change pr_crit() to dev_err() when IRQ request fails
    
    Use dev_err() which will going to print the driver's name as well and the
    KERN_ERR level is sufficient in this case (we also print via dev_err when
    there is an error with the mem resources)
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 0eff48585ae3..972691a668a3 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -158,8 +158,8 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	ret = devm_request_irq(&pdev->dev, l3->debug_irq, l3_interrupt_handler,
 			       IRQF_DISABLED, "l3-dbg-irq", l3);
 	if (ret) {
-		pr_crit("L3: request_irq failed to register for 0x%x\n",
-						l3->debug_irq);
+		dev_err(&pdev->dev, "request_irq failed for %d\n",
+			l3->debug_irq);
 		return ret;
 	}
 
@@ -167,8 +167,7 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	ret = devm_request_irq(&pdev->dev, l3->app_irq, l3_interrupt_handler,
 			       IRQF_DISABLED, "l3-app-irq", l3);
 	if (ret)
-		pr_crit("L3: request_irq failed to register for 0x%x\n",
-						l3->app_irq);
+		dev_err(&pdev->dev, "request_irq failed for %d\n", l3->app_irq);
 
 	return ret;
 }

commit 442a4da7cad64cf7270cbbbed9ad69dc4a1bc263
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Apr 1 16:23:49 2014 +0300

    drivers: bus: omap_l3: Remove the platform driver's remove function
    
    It is NOP after the devm_* conversion.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 25bcb60be880..0eff48585ae3 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -173,11 +173,6 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int omap4_l3_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
 #if defined(CONFIG_OF)
 static const struct of_device_id l3_noc_match[] = {
 	{.compatible = "ti,omap4-l3-noc", },
@@ -190,7 +185,6 @@ MODULE_DEVICE_TABLE(of, l3_noc_match);
 
 static struct platform_driver omap4_l3_driver = {
 	.probe		= omap4_l3_probe,
-	.remove		= omap4_l3_remove,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,

commit a0ef78f353d6edc9f88d3247601f1dc5ad8f4b84
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Apr 1 16:23:48 2014 +0300

    drivers: bus: omap_l3: Convert to use devm_request_irq()
    
    With this we can remove the free_irq() calls from probe and remove.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 6f58be3c2f76..25bcb60be880 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -155,9 +155,8 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	 * Setup interrupt Handlers
 	 */
 	l3->debug_irq = platform_get_irq(pdev, 0);
-	ret = request_irq(l3->debug_irq,
-			l3_interrupt_handler,
-			IRQF_DISABLED, "l3-dbg-irq", l3);
+	ret = devm_request_irq(&pdev->dev, l3->debug_irq, l3_interrupt_handler,
+			       IRQF_DISABLED, "l3-dbg-irq", l3);
 	if (ret) {
 		pr_crit("L3: request_irq failed to register for 0x%x\n",
 						l3->debug_irq);
@@ -165,29 +164,17 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	}
 
 	l3->app_irq = platform_get_irq(pdev, 1);
-	ret = request_irq(l3->app_irq,
-			l3_interrupt_handler,
-			IRQF_DISABLED, "l3-app-irq", l3);
-	if (ret) {
+	ret = devm_request_irq(&pdev->dev, l3->app_irq, l3_interrupt_handler,
+			       IRQF_DISABLED, "l3-app-irq", l3);
+	if (ret)
 		pr_crit("L3: request_irq failed to register for 0x%x\n",
 						l3->app_irq);
-		goto err4;
-	}
-
-	return 0;
 
-err4:
-	free_irq(l3->debug_irq, l3);
 	return ret;
 }
 
 static int omap4_l3_remove(struct platform_device *pdev)
 {
-	struct omap4_l3 *l3 = platform_get_drvdata(pdev);
-
-	free_irq(l3->app_irq, l3);
-	free_irq(l3->debug_irq, l3);
-
 	return 0;
 }
 

commit 56c4a0224add82ced3af81c3a898a228a0560720
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Apr 1 16:23:47 2014 +0300

    drivers: bus: omap_l3: Convert to use devm_ioremap_resource()
    
    We can then remove the iounmap() calls from probe and remove.
    Since the driver requests the resources via index we can do the mem resource
    request within a for loop.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index d25d727e7cfb..6f58be3c2f76 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -131,52 +131,24 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 static int omap4_l3_probe(struct platform_device *pdev)
 {
 	static struct omap4_l3 *l3;
-	struct resource	*res;
-	int ret;
+	int ret, i;
 
 	l3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);
 	if (!l3)
 		return -ENOMEM;
 
 	platform_set_drvdata(pdev, l3);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "couldn't find resource 0\n");
-		return -ENODEV;
-	}
-
-	l3->l3_base[0] = ioremap(res->start, resource_size(res));
-	if (!l3->l3_base[0]) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		return -ENOMEM;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (!res) {
-		dev_err(&pdev->dev, "couldn't find resource 1\n");
-		ret = -ENODEV;
-		goto err1;
-	}
 
-	l3->l3_base[1] = ioremap(res->start, resource_size(res));
-	if (!l3->l3_base[1]) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto err1;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
-	if (!res) {
-		dev_err(&pdev->dev, "couldn't find resource 2\n");
-		ret = -ENODEV;
-		goto err2;
-	}
+	/* Get mem resources */
+	for (i = 0; i < L3_MODULES; i++) {
+		struct resource	*res = platform_get_resource(pdev,
+							     IORESOURCE_MEM, i);
 
-	l3->l3_base[2] = ioremap(res->start, resource_size(res));
-	if (!l3->l3_base[2]) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto err2;
+		l3->l3_base[i] = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(l3->l3_base[i])) {
+			dev_err(&pdev->dev, "ioremap %d failed\n", i);
+			return PTR_ERR(l3->l3_base[i]);
+		}
 	}
 
 	/*
@@ -189,7 +161,7 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	if (ret) {
 		pr_crit("L3: request_irq failed to register for 0x%x\n",
 						l3->debug_irq);
-		goto err3;
+		return ret;
 	}
 
 	l3->app_irq = platform_get_irq(pdev, 1);
@@ -206,12 +178,6 @@ static int omap4_l3_probe(struct platform_device *pdev)
 
 err4:
 	free_irq(l3->debug_irq, l3);
-err3:
-	iounmap(l3->l3_base[2]);
-err2:
-	iounmap(l3->l3_base[1]);
-err1:
-	iounmap(l3->l3_base[0]);
 	return ret;
 }
 
@@ -221,9 +187,6 @@ static int omap4_l3_remove(struct platform_device *pdev)
 
 	free_irq(l3->app_irq, l3);
 	free_irq(l3->debug_irq, l3);
-	iounmap(l3->l3_base[0]);
-	iounmap(l3->l3_base[1]);
-	iounmap(l3->l3_base[2]);
 
 	return 0;
 }

commit bae74510179bc6d2c71168eeef33b7b157e244d0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Apr 1 16:23:46 2014 +0300

    drivers: bus: omap_l3: Convert to use devm_kzalloc
    
    We can remove the kfree() calls from probe and remove.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index feeecae623f6..d25d727e7cfb 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -134,7 +134,7 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	struct resource	*res;
 	int ret;
 
-	l3 = kzalloc(sizeof(*l3), GFP_KERNEL);
+	l3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);
 	if (!l3)
 		return -ENOMEM;
 
@@ -142,15 +142,13 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "couldn't find resource 0\n");
-		ret = -ENODEV;
-		goto err0;
+		return -ENODEV;
 	}
 
 	l3->l3_base[0] = ioremap(res->start, resource_size(res));
 	if (!l3->l3_base[0]) {
 		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto err0;
+		return -ENOMEM;
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
@@ -214,8 +212,6 @@ static int omap4_l3_probe(struct platform_device *pdev)
 	iounmap(l3->l3_base[1]);
 err1:
 	iounmap(l3->l3_base[0]);
-err0:
-	kfree(l3);
 	return ret;
 }
 
@@ -228,7 +224,6 @@ static int omap4_l3_remove(struct platform_device *pdev)
 	iounmap(l3->l3_base[0]);
 	iounmap(l3->l3_base[1]);
 	iounmap(l3->l3_base[2]);
-	kfree(l3);
 
 	return 0;
 }

commit 0fe763c570ad2701c830b9e4e53c65ad89c11c32
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:14:44 2012 -0800

    Drivers: misc: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index ab911a33f8a8..feeecae623f6 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -128,7 +128,7 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 	return IRQ_HANDLED;
 }
 
-static int __devinit omap4_l3_probe(struct platform_device *pdev)
+static int omap4_l3_probe(struct platform_device *pdev)
 {
 	static struct omap4_l3 *l3;
 	struct resource	*res;
@@ -219,7 +219,7 @@ static int __devinit omap4_l3_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit omap4_l3_remove(struct platform_device *pdev)
+static int omap4_l3_remove(struct platform_device *pdev)
 {
 	struct omap4_l3 *l3 = platform_get_drvdata(pdev);
 
@@ -245,7 +245,7 @@ MODULE_DEVICE_TABLE(of, l3_noc_match);
 
 static struct platform_driver omap4_l3_driver = {
 	.probe		= omap4_l3_probe,
-	.remove		= __devexit_p(omap4_l3_remove),
+	.remove		= omap4_l3_remove,
 	.driver		= {
 		.name		= "omap_l3_noc",
 		.owner		= THIS_MODULE,

commit 974a847e00cf3ff1695e62b276892137893706ab
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 16:14:25 2012 -0700

    drivers: bus: omap_l3: fixup merge conflict resolution
    
    This fixes a local merge conflict resolution done wrong locally in
    arm-soc for-next. soc.h was added on a cleanup branch, but the driver
    was moved and the header no longer needed.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    [ .. and I did the same wrong merge, since git automatically does the
      whole rename detection etc, so applying this patch from Olof  - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 44b2b3e57882..ab911a33f8a8 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -28,7 +28,6 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 
-#include "soc.h"
 #include "omap_l3_noc.h"
 
 /*

commit 8f446a7a069e0af0639385f67c78ee2279bca04c
Merge: 84be4ae2c038 04ef037c926d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 18:46:13 2012 -0700

    Merge tag 'drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM soc driver specific changes from Olof Johansson:
     - A long-coming conversion of various platforms to a common LED
       infrastructure
     - AT91 is moved over to use the newer MCI driver for MMC
     - Pincontrol conversions for samsung platforms
     - DT bindings for gscaler on samsung
     - i2c driver fixes for tegra, acked by i2c maintainer
    
    Fix up conflicts as per Olof.
    
    * tag 'drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (48 commits)
      drivers: bus: omap_l3: use resources instead of hardcoded irqs
      pinctrl: exynos: Fix wakeup IRQ domain registration check
      pinctrl: samsung: Uninline samsung_pinctrl_get_soc_data
      pinctrl: exynos: Correct the detection of wakeup-eint node
      pinctrl: exynos: Mark exynos_irq_demux_eint as inline
      pinctrl: exynos: Handle only unmasked wakeup interrupts
      pinctrl: exynos: Fix typos in gpio/wkup _irq_mask
      pinctrl: exynos: Set pin function to EINT in irq_set_type of GPIO EINTa
      drivers: bus: Move the OMAP interconnect driver to drivers/bus/
      i2c: tegra: dynamically control fast clk
      i2c: tegra: I2_M_NOSTART functionality not supported in Tegra20
      ARM: tegra: clock: remove unused clock entry for i2c
      ARM: tegra: clock: add connection name in i2c clock entry
      i2c: tegra: pass proper name for getting clock
      ARM: tegra: clock: add i2c fast clock entry in clock table
      ARM: EXYNOS: Adds G-Scaler device from Device Tree
      ARM: EXYNOS: Add clock support for G-Scaler
      ARM: EXYNOS: Enable pinctrl driver support for EXYNOS4 device tree enabled platform
      ARM: dts: Add pinctrl node entries for SAMSUNG EXYNOS4210 SoC
      ARM: EXYNOS: skip wakeup interrupt setup if pinctrl driver is used
      ...

commit 2c2d16745a3a0924e2335722f5a1676a0c501b1f
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 16:10:02 2012 -0700

    drivers: bus: omap_l3: use resources instead of hardcoded irqs
    
    This fixes up a merge conflict due to the move of the driver and cleanups of
    platform data around the same time. Moving to the resource is what we want
    anyway, so do it in this branch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [olof: rewrote with this branch as base, same end result]
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index d15225ff5c49..ab911a33f8a8 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -190,7 +190,7 @@ static int __devinit omap4_l3_probe(struct platform_device *pdev)
 			IRQF_DISABLED, "l3-dbg-irq", l3);
 	if (ret) {
 		pr_crit("L3: request_irq failed to register for 0x%x\n",
-						OMAP44XX_IRQ_L3_DBG);
+						l3->debug_irq);
 		goto err3;
 	}
 
@@ -200,7 +200,7 @@ static int __devinit omap4_l3_probe(struct platform_device *pdev)
 			IRQF_DISABLED, "l3-app-irq", l3);
 	if (ret) {
 		pr_crit("L3: request_irq failed to register for 0x%x\n",
-						OMAP44XX_IRQ_L3_APP);
+						l3->app_irq);
 		goto err4;
 	}
 

commit 0ee7261c9212dbaf72d510e37f6c5b849d1847f0
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Sep 14 14:50:34 2012 +0530

    drivers: bus: Move the OMAP interconnect driver to drivers/bus/
    
    OMAP interconnect drivers are used for the interconnect error handling.
    Since they are bus driver, lets move it to newly created drivers/bus.
    
    Tested-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
new file mode 100644
index 000000000000..d15225ff5c49
--- /dev/null
+++ b/drivers/bus/omap_l3_noc.c
@@ -0,0 +1,266 @@
+/*
+ * OMAP4XXX L3 Interconnect error handling driver
+ *
+ * Copyright (C) 2011 Texas Corporation
+ *	Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *	Sricharan <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "omap_l3_noc.h"
+
+/*
+ * Interrupt Handler for L3 error detection.
+ *	1) Identify the L3 clockdomain partition to which the error belongs to.
+ *	2) Identify the slave where the error information is logged
+ *	3) Print the logged information.
+ *	4) Add dump stack to provide kernel trace.
+ *
+ * Two Types of errors :
+ *	1) Custom errors in L3 :
+ *		Target like DMM/FW/EMIF generates SRESP=ERR error
+ *	2) Standard L3 error:
+ *		- Unsupported CMD.
+ *			L3 tries to access target while it is idle
+ *		- OCP disconnect.
+ *		- Address hole error:
+ *			If DSS/ISS/FDIF/USBHOSTFS access a target where they
+ *			do not have connectivity, the error is logged in
+ *			their default target which is DMM2.
+ *
+ *	On High Secure devices, firewall errors are possible and those
+ *	can be trapped as well. But the trapping is implemented as part
+ *	secure software and hence need not be implemented here.
+ */
+static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
+{
+
+	struct omap4_l3 *l3 = _l3;
+	int inttype, i, k;
+	int err_src = 0;
+	u32 std_err_main, err_reg, clear, masterid;
+	void __iomem *base, *l3_targ_base;
+	char *target_name, *master_name = "UN IDENTIFIED";
+
+	/* Get the Type of interrupt */
+	inttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;
+
+	for (i = 0; i < L3_MODULES; i++) {
+		/*
+		 * Read the regerr register of the clock domain
+		 * to determine the source
+		 */
+		base = l3->l3_base[i];
+		err_reg = __raw_readl(base + l3_flagmux[i] +
+					+ L3_FLAGMUX_REGERR0 + (inttype << 3));
+
+		/* Get the corresponding error and analyse */
+		if (err_reg) {
+			/* Identify the source from control status register */
+			err_src = __ffs(err_reg);
+
+			/* Read the stderrlog_main_source from clk domain */
+			l3_targ_base = base + *(l3_targ[i] + err_src);
+			std_err_main =  __raw_readl(l3_targ_base +
+					L3_TARG_STDERRLOG_MAIN);
+			masterid = __raw_readl(l3_targ_base +
+					L3_TARG_STDERRLOG_MSTADDR);
+
+			switch (std_err_main & CUSTOM_ERROR) {
+			case STANDARD_ERROR:
+				target_name =
+					l3_targ_inst_name[i][err_src];
+				WARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",
+					target_name,
+					__raw_readl(l3_targ_base +
+						L3_TARG_STDERRLOG_SLVOFSLSB));
+				/* clear the std error log*/
+				clear = std_err_main | CLEAR_STDERR_LOG;
+				writel(clear, l3_targ_base +
+					L3_TARG_STDERRLOG_MAIN);
+				break;
+
+			case CUSTOM_ERROR:
+				target_name =
+					l3_targ_inst_name[i][err_src];
+				for (k = 0; k < NUM_OF_L3_MASTERS; k++) {
+					if (masterid == l3_masters[k].id)
+						master_name =
+							l3_masters[k].name;
+				}
+				WARN(true, "L3 custom error: MASTER:%s TARGET:%s\n",
+					master_name, target_name);
+				/* clear the std error log*/
+				clear = std_err_main | CLEAR_STDERR_LOG;
+				writel(clear, l3_targ_base +
+					L3_TARG_STDERRLOG_MAIN);
+				break;
+
+			default:
+				/* Nothing to be handled here as of now */
+				break;
+			}
+		/* Error found so break the for loop */
+		break;
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int __devinit omap4_l3_probe(struct platform_device *pdev)
+{
+	static struct omap4_l3 *l3;
+	struct resource	*res;
+	int ret;
+
+	l3 = kzalloc(sizeof(*l3), GFP_KERNEL);
+	if (!l3)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, l3);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "couldn't find resource 0\n");
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	l3->l3_base[0] = ioremap(res->start, resource_size(res));
+	if (!l3->l3_base[0]) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "couldn't find resource 1\n");
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	l3->l3_base[1] = ioremap(res->start, resource_size(res));
+	if (!l3->l3_base[1]) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!res) {
+		dev_err(&pdev->dev, "couldn't find resource 2\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	l3->l3_base[2] = ioremap(res->start, resource_size(res));
+	if (!l3->l3_base[2]) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	/*
+	 * Setup interrupt Handlers
+	 */
+	l3->debug_irq = platform_get_irq(pdev, 0);
+	ret = request_irq(l3->debug_irq,
+			l3_interrupt_handler,
+			IRQF_DISABLED, "l3-dbg-irq", l3);
+	if (ret) {
+		pr_crit("L3: request_irq failed to register for 0x%x\n",
+						OMAP44XX_IRQ_L3_DBG);
+		goto err3;
+	}
+
+	l3->app_irq = platform_get_irq(pdev, 1);
+	ret = request_irq(l3->app_irq,
+			l3_interrupt_handler,
+			IRQF_DISABLED, "l3-app-irq", l3);
+	if (ret) {
+		pr_crit("L3: request_irq failed to register for 0x%x\n",
+						OMAP44XX_IRQ_L3_APP);
+		goto err4;
+	}
+
+	return 0;
+
+err4:
+	free_irq(l3->debug_irq, l3);
+err3:
+	iounmap(l3->l3_base[2]);
+err2:
+	iounmap(l3->l3_base[1]);
+err1:
+	iounmap(l3->l3_base[0]);
+err0:
+	kfree(l3);
+	return ret;
+}
+
+static int __devexit omap4_l3_remove(struct platform_device *pdev)
+{
+	struct omap4_l3 *l3 = platform_get_drvdata(pdev);
+
+	free_irq(l3->app_irq, l3);
+	free_irq(l3->debug_irq, l3);
+	iounmap(l3->l3_base[0]);
+	iounmap(l3->l3_base[1]);
+	iounmap(l3->l3_base[2]);
+	kfree(l3);
+
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id l3_noc_match[] = {
+	{.compatible = "ti,omap4-l3-noc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, l3_noc_match);
+#else
+#define l3_noc_match NULL
+#endif
+
+static struct platform_driver omap4_l3_driver = {
+	.probe		= omap4_l3_probe,
+	.remove		= __devexit_p(omap4_l3_remove),
+	.driver		= {
+		.name		= "omap_l3_noc",
+		.owner		= THIS_MODULE,
+		.of_match_table = l3_noc_match,
+	},
+};
+
+static int __init omap4_l3_init(void)
+{
+	return platform_driver_register(&omap4_l3_driver);
+}
+postcore_initcall_sync(omap4_l3_init);
+
+static void __exit omap4_l3_exit(void)
+{
+	platform_driver_unregister(&omap4_l3_driver);
+}
+module_exit(omap4_l3_exit);
