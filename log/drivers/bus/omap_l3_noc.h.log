commit e7309c2673a389a495fcfad70376d3bae8b9bc89
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Apr 24 12:54:20 2015 -0500

    bus: omap_l3_noc: Fix master id address decoding for OMAP5
    
    The L3 Error handling on OMAP5 for the most part is very similar
    to that of OMAP4, and had leveraged common data structures and
    register layout definitions so far. Upon closer inspection, there
    are a few minor differences causing an incorrect decoding and
    reporting of the master NIU upon an error:
    
      1. The L3_TARG_STDERRLOG_MSTADDR.STDERRLOG_MSTADDR occupies
         11 bits on OMAP5 as against 8 bits on OMAP4, with the master
         NIU connID encoded in the 6 MSBs of the STDERRLOG_MSTADDR
         field.
      2. The CLK3 FlagMux component has 1 input source on OMAP4 and 3
         input sources on OMAP5. The common DEBUGSS source is at a
         different input on each SoC.
    
    Fix the above issues by using a OMAP5-specific compatible property
    and using SoC-specific data where there are differences.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index a314d800f394..73431f81da28 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -1,7 +1,7 @@
 /*
  * OMAP L3 Interconnect  error handling driver header
  *
- * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2011-2015 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
  *	sricharan <r.sricharan@ti.com>
  *
@@ -175,16 +175,14 @@ static struct l3_flagmux_data omap_l3_flagmux_clk2 = {
 };
 
 
-static struct l3_target_data omap_l3_target_data_clk3[] = {
-	{0x0100, "EMUSS",},
-	{0x0300, "DEBUG SOURCE",},
-	{0x0,	"HOST CLK3",},
+static struct l3_target_data omap4_l3_target_data_clk3[] = {
+	{0x0100, "DEBUGSS",},
 };
 
-static struct l3_flagmux_data omap_l3_flagmux_clk3 = {
+static struct l3_flagmux_data omap4_l3_flagmux_clk3 = {
 	.offset = 0x0200,
-	.l3_targ = omap_l3_target_data_clk3,
-	.num_targ_data = ARRAY_SIZE(omap_l3_target_data_clk3),
+	.l3_targ = omap4_l3_target_data_clk3,
+	.num_targ_data = ARRAY_SIZE(omap4_l3_target_data_clk3),
 };
 
 static struct l3_masters_data omap_l3_masters[] = {
@@ -215,21 +213,49 @@ static struct l3_masters_data omap_l3_masters[] = {
 	{ 0x32, "USBHOSTFS"}
 };
 
-static struct l3_flagmux_data *omap_l3_flagmux[] = {
+static struct l3_flagmux_data *omap4_l3_flagmux[] = {
 	&omap_l3_flagmux_clk1,
 	&omap_l3_flagmux_clk2,
-	&omap_l3_flagmux_clk3,
+	&omap4_l3_flagmux_clk3,
 };
 
-static const struct omap_l3 omap_l3_data = {
-	.l3_flagmux = omap_l3_flagmux,
-	.num_modules = ARRAY_SIZE(omap_l3_flagmux),
+static const struct omap_l3 omap4_l3_data = {
+	.l3_flagmux = omap4_l3_flagmux,
+	.num_modules = ARRAY_SIZE(omap4_l3_flagmux),
 	.l3_masters = omap_l3_masters,
 	.num_masters = ARRAY_SIZE(omap_l3_masters),
 	/* The 6 MSBs of register field used to distinguish initiator */
 	.mst_addr_mask = 0xFC,
 };
 
+/* OMAP5 data */
+static struct l3_target_data omap5_l3_target_data_clk3[] = {
+	{0x0100, "L3INSTR",},
+	{0x0300, "DEBUGSS",},
+	{0x0,	 "HOSTCLK3",},
+};
+
+static struct l3_flagmux_data omap5_l3_flagmux_clk3 = {
+	.offset = 0x0200,
+	.l3_targ = omap5_l3_target_data_clk3,
+	.num_targ_data = ARRAY_SIZE(omap5_l3_target_data_clk3),
+};
+
+static struct l3_flagmux_data *omap5_l3_flagmux[] = {
+	&omap_l3_flagmux_clk1,
+	&omap_l3_flagmux_clk2,
+	&omap5_l3_flagmux_clk3,
+};
+
+static const struct omap_l3 omap5_l3_data = {
+	.l3_flagmux = omap5_l3_flagmux,
+	.num_modules = ARRAY_SIZE(omap5_l3_flagmux),
+	.l3_masters = omap_l3_masters,
+	.num_masters = ARRAY_SIZE(omap_l3_masters),
+	/* The 6 MSBs of register field used to distinguish initiator */
+	.mst_addr_mask = 0x7E0,
+};
+
 /* DRA7 data */
 static struct l3_target_data dra_l3_target_data_clk1[] = {
 	{0x2a00, "AES1",},

commit 4adf82c35572c69e96997641612fc88463b08f6f
Author: Illia Smyrnov <illia.smyrnov@globallogic.com>
Date:   Thu Apr 16 17:42:30 2015 -0500

    bus: omap_l3_noc: Fix offset for DRA7 CLK1_HOST_CLK1_2 instance
    
    The base address for DRA7 CLK1_HOST_CLK1_2 host instance is
    0x44800000, so correct offset is 0x800000. DRA7 TRM rev X(fewb 2015)
    has updates for this information.
    
    With wrong offset these errors are not correctly cleared by the L3
    IRQ handler and cause an continuous interrupt scenario and system lockup.
    
    Signed-off-by: Illia Smyrnov <illia.smyrnov@globallogic.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 95254585db86..a314d800f394 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -274,7 +274,7 @@ static struct l3_flagmux_data dra_l3_flagmux_clk1 = {
 
 static struct l3_target_data dra_l3_target_data_clk2[] = {
 	{0x0,	"HOST CLK1",},
-	{0x0,	"HOST CLK2",},
+	{0x800000, "HOST CLK2",},
 	{0xdead, L3_TARGET_NOT_SUPPORTED,},
 	{0x3400, "SHA2_2",},
 	{0x0900, "BB2D",},

commit 41fc619dd5584d438d1eb673bd82a722d627ad85
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Sep 10 05:20:27 2014 -0500

    bus: omap_l3_noc: Fix connID for OMAP4
    
    Commit d4d8819e205854c ("bus: omap_l3_noc: fix masterid detection")
    did the right thing in dropping the LSB 2 bits which is not part
    of the ConnID for NTTP master address. However, as part of that
    change, we should also have ensured that existing list of OMAP4 connID
    codes are also shifted by 2 bits to ensure that connIDs map to "Table
    13-18. ConnID Values" as provided in Technical Reference Manuals for
    OMAP4430(Rev AP, April 2014, SWPU220AP) and OMAP4460(Rev AB, April
    2014, SWPU234AB)
    
    Fixes: d4d8819e205854c ("bus: omap_l3_noc: fix masterid detection")
    Reported-by: Kristian Otnes <kotnes@cisco.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 551e01061434..95254585db86 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -188,31 +188,31 @@ static struct l3_flagmux_data omap_l3_flagmux_clk3 = {
 };
 
 static struct l3_masters_data omap_l3_masters[] = {
-	{ 0x0 , "MPU"},
-	{ 0x10, "CS_ADP"},
-	{ 0x14, "xxx"},
-	{ 0x20, "DSP"},
-	{ 0x30, "IVAHD"},
-	{ 0x40, "ISS"},
-	{ 0x44, "DucatiM3"},
-	{ 0x48, "FaceDetect"},
-	{ 0x50, "SDMA_Rd"},
-	{ 0x54, "SDMA_Wr"},
-	{ 0x58, "xxx"},
-	{ 0x5C, "xxx"},
-	{ 0x60, "SGX"},
-	{ 0x70, "DSS"},
-	{ 0x80, "C2C"},
-	{ 0x88, "xxx"},
-	{ 0x8C, "xxx"},
-	{ 0x90, "HSI"},
-	{ 0xA0, "MMC1"},
-	{ 0xA4, "MMC2"},
-	{ 0xA8, "MMC6"},
-	{ 0xB0, "UNIPRO1"},
-	{ 0xC0, "USBHOSTHS"},
-	{ 0xC4, "USBOTGHS"},
-	{ 0xC8, "USBHOSTFS"}
+	{ 0x00, "MPU"},
+	{ 0x04, "CS_ADP"},
+	{ 0x05, "xxx"},
+	{ 0x08, "DSP"},
+	{ 0x0C, "IVAHD"},
+	{ 0x10, "ISS"},
+	{ 0x11, "DucatiM3"},
+	{ 0x12, "FaceDetect"},
+	{ 0x14, "SDMA_Rd"},
+	{ 0x15, "SDMA_Wr"},
+	{ 0x16, "xxx"},
+	{ 0x17, "xxx"},
+	{ 0x18, "SGX"},
+	{ 0x1C, "DSS"},
+	{ 0x20, "C2C"},
+	{ 0x22, "xxx"},
+	{ 0x23, "xxx"},
+	{ 0x24, "HSI"},
+	{ 0x28, "MMC1"},
+	{ 0x29, "MMC2"},
+	{ 0x2A, "MMC6"},
+	{ 0x2C, "UNIPRO1"},
+	{ 0x30, "USBHOSTHS"},
+	{ 0x31, "USBOTGHS"},
+	{ 0x32, "USBHOSTFS"}
 };
 
 static struct l3_flagmux_data *omap_l3_flagmux[] = {

commit 27b7d5f3cc49f2e5cd6c005d73696058b7140c5c
Author: Afzal Mohammed <afzal@ti.com>
Date:   Mon Dec 2 17:48:57 2013 +0530

    bus: omap_l3_noc: Add AM4372 interconnect error data
    
    Add AM4372 information to handle L3 error.
    
    AM4372 has two clk domains 100f and 200s. Provide flagmux and data
    associated with it.
    
    NOTE: Timeout doesn't have STDERRLOG_MAIN register. And per hardware
    team, L3 timeout error cannot be cleared the normal way (by setting
    bit 31 in STDERRLOG_MAIN), instead it may be required to do system
    reset. L3 error handler can't help in such scenarios.
    
    Hence indicate timeout target offset as L3_TARGET_NOT_SUPPORTED as
    done for undocumented bits.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 9562a75259c8..551e01061434 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -381,4 +381,95 @@ static const struct omap_l3 dra_l3_data = {
 	.mst_addr_mask = 0xFC,
 };
 
+/* AM4372 data */
+static struct l3_target_data am4372_l3_target_data_200f[] = {
+	{0xf00,  "EMIF",},
+	{0x1200, "DES",},
+	{0x400,  "OCMCRAM",},
+	{0x700,  "TPTC0",},
+	{0x800,  "TPTC1",},
+	{0x900,  "TPTC2"},
+	{0xb00,  "TPCC",},
+	{0xd00,  "DEBUGSS",},
+	{0xdead, L3_TARGET_NOT_SUPPORTED,},
+	{0x200,  "SHA",},
+	{0xc00,  "SGX530",},
+	{0x500,  "AES0",},
+	{0xa00,  "L4_FAST",},
+	{0x300,  "MPUSS_L2_RAM",},
+	{0x100,  "ICSS",},
+};
+
+static struct l3_flagmux_data am4372_l3_flagmux_200f = {
+	.offset = 0x1000,
+	.l3_targ = am4372_l3_target_data_200f,
+	.num_targ_data = ARRAY_SIZE(am4372_l3_target_data_200f),
+};
+
+static struct l3_target_data am4372_l3_target_data_100s[] = {
+	{0x100, "L4_PER_0",},
+	{0x200, "L4_PER_1",},
+	{0x300, "L4_PER_2",},
+	{0x400, "L4_PER_3",},
+	{0x800, "McASP0",},
+	{0x900, "McASP1",},
+	{0xC00, "MMCHS2",},
+	{0x700, "GPMC",},
+	{0xD00, "L4_FW",},
+	{0xdead, L3_TARGET_NOT_SUPPORTED,},
+	{0x500, "ADCTSC",},
+	{0xE00, "L4_WKUP",},
+	{0xA00, "MAG_CARD",},
+};
+
+static struct l3_flagmux_data am4372_l3_flagmux_100s = {
+	.offset = 0x600,
+	.l3_targ = am4372_l3_target_data_100s,
+	.num_targ_data = ARRAY_SIZE(am4372_l3_target_data_100s),
+};
+
+static struct l3_masters_data am4372_l3_masters[] = {
+	{ 0x0, "M1 (128-bit)"},
+	{ 0x1, "M2 (64-bit)"},
+	{ 0x4, "DAP"},
+	{ 0x5, "P1500"},
+	{ 0xC, "ICSS0"},
+	{ 0xD, "ICSS1"},
+	{ 0x14, "Wakeup Processor"},
+	{ 0x18, "TPTC0 Read"},
+	{ 0x19, "TPTC0 Write"},
+	{ 0x1A, "TPTC1 Read"},
+	{ 0x1B, "TPTC1 Write"},
+	{ 0x1C, "TPTC2 Read"},
+	{ 0x1D, "TPTC2 Write"},
+	{ 0x20, "SGX530"},
+	{ 0x21, "OCP WP Traffic Probe"},
+	{ 0x22, "OCP WP DMA Profiling"},
+	{ 0x23, "OCP WP Event Trace"},
+	{ 0x25, "DSS"},
+	{ 0x28, "Crypto DMA RD"},
+	{ 0x29, "Crypto DMA WR"},
+	{ 0x2C, "VPFE0"},
+	{ 0x2D, "VPFE1"},
+	{ 0x30, "GEMAC"},
+	{ 0x34, "USB0 RD"},
+	{ 0x35, "USB0 WR"},
+	{ 0x36, "USB1 RD"},
+	{ 0x37, "USB1 WR"},
+};
+
+static struct l3_flagmux_data *am4372_l3_flagmux[] = {
+	&am4372_l3_flagmux_200f,
+	&am4372_l3_flagmux_100s,
+};
+
+static const struct omap_l3 am4372_l3_data = {
+	.l3_flagmux = am4372_l3_flagmux,
+	.num_modules = ARRAY_SIZE(am4372_l3_flagmux),
+	.l3_masters = am4372_l3_masters,
+	.num_masters = ARRAY_SIZE(am4372_l3_masters),
+	/* All 6 bits of register field used to distinguish initiator */
+	.mst_addr_mask = 0x3F,
+};
+
 #endif	/* __OMAP_L3_NOC_H */

commit 53a848be0a65c6fb105eb5ecb8b8b3edfa0f91ad
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Thu Apr 10 11:33:13 2014 -0500

    bus: omap_l3_noc: Add DRA7 interconnect error data
    
    DRA7 is distinctly different from OMAP4 in terms of masters and clock
    domain organization. There two main clock domains which is divided as
    follows:
         <0x44000000 0x1000000> is clk1 and clk2 is the sub clock domain
         <0x45000000 0x1000> is clk3
    
    Add all the data needed to handle L3 error handling on DRA7 devices
    and mark clk2 as subdomain and provide a compatible flag for
    functionality. Other than the data difference the hardware blocks
    involved are essentially the same.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [nm@ti.com: bugfixes and generic improvements, documentation]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index aced4c546783..9562a75259c8 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -230,4 +230,155 @@ static const struct omap_l3 omap_l3_data = {
 	.mst_addr_mask = 0xFC,
 };
 
+/* DRA7 data */
+static struct l3_target_data dra_l3_target_data_clk1[] = {
+	{0x2a00, "AES1",},
+	{0x0200, "DMM_P1",},
+	{0x0600, "DSP2_SDMA",},
+	{0x0b00, "EVE2",},
+	{0x1300, "DMM_P2",},
+	{0x2c00, "AES2",},
+	{0x0300, "DSP1_SDMA",},
+	{0x0a00, "EVE1",},
+	{0x0c00, "EVE3",},
+	{0x0d00, "EVE4",},
+	{0x2900, "DSS",},
+	{0x0100, "GPMC",},
+	{0x3700, "PCIE1",},
+	{0x1600, "IVA_CONFIG",},
+	{0x1800, "IVA_SL2IF",},
+	{0x0500, "L4_CFG",},
+	{0x1d00, "L4_WKUP",},
+	{0x3800, "PCIE2",},
+	{0x3300, "SHA2_1",},
+	{0x1200, "GPU",},
+	{0x1000, "IPU1",},
+	{0x1100, "IPU2",},
+	{0x2000, "TPCC_EDMA",},
+	{0x2e00, "TPTC1_EDMA",},
+	{0x2b00, "TPTC2_EDMA",},
+	{0x0700, "VCP1",},
+	{0x2500, "L4_PER2_P3",},
+	{0x0e00, "L4_PER3_P3",},
+	{0x2200, "MMU1",},
+	{0x1400, "PRUSS1",},
+	{0x1500, "PRUSS2"},
+	{0x0800, "VCP1",},
+};
+
+static struct l3_flagmux_data dra_l3_flagmux_clk1 = {
+	.offset = 0x803500,
+	.l3_targ = dra_l3_target_data_clk1,
+	.num_targ_data = ARRAY_SIZE(dra_l3_target_data_clk1),
+};
+
+static struct l3_target_data dra_l3_target_data_clk2[] = {
+	{0x0,	"HOST CLK1",},
+	{0x0,	"HOST CLK2",},
+	{0xdead, L3_TARGET_NOT_SUPPORTED,},
+	{0x3400, "SHA2_2",},
+	{0x0900, "BB2D",},
+	{0xdead, L3_TARGET_NOT_SUPPORTED,},
+	{0x2100, "L4_PER1_P3",},
+	{0x1c00, "L4_PER1_P1",},
+	{0x1f00, "L4_PER1_P2",},
+	{0x2300, "L4_PER2_P1",},
+	{0x2400, "L4_PER2_P2",},
+	{0x2600, "L4_PER3_P1",},
+	{0x2700, "L4_PER3_P2",},
+	{0x2f00, "MCASP1",},
+	{0x3000, "MCASP2",},
+	{0x3100, "MCASP3",},
+	{0x2800, "MMU2",},
+	{0x0f00, "OCMC_RAM1",},
+	{0x1700, "OCMC_RAM2",},
+	{0x1900, "OCMC_RAM3",},
+	{0x1e00, "OCMC_ROM",},
+	{0x3900, "QSPI",},
+};
+
+static struct l3_flagmux_data dra_l3_flagmux_clk2 = {
+	.offset = 0x803600,
+	.l3_targ = dra_l3_target_data_clk2,
+	.num_targ_data = ARRAY_SIZE(dra_l3_target_data_clk2),
+};
+
+static struct l3_target_data dra_l3_target_data_clk3[] = {
+	{0x0100, "L3_INSTR"},
+	{0x0300, "DEBUGSS_CT_TBR"},
+	{0x0,	 "HOST CLK3"},
+};
+
+static struct l3_flagmux_data dra_l3_flagmux_clk3 = {
+	.offset = 0x200,
+	.l3_targ = dra_l3_target_data_clk3,
+	.num_targ_data = ARRAY_SIZE(dra_l3_target_data_clk3),
+};
+
+static struct l3_masters_data dra_l3_masters[] = {
+	{ 0x0, "MPU" },
+	{ 0x4, "CS_DAP" },
+	{ 0x5, "IEEE1500_2_OCP" },
+	{ 0x8, "DSP1_MDMA" },
+	{ 0x9, "DSP1_CFG" },
+	{ 0xA, "DSP1_DMA" },
+	{ 0xB, "DSP2_MDMA" },
+	{ 0xC, "DSP2_CFG" },
+	{ 0xD, "DSP2_DMA" },
+	{ 0xE, "IVA" },
+	{ 0x10, "EVE1_P1" },
+	{ 0x11, "EVE2_P1" },
+	{ 0x12, "EVE3_P1" },
+	{ 0x13, "EVE4_P1" },
+	{ 0x14, "PRUSS1 PRU1" },
+	{ 0x15, "PRUSS1 PRU2" },
+	{ 0x16, "PRUSS2 PRU1" },
+	{ 0x17, "PRUSS2 PRU2" },
+	{ 0x18, "IPU1" },
+	{ 0x19, "IPU2" },
+	{ 0x1A, "SDMA" },
+	{ 0x1B, "CDMA" },
+	{ 0x1C, "TC1_EDMA" },
+	{ 0x1D, "TC2_EDMA" },
+	{ 0x20, "DSS" },
+	{ 0x21, "MMU1" },
+	{ 0x22, "PCIE1" },
+	{ 0x23, "MMU2" },
+	{ 0x24, "VIP1" },
+	{ 0x25, "VIP2" },
+	{ 0x26, "VIP3" },
+	{ 0x27, "VPE" },
+	{ 0x28, "GPU_P1" },
+	{ 0x29, "BB2D" },
+	{ 0x29, "GPU_P2" },
+	{ 0x2B, "GMAC_SW" },
+	{ 0x2C, "USB3" },
+	{ 0x2D, "USB2_SS" },
+	{ 0x2E, "USB2_ULPI_SS1" },
+	{ 0x2F, "USB2_ULPI_SS2" },
+	{ 0x30, "CSI2_1" },
+	{ 0x31, "CSI2_2" },
+	{ 0x33, "SATA" },
+	{ 0x34, "EVE1_P2" },
+	{ 0x35, "EVE2_P2" },
+	{ 0x36, "EVE3_P2" },
+	{ 0x37, "EVE4_P2" }
+};
+
+static struct l3_flagmux_data *dra_l3_flagmux[] = {
+	&dra_l3_flagmux_clk1,
+	&dra_l3_flagmux_clk2,
+	&dra_l3_flagmux_clk3,
+};
+
+static const struct omap_l3 dra_l3_data = {
+	.l3_base = { [1] = L3_BASE_IS_SUBMODULE },
+	.l3_flagmux = dra_l3_flagmux,
+	.num_modules = ARRAY_SIZE(dra_l3_flagmux),
+	.l3_masters = dra_l3_masters,
+	.num_masters = ARRAY_SIZE(dra_l3_masters),
+	/* The 6 MSBs of register field used to distinguish initiator */
+	.mst_addr_mask = 0xFC,
+};
+
 #endif	/* __OMAP_L3_NOC_H */

commit f33ddf745cbcd4145fcb2f8239f5dbba089fb8ff
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 14:37:03 2014 -0500

    bus: omap_l3_noc: introduce concept of submodule
    
    While OMAP4 and OMAP5 had 3 separate clock domains, DRA7 has only 2
    and the first one then is internally divided into 2 sub clock domains.
    
    To better represent this in the driver, we use the concept of submodule.
    
    The address defintions in the devicetree is as per the high level
    clock domain(module) base, the sub clockdomain/subdomain which shares
    the same register space of a clockdomain is marked in the SoC data as
    L3_BASE_IS_SUBMODULE.
    
    L3_BASE_IS_SUBMODULE is used as an indication that it's base address is
    the same as the parent module and offsets are considered from the same
    base address as they are usually intermingled.
    
    Other than the base address, the submodule is same as a module as it is
    functionally so.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 36dc48b3dc00..aced4c546783 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -41,6 +41,8 @@
 
 #define L3_TARGET_NOT_SUPPORTED		NULL
 
+#define L3_BASE_IS_SUBMODULE		((void __iomem *)(1 << 0))
+
 static const char * const l3_transaction_type[] = {
 	/* 0 0 0 */ "Idle",
 	/* 0 0 1 */ "Write",
@@ -96,7 +98,9 @@ struct l3_flagmux_data {
 /**
  * struct omap_l3 - Description of data relevant for L3 bus.
  * @dev:	device representing the bus (populated runtime)
- * @l3_base:	base addresses of modules (populated runtime)
+ * @l3_base:	base addresses of modules (populated runtime if 0)
+ *		if set to L3_BASE_IS_SUBMODULE, then uses previous
+ *		module index as the base address
  * @l3_flag_mux: array containing flag mux data per module
  *		 offset from corresponding module base indexed per
  *		 module.

commit cf52b2ecd719ca7acb19c0fd74bcfcce9dc6a362
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 17:23:33 2014 -0500

    bus: omap_l3_noc: Add information about the context of operation
    
    L3 error may be triggered using Debug interface (example JTAG) or
    due to other errors, for example an opcode fetch (due to function
    pointer or stack corruption) or a data access (due to some other
    failure). NOC registers contain additional information to help aid
    debug information.
    
    With this, we can enhance the error information to more detailed form:
    "
    L3 Custom Error: MASTER MPU TARGET L4PER2 (Read): Data Access in User mode
    during Functional access
    "
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 6670fd98ce7c..36dc48b3dc00 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -31,7 +31,9 @@
 #define L3_TARG_STDERRLOG_MAIN		0x48
 #define L3_TARG_STDERRLOG_HDR		0x4c
 #define L3_TARG_STDERRLOG_MSTADDR	0x50
+#define L3_TARG_STDERRLOG_INFO		0x58
 #define L3_TARG_STDERRLOG_SLVOFSLSB	0x5c
+#define L3_TARG_STDERRLOG_CINFO_INFO	0x64
 #define L3_TARG_STDERRLOG_CINFO_MSTADDR	0x68
 #define L3_TARG_STDERRLOG_CINFO_OPCODE	0x6c
 #define L3_FLAGMUX_REGERR0		0xc

commit 7f9de02d603c439890c4c94631a326c73e2b5b4c
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 15:47:28 2014 -0500

    bus: omap_l3_noc: add information about the type of operation
    
    Today we get error such as
    L3 Custom Error: MASTER MPU TARGET L4PER2
    
    But since the actual instruction triggerring the error Vs the point
    at which we report error may not be aligned, it makes sense to try
    and provide additional information - example the type of operation
    that was attempted to being performed can help narrow the debug down
    further.
    
    This helps provide log such as:
    L3 Custom Error: MASTER MPU TARGET L4PER2 (Read)
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 4e18307470f6..6670fd98ce7c 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -29,14 +29,27 @@
 
 /* L3 TARG register offsets */
 #define L3_TARG_STDERRLOG_MAIN		0x48
+#define L3_TARG_STDERRLOG_HDR		0x4c
 #define L3_TARG_STDERRLOG_MSTADDR	0x50
 #define L3_TARG_STDERRLOG_SLVOFSLSB	0x5c
 #define L3_TARG_STDERRLOG_CINFO_MSTADDR	0x68
+#define L3_TARG_STDERRLOG_CINFO_OPCODE	0x6c
 #define L3_FLAGMUX_REGERR0		0xc
 #define L3_FLAGMUX_MASK0		0x8
 
 #define L3_TARGET_NOT_SUPPORTED		NULL
 
+static const char * const l3_transaction_type[] = {
+	/* 0 0 0 */ "Idle",
+	/* 0 0 1 */ "Write",
+	/* 0 1 0 */ "Read",
+	/* 0 1 1 */ "ReadEx",
+	/* 1 0 0 */ "Read Link",
+	/* 1 0 1 */ "Write Non-Posted",
+	/* 1 1 0 */ "Write Conditional",
+	/* 1 1 1 */ "Write Broadcast",
+};
+
 /**
  * struct l3_masters_data - L3 Master information
  * @id:		ID of the L3 Master

commit 2100b595b756db29a0b71de49c3bf73ae76c679b
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Apr 25 17:38:11 2014 -0500

    bus: omap_l3_noc: ignore masked out unclearable targets
    
    Errors that cannot be cleared (determined by reading REGERR register)
    are currently handled by masking it. Documentation states that REGERR
    "Checks which application/debug error sources are active" - it does not
    indicate that this is "interrupt status" - masked out status represented
    eventually in the irq line to MPU.
    For example:
    
    Lets say module 0 bit 8(0x100) was unclearable, we do the mask it from
    generating further errors. However in the following cases:
    a) bit 9 of Module 0
    OR
    b) any bit of Module 1+
    occur, the interrupt handler wrongly assumes that the raw interrupt
    status of module 0 bit 8 is the root cause of the interrupt, and
    returns. This causes unhandled interrupt and resultant infinite
    interrupts.
    
    Fix this scenario by storing the events we masked out and masking raw
    status with masked ones before identifying and handling the error.
    
    Reported-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index ea2f51c984f1..4e18307470f6 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -66,11 +66,15 @@ struct l3_target_data {
  *		target data. unsupported ones are marked with
  *		L3_TARGET_NOT_SUPPORTED
  * @num_targ_data: number of entries in target data
+ * @mask_app_bits: ignore these from raw application irq status
+ * @mask_dbg_bits: ignore these from raw debug irq status
  */
 struct l3_flagmux_data {
 	u32 offset;
 	struct l3_target_data *l3_targ;
 	u8 num_targ_data;
+	u32 mask_app_bits;
+	u32 mask_dbg_bits;
 };
 
 

commit c98aa7aaa24b7687a170b93c4bf3111a6d166069
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 12:24:56 2014 -0500

    bus: omap_l3_noc: make error reporting and handling common
    
    The logic between handling CUSTOM_ERROR and STANDARD_ERROR is just the
    reporting style.
    
    So make it generic, simplify and standardize the reporting with both
    master and target information printed to log.
    
    Handle the register address difference for master code for standard
    error and custom error as well.
    
    While at it, fix a minor indentation error.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index ba8692444665..ea2f51c984f1 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -29,8 +29,9 @@
 
 /* L3 TARG register offsets */
 #define L3_TARG_STDERRLOG_MAIN		0x48
+#define L3_TARG_STDERRLOG_MSTADDR	0x50
 #define L3_TARG_STDERRLOG_SLVOFSLSB	0x5c
-#define L3_TARG_STDERRLOG_MSTADDR	0x68
+#define L3_TARG_STDERRLOG_CINFO_MSTADDR	0x68
 #define L3_FLAGMUX_REGERR0		0xc
 #define L3_FLAGMUX_MASK0		0x8
 

commit d4d8819e205854cc102e366f30b8eadd60a58e97
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Apr 16 11:01:02 2014 -0500

    bus: omap_l3_noc: fix masterid detection
    
    As per Documentation (OMAP4+), then masterid is infact encoded as
    follows:
    "L3_TARG_STDERRLOG_MSTADDR[7:0] STDERRLOG_MSTADDR stores the NTTP
    master address. The master address is the concatenation of Prefix &
    Initiator ConnID. It is defined on 8 bits. The 6 MSBs are used to
    distinguish the different initiators."
    
    So, when we matchup currently with the master ID list, we never get a
    proper match other than when MPU is the master (thanks to 0).
    
    Now, on other platforms such as AM437x, this tends to be bits[5:0].
    
    Fix this by using the relevant 6MSBits to identify the master ID for
    standard and custom errors.
    
    Reported-by: Darren Etheridge <detheridge@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 64869fe656e5..ba8692444665 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -84,6 +84,7 @@ struct l3_flagmux_data {
  * @l3_masters:	array pointing to master data containing name and register
  *		offset for the master.
  * @num_master: number of masters
+ * @mst_addr_mask: Mask representing MSTADDR information of NTTP packet
  * @debug_irq:	irq number of the debug interrupt (populated runtime)
  * @app_irq:	irq number of the application interrupt (populated runtime)
  */
@@ -96,6 +97,7 @@ struct omap_l3 {
 
 	struct l3_masters_data *l3_masters;
 	int num_masters;
+	u32 mst_addr_mask;
 
 	int debug_irq;
 	int app_irq;
@@ -200,6 +202,8 @@ static const struct omap_l3 omap_l3_data = {
 	.num_modules = ARRAY_SIZE(omap_l3_flagmux),
 	.l3_masters = omap_l3_masters,
 	.num_masters = ARRAY_SIZE(omap_l3_masters),
+	/* The 6 MSBs of register field used to distinguish initiator */
+	.mst_addr_mask = 0xFC,
 };
 
 #endif	/* __OMAP_L3_NOC_H */

commit 97708c08c9955306742872ff7f2e47faec864ee7
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Apr 14 09:57:50 2014 -0500

    bus: omap_l3_noc: convert flagmux information into a structure
    
    This allows us to encompass target information and flag mux offset that
    points to the target information into a singular structure. This saves
    us the need to look up two different arrays indexed by module ID for
    information.
    
    This allows us to reduce the static target information allocation to
    just the ones that are documented.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index e60865fe5965..64869fe656e5 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -17,8 +17,8 @@
 #ifndef __OMAP_L3_NOC_H
 #define __OMAP_L3_NOC_H
 
-#define OMAP_L3_MODULES			3
 #define MAX_L3_MODULES			3
+#define MAX_CLKDM_TARGETS		31
 
 #define CLEAR_STDERR_LOG		(1 << 31)
 #define CUSTOM_ERROR			0x2
@@ -36,8 +36,6 @@
 
 #define L3_TARGET_NOT_SUPPORTED		NULL
 
-#define MAX_CLKDM_TARGETS		31
-
 /**
  * struct l3_masters_data - L3 Master information
  * @id:		ID of the L3 Master
@@ -60,21 +58,32 @@ struct l3_target_data {
 	char *name;
 };
 
+/**
+ * struct l3_flagmux_data - Flag Mux information
+ * @offset:	offset from base for flagmux register
+ * @l3_targ:	array indexed by flagmux index (bit offset) pointing to the
+ *		target data. unsupported ones are marked with
+ *		L3_TARGET_NOT_SUPPORTED
+ * @num_targ_data: number of entries in target data
+ */
+struct l3_flagmux_data {
+	u32 offset;
+	struct l3_target_data *l3_targ;
+	u8 num_targ_data;
+};
+
 
 /**
  * struct omap_l3 - Description of data relevant for L3 bus.
  * @dev:	device representing the bus (populated runtime)
  * @l3_base:	base addresses of modules (populated runtime)
- * @l3_flag_mux: array containing offsets to flag mux per module
+ * @l3_flag_mux: array containing flag mux data per module
  *		 offset from corresponding module base indexed per
  *		 module.
  * @num_modules: number of clock domains / modules.
  * @l3_masters:	array pointing to master data containing name and register
  *		offset for the master.
  * @num_master: number of masters
- * @l3_targ:	array indexed by flagmux index (bit offset) pointing to the
- *		target data. unsupported ones are marked with
- *		L3_TARGET_NOT_SUPPORTED
  * @debug_irq:	irq number of the debug interrupt (populated runtime)
  * @app_irq:	irq number of the application interrupt (populated runtime)
  */
@@ -82,25 +91,17 @@ struct omap_l3 {
 	struct device *dev;
 
 	void __iomem *l3_base[MAX_L3_MODULES];
-	u32 *l3_flagmux;
+	struct l3_flagmux_data **l3_flagmux;
 	int num_modules;
 
 	struct l3_masters_data *l3_masters;
 	int num_masters;
 
-	struct l3_target_data **l3_targ;
-
 	int debug_irq;
 	int app_irq;
 };
 
-static u32 omap_l3_flagmux[OMAP_L3_MODULES] = {
-	0x500,
-	0x1000,
-	0X0200
-};
-
-static struct l3_target_data omap_l3_target_data_clk1[MAX_CLKDM_TARGETS] = {
+static struct l3_target_data omap_l3_target_data_clk1[] = {
 	{0x100,	"DMM1",},
 	{0x200,	"DMM2",},
 	{0x300,	"ABE",},
@@ -110,7 +111,14 @@ static struct l3_target_data omap_l3_target_data_clk1[MAX_CLKDM_TARGETS] = {
 	{0x900,	"L4WAKEUP",},
 };
 
-static struct l3_target_data omap_l3_target_data_clk2[MAX_CLKDM_TARGETS] = {
+static struct l3_flagmux_data omap_l3_flagmux_clk1 = {
+	.offset = 0x500,
+	.l3_targ = omap_l3_target_data_clk1,
+	.num_targ_data = ARRAY_SIZE(omap_l3_target_data_clk1),
+};
+
+
+static struct l3_target_data omap_l3_target_data_clk2[] = {
 	{0x500,	"CORTEXM3",},
 	{0x300,	"DSS",},
 	{0x100,	"GPMC",},
@@ -134,12 +142,25 @@ static struct l3_target_data omap_l3_target_data_clk2[MAX_CLKDM_TARGETS] = {
 	{0x1700, "LLI",},
 };
 
-static struct l3_target_data omap_l3_target_data_clk3[MAX_CLKDM_TARGETS] = {
+static struct l3_flagmux_data omap_l3_flagmux_clk2 = {
+	.offset = 0x1000,
+	.l3_targ = omap_l3_target_data_clk2,
+	.num_targ_data = ARRAY_SIZE(omap_l3_target_data_clk2),
+};
+
+
+static struct l3_target_data omap_l3_target_data_clk3[] = {
 	{0x0100, "EMUSS",},
 	{0x0300, "DEBUG SOURCE",},
 	{0x0,	"HOST CLK3",},
 };
 
+static struct l3_flagmux_data omap_l3_flagmux_clk3 = {
+	.offset = 0x0200,
+	.l3_targ = omap_l3_target_data_clk3,
+	.num_targ_data = ARRAY_SIZE(omap_l3_target_data_clk3),
+};
+
 static struct l3_masters_data omap_l3_masters[] = {
 	{ 0x0 , "MPU"},
 	{ 0x10, "CS_ADP"},
@@ -168,18 +189,17 @@ static struct l3_masters_data omap_l3_masters[] = {
 	{ 0xC8, "USBHOSTFS"}
 };
 
-static struct l3_target_data *omap_l3_targ[OMAP_L3_MODULES] = {
-	omap_l3_target_data_clk1,
-	omap_l3_target_data_clk2,
-	omap_l3_target_data_clk3,
+static struct l3_flagmux_data *omap_l3_flagmux[] = {
+	&omap_l3_flagmux_clk1,
+	&omap_l3_flagmux_clk2,
+	&omap_l3_flagmux_clk3,
 };
 
 static const struct omap_l3 omap_l3_data = {
 	.l3_flagmux = omap_l3_flagmux,
-	.num_modules = OMAP_L3_MODULES,
+	.num_modules = ARRAY_SIZE(omap_l3_flagmux),
 	.l3_masters = omap_l3_masters,
 	.num_masters = ARRAY_SIZE(omap_l3_masters),
-	.l3_targ = omap_l3_targ,
 };
 
 #endif	/* __OMAP_L3_NOC_H */

commit 0659452dd2b2602058b80cfdcc673e98f2a67184
Author: Sricharan R <r.sricharan@ti.com>
Date:   Tue Nov 26 07:38:23 2013 -0600

    bus: omap_l3_noc: use of_match_data to pick up SoC information
    
    DRA7xx SoC has the same l3-noc interconnect ip (as OMAP4 and OMAP5), but
    AM437x SoC has just 2 modules instead of 3 which other SoCs have.
    
    So, stop using direct access of array indices and use of->match data and
    simplify implementation to benefit future usage.
    
    While at it, rename a few very generic variables to make them omap
    specific. This helps us differentiate from DRA7 and AM43xx data in the
    future.
    
    NOTE: None of the platforms that use omap_l3_noc are non-device tree
    anymore. So, it is safe to assume OF match here.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [nm@ti.com: split, refactor and optimize logic]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 66caeceaf123..e60865fe5965 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -17,7 +17,9 @@
 #ifndef __OMAP_L3_NOC_H
 #define __OMAP_L3_NOC_H
 
-#define L3_MODULES			3
+#define OMAP_L3_MODULES			3
+#define MAX_L3_MODULES			3
+
 #define CLEAR_STDERR_LOG		(1 << 31)
 #define CUSTOM_ERROR			0x2
 #define STANDARD_ERROR			0x0
@@ -36,8 +38,6 @@
 
 #define MAX_CLKDM_TARGETS		31
 
-#define NUM_OF_L3_MASTERS	(sizeof(l3_masters)/sizeof(l3_masters[0]))
-
 /**
  * struct l3_masters_data - L3 Master information
  * @id:		ID of the L3 Master
@@ -60,13 +60,47 @@ struct l3_target_data {
 	char *name;
 };
 
-static u32 l3_flagmux[L3_MODULES] = {
+
+/**
+ * struct omap_l3 - Description of data relevant for L3 bus.
+ * @dev:	device representing the bus (populated runtime)
+ * @l3_base:	base addresses of modules (populated runtime)
+ * @l3_flag_mux: array containing offsets to flag mux per module
+ *		 offset from corresponding module base indexed per
+ *		 module.
+ * @num_modules: number of clock domains / modules.
+ * @l3_masters:	array pointing to master data containing name and register
+ *		offset for the master.
+ * @num_master: number of masters
+ * @l3_targ:	array indexed by flagmux index (bit offset) pointing to the
+ *		target data. unsupported ones are marked with
+ *		L3_TARGET_NOT_SUPPORTED
+ * @debug_irq:	irq number of the debug interrupt (populated runtime)
+ * @app_irq:	irq number of the application interrupt (populated runtime)
+ */
+struct omap_l3 {
+	struct device *dev;
+
+	void __iomem *l3_base[MAX_L3_MODULES];
+	u32 *l3_flagmux;
+	int num_modules;
+
+	struct l3_masters_data *l3_masters;
+	int num_masters;
+
+	struct l3_target_data **l3_targ;
+
+	int debug_irq;
+	int app_irq;
+};
+
+static u32 omap_l3_flagmux[OMAP_L3_MODULES] = {
 	0x500,
 	0x1000,
 	0X0200
 };
 
-static struct l3_target_data l3_target_inst_data_clk1[MAX_CLKDM_TARGETS] = {
+static struct l3_target_data omap_l3_target_data_clk1[MAX_CLKDM_TARGETS] = {
 	{0x100,	"DMM1",},
 	{0x200,	"DMM2",},
 	{0x300,	"ABE",},
@@ -76,7 +110,7 @@ static struct l3_target_data l3_target_inst_data_clk1[MAX_CLKDM_TARGETS] = {
 	{0x900,	"L4WAKEUP",},
 };
 
-static struct l3_target_data l3_target_inst_data_clk2[MAX_CLKDM_TARGETS] = {
+static struct l3_target_data omap_l3_target_data_clk2[MAX_CLKDM_TARGETS] = {
 	{0x500,	"CORTEXM3",},
 	{0x300,	"DSS",},
 	{0x100,	"GPMC",},
@@ -100,13 +134,13 @@ static struct l3_target_data l3_target_inst_data_clk2[MAX_CLKDM_TARGETS] = {
 	{0x1700, "LLI",},
 };
 
-static struct l3_target_data l3_target_inst_data_clk3[MAX_CLKDM_TARGETS] = {
+static struct l3_target_data omap_l3_target_data_clk3[MAX_CLKDM_TARGETS] = {
 	{0x0100, "EMUSS",},
 	{0x0300, "DEBUG SOURCE",},
 	{0x0,	"HOST CLK3",},
 };
 
-static struct l3_masters_data l3_masters[] = {
+static struct l3_masters_data omap_l3_masters[] = {
 	{ 0x0 , "MPU"},
 	{ 0x10, "CS_ADP"},
 	{ 0x14, "xxx"},
@@ -134,20 +168,18 @@ static struct l3_masters_data l3_masters[] = {
 	{ 0xC8, "USBHOSTFS"}
 };
 
-static struct l3_target_data *l3_targ[L3_MODULES] = {
-	l3_target_inst_data_clk1,
-	l3_target_inst_data_clk2,
-	l3_target_inst_data_clk3,
+static struct l3_target_data *omap_l3_targ[OMAP_L3_MODULES] = {
+	omap_l3_target_data_clk1,
+	omap_l3_target_data_clk2,
+	omap_l3_target_data_clk3,
 };
 
-struct omap_l3 {
-	struct device *dev;
-
-	/* memory base */
-	void __iomem *l3_base[L3_MODULES];
-
-	int debug_irq;
-	int app_irq;
+static const struct omap_l3 omap_l3_data = {
+	.l3_flagmux = omap_l3_flagmux,
+	.num_modules = OMAP_L3_MODULES,
+	.l3_masters = omap_l3_masters,
+	.num_masters = ARRAY_SIZE(omap_l3_masters),
+	.l3_targ = omap_l3_targ,
 };
 
 #endif	/* __OMAP_L3_NOC_H */

commit 3340d739f8e1273abd408c59ad1843ea2ac35566
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Thu Apr 10 11:31:33 2014 -0500

    bus: omap_l3_noc: Add support for discountinous flag mux input numbers
    
    On DRA7, unlike on OMAP4 and OMAP5, the flag mux input numbers used
    to indicate the source of errors are not continous. Have a way in the
    driver to catch these and WARN the user of the flag mux input thats
    either undocumented or wrong.
    
    In the similar vein, Timeout errors in AM43x can't be cleared per h/w
    team, neither does it have a STDERRLOG_MAIN to clear the error.
    
    Further, the mux bit offset might not even be indexed into our array
    of known mux input description, in which case we'd have a abort.
    
    So, define a static range check for bit description and any definition
    which has target_name set to NULL (the ones that are not populated or
    ones that are specifically marked in the case of discontinous input
    numbers), can handle the same gracefully. Upon occurance of error from
    such sources, mask it. Otherwise, we'd have an infinite interrupt
    source without any means to clear it.
    
    NOTE: follow on patch ensures that these masked bits are ignored.
    
    [nm@ti.com: rebase, squash and improve]
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index ae2878464efa..66caeceaf123 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -30,6 +30,11 @@
 #define L3_TARG_STDERRLOG_SLVOFSLSB	0x5c
 #define L3_TARG_STDERRLOG_MSTADDR	0x68
 #define L3_FLAGMUX_REGERR0		0xc
+#define L3_FLAGMUX_MASK0		0x8
+
+#define L3_TARGET_NOT_SUPPORTED		NULL
+
+#define MAX_CLKDM_TARGETS		31
 
 #define NUM_OF_L3_MASTERS	(sizeof(l3_masters)/sizeof(l3_masters[0]))
 
@@ -61,7 +66,7 @@ static u32 l3_flagmux[L3_MODULES] = {
 	0X0200
 };
 
-static struct l3_target_data l3_target_inst_data_clk1[] = {
+static struct l3_target_data l3_target_inst_data_clk1[MAX_CLKDM_TARGETS] = {
 	{0x100,	"DMM1",},
 	{0x200,	"DMM2",},
 	{0x300,	"ABE",},
@@ -71,7 +76,7 @@ static struct l3_target_data l3_target_inst_data_clk1[] = {
 	{0x900,	"L4WAKEUP",},
 };
 
-static struct l3_target_data l3_target_inst_data_clk2[] = {
+static struct l3_target_data l3_target_inst_data_clk2[MAX_CLKDM_TARGETS] = {
 	{0x500,	"CORTEXM3",},
 	{0x300,	"DSS",},
 	{0x100,	"GPMC",},
@@ -95,7 +100,7 @@ static struct l3_target_data l3_target_inst_data_clk2[] = {
 	{0x1700, "LLI",},
 };
 
-static struct l3_target_data l3_target_inst_data_clk3[] = {
+static struct l3_target_data l3_target_inst_data_clk3[MAX_CLKDM_TARGETS] = {
 	{0x0100, "EMUSS",},
 	{0x0300, "DEBUG SOURCE",},
 	{0x0,	"HOST CLK3",},

commit 3ae9af7c90f8113365cf2600797115ee35e42d0d
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 11:38:10 2014 -0500

    bus: omap_l3_noc: convert target information into a structure
    
    Currently the target instance information is organized indexed by bit
    field offset into multiple arrays.
    
    1. We currently have offsets specific to each target associated with each
    clock domains are in seperate arrays:
    
    l3_targ_inst_clk1
    l3_targ_inst_clk2
    l3_targ_inst_clk3
    
    2. Then they are organized per master index in l3_targ.
    
    3. We have names in l3_targ_inst_name as an array to array of strings
    corresponding to the above with offsets.
    
    Simplify the same by defining a structure for information containing
    both target offset and name. this is then stored in arrays per domain
    and organized into an array indexed off domain.
    
    The array is still indexed based on bit field offset.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 059c707fdc84..ae2878464efa 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -43,51 +43,62 @@ struct l3_masters_data {
 	char *name;
 };
 
+/**
+ * struct l3_target_data - L3 Target information
+ * @offset:	Offset from base for L3 Target
+ * @name:	Target name
+ *
+ * Target information is organized indexed by bit field definitions.
+ */
+struct l3_target_data {
+	u32 offset;
+	char *name;
+};
+
 static u32 l3_flagmux[L3_MODULES] = {
 	0x500,
 	0x1000,
 	0X0200
 };
 
-/* L3 Target standard Error register offsets */
-static u32 l3_targ_inst_clk1[] = {
-	0x100, /* DMM1 */
-	0x200, /* DMM2 */
-	0x300, /* ABE */
-	0x400, /* L4CFG */
-	0x600,  /* CLK2 PWR DISC */
-	0x0,	/* Host CLK1 */
-	0x900	/* L4 Wakeup */
+static struct l3_target_data l3_target_inst_data_clk1[] = {
+	{0x100,	"DMM1",},
+	{0x200,	"DMM2",},
+	{0x300,	"ABE",},
+	{0x400,	"L4CFG",},
+	{0x600,	"CLK2PWRDISC",},
+	{0x0,	"HOSTCLK1",},
+	{0x900,	"L4WAKEUP",},
 };
 
-static u32 l3_targ_inst_clk2[] = {
-	0x500, /* CORTEX M3 */
-	0x300, /* DSS */
-	0x100, /* GPMC */
-	0x400, /* ISS */
-	0x700, /* IVAHD */
-	0xD00, /* missing in TRM  corresponds to AES1*/
-	0x900, /* L4 PER0*/
-	0x200, /* OCMRAM */
-	0x100, /* missing in TRM corresponds to GPMC sERROR*/
-	0x600, /* SGX */
-	0x800, /* SL2 */
-	0x1600, /* C2C */
-	0x1100,	/* missing in TRM corresponds PWR DISC CLK1*/
-	0xF00, /* missing in TRM corrsponds to SHA1*/
-	0xE00, /* missing in TRM corresponds to AES2*/
-	0xC00, /* L4 PER3 */
-	0xA00, /* L4 PER1*/
-	0xB00, /* L4 PER2*/
-	0x0, /* HOST CLK2 */
-	0x1800, /* CAL */
-	0x1700 /* LLI */
+static struct l3_target_data l3_target_inst_data_clk2[] = {
+	{0x500,	"CORTEXM3",},
+	{0x300,	"DSS",},
+	{0x100,	"GPMC",},
+	{0x400,	"ISS",},
+	{0x700,	"IVAHD",},
+	{0xD00,	"AES1",},
+	{0x900,	"L4PER0",},
+	{0x200,	"OCMRAM",},
+	{0x100,	"GPMCsERROR",},
+	{0x600,	"SGX",},
+	{0x800,	"SL2",},
+	{0x1600, "C2C",},
+	{0x1100, "PWRDISCCLK1",},
+	{0xF00,	"SHA1",},
+	{0xE00,	"AES2",},
+	{0xC00,	"L4PER3",},
+	{0xA00,	"L4PER1",},
+	{0xB00,	"L4PER2",},
+	{0x0,	"HOSTCLK2",},
+	{0x1800, "CAL",},
+	{0x1700, "LLI",},
 };
 
-static u32 l3_targ_inst_clk3[] = {
-	0x0100	/* EMUSS */,
-	0x0300, /* DEBUGSS_CT_TBR */
-	0x0 /* HOST CLK3 */
+static struct l3_target_data l3_target_inst_data_clk3[] = {
+	{0x0100, "EMUSS",},
+	{0x0300, "DEBUG SOURCE",},
+	{0x0,	"HOST CLK3",},
 };
 
 static struct l3_masters_data l3_masters[] = {
@@ -118,50 +129,10 @@ static struct l3_masters_data l3_masters[] = {
 	{ 0xC8, "USBHOSTFS"}
 };
 
-static char *l3_targ_inst_name[L3_MODULES][21] = {
-	{
-		"DMM1",
-		"DMM2",
-		"ABE",
-		"L4CFG",
-		"CLK2 PWR DISC",
-		"HOST CLK1",
-		"L4 WAKEUP"
-	},
-	{
-		"CORTEX M3" ,
-		"DSS ",
-		"GPMC ",
-		"ISS ",
-		"IVAHD ",
-		"AES1",
-		"L4 PER0",
-		"OCMRAM ",
-		"GPMC sERROR",
-		"SGX ",
-		"SL2 ",
-		"C2C ",
-		"PWR DISC CLK1",
-		"SHA1",
-		"AES2",
-		"L4 PER3",
-		"L4 PER1",
-		"L4 PER2",
-		"HOST CLK2",
-		"CAL",
-		"LLI"
-	},
-	{
-		"EMUSS",
-		"DEBUG SOURCE",
-		"HOST CLK3"
-	},
-};
-
-static u32 *l3_targ[L3_MODULES] = {
-	l3_targ_inst_clk1,
-	l3_targ_inst_clk2,
-	l3_targ_inst_clk3,
+static struct l3_target_data *l3_targ[L3_MODULES] = {
+	l3_target_inst_data_clk1,
+	l3_target_inst_data_clk2,
+	l3_target_inst_data_clk3,
 };
 
 struct omap_l3 {

commit f0a6e654d8db2dfa3eb8b99380ad449d5e092c33
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 10:11:59 2014 -0500

    bus: omap_l3_noc: move L3 master data structure out
    
    Move the L3 master structure out of the static definition to enable
    reuse for other SoCs.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index 31984cf949cc..059c707fdc84 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -33,6 +33,16 @@
 
 #define NUM_OF_L3_MASTERS	(sizeof(l3_masters)/sizeof(l3_masters[0]))
 
+/**
+ * struct l3_masters_data - L3 Master information
+ * @id:		ID of the L3 Master
+ * @name:	master name
+ */
+struct l3_masters_data {
+	u32 id;
+	char *name;
+};
+
 static u32 l3_flagmux[L3_MODULES] = {
 	0x500,
 	0x1000,
@@ -80,10 +90,7 @@ static u32 l3_targ_inst_clk3[] = {
 	0x0 /* HOST CLK3 */
 };
 
-static struct l3_masters_data {
-	u32 id;
-	char name[10];
-} l3_masters[] = {
+static struct l3_masters_data l3_masters[] = {
 	{ 0x0 , "MPU"},
 	{ 0x10, "CS_ADP"},
 	{ 0x14, "xxx"},

commit 73cecc46dd3c3fc3fdf906f4de1448a4279cb1e2
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 13:55:22 2014 -0500

    bus: omap_l3_noc: remove iclk from omap_l3 struct
    
    we do not use iclk directly anymore. And, even if we had to, we
    should be using pm_runtime APIs to do the same to be completely SoC
    independent.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index b3c81f2fe7a2..31984cf949cc 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -159,7 +159,6 @@ static u32 *l3_targ[L3_MODULES] = {
 
 struct omap_l3 {
 	struct device *dev;
-	struct clk *ick;
 
 	/* memory base */
 	void __iomem *l3_base[L3_MODULES];

commit c10d5c9e1200e2b8c23329173f279caa86c6af45
Author: Sricharan R <r.sricharan@ti.com>
Date:   Fri Apr 11 13:09:36 2014 -0500

    bus: omap_l3_noc: rename functions and data to omap_l3
    
    Since omap_l3_noc driver is now being used for OMAP5 and reusable with
    DRA7 and AM437x, using omap4 specific naming is misleading.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index cc4b1b1788f0..b3c81f2fe7a2 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -1,5 +1,5 @@
 /*
- * OMAP4XXX L3 Interconnect  error handling driver header
+ * OMAP L3 Interconnect  error handling driver header
  *
  * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
@@ -14,8 +14,8 @@
  * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-#ifndef __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
-#define __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
+#ifndef __OMAP_L3_NOC_H
+#define __OMAP_L3_NOC_H
 
 #define L3_MODULES			3
 #define CLEAR_STDERR_LOG		(1 << 31)
@@ -157,7 +157,7 @@ static u32 *l3_targ[L3_MODULES] = {
 	l3_targ_inst_clk3,
 };
 
-struct omap4_l3 {
+struct omap_l3 {
 	struct device *dev;
 	struct clk *ick;
 
@@ -167,4 +167,5 @@ struct omap4_l3 {
 	int debug_irq;
 	int app_irq;
 };
-#endif
+
+#endif	/* __OMAP_L3_NOC_H */

commit c5f2aea0ef47b2934b46374abfac9015de79aecb
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 11 13:15:43 2014 -0500

    bus: omap_l3_noc: Fix copyright information
    
    This is an embarrassing patch :(.
    
    Texas Corporation does not make OMAP. Texas Instruments Inc does.
    
    For that matter I dont seem to be able to find a Texas Corporation on
    the internet either.
    
    While at it, update coverage to the current year and update the template
    to remove redundant information and use the standard boiler plate
    licensing.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index a6ce34dc4814..cc4b1b1788f0 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -1,24 +1,18 @@
 /*
  * OMAP4XXX L3 Interconnect  error handling driver header
  *
- * Copyright (C) 2011 Texas Corporation
+ * Copyright (C) 2011-2014 Texas Instruments Incorporated - http://www.ti.com/
  *	Santosh Shilimkar <santosh.shilimkar@ti.com>
  *	sricharan <r.sricharan@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
  */
 #ifndef __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
 #define __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H

commit 0ee7261c9212dbaf72d510e37f6c5b849d1847f0
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Sep 14 14:50:34 2012 +0530

    drivers: bus: Move the OMAP interconnect driver to drivers/bus/
    
    OMAP interconnect drivers are used for the interconnect error handling.
    Since they are bus driver, lets move it to newly created drivers/bus.
    
    Tested-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
new file mode 100644
index 000000000000..a6ce34dc4814
--- /dev/null
+++ b/drivers/bus/omap_l3_noc.h
@@ -0,0 +1,176 @@
+/*
+ * OMAP4XXX L3 Interconnect  error handling driver header
+ *
+ * Copyright (C) 2011 Texas Corporation
+ *	Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *	sricharan <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#ifndef __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
+#define __ARCH_ARM_MACH_OMAP2_L3_INTERCONNECT_3XXX_H
+
+#define L3_MODULES			3
+#define CLEAR_STDERR_LOG		(1 << 31)
+#define CUSTOM_ERROR			0x2
+#define STANDARD_ERROR			0x0
+#define INBAND_ERROR			0x0
+#define L3_APPLICATION_ERROR		0x0
+#define L3_DEBUG_ERROR			0x1
+
+/* L3 TARG register offsets */
+#define L3_TARG_STDERRLOG_MAIN		0x48
+#define L3_TARG_STDERRLOG_SLVOFSLSB	0x5c
+#define L3_TARG_STDERRLOG_MSTADDR	0x68
+#define L3_FLAGMUX_REGERR0		0xc
+
+#define NUM_OF_L3_MASTERS	(sizeof(l3_masters)/sizeof(l3_masters[0]))
+
+static u32 l3_flagmux[L3_MODULES] = {
+	0x500,
+	0x1000,
+	0X0200
+};
+
+/* L3 Target standard Error register offsets */
+static u32 l3_targ_inst_clk1[] = {
+	0x100, /* DMM1 */
+	0x200, /* DMM2 */
+	0x300, /* ABE */
+	0x400, /* L4CFG */
+	0x600,  /* CLK2 PWR DISC */
+	0x0,	/* Host CLK1 */
+	0x900	/* L4 Wakeup */
+};
+
+static u32 l3_targ_inst_clk2[] = {
+	0x500, /* CORTEX M3 */
+	0x300, /* DSS */
+	0x100, /* GPMC */
+	0x400, /* ISS */
+	0x700, /* IVAHD */
+	0xD00, /* missing in TRM  corresponds to AES1*/
+	0x900, /* L4 PER0*/
+	0x200, /* OCMRAM */
+	0x100, /* missing in TRM corresponds to GPMC sERROR*/
+	0x600, /* SGX */
+	0x800, /* SL2 */
+	0x1600, /* C2C */
+	0x1100,	/* missing in TRM corresponds PWR DISC CLK1*/
+	0xF00, /* missing in TRM corrsponds to SHA1*/
+	0xE00, /* missing in TRM corresponds to AES2*/
+	0xC00, /* L4 PER3 */
+	0xA00, /* L4 PER1*/
+	0xB00, /* L4 PER2*/
+	0x0, /* HOST CLK2 */
+	0x1800, /* CAL */
+	0x1700 /* LLI */
+};
+
+static u32 l3_targ_inst_clk3[] = {
+	0x0100	/* EMUSS */,
+	0x0300, /* DEBUGSS_CT_TBR */
+	0x0 /* HOST CLK3 */
+};
+
+static struct l3_masters_data {
+	u32 id;
+	char name[10];
+} l3_masters[] = {
+	{ 0x0 , "MPU"},
+	{ 0x10, "CS_ADP"},
+	{ 0x14, "xxx"},
+	{ 0x20, "DSP"},
+	{ 0x30, "IVAHD"},
+	{ 0x40, "ISS"},
+	{ 0x44, "DucatiM3"},
+	{ 0x48, "FaceDetect"},
+	{ 0x50, "SDMA_Rd"},
+	{ 0x54, "SDMA_Wr"},
+	{ 0x58, "xxx"},
+	{ 0x5C, "xxx"},
+	{ 0x60, "SGX"},
+	{ 0x70, "DSS"},
+	{ 0x80, "C2C"},
+	{ 0x88, "xxx"},
+	{ 0x8C, "xxx"},
+	{ 0x90, "HSI"},
+	{ 0xA0, "MMC1"},
+	{ 0xA4, "MMC2"},
+	{ 0xA8, "MMC6"},
+	{ 0xB0, "UNIPRO1"},
+	{ 0xC0, "USBHOSTHS"},
+	{ 0xC4, "USBOTGHS"},
+	{ 0xC8, "USBHOSTFS"}
+};
+
+static char *l3_targ_inst_name[L3_MODULES][21] = {
+	{
+		"DMM1",
+		"DMM2",
+		"ABE",
+		"L4CFG",
+		"CLK2 PWR DISC",
+		"HOST CLK1",
+		"L4 WAKEUP"
+	},
+	{
+		"CORTEX M3" ,
+		"DSS ",
+		"GPMC ",
+		"ISS ",
+		"IVAHD ",
+		"AES1",
+		"L4 PER0",
+		"OCMRAM ",
+		"GPMC sERROR",
+		"SGX ",
+		"SL2 ",
+		"C2C ",
+		"PWR DISC CLK1",
+		"SHA1",
+		"AES2",
+		"L4 PER3",
+		"L4 PER1",
+		"L4 PER2",
+		"HOST CLK2",
+		"CAL",
+		"LLI"
+	},
+	{
+		"EMUSS",
+		"DEBUG SOURCE",
+		"HOST CLK3"
+	},
+};
+
+static u32 *l3_targ[L3_MODULES] = {
+	l3_targ_inst_clk1,
+	l3_targ_inst_clk2,
+	l3_targ_inst_clk3,
+};
+
+struct omap4_l3 {
+	struct device *dev;
+	struct clk *ick;
+
+	/* memory base */
+	void __iomem *l3_base[L3_MODULES];
+
+	int debug_irq;
+	int app_irq;
+};
+#endif
