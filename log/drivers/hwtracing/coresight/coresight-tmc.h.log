commit 00bb485ce7b8d1186a5166fc9e38822797fae7d4
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Thu Aug 29 14:28:40 2019 -0600

    coresight: tmc: Make memory width mask computation into a function
    
    Make the computation of a memory mask representing the width of the memory
    bus into a function so that it can be re-used by the ETR driver.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Leo Yan <leo.yan@linaro.org>
    Link: https://lore.kernel.org/r/20190829202842.580-16-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 9dbcdf453e22..71de978575f3 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -255,6 +255,7 @@ void tmc_wait_for_tmcready(struct tmc_drvdata *drvdata);
 void tmc_flush_and_stop(struct tmc_drvdata *drvdata);
 void tmc_enable_hw(struct tmc_drvdata *drvdata);
 void tmc_disable_hw(struct tmc_drvdata *drvdata);
+u32 tmc_get_memwidth_mask(struct tmc_drvdata *drvdata);
 
 /* ETB/ETF functions */
 int tmc_read_prepare_etb(struct tmc_drvdata *drvdata);

commit bbedcb91cc3bf252e6031e199ab3d1f07107f7c5
Author: Yabin Cui <yabinc@google.com>
Date:   Thu Aug 29 14:28:39 2019 -0600

    coresight: tmc-etr: Fix perf_data check
    
    When tracing etm data of multiple threads on multiple cpus through
    perf interface, each cpu has a unique etr_perf_buffer while sharing
    the same etr device. There is no guarantee that the last cpu starts
    etm tracing also stops last. This makes perf_data check fail.
    
    Fix it by checking etr_buf instead of etr_perf_buffer.
    Also move the code setting and clearing perf_buf to more suitable
    places.
    
    Fixes: 3147da92a8a8 ("coresight: tmc-etr: Allocate and free ETR memory buffers for CPU-wide scenarios")
    Signed-off-by: Yabin Cui <yabinc@google.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20190829202842.580-15-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 4c59f2a4ad0e..9dbcdf453e22 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -182,8 +182,8 @@ struct etr_buf {
  *		device configuration register (DEVID)
  * @idr:	Holds etr_bufs allocated for this ETR.
  * @idr_mutex:	Access serialisation for idr.
- * @perf_data:	PERF buffer for ETR.
- * @sysfs_data:	SYSFS buffer for ETR.
+ * @sysfs_buf:	SYSFS buffer for ETR.
+ * @perf_buf:	PERF buffer for ETR.
  */
 struct tmc_drvdata {
 	void __iomem		*base;
@@ -206,7 +206,7 @@ struct tmc_drvdata {
 	struct idr		idr;
 	struct mutex		idr_mutex;
 	struct etr_buf		*sysfs_buf;
-	void			*perf_data;
+	struct etr_buf		*perf_buf;
 };
 
 struct etr_buf_operations {

commit 8a4bc4f195044004520e38da7b8a52a76ccc9945
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Thu Aug 29 14:28:31 2019 -0600

    coresight: tmc-etr: Check if non-secure access is enabled
    
    CoreSight TMC-ETR must have the non-secure invasive debug access
    enabled for use by self-hosted tracing. Without it, there is no
    point in enabling the ETR. So, let us check it in the TMC_AUTHSTATUS
    register and fail the probe if it is disabled.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20190829202842.580-7-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 95d2e2747970..4c59f2a4ad0e 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -39,6 +39,7 @@
 #define TMC_ITATBCTR2		0xef0
 #define TMC_ITATBCTR1		0xef4
 #define TMC_ITATBCTR0		0xef8
+#define TMC_AUTHSTATUS		0xfb8
 
 /* register description */
 /* TMC_CTL - 0x020 */
@@ -90,6 +91,8 @@
 #define TMC_DEVID_AXIAW_SHIFT	17
 #define TMC_DEVID_AXIAW_MASK	0x7f
 
+#define TMC_AUTH_NSID_MASK	GENMASK(1, 0)
+
 enum tmc_config_type {
 	TMC_CONFIG_TYPE_ETB,
 	TMC_CONFIG_TYPE_ETR,

commit f52ff9b7d64953b9a1a03faaf797d23b5c1d10d0
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Thu Aug 29 14:28:30 2019 -0600

    coresight: tmc-etr: Handle memory errors
    
    We have so far ignored the memory errors, assuming that we have perfect
    hardware and driver. Let us handle the memory errors reported by the
    TMC ETR in status and truncate the buffer.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    [Removed ASCII smiley face from changelog]
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20190829202842.580-6-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 1ed50411cc3c..95d2e2747970 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -47,6 +47,7 @@
 #define TMC_STS_TMCREADY_BIT	2
 #define TMC_STS_FULL		BIT(0)
 #define TMC_STS_TRIGGERED	BIT(1)
+#define TMC_STS_MEMERR		BIT(5)
 /*
  * TMC_AXICTL - 0x110
  *

commit 9dd0a92097675ffc629cfe3ea7a169842cc9b29c
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jun 19 11:29:12 2019 -0600

    coresight: tmc: Clean up device specific data
    
    In preparation to use a consistent device naming scheme,
    clean up the device link tracking in replicator driver.
    Use the "coresight" device instead of the "real" parent device
    for all internal purposes. All other requests (e.g, power management,
    DMA operations) must use the "real" device which is the parent device.
    
    Since the CATU driver also uses the TMC-SG infrastructure, update
    the callers to ensure they pass the appropriate device argument
    for the tables.
    
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 503f1b3a3741..1ed50411cc3c 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -161,7 +161,6 @@ struct etr_buf {
 /**
  * struct tmc_drvdata - specifics associated to an TMC component
  * @base:	memory mapped base address for this component.
- * @dev:	the device entity associated to this component.
  * @csdev:	component vitals needed by the framework.
  * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
  * @spinlock:	only one at a time pls.
@@ -184,7 +183,6 @@ struct etr_buf {
  */
 struct tmc_drvdata {
 	void __iomem		*base;
-	struct device		*dev;
 	struct coresight_device	*csdev;
 	struct miscdevice	miscdev;
 	spinlock_t		spinlock;

commit 8d03cfd16a7283e9e7a5aeb7dc0742ceb66d2d23
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Thu Apr 25 13:53:08 2019 -0600

    coresight: tmc-etr: Add support for CPU-wide trace scenarios
    
    This patch adds support for CPU-wide trace scenarios by making sure that
    only the sources monitoring the same process have access to a common sink.
    Because the sink is shared between sources, the first source to use the
    sink switches it on while the last one does the cleanup.  Any attempt to
    modify the HW is overlooked for as long as more than one source is using
    a sink.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Tested-by: Leo Yan <leo.yan@linaro.org>
    Tested-by: Robert Walker <robert.walker@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index c1b1700b2df7..503f1b3a3741 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -165,6 +165,8 @@ struct etr_buf {
  * @csdev:	component vitals needed by the framework.
  * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
  * @spinlock:	only one at a time pls.
+ * @pid:	Process ID of the process being monitored by the session
+ *		that is using this component.
  * @buf:	Snapshot of the trace data for ETF/ETB.
  * @etr_buf:	details of buffer used in TMC-ETR
  * @len:	size of the available trace for ETF/ETB.
@@ -186,6 +188,7 @@ struct tmc_drvdata {
 	struct coresight_device	*csdev;
 	struct miscdevice	miscdev;
 	spinlock_t		spinlock;
+	pid_t			pid;
 	bool			reading;
 	union {
 		char		*buf;		/* TMC ETB */

commit c5ff734462b1d32f793db717ef222cd05e6232d5
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Thu Apr 25 13:53:06 2019 -0600

    coresight: tmc-etr: Introduce the notion of IDR to ETR devices
    
    In CPU-wide scenarios with an N:1 source/sink topology, sources share
    the same sink.  In order to reuse the same sink for all sources an
    IDR is needed to archive events that have already been accounted for.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Tested-by: Leo Yan <leo.yan@linaro.org>
    Tested-by: Robert Walker <robert.walker@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index ee44906dffe8..c1b1700b2df7 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -8,7 +8,9 @@
 #define _CORESIGHT_TMC_H
 
 #include <linux/dma-mapping.h>
+#include <linux/idr.h>
 #include <linux/miscdevice.h>
+#include <linux/mutex.h>
 #include <linux/refcount.h>
 
 #define TMC_RSZ			0x004
@@ -173,6 +175,8 @@ struct etr_buf {
  * @trigger_cntr: amount of words to store after a trigger.
  * @etr_caps:	Bitmask of capabilities of the TMC ETR, inferred from the
  *		device configuration register (DEVID)
+ * @idr:	Holds etr_bufs allocated for this ETR.
+ * @idr_mutex:	Access serialisation for idr.
  * @perf_data:	PERF buffer for ETR.
  * @sysfs_data:	SYSFS buffer for ETR.
  */
@@ -194,6 +198,8 @@ struct tmc_drvdata {
 	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;
 	u32			etr_caps;
+	struct idr		idr;
+	struct mutex		idr_mutex;
 	struct etr_buf		*sysfs_buf;
 	void			*perf_data;
 };

commit 57549999b9a0d0c72900d2413ef1e3168bd2e817
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Thu Apr 25 13:53:05 2019 -0600

    coresight: tmc-etr: Introduce the notion of reference counting to ETR devices
    
    This patch adds reference counting to struct etr_buf so that, in CPU-wide
    trace scenarios, shared buffers can be disposed of when no longer used.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Tested-by: Leo Yan <leo.yan@linaro.org>
    Tested-by: Robert Walker <robert.walker@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 487c53701e9c..ee44906dffe8 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -9,6 +9,7 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/miscdevice.h>
+#include <linux/refcount.h>
 
 #define TMC_RSZ			0x004
 #define TMC_STS			0x00c
@@ -133,6 +134,7 @@ struct etr_buf_operations;
 
 /**
  * struct etr_buf - Details of the buffer used by ETR
+ * refcount	; Number of sources currently using this etr_buf.
  * @mode	: Mode of the ETR buffer, contiguous, Scatter Gather etc.
  * @full	: Trace data overflow
  * @size	: Size of the buffer.
@@ -143,6 +145,7 @@ struct etr_buf_operations;
  * @private	: Backend specific information for the buf
  */
 struct etr_buf {
+	refcount_t			refcount;
 	enum etr_mode			mode;
 	bool				full;
 	ssize_t				size;

commit 22f429f19c4135d51e9dcaf360c0920e32aac7f9
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Thu Sep 20 13:17:57 2018 -0600

    coresight: etm-perf: Add support for ETR backend
    
    Add support for using TMC-ETR as backend for ETM perf tracing.
    We use software double buffering at the moment. i.e, the TMC-ETR
    uses a separate buffer than the perf ring buffer. The data is
    copied to the perf ring buffer once a session completes.
    
    The TMC-ETR would try to match the larger of perf ring buffer
    or the ETR buffer size configured via sysfs, scaling down to
    a minimum limit of 1MB.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 872f63e3651b..487c53701e9c 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -170,6 +170,7 @@ struct etr_buf {
  * @trigger_cntr: amount of words to store after a trigger.
  * @etr_caps:	Bitmask of capabilities of the TMC ETR, inferred from the
  *		device configuration register (DEVID)
+ * @perf_data:	PERF buffer for ETR.
  * @sysfs_data:	SYSFS buffer for ETR.
  */
 struct tmc_drvdata {
@@ -191,6 +192,7 @@ struct tmc_drvdata {
 	u32			trigger_cntr;
 	u32			etr_caps;
 	struct etr_buf		*sysfs_buf;
+	void			*perf_data;
 };
 
 struct etr_buf_operations {

commit 96a7f644006ecc05eaaa1a5d09373d0ee63beb0a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Thu Sep 20 13:17:51 2018 -0600

    coresight: tmc-etr: Handle driver mode specific ETR buffers
    
    Since the ETR could be driven either by SYSFS or by perf, it
    becomes complicated how we deal with the buffers used for each
    of these modes. The ETR driver cannot simply free the current
    attached buffer without knowing the provider (i.e, sysfs vs perf).
    
    To solve this issue, we provide:
    1) the driver-mode specific etr buffer to be retained in the drvdata
    2) the etr_buf for a session should be passed on when enabling the
       hardware, which will be stored in drvdata->etr_buf. This will be
       replaced (not free'd) as soon as the hardware is disabled, after
       necessary sync operation.
    
    The advantages of this are :
    
    1) The common code path doesn't need to worry about how to dispose
       an existing buffer, if it is about to start a new session with a
       different buffer, possibly in a different mode.
    2) The driver mode can control its buffers and can get access to the
       saved session even when the hardware is operating in a different
       mode. (e.g, we can still access a trace buffer from a sysfs mode
       even if the etr is now used in perf mode, without disrupting the
       current session.)
    
    Towards this, we introduce a sysfs specific data which will hold the
    etr_buf used for sysfs mode of operation, controlled solely by the
    sysfs mode handling code.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 7027bd60c4cc..872f63e3651b 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -170,6 +170,7 @@ struct etr_buf {
  * @trigger_cntr: amount of words to store after a trigger.
  * @etr_caps:	Bitmask of capabilities of the TMC ETR, inferred from the
  *		device configuration register (DEVID)
+ * @sysfs_data:	SYSFS buffer for ETR.
  */
 struct tmc_drvdata {
 	void __iomem		*base;
@@ -189,6 +190,7 @@ struct tmc_drvdata {
 	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;
 	u32			etr_caps;
+	struct etr_buf		*sysfs_buf;
 };
 
 struct etr_buf_operations {

commit 434d611cddef1ceed32bf416a363992b01a3ff9a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jul 11 13:40:34 2018 -0600

    coresight: catu: Plug in CATU as a backend for ETR buffer
    
    Now that we can use a CATU with a scatter gather table, add support
    for the TMC ETR to make use of the connected CATU in translate mode.
    This is done by adding CATU as new buffer mode.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index e7456575bfc1..7027bd60c4cc 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -126,6 +126,7 @@ enum tmc_mem_intf_width {
 enum etr_mode {
 	ETR_MODE_FLAT,		/* Uses contiguous flat buffer */
 	ETR_MODE_ETR_SG,	/* Uses in-built TMC ETR SG mechanism */
+	ETR_MODE_CATU,		/* Use SG mechanism in CATU */
 };
 
 struct etr_buf_operations;
@@ -303,4 +304,6 @@ tmc_sg_table_buf_size(struct tmc_sg_table *sg_table)
 	return sg_table->data_pages.nr_pages << PAGE_SHIFT;
 }
 
+struct coresight_device *tmc_etr_get_catu_device(struct tmc_drvdata *drvdata);
+
 #endif

commit e8e3b771395d9b75ba5da409b7d20435ddb05a21
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jul 11 13:40:23 2018 -0600

    coresight: tmc-etr buf: Add TMC scatter gather mode backend
    
    Add the support for Scatter-Gather mode to the etr-buf layer.
    Since we now have two different modes, we choose the backend
    based on a set of conditions, documented in the code.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index bbd65e2107be..e7456575bfc1 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -125,6 +125,7 @@ enum tmc_mem_intf_width {
 
 enum etr_mode {
 	ETR_MODE_FLAT,		/* Uses contiguous flat buffer */
+	ETR_MODE_ETR_SG,	/* Uses in-built TMC ETR SG mechanism */
 };
 
 struct etr_buf_operations;

commit 75f4e3619fe202c642080a798e84d05288522a22
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jul 11 13:40:22 2018 -0600

    coresight: tmc-etr: Add transparent buffer management
    
    The TMC-ETR can use the target trace buffer in two different modes.
    Normal physically contiguous mode and a discontiguous list pages in
    Scatter-Gather mode. Also we have dedicated Coresight component, CATU
    (Coresight Address Translation Unit) to provide improved scatter-gather
    mode in Coresight SoC-600. This complicates the management of the
    buffer used for trace, depending on the mode in which ETR is configured.
    
    So, this patch adds a transparent layer for managing the ETR buffer
    which abstracts the basic operations on the buffer (alloc, free,
    sync and retrieve the data) and uses the mode specific helpers to
    do the actual operation. This also allows the ETR driver to choose
    the best mode for a given use case and adds the flexibility to
    fallback to a different mode, without duplicating the code.
    
    The patch also adds the "normal" flat memory mode and switches
    the sysfs driver to use the new layer.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index cdb668b4441d..bbd65e2107be 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -123,6 +123,34 @@ enum tmc_mem_intf_width {
 #define CORESIGHT_SOC_600_ETR_CAPS	\
 	(TMC_ETR_SAVE_RESTORE | TMC_ETR_AXI_ARCACHE)
 
+enum etr_mode {
+	ETR_MODE_FLAT,		/* Uses contiguous flat buffer */
+};
+
+struct etr_buf_operations;
+
+/**
+ * struct etr_buf - Details of the buffer used by ETR
+ * @mode	: Mode of the ETR buffer, contiguous, Scatter Gather etc.
+ * @full	: Trace data overflow
+ * @size	: Size of the buffer.
+ * @hwaddr	: Address to be programmed in the TMC:DBA{LO,HI}
+ * @offset	: Offset of the trace data in the buffer for consumption.
+ * @len		: Available trace data @buf (may round up to the beginning).
+ * @ops		: ETR buffer operations for the mode.
+ * @private	: Backend specific information for the buf
+ */
+struct etr_buf {
+	enum etr_mode			mode;
+	bool				full;
+	ssize_t				size;
+	dma_addr_t			hwaddr;
+	unsigned long			offset;
+	s64				len;
+	const struct etr_buf_operations	*ops;
+	void				*private;
+};
+
 /**
  * struct tmc_drvdata - specifics associated to an TMC component
  * @base:	memory mapped base address for this component.
@@ -130,11 +158,10 @@ enum tmc_mem_intf_width {
  * @csdev:	component vitals needed by the framework.
  * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
  * @spinlock:	only one at a time pls.
- * @buf:	area of memory where trace data get sent.
- * @paddr:	DMA start location in RAM.
- * @vaddr:	virtual representation of @paddr.
- * @size:	trace buffer size.
- * @len:	size of the available trace.
+ * @buf:	Snapshot of the trace data for ETF/ETB.
+ * @etr_buf:	details of buffer used in TMC-ETR
+ * @len:	size of the available trace for ETF/ETB.
+ * @size:	trace buffer size for this TMC (common for all modes).
  * @mode:	how this TMC is being used.
  * @config_type: TMC variant, must be of type @tmc_config_type.
  * @memwidth:	width of the memory interface databus, in bytes.
@@ -149,11 +176,12 @@ struct tmc_drvdata {
 	struct miscdevice	miscdev;
 	spinlock_t		spinlock;
 	bool			reading;
-	char			*buf;
-	dma_addr_t		paddr;
-	void __iomem		*vaddr;
-	u32			size;
+	union {
+		char		*buf;		/* TMC ETB */
+		struct etr_buf	*etr_buf;	/* TMC ETR */
+	};
 	u32			len;
+	u32			size;
 	u32			mode;
 	enum tmc_config_type	config_type;
 	enum tmc_mem_intf_width	memwidth;
@@ -161,6 +189,15 @@ struct tmc_drvdata {
 	u32			etr_caps;
 };
 
+struct etr_buf_operations {
+	int (*alloc)(struct tmc_drvdata *drvdata, struct etr_buf *etr_buf,
+		     int node, void **pages);
+	void (*sync)(struct etr_buf *etr_buf, u64 rrp, u64 rwp);
+	ssize_t (*get_data)(struct etr_buf *etr_buf, u64 offset, size_t len,
+			    char **bufpp);
+	void (*free)(struct etr_buf *etr_buf);
+};
+
 /**
  * struct tmc_pages - Collection of pages used for SG.
  * @nr_pages:		Number of pages in the list.

commit 99443ea19e8bb0fee5fb6f4ed9cec11fd825061f
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jul 11 13:40:20 2018 -0600

    coresight: Add generic TMC sg table framework
    
    This patch introduces a generic sg table data structure and
    associated operations. An SG table can be used to map a set
    of Data pages where the trace data could be stored by the TMC
    ETR. The information about the data pages could be stored in
    different formats, depending on the type of the underlying
    SG mechanism (e.g, TMC ETR SG vs Coresight CATU). The generic
    structure provides book keeping of the pages used for the data
    as well as the table contents. The table should be filled by
    the user of the infrastructure.
    
    A table can be created by specifying the number of data pages
    as well as the number of table pages required to hold the
    pointers, where the latter could be different for different
    types of tables. The pages are mapped in the appropriate dma
    data direction mode (i.e, DMA_TO_DEVICE for table pages
    and DMA_FROM_DEVICE for data pages).  The framework can optionally
    accept a set of allocated data pages (e.g, perf ring buffer) and
    map them accordingly. The table and data pages are vmap'ed to allow
    easier access by the drivers. The framework also provides helpers to
    sync the data written to the pages with appropriate directions.
    
    This will be later used by the TMC ETR SG unit and CATU.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 1d7cd582919b..cdb668b4441d 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -7,6 +7,7 @@
 #ifndef _CORESIGHT_TMC_H
 #define _CORESIGHT_TMC_H
 
+#include <linux/dma-mapping.h>
 #include <linux/miscdevice.h>
 
 #define TMC_RSZ			0x004
@@ -160,6 +161,38 @@ struct tmc_drvdata {
 	u32			etr_caps;
 };
 
+/**
+ * struct tmc_pages - Collection of pages used for SG.
+ * @nr_pages:		Number of pages in the list.
+ * @daddrs:		Array of DMA'able page address.
+ * @pages:		Array pages for the buffer.
+ */
+struct tmc_pages {
+	int nr_pages;
+	dma_addr_t	*daddrs;
+	struct page	**pages;
+};
+
+/*
+ * struct tmc_sg_table - Generic SG table for TMC
+ * @dev:		Device for DMA allocations
+ * @table_vaddr:	Contiguous Virtual address for PageTable
+ * @data_vaddr:		Contiguous Virtual address for Data Buffer
+ * @table_daddr:	DMA address of the PageTable base
+ * @node:		Node for Page allocations
+ * @table_pages:	List of pages & dma address for Table
+ * @data_pages:		List of pages & dma address for Data
+ */
+struct tmc_sg_table {
+	struct device *dev;
+	void *table_vaddr;
+	void *data_vaddr;
+	dma_addr_t table_daddr;
+	int node;
+	struct tmc_pages table_pages;
+	struct tmc_pages data_pages;
+};
+
 /* Generic functions */
 void tmc_wait_for_tmcready(struct tmc_drvdata *drvdata);
 void tmc_flush_and_stop(struct tmc_drvdata *drvdata);
@@ -215,4 +248,21 @@ static inline bool tmc_etr_has_cap(struct tmc_drvdata *drvdata, u32 cap)
 	return !!(drvdata->etr_caps & cap);
 }
 
+struct tmc_sg_table *tmc_alloc_sg_table(struct device *dev,
+					int node,
+					int nr_tpages,
+					int nr_dpages,
+					void **pages);
+void tmc_free_sg_table(struct tmc_sg_table *sg_table);
+void tmc_sg_table_sync_table(struct tmc_sg_table *sg_table);
+void tmc_sg_table_sync_data_range(struct tmc_sg_table *table,
+				  u64 offset, u64 size);
+ssize_t tmc_sg_table_get_data(struct tmc_sg_table *sg_table,
+			      u64 offset, size_t len, char **bufpp);
+static inline unsigned long
+tmc_sg_table_buf_size(struct tmc_sg_table *sg_table)
+{
+	return sg_table->data_pages.nr_pages << PAGE_SHIFT;
+}
+
 #endif

commit 3495722a0093c80f66c020f90161983b46a1f5ee
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Jul 11 13:40:15 2018 -0600

    coresight: tmc: Hide trace buffer handling for file read
    
    At the moment we adjust the buffer pointers for reading the trace
    data via misc device in the common code for ETF/ETB and ETR. Since
    we are going to change how we manage the buffer for ETR, let us
    move the buffer manipulation to the respective driver files, hiding
    it from the common code. We do so by adding type specific helpers
    for finding the length of data and the pointer to the buffer,
    for a given length at a file position.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index dfaff077a7fc..1d7cd582919b 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -172,10 +172,14 @@ int tmc_read_unprepare_etb(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etb_cs_ops;
 extern const struct coresight_ops tmc_etf_cs_ops;
 
+ssize_t tmc_etb_get_sysfs_trace(struct tmc_drvdata *drvdata,
+				loff_t pos, size_t len, char **bufpp);
 /* ETR functions */
 int tmc_read_prepare_etr(struct tmc_drvdata *drvdata);
 int tmc_read_unprepare_etr(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etr_cs_ops;
+ssize_t tmc_etr_get_sysfs_trace(struct tmc_drvdata *drvdata,
+				loff_t pos, size_t len, char **bufpp);
 
 
 #define TMC_REG_PAIR(name, lo_off, hi_off)				\

commit ad0dfdfd874c38d42bc4e5ef8969d86f3da0b93a
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Wed May 9 12:06:04 2018 -0600

    coresight: Moving framework and drivers to SPDX identifier
    
    Moving all kernel side CoreSight framework and drivers to SPDX identifier.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 8df7a813f537..dfaff077a7fc 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -1,18 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright(C) 2015 Linaro Limited. All rights reserved.
  * Author: Mathieu Poirier <mathieu.poirier@linaro.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef _CORESIGHT_TMC_H

commit 6495892c9194001936a9ef0d30638c36f431636f
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:17 2017 -0600

    coresight tmc: Add support for Coresight SoC 600 TMC
    
    The coresight SoC 600 supports ETR save-restore which allows us
    to restore a trace session by retaining the RRP/RWP/STS.Full values
    when the TMC leaves the Disabled state. However, the TMC doesn't
    have a scatter-gather unit in built.
    
    Also, TMCs have different PIDs in different configurations (ETF,
    ETB & ETR), unlike the previous generation.
    
    While the DEVID exposes some of the features/changes in the TMC,
    it doesn't explicitly advertises the new save-restore feature
    as described above.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index d0da43a14246..8df7a813f537 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -129,6 +129,10 @@ enum tmc_mem_intf_width {
  */
 #define TMC_ETR_SAVE_RESTORE		(0x1U << 2)
 
+/* Coresight SoC-600 TMC-ETR unadvertised capabilities */
+#define CORESIGHT_SOC_600_ETR_CAPS	\
+	(TMC_ETR_SAVE_RESTORE | TMC_ETR_AXI_ARCACHE)
+
 /**
  * struct tmc_drvdata - specifics associated to an TMC component
  * @base:	memory mapped base address for this component.

commit f2e931a2deab1ab426085f0357285410644f2945
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:16 2017 -0600

    coresight tmc: Support for save-restore in ETR
    
    The Coresight SoC 600 TMC ETR supports save-restore feature,
    where the values of the RRP/RWP and STS.Full are retained
    when it leaves the Disabled state. Hence, we must program the
    RRP/RWP and STS.Full to a proper value. For now, set the RRP/RWP
    to the base address of the buffer and clear the STS.Full register.
    This can be later exploited for proper save-restore of ETR
    trace contexts (e.g, perf).
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index f39caa6a45c3..d0da43a14246 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -119,6 +119,15 @@ enum tmc_mem_intf_width {
 #define TMC_ETR_SG			(0x1U << 0)
 /* ETR has separate read/write cache encodings */
 #define TMC_ETR_AXI_ARCACHE		(0x1U << 1)
+/*
+ * TMC_ETR_SAVE_RESTORE - Values of RRP/RWP/STS.Full are
+ * retained when TMC leaves Disabled state, allowing us to continue
+ * the tracing from a point where we stopped. This also implies that
+ * the RRP/RWP/STS.Full should always be programmed to the correct
+ * value. Unfortunately this is not advertised by the hardware,
+ * so we have to rely on PID of the IP to detect the functionality.
+ */
+#define TMC_ETR_SAVE_RESTORE		(0x1U << 2)
 
 /**
  * struct tmc_drvdata - specifics associated to an TMC component

commit ebab6a7db2c599b5c29d033f3a20f86016d9a9b8
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:15 2017 -0600

    coresight tmc etr: Setup AXI cache encoding for read transfers
    
    If the ETR supports split cache encoding (i.e, separate bits for
    read and write transfers) unlike the older version (where read
    and write transfers use the same encoding in AXICTL[2-5]).
    This feature is not advertised and has to be described by the
    static mask associated with the device id.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 07c0bf1d9269..f39caa6a45c3 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -59,13 +59,18 @@
  *
  * TMC AXICTL format for SoC-400
  *	Bits [0-1]	: ProtCtrlBit0-1
- *	Bits [2-5]	: CacheCtrlBits 0-3 (AxCACHE)
+ *	Bits [2-5]	: CacheCtrlBits 0-3 (AXCACHE)
  *	Bit  6		: Reserved
  *	Bit  7		: ScatterGatherMode
  *	Bits [8-11]	: WrBurstLen
  *	Bits [12-31]	: Reserved.
+ * TMC AXICTL format for SoC-600, as above except:
+ *	Bits [2-5]	: AXI WCACHE
+ *	Bits [16-19]	: AXI RCACHE
+ *	Bits [20-31]	: Reserved
  */
 #define TMC_AXICTL_CLEAR_MASK 0xfbf
+#define TMC_AXICTL_ARCACHE_MASK (0xf << 16)
 
 #define TMC_AXICTL_PROT_CTL_B0	BIT(0)
 #define TMC_AXICTL_PROT_CTL_B1	BIT(1)
@@ -73,6 +78,7 @@
 #define TMC_AXICTL_WR_BURST_16	0xF00
 /* Write-back Read and Write-allocate */
 #define TMC_AXICTL_AXCACHE_OS	(0xf << 2)
+#define TMC_AXICTL_ARCACHE_OS	(0xf << 16)
 
 /* TMC_FFCR - 0x304 */
 #define TMC_FFCR_FLUSHMAN_BIT	6
@@ -111,6 +117,8 @@ enum tmc_mem_intf_width {
 
 /* TMC ETR Capability bit definitions */
 #define TMC_ETR_SG			(0x1U << 0)
+/* ETR has separate read/write cache encodings */
+#define TMC_ETR_AXI_ARCACHE		(0x1U << 1)
 
 /**
  * struct tmc_drvdata - specifics associated to an TMC component

commit cd407abd5efd6f36b6372d615fbab486936e90f4
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:14 2017 -0600

    coresight tmc etr: Cleanup AXICTL register handling
    
    This patch cleans up how we setup the AXICTL register on
    TMC ETR. At the moment we don't set the CacheCtrl bits, which
    drives the arcache and awcache bits on AXI bus specifying the
    cacheablitiy. Set this to Write-back Read and Write-allocate.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index f55203d48673..07c0bf1d9269 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -54,11 +54,26 @@
 #define TMC_STS_TMCREADY_BIT	2
 #define TMC_STS_FULL		BIT(0)
 #define TMC_STS_TRIGGERED	BIT(1)
-/* TMC_AXICTL - 0x110 */
+/*
+ * TMC_AXICTL - 0x110
+ *
+ * TMC AXICTL format for SoC-400
+ *	Bits [0-1]	: ProtCtrlBit0-1
+ *	Bits [2-5]	: CacheCtrlBits 0-3 (AxCACHE)
+ *	Bit  6		: Reserved
+ *	Bit  7		: ScatterGatherMode
+ *	Bits [8-11]	: WrBurstLen
+ *	Bits [12-31]	: Reserved.
+ */
+#define TMC_AXICTL_CLEAR_MASK 0xfbf
+
 #define TMC_AXICTL_PROT_CTL_B0	BIT(0)
 #define TMC_AXICTL_PROT_CTL_B1	BIT(1)
 #define TMC_AXICTL_SCT_GAT_MODE	BIT(7)
 #define TMC_AXICTL_WR_BURST_16	0xF00
+/* Write-back Read and Write-allocate */
+#define TMC_AXICTL_AXCACHE_OS	(0xf << 2)
+
 /* TMC_FFCR - 0x304 */
 #define TMC_FFCR_FLUSHMAN_BIT	6
 #define TMC_FFCR_EN_FMT		BIT(0)

commit ff11f5bc5a42f2cfc9705481eedf1b4d470ade2c
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:13 2017 -0600

    coresight tmc etr: Detect address width at runtime
    
    TMC in Coresight SoC-600 advertises the AXI address width
    in the device configuration register.
    
    Bit 16 - AXIAW_VALID
     0 - AXI Address Width not valid
     1 - Valid AXI Address width in Bits[23-17]
    
    Bits [23-17] - AXIAW. If AXIAW_VALID = b01 then
     0x20 - 32bit AXI address bus
     0x28 - 40bit AXI address bus
     0x2c - 44bit AXI address bus
     0x30 - 48bit AXI address bus
     0x34 - 52bit AXI address bus
    
    Use the address bits from the device configuration register, if
    available. Otherwise, default to 40bit.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index bb6a3e3314b8..f55203d48673 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -71,6 +71,10 @@
 
 #define TMC_DEVID_NOSCAT	BIT(24)
 
+#define TMC_DEVID_AXIAW_VALID	BIT(16)
+#define TMC_DEVID_AXIAW_SHIFT	17
+#define TMC_DEVID_AXIAW_MASK	0x7f
+
 enum tmc_config_type {
 	TMC_CONFIG_TYPE_ETB,
 	TMC_CONFIG_TYPE_ETR,

commit 2e21934568c0f9fcd2e01060007506a74d49152b
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:12 2017 -0600

    coresight tmc: Detect support for scatter gather
    
    The SG unit in the TMC has been removed in Coresight SoC-600.
    This is however advertised by DEVID:Bit 24 = 0b1. On the
    previous generation, the bit is RES0, hence we can rely on the
    DEVID to detect the support.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Mike Leach <mike.leach@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 13ab1008f110..bb6a3e3314b8 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -69,6 +69,8 @@
 #define TMC_FFCR_STOP_ON_FLUSH	BIT(12)
 
 
+#define TMC_DEVID_NOSCAT	BIT(24)
+
 enum tmc_config_type {
 	TMC_CONFIG_TYPE_ETB,
 	TMC_CONFIG_TYPE_ETR,
@@ -88,6 +90,9 @@ enum tmc_mem_intf_width {
 	TMC_MEM_INTF_WIDTH_256BITS	= 8,
 };
 
+/* TMC ETR Capability bit definitions */
+#define TMC_ETR_SG			(0x1U << 0)
+
 /**
  * struct tmc_drvdata - specifics associated to an TMC component
  * @base:	memory mapped base address for this component.

commit 2884132ae8e4424c2d025deef48d937337e97db7
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:11 2017 -0600

    coresight tmc etr: Add capabilitiy information
    
    With new version of TMC ETR, there are differing set of
    features supported by the TMC. Add the capability of a
    given TMC ETR for making safer decisions at runtime.
    
    The device configuration register of the TMC (DEVID) lists
    some of the capabilities. So, we can detect some of them at
    probe. However, some of the features (or changes in behavior)
    are not advertised and we have to depend on the PID to infer
    the features. So we use a static description of the "unadvertised"
    capabilities attached to the PID. Combining both, the static
    and the dynamic capabilities, we maintain a bitmask of the
    available features which can be later checked to take
    appropriate actions.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index c4ff23336e76..13ab1008f110 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -104,6 +104,8 @@ enum tmc_mem_intf_width {
  * @config_type: TMC variant, must be of type @tmc_config_type.
  * @memwidth:	width of the memory interface databus, in bytes.
  * @trigger_cntr: amount of words to store after a trigger.
+ * @etr_caps:	Bitmask of capabilities of the TMC ETR, inferred from the
+ *		device configuration register (DEVID)
  */
 struct tmc_drvdata {
 	void __iomem		*base;
@@ -121,6 +123,7 @@ struct tmc_drvdata {
 	enum tmc_config_type	config_type;
 	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;
+	u32			etr_caps;
 };
 
 /* Generic functions */
@@ -157,4 +160,21 @@ TMC_REG_PAIR(rrp, TMC_RRP, TMC_RRPHI)
 TMC_REG_PAIR(rwp, TMC_RWP, TMC_RWPHI)
 TMC_REG_PAIR(dba, TMC_DBALO, TMC_DBAHI)
 
+/* Initialise the caps from unadvertised static capabilities of the device */
+static inline void tmc_etr_init_caps(struct tmc_drvdata *drvdata, u32 dev_caps)
+{
+	WARN_ON(drvdata->etr_caps);
+	drvdata->etr_caps = dev_caps;
+}
+
+static inline void tmc_etr_set_cap(struct tmc_drvdata *drvdata, u32 cap)
+{
+	drvdata->etr_caps |= cap;
+}
+
+static inline bool tmc_etr_has_cap(struct tmc_drvdata *drvdata, u32 cap)
+{
+	return !!(drvdata->etr_caps & cap);
+}
+
 #endif

commit 6f6ab4fce56bbb0385d3d2d62d8c9f688618d5ac
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Wed Aug 2 10:22:07 2017 -0600

    coresight tmc: Add helpers for accessing 64bit registers
    
    Coresight TMC splits 64bit registers into a pair of 32bit registers
    (e.g DBA, RRP, RWP). Provide helpers to read/write to these registers.
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 51c01851533e..c4ff23336e76 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -139,4 +139,22 @@ extern const struct coresight_ops tmc_etf_cs_ops;
 int tmc_read_prepare_etr(struct tmc_drvdata *drvdata);
 int tmc_read_unprepare_etr(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etr_cs_ops;
+
+
+#define TMC_REG_PAIR(name, lo_off, hi_off)				\
+static inline u64							\
+tmc_read_##name(struct tmc_drvdata *drvdata)				\
+{									\
+	return coresight_read_reg_pair(drvdata->base, lo_off, hi_off);	\
+}									\
+static inline void							\
+tmc_write_##name(struct tmc_drvdata *drvdata, u64 val)			\
+{									\
+	coresight_write_reg_pair(drvdata->base, val, lo_off, hi_off);	\
+}
+
+TMC_REG_PAIR(rrp, TMC_RRP, TMC_RRPHI)
+TMC_REG_PAIR(rwp, TMC_RWP, TMC_RWPHI)
+TMC_REG_PAIR(dba, TMC_DBALO, TMC_DBAHI)
+
 #endif

commit 297ab90f15f6222408380bbf4e8cbff57b02060d
Author: Suzuki K. Poulose <Suzuki.Poulose@arm.com>
Date:   Tue Nov 29 09:47:15 2016 -0700

    coresight: tmc: Cleanup operation mode handling
    
    The mode of operation of the TMC tracked in drvdata->mode is defined
    as a local_t type. This is always checked and modified under the
    drvdata->spinlock and hence we don't need local_t for it and the
    unnecessary synchronisation instructions that comes with it. This
    change makes the code a bit more cleaner.
    
    Also fixes the order in which we update the drvdata->mode to
    CS_MODE_DISABLED. i.e, in tmc_disable_etX_sink we change the
    mode to CS_MODE_DISABLED before invoking tmc_disable_etX_hw()
    which in turn depends on the mode to decide whether to dump the
    trace to a buffer.
    
    Applies on mathieu's coresight/next tree [1]
    
    https://git.linaro.org/kernel/coresight.git next
    
    Reported-by: Venkatesh Vivekanandan <venkatesh.vivekanandan@broadcom.com>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 44b3ae346118..51c01851533e 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -117,7 +117,7 @@ struct tmc_drvdata {
 	void __iomem		*vaddr;
 	u32			size;
 	u32			len;
-	local_t			mode;
+	u32			mode;
 	enum tmc_config_type	config_type;
 	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;

commit 8505feaed9246791e94c30e8bf52fa4c3ef2e7af
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Thu Aug 25 15:18:57 2016 -0600

    coresight: tmc: Limit the trace to available data
    
    At present the ETF or ETR gives out the entire device
    buffer, even if there is less or even no trace data
    available. This patch limits the trace data given out to
    the actual trace data collected.
    
    Cc: mathieu.poirier@linaro.org
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 5c5fe2ad2ca7..44b3ae346118 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -98,7 +98,8 @@ enum tmc_mem_intf_width {
  * @buf:	area of memory where trace data get sent.
  * @paddr:	DMA start location in RAM.
  * @vaddr:	virtual representation of @paddr.
- * @size:	@buf size.
+ * @size:	trace buffer size.
+ * @len:	size of the available trace.
  * @mode:	how this TMC is being used.
  * @config_type: TMC variant, must be of type @tmc_config_type.
  * @memwidth:	width of the memory interface databus, in bytes.
@@ -115,6 +116,7 @@ struct tmc_drvdata {
 	dma_addr_t		paddr;
 	void __iomem		*vaddr;
 	u32			size;
+	u32			len;
 	local_t			mode;
 	enum tmc_config_type	config_type;
 	enum tmc_mem_intf_width	memwidth;

commit 2e499bbc1a929ac87dcb9832d11000fc055f8bc6
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:59 2016 -0600

    coresight: tmc: implementing TMC-ETF AUX space API
    
    This patch implement the AUX area interfaces required to
    use the TMC (configured as an ETF) from the Perf sub-system.
    
    The heuristic is heavily borrowed from the ETB10 implementation.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index c5d06fd57fa8..5c5fe2ad2ca7 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -52,6 +52,7 @@
 #define TMC_CTL_CAPT_EN		BIT(0)
 /* TMC_STS - 0x00C */
 #define TMC_STS_TMCREADY_BIT	2
+#define TMC_STS_FULL		BIT(0)
 #define TMC_STS_TRIGGERED	BIT(1)
 /* TMC_AXICTL - 0x110 */
 #define TMC_AXICTL_PROT_CTL_B0	BIT(0)

commit 4f1ff3de925d741b0b77c59bc1387cb940ad7c73
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:57 2016 -0600

    coresight: tmc: keep track of memory width
    
    Accessing the HW configuration register each time the memory
    width is needed simply doesn't make sense.  It is much more
    efficient to read the value once and keep a reference for
    later use.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 94bc034d3b98..c5d06fd57fa8 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -81,10 +81,10 @@ enum tmc_mode {
 };
 
 enum tmc_mem_intf_width {
-	TMC_MEM_INTF_WIDTH_32BITS	= 0x2,
-	TMC_MEM_INTF_WIDTH_64BITS	= 0x3,
-	TMC_MEM_INTF_WIDTH_128BITS	= 0x4,
-	TMC_MEM_INTF_WIDTH_256BITS	= 0x5,
+	TMC_MEM_INTF_WIDTH_32BITS	= 1,
+	TMC_MEM_INTF_WIDTH_64BITS	= 2,
+	TMC_MEM_INTF_WIDTH_128BITS	= 4,
+	TMC_MEM_INTF_WIDTH_256BITS	= 8,
 };
 
 /**
@@ -100,6 +100,7 @@ enum tmc_mem_intf_width {
  * @size:	@buf size.
  * @mode:	how this TMC is being used.
  * @config_type: TMC variant, must be of type @tmc_config_type.
+ * @memwidth:	width of the memory interface databus, in bytes.
  * @trigger_cntr: amount of words to store after a trigger.
  */
 struct tmc_drvdata {
@@ -115,6 +116,7 @@ struct tmc_drvdata {
 	u32			size;
 	local_t			mode;
 	enum tmc_config_type	config_type;
+	enum tmc_mem_intf_width	memwidth;
 	u32			trigger_cntr;
 };
 

commit f2facc3366d77e78dbc8bf865f1e4a6227a7f0e5
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:54 2016 -0600

    coresight: tmc: adding mode of operation for link/sinks
    
    Moving tmc_drvdata::enable to a local_t mode.  That way the
    sink interface is aware of it's orgin and the foundation for
    mutual exclusion between the sysFS and Perf interface can be
    laid out.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 592eb149fe3a..94bc034d3b98 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -98,7 +98,7 @@ enum tmc_mem_intf_width {
  * @paddr:	DMA start location in RAM.
  * @vaddr:	virtual representation of @paddr.
  * @size:	@buf size.
- * @enable:	this TMC is being used.
+ * @mode:	how this TMC is being used.
  * @config_type: TMC variant, must be of type @tmc_config_type.
  * @trigger_cntr: amount of words to store after a trigger.
  */
@@ -113,7 +113,7 @@ struct tmc_drvdata {
 	dma_addr_t		paddr;
 	void __iomem		*vaddr;
 	u32			size;
-	bool			enable;
+	local_t			mode;
 	enum tmc_config_type	config_type;
 	u32			trigger_cntr;
 };

commit f74debbea0885ebb65fb3fa4e598323f40b03f5f
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:53 2016 -0600

    coresight: tmc: getting rid of multiple read access
    
    Allowing multiple readers to access the trace data simultaniously
    via sysFS provides no shortage of opportunity for race condition,
    mandates two variable to be maintained (drvdata::read_count and
    drvdata::reading), makes the code complex and provide little
    advantages, if any.
    
    This patch streamlines the read process by restricting trace data
    access to a single user.  That way drvdata::read_count can
    be eliminated and race conditions (along with faulty error handling)
    in function tmc_open() and tmc_release() eliminated.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index df661903f83c..592eb149fe3a 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -94,7 +94,6 @@ enum tmc_mem_intf_width {
  * @csdev:	component vitals needed by the framework.
  * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
  * @spinlock:	only one at a time pls.
- * @read_count:	manages preparation of buffer for reading.
  * @buf:	area of memory where trace data get sent.
  * @paddr:	DMA start location in RAM.
  * @vaddr:	virtual representation of @paddr.
@@ -109,7 +108,6 @@ struct tmc_drvdata {
 	struct coresight_device	*csdev;
 	struct miscdevice	miscdev;
 	spinlock_t		spinlock;
-	int			read_count;
 	bool			reading;
 	char			*buf;
 	dma_addr_t		paddr;

commit 4525412a5046692abb7a0588589d8ed2c20585e0
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:51 2016 -0600

    coresight: tmc: making prepare/unprepare functions generic
    
    Dealing with HW related matters in tmc_read_prepare/unprepare
    becomes convoluted when many cases need to be handled distinctively.
    
    As such moving processing related to HW setup to individual driver
    files and keep the core driver generic.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index b3017e115c4d..df661903f83c 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -127,13 +127,13 @@ void tmc_enable_hw(struct tmc_drvdata *drvdata);
 void tmc_disable_hw(struct tmc_drvdata *drvdata);
 
 /* ETB/ETF functions */
-void tmc_etb_enable_hw(struct tmc_drvdata *drvdata);
-void tmc_etb_disable_hw(struct tmc_drvdata *drvdata);
+int tmc_read_prepare_etb(struct tmc_drvdata *drvdata);
+int tmc_read_unprepare_etb(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etb_cs_ops;
 extern const struct coresight_ops tmc_etf_cs_ops;
 
 /* ETR functions */
-void tmc_etr_enable_hw(struct tmc_drvdata *drvdata);
-void tmc_etr_disable_hw(struct tmc_drvdata *drvdata);
+int tmc_read_prepare_etr(struct tmc_drvdata *drvdata);
+int tmc_read_unprepare_etr(struct tmc_drvdata *drvdata);
 extern const struct coresight_ops tmc_etr_cs_ops;
 #endif

commit 6c6ed1e244c0530fb76a8b52024f199f398ef100
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:50 2016 -0600

    coresight: tmc: splitting driver in ETB/ETF and ETR components
    
    The TMC block can operate in 3 modes (ETB, ETF and ETR) and accessed
    via two interfaces (sysFS and Perf).  That makes 6 mode to cover, which
    is way too much coupling for a single file.
    
    This patch splits the original TMC driver in 2 halves, one for ETB/ETF
    and another one for ETR mode.  A common core is kept for functionality
    common to all 3 modes.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 5a60830c8db5..b3017e115c4d 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -18,6 +18,8 @@
 #ifndef _CORESIGHT_TMC_H
 #define _CORESIGHT_TMC_H
 
+#include <linux/miscdevice.h>
+
 #define TMC_RSZ			0x004
 #define TMC_STS			0x00c
 #define TMC_RRD			0x010
@@ -118,4 +120,20 @@ struct tmc_drvdata {
 	u32			trigger_cntr;
 };
 
+/* Generic functions */
+void tmc_wait_for_tmcready(struct tmc_drvdata *drvdata);
+void tmc_flush_and_stop(struct tmc_drvdata *drvdata);
+void tmc_enable_hw(struct tmc_drvdata *drvdata);
+void tmc_disable_hw(struct tmc_drvdata *drvdata);
+
+/* ETB/ETF functions */
+void tmc_etb_enable_hw(struct tmc_drvdata *drvdata);
+void tmc_etb_disable_hw(struct tmc_drvdata *drvdata);
+extern const struct coresight_ops tmc_etb_cs_ops;
+extern const struct coresight_ops tmc_etf_cs_ops;
+
+/* ETR functions */
+void tmc_etr_enable_hw(struct tmc_drvdata *drvdata);
+void tmc_etr_disable_hw(struct tmc_drvdata *drvdata);
+extern const struct coresight_ops tmc_etr_cs_ops;
 #endif

commit a8ab4268e0db93c564ee6ccb770bb3d53af24be9
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:49 2016 -0600

    coresight: tmc: cleaning up header file
    
    This patch first move the TMC_STS_TMCREADY_BIT and
    TMC_FFCR_FLUSHMAN_BIT defines to their respective section.
    It also removes TMC_FFCR_FLUSHMAN, since the same result
    can easily be obtained using the BIT() macro.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
index 49718b4a9788..5a60830c8db5 100644
--- a/drivers/hwtracing/coresight/coresight-tmc.h
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -49,6 +49,7 @@
 /* TMC_CTL - 0x020 */
 #define TMC_CTL_CAPT_EN		BIT(0)
 /* TMC_STS - 0x00C */
+#define TMC_STS_TMCREADY_BIT	2
 #define TMC_STS_TRIGGERED	BIT(1)
 /* TMC_AXICTL - 0x110 */
 #define TMC_AXICTL_PROT_CTL_B0	BIT(0)
@@ -56,16 +57,14 @@
 #define TMC_AXICTL_SCT_GAT_MODE	BIT(7)
 #define TMC_AXICTL_WR_BURST_16	0xF00
 /* TMC_FFCR - 0x304 */
+#define TMC_FFCR_FLUSHMAN_BIT	6
 #define TMC_FFCR_EN_FMT		BIT(0)
 #define TMC_FFCR_EN_TI		BIT(1)
 #define TMC_FFCR_FON_FLIN	BIT(4)
 #define TMC_FFCR_FON_TRIG_EVT	BIT(5)
-#define TMC_FFCR_FLUSHMAN	BIT(6)
 #define TMC_FFCR_TRIGON_TRIGIN	BIT(8)
 #define TMC_FFCR_STOP_ON_FLUSH	BIT(12)
 
-#define TMC_STS_TMCREADY_BIT	2
-#define TMC_FFCR_FLUSHMAN_BIT	6
 
 enum tmc_config_type {
 	TMC_CONFIG_TYPE_ETB,

commit 4c324b5f0e8a692c8d077da9d18533820c2ab636
Author: Mathieu Poirier <mathieu.poirier@linaro.org>
Date:   Tue May 3 11:33:48 2016 -0600

    coresight: tmc: introducing new header file
    
    The amount of #define, enumeration and structure definition
    is big enough to justify moving them to a new header file.
    
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwtracing/coresight/coresight-tmc.h b/drivers/hwtracing/coresight/coresight-tmc.h
new file mode 100644
index 000000000000..49718b4a9788
--- /dev/null
+++ b/drivers/hwtracing/coresight/coresight-tmc.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright(C) 2015 Linaro Limited. All rights reserved.
+ * Author: Mathieu Poirier <mathieu.poirier@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _CORESIGHT_TMC_H
+#define _CORESIGHT_TMC_H
+
+#define TMC_RSZ			0x004
+#define TMC_STS			0x00c
+#define TMC_RRD			0x010
+#define TMC_RRP			0x014
+#define TMC_RWP			0x018
+#define TMC_TRG			0x01c
+#define TMC_CTL			0x020
+#define TMC_RWD			0x024
+#define TMC_MODE		0x028
+#define TMC_LBUFLEVEL		0x02c
+#define TMC_CBUFLEVEL		0x030
+#define TMC_BUFWM		0x034
+#define TMC_RRPHI		0x038
+#define TMC_RWPHI		0x03c
+#define TMC_AXICTL		0x110
+#define TMC_DBALO		0x118
+#define TMC_DBAHI		0x11c
+#define TMC_FFSR		0x300
+#define TMC_FFCR		0x304
+#define TMC_PSCR		0x308
+#define TMC_ITMISCOP0		0xee0
+#define TMC_ITTRFLIN		0xee8
+#define TMC_ITATBDATA0		0xeec
+#define TMC_ITATBCTR2		0xef0
+#define TMC_ITATBCTR1		0xef4
+#define TMC_ITATBCTR0		0xef8
+
+/* register description */
+/* TMC_CTL - 0x020 */
+#define TMC_CTL_CAPT_EN		BIT(0)
+/* TMC_STS - 0x00C */
+#define TMC_STS_TRIGGERED	BIT(1)
+/* TMC_AXICTL - 0x110 */
+#define TMC_AXICTL_PROT_CTL_B0	BIT(0)
+#define TMC_AXICTL_PROT_CTL_B1	BIT(1)
+#define TMC_AXICTL_SCT_GAT_MODE	BIT(7)
+#define TMC_AXICTL_WR_BURST_16	0xF00
+/* TMC_FFCR - 0x304 */
+#define TMC_FFCR_EN_FMT		BIT(0)
+#define TMC_FFCR_EN_TI		BIT(1)
+#define TMC_FFCR_FON_FLIN	BIT(4)
+#define TMC_FFCR_FON_TRIG_EVT	BIT(5)
+#define TMC_FFCR_FLUSHMAN	BIT(6)
+#define TMC_FFCR_TRIGON_TRIGIN	BIT(8)
+#define TMC_FFCR_STOP_ON_FLUSH	BIT(12)
+
+#define TMC_STS_TMCREADY_BIT	2
+#define TMC_FFCR_FLUSHMAN_BIT	6
+
+enum tmc_config_type {
+	TMC_CONFIG_TYPE_ETB,
+	TMC_CONFIG_TYPE_ETR,
+	TMC_CONFIG_TYPE_ETF,
+};
+
+enum tmc_mode {
+	TMC_MODE_CIRCULAR_BUFFER,
+	TMC_MODE_SOFTWARE_FIFO,
+	TMC_MODE_HARDWARE_FIFO,
+};
+
+enum tmc_mem_intf_width {
+	TMC_MEM_INTF_WIDTH_32BITS	= 0x2,
+	TMC_MEM_INTF_WIDTH_64BITS	= 0x3,
+	TMC_MEM_INTF_WIDTH_128BITS	= 0x4,
+	TMC_MEM_INTF_WIDTH_256BITS	= 0x5,
+};
+
+/**
+ * struct tmc_drvdata - specifics associated to an TMC component
+ * @base:	memory mapped base address for this component.
+ * @dev:	the device entity associated to this component.
+ * @csdev:	component vitals needed by the framework.
+ * @miscdev:	specifics to handle "/dev/xyz.tmc" entry.
+ * @spinlock:	only one at a time pls.
+ * @read_count:	manages preparation of buffer for reading.
+ * @buf:	area of memory where trace data get sent.
+ * @paddr:	DMA start location in RAM.
+ * @vaddr:	virtual representation of @paddr.
+ * @size:	@buf size.
+ * @enable:	this TMC is being used.
+ * @config_type: TMC variant, must be of type @tmc_config_type.
+ * @trigger_cntr: amount of words to store after a trigger.
+ */
+struct tmc_drvdata {
+	void __iomem		*base;
+	struct device		*dev;
+	struct coresight_device	*csdev;
+	struct miscdevice	miscdev;
+	spinlock_t		spinlock;
+	int			read_count;
+	bool			reading;
+	char			*buf;
+	dma_addr_t		paddr;
+	void __iomem		*vaddr;
+	u32			size;
+	bool			enable;
+	enum tmc_config_type	config_type;
+	u32			trigger_cntr;
+};
+
+#endif
