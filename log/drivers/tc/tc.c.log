commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index cf3fad2cb871..c5b17dd8f587 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -47,7 +47,7 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 	for (slot = 0; slot < tbus->num_tcslots; slot++) {
 		slotaddr = tbus->slot_base + slot * slotsize;
 		extslotaddr = tbus->ext_slot_base + slot * extslotsize;
-		module = ioremap_nocache(slotaddr, slotsize);
+		module = ioremap(slotaddr, slotsize);
 		BUG_ON(!module);
 
 		offset = TC_OLDCARD;

commit 3f2aa244ee1a0d17ed5b6c86564d2c1b24d1c96b
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Oct 3 13:21:07 2018 +0100

    TC: Set DMA masks for devices
    
    Fix a TURBOchannel support regression with commit 205e1b7f51e4
    ("dma-mapping: warn when there is no coherent_dma_mask") that caused
    coherent DMA allocations to produce a warning such as:
    
    defxx: v1.11 2014/07/01  Lawrence V. Stefani and others
    tc1: DEFTA at MMIO addr = 0x1e900000, IRQ = 20, Hardware addr = 08-00-2b-a3-a3-29
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at ./include/linux/dma-mapping.h:516 dfx_dev_register+0x670/0x678
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.19.0-rc6 #2
    Stack : ffffffff8009ffc0 fffffffffffffec0 0000000000000000 ffffffff80647650
            0000000000000000 0000000000000000 ffffffff806f5f80 ffffffffffffffff
            0000000000000000 0000000000000000 0000000000000001 ffffffff8065d4e8
            98000000031b6300 ffffffff80563478 ffffffff805685b0 ffffffffffffffff
            0000000000000000 ffffffff805d6720 0000000000000204 ffffffff80388df8
            0000000000000000 0000000000000009 ffffffff8053efd0 ffffffff806657d0
            0000000000000000 ffffffff803177f8 0000000000000000 ffffffff806d0000
            9800000003078000 980000000307b9e0 000000001e900000 ffffffff80067940
            0000000000000000 ffffffff805d6720 0000000000000204 ffffffff80388df8
            ffffffff805176c0 ffffffff8004dc78 0000000000000000 ffffffff80067940
            ...
    Call Trace:
    [<ffffffff8004dc78>] show_stack+0xa0/0x130
    [<ffffffff80067940>] __warn+0x128/0x170
    ---[ end trace b1d1e094f67f3bb2 ]---
    
    This is because the TURBOchannel bus driver fails to set the coherent
    DMA mask for devices enumerated.
    
    Set the regular and coherent DMA masks for TURBOchannel devices then,
    observing that the bus protocol supports a 34-bit (16GiB) DMA address
    space, by interpreting the value presented in the address cycle across
    the 32 `ad' lines as a 32-bit word rather than byte address[1].  The
    architectural size of the TURBOchannel DMA address space exceeds the
    maximum amount of RAM any actual TURBOchannel system in existence may
    have, hence both masks are the same.
    
    This removes the warning shown above.
    
    References:
    
    [1] "TURBOchannel Hardware Specification", EK-369AA-OD-007B, Digital
        Equipment Corporation, January 1993, Section "DMA", pp. 1-15 -- 1-17
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20835/
    Fixes: 205e1b7f51e4 ("dma-mapping: warn when there is no coherent_dma_mask")
    Cc: stable@vger.kernel.org # 4.16+
    Cc: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index 3be9519654e5..cf3fad2cb871 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -2,7 +2,7 @@
  *	TURBOchannel bus services.
  *
  *	Copyright (c) Harald Koerfgen, 1998
- *	Copyright (c) 2001, 2003, 2005, 2006  Maciej W. Rozycki
+ *	Copyright (c) 2001, 2003, 2005, 2006, 2018  Maciej W. Rozycki
  *	Copyright (c) 2005  James Simmons
  *
  *	This file is subject to the terms and conditions of the GNU
@@ -10,6 +10,7 @@
  *	directory of this archive for more details.
  */
 #include <linux/compiler.h>
+#include <linux/dma-mapping.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -92,6 +93,11 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 		tdev->dev.bus = &tc_bus_type;
 		tdev->slot = slot;
 
+		/* TURBOchannel has 34-bit DMA addressing (16GiB space). */
+		tdev->dma_mask = DMA_BIT_MASK(34);
+		tdev->dev.dma_mask = &tdev->dma_mask;
+		tdev->dev.coherent_dma_mask = DMA_BIT_MASK(34);
+
 		for (i = 0; i < 8; i++) {
 			tdev->firmware[i] =
 				readb(module + offset + TC_FIRM_VER + 4 * i);

commit e2afb7de6e7dad21f9d709f80f23bbd3c5bdad11
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Sun Apr 6 20:52:37 2014 +0100

    TC: Error handling clean-ups
    
    Rewrite TURBOchannel error handling to use a common failure path, making
    sure put_device is called for devices that failed initialization.  While
    at it update printk calls to use pr_err rather than KERN_ERR.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6701/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index 946562389ca8..3be9519654e5 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -83,8 +83,7 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 		/* Found a board, allocate it an entry in the list */
 		tdev = kzalloc(sizeof(*tdev), GFP_KERNEL);
 		if (!tdev) {
-			printk(KERN_ERR "tc%x: unable to allocate tc_dev\n",
-			       slot);
+			pr_err("tc%x: unable to allocate tc_dev\n", slot);
 			goto out_err;
 		}
 		dev_set_name(&tdev->dev, "tc%x", slot);
@@ -117,10 +116,10 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 			tdev->resource.start = extslotaddr;
 			tdev->resource.end = extslotaddr + devsize - 1;
 		} else {
-			printk(KERN_ERR "%s: Cannot provide slot space "
-			       "(%dMiB required, up to %dMiB supported)\n",
-			       dev_name(&tdev->dev), devsize >> 20,
-			       max(slotsize, extslotsize) >> 20);
+			pr_err("%s: Cannot provide slot space "
+			       "(%ldMiB required, up to %ldMiB supported)\n",
+			       dev_name(&tdev->dev), (long)(devsize >> 20),
+			       (long)(max(slotsize, extslotsize) >> 20));
 			kfree(tdev);
 			goto out_err;
 		}
@@ -147,14 +146,12 @@ static int __init tc_init(void)
 {
 	/* Initialize the TURBOchannel bus */
 	if (tc_bus_get_info(&tc_bus))
-		return 0;
+		goto out_err;
 
 	INIT_LIST_HEAD(&tc_bus.devices);
 	dev_set_name(&tc_bus.dev, "tc");
-	if (device_register(&tc_bus.dev)) {
-		put_device(&tc_bus.dev);
-		return 0;
-	}
+	if (device_register(&tc_bus.dev))
+		goto out_err_device;
 
 	if (tc_bus.info.slot_size) {
 		unsigned int tc_clock = tc_get_speed(&tc_bus) / 100000;
@@ -172,8 +169,8 @@ static int __init tc_init(void)
 		tc_bus.resource[0].flags = IORESOURCE_MEM;
 		if (request_resource(&iomem_resource,
 				     &tc_bus.resource[0]) < 0) {
-			printk(KERN_ERR "tc: Cannot reserve resource\n");
-			return 0;
+			pr_err("tc: Cannot reserve resource\n");
+			goto out_err_device;
 		}
 		if (tc_bus.ext_slot_size) {
 			tc_bus.resource[1].start = tc_bus.ext_slot_base;
@@ -184,10 +181,8 @@ static int __init tc_init(void)
 			tc_bus.resource[1].flags = IORESOURCE_MEM;
 			if (request_resource(&iomem_resource,
 					     &tc_bus.resource[1]) < 0) {
-				printk(KERN_ERR
-				       "tc: Cannot reserve resource\n");
-				release_resource(&tc_bus.resource[0]);
-				return 0;
+				pr_err("tc: Cannot reserve resource\n");
+				goto out_err_resource;
 			}
 		}
 
@@ -195,6 +190,13 @@ static int __init tc_init(void)
 	}
 
 	return 0;
+
+out_err_resource:
+	release_resource(&tc_bus.resource[0]);
+out_err_device:
+	put_device(&tc_bus.dev);
+out_err:
+	return 0;
 }
 
 subsys_initcall(tc_init);

commit 5bb7889f440532f3dbbffdb6b3b0881a805abbce
Author: Levente Kurusa <levex@linux.com>
Date:   Wed Apr 2 12:00:37 2014 +0200

    TC: Handle device_register() errors.
    
    Make the TURBOchannel driver bail out if the call to device_register()
    failed.
    
    Signed-off-by: Levente Kurusa <levex@linux.com>
    Acked-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Linux MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/6673/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index a8aaf6ac2ae2..946562389ca8 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -129,7 +129,10 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 
 		tc_device_get_irq(tdev);
 
-		device_register(&tdev->dev);
+		if (device_register(&tdev->dev)) {
+			put_device(&tdev->dev);
+			goto out_err;
+		}
 		list_add_tail(&tdev->node, &tbus->devices);
 
 out_err:
@@ -148,7 +151,10 @@ static int __init tc_init(void)
 
 	INIT_LIST_HEAD(&tc_bus.devices);
 	dev_set_name(&tc_bus.dev, "tc");
-	device_register(&tc_bus.dev);
+	if (device_register(&tc_bus.dev)) {
+		put_device(&tc_bus.dev);
+		return 0;
+	}
 
 	if (tc_bus.info.slot_size) {
 		unsigned int tc_clock = tc_get_speed(&tc_bus) / 100000;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index e5bd4470a570..a8aaf6ac2ae2 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -16,6 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/tc.h>
 #include <linux/types.h>

commit df388556d7d845983c0da3a4a49873472c466275
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Mar 24 16:38:22 2009 -0700

    tc: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Cc: macro@linux-mips.org
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index f77f62a4b325..e5bd4470a570 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -86,7 +86,7 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 			       slot);
 			goto out_err;
 		}
-		sprintf(tdev->dev.bus_id, "tc%x", slot);
+		dev_set_name(&tdev->dev, "tc%x", slot);
 		tdev->bus = tbus;
 		tdev->dev.parent = &tbus->dev;
 		tdev->dev.bus = &tc_bus_type;
@@ -104,7 +104,7 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 		tdev->vendor[8] = 0;
 		tdev->name[8] = 0;
 
-		pr_info("%s: %s %s %s\n", tdev->dev.bus_id, tdev->vendor,
+		pr_info("%s: %s %s %s\n", dev_name(&tdev->dev), tdev->vendor,
 			tdev->name, tdev->firmware);
 
 		devsize = readb(module + offset + TC_SLOT_SIZE);
@@ -118,7 +118,7 @@ static void __init tc_bus_add_devices(struct tc_bus *tbus)
 		} else {
 			printk(KERN_ERR "%s: Cannot provide slot space "
 			       "(%dMiB required, up to %dMiB supported)\n",
-			       tdev->dev.bus_id, devsize >> 20,
+			       dev_name(&tdev->dev), devsize >> 20,
 			       max(slotsize, extslotsize) >> 20);
 			kfree(tdev);
 			goto out_err;
@@ -146,7 +146,7 @@ static int __init tc_init(void)
 		return 0;
 
 	INIT_LIST_HEAD(&tc_bus.devices);
-	strcpy(tc_bus.dev.bus_id, "tc");
+	dev_set_name(&tc_bus.dev, "tc");
 	device_register(&tc_bus.dev);
 
 	if (tc_bus.info.slot_size) {

commit 56a47da1b940b6d3812de67fd94af9bfda6ee93a
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Feb 5 16:28:26 2007 -0800

    [TC] MIPS: TURBOchannel resources off-by-one fix
    
    Fix resource reservation of TURBOchannel areas, where the end is one byte
    too far.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index 5514e5283616..f77f62a4b325 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -160,7 +160,7 @@ static int __init tc_init(void)
 		tc_bus.resource[0].start = tc_bus.slot_base;
 		tc_bus.resource[0].end = tc_bus.slot_base +
 					 (tc_bus.info.slot_size << 20) *
-					 tc_bus.num_tcslots;
+					 tc_bus.num_tcslots - 1;
 		tc_bus.resource[0].name = tc_bus.name;
 		tc_bus.resource[0].flags = IORESOURCE_MEM;
 		if (request_resource(&iomem_resource,
@@ -172,7 +172,7 @@ static int __init tc_init(void)
 			tc_bus.resource[1].start = tc_bus.ext_slot_base;
 			tc_bus.resource[1].end = tc_bus.ext_slot_base +
 						 tc_bus.ext_slot_size *
-						 tc_bus.num_tcslots;
+						 tc_bus.num_tcslots - 1;
 			tc_bus.resource[1].name = tc_bus.name;
 			tc_bus.resource[1].flags = IORESOURCE_MEM;
 			if (request_resource(&iomem_resource,

commit b454cc6636d254fbf6049b73e9560aee76fb04a3
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Feb 5 16:28:25 2007 -0800

    [TC] MIPS: TURBOchannel update to the driver model
    
    This is a set of changes to convert support for the TURBOchannel bus to the
    driver model.  It implements the usual set of calls similar to what other bus
    drivers have: tc_register_driver(), tc_unregister_driver(), etc.  All the
    platform-specific bits have been removed and headers from asm-mips/dec/ have
    been merged into linux/tc.h, which should be included by drivers.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index 4a51e56f85b6..5514e5283616 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -1,254 +1,193 @@
 /*
- * tc-init: We assume the TURBOchannel to be up and running so
- * just probe for Modules and fill in the global data structure
- * tc_bus.
+ *	TURBOchannel bus services.
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
+ *	Copyright (c) Harald Koerfgen, 1998
+ *	Copyright (c) 2001, 2003, 2005, 2006  Maciej W. Rozycki
+ *	Copyright (c) 2005  James Simmons
  *
- * Copyright (c) Harald Koerfgen, 1998
- * Copyright (c) 2001, 2003, 2005  Maciej W. Rozycki
+ *	This file is subject to the terms and conditions of the GNU
+ *	General Public License.  See the file "COPYING" in the main
+ *	directory of this archive for more details.
  */
+#include <linux/compiler.h>
+#include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/ioport.h>
 #include <linux/kernel.h>
+#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/string.h>
+#include <linux/tc.h>
 #include <linux/types.h>
 
-#include <asm/addrspace.h>
-#include <asm/errno.h>
 #include <asm/io.h>
-#include <asm/paccess.h>
 
-#include <asm/dec/machtype.h>
-#include <asm/dec/prom.h>
-#include <asm/dec/tcinfo.h>
-#include <asm/dec/tcmodule.h>
-#include <asm/dec/interrupts.h>
-
-MODULE_LICENSE("GPL");
-slot_info tc_bus[MAX_SLOT];
-static int num_tcslots;
-static tcinfo *info;
+static struct tc_bus tc_bus = {
+	.name = "TURBOchannel",
+};
 
 /*
- * Interface to the world. Read comment in include/asm-mips/tc.h.
+ * Probing for TURBOchannel modules.
  */
-
-int search_tc_card(const char *name)
-{
-	int slot;
-	slot_info *sip;
-
-	for (slot = 0; slot < num_tcslots; slot++) {
-		sip = &tc_bus[slot];
-		if ((sip->flags & FREE) &&
-		    (strncmp(sip->name, name, strlen(name)) == 0)) {
-			return slot;
-		}
-	}
-
-	return -ENODEV;
-}
-
-void claim_tc_card(int slot)
-{
-	if (tc_bus[slot].flags & IN_USE) {
-		printk("claim_tc_card: attempting to claim a card already in use\n");
-		return;
-	}
-	tc_bus[slot].flags &= ~FREE;
-	tc_bus[slot].flags |= IN_USE;
-}
-
-void release_tc_card(int slot)
+static void __init tc_bus_add_devices(struct tc_bus *tbus)
 {
-	if (tc_bus[slot].flags & FREE) {
-		printk("release_tc_card: "
-		       "attempting to release a card already free\n");
-		return;
-	}
-	tc_bus[slot].flags &= ~IN_USE;
-	tc_bus[slot].flags |= FREE;
-}
-
-unsigned long get_tc_base_addr(int slot)
-{
-	return tc_bus[slot].base_addr;
-}
-
-unsigned long get_tc_irq_nr(int slot)
-{
-	return tc_bus[slot].interrupt;
-}
-
-unsigned long get_tc_speed(void)
-{
-	return 100000 * (10000 / (unsigned long)info->clk_period);
-}
-
-/*
- * Probing for TURBOchannel modules
- */
-static void __init tc_probe(unsigned long startaddr, unsigned long size,
-			    int slots)
-{
-	unsigned long slotaddr;
+	resource_size_t slotsize = tbus->info.slot_size << 20;
+	resource_size_t extslotsize = tbus->ext_slot_size;
+	resource_size_t slotaddr;
+	resource_size_t extslotaddr;
+	resource_size_t devsize;
+	void __iomem *module;
+	struct tc_dev *tdev;
 	int i, slot, err;
-	long offset;
 	u8 pattern[4];
-	volatile u8 *module;
+	long offset;
 
-	for (slot = 0; slot < slots; slot++) {
-		slotaddr = startaddr + slot * size;
-		module = ioremap_nocache(slotaddr, size);
+	for (slot = 0; slot < tbus->num_tcslots; slot++) {
+		slotaddr = tbus->slot_base + slot * slotsize;
+		extslotaddr = tbus->ext_slot_base + slot * extslotsize;
+		module = ioremap_nocache(slotaddr, slotsize);
 		BUG_ON(!module);
 
-		offset = OLDCARD;
+		offset = TC_OLDCARD;
 
 		err = 0;
-		err |= get_dbe(pattern[0], module + OLDCARD + TC_PATTERN0);
-		err |= get_dbe(pattern[1], module + OLDCARD + TC_PATTERN1);
-		err |= get_dbe(pattern[2], module + OLDCARD + TC_PATTERN2);
-		err |= get_dbe(pattern[3], module + OLDCARD + TC_PATTERN3);
-		if (err) {
-			iounmap(module);
-			continue;
-		}
+		err |= tc_preadb(pattern + 0, module + offset + TC_PATTERN0);
+		err |= tc_preadb(pattern + 1, module + offset + TC_PATTERN1);
+		err |= tc_preadb(pattern + 2, module + offset + TC_PATTERN2);
+		err |= tc_preadb(pattern + 3, module + offset + TC_PATTERN3);
+		if (err)
+			goto out_err;
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
 		    pattern[2] != 0xaa || pattern[3] != 0xff) {
-			offset = NEWCARD;
+			offset = TC_NEWCARD;
 
 			err = 0;
-			err |= get_dbe(pattern[0], module + TC_PATTERN0);
-			err |= get_dbe(pattern[1], module + TC_PATTERN1);
-			err |= get_dbe(pattern[2], module + TC_PATTERN2);
-			err |= get_dbe(pattern[3], module + TC_PATTERN3);
-			if (err) {
-				iounmap(module);
-				continue;
-			}
+			err |= tc_preadb(pattern + 0,
+					 module + offset + TC_PATTERN0);
+			err |= tc_preadb(pattern + 1,
+					 module + offset + TC_PATTERN1);
+			err |= tc_preadb(pattern + 2,
+					 module + offset + TC_PATTERN2);
+			err |= tc_preadb(pattern + 3,
+					 module + offset + TC_PATTERN3);
+			if (err)
+				goto out_err;
 		}
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
-		    pattern[2] != 0xaa || pattern[3] != 0xff) {
-			iounmap(module);
-			continue;
+		    pattern[2] != 0xaa || pattern[3] != 0xff)
+			goto out_err;
+
+		/* Found a board, allocate it an entry in the list */
+		tdev = kzalloc(sizeof(*tdev), GFP_KERNEL);
+		if (!tdev) {
+			printk(KERN_ERR "tc%x: unable to allocate tc_dev\n",
+			       slot);
+			goto out_err;
 		}
+		sprintf(tdev->dev.bus_id, "tc%x", slot);
+		tdev->bus = tbus;
+		tdev->dev.parent = &tbus->dev;
+		tdev->dev.bus = &tc_bus_type;
+		tdev->slot = slot;
 
-		tc_bus[slot].base_addr = slotaddr;
 		for (i = 0; i < 8; i++) {
-			tc_bus[slot].firmware[i] =
-				module[TC_FIRM_VER + offset + 4 * i];
-			tc_bus[slot].vendor[i] =
-				module[TC_VENDOR + offset + 4 * i];
-			tc_bus[slot].name[i] =
-				module[TC_MODULE + offset + 4 * i];
+			tdev->firmware[i] =
+				readb(module + offset + TC_FIRM_VER + 4 * i);
+			tdev->vendor[i] =
+				readb(module + offset + TC_VENDOR + 4 * i);
+			tdev->name[i] =
+				readb(module + offset + TC_MODULE + 4 * i);
 		}
-		tc_bus[slot].firmware[8] = 0;
-		tc_bus[slot].vendor[8] = 0;
-		tc_bus[slot].name[8] = 0;
-		/*
-		 * Looks unneccesary, but we may change
-		 * TC? in the future
-		 */
-		switch (slot) {
-		case 0:
-			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC0];
-			break;
-		case 1:
-			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC1];
-			break;
-		case 2:
-			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC2];
-			break;
-		/*
-		 * Yuck! DS5000/200 onboard devices
-		 */
-		case 5:
-			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC5];
-			break;
-		case 6:
-			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC6];
-			break;
-		default:
-			tc_bus[slot].interrupt = -1;
-			break;
+		tdev->firmware[8] = 0;
+		tdev->vendor[8] = 0;
+		tdev->name[8] = 0;
+
+		pr_info("%s: %s %s %s\n", tdev->dev.bus_id, tdev->vendor,
+			tdev->name, tdev->firmware);
+
+		devsize = readb(module + offset + TC_SLOT_SIZE);
+		devsize <<= 22;
+		if (devsize <= slotsize) {
+			tdev->resource.start = slotaddr;
+			tdev->resource.end = slotaddr + devsize - 1;
+		} else if (devsize <= extslotsize) {
+			tdev->resource.start = extslotaddr;
+			tdev->resource.end = extslotaddr + devsize - 1;
+		} else {
+			printk(KERN_ERR "%s: Cannot provide slot space "
+			       "(%dMiB required, up to %dMiB supported)\n",
+			       tdev->dev.bus_id, devsize >> 20,
+			       max(slotsize, extslotsize) >> 20);
+			kfree(tdev);
+			goto out_err;
 		}
+		tdev->resource.name = tdev->name;
+		tdev->resource.flags = IORESOURCE_MEM;
+
+		tc_device_get_irq(tdev);
 
+		device_register(&tdev->dev);
+		list_add_tail(&tdev->node, &tbus->devices);
+
+out_err:
 		iounmap(module);
 	}
 }
 
 /*
- * the main entry
+ * The main entry.
  */
 static int __init tc_init(void)
 {
-	int tc_clock;
-	int i;
-	unsigned long slot0addr;
-	unsigned long slot_size;
-
-	if (!TURBOCHANNEL)
+	/* Initialize the TURBOchannel bus */
+	if (tc_bus_get_info(&tc_bus))
 		return 0;
 
-	for (i = 0; i < MAX_SLOT; i++) {
-		tc_bus[i].base_addr = 0;
-		tc_bus[i].name[0] = 0;
-		tc_bus[i].vendor[0] = 0;
-		tc_bus[i].firmware[0] = 0;
-		tc_bus[i].interrupt = -1;
-		tc_bus[i].flags = FREE;
-	}
-
-	info = rex_gettcinfo();
-	slot0addr = CPHYSADDR((long)rex_slot_address(0));
-
-	switch (mips_machtype) {
-	case MACH_DS5000_200:
-		num_tcslots = 7;
-		break;
-	case MACH_DS5000_1XX:
-	case MACH_DS5000_2X0:
-	case MACH_DS5900:
-		num_tcslots = 3;
-		break;
-	case MACH_DS5000_XX:
-	default:
-		num_tcslots = 2;
-		break;
-	}
-
-	tc_clock = 10000 / info->clk_period;
-
-	if (info->slot_size && slot0addr) {
-		pr_info("TURBOchannel rev. %d at %d.%d MHz (with%s parity)\n",
-			info->revision, tc_clock / 10, tc_clock % 10,
-			info->parity ? "" : "out");
-
-		slot_size = info->slot_size << 20;
-
-		tc_probe(slot0addr, slot_size, num_tcslots);
-
-		for (i = 0; i < num_tcslots; i++) {
-			if (!tc_bus[i].base_addr)
-				continue;
-			pr_info("    slot %d: %s %s %s\n", i, tc_bus[i].vendor,
-				tc_bus[i].name, tc_bus[i].firmware);
+	INIT_LIST_HEAD(&tc_bus.devices);
+	strcpy(tc_bus.dev.bus_id, "tc");
+	device_register(&tc_bus.dev);
+
+	if (tc_bus.info.slot_size) {
+		unsigned int tc_clock = tc_get_speed(&tc_bus) / 100000;
+
+		pr_info("tc: TURBOchannel rev. %d at %d.%d MHz "
+			"(with%s parity)\n", tc_bus.info.revision,
+			tc_clock / 10, tc_clock % 10,
+			tc_bus.info.parity ? "" : "out");
+
+		tc_bus.resource[0].start = tc_bus.slot_base;
+		tc_bus.resource[0].end = tc_bus.slot_base +
+					 (tc_bus.info.slot_size << 20) *
+					 tc_bus.num_tcslots;
+		tc_bus.resource[0].name = tc_bus.name;
+		tc_bus.resource[0].flags = IORESOURCE_MEM;
+		if (request_resource(&iomem_resource,
+				     &tc_bus.resource[0]) < 0) {
+			printk(KERN_ERR "tc: Cannot reserve resource\n");
+			return 0;
+		}
+		if (tc_bus.ext_slot_size) {
+			tc_bus.resource[1].start = tc_bus.ext_slot_base;
+			tc_bus.resource[1].end = tc_bus.ext_slot_base +
+						 tc_bus.ext_slot_size *
+						 tc_bus.num_tcslots;
+			tc_bus.resource[1].name = tc_bus.name;
+			tc_bus.resource[1].flags = IORESOURCE_MEM;
+			if (request_resource(&iomem_resource,
+					     &tc_bus.resource[1]) < 0) {
+				printk(KERN_ERR
+				       "tc: Cannot reserve resource\n");
+				release_resource(&tc_bus.resource[0]);
+				return 0;
+			}
 		}
+
+		tc_bus_add_devices(&tc_bus);
 	}
 
 	return 0;
 }
 
 subsys_initcall(tc_init);
-
-EXPORT_SYMBOL(search_tc_card);
-EXPORT_SYMBOL(claim_tc_card);
-EXPORT_SYMBOL(release_tc_card);
-EXPORT_SYMBOL(get_tc_base_addr);
-EXPORT_SYMBOL(get_tc_irq_nr);
-EXPORT_SYMBOL(get_tc_speed);

commit 1b8623545b42c03eb92e51b28c84acf4b8ba00a3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 15 01:07:03 2005 -0500

    [PATCH] remove bogus asm/bug.h includes.
    
    A bunch of asm/bug.h includes are both not needed (since it will get
    pulled anyway) and bogus (since they are done too early).  Removed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index a0e5af638e0e..4a51e56f85b6 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -17,7 +17,6 @@
 #include <linux/types.h>
 
 #include <asm/addrspace.h>
-#include <asm/bug.h>
 #include <asm/errno.h>
 #include <asm/io.h>
 #include <asm/paccess.h>

commit a5fc9c0bbee8b91025993a49a9176a88380aef3c
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Jul 1 16:10:40 2005 +0000

    Use physical addresses at the interface level, letting drivers remap
    them as appropriate.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index d742c3a90b23..a0e5af638e0e 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -10,31 +10,29 @@
  * Copyright (c) Harald Koerfgen, 1998
  * Copyright (c) 2001, 2003, 2005  Maciej W. Rozycki
  */
-#include <linux/string.h>
 #include <linux/init.h>
-#include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/string.h>
+#include <linux/types.h>
 
 #include <asm/addrspace.h>
+#include <asm/bug.h>
 #include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/paccess.h>
+
 #include <asm/dec/machtype.h>
 #include <asm/dec/prom.h>
 #include <asm/dec/tcinfo.h>
 #include <asm/dec/tcmodule.h>
 #include <asm/dec/interrupts.h>
-#include <asm/paccess.h>
-#include <asm/ptrace.h>
-
-#define TC_DEBUG
 
 MODULE_LICENSE("GPL");
 slot_info tc_bus[MAX_SLOT];
 static int num_tcslots;
 static tcinfo *info;
 
-unsigned long system_base;
-
 /*
  * Interface to the world. Read comment in include/asm-mips/tc.h.
  */
@@ -97,13 +95,16 @@ unsigned long get_tc_speed(void)
 static void __init tc_probe(unsigned long startaddr, unsigned long size,
 			    int slots)
 {
+	unsigned long slotaddr;
 	int i, slot, err;
 	long offset;
-	unsigned char pattern[4];
-	unsigned char *module;
+	u8 pattern[4];
+	volatile u8 *module;
 
 	for (slot = 0; slot < slots; slot++) {
-		module = (char *)(startaddr + slot * size);
+		slotaddr = startaddr + slot * size;
+		module = ioremap_nocache(slotaddr, size);
+		BUG_ON(!module);
 
 		offset = OLDCARD;
 
@@ -112,8 +113,10 @@ static void __init tc_probe(unsigned long startaddr, unsigned long size,
 		err |= get_dbe(pattern[1], module + OLDCARD + TC_PATTERN1);
 		err |= get_dbe(pattern[2], module + OLDCARD + TC_PATTERN2);
 		err |= get_dbe(pattern[3], module + OLDCARD + TC_PATTERN3);
-		if (err)
+		if (err) {
+			iounmap(module);
 			continue;
+		}
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
 		    pattern[2] != 0xaa || pattern[3] != 0xff) {
@@ -124,16 +127,20 @@ static void __init tc_probe(unsigned long startaddr, unsigned long size,
 			err |= get_dbe(pattern[1], module + TC_PATTERN1);
 			err |= get_dbe(pattern[2], module + TC_PATTERN2);
 			err |= get_dbe(pattern[3], module + TC_PATTERN3);
-			if (err)
+			if (err) {
+				iounmap(module);
 				continue;
+			}
 		}
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
-		    pattern[2] != 0xaa || pattern[3] != 0xff)
+		    pattern[2] != 0xaa || pattern[3] != 0xff) {
+			iounmap(module);
 			continue;
+		}
 
-		tc_bus[slot].base_addr = (unsigned long)module;
-		for(i = 0; i < 8; i++) {
+		tc_bus[slot].base_addr = slotaddr;
+		for (i = 0; i < 8; i++) {
 			tc_bus[slot].firmware[i] =
 				module[TC_FIRM_VER + offset + 4 * i];
 			tc_bus[slot].vendor[i] =
@@ -171,6 +178,8 @@ static void __init tc_probe(unsigned long startaddr, unsigned long size,
 			tc_bus[slot].interrupt = -1;
 			break;
 		}
+
+		iounmap(module);
 	}
 }
 
@@ -196,8 +205,8 @@ static int __init tc_init(void)
 		tc_bus[i].flags = FREE;
 	}
 
-	info = (tcinfo *) rex_gettcinfo();
-	slot0addr = (unsigned long)CKSEG1ADDR(rex_slot_address(0));
+	info = rex_gettcinfo();
+	slot0addr = CPHYSADDR((long)rex_slot_address(0));
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
@@ -216,35 +225,21 @@ static int __init tc_init(void)
 
 	tc_clock = 10000 / info->clk_period;
 
-	if (TURBOCHANNEL && info->slot_size && slot0addr) {
-		printk("TURBOchannel rev. %1d at %2d.%1d MHz ", info->revision,
-			tc_clock / 10, tc_clock % 10);
-		printk("(with%s parity)\n", info->parity ? "" : "out");
+	if (info->slot_size && slot0addr) {
+		pr_info("TURBOchannel rev. %d at %d.%d MHz (with%s parity)\n",
+			info->revision, tc_clock / 10, tc_clock % 10,
+			info->parity ? "" : "out");
 
 		slot_size = info->slot_size << 20;
 
 		tc_probe(slot0addr, slot_size, num_tcslots);
 
-  		/*
-  		 * All TURBOchannel DECstations have the onboard devices
- 		 * where the (num_tcslots + 0 or 1 on DS5k/xx) Option Module
- 		 * would be.
- 		 */
- 		if(mips_machtype == MACH_DS5000_XX)
- 			i = 1;
-		else
- 			i = 0;
-
- 	        system_base = slot0addr + slot_size * (num_tcslots + i);
-
-#ifdef TC_DEBUG
-		for (i = 0; i < num_tcslots; i++)
-			if (tc_bus[i].base_addr) {
-				printk("    slot %d: ", i);
-				printk("%s %s %s\n", tc_bus[i].vendor,
-					tc_bus[i].name, tc_bus[i].firmware);
-			}
-#endif
+		for (i = 0; i < num_tcslots; i++) {
+			if (!tc_bus[i].base_addr)
+				continue;
+			pr_info("    slot %d: %s %s %s\n", i, tc_bus[i].vendor,
+				tc_bus[i].name, tc_bus[i].firmware);
+		}
 	}
 
 	return 0;
@@ -258,4 +253,3 @@ EXPORT_SYMBOL(release_tc_card);
 EXPORT_SYMBOL(get_tc_base_addr);
 EXPORT_SYMBOL(get_tc_irq_nr);
 EXPORT_SYMBOL(get_tc_speed);
-EXPORT_SYMBOL(system_base);

commit 778220f7c4a3357f7464a45044fd4937126ba6c5
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Thu Jun 16 20:37:40 2005 +0000

    Fix function types to ones appropriate for initcalls.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index 2613c5135c09..d742c3a90b23 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -8,7 +8,7 @@
  * for more details.
  *
  * Copyright (c) Harald Koerfgen, 1998
- * Copyright (c) 2001, 2003  Maciej W. Rozycki
+ * Copyright (c) 2001, 2003, 2005  Maciej W. Rozycki
  */
 #include <linux/string.h>
 #include <linux/init.h>
@@ -177,7 +177,7 @@ static void __init tc_probe(unsigned long startaddr, unsigned long size,
 /*
  * the main entry
  */
-void __init tc_init(void)
+static int __init tc_init(void)
 {
 	int tc_clock;
 	int i;
@@ -185,7 +185,7 @@ void __init tc_init(void)
 	unsigned long slot_size;
 
 	if (!TURBOCHANNEL)
-		return;
+		return 0;
 
 	for (i = 0; i < MAX_SLOT; i++) {
 		tc_bus[i].base_addr = 0;
@@ -246,6 +246,8 @@ void __init tc_init(void)
 			}
 #endif
 	}
+
+	return 0;
 }
 
 subsys_initcall(tc_init);

commit 3bd4c902da14030c9a780cd0c4be2ffe9aee2974
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Thu Jun 16 20:30:54 2005 +0000

    Deal with the bloody KSEG vs CKSEG horror...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
index a89ef4df80c3..2613c5135c09 100644
--- a/drivers/tc/tc.c
+++ b/drivers/tc/tc.c
@@ -197,7 +197,7 @@ void __init tc_init(void)
 	}
 
 	info = (tcinfo *) rex_gettcinfo();
-	slot0addr = (unsigned long)KSEG1ADDR(rex_slot_address(0));
+	slot0addr = (unsigned long)CKSEG1ADDR(rex_slot_address(0));
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
@@ -245,7 +245,6 @@ void __init tc_init(void)
 					tc_bus[i].name, tc_bus[i].firmware);
 			}
 #endif
-		ioport_resource.end = KSEG2 - 1;
 	}
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/tc/tc.c b/drivers/tc/tc.c
new file mode 100644
index 000000000000..a89ef4df80c3
--- /dev/null
+++ b/drivers/tc/tc.c
@@ -0,0 +1,260 @@
+/*
+ * tc-init: We assume the TURBOchannel to be up and running so
+ * just probe for Modules and fill in the global data structure
+ * tc_bus.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) Harald Koerfgen, 1998
+ * Copyright (c) 2001, 2003  Maciej W. Rozycki
+ */
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <asm/addrspace.h>
+#include <asm/errno.h>
+#include <asm/dec/machtype.h>
+#include <asm/dec/prom.h>
+#include <asm/dec/tcinfo.h>
+#include <asm/dec/tcmodule.h>
+#include <asm/dec/interrupts.h>
+#include <asm/paccess.h>
+#include <asm/ptrace.h>
+
+#define TC_DEBUG
+
+MODULE_LICENSE("GPL");
+slot_info tc_bus[MAX_SLOT];
+static int num_tcslots;
+static tcinfo *info;
+
+unsigned long system_base;
+
+/*
+ * Interface to the world. Read comment in include/asm-mips/tc.h.
+ */
+
+int search_tc_card(const char *name)
+{
+	int slot;
+	slot_info *sip;
+
+	for (slot = 0; slot < num_tcslots; slot++) {
+		sip = &tc_bus[slot];
+		if ((sip->flags & FREE) &&
+		    (strncmp(sip->name, name, strlen(name)) == 0)) {
+			return slot;
+		}
+	}
+
+	return -ENODEV;
+}
+
+void claim_tc_card(int slot)
+{
+	if (tc_bus[slot].flags & IN_USE) {
+		printk("claim_tc_card: attempting to claim a card already in use\n");
+		return;
+	}
+	tc_bus[slot].flags &= ~FREE;
+	tc_bus[slot].flags |= IN_USE;
+}
+
+void release_tc_card(int slot)
+{
+	if (tc_bus[slot].flags & FREE) {
+		printk("release_tc_card: "
+		       "attempting to release a card already free\n");
+		return;
+	}
+	tc_bus[slot].flags &= ~IN_USE;
+	tc_bus[slot].flags |= FREE;
+}
+
+unsigned long get_tc_base_addr(int slot)
+{
+	return tc_bus[slot].base_addr;
+}
+
+unsigned long get_tc_irq_nr(int slot)
+{
+	return tc_bus[slot].interrupt;
+}
+
+unsigned long get_tc_speed(void)
+{
+	return 100000 * (10000 / (unsigned long)info->clk_period);
+}
+
+/*
+ * Probing for TURBOchannel modules
+ */
+static void __init tc_probe(unsigned long startaddr, unsigned long size,
+			    int slots)
+{
+	int i, slot, err;
+	long offset;
+	unsigned char pattern[4];
+	unsigned char *module;
+
+	for (slot = 0; slot < slots; slot++) {
+		module = (char *)(startaddr + slot * size);
+
+		offset = OLDCARD;
+
+		err = 0;
+		err |= get_dbe(pattern[0], module + OLDCARD + TC_PATTERN0);
+		err |= get_dbe(pattern[1], module + OLDCARD + TC_PATTERN1);
+		err |= get_dbe(pattern[2], module + OLDCARD + TC_PATTERN2);
+		err |= get_dbe(pattern[3], module + OLDCARD + TC_PATTERN3);
+		if (err)
+			continue;
+
+		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
+		    pattern[2] != 0xaa || pattern[3] != 0xff) {
+			offset = NEWCARD;
+
+			err = 0;
+			err |= get_dbe(pattern[0], module + TC_PATTERN0);
+			err |= get_dbe(pattern[1], module + TC_PATTERN1);
+			err |= get_dbe(pattern[2], module + TC_PATTERN2);
+			err |= get_dbe(pattern[3], module + TC_PATTERN3);
+			if (err)
+				continue;
+		}
+
+		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
+		    pattern[2] != 0xaa || pattern[3] != 0xff)
+			continue;
+
+		tc_bus[slot].base_addr = (unsigned long)module;
+		for(i = 0; i < 8; i++) {
+			tc_bus[slot].firmware[i] =
+				module[TC_FIRM_VER + offset + 4 * i];
+			tc_bus[slot].vendor[i] =
+				module[TC_VENDOR + offset + 4 * i];
+			tc_bus[slot].name[i] =
+				module[TC_MODULE + offset + 4 * i];
+		}
+		tc_bus[slot].firmware[8] = 0;
+		tc_bus[slot].vendor[8] = 0;
+		tc_bus[slot].name[8] = 0;
+		/*
+		 * Looks unneccesary, but we may change
+		 * TC? in the future
+		 */
+		switch (slot) {
+		case 0:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC0];
+			break;
+		case 1:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC1];
+			break;
+		case 2:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC2];
+			break;
+		/*
+		 * Yuck! DS5000/200 onboard devices
+		 */
+		case 5:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC5];
+			break;
+		case 6:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC6];
+			break;
+		default:
+			tc_bus[slot].interrupt = -1;
+			break;
+		}
+	}
+}
+
+/*
+ * the main entry
+ */
+void __init tc_init(void)
+{
+	int tc_clock;
+	int i;
+	unsigned long slot0addr;
+	unsigned long slot_size;
+
+	if (!TURBOCHANNEL)
+		return;
+
+	for (i = 0; i < MAX_SLOT; i++) {
+		tc_bus[i].base_addr = 0;
+		tc_bus[i].name[0] = 0;
+		tc_bus[i].vendor[0] = 0;
+		tc_bus[i].firmware[0] = 0;
+		tc_bus[i].interrupt = -1;
+		tc_bus[i].flags = FREE;
+	}
+
+	info = (tcinfo *) rex_gettcinfo();
+	slot0addr = (unsigned long)KSEG1ADDR(rex_slot_address(0));
+
+	switch (mips_machtype) {
+	case MACH_DS5000_200:
+		num_tcslots = 7;
+		break;
+	case MACH_DS5000_1XX:
+	case MACH_DS5000_2X0:
+	case MACH_DS5900:
+		num_tcslots = 3;
+		break;
+	case MACH_DS5000_XX:
+	default:
+		num_tcslots = 2;
+		break;
+	}
+
+	tc_clock = 10000 / info->clk_period;
+
+	if (TURBOCHANNEL && info->slot_size && slot0addr) {
+		printk("TURBOchannel rev. %1d at %2d.%1d MHz ", info->revision,
+			tc_clock / 10, tc_clock % 10);
+		printk("(with%s parity)\n", info->parity ? "" : "out");
+
+		slot_size = info->slot_size << 20;
+
+		tc_probe(slot0addr, slot_size, num_tcslots);
+
+  		/*
+  		 * All TURBOchannel DECstations have the onboard devices
+ 		 * where the (num_tcslots + 0 or 1 on DS5k/xx) Option Module
+ 		 * would be.
+ 		 */
+ 		if(mips_machtype == MACH_DS5000_XX)
+ 			i = 1;
+		else
+ 			i = 0;
+
+ 	        system_base = slot0addr + slot_size * (num_tcslots + i);
+
+#ifdef TC_DEBUG
+		for (i = 0; i < num_tcslots; i++)
+			if (tc_bus[i].base_addr) {
+				printk("    slot %d: ", i);
+				printk("%s %s %s\n", tc_bus[i].vendor,
+					tc_bus[i].name, tc_bus[i].firmware);
+			}
+#endif
+		ioport_resource.end = KSEG2 - 1;
+	}
+}
+
+subsys_initcall(tc_init);
+
+EXPORT_SYMBOL(search_tc_card);
+EXPORT_SYMBOL(claim_tc_card);
+EXPORT_SYMBOL(release_tc_card);
+EXPORT_SYMBOL(get_tc_base_addr);
+EXPORT_SYMBOL(get_tc_irq_nr);
+EXPORT_SYMBOL(get_tc_speed);
+EXPORT_SYMBOL(system_base);
