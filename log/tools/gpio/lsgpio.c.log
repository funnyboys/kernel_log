commit 3831c051dfbf58595085e432acc00ad4efcf54cc
Author: Kent Gibson <warthog618@gmail.com>
Date:   Thu Apr 30 08:09:16 2020 +0800

    tools: gpio: add bias flags to lsgpio
    
    Add display of the bias flags.
    
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index e1430f504c13..8a71ad36f83b 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -49,6 +49,18 @@ struct gpio_flag flagnames[] = {
 		.name = "open-source",
 		.mask = GPIOLINE_FLAG_OPEN_SOURCE,
 	},
+	{
+		.name = "pull-up",
+		.mask = GPIOLINE_FLAG_BIAS_PULL_UP,
+	},
+	{
+		.name = "pull-down",
+		.mask = GPIOLINE_FLAG_BIAS_PULL_DOWN,
+	},
+	{
+		.name = "bias-disabled",
+		.mask = GPIOLINE_FLAG_BIAS_DISABLE,
+	},
 };
 
 void print_flags(unsigned long flags)

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index eb3f56efd215..e1430f504c13 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * lsgpio - example on how to list the GPIO lines on a system
  *
  * Copyright (C) 2015 Linus Walleij
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
  * Usage:
  *	lsgpio <-n device-name>
  */

commit 691998fac6f50c9117e279c3fbfa63a23cf7ce2e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Mar 25 13:36:30 2016 +0100

    tools/gpio: Add missing initialization of device_name
    
    lsgpio.c: In function ‘main’:
    lsgpio.c:166:7: warning: ‘device_name’ may be used uninitialized in this functio
    n [-Wmaybe-uninitialized]
       ret = list_device(device_name);
           ^
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index 1124da375942..eb3f56efd215 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -147,7 +147,7 @@ void print_usage(void)
 
 int main(int argc, char **argv)
 {
-	const char *device_name;
+	const char *device_name = NULL;
 	int ret;
 	int c;
 

commit 214338e372af2b856af07978daa771dbe087f990
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 25 21:01:48 2016 +0100

    gpio: present the consumer of a line to userspace
    
    I named the field representing the current user of GPIO line as
    "label" but this is too vague and ambiguous. Before anyone gets
    confused, rename it to "consumer" and indicate clearly in the
    documentation that this is a string set by the user of the line.
    
    Also clean up leftovers in the documentation.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index 6af118cc7efb..1124da375942 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -116,10 +116,10 @@ int list_device(const char *device_name)
 			fprintf(stdout, " \"%s\"", linfo.name);
 		else
 			fprintf(stdout, " unnamed");
-		if (linfo.label[0])
-			fprintf(stdout, " \"%s\"", linfo.label);
+		if (linfo.consumer[0])
+			fprintf(stdout, " \"%s\"", linfo.consumer);
 		else
-			fprintf(stdout, " unlabeled");
+			fprintf(stdout, " unused");
 		if (linfo.flags) {
 			fprintf(stdout, " [");
 			print_flags(linfo.flags);

commit bb91d345b49f9ca8ccf3ed9cc3346decdd9c4c3f
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Tue Feb 23 08:54:46 2016 +0100

    tools: gpio: Small updates for output format
    
    Use %2d for the GPIO line number. This should align the results
    horziontally for most gpio chips.
    
    The GPIO label uses quotes for real values. For GPIO names this is
    currently missing. The patch adds the missing quote.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index 5535ce81f8f7..6af118cc7efb 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -111,9 +111,9 @@ int list_device(const char *device_name)
 			perror("Failed to issue LINEINFO IOCTL\n");
 			goto exit_close_error;
 		}
-		fprintf(stdout, "\tline %d:", linfo.line_offset);
+		fprintf(stdout, "\tline %2d:", linfo.line_offset);
 		if (linfo.name[0])
-			fprintf(stdout, " %s", linfo.name);
+			fprintf(stdout, " \"%s\"", linfo.name);
 		else
 			fprintf(stdout, " unnamed");
 		if (linfo.label[0])

commit 521a2ad6f862a28e2e43cb3e254a26bf0f9452e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 12 22:25:22 2016 +0100

    gpio: add userspace ABI for GPIO line information
    
    This adds a GPIO line ABI for getting name, label and a few select
    flags from the kernel.
    
    This hides the kernel internals and only tells userspace what it
    may need to know: the different in-kernel consumers are masked
    behind the flag "kernel" and that is all userspace needs to know.
    
    However electric characteristics like active low, open drain etc
    are reflected to userspace, as this is important information.
    
    We provide information on all lines on all chips, later on we will
    likely add a flag for the chardev consumer so we can filter and
    display only the lines userspace actually uses in e.g. lsgpio,
    but then we first need an ABI for userspace to grab and use
    (get/set/select direction) a GPIO line.
    
    Sample output from "lsgpio" on ux500:
    
    GPIO chip: gpiochip7, "8011e000.gpio", 32 GPIO lines
            line 0: unnamed unlabeled
            line 1: unnamed unlabeled
    (...)
            line 25: unnamed "SFH7741 Proximity Sensor" [kernel output open-drain]
            line 26: unnamed unlabeled
    (...)
    
    Tested-by: Michael Welling <mwelling@ieee.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index 692233f561fb..5535ce81f8f7 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -26,12 +26,56 @@
 
 #include "gpio-utils.h"
 
+struct gpio_flag {
+	char *name;
+	unsigned long mask;
+};
+
+struct gpio_flag flagnames[] = {
+	{
+		.name = "kernel",
+		.mask = GPIOLINE_FLAG_KERNEL,
+	},
+	{
+		.name = "output",
+		.mask = GPIOLINE_FLAG_IS_OUT,
+	},
+	{
+		.name = "active-low",
+		.mask = GPIOLINE_FLAG_ACTIVE_LOW,
+	},
+	{
+		.name = "open-drain",
+		.mask = GPIOLINE_FLAG_OPEN_DRAIN,
+	},
+	{
+		.name = "open-source",
+		.mask = GPIOLINE_FLAG_OPEN_SOURCE,
+	},
+};
+
+void print_flags(unsigned long flags)
+{
+	int i;
+	int printed = 0;
+
+	for (i = 0; i < ARRAY_SIZE(flagnames); i++) {
+		if (flags & flagnames[i].mask) {
+			if (printed)
+				fprintf(stdout, " ");
+			fprintf(stdout, "%s", flagnames[i].name);
+			printed++;
+		}
+	}
+}
+
 int list_device(const char *device_name)
 {
 	struct gpiochip_info cinfo;
 	char *chrdev_name;
 	int fd;
 	int ret;
+	int i;
 
 	ret = asprintf(&chrdev_name, "/dev/%s", device_name);
 	if (ret < 0)
@@ -41,32 +85,55 @@ int list_device(const char *device_name)
 	if (fd == -1) {
 		ret = -errno;
 		fprintf(stderr, "Failed to open %s\n", chrdev_name);
-		goto free_chrdev_name;
+		goto exit_close_error;
 	}
 
 	/* Inspect this GPIO chip */
 	ret = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &cinfo);
 	if (ret == -1) {
 		ret = -errno;
-		fprintf(stderr, "Failed to retrieve GPIO fd\n");
-		if (close(fd) == -1)
-			perror("Failed to close GPIO character device file");
-
-		goto free_chrdev_name;
+		perror("Failed to issue CHIPINFO IOCTL\n");
+		goto exit_close_error;
 	}
 	fprintf(stdout, "GPIO chip: %s, \"%s\", %u GPIO lines\n",
 		cinfo.name, cinfo.label, cinfo.lines);
 
-	if (close(fd) == -1)  {
-		ret = -errno;
-		goto free_chrdev_name;
+	/* Loop over the lines and print info */
+	for (i = 0; i < cinfo.lines; i++) {
+		struct gpioline_info linfo;
+
+		memset(&linfo, 0, sizeof(linfo));
+		linfo.line_offset = i;
+
+		ret = ioctl(fd, GPIO_GET_LINEINFO_IOCTL, &linfo);
+		if (ret == -1) {
+			ret = -errno;
+			perror("Failed to issue LINEINFO IOCTL\n");
+			goto exit_close_error;
+		}
+		fprintf(stdout, "\tline %d:", linfo.line_offset);
+		if (linfo.name[0])
+			fprintf(stdout, " %s", linfo.name);
+		else
+			fprintf(stdout, " unnamed");
+		if (linfo.label[0])
+			fprintf(stdout, " \"%s\"", linfo.label);
+		else
+			fprintf(stdout, " unlabeled");
+		if (linfo.flags) {
+			fprintf(stdout, " [");
+			print_flags(linfo.flags);
+			fprintf(stdout, "]");
+		}
+		fprintf(stdout, "\n");
+
 	}
 
-free_chrdev_name:
+exit_close_error:
+	if (close(fd) == -1)
+		perror("Failed to close GPIO character device file");
 	free(chrdev_name);
-
 	return ret;
-
 }
 
 void print_usage(void)

commit df4878e969ccc047da45d2cd3af5d08031da1593
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 12 14:48:23 2016 +0100

    gpio: store reflect the label to userspace
    
    The gpio_chip label is useful for userspace to understand what
    kind of GPIO chip it is dealing with. Let's store a copy of this
    label in the gpio_device, add it to the struct passed to userspace
    for GPIO_GET_CHIPINFO_IOCTL and modify lsgpio to show it.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
index 4cfe29da279b..692233f561fb 100644
--- a/tools/gpio/lsgpio.c
+++ b/tools/gpio/lsgpio.c
@@ -54,8 +54,8 @@ int list_device(const char *device_name)
 
 		goto free_chrdev_name;
 	}
-	fprintf(stdout, "GPIO chip: %s, %u GPIO lines\n",
-		cinfo.name, cinfo.lines);
+	fprintf(stdout, "GPIO chip: %s, \"%s\", %u GPIO lines\n",
+		cinfo.name, cinfo.label, cinfo.lines);
 
 	if (close(fd) == -1)  {
 		ret = -errno;

commit 6d591c46bce037696d173bd5c8461b2b4bb680ad
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 21 15:45:54 2015 +0200

    tools/gpio: create GPIO tools
    
    This creates GPIO tools under tools/gpio/* and adds a single
    example program to list the GPIOs on a system. When proper
    devices are created it provides this minimal output:
    
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Michael Welling <mwelling@ieee.org>
    Cc: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/tools/gpio/lsgpio.c b/tools/gpio/lsgpio.c
new file mode 100644
index 000000000000..4cfe29da279b
--- /dev/null
+++ b/tools/gpio/lsgpio.c
@@ -0,0 +1,128 @@
+/*
+ * lsgpio - example on how to list the GPIO lines on a system
+ *
+ * Copyright (C) 2015 Linus Walleij
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * Usage:
+ *	lsgpio <-n device-name>
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <poll.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <linux/gpio.h>
+
+#include "gpio-utils.h"
+
+int list_device(const char *device_name)
+{
+	struct gpiochip_info cinfo;
+	char *chrdev_name;
+	int fd;
+	int ret;
+
+	ret = asprintf(&chrdev_name, "/dev/%s", device_name);
+	if (ret < 0)
+		return -ENOMEM;
+
+	fd = open(chrdev_name, 0);
+	if (fd == -1) {
+		ret = -errno;
+		fprintf(stderr, "Failed to open %s\n", chrdev_name);
+		goto free_chrdev_name;
+	}
+
+	/* Inspect this GPIO chip */
+	ret = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &cinfo);
+	if (ret == -1) {
+		ret = -errno;
+		fprintf(stderr, "Failed to retrieve GPIO fd\n");
+		if (close(fd) == -1)
+			perror("Failed to close GPIO character device file");
+
+		goto free_chrdev_name;
+	}
+	fprintf(stdout, "GPIO chip: %s, %u GPIO lines\n",
+		cinfo.name, cinfo.lines);
+
+	if (close(fd) == -1)  {
+		ret = -errno;
+		goto free_chrdev_name;
+	}
+
+free_chrdev_name:
+	free(chrdev_name);
+
+	return ret;
+
+}
+
+void print_usage(void)
+{
+	fprintf(stderr, "Usage: lsgpio [options]...\n"
+		"List GPIO chips, lines and states\n"
+		"  -n <name>  List GPIOs on a named device\n"
+		"  -?         This helptext\n"
+	);
+}
+
+int main(int argc, char **argv)
+{
+	const char *device_name;
+	int ret;
+	int c;
+
+	while ((c = getopt(argc, argv, "n:")) != -1) {
+		switch (c) {
+		case 'n':
+			device_name = optarg;
+			break;
+		case '?':
+			print_usage();
+			return -1;
+		}
+	}
+
+	if (device_name)
+		ret = list_device(device_name);
+	else {
+		const struct dirent *ent;
+		DIR *dp;
+
+		/* List all GPIO devices one at a time */
+		dp = opendir("/dev");
+		if (!dp) {
+			ret = -errno;
+			goto error_out;
+		}
+
+		ret = -ENOENT;
+		while (ent = readdir(dp), ent) {
+			if (check_prefix(ent->d_name, "gpiochip")) {
+				ret = list_device(ent->d_name);
+				if (ret)
+					break;
+			}
+		}
+
+		ret = 0;
+		if (closedir(dp) == -1) {
+			perror("scanning devices: Failed to close directory");
+			ret = -errno;
+		}
+	}
+error_out:
+	return ret;
+}
