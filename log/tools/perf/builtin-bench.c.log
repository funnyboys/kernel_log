commit ba35fe9358dfb961c74f3677a468148add9b23cb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed May 20 12:21:07 2020 -0300

    tools feature: Rename HAVE_EVENTFD to HAVE_EVENTFD_SUPPORT
    
    To be consistent with other such auto-detected features.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Anand K Mistry <amistry@google.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 083273209c88..cad31b1d3438 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -67,14 +67,14 @@ static struct bench futex_benchmarks[] = {
 	{ NULL,		NULL,						NULL			}
 };
 
-#ifdef HAVE_EVENTFD
+#ifdef HAVE_EVENTFD_SUPPORT
 static struct bench epoll_benchmarks[] = {
 	{ "wait",	"Benchmark epoll concurrent epoll_waits",       bench_epoll_wait	},
 	{ "ctl",	"Benchmark epoll concurrent epoll_ctls",        bench_epoll_ctl		},
 	{ "all",	"Run all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };
-#endif // HAVE_EVENTFD
+#endif // HAVE_EVENTFD_SUPPORT
 
 static struct bench internals_benchmarks[] = {
 	{ "synthesize", "Benchmark perf event synthesis",	bench_synthesize	},
@@ -95,7 +95,7 @@ static struct collection collections[] = {
 	{ "numa",	"NUMA scheduling and MM benchmarks",		numa_benchmarks		},
 #endif
 	{"futex",       "Futex stressing benchmarks",                   futex_benchmarks        },
-#ifdef HAVE_EVENTFD
+#ifdef HAVE_EVENTFD_SUPPORT
 	{"epoll",       "Epoll stressing benchmarks",                   epoll_benchmarks        },
 #endif
 	{ "internals",	"Perf-internals benchmarks",			internals_benchmarks	},

commit 51876bd45263f62083bbb823220bfb48909f313a
Author: Ian Rogers <irogers@google.com>
Date:   Fri May 1 15:13:13 2020 -0700

    perf bench: Add kallsyms parsing
    
    Add a benchmark for kallsyms parsing. Example output:
    
      Running 'internals/kallsyms-parse' benchmark:
      Average kallsyms__parse took: 103.971 ms (+- 0.121 ms)
    
    Committer testing:
    
    Test Machine: AMD Ryzen 5 3600X 6-Core Processor
    
      [root@five ~]# perf bench internals kallsyms-parse
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 79.692 ms (+- 0.101 ms)
      [root@five ~]# perf stat -r5 perf bench internals kallsyms-parse
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 80.563 ms (+- 0.079 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.046 ms (+- 0.155 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 80.874 ms (+- 0.104 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.173 ms (+- 0.133 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.169 ms (+- 0.074 ms)
    
       Performance counter stats for 'perf bench internals kallsyms-parse' (5 runs):
    
                8,093.54 msec task-clock                #    0.999 CPUs utilized            ( +-  0.14% )
                   3,165      context-switches          #    0.391 K/sec                    ( +-  0.18% )
                      10      cpu-migrations            #    0.001 K/sec                    ( +- 23.13% )
                     744      page-faults               #    0.092 K/sec                    ( +-  0.21% )
          34,551,564,954      cycles                    #    4.269 GHz                      ( +-  0.05% )  (83.33%)
           1,160,584,308      stalled-cycles-frontend   #    3.36% frontend cycles idle     ( +-  1.60% )  (83.33%)
          14,974,323,985      stalled-cycles-backend    #   43.34% backend cycles idle      ( +-  0.24% )  (83.33%)
          58,712,905,705      instructions              #    1.70  insn per cycle
                                                        #    0.26  stalled cycles per insn  ( +-  0.01% )  (83.34%)
          14,136,433,778      branches                  # 1746.632 M/sec                    ( +-  0.01% )  (83.33%)
             141,943,217      branch-misses             #    1.00% of all branches          ( +-  0.04% )  (83.33%)
    
                  8.1040 +- 0.0115 seconds time elapsed  ( +-  0.14% )
    
      [root@five ~]#
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200501221315.54715-2-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 11c79a8d85d6..083273209c88 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -78,6 +78,7 @@ static struct bench epoll_benchmarks[] = {
 
 static struct bench internals_benchmarks[] = {
 	{ "synthesize", "Benchmark perf event synthesis",	bench_synthesize	},
+	{ "kallsyms-parse", "Benchmark kallsyms parsing",	bench_kallsyms_parse	},
 	{ NULL,		NULL,					NULL			}
 };
 

commit 2a4b51666af8bf0b67ccc2e53120bad27351917c
Author: Ian Rogers <irogers@google.com>
Date:   Thu Apr 2 08:43:53 2020 -0700

    perf bench: Add event synthesis benchmark
    
    Event synthesis may occur at the start or end (tail) of a perf command.
    In system-wide mode it can scan every process in /proc, which may add
    seconds of latency before event recording. Add a new benchmark that
    times how long event synthesis takes with and without data synthesis.
    
    An example execution looks like:
    
     $ perf bench internals synthesize
     # Running 'internals/synthesize' benchmark:
     Average synthesis took: 168.253800 usec
     Average data synthesis took: 208.104700 usec
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrey Zhizhikin <andrey.z@gmail.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200402154357.107873-2-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index c06fe21c8613..11c79a8d85d6 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -76,6 +76,11 @@ static struct bench epoll_benchmarks[] = {
 };
 #endif // HAVE_EVENTFD
 
+static struct bench internals_benchmarks[] = {
+	{ "synthesize", "Benchmark perf event synthesis",	bench_synthesize	},
+	{ NULL,		NULL,					NULL			}
+};
+
 struct collection {
 	const char	*name;
 	const char	*summary;
@@ -92,6 +97,7 @@ static struct collection collections[] = {
 #ifdef HAVE_EVENTFD
 	{"epoll",       "Epoll stressing benchmarks",                   epoll_benchmarks        },
 #endif
+	{ "internals",	"Perf-internals benchmarks",			internals_benchmarks	},
 	{ "all",	"All benchmarks",				NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit 0ac25fd0a04d8bd52ceac2476e71a4e497489987
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 29 15:42:40 2019 -0300

    perf tools: Remove perf.h from source files not needing it
    
    With the movement of lots of stuff out of perf.h to other headers we
    ended up not needing it in lots of places, remove it from those places.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-c718m0sxxwp73lp9d8vpihb4@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index b8e7c38ef221..c06fe21c8613 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -16,7 +16,6 @@
  *  futex ... Futex performance
  *  epoll ... Event poll performance
  */
-#include "perf.h"
 #include <subcmd/parse-options.h>
 #include "builtin.h"
 #include "bench/bench.h"

commit 7f7c536f23e6afaa5d5d4b0e0958b0be8922491f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jul 4 11:32:27 2019 -0300

    tools lib: Adopt zalloc()/zfree() from tools/perf
    
    Eroding a bit more the tools/perf/util/util.h hodpodge header.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-natazosyn9rwjka25tvcnyi0@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 334c77ffc1d9..b8e7c38ef221 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -17,7 +17,6 @@
  *  epoll ... Event poll performance
  */
 #include "perf.h"
-#include "util/util.h"
 #include <subcmd/parse-options.h>
 #include "builtin.h"
 #include "bench/bench.h"
@@ -26,6 +25,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/prctl.h>
+#include <linux/zalloc.h>
 
 typedef int (*bench_fn_t)(int argc, const char **argv);
 

commit 231457ec707475c71d4e538a3253f1ed9e294cf0
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Nov 6 07:22:26 2018 -0800

    perf bench: Add epoll_ctl(2) benchmark
    
    Benchmark the various operations allowed for epoll_ctl(2).  The idea is
    to concurrently stress a single epoll instance doing add/mod/del
    operations.
    
    Committer testing:
    
      # perf bench epoll ctl
      # Running 'epoll/ctl' benchmark:
      Run summary [PID 20344]: 4 threads doing epoll_ctl ops 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0x21a46b0 ... 0x21a47ac [ add: 1680960 ops; mod: 1680960 ops; del: 1680960 ops ]
      [thread  1] fdmap: 0x21a4960 ... 0x21a4a5c [ add: 1685440 ops; mod: 1685440 ops; del: 1685440 ops ]
      [thread  2] fdmap: 0x21a4c10 ... 0x21a4d0c [ add: 1674368 ops; mod: 1674368 ops; del: 1674368 ops ]
      [thread  3] fdmap: 0x21a4ec0 ... 0x21a4fbc [ add: 1677568 ops; mod: 1677568 ops; del: 1677568 ops ]
    
      Averaged 1679584 ADD operations (+- 0.14%)
      Averaged 1679584 MOD operations (+- 0.14%)
      Averaged 1679584 DEL operations (+- 0.14%)
      #
    
    Lets measure those calls with 'perf trace' to get a glympse at what this
    benchmark is doing in terms of syscalls:
    
      # perf trace -m32768 -s perf bench epoll ctl
      # Running 'epoll/ctl' benchmark:
      Run summary [PID 20405]: 4 threads doing epoll_ctl ops 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0x21764e0 ... 0x21765dc [ add: 1100480 ops; mod: 1100480 ops; del: 1100480 ops ]
      [thread  1] fdmap: 0x2176790 ... 0x217688c [ add: 1250176 ops; mod: 1250176 ops; del: 1250176 ops ]
      [thread  2] fdmap: 0x2176a40 ... 0x2176b3c [ add: 1022464 ops; mod: 1022464 ops; del: 1022464 ops ]
      [thread  3] fdmap: 0x2176cf0 ... 0x2176dec [ add: 705472 ops; mod: 705472 ops; del: 705472 ops ]
    
      Averaged 1019648 ADD operations (+- 11.27%)
      Averaged 1019648 MOD operations (+- 11.27%)
      Averaged 1019648 DEL operations (+- 11.27%)
    
      Summary of events:
    
      epoll-ctl (20405), 1264 events, 0.0%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       eventfd2             256     9.514     0.001     0.037     5.243     68.00%
       clone                  4     1.245     0.204     0.311     0.531     24.13%
       mprotect              66     0.345     0.002     0.005     0.021      7.43%
       openat                45     0.313     0.004     0.007     0.073     21.93%
       mmap                  88     0.302     0.002     0.003     0.013      5.02%
       futex                  4     0.160     0.002     0.040     0.140     83.43%
       sched_setaffinity      4     0.124     0.005     0.031     0.070     49.39%
       read                  44     0.103     0.001     0.002     0.013     15.54%
       fstat                 40     0.052     0.001     0.001     0.003      5.43%
       close                 39     0.039     0.001     0.001     0.001      1.48%
       stat                   9     0.034     0.003     0.004     0.006      7.30%
       access                 3     0.023     0.007     0.008     0.008      4.25%
       open                   2     0.021     0.008     0.011     0.013     22.60%
       getdents               4     0.019     0.001     0.005     0.009     37.15%
       write                  2     0.013     0.004     0.007     0.009     38.48%
       munmap                 1     0.010     0.010     0.010     0.010      0.00%
       brk                    3     0.006     0.001     0.002     0.003     26.34%
       rt_sigprocmask         2     0.004     0.001     0.002     0.003     43.95%
       rt_sigaction           3     0.004     0.001     0.001     0.002     16.07%
       prlimit64              3     0.004     0.001     0.001     0.001      5.39%
       prctl                  1     0.003     0.003     0.003     0.003      0.00%
       epoll_create           1     0.003     0.003     0.003     0.003      0.00%
       lseek                  2     0.002     0.001     0.001     0.001     11.42%
       sched_getaffinity        1     0.002     0.002     0.002     0.002      0.00%
       arch_prctl             1     0.002     0.002     0.002     0.002      0.00%
       set_tid_address        1     0.001     0.001     0.001     0.001      0.00%
       getpid                 1     0.001     0.001     0.001     0.001      0.00%
       set_robust_list        1     0.001     0.001     0.001     0.001      0.00%
       execve                 1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20406), 1245480 events, 14.6%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         619511  1034.927     0.001     0.002     6.691      0.67%
       nanosleep           3226   616.114     0.006     0.191    10.376      7.57%
       futex                  2    11.336     0.002     5.668    11.334     99.97%
       set_robust_list        1     0.001     0.001     0.001     0.001      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20407), 1243151 events, 14.5%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         618350  1042.181     0.001     0.002     2.512      0.40%
       nanosleep           3220   366.261     0.012     0.114    18.162      9.59%
       futex                  4     5.463     0.001     1.366     5.427     99.12%
       set_robust_list        1     0.002     0.002     0.002     0.002      0.00%
    
     epoll-ctl (20408), 1801690 events, 21.1%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         896174  1540.581     0.001     0.002     6.987      0.74%
       nanosleep           4667   783.393     0.006     0.168    10.419      7.10%
       futex                  2     4.682     0.002     2.341     4.681     99.93%
       set_robust_list        1     0.002     0.002     0.002     0.002      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20409), 4254890 events, 49.8%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl        2116416  3768.097     0.001     0.002     9.956      0.41%
       nanosleep          11023  1141.778     0.006     0.104     9.447      4.95%
       futex                  3     0.037     0.002     0.012     0.029     70.50%
       set_robust_list        1     0.008     0.008     0.008     0.008      0.00%
       madvise                1     0.005     0.005     0.005     0.005      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
      #
    
    Committer notes:
    
    Fix build on fedora:24-x-ARC-uClibc, debian:experimental-x-mips,
    debian:experimental-x-mipsel, ubuntu:16.04-x-arm and ubuntu:16.04-x-powerpc
    
        CC       /tmp/build/perf/bench/epoll-ctl.o
      bench/epoll-ctl.c: In function 'init_fdmaps':
      bench/epoll-ctl.c:214:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nfds; i+=inc) {
                      ^
      bench/epoll-ctl.c: In function 'bench_epoll_ctl':
      bench/epoll-ctl.c:377:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nthreads; i++) {
                      ^
      bench/epoll-ctl.c:388:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nthreads; i++) {
                      ^
      cc1: all warnings being treated as errors
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181106152226.20883-3-dave@stgolabs.net
    [ Use inttypes.h to print rlim_t fields, fixing the build on Alpine Linux / musl libc ]
    [ Check if eventfd() is available, i.e. if HAVE_EVENTFD is defined ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 55efd23c3efb..334c77ffc1d9 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -71,6 +71,7 @@ static struct bench futex_benchmarks[] = {
 #ifdef HAVE_EVENTFD
 static struct bench epoll_benchmarks[] = {
 	{ "wait",	"Benchmark epoll concurrent epoll_waits",       bench_epoll_wait	},
+	{ "ctl",	"Benchmark epoll concurrent epoll_ctls",        bench_epoll_ctl		},
 	{ "all",	"Run all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit 121dd9ea0116de3e79a4903a84018190c595e2b6
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Nov 6 07:22:25 2018 -0800

    perf bench: Add epoll parallel epoll_wait benchmark
    
    This program benchmarks concurrent epoll_wait(2) for file descriptors
    that are monitored with with EPOLLIN along various semantics, by a
    single epoll instance. Such conditions can be found when using
    single/combined or multiple queuing when load balancing.
    
    Each thread has a number of private, nonblocking file descriptors,
    referred to as fdmap. A writer thread will constantly be writing to the
    fdmaps of all threads, minimizing each threads's chances of epoll_wait
    not finding any ready read events and blocking as this is not what we
    want to stress. Full details in the start of the C file.
    
    Committer testing:
    
      # perf bench
      Usage:
            perf bench [<common options>] <collection> <benchmark> [<options>]
    
            # List of all available benchmark collections:
    
             sched: Scheduler and IPC benchmarks
               mem: Memory access benchmarks
              numa: NUMA scheduling and MM benchmarks
             futex: Futex stressing benchmarks
             epoll: Epoll stressing benchmarks
               all: All benchmarks
    
      # perf bench epoll
    
            # List of available benchmarks for collection 'epoll':
    
              wait: Benchmark epoll concurrent epoll_waits
               all: Run all futex benchmarks
    
      # perf bench epoll wait
      # Running 'epoll/wait' benchmark:
      Run summary [PID 19295]: 3 threads monitoring on 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0xdaa650 ... 0xdaa74c [ 328241 ops/sec ]
      [thread  1] fdmap: 0xdaa900 ... 0xdaa9fc [ 351695 ops/sec ]
      [thread  2] fdmap: 0xdaabb0 ... 0xdaacac [ 381423 ops/sec ]
    
      Averaged 353786 operations/sec (+- 4.35%), total secs = 8
      #
    
    Committer notes:
    
    Fix the build on debian:experimental-x-mips, debian:experimental-x-mipsel
    and others:
    
        CC       /tmp/build/perf/bench/epoll-wait.o
      bench/epoll-wait.c: In function 'writerfn':
      bench/epoll-wait.c:399:12: error: format '%ld' expects argument of type 'long int', but argument 2 has type 'size_t' {aka 'unsigned int'} [-Werror=format=]
        printinfo("exiting writer-thread (total full-loops: %ld)\n", iter);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ~~~~
      bench/epoll-wait.c:86:31: note: in definition of macro 'printinfo'
        do { if (__verbose) { printf(fmt, ## arg); fflush(stdout); } } while (0)
                                     ^~~
      cc1: all warnings being treated as errors
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com> <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181106152226.20883-2-dave@stgolabs.net
    Link: http://lkml.kernel.org/r/20181106182349.thdkpvshkna5vd7o@linux-r8p5>
    [ Applied above fixup as per Davidlohr's request ]
    [ Use inttypes.h to print rlim_t fields, fixing the build on Alpine Linux / musl libc ]
    [ Check if eventfd() is available, i.e. if HAVE_EVENTFD is defined ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 17a6bcd01aa6..55efd23c3efb 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -14,6 +14,7 @@
  *  mem   ... memory access performance
  *  numa  ... NUMA scheduling and MM performance
  *  futex ... Futex performance
+ *  epoll ... Event poll performance
  */
 #include "perf.h"
 #include "util/util.h"
@@ -67,6 +68,14 @@ static struct bench futex_benchmarks[] = {
 	{ NULL,		NULL,						NULL			}
 };
 
+#ifdef HAVE_EVENTFD
+static struct bench epoll_benchmarks[] = {
+	{ "wait",	"Benchmark epoll concurrent epoll_waits",       bench_epoll_wait	},
+	{ "all",	"Run all futex benchmarks",			NULL			},
+	{ NULL,		NULL,						NULL			}
+};
+#endif // HAVE_EVENTFD
+
 struct collection {
 	const char	*name;
 	const char	*summary;
@@ -80,6 +89,9 @@ static struct collection collections[] = {
 	{ "numa",	"NUMA scheduling and MM benchmarks",		numa_benchmarks		},
 #endif
 	{"futex",       "Futex stressing benchmarks",                   futex_benchmarks        },
+#ifdef HAVE_EVENTFD
+	{"epoll",       "Epoll stressing benchmarks",                   epoll_benchmarks        },
+#endif
 	{ "all",	"All benchmarks",				NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 445e62881254..17a6bcd01aa6 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * builtin-bench.c
  *

commit b0ad8ea66445d64a469df0c710947f4cdb8ef16b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 27 11:47:20 2017 -0300

    perf tools: Remove unused 'prefix' from builtin functions
    
    We got it from the git sources but never used it for anything, with the
    place where this would be somehow used remaining:
    
      static int run_builtin(struct cmd_struct *p, int argc, const char **argv)
      {
            prefix = NULL;
            if (p->option & RUN_SETUP)
                    prefix = NULL; /* setup_perf_directory(); */
    
    Ditch it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-uw5swz05vol0qpr32c5lpvus@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index a1cddc6bbf0f..445e62881254 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -25,7 +25,7 @@
 #include <string.h>
 #include <sys/prctl.h>
 
-typedef int (*bench_fn_t)(int argc, const char **argv, const char *prefix);
+typedef int (*bench_fn_t)(int argc, const char **argv);
 
 struct bench {
 	const char	*name;
@@ -155,7 +155,7 @@ static int bench_str2int(const char *str)
  * to something meaningful:
  */
 static int run_bench(const char *coll_name, const char *bench_name, bench_fn_t fn,
-		     int argc, const char **argv, const char *prefix)
+		     int argc, const char **argv)
 {
 	int size;
 	char *name;
@@ -171,7 +171,7 @@ static int run_bench(const char *coll_name, const char *bench_name, bench_fn_t f
 	prctl(PR_SET_NAME, name);
 	argv[0] = name;
 
-	ret = fn(argc, argv, prefix);
+	ret = fn(argc, argv);
 
 	free(name);
 
@@ -198,7 +198,7 @@ static void run_collection(struct collection *coll)
 		fflush(stdout);
 
 		argv[1] = bench->name;
-		run_bench(coll->name, bench->name, bench->fn, 1, argv, NULL);
+		run_bench(coll->name, bench->name, bench->fn, 1, argv);
 		printf("\n");
 	}
 }
@@ -211,7 +211,7 @@ static void run_all_collections(void)
 		run_collection(coll);
 }
 
-int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
+int cmd_bench(int argc, const char **argv)
 {
 	struct collection *coll;
 	int ret = 0;
@@ -270,7 +270,7 @@ int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 			if (bench_format == BENCH_FORMAT_DEFAULT)
 				printf("# Running '%s/%s' benchmark:\n", coll->name, bench->name);
 			fflush(stdout);
-			ret = run_bench(coll->name, bench->name, bench->fn, argc-1, argv+1, prefix);
+			ret = run_bench(coll->name, bench->name, bench->fn, argc-1, argv+1);
 			goto end;
 		}
 

commit 4b6ab94eabe4f55371cff4569750bb3996c55db6
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Dec 15 09:39:39 2015 -0600

    perf subcmd: Create subcmd library
    
    Move the subcommand-related files from perf to a new library named
    libsubcmd.a.
    
    Since we're moving files anyway, go ahead and rename 'exec_cmd.*' to
    'exec-cmd.*' to be consistent with the naming of all the other files.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/c0a838d4c878ab17fee50998811612b2281355c1.1450193761.git.jpoimboe@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index b17aed36ca16..a1cddc6bbf0f 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -16,7 +16,7 @@
  */
 #include "perf.h"
 #include "util/util.h"
-#include "util/parse-options.h"
+#include <subcmd/parse-options.h>
 #include "builtin.h"
 #include "bench/bench.h"
 

commit aa254af25c40d6d1cdc3f354db29eaf3e85a5ede
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Oct 19 10:04:30 2015 +0200

    perf bench: Run benchmarks, don't test them
    
    So right now we output this text:
    
            memcpy: Benchmark for memcpy() functions
            memset: Benchmark for memset() functions
               all: Test all memory access benchmarks
    
    But the right verb to use with benchmarks is to 'run' them, not 'test'
    them.
    
    So change this (and all similar texts) to:
    
            memcpy: Benchmark for memcpy() functions
            memset: Benchmark for memset() functions
               all: Run all memory access benchmarks
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1445241870-24854-15-git-send-email-mingo@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index a8fc948c8ace..b17aed36ca16 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -36,7 +36,7 @@ struct bench {
 #ifdef HAVE_LIBNUMA_SUPPORT
 static struct bench numa_benchmarks[] = {
 	{ "mem",	"Benchmark for NUMA workloads",			bench_numa		},
-	{ "all",	"Test all NUMA benchmarks",			NULL			},
+	{ "all",	"Run all NUMA benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };
 #endif
@@ -44,14 +44,14 @@ static struct bench numa_benchmarks[] = {
 static struct bench sched_benchmarks[] = {
 	{ "messaging",	"Benchmark for scheduling and IPC",		bench_sched_messaging	},
 	{ "pipe",	"Benchmark for pipe() between two processes",	bench_sched_pipe	},
-	{ "all",	"Test all scheduler benchmarks",		NULL			},
+	{ "all",	"Run all scheduler benchmarks",		NULL			},
 	{ NULL,		NULL,						NULL			}
 };
 
 static struct bench mem_benchmarks[] = {
 	{ "memcpy",	"Benchmark for memcpy() functions",		bench_mem_memcpy	},
 	{ "memset",	"Benchmark for memset() functions",		bench_mem_memset	},
-	{ "all",	"Test all memory access benchmarks",		NULL			},
+	{ "all",	"Run all memory access benchmarks",		NULL			},
 	{ NULL,		NULL,						NULL			}
 };
 
@@ -62,7 +62,7 @@ static struct bench futex_benchmarks[] = {
 	{ "requeue",	"Benchmark for futex requeue calls",            bench_futex_requeue	},
 	/* pi-futexes */
 	{ "lock-pi",	"Benchmark for futex lock_pi calls",            bench_futex_lock_pi	},
-	{ "all",	"Test all futex benchmarks",			NULL			},
+	{ "all",	"Run all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };
 

commit 13b1fdce8d46027f346c0533a4323b58e2b5bad8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Oct 19 10:04:26 2015 +0200

    perf bench mem: Improve user visible strings
    
     - fix various typos in user visible output strings
     - make the output consistent (wrt. capitalization and spelling)
     - offer the list of routines to benchmark on '-r help'.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1445241870-24854-11-git-send-email-mingo@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 1b585213ba5a..a8fc948c8ace 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -49,9 +49,9 @@ static struct bench sched_benchmarks[] = {
 };
 
 static struct bench mem_benchmarks[] = {
-	{ "memcpy",	"Benchmark for memcpy()",			bench_mem_memcpy	},
-	{ "memset",	"Benchmark for memset() tests",			bench_mem_memset	},
-	{ "all",	"Test all memory benchmarks",			NULL			},
+	{ "memcpy",	"Benchmark for memcpy() functions",		bench_mem_memcpy	},
+	{ "memset",	"Benchmark for memset() functions",		bench_mem_memset	},
+	{ "all",	"Test all memory access benchmarks",		NULL			},
 	{ NULL,		NULL,						NULL			}
 };
 

commit 7a46a8fd13bd60584687f417cd35935965f29ae2
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Oct 19 10:04:22 2015 +0200

    perf bench: List output formatting options on 'perf bench -h'
    
    So 'perf bench -h' is not very helpful when printing the help line
    about the output formatting options:
    
        -f, --format <default>
                                  Specify format style
    
    There are two output format styles, 'default' and 'simple', so improve
    the help text to:
    
        -f, --format <default|simple>
                                  Specify the output formatting style
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1445241870-24854-7-git-send-email-mingo@kernel.org
    [ Removed leftovers from the mem-functions.c rename ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index f67934d46d40..1b585213ba5a 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -110,7 +110,7 @@ int bench_format = BENCH_FORMAT_DEFAULT;
 unsigned int bench_repeat = 10; /* default number of times to repeat the run */
 
 static const struct option bench_options[] = {
-	OPT_STRING('f', "format", &bench_format_str, "default", "Specify format style"),
+	OPT_STRING('f', "format", &bench_format_str, "default|simple", "Specify the output formatting style"),
 	OPT_UINTEGER('r', "repeat",  &bench_repeat,   "Specify amount of times to repeat the run"),
 	OPT_END()
 };

commit d2f3f5d2e9cae6e73f9642a5ddc8c8a07c35e79b
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Jul 7 01:55:53 2015 -0700

    perf bench futex: Add lock_pi stresser
    
    Allows a way of measuring low level kernel implementation of FUTEX_LOCK_PI and
    FUTEX_UNLOCK_PI.
    
    The program comes in two flavors:
    
    (i) single futex (default), all threads contend on the same uaddr.  For the
    sake of the benchmark, we call into kernel space even when the lock is
    uncontended.  The kernel will set it to TID, any waters that come in and
    contend for the pi futex will be handled respectively by the kernel.
    
    (ii) -M option for multiple futexes, each thread deals with its own futex. This
    is a trivial scenario and only measures kernel handling of 0->TID transition.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Mel Gorman <mgorman@suse.de>
    Link: http://lkml.kernel.org/r/1436259353.12255.78.camel@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index b5314e452ec7..f67934d46d40 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -60,6 +60,8 @@ static struct bench futex_benchmarks[] = {
 	{ "wake",	"Benchmark for futex wake calls",               bench_futex_wake	},
 	{ "wake-parallel", "Benchmark for parallel futex wake calls",   bench_futex_wake_parallel },
 	{ "requeue",	"Benchmark for futex requeue calls",            bench_futex_requeue	},
+	/* pi-futexes */
+	{ "lock-pi",	"Benchmark for futex lock_pi calls",            bench_futex_lock_pi	},
 	{ "all",	"Test all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit d65817b4e707068c2dd3e002e87c2a0294aabc2c
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri May 8 11:37:59 2015 -0700

    perf bench futex: Support parallel waker threads
    
    The futex-wake benchmark only measures wakeups done within a single
    process. While this has value in its own, it does not really generate
    any hb->lock contention.
    
    A new benchmark 'wake-parallel' is added, by extending the futex-wake
    code such that we can measure parallel waker threads. The program output
    shows the avg per-thread latency in order to complete its share of
    wakeups:
    
    Run summary [PID 13474]: blocking on 512 threads (at [private] futex 0xa88668), 8 threads waking up 64 at a time.
    
    [Run 1]: Avg per-thread latency (waking 64/512 threads) in 0.6230 ms (+-15.31%)
    [Run 2]: Avg per-thread latency (waking 64/512 threads) in 0.5175 ms (+-29.95%)
    [Run 3]: Avg per-thread latency (waking 64/512 threads) in 0.7578 ms (+-18.03%)
    [Run 4]: Avg per-thread latency (waking 64/512 threads) in 0.8944 ms (+-12.54%)
    [Run 5]: Avg per-thread latency (waking 64/512 threads) in 1.1204 ms (+-23.85%)
    Avg per-thread latency (waking 64/512 threads) in 0.7826 ms (+-9.91%)
    
    Naturally, different combinations of numbers of blocking and waker
    threads will exhibit different information.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Link: http://lkml.kernel.org/r/1431110280-20231-1-git-send-email-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index b9a56fa83330..b5314e452ec7 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -58,6 +58,7 @@ static struct bench mem_benchmarks[] = {
 static struct bench futex_benchmarks[] = {
 	{ "hash",	"Benchmark for futex hash table",               bench_futex_hash	},
 	{ "wake",	"Benchmark for futex wake calls",               bench_futex_wake	},
+	{ "wake-parallel", "Benchmark for parallel futex wake calls",   bench_futex_wake_parallel },
 	{ "requeue",	"Benchmark for futex requeue calls",            bench_futex_requeue	},
 	{ "all",	"Test all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}

commit b6f0629a94f7ed6089560be7f0561be19f934fc4
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Mon Jun 16 11:14:19 2014 -0700

    perf bench: Add --repeat option
    
    There are a number of benchmarks that do single runs and as a result
    does not really help users gain a general idea of how the workload
    performs. So the user must either manually do multiple runs or just use
    single bogus results.
    
    This option will enable users to specify the amount of runs (arbitrarily
    defaulted to 10, to use the existing benchmarks default) through the
    '--repeat' option.  Add it to perf-bench instead of implementing it
    always in each specific benchmark.
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/1402942467-10671-2-git-send-email-davidlohr@hp.com
    [ Kept the existing default of 10, changing it to something else should
      be done on separate patch ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 1e6e77710545..b9a56fa83330 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -104,9 +104,11 @@ static const char *bench_format_str;
 
 /* Output/formatting style, exported to benchmark modules: */
 int bench_format = BENCH_FORMAT_DEFAULT;
+unsigned int bench_repeat = 10; /* default number of times to repeat the run */
 
 static const struct option bench_options[] = {
 	OPT_STRING('f', "format", &bench_format_str, "default", "Specify format style"),
+	OPT_UINTEGER('r', "repeat",  &bench_repeat,   "Specify amount of times to repeat the run"),
 	OPT_END()
 };
 
@@ -226,6 +228,11 @@ int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 		goto end;
 	}
 
+	if (bench_repeat == 0) {
+		printf("Invalid repeat option: Must specify a positive value\n");
+		goto end;
+	}
+
 	if (argc < 1) {
 		print_usage();
 		goto end;

commit 8c292f11744297dfb3a69f4a0bccbe4a6417b50d
Merge: d31605dc8a63 538592ff0b00
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 31 11:13:25 2014 -0700

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf changes from Ingo Molnar:
     "Main changes:
    
      Kernel side changes:
    
       - Add SNB/IVB/HSW client uncore memory controller support (Stephane
         Eranian)
    
       - Fix various x86/P4 PMU driver bugs (Don Zickus)
    
      Tooling, user visible changes:
    
       - Add several futex 'perf bench' microbenchmarks (Davidlohr Bueso)
    
       - Speed up thread map generation (Don Zickus)
    
       - Introduce 'perf kvm --list-cmds' command line option for use by
         scripts (Ramkumar Ramachandra)
    
       - Print the evsel name in the annotate stdio output, prep to fix
         support outputting annotation for multiple events, not just for the
         first one (Arnaldo Carvalho de Melo)
    
       - Allow setting preferred callchain method in .perfconfig (Jiri Olsa)
    
       - Show in what binaries/modules 'perf probe's are set (Masami
         Hiramatsu)
    
       - Support distro-style debuginfo for uprobe in 'perf probe' (Masami
         Hiramatsu)
    
      Tooling, internal changes and fixes:
    
       - Use tid in mmap/mmap2 events to find maps (Don Zickus)
    
       - Record the reason for filtering an address_location (Namhyung Kim)
    
       - Apply all filters to an addr_location (Namhyung Kim)
    
       - Merge al->filtered with hist_entry->filtered in report/hists
         (Namhyung Kim)
    
       - Fix memory leak when synthesizing thread records (Namhyung Kim)
    
       - Use ui__has_annotation() in 'report' (Namhyung Kim)
    
       - hists browser refactorings to reuse code accross UIs (Namhyung Kim)
    
       - Add support for the new DWARF unwinder library in elfutils (Jiri
         Olsa)
    
       - Fix build race in the generation of bison files (Jiri Olsa)
    
       - Further streamline the feature detection display, trimming it a bit
         to show just the libraries detected, using VF=1 gets a more verbose
         output, showing the less interesting feature checks as well (Jiri
         Olsa).
    
       - Check compatible symtab type before loading dso (Namhyung Kim)
    
       - Check return value of filename__read_debuglink() (Stephane Eranian)
    
       - Move some hashing and fs related code from tools/perf/util/ to
         tools/lib/ so that it can be used by more tools/ living utilities
         (Borislav Petkov)
    
       - Prepare DWARF unwinding code for using an elfutils alternative
         unwinding library (Jiri Olsa)
    
       - Fix DWARF unwind max_stack processing (Jiri Olsa)
    
       - Add dwarf unwind 'perf test' entry (Jiri Olsa)
    
       - 'perf probe' improvements including memory leak fixes, sharing the
         intlist class with other tools, uprobes/kprobes code sharing and
         use of ref_reloc_sym (Masami Hiramatsu)
    
       - Shorten sample symbol resolving by adding cpumode to struct
         addr_location (Arnaldo Carvalho de Melo)
    
       - Fix synthesizing mmaps for threads (Don Zickus)
    
       - Fix invalid output on event group stdio report (Namhyung Kim)
    
       - Fixup header alignment in 'perf sched latency' output (Ramkumar
         Ramachandra)
    
       - Fix off-by-one error in 'perf timechart record' argv handling
         (Ramkumar Ramachandra)
    
      Tooling, cleanups:
    
       - Remove unused thread__find_map function (Jiri Olsa)
    
       - Remove unused simple_strtoul() function (Ramkumar Ramachandra)
    
      Tooling, documentation updates:
    
       - Update function names in debug messages (Ramkumar Ramachandra)
    
       - Update some code references in design.txt (Ramkumar Ramachandra)
    
       - Clarify load-latency information in the 'perf mem' docs (Andi
         Kleen)
    
       - Clarify x86 register naming in 'perf probe' docs (Andi Kleen)"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (96 commits)
      perf tools: Remove unused simple_strtoul() function
      perf tools: Update some code references in design.txt
      perf evsel: Update function names in debug messages
      perf tools: Remove thread__find_map function
      perf annotate: Print the evsel name in the stdio output
      perf report: Use ui__has_annotation()
      perf tools: Fix memory leak when synthesizing thread records
      perf tools: Use tid in mmap/mmap2 events to find maps
      perf report: Merge al->filtered with hist_entry->filtered
      perf symbols: Apply all filters to an addr_location
      perf symbols: Record the reason for filtering an address_location
      perf sched: Fixup header alignment in 'latency' output
      perf timechart: Fix off-by-one error in 'record' argv handling
      perf machine: Factor machine__find_thread to take tid argument
      perf tools: Speed up thread map generation
      perf kvm: introduce --list-cmds for use by scripts
      perf ui hists: Pass evsel to hpp->header/width functions explicitly
      perf symbols: Introduce thread__find_cpumode_addr_location
      perf session: Change header.misc dump from decimal to hex
      perf ui/tui: Reuse generic __hpp__fmt() code
      ...

commit 6eeefccdcfc2cc9697562e740bfe6c35fddd4e1c
Author: Patrick Palka <patrick@parcs.ath.cx>
Date:   Wed Mar 12 18:40:51 2014 -0400

    perf bench: Fix NULL pointer dereference in "perf bench all"
    
    The for_each_bench() macro must check that the "benchmarks" field of a
    collection is not NULL before dereferencing it because the "all"
    collection in particular has a NULL "benchmarks" field (signifying that
    it has no benchmarks to iterate over).
    
    This fixes this NULL pointer dereference when running "perf bench all":
    
      [root@ssdandy ~]# perf bench all
      <SNIP>
    
      # Running mem/memset benchmark...
      # Copying 1MB Bytes ...
    
             2.453675 GB/Sec
            12.056327 GB/Sec (with prefault)
    
      Segmentation fault (core dumped)
      [root@ssdandy ~]#
    
    Signed-off-by: Patrick Palka <patrick@parcs.ath.cx>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1394664051-6037-1-git-send-email-patrick@parcs.ath.cx
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index e47f90cc7b98..8a987d252780 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -76,7 +76,7 @@ static struct collection collections[] = {
 
 /* Iterate over all benchmarks within a collection: */
 #define for_each_bench(coll, bench) \
-	for (bench = coll->benchmarks; bench->name; bench++)
+	for (bench = coll->benchmarks; bench && bench->name; bench++)
 
 static void dump_benchmarks(struct collection *coll)
 {

commit 0fb298cf95c0d8119557b7d4657724a146e0622e
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:57 2013 -0800

    perf bench: Add futex-requeue microbenchmark
    
    Block a bunch of threads on a futex and requeue them on another, N at a
    time.
    
    This program is particularly useful to measure the latency of nthread
    requeues without waking up any tasks -- thus mimicking a regular
    futex_wait.
    
    An example run:
    
      $ perf bench futex requeue -r 100 -t 64
      Run summary [PID 151011]: Requeuing 64 threads (from 0x7d15c4 to 0x7d15c8), 1 at a time.
    
      [Run 1]: Requeued 64 of 64 threads in 0.0400 ms
      [Run 2]: Requeued 64 of 64 threads in 0.0390 ms
      [Run 3]: Requeued 64 of 64 threads in 0.0400 ms
      ...
      [Run 100]: Requeued 64 of 64 threads in 0.0390 ms
      Requeued 64 of 64 threads in 0.0399 ms (+-0.37%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-4-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 743a30a8baa0..f600b74216da 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -58,6 +58,7 @@ static struct bench mem_benchmarks[] = {
 static struct bench futex_benchmarks[] = {
 	{ "hash",	"Benchmark for futex hash table",               bench_futex_hash	},
 	{ "wake",	"Benchmark for futex wake calls",               bench_futex_wake	},
+	{ "requeue",	"Benchmark for futex requeue calls",            bench_futex_requeue	},
 	{ "all",	"Test all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit 27db78307481dbba68c5f3563c6cb694b25521d9
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:56 2013 -0800

    perf bench: Add futex-wake microbenchmark
    
    Block a bunch of threads on a futex and wake them up, N at a time.
    
    This program is particularly useful to measure the latency of nthread
    wakeups in non-error situations:  all waiters are queued and all wake
    calls wakeup one or more tasks.
    
    An example run:
    
      $ perf bench futex wake -t 512 -r 100
      Run summary [PID 27823]: blocking on 512 threads (at futex 0x7e10d4), waking up 1 at a time.
    
      [Run 1]: Wokeup 512 of 512 threads in 6.0080 ms
      [Run 2]: Wokeup 512 of 512 threads in 5.2280 ms
      [Run 3]: Wokeup 512 of 512 threads in 4.8300 ms
      ...
      [Run 100]: Wokeup 512 of 512 threads in 5.0100 ms
      Wokeup 512 of 512 threads in 5.0109 ms (+-2.25%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-3-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index a8b0138fc6a0..743a30a8baa0 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -57,6 +57,7 @@ static struct bench mem_benchmarks[] = {
 
 static struct bench futex_benchmarks[] = {
 	{ "hash",	"Benchmark for futex hash table",               bench_futex_hash	},
+	{ "wake",	"Benchmark for futex wake calls",               bench_futex_wake	},
 	{ "all",	"Test all futex benchmarks",			NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit a043971141f163f9845324a2f83502d15011485d
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:55 2013 -0800

    perf bench: Add futex-hash microbenchmark
    
    Introduce futexes to perf-bench and add a program that stresses and
    measures the kernel's implementation of the hash table.
    
    This is a multi-threaded program that simply measures the amount of
    failed futex wait calls - we only want to deal with the hashing
    overhead, so a negative return of futex_wait_setup() is enough to do the
    trick.
    
    An example run:
    
      $ perf bench futex hash -t 32
      Run summary [PID 10989]: 32 threads, each operating on 1024 [private] futexes for 10 secs.
    
      [thread  0] futexes: 0x19d9b10 ... 0x19dab0c [ 418713 ops/sec ]
      [thread  1] futexes: 0x19daca0 ... 0x19dbc9c [ 469913 ops/sec ]
      [thread  2] futexes: 0x19dbe30 ... 0x19dce2c [ 479744 ops/sec ]
      ...
      [thread 31] futexes: 0x19fbb80 ... 0x19fcb7c [ 464179 ops/sec ]
    
      Averaged 454310 operations/sec (+- 0.84%), total secs = 10
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-2-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index e47f90cc7b98..a8b0138fc6a0 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -12,6 +12,7 @@
  *  sched ... scheduler and IPC performance
  *  mem   ... memory access performance
  *  numa  ... NUMA scheduling and MM performance
+ *  futex ... Futex performance
  */
 #include "perf.h"
 #include "util/util.h"
@@ -54,6 +55,12 @@ static struct bench mem_benchmarks[] = {
 	{ NULL,		NULL,						NULL			}
 };
 
+static struct bench futex_benchmarks[] = {
+	{ "hash",	"Benchmark for futex hash table",               bench_futex_hash	},
+	{ "all",	"Test all futex benchmarks",			NULL			},
+	{ NULL,		NULL,						NULL			}
+};
+
 struct collection {
 	const char	*name;
 	const char	*summary;
@@ -61,11 +68,12 @@ struct collection {
 };
 
 static struct collection collections[] = {
-	{ "sched",	"Scheduler and IPC benchmarks",		sched_benchmarks	},
+	{ "sched",	"Scheduler and IPC benchmarks",			sched_benchmarks	},
 	{ "mem",	"Memory access benchmarks",			mem_benchmarks		},
 #ifdef HAVE_LIBNUMA_SUPPORT
 	{ "numa",	"NUMA scheduling and MM benchmarks",		numa_benchmarks		},
 #endif
+	{"futex",       "Futex stressing benchmarks",                   futex_benchmarks        },
 	{ "all",	"All benchmarks",				NULL			},
 	{ NULL,		NULL,						NULL			}
 };

commit 4157922a9070aef6a516573111fb1c0c67b891ac
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Oct 23 14:37:56 2013 +0200

    perf bench: Change the procps visible command-name of invididual benchmark tests plus cleanups
    
    Before this patch, looking at 'perf bench sched pipe' behavior over
    'top' only told us that something related to perf is running:
    
          PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
        19934 mingo     20   0 54836 1296  952 R 18.6  0.0   0:00.56 perf
        19935 mingo     20   0 54836  384   36 S 18.6  0.0   0:00.56 perf
    
    After the patch it's clearly visible what's going on:
    
          PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
        19744 mingo     20   0  125m 3536 2644 R 68.2  0.0   0:01.12 sched-pipe
        19745 mingo     20   0  125m 1172  276 R 68.2  0.0   0:01.12 sched-pipe
    
    The benchmark-subsystem name is concatenated with the individual
    testcase name.
    
    Unfortunately 'perf top' does not show the reconfigured name, possibly
    because it caches ->comm[] values and does not recognize changes to
    them?
    
    Also clean up a few bits in builtin-bench.c while at it and reorganize
    the code and the output strings to be consistent.
    
    Use iterators to access the various arrays. Rename 'suites' concept to
    'benchmark collection' and the 'bench_suite' to 'benchmark/bench'. The
    many repetitions of 'suite' made the code harder to read and understand.
    
    The new output is:
    
      comet:~/tip/tools/perf> ./perf bench
      Usage:
            perf bench [<common options>] <collection> <benchmark> [<options>]
    
            # List of all available benchmark collections:
    
             sched: Scheduler and IPC benchmarks
               mem: Memory access benchmarks
              numa: NUMA scheduling and MM benchmarks
               all: All benchmarks
    
      comet:~/tip/tools/perf> ./perf bench sched
    
            # List of available benchmarks for collection 'sched':
    
         messaging: Benchmark for scheduling and IPC
              pipe: Benchmark for pipe() between two processes
               all: Test all scheduler benchmarks
    
      comet:~/tip/tools/perf> ./perf bench mem
    
            # List of available benchmarks for collection 'mem':
    
            memcpy: Benchmark for memcpy()
            memset: Benchmark for memset() tests
               all: Test all memory benchmarks
    
      comet:~/tip/tools/perf> ./perf bench numa
    
            # List of available benchmarks for collection 'numa':
    
               mem: Benchmark for NUMA workloads
               all: Test all NUMA benchmarks
    
    Individual benchmark modules were not touched.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20131023123756.GA17871@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 33af80fa49cf..e47f90cc7b98 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -1,21 +1,18 @@
 /*
- *
  * builtin-bench.c
  *
- * General benchmarking subsystem provided by perf
+ * General benchmarking collections provided by perf
  *
  * Copyright (C) 2009, Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
- *
  */
 
 /*
+ * Available benchmark collection list:
  *
- * Available subsystem list:
- *  sched ... scheduler and IPC mechanism
+ *  sched ... scheduler and IPC performance
  *  mem   ... memory access performance
- *
+ *  numa  ... NUMA scheduling and MM performance
  */
-
 #include "perf.h"
 #include "util/util.h"
 #include "util/parse-options.h"
@@ -25,112 +22,92 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/prctl.h>
 
-struct bench_suite {
-	const char *name;
-	const char *summary;
-	int (*fn)(int, const char **, const char *);
+typedef int (*bench_fn_t)(int argc, const char **argv, const char *prefix);
+
+struct bench {
+	const char	*name;
+	const char	*summary;
+	bench_fn_t	fn;
 };
-						\
-/* sentinel: easy for help */
-#define suite_all { "all", "Test all benchmark suites", NULL }
 
 #ifdef HAVE_LIBNUMA_SUPPORT
-static struct bench_suite numa_suites[] = {
-	{ "mem",
-	  "Benchmark for NUMA workloads",
-	  bench_numa },
-	suite_all,
-	{ NULL,
-	  NULL,
-	  NULL                  }
+static struct bench numa_benchmarks[] = {
+	{ "mem",	"Benchmark for NUMA workloads",			bench_numa		},
+	{ "all",	"Test all NUMA benchmarks",			NULL			},
+	{ NULL,		NULL,						NULL			}
 };
 #endif
 
-static struct bench_suite sched_suites[] = {
-	{ "messaging",
-	  "Benchmark for scheduler and IPC mechanisms",
-	  bench_sched_messaging },
-	{ "pipe",
-	  "Flood of communication over pipe() between two processes",
-	  bench_sched_pipe      },
-	suite_all,
-	{ NULL,
-	  NULL,
-	  NULL                  }
+static struct bench sched_benchmarks[] = {
+	{ "messaging",	"Benchmark for scheduling and IPC",		bench_sched_messaging	},
+	{ "pipe",	"Benchmark for pipe() between two processes",	bench_sched_pipe	},
+	{ "all",	"Test all scheduler benchmarks",		NULL			},
+	{ NULL,		NULL,						NULL			}
 };
 
-static struct bench_suite mem_suites[] = {
-	{ "memcpy",
-	  "Simple memory copy in various ways",
-	  bench_mem_memcpy },
-	{ "memset",
-	  "Simple memory set in various ways",
-	  bench_mem_memset },
-	suite_all,
-	{ NULL,
-	  NULL,
-	  NULL             }
+static struct bench mem_benchmarks[] = {
+	{ "memcpy",	"Benchmark for memcpy()",			bench_mem_memcpy	},
+	{ "memset",	"Benchmark for memset() tests",			bench_mem_memset	},
+	{ "all",	"Test all memory benchmarks",			NULL			},
+	{ NULL,		NULL,						NULL			}
 };
 
-struct bench_subsys {
-	const char *name;
-	const char *summary;
-	struct bench_suite *suites;
+struct collection {
+	const char	*name;
+	const char	*summary;
+	struct bench	*benchmarks;
 };
 
-static struct bench_subsys subsystems[] = {
+static struct collection collections[] = {
+	{ "sched",	"Scheduler and IPC benchmarks",		sched_benchmarks	},
+	{ "mem",	"Memory access benchmarks",			mem_benchmarks		},
 #ifdef HAVE_LIBNUMA_SUPPORT
-	{ "numa",
-	  "NUMA scheduling and MM behavior",
-	  numa_suites },
+	{ "numa",	"NUMA scheduling and MM benchmarks",		numa_benchmarks		},
 #endif
-	{ "sched",
-	  "scheduler and IPC mechanism",
-	  sched_suites },
-	{ "mem",
-	  "memory access performance",
-	  mem_suites },
-	{ "all",		/* sentinel: easy for help */
-	  "all benchmark subsystem",
-	  NULL },
-	{ NULL,
-	  NULL,
-	  NULL       }
+	{ "all",	"All benchmarks",				NULL			},
+	{ NULL,		NULL,						NULL			}
 };
 
-static void dump_suites(int subsys_index)
+/* Iterate over all benchmark collections: */
+#define for_each_collection(coll) \
+	for (coll = collections; coll->name; coll++)
+
+/* Iterate over all benchmarks within a collection: */
+#define for_each_bench(coll, bench) \
+	for (bench = coll->benchmarks; bench->name; bench++)
+
+static void dump_benchmarks(struct collection *coll)
 {
-	int i;
+	struct bench *bench;
 
-	printf("# List of available suites for %s...\n\n",
-	       subsystems[subsys_index].name);
+	printf("\n        # List of available benchmarks for collection '%s':\n\n", coll->name);
 
-	for (i = 0; subsystems[subsys_index].suites[i].name; i++)
-		printf("%14s: %s\n",
-		       subsystems[subsys_index].suites[i].name,
-		       subsystems[subsys_index].suites[i].summary);
+	for_each_bench(coll, bench)
+		printf("%14s: %s\n", bench->name, bench->summary);
 
 	printf("\n");
-	return;
 }
 
 static const char *bench_format_str;
+
+/* Output/formatting style, exported to benchmark modules: */
 int bench_format = BENCH_FORMAT_DEFAULT;
 
 static const struct option bench_options[] = {
-	OPT_STRING('f', "format", &bench_format_str, "default",
-		    "Specify format style"),
+	OPT_STRING('f', "format", &bench_format_str, "default", "Specify format style"),
 	OPT_END()
 };
 
 static const char * const bench_usage[] = {
-	"perf bench [<common options>] <subsystem> <suite> [<options>]",
+	"perf bench [<common options>] <collection> <benchmark> [<options>]",
 	NULL
 };
 
 static void print_usage(void)
 {
+	struct collection *coll;
 	int i;
 
 	printf("Usage: \n");
@@ -138,11 +115,10 @@ static void print_usage(void)
 		printf("\t%s\n", bench_usage[i]);
 	printf("\n");
 
-	printf("# List of available subsystems...\n\n");
+	printf("        # List of all available benchmark collections:\n\n");
 
-	for (i = 0; subsystems[i].name; i++)
-		printf("%14s: %s\n",
-		       subsystems[i].name, subsystems[i].summary);
+	for_each_collection(coll)
+		printf("%14s: %s\n", coll->name, coll->summary);
 	printf("\n");
 }
 
@@ -159,44 +135,74 @@ static int bench_str2int(const char *str)
 	return BENCH_FORMAT_UNKNOWN;
 }
 
-static void all_suite(struct bench_subsys *subsys)	  /* FROM HERE */
+/*
+ * Run a specific benchmark but first rename the running task's ->comm[]
+ * to something meaningful:
+ */
+static int run_bench(const char *coll_name, const char *bench_name, bench_fn_t fn,
+		     int argc, const char **argv, const char *prefix)
 {
-	int i;
+	int size;
+	char *name;
+	int ret;
+
+	size = strlen(coll_name) + 1 + strlen(bench_name) + 1;
+
+	name = zalloc(size);
+	BUG_ON(!name);
+
+	scnprintf(name, size, "%s-%s", coll_name, bench_name);
+
+	prctl(PR_SET_NAME, name);
+	argv[0] = name;
+
+	ret = fn(argc, argv, prefix);
+
+	free(name);
+
+	return ret;
+}
+
+static void run_collection(struct collection *coll)
+{
+	struct bench *bench;
 	const char *argv[2];
-	struct bench_suite *suites = subsys->suites;
 
 	argv[1] = NULL;
 	/*
 	 * TODO:
-	 * preparing preset parameters for
+	 *
+	 * Preparing preset parameters for
 	 * embedded, ordinary PC, HPC, etc...
-	 * will be helpful
+	 * would be helpful.
 	 */
-	for (i = 0; suites[i].fn; i++) {
-		printf("# Running %s/%s benchmark...\n",
-		       subsys->name,
-		       suites[i].name);
+	for_each_bench(coll, bench) {
+		if (!bench->fn)
+			break;
+		printf("# Running %s/%s benchmark...\n", coll->name, bench->name);
 		fflush(stdout);
 
-		argv[1] = suites[i].name;
-		suites[i].fn(1, argv, NULL);
+		argv[1] = bench->name;
+		run_bench(coll->name, bench->name, bench->fn, 1, argv, NULL);
 		printf("\n");
 	}
 }
 
-static void all_subsystem(void)
+static void run_all_collections(void)
 {
-	int i;
-	for (i = 0; subsystems[i].suites; i++)
-		all_suite(&subsystems[i]);
+	struct collection *coll;
+
+	for_each_collection(coll)
+		run_collection(coll);
 }
 
 int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 {
-	int i, j, status = 0;
+	struct collection *coll;
+	int ret = 0;
 
 	if (argc < 2) {
-		/* No subsystem specified. */
+		/* No collection specified. */
 		print_usage();
 		goto end;
 	}
@@ -206,7 +212,7 @@ int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 
 	bench_format = bench_str2int(bench_format_str);
 	if (bench_format == BENCH_FORMAT_UNKNOWN) {
-		printf("Unknown format descriptor:%s\n", bench_format_str);
+		printf("Unknown format descriptor: '%s'\n", bench_format_str);
 		goto end;
 	}
 
@@ -216,52 +222,51 @@ int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 	}
 
 	if (!strcmp(argv[0], "all")) {
-		all_subsystem();
+		run_all_collections();
 		goto end;
 	}
 
-	for (i = 0; subsystems[i].name; i++) {
-		if (strcmp(subsystems[i].name, argv[0]))
+	for_each_collection(coll) {
+		struct bench *bench;
+
+		if (strcmp(coll->name, argv[0]))
 			continue;
 
 		if (argc < 2) {
-			/* No suite specified. */
-			dump_suites(i);
+			/* No bench specified. */
+			dump_benchmarks(coll);
 			goto end;
 		}
 
 		if (!strcmp(argv[1], "all")) {
-			all_suite(&subsystems[i]);
+			run_collection(coll);
 			goto end;
 		}
 
-		for (j = 0; subsystems[i].suites[j].name; j++) {
-			if (strcmp(subsystems[i].suites[j].name, argv[1]))
+		for_each_bench(coll, bench) {
+			if (strcmp(bench->name, argv[1]))
 				continue;
 
 			if (bench_format == BENCH_FORMAT_DEFAULT)
-				printf("# Running %s/%s benchmark...\n",
-				       subsystems[i].name,
-				       subsystems[i].suites[j].name);
+				printf("# Running '%s/%s' benchmark:\n", coll->name, bench->name);
 			fflush(stdout);
-			status = subsystems[i].suites[j].fn(argc - 1,
-							    argv + 1, prefix);
+			ret = run_bench(coll->name, bench->name, bench->fn, argc-1, argv+1, prefix);
 			goto end;
 		}
 
 		if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {
-			dump_suites(i);
+			dump_benchmarks(coll);
 			goto end;
 		}
 
-		printf("Unknown suite:%s for %s\n", argv[1], argv[0]);
-		status = 1;
+		printf("Unknown benchmark: '%s' for collection '%s'\n", argv[1], argv[0]);
+		ret = 1;
 		goto end;
 	}
 
-	printf("Unknown subsystem:%s\n", argv[0]);
-	status = 1;
+	printf("Unknown collection: '%s'\n", argv[0]);
+	ret = 1;
 
 end:
-	return status;
+	return ret;
 }

commit 89fe808ae777728da6e1d78b7d13562792310d17
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Sep 30 12:07:11 2013 +0200

    tools/perf: Standardize feature support define names to: HAVE_{FEATURE}_SUPPORT
    
    Standardize all the feature flags based on the HAVE_{FEATURE}_SUPPORT naming convention:
    
                    HAVE_ARCH_X86_64_SUPPORT
                    HAVE_BACKTRACE_SUPPORT
                    HAVE_CPLUS_DEMANGLE_SUPPORT
                    HAVE_DWARF_SUPPORT
                    HAVE_ELF_GETPHDRNUM_SUPPORT
                    HAVE_GTK2_SUPPORT
                    HAVE_GTK_INFO_BAR_SUPPORT
                    HAVE_LIBAUDIT_SUPPORT
                    HAVE_LIBELF_MMAP_SUPPORT
                    HAVE_LIBELF_SUPPORT
                    HAVE_LIBNUMA_SUPPORT
                    HAVE_LIBUNWIND_SUPPORT
                    HAVE_ON_EXIT_SUPPORT
                    HAVE_PERF_REGS_SUPPORT
                    HAVE_SLANG_SUPPORT
                    HAVE_STRLCPY_SUPPORT
    
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lkml.kernel.org/n/tip-u3zvqejddfZhtrbYbfhi3spa@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 77298bf892b8..33af80fa49cf 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -35,7 +35,7 @@ struct bench_suite {
 /* sentinel: easy for help */
 #define suite_all { "all", "Test all benchmark suites", NULL }
 
-#ifdef LIBNUMA_SUPPORT
+#ifdef HAVE_LIBNUMA_SUPPORT
 static struct bench_suite numa_suites[] = {
 	{ "mem",
 	  "Benchmark for NUMA workloads",
@@ -80,7 +80,7 @@ struct bench_subsys {
 };
 
 static struct bench_subsys subsystems[] = {
-#ifdef LIBNUMA_SUPPORT
+#ifdef HAVE_LIBNUMA_SUPPORT
 	{ "numa",
 	  "NUMA scheduling and MM behavior",
 	  numa_suites },

commit 79d824e31692d165f6c7d92bf4d1af0b9d969d76
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jan 27 20:51:22 2013 -0500

    perf tools: Make numa benchmark optional
    
    Commit "perf: Add 'perf bench numa mem'..." added a NUMA performance
    benchmark to perf. Make this optional and test for required
    dependencies.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1359337882-21821-1-git-send-email-peter@hurleysoftware.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index e5d514bf5365..77298bf892b8 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -35,6 +35,7 @@ struct bench_suite {
 /* sentinel: easy for help */
 #define suite_all { "all", "Test all benchmark suites", NULL }
 
+#ifdef LIBNUMA_SUPPORT
 static struct bench_suite numa_suites[] = {
 	{ "mem",
 	  "Benchmark for NUMA workloads",
@@ -44,6 +45,7 @@ static struct bench_suite numa_suites[] = {
 	  NULL,
 	  NULL                  }
 };
+#endif
 
 static struct bench_suite sched_suites[] = {
 	{ "messaging",
@@ -78,9 +80,11 @@ struct bench_subsys {
 };
 
 static struct bench_subsys subsystems[] = {
+#ifdef LIBNUMA_SUPPORT
 	{ "numa",
 	  "NUMA scheduling and MM behavior",
 	  numa_suites },
+#endif
 	{ "sched",
 	  "scheduler and IPC mechanism",
 	  sched_suites },

commit 1c13f3c9042f9d222959af7c9da6db93ea9f7e4c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Dec 6 13:51:59 2012 +0100

    perf: Add 'perf bench numa mem' NUMA performance measurement suite
    
    Add a suite of NUMA performance benchmarks.
    
    The goal was simulate the behavior and access patterns of real NUMA
    workloads, via a wide range of parameters, so this tool goes well
    beyond simple bzero() measurements that most NUMA micro-benchmarks use:
    
     - It processes the data and creates a chain of data dependencies,
       like a real workload would. Neither the compiler, nor the
       kernel (via KSM and other optimizations) nor the CPU can
       eliminate parts of the workload.
    
     - It randomizes the initial state and also randomizes the target
       addresses of the processing - it's not a simple forward scan
       of addresses.
    
     - It provides flexible options to set process, thread and memory
       relationship information: -G sets "global" memory shared between
       all test processes, -P sets "process" memory shared by all
       threads of a process and -T sets "thread" private memory.
    
     - There's a NUMA convergence monitoring and convergence latency
       measurement option via -c and -m.
    
     - Micro-sleeps and synchronization can be injected to provoke lock
       contention and scheduling, via the -u and -S options. This simulates
       IO and contention.
    
     - The -x option instructs the workload to 'perturb' itself artificially
       every N seconds, by moving to the first and last CPU of the system
       periodically. This way the stability of convergence equilibrium and
       the number of steps taken for the scheduler to reach equilibrium again
       can be measured.
    
     - The amount of work can be specified via the -l loop count, and/or
       via a -s seconds-timeout value.
    
     - CPU and node memory binding options, to test hard binding scenarios.
       THP can be turned on and off via madvise() calls.
    
     - Live reporting of convergence progress in an 'at glance' output format.
       Printing of convergence and deconvergence events.
    
    The 'perf bench numa mem -a' option will start an array of about 30
    individual tests that will each output such measurements:
    
     # Running  5x5-bw-thread, "perf bench numa mem -p 5 -t 5 -P 512 -s 20 -zZ0q --thp  1"
      5x5-bw-thread,                         20.276, secs,           runtime-max/thread
      5x5-bw-thread,                         20.004, secs,           runtime-min/thread
      5x5-bw-thread,                         20.155, secs,           runtime-avg/thread
      5x5-bw-thread,                          0.671, %,              spread-runtime/thread
      5x5-bw-thread,                         21.153, GB,             data/thread
      5x5-bw-thread,                        528.818, GB,             data-total
      5x5-bw-thread,                          0.959, nsecs,          runtime/byte/thread
      5x5-bw-thread,                          1.043, GB/sec,         thread-speed
      5x5-bw-thread,                         26.081, GB/sec,         total-speed
    
    See the help text and the code for more details.
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Hugh Dickins <hughd@google.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index afd1255a632f..e5d514bf5365 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -35,6 +35,16 @@ struct bench_suite {
 /* sentinel: easy for help */
 #define suite_all { "all", "Test all benchmark suites", NULL }
 
+static struct bench_suite numa_suites[] = {
+	{ "mem",
+	  "Benchmark for NUMA workloads",
+	  bench_numa },
+	suite_all,
+	{ NULL,
+	  NULL,
+	  NULL                  }
+};
+
 static struct bench_suite sched_suites[] = {
 	{ "messaging",
 	  "Benchmark for scheduler and IPC mechanisms",
@@ -68,6 +78,9 @@ struct bench_subsys {
 };
 
 static struct bench_subsys subsystems[] = {
+	{ "numa",
+	  "NUMA scheduling and MM behavior",
+	  numa_suites },
 	{ "sched",
 	  "scheduler and IPC mechanism",
 	  sched_suites },

commit 9b494ea2f5638184bc203a30062b32b9a9a05d9e
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Tue Jan 8 18:39:26 2013 +0900

    perf bench: Flush stdout before starting bench suite
    
    perf bench prints header message for bench suite before starting the
    benchmark.  However if the stdout is redirected to a file and bench
    suite forks child processes this (and possibly other debugging
    messages too) will be repeated multiple times.
    
      $ perf bench sched messaging
      # Running sched/messaging benchmark...
      # 20 sender and receiver processes per group
      # 10 groups == 400 processes run
    
           Total time: 0.100 [sec]
    
      $ perf bench sched messaging > result.txt
      $ wc -l result.txt
      391
    
    In this file, there were so many "Running sched/messaging benchmark..."
    lines.  This was because stdout is converted to fully-buffered due to
    the redirection and inherited child processes.  Other lines are printed
    after reaping all those tasks.
    
    So fix it by flushing stdout before starting bench suites.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1357637966-8216-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index cae9a5fd2ecf..afd1255a632f 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -159,6 +159,7 @@ static void all_suite(struct bench_subsys *subsys)	  /* FROM HERE */
 		printf("# Running %s/%s benchmark...\n",
 		       subsys->name,
 		       suites[i].name);
+		fflush(stdout);
 
 		argv[1] = suites[i].name;
 		suites[i].fn(1, argv, NULL);
@@ -225,6 +226,7 @@ int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 				printf("# Running %s/%s benchmark...\n",
 				       subsystems[i].name,
 				       subsystems[i].suites[j].name);
+			fflush(stdout);
 			status = subsystems[i].suites[j].fn(argc - 1,
 							    argv + 1, prefix);
 			goto end;

commit 1d037ca1648b775277fc96401ec2aa233724906c
Author: Irina Tirdea <irina.tirdea@gmail.com>
Date:   Tue Sep 11 01:15:03 2012 +0300

    perf tools: Use __maybe_used for unused variables
    
    perf defines both __used and __unused variables to use for marking
    unused variables. The variable __used is defined to
    __attribute__((__unused__)), which contradicts the kernel definition to
    __attribute__((__used__)) for new gcc versions. On Android, __used is
    also defined in system headers and this leads to warnings like: warning:
    '__used__' attribute ignored
    
    __unused is not defined in the kernel and is not a standard definition.
    If __unused is included everywhere instead of __used, this leads to
    conflicts with glibc headers, since glibc has a variables with this name
    in its headers.
    
    The best approach is to use __maybe_unused, the definition used in the
    kernel for __attribute__((unused)). In this way there is only one
    definition in perf sources (instead of 2 definitions that point to the
    same thing: __used and __unused) and it works on both Linux and Android.
    This patch simply replaces all instances of __used and __unused with
    __maybe_unused.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Acked-by: Pekka Enberg <penberg@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1347315303-29906-7-git-send-email-irina.tirdea@intel.com
    [ committer note: fixed up conflict with a116e05 in builtin-sched.c ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 1f3100216448..cae9a5fd2ecf 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -173,7 +173,7 @@ static void all_subsystem(void)
 		all_suite(&subsystems[i]);
 }
 
-int cmd_bench(int argc, const char **argv, const char *prefix __used)
+int cmd_bench(int argc, const char **argv, const char *prefix __maybe_unused)
 {
 	int i, j, status = 0;
 

commit 08942f6d5d992e9486b07653fd87ea8182a22fa0
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Jun 20 15:08:06 2012 +0900

    perf bench: Documentation update
    
    The current perf-bench documentation has a couple of typos and even
    lacks entire description of mem subsystem. Fix it.
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1340172486-17805-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index b0e74ab2d7a2..1f3100216448 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -33,7 +33,7 @@ struct bench_suite {
 };
 						\
 /* sentinel: easy for help */
-#define suite_all { "all", "test all suite (pseudo suite)", NULL }
+#define suite_all { "all", "Test all benchmark suites", NULL }
 
 static struct bench_suite sched_suites[] = {
 	{ "messaging",
@@ -75,7 +75,7 @@ static struct bench_subsys subsystems[] = {
 	  "memory access performance",
 	  mem_suites },
 	{ "all",		/* sentinel: easy for help */
-	  "test all subsystem (pseudo subsystem)",
+	  "all benchmark subsystem",
 	  NULL },
 	{ NULL,
 	  NULL,

commit be3de80dc2e671d9ee15e69fe9cd84d2b71e2225
Author: Jan Beulich <jbeulich@suse.com>
Date:   Tue Jan 24 10:03:22 2012 -0200

    perf bench: Also allow measuring memset()
    
    This simply clones the respective memcpy() implementation.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/4F16D743020000780006D735@nat28.tlf.novell.com
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index fcb96269852a..b0e74ab2d7a2 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -52,6 +52,9 @@ static struct bench_suite mem_suites[] = {
 	{ "memcpy",
 	  "Simple memory copy in various ways",
 	  bench_mem_memcpy },
+	{ "memset",
+	  "Simple memory set in various ways",
+	  bench_mem_memset },
 	suite_all,
 	{ NULL,
 	  NULL,

commit edb7c60e27c1baff38d82440dc52eaffac9a45f4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon May 17 16:22:41 2010 -0300

    perf options: Type check all the remaining OPT_ variants
    
    OPT_SET_INT was renamed to OPT_SET_UINT since the only use in these
    tools is to set something that has an enum type, that is builtin
    compatible with unsigned int.
    
    Several string constifications were done to make OPT_STRING require a
    const char * type.
    
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 46996774e559..fcb96269852a 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -95,7 +95,7 @@ static void dump_suites(int subsys_index)
 	return;
 }
 
-static char *bench_format_str;
+static const char *bench_format_str;
 int bench_format = BENCH_FORMAT_DEFAULT;
 
 static const struct option bench_options[] = {
@@ -126,7 +126,7 @@ static void print_usage(void)
 	printf("\n");
 }
 
-static int bench_str2int(char *str)
+static int bench_str2int(const char *str)
 {
 	if (!str)
 		return BENCH_FORMAT_DEFAULT;

commit 2044279d1e07c90edd64324f09c7adf1acfc42e5
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Sun Dec 13 17:01:59 2009 +0900

    perf bench: Add "all" pseudo subsystem and "all" pseudo suite
    
    This patch adds a new "all" pseudo subsystem and an "all" pseudo
    suite. These are for testing all subsystem and its all suite, or
    all suite of one subsystem.
    
    (This patch also contains a few trivial comment fixes for
    bench/* and output style fixes. I judged that there are no
    necessity to make them into individual patch.)
    
    Example of use:
    
    | % ./perf bench sched all                      # Test all suites of sched subsystem
    | # Running sched/messaging benchmark...
    | # 20 sender and receiver processes per group
    | # 10 groups == 400 processes run
    |
    |      Total time: 0.414 [sec]
    |
    | # Running sched/pipe benchmark...
    | # Extecuted 1000000 pipe operations between two tasks
    |
    |      Total time: 10.999 [sec]
    |
    |       10.999317 usecs/op
    |           90914 ops/sec
    |
    | % ./perf bench all                            # Test all suites of all subsystems
    | # Running sched/messaging benchmark...
    | # 20 sender and receiver processes per group
    | # 10 groups == 400 processes run
    |
    |      Total time: 0.420 [sec]
    |
    | # Running sched/pipe benchmark...
    | # Extecuted 1000000 pipe operations between two tasks
    |
    |      Total time: 11.741 [sec]
    |
    |       11.741346 usecs/op
    |           85169 ops/sec
    |
    | # Running mem/memcpy benchmark...
    | # Copying 1MB Bytes from 0x7ff33e920010 to 0x7ff3401ae010 ...
    |
    |      808.407437 MB/Sec
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <1260691319-4683-1-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index e043eb83092a..46996774e559 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -31,6 +31,9 @@ struct bench_suite {
 	const char *summary;
 	int (*fn)(int, const char **, const char *);
 };
+						\
+/* sentinel: easy for help */
+#define suite_all { "all", "test all suite (pseudo suite)", NULL }
 
 static struct bench_suite sched_suites[] = {
 	{ "messaging",
@@ -39,6 +42,7 @@ static struct bench_suite sched_suites[] = {
 	{ "pipe",
 	  "Flood of communication over pipe() between two processes",
 	  bench_sched_pipe      },
+	suite_all,
 	{ NULL,
 	  NULL,
 	  NULL                  }
@@ -48,6 +52,7 @@ static struct bench_suite mem_suites[] = {
 	{ "memcpy",
 	  "Simple memory copy in various ways",
 	  bench_mem_memcpy },
+	suite_all,
 	{ NULL,
 	  NULL,
 	  NULL             }
@@ -66,6 +71,9 @@ static struct bench_subsys subsystems[] = {
 	{ "mem",
 	  "memory access performance",
 	  mem_suites },
+	{ "all",		/* sentinel: easy for help */
+	  "test all subsystem (pseudo subsystem)",
+	  NULL },
 	{ NULL,
 	  NULL,
 	  NULL       }
@@ -75,11 +83,11 @@ static void dump_suites(int subsys_index)
 {
 	int i;
 
-	printf("List of available suites for %s...\n\n",
+	printf("# List of available suites for %s...\n\n",
 	       subsystems[subsys_index].name);
 
 	for (i = 0; subsystems[subsys_index].suites[i].name; i++)
-		printf("\t%s: %s\n",
+		printf("%14s: %s\n",
 		       subsystems[subsys_index].suites[i].name,
 		       subsystems[subsys_index].suites[i].summary);
 
@@ -110,10 +118,10 @@ static void print_usage(void)
 		printf("\t%s\n", bench_usage[i]);
 	printf("\n");
 
-	printf("List of available subsystems...\n\n");
+	printf("# List of available subsystems...\n\n");
 
 	for (i = 0; subsystems[i].name; i++)
-		printf("\t%s: %s\n",
+		printf("%14s: %s\n",
 		       subsystems[i].name, subsystems[i].summary);
 	printf("\n");
 }
@@ -131,6 +139,37 @@ static int bench_str2int(char *str)
 	return BENCH_FORMAT_UNKNOWN;
 }
 
+static void all_suite(struct bench_subsys *subsys)	  /* FROM HERE */
+{
+	int i;
+	const char *argv[2];
+	struct bench_suite *suites = subsys->suites;
+
+	argv[1] = NULL;
+	/*
+	 * TODO:
+	 * preparing preset parameters for
+	 * embedded, ordinary PC, HPC, etc...
+	 * will be helpful
+	 */
+	for (i = 0; suites[i].fn; i++) {
+		printf("# Running %s/%s benchmark...\n",
+		       subsys->name,
+		       suites[i].name);
+
+		argv[1] = suites[i].name;
+		suites[i].fn(1, argv, NULL);
+		printf("\n");
+	}
+}
+
+static void all_subsystem(void)
+{
+	int i;
+	for (i = 0; subsystems[i].suites; i++)
+		all_suite(&subsystems[i]);
+}
+
 int cmd_bench(int argc, const char **argv, const char *prefix __used)
 {
 	int i, j, status = 0;
@@ -155,6 +194,11 @@ int cmd_bench(int argc, const char **argv, const char *prefix __used)
 		goto end;
 	}
 
+	if (!strcmp(argv[0], "all")) {
+		all_subsystem();
+		goto end;
+	}
+
 	for (i = 0; subsystems[i].name; i++) {
 		if (strcmp(subsystems[i].name, argv[0]))
 			continue;
@@ -165,6 +209,11 @@ int cmd_bench(int argc, const char **argv, const char *prefix __used)
 			goto end;
 		}
 
+		if (!strcmp(argv[1], "all")) {
+			all_suite(&subsystems[i]);
+			goto end;
+		}
+
 		for (j = 0; subsystems[i].suites[j].name; j++) {
 			if (strcmp(subsystems[i].suites[j].name, argv[1]))
 				continue;

commit 827f3b4974c5db2968d4979fe6a0ae00ab37bdd8
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Wed Nov 18 00:20:09 2009 +0900

    perf bench: Add memcpy() benchmark
    
    'perf bench mem memcpy' is a benchmark suite for measuring memcpy()
    performance.
    
    Example on a Intel(R) Core(TM)2 Duo CPU E6850 @ 3.00GHz:
    
    | % perf bench mem memcpy -l 1GB
    | # Running mem/memcpy benchmark...
    | # Copying 1MB Bytes from 0xb7d98008 to 0xb7e99008 ...
    |
    |     726.216412 MB/Sec
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <1258471212-30281-1-git-send-email-mitake@dcl.info.waseda.ac.jp>
    [ v2: updated changelog, clarified history of builtin-bench.c ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 90c39baae0de..e043eb83092a 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -12,6 +12,7 @@
  *
  * Available subsystem list:
  *  sched ... scheduler and IPC mechanism
+ *  mem   ... memory access performance
  *
  */
 
@@ -43,6 +44,15 @@ static struct bench_suite sched_suites[] = {
 	  NULL                  }
 };
 
+static struct bench_suite mem_suites[] = {
+	{ "memcpy",
+	  "Simple memory copy in various ways",
+	  bench_mem_memcpy },
+	{ NULL,
+	  NULL,
+	  NULL             }
+};
+
 struct bench_subsys {
 	const char *name;
 	const char *summary;
@@ -53,9 +63,12 @@ static struct bench_subsys subsystems[] = {
 	{ "sched",
 	  "scheduler and IPC mechanism",
 	  sched_suites },
+	{ "mem",
+	  "memory access performance",
+	  mem_suites },
 	{ NULL,
 	  NULL,
-	  NULL         }
+	  NULL       }
 };
 
 static void dump_suites(int subsys_index)

commit 79e295d4bd0f524257299e7c4e42f643f21abcc2
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Wed Nov 11 00:04:00 2009 +0900

    perf bench: Improve builtin-bench.c for more friendly output
    
    This patch makes output of perf bench more friendly.
    Current style of putput, keeping user wait
    and printing everything suddenly when we finish,
    may confuse users.
    
    So I improved it:
    
     | % perf bench sched messaging
     | # Running sched/messaging benchmark...  <- printed right after invocation
     | # 20 sender and receiver processes per group
     | # 10 groups == 400 processes run
     |
     |      Total time: 1.476 [sec]
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1257865442-20252-2-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index c7505eaff84b..90c39baae0de 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -156,6 +156,10 @@ int cmd_bench(int argc, const char **argv, const char *prefix __used)
 			if (strcmp(subsystems[i].suites[j].name, argv[1]))
 				continue;
 
+			if (bench_format == BENCH_FORMAT_DEFAULT)
+				printf("# Running %s/%s benchmark...\n",
+				       subsystems[i].name,
+				       subsystems[i].suites[j].name);
 			status = subsystems[i].suites[j].fn(argc - 1,
 							    argv + 1, prefix);
 			goto end;

commit 386d7e9e542c2115d5d300747e57f503458a1617
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Tue Nov 10 08:20:00 2009 +0900

    perf bench: Modify builtin-bench.c for processing common options
    
    This patch modifies builtin-bench.c for processing common
    options. The first option added is "--format".
    Users of perf bench will be able to specify output style by
    --format.
    
    Usage example:
    
     % ./perf bench sched messaging         # with no style specify
     (20 sender and receiver processes per group)
     (10 groups == 400 processes run)
    
             Total time:1.431 sec
    
     % ./perf bench --format=simple sched messaging # specified
     simple 1.431
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1257808802-9420-3-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
index 31f41643b0cd..c7505eaff84b 100644
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@ -74,53 +74,104 @@ static void dump_suites(int subsys_index)
 	return;
 }
 
+static char *bench_format_str;
+int bench_format = BENCH_FORMAT_DEFAULT;
+
+static const struct option bench_options[] = {
+	OPT_STRING('f', "format", &bench_format_str, "default",
+		    "Specify format style"),
+	OPT_END()
+};
+
+static const char * const bench_usage[] = {
+	"perf bench [<common options>] <subsystem> <suite> [<options>]",
+	NULL
+};
+
+static void print_usage(void)
+{
+	int i;
+
+	printf("Usage: \n");
+	for (i = 0; bench_usage[i]; i++)
+		printf("\t%s\n", bench_usage[i]);
+	printf("\n");
+
+	printf("List of available subsystems...\n\n");
+
+	for (i = 0; subsystems[i].name; i++)
+		printf("\t%s: %s\n",
+		       subsystems[i].name, subsystems[i].summary);
+	printf("\n");
+}
+
+static int bench_str2int(char *str)
+{
+	if (!str)
+		return BENCH_FORMAT_DEFAULT;
+
+	if (!strcmp(str, BENCH_FORMAT_DEFAULT_STR))
+		return BENCH_FORMAT_DEFAULT;
+	else if (!strcmp(str, BENCH_FORMAT_SIMPLE_STR))
+		return BENCH_FORMAT_SIMPLE;
+
+	return BENCH_FORMAT_UNKNOWN;
+}
+
 int cmd_bench(int argc, const char **argv, const char *prefix __used)
 {
 	int i, j, status = 0;
 
 	if (argc < 2) {
 		/* No subsystem specified. */
-		printf("Usage: perf bench <subsystem> <suite> [<options>]\n\n");
-		printf("List of available subsystems...\n\n");
+		print_usage();
+		goto end;
+	}
 
-		for (i = 0; subsystems[i].name; i++)
-			printf("\t%s: %s\n",
-			       subsystems[i].name, subsystems[i].summary);
-		printf("\n");
+	argc = parse_options(argc, argv, bench_options, bench_usage,
+			     PARSE_OPT_STOP_AT_NON_OPTION);
+
+	bench_format = bench_str2int(bench_format_str);
+	if (bench_format == BENCH_FORMAT_UNKNOWN) {
+		printf("Unknown format descriptor:%s\n", bench_format_str);
+		goto end;
+	}
 
+	if (argc < 1) {
+		print_usage();
 		goto end;
 	}
 
 	for (i = 0; subsystems[i].name; i++) {
-		if (strcmp(subsystems[i].name, argv[1]))
+		if (strcmp(subsystems[i].name, argv[0]))
 			continue;
 
-		if (argc < 3) {
+		if (argc < 2) {
 			/* No suite specified. */
 			dump_suites(i);
 			goto end;
 		}
 
 		for (j = 0; subsystems[i].suites[j].name; j++) {
-			if (strcmp(subsystems[i].suites[j].name, argv[2]))
+			if (strcmp(subsystems[i].suites[j].name, argv[1]))
 				continue;
 
-			status = subsystems[i].suites[j].fn(argc - 2,
-							    argv + 2, prefix);
+			status = subsystems[i].suites[j].fn(argc - 1,
+							    argv + 1, prefix);
 			goto end;
 		}
 
-		if (!strcmp(argv[2], "-h") || !strcmp(argv[2], "--help")) {
+		if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {
 			dump_suites(i);
 			goto end;
 		}
 
-		printf("Unknown suite:%s for %s\n", argv[2], argv[1]);
+		printf("Unknown suite:%s for %s\n", argv[1], argv[0]);
 		status = 1;
 		goto end;
 	}
 
-	printf("Unknown subsystem:%s\n", argv[1]);
+	printf("Unknown subsystem:%s\n", argv[0]);
 	status = 1;
 
 end:

commit 629cc356653719c206a05f4dee5c5e242edb6546
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Thu Nov 5 09:31:34 2009 +0900

    perf bench: Add builtin-bench.c: General framework for benchmark suites
    
    This patch adds builtin-bench.c
    builtin-bench.c is a general framework for benchmark suites.
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: Jiri Kosina <jkosina@suse.cz>
    LKML-Reference: <1257381097-4743-5-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/builtin-bench.c b/tools/perf/builtin-bench.c
new file mode 100644
index 000000000000..31f41643b0cd
--- /dev/null
+++ b/tools/perf/builtin-bench.c
@@ -0,0 +1,128 @@
+/*
+ *
+ * builtin-bench.c
+ *
+ * General benchmarking subsystem provided by perf
+ *
+ * Copyright (C) 2009, Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
+ *
+ */
+
+/*
+ *
+ * Available subsystem list:
+ *  sched ... scheduler and IPC mechanism
+ *
+ */
+
+#include "perf.h"
+#include "util/util.h"
+#include "util/parse-options.h"
+#include "builtin.h"
+#include "bench/bench.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+struct bench_suite {
+	const char *name;
+	const char *summary;
+	int (*fn)(int, const char **, const char *);
+};
+
+static struct bench_suite sched_suites[] = {
+	{ "messaging",
+	  "Benchmark for scheduler and IPC mechanisms",
+	  bench_sched_messaging },
+	{ "pipe",
+	  "Flood of communication over pipe() between two processes",
+	  bench_sched_pipe      },
+	{ NULL,
+	  NULL,
+	  NULL                  }
+};
+
+struct bench_subsys {
+	const char *name;
+	const char *summary;
+	struct bench_suite *suites;
+};
+
+static struct bench_subsys subsystems[] = {
+	{ "sched",
+	  "scheduler and IPC mechanism",
+	  sched_suites },
+	{ NULL,
+	  NULL,
+	  NULL         }
+};
+
+static void dump_suites(int subsys_index)
+{
+	int i;
+
+	printf("List of available suites for %s...\n\n",
+	       subsystems[subsys_index].name);
+
+	for (i = 0; subsystems[subsys_index].suites[i].name; i++)
+		printf("\t%s: %s\n",
+		       subsystems[subsys_index].suites[i].name,
+		       subsystems[subsys_index].suites[i].summary);
+
+	printf("\n");
+	return;
+}
+
+int cmd_bench(int argc, const char **argv, const char *prefix __used)
+{
+	int i, j, status = 0;
+
+	if (argc < 2) {
+		/* No subsystem specified. */
+		printf("Usage: perf bench <subsystem> <suite> [<options>]\n\n");
+		printf("List of available subsystems...\n\n");
+
+		for (i = 0; subsystems[i].name; i++)
+			printf("\t%s: %s\n",
+			       subsystems[i].name, subsystems[i].summary);
+		printf("\n");
+
+		goto end;
+	}
+
+	for (i = 0; subsystems[i].name; i++) {
+		if (strcmp(subsystems[i].name, argv[1]))
+			continue;
+
+		if (argc < 3) {
+			/* No suite specified. */
+			dump_suites(i);
+			goto end;
+		}
+
+		for (j = 0; subsystems[i].suites[j].name; j++) {
+			if (strcmp(subsystems[i].suites[j].name, argv[2]))
+				continue;
+
+			status = subsystems[i].suites[j].fn(argc - 2,
+							    argv + 2, prefix);
+			goto end;
+		}
+
+		if (!strcmp(argv[2], "-h") || !strcmp(argv[2], "--help")) {
+			dump_suites(i);
+			goto end;
+		}
+
+		printf("Unknown suite:%s for %s\n", argv[2], argv[1]);
+		status = 1;
+		goto end;
+	}
+
+	printf("Unknown subsystem:%s\n", argv[1]);
+	status = 1;
+
+end:
+	return status;
+}
