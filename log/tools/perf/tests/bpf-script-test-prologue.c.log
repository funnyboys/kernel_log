commit 5875cf4cd32ea08d0d6abb82091f2d1f7cd6889f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jun 13 18:29:05 2019 -0300

    perf tests: Add missing SPDX headers
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-p0kg493z2m8qizjbdefzip1i@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/tests/bpf-script-test-prologue.c b/tools/perf/tests/bpf-script-test-prologue.c
index 43f1e16486f4..bd83d364cf30 100644
--- a/tools/perf/tests/bpf-script-test-prologue.c
+++ b/tools/perf/tests/bpf-script-test-prologue.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * bpf-script-test-prologue.c
  * Test BPF prologue

commit db26984a363e8b8e35783c402978e8acdf9041a5
Author: Wang Nan <wangnan0@huawei.com>
Date:   Tue Aug 15 11:21:59 2017 +0200

    perf bpf: Fix endianness problem when loading parameters in prologue
    
    Perf's BPF prologue generator unconditionally fetches 8 bytes for
    function parameters, which causes problems on big endian machines. Thomas
    gives a detailed analysis for this problem:
    
     http://lkml.kernel.org/r/968ebda5-abe4-8830-8d69-49f62529d151@linux.vnet.ibm.com
    
     ---- 8< ----
      I investigated perf test BPF for s390x and have a question regarding
      the 38.3 subtest (bpf-prologue test) which fails on s390x.
    
      When I turn on trace_printk in tests/bpf-script-test-prologue.c
      I see this output in /sys/kernel/debug/tracing/trace:
    
      [root@s8360047 perf]# cat /sys/kernel/debug/tracing/trace
      perf-30229 [000] d..2 170161.535791: : f_mode 2001d00000000 offset:0 orig:0
      perf-30229 [000] d..2 170161.535809: : f_mode 6001f00000000 offset:0 orig:0
      perf-30229 [000] d..2 170161.535815: : f_mode 6001f00000000 offset:1 orig:0
      perf-30229 [000] d..2 170161.535819: : f_mode 2001d00000000 offset:1 orig:0
      perf-30229 [000] d..2 170161.535822: : f_mode 2001d00000000 offset:2 orig:1
      perf-30229 [000] d..2 170161.535825: : f_mode 6001f00000000 offset:2 orig:1
      perf-30229 [000] d..2 170161.535828: : f_mode 6001f00000000 offset:3 orig:1
      perf-30229 [000] d..2 170161.535832: : f_mode 2001d00000000 offset:3 orig:1
      perf-30229 [000] d..2 170161.535835: : f_mode 2001d00000000 offset:4 orig:0
      perf-30229 [000] d..2 170161.535841: : f_mode 6001f00000000 offset:4 orig:0
    
      [...]
    
      There are 3 parameters the eBPF program tests/bpf-script-test-prologue.c
      accesses: f_mode (member of struct file at offset 140) offset and orig.  They
      are parameters of the lseek() system call triggered in this test case in
      function llseek_loop().
    
      What is really strange is the value of f_mode. It is an 8 byte value, whereas
      in the probe event it is defined as a 4 byte value.  The lower 4 bytes are all
      zero and do not belong to member f_mode.  The correct value should be 2001d for
      read-only and 6001f for read-write open mode.
    
      Here is the output of the 'perf test -vv bpf' trace:
      Try to find probe point from debuginfo.
      Matched function: null_lseek [2d9310d]
       Probe point found: null_lseek+0
      Searching 'file' variable in context.
      Converting variable file into trace event.
      converting f_mode in file
      f_mode type is unsigned int.
      Opening /sys/kernel/debug/tracing//README write=0
      Searching 'offset' variable in context.
      Converting variable offset into trace event.
      offset type is long long int.
      Searching 'orig' variable in context.
      Converting variable orig into trace event.
      orig type is int.
      Found 1 probe_trace_events.
      Opening /sys/kernel/debug/tracing//kprobe_events write=1
      Writing event: p:perf_bpf_probe/func _text+8794224 f_mode=+140(%r2):x32
     ---- 8< ----
    
    This patch parses the type of each argument and converts data from memory to
    expected type.
    
    Now the test runs successfully on 4.13.0-rc5:
    
      [root@s8360046 perf]# ./perf test  bpf
      38: BPF filter                                 :
      38.1: Basic BPF filtering                      : Ok
      38.2: BPF pinning                              : Ok
      38.3: BPF prologue generation                  : Ok
      38.4: BPF relocation checker                   : Ok
      [root@s8360046 perf]#
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/20170815092159.31912-1-tmricht@linux.vnet.ibm.com
    Signed-off-by: Thomas-Mich Richter <tmricht@linux.vnet.ibm.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/tests/bpf-script-test-prologue.c b/tools/perf/tests/bpf-script-test-prologue.c
index b4ebc75e25ae..43f1e16486f4 100644
--- a/tools/perf/tests/bpf-script-test-prologue.c
+++ b/tools/perf/tests/bpf-script-test-prologue.c
@@ -26,9 +26,11 @@ static void (*bpf_trace_printk)(const char *fmt, int fmt_size, ...) =
 	(void *) 6;
 
 SEC("func=null_lseek file->f_mode offset orig")
-int bpf_func__null_lseek(void *ctx, int err, unsigned long f_mode,
+int bpf_func__null_lseek(void *ctx, int err, unsigned long _f_mode,
 			 unsigned long offset, unsigned long orig)
 {
+	fmode_t f_mode = (fmode_t)_f_mode;
+
 	if (err)
 		return 0;
 	if (f_mode & FMODE_WRITE)

commit 9b57fb7e35957c6838f89f4ed7e3f8433a4bbfc5
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jun 21 02:32:03 2017 +0800

    perf test llvm: Avoid error when PROFILE_ALL_BRANCHES is set
    
    The 'if' keyword is a define that expands to complex code when
    CONFIG_PROFILE_ALL_BRANCHES is selected, which causes a 'perf test LLVM'
    failure like:
    
      $ ./perf test LLVM
      35: LLVM search and compile                    :
      35.1: Basic BPF llvm compile                    : Ok
      35.2: kbuild searching                          : Ok
      35.3: Compile source for BPF prologue generation: FAILED!
      35.4: Compile source for BPF relocation         : Skip
    
    The only affected test case is bpf-script-test-prologue.c
    because it uses kernel headers and has 'if' inside.
    
    This patch undefines 'if' to make it passes perf test.
    
    More detailed analysis from a message in this thread, also by Wang:
    
    The problem is caused by following relocation information:
    
      $ readelf -a ./llvmsubtest3
      ...
         [ 5] _ftrace_branch    PROGBITS         0000000000000000  00000260
              00000000000000a0  0000000000000000  WA       0     0     4
      ...
      Relocation section '.relfunc=null_lseek file->f_mode offset orig' at
      offset 0x490 contains 4 entries:
         Offset          Info           Type           Sym. Value    Sym. Name
      000000000038  000b00000001 unrecognized: 1       0000000000000000 _ftrace_branch
      0000000000b0  000b00000001 unrecognized: 1       0000000000000000 _ftrace_branch
      000000000128  000b00000001 unrecognized: 1       0000000000000000 _ftrace_branch
      0000000001c0  000b00000001 unrecognized: 1       0000000000000000 _ftrace_branch
    
      Relocation section '.rel_ftrace_branch' at offset 0x4d0 contains 8 entries:
         Offset          Info           Type           Sym. Value    Sym. Name
      000000000000  000200000001 unrecognized: 1       0000000000000000 .L__func__.bpf_func__n
      000000000008  000100000001 unrecognized: 1       0000000000000015 .L.str
      000000000028  000200000001 unrecognized: 1       0000000000000000 .L__func__.bpf_func__n
      000000000030  000100000001 unrecognized: 1       0000000000000015 .L.str
      000000000050  000200000001 unrecognized: 1       0000000000000000 .L__func__.bpf_func__n
      000000000058  000100000001 unrecognized: 1       0000000000000015 .L.str
      000000000078  000200000001 unrecognized: 1       0000000000000000 .L__func__.bpf_func__n
      000000000080  000100000001 unrecognized: 1       0000000000000015 .L.str
      ...
    
    So I think the failure is because you enabled CONFIG_PROFILE_ALL_BRANCHES.
    
    I can reproduce your buggy result by selecting
    CONFIG_PROFILE_ALL_BRANCHES in my kbuild:
    
      $ ./perf test LLVM
      35: LLVM search and compile                    :
      35.1: Basic BPF llvm compile                    : Ok
      35.2: kbuild searching                          : Ok
      35.3: Compile source for BPF prologue generation: FAILED!
      35.4: Compile source for BPF relocation         : Skip
    
    Simply undef CONFIG_PROFILE_ALL_BRANCHES in clang opts not working
    because it is introduced by "#include <uapi/linux/fs.h>", which override
    cmdline options. So I think the best way is to undefine 'if' inside BPF
    script.
    
    Reported-and-Tested-by: Thomas-Mich Richter <tmricht@linux.vnet.ibm.com>
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Cc: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/r/20170620183203.2517-1-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/tests/bpf-script-test-prologue.c b/tools/perf/tests/bpf-script-test-prologue.c
index 7230e62c70fc..b4ebc75e25ae 100644
--- a/tools/perf/tests/bpf-script-test-prologue.c
+++ b/tools/perf/tests/bpf-script-test-prologue.c
@@ -10,6 +10,15 @@
 
 #include <uapi/linux/fs.h>
 
+/*
+ * If CONFIG_PROFILE_ALL_BRANCHES is selected,
+ * 'if' is redefined after include kernel header.
+ * Recover 'if' for BPF object code.
+ */
+#ifdef if
+# undef if
+#endif
+
 #define FMODE_READ		0x1
 #define FMODE_WRITE		0x2
 

commit bbb7d4925a05ecd5bbfdbc1147d402b0db203a5a
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Nov 16 12:10:14 2015 +0000

    perf test: Test the BPF prologue adding infrastructure
    
    This patch introduces a new BPF script to test the BPF prologue adding
    routines. The new script probes at null_lseek, which is the function pointer
    used when we try to lseek on '/dev/null'.
    
    The null_lseek function is chosen because it is used by function pointers, so
    we don't need to consider inlining and LTO.
    
    By extracting file->f_mode, bpf-script-test-prologue.c should know whether the
    file is writable or readonly. According to llseek_loop() and
    bpf-script-test-prologue.c, one fourth of total lseeks should be collected.
    
    Committer note:
    
    Testing it:
    
      # perf test -v BPF
      <SNIP>
      Kernel build dir is set to /lib/modules/4.3.0+/build
      set env: KBUILD_DIR=/lib/modules/4.3.0+/build
      unset env: KBUILD_OPTS
      include option is set to  -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.9.2/include -I/home/git/linux/arch/x86/include -Iarch/x86/include/generated/uapi -Iarch/x86/include/generated  -I/home/git/linux/include -Iinclude -I/home/git/linux/arch/x86/include/uapi -Iarch/x86/include/generated/uapi -I/home/git/linux/include/uapi -Iinclude/generated/uapi -include /home/git/linux/include/linux/kconfig.h
      set env: NR_CPUS=4
      set env: LINUX_VERSION_CODE=0x40300
      set env: CLANG_EXEC=/usr/libexec/icecc/bin/clang
      set env: CLANG_OPTIONS=-xc
      set env: KERNEL_INC_OPTIONS= -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.9.2/include -I/home/git/linux/arch/x86/include -Iarch/x86/include/generated/uapi -Iarch/x86/include/generated  -I/home/git/linux/include -Iinclude -I/home/git/linux/arch/x86/include/uapi -Iarch/x86/include/generated/uapi -I/home/git/linux/include/uapi -Iinclude/generated/uapi -include /home/git/linux/include/linux/kconfig.h
      set env: WORKING_DIR=/lib/modules/4.3.0+/build
      set env: CLANG_SOURCE=-
      llvm compiling command template: echo '/*
       * bpf-script-test-prologue.c
       * Test BPF prologue
       */
      #ifndef LINUX_VERSION_CODE
      # error Need LINUX_VERSION_CODE
      # error Example: for 4.2 kernel, put 'clang-opt="-DLINUX_VERSION_CODE=0x40200" into llvm section of ~/.perfconfig'
      #endif
      #define SEC(NAME) __attribute__((section(NAME), used))
    
      #include <uapi/linux/fs.h>
    
      #define FMODE_READ            0x1
      #define FMODE_WRITE           0x2
    
      static void (*bpf_trace_printk)(const char *fmt, int fmt_size, ...) =
              (void *) 6;
    
      SEC("func=null_lseek file->f_mode offset orig")
      int bpf_func__null_lseek(void *ctx, int err, unsigned long f_mode,
                               unsigned long offset, unsigned long orig)
      {
              if (err)
                      return 0;
              if (f_mode & FMODE_WRITE)
                      return 0;
              if (offset & 1)
                      return 0;
              if (orig == SEEK_CUR)
                      return 0;
              return 1;
      }
    
      char _license[] SEC("license") = "GPL";
      int _version SEC("version") = LINUX_VERSION_CODE;
      ' | $CLANG_EXEC -D__KERNEL__ -D__NR_CPUS__=$NR_CPUS -DLINUX_VERSION_CODE=$LINUX_VERSION_CODE $CLANG_OPTIONS $KERNEL_INC_OPTIONS -Wno-unused-value -Wno-pointer-sign -working-directory $WORKING_DIR -c "$CLANG_SOURCE" -target bpf -O2 -o -
      libbpf: loading object '[bpf_prologue_test]' from buffer
      libbpf: section .strtab, size 135, link 0, flags 0, type=3
      libbpf: section .text, size 0, link 0, flags 6, type=1
      libbpf: section .data, size 0, link 0, flags 3, type=1
      libbpf: section .bss, size 0, link 0, flags 3, type=8
      libbpf: section func=null_lseek file->f_mode offset orig, size 112, link 0, flags 6, type=1
      libbpf: found program func=null_lseek file->f_mode offset orig
      libbpf: section license, size 4, link 0, flags 3, type=1
      libbpf: license of [bpf_prologue_test] is GPL
      libbpf: section version, size 4, link 0, flags 3, type=1
      libbpf: kernel version of [bpf_prologue_test] is 40300
      libbpf: section .symtab, size 168, link 1, flags 0, type=2
      bpf: config program 'func=null_lseek file->f_mode offset orig'
      symbol:null_lseek file:(null) line:0 offset:0 return:0 lazy:(null)
      parsing arg: file->f_mode into file, f_mode(1)
      parsing arg: offset into offset
      parsing arg: orig into orig
      bpf: config 'func=null_lseek file->f_mode offset orig' is ok
      Looking at the vmlinux_path (7 entries long)
      Using /lib/modules/4.3.0+/build/vmlinux for symbols
      Open Debuginfo file: /lib/modules/4.3.0+/build/vmlinux
      Try to find probe point from debuginfo.
      Matched function: null_lseek
      Probe point found: null_lseek+0
      Searching 'file' variable in context.
      Converting variable file into trace event.
      converting f_mode in file
      f_mode type is unsigned int.
      Searching 'offset' variable in context.
      Converting variable offset into trace event.
      offset type is long long int.
      Searching 'orig' variable in context.
      Converting variable orig into trace event.
      orig type is int.
      Found 1 probe_trace_events.
      Opening /sys/kernel/debug/tracing//kprobe_events write=1
      Writing event: p:perf_bpf_probe/func _text+4840528 f_mode=+68(%di):u32 offset=%si:s64 orig=%dx:s32
      libbpf: don't need create maps for [bpf_prologue_test]
      prologue: pass validation
      prologue: slow path
      prologue: fetch arg 0, base reg is %di
      prologue: arg 0: offset 68
      prologue: fetch arg 1, base reg is %si
      prologue: fetch arg 2, base reg is %dx
      add bpf event perf_bpf_probe:func and attach bpf program 3
      adding perf_bpf_probe:func
      adding perf_bpf_probe:func to 0x51672c0
      mmap size 1052672B
      Opening /sys/kernel/debug/tracing//kprobe_events write=1
      Opening /sys/kernel/debug/tracing//uprobe_events write=1
      Parsing probe_events: p:perf_bpf_probe/func _text+4840528 f_mode=+68(%di):u32 offset=%si:s64 orig=%dx:s32
      Group:perf_bpf_probe Event:func probe:p
      Writing event: -:perf_bpf_probe/func
      test child finished with 0
      ---- end ----
      Test BPF filter: Ok
      #
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1447675815-166222-13-git-send-email-wangnan0@huawei.com
    [ Added tools/perf/tests/llvm-src-prologue.c to .gitignore ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/tests/bpf-script-test-prologue.c b/tools/perf/tests/bpf-script-test-prologue.c
new file mode 100644
index 000000000000..7230e62c70fc
--- /dev/null
+++ b/tools/perf/tests/bpf-script-test-prologue.c
@@ -0,0 +1,35 @@
+/*
+ * bpf-script-test-prologue.c
+ * Test BPF prologue
+ */
+#ifndef LINUX_VERSION_CODE
+# error Need LINUX_VERSION_CODE
+# error Example: for 4.2 kernel, put 'clang-opt="-DLINUX_VERSION_CODE=0x40200" into llvm section of ~/.perfconfig'
+#endif
+#define SEC(NAME) __attribute__((section(NAME), used))
+
+#include <uapi/linux/fs.h>
+
+#define FMODE_READ		0x1
+#define FMODE_WRITE		0x2
+
+static void (*bpf_trace_printk)(const char *fmt, int fmt_size, ...) =
+	(void *) 6;
+
+SEC("func=null_lseek file->f_mode offset orig")
+int bpf_func__null_lseek(void *ctx, int err, unsigned long f_mode,
+			 unsigned long offset, unsigned long orig)
+{
+	if (err)
+		return 0;
+	if (f_mode & FMODE_WRITE)
+		return 0;
+	if (offset & 1)
+		return 0;
+	if (orig == SEEK_CUR)
+		return 0;
+	return 1;
+}
+
+char _license[] SEC("license") = "GPL";
+int _version SEC("version") = LINUX_VERSION_CODE;
