commit 6549a8c0c3d94500a9a1bb66fc237f7c01c41753
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Fri May 15 12:29:26 2020 -0500

    perf tools: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array
    member[1][2], introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning in
    case the flexible array does not occur last in the structure, which will
    help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by this
    change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Cc: Ian Rogers <irogers@google.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200515172926.GA31976@embeddedor
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
index f2c3823cc81a..ab2842def83d 100644
--- a/tools/perf/util/jitdump.h
+++ b/tools/perf/util/jitdump.h
@@ -93,7 +93,7 @@ struct debug_entry {
 	uint64_t addr;
 	int lineno;	    /* source line number starting at 1 */
 	int discrim;	    /* column discriminator, 0 is default */
-	const char name[0]; /* null terminated filename, \xff\0 if same as previous entry */
+	const char name[]; /* null terminated filename, \xff\0 if same as previous entry */
 };
 
 struct jr_code_debug_info {
@@ -101,7 +101,7 @@ struct jr_code_debug_info {
 
 	uint64_t code_addr;
 	uint64_t nr_entry;
-	struct debug_entry entries[0];
+	struct debug_entry entries[];
 };
 
 struct jr_code_unwinding_info {
@@ -110,7 +110,7 @@ struct jr_code_unwinding_info {
 	uint64_t unwinding_size;
 	uint64_t eh_frame_hdr_size;
 	uint64_t mapped_size;
-	const char unwinding_data[0];
+	const char unwinding_data[];
 };
 
 union jr_entry {

commit b15f321b9f27389f427ab572da5d50a223294b15
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:13 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 480
    
    Based on 1 normalized pattern(s):
    
      adapted from oprofile gplv2 support
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to add the SPDX license identifier to 1 file(s)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081204.397687630@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
index c6b9b67f43bf..f2c3823cc81a 100644
--- a/tools/perf/util/jitdump.h
+++ b/tools/perf/util/jitdump.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * jitdump.h: jitted code info encapsulation file format
  *

commit 0284fecd13b6db3ecd4c2b1bf3e72b105edce24b
Author: Stefano Sanfilippo <ssanfilippo@chromium.org>
Date:   Thu Oct 13 03:59:40 2016 -0700

    perf jit: Add unwinding support
    
    This record is intended to provide unwinding information in the
    eh_frame format. This is required to unwind JITed code which
    does not maintain the frame pointer register during function calls.
    
    The eh_frame unwinding information can be emitted by V8 / Chromium
    when the --perf_prof_unwinding_info is passed.
    
    A record of type jr_code_unwinding_info comes before the jr_code_load
    it referred to and contains both the .eh_frame and .eh_frame_hdr.
    
    The fields in the header have the following meaning:
    
      * unwinding_size: size of the eh_frame and eh_frame_hdr, necessary
        for distinguishing the content from the padding.
    
      * eh_frame_hdr_size: as the name says.
    
      * mapped_size: size of the payload that was in memory at runtime.
        typically unwinding_size if the .eh_frame_hdr and .eh_frame were
        mapped, or 0 if they weren't. It should always be the former case,
        since the .eh_frame is guaranteed to be mapped in memory. However,
        certain JITs might want to inject an .eh_frame_hdr with an empty LUT
        to trigger fp-based unwinding fallback in libunwind. The only part
        of the .eh_frame_hdr that libunwind reads from remote memory is the
        LUT, and since there is none, mapping the unwinding info in memory
        is not necessary, and 0 in this field signifies that it wasn't.
        This practical hack allows to save bytes in code memory for those
        JIT compilers that might or might not maintain a valid frame pointer.
    
    The payload that follows is assumed to contain first the .eh_frame and
    then the .eh_header_hdr, with no padding between the two.
    
    Signed-off-by: Stefano Sanfilippo <ssanfilippo@chromium.org>
    Signed-off-by: Ross McIlroy <rmcilroy@chromium.org>
    Reviewed-by: Stephane Eranian <eranian@google.com>
    Cc: Anton Blanchard <anton@ozlabs.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1476356383-30100-7-git-send-email-eranian@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
index bcacd20d0c1c..c6b9b67f43bf 100644
--- a/tools/perf/util/jitdump.h
+++ b/tools/perf/util/jitdump.h
@@ -19,6 +19,7 @@
 #define JITHEADER_MAGIC_SW	0x4454694A
 
 #define PADDING_8ALIGNED(x) ((((x) + 7) & 7) ^ 7)
+#define ALIGN_8(x) (((x) + 7) & (~7))
 
 #define JITHEADER_VERSION 1
 
@@ -48,6 +49,7 @@ enum jit_record_type {
         JIT_CODE_MOVE           = 1,
 	JIT_CODE_DEBUG_INFO	= 2,
 	JIT_CODE_CLOSE		= 3,
+	JIT_CODE_UNWINDING_INFO	= 4,
 
 	JIT_CODE_MAX,
 };
@@ -101,12 +103,22 @@ struct jr_code_debug_info {
 	struct debug_entry entries[0];
 };
 
+struct jr_code_unwinding_info {
+	struct jr_prefix p;
+
+	uint64_t unwinding_size;
+	uint64_t eh_frame_hdr_size;
+	uint64_t mapped_size;
+	const char unwinding_data[0];
+};
+
 union jr_entry {
         struct jr_code_debug_info info;
         struct jr_code_close close;
         struct jr_code_load load;
         struct jr_code_move move;
         struct jr_prefix prefix;
+        struct jr_code_unwinding_info unwinding;
 };
 
 static inline struct debug_entry *

commit 2a28e23049af99e1c810111ef5e56455cafeda45
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 8 10:38:50 2016 +0200

    perf jit: Add support for using TSC as a timestamp
    
    Intel PT uses TSC as a timestamp, so add support for using TSC instead
    of the monotonic clock.  Use of TSC is selected by an environment
    variable "JITDUMP_USE_ARCH_TIMESTAMP" and flagged in the jitdump file
    with flag JITDUMP_FLAGS_ARCH_TIMESTAMP.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1457426330-30226-1-git-send-email-adrian.hunter@intel.com
    [ Added the fixup from He Kuang to make it build on other arches, ]
    [ such as aarch64, to avoid inserting this bisectiong breakage upstream ]
    Link: http://lkml.kernel.org/r/1459482572-129494-1-git-send-email-hekuang@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
index b66c1f503d9e..bcacd20d0c1c 100644
--- a/tools/perf/util/jitdump.h
+++ b/tools/perf/util/jitdump.h
@@ -23,9 +23,12 @@
 #define JITHEADER_VERSION 1
 
 enum jitdump_flags_bits {
+	JITDUMP_FLAGS_ARCH_TIMESTAMP_BIT,
 	JITDUMP_FLAGS_MAX_BIT,
 };
 
+#define JITDUMP_FLAGS_ARCH_TIMESTAMP	(1ULL << JITDUMP_FLAGS_ARCH_TIMESTAMP_BIT)
+
 #define JITDUMP_FLAGS_RESERVED (JITDUMP_FLAGS_MAX_BIT < 64 ? \
 				(~((1ULL << JITDUMP_FLAGS_MAX_BIT) - 1)) : 0)
 

commit 9b07e27f88b9cd785cdb23f9a2231c12521dda94
Author: Stephane Eranian <eranian@google.com>
Date:   Mon Nov 30 10:02:21 2015 +0100

    perf inject: Add jitdump mmap injection support
    
    This patch adds a --jit/-j option to perf inject.
    
    This options injects MMAP records into the perf.data file to cover the
    jitted code mmaps. It also emits ELF images for each function in the
    jidump file.  Those images are created where the jitdump file is.  The
    MMAP records point to that location as well.
    
    Typical flow:
    
      $ perf record -k mono -- java -agentpath:libpjvmti.so java_class
      $ perf inject --jit -i perf.data -o perf.data.jitted
      $ perf report -i perf.data.jitted
    
    Note that jitdump.h support is not limited to Java, it works with any
    jitted environment modified to emit the jitdump file format, include
    those where code can be jitted multiple times and moved around.
    
    The jitdump.h format is adapted from the Oprofile project.
    
    The genelf.c (ELF binary generation) depends on MD5 hash encoding for
    the buildid. To enable this, libssl-dev must be installed. If not, then
    genelf.c defaults to using urandom to generate the buildid, which is not
    ideal.  The Makefile auto-detects the presence on libssl-dev.
    
    This version mmaps the jitdump file to create a marker MMAP record in
    the perf.data file. The marker is used to detect jitdump and cause perf
    inject to inject the jitted mmaps and generate ELF images for jitted
    functions.
    
    In V8, the following fixes and changes were made among other things:
    
      -  the jidump header format include a new flags field to be used
         to carry information about the configuration of the runtime agent.
         Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - Fix mmap pgoff: MMAP event pgoff must be the offset within the ELF file
        at which the code resides.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - Fix ELF virtual addresses: perf tools expect the ELF virtual addresses of dynamic
        objects to match the file offset.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - JIT MMAP injection does not obey finished_round semantics. JIT MMAP injection injects all
        MMAP events in one go, so it does not obey finished_round semantics, so drop the
        finished_round events from the output perf.data file.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Carl Love <cel@us.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John McCutchan <johnmccutchan@google.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sonny Rao <sonnyrao@chromium.org>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1448874143-7269-3-git-send-email-eranian@google.com
    [ Moved inject.build_ids ordering bits to a separate patch, fixed the NO_LIBELF=1 build ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
new file mode 100644
index 000000000000..b66c1f503d9e
--- /dev/null
+++ b/tools/perf/util/jitdump.h
@@ -0,0 +1,124 @@
+/*
+ * jitdump.h: jitted code info encapsulation file format
+ *
+ * Adapted from OProfile GPLv2 support jidump.h:
+ * Copyright 2007 OProfile authors
+ * Jens Wilke
+ * Daniel Hansel
+ * Copyright IBM Corporation 2007
+ */
+#ifndef JITDUMP_H
+#define JITDUMP_H
+
+#include <sys/time.h>
+#include <time.h>
+#include <stdint.h>
+
+/* JiTD */
+#define JITHEADER_MAGIC		0x4A695444
+#define JITHEADER_MAGIC_SW	0x4454694A
+
+#define PADDING_8ALIGNED(x) ((((x) + 7) & 7) ^ 7)
+
+#define JITHEADER_VERSION 1
+
+enum jitdump_flags_bits {
+	JITDUMP_FLAGS_MAX_BIT,
+};
+
+#define JITDUMP_FLAGS_RESERVED (JITDUMP_FLAGS_MAX_BIT < 64 ? \
+				(~((1ULL << JITDUMP_FLAGS_MAX_BIT) - 1)) : 0)
+
+struct jitheader {
+	uint32_t magic;		/* characters "jItD" */
+	uint32_t version;	/* header version */
+	uint32_t total_size;	/* total size of header */
+	uint32_t elf_mach;	/* elf mach target */
+	uint32_t pad1;		/* reserved */
+	uint32_t pid;		/* JIT process id */
+	uint64_t timestamp;	/* timestamp */
+	uint64_t flags;		/* flags */
+};
+
+enum jit_record_type {
+	JIT_CODE_LOAD		= 0,
+        JIT_CODE_MOVE           = 1,
+	JIT_CODE_DEBUG_INFO	= 2,
+	JIT_CODE_CLOSE		= 3,
+
+	JIT_CODE_MAX,
+};
+
+/* record prefix (mandatory in each record) */
+struct jr_prefix {
+	uint32_t id;
+	uint32_t total_size;
+	uint64_t timestamp;
+};
+
+struct jr_code_load {
+	struct jr_prefix p;
+
+	uint32_t pid;
+	uint32_t tid;
+	uint64_t vma;
+	uint64_t code_addr;
+	uint64_t code_size;
+	uint64_t code_index;
+};
+
+struct jr_code_close {
+	struct jr_prefix p;
+};
+
+struct jr_code_move {
+	struct jr_prefix p;
+
+	uint32_t pid;
+	uint32_t tid;
+	uint64_t vma;
+	uint64_t old_code_addr;
+	uint64_t new_code_addr;
+	uint64_t code_size;
+	uint64_t code_index;
+};
+
+struct debug_entry {
+	uint64_t addr;
+	int lineno;	    /* source line number starting at 1 */
+	int discrim;	    /* column discriminator, 0 is default */
+	const char name[0]; /* null terminated filename, \xff\0 if same as previous entry */
+};
+
+struct jr_code_debug_info {
+	struct jr_prefix p;
+
+	uint64_t code_addr;
+	uint64_t nr_entry;
+	struct debug_entry entries[0];
+};
+
+union jr_entry {
+        struct jr_code_debug_info info;
+        struct jr_code_close close;
+        struct jr_code_load load;
+        struct jr_code_move move;
+        struct jr_prefix prefix;
+};
+
+static inline struct debug_entry *
+debug_entry_next(struct debug_entry *ent)
+{
+	void *a = ent + 1;
+	size_t l = strlen(ent->name) + 1;
+	return a + l;
+}
+
+static inline char *
+debug_entry_file(struct debug_entry *ent)
+{
+	void *a = ent + 1;
+	return a;
+}
+
+#endif /* !JITDUMP_H */
