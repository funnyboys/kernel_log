commit bdadd647cbf7b6e7f5d5891bd4e711292793cf23
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 9 16:53:41 2020 -0300

    perf map: Use strstarts() to look for Android libraries
    
    And add the '/' to avoid looking at things like "/system/libsomething",
    when all we want to know if it is like "/system/lib/something", i.e. if
    it is in that system library dir.
    
    Using strstarts() avoids off-by-one errors like recently fixed in this
    file.
    
    Since this adds the '/' I separated this patch, another patch will make
    this consistent by removing other strncmp(str, prefix, manually
    calculated prefix length) usage.
    
    Reported-by: Dominik Czarnota <dominik.b.czarnota@gmail.com>
    Acked-by: Dominik Czarnota <dominik.b.czarnota@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: Link: http://lore.kernel.org/lkml/CABEVAa0_q-uC0vrrqpkqRHy_9RLOSXOJxizMLm1n5faHRy2AeA@mail.gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b342f744b1fc..53d96611e6a6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -44,8 +44,8 @@ static inline int is_no_dso_memory(const char *filename)
 
 static inline int is_android_lib(const char *filename)
 {
-	return !strncmp(filename, "/data/app-lib", 13) ||
-	       !strncmp(filename, "/system/lib", 11);
+	return strstarts(filename, "/data/app-lib/") ||
+	       strstarts(filename, "/system/lib/");
 }
 
 static inline bool replace_android_lib(const char *filename, char *newfilename)
@@ -65,7 +65,7 @@ static inline bool replace_android_lib(const char *filename, char *newfilename)
 
 	app_abi_length = strlen(app_abi);
 
-	if (!strncmp(filename, "/data/app-lib", 13)) {
+	if (strstarts(filename, "/data/app-lib/")) {
 		char *apk_path;
 
 		if (!app_abi_length)
@@ -89,7 +89,7 @@ static inline bool replace_android_lib(const char *filename, char *newfilename)
 		return true;
 	}
 
-	if (!strncmp(filename, "/system/lib/", 12)) {
+	if (strstarts(filename, "/system/lib/")) {
 		char *ndk, *app;
 		const char *arch;
 		size_t ndk_length;

commit b8fdcfb5a17f1d4fd503caef5c457005a765ecd7
Author: disconnect3d <dominik.b.czarnota@gmail.com>
Date:   Mon Mar 9 11:48:53 2020 +0100

    perf map: Fix off by one in strncpy() size argument
    
    This patch fixes an off-by-one error in strncpy size argument in
    tools/perf/util/map.c. The issue is that in:
    
            strncmp(filename, "/system/lib/", 11)
    
    the passed string literal: "/system/lib/" has 12 bytes (without the NULL
    byte) and the passed size argument is 11. As a result, the logic won't
    match the ending "/" byte and will pass filepaths that are stored in
    other directories e.g. "/system/libmalicious/bin" or just
    "/system/libmalicious".
    
    This functionality seems to be present only on Android. I assume the
    /system/ directory is only writable by the root user, so I don't think
    this bug has much (or any) security impact.
    
    Fixes: eca818369996 ("perf tools: Add automatic remapping of Android libraries")
    Signed-off-by: disconnect3d <dominik.b.czarnota@gmail.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Changbin Du <changbin.du@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John Keeping <john@metanate.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Michael Lentine <mlentine@google.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lore.kernel.org/lkml/20200309104855.3775-1-dominik.b.czarnota@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 95428511300d..b342f744b1fc 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -89,7 +89,7 @@ static inline bool replace_android_lib(const char *filename, char *newfilename)
 		return true;
 	}
 
-	if (!strncmp(filename, "/system/lib/", 11)) {
+	if (!strncmp(filename, "/system/lib/", 12)) {
 		char *ndk, *app;
 		const char *arch;
 		size_t ndk_length;

commit c395c3553d6870541f1c283479aea2a6f26364d5
Author: Nick Desaulniers <nick.desaulniers@gmail.com>
Date:   Sun Feb 23 11:34:49 2020 -0800

    perf diff: Fix undefined string comparison spotted by clang's -Wstring-compare
    
    clang warns:
    
      util/block-info.c:298:18: error: result of comparison against a string
      literal is unspecified (use an explicit string comparison function
      instead) [-Werror,-Wstring-compare]
              if ((start_line != SRCLINE_UNKNOWN) && (end_line != SRCLINE_UNKNOWN)) {
                              ^  ~~~~~~~~~~~~~~~
      util/block-info.c:298:51: error: result of comparison against a string
      literal is unspecified (use an explicit string comparison function
      instead) [-Werror,-Wstring-compare]
              if ((start_line != SRCLINE_UNKNOWN) && (end_line != SRCLINE_UNKNOWN)) {
                                                               ^  ~~~~~~~~~~~~~~~
      util/block-info.c:298:18: error: result of comparison against a string
      literal is unspecified (use an explicit string
      comparison function instead) [-Werror,-Wstring-compare]
              if ((start_line != SRCLINE_UNKNOWN) && (end_line != SRCLINE_UNKNOWN)) {
                              ^  ~~~~~~~~~~~~~~~
      util/block-info.c:298:51: error: result of comparison against a string
      literal is unspecified (use an explicit string comparison function
      instead) [-Werror,-Wstring-compare]
              if ((start_line != SRCLINE_UNKNOWN) && (end_line != SRCLINE_UNKNOWN)) {
                                                               ^  ~~~~~~~~~~~~~~~
      util/map.c:434:15: error: result of comparison against a string literal
      is unspecified (use an explicit string comparison function instead)
      [-Werror,-Wstring-compare]
                      if (srcline != SRCLINE_UNKNOWN)
                                  ^  ~~~~~~~~~~~~~~~
    
    Reviewer Notes:
    
    Looks good to me. Some more context:
    https://clang.llvm.org/docs/DiagnosticsReference.html#wstring-compare
    The spec says:
    J.1 Unspecified behavior
    The following are unspecified:
    .. Whether two string literals result in distinct arrays (6.4.5).
    
    Signed-off-by: Nick Desaulniers <nick.desaulniers@gmail.com>
    Reviewed-by: Ian Rogers <irogers@google.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Changbin Du <changbin.du@intel.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John Keeping <john@metanate.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: clang-built-linux@googlegroups.com
    Link: https://github.com/ClangBuiltLinux/linux/issues/900
    Link: http://lore.kernel.org/lkml/20200223193456.25291-1-nick.desaulniers@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a08ca276098e..95428511300d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -431,7 +431,7 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 
 	if (map && map->dso) {
 		char *srcline = map__srcline(map, addr, NULL);
-		if (srcline != SRCLINE_UNKNOWN)
+		if (strncmp(srcline, SRCLINE_UNKNOWN, strlen(SRCLINE_UNKNOWN)) != 0)
 			ret = fprintf(fp, "%s%s", prefix, srcline);
 		free_srcline(srcline);
 	}

commit 484214f49bd0948d716832a94e4737ca4dd02c16
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Feb 10 15:32:18 2020 +0100

    perf maps: Move kmap::kmaps setup to maps__insert()
    
    So the kmaps pointer setup is centralized and we do not need to update
    it in all those places (2 current places and few more missing) after
    calling maps__insert().
    
    Reported-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Tested-by: Kim Phillips <kim.phillips@amd.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200210143218.24948-5-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index cea05fc9595c..a08ca276098e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -543,6 +543,16 @@ void maps__insert(struct maps *maps, struct map *map)
 	__maps__insert(maps, map);
 	++maps->nr_maps;
 
+	if (map->dso && map->dso->kernel) {
+		struct kmap *kmap = map__kmap(map);
+
+		if (kmap)
+			kmap->kmaps = maps;
+		else
+			pr_err("Internal error: kernel dso with non kernel map\n");
+	}
+
+
 	/*
 	 * If we already performed some search by name, then we need to add the just
 	 * inserted map and resort.

commit 7ce66139a99ce57caaf47b64afed5cb6ed02c5ed
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Feb 10 15:32:17 2020 +0100

    perf maps: Fix map__clone() for struct kmap
    
    The map__clone() function can be called on kernel maps as well, so it
    needs to duplicate the whole kmap data.
    
    Reported-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Tested-by: Kim Phillips <kim.phillips@amd.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200210143218.24948-4-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index f67960bedebb..cea05fc9595c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -375,8 +375,13 @@ struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
 
 struct map *map__clone(struct map *from)
 {
-	struct map *map = memdup(from, sizeof(*map));
+	size_t size = sizeof(struct map);
+	struct map *map;
+
+	if (from->dso && from->dso->kernel)
+		size += sizeof(struct kmap);
 
+	map = memdup(from, size);
 	if (map != NULL) {
 		refcount_set(&map->refcnt, 1);
 		RB_CLEAR_NODE(&map->rb_node);

commit 85fc95d75970ee7dd8e01904e7fb1197c275ba6b
Author: Cengiz Can <cengiz@kernel.wtf>
Date:   Mon Jan 20 17:15:54 2020 +0300

    perf maps: Add missing unlock to maps__insert() error case
    
    `tools/perf/util/map.c` has a function named `maps__insert` that
    acquires a write lock if its in multithread context.
    
    Even though this lock is released when function successfully completes,
    there's a branch that is executed when `maps_by_name == NULL` that
    returns from this function without releasing the write lock.
    
    Added an `up_write` to release the lock when this happens.
    
    Fixes: a7c2b572e217 ("perf map_groups: Auto sort maps by name, if needed")
    Signed-off-by: Cengiz Can <cengiz@kernel.wtf>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lore.kernel.org/lkml/20200120141553.23934-1-cengiz@kernel.wtf
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index fdd5bddb3075..f67960bedebb 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -549,6 +549,7 @@ void maps__insert(struct maps *maps, struct map *map)
 
 			if (maps_by_name == NULL) {
 				__maps__free_maps_by_name(maps);
+				up_write(&maps->lock);
 				return;
 			}
 

commit 9a29ceee6bb14aeb58ab2222c8e792576fe90fb8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 22:21:28 2019 -0300

    perf maps: Rename 'mg' variables to 'maps'
    
    Continuing the merge of 'struct maps' with 'struct map_groups'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-z8d14wrw393a0fbvmnk1bqd9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 39bfed48b7f5..fdd5bddb3075 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -512,52 +512,50 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	return ip + map->reloc;
 }
 
-void maps__init(struct maps *mg, struct machine *machine)
+void maps__init(struct maps *maps, struct machine *machine)
 {
-	mg->entries = RB_ROOT;
-	init_rwsem(&mg->lock);
-	mg->machine = machine;
-	mg->last_search_by_name = NULL;
-	mg->nr_maps = 0;
-	mg->maps_by_name = NULL;
-	refcount_set(&mg->refcnt, 1);
+	maps->entries = RB_ROOT;
+	init_rwsem(&maps->lock);
+	maps->machine = machine;
+	maps->last_search_by_name = NULL;
+	maps->nr_maps = 0;
+	maps->maps_by_name = NULL;
+	refcount_set(&maps->refcnt, 1);
 }
 
-static void __maps__free_maps_by_name(struct maps *mg)
+static void __maps__free_maps_by_name(struct maps *maps)
 {
 	/*
 	 * Free everything to try to do it from the rbtree in the next search
 	 */
-	zfree(&mg->maps_by_name);
-	mg->nr_maps_allocated = 0;
+	zfree(&maps->maps_by_name);
+	maps->nr_maps_allocated = 0;
 }
 
-void maps__insert(struct maps *mg, struct map *map)
+void maps__insert(struct maps *maps, struct map *map)
 {
-	struct maps *maps = mg;
-
 	down_write(&maps->lock);
 	__maps__insert(maps, map);
-	++mg->nr_maps;
+	++maps->nr_maps;
 
 	/*
 	 * If we already performed some search by name, then we need to add the just
 	 * inserted map and resort.
 	 */
-	if (mg->maps_by_name) {
-		if (mg->nr_maps > mg->nr_maps_allocated) {
-			int nr_allocate = mg->nr_maps * 2;
-			struct map **maps_by_name = realloc(mg->maps_by_name, nr_allocate * sizeof(map));
+	if (maps->maps_by_name) {
+		if (maps->nr_maps > maps->nr_maps_allocated) {
+			int nr_allocate = maps->nr_maps * 2;
+			struct map **maps_by_name = realloc(maps->maps_by_name, nr_allocate * sizeof(map));
 
 			if (maps_by_name == NULL) {
 				__maps__free_maps_by_name(maps);
 				return;
 			}
 
-			mg->maps_by_name = maps_by_name;
-			mg->nr_maps_allocated = nr_allocate;
+			maps->maps_by_name = maps_by_name;
+			maps->nr_maps_allocated = nr_allocate;
 		}
-		mg->maps_by_name[mg->nr_maps - 1] = map;
+		maps->maps_by_name[maps->nr_maps - 1] = map;
 		__maps__sort_by_name(maps);
 	}
 	up_write(&maps->lock);
@@ -569,16 +567,15 @@ static void __maps__remove(struct maps *maps, struct map *map)
 	map__put(map);
 }
 
-void maps__remove(struct maps *mg, struct map *map)
+void maps__remove(struct maps *maps, struct map *map)
 {
-	struct maps *maps = mg;
 	down_write(&maps->lock);
-	if (mg->last_search_by_name == map)
-		mg->last_search_by_name = NULL;
+	if (maps->last_search_by_name == map)
+		maps->last_search_by_name = NULL;
 
 	__maps__remove(maps, map);
-	--mg->nr_maps;
-	if (mg->maps_by_name)
+	--maps->nr_maps;
+	if (maps->maps_by_name)
 		__maps__free_maps_by_name(maps);
 	up_write(&maps->lock);
 }
@@ -607,30 +604,30 @@ bool maps__empty(struct maps *maps)
 
 struct maps *maps__new(struct machine *machine)
 {
-	struct maps *mg = zalloc(sizeof(*mg)), *maps = mg;
+	struct maps *maps = zalloc(sizeof(*maps));
 
-	if (mg != NULL)
+	if (maps != NULL)
 		maps__init(maps, machine);
 
-	return mg;
+	return maps;
 }
 
-void maps__delete(struct maps *mg)
+void maps__delete(struct maps *maps)
 {
-	maps__exit(mg);
-	unwind__finish_access(mg);
-	free(mg);
+	maps__exit(maps);
+	unwind__finish_access(maps);
+	free(maps);
 }
 
-void maps__put(struct maps *mg)
+void maps__put(struct maps *maps)
 {
-	if (mg && refcount_dec_and_test(&mg->refcnt))
-		maps__delete(mg);
+	if (maps && refcount_dec_and_test(&maps->refcnt))
+		maps__delete(maps);
 }
 
-struct symbol *maps__find_symbol(struct maps *mg, u64 addr, struct map **mapp)
+struct symbol *maps__find_symbol(struct maps *maps, u64 addr, struct map **mapp)
 {
-	struct map *map = maps__find(mg, addr);
+	struct map *map = maps__find(maps, addr);
 
 	/* Ensure map is loaded before using map->map_ip */
 	if (map != NULL && map__load(map) >= 0) {
@@ -676,12 +673,12 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, st
 	return sym;
 }
 
-int maps__find_ams(struct maps *mg, struct addr_map_symbol *ams)
+int maps__find_ams(struct maps *maps, struct addr_map_symbol *ams)
 {
 	if (ams->addr < ams->ms.map->start || ams->addr >= ams->ms.map->end) {
-		if (mg == NULL)
+		if (maps == NULL)
 			return -1;
-		ams->ms.map = maps__find(mg, ams->addr);
+		ams->ms.map = maps__find(maps, ams->addr);
 		if (ams->ms.map == NULL)
 			return -1;
 	}
@@ -819,7 +816,7 @@ int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
  */
 int maps__clone(struct thread *thread, struct maps *parent)
 {
-	struct maps *mg = thread->maps;
+	struct maps *maps = thread->maps;
 	int err = -ENOMEM;
 	struct map *map;
 
@@ -830,11 +827,11 @@ int maps__clone(struct thread *thread, struct maps *parent)
 		if (new == NULL)
 			goto out_unlock;
 
-		err = unwind__prepare_access(mg, new, NULL);
+		err = unwind__prepare_access(maps, new, NULL);
 		if (err)
 			goto out_unlock;
 
-		maps__insert(mg, new);
+		maps__insert(maps, new);
 		map__put(new);
 	}
 

commit fe87797dea79b59e97a4ea67441bf91f2905bf23
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 22:07:43 2019 -0300

    perf thread: Rename thread->mg to thread->maps
    
    One more step on the merge of 'struct maps' with 'struct map_groups'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-69vcr8pubpym90skxhmbwhiw@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4c9fd064028f..39bfed48b7f5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -819,7 +819,7 @@ int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
  */
 int maps__clone(struct thread *thread, struct maps *parent)
 {
-	struct maps *mg = thread->mg;
+	struct maps *mg = thread->maps;
 	int err = -ENOMEM;
 	struct map *map;
 

commit 79b6bb73f888933cbcd20b0ef3976cde67951b72
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 21:58:33 2019 -0300

    perf maps: Merge 'struct maps' with 'struct map_groups'
    
    And pick the shortest name: 'struct maps'.
    
    The split existed because we used to have two groups of maps, one for
    functions and one for variables, but that only complicated things,
    sometimes we needed to figure out what was at some address and then had
    to first try it on the functions group and if that failed, fall back to
    the variables one.
    
    That split is long gone, so for quite a while we had only one struct
    maps per struct map_groups, simplify things by combining those structs.
    
    First patch is the minimum needed to merge both, follow up patches will
    rename 'thread->mg' to 'thread->maps', etc.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-hom6639ro7020o708trhxh59@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 267d951b5dfd..4c9fd064028f 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -512,15 +512,10 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	return ip + map->reloc;
 }
 
-static void maps__init(struct maps *maps)
+void maps__init(struct maps *mg, struct machine *machine)
 {
-	maps->entries = RB_ROOT;
-	init_rwsem(&maps->lock);
-}
-
-void map_groups__init(struct map_groups *mg, struct machine *machine)
-{
-	maps__init(&mg->maps);
+	mg->entries = RB_ROOT;
+	init_rwsem(&mg->lock);
 	mg->machine = machine;
 	mg->last_search_by_name = NULL;
 	mg->nr_maps = 0;
@@ -528,7 +523,7 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 	refcount_set(&mg->refcnt, 1);
 }
 
-static void __map_groups__free_maps_by_name(struct map_groups *mg)
+static void __maps__free_maps_by_name(struct maps *mg)
 {
 	/*
 	 * Free everything to try to do it from the rbtree in the next search
@@ -537,9 +532,9 @@ static void __map_groups__free_maps_by_name(struct map_groups *mg)
 	mg->nr_maps_allocated = 0;
 }
 
-void map_groups__insert(struct map_groups *mg, struct map *map)
+void maps__insert(struct maps *mg, struct map *map)
 {
-	struct maps *maps = &mg->maps;
+	struct maps *maps = mg;
 
 	down_write(&maps->lock);
 	__maps__insert(maps, map);
@@ -555,7 +550,7 @@ void map_groups__insert(struct map_groups *mg, struct map *map)
 			struct map **maps_by_name = realloc(mg->maps_by_name, nr_allocate * sizeof(map));
 
 			if (maps_by_name == NULL) {
-				__map_groups__free_maps_by_name(mg);
+				__maps__free_maps_by_name(maps);
 				return;
 			}
 
@@ -563,7 +558,7 @@ void map_groups__insert(struct map_groups *mg, struct map *map)
 			mg->nr_maps_allocated = nr_allocate;
 		}
 		mg->maps_by_name[mg->nr_maps - 1] = map;
-		__map_groups__sort_by_name(mg);
+		__maps__sort_by_name(maps);
 	}
 	up_write(&maps->lock);
 }
@@ -574,9 +569,9 @@ static void __maps__remove(struct maps *maps, struct map *map)
 	map__put(map);
 }
 
-void map_groups__remove(struct map_groups *mg, struct map *map)
+void maps__remove(struct maps *mg, struct map *map)
 {
-	struct maps *maps = &mg->maps;
+	struct maps *maps = mg;
 	down_write(&maps->lock);
 	if (mg->last_search_by_name == map)
 		mg->last_search_by_name = NULL;
@@ -584,7 +579,7 @@ void map_groups__remove(struct map_groups *mg, struct map *map)
 	__maps__remove(maps, map);
 	--mg->nr_maps;
 	if (mg->maps_by_name)
-		__map_groups__free_maps_by_name(mg);
+		__maps__free_maps_by_name(maps);
 	up_write(&maps->lock);
 }
 
@@ -598,50 +593,44 @@ static void __maps__purge(struct maps *maps)
 	}
 }
 
-static void maps__exit(struct maps *maps)
+void maps__exit(struct maps *maps)
 {
 	down_write(&maps->lock);
 	__maps__purge(maps);
 	up_write(&maps->lock);
 }
 
-void map_groups__exit(struct map_groups *mg)
+bool maps__empty(struct maps *maps)
 {
-	maps__exit(&mg->maps);
+	return !maps__first(maps);
 }
 
-bool map_groups__empty(struct map_groups *mg)
+struct maps *maps__new(struct machine *machine)
 {
-	return !maps__first(&mg->maps);
-}
-
-struct map_groups *map_groups__new(struct machine *machine)
-{
-	struct map_groups *mg = zalloc(sizeof(*mg));
+	struct maps *mg = zalloc(sizeof(*mg)), *maps = mg;
 
 	if (mg != NULL)
-		map_groups__init(mg, machine);
+		maps__init(maps, machine);
 
 	return mg;
 }
 
-void map_groups__delete(struct map_groups *mg)
+void maps__delete(struct maps *mg)
 {
-	map_groups__exit(mg);
+	maps__exit(mg);
 	unwind__finish_access(mg);
 	free(mg);
 }
 
-void map_groups__put(struct map_groups *mg)
+void maps__put(struct maps *mg)
 {
 	if (mg && refcount_dec_and_test(&mg->refcnt))
-		map_groups__delete(mg);
+		maps__delete(mg);
 }
 
-struct symbol *map_groups__find_symbol(struct map_groups *mg,
-				       u64 addr, struct map **mapp)
+struct symbol *maps__find_symbol(struct maps *mg, u64 addr, struct map **mapp)
 {
-	struct map *map = map_groups__find(mg, addr);
+	struct map *map = maps__find(mg, addr);
 
 	/* Ensure map is loaded before using map->map_ip */
 	if (map != NULL && map__load(map) >= 0) {
@@ -660,8 +649,7 @@ static bool map__contains_symbol(struct map *map, struct symbol *sym)
 	return ip >= map->start && ip < map->end;
 }
 
-static struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
-						struct map **mapp)
+struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp)
 {
 	struct symbol *sym;
 	struct map *pos;
@@ -688,19 +676,12 @@ static struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *n
 	return sym;
 }
 
-struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
-					       const char *name,
-					       struct map **mapp)
-{
-	return maps__find_symbol_by_name(&mg->maps, name, mapp);
-}
-
-int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
+int maps__find_ams(struct maps *mg, struct addr_map_symbol *ams)
 {
 	if (ams->addr < ams->ms.map->start || ams->addr >= ams->ms.map->end) {
 		if (mg == NULL)
 			return -1;
-		ams->ms.map = map_groups__find(mg, ams->addr);
+		ams->ms.map = maps__find(mg, ams->addr);
 		if (ams->ms.map == NULL)
 			return -1;
 	}
@@ -711,7 +692,7 @@ int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
 	return ams->ms.sym ? 0 : -1;
 }
 
-static size_t maps__fprintf(struct maps *maps, FILE *fp)
+size_t maps__fprintf(struct maps *maps, FILE *fp)
 {
 	size_t printed = 0;
 	struct map *pos;
@@ -732,19 +713,8 @@ static size_t maps__fprintf(struct maps *maps, FILE *fp)
 	return printed;
 }
 
-size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
+int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
 {
-	return maps__fprintf(&mg->maps, fp);
-}
-
-static void __map_groups__insert(struct map_groups *mg, struct map *map)
-{
-	__maps__insert(&mg->maps, map);
-}
-
-int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp)
-{
-	struct maps *maps = &mg->maps;
 	struct rb_root *root;
 	struct rb_node *next, *first;
 	int err = 0;
@@ -809,7 +779,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE
 			}
 
 			before->end = map->start;
-			__map_groups__insert(mg, before);
+			__maps__insert(maps, before);
 			if (verbose >= 2 && !use_browser)
 				map__fprintf(before, fp);
 			map__put(before);
@@ -826,7 +796,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE
 			after->start = map->end;
 			after->pgoff += map->end - pos->start;
 			assert(pos->map_ip(pos, map->end) == after->map_ip(after, map->end));
-			__map_groups__insert(mg, after);
+			__maps__insert(maps, after);
 			if (verbose >= 2 && !use_browser)
 				map__fprintf(after, fp);
 			map__put(after);
@@ -847,16 +817,15 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE
 /*
  * XXX This should not really _copy_ te maps, but refcount them.
  */
-int map_groups__clone(struct thread *thread, struct map_groups *parent)
+int maps__clone(struct thread *thread, struct maps *parent)
 {
-	struct map_groups *mg = thread->mg;
+	struct maps *mg = thread->mg;
 	int err = -ENOMEM;
 	struct map *map;
-	struct maps *maps = &parent->maps;
 
-	down_read(&maps->lock);
+	down_read(&parent->lock);
 
-	maps__for_each_entry(maps, map) {
+	maps__for_each_entry(parent, map) {
 		struct map *new = map__clone(map);
 		if (new == NULL)
 			goto out_unlock;
@@ -865,13 +834,13 @@ int map_groups__clone(struct thread *thread, struct map_groups *parent)
 		if (err)
 			goto out_unlock;
 
-		map_groups__insert(mg, new);
+		maps__insert(mg, new);
 		map__put(new);
 	}
 
 	err = 0;
 out_unlock:
-	up_read(&maps->lock);
+	up_read(&parent->lock);
 	return err;
 }
 
@@ -959,7 +928,7 @@ struct kmap *map__kmap(struct map *map)
 	return kmap;
 }
 
-struct map_groups *map__kmaps(struct map *map)
+struct maps *map__kmaps(struct map *map)
 {
 	struct kmap *kmap = map__kmap(map);
 

commit a82f15e39a4b75482d48d0910f6abe5e4f869b76
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 10:42:38 2019 -0300

    perf map: Remove unused functions
    
    At some point those stopped being used, prune them.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-p2k98mj3ff2uk1z95sbl5r6e@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b59944eb469e..267d951b5dfd 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -568,6 +568,12 @@ void map_groups__insert(struct map_groups *mg, struct map *map)
 	up_write(&maps->lock);
 }
 
+static void __maps__remove(struct maps *maps, struct map *map)
+{
+	rb_erase_init(&map->rb_node, &maps->entries);
+	map__put(map);
+}
+
 void map_groups__remove(struct map_groups *mg, struct map *map)
 {
 	struct maps *maps = &mg->maps;
@@ -654,8 +660,8 @@ static bool map__contains_symbol(struct map *map, struct symbol *sym)
 	return ip >= map->start && ip < map->end;
 }
 
-struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
-					 struct map **mapp)
+static struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
+						struct map **mapp)
 {
 	struct symbol *sym;
 	struct map *pos;
@@ -890,26 +896,6 @@ static void __maps__insert(struct maps *maps, struct map *map)
 	map__get(map);
 }
 
-void maps__insert(struct maps *maps, struct map *map)
-{
-	down_write(&maps->lock);
-	__maps__insert(maps, map);
-	up_write(&maps->lock);
-}
-
-void __maps__remove(struct maps *maps, struct map *map)
-{
-	rb_erase_init(&map->rb_node, &maps->entries);
-	map__put(map);
-}
-
-void maps__remove(struct maps *maps, struct map *map)
-{
-	down_write(&maps->lock);
-	__maps__remove(maps, map);
-	up_write(&maps->lock);
-}
-
 struct map *maps__find(struct maps *maps, u64 ip)
 {
 	struct rb_node *p;

commit 540a63ea30c86b2785769b9ae713efbfa7547fde
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 22 12:39:06 2019 -0300

    perf script: Move map__fprintf_srccode() to near its only user
    
    No need to have it elsewhere.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-8cw846pudpxo0xdkvi9qnvrh@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 744bfbaf35cf..b59944eb469e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -433,51 +433,6 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 	return ret;
 }
 
-int map__fprintf_srccode(struct map *map, u64 addr,
-			 FILE *fp,
-			 struct srccode_state *state)
-{
-	char *srcfile;
-	int ret = 0;
-	unsigned line;
-	int len;
-	char *srccode;
-
-	if (!map || !map->dso)
-		return 0;
-	srcfile = get_srcline_split(map->dso,
-				    map__rip_2objdump(map, addr),
-				    &line);
-	if (!srcfile)
-		return 0;
-
-	/* Avoid redundant printing */
-	if (state &&
-	    state->srcfile &&
-	    !strcmp(state->srcfile, srcfile) &&
-	    state->line == line) {
-		free(srcfile);
-		return 0;
-	}
-
-	srccode = find_sourceline(srcfile, line, &len);
-	if (!srccode)
-		goto out_free_line;
-
-	ret = fprintf(fp, "|%-8d %.*s", line, len, srccode);
-
-	if (state) {
-		state->srcfile = srcfile;
-		state->line = line;
-	}
-	return ret;
-
-out_free_line:
-	free(srcfile);
-	return ret;
-}
-
-
 void srccode_state_free(struct srccode_state *state)
 {
 	zfree(&state->srcfile);

commit 0e3149f86b99ddabde8c5029eea0a9267e34f1a0
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Nov 19 18:44:22 2019 -0300

    perf dso: Move dso_id from 'struct map' to 'struct dso'
    
    And take it into account when looking up DSOs when we have the dso_id
    fields obtained from somewhere, like from PERF_RECORD_MMAP2 records.
    
    Instances of struct map pointing to the same DSO pathname but with
    anything in dso_id different are in fact different DSOs, so better have
    different 'struct dso' instances to reflect that. At some point we may
    want to get copies of the contents of the different objects if we want
    to do correct annotation or other analysis.
    
    With this we get 'struct map' 24 bytes leaner:
    
      $ pahole -C map ~/bin/perf
      struct map {
            union {
                    struct rb_node     rb_node __attribute__((__aligned__(8))); /*     0    24 */
                    struct list_head   node;                 /*     0    16 */
            } __attribute__((__aligned__(8)));               /*     0    24 */
            u64                        start;                /*    24     8 */
            u64                        end;                  /*    32     8 */
            _Bool                      erange_warned:1;      /*    40: 0  1 */
            _Bool                      priv:1;               /*    40: 1  1 */
    
            /* XXX 6 bits hole, try to pack */
            /* XXX 3 bytes hole, try to pack */
    
            u32                        prot;                 /*    44     4 */
            u64                        pgoff;                /*    48     8 */
            u64                        reloc;                /*    56     8 */
            /* --- cacheline 1 boundary (64 bytes) --- */
            u64                        (*map_ip)(struct map *, u64); /*    64     8 */
            u64                        (*unmap_ip)(struct map *, u64); /*    72     8 */
            struct dso *               dso;                  /*    80     8 */
            refcount_t                 refcnt;               /*    88     4 */
            u32                        flags;                /*    92     4 */
    
            /* size: 96, cachelines: 2, members: 13 */
            /* sum members: 92, holes: 1, sum holes: 3 */
            /* sum bitfield members: 2 bits, bit holes: 1, sum bit holes: 6 bits */
            /* forced alignments: 1 */
            /* last cacheline: 32 bytes */
      } __attribute__((__aligned__(8)));
      $
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-g4hxxmraplo7wfjmk384mfsb@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 812d663ebb57..744bfbaf35cf 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -161,12 +161,6 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		anon = is_anon_memory(filename, flags);
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
-
-		if (id)
-			map->dso_id = *id;
-		else
-			map->dso_id.min = map->dso_id.ino = map->dso_id.ino_generation = 0;
-
 		map->prot = prot;
 		map->flags = flags;
 		nsi = nsinfo__get(thread->nsinfo);
@@ -196,7 +190,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			pgoff = 0;
 			dso = machine__findnew_vdso(machine, thread);
 		} else
-			dso = machine__findnew_dso(machine, filename);
+			dso = machine__findnew_dso_id(machine, filename, id);
 
 		if (dso == NULL)
 			goto out_delete;

commit 4a7380a52ec90fbb1565dd638ee7f5b6e709f7fb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Nov 19 12:40:29 2019 -0300

    perf map: Pass a dso_id to map__new()
    
    Instead of the 4 fields, a step in the direction of moving this to
    struct dso.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-gp5s1xgxacurmih5d1l94ymy@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4f50b1b2961f..812d663ebb57 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -144,8 +144,8 @@ void map__init(struct map *map, u64 start, u64 end, u64 pgoff, struct dso *dso)
 }
 
 struct map *map__new(struct machine *machine, u64 start, u64 len,
-		     u64 pgoff, u32 d_maj, u32 d_min, u64 ino,
-		     u64 ino_gen, u32 prot, u32 flags, char *filename,
+		     u64 pgoff, struct dso_id *id,
+		     u32 prot, u32 flags, char *filename,
 		     struct thread *thread)
 {
 	struct map *map = malloc(sizeof(*map));
@@ -162,10 +162,11 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
 
-		map->dso_id.maj = d_maj;
-		map->dso_id.min = d_min;
-		map->dso_id.ino = ino;
-		map->dso_id.ino_generation = ino_gen;
+		if (id)
+			map->dso_id = *id;
+		else
+			map->dso_id.min = map->dso_id.ino = map->dso_id.ino_generation = 0;
+
 		map->prot = prot;
 		map->flags = flags;
 		nsi = nsinfo__get(thread->nsinfo);

commit 99459a84d5870a88274b4f10bc85c3e39e1d642c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Nov 19 12:26:19 2019 -0300

    perf map: Move maj/min/ino/ino_generation to separate struct
    
    And this patch highlights where these fields are being used: in the sort
    order where it uses it to compare maps and classify samples taking into
    account not just the DSO, but those DSO id fields.
    
    I think these should be used to differentiate DSOs with the same name
    but different 'struct dso_id' fields, i.e. these fields should move to
    'struct dso' and then be used as part of the key when doing lookups for
    DSOs, in addition to the DSO name.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-8v5isitqy0dup47nnwkpc80f@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 67e0f81416cb..4f50b1b2961f 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -162,10 +162,10 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
 
-		map->maj = d_maj;
-		map->min = d_min;
-		map->ino = ino;
-		map->ino_generation = ino_gen;
+		map->dso_id.maj = d_maj;
+		map->dso_id.min = d_min;
+		map->dso_id.ino = ino;
+		map->dso_id.ino_generation = ino_gen;
 		map->prot = prot;
 		map->flags = flags;
 		nsi = nsinfo__get(thread->nsinfo);

commit a7c2b572e217418ad34441202ad3addd8f94d2ea
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Nov 17 11:38:13 2019 -0300

    perf map_groups: Auto sort maps by name, if needed
    
    There are still lots of lookups by name, even if just when loading
    vmlinux, till that code is studied to figure out if its possible to do
    away with those map lookup by names, provide a way to sort it using
    libc's qsort/bsearch.
    
    Doing it at the first lookup defers the sorting a bit, and as the code
    stands now, is never done for user maps, just for the kernel ones.
    
      # perf probe -l
      # perf probe -x ~/bin/perf -L __map_groups__find_by_name
      <__map_groups__find_by_name@/home/acme/git/perf/tools/perf/util/symbol.c:0>
            0  static struct map *__map_groups__find_by_name(struct map_groups *mg, const char *name)
            1  {
                      struct map **mapp;
    
            4         if (mg->maps_by_name == NULL &&
            5             map__groups__sort_by_name_from_rbtree(mg))
            6                 return NULL;
    
            8         mapp = bsearch(name, mg->maps_by_name, mg->nr_maps, sizeof(*mapp), map__strcmp_name);
            9         if (mapp)
           10                 return *mapp;
           11         return NULL;
           12  }
    
               struct map *map_groups__find_by_name(struct map_groups *mg, const char *name)
               {
    
      # perf probe -x ~/bin/perf 'found=__map_groups__find_by_name:10 name:string'
      Added new event:
        probe_perf:found     (on __map_groups__find_by_name:10 in /home/acme/bin/perf with name:string)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe_perf:found -aR sleep 1
    
      #
      # perf probe -x ~/bin/perf -L map_groups__find_by_name
      <map_groups__find_by_name@/home/acme/git/perf/tools/perf/util/symbol.c:0>
            0  struct map *map_groups__find_by_name(struct map_groups *mg, const char *name)
            1  {
            2         struct maps *maps = &mg->maps;
                      struct map *map;
    
            5         down_read(&maps->lock);
    
            7         if (mg->last_search_by_name && strcmp(mg->last_search_by_name->dso->short_name, name) == 0) {
            8                 map = mg->last_search_by_name;
            9                 goto out_unlock;
                      }
                      /*
                       * If we have mg->maps_by_name, then the name isn't in the rbtree,
                       * as mg->maps_by_name mirrors the rbtree when lookups by name are
                       * made.
                       */
           16         map = __map_groups__find_by_name(mg, name);
           17         if (map || mg->maps_by_name != NULL)
           18                 goto out_unlock;
    
                      /* Fallback to traversing the rbtree... */
           21         maps__for_each_entry(maps, map)
           22                 if (strcmp(map->dso->short_name, name) == 0) {
           23                         mg->last_search_by_name = map;
           24                         goto out_unlock;
                              }
    
           27         map = NULL;
    
               out_unlock:
           30         up_read(&maps->lock);
           31         return map;
           32  }
    
               int dso__load_vmlinux(struct dso *dso, struct map *map,
                                    const char *vmlinux, bool vmlinux_allocated)
    
      # perf probe -x ~/bin/perf 'fallback=map_groups__find_by_name:21 name:string'
      Added new events:
        probe_perf:fallback  (on map_groups__find_by_name:21 in /home/acme/bin/perf with name:string)
        probe_perf:fallback_1 (on map_groups__find_by_name:21 in /home/acme/bin/perf with name:string)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe_perf:fallback_1 -aR sleep 1
    
      #
      # perf probe -l
        probe_perf:fallback  (on map_groups__find_by_name:21@util/symbol.c in /home/acme/bin/perf with name_string)
        probe_perf:fallback_1 (on map_groups__find_by_name:21@util/symbol.c in /home/acme/bin/perf with name_string)
        probe_perf:found     (on __map_groups__find_by_name:10@util/symbol.c in /home/acme/bin/perf with name_string)
      #
      # perf stat -e probe_perf:*
    
    Now run 'perf top' in another term and then, after a while, stop 'perf stat':
    
    Furthermore, if we ask for interval printing, we can see that that is done just
    at the start of the workload:
    
      # perf stat -I1000 -e probe_perf:*
      #           time             counts unit events
           1.000319513                  0      probe_perf:found
           1.000319513                  0      probe_perf:fallback_1
           1.000319513                  0      probe_perf:fallback
           2.001868092             23,251      probe_perf:found
           2.001868092                  0      probe_perf:fallback_1
           2.001868092                  0      probe_perf:fallback
           3.002901597                  0      probe_perf:found
           3.002901597                  0      probe_perf:fallback_1
           3.002901597                  0      probe_perf:fallback
           4.003358591                  0      probe_perf:found
           4.003358591                  0      probe_perf:fallback_1
           4.003358591                  0      probe_perf:fallback
      ^C
      #
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-c5lmbyr14x448rcfii7y6t3k@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index d0899df77baa..67e0f81416cb 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -573,20 +573,63 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 	maps__init(&mg->maps);
 	mg->machine = machine;
 	mg->last_search_by_name = NULL;
+	mg->nr_maps = 0;
+	mg->maps_by_name = NULL;
 	refcount_set(&mg->refcnt, 1);
 }
 
+static void __map_groups__free_maps_by_name(struct map_groups *mg)
+{
+	/*
+	 * Free everything to try to do it from the rbtree in the next search
+	 */
+	zfree(&mg->maps_by_name);
+	mg->nr_maps_allocated = 0;
+}
+
 void map_groups__insert(struct map_groups *mg, struct map *map)
 {
-	maps__insert(&mg->maps, map);
+	struct maps *maps = &mg->maps;
+
+	down_write(&maps->lock);
+	__maps__insert(maps, map);
+	++mg->nr_maps;
+
+	/*
+	 * If we already performed some search by name, then we need to add the just
+	 * inserted map and resort.
+	 */
+	if (mg->maps_by_name) {
+		if (mg->nr_maps > mg->nr_maps_allocated) {
+			int nr_allocate = mg->nr_maps * 2;
+			struct map **maps_by_name = realloc(mg->maps_by_name, nr_allocate * sizeof(map));
+
+			if (maps_by_name == NULL) {
+				__map_groups__free_maps_by_name(mg);
+				return;
+			}
+
+			mg->maps_by_name = maps_by_name;
+			mg->nr_maps_allocated = nr_allocate;
+		}
+		mg->maps_by_name[mg->nr_maps - 1] = map;
+		__map_groups__sort_by_name(mg);
+	}
+	up_write(&maps->lock);
 }
 
 void map_groups__remove(struct map_groups *mg, struct map *map)
 {
+	struct maps *maps = &mg->maps;
+	down_write(&maps->lock);
 	if (mg->last_search_by_name == map)
 		mg->last_search_by_name = NULL;
 
-	maps__remove(&mg->maps, map);
+	__maps__remove(maps, map);
+	--mg->nr_maps;
+	if (mg->maps_by_name)
+		__map_groups__free_maps_by_name(mg);
+	up_write(&maps->lock);
 }
 
 static void __maps__purge(struct maps *maps)
@@ -904,7 +947,7 @@ void maps__insert(struct maps *maps, struct map *map)
 	up_write(&maps->lock);
 }
 
-static void __maps__remove(struct maps *maps, struct map *map)
+void __maps__remove(struct maps *maps, struct map *map)
 {
 	rb_erase_init(&map->rb_node, &maps->entries);
 	map__put(map);

commit 1ae14516cba032a83b561144d3d48fd381584c0c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Nov 13 16:33:33 2019 -0300

    perf map_groups: Add a front end cache for map lookups by name
    
    Lets see if it helps:
    
    First look at the probeable lines for the function that does lookups by
    name in a map_groups struct:
    
      # perf probe -x ~/bin/perf -L map_groups__find_by_name
      <map_groups__find_by_name@/home/acme/git/perf/tools/perf/util/symbol.c:0>
            0  struct map *map_groups__find_by_name(struct map_groups *mg, const char *name)
            1  {
            2         struct maps *maps = &mg->maps;
                      struct map *map;
    
            5         down_read(&maps->lock);
    
            7         if (mg->last_search_by_name && strcmp(mg->last_search_by_name->dso->short_name, name) == 0) {
            8                 map = mg->last_search_by_name;
            9                 goto out_unlock;
                      }
    
           12         maps__for_each_entry(maps, map)
           13                 if (strcmp(map->dso->short_name, name) == 0) {
           14                         mg->last_search_by_name = map;
           15                         goto out_unlock;
                              }
    
           18         map = NULL;
    
               out_unlock:
           21         up_read(&maps->lock);
           22         return map;
           23  }
    
               int dso__load_vmlinux(struct dso *dso, struct map *map,
                                    const char *vmlinux, bool vmlinux_allocated)
    
      #
    
    Now add a probe to the place where we reuse the last search:
    
      # perf probe -x ~/bin/perf map_groups__find_by_name:8
      Added new event:
        probe_perf:map_groups__find_by_name (on map_groups__find_by_name:8 in /home/acme/bin/perf)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe_perf:map_groups__find_by_name -aR sleep 1
    
      #
    
    Now lets do a system wide 'perf stat' counting those events:
    
      # perf stat -e probe_perf:*
    
    Leave it running and lets do a 'perf top', then, after a while, stop the
    'perf stat':
    
      # perf stat -e probe_perf:*
      ^C
       Performance counter stats for 'system wide':
    
                   3,603      probe_perf:map_groups__find_by_name
    
            44.565253139 seconds time elapsed
      #
    
    yeah, good to have.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-tcz37g3nxv3tvxw3q90vga3p@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 49e353eaa337..d0899df77baa 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -572,6 +572,7 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 {
 	maps__init(&mg->maps);
 	mg->machine = machine;
+	mg->last_search_by_name = NULL;
 	refcount_set(&mg->refcnt, 1);
 }
 
@@ -580,6 +581,14 @@ void map_groups__insert(struct map_groups *mg, struct map *map)
 	maps__insert(&mg->maps, map);
 }
 
+void map_groups__remove(struct map_groups *mg, struct map *map)
+{
+	if (mg->last_search_by_name == map)
+		mg->last_search_by_name = NULL;
+
+	maps__remove(&mg->maps, map);
+}
+
 static void __maps__purge(struct maps *maps)
 {
 	struct map *pos, *next;

commit c5c584d2dbb0883f1e6f61872964a4a3a35a2017
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Nov 13 16:16:25 2019 -0300

    perf maps: Do not use an rbtree to sort by map name
    
    This is only used for the kernel maps, shave 24 bytes out 'struct map'
    and just traverse the existing per ip rbtree to look for maps by name,
    use a front end cache to reuse the last search if its the same name.
    
    After this 'struct map' is down to just two cachelines:
    
      $ pahole -C map ~/bin/perf
      struct map {
            union {
                    struct rb_node rb_node __attribute__((__aligned__(8))); /*     0    24 */
                    struct list_head node;                   /*     0    16 */
            } __attribute__((__aligned__(8)));                                               /*     0    24 */
            u64                        start;                /*    24     8 */
            u64                        end;                  /*    32     8 */
            _Bool                      erange_warned;        /*    40     1 */
    
            /* XXX 3 bytes hole, try to pack */
    
            u32                        priv;                 /*    44     4 */
            u32                        prot;                 /*    48     4 */
            u32                        flags;                /*    52     4 */
            u64                        pgoff;                /*    56     8 */
            /* --- cacheline 1 boundary (64 bytes) --- */
            u64                        reloc;                /*    64     8 */
            u32                        maj;                  /*    72     4 */
            u32                        min;                  /*    76     4 */
            u64                        ino;                  /*    80     8 */
            u64                        ino_generation;       /*    88     8 */
            u64                        (*map_ip)(struct map *, u64); /*    96     8 */
            u64                        (*unmap_ip)(struct map *, u64); /*   104     8 */
            struct dso *               dso;                  /*   112     8 */
            refcount_t                 refcnt;               /*   120     4 */
    
            /* size: 128, cachelines: 2, members: 17 */
            /* sum members: 121, holes: 1, sum holes: 3 */
            /* padding: 4 */
            /* forced alignments: 1 */
      } __attribute__((__aligned__(8)));
      $
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-bvr8fqfgzxtgnhnwt5sssx5g@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 69b9e9b3d915..49e353eaa337 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -26,7 +26,6 @@
 #include "ui/ui.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
-static void __maps__insert_name(struct maps *maps, struct map *map);
 
 static inline int is_anon_memory(const char *filename, u32 flags)
 {
@@ -566,7 +565,6 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 static void maps__init(struct maps *maps)
 {
 	maps->entries = RB_ROOT;
-	maps->names = RB_ROOT;
 	init_rwsem(&maps->lock);
 }
 
@@ -589,8 +587,6 @@ static void __maps__purge(struct maps *maps)
 	maps__for_each_entry_safe(maps, pos, next) {
 		rb_erase_init(&pos->rb_node,  &maps->entries);
 		map__put(pos);
-		rb_erase_init(&pos->rb_node_name, &maps->names);
-		map__put(pos);
 	}
 }
 
@@ -736,7 +732,6 @@ size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 static void __map_groups__insert(struct map_groups *mg, struct map *map)
 {
 	__maps__insert(&mg->maps, map);
-	__maps__insert_name(&mg->maps, map);
 }
 
 int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp)
@@ -893,32 +888,10 @@ static void __maps__insert(struct maps *maps, struct map *map)
 	map__get(map);
 }
 
-static void __maps__insert_name(struct maps *maps, struct map *map)
-{
-	struct rb_node **p = &maps->names.rb_node;
-	struct rb_node *parent = NULL;
-	struct map *m;
-	int rc;
-
-	while (*p != NULL) {
-		parent = *p;
-		m = rb_entry(parent, struct map, rb_node_name);
-		rc = strcmp(m->dso->short_name, map->dso->short_name);
-		if (rc < 0)
-			p = &(*p)->rb_left;
-		else
-			p = &(*p)->rb_right;
-	}
-	rb_link_node(&map->rb_node_name, parent, p);
-	rb_insert_color(&map->rb_node_name, &maps->names);
-	map__get(map);
-}
-
 void maps__insert(struct maps *maps, struct map *map)
 {
 	down_write(&maps->lock);
 	__maps__insert(maps, map);
-	__maps__insert_name(maps, map);
 	up_write(&maps->lock);
 }
 
@@ -926,9 +899,6 @@ static void __maps__remove(struct maps *maps, struct map *map)
 {
 	rb_erase_init(&map->rb_node, &maps->entries);
 	map__put(map);
-
-	rb_erase_init(&map->rb_node_name, &maps->names);
-	map__put(map);
 }
 
 void maps__remove(struct maps *maps, struct map *map)

commit bcb8af5c46e452018de9b58db1fd0ffd94b5d96c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Nov 13 16:06:28 2019 -0300

    perf maps: Purge the entries from maps->names in __maps__purge()
    
    No need to iterate via the ->names rbtree, as all the entries there
    as in maps->entries as well, reuse __maps__purge() for that.
    
    Doing it this way we can kill maps__for_each_entry_by_name(),
    maps__for_each_entry_by_name_safe(), maps__{first,next}_by_name().
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-ps0nrio8pydyo23rr2s696ue@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 359846833a00..69b9e9b3d915 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -589,15 +589,7 @@ static void __maps__purge(struct maps *maps)
 	maps__for_each_entry_safe(maps, pos, next) {
 		rb_erase_init(&pos->rb_node,  &maps->entries);
 		map__put(pos);
-	}
-}
-
-static void __maps__purge_names(struct maps *maps)
-{
-	struct map *pos, *next;
-
-	maps__for_each_entry_by_name_safe(maps, pos, next) {
-		rb_erase_init(&pos->rb_node_name,  &maps->names);
+		rb_erase_init(&pos->rb_node_name, &maps->names);
 		map__put(pos);
 	}
 }
@@ -606,7 +598,6 @@ static void maps__exit(struct maps *maps)
 {
 	down_write(&maps->lock);
 	__maps__purge(maps);
-	__maps__purge_names(maps);
 	up_write(&maps->lock);
 }
 
@@ -994,29 +985,6 @@ struct map *map__next(struct map *map)
 	return map ? __map__next(map) : NULL;
 }
 
-struct map *maps__first_by_name(struct maps *maps)
-{
-	struct rb_node *first = rb_first(&maps->names);
-
-	if (first)
-		return rb_entry(first, struct map, rb_node_name);
-	return NULL;
-}
-
-static struct map *__map__next_by_name(struct map *map)
-{
-	struct rb_node *next = rb_next(&map->rb_node_name);
-
-	if (next)
-		return rb_entry(next, struct map, rb_node_name);
-	return NULL;
-}
-
-struct map *map__next_by_name(struct map *map)
-{
-	return map ? __map__next_by_name(map) : NULL;
-}
-
 struct kmap *__map__kmap(struct map *map)
 {
 	if (!map->dso || !map->dso->kernel)

commit 7b018e298752b9bcaf34eba8e1d3c08e3207dfd8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 16:55:53 2019 -0300

    perf map: Remove ->groups from 'struct map'
    
    With this 'struct map' uses a bit over 3 cachelines:
    
      $ pahole -C map ~/bin/perf
      <SNIP>
            /* --- cacheline 2 boundary (128 bytes) --- */
            u64                        (*unmap_ip)(struct map *, u64); /*   128     8 */
            struct dso *               dso;                            /*   136     8 */
            refcount_t                 refcnt;                         /*   144     4 */
    
            /* size: 152, cachelines: 3, members: 18 */
            /* sum members: 145, holes: 1, sum holes: 3 */
            /* padding: 4 */
            /* forced alignments: 2 */
            /* last cacheline: 24 bytes */
      } __attribute__((__aligned__(8)));
      $
    
    We probably can move map->map/unmap_ip() moved to 'struct map_groups',
    that will shave more 16 bytes, getting this almost to two cachelines.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-ymlv3nzpofv2fugnjnizkrwy@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 27d8508f8a44..359846833a00 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -140,7 +140,6 @@ void map__init(struct map *map, u64 start, u64 end, u64 pgoff, struct dso *dso)
 	map->map_ip   = map__map_ip;
 	map->unmap_ip = map__unmap_ip;
 	RB_CLEAR_NODE(&map->rb_node);
-	map->groups   = NULL;
 	map->erange_warned = false;
 	refcount_set(&map->refcnt, 1);
 }
@@ -388,7 +387,6 @@ struct map *map__clone(struct map *from)
 		refcount_set(&map->refcnt, 1);
 		RB_CLEAR_NODE(&map->rb_node);
 		dso__get(map->dso);
-		map->groups = NULL;
 	}
 
 	return map;
@@ -582,7 +580,6 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 void map_groups__insert(struct map_groups *mg, struct map *map)
 {
 	maps__insert(&mg->maps, map);
-	map->groups = mg;
 }
 
 static void __maps__purge(struct maps *maps)
@@ -749,7 +746,6 @@ static void __map_groups__insert(struct map_groups *mg, struct map *map)
 {
 	__maps__insert(&mg->maps, map);
 	__maps__insert_name(&mg->maps, map);
-	map->groups = mg;
 }
 
 int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp)

commit 3f662fc08dddebd7bab654eada1f3e7568959eef
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 1 17:53:02 2019 -0300

    perf map: Combine maps__fixup_overlappings with its only use
    
    In the process we can kill some of the struct map->groups usage, trying
    to get rid of this per-full struct map fields getting in the way of
    sharing a map across father/parent processes.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-e50eqtqw3za24vmbjnqmmcs6@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6c59f55026c1..27d8508f8a44 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -752,8 +752,9 @@ static void __map_groups__insert(struct map_groups *mg, struct map *map)
 	map->groups = mg;
 }
 
-static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
+int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp)
 {
+	struct maps *maps = &mg->maps;
 	struct rb_root *root;
 	struct rb_node *next, *first;
 	int err = 0;
@@ -818,7 +819,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			}
 
 			before->end = map->start;
-			__map_groups__insert(pos->groups, before);
+			__map_groups__insert(mg, before);
 			if (verbose >= 2 && !use_browser)
 				map__fprintf(before, fp);
 			map__put(before);
@@ -835,7 +836,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			after->start = map->end;
 			after->pgoff += map->end - pos->start;
 			assert(pos->map_ip(pos, map->end) == after->map_ip(after, map->end));
-			__map_groups__insert(pos->groups, after);
+			__map_groups__insert(mg, after);
 			if (verbose >= 2 && !use_browser)
 				map__fprintf(after, fp);
 			map__put(after);
@@ -853,12 +854,6 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 	return err;
 }
 
-int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
-				   FILE *fp)
-{
-	return maps__fixup_overlappings(&mg->maps, map, fp);
-}
-
 /*
  * XXX This should not really _copy_ te maps, but refcount them.
  */

commit d46a4cdf49937b0b3abeb2cd7fa5dc65795e7ea7
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 15:57:38 2019 -0300

    pref tools: Make 'struct addr_map_symbol' contain 'struct map_symbol'
    
    So that we pass that substructure around and with it consolidate lots of
    functions that receive a (map, symbol) pair and now can receive just a
    'struct map_symbol' pointer.
    
    This further paves the way to add 'struct map_groups' to 'struct
    map_symbol' so that we can have all we need for annotation so that we
    can ditch 'struct map'->groups, i.e. have the map_groups pointer in a
    more central place, avoiding the pointer in the 'struct map' that have
    tons of instances.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-fs90ttd9q12l7989fo7pw81q@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index db842568f4be..6c59f55026c1 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -705,18 +705,18 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 
 int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
 {
-	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
+	if (ams->addr < ams->ms.map->start || ams->addr >= ams->ms.map->end) {
 		if (mg == NULL)
 			return -1;
-		ams->map = map_groups__find(mg, ams->addr);
-		if (ams->map == NULL)
+		ams->ms.map = map_groups__find(mg, ams->addr);
+		if (ams->ms.map == NULL)
 			return -1;
 	}
 
-	ams->al_addr = ams->map->map_ip(ams->map, ams->addr);
-	ams->sym = map__find_symbol(ams->map, ams->al_addr);
+	ams->al_addr = ams->ms.map->map_ip(ams->ms.map, ams->addr);
+	ams->ms.sym = map__find_symbol(ams->ms.map, ams->al_addr);
 
-	return ams->sym ? 0 : -1;
+	return ams->ms.sym ? 0 : -1;
 }
 
 static size_t maps__fprintf(struct maps *maps, FILE *fp)

commit 9d355b381b35be1ac4e77600d6b9b27c674c5d5f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 10:14:05 2019 -0300

    perf map_groups: Pass the object to map_groups__find_ams()
    
    We were just passing a map to look for and reuse its map->groups member,
    but the idea is that this is going away, as a map can be in multiple
    rb_trees when being reused via a map_node, so do as all the other
    map_groups methods and pass as its first arg the object being operated
    on.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-nmi2pbggqloogwl6vxrvex5a@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a4d889c0fa88..db842568f4be 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -703,12 +703,12 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 	return maps__find_symbol_by_name(&mg->maps, name, mapp);
 }
 
-int map_groups__find_ams(struct addr_map_symbol *ams)
+int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
 {
 	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
-		if (ams->map->groups == NULL)
+		if (mg == NULL)
 			return -1;
-		ams->map = map_groups__find(ams->map->groups, ams->addr);
+		ams->map = map_groups__find(mg, ams->addr);
 		if (ams->map == NULL)
 			return -1;
 	}

commit de90d513b2464d28a17fc4eaada97f4ad742ba00
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 16:31:33 2019 -0300

    perf map: Use map->dso->kernel + map__kmaps() in map__kmaps()
    
    Its equivalent to using map->groups to obtain the machine struct.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-bdbazuj4ggrmzxdviaqdrdwh@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 466c9b035e19..a4d889c0fa88 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -244,18 +244,11 @@ struct map *map__new2(u64 start, struct dso *dso)
 	return map;
 }
 
-/*
- * Use this and __map__is_kmodule() for map instances that are in
- * machine->kmaps, and thus have map->groups->machine all properly set, to
- * disambiguate between the kernel and modules.
- *
- * When the need arises, introduce map__is_{kernel,kmodule)() that
- * checks (map->groups != NULL && map->groups->machine != NULL &&
- * map->dso->kernel) before calling __map__is_{kernel,kmodule}())
- */
 bool __map__is_kernel(const struct map *map)
 {
-	return machine__kernel_map(map->groups->machine) == map;
+	if (!map->dso->kernel)
+		return false;
+	return machine__kernel_map(map__kmaps((struct map *)map)->machine) == map;
 }
 
 bool __map__is_extra_kernel_map(const struct map *map)

commit 8efc4f05685dae2da1d21973eba5e59e7863c77f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 28 11:31:38 2019 -0300

    perf maps: Add for_each_entry()/_safe() iterators
    
    To reduce boilerplate, provide a more compact form using an idiom
    present in other trees of data structures.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-59gmq4kg1r68ou1wknyjl78x@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 86d8d187f872..466c9b035e19 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -594,28 +594,20 @@ void map_groups__insert(struct map_groups *mg, struct map *map)
 
 static void __maps__purge(struct maps *maps)
 {
-	struct rb_root *root = &maps->entries;
-	struct rb_node *next = rb_first(root);
+	struct map *pos, *next;
 
-	while (next) {
-		struct map *pos = rb_entry(next, struct map, rb_node);
-
-		next = rb_next(&pos->rb_node);
-		rb_erase_init(&pos->rb_node, root);
+	maps__for_each_entry_safe(maps, pos, next) {
+		rb_erase_init(&pos->rb_node,  &maps->entries);
 		map__put(pos);
 	}
 }
 
 static void __maps__purge_names(struct maps *maps)
 {
-	struct rb_root *root = &maps->names;
-	struct rb_node *next = rb_first(root);
-
-	while (next) {
-		struct map *pos = rb_entry(next, struct map, rb_node_name);
+	struct map *pos, *next;
 
-		next = rb_next(&pos->rb_node_name);
-		rb_erase_init(&pos->rb_node_name, root);
+	maps__for_each_entry_by_name_safe(maps, pos, next) {
+		rb_erase_init(&pos->rb_node_name,  &maps->names);
 		map__put(pos);
 	}
 }
@@ -687,13 +679,11 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 					 struct map **mapp)
 {
 	struct symbol *sym;
-	struct rb_node *nd;
+	struct map *pos;
 
 	down_read(&maps->lock);
 
-	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
-		struct map *pos = rb_entry(nd, struct map, rb_node);
-
+	maps__for_each_entry(maps, pos) {
 		sym = map__find_symbol_by_name(pos, name);
 
 		if (sym == NULL)
@@ -739,12 +729,11 @@ int map_groups__find_ams(struct addr_map_symbol *ams)
 static size_t maps__fprintf(struct maps *maps, FILE *fp)
 {
 	size_t printed = 0;
-	struct rb_node *nd;
+	struct map *pos;
 
 	down_read(&maps->lock);
 
-	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
-		struct map *pos = rb_entry(nd, struct map, rb_node);
+	maps__for_each_entry(maps, pos) {
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
 		if (verbose > 2) {
@@ -889,7 +878,7 @@ int map_groups__clone(struct thread *thread, struct map_groups *parent)
 
 	down_read(&maps->lock);
 
-	for (map = maps__first(maps); map; map = map__next(map)) {
+	maps__for_each_entry(maps, map) {
 		struct map *new = map__clone(map);
 		if (new == NULL)
 			goto out_unlock;
@@ -1021,6 +1010,29 @@ struct map *map__next(struct map *map)
 	return map ? __map__next(map) : NULL;
 }
 
+struct map *maps__first_by_name(struct maps *maps)
+{
+	struct rb_node *first = rb_first(&maps->names);
+
+	if (first)
+		return rb_entry(first, struct map, rb_node_name);
+	return NULL;
+}
+
+static struct map *__map__next_by_name(struct map *map)
+{
+	struct rb_node *next = rb_next(&map->rb_node_name);
+
+	if (next)
+		return rb_entry(next, struct map, rb_node_name);
+	return NULL;
+}
+
+struct map *map__next_by_name(struct map *map)
+{
+	return map ? __map__next_by_name(map) : NULL;
+}
+
 struct kmap *__map__kmap(struct map *map)
 {
 	if (!map->dso || !map->dso->kernel)

commit 20419d3a5bc0a278ed7e2ee54943674004411933
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 28 11:50:12 2019 -0300

    perf map: Allow map__next() to receive a NULL arg
    
    Just like free(), return NULL in that case, will simplify the
    for_each_entry_safe() iterators.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-pbde2ucn49khnrebclys9pny@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c9ba49566981..86d8d187f872 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1007,7 +1007,7 @@ struct map *maps__first(struct maps *maps)
 	return NULL;
 }
 
-struct map *map__next(struct map *map)
+static struct map *__map__next(struct map *map)
 {
 	struct rb_node *next = rb_next(&map->rb_node);
 
@@ -1016,6 +1016,11 @@ struct map *map__next(struct map *map)
 	return NULL;
 }
 
+struct map *map__next(struct map *map)
+{
+	return map ? __map__next(map) : NULL;
+}
+
 struct kmap *__map__kmap(struct map *map)
 {
 	if (!map->dso || !map->dso->kernel)

commit ee2555b612869a763563c5389ad789a52db0afd1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Oct 25 15:14:50 2019 -0300

    perf map: Check if the map still has some refcounts on exit
    
    We were checking just if it was still on some rb tree, but that is not
    the only way that this map can still have references, map->refcnt is
    there exactly for this, use it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-hany65tbeavsax7n3xvwl9pc@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index eec9b282c047..c9ba49566981 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -288,7 +288,7 @@ bool map__has_symbols(const struct map *map)
 
 static void map__exit(struct map *map)
 {
-	BUG_ON(!RB_EMPTY_NODE(&map->rb_node));
+	BUG_ON(refcount_read(&map->refcnt) != 0);
 	dso__zput(map->dso);
 }
 

commit ee212d6ea20887c0ef352be8563ca13dbf965906
Author: Steve MacLean <Steve.MacLean@microsoft.com>
Date:   Sat Sep 28 01:39:00 2019 +0000

    perf map: Fix overlapped map handling
    
    Whenever an mmap/mmap2 event occurs, the map tree must be updated to add a new
    entry. If a new map overlaps a previous map, the overlapped section of the
    previous map is effectively unmapped, but the non-overlapping sections are
    still valid.
    
    maps__fixup_overlappings() is responsible for creating any new map entries from
    the previously overlapped map. It optionally creates a before and an after map.
    
    When creating the after map the existing code failed to adjust the map.pgoff.
    This meant the new after map would incorrectly calculate the file offset
    for the ip. This results in incorrect symbol name resolution for any ip in the
    after region.
    
    Make maps__fixup_overlappings() correctly populate map.pgoff.
    
    Add an assert that new mapping matches old mapping at the beginning of
    the after map.
    
    Committer-testing:
    
    Validated correct parsing of libcoreclr.so symbols from .NET Core 3.0 preview9
    (which didn't strip symbols).
    
    Preparation:
    
      ~/dotnet3.0-preview9/dotnet new webapi -o perfSymbol
      cd perfSymbol
      ~/dotnet3.0-preview9/dotnet publish
      perf record ~/dotnet3.0-preview9/dotnet \
          bin/Debug/netcoreapp3.0/publish/perfSymbol.dll
      ^C
    
    Before:
    
      perf script --show-mmap-events 2>&1 | grep -e MMAP -e unknown |\
         grep libcoreclr.so | head -n 4
            dotnet  1907 373352.698780: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615726000(0x768000) @ 0 08:02 5510620 765057155]: \
                r-xp .../3.0.0-preview9-19423-09/libcoreclr.so
            dotnet  1907 373352.701091: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615974000(0x1000) @ 0x24e000 08:02 5510620 765057155]: \
                rwxp .../3.0.0-preview9-19423-09/libcoreclr.so
            dotnet  1907 373352.701241: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615c42000(0x1000) @ 0x51c000 08:02 5510620 765057155]: \
                rwxp .../3.0.0-preview9-19423-09/libcoreclr.so
            dotnet  1907 373352.705249:     250000 cpu-clock: \
                 7fe6159a1f99 [unknown] \
                 (.../3.0.0-preview9-19423-09/libcoreclr.so)
    
    After:
    
      perf script --show-mmap-events 2>&1 | grep -e MMAP -e unknown |\
         grep libcoreclr.so | head -n 4
            dotnet  1907 373352.698780: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615726000(0x768000) @ 0 08:02 5510620 765057155]: \
                r-xp .../3.0.0-preview9-19423-09/libcoreclr.so
            dotnet  1907 373352.701091: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615974000(0x1000) @ 0x24e000 08:02 5510620 765057155]: \
                rwxp .../3.0.0-preview9-19423-09/libcoreclr.so
            dotnet  1907 373352.701241: PERF_RECORD_MMAP2 1907/1907: \
                [0x7fe615c42000(0x1000) @ 0x51c000 08:02 5510620 765057155]: \
                rwxp .../3.0.0-preview9-19423-09/libcoreclr.so
    
    All the [unknown] symbols were resolved.
    
    Signed-off-by: Steve MacLean <Steve.MacLean@Microsoft.com>
    Tested-by: Brian Robbins <brianrob@microsoft.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Cc: John Keeping <john@metanate.com>
    Cc: John Salem <josalem@microsoft.com>
    Cc: Leo Yan <leo.yan@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom McDonald <thomas.mcdonald@microsoft.com>
    Link: http://lore.kernel.org/lkml/BN8PR21MB136270949F22A6A02335C238F7800@BN8PR21MB1362.namprd21.prod.outlook.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 5b83ed1ebbd6..eec9b282c047 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 #include "symbol.h"
+#include <assert.h>
 #include <errno.h>
 #include <inttypes.h>
 #include <limits.h>
@@ -850,6 +851,8 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			}
 
 			after->start = map->end;
+			after->pgoff += map->end - pos->start;
+			assert(pos->map_ip(pos, map->end) == after->map_ip(after, map->end));
 			__map_groups__insert(pos->groups, after);
 			if (verbose >= 2 && !use_browser)
 				map__fprintf(after, fp);

commit d3300a3c4e76ccecf4daa889327e340a870c550b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Aug 30 15:09:54 2019 -0300

    perf symbols: Move mem_info and branch_info out of symbol.h
    
    The mem_info struct goes to mem-events.h and branch_info goes to
    branch.h, where they belong, this way we can remove several headers from
    symbols.h and trim the include dependency tree more.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-aupw71xnravcsu2xoabfmhpc@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 623a63cd1eec..5b83ed1ebbd6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -10,6 +10,7 @@
 #include <uapi/linux/mman.h> /* To get things like MAP_HUGETLB even on older libc headers */
 #include "dso.h"
 #include "map.h"
+#include "map_symbol.h"
 #include "thread.h"
 #include "vdso.h"
 #include "build-id.h"

commit 4a3cec84949d14dc3ef7fb8a51b8949af93cac13
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Aug 30 11:11:01 2019 -0300

    perf dsos: Move the dsos struct and its methods to separate source files
    
    So that we can reduce the header dependency tree further, in the process
    noticed that lots of places were getting even things like build-id
    routines and 'struct perf_tool' definition indirectly, so fix all those
    too.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-ti0btma9ow5ndrytyoqdk62j@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c75b20b93820..623a63cd1eec 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <uapi/linux/mman.h> /* To get things like MAP_HUGETLB even on older libc headers */
+#include "dso.h"
 #include "map.h"
 #include "thread.h"
 #include "vdso.h"

commit 8520a98dbab61e9e340cdfb72dd17ccc8a98961e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 29 16:18:59 2019 -0300

    perf debug: Remove needless include directives from debug.h
    
    All we need there is a forward declaration for 'union perf_event', so
    remove it from there and add missing header directives in places using
    things from this indirect include.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-7ftk0ztstqub1tirjj8o8xbl@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 27b7b102e4a2..c75b20b93820 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -20,6 +20,7 @@
 #include "namespaces.h"
 #include "unwind.h"
 #include "srccode.h"
+#include "ui/ui.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
 static void __maps__insert_name(struct maps *maps, struct map *map);

commit e8ba2906f6b9054102ad035ac9cafad9d4168589
Author: John Keeping <john@metanate.com>
Date:   Thu Aug 15 11:01:45 2019 +0100

    perf unwind: Fix libunwind when tid != pid
    
    Commit e5adfc3e7e77 ("perf map: Synthesize maps only for thread group
    leader") changed the recording side so that we no longer get mmap events
    for threads other than the thread group leader (when synthesising these
    events for threads which exist before perf is started).
    
    When a file recorded after this change is loaded, the lack of mmap
    records mean that unwinding is not set up for any other threads.
    
    This can be seen in a simple record/report scenario:
    
            perf record --call-graph=dwarf -t $TID
            perf report
    
    If $TID is a process ID then the report will show call graphs, but if
    $TID is a secondary thread the output is as if --call-graph=none was
    specified.
    
    Following the rationale in that commit, move the libunwind fields into
    struct map_groups and update the libunwind functions to take this
    instead of the struct thread.  This is only required for
    unwind__finish_access which must now be called from map_groups__delete
    and the others are changed for symmetry.
    
    Note that unwind__get_entries keeps the thread argument since it is
    required for symbol lookup and the libdw unwind provider uses the thread
    ID.
    
    Signed-off-by: John Keeping <john@metanate.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Fixes: e5adfc3e7e77 ("perf map: Synthesize maps only for thread group leader")
    Link: http://lkml.kernel.org/r/20190815100146.28842-2-john@metanate.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 44b556812e4b..27b7b102e4a2 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -647,6 +647,7 @@ struct map_groups *map_groups__new(struct machine *machine)
 void map_groups__delete(struct map_groups *mg)
 {
 	map_groups__exit(mg);
+	unwind__finish_access(mg);
 	free(mg);
 }
 
@@ -887,7 +888,7 @@ int map_groups__clone(struct thread *thread, struct map_groups *parent)
 		if (new == NULL)
 			goto out_unlock;
 
-		err = unwind__prepare_access(thread, new, NULL);
+		err = unwind__prepare_access(mg, new, NULL);
 		if (err)
 			goto out_unlock;
 

commit ab6cd0e5276e24403751e0b3b8ed807738a8571f
Author: John Keeping <john@metanate.com>
Date:   Thu Aug 15 11:01:44 2019 +0100

    perf map: Use zalloc for map_groups
    
    In the next commit we will add new fields to map_groups and we need
    these to be null if no value is assigned.  The simplest way to achieve
    this is to request zeroed memory from the allocator.
    
    Signed-off-by: John Keeping <john@metanate.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: john keeping <john@metanate.com>
    Link: http://lkml.kernel.org/r/20190815100146.28842-1-john@metanate.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 668410b1d426..44b556812e4b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -636,7 +636,7 @@ bool map_groups__empty(struct map_groups *mg)
 
 struct map_groups *map_groups__new(struct machine *machine)
 {
-	struct map_groups *mg = malloc(sizeof(*mg));
+	struct map_groups *mg = zalloc(sizeof(*mg));
 
 	if (mg != NULL)
 		map_groups__init(mg, machine);

commit 7f7c536f23e6afaa5d5d4b0e0958b0be8922491f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jul 4 11:32:27 2019 -0300

    tools lib: Adopt zalloc()/zfree() from tools/perf
    
    Eroding a bit more the tools/perf/util/util.h hodpodge header.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-natazosyn9rwjka25tvcnyi0@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 5f87975d2562..668410b1d426 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -12,10 +12,10 @@
 #include "thread.h"
 #include "vdso.h"
 #include "build-id.h"
-#include "util.h"
 #include "debug.h"
 #include "machine.h"
 #include <linux/string.h>
+#include <linux/zalloc.h>
 #include "srcline.h"
 #include "namespaces.h"
 #include "unwind.h"

commit 363bbaef63ffebcc745239fe80a953ebb5ac9ec9
Author: Leo Yan <leo.yan@linaro.org>
Date:   Tue Jul 2 18:34:16 2019 +0800

    perf map: Fix potential NULL pointer dereference found by smatch tool
    
    Based on the following report from Smatch, fix the potential NULL
    pointer dereference check.
    
      tools/perf/util/map.c:479
      map__fprintf_srccode() error: we previously assumed 'state' could be
      null (see line 466)
    
      tools/perf/util/map.c
      465         /* Avoid redundant printing */
      466         if (state &&
      467             state->srcfile &&
      468             !strcmp(state->srcfile, srcfile) &&
      469             state->line == line) {
      470                 free(srcfile);
      471                 return 0;
      472         }
      473
      474         srccode = find_sourceline(srcfile, line, &len);
      475         if (!srccode)
      476                 goto out_free_line;
      477
      478         ret = fprintf(fp, "|%-8d %.*s", line, len, srccode);
      479         state->srcfile = srcfile;
                  ^^^^^^^
      480         state->line = line;
                  ^^^^^^^
    
    This patch validates 'state' pointer before access its elements.
    
    Signed-off-by: Leo Yan <leo.yan@linaro.org>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Alexios Zavras <alexios.zavras@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Changbin Du <changbin.du@intel.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: Suzuki Poulouse <suzuki.poulose@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Richter <tmricht@linux.ibm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Fixes: dd2e18e9ac20 ("perf tools: Support 'srccode' output")
    Link: http://lkml.kernel.org/r/20190702103420.27540-8-leo.yan@linaro.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6fce983c6115..5f87975d2562 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -476,8 +476,11 @@ int map__fprintf_srccode(struct map *map, u64 addr,
 		goto out_free_line;
 
 	ret = fprintf(fp, "|%-8d %.*s", line, len, srccode);
-	state->srcfile = srcfile;
-	state->line = line;
+
+	if (state) {
+		state->srcfile = srcfile;
+		state->line = line;
+	}
 	return ret;
 
 out_free_line:

commit 1c4924220c96392d17e0222c113509fd7b9a0854
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Wed May 8 15:20:05 2019 +0200

    perf script: Pad DSO name for --call-trace
    
    Pad the DSO name in --call-trace so we don't have the indent screwed by
    different DSO name lengths, as now for kernel there's also BPF code
    displayed.
    
      # perf-with-kcore record pt -e intel_pt//ku -- sleep 1
      # perf-core/perf-with-kcore script pt --call-trace
    
    Before:
    
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms])                      kretprobe_perf_func
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms])                          trace_call_bpf
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms])                              __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms])                                  __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464725: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_get_current_pid_tgid
       sleep 3660 [16] 57036.806464725: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_ktime_get_ns
       sleep 3660 [16] 57036.806464725: ([kernel.kallsyms])                                          __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464725: ([kernel.kallsyms])                                              __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806465045: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         __htab_map_lookup_elem
       sleep 3660 [16] 57036.806465366: ([kernel.kallsyms])                                          memcmp
       sleep 3660 [16] 57036.806465687: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_probe_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                          probe_kernel_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                              __check_object_size
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                                  check_stack_object
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                              copy_user_enhanced_fast_string
       sleep 3660 [16] 57036.806465687: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_probe_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                          probe_kernel_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                              __check_object_size
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                                  check_stack_object
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms])                                              copy_user_enhanced_fast_string
       sleep 3660 [16] 57036.806466008: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_get_current_uid_gid
       sleep 3660 [16] 57036.806466008: ([kernel.kallsyms])                                          from_kgid
       sleep 3660 [16] 57036.806466008: ([kernel.kallsyms])                                          from_kuid
       sleep 3660 [16] 57036.806466008: (bpf_prog_da4fe6b3d2c29b25_trace_return)                                         bpf_perf_event_output
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms])                                          perf_event_output
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms])                                              perf_prepare_sample
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms])                                                  perf_misc_flags
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms])                                                      __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms])                                                          __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806466328: ([kvm])                                                      kvm_is_in_guest
       sleep 3660 [16] 57036.806466649: ([kernel.kallsyms])                                                  __perf_event_header__init_id.isra.0
       sleep 3660 [16] 57036.806466649: ([kernel.kallsyms])                                              perf_output_begin
    
    After:
    
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms]                      )     kretprobe_perf_func
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms]                      )         trace_call_bpf
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms]                      )             __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464404: ([kernel.kallsyms]                      )                 __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464725: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_get_current_pid_tgid
       sleep 3660 [16] 57036.806464725: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_ktime_get_ns
       sleep 3660 [16] 57036.806464725: ([kernel.kallsyms]                      )                         __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806464725: ([kernel.kallsyms]                      )                             __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806465045: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     __htab_map_lookup_elem
       sleep 3660 [16] 57036.806465366: ([kernel.kallsyms]                      )                         memcmp
       sleep 3660 [16] 57036.806465687: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_probe_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                         probe_kernel_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                             __check_object_size
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                                 check_stack_object
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                             copy_user_enhanced_fast_string
       sleep 3660 [16] 57036.806465687: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_probe_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                         probe_kernel_read
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                             __check_object_size
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                                 check_stack_object
       sleep 3660 [16] 57036.806465687: ([kernel.kallsyms]                      )                             copy_user_enhanced_fast_string
       sleep 3660 [16] 57036.806466008: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_get_current_uid_gid
       sleep 3660 [16] 57036.806466008: ([kernel.kallsyms]                      )                         from_kgid
       sleep 3660 [16] 57036.806466008: ([kernel.kallsyms]                      )                         from_kuid
       sleep 3660 [16] 57036.806466008: (bpf_prog_da4fe6b3d2c29b25_trace_return )                     bpf_perf_event_output
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms]                      )                         perf_event_output
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms]                      )                             perf_prepare_sample
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms]                      )                                 perf_misc_flags
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms]                      )                                     __x86_indirect_thunk_rax
       sleep 3660 [16] 57036.806466328: ([kernel.kallsyms]                      )                                         __x86_indirect_thunk_rax
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Acked-by: Song Liu <songliubraving@fb.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stanislav Fomichev <sdf@google.com>
    Link: http://lkml.kernel.org/r/20190508132010.14512-8-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ee71efb9db62..6fce983c6115 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -405,6 +405,7 @@ size_t map__fprintf(struct map *map, FILE *fp)
 
 size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 {
+	char buf[symbol_conf.pad_output_len_dso + 1];
 	const char *dsoname = "[unknown]";
 
 	if (map && map->dso) {
@@ -414,6 +415,11 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 			dsoname = map->dso->name;
 	}
 
+	if (symbol_conf.pad_output_len_dso) {
+		scnprintf_pad(buf, symbol_conf.pad_output_len_dso, "%s", dsoname);
+		dsoname = buf;
+	}
+
 	return fprintf(fp, "%s", dsoname);
 }
 

commit b9abbdfa88024d52c8084d8f46ea4f161606c692
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Tue Apr 16 18:01:24 2019 +0200

    perf tools: Fix map reference counting
    
    By calling maps__insert() we assume to get 2 references on the map,
    which we relese within maps__remove call.
    
    However if there's already same map name, we currently don't bump the
    reference and can crash, like:
    
      Program received signal SIGABRT, Aborted.
      0x00007ffff75e60f5 in raise () from /lib64/libc.so.6
    
      (gdb) bt
      #0  0x00007ffff75e60f5 in raise () from /lib64/libc.so.6
      #1  0x00007ffff75d0895 in abort () from /lib64/libc.so.6
      #2  0x00007ffff75d0769 in __assert_fail_base.cold () from /lib64/libc.so.6
      #3  0x00007ffff75de596 in __assert_fail () from /lib64/libc.so.6
      #4  0x00000000004fc006 in refcount_sub_and_test (i=1, r=0x1224e88) at tools/include/linux/refcount.h:131
      #5  refcount_dec_and_test (r=0x1224e88) at tools/include/linux/refcount.h:148
      #6  map__put (map=0x1224df0) at util/map.c:299
      #7  0x00000000004fdb95 in __maps__remove (map=0x1224df0, maps=0xb17d80) at util/map.c:953
      #8  maps__remove (maps=0xb17d80, map=0x1224df0) at util/map.c:959
      #9  0x00000000004f7d8a in map_groups__remove (map=<optimized out>, mg=<optimized out>) at util/map_groups.h:65
      #10 machine__process_ksymbol_unregister (sample=<optimized out>, event=0x7ffff7279670, machine=<optimized out>) at util/machine.c:728
      #11 machine__process_ksymbol (machine=<optimized out>, event=0x7ffff7279670, sample=<optimized out>) at util/machine.c:741
      #12 0x00000000004fffbb in perf_session__deliver_event (session=0xb11390, event=0x7ffff7279670, tool=0x7fffffffc7b0, file_offset=13936) at util/session.c:1362
      #13 0x00000000005039bb in do_flush (show_progress=false, oe=0xb17e80) at util/ordered-events.c:243
      #14 __ordered_events__flush (oe=0xb17e80, how=OE_FLUSH__ROUND, timestamp=<optimized out>) at util/ordered-events.c:322
      #15 0x00000000005005e4 in perf_session__process_user_event (session=session@entry=0xb11390, event=event@entry=0x7ffff72a4af8,
      ...
    
    Add the map to the list and getting the reference event if we find the
    map with same name.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <songliubraving@fb.com>
    Fixes: 1e6285699b30 ("perf symbols: Fix slowness due to -ffunction-section")
    Link: http://lkml.kernel.org/r/20190416160127.30203-10-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 28d484ef74ae..ee71efb9db62 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -926,10 +926,8 @@ static void __maps__insert_name(struct maps *maps, struct map *map)
 		rc = strcmp(m->dso->short_name, map->dso->short_name);
 		if (rc < 0)
 			p = &(*p)->rb_left;
-		else if (rc  > 0)
-			p = &(*p)->rb_right;
 		else
-			return;
+			p = &(*p)->rb_right;
 	}
 	rb_link_node(&map->rb_node_name, parent, p);
 	rb_insert_color(&map->rb_node_name, &maps->names);

commit a93e0b2365e81e5a5b61f25e269b5dc73d242cba
Author: Song Liu <songliubraving@fb.com>
Date:   Tue Apr 16 18:01:22 2019 +0200

    perf tools: Check maps for bpf programs
    
    As reported by Jiri Olsa in:
    
      "[BUG] perf: intel_pt won't display kernel function"
      https://lore.kernel.org/lkml/20190403143738.GB32001@krava
    
    Recent changes to support PERF_RECORD_KSYMBOL and PERF_RECORD_BPF_EVENT
    broke --kallsyms option. This is because it broke test __map__is_kmodule.
    
    This patch fixes this by adding check for bpf program, so that these maps
    are not mistaken as kernel modules.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reported-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Andrii Nakryiko <andrii.nakryiko@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Martin KaFai Lau <kafai@fb.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yonghong Song <yhs@fb.com>
    Link: http://lkml.kernel.org/r/20190416160127.30203-8-jolsa@kernel.org
    Fixes: 76193a94522f ("perf, bpf: Introduce PERF_RECORD_KSYMBOL")
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index e32628cd20a7..28d484ef74ae 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -261,6 +261,22 @@ bool __map__is_extra_kernel_map(const struct map *map)
 	return kmap && kmap->name[0];
 }
 
+bool __map__is_bpf_prog(const struct map *map)
+{
+	const char *name;
+
+	if (map->dso->binary_type == DSO_BINARY_TYPE__BPF_PROG_INFO)
+		return true;
+
+	/*
+	 * If PERF_RECORD_BPF_EVENT is not included, the dso will not have
+	 * type of DSO_BINARY_TYPE__BPF_PROG_INFO. In such cases, we can
+	 * guess the type based on name.
+	 */
+	name = map->dso->short_name;
+	return name && (strstr(name, "bpf_prog_") == name);
+}
+
 bool map__has_symbols(const struct map *map)
 {
 	return dso__has_symbols(map->dso);

commit da3a53a7390a89391bd63bead0c2e9af4c5ef3d6
Author: Changbin Du <changbin.du@gmail.com>
Date:   Sat Mar 16 16:05:51 2019 +0800

    perf maps: Purge all maps from the 'names' tree
    
    Add function __maps__purge_names() to purge all maps from the names
    tree.  We need to cleanup the names tree in maps__exit().
    
    Detected with gcc's ASan.
    
    Signed-off-by: Changbin Du <changbin.du@gmail.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Fixes: 1e6285699b30 ("perf symbols: Fix slowness due to -ffunction-section")
    Link: http://lkml.kernel.org/r/20190316080556.3075-12-changbin.du@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 64bea5eb8bf6..e32628cd20a7 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -577,10 +577,25 @@ static void __maps__purge(struct maps *maps)
 	}
 }
 
+static void __maps__purge_names(struct maps *maps)
+{
+	struct rb_root *root = &maps->names;
+	struct rb_node *next = rb_first(root);
+
+	while (next) {
+		struct map *pos = rb_entry(next, struct map, rb_node_name);
+
+		next = rb_next(&pos->rb_node_name);
+		rb_erase_init(&pos->rb_node_name, root);
+		map__put(pos);
+	}
+}
+
 static void maps__exit(struct maps *maps)
 {
 	down_write(&maps->lock);
 	__maps__purge(maps);
+	__maps__purge_names(maps);
 	up_write(&maps->lock);
 }
 

commit b49265e04410b97b31a5ee66ef6782c1b2d6cd2c
Author: Changbin Du <changbin.du@gmail.com>
Date:   Sat Mar 16 16:05:50 2019 +0800

    perf map: Remove map from 'names' tree in __maps__remove()
    
    There are two trees for each map inserted by maps__insert(), so remove
    it from the 'names' tree in __maps__remove().
    
    Detected with gcc's ASan.
    
    Signed-off-by: Changbin Du <changbin.du@gmail.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Fixes: 1e6285699b30 ("perf symbols: Fix slowness due to -ffunction-section")
    Link: http://lkml.kernel.org/r/20190316080556.3075-11-changbin.du@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index fbeb0c6efaa6..64bea5eb8bf6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -917,6 +917,9 @@ static void __maps__remove(struct maps *maps, struct map *map)
 {
 	rb_erase_init(&map->rb_node, &maps->entries);
 	map__put(map);
+
+	rb_erase_init(&map->rb_node_name, &maps->names);
+	map__put(map);
 }
 
 void maps__remove(struct maps *maps, struct map *map)

commit 41f30914fc33116cfd0fd0982c8effe435d97698
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Jan 27 13:44:29 2019 +0100

    perf map: Move structs and prototypes for map groups to a separate header
    
    And since machine.h only needs what is in there, make it stop including
    map.h and instead include this newly introduced map_groups.h instead.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-dbob25fv5rp2rjpwlnterf38@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index cf407cc9d915..fbeb0c6efaa6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -557,6 +557,12 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 	refcount_set(&mg->refcnt, 1);
 }
 
+void map_groups__insert(struct map_groups *mg, struct map *map)
+{
+	maps__insert(&mg->maps, map);
+	map->groups = mg;
+}
+
 static void __maps__purge(struct maps *maps)
 {
 	struct rb_root *root = &maps->entries;

commit 7137ff50b68a48bc28270c91b1c313259ab0c1c4
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Thu Dec 6 11:18:17 2018 -0800

    perf symbols: Use cached rbtrees
    
    At the cost of an extra pointer, we can avoid the O(logN) cost of
    finding the first element in the tree (smallest node).
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20181206191819.30182-6-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6751301a755c..cf407cc9d915 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -286,8 +286,8 @@ void map__put(struct map *map)
 
 void map__fixup_start(struct map *map)
 {
-	struct rb_root *symbols = &map->dso->symbols;
-	struct rb_node *nd = rb_first(symbols);
+	struct rb_root_cached *symbols = &map->dso->symbols;
+	struct rb_node *nd = rb_first_cached(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
 		map->start = sym->start;
@@ -296,8 +296,8 @@ void map__fixup_start(struct map *map)
 
 void map__fixup_end(struct map *map)
 {
-	struct rb_root *symbols = &map->dso->symbols;
-	struct rb_node *nd = rb_last(symbols);
+	struct rb_root_cached *symbols = &map->dso->symbols;
+	struct rb_node *nd = rb_last(&symbols->rb_root);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
 		map->end = sym->end;

commit dd2e18e9ac20e3ffc27cabf318e83b43ed5ddb92
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Dec 3 16:18:48 2018 -0800

    perf tools: Support 'srccode' output
    
    When looking at PT or brstackinsn traces with 'perf script' it can be
    very useful to see the source code. This adds a simple facility to print
    them with 'perf script', if the information is available through dwarf
    
      % perf record ...
      % perf script -F insn,ip,sym,srccode
      ...
    
                4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004b3 main
      6                       v++;
    
      % perf record -b ...
      % perf script -F insn,ip,sym,srccode,brstackinsn
    
      ...
             main+22:
              0000000000400543        insn: e8 ca ff ff ff            # PRED
      |18                     f1();
              f1:
              0000000000400512        insn: 55
      |10       {
              0000000000400513        insn: 48 89 e5
              0000000000400516        insn: b8 00 00 00 00
      |11             f2();
              000000000040051b        insn: e8 d6 ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
              0000000000400500        insn: 8b 0d 2a 0b 20 00
              0000000000400506        insn: 99
              0000000000400507        insn: f7 f9
              0000000000400509        insn: 89 05 29 0b 20 00
              000000000040050f        insn: 90
      |7        }
              0000000000400510        insn: 5d
              0000000000400511        insn: c3                        # PRED
              f1+14:
              0000000000400520        insn: b8 00 00 00 00
      |12             f2();
              0000000000400525        insn: e8 cc ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
    
    Not supported for callchains currently, would need some layout changes
    there.
    
    Committer notes:
    
    Fixed the build on Alpine Linux (3.4 .. 3.8) by addressing this
    warning:
    
      In file included from util/srccode.c:19:0:
      /usr/include/sys/fcntl.h:1:2: error: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Werror=cpp]
       #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
        ^~~~~~~
      cc1: all warnings being treated as errors
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Tested-by: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/20181204001848.24769-1-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a0d58b4d9c32..6751301a755c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -19,6 +19,7 @@
 #include "srcline.h"
 #include "namespaces.h"
 #include "unwind.h"
+#include "srccode.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
 static void __maps__insert_name(struct maps *maps, struct map *map);
@@ -421,6 +422,54 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 	return ret;
 }
 
+int map__fprintf_srccode(struct map *map, u64 addr,
+			 FILE *fp,
+			 struct srccode_state *state)
+{
+	char *srcfile;
+	int ret = 0;
+	unsigned line;
+	int len;
+	char *srccode;
+
+	if (!map || !map->dso)
+		return 0;
+	srcfile = get_srcline_split(map->dso,
+				    map__rip_2objdump(map, addr),
+				    &line);
+	if (!srcfile)
+		return 0;
+
+	/* Avoid redundant printing */
+	if (state &&
+	    state->srcfile &&
+	    !strcmp(state->srcfile, srcfile) &&
+	    state->line == line) {
+		free(srcfile);
+		return 0;
+	}
+
+	srccode = find_sourceline(srcfile, line, &len);
+	if (!srccode)
+		goto out_free_line;
+
+	ret = fprintf(fp, "|%-8d %.*s", line, len, srccode);
+	state->srcfile = srcfile;
+	state->line = line;
+	return ret;
+
+out_free_line:
+	free(srcfile);
+	return ret;
+}
+
+
+void srccode_state_free(struct srccode_state *state)
+{
+	zfree(&state->srcfile);
+	state->line = 0;
+}
+
 /**
  * map__rip_2objdump - convert symbol start address to objdump address.
  * @map: memory map

commit b18e088825883bcb8dc4c4a641494049cf8ccec3
Author: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
Date:   Fri Nov 23 02:42:39 2018 -0800

    perf map: Remove extra indirection from map__find()
    
    A double pointer is used in map__find() where a single pointer is enough
    because the function doesn't affect the rbtree and the rbtree is locked.
    
    Signed-off-by: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Eric Saint-Etienne <eric.saintetienne@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1542969759-24346-1-git-send-email-eric.saint.etienne@oracle.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 781eed8e3265..a0d58b4d9c32 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -873,19 +873,18 @@ void maps__remove(struct maps *maps, struct map *map)
 
 struct map *maps__find(struct maps *maps, u64 ip)
 {
-	struct rb_node **p, *parent = NULL;
+	struct rb_node *p;
 	struct map *m;
 
 	down_read(&maps->lock);
 
-	p = &maps->entries.rb_node;
-	while (*p != NULL) {
-		parent = *p;
-		m = rb_entry(parent, struct map, rb_node);
+	p = maps->entries.rb_node;
+	while (p != NULL) {
+		m = rb_entry(p, struct map, rb_node);
 		if (ip < m->start)
-			p = &(*p)->rb_left;
+			p = p->rb_left;
 		else if (ip >= m->end)
-			p = &(*p)->rb_right;
+			p = p->rb_right;
 		else
 			goto out;
 	}

commit 1e6285699b3034e6f4d1f091edd46d717580bf7c
Author: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
Date:   Wed Nov 21 09:51:19 2018 -0800

    perf symbols: Fix slowness due to -ffunction-section
    
    Perf can take minutes to parse an image when -ffunction-section is used.
    This is especially true with the kernel image when it is compiled this
    way, which is the arm64 default since the patcheset "Enable deadcode
    elimination at link time".
    
    Perf organize maps using a rbtree. Whenever perf finds a new symbols, it
    first searches this rbtree for the map it belongs to, by strcmp()'aring
    section names.  When it finds the map with the right name, it uses it to
    add the symbol. With a usual image there aren't so many maps but when
    using -ffunction-section there's basically one map per function.  With
    the kernel image that's north of 40,000 maps. For most symbols perf has
    to parses the entire rbtree to eventually create a new map and add it.
    Consequently perf spends most of the time browsing a rbtree that keeps
    getting larger.
    
    This performance fix introduces a secondary rbtree that indexes maps
    based on the section name.
    
    Signed-off-by: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Reviewed-by: Dave Kleikamp <dave.kleikamp@oracle.com>
    Reviewed-by: David Aldridge <david.aldridge@oracle.com>
    Reviewed-by: Rob Gardner <rob.gardner@oracle.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1542822679-25591-1-git-send-email-eric.saint.etienne@oracle.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 354e54550d2b..781eed8e3265 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -21,6 +21,7 @@
 #include "unwind.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
+static void __maps__insert_name(struct maps *maps, struct map *map);
 
 static inline int is_anon_memory(const char *filename, u32 flags)
 {
@@ -496,6 +497,7 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 static void maps__init(struct maps *maps)
 {
 	maps->entries = RB_ROOT;
+	maps->names = RB_ROOT;
 	init_rwsem(&maps->lock);
 }
 
@@ -664,6 +666,7 @@ size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 static void __map_groups__insert(struct map_groups *mg, struct map *map)
 {
 	__maps__insert(&mg->maps, map);
+	__maps__insert_name(&mg->maps, map);
 	map->groups = mg;
 }
 
@@ -824,10 +827,34 @@ static void __maps__insert(struct maps *maps, struct map *map)
 	map__get(map);
 }
 
+static void __maps__insert_name(struct maps *maps, struct map *map)
+{
+	struct rb_node **p = &maps->names.rb_node;
+	struct rb_node *parent = NULL;
+	struct map *m;
+	int rc;
+
+	while (*p != NULL) {
+		parent = *p;
+		m = rb_entry(parent, struct map, rb_node_name);
+		rc = strcmp(m->dso->short_name, map->dso->short_name);
+		if (rc < 0)
+			p = &(*p)->rb_left;
+		else if (rc  > 0)
+			p = &(*p)->rb_right;
+		else
+			return;
+	}
+	rb_link_node(&map->rb_node_name, parent, p);
+	rb_insert_color(&map->rb_node_name, &maps->names);
+	map__get(map);
+}
+
 void maps__insert(struct maps *maps, struct map *map)
 {
 	down_write(&maps->lock);
 	__maps__insert(maps, map);
+	__maps__insert_name(maps, map);
 	up_write(&maps->lock);
 }
 

commit fb437bc8fe36c964d9bf2f4b568e6c77c235c5e3
Merge: 49e73246cbe6 6bf4ca7fbc85
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Sep 25 11:19:44 2018 +0200

    Merge tag 'v4.19-rc5' into perf/core, to pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 03db8b583d1c3c84963e08e2abf6c79081da5c31
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 7 11:51:16 2018 +0300

    perf tools: Fix maps__find_symbol_by_name()
    
    Commit 1c5aae7710bb ("perf machine: Create maps for x86 PTI entry
    trampolines") revealed a problem with maps__find_symbol_by_name() that
    resulted in probes not being found e.g.
    
            $ sudo perf probe xsk_mmap
            xsk_mmap is out of .text, skip it.
            Probe point 'xsk_mmap' not found.
               Error: Failed to add events.
    
    maps__find_symbol_by_name() can optionally return the map of the found
    symbol. It can get the map wrong because, in fact, the symbol is found
    on the map's dso, not allowing for the possibility that the dso has more
    than one map. Fix by always checking the map contains the symbol.
    
    Reported-by: Bjrn Tpel <bjorn.topel@intel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Bjrn Tpel <bjorn.topel@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: stable@vger.kernel.org
    Fixes: 1c5aae7710bb ("perf machine: Create maps for x86 PTI entry trampolines")
    Link: http://lkml.kernel.org/r/20180907085116.25782-1-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 36d0763311ef..6a6929f208b4 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -576,6 +576,13 @@ struct symbol *map_groups__find_symbol(struct map_groups *mg,
 	return NULL;
 }
 
+static bool map__contains_symbol(struct map *map, struct symbol *sym)
+{
+	u64 ip = map->unmap_ip(map, sym->start);
+
+	return ip >= map->start && ip < map->end;
+}
+
 struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 					 struct map **mapp)
 {
@@ -591,6 +598,10 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 
 		if (sym == NULL)
 			continue;
+		if (!map__contains_symbol(pos, sym)) {
+			sym = NULL;
+			continue;
+		}
 		if (mapp != NULL)
 			*mapp = pos;
 		goto out;

commit d8e75a110df7e3318990c9fb207ae0aa7812895a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Sep 4 10:43:07 2018 -0300

    perf map: Turn some pr_warning() to pr_debug()
    
    Annoying when using it with --stdio/--stdio2, so just turn them debug,
    we can get those using -v.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-t3684lkugnf1w4lwcmpj9ivm@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 36d0763311ef..3f07a587c8e6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -320,12 +320,11 @@ int map__load(struct map *map)
 			build_id__sprintf(map->dso->build_id,
 					  sizeof(map->dso->build_id),
 					  sbuild_id);
-			pr_warning("%s with build id %s not found",
-				   name, sbuild_id);
+			pr_debug("%s with build id %s not found", name, sbuild_id);
 		} else
-			pr_warning("Failed to open %s", name);
+			pr_debug("Failed to open %s", name);
 
-		pr_warning(", continuing without symbols\n");
+		pr_debug(", continuing without symbols\n");
 		return -1;
 	} else if (nr == 0) {
 #ifdef HAVE_LIBELF_SUPPORT
@@ -334,12 +333,11 @@ int map__load(struct map *map)
 
 		if (len > sizeof(DSO__DELETED) &&
 		    strcmp(name + real_len + 1, DSO__DELETED) == 0) {
-			pr_warning("%.*s was updated (is prelink enabled?). "
+			pr_debug("%.*s was updated (is prelink enabled?). "
 				"Restart the long running apps that use it!\n",
 				   (int)real_len, name);
 		} else {
-			pr_warning("no symbols found in %s, maybe install "
-				   "a debug package?\n", name);
+			pr_debug("no symbols found in %s, maybe install a debug package?\n", name);
 		}
 #endif
 		return -1;
@@ -701,8 +699,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 		if (verbose >= 2) {
 
 			if (use_browser) {
-				pr_warning("overlapping maps in %s "
-					   "(disable tui for more info)\n",
+				pr_debug("overlapping maps in %s (disable tui for more info)\n",
 					   map->dso->name);
 			} else {
 				fputs("overlapping maps:\n", fp);

commit 6a9405b56c274024564f9014bba97b92c91b34d6
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Tue Aug 7 17:24:54 2018 +0300

    perf map: Optimize maps__fixup_overlappings()
    
    This function splits and removes overlapping areas.
    
    Maps in tree are ordered by start address thus we could find first
    overlap and stop if next map does not overlap.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/153365189407.435244.7234821822450484712.stgit@buzz
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 89ac5b5dc218..36d0763311ef 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -381,20 +381,6 @@ struct map *map__clone(struct map *from)
 	return map;
 }
 
-int map__overlap(struct map *l, struct map *r)
-{
-	if (l->start > r->start) {
-		struct map *t = l;
-		l = r;
-		r = t;
-	}
-
-	if (l->end > r->start)
-		return 1;
-
-	return 0;
-}
-
 size_t map__fprintf(struct map *map, FILE *fp)
 {
 	return fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",
@@ -675,20 +661,42 @@ static void __map_groups__insert(struct map_groups *mg, struct map *map)
 static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
 {
 	struct rb_root *root;
-	struct rb_node *next;
+	struct rb_node *next, *first;
 	int err = 0;
 
 	down_write(&maps->lock);
 
 	root = &maps->entries;
-	next = rb_first(root);
 
+	/*
+	 * Find first map where end > map->start.
+	 * Same as find_vma() in kernel.
+	 */
+	next = root->rb_node;
+	first = NULL;
+	while (next) {
+		struct map *pos = rb_entry(next, struct map, rb_node);
+
+		if (pos->end > map->start) {
+			first = next;
+			if (pos->start <= map->start)
+				break;
+			next = next->rb_left;
+		} else
+			next = next->rb_right;
+	}
+
+	next = first;
 	while (next) {
 		struct map *pos = rb_entry(next, struct map, rb_node);
 		next = rb_next(&pos->rb_node);
 
-		if (!map__overlap(pos, map))
-			continue;
+		/*
+		 * Stop if current map starts after map->end.
+		 * Maps are ordered by start: next will not overlap for sure.
+		 */
+		if (pos->start >= map->end)
+			break;
 
 		if (verbose >= 2) {
 

commit 97802f3b81dc0d1da0f89c498249547d73a01164
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jun 5 10:30:00 2018 +0300

    perf map: Consider PTI entry trampolines in rip_2objdump()
    
    perf tools uses map__rip_2objdump() to calculate objdump virtual addresses.
    map__rip_2objdump() needs to be amended to deal with PTI entry trampolines.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lkml.kernel.org/r/1528183800-21577-1-git-send-email-adrian.hunter@intel.com
    [ split from a larger patch ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 92abc8e248c5..89ac5b5dc218 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -449,6 +449,20 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
  */
 u64 map__rip_2objdump(struct map *map, u64 rip)
 {
+	struct kmap *kmap = __map__kmap(map);
+
+	/*
+	 * vmlinux does not have program headers for PTI entry trampolines and
+	 * kcore may not either. However the trampoline object code is on the
+	 * main kernel map, so just use that instead.
+	 */
+	if (kmap && is_entry_trampoline(kmap->name) && kmap->kmaps && kmap->kmaps->machine) {
+		struct map *kernel_map = machine__kernel_map(kmap->kmaps->machine);
+
+		if (kernel_map)
+			map = kernel_map;
+	}
+
 	if (!map->dso->adjust_symbols)
 		return rip;
 

commit e2d88aaa649e65851463426b133d87b61d3accbd
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon May 28 11:05:20 2018 -0300

    perf srcline: Introduce map__srcline() to make code more compact
    
    Replacing a common open coded sequence.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-2d7d1nzd3ksqornloqeer99r@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6ae97eda370b..92abc8e248c5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -415,16 +415,20 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 	return fprintf(fp, "%s", dsoname);
 }
 
+char *map__srcline(struct map *map, u64 addr, struct symbol *sym)
+{
+	if (map == NULL)
+		return SRCLINE_UNKNOWN;
+	return get_srcline(map->dso, map__rip_2objdump(map, addr), sym, true, true, addr);
+}
+
 int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 			 FILE *fp)
 {
-	char *srcline;
 	int ret = 0;
 
 	if (map && map->dso) {
-		srcline = get_srcline(map->dso,
-				      map__rip_2objdump(map, addr), NULL,
-				      true, true, addr);
+		char *srcline = map__srcline(map, addr, NULL);
 		if (srcline != SRCLINE_UNKNOWN)
 			ret = fprintf(fp, "%s%s", prefix, srcline);
 		free_srcline(srcline);

commit 5759a6820aadd38b2c8c10e93919eae8e31a9f9a
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue May 22 13:54:35 2018 +0300

    perf machine: Allow for extra kernel maps
    
    Identify extra kernel maps by name so that they can be distinguished
    from the kernel map and module maps.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86@kernel.org
    Link: http://lkml.kernel.org/r/1526986485-6562-8-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c8fe836e4c3c..6ae97eda370b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -252,6 +252,13 @@ bool __map__is_kernel(const struct map *map)
 	return machine__kernel_map(map->groups->machine) == map;
 }
 
+bool __map__is_extra_kernel_map(const struct map *map)
+{
+	struct kmap *kmap = __map__kmap((struct map *)map);
+
+	return kmap && kmap->name[0];
+}
+
 bool map__has_symbols(const struct map *map)
 {
 	return dso__has_symbols(map->dso);
@@ -846,15 +853,22 @@ struct map *map__next(struct map *map)
 	return NULL;
 }
 
-struct kmap *map__kmap(struct map *map)
+struct kmap *__map__kmap(struct map *map)
 {
-	if (!map->dso || !map->dso->kernel) {
-		pr_err("Internal error: map__kmap with a non-kernel map\n");
+	if (!map->dso || !map->dso->kernel)
 		return NULL;
-	}
 	return (struct kmap *)(map + 1);
 }
 
+struct kmap *map__kmap(struct map *map)
+{
+	struct kmap *kmap = __map__kmap(map);
+
+	if (!kmap)
+		pr_err("Internal error: map__kmap with a non-kernel map\n");
+	return kmap;
+}
+
 struct map_groups *map__kmaps(struct map *map)
 {
 	struct kmap *kmap = map__kmap(map);

commit 3183f8ca304fd84096c44332f9bb699943beb6f1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 26 16:52:34 2018 -0300

    perf symbols: Unify symbol maps
    
    Remove the split of symbol tables for data (MAP__VARIABLE) and for
    functions (MAP__FUNCTION), its unneeded and there were various places
    doing two lookups to find a symbol, so simplify this.
    
    We still will consider only the symbols that matched the filters in
    place, i.e. see the (elf_(sec,sym)|symbol_type)__filter() routines in
    the patch, just so that we consider only the same symbols as before,
    to reduce the possibility of regressions.
    
    All the tests on 50-something build environments, in varios versions
    of lots of distros and cross build environments were performed without
    build regressions, as usual with all pull requests the other tests were
    also performed: 'perf test' and 'make -C tools/perf build-test'.
    
    Also this was done at a great granularity so that regressions can be
    bisected more easily.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-hiq0fy2rsleupnqqwuojo1ne@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a164e1ed5462..c8fe836e4c3c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -22,11 +22,6 @@
 
 static void __maps__insert(struct maps *maps, struct map *map);
 
-const char *map_type__name[MAP__NR_TYPES] = {
-	[MAP__FUNCTION] = "Functions",
-	[MAP__VARIABLE] = "Variables",
-};
-
 static inline int is_anon_memory(const char *filename, u32 flags)
 {
 	return flags & MAP_HUGETLB ||
@@ -129,10 +124,8 @@ static inline bool replace_android_lib(const char *filename, char *newfilename)
 	return false;
 }
 
-void map__init(struct map *map, enum map_type type,
-	       u64 start, u64 end, u64 pgoff, struct dso *dso)
+void map__init(struct map *map, u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
-	map->type     = type;
 	map->start    = start;
 	map->end      = end;
 	map->pgoff    = pgoff;
@@ -149,7 +142,7 @@ void map__init(struct map *map, enum map_type type,
 struct map *map__new(struct machine *machine, u64 start, u64 len,
 		     u64 pgoff, u32 d_maj, u32 d_min, u64 ino,
 		     u64 ino_gen, u32 prot, u32 flags, char *filename,
-		     enum map_type type, struct thread *thread)
+		     struct thread *thread)
 {
 	struct map *map = malloc(sizeof(*map));
 	struct nsinfo *nsi = NULL;
@@ -203,7 +196,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		if (dso == NULL)
 			goto out_delete;
 
-		map__init(map, type, start, start + len, pgoff, dso);
+		map__init(map, start, start + len, pgoff, dso);
 
 		if (anon || no_dso) {
 			map->map_ip = map->unmap_ip = identity__map_ip;
@@ -214,7 +207,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			 * unnecessary map__load warning.
 			 */
 			if (!(prot & PROT_EXEC))
-				dso__set_loaded(dso, map->type);
+				dso__set_loaded(dso);
 		}
 		dso->nsinfo = nsi;
 		dso__put(dso);
@@ -231,7 +224,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
  * they are loaded) and for vmlinux, where only after we load all the
  * symbols we'll know where it starts and ends.
  */
-struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
+struct map *map__new2(u64 start, struct dso *dso)
 {
 	struct map *map = calloc(1, (sizeof(*map) +
 				     (dso->kernel ? sizeof(struct kmap) : 0)));
@@ -239,7 +232,7 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
 		/*
 		 * ->end will be filled after we load all the symbols
 		 */
-		map__init(map, type, start, 0, 0, dso);
+		map__init(map, start, 0, 0, dso);
 	}
 
 	return map;
@@ -256,12 +249,12 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
  */
 bool __map__is_kernel(const struct map *map)
 {
-	return __machine__kernel_map(map->groups->machine, map->type) == map;
+	return machine__kernel_map(map->groups->machine) == map;
 }
 
 bool map__has_symbols(const struct map *map)
 {
-	return dso__has_symbols(map->dso, map->type);
+	return dso__has_symbols(map->dso);
 }
 
 static void map__exit(struct map *map)
@@ -284,7 +277,7 @@ void map__put(struct map *map)
 
 void map__fixup_start(struct map *map)
 {
-	struct rb_root *symbols = &map->dso->symbols[map->type];
+	struct rb_root *symbols = &map->dso->symbols;
 	struct rb_node *nd = rb_first(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
@@ -294,7 +287,7 @@ void map__fixup_start(struct map *map)
 
 void map__fixup_end(struct map *map)
 {
-	struct rb_root *symbols = &map->dso->symbols[map->type];
+	struct rb_root *symbols = &map->dso->symbols;
 	struct rb_node *nd = rb_last(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
@@ -309,7 +302,7 @@ int map__load(struct map *map)
 	const char *name = map->dso->long_name;
 	int nr;
 
-	if (dso__loaded(map->dso, map->type))
+	if (dso__loaded(map->dso))
 		return 0;
 
 	nr = dso__load(map->dso, map);
@@ -353,7 +346,7 @@ struct symbol *map__find_symbol(struct map *map, u64 addr)
 	if (map__load(map) < 0)
 		return NULL;
 
-	return __dso__find_symbol(map->dso, map->type, addr);
+	return dso__find_symbol(map->dso, addr);
 }
 
 struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
@@ -361,10 +354,10 @@ struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
 	if (map__load(map) < 0)
 		return NULL;
 
-	if (!dso__sorted_by_name(map->dso, map->type))
-		dso__sort_by_name(map->dso, map->type);
+	if (!dso__sorted_by_name(map->dso))
+		dso__sort_by_name(map->dso);
 
-	return __dso__find_symbol_by_name(map->dso, map->type, name);
+	return dso__find_symbol_by_name(map->dso, name);
 }
 
 struct map *map__clone(struct map *from)
@@ -499,10 +492,7 @@ static void maps__init(struct maps *maps)
 
 void map_groups__init(struct map_groups *mg, struct machine *machine)
 {
-	int i;
-	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		maps__init(&mg->maps[i]);
-	}
+	maps__init(&mg->maps);
 	mg->machine = machine;
 	refcount_set(&mg->refcnt, 1);
 }
@@ -530,22 +520,12 @@ static void maps__exit(struct maps *maps)
 
 void map_groups__exit(struct map_groups *mg)
 {
-	int i;
-
-	for (i = 0; i < MAP__NR_TYPES; ++i)
-		maps__exit(&mg->maps[i]);
+	maps__exit(&mg->maps);
 }
 
 bool map_groups__empty(struct map_groups *mg)
 {
-	int i;
-
-	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		if (maps__first(&mg->maps[i]))
-			return false;
-	}
-
-	return true;
+	return !maps__first(&mg->maps);
 }
 
 struct map_groups *map_groups__new(struct machine *machine)
@@ -571,10 +551,9 @@ void map_groups__put(struct map_groups *mg)
 }
 
 struct symbol *map_groups__find_symbol(struct map_groups *mg,
-				       enum map_type type, u64 addr,
-				       struct map **mapp)
+				       u64 addr, struct map **mapp)
 {
-	struct map *map = __map_groups__find(mg, type, addr);
+	struct map *map = map_groups__find(mg, addr);
 
 	/* Ensure map is loaded before using map->map_ip */
 	if (map != NULL && map__load(map) >= 0) {
@@ -613,13 +592,10 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 }
 
 struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
-					       enum map_type type,
 					       const char *name,
 					       struct map **mapp)
 {
-	struct symbol *sym = maps__find_symbol_by_name(&mg->maps[type], name, mapp);
-
-	return sym;
+	return maps__find_symbol_by_name(&mg->maps, name, mapp);
 }
 
 int map_groups__find_ams(struct addr_map_symbol *ams)
@@ -627,7 +603,7 @@ int map_groups__find_ams(struct addr_map_symbol *ams)
 	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
 		if (ams->map->groups == NULL)
 			return -1;
-		ams->map = __map_groups__find(ams->map->groups, ams->map->type, ams->addr);
+		ams->map = map_groups__find(ams->map->groups, ams->addr);
 		if (ams->map == NULL)
 			return -1;
 	}
@@ -650,7 +626,7 @@ static size_t maps__fprintf(struct maps *maps, FILE *fp)
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
 		if (verbose > 2) {
-			printed += dso__fprintf(pos->dso, pos->type, fp);
+			printed += dso__fprintf(pos->dso, fp);
 			printed += fprintf(fp, "--\n");
 		}
 	}
@@ -660,24 +636,14 @@ static size_t maps__fprintf(struct maps *maps, FILE *fp)
 	return printed;
 }
 
-size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
-				  FILE *fp)
-{
-	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
-	return printed += maps__fprintf(&mg->maps[type], fp);
-}
-
 size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 {
-	size_t printed = 0, i;
-	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_maps(mg, i, fp);
-	return printed;
+	return maps__fprintf(&mg->maps, fp);
 }
 
 static void __map_groups__insert(struct map_groups *mg, struct map *map)
 {
-	__maps__insert(&mg->maps[map->type], map);
+	__maps__insert(&mg->maps, map);
 	map->groups = mg;
 }
 
@@ -762,19 +728,18 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 				   FILE *fp)
 {
-	return maps__fixup_overlappings(&mg->maps[map->type], map, fp);
+	return maps__fixup_overlappings(&mg->maps, map, fp);
 }
 
 /*
  * XXX This should not really _copy_ te maps, but refcount them.
  */
-int map_groups__clone(struct thread *thread,
-		      struct map_groups *parent, enum map_type type)
+int map_groups__clone(struct thread *thread, struct map_groups *parent)
 {
 	struct map_groups *mg = thread->mg;
 	int err = -ENOMEM;
 	struct map *map;
-	struct maps *maps = &parent->maps[type];
+	struct maps *maps = &parent->maps;
 
 	down_read(&maps->lock);
 

commit d183b2614fcd6d0a10c792891fd09bb254594ad4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 26 16:08:38 2018 -0300

    perf map: Use map->prot in place of type==MAP__FUNCTION
    
    Equivalent, one step more in ditching enum map_type.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-mrjjc87a4tpf896j5u4sql4e@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ab12f2bc7669..a164e1ed5462 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -173,7 +173,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		map->flags = flags;
 		nsi = nsinfo__get(thread->nsinfo);
 
-		if ((anon || no_dso) && nsi && type == MAP__FUNCTION) {
+		if ((anon || no_dso) && nsi && (prot & PROT_EXEC)) {
 			snprintf(newfilename, sizeof(newfilename),
 				 "/tmp/perf-%d.map", nsi->pid);
 			filename = newfilename;
@@ -213,7 +213,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			 * functions still return NULL, and we avoid the
 			 * unnecessary map__load warning.
 			 */
-			if (type != MAP__FUNCTION)
+			if (!(prot & PROT_EXEC))
 				dso__set_loaded(dso, map->type);
 		}
 		dso->nsinfo = nsi;

commit af07eeb04ca9c992b67a59aa8bc10118b610d518
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 17:46:28 2018 -0300

    perf symbols: Remove map_type arg from dso__find_symbol()
    
    One more step to ditch MAP__{VARIABLE,FUNCTION}
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-919d1k13ts62pjipnpibvgwd@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 91e2afb010f8..ab12f2bc7669 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -353,7 +353,7 @@ struct symbol *map__find_symbol(struct map *map, u64 addr)
 	if (map__load(map) < 0)
 		return NULL;
 
-	return dso__find_symbol(map->dso, map->type, addr);
+	return __dso__find_symbol(map->dso, map->type, addr);
 }
 
 struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
@@ -364,7 +364,7 @@ struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
 	if (!dso__sorted_by_name(map->dso, map->type))
 		dso__sort_by_name(map->dso, map->type);
 
-	return dso__find_symbol_by_name(map->dso, map->type, name);
+	return __dso__find_symbol_by_name(map->dso, map->type, name);
 }
 
 struct map *map__clone(struct map *from)

commit abe5449d2de6ccc58444451b6fed130100892097
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 12:39:22 2018 -0300

    perf map: Shorten map_groups__find() signature
    
    Removing the map_type, that is going away.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-18iiiw25r75xn7zlppjldk48@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index f553e302bf9c..91e2afb010f8 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -574,7 +574,7 @@ struct symbol *map_groups__find_symbol(struct map_groups *mg,
 				       enum map_type type, u64 addr,
 				       struct map **mapp)
 {
-	struct map *map = map_groups__find(mg, type, addr);
+	struct map *map = __map_groups__find(mg, type, addr);
 
 	/* Ensure map is loaded before using map->map_ip */
 	if (map != NULL && map__load(map) >= 0) {
@@ -627,8 +627,7 @@ int map_groups__find_ams(struct addr_map_symbol *ams)
 	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
 		if (ams->map->groups == NULL)
 			return -1;
-		ams->map = map_groups__find(ams->map->groups, ams->map->type,
-					    ams->addr);
+		ams->map = __map_groups__find(ams->map->groups, ams->map->type, ams->addr);
 		if (ams->map == NULL)
 			return -1;
 	}

commit e94b861a231501e73d786970ed5a1fb3ea643906
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 23 17:13:49 2018 -0300

    perf map: Introduce map__has_symbols()
    
    To further simplify checking if symbols are available for a given map
    and to reduce the number of users of MAP__{FUNCTION,VARIABLE}.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-iyfoyvbfdti5uehgpjum3qrq@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 8fe57031e1a8..f553e302bf9c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -259,6 +259,11 @@ bool __map__is_kernel(const struct map *map)
 	return __machine__kernel_map(map->groups->machine, map->type) == map;
 }
 
+bool map__has_symbols(const struct map *map)
+{
+	return dso__has_symbols(map->dso, map->type);
+}
+
 static void map__exit(struct map *map)
 {
 	BUG_ON(!RB_EMPTY_NODE(&map->rb_node));

commit 935f5a9d4500020879858c9224c98dfabf16101d
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Sat Dec 30 00:26:52 2017 +0800

    perf report: Fix a wrong offset issue when using /proc/kcore
    
    When a valid vmlinux is not found, 'perf report' falls back to look at
    /proc/kcore. In this case, it will report the impossible large offset.
    
    For example:
    
      # perf record -b -e cycles:k find /etc/ > /dev/null
      # perf report --stdio --branch-history
    
        22.77%  _vm_normal_page+18446603336221188162
                |
                ---page_remove_rmap +18446603336221188324
                   page_remove_rmap +18446603336221188487 (cycles:5)
                   unlock_page_memcg +18446603336221188096
                   page_remove_rmap +18446603336221188327 (cycles:1)
    
    The issue is the value which is passed to parameter 'addr' in
    __get_srcline() is the objdump address. It's not correct if we calculate
    the offset by using 'addr - sym->start'.
    
    This patch creates a new parameter 'ip' in __get_srcline(). It is not
    converted to objdump address.
    
    With this patch, the perf report output is:
    
        22.77%  _vm_normal_page+66
                |
                ---page_remove_rmap +228
                   page_remove_rmap +391 (cycles:5)
                   unlock_page_memcg +0
                   page_remove_rmap +231 (cycles:1)
                   page_remove_rmap +236
    
    Committer testing:
    
    Make sure you get any valid vmlinux out of the way, using '-v' on the
    'perf report' case and deleting it from places where perf searches them,
    like your kernel build dir and the build-id cache, in ~/.debug/.
    
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1514564812-17344-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6d40efd74402..8fe57031e1a8 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -419,7 +419,7 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 	if (map && map->dso) {
 		srcline = get_srcline(map->dso,
 				      map__rip_2objdump(map, addr), NULL,
-				      true, true);
+				      true, true, addr);
 		if (srcline != SRCLINE_UNKNOWN)
 			ret = fprintf(fp, "%s%s", prefix, srcline);
 		free_srcline(srcline);

commit 15bcdc9477b03eb035052412c3a087e11e855e76
Merge: 340b5319c98e e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:30:18 2017 +0100

    Merge branch 'linus' into perf/core, to fix conflicts
    
    Conflicts:
            tools/perf/arch/arm/annotate/instructions.c
            tools/perf/arch/arm64/annotate/instructions.c
            tools/perf/arch/powerpc/annotate/instructions.c
            tools/perf/arch/s390/annotate/instructions.c
            tools/perf/arch/x86/tests/intel-cqm.c
            tools/perf/ui/tui/progress.c
            tools/perf/util/zlib.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index bdaa0a4edc17..4e7bd2750122 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include "symbol.h"
 #include <errno.h>
 #include <inttypes.h>

commit 0a7c74eae307894c6c95316c382f118aef8481e8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 4 13:15:04 2017 -0300

    perf tools: Provide mutex wrappers for pthreads rwlocks
    
    Andi reported a performance drop in single threaded perf tools such as
    'perf script' due to the growing number of locks being put in place to
    allow for multithreaded tools, so wrap the POSIX threads rwlock routines
    with the names used for such kinds of locks in the Linux kernel and then
    allow for tools to ask for those locks to be used or not.
    
    I.e. a tool may have a multithreaded phase and then switch to single
    threaded, like the upcoming patches for the synthesizing of
    PERF_RECORD_{FORK,MMAP,etc} for pre-existing processes to then switch to
    single threaded mode in 'perf top'.
    
    The init routines will not be conditional, this way starting as single
    threaded to then move to multi threaded mode should be possible.
    
    Reported-by: Andi Kleen <ak@linux.intel.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/20170404161739.GH12903@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index bdaa0a4edc17..5792d7a78152 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -488,7 +488,7 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 static void maps__init(struct maps *maps)
 {
 	maps->entries = RB_ROOT;
-	pthread_rwlock_init(&maps->lock, NULL);
+	init_rwsem(&maps->lock);
 }
 
 void map_groups__init(struct map_groups *mg, struct machine *machine)
@@ -517,9 +517,9 @@ static void __maps__purge(struct maps *maps)
 
 static void maps__exit(struct maps *maps)
 {
-	pthread_rwlock_wrlock(&maps->lock);
+	down_write(&maps->lock);
 	__maps__purge(maps);
-	pthread_rwlock_unlock(&maps->lock);
+	up_write(&maps->lock);
 }
 
 void map_groups__exit(struct map_groups *mg)
@@ -586,7 +586,7 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 	struct symbol *sym;
 	struct rb_node *nd;
 
-	pthread_rwlock_rdlock(&maps->lock);
+	down_read(&maps->lock);
 
 	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
@@ -602,7 +602,7 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 
 	sym = NULL;
 out:
-	pthread_rwlock_unlock(&maps->lock);
+	up_read(&maps->lock);
 	return sym;
 }
 
@@ -638,7 +638,7 @@ static size_t maps__fprintf(struct maps *maps, FILE *fp)
 	size_t printed = 0;
 	struct rb_node *nd;
 
-	pthread_rwlock_rdlock(&maps->lock);
+	down_read(&maps->lock);
 
 	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
@@ -650,7 +650,7 @@ static size_t maps__fprintf(struct maps *maps, FILE *fp)
 		}
 	}
 
-	pthread_rwlock_unlock(&maps->lock);
+	up_read(&maps->lock);
 
 	return printed;
 }
@@ -682,7 +682,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 	struct rb_node *next;
 	int err = 0;
 
-	pthread_rwlock_wrlock(&maps->lock);
+	down_write(&maps->lock);
 
 	root = &maps->entries;
 	next = rb_first(root);
@@ -750,7 +750,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 
 	err = 0;
 out:
-	pthread_rwlock_unlock(&maps->lock);
+	up_write(&maps->lock);
 	return err;
 }
 
@@ -771,7 +771,7 @@ int map_groups__clone(struct thread *thread,
 	struct map *map;
 	struct maps *maps = &parent->maps[type];
 
-	pthread_rwlock_rdlock(&maps->lock);
+	down_read(&maps->lock);
 
 	for (map = maps__first(maps); map; map = map__next(map)) {
 		struct map *new = map__clone(map);
@@ -788,7 +788,7 @@ int map_groups__clone(struct thread *thread,
 
 	err = 0;
 out_unlock:
-	pthread_rwlock_unlock(&maps->lock);
+	up_read(&maps->lock);
 	return err;
 }
 
@@ -815,9 +815,9 @@ static void __maps__insert(struct maps *maps, struct map *map)
 
 void maps__insert(struct maps *maps, struct map *map)
 {
-	pthread_rwlock_wrlock(&maps->lock);
+	down_write(&maps->lock);
 	__maps__insert(maps, map);
-	pthread_rwlock_unlock(&maps->lock);
+	up_write(&maps->lock);
 }
 
 static void __maps__remove(struct maps *maps, struct map *map)
@@ -828,9 +828,9 @@ static void __maps__remove(struct maps *maps, struct map *map)
 
 void maps__remove(struct maps *maps, struct map *map)
 {
-	pthread_rwlock_wrlock(&maps->lock);
+	down_write(&maps->lock);
 	__maps__remove(maps, map);
-	pthread_rwlock_unlock(&maps->lock);
+	up_write(&maps->lock);
 }
 
 struct map *maps__find(struct maps *maps, u64 ip)
@@ -838,7 +838,7 @@ struct map *maps__find(struct maps *maps, u64 ip)
 	struct rb_node **p, *parent = NULL;
 	struct map *m;
 
-	pthread_rwlock_rdlock(&maps->lock);
+	down_read(&maps->lock);
 
 	p = &maps->entries.rb_node;
 	while (*p != NULL) {
@@ -854,7 +854,7 @@ struct map *maps__find(struct maps *maps, u64 ip)
 
 	m = NULL;
 out:
-	pthread_rwlock_unlock(&maps->lock);
+	up_read(&maps->lock);
 	return m;
 }
 

commit bf2e710b3cb8445c052f2ff50b4875a2523bb279
Author: Krister Johansen <kjlx@templeofstupid.com>
Date:   Wed Jul 5 18:48:09 2017 -0700

    perf maps: Lookup maps in both intitial mountns and inner mountns.
    
    If a process is in a mountns and has symbols in /tmp/perf-<pid>.map,
    look first in the namespace using the tgid for the pidns that the
    process might be in.  If the map isn't found there, try looking in the
    mountns where perf is running, and use the tgid that's appropriate for
    perf's pid namespace.  If all else fails, use the original pid.
    
    This allows us to locate a symbol map file in the mount namespace, if it
    was generated there.  However, we also try the tool's /tmp in case it's
    there instead.
    
    Signed-off-by: Krister Johansen <kjlx@templeofstupid.com>
    Tested-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas-Mich Richter <tmricht@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1499305693-1599-3-git-send-email-kjlx@templeofstupid.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 5dc60ca5a294..bdaa0a4edc17 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -146,11 +146,13 @@ void map__init(struct map *map, enum map_type type,
 }
 
 struct map *map__new(struct machine *machine, u64 start, u64 len,
-		     u64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,
+		     u64 pgoff, u32 d_maj, u32 d_min, u64 ino,
 		     u64 ino_gen, u32 prot, u32 flags, char *filename,
 		     enum map_type type, struct thread *thread)
 {
 	struct map *map = malloc(sizeof(*map));
+	struct nsinfo *nsi = NULL;
+	struct nsinfo *nnsi;
 
 	if (map != NULL) {
 		char newfilename[PATH_MAX];
@@ -168,9 +170,11 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		map->ino_generation = ino_gen;
 		map->prot = prot;
 		map->flags = flags;
+		nsi = nsinfo__get(thread->nsinfo);
 
-		if ((anon || no_dso) && type == MAP__FUNCTION) {
-			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);
+		if ((anon || no_dso) && nsi && type == MAP__FUNCTION) {
+			snprintf(newfilename, sizeof(newfilename),
+				 "/tmp/perf-%d.map", nsi->pid);
 			filename = newfilename;
 		}
 
@@ -180,6 +184,16 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		}
 
 		if (vdso) {
+			/* The vdso maps are always on the host and not the
+			 * container.  Ensure that we don't use setns to look
+			 * them up.
+			 */
+			nnsi = nsinfo__copy(nsi);
+			if (nnsi) {
+				nsinfo__put(nsi);
+				nnsi->need_setns = false;
+				nsi = nnsi;
+			}
 			pgoff = 0;
 			dso = machine__findnew_vdso(machine, thread);
 		} else
@@ -201,11 +215,12 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			if (type != MAP__FUNCTION)
 				dso__set_loaded(dso, map->type);
 		}
-		dso->nsinfo = nsinfo__get(thread->nsinfo);
+		dso->nsinfo = nsi;
 		dso__put(dso);
 	}
 	return map;
 out_delete:
+	nsinfo__put(nsi);
 	free(map);
 	return NULL;
 }

commit 843ff37bb59edbe51d64e77ba1b3245a15a4dd9f
Author: Krister Johansen <kjlx@templeofstupid.com>
Date:   Wed Jul 5 18:48:08 2017 -0700

    perf symbols: Find symbols in different mount namespace
    
    Teach perf how to resolve symbols from binaries that are in a different
    mount namespace from the tool.  This allows perf to generate meaningful
    stack traces even if the binary resides in a different mount namespace
    from the tool.
    
    Signed-off-by: Krister Johansen <kjlx@templeofstupid.com>
    Tested-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas-Mich Richter <tmricht@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1499305693-1599-2-git-send-email-kjlx@templeofstupid.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 2179b2deb730..5dc60ca5a294 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -16,6 +16,7 @@
 #include "machine.h"
 #include <linux/string.h>
 #include "srcline.h"
+#include "namespaces.h"
 #include "unwind.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
@@ -200,6 +201,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			if (type != MAP__FUNCTION)
 				dso__set_loaded(dso, map->type);
 		}
+		dso->nsinfo = nsinfo__get(thread->nsinfo);
 		dso__put(dso);
 	}
 	return map;

commit d80406453ad4a69932dc17a617d5b7bc7ae80b8f
Author: Paul Clarke <pc@us.ibm.com>
Date:   Tue Apr 25 13:15:49 2017 -0500

    perf symbols: Allow user probes on versioned symbols
    
    Symbol versioning, as in glibc, results in symbols being defined as:
    
      <real symbol>@[@]<version>
    
    (Note that "@@" identifies a default symbol, if the symbol name is
    repeated.)
    
    perf is currently unable to deal with this, and is unable to create user
    probes at such symbols:
    
      --
      $ nm /lib/powerpc64le-linux-gnu/libpthread.so.0 | grep pthread_create
      0000000000008d30 t __pthread_create_2_1
      0000000000008d30 T pthread_create@@GLIBC_2.17
      $ /usr/bin/sudo perf probe -v -x /lib/powerpc64le-linux-gnu/libpthread.so.0 pthread_create
      probe-definition(0): pthread_create
      symbol:pthread_create file:(null) line:0 offset:0 return:0 lazy:(null)
      0 arguments
      Open Debuginfo file: /usr/lib/debug/lib/powerpc64le-linux-gnu/libpthread-2.19.so
      Try to find probe point from debuginfo.
      Probe point 'pthread_create' not found.
         Error: Failed to add events. Reason: No such file or directory (Code: -2)
      --
    
    One is not able to specify the fully versioned symbol, either, due to
    syntactic conflicts with other uses of "@" by perf:
    
      --
      $ /usr/bin/sudo perf probe -v -x /lib/powerpc64le-linux-gnu/libpthread.so.0 pthread_create@@GLIBC_2.17
      probe-definition(0): pthread_create@@GLIBC_2.17
      Semantic error :SRC@SRC is not allowed.
      0 arguments
         Error: Command Parse Error. Reason: Invalid argument (Code: -22)
      --
    
    This patch ignores versioning for default symbols, thus allowing probes to be
    created for these symbols:
    
      --
      $ /usr/bin/sudo ./perf probe -x /lib/powerpc64le-linux-gnu/libpthread.so.0 pthread_create
      Added new event:
         probe_libpthread:pthread_create (on pthread_create in /lib/powerpc64le-linux-gnu/libpthread-2.19.so)
    
      You can now use it in all perf tools, such as:
    
               perf record -e probe_libpthread:pthread_create -aR sleep 1
    
      $ /usr/bin/sudo ./perf record -e probe_libpthread:pthread_create -aR ./test 2
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.052 MB perf.data (2 samples) ]
      $ /usr/bin/sudo ./perf script
                   test  2915 [000] 19124.260729: probe_libpthread:pthread_create: (3fff99248d38)
                   test  2916 [000] 19124.260962: probe_libpthread:pthread_create: (3fff99248d38)
      $ /usr/bin/sudo ./perf probe --del=probe_libpthread:pthread_create
      Removed event: probe_libpthread:pthread_create
      --
    
    Committer note:
    
    Change the variable storing the result of strlen() to 'int', to fix the build
    on debian:experimental-x-mipsel, fedora:24-x-ARC-uClibc, ubuntu:16.04-x-arm,
    etc:
    
      util/symbol.c: In function 'symbol__match_symbol_name':
      util/symbol.c:422:11: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
         if (len < versioning - name)
                 ^
    
    Signed-off-by: Paul A. Clarke <pc@us.ibm.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Acked-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Link: http://lkml.kernel.org/r/c2b18d9c-17f8-9285-4868-f58b6359ccac@us.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ebfa5d92358a..2179b2deb730 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -325,11 +325,6 @@ int map__load(struct map *map)
 	return 0;
 }
 
-int __weak arch__compare_symbol_names(const char *namea, const char *nameb)
-{
-	return strcmp(namea, nameb);
-}
-
 struct symbol *map__find_symbol(struct map *map, u64 addr)
 {
 	if (map__load(map) < 0)

commit 8ec20b176c4be72d067fa18e33a4f156d1da9bc8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 18 10:57:25 2017 -0300

    perf str{filter,list}: Disentangle headers
    
    There are places where we just need a forward declaration, and others
    were we need to include strlist.h and/or strfilter.h, reducing the
    impact of changes in headers on the build time, do it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-zab42gbiki88y9k0csorxekb@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9059d20c3b8a..ebfa5d92358a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -9,7 +9,6 @@
 #include <uapi/linux/mman.h> /* To get things like MAP_HUGETLB even on older libc headers */
 #include "map.h"
 #include "thread.h"
-#include "strlist.h"
 #include "vdso.h"
 #include "build-id.h"
 #include "util.h"

commit 632a5cabea21eb079b788d2bb4a9318bd6fff5e1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 17 16:30:49 2017 -0300

    perf tools: Move srcline definitions to separate header
    
    Out of util.h into a new file, srcline.h
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-ludnlm4djqcdjziekzr4s3u9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c1870ac365a3..9059d20c3b8a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -16,6 +16,7 @@
 #include "debug.h"
 #include "machine.h"
 #include <linux/string.h>
+#include "srcline.h"
 #include "unwind.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);

commit 5dfa210e407d0fedf746958bff206995bd46570d
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Sat Mar 18 22:49:28 2017 +0100

    perf report: Enable sorting by srcline as key
    
    Often it is interesting to know how costly a given source line is in
    total. Previously, one had to build these sums manually based on all
    addresses that pointed to the same source line. This patch introduces
    srcline as a sort key, which will do the aggregation for us.
    
    Paired with the recent addition of showing inline frames, this makes
    perf report much more useful for many C++ work loads.
    
    The following shows the new feature in action. First, let's show the
    status quo output when we sort by address. The result contains many hist
    entries that generate the same output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g address
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--60.31%--hypot +20
                |          |          |
                |          |          |--8.52%--__hypot_finite +273
                |          |          |
                |          |          |--7.32%--__hypot_finite +411
    ...
                 --35.34%--_start +4194346
                           __libc_start_main +241
                           |
                           |--6.65%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--2.70%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--1.69%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    With this patch and `-g srcline` we instead get the following output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g srcline
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--64.02%--hypot
                |          |          |
                |          |           --59.81%--__hypot_finite
                |          |
                |           --0.53%--cabs
                |
                 --35.34%--_start
                           __libc_start_main
                           |
                           |--12.48%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20170318214928.9047-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 1d9ebcf9e38e..c1870ac365a3 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -405,7 +405,8 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 
 	if (map && map->dso) {
 		srcline = get_srcline(map->dso,
-				      map__rip_2objdump(map, addr), NULL, true);
+				      map__rip_2objdump(map, addr), NULL,
+				      true, true);
 		if (srcline != SRCLINE_UNKNOWN)
 			ret = fprintf(fp, "%s%s", prefix, srcline);
 		free_srcline(srcline);

commit ead05e8f3fffe2860f0f8d1c23d74c526e9f2a3c
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Tue Feb 21 17:35:00 2017 +0200

    perf map: Convert map_groups.refcnt from atomic_t to refcount_t
    
    The refcount_t type and corresponding API should be used instead of
    atomic_t when the variable is used as a reference counter.
    
    This allows to avoid accidental refcounter overflows that might lead to
    use-after-free situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Kook <keescook@chromium.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: David Windsor <dwindsor@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Hans Liljestrand <ishkamiel@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kees Kook <keescook@chromium.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nokia.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: alsa-devel@alsa-project.org
    Link: http://lkml.kernel.org/r/1487691303-31858-7-git-send-email-elena.reshetova@intel.com
    [ Did the missing conversion of tests/thread-mg-share.c too ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index f0e2428efd0b..1d9ebcf9e38e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -485,7 +485,7 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 		maps__init(&mg->maps[i]);
 	}
 	mg->machine = machine;
-	atomic_set(&mg->refcnt, 1);
+	refcount_set(&mg->refcnt, 1);
 }
 
 static void __maps__purge(struct maps *maps)
@@ -547,7 +547,7 @@ void map_groups__delete(struct map_groups *mg)
 
 void map_groups__put(struct map_groups *mg)
 {
-	if (mg && atomic_dec_and_test(&mg->refcnt))
+	if (mg && refcount_dec_and_test(&mg->refcnt))
 		map_groups__delete(mg);
 }
 

commit e3a42cdd3e35d6c2181d5acfa191eb448aea6ace
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Tue Feb 21 17:34:59 2017 +0200

    perf map: Convert map.refcnt from atomic_t to refcount_t
    
    The refcount_t type and corresponding API should be used instead of
    atomic_t when the variable is used as a reference counter.
    
    This allows to avoid accidental refcounter overflows that might lead to
    use-after-free situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Kook <keescook@chromium.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: David Windsor <dwindsor@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Hans Liljestrand <ishkamiel@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kees Kook <keescook@chromium.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nokia.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: alsa-devel@alsa-project.org
    Link: http://lkml.kernel.org/r/1487691303-31858-6-git-send-email-elena.reshetova@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 0a943e7b1ea7..f0e2428efd0b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -141,7 +141,7 @@ void map__init(struct map *map, enum map_type type,
 	RB_CLEAR_NODE(&map->rb_node);
 	map->groups   = NULL;
 	map->erange_warned = false;
-	atomic_set(&map->refcnt, 1);
+	refcount_set(&map->refcnt, 1);
 }
 
 struct map *map__new(struct machine *machine, u64 start, u64 len,
@@ -255,7 +255,7 @@ void map__delete(struct map *map)
 
 void map__put(struct map *map)
 {
-	if (map && atomic_dec_and_test(&map->refcnt))
+	if (map && refcount_dec_and_test(&map->refcnt))
 		map__delete(map);
 }
 
@@ -354,7 +354,7 @@ struct map *map__clone(struct map *from)
 	struct map *map = memdup(from, sizeof(*map));
 
 	if (map != NULL) {
-		atomic_set(&map->refcnt, 1);
+		refcount_set(&map->refcnt, 1);
 		RB_CLEAR_NODE(&map->rb_node);
 		dso__get(map->dso);
 		map->groups = NULL;

commit 5eae7d842510d33d4410c062280eda6c935403dd
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Feb 13 17:11:03 2017 -0300

    perf symbols: dso->name is an array, no need to check it against NULL
    
    As it will always evaluate to 'true', as reported by clang:
    
      util/map.c:390:36: error: address of array 'map->dso->name' will always evaluate to 'true' [-Werror,-Wpointer-bool-conversion]
              if (map && map->dso && (map->dso->name || map->dso->long_name)) {
                                      ~~~~~~~~~~^~~~ ~~
      util/map.c:393:22: error: address of array 'map->dso->name' will always evaluate to 'true' [-Werror,-Wpointer-bool-conversion]
                      else if (map->dso->name)
                         ~~  ~~~~~~~~~~^~~~
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-x8cu007cly40kfp8xnpi9kya@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4f9a71c63026..0a943e7b1ea7 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -387,10 +387,10 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 {
 	const char *dsoname = "[unknown]";
 
-	if (map && map->dso && (map->dso->name || map->dso->long_name)) {
+	if (map && map->dso) {
 		if (symbol_conf.show_kernel_path && map->dso->long_name)
 			dsoname = map->dso->long_name;
-		else if (map->dso->name)
+		else
 			dsoname = map->dso->name;
 	}
 

commit 21e8c81095cdbbde9d2aba8fffc51cb9b5e0eeaa
Author: Alexis Berlemont <alexis.berlemont@gmail.com>
Date:   Wed Oct 12 23:48:23 2016 +0200

    perf hists browser: Dynamically change verbosity level
    
    Here is a small patch which tries to fulfill a point in the perf todo
    list:
    
    * Make pressing 'V' multiple times to go on cycling thru various
      verbosity levels in 'perf top', so that info that is present in
      'perf top -v' can be obtained without having to restart the tool
      (acme).
    
    After a small grep in the code, the max verbosity level seems 3; so,
    we cycle at 4; I did not dare define a MAX_VERBOSE_LEVEL constant.
    
    Signed-off-by: Alexis Berlemont <alexis.berlemont@gmail.com>
    Suggested-and-Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20161012214823.14324-2-alexis.berlemont@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c662fef95d14..4f9a71c63026 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -682,9 +682,16 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			continue;
 
 		if (verbose >= 2) {
-			fputs("overlapping maps:\n", fp);
-			map__fprintf(map, fp);
-			map__fprintf(pos, fp);
+
+			if (use_browser) {
+				pr_warning("overlapping maps in %s "
+					   "(disable tui for more info)\n",
+					   map->dso->name);
+			} else {
+				fputs("overlapping maps:\n", fp);
+				map__fprintf(map, fp);
+				map__fprintf(pos, fp);
+			}
 		}
 
 		rb_erase_init(&pos->rb_node, root);
@@ -702,7 +709,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 
 			before->end = map->start;
 			__map_groups__insert(pos->groups, before);
-			if (verbose >= 2)
+			if (verbose >= 2 && !use_browser)
 				map__fprintf(before, fp);
 			map__put(before);
 		}
@@ -717,7 +724,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 
 			after->start = map->end;
 			__map_groups__insert(pos->groups, after);
-			if (verbose >= 2)
+			if (verbose >= 2 && !use_browser)
 				map__fprintf(after, fp);
 			map__put(after);
 		}

commit fbef103fad5009827965b10aedbecb1786904f4d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Sep 12 16:47:57 2016 -0300

    perf tools: Do hugetlb handling in more systems
    
    The csets:
    
      0ac3348e5024 ("perf tools: Recognize hugetlb mapping as anon mapping")
      d7e404af115b ("perf record: Mark MAP_HUGETLB when synthesizing mmap events")
    
    Added code conditional on MAP_HUGETLB, to make it build in older systems
    where that define wasn't available. Now that we grabbed copies of
    uapi/linux/mmap.h to have all those definitions in tools/, use it so
    that we can support building the tools for older systems (without the
    MAP_HUGETLB define in its libc headers) using new kernels that support
    such maps.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/n/tip-wv6oqbfkpxbix4umj2kcfmaz@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index d51a1257973b..c662fef95d14 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -6,7 +6,7 @@
 #include <string.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <sys/mman.h>
+#include <uapi/linux/mman.h> /* To get things like MAP_HUGETLB even on older libc headers */
 #include "map.h"
 #include "thread.h"
 #include "strlist.h"
@@ -27,12 +27,7 @@ const char *map_type__name[MAP__NR_TYPES] = {
 
 static inline int is_anon_memory(const char *filename, u32 flags)
 {
-	u32 anon_flags = 0;
-
-#ifdef MAP_HUGETLB
-	anon_flags |= MAP_HUGETLB;
-#endif
-	return flags & anon_flags ||
+	return flags & MAP_HUGETLB ||
 	       !strcmp(filename, "//anon") ||
 	       !strncmp(filename, "/dev/zero", sizeof("/dev/zero") - 1) ||
 	       !strncmp(filename, "/anon_hugepage", sizeof("/anon_hugepage") - 1);

commit 0ac3348e502423cf2fe86beca83b8835a2e6d289
Author: Wang Nan <wangnan0@huawei.com>
Date:   Tue Sep 6 04:58:27 2016 +0000

    perf tools: Recognize hugetlb mapping as anon mapping
    
    Hugetlbfs mapping should be recognized as anon mapping so user has a
    chance to create /tmp/perf-<pid>.map file for symbol resolving. This
    patch utilizes MAP_HUGETLB to identify hugetlb mapping.
    
    After this patch, if perf is started before a program starts using huge
    pages (so perf gets MMAP2 events from kernel), perf is able to recognize
    hugetlb mapping as anon mapping.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Nilay Vaish <nilayvaish@gmail.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/r/1473137909-142064-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Hou Pengyang <houpengyang@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 0c54adb07ae9..d51a1257973b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -6,6 +6,7 @@
 #include <string.h>
 #include <stdio.h>
 #include <unistd.h>
+#include <sys/mman.h>
 #include "map.h"
 #include "thread.h"
 #include "strlist.h"
@@ -24,9 +25,15 @@ const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__VARIABLE] = "Variables",
 };
 
-static inline int is_anon_memory(const char *filename)
+static inline int is_anon_memory(const char *filename, u32 flags)
 {
-	return !strcmp(filename, "//anon") ||
+	u32 anon_flags = 0;
+
+#ifdef MAP_HUGETLB
+	anon_flags |= MAP_HUGETLB;
+#endif
+	return flags & anon_flags ||
+	       !strcmp(filename, "//anon") ||
 	       !strncmp(filename, "/dev/zero", sizeof("/dev/zero") - 1) ||
 	       !strncmp(filename, "/anon_hugepage", sizeof("/anon_hugepage") - 1);
 }
@@ -155,7 +162,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 		int anon, no_dso, vdso, android;
 
 		android = is_android_lib(filename);
-		anon = is_anon_memory(filename);
+		anon = is_anon_memory(filename, flags);
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
 

commit be39db9f2932f0ce4e116c71ba5ae2b542e536a7
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Sep 1 19:25:52 2016 -0300

    perf symbols: Remove symbol_filter_t machinery
    
    We're not using it anymore, few users were, but we really could do
    without it, simplify lots of functions by removing it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-1zng8wdznn00iiz08bb7q3vn@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 728129ac653a..0c54adb07ae9 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -279,7 +279,7 @@ void map__fixup_end(struct map *map)
 
 #define DSO__DELETED "(deleted)"
 
-int map__load(struct map *map, symbol_filter_t filter)
+int map__load(struct map *map)
 {
 	const char *name = map->dso->long_name;
 	int nr;
@@ -287,7 +287,7 @@ int map__load(struct map *map, symbol_filter_t filter)
 	if (dso__loaded(map->dso, map->type))
 		return 0;
 
-	nr = dso__load(map->dso, map, filter);
+	nr = dso__load(map->dso, map);
 	if (nr < 0) {
 		if (map->dso->has_build_id) {
 			char sbuild_id[SBUILD_ID_SIZE];
@@ -312,9 +312,6 @@ int map__load(struct map *map, symbol_filter_t filter)
 			pr_warning("%.*s was updated (is prelink enabled?). "
 				"Restart the long running apps that use it!\n",
 				   (int)real_len, name);
-		} else if (filter) {
-			pr_warning("no symbols passed the given filter.\n");
-			return -2;	/* Empty but maybe by the filter */
 		} else {
 			pr_warning("no symbols found in %s, maybe install "
 				   "a debug package?\n", name);
@@ -331,19 +328,17 @@ int __weak arch__compare_symbol_names(const char *namea, const char *nameb)
 	return strcmp(namea, nameb);
 }
 
-struct symbol *map__find_symbol(struct map *map, u64 addr,
-				symbol_filter_t filter)
+struct symbol *map__find_symbol(struct map *map, u64 addr)
 {
-	if (map__load(map, filter) < 0)
+	if (map__load(map) < 0)
 		return NULL;
 
 	return dso__find_symbol(map->dso, map->type, addr);
 }
 
-struct symbol *map__find_symbol_by_name(struct map *map, const char *name,
-					symbol_filter_t filter)
+struct symbol *map__find_symbol_by_name(struct map *map, const char *name)
 {
-	if (map__load(map, filter) < 0)
+	if (map__load(map) < 0)
 		return NULL;
 
 	if (!dso__sorted_by_name(map->dso, map->type))
@@ -556,23 +551,22 @@ void map_groups__put(struct map_groups *mg)
 
 struct symbol *map_groups__find_symbol(struct map_groups *mg,
 				       enum map_type type, u64 addr,
-				       struct map **mapp,
-				       symbol_filter_t filter)
+				       struct map **mapp)
 {
 	struct map *map = map_groups__find(mg, type, addr);
 
 	/* Ensure map is loaded before using map->map_ip */
-	if (map != NULL && map__load(map, filter) >= 0) {
+	if (map != NULL && map__load(map) >= 0) {
 		if (mapp != NULL)
 			*mapp = map;
-		return map__find_symbol(map, map->map_ip(map, addr), filter);
+		return map__find_symbol(map, map->map_ip(map, addr));
 	}
 
 	return NULL;
 }
 
 struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
-					 struct map **mapp, symbol_filter_t filter)
+					 struct map **mapp)
 {
 	struct symbol *sym;
 	struct rb_node *nd;
@@ -582,7 +576,7 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 
-		sym = map__find_symbol_by_name(pos, name, filter);
+		sym = map__find_symbol_by_name(pos, name);
 
 		if (sym == NULL)
 			continue;
@@ -600,15 +594,14 @@ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 					       enum map_type type,
 					       const char *name,
-					       struct map **mapp,
-					       symbol_filter_t filter)
+					       struct map **mapp)
 {
-	struct symbol *sym = maps__find_symbol_by_name(&mg->maps[type], name, mapp, filter);
+	struct symbol *sym = maps__find_symbol_by_name(&mg->maps[type], name, mapp);
 
 	return sym;
 }
 
-int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
+int map_groups__find_ams(struct addr_map_symbol *ams)
 {
 	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
 		if (ams->map->groups == NULL)
@@ -620,7 +613,7 @@ int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
 	}
 
 	ams->al_addr = ams->map->map_ip(ams->map, ams->addr);
-	ams->sym = map__find_symbol(ams->map, ams->al_addr, filter);
+	ams->sym = map__find_symbol(ams->map, ams->al_addr);
 
 	return ams->sym ? 0 : -1;
 }

commit e70493429bb1acaad829caae01c61dd7056fe671
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Tue Jul 19 01:12:41 2016 +0900

    perf probe: Warn unmatched function filter correctly
    
    Warn unmatched function filter correctly instead of warning
    "symbol-loading error", since that can be a filter issue.
    
    From the technical point of view, this adds a filter chech in map__load
    and if there is a filter, it returns -2 (filter-out), instead of -1
    (error), and perf-probe checks it and change message.
    
    E.g. without this fix:
    
      # perf probe -F rt_sp*
      no symbols found in [kernel.kallsyms], maybe install a debug package?
      Failed to load symbols in kernel
    
    With this fix:
    
      # perf probe -F rt_sp*
      no symbols passed the given filter.
      Failed to find symbols matched to "rt_sp*"
        Error: Failed to show functions.
    
    Reported-and-Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/146885835596.16106.2293540792775552481.stgit@devbox
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b39b12a1208d..728129ac653a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -312,6 +312,9 @@ int map__load(struct map *map, symbol_filter_t filter)
 			pr_warning("%.*s was updated (is prelink enabled?). "
 				"Restart the long running apps that use it!\n",
 				   (int)real_len, name);
+		} else if (filter) {
+			pr_warning("no symbols passed the given filter.\n");
+			return -2;	/* Empty but maybe by the filter */
 		} else {
 			pr_warning("no symbols found in %s, maybe install "
 				   "a debug package?\n", name);

commit 6c502584438bda63fc1a67606854fb0b300465cd
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Jul 4 14:16:23 2016 +0200

    perf unwind: Call unwind__prepare_access for forked thread
    
    Currently we call unwind__prepare_access for map event.  In case we
    report fork event the thread inherits its parent's maps and
    unwind__prepare_access is never called for the thread.
    
    This causes unwind__get_entries seeing uninitialized
    unwind_libunwind_ops and thus returning no callchain.
    
    Adding unwind__prepare_access calls for fork even processing.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1467634583-29147-5-git-send-email-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b19bcd3b7128..b39b12a1208d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -15,6 +15,7 @@
 #include "debug.h"
 #include "machine.h"
 #include <linux/string.h>
+#include "unwind.h"
 
 static void __maps__insert(struct maps *maps, struct map *map);
 
@@ -744,9 +745,10 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 /*
  * XXX This should not really _copy_ te maps, but refcount them.
  */
-int map_groups__clone(struct map_groups *mg,
+int map_groups__clone(struct thread *thread,
 		      struct map_groups *parent, enum map_type type)
 {
+	struct map_groups *mg = thread->mg;
 	int err = -ENOMEM;
 	struct map *map;
 	struct maps *maps = &parent->maps[type];
@@ -757,6 +759,11 @@ int map_groups__clone(struct map_groups *mg,
 		struct map *new = map__clone(map);
 		if (new == NULL)
 			goto out_unlock;
+
+		err = unwind__prepare_access(thread, new, NULL);
+		if (err)
+			goto out_unlock;
+
 		map_groups__insert(mg, new);
 		map__put(new);
 	}

commit b5d8bbe8601a45b908f7952707bbb30bf221ca3b
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Wed May 11 22:51:59 2016 +0900

    perf tools: Use SBUILD_ID_SIZE where applicable
    
    Use the existing SBUILD_ID_SIZE macro instead of the equivalent
    BUILD_ID_SIZE * 2 + 1 expression for allocating a buffer for build-id
    strings.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Ananth N Mavinakayanahalli <ananth@linux.vnet.ibm.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Hemant Kumar <hemant@linux.vnet.ibm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20160511135159.23943.57120.stgit@devbox
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 02c31865648b..b19bcd3b7128 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -289,7 +289,7 @@ int map__load(struct map *map, symbol_filter_t filter)
 	nr = dso__load(map->dso, map, filter);
 	if (nr < 0) {
 		if (map->dso->has_build_id) {
-			char sbuild_id[BUILD_ID_SIZE * 2 + 1];
+			char sbuild_id[SBUILD_ID_SIZE];
 
 			build_id__sprintf(map->dso->build_id,
 					  sizeof(map->dso->build_id),

commit a58f7033ba892b7d299954b94471450d72623039
Author: Wang Nan <wangnan0@huawei.com>
Date:   Thu Apr 7 10:24:30 2016 +0000

    perf symbols: Record text offset in dso to calculate objdump address
    
    In this patch, the offset of '.text' section is stored into dso
    and used here to re-calculate address to objdump.
    
    In most of the cases, executable code is in '.text' section, so the
    adjustment made to a symbol in dso__load_sym (using
    sym.st_value -= shdr.sh_addr - shdr.sh_offset) should equal to
    'sym.st_value -= dso->text_offset'. Therefore, adding text_offset back
    get objdump address from symbol address (rip). However, it is not true
    for kernel and kernel module since there could be multiple executable
    sections with different offset. Exclude kernel for this reason.
    
    After this patch, even dso->adjust_symbols is set to true for shared
    objects, map__rip_2objdump() and map__objdump_2mem() would return
    correct result, so perf behavior of annotate won't be changed.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Cody P Schafer <dev@codyps.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1460024671-64774-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 171b6d10a04b..02c31865648b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -431,6 +431,13 @@ u64 map__rip_2objdump(struct map *map, u64 rip)
 	if (map->dso->rel)
 		return rip - map->pgoff;
 
+	/*
+	 * kernel modules also have DSO_TYPE_USER in dso->kernel,
+	 * but all kernel modules are ET_REL, so won't get here.
+	 */
+	if (map->dso->kernel == DSO_TYPE_USER)
+		return rip + map->dso->text_offset;
+
 	return map->unmap_ip(map, rip) - map->reloc;
 }
 
@@ -454,6 +461,13 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	if (map->dso->rel)
 		return map->unmap_ip(map, ip + map->pgoff);
 
+	/*
+	 * kernel modules also have DSO_TYPE_USER in dso->kernel,
+	 * but all kernel modules are ET_REL, so won't get here.
+	 */
+	if (map->dso->kernel == DSO_TYPE_USER)
+		return map->unmap_ip(map, ip - map->dso->text_offset);
+
 	return ip + map->reloc;
 }
 

commit d91130e90a005876b488b6d52b743149d95b4a59
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Wed Dec 9 11:11:31 2015 +0900

    perf tools: Fix maps__fixup_overlappings to put used maps
    
    Since the __map_groups__insert got the given map, we don't need to keep
    it. So put the maps.
    
    Refcnt debugger shows that map_groups__fixup_overlappings() got a map
    twice but the group released it just once. This pattern usually
    indicates the leak happens in caller site.
    
      ----
      ==== [0] ====
      Unreclaimed map@0x39d3ae0
      Refcount +1 => 1 at
        ./perf(map_groups__fixup_overlappings+0x335) [0x4c1865]
        ./perf(thread__insert_map+0x30) [0x4c8e00]
        ./perf(machine__process_mmap2_event+0x106) [0x4bd876]
        ./perf() [0x4c378e]
        ./perf() [0x4c4393]
        ./perf(perf_session__process_events+0x38a) [0x4c654a]
        ./perf(cmd_record+0xe24) [0x42fc94]
        ./perf() [0x47b745]
        ./perf(main+0x617) [0x422547]
        /lib64/libc.so.6(__libc_start_main+0xf5) [0x7f2eca2deaf5]
        ./perf() [0x4226bd]
      Refcount +1 => 2 at
        ./perf(map_groups__fixup_overlappings+0x3c5) [0x4c18f5]
        ./perf(thread__insert_map+0x30) [0x4c8e00]
        ./perf(machine__process_mmap2_event+0x106) [0x4bd876]
        ./perf() [0x4c378e]
        ./perf() [0x4c4393]
        ./perf(perf_session__process_events+0x38a) [0x4c654a]
        ./perf(cmd_record+0xe24) [0x42fc94]
        ./perf() [0x47b745]
        ./perf(main+0x617) [0x422547]
        /lib64/libc.so.6(__libc_start_main+0xf5) [0x7f2eca2deaf5]
        ./perf() [0x4226bd]
      Refcount -1 => 1 at
        ./perf(map_groups__exit+0x92) [0x4c0962]
        ./perf(map_groups__put+0x60) [0x4c0bc0]
        ./perf(thread__put+0x90) [0x4c8a40]
        ./perf(machine__delete_threads+0x7e) [0x4bad9e]
        ./perf(perf_session__delete+0x4f) [0x4c499f]
        ./perf(cmd_record+0xb6d) [0x42f9dd]
        ./perf() [0x47b745]
        ./perf(main+0x617) [0x422547]
        /lib64/libc.so.6(__libc_start_main+0xf5) [0x7f2eca2deaf5]
        ./perf() [0x4226bd]
      ----
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20151209021131.10245.41485.stgit@localhost.localdomain
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 7b1c720976fc..171b6d10a04b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -691,6 +691,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			__map_groups__insert(pos->groups, before);
 			if (verbose >= 2)
 				map__fprintf(before, fp);
+			map__put(before);
 		}
 
 		if (map->end < pos->end) {
@@ -705,6 +706,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			__map_groups__insert(pos->groups, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);
+			map__put(after);
 		}
 put_map:
 		map__put(pos);

commit bae32b50ea96ca0f8702ea55e62095e8cc4745e2
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Wed Dec 9 11:11:20 2015 +0900

    perf tools: Fix map_groups__clone to put cloned map
    
    Fix map_groups__clone to put cloned map after inserting it to the
    map_groups.
    
    Refcnt debugger shows:
      ----
      ==== [0] ====
      Unreclaimed map: 0x2a27ee0
      Refcount +1 => 1 at
        ./perf(map_groups__clone+0x8d) [0x4bb7ed]
        ./perf(thread__fork+0xbe) [0x4c1f9e]
        ./perf(machine__process_fork_event+0x216) [0x4b79a6]
        ./perf(perf_event__synthesize_threads+0x38b) [0x48135b]
        ./perf(cmd_top+0xdc6) [0x43cb76]
        ./perf() [0x477223]
        ./perf(main+0x617) [0x422077]
        /lib64/libc.so.6(__libc_start_main+0xf0) [0x7ff806af8fe0]
        ./perf() [0x4221ed]
      Refcount +1 => 2 at
        ./perf(map_groups__clone+0x128) [0x4bb888]
        ./perf(thread__fork+0xbe) [0x4c1f9e]
        ./perf(machine__process_fork_event+0x216) [0x4b79a6]
        ./perf(perf_event__synthesize_threads+0x38b) [0x48135b]
        ./perf(cmd_top+0xdc6) [0x43cb76]
        ./perf() [0x477223]
        ./perf(main+0x617) [0x422077]
        /lib64/libc.so.6(__libc_start_main+0xf0) [0x7ff806af8fe0]
        ./perf() [0x4221ed]
      Refcount -1 => 1 at
        ./perf(map_groups__exit+0x87) [0x4ba757]
        ./perf(map_groups__put+0x68) [0x4ba9a8]
        ./perf(thread__put+0x8b) [0x4c1aeb]
        ./perf(machine__delete_threads+0x81) [0x4b48f1]
        ./perf(perf_session__delete+0x4f) [0x4be63f]
        ./perf(cmd_top+0x1094) [0x43ce44]
        ./perf() [0x477223]
        ./perf(main+0x617) [0x422077]
        /lib64/libc.so.6(__libc_start_main+0xf0) [0x7ff806af8fe0]
        ./perf() [0x4221ed]
      ----
    
    This shows map_groups__clone get the map twice and put it when
    map_groups__exit.
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20151209021120.10245.95388.stgit@localhost.localdomain
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 93d9f1ce3baa..7b1c720976fc 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -742,6 +742,7 @@ int map_groups__clone(struct map_groups *mg,
 		if (new == NULL)
 			goto out_unlock;
 		map_groups__insert(mg, new);
+		map__put(new);
 	}
 
 	err = 0;

commit b2be5451f660e0ee230969cc24121d9e210a91de
Author: Yannick Brosseau <scientist@fb.com>
Date:   Thu Nov 26 03:42:32 2015 -0800

    perf tools: Correctly identify anon_hugepage when generating map (v2)
    
    When parsing /proc/xxx/maps, the sscanf in perf_event__synthesize_mmap_events
    truncate the map name at the space in "/anon_hugepage (deleted)".
    
    is_anon_memory() then only receives the string "/anon_hugepage" and does
    not detect it.  We change is_anon_memory() to only compare the first
    part of the string, effectively ignoring if " (deleted)" is there.
    
    Signed-off-by: Yannick Brosseau <scientist@fb.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Joshua Zhu <zhu.wen-jie@hp.com>
    Cc: kernel-team@fb.com
    Link: http://lkml.kernel.org/r/1448538152-2898-1-git-send-email-scientist@fb.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index afc6b56cf749..93d9f1ce3baa 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -26,8 +26,8 @@ const char *map_type__name[MAP__NR_TYPES] = {
 static inline int is_anon_memory(const char *filename)
 {
 	return !strcmp(filename, "//anon") ||
-	       !strcmp(filename, "/dev/zero (deleted)") ||
-	       !strcmp(filename, "/anon_hugepage (deleted)");
+	       !strncmp(filename, "/dev/zero", sizeof("/dev/zero") - 1) ||
+	       !strncmp(filename, "/anon_hugepage", sizeof("/anon_hugepage") - 1);
 }
 
 static inline int is_no_dso_memory(const char *filename)

commit cb8382e05817a8104ea0edb63b8e37b8fbecd14c
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Wed Nov 4 15:08:11 2015 +0100

    perf tools: Insert split maps correctly into origin group
    
    When new maps are cloned out of split map they are added into origin
    map's group, but their groups pointer is not updated.
    
    This could lead to a segfault, because map->groups is expected to be
    always set as reported by Markus:
    
      __map__is_kernel (map=map@entry=0x1abb7a0) at util/map.c:238
      238             return __machine__kernel_map(map->groups->machine, map->type) =
      (gdb) bt
      #0  __map__is_kernel (map=map@entry=0x1abb7a0) at util/map.c:238
      #1  0x00000000004393e4 in symbol_filter (map=map@entry=0x1abb7a0, sym=sym@entry
      #2  0x00000000004fcd4d in dso__load_sym (dso=dso@entry=0x166dae0, map=map@entry
      #3  0x00000000004a64e0 in dso__load (dso=0x166dae0, map=map@entry=0x1abb7a0, fi
      #4  0x00000000004b941f in map__load (filter=0x4393c0 <symbol_filter>, map=<opti
      #5  map__find_symbol (map=0x1abb7a0, addr=40188, filter=0x4393c0 <symbol_filter
      ...
    
    Adding __map_groups__insert function to add map into groups together
    with map->groups pointer update. It takes no lock as opposed to existing
    map_groups__insert, as maps__fixup_overlappings(), where it is being
    called, already has the necessary lock held.
    
    Using __map_groups__insert to add new maps after map split.
    
    Reported-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20151104140811.GA32664@krava.brq.redhat.com
    Fixes: cfc5acd4c80b ("perf top: Filter symbols based on __map__is_kernel(map)")
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4e38c396a897..afc6b56cf749 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -644,6 +644,12 @@ size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 	return printed;
 }
 
+static void __map_groups__insert(struct map_groups *mg, struct map *map)
+{
+	__maps__insert(&mg->maps[map->type], map);
+	map->groups = mg;
+}
+
 static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
 {
 	struct rb_root *root;
@@ -682,7 +688,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			}
 
 			before->end = map->start;
-			__maps__insert(maps, before);
+			__map_groups__insert(pos->groups, before);
 			if (verbose >= 2)
 				map__fprintf(before, fp);
 		}
@@ -696,7 +702,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			}
 
 			after->start = map->end;
-			__maps__insert(maps, after);
+			__map_groups__insert(pos->groups, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);
 		}

commit a5e813c68649366aaa3f785772b00ea6ccad7b8d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Sep 30 11:54:04 2015 -0300

    perf machine: Add method for common kernel_map(FUNCTION) operation
    
    And it is also a step in the direction of killing the separation of data
    and text maps in map_groups.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-rrds86kb3wx5wk8v38v56gw8@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 2a9d859d30b9..4e38c396a897 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -235,7 +235,7 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
  */
 bool __map__is_kernel(const struct map *map)
 {
-	return machine__kernel_map(map->groups->machine, map->type) == map;
+	return __machine__kernel_map(map->groups->machine, map->type) == map;
 }
 
 static void map__exit(struct map *map)

commit 77e65977495cd6f6fcfacd8c16bdd9c8c18a1d72
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Sep 30 11:08:58 2015 -0300

    perf machine: Use machine__kernel_map() thoroughly
    
    In places where we were using its open coded equivalent.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-khkdugcdoqy3tkszm3jdxgbe@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 622c2c9a1e65..2a9d859d30b9 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -235,7 +235,7 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
  */
 bool __map__is_kernel(const struct map *map)
 {
-	return map->groups->machine->vmlinux_maps[map->type] == map;
+	return machine__kernel_map(map->groups->machine, map->type) == map;
 }
 
 static void map__exit(struct map *map)

commit b7f9ff5654d53fa47e0b5ff20f834f3e7a611846
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Sep 29 17:34:46 2015 -0300

    perf maps: Introduce maps__find_symbol_by_name()
    
    Out of map_groups__find_symbol_by_name(), so that we can turn this later
    one first into a call to maps__find_symbol_by_name(MAP__FUNCTION) +
    MAP__VARIABLE, and then to just one call, we'll merge MAP__FUNCTION with
    MAP__VARIABLE maps, to simplify the code.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-pvkar0jacqn92g148u9sqttt@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b1c475d9b240..622c2c9a1e65 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -553,13 +553,9 @@ struct symbol *map_groups__find_symbol(struct map_groups *mg,
 	return NULL;
 }
 
-struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
-					       enum map_type type,
-					       const char *name,
-					       struct map **mapp,
-					       symbol_filter_t filter)
+struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
+					 struct map **mapp, symbol_filter_t filter)
 {
-	struct maps *maps = &mg->maps[type];
 	struct symbol *sym;
 	struct rb_node *nd;
 
@@ -583,6 +579,17 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 	return sym;
 }
 
+struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
+					       enum map_type type,
+					       const char *name,
+					       struct map **mapp,
+					       symbol_filter_t filter)
+{
+	struct symbol *sym = maps__find_symbol_by_name(&mg->maps[type], name, mapp, filter);
+
+	return sym;
+}
+
 int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
 {
 	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {

commit 66671d001aeb525b9101e0ccb9062627539de555
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Aug 18 15:19:50 2015 -0300

    perf tools: Initialize reference counts in map__clone()
    
    Map clone was written before we introduced reference counts for
    maps and dsos, so all that was needed was just a copy and then we
    would insert it into the new map_groups instance.
    
    Fix it by, after copying, initializing the map->refcnt, grabbing
    a struct dso refcount and resetting pointers that may be used
    to determine if a map, when deleted, is in a rb_tree.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-pd4mr80o5b9gvk50iineacec@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ce37e95bc513..b1c475d9b240 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -348,9 +348,18 @@ struct symbol *map__find_symbol_by_name(struct map *map, const char *name,
 	return dso__find_symbol_by_name(map->dso, map->type, name);
 }
 
-struct map *map__clone(struct map *map)
+struct map *map__clone(struct map *from)
 {
-	return memdup(map, sizeof(*map));
+	struct map *map = memdup(from, sizeof(*map));
+
+	if (map != NULL) {
+		atomic_set(&map->refcnt, 1);
+		RB_CLEAR_NODE(&map->rb_node);
+		dso__get(map->dso);
+		map->groups = NULL;
+	}
+
+	return map;
 }
 
 int map__overlap(struct map *l, struct map *r)

commit e6ce712634ea038ce42bbb11932b692696756882
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jul 23 11:06:16 2015 -0300

    perf symbols: Introduce map__is_(kernel,kmodule)()
    
    To, with members we already have, check if a kernel level map is for the
    kernel proper or for a module.
    
    Acked-by: David Ahern <dsahern@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-m5ic7h0z2crmtj7vi1a1rj3b@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b5a5e9c02437..ce37e95bc513 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -224,6 +224,20 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
 	return map;
 }
 
+/*
+ * Use this and __map__is_kmodule() for map instances that are in
+ * machine->kmaps, and thus have map->groups->machine all properly set, to
+ * disambiguate between the kernel and modules.
+ *
+ * When the need arises, introduce map__is_{kernel,kmodule)() that
+ * checks (map->groups != NULL && map->groups->machine != NULL &&
+ * map->dso->kernel) before calling __map__is_{kernel,kmodule}())
+ */
+bool __map__is_kernel(const struct map *map)
+{
+	return map->groups->machine->vmlinux_maps[map->type] == map;
+}
+
 static void map__exit(struct map *map)
 {
 	BUG_ON(!RB_EMPTY_NODE(&map->rb_node));

commit 5c24b67aae72f54c5d2a6898be4bae9726df63bb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Jun 15 23:29:51 2015 -0300

    perf tools: Replace map->referenced & maps->removed_maps with map->refcnt
    
    Use just reference counts, so that when no more hist_entry instances
    references a map and the thread instance goes away by processing a
    PERF_RECORD_EXIT, we can delete the maps.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-oym7lfhcc7ss6xpz44h7nbxs@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 1241ab989cf5..b5a5e9c02437 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -137,7 +137,6 @@ void map__init(struct map *map, enum map_type type,
 	map->unmap_ip = map__unmap_ip;
 	RB_CLEAR_NODE(&map->rb_node);
 	map->groups   = NULL;
-	map->referenced = false;
 	map->erange_warned = false;
 	atomic_set(&map->refcnt, 1);
 }
@@ -439,7 +438,6 @@ static void maps__init(struct maps *maps)
 {
 	maps->entries = RB_ROOT;
 	pthread_rwlock_init(&maps->lock, NULL);
-	INIT_LIST_HEAD(&maps->removed_maps);
 }
 
 void map_groups__init(struct map_groups *mg, struct machine *machine)
@@ -466,21 +464,10 @@ static void __maps__purge(struct maps *maps)
 	}
 }
 
-static void __maps__purge_removed_maps(struct maps *maps)
-{
-	struct map *pos, *n;
-
-	list_for_each_entry_safe(pos, n, &maps->removed_maps, node) {
-		list_del_init(&pos->node);
-		map__put(pos);
-	}
-}
-
 static void maps__exit(struct maps *maps)
 {
 	pthread_rwlock_wrlock(&maps->lock);
 	__maps__purge(maps);
-	__maps__purge_removed_maps(maps);
 	pthread_rwlock_unlock(&maps->lock);
 }
 
@@ -499,8 +486,6 @@ bool map_groups__empty(struct map_groups *mg)
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
 		if (maps__first(&mg->maps[i]))
 			return false;
-		if (!list_empty(&mg->maps[i].removed_maps))
-			return false;
 	}
 
 	return true;
@@ -621,7 +606,7 @@ size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
 	return printed += maps__fprintf(&mg->maps[type], fp);
 }
 
-static size_t map_groups__fprintf_maps(struct map_groups *mg, FILE *fp)
+size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 {
 	size_t printed = 0, i;
 	for (i = 0; i < MAP__NR_TYPES; ++i)
@@ -629,39 +614,6 @@ static size_t map_groups__fprintf_maps(struct map_groups *mg, FILE *fp)
 	return printed;
 }
 
-static size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,
-						 enum map_type type, FILE *fp)
-{
-	struct map *pos;
-	size_t printed = 0;
-
-	list_for_each_entry(pos, &mg->maps[type].removed_maps, node) {
-		printed += fprintf(fp, "Map:");
-		printed += map__fprintf(pos, fp);
-		if (verbose > 1) {
-			printed += dso__fprintf(pos->dso, type, fp);
-			printed += fprintf(fp, "--\n");
-		}
-	}
-	return printed;
-}
-
-static size_t map_groups__fprintf_removed_maps(struct map_groups *mg,
-					       FILE *fp)
-{
-	size_t printed = 0, i;
-	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_removed_maps(mg, i, fp);
-	return printed;
-}
-
-size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
-{
-	size_t printed = map_groups__fprintf_maps(mg, fp);
-	printed += fprintf(fp, "Removed maps:\n");
-	return printed + map_groups__fprintf_removed_maps(mg, fp);
-}
-
 static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
 {
 	struct rb_root *root;
@@ -719,13 +671,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 				map__fprintf(after, fp);
 		}
 put_map:
-		/*
-		 * If we have references, just move them to a separate list.
-		 */
-		if (pos->referenced)
-			list_add_tail(&pos->node, &maps->removed_maps);
-		else
-			map__put(pos);
+		map__put(pos);
 
 		if (err)
 			goto out;

commit d3a7c489c7fd2463e3b2c3a2179c7be879dd9cb4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Jun 2 11:53:26 2015 -0300

    perf tools: Reference count struct dso
    
    This has a different model than the 'thread' and 'map' struct lifetimes:
    there is not a definitive "don't use this DSO anymore" event, i.e. we may
    get many 'struct map' holding references to the '/usr/lib64/libc-2.20.so'
    DSO but then at some point some DSO may have no references but we still
    don't want to straight away release its resources, because "soon" we may
    get a new 'struct map' that needs it and we want to reuse its symtab or
    other resources.
    
    So we need some way to garbage collect it when crossing some memory
    usage threshold, which is left for anoter patch, for now it is
    sufficient to release it when calling dsos__exit(), i.e. when deleting
    the whole list as part of deleting the 'struct machine' containing it,
    which will leave only referenced objects being used.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-majzgz07cm90t2tejrjy4clf@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 365011c233a6..1241ab989cf5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -132,7 +132,7 @@ void map__init(struct map *map, enum map_type type,
 	map->end      = end;
 	map->pgoff    = pgoff;
 	map->reloc    = 0;
-	map->dso      = dso;
+	map->dso      = dso__get(dso);
 	map->map_ip   = map__map_ip;
 	map->unmap_ip = map__unmap_ip;
 	RB_CLEAR_NODE(&map->rb_node);
@@ -198,6 +198,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			if (type != MAP__FUNCTION)
 				dso__set_loaded(dso, map->type);
 		}
+		dso__put(dso);
 	}
 	return map;
 out_delete:
@@ -224,9 +225,15 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
 	return map;
 }
 
-void map__delete(struct map *map)
+static void map__exit(struct map *map)
 {
 	BUG_ON(!RB_EMPTY_NODE(&map->rb_node));
+	dso__zput(map->dso);
+}
+
+void map__delete(struct map *map)
+{
+	map__exit(map);
 	free(map);
 }
 

commit 9a4388c711d07889217b19eaf63485122dec8817
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 29 11:54:08 2015 -0300

    perf machine: Fix up vdso methods names
    
    To make it consistent with the other dso lifetime routines.
    
    For instance:
    
     struct dso *vdso__new(struct machine *machine, const char *short_name,
                            const char *long_name)
    
    Becomes:
    
     struct dso *machine__addnew_vdso(struct machine *machine, const
                                      char *short_name, const char *long_name)
    
    Because:
    
    1) There is no 'struct vdso' for us to have vdso__ prefixed routines.
    
    2) Because it will not really just create a new instance of 'struct
       dso', it'll call dso__new() but it will also insert it into the
       DSO's list/rbtree, and we have a method name for that: 'addnew',
       just like we have dsos__addnew().
    
    3) So it is really a 'struct machine' operation, it is the first
       argument, etc.
    
    This way the place where this is used gets consistent:
    
                    if (vdso) {
                            pgoff = 0;
    -                       dso = vdso__dso_findnew(machine, thread);
    +                       dso = machine__findnew_vdso(machine, thread);
                    } else
                            dso = machine__findnew_dso(machine, filename);
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-r3w3tvh8exm9xfz3p4tz9qbz@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index d15e1e9dd2ae..365011c233a6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -178,7 +178,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 
 		if (vdso) {
 			pgoff = 0;
-			dso = vdso__dso_findnew(machine, thread);
+			dso = machine__findnew_vdso(machine, thread);
 		} else
 			dso = machine__findnew_dso(machine, filename);
 

commit aa7cc2ae5ae69aff555793fbfcff514141bb23f3
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 29 11:31:12 2015 -0300

    perf machine: Introduce machine__findnew_dso() method
    
    Similar to machine__findnew_thread(), also prepping for refcounting and
    locking, this time for struct dso instances.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-fv3tshv5o1413coh147lszjc@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 57ff0256c22c..d15e1e9dd2ae 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -180,7 +180,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			pgoff = 0;
 			dso = vdso__dso_findnew(machine, thread);
 		} else
-			dso = __dsos__findnew(&machine->dsos, filename);
+			dso = machine__findnew_dso(machine, filename);
 
 		if (dso == NULL)
 			goto out_delete;

commit 3d39ac538629e4f00a6e1c38d46346f1b8e69505
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu May 28 13:06:42 2015 -0300

    perf machine: No need to have two DSOs lists
    
    We can, given a DSO, figure out if it is a kernel, a kernel module or
    a userlevel DSO, so stop having to process two lists in several
    functions.
    
    If searching becomes an issue at some point, we can have them in a
    rbtree, etc.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-s4yb0onpdywu6dj2xl9lxi4t@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index af572322586d..57ff0256c22c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -180,7 +180,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 			pgoff = 0;
 			dso = vdso__dso_findnew(machine, thread);
 		} else
-			dso = __dsos__findnew(&machine->user_dsos, filename);
+			dso = __dsos__findnew(&machine->dsos, filename);
 
 		if (dso == NULL)
 			goto out_delete;

commit 84c2cafa288939e11d21c7830e32b2aee21b723e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon May 25 16:59:56 2015 -0300

    perf tools: Reference count struct map
    
    We have pointers to struct map instances in several places, like in the
    hist_entry instances, so we need a way to know when we can destroy them,
    otherwise we may either keep leaking them or end up referencing deleted
    instances.
    
    Start fixing it by reference counting them.
    
    This patch puts the reference count for struct map in place, replacing
    direct map__delete() calls with map__put() ones and then grabbing a
    reference count when adding it to the maps struct where maps for a
    struct thread are kept.
    
    Next we'll grab reference counts when setting pointers to struct map
    instances, in places like in the hist_entry code.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-wi19xczk0t2a41r1i2chuio5@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4d3a92d5dff3..af572322586d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -139,6 +139,7 @@ void map__init(struct map *map, enum map_type type,
 	map->groups   = NULL;
 	map->referenced = false;
 	map->erange_warned = false;
+	atomic_set(&map->refcnt, 1);
 }
 
 struct map *map__new(struct machine *machine, u64 start, u64 len,
@@ -229,6 +230,12 @@ void map__delete(struct map *map)
 	free(map);
 }
 
+void map__put(struct map *map)
+{
+	if (map && atomic_dec_and_test(&map->refcnt))
+		map__delete(map);
+}
+
 void map__fixup_start(struct map *map)
 {
 	struct rb_root *symbols = &map->dso->symbols[map->type];
@@ -448,7 +455,7 @@ static void __maps__purge(struct maps *maps)
 
 		next = rb_next(&pos->rb_node);
 		rb_erase_init(&pos->rb_node, root);
-		map__delete(pos);
+		map__put(pos);
 	}
 }
 
@@ -458,7 +465,7 @@ static void __maps__purge_removed_maps(struct maps *maps)
 
 	list_for_each_entry_safe(pos, n, &maps->removed_maps, node) {
 		list_del_init(&pos->node);
-		map__delete(pos);
+		map__put(pos);
 	}
 }
 
@@ -682,7 +689,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 
 			if (before == NULL) {
 				err = -ENOMEM;
-				goto move_map;
+				goto put_map;
 			}
 
 			before->end = map->start;
@@ -696,7 +703,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 
 			if (after == NULL) {
 				err = -ENOMEM;
-				goto move_map;
+				goto put_map;
 			}
 
 			after->start = map->end;
@@ -704,14 +711,14 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			if (verbose >= 2)
 				map__fprintf(after, fp);
 		}
-move_map:
+put_map:
 		/*
 		 * If we have references, just move them to a separate list.
 		 */
 		if (pos->referenced)
 			list_add_tail(&pos->node, &maps->removed_maps);
 		else
-			map__delete(pos);
+			map__put(pos);
 
 		if (err)
 			goto out;
@@ -772,6 +779,7 @@ static void __maps__insert(struct maps *maps, struct map *map)
 
 	rb_link_node(&map->rb_node, parent, p);
 	rb_insert_color(&map->rb_node, &maps->entries);
+	map__get(map);
 }
 
 void maps__insert(struct maps *maps, struct map *map)
@@ -784,6 +792,7 @@ void maps__insert(struct maps *maps, struct map *map)
 static void __maps__remove(struct maps *maps, struct map *map)
 {
 	rb_erase_init(&map->rb_node, &maps->entries);
+	map__put(map);
 }
 
 void maps__remove(struct maps *maps, struct map *map)

commit facf3f0621b2e11957af1aae9085730ea78ccf85
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon May 25 15:30:09 2015 -0300

    perf tools: Check if a map is still in use when deleting it
    
    I.e. match RB_CLEAR_NODE() with RB_EMPTY_NODE(), to check that it isn't
    in a rb tree at the time of its deletion.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-vumvhird765id11zbx00d2r8@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 0905b07072da..4d3a92d5dff3 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -225,6 +225,7 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
 
 void map__delete(struct map *map)
 {
+	BUG_ON(!RB_EMPTY_NODE(&map->rb_node));
 	free(map);
 }
 
@@ -446,7 +447,7 @@ static void __maps__purge(struct maps *maps)
 		struct map *pos = rb_entry(next, struct map, rb_node);
 
 		next = rb_next(&pos->rb_node);
-		rb_erase(&pos->rb_node, root);
+		rb_erase_init(&pos->rb_node, root);
 		map__delete(pos);
 	}
 }
@@ -456,7 +457,7 @@ static void __maps__purge_removed_maps(struct maps *maps)
 	struct map *pos, *n;
 
 	list_for_each_entry_safe(pos, n, &maps->removed_maps, node) {
-		list_del(&pos->node);
+		list_del_init(&pos->node);
 		map__delete(pos);
 	}
 }
@@ -671,7 +672,7 @@ static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp
 			map__fprintf(pos, fp);
 		}
 
-		rb_erase(&pos->rb_node, root);
+		rb_erase_init(&pos->rb_node, root);
 		/*
 		 * Now check if we need to create new maps for areas not
 		 * overlapped by the new map:
@@ -782,7 +783,7 @@ void maps__insert(struct maps *maps, struct map *map)
 
 static void __maps__remove(struct maps *maps, struct map *map)
 {
-	rb_erase(&map->rb_node, &maps->entries);
+	rb_erase_init(&map->rb_node, &maps->entries);
 }
 
 void maps__remove(struct maps *maps, struct map *map)

commit 6a2ffcddad22ead7ce75c5773e87895b91e7cca7
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 22 13:45:24 2015 -0300

    perf tools: Protect accesses the map rbtrees with a rw lock
    
    To allow concurrent access, next step: refcount struct map instances, so
    that we can ditch maps->removed_maps and stop leaking threads, maps,
    then struct DSO needs the same treatment.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-o45w2w5dzrza38nzqxnqzhyf@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index adf012c4d650..0905b07072da 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -16,6 +16,8 @@
 #include "machine.h"
 #include <linux/string.h>
 
+static void __maps__insert(struct maps *maps, struct map *map);
+
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
 	[MAP__VARIABLE] = "Variables",
@@ -421,6 +423,7 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 static void maps__init(struct maps *maps)
 {
 	maps->entries = RB_ROOT;
+	pthread_rwlock_init(&maps->lock, NULL);
 	INIT_LIST_HEAD(&maps->removed_maps);
 }
 
@@ -434,7 +437,7 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 	atomic_set(&mg->refcnt, 1);
 }
 
-static void maps__purge(struct maps *maps)
+static void __maps__purge(struct maps *maps)
 {
 	struct rb_root *root = &maps->entries;
 	struct rb_node *next = rb_first(root);
@@ -448,7 +451,7 @@ static void maps__purge(struct maps *maps)
 	}
 }
 
-static void maps__purge_removed_maps(struct maps *maps)
+static void __maps__purge_removed_maps(struct maps *maps)
 {
 	struct map *pos, *n;
 
@@ -460,8 +463,10 @@ static void maps__purge_removed_maps(struct maps *maps)
 
 static void maps__exit(struct maps *maps)
 {
-	maps__purge(maps);
-	maps__purge_removed_maps(maps);
+	pthread_rwlock_wrlock(&maps->lock);
+	__maps__purge(maps);
+	__maps__purge_removed_maps(maps);
+	pthread_rwlock_unlock(&maps->lock);
 }
 
 void map_groups__exit(struct map_groups *mg)
@@ -531,20 +536,28 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 					       struct map **mapp,
 					       symbol_filter_t filter)
 {
+	struct maps *maps = &mg->maps[type];
+	struct symbol *sym;
 	struct rb_node *nd;
 
-	for (nd = rb_first(&mg->maps[type].entries); nd; nd = rb_next(nd)) {
+	pthread_rwlock_rdlock(&maps->lock);
+
+	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
-		struct symbol *sym = map__find_symbol_by_name(pos, name, filter);
+
+		sym = map__find_symbol_by_name(pos, name, filter);
 
 		if (sym == NULL)
 			continue;
 		if (mapp != NULL)
 			*mapp = pos;
-		return sym;
+		goto out;
 	}
 
-	return NULL;
+	sym = NULL;
+out:
+	pthread_rwlock_unlock(&maps->lock);
+	return sym;
 }
 
 int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
@@ -564,25 +577,35 @@ int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
 	return ams->sym ? 0 : -1;
 }
 
-size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
-				  FILE *fp)
+static size_t maps__fprintf(struct maps *maps, FILE *fp)
 {
-	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
+	size_t printed = 0;
 	struct rb_node *nd;
 
-	for (nd = rb_first(&mg->maps[type].entries); nd; nd = rb_next(nd)) {
+	pthread_rwlock_rdlock(&maps->lock);
+
+	for (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
 		if (verbose > 2) {
-			printed += dso__fprintf(pos->dso, type, fp);
+			printed += dso__fprintf(pos->dso, pos->type, fp);
 			printed += fprintf(fp, "--\n");
 		}
 	}
 
+	pthread_rwlock_unlock(&maps->lock);
+
 	return printed;
 }
 
+size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
+				  FILE *fp)
+{
+	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
+	return printed += maps__fprintf(&mg->maps[type], fp);
+}
+
 static size_t map_groups__fprintf_maps(struct map_groups *mg, FILE *fp)
 {
 	size_t printed = 0, i;
@@ -624,13 +647,17 @@ size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 	return printed + map_groups__fprintf_removed_maps(mg, fp);
 }
 
-int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
-				   FILE *fp)
+static int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
 {
-	struct rb_root *root = &mg->maps[map->type].entries;
-	struct rb_node *next = rb_first(root);
+	struct rb_root *root;
+	struct rb_node *next;
 	int err = 0;
 
+	pthread_rwlock_wrlock(&maps->lock);
+
+	root = &maps->entries;
+	next = rb_first(root);
+
 	while (next) {
 		struct map *pos = rb_entry(next, struct map, rb_node);
 		next = rb_next(&pos->rb_node);
@@ -658,7 +685,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 			}
 
 			before->end = map->start;
-			map_groups__insert(mg, before);
+			__maps__insert(maps, before);
 			if (verbose >= 2)
 				map__fprintf(before, fp);
 		}
@@ -672,7 +699,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 			}
 
 			after->start = map->end;
-			map_groups__insert(mg, after);
+			__maps__insert(maps, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);
 		}
@@ -681,15 +708,24 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 		 * If we have references, just move them to a separate list.
 		 */
 		if (pos->referenced)
-			list_add_tail(&pos->node, &mg->maps[map->type].removed_maps);
+			list_add_tail(&pos->node, &maps->removed_maps);
 		else
 			map__delete(pos);
 
 		if (err)
-			return err;
+			goto out;
 	}
 
-	return 0;
+	err = 0;
+out:
+	pthread_rwlock_unlock(&maps->lock);
+	return err;
+}
+
+int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
+				   FILE *fp)
+{
+	return maps__fixup_overlappings(&mg->maps[map->type], map, fp);
 }
 
 /*
@@ -698,19 +734,26 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 int map_groups__clone(struct map_groups *mg,
 		      struct map_groups *parent, enum map_type type)
 {
+	int err = -ENOMEM;
 	struct map *map;
 	struct maps *maps = &parent->maps[type];
 
+	pthread_rwlock_rdlock(&maps->lock);
+
 	for (map = maps__first(maps); map; map = map__next(map)) {
 		struct map *new = map__clone(map);
 		if (new == NULL)
-			return -ENOMEM;
+			goto out_unlock;
 		map_groups__insert(mg, new);
 	}
-	return 0;
+
+	err = 0;
+out_unlock:
+	pthread_rwlock_unlock(&maps->lock);
+	return err;
 }
 
-void maps__insert(struct maps *maps, struct map *map)
+static void __maps__insert(struct maps *maps, struct map *map)
 {
 	struct rb_node **p = &maps->entries.rb_node;
 	struct rb_node *parent = NULL;
@@ -730,17 +773,33 @@ void maps__insert(struct maps *maps, struct map *map)
 	rb_insert_color(&map->rb_node, &maps->entries);
 }
 
-void maps__remove(struct maps *maps, struct map *map)
+void maps__insert(struct maps *maps, struct map *map)
+{
+	pthread_rwlock_wrlock(&maps->lock);
+	__maps__insert(maps, map);
+	pthread_rwlock_unlock(&maps->lock);
+}
+
+static void __maps__remove(struct maps *maps, struct map *map)
 {
 	rb_erase(&map->rb_node, &maps->entries);
 }
 
+void maps__remove(struct maps *maps, struct map *map)
+{
+	pthread_rwlock_wrlock(&maps->lock);
+	__maps__remove(maps, map);
+	pthread_rwlock_unlock(&maps->lock);
+}
+
 struct map *maps__find(struct maps *maps, u64 ip)
 {
-	struct rb_node **p = &maps->entries.rb_node;
-	struct rb_node *parent = NULL;
+	struct rb_node **p, *parent = NULL;
 	struct map *m;
 
+	pthread_rwlock_rdlock(&maps->lock);
+
+	p = &maps->entries.rb_node;
 	while (*p != NULL) {
 		parent = *p;
 		m = rb_entry(parent, struct map, rb_node);
@@ -749,10 +808,13 @@ struct map *maps__find(struct maps *maps, u64 ip)
 		else if (ip >= m->end)
 			p = &(*p)->rb_right;
 		else
-			return m;
+			goto out;
 	}
 
-	return NULL;
+	m = NULL;
+out:
+	pthread_rwlock_unlock(&maps->lock);
+	return m;
 }
 
 struct map *maps__first(struct maps *maps)

commit 1eee78aea9252fabcd333805d5d9fa42a1bf9427
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 22 12:58:53 2015 -0300

    perf tools: Introduce struct maps
    
    That for now has the maps rbtree and the list for the dead maps, that
    may be still referenced from some hist_entry, etc.
    
    This paves the way for protecting the rbtree with a lock, then refcount
    the maps and finally remove the removed_maps list, as it'll not ne
    anymore needed.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-fl0fa6142pj8khj97fow3uw0@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 898ab92a98dd..adf012c4d650 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -418,48 +418,58 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	return ip + map->reloc;
 }
 
+static void maps__init(struct maps *maps)
+{
+	maps->entries = RB_ROOT;
+	INIT_LIST_HEAD(&maps->removed_maps);
+}
+
 void map_groups__init(struct map_groups *mg, struct machine *machine)
 {
 	int i;
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		mg->maps[i] = RB_ROOT;
-		INIT_LIST_HEAD(&mg->removed_maps[i]);
+		maps__init(&mg->maps[i]);
 	}
 	mg->machine = machine;
 	atomic_set(&mg->refcnt, 1);
 }
 
-static void maps__delete(struct rb_root *maps)
+static void maps__purge(struct maps *maps)
 {
-	struct rb_node *next = rb_first(maps);
+	struct rb_root *root = &maps->entries;
+	struct rb_node *next = rb_first(root);
 
 	while (next) {
 		struct map *pos = rb_entry(next, struct map, rb_node);
 
 		next = rb_next(&pos->rb_node);
-		rb_erase(&pos->rb_node, maps);
+		rb_erase(&pos->rb_node, root);
 		map__delete(pos);
 	}
 }
 
-static void maps__delete_removed(struct list_head *maps)
+static void maps__purge_removed_maps(struct maps *maps)
 {
 	struct map *pos, *n;
 
-	list_for_each_entry_safe(pos, n, maps, node) {
+	list_for_each_entry_safe(pos, n, &maps->removed_maps, node) {
 		list_del(&pos->node);
 		map__delete(pos);
 	}
 }
 
+static void maps__exit(struct maps *maps)
+{
+	maps__purge(maps);
+	maps__purge_removed_maps(maps);
+}
+
 void map_groups__exit(struct map_groups *mg)
 {
 	int i;
 
-	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		maps__delete(&mg->maps[i]);
-		maps__delete_removed(&mg->removed_maps[i]);
-	}
+	for (i = 0; i < MAP__NR_TYPES; ++i)
+		maps__exit(&mg->maps[i]);
 }
 
 bool map_groups__empty(struct map_groups *mg)
@@ -469,7 +479,7 @@ bool map_groups__empty(struct map_groups *mg)
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
 		if (maps__first(&mg->maps[i]))
 			return false;
-		if (!list_empty(&mg->removed_maps[i]))
+		if (!list_empty(&mg->maps[i].removed_maps))
 			return false;
 	}
 
@@ -523,7 +533,7 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 {
 	struct rb_node *nd;
 
-	for (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {
+	for (nd = rb_first(&mg->maps[type].entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 		struct symbol *sym = map__find_symbol_by_name(pos, name, filter);
 
@@ -560,7 +570,7 @@ size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
 	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
 	struct rb_node *nd;
 
-	for (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {
+	for (nd = rb_first(&mg->maps[type].entries); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
@@ -587,7 +597,7 @@ static size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,
 	struct map *pos;
 	size_t printed = 0;
 
-	list_for_each_entry(pos, &mg->removed_maps[type], node) {
+	list_for_each_entry(pos, &mg->maps[type].removed_maps, node) {
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
 		if (verbose > 1) {
@@ -617,7 +627,7 @@ size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 				   FILE *fp)
 {
-	struct rb_root *root = &mg->maps[map->type];
+	struct rb_root *root = &mg->maps[map->type].entries;
 	struct rb_node *next = rb_first(root);
 	int err = 0;
 
@@ -671,7 +681,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 		 * If we have references, just move them to a separate list.
 		 */
 		if (pos->referenced)
-			list_add_tail(&pos->node, &mg->removed_maps[map->type]);
+			list_add_tail(&pos->node, &mg->maps[map->type].removed_maps);
 		else
 			map__delete(pos);
 
@@ -689,7 +699,7 @@ int map_groups__clone(struct map_groups *mg,
 		      struct map_groups *parent, enum map_type type)
 {
 	struct map *map;
-	struct rb_root *maps = &parent->maps[type];
+	struct maps *maps = &parent->maps[type];
 
 	for (map = maps__first(maps); map; map = map__next(map)) {
 		struct map *new = map__clone(map);
@@ -700,9 +710,9 @@ int map_groups__clone(struct map_groups *mg,
 	return 0;
 }
 
-void maps__insert(struct rb_root *maps, struct map *map)
+void maps__insert(struct maps *maps, struct map *map)
 {
-	struct rb_node **p = &maps->rb_node;
+	struct rb_node **p = &maps->entries.rb_node;
 	struct rb_node *parent = NULL;
 	const u64 ip = map->start;
 	struct map *m;
@@ -717,17 +727,17 @@ void maps__insert(struct rb_root *maps, struct map *map)
 	}
 
 	rb_link_node(&map->rb_node, parent, p);
-	rb_insert_color(&map->rb_node, maps);
+	rb_insert_color(&map->rb_node, &maps->entries);
 }
 
-void maps__remove(struct rb_root *maps, struct map *map)
+void maps__remove(struct maps *maps, struct map *map)
 {
-	rb_erase(&map->rb_node, maps);
+	rb_erase(&map->rb_node, &maps->entries);
 }
 
-struct map *maps__find(struct rb_root *maps, u64 ip)
+struct map *maps__find(struct maps *maps, u64 ip)
 {
-	struct rb_node **p = &maps->rb_node;
+	struct rb_node **p = &maps->entries.rb_node;
 	struct rb_node *parent = NULL;
 	struct map *m;
 
@@ -745,9 +755,9 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 	return NULL;
 }
 
-struct map *maps__first(struct rb_root *maps)
+struct map *maps__first(struct maps *maps)
 {
-	struct rb_node *first = rb_first(maps);
+	struct rb_node *first = rb_first(&maps->entries);
 
 	if (first)
 		return rb_entry(first, struct map, rb_node);

commit 4bb7123dcfa7aa1d963ad4a8f01b88d54a2bb873
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 22 11:52:22 2015 -0300

    perf tools: Use maps__first()/map__next()
    
    In a few more remaining places, for consistency.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-c2n7slwtto29wndfttdrhfrx@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c1bfd0a12a94..898ab92a98dd 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -688,9 +688,10 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 int map_groups__clone(struct map_groups *mg,
 		      struct map_groups *parent, enum map_type type)
 {
-	struct rb_node *nd;
-	for (nd = rb_first(&parent->maps[type]); nd; nd = rb_next(nd)) {
-		struct map *map = rb_entry(nd, struct map, rb_node);
+	struct map *map;
+	struct rb_root *maps = &parent->maps[type];
+
+	for (map = maps__first(maps); map; map = map__next(map)) {
 		struct map *new = map__clone(map);
 		if (new == NULL)
 			return -ENOMEM;

commit f7e365eb61d4d78f2f5e66d859664048c2921df2
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon May 25 18:03:44 2015 -0300

    perf tools: Nuke unused map_groups__flush()
    
    Since:
    
            9fdbf671ba7e "perf tools: do not flush maps on COMM for perf report"
    
    We have no users of this function, nuke it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Luigi Semenzato <semenzato@chromium.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-hsac1t42ehtva8gut8qe6hih@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 09a62731e035..c1bfd0a12a94 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -498,28 +498,6 @@ void map_groups__put(struct map_groups *mg)
 		map_groups__delete(mg);
 }
 
-void map_groups__flush(struct map_groups *mg)
-{
-	int type;
-
-	for (type = 0; type < MAP__NR_TYPES; type++) {
-		struct rb_root *root = &mg->maps[type];
-		struct rb_node *next = rb_first(root);
-
-		while (next) {
-			struct map *pos = rb_entry(next, struct map, rb_node);
-			next = rb_next(&pos->rb_node);
-			rb_erase(&pos->rb_node, root);
-			/*
-			 * We may have references to this map, for
-			 * instance in some hist_entry instances, so
-			 * just move them to a separate list.
-			 */
-			list_add_tail(&pos->node, &mg->removed_maps[pos->type]);
-		}
-	}
-}
-
 struct symbol *map_groups__find_symbol(struct map_groups *mg,
 				       enum map_type type, u64 addr,
 				       struct map **mapp,

commit 4d4dee9a9609819309a84cd3f2d19dcc50ece195
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu May 21 17:48:33 2015 -0300

    perf tools: Rename maps__next
    
    It really is a 'struct map' method, and since we're introducing a new
    'struct maps' class, fix it to avoid confusion.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-xo9ifhk53cfl30wqcuhxpnvl@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 2d20c5ff8653..09a62731e035 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -775,7 +775,7 @@ struct map *maps__first(struct rb_root *maps)
 	return NULL;
 }
 
-struct map *maps__next(struct map *map)
+struct map *map__next(struct map *map)
 {
 	struct rb_node *next = rb_next(&map->rb_node);
 

commit 848cbd2562bb85953884be72b3bdbee0b2f32474
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri May 15 15:20:44 2015 -0300

    perf tools: Use atomic.h for the map_groups refcount
    
    Now that we have atomic.h, we should convert all of the existing
    refcounts to use it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-onm5u3pioba1hqqhjs8on03e@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index cd0e335008b4..2d20c5ff8653 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -426,7 +426,7 @@ void map_groups__init(struct map_groups *mg, struct machine *machine)
 		INIT_LIST_HEAD(&mg->removed_maps[i]);
 	}
 	mg->machine = machine;
-	mg->refcnt = 1;
+	atomic_set(&mg->refcnt, 1);
 }
 
 static void maps__delete(struct rb_root *maps)
@@ -494,7 +494,7 @@ void map_groups__delete(struct map_groups *mg)
 
 void map_groups__put(struct map_groups *mg)
 {
-	if (--mg->refcnt == 0)
+	if (mg && atomic_dec_and_test(&mg->refcnt))
 		map_groups__delete(mg);
 }
 

commit 031b84c407c3153ffbcb4f8f832edf48af988719
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Tue Apr 28 17:35:37 2015 +0530

    perf probe ppc: Enable matching against dot symbols automatically
    
    Allow perf probe to work on ppc ABIv1 without the need to specify the
    leading dot '.' for functions. 'perf probe do_fork' works with this
    patch.
    
    We do this by changing how symbol name comparison works on ppc ABIv1 -
    we simply ignore and skip over the initial dot, if one exists, during
    symbol name comparison.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/652a8f3bfa919bd02a1836a128370eaed59b4a34.1430217967.git.naveen.n.rao@linux.vnet.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a14f08f41686..cd0e335008b4 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -292,6 +292,11 @@ int map__load(struct map *map, symbol_filter_t filter)
 	return 0;
 }
 
+int __weak arch__compare_symbol_names(const char *namea, const char *nameb)
+{
+	return strcmp(namea, nameb);
+}
+
 struct symbol *map__find_symbol(struct map *map, u64 addr,
 				symbol_filter_t filter)
 {

commit ba92732e9808df679ddf75c5ea1c0caae6d7dce2
Author: Wang Nan <wangnan0@huawei.com>
Date:   Tue Apr 7 08:22:45 2015 +0000

    perf kmaps: Check kmaps to make code more robust
    
    This patch add checks in places where map__kmap is used to get kmaps
    from struct kmap.
    
    Error messages are added at map__kmap to warn invalid accessing of kmap
    (for the case of !map->dso->kernel, kmap(map) does not exists at all).
    
    Also, introduces map__kmaps() to warn uninitialized kmaps.
    
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: pi3orama@163.com
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/r/1428394966-131044-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 62ca9f2607d5..a14f08f41686 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -778,3 +778,23 @@ struct map *maps__next(struct map *map)
 		return rb_entry(next, struct map, rb_node);
 	return NULL;
 }
+
+struct kmap *map__kmap(struct map *map)
+{
+	if (!map->dso || !map->dso->kernel) {
+		pr_err("Internal error: map__kmap with a non-kernel map\n");
+		return NULL;
+	}
+	return (struct kmap *)(map + 1);
+}
+
+struct map_groups *map__kmaps(struct map *map)
+{
+	struct kmap *kmap = map__kmap(map);
+
+	if (!kmap || !kmap->kmaps) {
+		pr_err("Internal error: map__kmaps with a non-kernel map\n");
+		return NULL;
+	}
+	return kmap->kmaps;
+}

commit 85c116a6cb91a5c09b7a6c95ffc6a6cbd32cd237
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:27 2014 -0800

    perf callchain: Make get_srcline fall back to sym+offset
    
    When the source line is not found fall back to sym + offset.  This is
    generally much more useful than a raw address.
    
    For this we need to pass in the symbol from the caller.
    
    For some callers it's awkward to compute, so we stay at the old
    behaviour.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-10-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 040a785c857b..62ca9f2607d5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -360,7 +360,7 @@ int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
 
 	if (map && map->dso) {
 		srcline = get_srcline(map->dso,
-				      map__rip_2objdump(map, addr));
+				      map__rip_2objdump(map, addr), NULL, true);
 		if (srcline != SRCLINE_UNKNOWN)
 			ret = fprintf(fp, "%s%s", prefix, srcline);
 		free_srcline(srcline);

commit 11246c708acdfa9512d7b69c18938810c20fd6ab
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Oct 21 17:29:02 2014 -0300

    perf tools: Set thread->mg.machine in all places
    
    We were setting this only in machine__init(), i.e. for the map_groups that
    holds the kernel module maps, not for the one used for a thread's executable
    mmaps.
    
    Now we are sure that we can obtain the machine where a thread is by going
    via thread->mg->machine, thus we can, in the following patch, make all
    codepaths that receive machine _and_ thread, drop the machine one.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-y6zgaqsvhrf04v57u15e4ybm@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 2137c4596ec7..040a785c857b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -413,14 +413,14 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	return ip + map->reloc;
 }
 
-void map_groups__init(struct map_groups *mg)
+void map_groups__init(struct map_groups *mg, struct machine *machine)
 {
 	int i;
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
 		mg->maps[i] = RB_ROOT;
 		INIT_LIST_HEAD(&mg->removed_maps[i]);
 	}
-	mg->machine = NULL;
+	mg->machine = machine;
 	mg->refcnt = 1;
 }
 
@@ -471,12 +471,12 @@ bool map_groups__empty(struct map_groups *mg)
 	return true;
 }
 
-struct map_groups *map_groups__new(void)
+struct map_groups *map_groups__new(struct machine *machine)
 {
 	struct map_groups *mg = malloc(sizeof(*mg));
 
 	if (mg != NULL)
-		map_groups__init(mg);
+		map_groups__init(mg, machine);
 
 	return mg;
 }

commit 4955ea225db42144d1667838f908315a16d51c5b
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Oct 14 16:05:38 2014 -0300

    perf tools: Fixup off-by-one comparision in maps__find
    
    map->end is the first addr _outside_ the a map, following the convention
    of vm_area_struct->vm_end.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Stephane Eranian <eranian@google.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/8761fwh1nc.fsf@sejong.aot.lge.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 186418ba18db..2137c4596ec7 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -752,7 +752,7 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 		m = rb_entry(parent, struct map, rb_node);
 		if (ip < m->start)
 			p = &(*p)->rb_left;
-		else if (ip > m->end)
+		else if (ip >= m->end)
 			p = &(*p)->rb_right;
 		else
 			return m;

commit 77faf4d060e3ee1fd2ff6cd39f2b2eb887100422
Author: Stephane Eranian <eranian@google.com>
Date:   Mon Oct 6 10:35:32 2014 +0200

    perf tools: fix off-by-one error in maps
    
    This patch fixes off-by-one errors in the management of maps.
    
    A map is defined by start address and length as implemented by
    map__new():
    
      map__init(map, type, start, start + len, pgoff, dso);
    
      map->start = addr;
      map->end = end;
    
    Consequently, the actual address range is [start; end[ map->end is the
    first byte outside the range.
    
    This patch fixes two bugs where upper bound checking was off-by-one.
    
    In V2, we fix map_groups__fixup_overlappings() some more where
    map->start was off-by-one as reported by Jiri.
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20141006083532.GA4850@quad
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b7090596ac50..186418ba18db 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -556,7 +556,7 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 
 int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
 {
-	if (ams->addr < ams->map->start || ams->addr > ams->map->end) {
+	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
 		if (ams->map->groups == NULL)
 			return -1;
 		ams->map = map_groups__find(ams->map->groups, ams->map->type,
@@ -664,7 +664,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 				goto move_map;
 			}
 
-			before->end = map->start - 1;
+			before->end = map->start;
 			map_groups__insert(mg, before);
 			if (verbose >= 2)
 				map__fprintf(before, fp);
@@ -678,7 +678,7 @@ int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 				goto move_map;
 			}
 
-			after->start = map->end + 1;
+			after->start = map->end;
 			map_groups__insert(mg, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);

commit 700be564308bcfc217bd3515d634b56f0c3c1bbb
Author: Don Zickus <dzickus@redhat.com>
Date:   Tue Aug 19 22:31:14 2014 -0400

    perf symbols: Don't try to find DSOs in SYSV maps
    
    We are seeing a lot of the following with regards to SYSV memory
    
    Failed to open /SYSV0000279c, continuing without symbols
    
    We don't believe this memory will have DSO info, so treat it like the
    heap and stack for now and skip it to prevent the warning.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Joe Mario <jmario@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Joe Mario <jmario@redhat.com>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1408501874-244377-1-git-send-email-dzickus@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 31b8905dd863..b7090596ac50 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -31,6 +31,7 @@ static inline int is_anon_memory(const char *filename)
 static inline int is_no_dso_memory(const char *filename)
 {
 	return !strncmp(filename, "[stack", 6) ||
+	       !strncmp(filename, "/SYSV",5)   ||
 	       !strcmp(filename, "[heap]");
 }
 

commit 5835eddab6f162b38e9a6a5447a2c3a128637956
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jul 22 16:18:00 2014 +0300

    perf tools: Add thread parameter to vdso__dso_findnew()
    
    The thread will be needed to determine the VDSO type.
    
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1406035081-14301-52-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index dffc8dce6046..31b8905dd863 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -141,7 +141,7 @@ void map__init(struct map *map, enum map_type type,
 struct map *map__new(struct machine *machine, u64 start, u64 len,
 		     u64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,
 		     u64 ino_gen, u32 prot, u32 flags, char *filename,
-		     enum map_type type)
+		     enum map_type type, struct thread *thread)
 {
 	struct map *map = malloc(sizeof(*map));
 
@@ -174,7 +174,7 @@ struct map *map__new(struct machine *machine, u64 start, u64 len,
 
 		if (vdso) {
 			pgoff = 0;
-			dso = vdso__dso_findnew(machine);
+			dso = vdso__dso_findnew(machine, thread);
 		} else
 			dso = __dsos__findnew(&machine->user_dsos, filename);
 

commit 2a03068c5cfa104768703cbefa2e23a6353f8de5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jul 22 16:17:53 2014 +0300

    perf tools: Pass machine to vdso__dso_findnew()
    
    This is preparation for removing the global variables used in vdso.c and
    thereby fixing the lifetime of the VDSO temporary file.
    
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1406035081-14301-45-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 845f627e45f4..dffc8dce6046 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -13,6 +13,7 @@
 #include "build-id.h"
 #include "util.h"
 #include "debug.h"
+#include "machine.h"
 #include <linux/string.h>
 
 const char *map_type__name[MAP__NR_TYPES] = {
@@ -137,7 +138,7 @@ void map__init(struct map *map, enum map_type type,
 	map->erange_warned = false;
 }
 
-struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
+struct map *map__new(struct machine *machine, u64 start, u64 len,
 		     u64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,
 		     u64 ino_gen, u32 prot, u32 flags, char *filename,
 		     enum map_type type)
@@ -173,9 +174,9 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 
 		if (vdso) {
 			pgoff = 0;
-			dso = vdso__dso_findnew(dsos__list);
+			dso = vdso__dso_findnew(machine);
 		} else
-			dso = __dsos__findnew(dsos__list, filename);
+			dso = __dsos__findnew(&machine->user_dsos, filename);
 
 		if (dso == NULL)
 			goto out_delete;

commit acebd408bef17169fbf79079b96f0264b535916c
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Jul 14 23:46:47 2014 +0200

    perf tools: Remove verbose from functions prototypes
    
    And use verbose as an global object in following functions:
    
      __map_groups__fprintf_maps
      __map_groups__fprintf_removed_maps
      map_groups__fprintf_maps
      map_groups__fprintf
    
    Also making map_groups__fprintf_maps static.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1405374411-29012-2-git-send-email-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 7af14807ee90..845f627e45f4 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -12,6 +12,7 @@
 #include "vdso.h"
 #include "build-id.h"
 #include "util.h"
+#include "debug.h"
 #include <linux/string.h>
 
 const char *map_type__name[MAP__NR_TYPES] = {
@@ -568,8 +569,8 @@ int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
 	return ams->sym ? 0 : -1;
 }
 
-size_t __map_groups__fprintf_maps(struct map_groups *mg,
-				  enum map_type type, int verbose, FILE *fp)
+size_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,
+				  FILE *fp)
 {
 	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
 	struct rb_node *nd;
@@ -587,17 +588,16 @@ size_t __map_groups__fprintf_maps(struct map_groups *mg,
 	return printed;
 }
 
-size_t map_groups__fprintf_maps(struct map_groups *mg, int verbose, FILE *fp)
+static size_t map_groups__fprintf_maps(struct map_groups *mg, FILE *fp)
 {
 	size_t printed = 0, i;
 	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_maps(mg, i, verbose, fp);
+		printed += __map_groups__fprintf_maps(mg, i, fp);
 	return printed;
 }
 
 static size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,
-						 enum map_type type,
-						 int verbose, FILE *fp)
+						 enum map_type type, FILE *fp)
 {
 	struct map *pos;
 	size_t printed = 0;
@@ -614,23 +614,23 @@ static size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,
 }
 
 static size_t map_groups__fprintf_removed_maps(struct map_groups *mg,
-					       int verbose, FILE *fp)
+					       FILE *fp)
 {
 	size_t printed = 0, i;
 	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_removed_maps(mg, i, verbose, fp);
+		printed += __map_groups__fprintf_removed_maps(mg, i, fp);
 	return printed;
 }
 
-size_t map_groups__fprintf(struct map_groups *mg, int verbose, FILE *fp)
+size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
 {
-	size_t printed = map_groups__fprintf_maps(mg, verbose, fp);
+	size_t printed = map_groups__fprintf_maps(mg, fp);
 	printed += fprintf(fp, "Removed maps:\n");
-	return printed + map_groups__fprintf_removed_maps(mg, verbose, fp);
+	return printed + map_groups__fprintf_removed_maps(mg, fp);
 }
 
 int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
-				   int verbose, FILE *fp)
+				   FILE *fp)
 {
 	struct rb_root *root = &mg->maps[map->type];
 	struct rb_node *next = rb_first(root);

commit 29ce36121e6738012aaf00d983d25260627f2b0d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Jul 16 11:07:13 2014 +0300

    perf machine: Fix map groups of threads with unknown pids
    
    Events like sched_switch do not provide a pid (tgid) which can result in
    threads with an unknown pid.  If the pid is later discovered, join the
    map groups.
    
    Note the thread's map groups should be empty because they are populated
    by MMAP events which do provide the pid and tid.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1405498033-23817-1-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 25c571f4cba6..7af14807ee90 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -454,6 +454,20 @@ void map_groups__exit(struct map_groups *mg)
 	}
 }
 
+bool map_groups__empty(struct map_groups *mg)
+{
+	int i;
+
+	for (i = 0; i < MAP__NR_TYPES; ++i) {
+		if (maps__first(&mg->maps[i]))
+			return false;
+		if (!list_empty(&mg->removed_maps[i]))
+			return false;
+	}
+
+	return true;
+}
+
 struct map_groups *map_groups__new(void)
 {
 	struct map_groups *mg = malloc(sizeof(*mg));

commit 7ef807034ef33f8afe33fa7957c73954e8e4f89c
Author: Don Zickus <dzickus@redhat.com>
Date:   Mon May 19 15:13:49 2014 -0400

    perf tools: Update mmap2 interface with protection and flag bits
    
    The kernel piece passes more info now.  Update the perf tool to reflect
    that and adjust the synthesized maps to play along.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Link: http://lkml.kernel.org/r/1400526833-141779-4-git-send-email-dzickus@redhat.com
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 8ccbb32eda25..25c571f4cba6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -138,7 +138,7 @@ void map__init(struct map *map, enum map_type type,
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		     u64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,
-		     u64 ino_gen, char *filename,
+		     u64 ino_gen, u32 prot, u32 flags, char *filename,
 		     enum map_type type)
 {
 	struct map *map = malloc(sizeof(*map));
@@ -157,6 +157,8 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		map->min = d_min;
 		map->ino = ino;
 		map->ino_generation = ino_gen;
+		map->prot = prot;
+		map->flags = flags;
 
 		if ((anon || no_dso) && type == MAP__FUNCTION) {
 			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);

commit eca8183699964579ca8a0b8d116bd1f4da0136f7
Author: Michael Lentine <mlentine@google.com>
Date:   Tue May 20 11:48:50 2014 +0200

    perf tools: Add automatic remapping of Android libraries
    
    This patch automatically adjusts the path of MMAP records
    associated with Android system libraries.
    
    The Android system is organized with system libraries found in
    /system/lib and user libraries in /data/app-lib. On the host system
    (not running Android), system libraries can be found in the downloaded
    NDK directory under ${NDK_ROOT}/platforms/${APP_PLATFORM}/arch-${ARCH}/usr/lib
    and the user libraries are installed under libs/${APP_ABI} within
    the apk build directory. This patch makes running the reporting
    tools possible on the host system using the libraries from the NDK.
    
    Signed-off-by: Michael Lentine <mlentine@google.com>
    Reviewed-by: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1400579330-5043-3-git-send-email-eranian@google.com
    [ fixed 'space required before the open parenthesis' checkpatch.pl errors ]
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ba5f5c0c838b..8ccbb32eda25 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -32,6 +32,93 @@ static inline int is_no_dso_memory(const char *filename)
 	       !strcmp(filename, "[heap]");
 }
 
+static inline int is_android_lib(const char *filename)
+{
+	return !strncmp(filename, "/data/app-lib", 13) ||
+	       !strncmp(filename, "/system/lib", 11);
+}
+
+static inline bool replace_android_lib(const char *filename, char *newfilename)
+{
+	const char *libname;
+	char *app_abi;
+	size_t app_abi_length, new_length;
+	size_t lib_length = 0;
+
+	libname  = strrchr(filename, '/');
+	if (libname)
+		lib_length = strlen(libname);
+
+	app_abi = getenv("APP_ABI");
+	if (!app_abi)
+		return false;
+
+	app_abi_length = strlen(app_abi);
+
+	if (!strncmp(filename, "/data/app-lib", 13)) {
+		char *apk_path;
+
+		if (!app_abi_length)
+			return false;
+
+		new_length = 7 + app_abi_length + lib_length;
+
+		apk_path = getenv("APK_PATH");
+		if (apk_path) {
+			new_length += strlen(apk_path) + 1;
+			if (new_length > PATH_MAX)
+				return false;
+			snprintf(newfilename, new_length,
+				 "%s/libs/%s/%s", apk_path, app_abi, libname);
+		} else {
+			if (new_length > PATH_MAX)
+				return false;
+			snprintf(newfilename, new_length,
+				 "libs/%s/%s", app_abi, libname);
+		}
+		return true;
+	}
+
+	if (!strncmp(filename, "/system/lib/", 11)) {
+		char *ndk, *app;
+		const char *arch;
+		size_t ndk_length;
+		size_t app_length;
+
+		ndk = getenv("NDK_ROOT");
+		app = getenv("APP_PLATFORM");
+
+		if (!(ndk && app))
+			return false;
+
+		ndk_length = strlen(ndk);
+		app_length = strlen(app);
+
+		if (!(ndk_length && app_length && app_abi_length))
+			return false;
+
+		arch = !strncmp(app_abi, "arm", 3) ? "arm" :
+		       !strncmp(app_abi, "mips", 4) ? "mips" :
+		       !strncmp(app_abi, "x86", 3) ? "x86" : NULL;
+
+		if (!arch)
+			return false;
+
+		new_length = 27 + ndk_length +
+			     app_length + lib_length
+			   + strlen(arch);
+
+		if (new_length > PATH_MAX)
+			return false;
+		snprintf(newfilename, new_length,
+			"%s/platforms/%s/arch-%s/usr/lib/%s",
+			ndk, app, arch, libname);
+
+		return true;
+	}
+	return false;
+}
+
 void map__init(struct map *map, enum map_type type,
 	       u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
@@ -59,8 +146,9 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 	if (map != NULL) {
 		char newfilename[PATH_MAX];
 		struct dso *dso;
-		int anon, no_dso, vdso;
+		int anon, no_dso, vdso, android;
 
+		android = is_android_lib(filename);
 		anon = is_anon_memory(filename);
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
@@ -75,6 +163,11 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 			filename = newfilename;
 		}
 
+		if (android) {
+			if (replace_android_lib(filename, newfilename))
+				filename = newfilename;
+		}
+
 		if (vdso) {
 			pgoff = 0;
 			dso = vdso__dso_findnew(dsos__list);

commit a26ca6716a6c683f40bd676cea7e89704653b98d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 25 15:26:44 2014 -0300

    perf tools: Reference count map_groups objects
    
    We will share it among threads in the same process.
    Adding map_groups__get/map_groups__put interface for that.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@kernel.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1397490723-1992-4-git-send-email-jolsa@redhat.com
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ae4c5e12debd..ba5f5c0c838b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -323,6 +323,7 @@ void map_groups__init(struct map_groups *mg)
 		INIT_LIST_HEAD(&mg->removed_maps[i]);
 	}
 	mg->machine = NULL;
+	mg->refcnt = 1;
 }
 
 static void maps__delete(struct rb_root *maps)
@@ -374,6 +375,12 @@ void map_groups__delete(struct map_groups *mg)
 	free(mg);
 }
 
+void map_groups__put(struct map_groups *mg)
+{
+	if (--mg->refcnt == 0)
+		map_groups__delete(mg);
+}
+
 void map_groups__flush(struct map_groups *mg)
 {
 	int type;

commit 93d5731dcb5b8cb7fa56ee11a5891f10c96c2a45
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Mar 21 17:57:01 2014 -0300

    perf tools: Allocate thread map_groups's dynamically
    
    Moving towards sharing map groups within a process threads.
    
    Because of this we need the map groups to be dynamically allocated. No
    other functional change is intended in here.
    
    Based on a patch by Jiri Olsa, but this time _just_ making the
    conversion from statically allocating thread->mg to turning it into a
    pointer and instead of initializing it at thread's constructor,
    introduce a constructor/destructor for the map_groups class and
    call at thread creation time.
    
    Later we will introduce the get/put methods when we move to sharing
    those map_groups, when the get/put refcounting semantics will be needed.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@kernel.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1397490723-1992-3-git-send-email-jolsa@redhat.com
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 39cd2d0faff6..ae4c5e12debd 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -358,6 +358,22 @@ void map_groups__exit(struct map_groups *mg)
 	}
 }
 
+struct map_groups *map_groups__new(void)
+{
+	struct map_groups *mg = malloc(sizeof(*mg));
+
+	if (mg != NULL)
+		map_groups__init(mg);
+
+	return mg;
+}
+
+void map_groups__delete(struct map_groups *mg)
+{
+	map_groups__exit(mg);
+	free(mg);
+}
+
 void map_groups__flush(struct map_groups *mg)
 {
 	int type;

commit 9176753d1ed56951a6ee2a0f0a3f367904e35567
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Jan 29 16:14:36 2014 +0200

    perf symbols: Fix symbol annotation for relocated kernel
    
    Kernel maps map memory addresses to file offsets.
    
    For symbol annotation, objdump needs the object VMA addresses.  For an
    unrelocated kernel, that is the same as the memory address.
    
    The addresses passed to objdump for symbol annotation did not take into
    account kernel relocation.
    
    This patch fixes that.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Jiri Olsa <jolsa@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1391004884-10334-2-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 3b97513f0e77..39cd2d0faff6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -39,6 +39,7 @@ void map__init(struct map *map, enum map_type type,
 	map->start    = start;
 	map->end      = end;
 	map->pgoff    = pgoff;
+	map->reloc    = 0;
 	map->dso      = dso;
 	map->map_ip   = map__map_ip;
 	map->unmap_ip = map__unmap_ip;
@@ -288,7 +289,7 @@ u64 map__rip_2objdump(struct map *map, u64 rip)
 	if (map->dso->rel)
 		return rip - map->pgoff;
 
-	return map->unmap_ip(map, rip);
+	return map->unmap_ip(map, rip) - map->reloc;
 }
 
 /**
@@ -311,7 +312,7 @@ u64 map__objdump_2mem(struct map *map, u64 ip)
 	if (map->dso->rel)
 		return map->unmap_ip(map, ip + map->pgoff);
 
-	return ip;
+	return ip + map->reloc;
 }
 
 void map_groups__init(struct map_groups *mg)

commit 4afc81cd1caa93daa50c1c29a3ab747c978abc13
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Thu Jan 23 02:29:50 2014 +0000

    perf symbols: Load map before using map->map_ip()
    
    In map_groups__find_symbol() map->map_ip is used without ensuring the
    map is loaded. Then the address passed to map->map_ip isn't mapped at
    the first time.
    
    E.g. below code always fails to get a symbol at the first call;
    
            addr = /* Somewhere in the kernel text */
            symbol_conf.try_vmlinux_path = true;
            symbol__init();
            host_machine = machine__new_host();
            sym = machine__find_kernel_function(host_machine,
                                             addr, NULL, NULL);
            /* Note that machine__find_kernel_function calls
               map_groups__find_symbol */
    
    This ensures it by calling map__load before using it in
    map_groups__find_symbol().
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: "David A. Long" <dave.long@linaro.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: "Steven Rostedt (Red Hat)" <rostedt@goodmis.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20140123022950.7206.17357.stgit@kbuild-fedora.yrl.intra.hitachi.co.jp
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ee1dd687a262..3b97513f0e77 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -386,7 +386,8 @@ struct symbol *map_groups__find_symbol(struct map_groups *mg,
 {
 	struct map *map = map_groups__find(mg, type, addr);
 
-	if (map != NULL) {
+	/* Ensure map is loaded before using map->map_ip */
+	if (map != NULL && map__load(map, filter) >= 0) {
 		if (mapp != NULL)
 			*mapp = map;
 		return map__find_symbol(map, map->map_ip(map, addr), filter);

commit 578c03c86fadcc6fd7319ddf41dd4d1d88aab77a
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Jan 16 10:49:31 2014 +0900

    perf symbols: Fix JIT symbol resolution on heap
    
    Gaurav reported that perf cannot profile JIT program if it executes the
    code on heap.  This was because current map__new() only handle JIT on
    anon mappings - extends it to handle no_dso (heap, stack) case too.
    
    This patch assumes JIT profiling only provides dynamic function symbols
    so check the mapping type to distinguish the case.  It'd provide no
    symbols for data mapping - if we need to support symbols on data
    mappings later it should be changed.
    
    Reported-by: Gaurav Jain <gjain@fb.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Gaurav Jain <gjain@fb.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Gaurav Jain <gjain@fb.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1389836971-3549-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9b9bd719aa19..ee1dd687a262 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -69,7 +69,7 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		map->ino = ino;
 		map->ino_generation = ino_gen;
 
-		if (anon) {
+		if ((anon || no_dso) && type == MAP__FUNCTION) {
 			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);
 			filename = newfilename;
 		}
@@ -93,7 +93,7 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 			 * functions still return NULL, and we avoid the
 			 * unnecessary map__load warning.
 			 */
-			if (no_dso)
+			if (type != MAP__FUNCTION)
 				dso__set_loaded(dso, map->type);
 		}
 	}

commit cc8fae1d81648e85587f5d18b4f93e0b771fb02d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Dec 6 09:42:57 2013 +0200

    perf script: Add an option to print the source line number
    
    Add field 'srcline' that displays the source file name and line number
    associated with the sample ip.  The information displayed is the same as
    from addr2line.
    
     $ perf script -f comm,tid,pid,time,ip,sym,dso,symoff,srcline
                grep 10701/10701 2497321.421013:  ffffffff81043ffa native_write_msr_safe+0xa ([kernel.kallsyms])
      /usr/src/debug/kernel-3.9.fc17/linux-3.9.10-100.fc17.x86_64/arch/x86/include/asm/msr.h:95
                grep 10701/10701 2497321.421984:  ffffffff8165b6b3 _raw_spin_lock+0x13 ([kernel.kallsyms])
      /usr/src/debug/kernel-3.9.fc17/linux-3.9.10-100.fc17.x86_64/arch/x86/include/asm/spinlock.h:54
                grep 10701/10701 2497321.421990:  ffffffff810b64b3 tick_sched_timer+0x53 ([kernel.kallsyms])
      /usr/src/debug/kernel-3.9.fc17/linux-3.9.10-100.fc17.x86_64/kernel/time/tick-sched.c:840
                grep 10701/10701 2497321.421992:  ffffffff8106f63f run_timer_softirq+0x2f ([kernel.kallsyms])
      /usr/src/debug/kernel-3.9.fc17/linux-3.9.10-100.fc17.x86_64/kernel/timer.c:1372
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1386315778-11633-3-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ef5bc913ca7a..9b9bd719aa19 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -11,6 +11,7 @@
 #include "strlist.h"
 #include "vdso.h"
 #include "build-id.h"
+#include "util.h"
 #include <linux/string.h>
 
 const char *map_type__name[MAP__NR_TYPES] = {
@@ -252,6 +253,22 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 	return fprintf(fp, "%s", dsoname);
 }
 
+int map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,
+			 FILE *fp)
+{
+	char *srcline;
+	int ret = 0;
+
+	if (map && map->dso) {
+		srcline = get_srcline(map->dso,
+				      map__rip_2objdump(map, addr));
+		if (srcline != SRCLINE_UNKNOWN)
+			ret = fprintf(fp, "%s%s", prefix, srcline);
+		free_srcline(srcline);
+	}
+	return ret;
+}
+
 /**
  * map__rip_2objdump - convert symbol start address to objdump address.
  * @map: memory map

commit 1d5077bdd9a10c4297cded139989bb9ee2998a6c
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Oct 14 13:43:44 2013 +0300

    perf annotate: Another fix for annotate_browser__callq()
    
    The target address is provided by objdump and is not necessary a memory
    address.  Add a helper to get the correct address.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1381747424-3557-8-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9dea404de3fa..ef5bc913ca7a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -252,10 +252,16 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 	return fprintf(fp, "%s", dsoname);
 }
 
-/*
+/**
+ * map__rip_2objdump - convert symbol start address to objdump address.
+ * @map: memory map
+ * @rip: symbol start address
+ *
  * objdump wants/reports absolute IPs for ET_EXEC, and RIPs for ET_DYN.
  * map->dso->adjust_symbols==1 for ET_EXEC-like cases except ET_REL which is
  * relative to section start.
+ *
+ * Return: Address suitable for passing to "objdump --start-address="
  */
 u64 map__rip_2objdump(struct map *map, u64 rip)
 {
@@ -268,6 +274,29 @@ u64 map__rip_2objdump(struct map *map, u64 rip)
 	return map->unmap_ip(map, rip);
 }
 
+/**
+ * map__objdump_2mem - convert objdump address to a memory address.
+ * @map: memory map
+ * @ip: objdump address
+ *
+ * Closely related to map__rip_2objdump(), this function takes an address from
+ * objdump and converts it to a memory address.  Note this assumes that @map
+ * contains the address.  To be sure the result is valid, check it forwards
+ * e.g. map__rip_2objdump(map->map_ip(map, map__objdump_2mem(map, ip))) == ip
+ *
+ * Return: Memory address.
+ */
+u64 map__objdump_2mem(struct map *map, u64 ip)
+{
+	if (!map->dso->adjust_symbols)
+		return map->unmap_ip(map, ip);
+
+	if (map->dso->rel)
+		return map->unmap_ip(map, ip + map->pgoff);
+
+	return ip;
+}
+
 void map_groups__init(struct map_groups *mg)
 {
 	int i;

commit 4e987712740a3634c19a6fedaf12577b26775dc5
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 14 13:43:38 2013 +0300

    perf symbols: Add map_groups__find_ams()
    
    Add a function to find a symbol using an ip that might be on a different
    map.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1381747424-3557-2-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 17ee458a0870..9dea404de3fa 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -371,6 +371,23 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 	return NULL;
 }
 
+int map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)
+{
+	if (ams->addr < ams->map->start || ams->addr > ams->map->end) {
+		if (ams->map->groups == NULL)
+			return -1;
+		ams->map = map_groups__find(ams->map->groups, ams->map->type,
+					    ams->addr);
+		if (ams->map == NULL)
+			return -1;
+	}
+
+	ams->al_addr = ams->map->map_ip(ams->map, ams->addr);
+	ams->sym = map__find_symbol(ams->map, ams->al_addr, filter);
+
+	return ams->sym ? 0 : -1;
+}
+
 size_t __map_groups__fprintf_maps(struct map_groups *mg,
 				  enum map_type type, int verbose, FILE *fp)
 {

commit 89fe808ae777728da6e1d78b7d13562792310d17
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Sep 30 12:07:11 2013 +0200

    tools/perf: Standardize feature support define names to: HAVE_{FEATURE}_SUPPORT
    
    Standardize all the feature flags based on the HAVE_{FEATURE}_SUPPORT naming convention:
    
                    HAVE_ARCH_X86_64_SUPPORT
                    HAVE_BACKTRACE_SUPPORT
                    HAVE_CPLUS_DEMANGLE_SUPPORT
                    HAVE_DWARF_SUPPORT
                    HAVE_ELF_GETPHDRNUM_SUPPORT
                    HAVE_GTK2_SUPPORT
                    HAVE_GTK_INFO_BAR_SUPPORT
                    HAVE_LIBAUDIT_SUPPORT
                    HAVE_LIBELF_MMAP_SUPPORT
                    HAVE_LIBELF_SUPPORT
                    HAVE_LIBNUMA_SUPPORT
                    HAVE_LIBUNWIND_SUPPORT
                    HAVE_ON_EXIT_SUPPORT
                    HAVE_PERF_REGS_SUPPORT
                    HAVE_SLANG_SUPPORT
                    HAVE_STRLCPY_SUPPORT
    
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lkml.kernel.org/n/tip-u3zvqejddfZhtrbYbfhi3spa@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4f6680d2043b..17ee458a0870 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -172,7 +172,7 @@ int map__load(struct map *map, symbol_filter_t filter)
 		pr_warning(", continuing without symbols\n");
 		return -1;
 	} else if (nr == 0) {
-#ifdef LIBELF_SUPPORT
+#ifdef HAVE_LIBELF_SUPPORT
 		const size_t len = strlen(name);
 		const size_t real_len = len - sizeof(DSO__DELETED);
 

commit 5c5e854bc760a2e2c878df3cfcf2afa4febcd511
Author: Stephane Eranian <eranian@google.com>
Date:   Wed Aug 21 12:10:25 2013 +0200

    perf tools: Add attr->mmap2 support
    
    This patch adds support for the new PERF_RECORD_MMAP2 record type
    exposed by the kernel. This is an extended PERF_RECORD_MMAP record.
    
    It adds for each file-backed mapping the device major, minor number and
    the inode number and generation.
    
    This triplet uniquely identifies the source of a file-backed mapping. It
    can be used to detect identical virtual mappings between processes, for
    instance.
    
    The patch will prefer MMAP2 over MMAP.
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1377079825-19057-3-git-send-email-eranian@google.com
    [ Cope with 314add6 "Change machine__findnew_thread() to set thread pid",
      fix 'perf test' regression test entry affected,
      use perf_missing_features.mmap2 to fallback to not using .mmap2 in older kernels,
      so that new tools can work with kernels where this feature is not present ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9e8304ca343e..4f6680d2043b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -48,7 +48,8 @@ void map__init(struct map *map, enum map_type type,
 }
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
-		     u64 pgoff, u32 pid, char *filename,
+		     u64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,
+		     u64 ino_gen, char *filename,
 		     enum map_type type)
 {
 	struct map *map = malloc(sizeof(*map));
@@ -62,6 +63,11 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
 
+		map->maj = d_maj;
+		map->min = d_min;
+		map->ino = ino;
+		map->ino_generation = ino_gen;
+
 		if (anon) {
 			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);
 			filename = newfilename;

commit 8e0cf965f95edd41df11cca50b92b4cb6ea8d80a
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Aug 7 14:38:51 2013 +0300

    perf symbols: Add support for reading from /proc/kcore
    
    In the absence of vmlinux, perf tools uses kallsyms for symbols.  If the
    user has access, now also map to /proc/kcore.
    
    The dso data_type is now set to either DSO_BINARY_TYPE__KCORE or
    DSO_BINARY_TYPE__GUEST_KCORE as approprite.
    
    This patch breaks the "vmlinux symtab matches kallsyms" test.  That is
    fixed in a following patch.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1375875537-4509-8-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4d599febfb0b..9e8304ca343e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -555,3 +555,21 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 
 	return NULL;
 }
+
+struct map *maps__first(struct rb_root *maps)
+{
+	struct rb_node *first = rb_first(maps);
+
+	if (first)
+		return rb_entry(first, struct map, rb_node);
+	return NULL;
+}
+
+struct map *maps__next(struct map *map)
+{
+	struct rb_node *next = rb_next(&map->rb_node);
+
+	if (next)
+		return rb_entry(next, struct map, rb_node);
+	return NULL;
+}

commit 0131c4ec794a7409eafff0c79105309540aaca4d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Aug 7 14:38:50 2013 +0300

    perf tools: Make it possible to read object code from kernel modules
    
    The new "object code reading" test shows that it is not possible to read
    object code from kernel modules.  That is because the mappings do not
    map to the dsos.  This patch fixes that.
    
    This involves identifying and flagging relocatable (ELF type ET_REL)
    files (e.g. kernel modules) for symbol adjustment and updating
    map__rip_2objdump() accordingly.  The kmodule parameter of
    dso__load_sym() is taken into use and the module map altered to map to
    the dso.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1375875537-4509-7-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 5f662a3a0163..4d599febfb0b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -248,14 +248,18 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 
 /*
  * objdump wants/reports absolute IPs for ET_EXEC, and RIPs for ET_DYN.
- * map->dso->adjust_symbols==1 for ET_EXEC-like cases.
+ * map->dso->adjust_symbols==1 for ET_EXEC-like cases except ET_REL which is
+ * relative to section start.
  */
 u64 map__rip_2objdump(struct map *map, u64 rip)
 {
-	u64 addr = map->dso->adjust_symbols ?
-			map->unmap_ip(map, rip) :	/* RIP -> IP */
-			rip;
-	return addr;
+	if (!map->dso->adjust_symbols)
+		return rip;
+
+	if (map->dso->rel)
+		return rip - map->pgoff;
+
+	return map->unmap_ip(map, rip);
 }
 
 void map_groups__init(struct map_groups *mg)

commit 39b12f7812710e9a5896805d96812b3ede7491e8
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Aug 7 14:38:47 2013 +0300

    perf tools: Make it possible to read object code from vmlinux
    
    The new "object code reading" test shows that it is not possible to read
    object code from vmlinux.  That is because the mappings do not map to
    the dso.  This patch fixes that.
    
    A side-effect of changing the kernel map is that the "reloc" offset must
    be taken into account.  As a result of that separate map functions for
    relocation are no longer needed.
    
    Also fixing up the maps to match the symbols no longer makes sense and
    so is not done.
    
    The vmlinux dso data_type is now set to either DSO_BINARY_TYPE__VMLINUX
    or DSO_BINARY_TYPE__GUEST_VMLINUX as approprite, which enables the
    correct file name to be determined by dso__binary_type_file().
    
    This patch breaks the "vmlinux symtab matches kallsyms" test.  That is
    fixed in a following patch.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1375875537-4509-4-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 8bcdf9e54089..5f662a3a0163 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -182,12 +182,6 @@ int map__load(struct map *map, symbol_filter_t filter)
 #endif
 		return -1;
 	}
-	/*
-	 * Only applies to the kernel, as its symtabs aren't relative like the
-	 * module ones.
-	 */
-	if (map->dso->kernel)
-		map__reloc_vmlinux(map);
 
 	return 0;
 }
@@ -513,35 +507,6 @@ int map_groups__clone(struct map_groups *mg,
 	return 0;
 }
 
-static u64 map__reloc_map_ip(struct map *map, u64 ip)
-{
-	return ip + (s64)map->pgoff;
-}
-
-static u64 map__reloc_unmap_ip(struct map *map, u64 ip)
-{
-	return ip - (s64)map->pgoff;
-}
-
-void map__reloc_vmlinux(struct map *map)
-{
-	struct kmap *kmap = map__kmap(map);
-	s64 reloc;
-
-	if (!kmap->ref_reloc_sym || !kmap->ref_reloc_sym->unrelocated_addr)
-		return;
-
-	reloc = (kmap->ref_reloc_sym->unrelocated_addr -
-		 kmap->ref_reloc_sym->addr);
-
-	if (!reloc)
-		return;
-
-	map->map_ip   = map__reloc_map_ip;
-	map->unmap_ip = map__reloc_unmap_ip;
-	map->pgoff    = reloc;
-}
-
 void maps__insert(struct rb_root *maps, struct map *map)
 {
 	struct rb_node **p = &maps->rb_node;

commit 89365e6c9ad4c0e090e4c6a4b67a3ce319381d89
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Apr 24 17:03:02 2013 -0700

    perf tools: Handle JITed code in shared memory
    
    Need to check for /dev/zero.
    
    Most likely more strings are missing too.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1366848182-30449-1-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6fcb9de62340..8bcdf9e54089 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -21,6 +21,7 @@ const char *map_type__name[MAP__NR_TYPES] = {
 static inline int is_anon_memory(const char *filename)
 {
 	return !strcmp(filename, "//anon") ||
+	       !strcmp(filename, "/dev/zero (deleted)") ||
 	       !strcmp(filename, "/anon_hugepage (deleted)");
 }
 

commit 8e16017d497e9bb37c8c3c5ed1edb8d6adeebf3a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jan 24 22:16:43 2013 -0300

    perf tools: Use memdup in map__clone
    
    We have memdup() exactly for that, remove open coded dup.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-tnsoexrgv6u9l125srq2c7su@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b6b163642c7d..6fcb9de62340 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -11,6 +11,7 @@
 #include "strlist.h"
 #include "vdso.h"
 #include "build-id.h"
+#include <linux/string.h>
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
@@ -213,12 +214,7 @@ struct symbol *map__find_symbol_by_name(struct map *map, const char *name,
 
 struct map *map__clone(struct map *map)
 {
-	struct map *clone = malloc(sizeof(*clone));
-
-	if (clone != NULL)
-		memcpy(clone, map, sizeof(*clone));
-
-	return clone;
+	return memdup(map, sizeof(*map));
 }
 
 int map__overlap(struct map *l, struct map *r)

commit 237a7e04a1a4461843a998fae78517dbbd08602e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jan 24 21:59:59 2013 -0300

    perf tools: Stop using 'self' in map.[ch]
    
    As suggested by tglx, 'self' should be replaced by something that is
    more useful.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-vse2c54m0yahx6p79tmoel03@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ff94425779a2..b6b163642c7d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -29,29 +29,29 @@ static inline int is_no_dso_memory(const char *filename)
 	       !strcmp(filename, "[heap]");
 }
 
-void map__init(struct map *self, enum map_type type,
+void map__init(struct map *map, enum map_type type,
 	       u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
-	self->type     = type;
-	self->start    = start;
-	self->end      = end;
-	self->pgoff    = pgoff;
-	self->dso      = dso;
-	self->map_ip   = map__map_ip;
-	self->unmap_ip = map__unmap_ip;
-	RB_CLEAR_NODE(&self->rb_node);
-	self->groups   = NULL;
-	self->referenced = false;
-	self->erange_warned = false;
+	map->type     = type;
+	map->start    = start;
+	map->end      = end;
+	map->pgoff    = pgoff;
+	map->dso      = dso;
+	map->map_ip   = map__map_ip;
+	map->unmap_ip = map__unmap_ip;
+	RB_CLEAR_NODE(&map->rb_node);
+	map->groups   = NULL;
+	map->referenced = false;
+	map->erange_warned = false;
 }
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		     u64 pgoff, u32 pid, char *filename,
 		     enum map_type type)
 {
-	struct map *self = malloc(sizeof(*self));
+	struct map *map = malloc(sizeof(*map));
 
-	if (self != NULL) {
+	if (map != NULL) {
 		char newfilename[PATH_MAX];
 		struct dso *dso;
 		int anon, no_dso, vdso;
@@ -74,10 +74,10 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		if (dso == NULL)
 			goto out_delete;
 
-		map__init(self, type, start, start + len, pgoff, dso);
+		map__init(map, type, start, start + len, pgoff, dso);
 
 		if (anon || no_dso) {
-			self->map_ip = self->unmap_ip = identity__map_ip;
+			map->map_ip = map->unmap_ip = identity__map_ip;
 
 			/*
 			 * Set memory without DSO as loaded. All map__find_*
@@ -85,12 +85,12 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 			 * unnecessary map__load warning.
 			 */
 			if (no_dso)
-				dso__set_loaded(dso, self->type);
+				dso__set_loaded(dso, map->type);
 		}
 	}
-	return self;
+	return map;
 out_delete:
-	free(self);
+	free(map);
 	return NULL;
 }
 
@@ -113,48 +113,48 @@ struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
 	return map;
 }
 
-void map__delete(struct map *self)
+void map__delete(struct map *map)
 {
-	free(self);
+	free(map);
 }
 
-void map__fixup_start(struct map *self)
+void map__fixup_start(struct map *map)
 {
-	struct rb_root *symbols = &self->dso->symbols[self->type];
+	struct rb_root *symbols = &map->dso->symbols[map->type];
 	struct rb_node *nd = rb_first(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
-		self->start = sym->start;
+		map->start = sym->start;
 	}
 }
 
-void map__fixup_end(struct map *self)
+void map__fixup_end(struct map *map)
 {
-	struct rb_root *symbols = &self->dso->symbols[self->type];
+	struct rb_root *symbols = &map->dso->symbols[map->type];
 	struct rb_node *nd = rb_last(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
-		self->end = sym->end;
+		map->end = sym->end;
 	}
 }
 
 #define DSO__DELETED "(deleted)"
 
-int map__load(struct map *self, symbol_filter_t filter)
+int map__load(struct map *map, symbol_filter_t filter)
 {
-	const char *name = self->dso->long_name;
+	const char *name = map->dso->long_name;
 	int nr;
 
-	if (dso__loaded(self->dso, self->type))
+	if (dso__loaded(map->dso, map->type))
 		return 0;
 
-	nr = dso__load(self->dso, self, filter);
+	nr = dso__load(map->dso, map, filter);
 	if (nr < 0) {
-		if (self->dso->has_build_id) {
+		if (map->dso->has_build_id) {
 			char sbuild_id[BUILD_ID_SIZE * 2 + 1];
 
-			build_id__sprintf(self->dso->build_id,
-					  sizeof(self->dso->build_id),
+			build_id__sprintf(map->dso->build_id,
+					  sizeof(map->dso->build_id),
 					  sbuild_id);
 			pr_warning("%s with build id %s not found",
 				   name, sbuild_id);
@@ -184,43 +184,41 @@ int map__load(struct map *self, symbol_filter_t filter)
 	 * Only applies to the kernel, as its symtabs aren't relative like the
 	 * module ones.
 	 */
-	if (self->dso->kernel)
-		map__reloc_vmlinux(self);
+	if (map->dso->kernel)
+		map__reloc_vmlinux(map);
 
 	return 0;
 }
 
-struct symbol *map__find_symbol(struct map *self, u64 addr,
+struct symbol *map__find_symbol(struct map *map, u64 addr,
 				symbol_filter_t filter)
 {
-	if (map__load(self, filter) < 0)
+	if (map__load(map, filter) < 0)
 		return NULL;
 
-	return dso__find_symbol(self->dso, self->type, addr);
+	return dso__find_symbol(map->dso, map->type, addr);
 }
 
-struct symbol *map__find_symbol_by_name(struct map *self, const char *name,
+struct symbol *map__find_symbol_by_name(struct map *map, const char *name,
 					symbol_filter_t filter)
 {
-	if (map__load(self, filter) < 0)
+	if (map__load(map, filter) < 0)
 		return NULL;
 
-	if (!dso__sorted_by_name(self->dso, self->type))
-		dso__sort_by_name(self->dso, self->type);
+	if (!dso__sorted_by_name(map->dso, map->type))
+		dso__sort_by_name(map->dso, map->type);
 
-	return dso__find_symbol_by_name(self->dso, self->type, name);
+	return dso__find_symbol_by_name(map->dso, map->type, name);
 }
 
-struct map *map__clone(struct map *self)
+struct map *map__clone(struct map *map)
 {
-	struct map *map = malloc(sizeof(*self));
+	struct map *clone = malloc(sizeof(*clone));
 
-	if (!map)
-		return NULL;
+	if (clone != NULL)
+		memcpy(clone, map, sizeof(*clone));
 
-	memcpy(map, self, sizeof(*self));
-
-	return map;
+	return clone;
 }
 
 int map__overlap(struct map *l, struct map *r)
@@ -237,10 +235,10 @@ int map__overlap(struct map *l, struct map *r)
 	return 0;
 }
 
-size_t map__fprintf(struct map *self, FILE *fp)
+size_t map__fprintf(struct map *map, FILE *fp)
 {
 	return fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",
-		       self->start, self->end, self->pgoff, self->dso->name);
+		       map->start, map->end, map->pgoff, map->dso->name);
 }
 
 size_t map__fprintf_dsoname(struct map *map, FILE *fp)
@@ -528,9 +526,9 @@ static u64 map__reloc_unmap_ip(struct map *map, u64 ip)
 	return ip - (s64)map->pgoff;
 }
 
-void map__reloc_vmlinux(struct map *self)
+void map__reloc_vmlinux(struct map *map)
 {
-	struct kmap *kmap = map__kmap(self);
+	struct kmap *kmap = map__kmap(map);
 	s64 reloc;
 
 	if (!kmap->ref_reloc_sym || !kmap->ref_reloc_sym->unrelocated_addr)
@@ -542,9 +540,9 @@ void map__reloc_vmlinux(struct map *self)
 	if (!reloc)
 		return;
 
-	self->map_ip   = map__reloc_map_ip;
-	self->unmap_ip = map__reloc_unmap_ip;
-	self->pgoff    = reloc;
+	map->map_ip   = map__reloc_map_ip;
+	map->unmap_ip = map__reloc_unmap_ip;
+	map->pgoff    = reloc;
 }
 
 void maps__insert(struct rb_root *maps, struct map *map)
@@ -567,9 +565,9 @@ void maps__insert(struct rb_root *maps, struct map *map)
 	rb_insert_color(&map->rb_node, maps);
 }
 
-void maps__remove(struct rb_root *self, struct map *map)
+void maps__remove(struct rb_root *maps, struct map *map)
 {
-	rb_erase(&map->rb_node, self);
+	rb_erase(&map->rb_node, maps);
 }
 
 struct map *maps__find(struct rb_root *maps, u64 ip)

commit d0528b5d71faf612014dd7672e44225c915344b2
Author: Joshua Zhu <zhu.wen-jie@hp.com>
Date:   Sat Jan 5 13:29:57 2013 +0800

    perf tools: Add anonymous huge page recognition
    
    Judging anonymous memory's vm_area_struct, perf_mmap_event's filename
    will be set to "//anon" indicating this vma belongs to anonymous
    memory.
    
    Once hugepage is used, vma's vm_file points to hugetlbfs. In this way,
    this vma will not be regarded as anonymous memory by is_anon_memory() in
    perf user space utility.
    
    Signed-off-by: Joshua Zhu <zhu.wen-jie@hp.com>
    Cc: Akihiro Nagai <akihiro.nagai.hw@hitachi.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Joshua Zhu <zhu.wen-jie@hp.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1357363797-3550-1-git-send-email-zhu.wen-jie@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 0328d45c4f2a..ff94425779a2 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -19,7 +19,8 @@ const char *map_type__name[MAP__NR_TYPES] = {
 
 static inline int is_anon_memory(const char *filename)
 {
-	return strcmp(filename, "//anon") == 0;
+	return !strcmp(filename, "//anon") ||
+	       !strcmp(filename, "/anon_hugepage (deleted)");
 }
 
 static inline int is_no_dso_memory(const char *filename)

commit 69d2591a829132492662bbfe164fcde5e44ad1c4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 9 11:32:52 2012 -0300

    perf machine: Move more methods to machine.[ch]
    
    This time out of map.[ch] mostly, just code move plus a buch of 'self'
    removal, using machine or machines instead.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-j1vtux3vnu6wzmrjutpxnjcz@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 579187865f08..0328d45c4f2a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -590,182 +590,3 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 
 	return NULL;
 }
-
-int machine__init(struct machine *self, const char *root_dir, pid_t pid)
-{
-	map_groups__init(&self->kmaps);
-	RB_CLEAR_NODE(&self->rb_node);
-	INIT_LIST_HEAD(&self->user_dsos);
-	INIT_LIST_HEAD(&self->kernel_dsos);
-
-	self->threads = RB_ROOT;
-	INIT_LIST_HEAD(&self->dead_threads);
-	self->last_match = NULL;
-
-	self->kmaps.machine = self;
-	self->pid	    = pid;
-	self->root_dir      = strdup(root_dir);
-	if (self->root_dir == NULL)
-		return -ENOMEM;
-
-	if (pid != HOST_KERNEL_ID) {
-		struct thread *thread = machine__findnew_thread(self, pid);
-		char comm[64];
-
-		if (thread == NULL)
-			return -ENOMEM;
-
-		snprintf(comm, sizeof(comm), "[guest/%d]", pid);
-		thread__set_comm(thread, comm);
-	}
-
-	return 0;
-}
-
-static void dsos__delete(struct list_head *self)
-{
-	struct dso *pos, *n;
-
-	list_for_each_entry_safe(pos, n, self, node) {
-		list_del(&pos->node);
-		dso__delete(pos);
-	}
-}
-
-void machine__exit(struct machine *self)
-{
-	map_groups__exit(&self->kmaps);
-	dsos__delete(&self->user_dsos);
-	dsos__delete(&self->kernel_dsos);
-	free(self->root_dir);
-	self->root_dir = NULL;
-}
-
-void machine__delete(struct machine *self)
-{
-	machine__exit(self);
-	free(self);
-}
-
-struct machine *machines__add(struct rb_root *self, pid_t pid,
-			      const char *root_dir)
-{
-	struct rb_node **p = &self->rb_node;
-	struct rb_node *parent = NULL;
-	struct machine *pos, *machine = malloc(sizeof(*machine));
-
-	if (!machine)
-		return NULL;
-
-	if (machine__init(machine, root_dir, pid) != 0) {
-		free(machine);
-		return NULL;
-	}
-
-	while (*p != NULL) {
-		parent = *p;
-		pos = rb_entry(parent, struct machine, rb_node);
-		if (pid < pos->pid)
-			p = &(*p)->rb_left;
-		else
-			p = &(*p)->rb_right;
-	}
-
-	rb_link_node(&machine->rb_node, parent, p);
-	rb_insert_color(&machine->rb_node, self);
-
-	return machine;
-}
-
-struct machine *machines__find(struct rb_root *self, pid_t pid)
-{
-	struct rb_node **p = &self->rb_node;
-	struct rb_node *parent = NULL;
-	struct machine *machine;
-	struct machine *default_machine = NULL;
-
-	while (*p != NULL) {
-		parent = *p;
-		machine = rb_entry(parent, struct machine, rb_node);
-		if (pid < machine->pid)
-			p = &(*p)->rb_left;
-		else if (pid > machine->pid)
-			p = &(*p)->rb_right;
-		else
-			return machine;
-		if (!machine->pid)
-			default_machine = machine;
-	}
-
-	return default_machine;
-}
-
-struct machine *machines__findnew(struct rb_root *self, pid_t pid)
-{
-	char path[PATH_MAX];
-	const char *root_dir = "";
-	struct machine *machine = machines__find(self, pid);
-
-	if (machine && (machine->pid == pid))
-		goto out;
-
-	if ((pid != HOST_KERNEL_ID) &&
-	    (pid != DEFAULT_GUEST_KERNEL_ID) &&
-	    (symbol_conf.guestmount)) {
-		sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
-		if (access(path, R_OK)) {
-			static struct strlist *seen;
-
-			if (!seen)
-				seen = strlist__new(true, NULL);
-
-			if (!strlist__has_entry(seen, path)) {
-				pr_err("Can't access file %s\n", path);
-				strlist__add(seen, path);
-			}
-			machine = NULL;
-			goto out;
-		}
-		root_dir = path;
-	}
-
-	machine = machines__add(self, pid, root_dir);
-
-out:
-	return machine;
-}
-
-void machines__process(struct rb_root *self, machine__process_t process, void *data)
-{
-	struct rb_node *nd;
-
-	for (nd = rb_first(self); nd; nd = rb_next(nd)) {
-		struct machine *pos = rb_entry(nd, struct machine, rb_node);
-		process(pos, data);
-	}
-}
-
-char *machine__mmap_name(struct machine *self, char *bf, size_t size)
-{
-	if (machine__is_host(self))
-		snprintf(bf, size, "[%s]", "kernel.kallsyms");
-	else if (machine__is_default_guest(self))
-		snprintf(bf, size, "[%s]", "guest.kernel.kallsyms");
-	else
-		snprintf(bf, size, "[%s.%d]", "guest.kernel.kallsyms", self->pid);
-
-	return bf;
-}
-
-void machines__set_id_hdr_size(struct rb_root *machines, u16 id_hdr_size)
-{
-	struct rb_node *node;
-	struct machine *machine;
-
-	for (node = rb_first(machines); node; node = rb_next(node)) {
-		machine = rb_entry(node, struct machine, rb_node);
-		machine->id_hdr_size = id_hdr_size;
-	}
-
-	return;
-}

commit 1e82574d1db1451f137cb520f21b9176f05284c9
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Nov 7 16:27:11 2012 +0900

    perf tools: Fix detection of stack area
    
    Output of /proc/<pid>/maps contains helpful information to anonymous
    mappings like stack, heap, ...  For the case of stack, it can show
    multiple stack area for each thread in the process:
    
      $ cat /proc/$(pidof gnome-shell)/maps | grep stack
      7fe019946000-7fe01a146000 rw-p 00000000 00:00 0          [stack:1624]
      7fe040e32000-7fe041632000 rw-p 00000000 00:00 0          [stack:1451]
      7fe041643000-7fe041e43000 rw-p 00000000 00:00 0          [stack:1450]
      7fe04204b000-7fe04284b000 rw-p 00000000 00:00 0          [stack:1449]
      7fe042a7e000-7fe04327e000 rw-p 00000000 00:00 0          [stack:1446]
      7fe0432ff000-7fe043aff000 rw-p 00000000 00:00 0          [stack:1445]
      7fe043b00000-7fe044300000 rw-p 00000000 00:00 0          [stack:1444]
      7fe044301000-7fe044b01000 rw-p 00000000 00:00 0          [stack:1443]
      7fe044b02000-7fe045302000 rw-p 00000000 00:00 0          [stack:1442]
      7fe045303000-7fe045b03000 rw-p 00000000 00:00 0          [stack:1441]
      7fe045b04000-7fe046304000 rw-p 00000000 00:00 0          [stack:1440]
      7fe046305000-7fe046b05000 rw-p 00000000 00:00 0          [stack:1439]
      7fe046b06000-7fe047306000 rw-p 00000000 00:00 0          [stack:1438]
      7fff4b16f000-7fff4b190000 rw-p 00000000 00:00 0          [stack]
    
    However perf only knew about the main thread's.  Fix it.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1352273234-28912-4-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9b40c444039c..579187865f08 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -24,7 +24,7 @@ static inline int is_anon_memory(const char *filename)
 
 static inline int is_no_dso_memory(const char *filename)
 {
-	return !strcmp(filename, "[stack]") ||
+	return !strncmp(filename, "[stack", 6) ||
 	       !strcmp(filename, "[heap]");
 }
 

commit ebb296c276ca19798c3116220eb8d0b2c0975ae0
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Sat Oct 27 23:18:28 2012 +0200

    perf tools: Move build_id__sprintf into build-id object
    
    Moving build_id__sprintf function into build-id object.
    
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1351372712-21104-2-git-send-email-jolsa@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 6109fa4d14cd..9b40c444039c 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -10,6 +10,7 @@
 #include "thread.h"
 #include "strlist.h"
 #include "vdso.h"
+#include "build-id.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",

commit 29a0fc9b2b6084e7a8810481df62a0fa496d8957
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Fri Sep 28 18:31:59 2012 +0900

    perf tools: Convert to LIBELF_SUPPORT
    
    For building perf without libelf, we can set NO_LIBELF=1 as a argument
    of make.  It then defines NO_LIBELF_SUPPORT macro for C code to do the
    proper handling.  However it usually used in a negative semantics -
    e.g. #ifndef - so we saw double negations which can be misleading.
    Convert it to a positive form to make it more readable.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1348824728-14025-4-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ead5316b3f89..6109fa4d14cd 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -162,7 +162,7 @@ int map__load(struct map *self, symbol_filter_t filter)
 		pr_warning(", continuing without symbols\n");
 		return -1;
 	} else if (nr == 0) {
-#ifndef NO_LIBELF_SUPPORT
+#ifdef LIBELF_SUPPORT
 		const size_t len = strlen(name);
 		const size_t real_len = len - sizeof(DSO__DELETED);
 

commit 8f28f19a87cb48d13570ba774a3e85776eb36bb4
Author: Feng Tang <feng.tang@intel.com>
Date:   Mon Aug 27 15:38:26 2012 +0800

    perf tools: Fix a compiling error in util/map.c
    
    This patch fix a compile warning taken as error:
    
            CC util/map.o
            cc1: warnings being treated as errors
            util/map.c: In function map__fprintf_dsoname:
            util/map.c:240: error: dsoname may be used uninitialized in this function
            make: *** [util/map.o] Error 1
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1346053107-11946-3-git-send-email-feng.tang@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index b442ee49452b..ead5316b3f89 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -243,15 +243,14 @@ size_t map__fprintf(struct map *self, FILE *fp)
 
 size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 {
-	const char *dsoname;
+	const char *dsoname = "[unknown]";
 
 	if (map && map->dso && (map->dso->name || map->dso->long_name)) {
 		if (symbol_conf.show_kernel_path && map->dso->long_name)
 			dsoname = map->dso->long_name;
 		else if (map->dso->name)
 			dsoname = map->dso->name;
-	} else
-		dsoname = "[unknown]";
+	}
 
 	return fprintf(fp, "%s", dsoname);
 }

commit 7dbf4dcfe2987c35c2c4675cd7ae1b6006979176
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Mon Sep 10 18:50:19 2012 +0200

    perf tools: Back [vdso] DSO with real data
    
    Storing data for VDSO shared object, because we need it for the post
    unwind processing.
    
    The VDSO shared object is same for all process on a running system, so
    it makes no difference when we store it inside the tracer - perf.
    
    When [vdso] map memory is hit, we retrieve [vdso] DSO image and store it
    into temporary file.
    
    During the build-id processing phase, the [vdso] DSO image is stored in
    build-id db, and build-id reference is made inside perf.data. The
    build-id vdso file object is called '[vdso]'. We don't use temporary
    file name which gets removed when record is finished.
    
    During report phase the vdso build-id object is treated as any other
    build-id DSO object.
    
    Adding following API for vdso object:
    
      bool is_vdso_map(const char *filename)
        - returns true if the filename matches vdso map name
    
      struct dso *vdso__dso_findnew(struct list_head *head)
        - find/create proper vdso DSO object
    
      vdso__exit(void)
        - removes temporary VDSO image if there's any
    
    This change makes backtrace dwarf post unwind possible from [vdso] maps.
    
    Following output is current report of [vdso] sample dwarf backtrace:
    
      # Overhead  Command      Shared Object                         Symbol
      # ........  .......  .................  .............................
      #
          99.52%       ex  [vdso]             [.] 0x00007fff3ace89af
                       |
                       --- 0x7fff3ace89af
    
    Following output is new report of [vdso] sample dwarf backtrace:
    
      # Overhead  Command      Shared Object                         Symbol
      # ........  .......  .................  .............................
      #
          99.52%       ex  [vdso]             [.] 0x00000000000009af
                       |
                       --- 0x7fff3ace89af
                           main
                           __libc_start_main
                           _start
    
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1347295819-23177-5-git-send-email-jolsa@redhat.com
    [ committer note: s/ALIGN/PERF_ALIGN/g to cope with the android build changes ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 7d37159c1e99..b442ee49452b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -9,6 +9,7 @@
 #include "map.h"
 #include "thread.h"
 #include "strlist.h"
+#include "vdso.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
@@ -23,7 +24,6 @@ static inline int is_anon_memory(const char *filename)
 static inline int is_no_dso_memory(const char *filename)
 {
 	return !strcmp(filename, "[stack]") ||
-	       !strcmp(filename, "[vdso]")  ||
 	       !strcmp(filename, "[heap]");
 }
 
@@ -52,9 +52,10 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 	if (self != NULL) {
 		char newfilename[PATH_MAX];
 		struct dso *dso;
-		int anon, no_dso;
+		int anon, no_dso, vdso;
 
 		anon = is_anon_memory(filename);
+		vdso = is_vdso_map(filename);
 		no_dso = is_no_dso_memory(filename);
 
 		if (anon) {
@@ -62,7 +63,12 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 			filename = newfilename;
 		}
 
-		dso = __dsos__findnew(dsos__list, filename);
+		if (vdso) {
+			pgoff = 0;
+			dso = vdso__dso_findnew(dsos__list);
+		} else
+			dso = __dsos__findnew(dsos__list, filename);
+
 		if (dso == NULL)
 			goto out_delete;
 

commit 0f75a710dfd8fd5cd9e558e3f26c474c8fa63e3c
Author: Cody P Schafer <cody@linux.vnet.ibm.com>
Date:   Fri Aug 10 15:22:50 2012 -0700

    perf symbols: Remove unused function map__objdump_2ip
    
    map__objdump_2ip was introduced in:
    
    ee11b90b12 perf top: Fix annotate for userspace
    
    And it's last user removed in:
    
    36532461a0 perf top: Ditch private annotation code, share perf annotate's
    
    Remove it.
    
    Signed-off-by: Cody P Schafer <cody@linux.vnet.ibm.com>
    Cc: David Hansen <dave@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Hellsley <matthltc@us.ibm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1344637382-22789-5-git-send-email-cody@linux.vnet.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 287cb3452b4b..7d37159c1e99 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -262,14 +262,6 @@ u64 map__rip_2objdump(struct map *map, u64 rip)
 	return addr;
 }
 
-u64 map__objdump_2ip(struct map *map, u64 addr)
-{
-	u64 ip = map->dso->adjust_symbols ?
-			addr :
-			map->unmap_ip(map, addr);	/* RIP -> IP */
-	return ip;
-}
-
 void map_groups__init(struct map_groups *mg)
 {
 	int i;

commit 393be2e3747ea3ef0d2e724115a5f42b2fa50dbd
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Mon Aug 6 13:41:21 2012 +0900

    perf symbols: Support minimal build without libelf
    
    Now we have isolated all ELF-specific stuff, it's possible to build
    without libelf. The output binary can do most of jobs but lacks (user
    level) symbol information - kernel symbols are still accessable thanks
    to the kallsyms.
    
    To build perf without libelf (elfutils), give NO_LIBELF=1 to make.
    
    For now, only 'perf probe' command is removed since it depends on
    libelf/libdw heavily.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1344228082-15569-4-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 115654c469c6..287cb3452b4b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -156,6 +156,7 @@ int map__load(struct map *self, symbol_filter_t filter)
 		pr_warning(", continuing without symbols\n");
 		return -1;
 	} else if (nr == 0) {
+#ifndef NO_LIBELF_SUPPORT
 		const size_t len = strlen(name);
 		const size_t real_len = len - sizeof(DSO__DELETED);
 
@@ -168,7 +169,7 @@ int map__load(struct map *self, symbol_filter_t filter)
 			pr_warning("no symbols found in %s, maybe install "
 				   "a debug package?\n", name);
 		}
-
+#endif
 		return -1;
 	}
 	/*

commit e5a1845fc0aeca85c98115980c3531129f87e18d
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Mon Aug 6 13:41:20 2012 +0900

    perf symbols: Split out util/symbol-elf.c
    
    Factor out the dependency of ELF handling into separate symbol-elf.c
    file. It is a preparation of building a minimalistic version perf tools
    which doesn't depend on the elfutils.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1344228082-15569-3-git-send-email-namhyung@kernel.org
    [ committer note: removed blank line at symbol-elf.c EOF ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index cc33486ad9e2..115654c469c6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -86,6 +86,25 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 	return NULL;
 }
 
+/*
+ * Constructor variant for modules (where we know from /proc/modules where
+ * they are loaded) and for vmlinux, where only after we load all the
+ * symbols we'll know where it starts and ends.
+ */
+struct map *map__new2(u64 start, struct dso *dso, enum map_type type)
+{
+	struct map *map = calloc(1, (sizeof(*map) +
+				     (dso->kernel ? sizeof(struct kmap) : 0)));
+	if (map != NULL) {
+		/*
+		 * ->end will be filled after we load all the symbols
+		 */
+		map__init(map, type, start, 0, 0, dso);
+	}
+
+	return map;
+}
+
 void map__delete(struct map *self)
 {
 	free(self);

commit c80c3c269011c67b8dabef5238af44a6d94e4d0e
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Jul 20 17:25:51 2012 -0600

    perf kvm: Limit repetitive guestmount message to once per directory
    
    After 7ed97ad use of the guestmount option without a subdir for *each*
    VM generates an error message for each sample related to that VM. Once
    per VM is enough.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1342826756-64663-7-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 16d783d322b6..cc33486ad9e2 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -8,6 +8,7 @@
 #include <unistd.h>
 #include "map.h"
 #include "thread.h"
+#include "strlist.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
@@ -695,7 +696,15 @@ struct machine *machines__findnew(struct rb_root *self, pid_t pid)
 	    (symbol_conf.guestmount)) {
 		sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
 		if (access(path, R_OK)) {
-			pr_err("Can't access file %s\n", path);
+			static struct strlist *seen;
+
+			if (!seen)
+				seen = strlist__new(true, NULL);
+
+			if (!strlist__has_entry(seen, path)) {
+				pr_err("Can't access file %s\n", path);
+				strlist__add(seen, path);
+			}
 			machine = NULL;
 			goto out;
 		}

commit adb5d2a487c55e5ca2ecc0b73c8f592e95d292c7
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Jul 20 17:25:49 2012 -0600

    perf kvm: Fix bug resolving guest kernel syms
    
    Guest kernel symbols are not resolved despite passing the information
    needed to resolve them. e.g.,
    
    perf kvm --guest --guestmount=/tmp/guest-mount record -a -- sleep 1
    perf kvm --guest --guestmount=/tmp/guest-mount report --stdio
    
        36.55%  [guest/11399]  [unknown]         [g] 0xffffffff81600bc8
        33.19%  [guest/10474]  [unknown]         [g] 0x00000000c0116e00
        30.26%  [guest/11094]  [unknown]         [g] 0xffffffff8100a288
        43.69%  [guest/10474]  [unknown]         [g] 0x00000000c0103d90
        37.38%  [guest/11399]  [unknown]         [g] 0xffffffff81600bc8
        12.24%  [guest/11094]  [unknown]         [g] 0xffffffff810aa91d
         6.69%  [guest/11094]  [unknown]         [u] 0x00007fa784d721c3
    
    which is just pathetic.
    
    After a maddening 2 days sifting through perf minutia I found it --
    id_hdr_size is not initialized for guest machines. This shows up on the
    report side as random garbage for the cpu and timestamp, e.g.,
    
    29816 7310572949125804849 0x1ac0 [0x50]: PERF_RECORD_MMAP ...
    
    That messes up the sample sorting such that synthesized guest maps are
    processed last.
    
    With this patch you get a much more helpful report:
    
      12.11%  [guest/11399]  [guest.kernel.kallsyms.11399]  [g] irqtime_account_process_tick
      10.58%  [guest/11399]  [guest.kernel.kallsyms.11399]  [g] run_timer_softirq
       6.95%  [guest/11094]  [guest.kernel.kallsyms.11094]  [g] printk_needs_cpu
       6.50%  [guest/11094]  [guest.kernel.kallsyms.11094]  [g] do_timer
       6.45%  [guest/11399]  [guest.kernel.kallsyms.11399]  [g] idle_balance
       4.90%  [guest/11094]  [guest.kernel.kallsyms.11094]  [g] native_read_tsc
        ...
    
    v2:
    - changed rbtree walk to use rb_first per Namhyung's suggestion
    
    Tested-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1342826756-64663-5-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 8668569d4b2a..16d783d322b6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -729,3 +729,16 @@ char *machine__mmap_name(struct machine *self, char *bf, size_t size)
 
 	return bf;
 }
+
+void machines__set_id_hdr_size(struct rb_root *machines, u16 id_hdr_size)
+{
+	struct rb_node *node;
+	struct machine *machine;
+
+	for (node = rb_first(machines); node; node = rb_next(node)) {
+		machine = rb_entry(node, struct machine, rb_node);
+		machine->id_hdr_size = id_hdr_size;
+	}
+
+	return;
+}

commit 5cd95c2db479aa7a66f6fa572dfa410c6314c78e
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Jul 20 17:25:47 2012 -0600

    perf kvm: Set name for VM process in guest machine
    
    COMM events are not generated in the context of a guest machine, so the
    thread name is never set for the VMM process. For example, the qemu-kvm
    name applies to the process in the host machine, not the guest machine.
    So, samples for guest machines are currently displayed as:
    
        99.67%     :5671  [unknown]         [g] 0xffffffff81366b41
    
    where 5671 is the pid of the VMM. With this patch the samples in the guest
    machine are shown as:
    
        18.43%  [guest/5671]  [unknown]           [g] 0xffffffff810d68b7
    
    Tested-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1342826756-64663-3-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a1f4e3669142..8668569d4b2a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -7,6 +7,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include "map.h"
+#include "thread.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
@@ -585,7 +586,21 @@ int machine__init(struct machine *self, const char *root_dir, pid_t pid)
 	self->kmaps.machine = self;
 	self->pid	    = pid;
 	self->root_dir      = strdup(root_dir);
-	return self->root_dir == NULL ? -ENOMEM : 0;
+	if (self->root_dir == NULL)
+		return -ENOMEM;
+
+	if (pid != HOST_KERNEL_ID) {
+		struct thread *thread = machine__findnew_thread(self, pid);
+		char comm[64];
+
+		if (thread == NULL)
+			return -ENOMEM;
+
+		snprintf(comm, sizeof(comm), "[guest/%d]", pid);
+		thread__set_comm(thread, comm);
+	}
+
+	return 0;
 }
 
 static void dsos__delete(struct list_head *self)

commit 7ed97ad41ffa94040dfd593948962a7e9e7b0db9
Author: David Ahern <dsahern@gmail.com>
Date:   Mon Jul 2 09:12:57 2012 -0600

    perf kvm: Fix segfault with report and mixed guestmount use
    
    Using the guestmount option on record:
        $ perf kvm --guest --host --guestmount=/tmp/guest-mount record -ag
    
    But not the subsequent report:
        $ perf kvm report
    
    causes a SEGFAULT in the usual place:
    (gdb) bt
    0  0x0000000000470356 in machine__mmap_name (self=0x0, bf=0x7fffffffbdb0 " z\370\367\377\177", size=
        4096) at util/map.c:712
    1  0x00000000004453e8 in perf_event__process_kernel_mmap (tool=0x7fffffffde10, event=0x7ffff7f87e38,
        machine=0x0) at util/event.c:550
    2  0x00000000004458c9 in perf_event__process_mmap (tool=0x7fffffffde10, event=0x7ffff7f87e38, sample=
        0x7fffffffd2a0, machine=0x0) at util/event.c:656
    3  0x00000000004733e0 in perf_session_deliver_event (session=0x91aca0, event=0x7ffff7f87e38, sample=
        0x7fffffffd2a0, tool=0x7fffffffde10, file_offset=7736) at util/session.c:979
    ...
    
    The MMAP events in this case already contain the full path to the
    module. No need to require it for the report path to.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1341241977-71535-1-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 35ae56864e4f..a1f4e3669142 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -669,25 +669,26 @@ struct machine *machines__find(struct rb_root *self, pid_t pid)
 struct machine *machines__findnew(struct rb_root *self, pid_t pid)
 {
 	char path[PATH_MAX];
-	const char *root_dir;
+	const char *root_dir = "";
 	struct machine *machine = machines__find(self, pid);
 
-	if (!machine || machine->pid != pid) {
-		if (pid == HOST_KERNEL_ID || pid == DEFAULT_GUEST_KERNEL_ID)
-			root_dir = "";
-		else {
-			if (!symbol_conf.guestmount)
-				goto out;
-			sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
-			if (access(path, R_OK)) {
-				pr_err("Can't access file %s\n", path);
-				goto out;
-			}
-			root_dir = path;
+	if (machine && (machine->pid == pid))
+		goto out;
+
+	if ((pid != HOST_KERNEL_ID) &&
+	    (pid != DEFAULT_GUEST_KERNEL_ID) &&
+	    (symbol_conf.guestmount)) {
+		sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
+		if (access(path, R_OK)) {
+			pr_err("Can't access file %s\n", path);
+			machine = NULL;
+			goto out;
 		}
-		machine = machines__add(self, pid, root_dir);
+		root_dir = path;
 	}
 
+	machine = machines__add(self, pid, root_dir);
+
 out:
 	return machine;
 }

commit 31d68e7b66f168e623902e194af1e52b8cf75d71
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 27 12:55:57 2012 -0300

    perf annotate: Validate addr in symbol__inc_addr_samples
    
    This routine was checking only if the provided address was after
    sym->end, not if it was before sym->start.
    
    Fix that by checking for both and return in both cases -ERANGE, so that
    tools can communicate this to the user properly, or if they chose so, to
    abort.
    
    This problem was reported previously but the fixes involved either doing
    what was being done for the > end case, i.e. silently drop the sample,
    returning 0, or aborting at this function, which is in a lib (or better,
    is slated to be at some point) and shouldn't abort.
    
    The 'report' tool already checks this value and uses pr_debug to warn
    the user.
    
    This patch makes the 'top' tool check it too and warn once per map where
    such range problem takes place.
    
    Reported-by: David Miller <davem@davemloft.net>
    Reported-by: Sorin Dumitru <dumitru.sorin87@gmail.com>
    Reported-by: Stephane Eranian <eranian@google.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/n/tip-lw8gs7p9i9nhldilo82tzpne@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index dea6d1c1a954..35ae56864e4f 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -38,6 +38,7 @@ void map__init(struct map *self, enum map_type type,
 	RB_CLEAR_NODE(&self->rb_node);
 	self->groups   = NULL;
 	self->referenced = false;
+	self->erange_warned = false;
 }
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,

commit 0bc8d20580af74c9a8a39c200e269261e5cded05
Author: Akihiro Nagai <akihiro.nagai.hw@hitachi.com>
Date:   Mon Jan 30 13:43:20 2012 +0900

    perf script: Add option resolving vmlinux path
    
    Add the option get the path of [kernel.kallsyms].
    Specify '--show-kernel-path' option to use this function.
    This patch enables other applications to use this output easily.
    
    Without --show-kernel-path  option
    
    ffffffff81467612 irq_return ([kernel.kallsyms])
    ffffffff81467612 irq_return ([kernel.kallsyms])
        7f24fc02a6b3 _start (/lib64/ld-2.14.so)
    [snip]
    
    With --show-kernel-path option
    
    ffffffff81467612 irq_return (/lib/modules/3.2.0+/build/vmlinux)
    ffffffff81467612 irq_return (/lib/modules/3.2.0+/build/vmlinux)
        7f24fc02a6b3 _start (/lib64/ld-2.14.so)
    [snip]
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20120130044320.2384.73322.stgit@linux3
    Signed-off-by: Akihiro Nagai <akihiro.nagai.hw@hitachi.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 11079607105b..dea6d1c1a954 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -216,9 +216,12 @@ size_t map__fprintf_dsoname(struct map *map, FILE *fp)
 {
 	const char *dsoname;
 
-	if (map && map->dso && map->dso->name)
-		dsoname = map->dso->name;
-	else
+	if (map && map->dso && (map->dso->name || map->dso->long_name)) {
+		if (symbol_conf.show_kernel_path && map->dso->long_name)
+			dsoname = map->dso->long_name;
+		else if (map->dso->name)
+			dsoname = map->dso->name;
+	} else
 		dsoname = "[unknown]";
 
 	return fprintf(fp, "%s", dsoname);

commit 547a92e0aedb88129e7fbd804697a11949de2e5a
Author: Akihiro Nagai <akihiro.nagai.hw@hitachi.com>
Date:   Mon Jan 30 13:42:57 2012 +0900

    perf script: Unify the expressions indicating "unknown"
    
    The perf script command uses various expressions to indicate "unknown".
    
    It is unfriendly for user scripts to parse it. So, this patch unifies
    the expressions to "[unknown]".
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20120130044257.2384.62905.stgit@linux3
    Signed-off-by: Akihiro Nagai <akihiro.nagai.hw@hitachi.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 316aa0ab7122..11079607105b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -212,6 +212,18 @@ size_t map__fprintf(struct map *self, FILE *fp)
 		       self->start, self->end, self->pgoff, self->dso->name);
 }
 
+size_t map__fprintf_dsoname(struct map *map, FILE *fp)
+{
+	const char *dsoname;
+
+	if (map && map->dso && map->dso->name)
+		dsoname = map->dso->name;
+	else
+		dsoname = "[unknown]";
+
+	return fprintf(fp, "%s", dsoname);
+}
+
 /*
  * objdump wants/reports absolute IPs for ET_EXEC, and RIPs for ET_DYN.
  * map->dso->adjust_symbols==1 for ET_EXEC-like cases.

commit b424eba27160dd19577896d4520b8eebabed919f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Nov 9 13:24:25 2011 -0200

    perf session: Move threads to struct machine
    
    The 'machine' abstraction was introduced with 'perf kvm' where we could
    have samples for the host and multiple guests, but at the time we ended
    up keeping the list of all machines threads all in
    session->host_machine.
    
    Move the threads rb_tree to struct machine to separate the namespaces.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-mdg7sm6j3va09vtgj49gbsrp@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 78284b13e808..316aa0ab7122 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -562,6 +562,10 @@ int machine__init(struct machine *self, const char *root_dir, pid_t pid)
 	INIT_LIST_HEAD(&self->user_dsos);
 	INIT_LIST_HEAD(&self->kernel_dsos);
 
+	self->threads = RB_ROOT;
+	INIT_LIST_HEAD(&self->dead_threads);
+	self->last_match = NULL;
+
 	self->kmaps.machine = self;
 	self->pid	    = pid;
 	self->root_dir      = strdup(root_dir);

commit e77b15bd849fc85b0228e95da9b7559aa6d31f40
Author: David Ahern <dsahern@gmail.com>
Date:   Tue Oct 18 18:44:45 2011 -0600

    perf tools: Add prelink suggestion to dso update message
    
    Following a prelink run mapped files for long running processes can show
    as deleted. The current message suggests restarting long running
    processes. Add to that a suggestion that prelink might be the cause.
    
    Old message:
    /lib64/libc-2.14.so was updated, restart the long running
     apps that use it!
    
    New message:
    /lib64/libc-2.14.so was updated (is prelink enabled?).
      Restart the long running apps that use it!
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1318985085-20776-1-git-send-email-dsahern@gmail.com
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9cf0d4393c8d..78284b13e808 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -139,8 +139,8 @@ int map__load(struct map *self, symbol_filter_t filter)
 
 		if (len > sizeof(DSO__DELETED) &&
 		    strcmp(name + real_len + 1, DSO__DELETED) == 0) {
-			pr_warning("%.*s was updated, restart the long "
-				   "running apps that use it!\n",
+			pr_warning("%.*s was updated (is prelink enabled?). "
+				"Restart the long running apps that use it!\n",
 				   (int)real_len, name);
 		} else {
 			pr_warning("no symbols found in %s, maybe install "

commit 87ffef79ab7562ca4a1f6f22ed7ddef1c434bc24
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Wed Aug 24 15:18:34 2011 +0200

    perf symbols: Treat all memory maps without dso file as loaded
    
    The stack/vdso/heap memory maps dont have any dso file.  Setting the
    perf dso objects as 'loaded' for these maps, we avoid unnecessary
    warnings like:
    
      "Failed to open [stack], continuing without symbols"
    
    All map__find_* functions still return NULL when searching for symbols
    in these maps.
    
    Link: http://lkml.kernel.org/r/20110824131834.GA2007@jolsa.brq.redhat.com
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index aa2f9fd178e1..9cf0d4393c8d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -18,6 +18,13 @@ static inline int is_anon_memory(const char *filename)
 	return strcmp(filename, "//anon") == 0;
 }
 
+static inline int is_no_dso_memory(const char *filename)
+{
+	return !strcmp(filename, "[stack]") ||
+	       !strcmp(filename, "[vdso]")  ||
+	       !strcmp(filename, "[heap]");
+}
+
 void map__init(struct map *self, enum map_type type,
 	       u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
@@ -42,9 +49,10 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 	if (self != NULL) {
 		char newfilename[PATH_MAX];
 		struct dso *dso;
-		int anon;
+		int anon, no_dso;
 
 		anon = is_anon_memory(filename);
+		no_dso = is_no_dso_memory(filename);
 
 		if (anon) {
 			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);
@@ -57,12 +65,16 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 
 		map__init(self, type, start, start + len, pgoff, dso);
 
-		if (anon) {
-set_identity:
+		if (anon || no_dso) {
 			self->map_ip = self->unmap_ip = identity__map_ip;
-		} else if (strcmp(filename, "[vdso]") == 0) {
-			dso__set_loaded(dso, self->type);
-			goto set_identity;
+
+			/*
+			 * Set memory without DSO as loaded. All map__find_*
+			 * functions still return NULL, and we avoid the
+			 * unnecessary map__load warning.
+			 */
+			if (no_dso)
+				dso__set_loaded(dso, self->type);
 		}
 	}
 	return self;

commit 98dfd55d80eaac03740aed6c6331e34a504fdf18
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Aug 23 14:31:30 2011 -0300

    perf symbols: Stop using 'self' in map_groups__ methods
    
    Stop using this python/OOP convention, doesn't really helps. Will do
    more from time to time till we get it cleaned up in all of /perf.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-rl9e690y60vnuyng05yp1zd3@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a16ecab5229d..aa2f9fd178e1 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -220,55 +220,55 @@ u64 map__objdump_2ip(struct map *map, u64 addr)
 	return ip;
 }
 
-void map_groups__init(struct map_groups *self)
+void map_groups__init(struct map_groups *mg)
 {
 	int i;
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		self->maps[i] = RB_ROOT;
-		INIT_LIST_HEAD(&self->removed_maps[i]);
+		mg->maps[i] = RB_ROOT;
+		INIT_LIST_HEAD(&mg->removed_maps[i]);
 	}
-	self->machine = NULL;
+	mg->machine = NULL;
 }
 
-static void maps__delete(struct rb_root *self)
+static void maps__delete(struct rb_root *maps)
 {
-	struct rb_node *next = rb_first(self);
+	struct rb_node *next = rb_first(maps);
 
 	while (next) {
 		struct map *pos = rb_entry(next, struct map, rb_node);
 
 		next = rb_next(&pos->rb_node);
-		rb_erase(&pos->rb_node, self);
+		rb_erase(&pos->rb_node, maps);
 		map__delete(pos);
 	}
 }
 
-static void maps__delete_removed(struct list_head *self)
+static void maps__delete_removed(struct list_head *maps)
 {
 	struct map *pos, *n;
 
-	list_for_each_entry_safe(pos, n, self, node) {
+	list_for_each_entry_safe(pos, n, maps, node) {
 		list_del(&pos->node);
 		map__delete(pos);
 	}
 }
 
-void map_groups__exit(struct map_groups *self)
+void map_groups__exit(struct map_groups *mg)
 {
 	int i;
 
 	for (i = 0; i < MAP__NR_TYPES; ++i) {
-		maps__delete(&self->maps[i]);
-		maps__delete_removed(&self->removed_maps[i]);
+		maps__delete(&mg->maps[i]);
+		maps__delete_removed(&mg->removed_maps[i]);
 	}
 }
 
-void map_groups__flush(struct map_groups *self)
+void map_groups__flush(struct map_groups *mg)
 {
 	int type;
 
 	for (type = 0; type < MAP__NR_TYPES; type++) {
-		struct rb_root *root = &self->maps[type];
+		struct rb_root *root = &mg->maps[type];
 		struct rb_node *next = rb_first(root);
 
 		while (next) {
@@ -280,17 +280,17 @@ void map_groups__flush(struct map_groups *self)
 			 * instance in some hist_entry instances, so
 			 * just move them to a separate list.
 			 */
-			list_add_tail(&pos->node, &self->removed_maps[pos->type]);
+			list_add_tail(&pos->node, &mg->removed_maps[pos->type]);
 		}
 	}
 }
 
-struct symbol *map_groups__find_symbol(struct map_groups *self,
+struct symbol *map_groups__find_symbol(struct map_groups *mg,
 				       enum map_type type, u64 addr,
 				       struct map **mapp,
 				       symbol_filter_t filter)
 {
-	struct map *map = map_groups__find(self, type, addr);
+	struct map *map = map_groups__find(mg, type, addr);
 
 	if (map != NULL) {
 		if (mapp != NULL)
@@ -301,7 +301,7 @@ struct symbol *map_groups__find_symbol(struct map_groups *self,
 	return NULL;
 }
 
-struct symbol *map_groups__find_symbol_by_name(struct map_groups *self,
+struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 					       enum map_type type,
 					       const char *name,
 					       struct map **mapp,
@@ -309,7 +309,7 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *self,
 {
 	struct rb_node *nd;
 
-	for (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {
+	for (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 		struct symbol *sym = map__find_symbol_by_name(pos, name, filter);
 
@@ -323,13 +323,13 @@ struct symbol *map_groups__find_symbol_by_name(struct map_groups *self,
 	return NULL;
 }
 
-size_t __map_groups__fprintf_maps(struct map_groups *self,
+size_t __map_groups__fprintf_maps(struct map_groups *mg,
 				  enum map_type type, int verbose, FILE *fp)
 {
 	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
 	struct rb_node *nd;
 
-	for (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {
+	for (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {
 		struct map *pos = rb_entry(nd, struct map, rb_node);
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
@@ -342,22 +342,22 @@ size_t __map_groups__fprintf_maps(struct map_groups *self,
 	return printed;
 }
 
-size_t map_groups__fprintf_maps(struct map_groups *self, int verbose, FILE *fp)
+size_t map_groups__fprintf_maps(struct map_groups *mg, int verbose, FILE *fp)
 {
 	size_t printed = 0, i;
 	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_maps(self, i, verbose, fp);
+		printed += __map_groups__fprintf_maps(mg, i, verbose, fp);
 	return printed;
 }
 
-static size_t __map_groups__fprintf_removed_maps(struct map_groups *self,
+static size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,
 						 enum map_type type,
 						 int verbose, FILE *fp)
 {
 	struct map *pos;
 	size_t printed = 0;
 
-	list_for_each_entry(pos, &self->removed_maps[type], node) {
+	list_for_each_entry(pos, &mg->removed_maps[type], node) {
 		printed += fprintf(fp, "Map:");
 		printed += map__fprintf(pos, fp);
 		if (verbose > 1) {
@@ -368,26 +368,26 @@ static size_t __map_groups__fprintf_removed_maps(struct map_groups *self,
 	return printed;
 }
 
-static size_t map_groups__fprintf_removed_maps(struct map_groups *self,
+static size_t map_groups__fprintf_removed_maps(struct map_groups *mg,
 					       int verbose, FILE *fp)
 {
 	size_t printed = 0, i;
 	for (i = 0; i < MAP__NR_TYPES; ++i)
-		printed += __map_groups__fprintf_removed_maps(self, i, verbose, fp);
+		printed += __map_groups__fprintf_removed_maps(mg, i, verbose, fp);
 	return printed;
 }
 
-size_t map_groups__fprintf(struct map_groups *self, int verbose, FILE *fp)
+size_t map_groups__fprintf(struct map_groups *mg, int verbose, FILE *fp)
 {
-	size_t printed = map_groups__fprintf_maps(self, verbose, fp);
+	size_t printed = map_groups__fprintf_maps(mg, verbose, fp);
 	printed += fprintf(fp, "Removed maps:\n");
-	return printed + map_groups__fprintf_removed_maps(self, verbose, fp);
+	return printed + map_groups__fprintf_removed_maps(mg, verbose, fp);
 }
 
-int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
+int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,
 				   int verbose, FILE *fp)
 {
-	struct rb_root *root = &self->maps[map->type];
+	struct rb_root *root = &mg->maps[map->type];
 	struct rb_node *next = rb_first(root);
 	int err = 0;
 
@@ -418,7 +418,7 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 			}
 
 			before->end = map->start - 1;
-			map_groups__insert(self, before);
+			map_groups__insert(mg, before);
 			if (verbose >= 2)
 				map__fprintf(before, fp);
 		}
@@ -432,7 +432,7 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 			}
 
 			after->start = map->end + 1;
-			map_groups__insert(self, after);
+			map_groups__insert(mg, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);
 		}
@@ -441,7 +441,7 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 		 * If we have references, just move them to a separate list.
 		 */
 		if (pos->referenced)
-			list_add_tail(&pos->node, &self->removed_maps[map->type]);
+			list_add_tail(&pos->node, &mg->removed_maps[map->type]);
 		else
 			map__delete(pos);
 
@@ -455,7 +455,7 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 /*
  * XXX This should not really _copy_ te maps, but refcount them.
  */
-int map_groups__clone(struct map_groups *self,
+int map_groups__clone(struct map_groups *mg,
 		      struct map_groups *parent, enum map_type type)
 {
 	struct rb_node *nd;
@@ -464,7 +464,7 @@ int map_groups__clone(struct map_groups *self,
 		struct map *new = map__clone(map);
 		if (new == NULL)
 			return -ENOMEM;
-		map_groups__insert(self, new);
+		map_groups__insert(mg, new);
 	}
 	return 0;
 }

commit 9486aa38771661e96fbb51c549b9901b5df609d8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sat Jan 22 20:37:02 2011 -0200

    perf tools: Fix 64 bit integer format strings
    
    Using %L[uxd] has issues in some architectures, like on ppc64.  Fix it
    by making our 64 bit integers typedefs of stdint.h types and using
    PRI[ux]64 like, for instance, git does.
    
    Reported by Denis Kirjanov that provided a patch for one case, I went
    and changed all cases.
    
    Reported-by: Denis Kirjanov <dkirjanov@kernel.org>
    Tested-by: Denis Kirjanov <dkirjanov@kernel.org>
    LKML-Reference: <20110120093246.GA8031@hera.kernel.org>
    Cc: Denis Kirjanov <dkirjanov@kernel.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Pingtian Han <phan@redhat.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 3a7eb6ec0eec..a16ecab5229d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,5 +1,6 @@
 #include "symbol.h"
 #include <errno.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
@@ -195,7 +196,7 @@ int map__overlap(struct map *l, struct map *r)
 
 size_t map__fprintf(struct map *self, FILE *fp)
 {
-	return fprintf(fp, " %Lx-%Lx %Lx %s\n",
+	return fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",
 		       self->start, self->end, self->pgoff, self->dso->name);
 }
 

commit 0a1eae391d0d92b60cff9f55cdaf3861b4e33922
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Aug 2 19:45:23 2010 -0300

    perf tools: Don't keep unreferenced maps when unmaps are detected
    
    For a file with:
    
    [root@emilia linux-2.6-tip]# perf report -D -fi allmodconfig-j32.perf.data | grep events:
         TOTAL events:      36933
          MMAP events:       9056
          LOST events:          0
          COMM events:       1702
          EXIT events:       1887
      THROTTLE events:          8
    UNTHROTTLE events:          8
          FORK events:       1894
          READ events:          0
        SAMPLE events:      22378
          ATTR events:          0
    EVENT_TYPE events:          0
    TRACING_DATA events:          0
      BUILD_ID events:          0
    [root@emilia linux-2.6-tip]#
    
    Testing with valgrind and making perf_session__delete() a nop, so that
    we can notice how many maps were actually deleted due to not having any
    samples on it:
    
    ==== HEAP SUMMARY:
    
    Before:
    
    ==10339==     in use at exit: 8,909,997 bytes in 68,690 blocks
    ==10339==   total heap usage: 78,696 allocs, 10,007 frees, 11,925,853 bytes allocated
    
    After:
    
    ==10506==     in use at exit: 8,902,605 bytes in 68,606 blocks
    ==10506==   total heap usage: 78,696 allocs, 10,091 frees, 11,925,853 bytes allocated
    
    I.e. just 84 detected unmaps with no hits out of 9056 for this workload,
    not much, but in some other long running workload this may save more
    bytes.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 801e6962b0a6..3a7eb6ec0eec 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -29,6 +29,7 @@ void map__init(struct map *self, enum map_type type,
 	self->unmap_ip = map__unmap_ip;
 	RB_CLEAR_NODE(&self->rb_node);
 	self->groups   = NULL;
+	self->referenced = false;
 }
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
@@ -387,6 +388,7 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 {
 	struct rb_root *root = &self->maps[map->type];
 	struct rb_node *next = rb_first(root);
+	int err = 0;
 
 	while (next) {
 		struct map *pos = rb_entry(next, struct map, rb_node);
@@ -402,12 +404,6 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 		}
 
 		rb_erase(&pos->rb_node, root);
-		/*
-		 * We may have references to this map, for instance in some
-		 * hist_entry instances, so just move them to a separate
-		 * list.
-		 */
-		list_add_tail(&pos->node, &self->removed_maps[map->type]);
 		/*
 		 * Now check if we need to create new maps for areas not
 		 * overlapped by the new map:
@@ -415,8 +411,10 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 		if (map->start > pos->start) {
 			struct map *before = map__clone(pos);
 
-			if (before == NULL)
-				return -ENOMEM;
+			if (before == NULL) {
+				err = -ENOMEM;
+				goto move_map;
+			}
 
 			before->end = map->start - 1;
 			map_groups__insert(self, before);
@@ -427,14 +425,27 @@ int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
 		if (map->end < pos->end) {
 			struct map *after = map__clone(pos);
 
-			if (after == NULL)
-				return -ENOMEM;
+			if (after == NULL) {
+				err = -ENOMEM;
+				goto move_map;
+			}
 
 			after->start = map->end + 1;
 			map_groups__insert(self, after);
 			if (verbose >= 2)
 				map__fprintf(after, fp);
 		}
+move_map:
+		/*
+		 * If we have references, just move them to a separate list.
+		 */
+		if (pos->referenced)
+			list_add_tail(&pos->node, &self->removed_maps[map->type]);
+		else
+			map__delete(pos);
+
+		if (err)
+			return err;
 	}
 
 	return 0;

commit 076c6e45215aea0de1ed34d3d5079fabeaabf5e1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Aug 2 18:18:28 2010 -0300

    perf session: Free the ref_reloc_sym memory at the right place
    
    Which is at perf_session__destroy_kernel_maps, counterpart to the
    perf_session__create_kernel_maps where the kmap structure is located, just
    after the vmlinux_maps.
    
    Make it also check if the kernel maps were actually created, which may not
    be the case if, for instance, perf_session__new can't complete due to
    permission problems in, for instance, a 'perf report' case, when a
    segfault will take place, that is how this was noticed.
    
    The problem was introduced in d65a458, thus post .35.
    
    This also adds code to release guest machines as them are also created
    in perf_session__create_kernel_maps, so should be deleted on this newly
    introduced counterpart, perf_session__destroy_kernel_maps.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 15d6a6dd50c5..801e6962b0a6 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -506,6 +506,11 @@ void maps__insert(struct rb_root *maps, struct map *map)
 	rb_insert_color(&map->rb_node, maps);
 }
 
+void maps__remove(struct rb_root *self, struct map *map)
+{
+	rb_erase(&map->rb_node, self);
+}
+
 struct map *maps__find(struct rb_root *maps, u64 ip)
 {
 	struct rb_node **p = &maps->rb_node;
@@ -551,13 +556,6 @@ static void dsos__delete(struct list_head *self)
 
 void machine__exit(struct machine *self)
 {
-	struct kmap *kmap = map__kmap(self->vmlinux_maps[MAP__FUNCTION]);
-
-	if (kmap->ref_reloc_sym) {
-		free((char *)kmap->ref_reloc_sym->name);
-		free(kmap->ref_reloc_sym);
-	}
-
 	map_groups__exit(&self->kmaps);
 	dsos__delete(&self->user_dsos);
 	dsos__delete(&self->kernel_dsos);
@@ -565,6 +563,12 @@ void machine__exit(struct machine *self)
 	self->root_dir = NULL;
 }
 
+void machine__delete(struct machine *self)
+{
+	machine__exit(self);
+	free(self);
+}
+
 struct machine *machines__add(struct rb_root *self, pid_t pid,
 			      const char *root_dir)
 {

commit d65a458b348cd458413b3cfec66e43ebd0367646
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jul 30 18:31:28 2010 -0300

    perf tools: Release session and symbol resources on exit
    
    So that we reduce the noise when looking for leaks using tools such as
    valgrind.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 2ddbae319de5..15d6a6dd50c5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -539,6 +539,32 @@ int machine__init(struct machine *self, const char *root_dir, pid_t pid)
 	return self->root_dir == NULL ? -ENOMEM : 0;
 }
 
+static void dsos__delete(struct list_head *self)
+{
+	struct dso *pos, *n;
+
+	list_for_each_entry_safe(pos, n, self, node) {
+		list_del(&pos->node);
+		dso__delete(pos);
+	}
+}
+
+void machine__exit(struct machine *self)
+{
+	struct kmap *kmap = map__kmap(self->vmlinux_maps[MAP__FUNCTION]);
+
+	if (kmap->ref_reloc_sym) {
+		free((char *)kmap->ref_reloc_sym->name);
+		free(kmap->ref_reloc_sym);
+	}
+
+	map_groups__exit(&self->kmaps);
+	dsos__delete(&self->user_dsos);
+	dsos__delete(&self->kernel_dsos);
+	free(self->root_dir);
+	self->root_dir = NULL;
+}
+
 struct machine *machines__add(struct rb_root *self, pid_t pid,
 			      const char *root_dir)
 {

commit 591765fdaf7ea1888157f342b67b0461f2e5ed9b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jul 30 18:28:42 2010 -0300

    perf tools: Release thread resources on PERF_RECORD_EXIT
    
    For long running sessions with many threads with short lifetimes the
    amount of memory that the buildid process takes is too much.
    
    Since we don't have hist_entries that may be pointing to them, we can
    just release the resources associated with each thread when the exit
    (PERF_RECORD_EXIT) event is received.
    
    For normal processing we need to annotate maps with hits, and thus
    hist_entries pointing to it and drop the ones that had none. Will be
    done in a followup patch.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 37cab9038538..2ddbae319de5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -228,6 +228,39 @@ void map_groups__init(struct map_groups *self)
 	self->machine = NULL;
 }
 
+static void maps__delete(struct rb_root *self)
+{
+	struct rb_node *next = rb_first(self);
+
+	while (next) {
+		struct map *pos = rb_entry(next, struct map, rb_node);
+
+		next = rb_next(&pos->rb_node);
+		rb_erase(&pos->rb_node, self);
+		map__delete(pos);
+	}
+}
+
+static void maps__delete_removed(struct list_head *self)
+{
+	struct map *pos, *n;
+
+	list_for_each_entry_safe(pos, n, self, node) {
+		list_del(&pos->node);
+		map__delete(pos);
+	}
+}
+
+void map_groups__exit(struct map_groups *self)
+{
+	int i;
+
+	for (i = 0; i < MAP__NR_TYPES; ++i) {
+		maps__delete(&self->maps[i]);
+		maps__delete_removed(&self->removed_maps[i]);
+	}
+}
+
 void map_groups__flush(struct map_groups *self)
 {
 	int type;

commit 361d13462585474267a0c41e956f1a1c19a93f17
Author: Dave Martin <dave.martin@linaro.org>
Date:   Tue Jul 27 16:40:02 2010 +0100

    perf report: Don't abbreviate file paths relative to the cwd
    
    This avoids around some problems where the full path is executables and DSOs it
    needed for finding debug symbols on platforms with separated debug symbol files
    such as Ubuntu.  This is simpler than tracking an extra name for each image.
    
    The only impact should be that paths in verbose output from the perf tools
    become absolute, instead of relative to .
    
    LKML-Reference: <new-submission>
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index e672f2fef65b..37cab9038538 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -17,16 +17,6 @@ static inline int is_anon_memory(const char *filename)
 	return strcmp(filename, "//anon") == 0;
 }
 
-static int strcommon(const char *pathname, char *cwd, int cwdlen)
-{
-	int n = 0;
-
-	while (n < cwdlen && pathname[n] == cwd[n])
-		++n;
-
-	return n;
-}
-
 void map__init(struct map *self, enum map_type type,
 	       u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
@@ -43,7 +33,7 @@ void map__init(struct map *self, enum map_type type,
 
 struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		     u64 pgoff, u32 pid, char *filename,
-		     enum map_type type, char *cwd, int cwdlen)
+		     enum map_type type)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -52,16 +42,6 @@ struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
 		struct dso *dso;
 		int anon;
 
-		if (cwd) {
-			int n = strcommon(filename, cwd, cwdlen);
-
-			if (n == cwdlen) {
-				snprintf(newfilename, sizeof(newfilename),
-					 ".%s", filename + n);
-				filename = newfilename;
-			}
-		}
-
 		anon = is_anon_memory(filename);
 
 		if (anon) {

commit 1f626bc36847ac8dd192f055aed0f9678a781313
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun May 9 19:57:08 2010 -0300

    perf session: Embed the host machine data on perf_session
    
    We have just one host on a given session, and that is the most common
    setup right now, so embed a ->host_machine struct machine instance
    directly in the perf_session class, check if we're looking for it before
    going to the rb_tree.
    
    This also fixes a problem found when we try to process old perf.data
    files where we didn't have MMAP events for the kernel and modules and
    thus don't create the kernel maps, do it in event__preprocess_sample if
    it wasn't already.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    Cc: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 44a4df68b3cf..e672f2fef65b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -579,30 +579,6 @@ struct machine *machines__find(struct rb_root *self, pid_t pid)
 	return default_machine;
 }
 
-/*
- * FIXME: Why repeatedly search for this?
- */
-struct machine *machines__find_host(struct rb_root *self)
-{
-	struct rb_node **p = &self->rb_node;
-	struct rb_node *parent = NULL;
-	struct machine *machine;
-	pid_t pid = HOST_KERNEL_ID;
-
-	while (*p != NULL) {
-		parent = *p;
-		machine = rb_entry(parent, struct machine, rb_node);
-		if (pid < machine->pid)
-			p = &(*p)->rb_left;
-		else if (pid > machine->pid)
-			p = &(*p)->rb_right;
-		else
-			return machine;
-	}
-
-	return NULL;
-}
-
 struct machine *machines__findnew(struct rb_root *self, pid_t pid)
 {
 	char path[PATH_MAX];

commit d28c62232e50eab202bcd3f19b5c7a25b8b900b6
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 27 21:20:43 2010 -0300

    perf machine: Adopt some map_groups functions
    
    Those functions operated on members now grouped in 'struct machine', so
    move those methods to this new class.
    
    The changes made to 'perf probe' shows that using this abstraction
    inserting probes on guests almost got supported for free.
    
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Masami Hiramatsu <mhiramat@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index ee25ee91504b..44a4df68b3cf 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -513,6 +513,19 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 	return NULL;
 }
 
+int machine__init(struct machine *self, const char *root_dir, pid_t pid)
+{
+	map_groups__init(&self->kmaps);
+	RB_CLEAR_NODE(&self->rb_node);
+	INIT_LIST_HEAD(&self->user_dsos);
+	INIT_LIST_HEAD(&self->kernel_dsos);
+
+	self->kmaps.machine = self;
+	self->pid	    = pid;
+	self->root_dir      = strdup(root_dir);
+	return self->root_dir == NULL ? -ENOMEM : 0;
+}
+
 struct machine *machines__add(struct rb_root *self, pid_t pid,
 			      const char *root_dir)
 {
@@ -523,13 +536,10 @@ struct machine *machines__add(struct rb_root *self, pid_t pid,
 	if (!machine)
 		return NULL;
 
-	machine->pid = pid;
-	map_groups__init(&machine->kmaps);
-	machine->root_dir = strdup(root_dir);
-	RB_CLEAR_NODE(&machine->rb_node);
-	INIT_LIST_HEAD(&machine->user_dsos);
-	INIT_LIST_HEAD(&machine->kernel_dsos);
-	machine->kmaps.machine = machine;
+	if (machine__init(machine, root_dir, pid) != 0) {
+		free(machine);
+		return NULL;
+	}
 
 	while (*p != NULL) {
 		parent = *p;

commit 48ea8f5470aa6f35244d1b218316705ea88c0259
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 27 21:19:05 2010 -0300

    perf machine: Pass buffer size to machine__mmap_name
    
    Don't blindly assume that the size of the buffer is enough, use
    snprintf.
    
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index da3d4e826231..ee25ee91504b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -629,14 +629,14 @@ void machines__process(struct rb_root *self, machine__process_t process, void *d
 	}
 }
 
-char *machine__mmap_name(struct machine *self, char *buff)
+char *machine__mmap_name(struct machine *self, char *bf, size_t size)
 {
 	if (machine__is_host(self))
-		sprintf(buff, "[%s]", "kernel.kallsyms");
+		snprintf(bf, size, "[%s]", "kernel.kallsyms");
 	else if (machine__is_default_guest(self))
-		sprintf(buff, "[%s]", "guest.kernel.kallsyms");
+		snprintf(bf, size, "[%s]", "guest.kernel.kallsyms");
 	else
-		sprintf(buff, "[%s.%d]", "guest.kernel.kallsyms", self->pid);
+		snprintf(bf, size, "[%s.%d]", "guest.kernel.kallsyms", self->pid);
 
-	return buff;
+	return bf;
 }

commit 23346f21b277e3aae5e9989e711a11cbe8133a45
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 27 21:17:50 2010 -0300

    perf tools: Rename "kernel_info" to "machine"
    
    struct kernel_info and kerninfo__ are too vague, what they really
    describe are machines, virtual ones or hosts.
    
    There are more changes to introduce helpers to shorten function calls
    and to make more clear what is really being done, but I left that for
    subsequent patches.
    
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 7facd016ec97..da3d4e826231 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -245,7 +245,7 @@ void map_groups__init(struct map_groups *self)
 		self->maps[i] = RB_ROOT;
 		INIT_LIST_HEAD(&self->removed_maps[i]);
 	}
-	 self->this_kerninfo = NULL;
+	self->machine = NULL;
 }
 
 void map_groups__flush(struct map_groups *self)
@@ -513,133 +513,130 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 	return NULL;
 }
 
-struct kernel_info *add_new_kernel_info(struct rb_root *kerninfo_root,
-			pid_t pid, const char *root_dir)
+struct machine *machines__add(struct rb_root *self, pid_t pid,
+			      const char *root_dir)
 {
-	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node **p = &self->rb_node;
 	struct rb_node *parent = NULL;
-	struct kernel_info *kerninfo, *pos;
+	struct machine *pos, *machine = malloc(sizeof(*machine));
 
-	kerninfo = malloc(sizeof(struct kernel_info));
-	if (!kerninfo)
+	if (!machine)
 		return NULL;
 
-	kerninfo->pid = pid;
-	map_groups__init(&kerninfo->kmaps);
-	kerninfo->root_dir = strdup(root_dir);
-	RB_CLEAR_NODE(&kerninfo->rb_node);
-	INIT_LIST_HEAD(&kerninfo->dsos__user);
-	INIT_LIST_HEAD(&kerninfo->dsos__kernel);
-	kerninfo->kmaps.this_kerninfo = kerninfo;
+	machine->pid = pid;
+	map_groups__init(&machine->kmaps);
+	machine->root_dir = strdup(root_dir);
+	RB_CLEAR_NODE(&machine->rb_node);
+	INIT_LIST_HEAD(&machine->user_dsos);
+	INIT_LIST_HEAD(&machine->kernel_dsos);
+	machine->kmaps.machine = machine;
 
 	while (*p != NULL) {
 		parent = *p;
-		pos = rb_entry(parent, struct kernel_info, rb_node);
+		pos = rb_entry(parent, struct machine, rb_node);
 		if (pid < pos->pid)
 			p = &(*p)->rb_left;
 		else
 			p = &(*p)->rb_right;
 	}
 
-	rb_link_node(&kerninfo->rb_node, parent, p);
-	rb_insert_color(&kerninfo->rb_node, kerninfo_root);
+	rb_link_node(&machine->rb_node, parent, p);
+	rb_insert_color(&machine->rb_node, self);
 
-	return kerninfo;
+	return machine;
 }
 
-struct kernel_info *kerninfo__find(struct rb_root *kerninfo_root, pid_t pid)
+struct machine *machines__find(struct rb_root *self, pid_t pid)
 {
-	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node **p = &self->rb_node;
 	struct rb_node *parent = NULL;
-	struct kernel_info *kerninfo;
-	struct kernel_info *default_kerninfo = NULL;
+	struct machine *machine;
+	struct machine *default_machine = NULL;
 
 	while (*p != NULL) {
 		parent = *p;
-		kerninfo = rb_entry(parent, struct kernel_info, rb_node);
-		if (pid < kerninfo->pid)
+		machine = rb_entry(parent, struct machine, rb_node);
+		if (pid < machine->pid)
 			p = &(*p)->rb_left;
-		else if (pid > kerninfo->pid)
+		else if (pid > machine->pid)
 			p = &(*p)->rb_right;
 		else
-			return kerninfo;
-		if (!kerninfo->pid)
-			default_kerninfo = kerninfo;
+			return machine;
+		if (!machine->pid)
+			default_machine = machine;
 	}
 
-	return default_kerninfo;
+	return default_machine;
 }
 
-struct kernel_info *kerninfo__findhost(struct rb_root *kerninfo_root)
+/*
+ * FIXME: Why repeatedly search for this?
+ */
+struct machine *machines__find_host(struct rb_root *self)
 {
-	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node **p = &self->rb_node;
 	struct rb_node *parent = NULL;
-	struct kernel_info *kerninfo;
+	struct machine *machine;
 	pid_t pid = HOST_KERNEL_ID;
 
 	while (*p != NULL) {
 		parent = *p;
-		kerninfo = rb_entry(parent, struct kernel_info, rb_node);
-		if (pid < kerninfo->pid)
+		machine = rb_entry(parent, struct machine, rb_node);
+		if (pid < machine->pid)
 			p = &(*p)->rb_left;
-		else if (pid > kerninfo->pid)
+		else if (pid > machine->pid)
 			p = &(*p)->rb_right;
 		else
-			return kerninfo;
+			return machine;
 	}
 
 	return NULL;
 }
 
-struct kernel_info *kerninfo__findnew(struct rb_root *kerninfo_root, pid_t pid)
+struct machine *machines__findnew(struct rb_root *self, pid_t pid)
 {
 	char path[PATH_MAX];
 	const char *root_dir;
-	int ret;
-	struct kernel_info *kerninfo = kerninfo__find(kerninfo_root, pid);
+	struct machine *machine = machines__find(self, pid);
 
-	if (!kerninfo || kerninfo->pid != pid) {
+	if (!machine || machine->pid != pid) {
 		if (pid == HOST_KERNEL_ID || pid == DEFAULT_GUEST_KERNEL_ID)
 			root_dir = "";
 		else {
 			if (!symbol_conf.guestmount)
 				goto out;
 			sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
-			ret = access(path, R_OK);
-			if (ret) {
+			if (access(path, R_OK)) {
 				pr_err("Can't access file %s\n", path);
 				goto out;
 			}
 			root_dir = path;
 		}
-		kerninfo = add_new_kernel_info(kerninfo_root, pid, root_dir);
+		machine = machines__add(self, pid, root_dir);
 	}
 
 out:
-	return kerninfo;
+	return machine;
 }
 
-void kerninfo__process_allkernels(struct rb_root *kerninfo_root,
-		process_kernel_info process,
-		void *data)
+void machines__process(struct rb_root *self, machine__process_t process, void *data)
 {
 	struct rb_node *nd;
 
-	for (nd = rb_first(kerninfo_root); nd; nd = rb_next(nd)) {
-		struct kernel_info *pos = rb_entry(nd, struct kernel_info,
-							rb_node);
+	for (nd = rb_first(self); nd; nd = rb_next(nd)) {
+		struct machine *pos = rb_entry(nd, struct machine, rb_node);
 		process(pos, data);
 	}
 }
 
-char *kern_mmap_name(struct kernel_info *kerninfo, char *buff)
+char *machine__mmap_name(struct machine *self, char *buff)
 {
-	if (is_host_kernel(kerninfo))
+	if (machine__is_host(self))
 		sprintf(buff, "[%s]", "kernel.kallsyms");
-	else if (is_default_guest(kerninfo))
+	else if (machine__is_default_guest(self))
 		sprintf(buff, "[%s]", "guest.kernel.kallsyms");
 	else
-		sprintf(buff, "[%s.%d]", "guest.kernel.kallsyms", kerninfo->pid);
+		sprintf(buff, "[%s.%d]", "guest.kernel.kallsyms", self->pid);
 
 	return buff;
 }

commit a1645ce12adb6c9cc9e19d7695466204e3f017fe
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Mon Apr 19 13:32:50 2010 +0800

    perf: 'perf kvm' tool for monitoring guest performance from host
    
    Here is the patch of userspace perf tool.
    
    Signed-off-by: Zhang Yanmin <yanmin_zhang@linux.intel.com>
    Signed-off-by: Avi Kivity <avi@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 37913b241bdf..7facd016ec97 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -4,6 +4,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
+#include <unistd.h>
 #include "map.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
@@ -37,9 +38,11 @@ void map__init(struct map *self, enum map_type type,
 	self->map_ip   = map__map_ip;
 	self->unmap_ip = map__unmap_ip;
 	RB_CLEAR_NODE(&self->rb_node);
+	self->groups   = NULL;
 }
 
-struct map *map__new(u64 start, u64 len, u64 pgoff, u32 pid, char *filename,
+struct map *map__new(struct list_head *dsos__list, u64 start, u64 len,
+		     u64 pgoff, u32 pid, char *filename,
 		     enum map_type type, char *cwd, int cwdlen)
 {
 	struct map *self = malloc(sizeof(*self));
@@ -66,7 +69,7 @@ struct map *map__new(u64 start, u64 len, u64 pgoff, u32 pid, char *filename,
 			filename = newfilename;
 		}
 
-		dso = dsos__findnew(filename);
+		dso = __dsos__findnew(dsos__list, filename);
 		if (dso == NULL)
 			goto out_delete;
 
@@ -242,6 +245,7 @@ void map_groups__init(struct map_groups *self)
 		self->maps[i] = RB_ROOT;
 		INIT_LIST_HEAD(&self->removed_maps[i]);
 	}
+	 self->this_kerninfo = NULL;
 }
 
 void map_groups__flush(struct map_groups *self)
@@ -508,3 +512,134 @@ struct map *maps__find(struct rb_root *maps, u64 ip)
 
 	return NULL;
 }
+
+struct kernel_info *add_new_kernel_info(struct rb_root *kerninfo_root,
+			pid_t pid, const char *root_dir)
+{
+	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node *parent = NULL;
+	struct kernel_info *kerninfo, *pos;
+
+	kerninfo = malloc(sizeof(struct kernel_info));
+	if (!kerninfo)
+		return NULL;
+
+	kerninfo->pid = pid;
+	map_groups__init(&kerninfo->kmaps);
+	kerninfo->root_dir = strdup(root_dir);
+	RB_CLEAR_NODE(&kerninfo->rb_node);
+	INIT_LIST_HEAD(&kerninfo->dsos__user);
+	INIT_LIST_HEAD(&kerninfo->dsos__kernel);
+	kerninfo->kmaps.this_kerninfo = kerninfo;
+
+	while (*p != NULL) {
+		parent = *p;
+		pos = rb_entry(parent, struct kernel_info, rb_node);
+		if (pid < pos->pid)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+	}
+
+	rb_link_node(&kerninfo->rb_node, parent, p);
+	rb_insert_color(&kerninfo->rb_node, kerninfo_root);
+
+	return kerninfo;
+}
+
+struct kernel_info *kerninfo__find(struct rb_root *kerninfo_root, pid_t pid)
+{
+	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node *parent = NULL;
+	struct kernel_info *kerninfo;
+	struct kernel_info *default_kerninfo = NULL;
+
+	while (*p != NULL) {
+		parent = *p;
+		kerninfo = rb_entry(parent, struct kernel_info, rb_node);
+		if (pid < kerninfo->pid)
+			p = &(*p)->rb_left;
+		else if (pid > kerninfo->pid)
+			p = &(*p)->rb_right;
+		else
+			return kerninfo;
+		if (!kerninfo->pid)
+			default_kerninfo = kerninfo;
+	}
+
+	return default_kerninfo;
+}
+
+struct kernel_info *kerninfo__findhost(struct rb_root *kerninfo_root)
+{
+	struct rb_node **p = &kerninfo_root->rb_node;
+	struct rb_node *parent = NULL;
+	struct kernel_info *kerninfo;
+	pid_t pid = HOST_KERNEL_ID;
+
+	while (*p != NULL) {
+		parent = *p;
+		kerninfo = rb_entry(parent, struct kernel_info, rb_node);
+		if (pid < kerninfo->pid)
+			p = &(*p)->rb_left;
+		else if (pid > kerninfo->pid)
+			p = &(*p)->rb_right;
+		else
+			return kerninfo;
+	}
+
+	return NULL;
+}
+
+struct kernel_info *kerninfo__findnew(struct rb_root *kerninfo_root, pid_t pid)
+{
+	char path[PATH_MAX];
+	const char *root_dir;
+	int ret;
+	struct kernel_info *kerninfo = kerninfo__find(kerninfo_root, pid);
+
+	if (!kerninfo || kerninfo->pid != pid) {
+		if (pid == HOST_KERNEL_ID || pid == DEFAULT_GUEST_KERNEL_ID)
+			root_dir = "";
+		else {
+			if (!symbol_conf.guestmount)
+				goto out;
+			sprintf(path, "%s/%d", symbol_conf.guestmount, pid);
+			ret = access(path, R_OK);
+			if (ret) {
+				pr_err("Can't access file %s\n", path);
+				goto out;
+			}
+			root_dir = path;
+		}
+		kerninfo = add_new_kernel_info(kerninfo_root, pid, root_dir);
+	}
+
+out:
+	return kerninfo;
+}
+
+void kerninfo__process_allkernels(struct rb_root *kerninfo_root,
+		process_kernel_info process,
+		void *data)
+{
+	struct rb_node *nd;
+
+	for (nd = rb_first(kerninfo_root); nd; nd = rb_next(nd)) {
+		struct kernel_info *pos = rb_entry(nd, struct kernel_info,
+							rb_node);
+		process(pos, data);
+	}
+}
+
+char *kern_mmap_name(struct kernel_info *kerninfo, char *buff)
+{
+	if (is_host_kernel(kerninfo))
+		sprintf(buff, "[%s]", "kernel.kallsyms");
+	else if (is_default_guest(kerninfo))
+		sprintf(buff, "[%s]", "guest.kernel.kallsyms");
+	else
+		sprintf(buff, "[%s.%d]", "guest.kernel.kallsyms", kerninfo->pid);
+
+	return buff;
+}

commit 7e5e1b1404c30db5f6bc3f5203b6c21c1d244f99
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Mar 26 12:30:40 2010 -0300

    perf symbols: map_groups__find_symbol must return the map too
    
    Tools need to know from which map in the map_group a symbol was resolved
    to, so that, for isntance, we can annotate kernel modules symbols by
    getting its precise name, etc.
    
    Also add the _by_name variants for completeness.
    
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index e21f98001734..37913b241bdf 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -268,12 +268,38 @@ void map_groups__flush(struct map_groups *self)
 
 struct symbol *map_groups__find_symbol(struct map_groups *self,
 				       enum map_type type, u64 addr,
+				       struct map **mapp,
 				       symbol_filter_t filter)
 {
 	struct map *map = map_groups__find(self, type, addr);
 
-	if (map != NULL)
+	if (map != NULL) {
+		if (mapp != NULL)
+			*mapp = map;
 		return map__find_symbol(map, map->map_ip(map, addr), filter);
+	}
+
+	return NULL;
+}
+
+struct symbol *map_groups__find_symbol_by_name(struct map_groups *self,
+					       enum map_type type,
+					       const char *name,
+					       struct map **mapp,
+					       symbol_filter_t filter)
+{
+	struct rb_node *nd;
+
+	for (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {
+		struct map *pos = rb_entry(nd, struct map, rb_node);
+		struct symbol *sym = map__find_symbol_by_name(pos, name, filter);
+
+		if (sym == NULL)
+			continue;
+		if (mapp != NULL)
+			*mapp = pos;
+		return sym;
+	}
 
 	return NULL;
 }

commit c6e718ff8cdcf5e7855077687720b37c4a07650a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Mar 26 12:11:06 2010 -0300

    perf symbols: Move more map_groups methods to map.c
    
    While writing a standalone test app that uses the symbol system to
    find kernel space symbols I noticed these also need to be moved.
    
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 9f2963f9ee9a..e21f98001734 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,4 +1,5 @@
 #include "symbol.h"
+#include <errno.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
@@ -234,6 +235,37 @@ u64 map__objdump_2ip(struct map *map, u64 addr)
 	return ip;
 }
 
+void map_groups__init(struct map_groups *self)
+{
+	int i;
+	for (i = 0; i < MAP__NR_TYPES; ++i) {
+		self->maps[i] = RB_ROOT;
+		INIT_LIST_HEAD(&self->removed_maps[i]);
+	}
+}
+
+void map_groups__flush(struct map_groups *self)
+{
+	int type;
+
+	for (type = 0; type < MAP__NR_TYPES; type++) {
+		struct rb_root *root = &self->maps[type];
+		struct rb_node *next = rb_first(root);
+
+		while (next) {
+			struct map *pos = rb_entry(next, struct map, rb_node);
+			next = rb_next(&pos->rb_node);
+			rb_erase(&pos->rb_node, root);
+			/*
+			 * We may have references to this map, for
+			 * instance in some hist_entry instances, so
+			 * just move them to a separate list.
+			 */
+			list_add_tail(&pos->node, &self->removed_maps[pos->type]);
+		}
+	}
+}
+
 struct symbol *map_groups__find_symbol(struct map_groups *self,
 				       enum map_type type, u64 addr,
 				       symbol_filter_t filter)
@@ -246,6 +278,142 @@ struct symbol *map_groups__find_symbol(struct map_groups *self,
 	return NULL;
 }
 
+size_t __map_groups__fprintf_maps(struct map_groups *self,
+				  enum map_type type, int verbose, FILE *fp)
+{
+	size_t printed = fprintf(fp, "%s:\n", map_type__name[type]);
+	struct rb_node *nd;
+
+	for (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {
+		struct map *pos = rb_entry(nd, struct map, rb_node);
+		printed += fprintf(fp, "Map:");
+		printed += map__fprintf(pos, fp);
+		if (verbose > 2) {
+			printed += dso__fprintf(pos->dso, type, fp);
+			printed += fprintf(fp, "--\n");
+		}
+	}
+
+	return printed;
+}
+
+size_t map_groups__fprintf_maps(struct map_groups *self, int verbose, FILE *fp)
+{
+	size_t printed = 0, i;
+	for (i = 0; i < MAP__NR_TYPES; ++i)
+		printed += __map_groups__fprintf_maps(self, i, verbose, fp);
+	return printed;
+}
+
+static size_t __map_groups__fprintf_removed_maps(struct map_groups *self,
+						 enum map_type type,
+						 int verbose, FILE *fp)
+{
+	struct map *pos;
+	size_t printed = 0;
+
+	list_for_each_entry(pos, &self->removed_maps[type], node) {
+		printed += fprintf(fp, "Map:");
+		printed += map__fprintf(pos, fp);
+		if (verbose > 1) {
+			printed += dso__fprintf(pos->dso, type, fp);
+			printed += fprintf(fp, "--\n");
+		}
+	}
+	return printed;
+}
+
+static size_t map_groups__fprintf_removed_maps(struct map_groups *self,
+					       int verbose, FILE *fp)
+{
+	size_t printed = 0, i;
+	for (i = 0; i < MAP__NR_TYPES; ++i)
+		printed += __map_groups__fprintf_removed_maps(self, i, verbose, fp);
+	return printed;
+}
+
+size_t map_groups__fprintf(struct map_groups *self, int verbose, FILE *fp)
+{
+	size_t printed = map_groups__fprintf_maps(self, verbose, fp);
+	printed += fprintf(fp, "Removed maps:\n");
+	return printed + map_groups__fprintf_removed_maps(self, verbose, fp);
+}
+
+int map_groups__fixup_overlappings(struct map_groups *self, struct map *map,
+				   int verbose, FILE *fp)
+{
+	struct rb_root *root = &self->maps[map->type];
+	struct rb_node *next = rb_first(root);
+
+	while (next) {
+		struct map *pos = rb_entry(next, struct map, rb_node);
+		next = rb_next(&pos->rb_node);
+
+		if (!map__overlap(pos, map))
+			continue;
+
+		if (verbose >= 2) {
+			fputs("overlapping maps:\n", fp);
+			map__fprintf(map, fp);
+			map__fprintf(pos, fp);
+		}
+
+		rb_erase(&pos->rb_node, root);
+		/*
+		 * We may have references to this map, for instance in some
+		 * hist_entry instances, so just move them to a separate
+		 * list.
+		 */
+		list_add_tail(&pos->node, &self->removed_maps[map->type]);
+		/*
+		 * Now check if we need to create new maps for areas not
+		 * overlapped by the new map:
+		 */
+		if (map->start > pos->start) {
+			struct map *before = map__clone(pos);
+
+			if (before == NULL)
+				return -ENOMEM;
+
+			before->end = map->start - 1;
+			map_groups__insert(self, before);
+			if (verbose >= 2)
+				map__fprintf(before, fp);
+		}
+
+		if (map->end < pos->end) {
+			struct map *after = map__clone(pos);
+
+			if (after == NULL)
+				return -ENOMEM;
+
+			after->start = map->end + 1;
+			map_groups__insert(self, after);
+			if (verbose >= 2)
+				map__fprintf(after, fp);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * XXX This should not really _copy_ te maps, but refcount them.
+ */
+int map_groups__clone(struct map_groups *self,
+		      struct map_groups *parent, enum map_type type)
+{
+	struct rb_node *nd;
+	for (nd = rb_first(&parent->maps[type]); nd; nd = rb_next(nd)) {
+		struct map *map = rb_entry(nd, struct map, rb_node);
+		struct map *new = map__clone(map);
+		if (new == NULL)
+			return -ENOMEM;
+		map_groups__insert(self, new);
+	}
+	return 0;
+}
+
 static u64 map__reloc_map_ip(struct map *map, u64 ip)
 {
 	return ip + (s64)map->pgoff;

commit 4b8cf84624e9a58a21aaac3d064222092ae234e0
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Mar 25 19:58:58 2010 -0300

    perf symbols: Move map related routines to map.c
    
    Thru series of refactorings functions were being renamed but not
    moved to map.c to reduce patch noise, now lets have them in the
    same place so that use of the symbol system by tools can be
    constrained to building and linking fewer source files:
    symbol.c, map.c and rbtree.c.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1269557941-15617-3-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index a9b42273675d..9f2963f9ee9a 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,8 +1,9 @@
 #include "symbol.h"
+#include <limits.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
-#include "debug.h"
+#include "map.h"
 
 const char *map_type__name[MAP__NR_TYPES] = {
 	[MAP__FUNCTION] = "Functions",
@@ -232,3 +233,84 @@ u64 map__objdump_2ip(struct map *map, u64 addr)
 			map->unmap_ip(map, addr);	/* RIP -> IP */
 	return ip;
 }
+
+struct symbol *map_groups__find_symbol(struct map_groups *self,
+				       enum map_type type, u64 addr,
+				       symbol_filter_t filter)
+{
+	struct map *map = map_groups__find(self, type, addr);
+
+	if (map != NULL)
+		return map__find_symbol(map, map->map_ip(map, addr), filter);
+
+	return NULL;
+}
+
+static u64 map__reloc_map_ip(struct map *map, u64 ip)
+{
+	return ip + (s64)map->pgoff;
+}
+
+static u64 map__reloc_unmap_ip(struct map *map, u64 ip)
+{
+	return ip - (s64)map->pgoff;
+}
+
+void map__reloc_vmlinux(struct map *self)
+{
+	struct kmap *kmap = map__kmap(self);
+	s64 reloc;
+
+	if (!kmap->ref_reloc_sym || !kmap->ref_reloc_sym->unrelocated_addr)
+		return;
+
+	reloc = (kmap->ref_reloc_sym->unrelocated_addr -
+		 kmap->ref_reloc_sym->addr);
+
+	if (!reloc)
+		return;
+
+	self->map_ip   = map__reloc_map_ip;
+	self->unmap_ip = map__reloc_unmap_ip;
+	self->pgoff    = reloc;
+}
+
+void maps__insert(struct rb_root *maps, struct map *map)
+{
+	struct rb_node **p = &maps->rb_node;
+	struct rb_node *parent = NULL;
+	const u64 ip = map->start;
+	struct map *m;
+
+	while (*p != NULL) {
+		parent = *p;
+		m = rb_entry(parent, struct map, rb_node);
+		if (ip < m->start)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+	}
+
+	rb_link_node(&map->rb_node, parent, p);
+	rb_insert_color(&map->rb_node, maps);
+}
+
+struct map *maps__find(struct rb_root *maps, u64 ip)
+{
+	struct rb_node **p = &maps->rb_node;
+	struct rb_node *parent = NULL;
+	struct map *m;
+
+	while (*p != NULL) {
+		parent = *p;
+		m = rb_entry(parent, struct map, rb_node);
+		if (ip < m->start)
+			p = &(*p)->rb_left;
+		else if (ip > m->end)
+			p = &(*p)->rb_right;
+		else
+			return m;
+	}
+
+	return NULL;
+}

commit b177f63f5226e75280855bbcd106e677250778bd
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Mar 25 19:58:57 2010 -0300

    perf symbols: Pass the mmap parameters instead of using mmap_event
    
    To reduce the coupling of the symbol system with the rest of
    perf.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1269557941-15617-2-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index e509cd59c67d..a9b42273675d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -1,4 +1,3 @@
-#include "event.h"
 #include "symbol.h"
 #include <stdlib.h>
 #include <string.h>
@@ -38,13 +37,12 @@ void map__init(struct map *self, enum map_type type,
 	RB_CLEAR_NODE(&self->rb_node);
 }
 
-struct map *map__new(struct mmap_event *event, enum map_type type,
-		     char *cwd, int cwdlen)
+struct map *map__new(u64 start, u64 len, u64 pgoff, u32 pid, char *filename,
+		     enum map_type type, char *cwd, int cwdlen)
 {
 	struct map *self = malloc(sizeof(*self));
 
 	if (self != NULL) {
-		const char *filename = event->filename;
 		char newfilename[PATH_MAX];
 		struct dso *dso;
 		int anon;
@@ -62,7 +60,7 @@ struct map *map__new(struct mmap_event *event, enum map_type type,
 		anon = is_anon_memory(filename);
 
 		if (anon) {
-			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", event->pid);
+			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);
 			filename = newfilename;
 		}
 
@@ -70,8 +68,7 @@ struct map *map__new(struct mmap_event *event, enum map_type type,
 		if (dso == NULL)
 			goto out_delete;
 
-		map__init(self, type, event->start, event->start + event->len,
-			  event->pgoff, dso);
+		map__init(self, type, start, start + len, pgoff, dso);
 
 		if (anon) {
 set_identity:

commit 3846df2e0a99a2bf10023de0e9c1496592012d4c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Feb 22 16:15:39 2010 -0300

    perf symbols: Improve debugging information about symtab origins
    
    Be more clear about DSO long names and tell from which file
    kernel symbols were obtained, all in --verbose mode:
    
        [root@mica ~]# perf report -v > /dev/null
        Looking at the vmlinux_path (5 entries long)
        Using /lib/modules/2.6.33-rc8-tip-00777-g0918527-dirty/build/vmlinux for symbols
        [root@mica ~]# mv /lib/modules/2.6.33-rc8-tip-00777-g0918527-dirty/build/vmlinux /tmp/dd
        [root@mica ~]# perf report -v > /dev/null
        Looking at the vmlinux_path (5 entries long)
        Using /proc/kallsyms for symbols
        [root@mica ~]#
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1266866139-6361-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 138e3cb2b727..e509cd59c67d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -5,6 +5,11 @@
 #include <stdio.h>
 #include "debug.h"
 
+const char *map_type__name[MAP__NR_TYPES] = {
+	[MAP__FUNCTION] = "Functions",
+	[MAP__VARIABLE] = "Variables",
+};
+
 static inline int is_anon_memory(const char *filename)
 {
 	return strcmp(filename, "//anon") == 0;

commit ee11b90b12eb1ec25e1044bac861e90bfd19ec9e
Author: Kirill Smelkov <kirr@landau.phys.spbu.ru>
Date:   Sun Feb 7 11:46:15 2010 -0200

    perf top: Fix annotate for userspace
    
    First, for programs and prelinked libraries, annotate code was
    fooled by objdump output IPs (src->eip in the code) being
    wrongly converted to absolute IPs. In such case there were no
    conversion needed, but in
    
       src->eip = strtoull(src->line, NULL, 16);
       src->eip = map->unmap_ip(map, src->eip); // = eip + map->start - map->pgoff
    
    we were reading absolute address from objdump (e.g. 8048604) and
    then almost doubling it, because eip & map->start are
    approximately close for small programs.
    
    Needless to say, that later, in record_precise_ip() there was no
    matching with real runtime IPs.
    
    And second, like with `perf annotate` the problem with
    non-prelinked *.so was that we were doing rip -> objdump address
    conversion wrong.
    
    Also, because unlike `perf annotate`, `perf top` code does
    annotation based on absolute IPs for performance reasons(*), new
    helper for mapping objdump addresse to IP is introduced.
    
    (*) we get samples info in absolute IPs, and since we do lots of
        hit-testing on absolute IPs at runtime in record_precise_ip(), it's
        better to convert objdump addresses to IPs once and do no conversion
        at runtime.
    
    I also had to fix how objdump output is parsed (with hardcoded
    8/16 characters format, which was inappropriate for ET_DYN dsos
    with small addresses like '4ac')
    
    Also note, that not all objdump output lines has associtated
    IPs, e.g. look at source lines here:
    
        000004ac <my_strlen>:
        extern "C"
        int my_strlen(const char *s)
         4ac:   55                      push   %ebp
         4ad:   89 e5                   mov    %esp,%ebp
         4af:   83 ec 10                sub    $0x10,%esp
        {
            int len = 0;
         4b2:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)
         4b9:   eb 08                   jmp    4c3 <my_strlen+0x17>
    
            while (*s) {
                ++len;
         4bb:   83 45 fc 01             addl   $0x1,-0x4(%ebp)
                ++s;
         4bf:   83 45 08 01             addl   $0x1,0x8(%ebp)
    
    So we mark them with eip=0, and ignore such lines in annotate
    lookup code.
    
    Signed-off-by: Kirill Smelkov <kirr@landau.phys.spbu.ru>
    [ Note: one hunk of this patch was applied by Mike in 57d8188 ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1265550376-12665-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index af5805f51314..138e3cb2b727 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -222,3 +222,11 @@ u64 map__rip_2objdump(struct map *map, u64 rip)
 			rip;
 	return addr;
 }
+
+u64 map__objdump_2ip(struct map *map, u64 addr)
+{
+	u64 ip = map->dso->adjust_symbols ?
+			addr :
+			map->unmap_ip(map, addr);	/* RIP -> IP */
+	return ip;
+}

commit 7a2b6209863626cf8362e5ff4653491558f91e67
Author: Kirill Smelkov <kirr@landau.phys.spbu.ru>
Date:   Wed Feb 3 16:52:07 2010 -0200

    perf annotate: Fix it for non-prelinked *.so
    
    The problem was we were incorrectly calculating objdump
    addresses for sym->start and sym->end, look:
    
    For simple ET_DYN type DSO (*.so) with one function, objdump -dS
    output is something like this:
    
        000004ac <my_strlen>:
        int my_strlen(const char *s)
         4ac:   55                      push   %ebp
         4ad:   89 e5                   mov    %esp,%ebp
         4af:   83 ec 10                sub    $0x10,%esp
        {
    
    i.e. we have relative-to-dso-mapping IPs (=RIP) there.
    
    For ET_EXEC type and probably for prelinked libs as well (sorry
    can't test - I don't use prelink) objdump outputs absolute IPs,
    e.g.
    
        08048604 <zz_strlen>:
        extern "C"
        int zz_strlen(const char *s)
         8048604:       55                      push   %ebp
         8048605:       89 e5                   mov    %esp,%ebp
         8048607:       83 ec 10                sub    $0x10,%esp
        {
    
    So, if sym->start is always relative to dso mapping(*), we'll
    have to unmap it for ET_EXEC like cases, and leave as is for
    ET_DYN cases.
    
    (*) and it is - we've explicitely made it relative. Look for
        adjust_symbols handling in dso__load_sym()
    
    Previously we were always unmapping sym->start and for ET_DYN
    dsos resulting addresses were wrong, and so objdump output was
    empty.
    
    The end result was that perf annotate output for symbols from
    non-prelinked *.so had always 0.00% percents only, which is
    wrong.
    
    To fix it, let's introduce a helper for converting rip to
    objdump address, and also let's document what map_ip() and
    unmap_ip() do -- I had to study sources for several hours to
    understand it.
    
    Signed-off-by: Kirill Smelkov <kirr@landau.phys.spbu.ru>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1265223128-11786-8-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index f6626cc3df2e..af5805f51314 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -210,3 +210,15 @@ size_t map__fprintf(struct map *self, FILE *fp)
 	return fprintf(fp, " %Lx-%Lx %Lx %s\n",
 		       self->start, self->end, self->pgoff, self->dso->name);
 }
+
+/*
+ * objdump wants/reports absolute IPs for ET_EXEC, and RIPs for ET_DYN.
+ * map->dso->adjust_symbols==1 for ET_EXEC-like cases.
+ */
+u64 map__rip_2objdump(struct map *map, u64 rip)
+{
+	u64 addr = map->dso->adjust_symbols ?
+			map->unmap_ip(map, rip) :	/* RIP -> IP */
+			rip;
+	return addr;
+}

commit 8d92c02ab07602786eaa6d4e5b519395730b3fd3
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Feb 3 16:52:02 2010 -0200

    perf symbols: Ditch vdso global variable
    
    We can check using strcmp, most DSOs don't start with '[' so the
    test is cheap enough and we had to test it there anyway since
    when reading perf.data files we weren't calling the routine that
    created this global variable and thus weren't setting it as
    "loaded", which was causing a bogus:
    
      Failed to open [vdso], continuing without symbols
    
    Message as the first line of 'perf report'.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1265223128-11786-3-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 36ff0bf0315d..f6626cc3df2e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -68,8 +68,13 @@ struct map *map__new(struct mmap_event *event, enum map_type type,
 		map__init(self, type, event->start, event->start + event->len,
 			  event->pgoff, dso);
 
-		if (self->dso == vdso || anon)
+		if (anon) {
+set_identity:
 			self->map_ip = self->unmap_ip = identity__map_ip;
+		} else if (strcmp(filename, "[vdso]") == 0) {
+			dso__set_loaded(dso, self->type);
+			goto set_identity;
+		}
 	}
 	return self;
 out_delete:

commit 9de89fe7c577847877ae00ea1aa6315559b10243
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Feb 3 16:52:00 2010 -0200

    perf symbols: Remove perf_session usage in symbols layer
    
    I noticed while writing the first test in 'perf regtest' that to
    just test the symbol handling routines one needs to create a
    perf session, that is a layer centered on a perf.data file,
    events, etc, so I untied these layers.
    
    This reduces the complexity for the users as the number of
    parameters to most of the symbols and session APIs now was
    reduced while not adding more state to all the map instances by
    only having data that is needed to split the kernel (kallsyms
    and ELF symtab sections) maps and do vmlinux relocation on the
    main kernel map.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1265223128-11786-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c4d55a0da2ea..36ff0bf0315d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -104,8 +104,7 @@ void map__fixup_end(struct map *self)
 
 #define DSO__DELETED "(deleted)"
 
-int map__load(struct map *self, struct perf_session *session,
-	      symbol_filter_t filter)
+int map__load(struct map *self, symbol_filter_t filter)
 {
 	const char *name = self->dso->long_name;
 	int nr;
@@ -113,7 +112,7 @@ int map__load(struct map *self, struct perf_session *session,
 	if (dso__loaded(self->dso, self->type))
 		return 0;
 
-	nr = dso__load(self->dso, self, session, filter);
+	nr = dso__load(self->dso, self, filter);
 	if (nr < 0) {
 		if (self->dso->has_build_id) {
 			char sbuild_id[BUILD_ID_SIZE * 2 + 1];
@@ -144,24 +143,29 @@ int map__load(struct map *self, struct perf_session *session,
 
 		return -1;
 	}
+	/*
+	 * Only applies to the kernel, as its symtabs aren't relative like the
+	 * module ones.
+	 */
+	if (self->dso->kernel)
+		map__reloc_vmlinux(self);
 
 	return 0;
 }
 
-struct symbol *map__find_symbol(struct map *self, struct perf_session *session,
-				u64 addr, symbol_filter_t filter)
+struct symbol *map__find_symbol(struct map *self, u64 addr,
+				symbol_filter_t filter)
 {
-	if (map__load(self, session, filter) < 0)
+	if (map__load(self, filter) < 0)
 		return NULL;
 
 	return dso__find_symbol(self->dso, self->type, addr);
 }
 
 struct symbol *map__find_symbol_by_name(struct map *self, const char *name,
-					struct perf_session *session,
 					symbol_filter_t filter)
 {
-	if (map__load(self, session, filter) < 0)
+	if (map__load(self, filter) < 0)
 		return NULL;
 
 	if (!dso__sorted_by_name(self->dso, self->type))

commit a128168d1e79e537d6666655e7771d973e9230e3
Author: Masami Hiramatsu <mhiramat@redhat.com>
Date:   Tue Dec 15 10:32:33 2009 -0500

    perf probe: Check build-id of vmlinux
    
    Check build-id of vmlinux by using functions in symbol.c.
    This also exposes map__load() for getting vmlinux path,
    and removes vmlinux path list in builtin-probe.c,
    because symbol.c already has that. Checking build-id
    prevents users to open old or different debuginfo from
    current running kernel.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jim Keniston <jkenisto@us.ibm.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Frank Ch. Eigler <fche@redhat.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: K.Prasad <prasad@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: systemtap <systemtap@sources.redhat.com>
    Cc: DLE <dle-develop@lists.sourceforge.net>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <20091215153232.17436.45539.stgit@dhcp-100-2-132.bos.redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 8b3dd467adb5..c4d55a0da2ea 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -104,12 +104,16 @@ void map__fixup_end(struct map *self)
 
 #define DSO__DELETED "(deleted)"
 
-static int map__load(struct map *self, struct perf_session *session,
-		     symbol_filter_t filter)
+int map__load(struct map *self, struct perf_session *session,
+	      symbol_filter_t filter)
 {
 	const char *name = self->dso->long_name;
-	int nr = dso__load(self->dso, self, session, filter);
+	int nr;
 
+	if (dso__loaded(self->dso, self->type))
+		return 0;
+
+	nr = dso__load(self->dso, self, session, filter);
 	if (nr < 0) {
 		if (self->dso->has_build_id) {
 			char sbuild_id[BUILD_ID_SIZE * 2 + 1];
@@ -147,7 +151,7 @@ static int map__load(struct map *self, struct perf_session *session,
 struct symbol *map__find_symbol(struct map *self, struct perf_session *session,
 				u64 addr, symbol_filter_t filter)
 {
-	if (!dso__loaded(self->dso, self->type) && map__load(self, session, filter) < 0)
+	if (map__load(self, session, filter) < 0)
 		return NULL;
 
 	return dso__find_symbol(self->dso, self->type, addr);
@@ -157,7 +161,7 @@ struct symbol *map__find_symbol_by_name(struct map *self, const char *name,
 					struct perf_session *session,
 					symbol_filter_t filter)
 {
-	if (!dso__loaded(self->dso, self->type) && map__load(self, session, filter) < 0)
+	if (map__load(self, session, filter) < 0)
 		return NULL;
 
 	if (!dso__sorted_by_name(self->dso, self->type))

commit 4aa65636411ccb12f006a6ad593930655c445ff6
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Dec 13 19:50:29 2009 -0200

    perf session: Move kmaps to perf_session
    
    There is still some more work to do to disentangle map creation
    from DSO loading, but this happens only for the kernel, and for
    the early adopters of perf diff, where this disentanglement
    matters most, we'll be testing different kernels, so no problem
    here.
    
    Further clarification: right now we create the kernel maps for
    the various modules and discontiguous kernel text maps when
    loading the DSO, we should do it as a two step process, first
    creating the maps, for multiple mappings with the same DSO
    store, then doing the dso load just once, for the first hit on
    one of the maps sharing this DSO backing store.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1260741029-4430-6-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 76bdca640a9b..8b3dd467adb5 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -104,10 +104,11 @@ void map__fixup_end(struct map *self)
 
 #define DSO__DELETED "(deleted)"
 
-static int map__load(struct map *self, symbol_filter_t filter)
+static int map__load(struct map *self, struct perf_session *session,
+		     symbol_filter_t filter)
 {
 	const char *name = self->dso->long_name;
-	int nr = dso__load(self->dso, self, filter);
+	int nr = dso__load(self->dso, self, session, filter);
 
 	if (nr < 0) {
 		if (self->dso->has_build_id) {
@@ -143,19 +144,20 @@ static int map__load(struct map *self, symbol_filter_t filter)
 	return 0;
 }
 
-struct symbol *map__find_symbol(struct map *self, u64 addr,
-				symbol_filter_t filter)
+struct symbol *map__find_symbol(struct map *self, struct perf_session *session,
+				u64 addr, symbol_filter_t filter)
 {
-	if (!dso__loaded(self->dso, self->type) && map__load(self, filter) < 0)
+	if (!dso__loaded(self->dso, self->type) && map__load(self, session, filter) < 0)
 		return NULL;
 
 	return dso__find_symbol(self->dso, self->type, addr);
 }
 
 struct symbol *map__find_symbol_by_name(struct map *self, const char *name,
+					struct perf_session *session,
 					symbol_filter_t filter)
 {
-	if (!dso__loaded(self->dso, self->type) && map__load(self, filter) < 0)
+	if (!dso__loaded(self->dso, self->type) && map__load(self, session, filter) < 0)
 		return NULL;
 
 	if (!dso__sorted_by_name(self->dso, self->type))

commit ea08d8cbd162fe3756e3e2298efbe0b8b12f92d1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Dec 11 18:56:39 2009 -0200

    perf symbols: Ditch dso->find_symbol
    
    It is always wired to dso__find_symbol.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1260564999-13371-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 175f1f6b6914..76bdca640a9b 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -149,7 +149,7 @@ struct symbol *map__find_symbol(struct map *self, u64 addr,
 	if (!dso__loaded(self->dso, self->type) && map__load(self, filter) < 0)
 		return NULL;
 
-	return self->dso->find_symbol(self->dso, self->type, addr);
+	return dso__find_symbol(self->dso, self->type, addr);
 }
 
 struct symbol *map__find_symbol_by_name(struct map *self, const char *name,

commit 79406cd789f745ac6aa9d597895f904a98a14007
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Dec 11 18:50:22 2009 -0200

    perf symbols: Allow lookups by symbol name too
    
    Configurable via symbol_conf.sort_by_name, so that the cost of an
    extra rb_node on all 'struct symbol' instances is not paid by tools
    that only want to decode addresses.
    
    How to use it:
    
            symbol_conf.sort_by_name = true;
            symbol_init(&symbol_conf);
    
            struct map *map = map_groups__find_by_name(kmaps, MAP__VARIABLE, "[kernel.kallsyms]");
    
            if (map == NULL) {
                    pr_err("couldn't find map!\n");
                    kernel_maps__fprintf(stdout);
            } else {
                    struct symbol *sym = map__find_symbol_by_name(map, sym_filter, NULL);
                    if (sym == NULL)
                            pr_err("couldn't find symbol %s!\n", sym_filter);
                    else
                            pr_info("symbol %s: %#Lx-%#Lx \n", sym_filter, sym->start, sym->end);
            }
    
    Looking over the vmlinux/kallsyms is common enough that I'll add a
    variable to the upcoming struct perf_session to avoid the need to
    use map_groups__find_by_name to get the main vmlinux/kallsyms map.
    
    The above example looks on the 'variable' symtab, but it is just
    like that for the functions one.
    
    Also the sort operation is done when we first use
    map__find_symbol_by_name, in a lazy way.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Masami Hiramatsu <mhiramat@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1260564622-12392-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 69f94fe9db20..175f1f6b6914 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -104,45 +104,66 @@ void map__fixup_end(struct map *self)
 
 #define DSO__DELETED "(deleted)"
 
-struct symbol *map__find_symbol(struct map *self, u64 addr,
-				symbol_filter_t filter)
+static int map__load(struct map *self, symbol_filter_t filter)
 {
-	if (!dso__loaded(self->dso, self->type)) {
-		int nr = dso__load(self->dso, self, filter);
-
-		if (nr < 0) {
-			if (self->dso->has_build_id) {
-				char sbuild_id[BUILD_ID_SIZE * 2 + 1];
-
-				build_id__sprintf(self->dso->build_id,
-						  sizeof(self->dso->build_id),
-						  sbuild_id);
-				pr_warning("%s with build id %s not found",
-					   self->dso->long_name, sbuild_id);
-			} else
-				pr_warning("Failed to open %s",
-					   self->dso->long_name);
-			pr_warning(", continuing without symbols\n");
-			return NULL;
-		} else if (nr == 0) {
-			const char *name = self->dso->long_name;
-			const size_t len = strlen(name);
-			const size_t real_len = len - sizeof(DSO__DELETED);
-
-			if (len > sizeof(DSO__DELETED) &&
-			    strcmp(name + real_len + 1, DSO__DELETED) == 0) {
-				pr_warning("%.*s was updated, restart the long running apps that use it!\n",
-					   (int)real_len, name);
-			} else {
-				pr_warning("no symbols found in %s, maybe install a debug package?\n", name);
-			}
-			return NULL;
+	const char *name = self->dso->long_name;
+	int nr = dso__load(self->dso, self, filter);
+
+	if (nr < 0) {
+		if (self->dso->has_build_id) {
+			char sbuild_id[BUILD_ID_SIZE * 2 + 1];
+
+			build_id__sprintf(self->dso->build_id,
+					  sizeof(self->dso->build_id),
+					  sbuild_id);
+			pr_warning("%s with build id %s not found",
+				   name, sbuild_id);
+		} else
+			pr_warning("Failed to open %s", name);
+
+		pr_warning(", continuing without symbols\n");
+		return -1;
+	} else if (nr == 0) {
+		const size_t len = strlen(name);
+		const size_t real_len = len - sizeof(DSO__DELETED);
+
+		if (len > sizeof(DSO__DELETED) &&
+		    strcmp(name + real_len + 1, DSO__DELETED) == 0) {
+			pr_warning("%.*s was updated, restart the long "
+				   "running apps that use it!\n",
+				   (int)real_len, name);
+		} else {
+			pr_warning("no symbols found in %s, maybe install "
+				   "a debug package?\n", name);
 		}
+
+		return -1;
 	}
 
+	return 0;
+}
+
+struct symbol *map__find_symbol(struct map *self, u64 addr,
+				symbol_filter_t filter)
+{
+	if (!dso__loaded(self->dso, self->type) && map__load(self, filter) < 0)
+		return NULL;
+
 	return self->dso->find_symbol(self->dso, self->type, addr);
 }
 
+struct symbol *map__find_symbol_by_name(struct map *self, const char *name,
+					symbol_filter_t filter)
+{
+	if (!dso__loaded(self->dso, self->type) && map__load(self, filter) < 0)
+		return NULL;
+
+	if (!dso__sorted_by_name(self->dso, self->type))
+		dso__sort_by_name(self->dso, self->type);
+
+	return dso__find_symbol_by_name(self->dso, self->type, name);
+}
+
 struct map *map__clone(struct map *self)
 {
 	struct map *map = malloc(sizeof(*self));

commit 6a4694a433a218c729d336b348a01bfc720da095
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 27 16:29:17 2009 -0200

    perf symbols: Better support for multiple symbol tables per dso
    
    By using an array of rb_roots in struct dso we can, from a
    struct map instance to get the right symbol rb_tree more easily.
    This way we can have just one symbol lookup method for struct
    map instances, map__find_symbol, instead of one per symtab type
    (functions, variables).
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1259346563-12568-6-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 52bb4c6cf74d..69f94fe9db20 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -82,8 +82,9 @@ void map__delete(struct map *self)
 	free(self);
 }
 
-void map__fixup_start(struct map *self, struct rb_root *symbols)
+void map__fixup_start(struct map *self)
 {
+	struct rb_root *symbols = &self->dso->symbols[self->type];
 	struct rb_node *nd = rb_first(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
@@ -91,8 +92,9 @@ void map__fixup_start(struct map *self, struct rb_root *symbols)
 	}
 }
 
-void map__fixup_end(struct map *self, struct rb_root *symbols)
+void map__fixup_end(struct map *self)
 {
+	struct rb_root *symbols = &self->dso->symbols[self->type];
 	struct rb_node *nd = rb_last(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
@@ -102,8 +104,8 @@ void map__fixup_end(struct map *self, struct rb_root *symbols)
 
 #define DSO__DELETED "(deleted)"
 
-struct symbol *map__find_function(struct map *self, u64 ip,
-				  symbol_filter_t filter)
+struct symbol *map__find_symbol(struct map *self, u64 addr,
+				symbol_filter_t filter)
 {
 	if (!dso__loaded(self->dso, self->type)) {
 		int nr = dso__load(self->dso, self, filter);
@@ -138,7 +140,7 @@ struct symbol *map__find_function(struct map *self, u64 ip,
 		}
 	}
 
-	return self->dso->find_function(self->dso, ip);
+	return self->dso->find_symbol(self->dso, self->type, addr);
 }
 
 struct map *map__clone(struct map *self)

commit 3610583c29563e23dd038d2870f59c88438bf7a3
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 27 16:29:16 2009 -0200

    perf symbols: Add a 'type' field to struct map
    
    That way we will be able to check if the right symtab is loaded
    in the underlying DSO.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1259346563-12568-5-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 41c5c4a20010..52bb4c6cf74d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -20,9 +20,10 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 	return n;
 }
 
-void map__init(struct map *self, u64 start, u64 end, u64 pgoff,
-	       struct dso *dso)
+void map__init(struct map *self, enum map_type type,
+	       u64 start, u64 end, u64 pgoff, struct dso *dso)
 {
+	self->type     = type;
 	self->start    = start;
 	self->end      = end;
 	self->pgoff    = pgoff;
@@ -32,7 +33,8 @@ void map__init(struct map *self, u64 start, u64 end, u64 pgoff,
 	RB_CLEAR_NODE(&self->rb_node);
 }
 
-struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
+struct map *map__new(struct mmap_event *event, enum map_type type,
+		     char *cwd, int cwdlen)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -63,7 +65,7 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
 		if (dso == NULL)
 			goto out_delete;
 
-		map__init(self, event->start, event->start + event->len,
+		map__init(self, type, event->start, event->start + event->len,
 			  event->pgoff, dso);
 
 		if (self->dso == vdso || anon)
@@ -103,7 +105,7 @@ void map__fixup_end(struct map *self, struct rb_root *symbols)
 struct symbol *map__find_function(struct map *self, u64 ip,
 				  symbol_filter_t filter)
 {
-	if (!self->dso->loaded) {
+	if (!dso__loaded(self->dso, self->type)) {
 		int nr = dso__load(self->dso, self, filter);
 
 		if (nr < 0) {

commit fcf1203a919c3a3d212c0ed01f5240fd592bf5ae
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Nov 24 13:01:52 2009 -0200

    perf symbols: Rename find_symbol routines to find_function
    
    Paving the way for supporting variable in adition to function
    symbols.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1259074912-5924-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 09412321a80d..41c5c4a20010 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -80,18 +80,18 @@ void map__delete(struct map *self)
 	free(self);
 }
 
-void map__fixup_start(struct map *self)
+void map__fixup_start(struct map *self, struct rb_root *symbols)
 {
-	struct rb_node *nd = rb_first(&self->dso->syms);
+	struct rb_node *nd = rb_first(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
 		self->start = sym->start;
 	}
 }
 
-void map__fixup_end(struct map *self)
+void map__fixup_end(struct map *self, struct rb_root *symbols)
 {
-	struct rb_node *nd = rb_last(&self->dso->syms);
+	struct rb_node *nd = rb_last(symbols);
 	if (nd != NULL) {
 		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
 		self->end = sym->end;
@@ -100,8 +100,8 @@ void map__fixup_end(struct map *self)
 
 #define DSO__DELETED "(deleted)"
 
-struct symbol *
-map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
+struct symbol *map__find_function(struct map *self, u64 ip,
+				  symbol_filter_t filter)
 {
 	if (!self->dso->loaded) {
 		int nr = dso__load(self->dso, self, filter);
@@ -136,7 +136,7 @@ map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
 		}
 	}
 
-	return self->dso->find_symbol(self->dso, ip);
+	return self->dso->find_function(self->dso, ip);
 }
 
 struct map *map__clone(struct map *self)

commit c338aee853db197e1855b393e6d6cc667784537f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 20 20:51:27 2009 -0200

    perf symbols: Do lazy symtab loading for the kernel & modules too
    
    Just like we do with the other DSOs. This also simplifies the
    kernel_maps setup process, now all that the tools need to do is
    to call kernel_maps__init and the maps for the modules and
    kernel will be created, then, later, when
    kernel_maps__find_symbol() is used, it will also call
    maps__find_symbol that already checks if the symtab was loaded,
    loading it if needed.
    
    Now if one does 'perf top --hide_kernel_symbols' we won't pay
    the price of loading the (many) symbols in /proc/kallsyms or
    vmlinux.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1258757489-5978-4-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 94ca95073c40..09412321a80d 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -75,6 +75,29 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
 	return NULL;
 }
 
+void map__delete(struct map *self)
+{
+	free(self);
+}
+
+void map__fixup_start(struct map *self)
+{
+	struct rb_node *nd = rb_first(&self->dso->syms);
+	if (nd != NULL) {
+		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
+		self->start = sym->start;
+	}
+}
+
+void map__fixup_end(struct map *self)
+{
+	struct rb_node *nd = rb_last(&self->dso->syms);
+	if (nd != NULL) {
+		struct symbol *sym = rb_entry(nd, struct symbol, rb_node);
+		self->end = sym->end;
+	}
+}
+
 #define DSO__DELETED "(deleted)"
 
 struct symbol *

commit 8d06367fa79c053a4a56a2ce0bb9e840f5da1236
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Nov 4 18:50:43 2009 -0200

    perf symbols: Use the buildids if present
    
    With this change 'perf record' will intercept PERF_RECORD_MMAP
    calls, creating a linked list of DSOs, then when the session
    finishes, it will traverse this list and read the buildids,
    stashing them at the end of the file and will set up a new
    feature bit in the header bitmask.
    
    'perf report' will then notice this feature and populate the
    'dsos' list and set the build ids.
    
    When reading the symtabs it will refuse to load from a file that
    doesn't have the same build id. This improves the
    reliability of the profiler output, as symbols and profiling
    data is more guaranteed to match.
    
    Example:
    
     [root@doppio ~]# perf report | head
     /home/acme/bin/perf with build id b1ea544ac3746e7538972548a09aadecc5753868 not found, continuing without symbols
      # Samples: 2621434559
      #
      # Overhead          Command                  Shared Object  Symbol
      # ........  ...............  .............................  ......
      #
           7.91%             init  [kernel]        [k] read_hpet
           7.64%             init  [kernel]        [k] mwait_idle_with_hints
           7.60%          swapper  [kernel]        [k] read_hpet
           7.60%          swapper  [kernel]        [k] mwait_idle_with_hints
           3.65%             init  [kernel]        [k] 0xffffffffa02339d9
    [root@doppio ~]#
    
    In this case the 'perf' binary was an older one, vanished,
    so its symbols probably wouldn't match or would cause subtly
    different (and misleading) output.
    
    Next patches will support the kernel as well, reading the build
    id notes for it and the modules from /sys.
    
    Another patch should also introduce a new plumbing command:
    
    'perf list-buildids'
    
    that will then be used in porcelain that is distro specific to
    fetch -debuginfo packages where such buildids are present. This
    will in turn allow for one to run 'perf record' in one machine
    and 'perf report' in another.
    
    Future work on having the buildid sent directly from the kernel
    in the PERF_RECORD_MMAP event is needed to close races, as the
    DSO can be changed during a 'perf record' session, but this
    patch at least helps with non-corner cases and current/older
    kernels.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Frank Ch. Eigler <fche@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Jim Keniston <jkenisto@us.ibm.com>
    Cc: K. Prasad <prasad@linux.vnet.ibm.com>
    Cc: Masami Hiramatsu <mhiramat@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    LKML-Reference: <1257367843-26224-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 33f868420d73..94ca95073c40 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -84,8 +84,18 @@ map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
 		int nr = dso__load(self->dso, self, filter);
 
 		if (nr < 0) {
-			pr_warning("Failed to open %s, continuing without symbols\n",
-				   self->dso->long_name);
+			if (self->dso->has_build_id) {
+				char sbuild_id[BUILD_ID_SIZE * 2 + 1];
+
+				build_id__sprintf(self->dso->build_id,
+						  sizeof(self->dso->build_id),
+						  sbuild_id);
+				pr_warning("%s with build id %s not found",
+					   self->dso->long_name, sbuild_id);
+			} else
+				pr_warning("Failed to open %s",
+					   self->dso->long_name);
+			pr_warning(", continuing without symbols\n");
 			return NULL;
 		} else if (nr == 0) {
 			const char *name = self->dso->long_name;

commit 900b20d5900045fb9b48f2fb3d80cbdbae3f44c0
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Nov 2 19:25:25 2009 +0100

    perf tools: Fix missing symtabs printouts
    
    Fix:
    
      util/map.c: In function map__find_symbol:
      util/map.c:97: error: field precision should have type int, but argument 3 has type size_t
    
    Also clean up some line wrap damage - we dont line-wrap printk
    messages.
    
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256927305-4628-3-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index f1e216955420..33f868420d73 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -93,13 +93,12 @@ map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
 			const size_t real_len = len - sizeof(DSO__DELETED);
 
 			if (len > sizeof(DSO__DELETED) &&
-			    strcmp(name + real_len + 1, DSO__DELETED) == 0)
-				pr_warning("%.*s was updated, restart the "
-					   "long running apps that use it!\n",
-					   real_len, name);
-			else
-				pr_warning("no symbols found in %s, maybe "
-					   "install a debug package?\n", name);
+			    strcmp(name + real_len + 1, DSO__DELETED) == 0) {
+				pr_warning("%.*s was updated, restart the long running apps that use it!\n",
+					   (int)real_len, name);
+			} else {
+				pr_warning("no symbols found in %s, maybe install a debug package?\n", name);
+			}
 			return NULL;
 		}
 	}

commit d70a5402f9c2e2671b809363616b3508b4c5a565
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Oct 30 16:28:25 2009 -0200

    perf tools: Improve message about missing symtabs for deleted DSOs
    
    Instead of:
    
      no symbols found in /usr/lib/gstreamer-0.10/libgsttypefindfunctions.so (deleted), maybe install a debug package?
      no symbols found in /usr/lib/gstreamer-0.10/libgstaudioconvert.so (deleted), maybe install a debug package?
    
    We now emit:
    
      /usr/lib/gstreamer-0.10/libgsttypefindfunctions.so was updated, restart the long running apps that use it!
      /usr/lib/gstreamer-0.10/libgstaudioconvert.so was updated, restart the long running apps that use it!
    
    Which is far less misleading about what the cause of the
    symbol mismatch is.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256927305-4628-3-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 679011c1b6d1..f1e216955420 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -75,6 +75,8 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
 	return NULL;
 }
 
+#define DSO__DELETED "(deleted)"
+
 struct symbol *
 map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
 {
@@ -86,8 +88,18 @@ map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
 				   self->dso->long_name);
 			return NULL;
 		} else if (nr == 0) {
-			pr_warning("No symbols found in %s, maybe install a debug package?\n",
-				   self->dso->long_name);
+			const char *name = self->dso->long_name;
+			const size_t len = strlen(name);
+			const size_t real_len = len - sizeof(DSO__DELETED);
+
+			if (len > sizeof(DSO__DELETED) &&
+			    strcmp(name + real_len + 1, DSO__DELETED) == 0)
+				pr_warning("%.*s was updated, restart the "
+					   "long running apps that use it!\n",
+					   real_len, name);
+			else
+				pr_warning("no symbols found in %s, maybe "
+					   "install a debug package?\n", name);
 			return NULL;
 		}
 	}

commit 00a192b395b0606ad0265243844b3cd68e73420a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Oct 30 16:28:24 2009 -0200

    perf tools: Simplify the symbol priv area mechanism
    
    Before we were storing this in the DSO, but in fact this is a
    property of the 'symbol' class, not something that will vary
    among DSOs, so move it to a global variable and initialize it
    using the existing symbol__init routine.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256927305-4628-2-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 3b7ce1bf9f8e..679011c1b6d1 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -32,8 +32,7 @@ void map__init(struct map *self, u64 start, u64 end, u64 pgoff,
 	RB_CLEAR_NODE(&self->rb_node);
 }
 
-struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
-		     unsigned int sym_priv_size)
+struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -60,7 +59,7 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 			filename = newfilename;
 		}
 
-		dso = dsos__findnew(filename, sym_priv_size);
+		dso = dsos__findnew(filename);
 		if (dso == NULL)
 			goto out_delete;
 

commit afb7b4f08e274cecd8337f9444affa288a9cd4c1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Oct 30 16:28:23 2009 -0200

    perf tools: Factor out the map initialization
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256927305-4628-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index d302e513e062..3b7ce1bf9f8e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -20,6 +20,18 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 	return n;
 }
 
+void map__init(struct map *self, u64 start, u64 end, u64 pgoff,
+	       struct dso *dso)
+{
+	self->start    = start;
+	self->end      = end;
+	self->pgoff    = pgoff;
+	self->dso      = dso;
+	self->map_ip   = map__map_ip;
+	self->unmap_ip = map__unmap_ip;
+	RB_CLEAR_NODE(&self->rb_node);
+}
+
 struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 		     unsigned int sym_priv_size)
 {
@@ -28,6 +40,7 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 	if (self != NULL) {
 		const char *filename = event->filename;
 		char newfilename[PATH_MAX];
+		struct dso *dso;
 		int anon;
 
 		if (cwd) {
@@ -47,20 +60,15 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 			filename = newfilename;
 		}
 
-		self->start = event->start;
-		self->end   = event->start + event->len;
-		self->pgoff = event->pgoff;
-
-		self->dso = dsos__findnew(filename, sym_priv_size);
-		if (self->dso == NULL)
+		dso = dsos__findnew(filename, sym_priv_size);
+		if (dso == NULL)
 			goto out_delete;
 
+		map__init(self, event->start, event->start + event->len,
+			  event->pgoff, dso);
+
 		if (self->dso == vdso || anon)
 			self->map_ip = self->unmap_ip = identity__map_ip;
-		else {
-			self->map_ip = map__map_ip;
-			self->unmap_ip = map__unmap_ip;
-		}
 	}
 	return self;
 out_delete:

commit 66bd8424cc05e800db384053bf7ab967e4658468
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Oct 28 21:51:21 2009 -0200

    perf tools: Delay loading symtabs till we hit a map with it
    
    So that we can have a quicker start on perf top and even
    speedups in the other tools, as we can have maps with no hits,
    so no need to load its symtabs.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256773881-4191-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index c1c556825343..d302e513e062 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -21,7 +21,7 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 }
 
 struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
-		     unsigned int sym_priv_size, symbol_filter_t filter)
+		     unsigned int sym_priv_size)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -29,7 +29,6 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 		const char *filename = event->filename;
 		char newfilename[PATH_MAX];
 		int anon;
-		bool new_dso;
 
 		if (cwd) {
 			int n = strcommon(filename, cwd, cwdlen);
@@ -52,23 +51,10 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 		self->end   = event->start + event->len;
 		self->pgoff = event->pgoff;
 
-		self->dso = dsos__findnew(filename, sym_priv_size, &new_dso);
+		self->dso = dsos__findnew(filename, sym_priv_size);
 		if (self->dso == NULL)
 			goto out_delete;
 
-		if (new_dso) {
-			int nr = dso__load(self->dso, self, filter);
-
-			if (nr < 0)
-				pr_warning("Failed to open %s, continuing "
-					   "without symbols\n",
-					   self->dso->long_name);
-			else if (nr == 0)
-				pr_warning("No symbols found in %s, maybe "
-					   "install a debug package?\n",
-					   self->dso->long_name);
-		}
-
 		if (self->dso == vdso || anon)
 			self->map_ip = self->unmap_ip = identity__map_ip;
 		else {
@@ -82,6 +68,26 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 	return NULL;
 }
 
+struct symbol *
+map__find_symbol(struct map *self, u64 ip, symbol_filter_t filter)
+{
+	if (!self->dso->loaded) {
+		int nr = dso__load(self->dso, self, filter);
+
+		if (nr < 0) {
+			pr_warning("Failed to open %s, continuing without symbols\n",
+				   self->dso->long_name);
+			return NULL;
+		} else if (nr == 0) {
+			pr_warning("No symbols found in %s, maybe install a debug package?\n",
+				   self->dso->long_name);
+			return NULL;
+		}
+	}
+
+	return self->dso->find_symbol(self->dso, ip);
+}
+
 struct map *map__clone(struct map *self)
 {
 	struct map *map = malloc(sizeof(*self));

commit 6beba7adbe092e63dfe8d09fbd1e3ec140474a13
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Oct 21 17:34:06 2009 -0200

    perf tools: Unify debug messages mechanisms
    
    We were using eprintf in some places, that looks at a global
    'verbose' level, and at other places passing a 'v' parameter to
    specify the verbosity level, unify it by introducing
    pr_{err,warning,debug,etc}, just like in the kernel.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256153646-10097-1-git-send-email-acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 55079c0200e0..c1c556825343 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -21,8 +21,7 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 }
 
 struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
-		     unsigned int sym_priv_size, symbol_filter_t filter,
-		     int v)
+		     unsigned int sym_priv_size, symbol_filter_t filter)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -58,16 +57,16 @@ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
 			goto out_delete;
 
 		if (new_dso) {
-			int nr = dso__load(self->dso, self, filter, v);
+			int nr = dso__load(self->dso, self, filter);
 
 			if (nr < 0)
-				eprintf("Failed to open %s, continuing "
-					"without symbols\n",
-					self->dso->long_name);
+				pr_warning("Failed to open %s, continuing "
+					   "without symbols\n",
+					   self->dso->long_name);
 			else if (nr == 0)
-				eprintf("No symbols found in %s, maybe "
-					"install a debug package?\n",
-					self->dso->long_name);
+				pr_warning("No symbols found in %s, maybe "
+					   "install a debug package?\n",
+					   self->dso->long_name);
 		}
 
 		if (self->dso == vdso || anon)

commit e42049926ebdcae24fdfdc8f0e3ff8f05f24a60b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Oct 20 14:25:40 2009 -0200

    perf annotate: Use the sym_priv_size area for the histogram
    
    We have this sym_priv_size mechanism for attaching private areas
    to struct symbol entries but annotate wasn't using it, adding
    private areas to struct symbol in addition to a ->priv pointer.
    
    Scrap all that and use the sym_priv_size mechanism.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1256055940-19511-1-git-send-email-acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 4e203d144f9e..55079c0200e0 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
+#include "debug.h"
 
 static inline int is_anon_memory(const char *filename)
 {
@@ -19,7 +20,9 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 	return n;
 }
 
- struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
+struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen,
+		     unsigned int sym_priv_size, symbol_filter_t filter,
+		     int v)
 {
 	struct map *self = malloc(sizeof(*self));
 
@@ -27,6 +30,7 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 		const char *filename = event->filename;
 		char newfilename[PATH_MAX];
 		int anon;
+		bool new_dso;
 
 		if (cwd) {
 			int n = strcommon(filename, cwd, cwdlen);
@@ -49,10 +53,23 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 		self->end   = event->start + event->len;
 		self->pgoff = event->pgoff;
 
-		self->dso = dsos__findnew(filename);
+		self->dso = dsos__findnew(filename, sym_priv_size, &new_dso);
 		if (self->dso == NULL)
 			goto out_delete;
 
+		if (new_dso) {
+			int nr = dso__load(self->dso, self, filter, v);
+
+			if (nr < 0)
+				eprintf("Failed to open %s, continuing "
+					"without symbols\n",
+					self->dso->long_name);
+			else if (nr == 0)
+				eprintf("No symbols found in %s, maybe "
+					"install a debug package?\n",
+					self->dso->long_name);
+		}
+
 		if (self->dso == vdso || anon)
 			self->map_ip = self->unmap_ip = identity__map_ip;
 		else {

commit ed52ce2e3c33dc7626a40fa2da766d1a6460e543
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 19 17:17:57 2009 -0200

    perf tools: Add ->unmap_ip operation to struct map
    
    We need this because we get section relative addresses when
    reading the symtabs, but when a tool like 'perf annotate' needs
    to match these address to what 'objdump -dS' produces we need
    the address + section back again.
    
    So in annotate now we look at the 'struct hist_entry' instances
    (that weren't really being used) so that we iterate only over
    the symbols that had some hit and get the map where that
    particular hit happened so that we can get the right address to
    match with annotate.
    
    Verified that at least:
    
     perf annotate mmap_read_counter # Uses the ~/bin/perf binary
     perf annotate --vmlinux /home/acme/git/build/perf/vmlinux intel_pmu_enable_all
    
    on a 'perf record perf top' session seems to work.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1255979877-12533-1-git-send-email-acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 804e02382739..4e203d144f9e 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -54,9 +54,11 @@ static int strcommon(const char *pathname, char *cwd, int cwdlen)
 			goto out_delete;
 
 		if (self->dso == vdso || anon)
-			self->map_ip = vdso__map_ip;
-		else
+			self->map_ip = self->unmap_ip = identity__map_ip;
+		else {
 			self->map_ip = map__map_ip;
+			self->unmap_ip = map__unmap_ip;
+		}
 	}
 	return self;
 out_delete:

commit 66e274f3b8d7fc89d38997e85b900e188f8d5cc0
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Aug 12 11:07:25 2009 +0200

    perf tools: Factorize the map helpers
    
    Factorize the dso mapping helpers into a single purpose common file
    "util/map.c"
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Brice Goglin <Brice.Goglin@inria.fr>

diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
new file mode 100644
index 000000000000..804e02382739
--- /dev/null
+++ b/tools/perf/util/map.c
@@ -0,0 +1,97 @@
+#include "event.h"
+#include "symbol.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+static inline int is_anon_memory(const char *filename)
+{
+	return strcmp(filename, "//anon") == 0;
+}
+
+static int strcommon(const char *pathname, char *cwd, int cwdlen)
+{
+	int n = 0;
+
+	while (n < cwdlen && pathname[n] == cwd[n])
+		++n;
+
+	return n;
+}
+
+ struct map *map__new(struct mmap_event *event, char *cwd, int cwdlen)
+{
+	struct map *self = malloc(sizeof(*self));
+
+	if (self != NULL) {
+		const char *filename = event->filename;
+		char newfilename[PATH_MAX];
+		int anon;
+
+		if (cwd) {
+			int n = strcommon(filename, cwd, cwdlen);
+
+			if (n == cwdlen) {
+				snprintf(newfilename, sizeof(newfilename),
+					 ".%s", filename + n);
+				filename = newfilename;
+			}
+		}
+
+		anon = is_anon_memory(filename);
+
+		if (anon) {
+			snprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", event->pid);
+			filename = newfilename;
+		}
+
+		self->start = event->start;
+		self->end   = event->start + event->len;
+		self->pgoff = event->pgoff;
+
+		self->dso = dsos__findnew(filename);
+		if (self->dso == NULL)
+			goto out_delete;
+
+		if (self->dso == vdso || anon)
+			self->map_ip = vdso__map_ip;
+		else
+			self->map_ip = map__map_ip;
+	}
+	return self;
+out_delete:
+	free(self);
+	return NULL;
+}
+
+struct map *map__clone(struct map *self)
+{
+	struct map *map = malloc(sizeof(*self));
+
+	if (!map)
+		return NULL;
+
+	memcpy(map, self, sizeof(*self));
+
+	return map;
+}
+
+int map__overlap(struct map *l, struct map *r)
+{
+	if (l->start > r->start) {
+		struct map *t = l;
+		l = r;
+		r = t;
+	}
+
+	if (l->end > r->start)
+		return 1;
+
+	return 0;
+}
+
+size_t map__fprintf(struct map *self, FILE *fp)
+{
+	return fprintf(fp, " %Lx-%Lx %Lx %s\n",
+		       self->start, self->end, self->pgoff, self->dso->name);
+}
