commit 55ecd6310f9fe48cf7e435be408862da1e0e6baa
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Thu Dec 6 11:18:15 2018 -0800

    perf callchain: Use cached rbtrees
    
    At the cost of an extra pointer, we can avoid the O(logN) cost of
    finding the first element in the tree (smallest node), which is
    something required for nearly every in/srcline callchain node deletion
    (in/srcline__tree_delete()).
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20181206191819.30182-4-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 5762212dc342..b11a0aaaa676 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -19,11 +19,11 @@ void free_srcline(char *srcline);
 char *get_srcline_split(struct dso *dso, u64 addr, unsigned *line);
 
 /* insert the srcline into the DSO, which will take ownership */
-void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline);
+void srcline__tree_insert(struct rb_root_cached *tree, u64 addr, char *srcline);
 /* find previously inserted srcline */
-char *srcline__tree_find(struct rb_root *tree, u64 addr);
+char *srcline__tree_find(struct rb_root_cached *tree, u64 addr);
 /* delete all srclines within the tree */
-void srcline__tree_delete(struct rb_root *tree);
+void srcline__tree_delete(struct rb_root_cached *tree);
 
 #define SRCLINE_UNKNOWN  ((char *) "??:0")
 
@@ -46,10 +46,11 @@ struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,
 void inline_node__delete(struct inline_node *node);
 
 /* insert the inline node list into the DSO, which will take ownership */
-void inlines__tree_insert(struct rb_root *tree, struct inline_node *inlines);
+void inlines__tree_insert(struct rb_root_cached *tree,
+			  struct inline_node *inlines);
 /* find previously inserted inline node list */
-struct inline_node *inlines__tree_find(struct rb_root *tree, u64 addr);
+struct inline_node *inlines__tree_find(struct rb_root_cached *tree, u64 addr);
 /* delete all nodes within the tree of inline_node s */
-void inlines__tree_delete(struct rb_root *tree);
+void inlines__tree_delete(struct rb_root_cached *tree);
 
 #endif /* PERF_SRCLINE_H */

commit dd2e18e9ac20e3ffc27cabf318e83b43ed5ddb92
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Dec 3 16:18:48 2018 -0800

    perf tools: Support 'srccode' output
    
    When looking at PT or brstackinsn traces with 'perf script' it can be
    very useful to see the source code. This adds a simple facility to print
    them with 'perf script', if the information is available through dwarf
    
      % perf record ...
      % perf script -F insn,ip,sym,srccode
      ...
    
                4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004b3 main
      6                       v++;
    
      % perf record -b ...
      % perf script -F insn,ip,sym,srccode,brstackinsn
    
      ...
             main+22:
              0000000000400543        insn: e8 ca ff ff ff            # PRED
      |18                     f1();
              f1:
              0000000000400512        insn: 55
      |10       {
              0000000000400513        insn: 48 89 e5
              0000000000400516        insn: b8 00 00 00 00
      |11             f2();
              000000000040051b        insn: e8 d6 ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
              0000000000400500        insn: 8b 0d 2a 0b 20 00
              0000000000400506        insn: 99
              0000000000400507        insn: f7 f9
              0000000000400509        insn: 89 05 29 0b 20 00
              000000000040050f        insn: 90
      |7        }
              0000000000400510        insn: 5d
              0000000000400511        insn: c3                        # PRED
              f1+14:
              0000000000400520        insn: b8 00 00 00 00
      |12             f2();
              0000000000400525        insn: e8 cc ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
    
    Not supported for callchains currently, would need some layout changes
    there.
    
    Committer notes:
    
    Fixed the build on Alpine Linux (3.4 .. 3.8) by addressing this
    warning:
    
      In file included from util/srccode.c:19:0:
      /usr/include/sys/fcntl.h:1:2: error: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Werror=cpp]
       #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
        ^~~~~~~
      cc1: all warnings being treated as errors
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Tested-by: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/20181204001848.24769-1-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index b2bb5502fd62..5762212dc342 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -16,6 +16,7 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 		  bool show_sym, bool show_addr, bool unwind_inlines,
 		  u64 ip);
 void free_srcline(char *srcline);
+char *get_srcline_split(struct dso *dso, u64 addr, unsigned *line);
 
 /* insert the srcline into the DSO, which will take ownership */
 void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline);

commit 935f5a9d4500020879858c9224c98dfabf16101d
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Sat Dec 30 00:26:52 2017 +0800

    perf report: Fix a wrong offset issue when using /proc/kcore
    
    When a valid vmlinux is not found, 'perf report' falls back to look at
    /proc/kcore. In this case, it will report the impossible large offset.
    
    For example:
    
      # perf record -b -e cycles:k find /etc/ > /dev/null
      # perf report --stdio --branch-history
    
        22.77%  _vm_normal_page+18446603336221188162
                |
                ---page_remove_rmap +18446603336221188324
                   page_remove_rmap +18446603336221188487 (cycles:5)
                   unlock_page_memcg +18446603336221188096
                   page_remove_rmap +18446603336221188327 (cycles:1)
    
    The issue is the value which is passed to parameter 'addr' in
    __get_srcline() is the objdump address. It's not correct if we calculate
    the offset by using 'addr - sym->start'.
    
    This patch creates a new parameter 'ip' in __get_srcline(). It is not
    converted to objdump address.
    
    With this patch, the perf report output is:
    
        22.77%  _vm_normal_page+66
                |
                ---page_remove_rmap +228
                   page_remove_rmap +391 (cycles:5)
                   unlock_page_memcg +0
                   page_remove_rmap +231 (cycles:1)
                   page_remove_rmap +236
    
    Committer testing:
    
    Make sure you get any valid vmlinux out of the way, using '-v' on the
    'perf report' case and deleting it from places where perf searches them,
    like your kernel build dir and the build-id cache, in ~/.debug/.
    
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1514564812-17344-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 847b7086182c..b2bb5502fd62 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -11,9 +11,10 @@ struct symbol;
 
 extern bool srcline_full_filename;
 char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym, bool show_addr);
+		  bool show_sym, bool show_addr, u64 ip);
 char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym, bool show_addr, bool unwind_inlines);
+		  bool show_sym, bool show_addr, bool unwind_inlines,
+		  u64 ip);
 void free_srcline(char *srcline);
 
 /* insert the srcline into the DSO, which will take ownership */

commit 15bcdc9477b03eb035052412c3a087e11e855e76
Merge: 340b5319c98e e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:30:18 2017 +0100

    Merge branch 'linus' into perf/core, to fix conflicts
    
    Conflicts:
            tools/perf/arch/arm/annotate/instructions.c
            tools/perf/arch/arm64/annotate/instructions.c
            tools/perf/arch/powerpc/annotate/instructions.c
            tools/perf/arch/s390/annotate/instructions.c
            tools/perf/arch/x86/tests/intel-cqm.c
            tools/perf/ui/tui/progress.c
            tools/perf/util/zlib.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 7b52ba88676e..8e73f607dfa3 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef PERF_SRCLINE_H
 #define PERF_SRCLINE_H
 

commit 21ac9d547fdde79c1e8692587d9044fde549214b
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Thu Oct 19 13:38:34 2017 +0200

    perf report: Cache srclines for callchain nodes
    
    On one hand this ensures that the memory is properly freed when the DSO
    gets freed. On the other hand this significantly speeds up the
    processing of the callchain nodes when lots of srclines are requested.
    For one of my data files e.g.:
    
    Before:
    
     Performance counter stats for 'perf report -s srcline -g srcline --stdio':
    
          52496.495043      task-clock (msec)         #    0.999 CPUs utilized
                   634      context-switches          #    0.012 K/sec
                     2      cpu-migrations            #    0.000 K/sec
               191,561      page-faults               #    0.004 M/sec
       165,074,498,235      cycles                    #    3.144 GHz
       334,170,832,408      instructions              #    2.02  insn per cycle
        90,220,029,745      branches                  # 1718.591 M/sec
           654,525,177      branch-misses             #    0.73% of all branches
    
          52.533273822 seconds time elapsedProcessed 236605 events and lost 40 chunks!
    
    After:
    
     Performance counter stats for 'perf report -s srcline -g srcline --stdio':
    
          22606.323706      task-clock (msec)         #    1.000 CPUs utilized
                    31      context-switches          #    0.001 K/sec
                     0      cpu-migrations            #    0.000 K/sec
               185,471      page-faults               #    0.008 M/sec
        71,188,113,681      cycles                    #    3.149 GHz
       133,204,943,083      instructions              #    1.87  insn per cycle
        34,886,384,979      branches                  # 1543.214 M/sec
           278,214,495      branch-misses             #    0.80% of all branches
    
          22.609857253 seconds time elapsed
    
    Note that the difference is only this large when `--inline` is not
    passed. In such situations, we would use the inliner cache and thus do
    not run this code path that often.
    
    I think that this cache should actually be used in other places, too.
    When looking at the valgrind leak report for perf report, we see tons of
    srclines being leaked, most notably from calls to
    hist_entry__get_srcline. The problem is that get_srcline has many
    different formatting options (show_sym, show_addr, potentially even
    unwind_inlines when calling __get_srcline directly). As such, the
    srcline cannot easily be cached for all calls, or we'd have to add
    caches for all formatting combinations (6 so far). An alternative would
    be to remove the formatting options and handle that on a different level
    - i.e. print the sym/addr on demand wherever we actually output
    something. And the unwind_inlines could be moved into a separate
    function that does not return the srcline.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20171019113836.5548-4-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index ebe38cd22294..1c4d6210860b 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -15,6 +15,13 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 		  bool show_sym, bool show_addr, bool unwind_inlines);
 void free_srcline(char *srcline);
 
+/* insert the srcline into the DSO, which will take ownership */
+void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline);
+/* find previously inserted srcline */
+char *srcline__tree_find(struct rb_root *tree, u64 addr);
+/* delete all srclines within the tree */
+void srcline__tree_delete(struct rb_root *tree);
+
 #define SRCLINE_UNKNOWN  ((char *) "??:0")
 
 struct inline_list {

commit 11ea2515f32e783b9a7984c148e742c377383915
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:59 2017 +0200

    perf callchain: Create real callchain entries for inlined frames
    
    The inline_node structs are maintained by the new dso->inlines tree.
    This in turn keeps ownership of the fake symbols and srcline string
    representing an inline frame.
    
    This tree is sorted by address to allow quick lookups. All other entries
    of the symbol beside the function name are unused for inline frames. The
    advantage of this approach is that all existing users of the callchain
    API can now transparently display inlined frames without having to patch
    their code.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-6-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 0201ed2c0b9c..ebe38cd22294 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -2,6 +2,7 @@
 #define PERF_SRCLINE_H
 
 #include <linux/list.h>
+#include <linux/rbtree.h>
 #include <linux/types.h>
 
 struct dso;
@@ -25,6 +26,7 @@ struct inline_list {
 struct inline_node {
 	u64			addr;
 	struct list_head	val;
+	struct rb_node		rb_node;
 };
 
 /* parse inlined frames for the given address */
@@ -33,4 +35,11 @@ struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,
 /* free resources associated to the inline node list */
 void inline_node__delete(struct inline_node *node);
 
+/* insert the inline node list into the DSO, which will take ownership */
+void inlines__tree_insert(struct rb_root *tree, struct inline_node *inlines);
+/* find previously inserted inline node list */
+struct inline_node *inlines__tree_find(struct rb_root *tree, u64 addr);
+/* delete all nodes within the tree of inline_node s */
+void inlines__tree_delete(struct rb_root *tree);
+
 #endif /* PERF_SRCLINE_H */

commit 2be8832f3c51cf9e36a3e80ff57f4137505c2ba4
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:58 2017 +0200

    perf callchain: Refactor inline_list to store srcline string directly
    
    This is a preparation for the creation of real callchain entries for
    inlined frames. The rest of the perf code uses the srcline string. As
    such, using that also for the srcline API allows us to simplify some of
    the upcoming code. Most notably, it will allow us to cache the srcline
    for a given inline node and reuse it for different callchain entries.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-5-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 730bfd6926d7..0201ed2c0b9c 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -18,8 +18,7 @@ void free_srcline(char *srcline);
 
 struct inline_list {
 	struct symbol		*symbol;
-	char			*filename;
-	unsigned int		line_nr;
+	char			*srcline;
 	struct list_head	list;
 };
 

commit fea0cf842c7aa08950063264ab1cfbce4ba38c1b
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:57 2017 +0200

    perf callchain: Refactor inline_list to operate on symbols
    
    This is a requirement to create real callchain entries for inlined
    frames.
    
    Since the list of inlines usually contains the target symbol too, i.e.
    the location where the frames get inlined to, we alias that symbol and
    reuse it as-is is. This ensures that other dependent functionality keeps
    working, most notably annotation of the target frames.
    
    For all other entries in the inline_list, a fake symbol is created.
    These are marked by new 'inlined' member which is set to true. Only
    those symbols are managed by the inline_list and get freed when the
    inline_list is deleted from within inline_node__delete.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-4-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
index 7b52ba88676e..730bfd6926d7 100644
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -17,8 +17,8 @@ void free_srcline(char *srcline);
 #define SRCLINE_UNKNOWN  ((char *) "??:0")
 
 struct inline_list {
+	struct symbol		*symbol;
 	char			*filename;
-	char			*funcname;
 	unsigned int		line_nr;
 	struct list_head	list;
 };
@@ -28,7 +28,10 @@ struct inline_node {
 	struct list_head	val;
 };
 
-struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr);
+/* parse inlined frames for the given address */
+struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,
+					    struct symbol *sym);
+/* free resources associated to the inline node list */
 void inline_node__delete(struct inline_node *node);
 
 #endif /* PERF_SRCLINE_H */

commit 632a5cabea21eb079b788d2bb4a9318bd6fff5e1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 17 16:30:49 2017 -0300

    perf tools: Move srcline definitions to separate header
    
    Out of util.h into a new file, srcline.h
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-ludnlm4djqcdjziekzr4s3u9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.h b/tools/perf/util/srcline.h
new file mode 100644
index 000000000000..7b52ba88676e
--- /dev/null
+++ b/tools/perf/util/srcline.h
@@ -0,0 +1,34 @@
+#ifndef PERF_SRCLINE_H
+#define PERF_SRCLINE_H
+
+#include <linux/list.h>
+#include <linux/types.h>
+
+struct dso;
+struct symbol;
+
+extern bool srcline_full_filename;
+char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
+		  bool show_sym, bool show_addr);
+char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
+		  bool show_sym, bool show_addr, bool unwind_inlines);
+void free_srcline(char *srcline);
+
+#define SRCLINE_UNKNOWN  ((char *) "??:0")
+
+struct inline_list {
+	char			*filename;
+	char			*funcname;
+	unsigned int		line_nr;
+	struct list_head	list;
+};
+
+struct inline_node {
+	u64			addr;
+	struct list_head	val;
+};
+
+struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr);
+void inline_node__delete(struct inline_node *node);
+
+#endif /* PERF_SRCLINE_H */
