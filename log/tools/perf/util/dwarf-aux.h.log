commit 91e2f539eeda26ab00bd03fae8dc434c128c85ed
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu Oct 24 18:12:54 2019 +0900

    perf probe: Fix to show function entry line as probe-able
    
    Fix die_walk_lines() to list the function entry line correctly.  Since
    the dwarf_entrypc() does not return the entry pc if the DIE has only
    range attribute, __die_walk_funclines() fails to list the declaration
    line (entry line) in that case.
    
    To solve this issue, this introduces die_entrypc() which correctly
    returns the entry PC (the first address range) even if the DIE has only
    range attribute. With this fix die_walk_lines() shows the function entry
    line is able to probe correctly.
    
    Fixes: 4cc9cec636e7 ("perf probe: Introduce lines walker interface")
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lore.kernel.org/lkml/157190837419.1859.4619125803596816752.stgit@devnote2
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index f204e5892403..506006e0cf66 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -29,6 +29,9 @@ int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
 /* Get DW_AT_linkage_name (should be NULL for C binary) */
 const char *die_get_linkage_name(Dwarf_Die *dw_die);
 
+/* Get the lowest PC in DIE (including range list) */
+int die_entrypc(Dwarf_Die *dw_die, Dwarf_Addr *addr);
+
 /* Ensure that this DIE is a subprogram and definition (not declaration) */
 bool die_is_func_def(Dwarf_Die *dw_die);
 

commit 8520a98dbab61e9e340cdfb72dd17ccc8a98961e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 29 16:18:59 2019 -0300

    perf debug: Remove needless include directives from debug.h
    
    All we need there is a forward declaration for 'union perf_event', so
    remove it from there and add missing header directives in places using
    things from this indirect include.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-7ftk0ztstqub1tirjj8o8xbl@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 0489b0cf8e2c..f204e5892403 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -10,6 +10,8 @@
 #include <elfutils/libdwfl.h>
 #include <elfutils/version.h>
 
+struct strbuf;
+
 /* Find the realpath of the target file */
 const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 8ac53bf1ec4e..0489b0cf8e2c 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -1,22 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef _DWARF_AUX_H
 #define _DWARF_AUX_H
 /*
  * dwarf-aux.h : libdw auxiliary interfaces
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  */
 
 #include <dwarf.h>

commit d5a00296a63fdd049273f86d0a0cdef6b230f8e6
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Sat Sep 24 00:35:31 2016 +0900

    perf probe: Match linkage name with mangled name
    
    Match linkage name with mangled name if exists. The linkage_name is used
    for storing mangled name of the object.
    
    Thus, this allows 'perf probe' to find appropriate probe point from
    mangled symbol as below.
    
    E.g. without this fix:
      ----
      $ perf probe -x /usr/lib64/libstdc++.so.6 \
        -D _ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv
      Probe point '_ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv'
      not found.
        Error: Failed to add events.
      ----
    
    With this fix, perf probe can find the correct one.
      ----
      $ perf probe -x /usr/lib64/libstdc++.so.6 \
        -D _ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv
      p:probe_libstdc/_ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv
      /usr/lib64/libstdc++.so.6.0.22:0x8ca60
      ----
    
    Committer notes:
    
    After the fix, setting it for real (no -D/--definition, that amounts to
    a --dry-run):
    
      # perf probe -x /usr/lib64/libstdc++.so.6 _ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv
      Added new event:
        probe_libstdc:_ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv (on _ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv in /usr/lib64/libstdc++.so.6.0.22)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe_libstdc:_ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv -aR sleep 1
    
      # perf probe -l probe_libstdc:*
        probe_libstdc:_ZNKSt15basic_fstreamXXIwSt11char_traitsIwEE7is_openEv (on is_open@libstdc++-v3/include/fstream in /usr/lib64/libstdc++.so.6.0.22)
      #
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Tested-by: Jiri Olsa <jolsa@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/147464493162.29804.16715053505069382443.stgit@devbox
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 8b6d2f83af02..8ac53bf1ec4e 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -38,6 +38,9 @@ int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
 int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
 			 int (*callback)(Dwarf_Die *, void *), void *data);
 
+/* Get DW_AT_linkage_name (should be NULL for C binary) */
+const char *die_get_linkage_name(Dwarf_Die *dw_die);
+
 /* Ensure that this DIE is a subprogram and definition (not declaration) */
 bool die_is_func_def(Dwarf_Die *dw_die);
 

commit 6243b9dc4c991fe8bdc53a0e029908aef3ddb101
Author: Ravi Bangoria <ravi.bangoria@linux.vnet.ibm.com>
Date:   Tue Aug 30 14:09:37 2016 +0530

    perf probe: Move dwarf specific functions to dwarf-aux.c
    
    Move generic dwarf related functions from util/probe-finder.c to
    util/dwarf-aux.c. Functions name and their prototype are also changed
    accordingly. No functionality changes.
    
    Suggested-and-Acked-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.vnet.ibm.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Hemant Kumar <hemant@linux.vnet.ibm.com>
    Cc: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1472546377-25612-1-git-send-email-ravi.bangoria@linux.vnet.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index dc0ce1adb075..8b6d2f83af02 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -125,4 +125,12 @@ int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);
 /* Get the name and type of given variable DIE, stored as "type\tname" */
 int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);
 int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die, struct strbuf *buf);
+
+/* Check if target program is compiled with optimization */
+bool die_is_optimized_target(Dwarf_Die *cu_die);
+
+/* Use next address after prologue as probe location */
+void die_skip_prologue(Dwarf_Die *sp_die, Dwarf_Die *cu_die,
+		       Dwarf_Addr *entrypc);
+
 #endif

commit 3938bad44ed2fea41328e4be2ae04a8e94540813
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Mar 23 15:06:35 2016 -0300

    perf tools: Remove needless 'extern' from function prototypes
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-w246stf7ponfamclsai6b9zo@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index c42ec366f2a7..dc0ce1adb075 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -25,48 +25,48 @@
 #include <elfutils/version.h>
 
 /* Find the realpath of the target file */
-extern const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);
+const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);
 
 /* Get DW_AT_comp_dir (should be NULL with older gcc) */
-extern const char *cu_get_comp_dir(Dwarf_Die *cu_die);
+const char *cu_get_comp_dir(Dwarf_Die *cu_die);
 
 /* Get a line number and file name for given address */
-extern int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
-			    const char **fname, int *lineno);
+int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
+		     const char **fname, int *lineno);
 
 /* Walk on funcitons at given address */
-extern int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
-			int (*callback)(Dwarf_Die *, void *), void *data);
+int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
+			 int (*callback)(Dwarf_Die *, void *), void *data);
 
 /* Ensure that this DIE is a subprogram and definition (not declaration) */
-extern bool die_is_func_def(Dwarf_Die *dw_die);
+bool die_is_func_def(Dwarf_Die *dw_die);
 
 /* Ensure that this DIE is an instance of a subprogram */
-extern bool die_is_func_instance(Dwarf_Die *dw_die);
+bool die_is_func_instance(Dwarf_Die *dw_die);
 
 /* Compare diename and tname */
-extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
+bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 
 /* Matching diename with glob pattern */
-extern bool die_match_name(Dwarf_Die *dw_die, const char *glob);
+bool die_match_name(Dwarf_Die *dw_die, const char *glob);
 
 /* Get callsite line number of inline-function instance */
-extern int die_get_call_lineno(Dwarf_Die *in_die);
+int die_get_call_lineno(Dwarf_Die *in_die);
 
 /* Get callsite file name of inlined function instance */
-extern const char *die_get_call_file(Dwarf_Die *in_die);
+const char *die_get_call_file(Dwarf_Die *in_die);
 
 /* Get type die */
-extern Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
+Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
 
 /* Get a type die, but skip qualifiers and typedef */
-extern Dwarf_Die *die_get_real_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
+Dwarf_Die *die_get_real_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
 
 /* Check whether the DIE is signed or not */
-extern bool die_is_signed_type(Dwarf_Die *tp_die);
+bool die_is_signed_type(Dwarf_Die *tp_die);
 
 /* Get data_member_location offset */
-extern int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs);
+int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs);
 
 /* Return values for die_find_child() callbacks */
 enum {
@@ -77,29 +77,29 @@ enum {
 };
 
 /* Search child DIEs */
-extern Dwarf_Die *die_find_child(Dwarf_Die *rt_die,
-				 int (*callback)(Dwarf_Die *, void *),
-				 void *data, Dwarf_Die *die_mem);
+Dwarf_Die *die_find_child(Dwarf_Die *rt_die,
+			 int (*callback)(Dwarf_Die *, void *),
+			 void *data, Dwarf_Die *die_mem);
 
 /* Search a non-inlined function including given address */
-extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
-				    Dwarf_Die *die_mem);
+Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
+			     Dwarf_Die *die_mem);
 
 /* Search a non-inlined function with tail call at given address */
 Dwarf_Die *die_find_tailfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
 				    Dwarf_Die *die_mem);
 
 /* Search the top inlined function including given address */
-extern Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
-					  Dwarf_Die *die_mem);
+Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
+				   Dwarf_Die *die_mem);
 
 /* Search the deepest inlined function including given address */
-extern Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
-				      Dwarf_Die *die_mem);
+Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
+			       Dwarf_Die *die_mem);
 
 /* Walk on the instances of given DIE */
-extern int die_walk_instances(Dwarf_Die *in_die,
-			      int (*callback)(Dwarf_Die *, void *), void *data);
+int die_walk_instances(Dwarf_Die *in_die,
+		       int (*callback)(Dwarf_Die *, void *), void *data);
 
 /* Walker on lines (Note: line number will not be sorted) */
 typedef int (* line_walk_callback_t) (const char *fname, int lineno,
@@ -109,22 +109,20 @@ typedef int (* line_walk_callback_t) (const char *fname, int lineno,
  * Walk on lines inside given DIE. If the DIE is a subprogram, walk only on
  * the lines inside the subprogram, otherwise the DIE must be a CU DIE.
  */
-extern int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback,
-			  void *data);
+int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback, void *data);
 
 /* Find a variable called 'name' at given address */
-extern Dwarf_Die *die_find_variable_at(Dwarf_Die *sp_die, const char *name,
-				       Dwarf_Addr addr, Dwarf_Die *die_mem);
+Dwarf_Die *die_find_variable_at(Dwarf_Die *sp_die, const char *name,
+				Dwarf_Addr addr, Dwarf_Die *die_mem);
 
 /* Find a member called 'name' */
-extern Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,
-				  Dwarf_Die *die_mem);
+Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,
+			   Dwarf_Die *die_mem);
 
 /* Get the name of given variable DIE */
-extern int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);
+int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);
 
 /* Get the name and type of given variable DIE, stored as "type\tname" */
-extern int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);
-extern int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die,
-			struct strbuf *buf);
+int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);
+int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die, struct strbuf *buf);
 #endif

commit d4c537e6bf860c12262cb936eef663180d7a3d45
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Thu Apr 30 17:12:31 2015 +0530

    perf probe: Ignore tail calls to probed functions
    
    perf probe currently errors out if there are any tail calls to probed
    functions:
    
    [root@rhel71be]# perf probe do_fork
    Failed to find probe point in any functions.
      Error: Failed to add events.
    
    Fix this by teaching perf to ignore tail calls.
    
    Without patch:
    
      [root@rhel71be perf]# ./perf probe -v do_fork
      probe-definition(0): do_fork symbol:do_fork file:(null) line:0 offset:0
      return:0 lazy:(null)
      0 arguments
      Looking at the vmlinux_path (7 entries long)
      symsrc__init: build id mismatch for /boot/vmlinux.
      Using /usr/lib/debug/lib/modules/3.10.0-201.el7.ppc64/vmlinux for symbols
      Open Debuginfo file:
      /usr/lib/debug/lib/modules/3.10.0-201.el7.ppc64/vmlinux
      Try to find probe point from debuginfo.
      found inline addr: 0xc0000000000bb9b0
      Probe point found: do_fork+0
      found inline addr: 0xc0000000000bbe20
      Probe point found: kernel_thread+48
      found inline addr: 0xc0000000000bbe5c
      Probe point found: sys_fork+28
      found inline addr: 0xc0000000000bbfac
      Probe point found: sys_vfork+44
      found inline addr: 0xc0000000000bc27c
      Failed to find probe point in any functions.
      An error occurred in debuginfo analysis (-2).
      Error: Failed to add events. Reason: No such file or directory (Code: -2)
    
    With patch:
    
      [root@rhel71be perf]# ./perf probe -v do_fork
      probe-definition(0): do_fork symbol:do_fork file:(null) line:0 offset:0
      return:0 lazy:(null)
      0 arguments
      Looking at the vmlinux_path (7 entries long)
      symsrc__init: build id mismatch for /boot/vmlinux.
      Using /usr/lib/debug/lib/modules/3.10.0-201.el7.ppc64/vmlinux for symbols
      Open Debuginfo file:
      /usr/lib/debug/lib/modules/3.10.0-201.el7.ppc64/vmlinux
      Try to find probe point from debuginfo.
      found inline addr: 0xc0000000000bb9b0
      Probe point found: do_fork+0
      found inline addr: 0xc0000000000bbe20
      Probe point found: kernel_thread+48
      found inline addr: 0xc0000000000bbe5c
      Probe point found: sys_fork+28
      found inline addr: 0xc0000000000bbfac
      Probe point found: sys_vfork+44
      found inline addr: 0xc0000000000bc27c
      Ignoring tail call from SyS_clone
      Found 4 probe_trace_events.
      Opening /sys/kernel/debug/tracing/kprobe_events write=1
      No kprobe blacklist support, ignored
      Added new events:
      Writing event: p:probe/do_fork _text+768432
      Failed to write event: Invalid argument
        Error: Failed to add events. Reason: Invalid argument (Code: -22)
    
    [Ignore the error about failure to write event - this kernel is missing
    a patch to resolve _text properly]
    
    The reason to ignore tail calls is that the address does not belong to
    any function frame. In the example above, the address in SyS_clone is
    0xc0000000000bc27c, but looking at the debug-info:
    
     <1><830081>: Abbrev Number: 133 (DW_TAG_subprogram)
        <830083>   DW_AT_external    : 1
        <830083>   DW_AT_name        : (indirect string, offset: 0x3cea3): SyS_clone
        <830087>   DW_AT_decl_file   : 7
        <830088>   DW_AT_decl_line   : 1689
        <83008a>   DW_AT_prototyped  : 1
        <83008a>   DW_AT_type        : <0x8110eb>
        <83008e>   DW_AT_low_pc      : 0xc0000000000bc270
        <830096>   DW_AT_high_pc     : 0xc
        <83009e>   DW_AT_frame_base  : 1 byte block: 9c     (DW_OP_call_frame_cfa)
        <8300a0>   DW_AT_GNU_all_call_sites: 1
        <8300a0>   DW_AT_sibling     : <0x830178>
    <snip>
     <3><830147>: Abbrev Number: 125 (DW_TAG_GNU_call_site)
        <830148>   DW_AT_low_pc      : 0xc0000000000bc27c
        <830150>   DW_AT_GNU_tail_call: 1
        <830150>   DW_AT_abstract_origin: <0x82e7e1>
    
    The frame ends at 0xc0000000000bc27c. I suppose this is why this
    particular call is a "tail" call. FWIW, systemtap seems to ignore these
    as well and requires users to explicitly place probes at these call
    sites if necessary. I print out the caller so that users know.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Link: http://lkml.kernel.org/r/1430394151-15928-1-git-send-email-naveen.n.rao@linux.vnet.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index c154c0b80880..c42ec366f2a7 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -85,6 +85,10 @@ extern Dwarf_Die *die_find_child(Dwarf_Die *rt_die,
 extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
 				    Dwarf_Die *die_mem);
 
+/* Search a non-inlined function with tail call at given address */
+Dwarf_Die *die_find_tailfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
+				    Dwarf_Die *die_mem);
+
 /* Search the top inlined function including given address */
 extern Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
 					  Dwarf_Die *die_mem);

commit 349e8d2611316cce11c0b9d0830ebb585c9b82b8
Author: He Kuang <hekuang@huawei.com>
Date:   Mon May 11 09:25:03 2015 +0000

    perf probe: Add --range option to show a variable's location range
    
    It is not easy for users to get the accurate byte offset or the line
    number where a local variable can be probed.
    
    With '--range' option, local variables in the scope of the probe point
    are showed with a byte offset range, and can be added according to this
    range information.
    
    For example, there are some variables in the function
    generic_perform_write():
    
      <generic_perform_write@mm/filemap.c:0>
      0  ssize_t generic_perform_write(struct file *file,
      1                                 struct iov_iter *i, loff_t pos)
      2  {
      3          struct address_space *mapping = file->f_mapping;
      4          const struct address_space_operations *a_ops = mapping->a_ops;
      ...
      42                 status = a_ops->write_begin(file, mapping, pos, bytes, flags,
                                                   &page, &fsdata);
      44                 if (unlikely(status < 0))
    
    But we fail when we try to probe the variable 'a_ops' at line 42 or 44.
    
      $ perf probe --add 'generic_perform_write:42 a_ops'
      Failed to find the location of a_ops at this address.
        Perhaps, it has been optimized out.
    
    This is because the source code do not match the assembly, so a variable
    may not be available in the source code line where it appears.
    
    After this patch, we can lookup the accurate byte offset range of a
    variable, 'INV' indicates that this variable is not valid at the given
    point, but available in the scope:
    
      $ perf probe --vars 'generic_perform_write:42' --range
      Available variables at generic_perform_write:42
        @<generic_perform_write+141>
           [INV] ssize_t written @<generic_perform_write+[324-331]>
           [INV] struct address_space_operations*        a_ops   @<generic_perform_write+[55-61,170-176,223-246]>
           [VAL] (unknown_type)  fsdata  @<generic_perform_write+[70-307,346-411]>
           [VAL] loff_t  pos     @<generic_perform_write+[0-286,286-336,346-411]>
           [VAL] long int        status  @<generic_perform_write+[83-342,346-411]>
           [VAL] long unsigned int       bytes   @<generic_perform_write+[122-311,320-338,346-403,403-411]>
           [VAL] struct address_space*   mapping @<generic_perform_write+[35-344,346-411]>
           [VAL] struct iov_iter*        i       @<generic_perform_write+[0-340,346-411]>
           [VAL] struct page*    page    @<generic_perform_write+[70-307,346-411]>
    
    Then it is more clear for us to add a probe with this variable:
    
      $ perf probe --add 'generic_perform_write+170 a_ops'
      Added new event:
        probe:generic_perform_write (on generic_perform_write+170 with a_ops)
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1431336304-16863-2-git-send-email-hekuang@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 60676fda4824..c154c0b80880 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -121,4 +121,6 @@ extern int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);
 
 /* Get the name and type of given variable DIE, stored as "type\tname" */
 extern int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);
+extern int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die,
+			struct strbuf *buf);
 #endif

commit fb9596d1731cc37da6489de439f8b876f3a12db2
Author: He Kuang <hekuang@huawei.com>
Date:   Mon May 11 09:25:02 2015 +0000

    perf probe: Remove length limitation for showing available variables
    
    Use struct strbuf instead of bare char[] to remove the length limitation
    of variables in variable_list, so they will not disappear due to
    overlength, and make preparation for adding more description for
    variables.
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1431336304-16863-1-git-send-email-hekuang@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 50a3cdc55fd7..60676fda4824 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -117,8 +117,8 @@ extern Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,
 				  Dwarf_Die *die_mem);
 
 /* Get the name of given variable DIE */
-extern int die_get_typename(Dwarf_Die *vr_die, char *buf, int len);
+extern int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);
 
 /* Get the name and type of given variable DIE, stored as "type\tname" */
-extern int die_get_varname(Dwarf_Die *vr_die, char *buf, int len);
+extern int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);
 #endif

commit 4c859351226c920b227fec040a3b447f0d482af3
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Fri May 8 10:03:35 2015 +0900

    perf probe: Support glob wildcards for function name
    
    Support glob wildcards for function name when adding new probes. This
    will allow us to build caches of function-entry level information with
    $params.
    
    e.g.
      ----
      # perf probe --no-inlines --add 'kmalloc* $params'
      Added new events:
        probe:kmalloc_slab   (on kmalloc* with $params)
        probe:kmalloc_large_node (on kmalloc* with $params)
        probe:kmalloc_order_trace (on kmalloc* with $params)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe:kmalloc_order_trace -aR sleep 1
    
      # perf probe --list
        probe:kmalloc_large_node (on kmalloc_large_node@mm/slub.c with size flags node)
        probe:kmalloc_order_trace (on kmalloc_order_trace@mm/slub.c with size flags order)
        probe:kmalloc_slab   (on kmalloc_slab@mm/slab_common.c with size flags)
      ----
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hemant Kumar <hemant@linux.vnet.ibm.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20150508010335.24812.19972.stgit@localhost.localdomain
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index af7dbcd5f929..50a3cdc55fd7 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -47,6 +47,9 @@ extern bool die_is_func_instance(Dwarf_Die *dw_die);
 /* Compare diename and tname */
 extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 
+/* Matching diename with glob pattern */
+extern bool die_match_name(Dwarf_Die *dw_die, const char *glob);
+
 /* Get callsite line number of inline-function instance */
 extern int die_get_call_lineno(Dwarf_Die *in_die);
 

commit e1ecbbc3fa834cc6b4b344edb1968e734d57189b
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Fri Jan 30 18:37:44 2015 +0900

    perf probe: Fix to handle optimized not-inlined functions
    
    Fix to handle optimized no-inline functions which have only function
    definition but no actual instance at that point.
    
    To fix this problem, we need to find actual instance of the function.
    
    Without this patch:
      ----
      # perf probe -a __up
      Failed to get entry address of __up.
        Error: Failed to add events.
      # perf probe -L __up
      Specified source line is not found.
        Error: Failed to show lines.
      ----
    
    With this patch:
      ----
      # perf probe -a __up
      Added new event:
        probe:__up           (on __up)
    
      You can now use it in all perf tools, such as:
    
              perf record -e probe:__up -aR sleep 1
    
      # perf probe -L __up
      <__up@/home/fedora/ksrc/linux-3/kernel/locking/semaphore.c:0>
            0  static noinline void __sched __up(struct semaphore *sem)
               {
                      struct semaphore_waiter *waiter = list_first_entry(&sem->wait_
                                                              struct semaphore_waite
            4         list_del(&waiter->list);
            5         waiter->up = true;
            6         wake_up_process(waiter->task);
            7  }
      ----
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20150130093744.30575.43290.stgit@localhost.localdomain
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index b4fe90c6cb2d..af7dbcd5f929 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -41,6 +41,9 @@ extern int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
 /* Ensure that this DIE is a subprogram and definition (not declaration) */
 extern bool die_is_func_def(Dwarf_Die *dw_die);
 
+/* Ensure that this DIE is an instance of a subprogram */
+extern bool die_is_func_instance(Dwarf_Die *dw_die);
+
 /* Compare diename and tname */
 extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 

commit e08cfd4bda7683cdbe6971c26cf23e2afdb1e7a8
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Mon Sep 30 18:21:44 2013 +0900

    perf probe: Fix to find line information for probe list
    
    Fix to find the correct (as much as possible) line information for
    listing probes. Without this fix, perf probe --list action will show
    incorrect line information as below;
    
      probe:getname_flags  (on getname_flags@ksrc/linux-3/fs/namei.c)
      probe:getname_flags_1 (on getname:-89@x86/include/asm/current.h)
      probe:getname_flags_2 (on user_path_at_empty:-2054@x86/include/asm/current.h)
    
    The minus line number is obviously wrong, and current.h is not related
    to the probe point. Deeper investigation discovered that there were 2
    issues related to this bug, and minor typos too.
    
    The 1st issue is the rack of considering about nested inlined functions,
    which causes the wrong (relative) line number.
    
    The 2nd issue is that the dwarf line info is not correct at those
    points. It points 14th line of current.h.
    
    Since it seems that the line info includes somewhat unreliable
    information, this fixes perf to try to find correct line information
    from both of debuginfo and line info as below.
    
    1) Probe address is the entry of a function instance
    
      In this case, the line is set as the function declared line.
    
    2) Probe address is the entry of an expanded inline function block
    
      In this case, the line is set as the function call-site line.
      This means that the line number is relative from the entry line
      of caller function (which can be an inlined function if nested)
    
    3) Probe address is inside a function instance or an expanded
       inline function block
    
      In this case, perf probe queries the line number from lineinfo
      and verify the function declared file is same as the file name
      queried from lineinfo.
    
      If the file name is different, it is a failure case. The probe
      address is shown as symbol+offset.
    
    4) Probe address is not in the any function instance
    
      This is a failure case, the probe address is shown as
      symbol+offset.
    
    With this fix, perf probe -l shows correct probe lines as below;
    
      probe:getname_flags  (on getname_flags@ksrc/linux-3/fs/namei.c)
      probe:getname_flags_1 (on getname:2@ksrc/linux-3/fs/namei.c)
      probe:getname_flags_2 (on user_path_at_empty:4@ksrc/linux-3/fs/namei.c)
    
    Changes at v2:
     - Fix typos in the function comments. (Thanks to Namhyung Kim)
     - Use die_find_top_inlinefunc instead of die_find_inlinefunc_next.
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20130930092144.1693.11058.stgit@udc4-manage.rcp.hitachi.co.jp
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 8658d41697d2..b4fe90c6cb2d 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -79,7 +79,11 @@ extern Dwarf_Die *die_find_child(Dwarf_Die *rt_die,
 extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
 				    Dwarf_Die *die_mem);
 
-/* Search an inlined function including given address */
+/* Search the top inlined function including given address */
+extern Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
+					  Dwarf_Die *die_mem);
+
+/* Search the deepest inlined function including given address */
 extern Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
 				      Dwarf_Die *die_mem);
 

commit 0dbb1cac1dbdddf64cdd0f972c062a26484b7177
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Mon Apr 23 12:24:36 2012 +0900

    perf probe: Fix finder to find lines of given function
    
    The commit ba28c59bc9ed8fb7b9a753cd88ee54a2c4f6265b fixed a declaration
    entry bug in probe_point_search_cb().  There are same bugs in line
    finder and call_probe_finder().  This introduces a new dwarf utility
    function to determine given DIE is a function definition, not
    declaration.
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Prashanth Nageshappa <prashanth@linux.vnet.ibm.com>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20120423032435.8737.80064.stgit@localhost.localdomain
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 6ce1717784b7..8658d41697d2 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -38,6 +38,9 @@ extern int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
 extern int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
 			int (*callback)(Dwarf_Die *, void *), void *data);
 
+/* Ensure that this DIE is a subprogram and definition (not declaration) */
+extern bool die_is_func_def(Dwarf_Die *dw_die);
+
 /* Compare diename and tname */
 extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 

commit db0d2c6420eeb8fd669bac84d72f1ab828bbaa64
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Thu Aug 11 20:03:11 2011 +0900

    perf probe: Search concrete out-of-line instances
    
    gcc 4.6 generates a concrete out-of-line instance when there is a
    function which is implicitly inlined somewhere but also has its own
    instance. The concrete out-of-line instance means that it has an
    abstract origin of the function which is referred by not only
    inlined-subroutines but also a concrete subprogram.
    
    Since current dwarf_func_inline_instances() can find only instances of
    inlined-subroutines, this introduces new die_walk_instances() to find
    both of subprogram and inlined-subroutines.
    
    e.g. without this,
    Available variables at sched_group_rt_period
            @<cpu_rt_period_read_uint+9>
                    struct task_group*      tg
    
    perf probe failed to find actual subprogram instance of
    sched_group_rt_period().
    
    With this,
    
    Available variables at sched_group_rt_period
            @<cpu_rt_period_read_uint+9>
                    struct task_group*      tg
            @<sched_group_rt_period+0>
                    struct task_group*      tg
    
    Now it found the sched_group_rt_period() itself.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20110811110311.19900.63997.stgit@fedora15
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index 6f46106fd1d5..6ce1717784b7 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -80,6 +80,10 @@ extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
 extern Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
 				      Dwarf_Die *die_mem);
 
+/* Walk on the instances of given DIE */
+extern int die_walk_instances(Dwarf_Die *in_die,
+			      int (*callback)(Dwarf_Die *, void *), void *data);
+
 /* Walker on lines (Note: line number will not be sorted) */
 typedef int (* line_walk_callback_t) (const char *fname, int lineno,
 				      Dwarf_Addr addr, void *data);

commit 221d061182b8ff5507d5768aeeecbc74f01c5dfa
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Thu Aug 11 20:02:59 2011 +0900

    perf probe: Fix to search local variables in appropriate scope
    
    Fix perf probe to search local variables in appropriate local inlined
    function scope. For example, pre_schedule() has only 2 local variables,
    as below;
    
    $ perf probe -L pre_schedule
    <pre_schedule@/home/mhiramat/ksrc/linux-2.6/kernel/sched.c:0>
          0  static inline void pre_schedule(struct rq *rq, struct task_struct *prev)
             {
          2         if (prev->sched_class->pre_schedule)
          3                 prev->sched_class->pre_schedule(rq, prev);
             }
    
    However, current perf probe shows 4 local variables on pre_schedule(),
    because it searches variables in the caller(schedule()) scope.
    
    $ perf probe -V pre_schedule
    Available variables at pre_schedule
            @<schedule+445>
                    int     cpu
                    long unsigned int*      switch_count
                    struct rq*      rq
                    struct task_struct*     prev
    
    This patch fixes this issue by searching variables in the local scope of
    the instance of inlined function. Here is the result.
    
    $ perf probe -V pre_schedule
    Available variables at pre_schedule
            @<schedule+445>
                    struct rq*      rq
                    struct task_struct*     prev
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20110811110259.19900.85664.stgit@fedora15
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index c8e491bc133f..6f46106fd1d5 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -34,6 +34,10 @@ extern const char *cu_get_comp_dir(Dwarf_Die *cu_die);
 extern int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
 			    const char **fname, int *lineno);
 
+/* Walk on funcitons at given address */
+extern int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,
+			int (*callback)(Dwarf_Die *, void *), void *data);
+
 /* Compare diename and tname */
 extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 

commit b0e9cb2802d4bf50955cca8a7d87cf94ebf750a5
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Thu Aug 11 20:02:41 2011 +0900

    perf probe: Fix to search nested inlined functions in CU
    
    Fix perf probe to walk through the lines of all nested inlined function
    call sites and declared lines when a whole CU is passed to the line
    walker.
    
    The die_walk_lines() can have two different type of DIEs, subprogram (or
    inlined-subroutine) DIE and CU DIE.
    
    If a caller passes a subprogram DIE, this means that the walker walk on
    lines of given subprogram. In this case, it just needs to search on
    direct children of DIE tree for finding call-site information of inlined
    function which directly called from given subprogram.
    
    On the other hand, if a caller passes a CU DIE to the walker, this means
    that the walker have to walk on all lines in the source files included
    in given CU DIE. In this case, it has to search whole DIE trees of all
    subprograms to find the call-site information of all nested inlined
    functions.
    
    Without this patch:
    
    $ perf probe --line kernel/cpu.c:151-157
    </home/mhiramat/ksrc/linux-2.6/kernel/cpu.c:151>
    
             static int cpu_notify(unsigned long val, void *v)
             {
        154         return __cpu_notify(val, v, -1, NULL);
             }
    
    With this:
    $ perf probe --line kernel/cpu.c:151-157
    </home/mhiramat/ksrc/linux-2.6/kernel/cpu.c:151>
    
        152  static int cpu_notify(unsigned long val, void *v)
             {
        154         return __cpu_notify(val, v, -1, NULL);
             }
    
    As you can see, --line option with source line range shows the declared
    lines as probe-able.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: yrl.pp-manager.tt@hitachi.com
    Link: http://lkml.kernel.org/r/20110811110241.19900.34994.stgit@fedora15
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
index bc3b21167e70..c8e491bc133f 100644
--- a/tools/perf/util/dwarf-aux.h
+++ b/tools/perf/util/dwarf-aux.h
@@ -40,6 +40,9 @@ extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
 /* Get callsite line number of inline-function instance */
 extern int die_get_call_lineno(Dwarf_Die *in_die);
 
+/* Get callsite file name of inlined function instance */
+extern const char *die_get_call_file(Dwarf_Die *in_die);
+
 /* Get type die */
 extern Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
 

commit e0d153c69040bb37cbdf09deb52fee3013c07742
Author: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
Date:   Mon Jun 27 16:27:27 2011 +0900

    perf-probe: Move dwarf library routines to dwarf-aux.{c, h}
    
    Move dwarf library related routines to dwarf-aux.{c,h}.
    This includes several minor changes.
    - Add simple documents for each API.
    - Rename die_find_real_subprogram() to die_find_realfunc()
    - Rename line_walk_handler_t to line_walk_callback_t.
    - Minor cleanups.
    
    Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Link: http://lkml.kernel.org/r/20110627072727.6528.57647.stgit@fedora15
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h
new file mode 100644
index 000000000000..bc3b21167e70
--- /dev/null
+++ b/tools/perf/util/dwarf-aux.h
@@ -0,0 +1,100 @@
+#ifndef _DWARF_AUX_H
+#define _DWARF_AUX_H
+/*
+ * dwarf-aux.h : libdw auxiliary interfaces
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <dwarf.h>
+#include <elfutils/libdw.h>
+#include <elfutils/libdwfl.h>
+#include <elfutils/version.h>
+
+/* Find the realpath of the target file */
+extern const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);
+
+/* Get DW_AT_comp_dir (should be NULL with older gcc) */
+extern const char *cu_get_comp_dir(Dwarf_Die *cu_die);
+
+/* Get a line number and file name for given address */
+extern int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
+			    const char **fname, int *lineno);
+
+/* Compare diename and tname */
+extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);
+
+/* Get callsite line number of inline-function instance */
+extern int die_get_call_lineno(Dwarf_Die *in_die);
+
+/* Get type die */
+extern Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
+
+/* Get a type die, but skip qualifiers and typedef */
+extern Dwarf_Die *die_get_real_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);
+
+/* Check whether the DIE is signed or not */
+extern bool die_is_signed_type(Dwarf_Die *tp_die);
+
+/* Get data_member_location offset */
+extern int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs);
+
+/* Return values for die_find_child() callbacks */
+enum {
+	DIE_FIND_CB_END = 0,		/* End of Search */
+	DIE_FIND_CB_CHILD = 1,		/* Search only children */
+	DIE_FIND_CB_SIBLING = 2,	/* Search only siblings */
+	DIE_FIND_CB_CONTINUE = 3,	/* Search children and siblings */
+};
+
+/* Search child DIEs */
+extern Dwarf_Die *die_find_child(Dwarf_Die *rt_die,
+				 int (*callback)(Dwarf_Die *, void *),
+				 void *data, Dwarf_Die *die_mem);
+
+/* Search a non-inlined function including given address */
+extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
+				    Dwarf_Die *die_mem);
+
+/* Search an inlined function including given address */
+extern Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
+				      Dwarf_Die *die_mem);
+
+/* Walker on lines (Note: line number will not be sorted) */
+typedef int (* line_walk_callback_t) (const char *fname, int lineno,
+				      Dwarf_Addr addr, void *data);
+
+/*
+ * Walk on lines inside given DIE. If the DIE is a subprogram, walk only on
+ * the lines inside the subprogram, otherwise the DIE must be a CU DIE.
+ */
+extern int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback,
+			  void *data);
+
+/* Find a variable called 'name' at given address */
+extern Dwarf_Die *die_find_variable_at(Dwarf_Die *sp_die, const char *name,
+				       Dwarf_Addr addr, Dwarf_Die *die_mem);
+
+/* Find a member called 'name' */
+extern Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,
+				  Dwarf_Die *die_mem);
+
+/* Get the name of given variable DIE */
+extern int die_get_typename(Dwarf_Die *vr_die, char *buf, int len);
+
+/* Get the name and type of given variable DIE, stored as "type\tname" */
+extern int die_get_varname(Dwarf_Die *vr_die, char *buf, int len);
+#endif
