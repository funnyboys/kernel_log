commit 0ada120c883d4f1f6aafd01cf0fbb10d8bbba015
Author: Changbin Du <changbin.du@gmail.com>
Date:   Tue Jan 28 23:29:38 2020 +0800

    perf: Make perf able to build with latest libbfd
    
    libbfd has changed the bfd_section_* macros to inline functions
    bfd_section_<field> since 2019-09-18. See below two commits:
      o http://www.sourceware.org/ml/gdb-cvs/2019-09/msg00064.html
      o https://www.sourceware.org/ml/gdb-cvs/2019-09/msg00072.html
    
    This fix make perf able to build with both old and new libbfd.
    
    Signed-off-by: Changbin Du <changbin.du@gmail.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200128152938.31413-1-changbin.du@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 6ccf6f6d09df..5b7d6c16d33f 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -193,16 +193,30 @@ static void find_address_in_section(bfd *abfd, asection *section, void *data)
 	bfd_vma pc, vma;
 	bfd_size_type size;
 	struct a2l_data *a2l = data;
+	flagword flags;
 
 	if (a2l->found)
 		return;
 
-	if ((bfd_get_section_flags(abfd, section) & SEC_ALLOC) == 0)
+#ifdef bfd_get_section_flags
+	flags = bfd_get_section_flags(abfd, section);
+#else
+	flags = bfd_section_flags(section);
+#endif
+	if ((flags & SEC_ALLOC) == 0)
 		return;
 
 	pc = a2l->addr;
+#ifdef bfd_get_section_vma
 	vma = bfd_get_section_vma(abfd, section);
+#else
+	vma = bfd_section_vma(section);
+#endif
+#ifdef bfd_get_section_size
 	size = bfd_get_section_size(section);
+#else
+	size = bfd_section_size(section);
+#endif
 
 	if (pc < vma || pc >= vma + size)
 		return;

commit 7f7c536f23e6afaa5d5d4b0e0958b0be8922491f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jul 4 11:32:27 2019 -0300

    tools lib: Adopt zalloc()/zfree() from tools/perf
    
    Eroding a bit more the tools/perf/util/util.h hodpodge header.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-natazosyn9rwjka25tvcnyi0@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index dcad75daf5e4..6ccf6f6d09df 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -6,9 +6,9 @@
 
 #include <linux/kernel.h>
 #include <linux/string.h>
+#include <linux/zalloc.h>
 
 #include "util/dso.h"
-#include "util/util.h"
 #include "util/debug.h"
 #include "util/callchain.h"
 #include "util/symbol_conf.h"

commit b10c78c50964da952e6d4db78a3692ab051e6638
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Fri Jun 28 17:23:03 2019 +0800

    perf diff: Print the basic block cycles diff
    
     $ perf record -b ./div
     $ perf record -b ./div
    
    Following is the default perf diff output
    
     $ perf diff
    
     # Event 'cycles'
     #
     # Baseline  Delta Abs  Shared Object     Symbol
     # ........  .........  ................  ..................................
     #
         48.75%     +0.33%  div               [.] main
          8.21%     -0.20%  div               [.] compute_flag
         19.02%     -0.12%  libc-2.23.so      [.] __random_r
         16.17%     -0.09%  libc-2.23.so      [.] __random
          2.27%     -0.03%  div               [.] rand@plt
                    +0.02%  [i915]            [k] gen8_irq_handler
          5.52%     +0.02%  libc-2.23.so      [.] rand
    
    This patch creates a new computation selection 'cycles'.
    
     $ perf diff -c cycles
    
     # Event 'cycles'
     #
     # Baseline       [Program Block Range] Cycles Diff Shared Object Symbol
     # ........ ....................................... .........................................
     #
         48.75%             [div.c:42 -> div.c:45]  147 div           [.] main
         48.75%             [div.c:31 -> div.c:40]    4 div           [.] main
         48.75%             [div.c:40 -> div.c:40]    0 div           [.] main
         48.75%             [div.c:42 -> div.c:42]    0 div           [.] main
         48.75%             [div.c:42 -> div.c:44]    0 div           [.] main
         19.02% [random_r.c:357 -> random_r.c:360]    0 libc-2.23.so  [.] __random_r
         19.02% [random_r.c:357 -> random_r.c:373]    0 libc-2.23.so  [.] __random_r
         19.02% [random_r.c:357 -> random_r.c:376]    0 libc-2.23.so  [.] __random_r
         19.02% [random_r.c:357 -> random_r.c:380]    0 libc-2.23.so  [.] __random_r
         19.02% [random_r.c:357 -> random_r.c:392]    0 libc-2.23.so  [.] __random_r
         16.17%     [random.c:288 -> random.c:291]    0 libc-2.23.so  [.] __random
         16.17%     [random.c:288 -> random.c:291]    0 libc-2.23.so  [.] __random
         16.17%     [random.c:288 -> random.c:295]    0 libc-2.23.so  [.] __random
         16.17%     [random.c:288 -> random.c:297]    0 libc-2.23.so  [.] __random
         16.17%     [random.c:291 -> random.c:291]    0 libc-2.23.so  [.] __random
         16.17%     [random.c:293 -> random.c:293]    0 libc-2.23.so  [.] __random
          8.21%             [div.c:22 -> div.c:22]  148 div           [.] compute_flag
          8.21%             [div.c:22 -> div.c:25]    0 div           [.] compute_flag
          8.21%             [div.c:27 -> div.c:28]    0 div           [.] compute_flag
          5.52%           [rand.c:26 -> rand.c:27]    0 libc-2.23.so  [.] rand
          5.52%           [rand.c:26 -> rand.c:28]    0 libc-2.23.so  [.] rand
          2.27%         [rand@plt+0 -> rand@plt+0]    0 div           [.] rand@plt
          0.01% [entry_64.S:694 -> entry_64.S:694]   16 [vmlinux]     [k] native_irq_return_iret
          0.00%       [fair.c:7676 -> fair.c:7665]  162 [vmlinux]     [k] update_blocked_averages
    
    "[Program Block Range]" indicates the range of program basic block
    (start -> end). If we can find the source line it prints the source line
    otherwise it prints the symbol+offset instead.
    
     v4:
     ---
     Use source lines or symbol+offset to indicate the basic block. It should
     be easier to understand.
    
     v3:
     ---
     Cast 'struct hist_entry' to 'struct block_hist' in hist_entry__block_fprintf.
     Use symbol_conf.report_block to check if executing hist_entry__block_fprintf.
    
     v2:
     ---
     Keep standard perf diff format and display the 'Baseline' and
     'Shared Object'.
    
    The output is sorted by "Baseline" and the basic blocks in the same
    function are sorted by cycles diff.
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jin Yao <yao.jin@intel.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1561713784-30533-7-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 1824cabe3512..dcad75daf5e4 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -11,6 +11,7 @@
 #include "util/util.h"
 #include "util/debug.h"
 #include "util/callchain.h"
+#include "util/symbol_conf.h"
 #include "srcline.h"
 #include "string2.h"
 #include "symbol.h"
@@ -288,7 +289,8 @@ static int addr2line(const char *dso_name, u64 addr,
 	}
 
 	if (a2l == NULL) {
-		pr_warning("addr2line_init failed for %s\n", dso_name);
+		if (!symbol_conf.disable_add2line_warn)
+			pr_warning("addr2line_init failed for %s\n", dso_name);
 		return 0;
 	}
 

commit 13c230ab6e56c6ae3a968f01f4c6505b794cecad
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Jun 26 12:13:13 2019 -0300

    perf tools: Ditch rtrim(), use strim() from tools/lib
    
    Cleaning up a bit more tools/perf/util/ by using things we got from the
    kernel and have in tools/lib/
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-7hluuoveryoicvkclshzjf1k@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 10ca1533937e..1824cabe3512 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -5,6 +5,7 @@
 #include <string.h>
 
 #include <linux/kernel.h>
+#include <linux/string.h>
 
 #include "util/dso.h"
 #include "util/util.h"
@@ -464,7 +465,7 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 		char *srcline;
 		struct symbol *inline_sym;
 
-		rtrim(funcname);
+		strim(funcname);
 
 		if (getline(&filename, &filelen, fp) == -1)
 			goto out;

commit 7346195e8643482968f547483e0d823ec1982fab
Author: He Kuang <hekuang@huawei.com>
Date:   Tue Feb 19 21:05:31 2019 +0800

    perf report: Don't shadow inlined symbol with different addr range
    
    We can't assume inlined symbols with the same name are equal, because
    their address range may be different. This will cause the symbols with
    different addresses be shadowed when adding to the hist entry, and lead
    to ERANGE error when checking the symbol address during sample parse,
    the addr should be within the range of [sym.start, sym.end].
    
    The error message is like: "0x36aea60 [0x8]: failed to process type: 68".
    
    The second parameter of symbol__new() is the length of the fake symbol
    for the inline frame, which is the subtraction of the end and start
    address of base_sym.
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Fixes: aa441895f7b4 ("perf report: Compare symbol name for inlined frames when sorting")
    Link: http://lkml.kernel.org/r/20190219130531.15692-1-hekuang@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 00f215580b5a..10ca1533937e 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -104,7 +104,7 @@ static struct symbol *new_inline_sym(struct dso *dso,
 	} else {
 		/* create a fake symbol for the inline frame */
 		inline_sym = symbol__new(base_sym ? base_sym->start : 0,
-					 base_sym ? base_sym->end : 0,
+					 base_sym ? (base_sym->end - base_sym->start) : 0,
 					 base_sym ? base_sym->binding : 0,
 					 base_sym ? base_sym->type : 0,
 					 funcname);

commit 55ecd6310f9fe48cf7e435be408862da1e0e6baa
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Thu Dec 6 11:18:15 2018 -0800

    perf callchain: Use cached rbtrees
    
    At the cost of an extra pointer, we can avoid the O(logN) cost of
    finding the first element in the tree (smallest node), which is
    something required for nearly every in/srcline callchain node deletion
    (in/srcline__tree_delete()).
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20181206191819.30182-4-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index dc86597d0cc4..00f215580b5a 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -594,11 +594,12 @@ struct srcline_node {
 	struct rb_node		rb_node;
 };
 
-void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline)
+void srcline__tree_insert(struct rb_root_cached *tree, u64 addr, char *srcline)
 {
-	struct rb_node **p = &tree->rb_node;
+	struct rb_node **p = &tree->rb_root.rb_node;
 	struct rb_node *parent = NULL;
 	struct srcline_node *i, *node;
+	bool leftmost = true;
 
 	node = zalloc(sizeof(struct srcline_node));
 	if (!node) {
@@ -614,16 +615,18 @@ void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline)
 		i = rb_entry(parent, struct srcline_node, rb_node);
 		if (addr < i->addr)
 			p = &(*p)->rb_left;
-		else
+		else {
 			p = &(*p)->rb_right;
+			leftmost = false;
+		}
 	}
 	rb_link_node(&node->rb_node, parent, p);
-	rb_insert_color(&node->rb_node, tree);
+	rb_insert_color_cached(&node->rb_node, tree, leftmost);
 }
 
-char *srcline__tree_find(struct rb_root *tree, u64 addr)
+char *srcline__tree_find(struct rb_root_cached *tree, u64 addr)
 {
-	struct rb_node *n = tree->rb_node;
+	struct rb_node *n = tree->rb_root.rb_node;
 
 	while (n) {
 		struct srcline_node *i = rb_entry(n, struct srcline_node,
@@ -640,15 +643,15 @@ char *srcline__tree_find(struct rb_root *tree, u64 addr)
 	return NULL;
 }
 
-void srcline__tree_delete(struct rb_root *tree)
+void srcline__tree_delete(struct rb_root_cached *tree)
 {
 	struct srcline_node *pos;
-	struct rb_node *next = rb_first(tree);
+	struct rb_node *next = rb_first_cached(tree);
 
 	while (next) {
 		pos = rb_entry(next, struct srcline_node, rb_node);
 		next = rb_next(&pos->rb_node);
-		rb_erase(&pos->rb_node, tree);
+		rb_erase_cached(&pos->rb_node, tree);
 		free_srcline(pos->srcline);
 		zfree(&pos);
 	}
@@ -682,28 +685,32 @@ void inline_node__delete(struct inline_node *node)
 	free(node);
 }
 
-void inlines__tree_insert(struct rb_root *tree, struct inline_node *inlines)
+void inlines__tree_insert(struct rb_root_cached *tree,
+			  struct inline_node *inlines)
 {
-	struct rb_node **p = &tree->rb_node;
+	struct rb_node **p = &tree->rb_root.rb_node;
 	struct rb_node *parent = NULL;
 	const u64 addr = inlines->addr;
 	struct inline_node *i;
+	bool leftmost = true;
 
 	while (*p != NULL) {
 		parent = *p;
 		i = rb_entry(parent, struct inline_node, rb_node);
 		if (addr < i->addr)
 			p = &(*p)->rb_left;
-		else
+		else {
 			p = &(*p)->rb_right;
+			leftmost = false;
+		}
 	}
 	rb_link_node(&inlines->rb_node, parent, p);
-	rb_insert_color(&inlines->rb_node, tree);
+	rb_insert_color_cached(&inlines->rb_node, tree, leftmost);
 }
 
-struct inline_node *inlines__tree_find(struct rb_root *tree, u64 addr)
+struct inline_node *inlines__tree_find(struct rb_root_cached *tree, u64 addr)
 {
-	struct rb_node *n = tree->rb_node;
+	struct rb_node *n = tree->rb_root.rb_node;
 
 	while (n) {
 		struct inline_node *i = rb_entry(n, struct inline_node,
@@ -720,15 +727,15 @@ struct inline_node *inlines__tree_find(struct rb_root *tree, u64 addr)
 	return NULL;
 }
 
-void inlines__tree_delete(struct rb_root *tree)
+void inlines__tree_delete(struct rb_root_cached *tree)
 {
 	struct inline_node *pos;
-	struct rb_node *next = rb_first(tree);
+	struct rb_node *next = rb_first_cached(tree);
 
 	while (next) {
 		pos = rb_entry(next, struct inline_node, rb_node);
 		next = rb_next(&pos->rb_node);
-		rb_erase(&pos->rb_node, tree);
+		rb_erase_cached(&pos->rb_node, tree);
 		inline_node__delete(pos);
 	}
 }

commit dd2e18e9ac20e3ffc27cabf318e83b43ed5ddb92
Author: Andi Kleen <ak@linux.intel.com>
Date:   Mon Dec 3 16:18:48 2018 -0800

    perf tools: Support 'srccode' output
    
    When looking at PT or brstackinsn traces with 'perf script' it can be
    very useful to see the source code. This adds a simple facility to print
    them with 'perf script', if the information is available through dwarf
    
      % perf record ...
      % perf script -F insn,ip,sym,srccode
      ...
    
                4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004c6 main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004cd main
      5               for (i = 0; i < 10000000; i++)
                 4004b3 main
      6                       v++;
    
      % perf record -b ...
      % perf script -F insn,ip,sym,srccode,brstackinsn
    
      ...
             main+22:
              0000000000400543        insn: e8 ca ff ff ff            # PRED
      |18                     f1();
              f1:
              0000000000400512        insn: 55
      |10       {
              0000000000400513        insn: 48 89 e5
              0000000000400516        insn: b8 00 00 00 00
      |11             f2();
              000000000040051b        insn: e8 d6 ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
              0000000000400500        insn: 8b 0d 2a 0b 20 00
              0000000000400506        insn: 99
              0000000000400507        insn: f7 f9
              0000000000400509        insn: 89 05 29 0b 20 00
              000000000040050f        insn: 90
      |7        }
              0000000000400510        insn: 5d
              0000000000400511        insn: c3                        # PRED
              f1+14:
              0000000000400520        insn: b8 00 00 00 00
      |12             f2();
              0000000000400525        insn: e8 cc ff ff ff            # PRED
              f2:
              00000000004004f6        insn: 55
      |5        {
              00000000004004f7        insn: 48 89 e5
              00000000004004fa        insn: 8b 05 2c 0b 20 00
      |6              c = a / b;
    
    Not supported for callchains currently, would need some layout changes
    there.
    
    Committer notes:
    
    Fixed the build on Alpine Linux (3.4 .. 3.8) by addressing this
    warning:
    
      In file included from util/srccode.c:19:0:
      /usr/include/sys/fcntl.h:1:2: error: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Werror=cpp]
       #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
        ^~~~~~~
      cc1: all warnings being treated as errors
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Tested-by: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/20181204001848.24769-1-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index e767c4a9d4d2..dc86597d0cc4 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -548,6 +548,34 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	return srcline;
 }
 
+/* Returns filename and fills in line number in line */
+char *get_srcline_split(struct dso *dso, u64 addr, unsigned *line)
+{
+	char *file = NULL;
+	const char *dso_name;
+
+	if (!dso->has_srcline)
+		goto out;
+
+	dso_name = dso__name(dso);
+	if (dso_name == NULL)
+		goto out;
+
+	if (!addr2line(dso_name, addr, &file, line, dso, true, NULL, NULL))
+		goto out;
+
+	dso->a2l_fails = 0;
+	return file;
+
+out:
+	if (dso->a2l_fails && ++dso->a2l_fails > A2L_FAIL_LIMIT) {
+		dso->has_srcline = 0;
+		dso__free_a2l(dso);
+	}
+
+	return NULL;
+}
+
 void free_srcline(char *srcline)
 {
 	if (srcline && strcmp(srcline, SRCLINE_UNKNOWN) != 0)

commit d4046e8e17b9f378cb861982ef71c63911b5dff3
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Wed Sep 26 15:52:07 2018 +0200

    perf report: Don't crash on invalid inline debug information
    
    When the function name for an inline frame is invalid, we must not try
    to demangle this symbol, otherwise we crash with:
    
      #0  0x0000555555895c01 in bfd_demangle ()
      #1  0x0000555555823262 in demangle_sym (dso=0x555555d92b90, elf_name=0x0, kmodule=0) at util/symbol-elf.c:215
      #2  dso__demangle_sym (dso=dso@entry=0x555555d92b90, kmodule=<optimized out>, kmodule@entry=0, elf_name=elf_name@entry=0x0) at util/symbol-elf.c:400
      #3  0x00005555557fef4b in new_inline_sym (funcname=0x0, base_sym=0x555555d92b90, dso=0x555555d92b90) at util/srcline.c:89
      #4  inline_list__append_dso_a2l (dso=dso@entry=0x555555c7bb00, node=node@entry=0x555555e31810, sym=sym@entry=0x555555d92b90) at util/srcline.c:264
      #5  0x00005555557ff27f in addr2line (dso_name=dso_name@entry=0x555555d92430 "/home/milian/.debug/.build-id/f7/186d14bb94f3c6161c010926da66033d24fce5/elf", addr=addr@entry=2888, file=file@entry=0x0,
          line=line@entry=0x0, dso=dso@entry=0x555555c7bb00, unwind_inlines=unwind_inlines@entry=true, node=0x555555e31810, sym=0x555555d92b90) at util/srcline.c:313
      #6  0x00005555557ffe7c in addr2inlines (sym=0x555555d92b90, dso=0x555555c7bb00, addr=2888, dso_name=0x555555d92430 "/home/milian/.debug/.build-id/f7/186d14bb94f3c6161c010926da66033d24fce5/elf")
          at util/srcline.c:358
    
    So instead handle the case where we get invalid function names for
    inlined frames and use a fallback '??' function name instead.
    
    While this crash was originally reported by Hadrien for rust code, I can
    now also reproduce it with trivial C++ code. Indeed, it seems like
    libbfd fails to interpret the debug information for the inline frame
    symbol name:
    
      $ addr2line -e /home/milian/.debug/.build-id/f7/186d14bb94f3c6161c010926da66033d24fce5/elf -if b48
      main
      /usr/include/c++/8.2.1/complex:610
      ??
      /usr/include/c++/8.2.1/complex:618
      ??
      /usr/include/c++/8.2.1/complex:675
      ??
      /usr/include/c++/8.2.1/complex:685
      main
      /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39
    
    I've reported this bug upstream and also attached a patch there which
    should fix this issue:
    
    https://sourceware.org/bugzilla/show_bug.cgi?id=23715
    
    Reported-by: Hadrien Grasland <grasland@lal.in2p3.fr>
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Fixes: a64489c56c30 ("perf report: Find the inline stack for a given address")
    [ The above 'Fixes:' cset is where originally the problem was
      introduced, i.e.  using a2l->funcname without checking if it is NULL,
      but this current patch fixes the current codebase, i.e. multiple csets
      were applied after a64489c56c30 before the problem was reported by Hadrien ]
    Link: http://lkml.kernel.org/r/20180926135207.30263-3-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 09d6746e6ec8..e767c4a9d4d2 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -85,6 +85,9 @@ static struct symbol *new_inline_sym(struct dso *dso,
 	struct symbol *inline_sym;
 	char *demangled = NULL;
 
+	if (!funcname)
+		funcname = "??";
+
 	if (dso) {
 		demangled = dso__demangle_sym(dso, 0, funcname);
 		if (demangled)

commit af30bffa2f9aa73a648ea932ed468dc3031ac1f9
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 26 11:09:10 2018 -0300

    perf symbols: Store the ELF symbol type in the symbol struct
    
    There is code that needs to see if a resolved address is a function, so,
    since we're going to ditch the MAP__{FUNCTION,VARIABLE} split, store
    that info in the per symbol struct.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-9ugwxz0i8ryg5702rx8u5q6z@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 3c21fd059b64..09d6746e6ec8 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -103,6 +103,7 @@ static struct symbol *new_inline_sym(struct dso *dso,
 		inline_sym = symbol__new(base_sym ? base_sym->start : 0,
 					 base_sym ? base_sym->end : 0,
 					 base_sym ? base_sym->binding : 0,
+					 base_sym ? base_sym->type : 0,
 					 funcname);
 		if (inline_sym)
 			inline_sym->inlined = 1;

commit 935f5a9d4500020879858c9224c98dfabf16101d
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Sat Dec 30 00:26:52 2017 +0800

    perf report: Fix a wrong offset issue when using /proc/kcore
    
    When a valid vmlinux is not found, 'perf report' falls back to look at
    /proc/kcore. In this case, it will report the impossible large offset.
    
    For example:
    
      # perf record -b -e cycles:k find /etc/ > /dev/null
      # perf report --stdio --branch-history
    
        22.77%  _vm_normal_page+18446603336221188162
                |
                ---page_remove_rmap +18446603336221188324
                   page_remove_rmap +18446603336221188487 (cycles:5)
                   unlock_page_memcg +18446603336221188096
                   page_remove_rmap +18446603336221188327 (cycles:1)
    
    The issue is the value which is passed to parameter 'addr' in
    __get_srcline() is the objdump address. It's not correct if we calculate
    the offset by using 'addr - sym->start'.
    
    This patch creates a new parameter 'ip' in __get_srcline(). It is not
    converted to objdump address.
    
    With this patch, the perf report output is:
    
        22.77%  _vm_normal_page+66
                |
                ---page_remove_rmap +228
                   page_remove_rmap +391 (cycles:5)
                   unlock_page_memcg +0
                   page_remove_rmap +231 (cycles:1)
                   page_remove_rmap +236
    
    Committer testing:
    
    Make sure you get any valid vmlinux out of the way, using '-v' on the
    'perf report' case and deleting it from places where perf searches them,
    like your kernel build dir and the build-id cache, in ~/.debug/.
    
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1514564812-17344-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index d19f05c56de6..3c21fd059b64 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -496,7 +496,8 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 #define A2L_FAIL_LIMIT 123
 
 char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym, bool show_addr, bool unwind_inlines)
+		  bool show_sym, bool show_addr, bool unwind_inlines,
+		  u64 ip)
 {
 	char *file = NULL;
 	unsigned line = 0;
@@ -536,7 +537,7 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 
 	if (sym) {
 		if (asprintf(&srcline, "%s+%" PRIu64, show_sym ? sym->name : "",
-					addr - sym->start) < 0)
+					ip - sym->start) < 0)
 			return SRCLINE_UNKNOWN;
 	} else if (asprintf(&srcline, "%s[%" PRIx64 "]", dso->short_name, addr) < 0)
 		return SRCLINE_UNKNOWN;
@@ -550,9 +551,9 @@ void free_srcline(char *srcline)
 }
 
 char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym, bool show_addr)
+		  bool show_sym, bool show_addr, u64 ip)
 {
-	return __get_srcline(dso, addr, sym, show_sym, show_addr, false);
+	return __get_srcline(dso, addr, sym, show_sym, show_addr, false, ip);
 }
 
 struct srcline_node {

commit 15bcdc9477b03eb035052412c3a087e11e855e76
Merge: 340b5319c98e e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:30:18 2017 +0100

    Merge branch 'linus' into perf/core, to fix conflicts
    
    Conflicts:
            tools/perf/arch/arm/annotate/instructions.c
            tools/perf/arch/arm64/annotate/instructions.c
            tools/perf/arch/powerpc/annotate/instructions.c
            tools/perf/arch/s390/annotate/instructions.c
            tools/perf/arch/x86/tests/intel-cqm.c
            tools/perf/ui/tui/progress.c
            tools/perf/util/zlib.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index ed8e8d2de942..4105682afc7a 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>

commit 7285cf3325b4a1dfb336d31eebc27dfbc30fb9aa
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Oct 31 11:06:54 2017 +0900

    perf srcline: Show correct function name for srcline of callchains
    
    When libbfd is not used, it doesn't show proper function name and reuse
    the original symbol of the sample.  That's because it passes the
    original sym to inline_list__append().  As `addr2line -f` returns
    function names as well, use that to create an inline_sym and pass it to
    inline_list__append().
    
    For example, following data shows that inlined entries of main have same
    name (main).
    
    Before:
      $ perf report -g srcline -q | head
          45.22%  inlining     libm-2.26.so      [.] __hypot_finite
                  |
                  ---__hypot_finite ??:0
                     |
                     |--44.15%--hypot ??:0
                     |          main complex:589
                     |          main complex:597
                     |          main complex:654
                     |          main complex:664
                     |          main inlining.cpp:14
    
    After:
      $ perf report -g srcline -q | head
          45.22%  inlining     libm-2.26.so      [.] __hypot_finite
                  |
                  ---__hypot_finite
                     |
                     |--44.15%--hypot
                     |          std::__complex_abs complex:589 (inlined)
                     |          std::abs<double> complex:597 (inlined)
                     |          std::_Norm_helper<true>::_S_do_it<double> complex:654 (inlined)
                     |          std::norm<double> complex:664 (inlined)
                     |          main inlining.cpp:14
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Reviewed-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20171031020654.31163-2-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 51dc49c65476..ad1b46f1f2cf 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -10,7 +10,7 @@
 #include "util/debug.h"
 #include "util/callchain.h"
 #include "srcline.h"
-
+#include "string2.h"
 #include "symbol.h"
 
 bool srcline_full_filename;
@@ -77,6 +77,41 @@ static char *srcline_from_fileline(const char *file, unsigned int line)
 	return srcline;
 }
 
+static struct symbol *new_inline_sym(struct dso *dso,
+				     struct symbol *base_sym,
+				     const char *funcname)
+{
+	struct symbol *inline_sym;
+	char *demangled = NULL;
+
+	if (dso) {
+		demangled = dso__demangle_sym(dso, 0, funcname);
+		if (demangled)
+			funcname = demangled;
+	}
+
+	if (base_sym && strcmp(funcname, base_sym->name) == 0) {
+		/* reuse the real, existing symbol */
+		inline_sym = base_sym;
+		/* ensure that we don't alias an inlined symbol, which could
+		 * lead to double frees in inline_node__delete
+		 */
+		assert(!base_sym->inlined);
+	} else {
+		/* create a fake symbol for the inline frame */
+		inline_sym = symbol__new(base_sym ? base_sym->start : 0,
+					 base_sym ? base_sym->end : 0,
+					 base_sym ? base_sym->binding : 0,
+					 funcname);
+		if (inline_sym)
+			inline_sym->inlined = 1;
+	}
+
+	free(demangled);
+
+	return inline_sym;
+}
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -219,41 +254,6 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 
 #define MAX_INLINE_NEST 1024
 
-static struct symbol *new_inline_sym(struct dso *dso,
-				     struct symbol *base_sym,
-				     const char *funcname)
-{
-	struct symbol *inline_sym;
-	char *demangled = NULL;
-
-	if (dso) {
-		demangled = dso__demangle_sym(dso, 0, funcname);
-		if (demangled)
-			funcname = demangled;
-	}
-
-	if (base_sym && strcmp(funcname, base_sym->name) == 0) {
-		/* reuse the real, existing symbol */
-		inline_sym = base_sym;
-		/* ensure that we don't alias an inlined symbol, which could
-		 * lead to double frees in inline_node__delete
-		 */
-		assert(!base_sym->inlined);
-	} else {
-		/* create a fake symbol for the inline frame */
-		inline_sym = symbol__new(base_sym ? base_sym->start : 0,
-					 base_sym ? base_sym->end : 0,
-					 base_sym ? base_sym->binding : 0,
-					 funcname);
-		if (inline_sym)
-			inline_sym->inlined = 1;
-	}
-
-	free(demangled);
-
-	return inline_sym;
-}
-
 static int inline_list__append_dso_a2l(struct dso *dso,
 				       struct inline_node *node,
 				       struct symbol *sym)
@@ -432,10 +432,11 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	char cmd[PATH_MAX];
 	struct inline_node *node;
 	char *filename = NULL;
-	size_t len;
+	char *funcname = NULL;
+	size_t filelen, funclen;
 	unsigned int line_nr = 0;
 
-	scnprintf(cmd, sizeof(cmd), "addr2line -e %s -i %016"PRIx64,
+	scnprintf(cmd, sizeof(cmd), "addr2line -e %s -i -f %016"PRIx64,
 		  dso_name, addr);
 
 	fp = popen(cmd, "r");
@@ -453,20 +454,34 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	INIT_LIST_HEAD(&node->val);
 	node->addr = addr;
 
-	while (getline(&filename, &len, fp) != -1) {
+	/* addr2line -f generates two lines for each inlined functions */
+	while (getline(&funcname, &funclen, fp) != -1) {
 		char *srcline;
+		struct symbol *inline_sym;
+
+		rtrim(funcname);
+
+		if (getline(&filename, &filelen, fp) == -1)
+			goto out;
 
 		if (filename_split(filename, &line_nr) != 1)
 			goto out;
 
 		srcline = srcline_from_fileline(filename, line_nr);
-		if (inline_list__append(sym, srcline, node) != 0)
+		inline_sym = new_inline_sym(dso, sym, funcname);
+
+		if (inline_list__append(inline_sym, srcline, node) != 0) {
+			free(srcline);
+			if (inline_sym && inline_sym->inlined)
+				symbol__delete(inline_sym);
 			goto out;
+		}
 	}
 
 out:
 	pclose(fp);
 	free(filename);
+	free(funcname);
 
 	return node;
 }

commit b7b75a60b291cc699ca9bb2a8517a1b3b08bbeb1
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Oct 31 11:06:53 2017 +0900

    perf srcline: Fix memory leak in addr2inlines()
    
    When libbfd is not used, addr2inlines() executes `addr2line -i` and
    process output line by line.  But it resets filename to NULL in the loop
    so getline() allocates additional memory everytime instead of realloc.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20171031020654.31163-1-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index c143c3bc1ef8..51dc49c65476 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -456,20 +456,17 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	while (getline(&filename, &len, fp) != -1) {
 		char *srcline;
 
-		if (filename_split(filename, &line_nr) != 1) {
-			free(filename);
+		if (filename_split(filename, &line_nr) != 1)
 			goto out;
-		}
 
 		srcline = srcline_from_fileline(filename, line_nr);
 		if (inline_list__append(sym, srcline, node) != 0)
 			goto out;
-
-		filename = NULL;
 	}
 
 out:
 	pclose(fp);
+	free(filename);
 
 	return node;
 }

commit 21ac9d547fdde79c1e8692587d9044fde549214b
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Thu Oct 19 13:38:34 2017 +0200

    perf report: Cache srclines for callchain nodes
    
    On one hand this ensures that the memory is properly freed when the DSO
    gets freed. On the other hand this significantly speeds up the
    processing of the callchain nodes when lots of srclines are requested.
    For one of my data files e.g.:
    
    Before:
    
     Performance counter stats for 'perf report -s srcline -g srcline --stdio':
    
          52496.495043      task-clock (msec)         #    0.999 CPUs utilized
                   634      context-switches          #    0.012 K/sec
                     2      cpu-migrations            #    0.000 K/sec
               191,561      page-faults               #    0.004 M/sec
       165,074,498,235      cycles                    #    3.144 GHz
       334,170,832,408      instructions              #    2.02  insn per cycle
        90,220,029,745      branches                  # 1718.591 M/sec
           654,525,177      branch-misses             #    0.73% of all branches
    
          52.533273822 seconds time elapsedProcessed 236605 events and lost 40 chunks!
    
    After:
    
     Performance counter stats for 'perf report -s srcline -g srcline --stdio':
    
          22606.323706      task-clock (msec)         #    1.000 CPUs utilized
                    31      context-switches          #    0.001 K/sec
                     0      cpu-migrations            #    0.000 K/sec
               185,471      page-faults               #    0.008 M/sec
        71,188,113,681      cycles                    #    3.149 GHz
       133,204,943,083      instructions              #    1.87  insn per cycle
        34,886,384,979      branches                  # 1543.214 M/sec
           278,214,495      branch-misses             #    0.80% of all branches
    
          22.609857253 seconds time elapsed
    
    Note that the difference is only this large when `--inline` is not
    passed. In such situations, we would use the inliner cache and thus do
    not run this code path that often.
    
    I think that this cache should actually be used in other places, too.
    When looking at the valgrind leak report for perf report, we see tons of
    srclines being leaked, most notably from calls to
    hist_entry__get_srcline. The problem is that get_srcline has many
    different formatting options (show_sym, show_addr, potentially even
    unwind_inlines when calling __get_srcline directly). As such, the
    srcline cannot easily be cached for all calls, or we'd have to add
    caches for all formatting combinations (6 so far). An alternative would
    be to remove the formatting options and handle that on a different level
    - i.e. print the sym/addr on demand wherever we actually output
    something. And the unwind_inlines could be moved into a separate
    function that does not return the srcline.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20171019113836.5548-4-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index fc3888664b20..c143c3bc1ef8 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -542,6 +542,72 @@ char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	return __get_srcline(dso, addr, sym, show_sym, show_addr, false);
 }
 
+struct srcline_node {
+	u64			addr;
+	char			*srcline;
+	struct rb_node		rb_node;
+};
+
+void srcline__tree_insert(struct rb_root *tree, u64 addr, char *srcline)
+{
+	struct rb_node **p = &tree->rb_node;
+	struct rb_node *parent = NULL;
+	struct srcline_node *i, *node;
+
+	node = zalloc(sizeof(struct srcline_node));
+	if (!node) {
+		perror("not enough memory for the srcline node");
+		return;
+	}
+
+	node->addr = addr;
+	node->srcline = srcline;
+
+	while (*p != NULL) {
+		parent = *p;
+		i = rb_entry(parent, struct srcline_node, rb_node);
+		if (addr < i->addr)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+	}
+	rb_link_node(&node->rb_node, parent, p);
+	rb_insert_color(&node->rb_node, tree);
+}
+
+char *srcline__tree_find(struct rb_root *tree, u64 addr)
+{
+	struct rb_node *n = tree->rb_node;
+
+	while (n) {
+		struct srcline_node *i = rb_entry(n, struct srcline_node,
+						  rb_node);
+
+		if (addr < i->addr)
+			n = n->rb_left;
+		else if (addr > i->addr)
+			n = n->rb_right;
+		else
+			return i->srcline;
+	}
+
+	return NULL;
+}
+
+void srcline__tree_delete(struct rb_root *tree)
+{
+	struct srcline_node *pos;
+	struct rb_node *next = rb_first(tree);
+
+	while (next) {
+		pos = rb_entry(next, struct srcline_node, rb_node);
+		next = rb_next(&pos->rb_node);
+		rb_erase(&pos->rb_node, tree);
+		free_srcline(pos->srcline);
+		zfree(&pos);
+	}
+}
+
 struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,
 					    struct symbol *sym)
 {

commit b38775cf7678d7715b35dded3dcfab66e244baae
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Thu Oct 19 13:38:33 2017 +0200

    perf report: Cache failed lookups of inlined frames
    
    When no inlined frames could be found for a given address, we did not
    store this information anywhere. That means we potentially do the costly
    inliner lookup repeatedly for cases where we know it can never succeed.
    
    This patch makes dso__parse_addr_inlines always return a valid
    inline_node. It will be empty when no inliners are found. This enables
    us to cache the empty list in the DSO, thereby improving the performance
    when many addresses fail to find the inliners.
    
    For my trivial example, the performance impact is already quite
    significant:
    
    Before:
    
    ~~~~~
     Performance counter stats for 'perf report --stdio --inline -g srcline -s srcline' (5 runs):
    
            594.804032      task-clock (msec)         #    0.998 CPUs utilized            ( +-  0.07% )
                    53      context-switches          #    0.089 K/sec                    ( +-  4.09% )
                     0      cpu-migrations            #    0.000 K/sec                    ( +-100.00% )
                 5,687      page-faults               #    0.010 M/sec                    ( +-  0.02% )
         2,300,918,213      cycles                    #    3.868 GHz                      ( +-  0.09% )
         4,395,839,080      instructions              #    1.91  insn per cycle           ( +-  0.00% )
           939,177,205      branches                  # 1578.969 M/sec                    ( +-  0.00% )
            11,824,633      branch-misses             #    1.26% of all branches          ( +-  0.10% )
    
           0.596246531 seconds time elapsed                                          ( +-  0.07% )
    ~~~~~
    
    After:
    
    ~~~~~
     Performance counter stats for 'perf report --stdio --inline -g srcline -s srcline' (5 runs):
    
            113.111405      task-clock (msec)         #    0.990 CPUs utilized            ( +-  0.89% )
                    29      context-switches          #    0.255 K/sec                    ( +- 54.25% )
                     0      cpu-migrations            #    0.000 K/sec
                 5,380      page-faults               #    0.048 M/sec                    ( +-  0.01% )
           432,378,779      cycles                    #    3.823 GHz                      ( +-  0.75% )
           670,057,633      instructions              #    1.55  insn per cycle           ( +-  0.01% )
           141,001,247      branches                  # 1246.570 M/sec                    ( +-  0.01% )
             2,346,845      branch-misses             #    1.66% of all branches          ( +-  0.19% )
    
           0.114222393 seconds time elapsed                                          ( +-  1.19% )
    ~~~~~
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20171019113836.5548-3-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 8bea6621d657..fc3888664b20 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -353,17 +353,8 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	INIT_LIST_HEAD(&node->val);
 	node->addr = addr;
 
-	if (!addr2line(dso_name, addr, NULL, NULL, dso, TRUE, node, sym))
-		goto out_free_inline_node;
-
-	if (list_empty(&node->val))
-		goto out_free_inline_node;
-
+	addr2line(dso_name, addr, NULL, NULL, dso, true, node, sym);
 	return node;
-
-out_free_inline_node:
-	inline_node__delete(node);
-	return NULL;
 }
 
 #else /* HAVE_LIBBFD_SUPPORT */
@@ -480,11 +471,6 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 out:
 	pclose(fp);
 
-	if (list_empty(&node->val)) {
-		inline_node__delete(node);
-		return NULL;
-	}
-
 	return node;
 }
 

commit 11ea2515f32e783b9a7984c148e742c377383915
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:59 2017 +0200

    perf callchain: Create real callchain entries for inlined frames
    
    The inline_node structs are maintained by the new dso->inlines tree.
    This in turn keeps ownership of the fake symbols and srcline string
    representing an inline frame.
    
    This tree is sorted by address to allow quick lookups. All other entries
    of the symbol beside the function name are unused for inline frames. The
    advantage of this approach is that all existing users of the callchain
    API can now transparently display inlined frames without having to patch
    their code.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-6-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index f202fc7827df..8bea6621d657 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -583,3 +583,54 @@ void inline_node__delete(struct inline_node *node)
 
 	free(node);
 }
+
+void inlines__tree_insert(struct rb_root *tree, struct inline_node *inlines)
+{
+	struct rb_node **p = &tree->rb_node;
+	struct rb_node *parent = NULL;
+	const u64 addr = inlines->addr;
+	struct inline_node *i;
+
+	while (*p != NULL) {
+		parent = *p;
+		i = rb_entry(parent, struct inline_node, rb_node);
+		if (addr < i->addr)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+	}
+	rb_link_node(&inlines->rb_node, parent, p);
+	rb_insert_color(&inlines->rb_node, tree);
+}
+
+struct inline_node *inlines__tree_find(struct rb_root *tree, u64 addr)
+{
+	struct rb_node *n = tree->rb_node;
+
+	while (n) {
+		struct inline_node *i = rb_entry(n, struct inline_node,
+						 rb_node);
+
+		if (addr < i->addr)
+			n = n->rb_left;
+		else if (addr > i->addr)
+			n = n->rb_right;
+		else
+			return i;
+	}
+
+	return NULL;
+}
+
+void inlines__tree_delete(struct rb_root *tree)
+{
+	struct inline_node *pos;
+	struct rb_node *next = rb_first(tree);
+
+	while (next) {
+		pos = rb_entry(next, struct inline_node, rb_node);
+		next = rb_next(&pos->rb_node);
+		rb_erase(&pos->rb_node, tree);
+		inline_node__delete(pos);
+	}
+}

commit 2be8832f3c51cf9e36a3e80ff57f4137505c2ba4
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:58 2017 +0200

    perf callchain: Refactor inline_list to store srcline string directly
    
    This is a preparation for the creation of real callchain entries for
    inlined frames. The rest of the perf code uses the srcline string. As
    such, using that also for the srcline API allows us to simplify some of
    the upcoming code. Most notably, it will allow us to cache the srcline
    for a given inline node and reuse it for different callchain entries.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-5-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index c0af61b355ed..f202fc7827df 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -33,8 +33,8 @@ static const char *dso__name(struct dso *dso)
 	return dso_name;
 }
 
-static int inline_list__append(struct symbol *symbol, char *filename,
-			       int line_nr, struct inline_node *node)
+static int inline_list__append(struct symbol *symbol, char *srcline,
+			       struct inline_node *node)
 {
 	struct inline_list *ilist;
 
@@ -43,8 +43,7 @@ static int inline_list__append(struct symbol *symbol, char *filename,
 		return -1;
 
 	ilist->symbol = symbol;
-	ilist->filename = filename;
-	ilist->line_nr = line_nr;
+	ilist->srcline = srcline;
 
 	if (callchain_param.order == ORDER_CALLEE)
 		list_add_tail(&ilist->list, &node->val);
@@ -54,6 +53,30 @@ static int inline_list__append(struct symbol *symbol, char *filename,
 	return 0;
 }
 
+/* basename version that takes a const input string */
+static const char *gnu_basename(const char *path)
+{
+	const char *base = strrchr(path, '/');
+
+	return base ? base + 1 : path;
+}
+
+static char *srcline_from_fileline(const char *file, unsigned int line)
+{
+	char *srcline;
+
+	if (!file)
+		return NULL;
+
+	if (!srcline_full_filename)
+		file = gnu_basename(file);
+
+	if (asprintf(&srcline, "%s:%u", file, line) < 0)
+		return NULL;
+
+	return srcline;
+}
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -237,9 +260,12 @@ static int inline_list__append_dso_a2l(struct dso *dso,
 {
 	struct a2l_data *a2l = dso->a2l;
 	struct symbol *inline_sym = new_inline_sym(dso, sym, a2l->funcname);
+	char *srcline = NULL;
 
-	return inline_list__append(inline_sym, strdup(a2l->filename),
-				   a2l->line, node);
+	if (a2l->filename)
+		srcline = srcline_from_fileline(a2l->filename, a2l->line);
+
+	return inline_list__append(inline_sym, srcline, node);
 }
 
 static int addr2line(const char *dso_name, u64 addr,
@@ -437,13 +463,15 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	node->addr = addr;
 
 	while (getline(&filename, &len, fp) != -1) {
+		char *srcline;
 
 		if (filename_split(filename, &line_nr) != 1) {
 			free(filename);
 			goto out;
 		}
 
-		if (inline_list__append(sym, filename, line_nr, node) != 0)
+		srcline = srcline_from_fileline(filename, line_nr);
+		if (inline_list__append(sym, srcline, node) != 0)
 			goto out;
 
 		filename = NULL;
@@ -487,16 +515,14 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 		       unwind_inlines, NULL, sym))
 		goto out;
 
-	if (asprintf(&srcline, "%s:%u",
-				srcline_full_filename ? file : basename(file),
-				line) < 0) {
-		free(file);
+	srcline = srcline_from_fileline(file, line);
+	free(file);
+
+	if (!srcline)
 		goto out;
-	}
 
 	dso->a2l_fails = 0;
 
-	free(file);
 	return srcline;
 
 out:
@@ -548,7 +574,7 @@ void inline_node__delete(struct inline_node *node)
 
 	list_for_each_entry_safe(ilist, tmp, &node->val, list) {
 		list_del_init(&ilist->list);
-		zfree(&ilist->filename);
+		free_srcline(ilist->srcline);
 		/* only the inlined symbols are owned by the list */
 		if (ilist->symbol && ilist->symbol->inlined)
 			symbol__delete(ilist->symbol);

commit fea0cf842c7aa08950063264ab1cfbce4ba38c1b
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:57 2017 +0200

    perf callchain: Refactor inline_list to operate on symbols
    
    This is a requirement to create real callchain entries for inlined
    frames.
    
    Since the list of inlines usually contains the target symbol too, i.e.
    the location where the frames get inlined to, we alias that symbol and
    reuse it as-is is. This ensures that other dependent functionality keeps
    working, most notably annotation of the target frames.
    
    For all other entries in the inline_list, a fake symbol is created.
    These are marked by new 'inlined' member which is set to true. Only
    those symbols are managed by the inline_list and get freed when the
    inline_list is deleted from within inline_node__delete.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-4-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index ed8e8d2de942..c0af61b355ed 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -33,29 +33,19 @@ static const char *dso__name(struct dso *dso)
 	return dso_name;
 }
 
-static int inline_list__append(char *filename, char *funcname, int line_nr,
-			       struct inline_node *node, struct dso *dso)
+static int inline_list__append(struct symbol *symbol, char *filename,
+			       int line_nr, struct inline_node *node)
 {
 	struct inline_list *ilist;
-	char *demangled;
 
 	ilist = zalloc(sizeof(*ilist));
 	if (ilist == NULL)
 		return -1;
 
+	ilist->symbol = symbol;
 	ilist->filename = filename;
 	ilist->line_nr = line_nr;
 
-	if (dso != NULL) {
-		demangled = dso__demangle_sym(dso, 0, funcname);
-		if (demangled == NULL) {
-			ilist->funcname = funcname;
-		} else {
-			ilist->funcname = demangled;
-			free(funcname);
-		}
-	}
-
 	if (callchain_param.order == ORDER_CALLEE)
 		list_add_tail(&ilist->list, &node->val);
 	else
@@ -206,19 +196,56 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 
 #define MAX_INLINE_NEST 1024
 
+static struct symbol *new_inline_sym(struct dso *dso,
+				     struct symbol *base_sym,
+				     const char *funcname)
+{
+	struct symbol *inline_sym;
+	char *demangled = NULL;
+
+	if (dso) {
+		demangled = dso__demangle_sym(dso, 0, funcname);
+		if (demangled)
+			funcname = demangled;
+	}
+
+	if (base_sym && strcmp(funcname, base_sym->name) == 0) {
+		/* reuse the real, existing symbol */
+		inline_sym = base_sym;
+		/* ensure that we don't alias an inlined symbol, which could
+		 * lead to double frees in inline_node__delete
+		 */
+		assert(!base_sym->inlined);
+	} else {
+		/* create a fake symbol for the inline frame */
+		inline_sym = symbol__new(base_sym ? base_sym->start : 0,
+					 base_sym ? base_sym->end : 0,
+					 base_sym ? base_sym->binding : 0,
+					 funcname);
+		if (inline_sym)
+			inline_sym->inlined = 1;
+	}
+
+	free(demangled);
+
+	return inline_sym;
+}
+
 static int inline_list__append_dso_a2l(struct dso *dso,
-				       struct inline_node *node)
+				       struct inline_node *node,
+				       struct symbol *sym)
 {
 	struct a2l_data *a2l = dso->a2l;
-	char *funcname = a2l->funcname ? strdup(a2l->funcname) : NULL;
-	char *filename = a2l->filename ? strdup(a2l->filename) : NULL;
+	struct symbol *inline_sym = new_inline_sym(dso, sym, a2l->funcname);
 
-	return inline_list__append(filename, funcname, a2l->line, node, dso);
+	return inline_list__append(inline_sym, strdup(a2l->filename),
+				   a2l->line, node);
 }
 
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line, struct dso *dso,
-		     bool unwind_inlines, struct inline_node *node)
+		     bool unwind_inlines, struct inline_node *node,
+		     struct symbol *sym)
 {
 	int ret = 0;
 	struct a2l_data *a2l = dso->a2l;
@@ -244,7 +271,7 @@ static int addr2line(const char *dso_name, u64 addr,
 	if (unwind_inlines) {
 		int cnt = 0;
 
-		if (node && inline_list__append_dso_a2l(dso, node))
+		if (node && inline_list__append_dso_a2l(dso, node, sym))
 			return 0;
 
 		while (bfd_find_inliner_info(a2l->abfd, &a2l->filename,
@@ -255,7 +282,7 @@ static int addr2line(const char *dso_name, u64 addr,
 				a2l->filename = NULL;
 
 			if (node != NULL) {
-				if (inline_list__append_dso_a2l(dso, node))
+				if (inline_list__append_dso_a2l(dso, node, sym))
 					return 0;
 				// found at least one inline frame
 				ret = 1;
@@ -287,7 +314,7 @@ void dso__free_a2l(struct dso *dso)
 }
 
 static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
-	struct dso *dso)
+					struct dso *dso, struct symbol *sym)
 {
 	struct inline_node *node;
 
@@ -300,7 +327,7 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	INIT_LIST_HEAD(&node->val);
 	node->addr = addr;
 
-	if (!addr2line(dso_name, addr, NULL, NULL, dso, TRUE, node))
+	if (!addr2line(dso_name, addr, NULL, NULL, dso, TRUE, node, sym))
 		goto out_free_inline_node;
 
 	if (list_empty(&node->val))
@@ -340,7 +367,8 @@ static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line_nr,
 		     struct dso *dso __maybe_unused,
 		     bool unwind_inlines __maybe_unused,
-		     struct inline_node *node __maybe_unused)
+		     struct inline_node *node __maybe_unused,
+		     struct symbol *sym __maybe_unused)
 {
 	FILE *fp;
 	char cmd[PATH_MAX];
@@ -380,7 +408,8 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
 }
 
 static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
-	struct dso *dso __maybe_unused)
+					struct dso *dso __maybe_unused,
+					struct symbol *sym)
 {
 	FILE *fp;
 	char cmd[PATH_MAX];
@@ -408,13 +437,13 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	node->addr = addr;
 
 	while (getline(&filename, &len, fp) != -1) {
+
 		if (filename_split(filename, &line_nr) != 1) {
 			free(filename);
 			goto out;
 		}
 
-		if (inline_list__append(filename, NULL, line_nr, node,
-					NULL) != 0)
+		if (inline_list__append(sym, filename, line_nr, node) != 0)
 			goto out;
 
 		filename = NULL;
@@ -454,7 +483,8 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	if (dso_name == NULL)
 		goto out;
 
-	if (!addr2line(dso_name, addr, &file, &line, dso, unwind_inlines, NULL))
+	if (!addr2line(dso_name, addr, &file, &line, dso,
+		       unwind_inlines, NULL, sym))
 		goto out;
 
 	if (asprintf(&srcline, "%s:%u",
@@ -500,7 +530,8 @@ char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	return __get_srcline(dso, addr, sym, show_sym, show_addr, false);
 }
 
-struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr)
+struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr,
+					    struct symbol *sym)
 {
 	const char *dso_name;
 
@@ -508,7 +539,7 @@ struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr)
 	if (dso_name == NULL)
 		return NULL;
 
-	return addr2inlines(dso_name, addr, dso);
+	return addr2inlines(dso_name, addr, dso, sym);
 }
 
 void inline_node__delete(struct inline_node *node)
@@ -518,7 +549,9 @@ void inline_node__delete(struct inline_node *node)
 	list_for_each_entry_safe(ilist, tmp, &node->val, list) {
 		list_del_init(&ilist->list);
 		zfree(&ilist->filename);
-		zfree(&ilist->funcname);
+		/* only the inlined symbols are owned by the list */
+		if (ilist->symbol && ilist->symbol->inlined)
+			symbol__delete(ilist->symbol);
 		free(ilist);
 	}
 

commit d964b1cdbd94f359f1f65f81440be84ceb45978e
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Sun Aug 6 23:24:45 2017 +0200

    perf srcline: Do not consider empty files as valid srclines
    
    Sometimes we get a non-null, but empty, string for the filename from
    bfd. This then results in srclines of the form ":0", which is different
    from the canonical SRCLINE_UNKNOWN in the form "??:0".  Set the file to
    NULL if it is empty to fix this.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20170806212446.24925-14-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index ebc88a74e67b..ed8e8d2de942 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -155,6 +155,9 @@ static void find_address_in_section(bfd *abfd, asection *section, void *data)
 	a2l->found = bfd_find_nearest_line(abfd, section, a2l->syms, pc - vma,
 					   &a2l->filename, &a2l->funcname,
 					   &a2l->line);
+
+	if (a2l->filename && !strlen(a2l->filename))
+		a2l->filename = NULL;
 }
 
 static struct a2l_data *addr2line_init(const char *path)
@@ -248,6 +251,9 @@ static int addr2line(const char *dso_name, u64 addr,
 					     &a2l->funcname, &a2l->line) &&
 		       cnt++ < MAX_INLINE_NEST) {
 
+			if (a2l->filename && !strlen(a2l->filename))
+				a2l->filename = NULL;
+
 			if (node != NULL) {
 				if (inline_list__append_dso_a2l(dso, node))
 					return 0;

commit 4d53b9d546f9f4505e6e3d58c8eed894d6f684e7
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Wed May 24 15:21:28 2017 +0900

    perf report: Do not drop last inlined frame
    
    The very last inlined frame, i.e. the one furthest away from the
    non-inlined frame, was silently dropped. This is apparent when
    comparing the output of `perf script` and `addr2line`:
    
    ~~~~~~
      $ perf script --inline
      ...
      a.out 26722 80836.309329:      72425 cycles:
                         21561 __hypot_finite (/usr/lib/libm-2.25.so)
                          ace3 hypot (/usr/lib/libm-2.25.so)
                           a4a main (a.out)
                               std::abs<double>
                               std::_Norm_helper<true>::_S_do_it<double>
                               std::norm<double>
                               main
                         20510 __libc_start_main (/usr/lib/libc-2.25.so)
                           bd9 _start (a.out)
    
      $ addr2line -a -f -i -e /tmp/a.out a4a | c++filt
      0x0000000000000a4a
      std::__complex_abs(doublecomplex )
      /usr/include/c++/6.3.1/complex:589
      double std::abs<double>(std::complex<double> const&)
      /usr/include/c++/6.3.1/complex:597
      double std::_Norm_helper<true>::_S_do_it<double>(std::complex<double> const&)
      /usr/include/c++/6.3.1/complex:654
      double std::norm<double>(std::complex<double> const&)
      /usr/include/c++/6.3.1/complex:664
      main
      /tmp/inlining.cpp:14
    ~~~~~
    
    Note how `std::__complex_abs` is missing from the `perf script`
    output. This is similarly showing up in `perf report`. The patch
    here fixes this issue, and the output becomes:
    
    ~~~~~
      a.out 26722 80836.309329:      72425 cycles:
                         21561 __hypot_finite (/usr/lib/libm-2.25.so)
                          ace3 hypot (/usr/lib/libm-2.25.so)
                           a4a main (a.out)
                               std::__complex_abs
                               std::abs<double>
                               std::_Norm_helper<true>::_S_do_it<double>
                               std::norm<double>
                               main
                         20510 __libc_start_main (/usr/lib/libc-2.25.so)
                           bd9 _start (a.out)
    ~~~~~
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20170524062129.32529-7-namhyung@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 6af0364cad06..ebc88a74e67b 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -203,6 +203,16 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 
 #define MAX_INLINE_NEST 1024
 
+static int inline_list__append_dso_a2l(struct dso *dso,
+				       struct inline_node *node)
+{
+	struct a2l_data *a2l = dso->a2l;
+	char *funcname = a2l->funcname ? strdup(a2l->funcname) : NULL;
+	char *filename = a2l->filename ? strdup(a2l->filename) : NULL;
+
+	return inline_list__append(filename, funcname, a2l->line, node, dso);
+}
+
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line, struct dso *dso,
 		     bool unwind_inlines, struct inline_node *node)
@@ -231,15 +241,15 @@ static int addr2line(const char *dso_name, u64 addr,
 	if (unwind_inlines) {
 		int cnt = 0;
 
+		if (node && inline_list__append_dso_a2l(dso, node))
+			return 0;
+
 		while (bfd_find_inliner_info(a2l->abfd, &a2l->filename,
 					     &a2l->funcname, &a2l->line) &&
 		       cnt++ < MAX_INLINE_NEST) {
 
 			if (node != NULL) {
-				if (inline_list__append(strdup(a2l->filename),
-							strdup(a2l->funcname),
-							a2l->line, node,
-							dso) != 0)
+				if (inline_list__append_dso_a2l(dso, node))
 					return 0;
 				// found at least one inline frame
 				ret = 1;

commit 28071f51839e393f697d0d1df0b223a4bc373606
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Wed May 24 15:21:27 2017 +0900

    perf report: Always honor callchain order for inlined nodes
    
    So far, the inlined nodes where only reversed when we built perf
    against libbfd. If that was not available, the addr2line fallback
    code path was missing the inline_list__reverse call.
    
    Now we always add the nodes in the correct order within
    inline_list__append. This removes the need to reverse the list
    and also ensures that all callers construct the list in the right
    order.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20170524062129.32529-6-namhyung@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 5e376d64d59e..6af0364cad06 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -56,7 +56,10 @@ static int inline_list__append(char *filename, char *funcname, int line_nr,
 		}
 	}
 
-	list_add_tail(&ilist->list, &node->val);
+	if (callchain_param.order == ORDER_CALLEE)
+		list_add_tail(&ilist->list, &node->val);
+	else
+		list_add(&ilist->list, &node->val);
 
 	return 0;
 }
@@ -200,14 +203,6 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 
 #define MAX_INLINE_NEST 1024
 
-static void inline_list__reverse(struct inline_node *node)
-{
-	struct inline_list *ilist, *n;
-
-	list_for_each_entry_safe_reverse(ilist, n, &node->val, list)
-		list_move_tail(&ilist->list, &node->val);
-}
-
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line, struct dso *dso,
 		     bool unwind_inlines, struct inline_node *node)
@@ -250,11 +245,6 @@ static int addr2line(const char *dso_name, u64 addr,
 				ret = 1;
 			}
 		}
-
-		if ((node != NULL) &&
-		    (callchain_param.order != ORDER_CALLEE)) {
-			inline_list__reverse(node);
-		}
 	}
 
 	if (file) {

commit b21cc97810932a551f7aac46f0b89c469c828b3f
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Wed May 24 15:21:24 2017 +0900

    perf report: Fix memory leak in addr2line when called by addr2inlines
    
    When a filename was found in addr2line it was duplicated via strdup()
    but never freed. Now we pass NULL and handle this gracefully in
    addr2line.
    
    Detected by Valgrind:
    
      ==16331== 1,680 bytes in 21 blocks are definitely lost in loss record 148 of 220
      ==16331==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
      ==16331==    by 0x672FA69: strdup (in /usr/lib/libc-2.25.so)
      ==16331==    by 0x52769F: addr2line (srcline.c:256)
      ==16331==    by 0x52769F: addr2inlines (srcline.c:294)
      ==16331==    by 0x52769F: dso__parse_addr_inlines (srcline.c:502)
      ==16331==    by 0x574D7A: inline__fprintf (hist.c:41)
      ==16331==    by 0x574D7A: ipchain__fprintf_graph (hist.c:147)
      ==16331==    by 0x57518A: __callchain__fprintf_graph (hist.c:212)
      ==16331==    by 0x5753CF: callchain__fprintf_graph.constprop.6 (hist.c:337)
      ==16331==    by 0x57738E: hist_entry__fprintf (hist.c:628)
      ==16331==    by 0x57738E: hists__fprintf (hist.c:882)
      ==16331==    by 0x44A20F: perf_evlist__tty_browse_hists (builtin-report.c:399)
      ==16331==    by 0x44A20F: report__browse_hists (builtin-report.c:491)
      ==16331==    by 0x44A20F: __cmd_report (builtin-report.c:624)
      ==16331==    by 0x44A20F: cmd_report (builtin-report.c:1054)
      ==16331==    by 0x4A49CE: run_builtin (perf.c:296)
      ==16331==    by 0x4A4CC0: handle_internal_command (perf.c:348)
      ==16331==    by 0x434371: run_argv (perf.c:392)
      ==16331==    by 0x434371: main (perf.c:530)
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20170524062129.32529-3-namhyung@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index df051a52393c..5e376d64d59e 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -230,7 +230,10 @@ static int addr2line(const char *dso_name, u64 addr,
 
 	bfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);
 
-	if (a2l->found && unwind_inlines) {
+	if (!a2l->found)
+		return 0;
+
+	if (unwind_inlines) {
 		int cnt = 0;
 
 		while (bfd_find_inliner_info(a2l->abfd, &a2l->filename,
@@ -243,6 +246,8 @@ static int addr2line(const char *dso_name, u64 addr,
 							a2l->line, node,
 							dso) != 0)
 					return 0;
+				// found at least one inline frame
+				ret = 1;
 			}
 		}
 
@@ -252,14 +257,14 @@ static int addr2line(const char *dso_name, u64 addr,
 		}
 	}
 
-	if (a2l->found && a2l->filename) {
-		*file = strdup(a2l->filename);
-		*line = a2l->line;
-
-		if (*file)
-			ret = 1;
+	if (file) {
+		*file = a2l->filename ? strdup(a2l->filename) : NULL;
+		ret = *file ? 1 : 0;
 	}
 
+	if (line)
+		*line = a2l->line;
+
 	return ret;
 }
 
@@ -278,8 +283,6 @@ void dso__free_a2l(struct dso *dso)
 static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	struct dso *dso)
 {
-	char *file = NULL;
-	unsigned int line = 0;
 	struct inline_node *node;
 
 	node = zalloc(sizeof(*node));
@@ -291,7 +294,7 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 	INIT_LIST_HEAD(&node->val);
 	node->addr = addr;
 
-	if (!addr2line(dso_name, addr, &file, &line, dso, TRUE, node))
+	if (!addr2line(dso_name, addr, NULL, NULL, dso, TRUE, node))
 		goto out_free_inline_node;
 
 	if (list_empty(&node->val))

commit 632a5cabea21eb079b788d2bb4a9318bd6fff5e1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 17 16:30:49 2017 -0300

    perf tools: Move srcline definitions to separate header
    
    Out of util.h into a new file, srcline.h
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-ludnlm4djqcdjziekzr4s3u9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index ef192802edc9..df051a52393c 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -9,6 +9,7 @@
 #include "util/util.h"
 #include "util/debug.h"
 #include "util/callchain.h"
+#include "srcline.h"
 
 #include "symbol.h"
 

commit fd20e8111cc0e51ce12fb8ee17c863088fe95065
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 17 15:23:08 2017 -0300

    perf tools: Including missing inttypes.h header
    
    Needed to use the PRI[xu](32,64) formatting macros.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-wkbho8kaw24q67dd11q0j39f@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 778ccb5d99d1..ef192802edc9 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -1,3 +1,4 @@
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

commit 5dfa210e407d0fedf746958bff206995bd46570d
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Sat Mar 18 22:49:28 2017 +0100

    perf report: Enable sorting by srcline as key
    
    Often it is interesting to know how costly a given source line is in
    total. Previously, one had to build these sums manually based on all
    addresses that pointed to the same source line. This patch introduces
    srcline as a sort key, which will do the aggregation for us.
    
    Paired with the recent addition of showing inline frames, this makes
    perf report much more useful for many C++ work loads.
    
    The following shows the new feature in action. First, let's show the
    status quo output when we sort by address. The result contains many hist
    entries that generate the same output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g address
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--60.31%--hypot +20
                |          |          |
                |          |          |--8.52%--__hypot_finite +273
                |          |          |
                |          |          |--7.32%--__hypot_finite +411
    ...
                 --35.34%--_start +4194346
                           __libc_start_main +241
                           |
                           |--6.65%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--2.70%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--1.69%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    With this patch and `-g srcline` we instead get the following output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g srcline
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--64.02%--hypot
                |          |          |
                |          |           --59.81%--__hypot_finite
                |          |
                |           --0.53%--cabs
                |
                 --35.34%--_start
                           __libc_start_main
                           |
                           |--12.48%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20170318214928.9047-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 3ce28f702b36..778ccb5d99d1 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -429,7 +429,7 @@ static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
 #define A2L_FAIL_LIMIT 123
 
 char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym, bool unwind_inlines)
+		  bool show_sym, bool show_addr, bool unwind_inlines)
 {
 	char *file = NULL;
 	unsigned line = 0;
@@ -463,6 +463,11 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 		dso->has_srcline = 0;
 		dso__free_a2l(dso);
 	}
+
+	if (!show_addr)
+		return (show_sym && sym) ?
+			    strndup(sym->name, sym->namelen) : NULL;
+
 	if (sym) {
 		if (asprintf(&srcline, "%s+%" PRIu64, show_sym ? sym->name : "",
 					addr - sym->start) < 0)
@@ -479,9 +484,9 @@ void free_srcline(char *srcline)
 }
 
 char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym)
+		  bool show_sym, bool show_addr)
 {
-	return __get_srcline(dso, addr, sym, show_sym, false);
+	return __get_srcline(dso, addr, sym, show_sym, show_addr, false);
 }
 
 struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr)

commit a64489c56c307bf0955f0489158c5ecf6aa10fe2
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Sun Mar 26 04:34:26 2017 +0800

    perf report: Find the inline stack for a given address
    
    It would be useful for perf to support a mode to query the inline stack
    for a given callgraph address. This would simplify finding the right
    code in code that does a lot of inlining.
    
    The srcline.c has contained the code which supports to translate the
    address to filename:line_nr. This patch just extends the function to let
    it support getting the inline stacks.
    
    It introduces the inline_list which will store the inline function
    result (filename:line_nr and funcname).
    
    If BFD lib is not supported, the result is only filename:line_nr.
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Tested-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Link: http://lkml.kernel.org/r/1490474069-15823-3-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 2953c9fecb30..3ce28f702b36 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -7,6 +7,7 @@
 #include "util/dso.h"
 #include "util/util.h"
 #include "util/debug.h"
+#include "util/callchain.h"
 
 #include "symbol.h"
 
@@ -30,6 +31,34 @@ static const char *dso__name(struct dso *dso)
 	return dso_name;
 }
 
+static int inline_list__append(char *filename, char *funcname, int line_nr,
+			       struct inline_node *node, struct dso *dso)
+{
+	struct inline_list *ilist;
+	char *demangled;
+
+	ilist = zalloc(sizeof(*ilist));
+	if (ilist == NULL)
+		return -1;
+
+	ilist->filename = filename;
+	ilist->line_nr = line_nr;
+
+	if (dso != NULL) {
+		demangled = dso__demangle_sym(dso, 0, funcname);
+		if (demangled == NULL) {
+			ilist->funcname = funcname;
+		} else {
+			ilist->funcname = demangled;
+			free(funcname);
+		}
+	}
+
+	list_add_tail(&ilist->list, &node->val);
+
+	return 0;
+}
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -169,9 +198,17 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 
 #define MAX_INLINE_NEST 1024
 
+static void inline_list__reverse(struct inline_node *node)
+{
+	struct inline_list *ilist, *n;
+
+	list_for_each_entry_safe_reverse(ilist, n, &node->val, list)
+		list_move_tail(&ilist->list, &node->val);
+}
+
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line, struct dso *dso,
-		     bool unwind_inlines)
+		     bool unwind_inlines, struct inline_node *node)
 {
 	int ret = 0;
 	struct a2l_data *a2l = dso->a2l;
@@ -196,8 +233,21 @@ static int addr2line(const char *dso_name, u64 addr,
 
 		while (bfd_find_inliner_info(a2l->abfd, &a2l->filename,
 					     &a2l->funcname, &a2l->line) &&
-		       cnt++ < MAX_INLINE_NEST)
-			;
+		       cnt++ < MAX_INLINE_NEST) {
+
+			if (node != NULL) {
+				if (inline_list__append(strdup(a2l->filename),
+							strdup(a2l->funcname),
+							a2l->line, node,
+							dso) != 0)
+					return 0;
+			}
+		}
+
+		if ((node != NULL) &&
+		    (callchain_param.order != ORDER_CALLEE)) {
+			inline_list__reverse(node);
+		}
 	}
 
 	if (a2l->found && a2l->filename) {
@@ -223,6 +273,35 @@ void dso__free_a2l(struct dso *dso)
 	dso->a2l = NULL;
 }
 
+static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
+	struct dso *dso)
+{
+	char *file = NULL;
+	unsigned int line = 0;
+	struct inline_node *node;
+
+	node = zalloc(sizeof(*node));
+	if (node == NULL) {
+		perror("not enough memory for the inline node");
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&node->val);
+	node->addr = addr;
+
+	if (!addr2line(dso_name, addr, &file, &line, dso, TRUE, node))
+		goto out_free_inline_node;
+
+	if (list_empty(&node->val))
+		goto out_free_inline_node;
+
+	return node;
+
+out_free_inline_node:
+	inline_node__delete(node);
+	return NULL;
+}
+
 #else /* HAVE_LIBBFD_SUPPORT */
 
 static int filename_split(char *filename, unsigned int *line_nr)
@@ -249,7 +328,8 @@ static int filename_split(char *filename, unsigned int *line_nr)
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line_nr,
 		     struct dso *dso __maybe_unused,
-		     bool unwind_inlines __maybe_unused)
+		     bool unwind_inlines __maybe_unused,
+		     struct inline_node *node __maybe_unused)
 {
 	FILE *fp;
 	char cmd[PATH_MAX];
@@ -288,6 +368,58 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
 {
 }
 
+static struct inline_node *addr2inlines(const char *dso_name, u64 addr,
+	struct dso *dso __maybe_unused)
+{
+	FILE *fp;
+	char cmd[PATH_MAX];
+	struct inline_node *node;
+	char *filename = NULL;
+	size_t len;
+	unsigned int line_nr = 0;
+
+	scnprintf(cmd, sizeof(cmd), "addr2line -e %s -i %016"PRIx64,
+		  dso_name, addr);
+
+	fp = popen(cmd, "r");
+	if (fp == NULL) {
+		pr_err("popen failed for %s\n", dso_name);
+		return NULL;
+	}
+
+	node = zalloc(sizeof(*node));
+	if (node == NULL) {
+		perror("not enough memory for the inline node");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&node->val);
+	node->addr = addr;
+
+	while (getline(&filename, &len, fp) != -1) {
+		if (filename_split(filename, &line_nr) != 1) {
+			free(filename);
+			goto out;
+		}
+
+		if (inline_list__append(filename, NULL, line_nr, node,
+					NULL) != 0)
+			goto out;
+
+		filename = NULL;
+	}
+
+out:
+	pclose(fp);
+
+	if (list_empty(&node->val)) {
+		inline_node__delete(node);
+		return NULL;
+	}
+
+	return node;
+}
+
 #endif /* HAVE_LIBBFD_SUPPORT */
 
 /*
@@ -311,7 +443,7 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	if (dso_name == NULL)
 		goto out;
 
-	if (!addr2line(dso_name, addr, &file, &line, dso, unwind_inlines))
+	if (!addr2line(dso_name, addr, &file, &line, dso, unwind_inlines, NULL))
 		goto out;
 
 	if (asprintf(&srcline, "%s:%u",
@@ -351,3 +483,28 @@ char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 {
 	return __get_srcline(dso, addr, sym, show_sym, false);
 }
+
+struct inline_node *dso__parse_addr_inlines(struct dso *dso, u64 addr)
+{
+	const char *dso_name;
+
+	dso_name = dso__name(dso);
+	if (dso_name == NULL)
+		return NULL;
+
+	return addr2inlines(dso_name, addr, dso);
+}
+
+void inline_node__delete(struct inline_node *node)
+{
+	struct inline_list *ilist, *tmp;
+
+	list_for_each_entry_safe(ilist, tmp, &node->val, list) {
+		list_del_init(&ilist->list);
+		zfree(&ilist->filename);
+		zfree(&ilist->funcname);
+		free(ilist);
+	}
+
+	free(node);
+}

commit 5580338d0f207921bc1fef5b668cd564adcc3419
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Sun Mar 26 04:34:25 2017 +0800

    perf report: Refactor common code in srcline.c
    
    Introduce dso__name() and filename_split() out of existing code because
    these codes will be used in several places in next patch.
    
    For filename_split(), it may also solve a potential memory leak in
    existing code. In existing addr2line(),
    
            sep = strchr(filename, ':');
            if (sep) {
                    *sep++ = '\0';
                    *file = filename;
                    *line_nr = strtoul(sep, NULL, 0);
                    ret = 1;
            }
    
    out:
            pclose(fp);
            return ret;
    
    If sep is NULL, filename is not freed or returned via file.
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Tested-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Link: http://lkml.kernel.org/r/1490474069-15823-2-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index b4db3f48e3b0..2953c9fecb30 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -12,6 +12,24 @@
 
 bool srcline_full_filename;
 
+static const char *dso__name(struct dso *dso)
+{
+	const char *dso_name;
+
+	if (dso->symsrc_filename)
+		dso_name = dso->symsrc_filename;
+	else
+		dso_name = dso->long_name;
+
+	if (dso_name[0] == '[')
+		return NULL;
+
+	if (!strncmp(dso_name, "/tmp/perf-", 10))
+		return NULL;
+
+	return dso_name;
+}
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -207,6 +225,27 @@ void dso__free_a2l(struct dso *dso)
 
 #else /* HAVE_LIBBFD_SUPPORT */
 
+static int filename_split(char *filename, unsigned int *line_nr)
+{
+	char *sep;
+
+	sep = strchr(filename, '\n');
+	if (sep)
+		*sep = '\0';
+
+	if (!strcmp(filename, "??:0"))
+		return 0;
+
+	sep = strchr(filename, ':');
+	if (sep) {
+		*sep++ = '\0';
+		*line_nr = strtoul(sep, NULL, 0);
+		return 1;
+	}
+
+	return 0;
+}
+
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line_nr,
 		     struct dso *dso __maybe_unused,
@@ -216,7 +255,6 @@ static int addr2line(const char *dso_name, u64 addr,
 	char cmd[PATH_MAX];
 	char *filename = NULL;
 	size_t len;
-	char *sep;
 	int ret = 0;
 
 	scnprintf(cmd, sizeof(cmd), "addr2line -e %s %016"PRIx64,
@@ -233,23 +271,14 @@ static int addr2line(const char *dso_name, u64 addr,
 		goto out;
 	}
 
-	sep = strchr(filename, '\n');
-	if (sep)
-		*sep = '\0';
-
-	if (!strcmp(filename, "??:0")) {
-		pr_debug("no debugging info in %s\n", dso_name);
+	ret = filename_split(filename, line_nr);
+	if (ret != 1) {
 		free(filename);
 		goto out;
 	}
 
-	sep = strchr(filename, ':');
-	if (sep) {
-		*sep++ = '\0';
-		*file = filename;
-		*line_nr = strtoul(sep, NULL, 0);
-		ret = 1;
-	}
+	*file = filename;
+
 out:
 	pclose(fp);
 	return ret;
@@ -278,15 +307,8 @@ char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	if (!dso->has_srcline)
 		goto out;
 
-	if (dso->symsrc_filename)
-		dso_name = dso->symsrc_filename;
-	else
-		dso_name = dso->long_name;
-
-	if (dso_name[0] == '[')
-		goto out;
-
-	if (!strncmp(dso_name, "/tmp/perf-", 10))
+	dso_name = dso__name(dso);
+	if (dso_name == NULL)
 		goto out;
 
 	if (!addr2line(dso_name, addr, &file, &line, dso, unwind_inlines))

commit 2f84b42b28eed0f980200401077e51571202f868
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Sep 1 11:47:19 2015 -0700

    perf tools: Always use non inlined file name for 'srcfile' sort key
    
    When profiling the kernel with the 'srcfile' sort key it's common to
    "get stuck" in include. For example a lot of code uses current or other
    inlines, so they get accounted to some random include file. This is not
    very useful as a high level categorization.
    
    For example just profiling the idle loop usually shows mostly inlines,
    so you never see the actual cpuidle file.
    
    This patch changes the 'srcfile' sort key to always unwind the inline
    stack using BFD/DWARF. So we always account to the base function that
    called the inline.
    
    In a few cases include is still shown (for example for MSR accesses),
    but that is because they get inlining expanded as part of assigning to a
    global function pointer. For the majority it works fine though.
    
    v2: Use simpler while loop. Add maximum iteration count.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/1441133239-31254-1-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index fc08248f08ca..b4db3f48e3b0 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -149,8 +149,11 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 	free(a2l);
 }
 
+#define MAX_INLINE_NEST 1024
+
 static int addr2line(const char *dso_name, u64 addr,
-		     char **file, unsigned int *line, struct dso *dso)
+		     char **file, unsigned int *line, struct dso *dso,
+		     bool unwind_inlines)
 {
 	int ret = 0;
 	struct a2l_data *a2l = dso->a2l;
@@ -170,6 +173,15 @@ static int addr2line(const char *dso_name, u64 addr,
 
 	bfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);
 
+	if (a2l->found && unwind_inlines) {
+		int cnt = 0;
+
+		while (bfd_find_inliner_info(a2l->abfd, &a2l->filename,
+					     &a2l->funcname, &a2l->line) &&
+		       cnt++ < MAX_INLINE_NEST)
+			;
+	}
+
 	if (a2l->found && a2l->filename) {
 		*file = strdup(a2l->filename);
 		*line = a2l->line;
@@ -197,7 +209,8 @@ void dso__free_a2l(struct dso *dso)
 
 static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line_nr,
-		     struct dso *dso __maybe_unused)
+		     struct dso *dso __maybe_unused,
+		     bool unwind_inlines __maybe_unused)
 {
 	FILE *fp;
 	char cmd[PATH_MAX];
@@ -254,8 +267,8 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
  */
 #define A2L_FAIL_LIMIT 123
 
-char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
-		  bool show_sym)
+char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
+		  bool show_sym, bool unwind_inlines)
 {
 	char *file = NULL;
 	unsigned line = 0;
@@ -276,7 +289,7 @@ char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	if (!strncmp(dso_name, "/tmp/perf-", 10))
 		goto out;
 
-	if (!addr2line(dso_name, addr, &file, &line, dso))
+	if (!addr2line(dso_name, addr, &file, &line, dso, unwind_inlines))
 		goto out;
 
 	if (asprintf(&srcline, "%s:%u",
@@ -310,3 +323,9 @@ void free_srcline(char *srcline)
 	if (srcline && strcmp(srcline, SRCLINE_UNKNOWN) != 0)
 		free(srcline);
 }
+
+char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
+		  bool show_sym)
+{
+	return __get_srcline(dso, addr, sym, show_sym, false);
+}

commit a9710ba091b0dcdace90f791706e9192313ffb7c
Author: Andi Kleen <ak@linux.intel.com>
Date:   Fri Aug 7 15:24:05 2015 -0700

    perf tools: Support full source file paths for srcline
    
    For perf report/script srcline currently only the base file name of the
    source file is printed. This is a good default because it usually fits
    on the screen.
    
    But in some cases we want to know the full file name, for example to
    aggregate hits per file.
    
    In the later case we need more than the base file name to resolve file
    naming collisions: for example the kernel source has ~70 files named
    "core.c"
    
    It's also useful as input to post processing tools which want to point
    to the right file.
    
    Add a flag to allow full file name output.
    
    Add an option to perf report/script to enable this option.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1438986245-15191-1-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index c93fb0c5bd0b..fc08248f08ca 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -10,6 +10,8 @@
 
 #include "symbol.h"
 
+bool srcline_full_filename;
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -277,7 +279,9 @@ char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 	if (!addr2line(dso_name, addr, &file, &line, dso))
 		goto out;
 
-	if (asprintf(&srcline, "%s:%u", basename(file), line) < 0) {
+	if (asprintf(&srcline, "%s:%u",
+				srcline_full_filename ? file : basename(file),
+				line) < 0) {
 		free(file);
 		goto out;
 	}

commit ac931f87a647ca156f65a4c00e7297165e4fa2d8
Author: Wang Nan <wangnan0@huawei.com>
Date:   Tue Dec 16 14:19:06 2014 +0800

    perf: Fix building warning on ARM 32
    
    Commit 85c116a6cb91 ("perf callchain: Make get_srcline fall back to sym+offset")
    introduces asprintf() call and matches '%ld' to a u64 argument, which is
    incorrect on ARM:
    
       CC       /home/wn/util/srcline.o
     util/srcline.c: In function 'get_srcline':
     util/srcline.c:297:6: error: format '%ld' expects argument of type 'long int', but argument 4 has type 'u64' [-Werror=format]
     cc1: all warnings being treated as errors
     make[1]: *** [/home/wn/util/srcline.o] Error 1
    
    In addition, all users of get_srcline() use u64 addr, and libbfd
    also use 64 bit bfd_vma as address. This patch also fix
    prototype of get_srcline() and addr2line() to use u64 addr
    instead of unsigned long.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: <lizefan@huawei.com>
    Cc: <a.p.zijlstra@chello.nl>
    Cc: <paulus@samba.org>
    Cc: <acme@kernel.org>
    Cc: <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1418710746-35943-1-git-send-email-wangnan0@huawei.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index e73b6a5c9e0f..c93fb0c5bd0b 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -20,7 +20,7 @@
 
 struct a2l_data {
 	const char 	*input;
-	unsigned long 	addr;
+	u64	 	addr;
 
 	bool 		found;
 	const char 	*filename;
@@ -147,7 +147,7 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 	free(a2l);
 }
 
-static int addr2line(const char *dso_name, unsigned long addr,
+static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line, struct dso *dso)
 {
 	int ret = 0;
@@ -193,7 +193,7 @@ void dso__free_a2l(struct dso *dso)
 
 #else /* HAVE_LIBBFD_SUPPORT */
 
-static int addr2line(const char *dso_name, unsigned long addr,
+static int addr2line(const char *dso_name, u64 addr,
 		     char **file, unsigned int *line_nr,
 		     struct dso *dso __maybe_unused)
 {
@@ -252,7 +252,7 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
  */
 #define A2L_FAIL_LIMIT 123
 
-char *get_srcline(struct dso *dso, unsigned long addr, struct symbol *sym,
+char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 		  bool show_sym)
 {
 	char *file = NULL;
@@ -293,10 +293,10 @@ char *get_srcline(struct dso *dso, unsigned long addr, struct symbol *sym,
 		dso__free_a2l(dso);
 	}
 	if (sym) {
-		if (asprintf(&srcline, "%s+%ld", show_sym ? sym->name : "",
+		if (asprintf(&srcline, "%s+%" PRIu64, show_sym ? sym->name : "",
 					addr - sym->start) < 0)
 			return SRCLINE_UNKNOWN;
-	} else if (asprintf(&srcline, "%s[%lx]", dso->short_name, addr) < 0)
+	} else if (asprintf(&srcline, "%s[%" PRIx64 "]", dso->short_name, addr) < 0)
 		return SRCLINE_UNKNOWN;
 	return srcline;
 }

commit 85c116a6cb91a5c09b7a6c95ffc6a6cbd32cd237
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:27 2014 -0800

    perf callchain: Make get_srcline fall back to sym+offset
    
    When the source line is not found fall back to sym + offset.  This is
    generally much more useful than a raw address.
    
    For this we need to pass in the symbol from the caller.
    
    For some callers it's awkward to compute, so we stay at the old
    behaviour.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-10-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index ac877f96fed7..e73b6a5c9e0f 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -8,6 +8,8 @@
 #include "util/util.h"
 #include "util/debug.h"
 
+#include "symbol.h"
+
 #ifdef HAVE_LIBBFD_SUPPORT
 
 /*
@@ -250,7 +252,8 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
  */
 #define A2L_FAIL_LIMIT 123
 
-char *get_srcline(struct dso *dso, unsigned long addr)
+char *get_srcline(struct dso *dso, unsigned long addr, struct symbol *sym,
+		  bool show_sym)
 {
 	char *file = NULL;
 	unsigned line = 0;
@@ -289,7 +292,11 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 		dso->has_srcline = 0;
 		dso__free_a2l(dso);
 	}
-	if (asprintf(&srcline, "%s[%lx]", dso->short_name, addr) < 0)
+	if (sym) {
+		if (asprintf(&srcline, "%s+%ld", show_sym ? sym->name : "",
+					addr - sym->start) < 0)
+			return SRCLINE_UNKNOWN;
+	} else if (asprintf(&srcline, "%s[%lx]", dso->short_name, addr) < 0)
 		return SRCLINE_UNKNOWN;
 	return srcline;
 }

commit 23f0981bbd89fcc1496d0490ec39ca7c91599e32
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:24 2014 -0800

    perf callchain: Enable printing the srcline in the history
    
    For lbr-as-callgraph we need to see the line number in the history,
    because many LBR entries can be in a single function, and just
    showing the same function name many times is not useful.
    
    When the history code is configured to sort by address, also try to
    resolve the address to a file:srcline and display this in the browser.
    If that doesn't work still display the address.
    
    This can be also useful without LBRs for understanding which call in a large
    function (or in which inlined function) called something else.
    
    Contains fixes from Namhyung Kim
    
    v2: Refactor code into common function
    v3: Fix GTK build
    v4: Rebase
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-7-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 77c180637138..ac877f96fed7 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -258,7 +258,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	const char *dso_name;
 
 	if (!dso->has_srcline)
-		return SRCLINE_UNKNOWN;
+		goto out;
 
 	if (dso->symsrc_filename)
 		dso_name = dso->symsrc_filename;
@@ -289,7 +289,9 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 		dso->has_srcline = 0;
 		dso__free_a2l(dso);
 	}
-	return SRCLINE_UNKNOWN;
+	if (asprintf(&srcline, "%s[%lx]", dso->short_name, addr) < 0)
+		return SRCLINE_UNKNOWN;
+	return srcline;
 }
 
 void free_srcline(char *srcline)

commit 2de217688e8f086bf6d920d530401b56fcbc6eff
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:25 2014 -0800

    perf tools: Only print base source file for srcline
    
    For perf report with --sort srcline only print the base source file
    name. This makes the results generally fit much better to the screen.
    The path is usually not that useful anyways because it is often from
    different systems.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-8-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index f3e4bc5fe5d2..77c180637138 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -274,7 +274,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	if (!addr2line(dso_name, addr, &file, &line, dso))
 		goto out;
 
-	if (asprintf(&srcline, "%s:%u", file, line) < 0) {
+	if (asprintf(&srcline, "%s:%u", basename(file), line) < 0) {
 		free(file);
 		goto out;
 	}

commit 7d16c634233c411f54b89d0f1d51750dc85c5f7e
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Jan 9 23:07:59 2014 +0900

    perf tools: Fix build error due to zfree() cast
    
    It failed to build perf on my ubuntu 10.04 box (gcc 4.4.3):
    
        CC       util/strlist.o
      cc1: warnings being treated as errors
      util/strlist.c: In function ‘str_node__delete’:
      util/strlist.c:42: error: dereferencing type-punned pointer will break strict-aliasing rules
      util/strlist.c:42: error: dereferencing type-punned pointer will break strict-aliasing rules
        CC       util/strfilter.o
      make: *** [util/strlist.o] Error 1
    
        CC       util/srcline.o
      cc1: warnings being treated as errors
      util/srcline.c: In function ‘addr2line_init’:
      util/srcline.c:132: error: dereferencing type-punned pointer will break strict-aliasing rules
      util/srcline.c:132: error: dereferencing type-punned pointer will break strict-aliasing rules
      util/srcline.c: In function ‘addr2line_cleanup’:
      util/srcline.c:143: error: dereferencing type-punned pointer will break strict-aliasing rules
      util/srcline.c:143: error: dereferencing type-punned pointer will break strict-aliasing rules
      make: *** [util/srcline.o] Error 1
    
    It seems it only allows to remove 'const' qualifier.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1389276479-9047-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 7e67879ebd25..f3e4bc5fe5d2 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -129,7 +129,7 @@ static struct a2l_data *addr2line_init(const char *path)
 
 out:
 	if (a2l) {
-		zfree((void **)&a2l->input);
+		zfree((char **)&a2l->input);
 		free(a2l);
 	}
 	bfd_close(abfd);
@@ -140,7 +140,7 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 {
 	if (a2l->abfd)
 		bfd_close(a2l->abfd);
-	zfree((void **)&a2l->input);
+	zfree((char **)&a2l->input);
 	zfree(&a2l->syms);
 	free(a2l);
 }

commit 74cf249d5cf7de84c88cca69a2f13b13d500ff94
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Dec 27 16:55:14 2013 -0300

    perf tools: Use zfree to help detect use after free bugs
    
    Several areas already used this technique, so do some audit to
    consistently use it elsewhere.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-9sbere0kkplwe45ak6rk4a1f@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 58b2bd8f38c9..7e67879ebd25 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -129,7 +129,7 @@ static struct a2l_data *addr2line_init(const char *path)
 
 out:
 	if (a2l) {
-		free((void *)a2l->input);
+		zfree((void **)&a2l->input);
 		free(a2l);
 	}
 	bfd_close(abfd);
@@ -140,8 +140,8 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 {
 	if (a2l->abfd)
 		bfd_close(a2l->abfd);
-	free((void *)a2l->input);
-	free(a2l->syms);
+	zfree((void **)&a2l->input);
+	zfree(&a2l->syms);
 	free(a2l);
 }
 

commit bf4414ae7b86cddca60a5b510954a37d30583a1f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Dec 10 15:19:23 2013 -0300

    perf symbols: Constify dso->long_name
    
    Same reason as for dso->short_name, it may point to a const string, and
    in most places it is treated as const, i.e. it is just accessed for
    using its contents as a key or to show it on reports.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-nf7mxf33zt5qw207pbxxryot@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 0c075560ad46..58b2bd8f38c9 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -255,7 +255,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	char *file = NULL;
 	unsigned line = 0;
 	char *srcline;
-	char *dso_name;
+	const char *dso_name;
 
 	if (!dso->has_srcline)
 		return SRCLINE_UNKNOWN;

commit 906049c8276eb99af997f73d602649a98e360035
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Dec 3 09:23:10 2013 +0200

    perf tools: Do not disable source line lookup just because of 1 failure
    
    Looking up an ip's source file name and line number does not succeed
    always.  Current logic disables the lookup for a dso entirely on any
    failure.  Change it so that disabling never happens if there has ever
    been a successful lookup for that dso but disable if the first 123
    lookups fail.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1386055390-13757-8-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 93795f9c2480..0c075560ad46 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -244,6 +244,12 @@ void dso__free_a2l(struct dso *dso __maybe_unused)
 
 #endif /* HAVE_LIBBFD_SUPPORT */
 
+/*
+ * Number of addr2line failures (without success) before disabling it for that
+ * dso.
+ */
+#define A2L_FAIL_LIMIT 123
+
 char *get_srcline(struct dso *dso, unsigned long addr)
 {
 	char *file = NULL;
@@ -268,15 +274,21 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	if (!addr2line(dso_name, addr, &file, &line, dso))
 		goto out;
 
-	if (asprintf(&srcline, "%s:%u", file, line) < 0)
-		srcline = SRCLINE_UNKNOWN;
+	if (asprintf(&srcline, "%s:%u", file, line) < 0) {
+		free(file);
+		goto out;
+	}
+
+	dso->a2l_fails = 0;
 
 	free(file);
 	return srcline;
 
 out:
-	dso->has_srcline = 0;
-	dso__free_a2l(dso);
+	if (dso->a2l_fails && ++dso->a2l_fails > A2L_FAIL_LIMIT) {
+		dso->has_srcline = 0;
+		dso__free_a2l(dso);
+	}
 	return SRCLINE_UNKNOWN;
 }
 

commit 0058aef65eda9c9dde8253af702d542ba7eef697
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Dec 3 09:23:08 2013 +0200

    perf symbols: Retain symbol source file name to lookup source line numbers
    
    Currently, lookup of an ip's source file name and line number is done
    using the dso file name.
    
    Instead retain the file name used to lookup the dso's symbols and use
    that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1386055390-13757-6-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 25b85b28301b..93795f9c2480 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -249,11 +249,16 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	char *file = NULL;
 	unsigned line = 0;
 	char *srcline;
-	char *dso_name = dso->long_name;
+	char *dso_name;
 
 	if (!dso->has_srcline)
 		return SRCLINE_UNKNOWN;
 
+	if (dso->symsrc_filename)
+		dso_name = dso->symsrc_filename;
+	else
+		dso_name = dso->long_name;
+
 	if (dso_name[0] == '[')
 		goto out;
 

commit 454ff00f969e515c4cbfd52718ec5e01c7d9aeef
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Dec 3 09:23:07 2013 +0200

    perf symbols: Retain bfd reference to lookup source line numbers
    
    Closng and re-opening for every lookup when using libbfd to lookup
    source file name and line number is very very slow.  Instead keep the
    reference on struct dso.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1386055390-13757-5-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 4c8e816a2191..25b85b28301b 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -146,18 +146,24 @@ static void addr2line_cleanup(struct a2l_data *a2l)
 }
 
 static int addr2line(const char *dso_name, unsigned long addr,
-		     char **file, unsigned int *line)
+		     char **file, unsigned int *line, struct dso *dso)
 {
 	int ret = 0;
-	struct a2l_data *a2l;
+	struct a2l_data *a2l = dso->a2l;
+
+	if (!a2l) {
+		dso->a2l = addr2line_init(dso_name);
+		a2l = dso->a2l;
+	}
 
-	a2l = addr2line_init(dso_name);
 	if (a2l == NULL) {
 		pr_warning("addr2line_init failed for %s\n", dso_name);
 		return 0;
 	}
 
 	a2l->addr = addr;
+	a2l->found = false;
+
 	bfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);
 
 	if (a2l->found && a2l->filename) {
@@ -168,14 +174,26 @@ static int addr2line(const char *dso_name, unsigned long addr,
 			ret = 1;
 	}
 
-	addr2line_cleanup(a2l);
 	return ret;
 }
 
+void dso__free_a2l(struct dso *dso)
+{
+	struct a2l_data *a2l = dso->a2l;
+
+	if (!a2l)
+		return;
+
+	addr2line_cleanup(a2l);
+
+	dso->a2l = NULL;
+}
+
 #else /* HAVE_LIBBFD_SUPPORT */
 
 static int addr2line(const char *dso_name, unsigned long addr,
-		     char **file, unsigned int *line_nr)
+		     char **file, unsigned int *line_nr,
+		     struct dso *dso __maybe_unused)
 {
 	FILE *fp;
 	char cmd[PATH_MAX];
@@ -219,6 +237,11 @@ static int addr2line(const char *dso_name, unsigned long addr,
 	pclose(fp);
 	return ret;
 }
+
+void dso__free_a2l(struct dso *dso __maybe_unused)
+{
+}
+
 #endif /* HAVE_LIBBFD_SUPPORT */
 
 char *get_srcline(struct dso *dso, unsigned long addr)
@@ -237,7 +260,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	if (!strncmp(dso_name, "/tmp/perf-", 10))
 		goto out;
 
-	if (!addr2line(dso_name, addr, &file, &line))
+	if (!addr2line(dso_name, addr, &file, &line, dso))
 		goto out;
 
 	if (asprintf(&srcline, "%s:%u", file, line) < 0)
@@ -248,6 +271,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 
 out:
 	dso->has_srcline = 0;
+	dso__free_a2l(dso);
 	return SRCLINE_UNKNOWN;
 }
 

commit d88938ebc97df72320609b33aa0cf9a9a98accb1
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Dec 3 09:23:06 2013 +0200

    perf tools: Use asprintf instead of malloc plus snprintf
    
    The asprintf library function is equivalent to malloc plus snprintf so
    use it because it is simpler.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1386055390-13757-4-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index d11aefbc4b8d..4c8e816a2191 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -227,7 +227,6 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	unsigned line = 0;
 	char *srcline;
 	char *dso_name = dso->long_name;
-	size_t size;
 
 	if (!dso->has_srcline)
 		return SRCLINE_UNKNOWN;
@@ -241,13 +240,7 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 	if (!addr2line(dso_name, addr, &file, &line))
 		goto out;
 
-	/* just calculate actual length */
-	size = snprintf(NULL, 0, "%s:%u", file, line) + 1;
-
-	srcline = malloc(size);
-	if (srcline)
-		snprintf(srcline, size, "%s:%u", file, line);
-	else
+	if (asprintf(&srcline, "%s:%u", file, line) < 0)
 		srcline = SRCLINE_UNKNOWN;
 
 	free(file);

commit a949fffb84df6f9be136198a00f796a9dc696bd0
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 9 21:51:31 2013 -0600

    perf tools: Fix old GCC build error in 'get_srcline'
    
    trace-event-parse.c:parse_proc_kallsyms()
    
        Old GCC (4.4.2) does not see through the code flow of get_srcline() and
    gets confused about the status of 'file' and 'line':
    
        CC       /tmp/build/perf/util/srcline.o
      cc1: warnings being treated as errors
      util/srcline.c: In function ¿get_srcline¿:
      util/srcline.c:226: error: ¿file¿ may be used uninitialized in this function
      util/srcline.c:227: error: ¿line¿ may be used uninitialized in this function
      make[1]: *** [/tmp/build/perf/util/srcline.o] Error 1
      make: *** [install] Error 2
      make: Leaving directory `/home/acme/git/linux/tools/perf'
      [acme@fedora12 linux]$
    
    Help out GCC by initializing 'file' and 'line'.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Link: http://lkml.kernel.org/n/tip-h8k7h49z3cndqgjdftkmm9f8@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 37353194e0f6..d11aefbc4b8d 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -223,8 +223,8 @@ static int addr2line(const char *dso_name, unsigned long addr,
 
 char *get_srcline(struct dso *dso, unsigned long addr)
 {
-	char *file;
-	unsigned line;
+	char *file = NULL;
+	unsigned line = 0;
 	char *srcline;
 	char *dso_name = dso->long_name;
 	size_t size;

commit 2f48fcd84e9e68392e29c59204a4a434311d49e9
Author: Roberto Vitillo <ravitillo@lbl.gov>
Date:   Wed Sep 11 14:09:32 2013 +0900

    perf tools: Implement addr2line directly using libbfd
    
    When the srcline sort key is used , the external addr2line utility needs
    to be run for each hist entry to get the srcline info.  This can consume
    quite a time if one has a huge perf.data file.
    
    So rather than executing the external utility, implement it internally
    and just call it.  We can do it since we've linked with libbfd already.
    
    Signed-off-by: Roberto Agostino Vitillo <ravitillo@lbl.gov>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1378876173-13363-9-git-send-email-namhyung@kernel.org
    [ Use a2l_data struct instead of static globals ]
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index dcff10bed7da..37353194e0f6 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -8,6 +8,172 @@
 #include "util/util.h"
 #include "util/debug.h"
 
+#ifdef HAVE_LIBBFD_SUPPORT
+
+/*
+ * Implement addr2line using libbfd.
+ */
+#define PACKAGE "perf"
+#include <bfd.h>
+
+struct a2l_data {
+	const char 	*input;
+	unsigned long 	addr;
+
+	bool 		found;
+	const char 	*filename;
+	const char 	*funcname;
+	unsigned 	line;
+
+	bfd 		*abfd;
+	asymbol 	**syms;
+};
+
+static int bfd_error(const char *string)
+{
+	const char *errmsg;
+
+	errmsg = bfd_errmsg(bfd_get_error());
+	fflush(stdout);
+
+	if (string)
+		pr_debug("%s: %s\n", string, errmsg);
+	else
+		pr_debug("%s\n", errmsg);
+
+	return -1;
+}
+
+static int slurp_symtab(bfd *abfd, struct a2l_data *a2l)
+{
+	long storage;
+	long symcount;
+	asymbol **syms;
+	bfd_boolean dynamic = FALSE;
+
+	if ((bfd_get_file_flags(abfd) & HAS_SYMS) == 0)
+		return bfd_error(bfd_get_filename(abfd));
+
+	storage = bfd_get_symtab_upper_bound(abfd);
+	if (storage == 0L) {
+		storage = bfd_get_dynamic_symtab_upper_bound(abfd);
+		dynamic = TRUE;
+	}
+	if (storage < 0L)
+		return bfd_error(bfd_get_filename(abfd));
+
+	syms = malloc(storage);
+	if (dynamic)
+		symcount = bfd_canonicalize_dynamic_symtab(abfd, syms);
+	else
+		symcount = bfd_canonicalize_symtab(abfd, syms);
+
+	if (symcount < 0) {
+		free(syms);
+		return bfd_error(bfd_get_filename(abfd));
+	}
+
+	a2l->syms = syms;
+	return 0;
+}
+
+static void find_address_in_section(bfd *abfd, asection *section, void *data)
+{
+	bfd_vma pc, vma;
+	bfd_size_type size;
+	struct a2l_data *a2l = data;
+
+	if (a2l->found)
+		return;
+
+	if ((bfd_get_section_flags(abfd, section) & SEC_ALLOC) == 0)
+		return;
+
+	pc = a2l->addr;
+	vma = bfd_get_section_vma(abfd, section);
+	size = bfd_get_section_size(section);
+
+	if (pc < vma || pc >= vma + size)
+		return;
+
+	a2l->found = bfd_find_nearest_line(abfd, section, a2l->syms, pc - vma,
+					   &a2l->filename, &a2l->funcname,
+					   &a2l->line);
+}
+
+static struct a2l_data *addr2line_init(const char *path)
+{
+	bfd *abfd;
+	struct a2l_data *a2l = NULL;
+
+	abfd = bfd_openr(path, NULL);
+	if (abfd == NULL)
+		return NULL;
+
+	if (!bfd_check_format(abfd, bfd_object))
+		goto out;
+
+	a2l = zalloc(sizeof(*a2l));
+	if (a2l == NULL)
+		goto out;
+
+	a2l->abfd = abfd;
+	a2l->input = strdup(path);
+	if (a2l->input == NULL)
+		goto out;
+
+	if (slurp_symtab(abfd, a2l))
+		goto out;
+
+	return a2l;
+
+out:
+	if (a2l) {
+		free((void *)a2l->input);
+		free(a2l);
+	}
+	bfd_close(abfd);
+	return NULL;
+}
+
+static void addr2line_cleanup(struct a2l_data *a2l)
+{
+	if (a2l->abfd)
+		bfd_close(a2l->abfd);
+	free((void *)a2l->input);
+	free(a2l->syms);
+	free(a2l);
+}
+
+static int addr2line(const char *dso_name, unsigned long addr,
+		     char **file, unsigned int *line)
+{
+	int ret = 0;
+	struct a2l_data *a2l;
+
+	a2l = addr2line_init(dso_name);
+	if (a2l == NULL) {
+		pr_warning("addr2line_init failed for %s\n", dso_name);
+		return 0;
+	}
+
+	a2l->addr = addr;
+	bfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);
+
+	if (a2l->found && a2l->filename) {
+		*file = strdup(a2l->filename);
+		*line = a2l->line;
+
+		if (*file)
+			ret = 1;
+	}
+
+	addr2line_cleanup(a2l);
+	return ret;
+}
+
+#else /* HAVE_LIBBFD_SUPPORT */
+
 static int addr2line(const char *dso_name, unsigned long addr,
 		     char **file, unsigned int *line_nr)
 {
@@ -53,6 +219,7 @@ static int addr2line(const char *dso_name, unsigned long addr,
 	pclose(fp);
 	return ret;
 }
+#endif /* HAVE_LIBBFD_SUPPORT */
 
 char *get_srcline(struct dso *dso, unsigned long addr)
 {

commit 2cc9d0ef577975abb3ebce7d5978559ec1c73633
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Sep 11 14:09:31 2013 +0900

    perf tools: Save failed result of get_srcline()
    
    Some dso's lack srcline info, so there's no point to keep trying on
    them.  Just save failture status and skip them.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1378876173-13363-8-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index c736d9428cf2..dcff10bed7da 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -58,10 +58,13 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 {
 	char *file;
 	unsigned line;
-	char *srcline = SRCLINE_UNKNOWN;
+	char *srcline;
 	char *dso_name = dso->long_name;
 	size_t size;
 
+	if (!dso->has_srcline)
+		return SRCLINE_UNKNOWN;
+
 	if (dso_name[0] == '[')
 		goto out;
 
@@ -81,8 +84,11 @@ char *get_srcline(struct dso *dso, unsigned long addr)
 		srcline = SRCLINE_UNKNOWN;
 
 	free(file);
-out:
 	return srcline;
+
+out:
+	dso->has_srcline = 0;
+	return SRCLINE_UNKNOWN;
 }
 
 void free_srcline(char *srcline)

commit 86c98cab5a3137376ea7df5ffa5bd52e545fee95
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Sep 11 14:09:30 2013 +0900

    perf annotate: Pass dso instead of dso_name to get_srcline()
    
    This is a preparation of next change.  No functional changes are
    intended.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1378876173-13363-7-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 777f91880cdb..c736d9428cf2 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -4,6 +4,7 @@
 
 #include <linux/kernel.h>
 
+#include "util/dso.h"
 #include "util/util.h"
 #include "util/debug.h"
 
@@ -53,11 +54,12 @@ static int addr2line(const char *dso_name, unsigned long addr,
 	return ret;
 }
 
-char *get_srcline(const char *dso_name, unsigned long addr)
+char *get_srcline(struct dso *dso, unsigned long addr)
 {
 	char *file;
 	unsigned line;
 	char *srcline = SRCLINE_UNKNOWN;
+	char *dso_name = dso->long_name;
 	size_t size;
 
 	if (dso_name[0] == '[')

commit 58d91a0068694a5ba3efc99e88ce6b4b0dd0d085
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Sep 11 14:09:29 2013 +0900

    perf tools: Do not try to call addr2line on non-binary files
    
    No need to call addr2line since they don't have such information.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1378876173-13363-6-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
index 7e92cca6f502..777f91880cdb 100644
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -57,11 +57,17 @@ char *get_srcline(const char *dso_name, unsigned long addr)
 {
 	char *file;
 	unsigned line;
-	char *srcline;
+	char *srcline = SRCLINE_UNKNOWN;
 	size_t size;
 
+	if (dso_name[0] == '[')
+		goto out;
+
+	if (!strncmp(dso_name, "/tmp/perf-", 10))
+		goto out;
+
 	if (!addr2line(dso_name, addr, &file, &line))
-		return SRCLINE_UNKNOWN;
+		goto out;
 
 	/* just calculate actual length */
 	size = snprintf(NULL, 0, "%s:%u", file, line) + 1;
@@ -73,6 +79,7 @@ char *get_srcline(const char *dso_name, unsigned long addr)
 		srcline = SRCLINE_UNKNOWN;
 
 	free(file);
+out:
 	return srcline;
 }
 

commit f048d548f803b57ee1dbf66702f398ba69657450
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Wed Sep 11 14:09:28 2013 +0900

    perf annotate: Factor out get/free_srcline()
    
    Currently external addr2line tool is used for srcline sort key and
    annotate with srcline info.  Separate the common code to prepare
    upcoming enhancements.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1378876173-13363-5-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/srcline.c b/tools/perf/util/srcline.c
new file mode 100644
index 000000000000..7e92cca6f502
--- /dev/null
+++ b/tools/perf/util/srcline.c
@@ -0,0 +1,83 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <linux/kernel.h>
+
+#include "util/util.h"
+#include "util/debug.h"
+
+static int addr2line(const char *dso_name, unsigned long addr,
+		     char **file, unsigned int *line_nr)
+{
+	FILE *fp;
+	char cmd[PATH_MAX];
+	char *filename = NULL;
+	size_t len;
+	char *sep;
+	int ret = 0;
+
+	scnprintf(cmd, sizeof(cmd), "addr2line -e %s %016"PRIx64,
+		  dso_name, addr);
+
+	fp = popen(cmd, "r");
+	if (fp == NULL) {
+		pr_warning("popen failed for %s\n", dso_name);
+		return 0;
+	}
+
+	if (getline(&filename, &len, fp) < 0 || !len) {
+		pr_warning("addr2line has no output for %s\n", dso_name);
+		goto out;
+	}
+
+	sep = strchr(filename, '\n');
+	if (sep)
+		*sep = '\0';
+
+	if (!strcmp(filename, "??:0")) {
+		pr_debug("no debugging info in %s\n", dso_name);
+		free(filename);
+		goto out;
+	}
+
+	sep = strchr(filename, ':');
+	if (sep) {
+		*sep++ = '\0';
+		*file = filename;
+		*line_nr = strtoul(sep, NULL, 0);
+		ret = 1;
+	}
+out:
+	pclose(fp);
+	return ret;
+}
+
+char *get_srcline(const char *dso_name, unsigned long addr)
+{
+	char *file;
+	unsigned line;
+	char *srcline;
+	size_t size;
+
+	if (!addr2line(dso_name, addr, &file, &line))
+		return SRCLINE_UNKNOWN;
+
+	/* just calculate actual length */
+	size = snprintf(NULL, 0, "%s:%u", file, line) + 1;
+
+	srcline = malloc(size);
+	if (srcline)
+		snprintf(srcline, size, "%s:%u", file, line);
+	else
+		srcline = SRCLINE_UNKNOWN;
+
+	free(file);
+	return srcline;
+}
+
+void free_srcline(char *srcline)
+{
+	if (srcline && strcmp(srcline, SRCLINE_UNKNOWN) != 0)
+		free(srcline);
+}
