commit 16b4b4e1a0038365a6734a4f50aba77e57865c8e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 28 15:08:58 2020 +0300

    perf record: Respect --no-switch-events
    
    Context switch events are added automatically by Intel PT and Coresight.
    
    Make it possible to suppress them. That is useful for tracing the
    scheduler without the disturbance that the switch event processing
    creates.
    
    Example:
    
      Prerequisites:
    
        $ which perf
        ~/bin/perf
        $ sudo setcap "cap_sys_rawio,cap_sys_admin,cap_sys_ptrace,cap_syslog,cap_ipc_lock=ep" ~/bin/perf
        $ sudo chmod +r /proc/kcore
    
      Before:
    
        $ perf record --no-switch-events --kcore -a -e intel_pt//k -- sleep 0.001
        [ perf record: Woken up 1 times to write data ]
        [ perf record: Captured and wrote 0.938 MB perf.data ]
        $ perf script -D | grep PERF_RECORD_SWITCH | wc -l
        572
    
      After:
    
        $ perf record --no-switch-events --kcore -a -e intel_pt//k -- sleep 0.001
        Warning:
        Intel Processor Trace decoding will not be possible except for kernel tracing!
        [ perf record: Woken up 1 times to write data ]
        [ perf record: Captured and wrote 0.838 MB perf.data ]
        $ perf script -D | grep PERF_RECORD_SWITCH | wc -l
        0
    
        $ sudo chmod go-r /proc/kcore
        $ sudo setcap -r ~/bin/perf
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: http://lore.kernel.org/lkml/20200528120859.21604-1-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
index 923565c3b155..39d1de4b2a36 100644
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@ -36,6 +36,7 @@ struct record_opts {
 	bool	      record_namespaces;
 	bool	      record_cgroup;
 	bool	      record_switch_events;
+	bool	      record_switch_events_set;
 	bool	      all_kernel;
 	bool	      all_user;
 	bool	      kernel_callchains;
@@ -76,4 +77,9 @@ extern struct option *record_options;
 
 int record__parse_freq(const struct option *opt, const char *str, int unset);
 
+static inline bool record_opts__no_switch_events(const struct record_opts *opts)
+{
+	return opts->record_switch_events_set && !opts->record_switch_events;
+}
+
 #endif // _PERF_RECORD_H

commit d99c22eabee45f40ca44b877a1adde028f14b6b4
Author: Stephane Eranian <eranian@google.com>
Date:   Wed Apr 22 08:50:38 2020 -0700

    perf record: Add num-synthesize-threads option
    
    To control degree of parallelism of the synthesize_mmap() code which
    is scanning /proc/PID/task/PID/maps and can be time consuming.
    Mimic perf top way of handling the option.
    If not specified will default to 1 thread, i.e. default behavior before
    this option.
    
    On a desktop computer the processing of /proc/PID/task/PID/maps isn't
    slow enough to warrant parallel processing and the thread creation has
    some cost - hence the default of 1. On a loaded server with
    >100 cores it is possible to see synthesis times in the order of
    seconds and in this case having the option is desirable.
    
    As the processing is a synchronization point, it is legitimate to worry if
    Amdahl's law will apply to this patch. Profiling with this patch in
    place:
    https://lore.kernel.org/lkml/20200415054050.31645-4-irogers@google.com/
    shows:
    ...
          - 32.59% __perf_event__synthesize_threads
             - 32.54% __event__synthesize_thread
                + 22.13% perf_event__synthesize_mmap_events
                + 6.68% perf_event__get_comm_ids.constprop.0
                + 1.49% process_synthesized_event
                + 1.29% __GI___readdir64
                + 0.60% __opendir
    ...
    That is the processing is 1.49% of execution time and there is plenty to
    make parallel. This is shown in the benchmark in this patch:
    
    https://lore.kernel.org/lkml/20200415054050.31645-2-irogers@google.com/
    
      Computing performance of multi threaded perf event synthesis by
      synthesizing events on CPU 0:
       Number of synthesis threads: 1
         Average synthesis took: 127729.000 usec (+- 3372.880 usec)
         Average num. events: 21548.600 (+- 0.306)
         Average time per event 5.927 usec
       Number of synthesis threads: 2
         Average synthesis took: 88863.500 usec (+- 385.168 usec)
         Average num. events: 21552.800 (+- 0.327)
         Average time per event 4.123 usec
       Number of synthesis threads: 3
         Average synthesis took: 83257.400 usec (+- 348.617 usec)
         Average num. events: 21553.200 (+- 0.327)
         Average time per event 3.863 usec
       Number of synthesis threads: 4
         Average synthesis took: 75093.000 usec (+- 422.978 usec)
         Average num. events: 21554.200 (+- 0.200)
         Average time per event 3.484 usec
       Number of synthesis threads: 5
         Average synthesis took: 64896.600 usec (+- 353.348 usec)
         Average num. events: 21558.000 (+- 0.000)
         Average time per event 3.010 usec
       Number of synthesis threads: 6
         Average synthesis took: 59210.200 usec (+- 342.890 usec)
         Average num. events: 21560.000 (+- 0.000)
         Average time per event 2.746 usec
       Number of synthesis threads: 7
         Average synthesis took: 54093.900 usec (+- 306.247 usec)
         Average num. events: 21562.000 (+- 0.000)
         Average time per event 2.509 usec
       Number of synthesis threads: 8
         Average synthesis took: 48938.700 usec (+- 341.732 usec)
         Average num. events: 21564.000 (+- 0.000)
         Average time per event 2.269 usec
    
    Where average time per synthesized event goes from 5.927 usec with 1
    thread to 2.269 usec with 8. This isn't a linear speed up as not all of
    synthesize code has been made parallel. If the synthesis time was about
    10 seconds then using 8 threads may bring this down to less than 4.
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Reviewed-by: Ian Rogers <irogers@google.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Jones <tonyj@suse.de>
    Cc: yuzhoujian <yuzhoujian@didichuxing.com>
    Link: http://lore.kernel.org/lkml/20200422155038.9380-1-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
index 24316458be20..923565c3b155 100644
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@ -68,6 +68,7 @@ struct record_opts {
 	int	      affinity;
 	int	      mmap_flush;
 	unsigned int  comp_level;
+	unsigned int  nr_threads_synthesize;
 };
 
 extern const char * const *record_usage;

commit 8fb4b67939e169fca68174e9ac7be79fe9a04498
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Wed Mar 25 21:45:34 2020 +0900

    perf record: Add --all-cgroups option
    
    The --all-cgroups option is to enable cgroup profiling support.  It
    tells kernel to record CGROUP events in the ring buffer so that perf
    report can identify task/cgroup association later.
    
      [root@seventh ~]# perf record --all-cgroups --namespaces /wb/cgtest
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.042 MB perf.data (558 samples) ]
      [root@seventh ~]# perf report --stdio -s cgroup_id,cgroup,pid
      # To display the perf.data header info, please use --header/--header-only options.
      #
      #
      # Total Lost Samples: 0
      #
      # Samples: 558  of event 'cycles'
      # Event count (approx.): 458017341
      #
      # Overhead  cgroup id (dev/inode)  Cgroup          Pid:Command
      # ........  .....................  ..........  ...............
      #
          33.15%  4/0xeffffffb           /sub           9615:looper0
          32.83%  4/0xf00002f5           /sub/cgrp2     9620:looper2
          32.79%  4/0xf00002f4           /sub/cgrp1     9619:looper1
           0.35%  4/0xf00002f5           /sub/cgrp2     9618:cgtest
           0.34%  4/0xf00002f4           /sub/cgrp1     9617:cgtest
           0.32%  4/0xeffffffb           /              9615:looper0
           0.11%  4/0xeffffffb           /sub           9617:cgtest
           0.10%  4/0xeffffffb           /sub           9618:cgtest
    
      #
      # (Tip: Sample related events with: perf record -e '{cycles,instructions}:S')
      #
      [root@seventh ~]#
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200325124536.2800725-8-namhyung@kernel.org
    Link: http://lore.kernel.org/lkml/20200402015249.3800462-1-namhyung@kernel.org
    [ Extracted the HAVE_FILE_HANDLE from the followup patch ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
index 5421fd2ad383..24316458be20 100644
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@ -34,6 +34,7 @@ struct record_opts {
 	bool	      auxtrace_snapshot_on_exit;
 	bool	      auxtrace_sample_mode;
 	bool	      record_namespaces;
+	bool	      record_cgroup;
 	bool	      record_switch_events;
 	bool	      all_kernel;
 	bool	      all_user;

commit f0bb7ee8530a07d3c23bd2e06984796e66cfbcf1
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Nov 15 14:42:15 2019 +0200

    perf auxtrace: Add support for AUX area sample recording
    
    Add support for parsing and validating AUX area sample options. At
    present, the only option is the sample size, but it is also necessary to
    ensure that events are in a group with an AUX area event as the leader.
    
    Committer note:
    
    Add missing 'static inline' in front of auxtrace_parse_sample_options()
    for when we don't HAVE_AUXTRACE_SUPPORT.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lore.kernel.org/lkml/20191115124225.5247-6-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
index 948bbcf9aef3..5421fd2ad383 100644
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@ -32,6 +32,7 @@ struct record_opts {
 	bool	      full_auxtrace;
 	bool	      auxtrace_snapshot_mode;
 	bool	      auxtrace_snapshot_on_exit;
+	bool	      auxtrace_sample_mode;
 	bool	      record_namespaces;
 	bool	      record_switch_events;
 	bool	      all_kernel;
@@ -56,6 +57,7 @@ struct record_opts {
 	u64	      user_interval;
 	size_t	      auxtrace_snapshot_size;
 	const char    *auxtrace_snapshot_opts;
+	const char    *auxtrace_sample_opts;
 	bool	      sample_transaction;
 	unsigned      initial_delay;
 	bool	      use_clockid;

commit eeb399b531a1576e36016f8a7f0c50d10194e190
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Oct 4 11:31:21 2019 +0300

    perf record: Put a copy of kcore into the perf.data directory
    
    Add a new 'perf record' option '--kcore' which will put a copy of
    /proc/kcore, kallsyms and modules into a perf.data directory. Note, that
    without the --kcore option, output goes to a file as previously.  The
    tools' -o and -i options work with either a file name or directory name.
    
    Example:
    
      $ sudo perf record --kcore uname
    
      $ sudo tree perf.data
      perf.data
      ├── kcore_dir
      │   ├── kallsyms
      │   ├── kcore
      │   └── modules
      └── data
    
      $ sudo perf script -v
      build id event received for vmlinux: 1eaa285996affce2d74d8e66dcea09a80c9941de
      build id event received for [vdso]: 8bbaf5dc62a9b644b4d4e4539737e104e4a84541
      Samples for 'cycles' event do not have CPU attribute set. Skipping 'cpu' field.
      Using CPUID GenuineIntel-6-8E-A
      Using perf.data/kcore_dir/kcore for kernel data
      Using perf.data/kcore_dir/kallsyms for symbols
                 perf 19058 506778.423729:          1 cycles:  ffffffffa2caa548 native_write_msr+0x8 (vmlinux)
                 perf 19058 506778.423733:          1 cycles:  ffffffffa2caa548 native_write_msr+0x8 (vmlinux)
                 perf 19058 506778.423734:          7 cycles:  ffffffffa2caa548 native_write_msr+0x8 (vmlinux)
                 perf 19058 506778.423736:        117 cycles:  ffffffffa2caa54a native_write_msr+0xa (vmlinux)
                 perf 19058 506778.423738:       2092 cycles:  ffffffffa2c9b7b0 native_apic_msr_write+0x0 (vmlinux)
                 perf 19058 506778.423740:      37380 cycles:  ffffffffa2f121d0 perf_event_addr_filters_exec+0x0 (vmlinux)
                uname 19058 506778.423751:     582673 cycles:  ffffffffa303a407 propagate_protected_usage+0x147 (vmlinux)
                uname 19058 506778.423892:    2241841 cycles:  ffffffffa2cae0c9 unwind_next_frame.part.5+0x79 (vmlinux)
                uname 19058 506778.424430:    2457397 cycles:  ffffffffa3019232 check_memory_region+0x52 (vmlinux)
    
    Committer testing:
    
      # rm -rf perf.data*
      # perf record sleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.024 MB perf.data (7 samples) ]
      # ls -l perf.data
      -rw-------. 1 root root 34772 Oct 21 11:08 perf.data
      # perf record --kcore uname
      Linux
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.024 MB perf.data (7 samples) ]
      ls[root@quaco ~]# ls -lad perf.data*
      drwx------. 3 root root  4096 Oct 21 11:08 perf.data
      -rw-------. 1 root root 34772 Oct 21 11:08 perf.data.old
      # perf evlist -v
      cycles: size: 112, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|PERIOD, read_format: ID, disabled: 1, inherit: 1, mmap: 1, comm: 1, freq: 1, enable_on_exec: 1, task: 1, precise_ip: 3, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, ksymbol: 1, bpf_event: 1
      # perf evlist -v -i perf.data/data
      cycles: size: 112, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|PERIOD, read_format: ID, disabled: 1, inherit: 1, mmap: 1, comm: 1, freq: 1, enable_on_exec: 1, task: 1, precise_ip: 3, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, ksymbol: 1, bpf_event: 1
      #
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Link: http://lore.kernel.org/lkml/20191004083121.12182-6-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
index 00275afc524d..948bbcf9aef3 100644
--- a/tools/perf/util/record.h
+++ b/tools/perf/util/record.h
@@ -44,6 +44,7 @@ struct record_opts {
 	bool	      strict_freq;
 	bool	      sample_id;
 	bool	      no_bpf_event;
+	bool	      kcore;
 	unsigned int  freq;
 	unsigned int  mmap_pages;
 	unsigned int  auxtrace_mmap_pages;

commit aeb00b1aeab6dadd72c24f93bea51a46e109c2ba
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 22 15:40:29 2019 -0300

    perf record: Move record_opts and other record decls out of perf.h
    
    And into a separate util/record.h, to better isolate things and make
    sure that those who use record_opts and the other moved declarations
    are explicitly including the necessary header.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-31q8mei1qkh74qvkl9nwidfq@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/record.h b/tools/perf/util/record.h
new file mode 100644
index 000000000000..00275afc524d
--- /dev/null
+++ b/tools/perf/util/record.h
@@ -0,0 +1,74 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _PERF_RECORD_H
+#define _PERF_RECORD_H
+
+#include <time.h>
+#include <stdbool.h>
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/perf_event.h>
+#include "util/target.h"
+
+struct option;
+
+struct record_opts {
+	struct target target;
+	bool	      group;
+	bool	      inherit_stat;
+	bool	      no_buffering;
+	bool	      no_inherit;
+	bool	      no_inherit_set;
+	bool	      no_samples;
+	bool	      raw_samples;
+	bool	      sample_address;
+	bool	      sample_phys_addr;
+	bool	      sample_weight;
+	bool	      sample_time;
+	bool	      sample_time_set;
+	bool	      sample_cpu;
+	bool	      period;
+	bool	      period_set;
+	bool	      running_time;
+	bool	      full_auxtrace;
+	bool	      auxtrace_snapshot_mode;
+	bool	      auxtrace_snapshot_on_exit;
+	bool	      record_namespaces;
+	bool	      record_switch_events;
+	bool	      all_kernel;
+	bool	      all_user;
+	bool	      kernel_callchains;
+	bool	      user_callchains;
+	bool	      tail_synthesize;
+	bool	      overwrite;
+	bool	      ignore_missing_thread;
+	bool	      strict_freq;
+	bool	      sample_id;
+	bool	      no_bpf_event;
+	unsigned int  freq;
+	unsigned int  mmap_pages;
+	unsigned int  auxtrace_mmap_pages;
+	unsigned int  user_freq;
+	u64	      branch_stack;
+	u64	      sample_intr_regs;
+	u64	      sample_user_regs;
+	u64	      default_interval;
+	u64	      user_interval;
+	size_t	      auxtrace_snapshot_size;
+	const char    *auxtrace_snapshot_opts;
+	bool	      sample_transaction;
+	unsigned      initial_delay;
+	bool	      use_clockid;
+	clockid_t     clockid;
+	u64	      clockid_res_ns;
+	int	      nr_cblocks;
+	int	      affinity;
+	int	      mmap_flush;
+	unsigned int  comp_level;
+};
+
+extern const char * const *record_usage;
+extern struct option *record_options;
+
+int record__parse_freq(const struct option *opt, const char *str, int unset);
+
+#endif // _PERF_RECORD_H
