commit 0d71a2b242b36732d31323d74809f6c8b25e18da
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Thu May 7 11:50:23 2020 +0200

    perf callchain: Setup callchain properly in pipe mode
    
    Callchains are automatically initialized by checking on event's
    sample_type. For pipe mode we need to put this check into attr event
    code.
    
    Moving the callchains setup code into callchain_param_setup function and
    calling it from attr event process code.
    
    This enables pipe output having callchains, like:
    
      # perf record -g -e 'raw_syscalls:sys_enter' true | perf script
      # perf record -g -e 'raw_syscalls:sys_enter' true | perf report
    
    Committer notes:
    
    We still need the next patch for the above output to work.
    
    Reported-by: Paul Khuong <pvk@pvk.ca>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Ian Rogers <irogers@google.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lore.kernel.org/lkml/20200507095024.2789147-5-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8f668ee29f25..fe36a9e5ccd1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -297,4 +297,5 @@ int callchain_branch_counts(struct callchain_root *root,
 			    u64 *branch_count, u64 *predicted_count,
 			    u64 *abort_count, u64 *cycles_count);
 
+void callchain_param_setup(u64 sample_type);
 #endif	/* __PERF_CALLCHAIN_H */

commit ff165628d72644e37674c5485658e8bd9f4a348b
Author: Kan Liang <kan.liang@linux.intel.com>
Date:   Thu Mar 19 13:25:12 2020 -0700

    perf callchain: Stitch LBR call stack
    
    In LBR call stack mode, the depth of reconstructed LBR call stack limits
    to the number of LBR registers.
    
      For example, on skylake, the depth of reconstructed LBR call stack is
      always <= 32.
    
      # To display the perf.data header info, please use
      # --header/--header-only options.
      #
      #
      # Total Lost Samples: 0
      #
      # Samples: 6K of event 'cycles'
      # Event count (approx.): 6487119731
      #
      # Children      Self  Command          Shared Object       Symbol
      # ........  ........  ...............  ..................
      # ................................
    
        99.97%    99.97%  tchain_edit      tchain_edit        [.] f43
                |
                 --99.64%--f11
                           f12
                           f13
                           f14
                           f15
                           f16
                           f17
                           f18
                           f19
                           f20
                           f21
                           f22
                           f23
                           f24
                           f25
                           f26
                           f27
                           f28
                           f29
                           f30
                           f31
                           f32
                           f33
                           f34
                           f35
                           f36
                           f37
                           f38
                           f39
                           f40
                           f41
                           f42
                           f43
    
    For a call stack which is deeper than LBR limit, HW will overwrite the
    LBR register with oldest branch. Only partial call stacks can be
    reconstructed.
    
    However, the overwritten LBRs may still be retrieved from previous
    sample. At that moment, HW hasn't overwritten the LBR registers yet.
    Perf tools can stitch those overwritten LBRs on current call stacks to
    get a more complete call stack.
    
    To determine if LBRs can be stitched, perf tools need to compare current
    sample with previous sample.
    
    - They should have identical LBR records (Same from, to and flags
      values, and the same physical index of LBR registers).
    
    - The searching starts from the base-of-stack of current sample.
    
    Once perf determines to stitch the previous LBRs, the corresponding LBR
    cursor nodes will be copied to 'lists'.  The 'lists' is to track the LBR
    cursor nodes which are going to be stitched.
    
    When the stitching is over, the nodes will not be freed immediately.
    They will be moved to 'free_lists'. Next stitching may reuse the space.
    Both 'lists' and 'free_lists' will be freed when all samples are
    processed.
    
    Committer notes:
    
    Fix the intel-pt.c initialization of the union with 'struct
    branch_flags', that breaks the build with its unnamed union on older gcc
    versions.
    
    Uninline thread__free_stitch_list(), as it grew big and started dragging
    includes to thread.h, so move it to thread.c where what it needs in
    terms of headers are already there.
    
    This fixes the build in several systems such as debian:experimental when
    cross building to the MIPS32 architecture, i.e. in the other cases what
    was needed was being included by sheer luck.
    
      In file included from builtin-sched.c:11:
      util/thread.h: In function 'thread__free_stitch_list':
      util/thread.h:169:3: error: implicit declaration of function 'free' [-Werror=implicit-function-declaration]
        169 |   free(pos);
            |   ^~~~
      util/thread.h:169:3: error: incompatible implicit declaration of built-in function 'free' [-Werror]
      util/thread.h:19:1: note: include '<stdlib.h>' or provide a declaration of 'free'
         18 | #include "callchain.h"
        +++ |+#include <stdlib.h>
         19 |
      util/thread.h:174:3: error: incompatible implicit declaration of built-in function 'free' [-Werror]
        174 |   free(pos);
            |   ^~~~
      util/thread.h:174:3: note: include '<stdlib.h>' or provide a declaration of 'free'
    
    Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Pavel Gerasimov <pavel.gerasimov@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Vitaly Slobodskoy <vitaly.slobodskoy@intel.com>
    Link: http://lore.kernel.org/lkml/20200319202517.23423-13-kan.liang@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index cb33cd42ff43..8f668ee29f25 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -154,6 +154,11 @@ struct callchain_cursor_node {
 	struct callchain_cursor_node	*next;
 };
 
+struct stitch_list {
+	struct list_head		node;
+	struct callchain_cursor_node	cursor;
+};
+
 struct callchain_cursor {
 	u64				nr;
 	struct callchain_cursor_node	*first;

commit 7f1d39317c071268b4204175df7cfbb2187acb72
Author: Kan Liang <kan.liang@linux.intel.com>
Date:   Thu Mar 19 13:25:11 2020 -0700

    perf callchain: Save previous cursor nodes for LBR stitching approach
    
    The cursor nodes which generates from sample are eventually added into
    callchain. To avoid generating cursor nodes from previous samples again,
    the previous cursor nodes are also saved for LBR stitching approach.
    
    Some option, e.g. hide-unresolved, may hide some LBRs.  Add a variable
    'valid' in struct callchain_cursor_node to indicate this case. The LBR
    stitching approach will only append the valid cursor nodes from previous
    samples later.
    
    Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Pavel Gerasimov <pavel.gerasimov@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Vitaly Slobodskoy <vitaly.slobodskoy@intel.com>
    Link: http://lore.kernel.org/lkml/20200319202517.23423-12-kan.liang@linux.intel.com
    [ Use zfree() instead of open coded equivalent, and use it when freeing members of structs ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 706bb7bbe1e1..cb33cd42ff43 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -143,6 +143,9 @@ struct callchain_cursor_node {
 	u64				ip;
 	struct map_symbol		ms;
 	const char			*srcline;
+	/* Indicate valid cursor node for LBR stitch */
+	bool				valid;
+
 	bool				branch;
 	struct branch_flags		branch_flags;
 	u64				branch_from;

commit 5f0fef8ac3e7a5707751493293ba8ff2ffc0f8a4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 12:14:32 2019 -0300

    perf callchain: Use 'struct map_symbol' in 'struct callchain_cursor_node'
    
    To ease passing around map+symbol, just like done for other parts of the
    tree recently.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 83398e5bbe4b..706bb7bbe1e1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -141,8 +141,7 @@ struct callchain_list {
  */
 struct callchain_cursor_node {
 	u64				ip;
-	struct map			*map;
-	struct symbol			*sym;
+	struct map_symbol		ms;
 	const char			*srcline;
 	bool				branch;
 	struct branch_flags		branch_flags;
@@ -195,7 +194,7 @@ int callchain_merge(struct callchain_cursor *cursor,
 void callchain_cursor_reset(struct callchain_cursor *cursor);
 
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
-			    struct map *map, struct symbol *sym,
+			    struct map_symbol *ms,
 			    bool branch, struct branch_flags *flags,
 			    int nr_loop_iter, u64 iter_cycles, u64 branch_from,
 			    const char *srcline);

commit 9c9e754fb804828473c5131bb3e7df78bde396e6
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Sep 10 17:24:07 2019 +0100

    perf callchain: Remove needless event.h include
    
    All we need is a bunch of struct forward declarations and then add
    event.h to the only place that was getting it indirectly via
    callchain.h.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-qq2xhyuxcvx5vmxha9otjd8d@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index b042ceef4114..83398e5bbe4b 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -4,12 +4,15 @@
 
 #include <linux/list.h>
 #include <linux/rbtree.h>
-#include "event.h"
 #include "map_symbol.h"
 #include "branch.h"
 
+struct addr_location;
 struct evsel;
+struct ip_callchain;
 struct map;
+struct perf_sample;
+struct thread;
 
 #define HELP_PAD "\t\t\t\t"
 

commit 4cb3c6d546aa5493a960d05eb73bad8e69a58574
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 29 17:19:02 2019 -0300

    perf event: Remove needless include directives from event.h
    
    bpf.h and build-id.h are not needed at all in event.h, remove them.
    
    And fixup the fallout of files that were getting needed stuff from this
    now pruned include.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-rdm3dgtlrndmmnlc4bafsg3b@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 45b9ed49e2b1..b042ceef4114 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -8,6 +8,7 @@
 #include "map_symbol.h"
 #include "branch.h"
 
+struct evsel;
 struct map;
 
 #define HELP_PAD "\t\t\t\t"

commit 32dcd021d004038ca12ac17319da5aa4756e9312
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Sun Jul 21 13:23:51 2019 +0200

    perf evsel: Rename struct perf_evsel to struct evsel
    
    Rename struct perf_evsel to struct evsel, so we don't have a name clash
    when we add struct perf_evsel in libperf.
    
    Committer notes:
    
    Added fixes for arm64, provided by Jiri.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20190721112506.12306-5-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 80e056a3d882..45b9ed49e2b1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -236,7 +236,7 @@ int record_opts__parse_callchain(struct record_opts *record,
 
 int sample__resolve_callchain(struct perf_sample *sample,
 			      struct callchain_cursor *cursor, struct symbol **parent,
-			      struct perf_evsel *evsel, struct addr_location *al,
+			      struct evsel *evsel, struct addr_location *al,
 			      int max_stack);
 int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);
 int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *node,

commit 9f4e8ff27a807dd6919faa0ecb2a152c57cfa5b2
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Jan 27 12:02:41 2019 +0100

    perf symbols: Introduce map_symbol.h
    
    To allow headers just wanting this definition to be able to get it
    without all the things in symbol.h, to reduce the include dep tree.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-l32z2qyhs6fe8unf4gk2ead2@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index b6f18c2d4b14..80e056a3d882 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -5,7 +5,7 @@
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include "event.h"
-#include "symbol.h"
+#include "map_symbol.h"
 #include "branch.h"
 
 struct map;

commit 7b644f9ad18f74aeac42360bee9c4c1cf874f4c0
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Jan 27 11:55:39 2019 +0100

    perf callchain: Uninline callchain_cursor_reset() to remove map.h dependency
    
    That was the only thing that made including map.h in callchain.h a
    requiriment, so uninline it and just add a 'struct map' forward
    declaration.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-7fjz4hvv1bpzqaeriku44fn4@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8afe1622edf3..b6f18c2d4b14 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -5,10 +5,11 @@
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include "event.h"
-#include "map.h"
 #include "symbol.h"
 #include "branch.h"
 
+struct map;
+
 #define HELP_PAD "\t\t\t\t"
 
 #define CALLCHAIN_HELP "setup and enables call-graph (stack chain/backtrace):\n\n"
@@ -187,20 +188,7 @@ int callchain_append(struct callchain_root *root,
 int callchain_merge(struct callchain_cursor *cursor,
 		    struct callchain_root *dst, struct callchain_root *src);
 
-/*
- * Initialize a cursor before adding entries inside, but keep
- * the previously allocated entries as a cache.
- */
-static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
-{
-	struct callchain_cursor_node *node;
-
-	cursor->nr = 0;
-	cursor->last = &cursor->first;
-
-	for (node = cursor->first; node != NULL; node = node->next)
-		map__zput(node->map);
-}
+void callchain_cursor_reset(struct callchain_cursor *cursor);
 
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
 			    struct map *map, struct symbol *sym,

commit 95420d338e2d802ea0dce4d770d3292beb587f71
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Jan 22 11:32:41 2019 -0200

    perf callchain: No need to include perf.h
    
    So ditch it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-bodhwdvcds9ahk26dy4w8m71@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 99d38ac019b8..8afe1622edf3 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -2,7 +2,6 @@
 #ifndef __PERF_CALLCHAIN_H
 #define __PERF_CALLCHAIN_H
 
-#include "../perf.h"
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include "event.h"

commit a3366db06bb656cef2e03f30f780d93059bcc594
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Fri Jan 4 14:10:30 2019 +0800

    perf report: Fix wrong iteration count in --branch-history
    
    By calculating the removed loops, we can get the iteration count.
    
    But the iteration count could be reported incorrectly, reporting
    impossibly high counts.
    
    That's because previous code uses the number of removed LBR entries for
    the iteration count. That's not good. Fix this by increasing the
    iteration count when a loop is detected.
    
    When matching the chain, the iteration count would be added up, finally we need
    to compute the average value when printing out.
    
    For example,
    
      $ perf report --branch-history --stdio --no-children
    
    Before:
    
      ---f2 +0
         |
         |--33.62%--f1 +9 (cycles:1)
         |          f1 +0
         |          main +22 (cycles:1)
         |          main +17
         |          main +38 (cycles:1)
         |          main +27
         |          f1 +26 (cycles:1)
         |          f1 +24
         |          f2 +27 (cycles:7)
         |          f2 +0
         |          f1 +19 (cycles:1)
         |          f1 +14
         |          f2 +27 (cycles:11)
         |          f2 +0
         |          f1 +9 (cycles:1 iter:2968 avg_cycles:3)
         |          f1 +0
         |          main +22 (cycles:1 iter:2968 avg_cycles:3)
         |          main +17
         |          main +38 (cycles:1 iter:2968 avg_cycles:3)
    
    2968 is an impossible high iteration count and avg_cycles is too small.
    
    After:
    
      ---f2 +0
         |
         |--33.62%--f1 +9 (cycles:1)
         |          f1 +0
         |          main +22 (cycles:1)
         |          main +17
         |          main +38 (cycles:1)
         |          main +27
         |          f1 +26 (cycles:1)
         |          f1 +24
         |          f2 +27 (cycles:7)
         |          f2 +0
         |          f1 +19 (cycles:1)
         |          f1 +14
         |          f2 +27 (cycles:11)
         |          f2 +0
         |          f1 +9 (cycles:1 iter:1 avg_cycles:23)
         |          f1 +0
         |          main +22 (cycles:1 iter:1 avg_cycles:23)
         |          main +17
         |          main +38 (cycles:1 iter:1 avg_cycles:23)
    
    avg_cycles:23 is the average cycles of this iteration.
    
    Fixes: c4ee06251d42 ("perf report: Calculate the average cycles of iterations")
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1546582230-17507-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 154560b1eb65..99d38ac019b8 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -118,6 +118,7 @@ struct callchain_list {
 		bool		has_children;
 	};
 	u64			branch_count;
+	u64			from_count;
 	u64			predicted_count;
 	u64			abort_count;
 	u64			cycles_count;

commit eabad8c6856f185f876b54c426c2cc69fe0f0a7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Jan 15 16:48:46 2018 -0300

    perf unwind: Do not look just at the global callchain_param.record_mode
    
    When setting up DWARF callchains on specific events, without using
    'record' or 'trace' --call-graph, but instead doing it like:
    
            perf trace -e cycles/call-graph=dwarf/
    
    The unwind__prepare_access() call in thread__insert_map() when we
    process PERF_RECORD_MMAP(2) metadata events were not being performed,
    precluding us from using per-event DWARF callchains, handling them just
    when we asked for all events to be DWARF, using "--call-graph dwarf".
    
    We do it in the PERF_RECORD_MMAP because we have to look at one of the
    executable maps to figure out the executable type (64-bit, 32-bit) of
    the DSO laid out in that mmap. Also to look at the architecture where
    the perf.data file was recorded.
    
    All this probably should be deferred to when we process a sample for
    some thread that has callchains, so that we do this processing only for
    the threads with samples, not for all of them.
    
    For now, fix using DWARF on specific events.
    
    Before:
    
      # perf trace --no-syscalls -e probe_libc:inet_pton/call-graph=dwarf/ ping -6 -c 1 ::1
      PING ::1(::1) 56 data bytes
      64 bytes from ::1: icmp_seq=1 ttl=64 time=0.048 ms
    
      --- ::1 ping statistics ---
      1 packets transmitted, 1 received, 0% packet loss, time 0ms
      rtt min/avg/max/mdev = 0.048/0.048/0.048/0.000 ms
         0.000 probe_libc:inet_pton:(7fe9597bb350))
      Problem processing probe_libc:inet_pton callchain, skipping...
      #
    
    After:
    
      # perf trace --no-syscalls -e probe_libc:inet_pton/call-graph=dwarf/ ping -6 -c 1 ::1
      PING ::1(::1) 56 data bytes
      64 bytes from ::1: icmp_seq=1 ttl=64 time=0.060 ms
    
      --- ::1 ping statistics ---
      1 packets transmitted, 1 received, 0% packet loss, time 0ms
      rtt min/avg/max/mdev = 0.060/0.060/0.060/0.000 ms
           0.000 probe_libc:inet_pton:(7fd4aa930350))
                                             __inet_pton (inlined)
                                             gaih_inet.constprop.7 (/usr/lib64/libc-2.26.so)
                                             __GI_getaddrinfo (inlined)
                                             [0xffffaa804e51af3f] (/usr/bin/ping)
                                             __libc_start_main (/usr/lib64/libc-2.26.so)
                                             [0xffffaa804e51b379] (/usr/bin/ping)
      #
      # perf trace --call-graph=dwarf --no-syscalls -e probe_libc:inet_pton/call-graph=dwarf/ ping -6 -c 1 ::1
      PING ::1(::1) 56 data bytes
      64 bytes from ::1: icmp_seq=1 ttl=64 time=0.057 ms
    
      --- ::1 ping statistics ---
      1 packets transmitted, 1 received, 0% packet loss, time 0ms
      rtt min/avg/max/mdev = 0.057/0.057/0.057/0.000 ms
           0.000 probe_libc:inet_pton:(7f9363b9e350))
                                             __inet_pton (inlined)
                                             gaih_inet.constprop.7 (/usr/lib64/libc-2.26.so)
                                             __GI_getaddrinfo (inlined)
                                             [0xffffa9e8a14e0f3f] (/usr/bin/ping)
                                             __libc_start_main (/usr/lib64/libc-2.26.so)
                                             [0xffffa9e8a14e1379] (/usr/bin/ping)
      #
      # perf trace --call-graph=fp --no-syscalls -e probe_libc:inet_pton/call-graph=dwarf/ ping -6 -c 1 ::1
      PING ::1(::1) 56 data bytes
      64 bytes from ::1: icmp_seq=1 ttl=64 time=0.077 ms
    
      --- ::1 ping statistics ---
      1 packets transmitted, 1 received, 0% packet loss, time 0ms
      rtt min/avg/max/mdev = 0.077/0.077/0.077/0.000 ms
           0.000 probe_libc:inet_pton:(7f4947e1c350))
                                             __inet_pton (inlined)
                                             gaih_inet.constprop.7 (/usr/lib64/libc-2.26.so)
                                             __GI_getaddrinfo (inlined)
                                             [0xffffaa716d88ef3f] (/usr/bin/ping)
                                             __libc_start_main (/usr/lib64/libc-2.26.so)
                                             [0xffffaa716d88f379] (/usr/bin/ping)
      #
      # perf trace --no-syscalls -e probe_libc:inet_pton/call-graph=fp/ ping -6 -c 1 ::1
      PING ::1(::1) 56 data bytes
      64 bytes from ::1: icmp_seq=1 ttl=64 time=0.078 ms
    
      --- ::1 ping statistics ---
      1 packets transmitted, 1 received, 0% packet loss, time 0ms
      rtt min/avg/max/mdev = 0.078/0.078/0.078/0.000 ms
           0.000 probe_libc:inet_pton:(7fa157696350))
                                             __GI___inet_pton (/usr/lib64/libc-2.26.so)
                                             getaddrinfo (/usr/lib64/libc-2.26.so)
                                             [0xffffa9ba39c74f40] (/usr/bin/ping)
      #
    
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Hendrick Brueckner <brueckner@linux.vnet.ibm.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Thomas Richter <tmricht@linux.vnet.ibm.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/r/20180116182650.GE16107@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index b79ef2478a57..154560b1eb65 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -89,6 +89,8 @@ enum chain_value {
 	CCVAL_COUNT,
 };
 
+extern bool dwarf_callchain_users;
+
 struct callchain_param {
 	bool			enabled;
 	enum perf_call_graph_mode record_mode;

commit 15bcdc9477b03eb035052412c3a087e11e855e76
Merge: 340b5319c98e e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:30:18 2017 +0100

    Merge branch 'linus' into perf/core, to fix conflicts
    
    Conflicts:
            tools/perf/arch/arm/annotate/instructions.c
            tools/perf/arch/arm64/annotate/instructions.c
            tools/perf/arch/powerpc/annotate/instructions.c
            tools/perf/arch/s390/annotate/instructions.c
            tools/perf/arch/x86/tests/intel-cqm.c
            tools/perf/ui/tui/progress.c
            tools/perf/util/zlib.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1ed6fc61d0a5..f967aa47d0a1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __PERF_CALLCHAIN_H
 #define __PERF_CALLCHAIN_H
 

commit 40a342cda2cd9bc8f7bf81c5ce1a141584760757
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 9 22:32:56 2017 +0200

    perf callchain: Store srcline in callchain_cursor_node
    
    This is mostly a preparation to enable the creation of full callchain
    nodes for inline frames. Such frames will reference the IP of the
    non-inlined frame, but hold the symbol and srcline for an inlined
    location. As such, we won't be able to query the srcline on-demand based
    on the IP alone. Instead, we will leverage the functionality provided by
    this patch here, and store the srcline for the inlined nodes in the new
    srcline member of callchain_cursor_node.
    
    Note that this patch on its own leaks the srcline, as there is no
    free_callchain_cursor_node or similar. A future patch will add caching
    of the srcline and handle deletion properly.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20171009203310.17362-3-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1ed6fc61d0a5..8f67b681cde9 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -121,7 +121,7 @@ struct callchain_list {
 	u64			iter_count;
 	u64			iter_cycles;
 	struct branch_type_stat brtype_stat;
-	char		       *srcline;
+	const char		*srcline;
 	struct list_head	list;
 };
 
@@ -135,6 +135,7 @@ struct callchain_cursor_node {
 	u64				ip;
 	struct map			*map;
 	struct symbol			*sym;
+	const char			*srcline;
 	bool				branch;
 	struct branch_flags		branch_flags;
 	u64				branch_from;
@@ -201,7 +202,8 @@ static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
 			    struct map *map, struct symbol *sym,
 			    bool branch, struct branch_flags *flags,
-			    int nr_loop_iter, u64 iter_cycles, u64 branch_from);
+			    int nr_loop_iter, u64 iter_cycles, u64 branch_from,
+			    const char *srcline);
 
 /* Close a cursor writing session. Initialize for the reader */
 static inline void callchain_cursor_commit(struct callchain_cursor *cursor)

commit c4ee06251d4212a0d55e2371f2db464f6a1e0901
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Mon Aug 7 21:05:15 2017 +0800

    perf report: Calculate the average cycles of iterations
    
    The branch history code has a loop detection function. With this, we can
    get the number of iterations by calculating the removed loops.
    
    While it would be nice for knowing the average cycles of iterations.
    This patch adds up the cycles in branch entries of removed loops and
    save the result to the next branch entry (e.g. branch entry A).
    
    Finally it will display the iteration number and average cycles at the
    "from" of branch entry A.
    
    For example:
    perf record -g -j any,save_type ./div
    perf report --branch-history --no-children --stdio
    
    --22.63%--main div.c:42 (RET CROSS_2M)
              compute_flag div.c:28 (cycles:2 iter:173115 avg_cycles:2)
              |
               --10.73%--compute_flag div.c:27 (RET CROSS_2M)
                         rand rand.c:28 (cycles:1)
                         rand rand.c:28 (RET CROSS_2M)
                         __random random.c:298 (cycles:1)
                         __random random.c:297 (COND_BWD CROSS_2M)
                         __random random.c:295 (cycles:1)
                         __random random.c:295 (COND_BWD CROSS_2M)
                         __random random.c:295 (cycles:1)
                         __random random.c:295 (RET CROSS_2M)
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1502111115-18305-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 97738201464a..1ed6fc61d0a5 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -119,7 +119,7 @@ struct callchain_list {
 	u64			abort_count;
 	u64			cycles_count;
 	u64			iter_count;
-	u64			samples_count;
+	u64			iter_cycles;
 	struct branch_type_stat brtype_stat;
 	char		       *srcline;
 	struct list_head	list;
@@ -139,7 +139,7 @@ struct callchain_cursor_node {
 	struct branch_flags		branch_flags;
 	u64				branch_from;
 	int				nr_loop_iter;
-	int				samples;
+	u64				iter_cycles;
 	struct callchain_cursor_node	*next;
 };
 
@@ -201,7 +201,7 @@ static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
 			    struct map *map, struct symbol *sym,
 			    bool branch, struct branch_flags *flags,
-			    int nr_loop_iter, int samples, u64 branch_from);
+			    int nr_loop_iter, u64 iter_cycles, u64 branch_from);
 
 /* Close a cursor writing session. Initialize for the reader */
 static inline void callchain_cursor_commit(struct callchain_cursor *cursor)
@@ -282,8 +282,7 @@ char *callchain_node__scnprintf_value(struct callchain_node *node,
 int callchain_node__fprintf_value(struct callchain_node *node,
 				  FILE *fp, u64 total);
 
-int callchain_list_counts__printf_value(struct callchain_node *node,
-					struct callchain_list *clist,
+int callchain_list_counts__printf_value(struct callchain_list *clist,
 					FILE *fp, char *bf, int bfsize);
 
 void free_callchain(struct callchain_root *root);

commit b851dd49868e295e18c5d72fc3bad85ff1c444b1
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Tue Jul 18 20:13:15 2017 +0800

    perf report: Show branch type in callchain entry
    
    Show branch type in callchain entry. The branch type is printed
    with other LBR information (such as cycles/abort/...).
    
    For example:
    
      perf record -g -j any,save_type
      perf report --branch-history --stdio --no-children
    
      38.50%  div.c:45                [.] main                    div
              |
              ---main div.c:42 (RET CROSS_2M cycles:2)
                 compute_flag div.c:28 (cycles:2)
                 compute_flag div.c:27 (RET CROSS_2M cycles:1)
                 rand rand.c:28 (cycles:1)
                 rand rand.c:28 (RET CROSS_2M cycles:1)
                 __random random.c:298 (cycles:1)
                 __random random.c:297 (COND_BWD CROSS_2M cycles:1)
                 __random random.c:295 (cycles:1)
                 __random random.c:295 (COND_BWD CROSS_2M cycles:1)
                 __random random.c:295 (cycles:1)
                 __random random.c:295 (RET CROSS_2M cycles:9)
    
    Change log
    
    v6: Remove the branch_type_str() since it's moved to branch.c.
    
    v5: Rewrite the branch info print code in util/callchain.c.
    
    v4: Comparing to previous version, the major changes are:
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1500379995-6449-8-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index c56c23dbbf72..97738201464a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,6 +7,7 @@
 #include "event.h"
 #include "map.h"
 #include "symbol.h"
+#include "branch.h"
 
 #define HELP_PAD "\t\t\t\t"
 
@@ -119,6 +120,7 @@ struct callchain_list {
 	u64			cycles_count;
 	u64			iter_count;
 	u64			samples_count;
+	struct branch_type_stat brtype_stat;
 	char		       *srcline;
 	struct list_head	list;
 };
@@ -135,6 +137,7 @@ struct callchain_cursor_node {
 	struct symbol			*sym;
 	bool				branch;
 	struct branch_flags		branch_flags;
+	u64				branch_from;
 	int				nr_loop_iter;
 	int				samples;
 	struct callchain_cursor_node	*next;
@@ -198,7 +201,7 @@ static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
 			    struct map *map, struct symbol *sym,
 			    bool branch, struct branch_flags *flags,
-			    int nr_loop_iter, int samples);
+			    int nr_loop_iter, int samples, u64 branch_from);
 
 /* Close a cursor writing session. Initialize for the reader */
 static inline void callchain_cursor_commit(struct callchain_cursor *cursor)

commit 5dfa210e407d0fedf746958bff206995bd46570d
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Sat Mar 18 22:49:28 2017 +0100

    perf report: Enable sorting by srcline as key
    
    Often it is interesting to know how costly a given source line is in
    total. Previously, one had to build these sums manually based on all
    addresses that pointed to the same source line. This patch introduces
    srcline as a sort key, which will do the aggregation for us.
    
    Paired with the recent addition of showing inline frames, this makes
    perf report much more useful for many C++ work loads.
    
    The following shows the new feature in action. First, let's show the
    status quo output when we sort by address. The result contains many hist
    entries that generate the same output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g address
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--60.31%--hypot +20
                |          |          |
                |          |          |--8.52%--__hypot_finite +273
                |          |          |
                |          |          |--7.32%--__hypot_finite +411
    ...
                 --35.34%--_start +4194346
                           __libc_start_main +241
                           |
                           |--6.65%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--2.70%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
                           |
                           |--1.69%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    With this patch and `-g srcline` we instead get the following output:
    
      ~~~~~~~~~~~~~~~~
      $ perf report --stdio --inline -g srcline
      # Children      Self  Command       Shared Object        Symbol
      # ........  ........  ............  ...................  .........................................
      #
          99.89%    35.34%  cpp-inlining  cpp-inlining         [.] main
                |
                |--64.55%--main complex:655
                |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                |          /usr/include/c++/6.3.1/complex:664 (inline)
                |          |
                |          |--64.02%--hypot
                |          |          |
                |          |           --59.81%--__hypot_finite
                |          |
                |           --0.53%--cabs
                |
                 --35.34%--_start
                           __libc_start_main
                           |
                           |--12.48%--main random.tcc:3326
                           |          /home/milian/projects/kdab/rnd/hotspot/tests/test-clients/cpp-inlining/main.cpp:39 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1809 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:1818 (inline)
                           |          /usr/include/c++/6.3.1/bits/random.h:185 (inline)
      ...
      ~~~~~~~~~~~~~~~~
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/20170318214928.9047-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 4f4b60f1558a..c56c23dbbf72 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -77,7 +77,8 @@ typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_root *,
 
 enum chain_key {
 	CCKEY_FUNCTION,
-	CCKEY_ADDRESS
+	CCKEY_ADDRESS,
+	CCKEY_SRCLINE
 };
 
 enum chain_value {

commit aa33b9b9a2ebb00d33c83a5312d4fbf2d5aeba36
Author: Krister Johansen <kjlx@templeofstupid.com>
Date:   Thu Jan 5 22:23:31 2017 -0800

    perf callchain: Reference count maps
    
    If dso__load_kcore frees all of the existing maps, but one has already
    been attached to a callchain cursor node, then we can get a SIGSEGV in
    any function that happens to try to use this invalid cursor.  Use the
    existing map refcount mechanism to forestall cleanup of a map until the
    cursor iterates past the node.
    
    Signed-off-by: Krister Johansen <kjlx@templeofstupid.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: stable@kernel.org
    Fixes: 84c2cafa2889 ("perf tools: Reference count struct map")
    Link: http://lkml.kernel.org/r/20170106062331.GB2707@templeofstupid.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 35c8e379530f..4f4b60f1558a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -5,6 +5,7 @@
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include "event.h"
+#include "map.h"
 #include "symbol.h"
 
 #define HELP_PAD "\t\t\t\t"
@@ -184,8 +185,13 @@ int callchain_merge(struct callchain_cursor *cursor,
  */
 static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 {
+	struct callchain_cursor_node *node;
+
 	cursor->nr = 0;
 	cursor->last = &cursor->first;
+
+	for (node = cursor->first; node != NULL; node = node->next)
+		map__zput(node->map);
 }
 
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,

commit 571f1eb9b967a52732d2e1f41f1b62e27c900325
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Dec 6 12:40:02 2016 +0900

    perf callchain: Introduce callchain_cursor__copy()
    
    The callchain_cursor__copy() function is to save current callchain
    captured by a cursor.  It'll be used to keep callchains when switching
    to idle task for each cpu.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20161206034010.6499-3-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index d9c70dccf06a..35c8e379530f 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -216,6 +216,9 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 	cursor->pos++;
 }
 
+int callchain_cursor__copy(struct callchain_cursor *dst,
+			   struct callchain_cursor *src);
+
 struct option;
 struct hist_entry;
 

commit 3dd029ef94018dfa499c05778dd67d03c00b637c
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Mon Oct 31 09:19:51 2016 +0800

    perf report: Calculate and return the branch flag counting
    
    Create some branch counters in per callchain list entry. Each counter
    is for a branch flag. For example, predicted_count counts all the
    *predicted* branches. The counters get updated by processing the
    callchain cursor nodes.
    
    It also provides functions to retrieve or print the values of counters
    in callchain list.
    
    Besides the counting for branch flags, it also counts and returns the
    average number of iterations.
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Linux-kernel@vger.kernel.org
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/r/1477876794-30749-4-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index df6329d1c350..d9c70dccf06a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -111,6 +111,12 @@ struct callchain_list {
 		bool		unfolded;
 		bool		has_children;
 	};
+	u64			branch_count;
+	u64			predicted_count;
+	u64			abort_count;
+	u64			cycles_count;
+	u64			iter_count;
+	u64			samples_count;
 	char		       *srcline;
 	struct list_head	list;
 };
@@ -263,8 +269,16 @@ char *callchain_node__scnprintf_value(struct callchain_node *node,
 int callchain_node__fprintf_value(struct callchain_node *node,
 				  FILE *fp, u64 total);
 
+int callchain_list_counts__printf_value(struct callchain_node *node,
+					struct callchain_list *clist,
+					FILE *fp, char *bf, int bfsize);
+
 void free_callchain(struct callchain_root *root);
 void decay_callchain(struct callchain_root *root);
 int callchain_node__make_parent_list(struct callchain_node *node);
 
+int callchain_branch_counts(struct callchain_root *root,
+			    u64 *branch_count, u64 *predicted_count,
+			    u64 *abort_count, u64 *cycles_count);
+
 #endif	/* __PERF_CALLCHAIN_H */

commit 410024dbbcb1df5b8140a812b4f1a4dbd62ef924
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Mon Oct 31 09:19:49 2016 +0800

    perf report: Add branch flag to callchain cursor node
    
    Since the branch ip has been added to call stack for easier browsing,
    this patch adds more branch information. For example, add a flag to
    indicate if this ip is a branch, and also add with the branch flag.
    
    Then we can know if the cursor node represents a branch and know what
    the branch flag it has.
    
    The branch history code has a loop detection pass that removes loops. It
    would be nice for knowing how many loops were removed then in next
    steps, we can compute out the average number of iterations.
    
    For example:
    
    Before remove_loops(),
    entry0: from = 0x100, to = 0x200
    entry1: from = 0x300, to = 0x250
    entry2: from = 0x300, to = 0x250
    entry3: from = 0x300, to = 0x250
    entry4: from = 0x700, to = 0x800
    
    After remove_loops()
    entry0: from = 0x100, to = 0x200
    entry1: from = 0x300, to = 0x250
    entry2: from = 0x700, to = 0x800
    
    The original entry2 and entry3 are removed. So the number of iterations
    (from = 0x300, to = 0x250) is equal to removed number + 1 (2 + 1).
    
    iterations = removed number + 1;
    average iteractions = Sum(iteractions) / number of samples
    
    This formula ignores other cases, for example, iterations cross multiple
    buffers and one buffer contains 2+ loops. Because in practice, it's good
    enough.
    
    Signed-off-by: Yao Jin <yao.jin@linux.intel.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Linux-kernel@vger.kernel.org
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Link: http://lkml.kernel.org/n/1477876794-30749-2-git-send-email-yao.jin@linux.intel.com
    [ Renamed 'iter' to 'nr_loop_iter' for clarity ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 47cfd1080975..df6329d1c350 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -125,6 +125,10 @@ struct callchain_cursor_node {
 	u64				ip;
 	struct map			*map;
 	struct symbol			*sym;
+	bool				branch;
+	struct branch_flags		branch_flags;
+	int				nr_loop_iter;
+	int				samples;
 	struct callchain_cursor_node	*next;
 };
 
@@ -179,7 +183,9 @@ static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 }
 
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
-			    struct map *map, struct symbol *sym);
+			    struct map *map, struct symbol *sym,
+			    bool branch, struct branch_flags *flags,
+			    int nr_loop_iter, int samples);
 
 /* Close a cursor writing session. Initialize for the reader */
 static inline void callchain_cursor_commit(struct callchain_cursor *cursor)

commit c56cb33b56c13493eeb95612f80e4dd6e35cd109
Author: Rabin Vincent <rabinv@axis.com>
Date:   Wed Aug 10 15:52:28 2016 +0200

    perf callchain: Fixup help/config for no-unwinding
    
    Since 841e3558b2d ("perf callchain: Recording 'dwarf' callchains do not
    need DWARF unwinding support"), --call-graph dwarf is allowed in 'perf
    record' even without unwind support.  A couple of other places don't
    reflect this yet though: the help text should list dwarf as a valid
    record mode and the dump_size config should be respected too.
    
    Signed-off-by: Rabin Vincent <rabinv@axis.com>
    Cc: He Kuang <hekuang@huawei.com>
    Fixes: 841e3558b2de ("perf callchain: Recording 'dwarf' callchains do not need DWARF unwinding support")
    Link: http://lkml.kernel.org/r/1470837148-7642-1-git-send-email-rabin.vincent@axis.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 13e75549c440..47cfd1080975 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -11,11 +11,7 @@
 
 #define CALLCHAIN_HELP "setup and enables call-graph (stack chain/backtrace):\n\n"
 
-#ifdef HAVE_DWARF_UNWIND_SUPPORT
 # define RECORD_MODE_HELP  HELP_PAD "record_mode:\tcall graph recording mode (fp|dwarf|lbr)\n"
-#else
-# define RECORD_MODE_HELP  HELP_PAD "record_mode:\tcall graph recording mode (fp|lbr)\n"
-#endif
 
 #define RECORD_SIZE_HELP						\
 	HELP_PAD "record_size:\tif record_mode is 'dwarf', max size of stack recording (<bytes>)\n" \

commit 347ca878062d5fb0e16db1fae81b0994f2457efd
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Jul 4 14:16:21 2016 +0200

    perf tests: Fix hist accumulation test
    
    User's values from .perfconfig could overload the default callchain
    setup and cause this test to fail.  Making sure the test is using
    default callchain_param values.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1467634583-29147-3-git-send-email-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index a70f6b54eb92..13e75549c440 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -106,6 +106,7 @@ struct callchain_param {
 };
 
 extern struct callchain_param callchain_param;
+extern struct callchain_param callchain_param_default;
 
 struct callchain_list {
 	u64			ip;

commit 792d48b4cf9c248ab2bf66c140a27c48e116bed7
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 28 19:03:42 2016 -0300

    perf tools: Per event max-stack settings
    
    The tooling counterpart, now it is possible to do:
    
      # perf record -e sched:sched_switch/max-stack=10/ -e cycles/call-graph=dwarf,max-stack=4/ -e cpu-cycles/call-graph=dwarf,max-stack=1024/ usleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.052 MB perf.data (5 samples) ]
      # perf evlist -v
      sched:sched_switch: type: 2, size: 112, config: 0x110, { sample_period, sample_freq }: 1, sample_type: IP|TID|TIME|CALLCHAIN|CPU|PERIOD|RAW|IDENTIFIER, read_format: ID, disabled: 1, inherit: 1, mmap: 1, comm: 1, enable_on_exec: 1, task: 1, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, sample_max_stack: 10
      cycles/call-graph=dwarf,max-stack=4/: size: 112, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|CALLCHAIN|PERIOD|REGS_USER|STACK_USER|IDENTIFIER, read_format: ID, disabled: 1, inherit: 1, freq: 1, enable_on_exec: 1, sample_id_all: 1, exclude_guest: 1, exclude_callchain_user: 1, sample_regs_user: 0xff0fff, sample_stack_user: 8192, sample_max_stack: 4
      cpu-cycles/call-graph=dwarf,max-stack=1024/: size: 112, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|CALLCHAIN|PERIOD|REGS_USER|STACK_USER|IDENTIFIER, read_format: ID, disabled: 1, inherit: 1, freq: 1, enable_on_exec: 1, sample_id_all: 1, exclude_guest: 1, exclude_callchain_user: 1, sample_regs_user: 0xff0fff, sample_stack_user: 8192, sample_max_stack: 1024
      # Tip: use 'perf evlist --trace-fields' to show fields for tracepoint events
    
    Using just /max-stack=N/ means /call-graph=fp,max-stack=N/, that should
    be further configurable by means of some .perfconfig knob.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/n/tip-kolmn1yo40p7jhswxwrc7rrd@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 65e2a4f7cb4e..a70f6b54eb92 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -94,6 +94,7 @@ struct callchain_param {
 	enum perf_call_graph_mode record_mode;
 	u32			dump_size;
 	enum chain_mode 	mode;
+	u16			max_stack;
 	u32			print_limit;
 	double			min_percent;
 	sort_chain_func_t	sort;

commit 0883e820a0ac18e04f036dbebc3580351d7fd6cf
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Apr 15 16:37:17 2016 -0300

    perf record: Export record_opts based callchain parsing helper
    
    To be able to call it outside option parsing, like when setting a
    default --call-graph parameter in 'perf trace' when just --min-stack is
    used.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-xay69plylwibpb3l4isrpl1k@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index cae5a7b1f5c8..65e2a4f7cb4e 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -212,6 +212,12 @@ struct hist_entry;
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 
+struct record_opts;
+
+int record_opts__parse_callchain(struct record_opts *record,
+				 struct callchain_param *callchain,
+				 const char *arg, bool unset);
+
 int sample__resolve_callchain(struct perf_sample *sample,
 			      struct callchain_cursor *cursor, struct symbol **parent,
 			      struct perf_evsel *evsel, struct addr_location *al,

commit 91d7b2de318ff701451dfc7ede1c029b150ef0e9
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 14 14:48:07 2016 -0300

    perf callchain: Start moving away from global per thread cursors
    
    The recent perf_evsel__fprintf_callchain() move to evsel.c added several
    new symbol requirements to the python binding, for instance:
    
      # perf test -v python
      16: Try 'import perf' in python, checking link problems      :
      --- start ---
      test child forked, pid 18030
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
      ImportError: /tmp/build/perf/python/perf.so: undefined symbol:
      callchain_cursor
      test child finished with -1
      ---- end ----
      Try 'import perf' in python, checking link problems: FAILED!
      #
    
    This would require linking against callchain.c to access to the global
    callchain_cursor variables.
    
    Since lots of functions already receive as a parameter a
    callchain_cursor struct pointer, make that be the case for some more
    function so that we can start phasing out usage of yet another global
    variable.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-djko3097eyg2rn66v2qcqfvn@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index d2a9e694810c..cae5a7b1f5c8 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -212,7 +212,8 @@ struct hist_entry;
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 
-int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent,
+int sample__resolve_callchain(struct perf_sample *sample,
+			      struct callchain_cursor *cursor, struct symbol **parent,
 			      struct perf_evsel *evsel, struct addr_location *al,
 			      int max_stack);
 int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);

commit 3938bad44ed2fea41328e4be2ae04a8e94540813
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Mar 23 15:06:35 2016 -0300

    perf tools: Remove needless 'extern' from function prototypes
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-w246stf7ponfamclsai6b9zo@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 18dd22269764..d2a9e694810c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -220,7 +220,7 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 			bool hide_unresolved);
 
 extern const char record_callchain_help[];
-extern int parse_callchain_record(const char *arg, struct callchain_param *param);
+int parse_callchain_record(const char *arg, struct callchain_param *param);
 int parse_callchain_record_opt(const char *arg, struct callchain_param *param);
 int parse_callchain_report_opt(const char *arg);
 int parse_callchain_top_opt(const char *arg);
@@ -236,7 +236,7 @@ static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,
 }
 
 #ifdef HAVE_SKIP_CALLCHAIN_IDX
-extern int arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain);
+int arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain);
 #else
 static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 			struct ip_callchain *chain __maybe_unused)

commit 42b276a2351517409d55b1202a1fa8b05c0cdc99
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Jan 5 12:06:00 2016 +0900

    perf top: Decay periods in callchains
    
    It missed to decay periods in callchains when decaying hist entries.
    This resulted in more than 100 percent overhead in callchains in the
    fractal style output.
    
    Reported-by: Arnaldo Carvalho de Melo <acme@kernel.org>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1451963160-17196-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8ac8f043004c..18dd22269764 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -253,6 +253,7 @@ int callchain_node__fprintf_value(struct callchain_node *node,
 				  FILE *fp, u64 total);
 
 void free_callchain(struct callchain_root *root);
+void decay_callchain(struct callchain_root *root);
 int callchain_node__make_parent_list(struct callchain_node *node);
 
 #endif	/* __PERF_CALLCHAIN_H */

commit 646a6e846c4dc3812c614fd061603b6db5b8d380
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Sat Nov 21 11:23:55 2015 +0100

    perf callchain: Add missing parent_val initialization
    
    Adding missing parent_val callchain_node initialization.
    It's causing segfault in perf top:
    
      $ sudo perf top -g
      perf: Segmentation fault
      -------- backtrace --------
      free_callchain_node(+0x29) in perf [0x4a4b3e]
      free_callchain(+0x29) in perf [0x4a5a83]
      hist_entry__delete(+0x126) in perf [0x4c6649]
      hists__delete_entry(+0x6e) in perf [0x4c66dc]
      hists__decay_entries(+0x7d) in perf [0x4c6776]
      perf_top__sort_new_samples(+0x7c) in perf [0x436a78]
      hist_browser__run(+0xf2) in perf [0x507760]
      perf_evsel__hists_browse(+0x1da) in perf [0x507c8d]
      perf_evlist__tui_browse_hists(+0x3e) in perf [0x5088cf]
      display_thread_tui(+0x7f) in perf [0x437953]
      start_thread(+0xc5) in libpthread-2.21.so [0x7f7068fbb555]
      __clone(+0x6d) in libc-2.21.so [0x7f7066fc3b9d]
      [0x0]
    
    Reported-and-Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Fixes: 4b3a3212233a ("perf hists browser: Support flat callchains")
    Link: http://lkml.kernel.org/r/20151121102355.GA17313@krava.local
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 6e9b5f2099e1..8ac8f043004c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -143,6 +143,7 @@ extern __thread struct callchain_cursor callchain_cursor;
 static inline void callchain_init(struct callchain_root *root)
 {
 	INIT_LIST_HEAD(&root->node.val);
+	INIT_LIST_HEAD(&root->node.parent_val);
 
 	root->node.parent = NULL;
 	root->node.hit = 0;

commit 4b3a3212233a042f48b7b8fedc64933e1ccd8643
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Nov 9 14:45:43 2015 +0900

    perf hists browser: Support flat callchains
    
    The flat callchain mode is to print all chains in a single, simple
    hierarchy so make it easy to see.
    
    Currently perf report --tui doesn't show flat callchains properly.  With
    flat callchains, only leaf nodes are added to the final rbtree so it
    should show entries in parent nodes.  To do that, add parent_val list to
    struct callchain_node and show them along with the (normal) val list.
    
    For example, consider following callchains with '-g graph'.
    
      $ perf report -g graph
      - 39.93%  swapper  [kernel.vmlinux]  [k] intel_idle
           intel_idle
           cpuidle_enter_state
           cpuidle_enter
           call_cpuidle
         - cpu_startup_entry
              28.63% start_secondary
            - 11.30% rest_init
                 start_kernel
                 x86_64_start_reservations
                 x86_64_start_kernel
    
    Before:
      $ perf report -g flat
      - 39.93%  swapper  [kernel.vmlinux]  [k] intel_idle
           28.63% start_secondary
         - 11.30% rest_init
              start_kernel
              x86_64_start_reservations
              x86_64_start_kernel
    
    After:
      $ perf report -g flat
      - 39.93%  swapper  [kernel.vmlinux]  [k] intel_idle
         - 28.63% intel_idle
              cpuidle_enter_state
              cpuidle_enter
              call_cpuidle
              cpu_startup_entry
              start_secondary
         - 11.30% intel_idle
              cpuidle_enter_state
              cpuidle_enter
              call_cpuidle
              cpu_startup_entry
              start_kernel
              x86_64_start_reservations
              x86_64_start_kernel
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Tested-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1447047946-1691-8-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 47bc0c57f764..6e9b5f2099e1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -56,6 +56,7 @@ enum chain_order {
 struct callchain_node {
 	struct callchain_node	*parent;
 	struct list_head	val;
+	struct list_head	parent_val;
 	struct rb_node		rb_node_in; /* to insert nodes in an rbtree */
 	struct rb_node		rb_node;    /* to sort nodes in an output tree */
 	struct rb_root		rb_root_in; /* input tree of children */
@@ -251,5 +252,6 @@ int callchain_node__fprintf_value(struct callchain_node *node,
 				  FILE *fp, u64 total);
 
 void free_callchain(struct callchain_root *root);
+int callchain_node__make_parent_list(struct callchain_node *node);
 
 #endif	/* __PERF_CALLCHAIN_H */

commit f2af008695e0b54a58b76caecd52af7e6c97fb29
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Nov 9 14:45:41 2015 +0900

    perf report: Add callchain value option
    
    Now -g/--call-graph option supports how to display callchain values.
    Possible values are 'percent', 'period' and 'count'.  The percent is
    same as before and it's the default behavior.  The period displays the
    raw period value rather than the percentage.  The count displays the
    number of occurrences.
    
      $ perf report --no-children --stdio -g percent
      ...
        39.93%  swapper  [kernel.vmlinux]  [k] intel_idel
                |
                ---intel_idle
                   cpuidle_enter_state
                   cpuidle_enter
                   call_cpuidle
                   cpu_startup_entry
                   |
                   |--28.63%-- start_secondary
                   |
                    --11.30%-- rest_init
    
      $ perf report --no-children --show-total-period --stdio -g period
      ...
        39.93%   13018705  swapper  [kernel.vmlinux]  [k] intel_idel
                |
                ---intel_idle
                   cpuidle_enter_state
                   cpuidle_enter
                   call_cpuidle
                   cpu_startup_entry
                   |
                   |--9334403-- start_secondary
                   |
                    --3684302-- rest_init
    
      $ perf report --no-children --show-nr-samples --stdio -g count
      ...
        39.93%     80  swapper  [kernel.vmlinux]  [k] intel_idel
                |
                ---intel_idle
                   cpuidle_enter_state
                   cpuidle_enter
                   call_cpuidle
                   cpu_startup_entry
                   |
                   |--57-- start_secondary
                   |
                    --23-- rest_init
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1447047946-1691-6-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index cdb386d9ba02..47bc0c57f764 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -29,7 +29,8 @@
 	HELP_PAD "print_limit:\tmaximum number of call graph entry (<number>)\n" \
 	HELP_PAD "order:\t\tcall graph order (caller|callee)\n" \
 	HELP_PAD "sort_key:\tcall graph sort key (function|address)\n"	\
-	HELP_PAD "branch:\t\tinclude last branch info to call graph (branch)\n"
+	HELP_PAD "branch:\t\tinclude last branch info to call graph (branch)\n" \
+	HELP_PAD "value:\t\tcall graph value (percent|period|count)\n"
 
 enum perf_call_graph_mode {
 	CALLCHAIN_NONE,
@@ -81,6 +82,12 @@ enum chain_key {
 	CCKEY_ADDRESS
 };
 
+enum chain_value {
+	CCVAL_PERCENT,
+	CCVAL_PERIOD,
+	CCVAL_COUNT,
+};
+
 struct callchain_param {
 	bool			enabled;
 	enum perf_call_graph_mode record_mode;
@@ -93,6 +100,7 @@ struct callchain_param {
 	bool			order_set;
 	enum chain_key		key;
 	bool			branch_callstack;
+	enum chain_value	value;
 };
 
 extern struct callchain_param callchain_param;

commit 5e47f8ff406296bd078716d71283796ca5c6544b
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Nov 9 14:45:40 2015 +0900

    perf callchain: Add count fields to struct callchain_node
    
    It's to track the count of occurrences of the callchains.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1447047946-1691-5-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 060e636e33ab..cdb386d9ba02 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -60,6 +60,8 @@ struct callchain_node {
 	struct rb_root		rb_root_in; /* input tree of children */
 	struct rb_root		rb_root;    /* sorted output tree of children */
 	unsigned int		val_nr;
+	unsigned int		count;
+	unsigned int		children_count;
 	u64			hit;
 	u64			children_hit;
 };
@@ -145,6 +147,11 @@ static inline u64 callchain_cumul_hits(struct callchain_node *node)
 	return node->hit + node->children_hit;
 }
 
+static inline unsigned callchain_cumul_counts(struct callchain_node *node)
+{
+	return node->count + node->children_count;
+}
+
 int callchain_register_param(struct callchain_param *param);
 int callchain_append(struct callchain_root *root,
 		     struct callchain_cursor *cursor,

commit 5ab250cafcd884a2638b102239870bddca42ff88
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Nov 9 14:45:39 2015 +0900

    perf callchain: Abstract callchain print function
    
    This is a preparation to support for printing other type of callchain
    value like count or period.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1447047946-1691-4-git-send-email-namhyung@kernel.org
    [ renamed new _sprintf_ operation to _scnprintf_ ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 544d99ac169c..060e636e33ab 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -230,6 +230,10 @@ static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 
 char *callchain_list__sym_name(struct callchain_list *cl,
 			       char *bf, size_t bfsize, bool show_dso);
+char *callchain_node__scnprintf_value(struct callchain_node *node,
+				      char *bf, size_t bfsize, u64 total);
+int callchain_node__fprintf_value(struct callchain_node *node,
+				  FILE *fp, u64 total);
 
 void free_callchain(struct callchain_root *root);
 

commit 26e779245dd6f5270c0696860438e5c03d0780fd
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Nov 9 14:45:37 2015 +0900

    perf report: Support folded callchain mode on --stdio
    
    Add new call chain option (-g) 'folded' to print callchains in a line.
    The callchains are separated by semicolons, and preceded by (absolute)
    percent values and a space.
    
    For example, the following 20 lines can be printed in 3 lines with the
    folded output mode:
    
      $ perf report -g flat --no-children | grep -v ^# | head -20
          60.48%  swapper  [kernel.vmlinux]  [k] intel_idle
                  54.60%
                     intel_idle
                     cpuidle_enter_state
                     cpuidle_enter
                     call_cpuidle
                     cpu_startup_entry
                     start_secondary
    
                  5.88%
                     intel_idle
                     cpuidle_enter_state
                     cpuidle_enter
                     call_cpuidle
                     cpu_startup_entry
                     rest_init
                     start_kernel
                     x86_64_start_reservations
                     x86_64_start_kernel
    
      $ perf report -g folded --no-children | grep -v ^# | head -3
          60.48%  swapper  [kernel.vmlinux]  [k] intel_idle
      54.60% intel_idle;cpuidle_enter_state;cpuidle_enter;call_cpuidle;cpu_startup_entry;start_secondary
      5.88% intel_idle;cpuidle_enter_state;cpuidle_enter;call_cpuidle;cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
    
    This mode is supported only for --stdio now and intended to be used by
    some scripts like in FlameGraphs[1].  Support for other UI might be
    added later.
    
    [1] http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html
    
    Requested-and-Tested-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1447047946-1691-2-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index fce8161e54db..544d99ac169c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -24,7 +24,7 @@
 #define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP RECORD_MODE_HELP RECORD_SIZE_HELP
 
 #define CALLCHAIN_REPORT_HELP						\
-	HELP_PAD "print_type:\tcall graph printing style (graph|flat|fractal|none)\n" \
+	HELP_PAD "print_type:\tcall graph printing style (graph|flat|fractal|folded|none)\n" \
 	HELP_PAD "threshold:\tminimum call graph inclusion threshold (<percent>)\n" \
 	HELP_PAD "print_limit:\tmaximum number of call graph entry (<number>)\n" \
 	HELP_PAD "order:\t\tcall graph order (caller|callee)\n" \
@@ -43,7 +43,8 @@ enum chain_mode {
 	CHAIN_NONE,
 	CHAIN_FLAT,
 	CHAIN_GRAPH_ABS,
-	CHAIN_GRAPH_REL
+	CHAIN_GRAPH_REL,
+	CHAIN_FOLDED,
 };
 
 enum chain_order {

commit 76a26549eb367f683fbb394b7246bef5dc665f8c
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Oct 22 23:28:32 2015 +0900

    perf tools: Improve call graph documents and help messages
    
    The --call-graph option is complex so we should provide better guide for
    users.  Also change help message to be consistent with config option
    names.  Now perf top will show help like below:
    
      $ perf top --call-graph
        Error: option `call-graph' requires a value
    
       Usage: perf top [<options>]
    
          --call-graph <record_mode[,record_size],print_type,threshold[,print_limit],order,sort_key[,branch]>
               setup and enables call-graph (stack chain/backtrace):
    
                    record_mode:    call graph recording mode (fp|dwarf|lbr)
                    record_size:    if record_mode is 'dwarf', max size of stack recording (<bytes>)
                                    default: 8192 (bytes)
                    print_type:     call graph printing style (graph|flat|fractal|none)
                    threshold:      minimum call graph inclusion threshold (<percent>)
                    print_limit:    maximum number of call graph entry (<number>)
                    order:          call graph order (caller|callee)
                    sort_key:       call graph sort key (function|address)
                    branch:         include last branch info to call graph (branch)
    
                    Default: fp,graph,0.5,caller,function
    
    Requested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Chandler Carruth <chandlerc@gmail.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1445524112-5201-2-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index aaf467c9ef2b..fce8161e54db 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,17 +7,29 @@
 #include "event.h"
 #include "symbol.h"
 
-#define CALLCHAIN_HELP "setup and enables call-graph (stack chain/backtrace) recording: "
+#define HELP_PAD "\t\t\t\t"
+
+#define CALLCHAIN_HELP "setup and enables call-graph (stack chain/backtrace):\n\n"
 
 #ifdef HAVE_DWARF_UNWIND_SUPPORT
-#define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP "fp dwarf lbr"
+# define RECORD_MODE_HELP  HELP_PAD "record_mode:\tcall graph recording mode (fp|dwarf|lbr)\n"
 #else
-#define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP "fp lbr"
+# define RECORD_MODE_HELP  HELP_PAD "record_mode:\tcall graph recording mode (fp|lbr)\n"
 #endif
 
-#define CALLCHAIN_REPORT_HELP  "output_type (graph, flat, fractal, or none), " \
-	"min percent threshold, optional print limit, callchain order, " \
-	"key (function or address), add branches"
+#define RECORD_SIZE_HELP						\
+	HELP_PAD "record_size:\tif record_mode is 'dwarf', max size of stack recording (<bytes>)\n" \
+	HELP_PAD "\t\tdefault: 8192 (bytes)\n"
+
+#define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP RECORD_MODE_HELP RECORD_SIZE_HELP
+
+#define CALLCHAIN_REPORT_HELP						\
+	HELP_PAD "print_type:\tcall graph printing style (graph|flat|fractal|none)\n" \
+	HELP_PAD "threshold:\tminimum call graph inclusion threshold (<percent>)\n" \
+	HELP_PAD "print_limit:\tmaximum number of call graph entry (<number>)\n" \
+	HELP_PAD "order:\t\tcall graph order (caller|callee)\n" \
+	HELP_PAD "sort_key:\tcall graph sort key (function|address)\n"	\
+	HELP_PAD "branch:\t\tinclude last branch info to call graph (branch)\n"
 
 enum perf_call_graph_mode {
 	CALLCHAIN_NONE,

commit 792aeafa8ed08e5e18fb66ab93b470f78e619f75
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Oct 22 16:45:46 2015 +0900

    perf tools: Defaults to 'caller' callchain order only if --children is enabled
    
    The caller callchain order is useful with --children option since it can
    show 'overview' style output, but other commands which don't use
    --children feature like 'perf script' or even 'perf report/top' without
    --children are better to keep callee order.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Brendan Gregg <brendan.d.gregg@gmail.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Chandler Carruth <chandlerc@gmail.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1445499946-29817-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 836d59a001bc..aaf467c9ef2b 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -75,6 +75,7 @@ struct callchain_param {
 	double			min_percent;
 	sort_chain_func_t	sort;
 	enum chain_order	order;
+	bool			order_set;
 	enum chain_key		key;
 	bool			branch_callstack;
 };

commit a2c10d39af49b00514f7cc7b750757fcc2174f0c
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Oct 22 15:28:49 2015 +0900

    perf top: Support call-graph display options also
    
    Currently 'perf top --call-graph' option is same as 'perf record'.  But
    'perf top' also need to receive display options in 'perf report'.  To do
    that, change parse_callchain_report_opt() to allow record options too.
    
    Now perf top can receive display options like below:
    
      $ perf top --call-graph
        Error: option `call-graph' requires a value
    
       Usage: perf top [<options>]
    
            --call-graph
              <mode[,dump_size],output_type,min_percent[,print_limit],call_order[,branch]>
                         setup and enables call-graph (stack chain/backtrace)
                         recording: fp dwarf lbr, output_type (graph, flat,
                         fractal, or none), min percent threshold, optional
                         print limit, callchain order, key (function or
                         address), add branches
    
      $ perf top --call-graph callee,graph,fp
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Chandler Carruth <chandlerc@gmail.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1445495330-25416-2-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index c9e3a2e85a72..836d59a001bc 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -192,6 +192,7 @@ extern const char record_callchain_help[];
 extern int parse_callchain_record(const char *arg, struct callchain_param *param);
 int parse_callchain_record_opt(const char *arg, struct callchain_param *param);
 int parse_callchain_report_opt(const char *arg);
+int parse_callchain_top_opt(const char *arg);
 int perf_callchain_config(const char *var, const char *value);
 
 static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,

commit 21cf62847d29392e51c37460856d3c3c57769c5e
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Oct 22 15:28:48 2015 +0900

    perf tools: Move callchain help messages to callchain.h
    
    These messages will be used by 'perf top' in the next patch.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Chandler Carruth <chandlerc@gmail.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1445495330-25416-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index acee2b3cd801..c9e3a2e85a72 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,6 +7,18 @@
 #include "event.h"
 #include "symbol.h"
 
+#define CALLCHAIN_HELP "setup and enables call-graph (stack chain/backtrace) recording: "
+
+#ifdef HAVE_DWARF_UNWIND_SUPPORT
+#define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP "fp dwarf lbr"
+#else
+#define CALLCHAIN_RECORD_HELP  CALLCHAIN_HELP "fp lbr"
+#endif
+
+#define CALLCHAIN_REPORT_HELP  "output_type (graph, flat, fractal, or none), " \
+	"min percent threshold, optional print limit, callchain order, " \
+	"key (function or address), add branches"
+
 enum perf_call_graph_mode {
 	CALLCHAIN_NONE,
 	CALLCHAIN_FP,

commit 076a30c411ba2b91a18d44a5a01977035cdd7716
Author: Kan Liang <kan.liang@intel.com>
Date:   Thu Aug 6 15:44:52 2015 -0400

    perf callchain: Move option parsing code to util.c
    
    Move callchain option parse related code to util.c, to avoid dragging
    more object files into the python binding.
    
    Signed-off-by: Kan Liang <kan.liang@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1438890294-33409-1-git-send-email-kan.liang@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 68a32c2fe87a..acee2b3cd801 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -177,6 +177,7 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 			bool hide_unresolved);
 
 extern const char record_callchain_help[];
+extern int parse_callchain_record(const char *arg, struct callchain_param *param);
 int parse_callchain_record_opt(const char *arg, struct callchain_param *param);
 int parse_callchain_report_opt(const char *arg);
 int perf_callchain_config(const char *var, const char *value);

commit c3a6a8c40538f609923acf9473250266283269a5
Author: Kan Liang <kan.liang@intel.com>
Date:   Tue Aug 4 04:30:20 2015 -0400

    perf tools: Refine parse/config callchain functions
    
    Pass global callchain_param into parse_callchain_record_opt and
    perf_evsel__config_callgraph as parameter. So we can reuse these
    functions to parse/config local param for callchain.
    
    Signed-off-by: Kan Liang <kan.liang@intel.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1438677022-34296-3-git-send-email-kan.liang@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 679c2c6d8ade..68a32c2fe87a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -177,7 +177,7 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 			bool hide_unresolved);
 
 extern const char record_callchain_help[];
-int parse_callchain_record_opt(const char *arg);
+int parse_callchain_record_opt(const char *arg, struct callchain_param *param);
 int parse_callchain_report_opt(const char *arg);
 int perf_callchain_config(const char *var, const char *value);
 

commit 3698dab1c849c7e1cd440df4fca24baa1973d53b
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue May 5 23:55:46 2015 +0900

    perf tools: Move TUI-specific fields out of map_symbol
    
    The has_children and unfolded fields don't belong to the struct
    map_symbol since they're used by the TUI only.  Move those fields out of
    map_symbol since the struct is also used by other places.
    
    This will also help to compact the sizeof struct hist_entry.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1429687101-4360-11-git-send-email-namhyung@kernel.org
    Link: http://lkml.kernel.org/r/1430837746-5439-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 6033a0a212ca..679c2c6d8ade 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -72,6 +72,10 @@ extern struct callchain_param callchain_param;
 struct callchain_list {
 	u64			ip;
 	struct map_symbol	ms;
+	struct /* for TUI */ {
+		bool		unfolded;
+		bool		has_children;
+	};
 	char		       *srcline;
 	struct list_head	list;
 };

commit aad2b21c151273fa7abc419dac51a980eff1dd17
Author: Kan Liang <kan.liang@intel.com>
Date:   Mon Jan 5 13:23:04 2015 -0500

    perf tools: Enable LBR call stack support
    
    Currently, there are two call chain recording options, fp and dwarf.
    
    Haswell has a new feature that utilizes the existing LBR facility to
    record call chains. Kernel side LBR support code provides this as a
    third option to record call chains. This patch enables the lbr call
    stack support on the tooling side.
    
    LBR call stack has some limitations:
    
     - It reuses current LBR facility, so LBR call stack and branch record
       can not be enabled at the same time.
    
     - It is only available for user-space callchains.
    
    However, it also offers some advantages:
    
     - LBR call stack can work on user apps which don't have frame-pointers
       or dwarf debug info compiled. It is a good alternative when nothing
       else works.
    
    Tested-by: Jiri Olsa <jolsa@kernel.org>
    Signed-off-by: Kan Liang <kan.liang@intel.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Anshuman Khandual <khandual@linux.vnet.ibm.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Cody P Schafer <cody@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Jacob Shin <jacob.w.shin@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rodrigo Campos <rodrigo@sdfg.com.ar>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1420482185-29830-2-git-send-email-kan.liang@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index c0ec1acc38e4..6033a0a212ca 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -11,6 +11,7 @@ enum perf_call_graph_mode {
 	CALLCHAIN_NONE,
 	CALLCHAIN_FP,
 	CALLCHAIN_DWARF,
+	CALLCHAIN_LBR,
 	CALLCHAIN_MAX
 };
 

commit d114960c488b5a95705a04bba305f931cef0efd6
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Dec 30 14:38:13 2014 +0900

    perf callchain: Free callchains when hist entries are deleted
    
    Markus reported that "perf top -g" can leak ~300MB per second on his
    machine.  This is partly because it missed to free callchains when hist
    entries are deleted.  Fix it.
    
    Reported-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Markus Trippelsdorf <markus@trippelsdorf.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20141230053813.GD6081@sejong
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index dbc08cf5f970..c0ec1acc38e4 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -198,4 +198,6 @@ static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 char *callchain_list__sym_name(struct callchain_list *cl,
 			       char *bf, size_t bfsize, bool show_dso);
 
+void free_callchain(struct callchain_root *root);
+
 #endif	/* __PERF_CALLCHAIN_H */

commit 8b7bad58efb7e3aaff60f7c1fa4361fb8c23181d
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:20 2014 -0800

    perf callchain: Support handling complete branch stacks as histograms
    
    Currently branch stacks can be only shown as edge histograms for
    individual branches. I never found this display particularly useful.
    
    This implements an alternative mode that creates histograms over
    complete branch traces, instead of individual branches, similar to how
    normal callgraphs are handled. This is done by putting it in front of
    the normal callgraph and then using the normal callgraph histogram
    infrastructure to unify them.
    
    This way in complex functions we can understand the control flow that
    lead to a particular sample, and may even see some control flow in the
    caller for short functions.
    
    Example (simplified, of course for such simple code this is usually not
    needed), please run this after the whole patchkit is in, as at this
    point in the patch order there is no --branch-history, that will be
    added in a patch after this one:
    
    tcall.c:
    
    volatile a = 10000, b = 100000, c;
    
    __attribute__((noinline)) f2()
    {
            c = a / b;
    }
    
    __attribute__((noinline)) f1()
    {
            f2();
            f2();
    }
    main()
    {
            int i;
            for (i = 0; i < 1000000; i++)
                    f1();
    }
    
    % perf record -b -g ./tsrc/tcall
    [ perf record: Woken up 1 times to write data ]
    [ perf record: Captured and wrote 0.044 MB perf.data (~1923 samples) ]
    % perf report --no-children --branch-history
    ...
        54.91%  tcall.c:6  [.] f2                      tcall
                |
                |--65.53%-- f2 tcall.c:5
                |          |
                |          |--70.83%-- f1 tcall.c:11
                |          |          f1 tcall.c:10
                |          |          main tcall.c:18
                |          |          main tcall.c:18
                |          |          main tcall.c:17
                |          |          main tcall.c:17
                |          |          f1 tcall.c:13
                |          |          f1 tcall.c:13
                |          |          f2 tcall.c:7
                |          |          f2 tcall.c:5
                |          |          f1 tcall.c:12
                |          |          f1 tcall.c:12
                |          |          f2 tcall.c:7
                |          |          f2 tcall.c:5
                |          |          f1 tcall.c:11
                |          |
                |           --29.17%-- f1 tcall.c:12
                |                     f1 tcall.c:12
                |                     f2 tcall.c:7
                |                     f2 tcall.c:5
                |                     f1 tcall.c:11
                |                     f1 tcall.c:10
                |                     main tcall.c:18
                |                     main tcall.c:18
                |                     main tcall.c:17
                |                     main tcall.c:17
                |                     f1 tcall.c:13
                |                     f1 tcall.c:13
                |                     f2 tcall.c:7
                |                     f2 tcall.c:5
                |                     f1 tcall.c:12
    
    The default output is unchanged.
    
    This is only implemented in perf report, no change to record or anywhere
    else.
    
    This adds the basic code to report:
    
    - add a new "branch" option to the -g option parser to enable this mode
    - when the flag is set include the LBR into the callstack in machine.c.
    
    The rest of the history code is unchanged and doesn't know the
    difference between LBR entry and normal call entry.
    
    - detect overlaps with the callchain
    - remove small loop duplicates in the LBR
    
    Current limitations:
    
    - The LBR flags (mispredict etc.) are not shown in the history
    and LBR entries have no special marker.
    - It would be nice if annotate marked the LBR entries somehow
    (e.g. with arrows)
    
    v2: Various fixes.
    v3: Merge further patches into this one. Fix white space.
    v4: Improve manpage. Address review feedback.
    v5: Rename functions. Better error message without -g. Fix crash without
        -b.
    v6: Rebase
    v7: Rebase. Use NO_ENTRY in memset.
    v8: Port to latest tip. Move add_callchain_ip to separate
        patch. Skip initial entries in callchain. Minor cleanups.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-3-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 3f158474c892..dbc08cf5f970 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -63,6 +63,7 @@ struct callchain_param {
 	sort_chain_func_t	sort;
 	enum chain_order	order;
 	enum chain_key		key;
+	bool			branch_callstack;
 };
 
 extern struct callchain_param callchain_param;

commit 23f0981bbd89fcc1496d0490ec39ca7c91599e32
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:24 2014 -0800

    perf callchain: Enable printing the srcline in the history
    
    For lbr-as-callgraph we need to see the line number in the history,
    because many LBR entries can be in a single function, and just
    showing the same function name many times is not useful.
    
    When the history code is configured to sort by address, also try to
    resolve the address to a file:srcline and display this in the browser.
    If that doesn't work still display the address.
    
    This can be also useful without LBRs for understanding which call in a large
    function (or in which inlined function) called something else.
    
    Contains fixes from Namhyung Kim
    
    v2: Refactor code into common function
    v3: Fix GTK build
    v4: Rebase
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-7-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 3e1ed15d11f1..3f158474c892 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -70,6 +70,7 @@ extern struct callchain_param callchain_param;
 struct callchain_list {
 	u64			ip;
 	struct map_symbol	ms;
+	char		       *srcline;
 	struct list_head	list;
 };
 

commit 2989ccaac48f8c3da7f77101bbf98e0ea8773d83
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Nov 12 18:05:23 2014 -0800

    perf callchain: Use a common function to resolve symbol or name
    
    Refactor the duplicated code to resolve the symbol name or
    the address of a symbol into a single function.
    
    Used in next patch to add common functionality.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1415844328-4884-6-git-send-email-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 3caccc2c173c..3e1ed15d11f1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -193,4 +193,7 @@ static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 }
 #endif
 
+char *callchain_list__sym_name(struct callchain_list *cl,
+			       char *bf, size_t bfsize, bool show_dso);
+
 #endif	/* __PERF_CALLCHAIN_H */

commit bb871a9c8d68692ed2513b3f0e1c010c2ac12f44
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Oct 23 12:50:25 2014 -0300

    perf tools: A thread's machine can be found via thread->mg->machine
    
    So stop passing both machine and thread to several thread methods,
    reducing function signature length.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-ckcy19dcp1jfkmdihdjcqdn1@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 94cfefddf4db..3caccc2c173c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -184,11 +184,9 @@ static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,
 }
 
 #ifdef HAVE_SKIP_CALLCHAIN_IDX
-extern int arch_skip_callchain_idx(struct machine *machine,
-			struct thread *thread, struct ip_callchain *chain);
+extern int arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain);
 #else
-static inline int arch_skip_callchain_idx(struct machine *machine __maybe_unused,
-			struct thread *thread __maybe_unused,
+static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 			struct ip_callchain *chain __maybe_unused)
 {
 	return -1;

commit 8f651eae186f4dfb1740988623c83ba03dcf3a76
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Oct 9 16:12:24 2014 -0300

    perf callchain: Move the callchain_param extern to callchain.h
    
    It was lost in hist.h, move it to where it belongs, callchain.h, as
    there are places that gets hist.h by means of evsel.h, and since evsel.h
    is being untangled from hist.h...
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-0rg7ji1jnbm6q6gj35j37jby@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 2a1f5a46543a..94cfefddf4db 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -65,6 +65,8 @@ struct callchain_param {
 	enum chain_key		key;
 };
 
+extern struct callchain_param callchain_param;
+
 struct callchain_list {
 	u64			ip;
 	struct map_symbol	ms;

commit 2b9240cafe9780f77b257321b13c4c4d2c2d0dc8
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Sep 23 10:01:43 2014 +0900

    perf tools: Introduce perf_callchain_config()
    
    This patch adds support for following config options to ~/.perfconfig file.
    
      [call-graph]
        record-mode = dwarf
        dump-size = 8192
        print-type = fractal
        order = callee
        threshold = 0.5
        print-limit = 128
        sort-key = function
    
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Milian Wolff <mail@milianw.de>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1411434104-5307-5-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8adfbf0bab5c..2a1f5a46543a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -170,6 +170,7 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 extern const char record_callchain_help[];
 int parse_callchain_record_opt(const char *arg);
 int parse_callchain_report_opt(const char *arg);
+int perf_callchain_config(const char *var, const char *value);
 
 static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,
 					     struct callchain_cursor *src)

commit f7f084f4d3c29b0f9877a32fc6e2feacd47695b9
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Sep 23 10:01:42 2014 +0900

    perf callchain: Move some parser functions to callchain.c
    
    And rename record_callchain_parse() to parse_callchain_record_opt() in
    accordance to parse_callchain_report_opt().
    
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Milian Wolff <mail@milianw.de>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1411434104-5307-4-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 819ae4f61e08..8adfbf0bab5c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -157,7 +157,6 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 struct option;
 struct hist_entry;
 
-int record_parse_callchain(const char *arg);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 
@@ -169,6 +168,7 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 			bool hide_unresolved);
 
 extern const char record_callchain_help[];
+int parse_callchain_record_opt(const char *arg);
 int parse_callchain_report_opt(const char *arg);
 
 static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,

commit 72a128aa083a7f4cc4f800718aaae05d9c698e26
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Sep 23 10:01:41 2014 +0900

    perf tools: Move callchain config from record_opts to callchain_param
    
    So that all callchain config parameters can be read/written to a single
    place.  It's a preparation to consolidate handling of all callchain
    options.
    
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Milian Wolff <mail@milianw.de>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1411434104-5307-3-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index da43619d6173..819ae4f61e08 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -54,6 +54,9 @@ enum chain_key {
 };
 
 struct callchain_param {
+	bool			enabled;
+	enum perf_call_graph_mode record_mode;
+	u32			dump_size;
 	enum chain_mode 	mode;
 	u32			print_limit;
 	double			min_percent;
@@ -154,7 +157,7 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 struct option;
 struct hist_entry;
 
-int record_parse_callchain(const char *arg, struct record_opts *opts);
+int record_parse_callchain(const char *arg);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 

commit a60335ba32981db5bc057b35782644e9e2436407
Author: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
Date:   Wed Jun 25 08:49:03 2014 -0700

    perf tools powerpc: Adjust callchain based on DWARF debug info
    
    When saving the callchain on Power, the kernel conservatively saves excess
    entries in the callchain. A few of these entries are needed in some cases
    but not others. We should use the DWARF debug information to determine
    when the entries are  needed.
    
    Eg: the value in the link register (LR) is needed only when it holds the
    return address of a function. At other times it must be ignored.
    
    If the unnecessary entries are not ignored, we end up with duplicate arcs
    in the call-graphs.
    
    Use the DWARF debug information to determine if any callchain entries
    should be ignored when building call-graphs.
    
    Callgraph before the patch:
    
        14.67%          2234  sprintft  libc-2.18.so       [.] __random
                |
                --- __random
                   |
                   |--61.12%-- __random
                   |          |
                   |          |--97.15%-- rand
                   |          |          do_my_sprintf
                   |          |          main
                   |          |          generic_start_main.isra.0
                   |          |          __libc_start_main
                   |          |          0x0
                   |          |
                   |           --2.85%-- do_my_sprintf
                   |                     main
                   |                     generic_start_main.isra.0
                   |                     __libc_start_main
                   |                     0x0
                   |
                    --38.88%-- rand
                              |
                              |--94.01%-- rand
                              |          do_my_sprintf
                              |          main
                              |          generic_start_main.isra.0
                              |          __libc_start_main
                              |          0x0
                              |
                               --5.99%-- do_my_sprintf
                                         main
                                         generic_start_main.isra.0
                                         __libc_start_main
                                         0x0
    
    Callgraph after the patch:
    
        14.67%          2234  sprintft  libc-2.18.so       [.] __random
                |
                --- __random
                   |
                   |--95.93%-- rand
                   |          do_my_sprintf
                   |          main
                   |          generic_start_main.isra.0
                   |          __libc_start_main
                   |          0x0
                   |
                    --4.07%-- do_my_sprintf
                              main
                              generic_start_main.isra.0
                              __libc_start_main
                              0x0
    
    TODO:   For split-debug info objects like glibc, we can only determine
            the call-frame-address only when both .eh_frame and .debug_info
            sections are available. We should be able to determin the CFA
            even without the .eh_frame section.
    
    Fix suggested by Anton Blanchard.
    
    Thanks to valuable input on DWARF debug information from Ulrich Weigand.
    
    Reported-by: Maynard Johnson <maynard@us.ibm.com>
    Tested-by: Maynard Johnson <maynard@us.ibm.com>
    Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/20140625154903.GA29607@us.ibm.com
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8f84423a75da..da43619d6173 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -176,4 +176,17 @@ static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,
 	dest->first = src->curr;
 	dest->nr -= src->pos;
 }
+
+#ifdef HAVE_SKIP_CALLCHAIN_IDX
+extern int arch_skip_callchain_idx(struct machine *machine,
+			struct thread *thread, struct ip_callchain *chain);
+#else
+static inline int arch_skip_callchain_idx(struct machine *machine __maybe_unused,
+			struct thread *thread __maybe_unused,
+			struct ip_callchain *chain __maybe_unused)
+{
+	return -1;
+}
+#endif
+
 #endif	/* __PERF_CALLCHAIN_H */

commit be1f13e30862ab6b0fffaecd556856a965cefa0c
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Mon Sep 10 13:38:00 2012 +0900

    perf callchain: Add callchain_cursor_snapshot()
    
    The callchain_cursor_snapshot() is for saving current status of the
    callchain.  It'll be used to accumulate callchain information for each node.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arun Sharma <asharma@fb.com>
    Tested-by: Rodrigo Campos <rodrigo@sdfg.com.ar>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/1401335910-16832-9-git-send-email-namhyung@kernel.org
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 24a53d562d0a..8f84423a75da 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -167,4 +167,13 @@ int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *
 
 extern const char record_callchain_help[];
 int parse_callchain_report_opt(const char *arg);
+
+static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,
+					     struct callchain_cursor *src)
+{
+	*dest = *src;
+
+	dest->first = src->curr;
+	dest->nr -= src->pos;
+}
 #endif	/* __PERF_CALLCHAIN_H */

commit c7405d85d7a354b8ba49e2db7c4b027e6cb997c1
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Oct 31 13:58:30 2013 +0900

    perf tools: Update cpumode for each cumulative entry
    
    The cpumode and level in struct addr_localtion was set for a sample
    and but updated as cumulative callchains were added.  This led to have
    non-matching symbol and cpumode in the output.
    
    Update it accordingly based on the fact whether the map is a part of
    the kernel or not.  This is a reverse of what thread__find_addr_map()
    does.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arun Sharma <asharma@fb.com>
    Tested-by: Rodrigo Campos <rodrigo@sdfg.com.ar>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/1401335910-16832-7-git-send-email-namhyung@kernel.org
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index bde2b0cc24cf..24a53d562d0a 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -162,6 +162,8 @@ int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent
 			      struct perf_evsel *evsel, struct addr_location *al,
 			      int max_stack);
 int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);
+int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *node,
+			bool hide_unresolved);
 
 extern const char record_callchain_help[];
 int parse_callchain_report_opt(const char *arg);

commit 2c83bc08e305e135b954d82596864b7d024fc7fd
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon May 5 12:46:17 2014 +0200

    perf tools: Move perf_call_graph_mode enum from perf.h
    
    Into util/callchain.h header where all callchain related
    structures should be.
    
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1399293219-8732-8-git-send-email-jolsa@kernel.org
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index dda4cf8b534c..bde2b0cc24cf 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,6 +7,13 @@
 #include "event.h"
 #include "symbol.h"
 
+enum perf_call_graph_mode {
+	CALLCHAIN_NONE,
+	CALLCHAIN_FP,
+	CALLCHAIN_DWARF,
+	CALLCHAIN_MAX
+};
+
 enum chain_mode {
 	CHAIN_NONE,
 	CHAIN_FLAT,

commit cff6bb46d477383092f46682a0d12e323e4b84d2
Author: Don Zickus <dzickus@redhat.com>
Date:   Mon Apr 7 14:55:24 2014 -0400

    perf callchain: Add generic report parse callchain callback function
    
    This takes the parse_callchain_opt function and copies it into the
    callchain.c file.  Now the c2c tool can use it too without duplicating.
    
    Update perf-report to use the new routine too.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1396896924-129847-5-git-send-email-dzickus@redhat.com
    [ Adding missing braces to multiline if condition ]
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8ad97e9b119f..dda4cf8b534c 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -157,4 +157,5 @@ int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent
 int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);
 
 extern const char record_callchain_help[];
+int parse_callchain_report_opt(const char *arg);
 #endif	/* __PERF_CALLCHAIN_H */

commit 2dc9fb1a7bf013ce24dd34bc25283b60b966f015
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Jan 14 14:25:35 2014 +0900

    perf tools: Factor out sample__resolve_callchain()
    
    The report__resolve_callchain() can be shared with perf top code as it
    doesn't really depend on the perf report code.  Factor it out as
    sample__resolve_callchain().  The same goes to the hist_entry__append_
    callchain() too.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Arun Sharma <asharma@fb.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Rodrigo Campos <rodrigo@sdfg.com.ar>
    Link: http://lkml.kernel.org/r/1389677157-30513-3-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 08b25af9eea1..8ad97e9b119f 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -145,10 +145,16 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 }
 
 struct option;
+struct hist_entry;
 
 int record_parse_callchain(const char *arg, struct record_opts *opts);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 
+int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent,
+			      struct perf_evsel *evsel, struct addr_location *al,
+			      int max_stack);
+int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);
+
 extern const char record_callchain_help[];
 #endif	/* __PERF_CALLCHAIN_H */

commit b40067964f09a5b4d9e133dec225007ee0a13050
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Dec 19 14:43:45 2013 -0300

    perf tools: Rename 'perf_record_opts' to 'record_opts
    
    Reduce typing, functions use class__method convention, so unlikely to
    clash with other libraries.
    
    This actually was discussed in the "Link:" referenced message below.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/20131112113427.GA4053@ghostprotocols.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 4f7f989876ec..08b25af9eea1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -146,7 +146,7 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 
 struct option;
 
-int record_parse_callchain(const char *arg, struct perf_record_opts *opts);
+int record_parse_callchain(const char *arg, struct record_opts *opts);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 

commit aac898548d04c7bff179b79f805874b0d6f87571
Merge: 2f5e98802350 cd6571871246
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Oct 29 11:23:32 2013 +0100

    Merge branch 'perf/urgent' into perf/core
    
    Conflicts:
            tools/perf/builtin-record.c
            tools/perf/builtin-top.c
            tools/perf/util/hist.h

commit 09b0fd45ff63413df94cbd832a765076b201edbb
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Sat Oct 26 16:25:33 2013 +0200

    perf record: Split -g and --call-graph
    
    Splitting -g and --call-graph for record command, so we could use '-g'
    with no option.
    
    The '-g' option now takes NO argument and enables the configured unwind
    method, which is currently the frame pointers method.
    
    It will be possible to configure unwind method via config file in
    upcoming patches.
    
    All current '-g' arguments is overtaken by --call-graph option.
    
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Tested-by: David Ahern <dsahern@gmail.com>
    Tested-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1382797536-32303-2-git-send-email-jolsa@redhat.com
    [ reordered -g/--call-graph on --help and expanded the man page
      according to comments by David Ahern and Namhyung Kim ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 2b585bc308cf..9e99060408ae 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -147,6 +147,9 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 
 struct option;
 
+int record_parse_callchain(const char *arg, struct perf_record_opts *opts);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
+int record_callchain_opt(const struct option *opt, const char *arg, int unset);
+
 extern const char record_callchain_help[];
 #endif	/* __PERF_CALLCHAIN_H */

commit e369517ce5f796945c6af047b4e8b1d650e03458
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Fri Oct 11 14:15:36 2013 +0900

    perf callchain: Convert children list to rbtree
    
    Current collapse stage has a scalability problem which can be reproduced
    easily with a parallel kernel build.
    
    This is because it needs to traverse every children of callchains
    linearly during the collapse/merge stage.
    
    Converting it to a rbtree reduced the overhead significantly.
    
    On my 400MB perf.data file which recorded with make -j32 kernel build:
    
      $ time perf --no-pager report --stdio > /dev/null
    
    before:
      real  6m22.073s
      user  6m18.683s
      sys   0m0.706s
    
    after:
      real  0m20.780s
      user  0m19.962s
      sys   0m0.689s
    
    During the perf report the overhead on append_chain_children went down
    from 96.69% to 18.16%:
    
      -  18.16%  perf  perf                [.] append_chain_children
         - append_chain_children
            - 77.48% append_chain_children
               + 69.79% merge_chain_branch
               - 22.96% append_chain_children
                  + 67.44% merge_chain_branch
                  + 30.15% append_chain_children
                  + 2.41% callchain_append
               + 7.25% callchain_append
            + 12.26% callchain_append
            + 10.22% merge_chain_branch
      +  11.58%  perf  perf                [.] dso__find_symbol
      +   8.02%  perf  perf                [.] sort__comm_cmp
      +   5.48%  perf  libc-2.17.so        [.] malloc_consolidate
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1381468543-25334-2-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 2b585bc308cf..7bb36022377f 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -21,11 +21,11 @@ enum chain_order {
 
 struct callchain_node {
 	struct callchain_node	*parent;
-	struct list_head	siblings;
-	struct list_head	children;
 	struct list_head	val;
-	struct rb_node		rb_node; /* to sort nodes in an rbtree */
-	struct rb_root		rb_root; /* sorted tree of children */
+	struct rb_node		rb_node_in; /* to insert nodes in an rbtree */
+	struct rb_node		rb_node;    /* to sort nodes in an output tree */
+	struct rb_root		rb_root_in; /* input tree of children */
+	struct rb_root		rb_root;    /* sorted output tree of children */
 	unsigned int		val_nr;
 	u64			hit;
 	u64			children_hit;
@@ -86,13 +86,12 @@ extern __thread struct callchain_cursor callchain_cursor;
 
 static inline void callchain_init(struct callchain_root *root)
 {
-	INIT_LIST_HEAD(&root->node.siblings);
-	INIT_LIST_HEAD(&root->node.children);
 	INIT_LIST_HEAD(&root->node.val);
 
 	root->node.parent = NULL;
 	root->node.hit = 0;
 	root->node.children_hit = 0;
+	root->node.rb_root_in = RB_ROOT;
 	root->max_depth = 0;
 }
 

commit 07940293ba7a43070cdebda952b0e6025d80a383
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Aug 27 11:23:05 2013 +0300

    perf callchain: Remove unnecessary validation
    
    Now that the sample parsing correctly checks data sizes there is no
    reason for it to be done again for callchains.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1377591794-30553-4-git-send-email-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 812d5a0ff2bc..2b585bc308cf 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -109,11 +109,6 @@ int callchain_append(struct callchain_root *root,
 int callchain_merge(struct callchain_cursor *cursor,
 		    struct callchain_root *dst, struct callchain_root *src);
 
-struct ip_callchain;
-union perf_event;
-
-bool ip_callchain__valid(struct ip_callchain *chain,
-			 const union perf_event *event);
 /*
  * Initialize a cursor before adding entries inside, but keep
  * the previously allocated entries as a cache.

commit 99571ab3d9b342a717295a9c7e2b4495ee19e32a
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Jul 18 15:33:57 2013 -0700

    perf tools: Support callchain sorting based on addresses
    
    With programs with very large functions it can be useful to distinguish
    the callgraph nodes on more than just function names. So for example if
    you have multiple calls to the same function, it ends up being separate
    nodes in the chain.
    
    This patch adds a new key field to the callgraph options, that allows
    comparing nodes on functions (as today, default) and addresses.
    
    Longer term it would be nice to also handle src lines, but that would
    need more changes and address is a reasonable proxy for it today.
    
    I right now reference the global params, as there was no simple way to
    register a params pointer.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/n/tip-0uskktybf0e7wrnoi5e9b9it@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 3ee9f67d5af0..812d5a0ff2bc 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -41,12 +41,18 @@ struct callchain_param;
 typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_root *,
 				 u64, struct callchain_param *);
 
+enum chain_key {
+	CCKEY_FUNCTION,
+	CCKEY_ADDRESS
+};
+
 struct callchain_param {
 	enum chain_mode 	mode;
 	u32			print_limit;
 	double			min_percent;
 	sort_chain_func_t	sort;
 	enum chain_order	order;
+	enum chain_key		key;
 };
 
 struct callchain_list {

commit 75d9a10854db6aab2400cd6a844c392107be4c64
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Dec 11 16:46:05 2012 -0300

    perf record: Export the callchain parsing routine and help
    
    Will be used by perf top, that will first setup the symbol system to
    deal with callchains and then call these routines to ask the kernel
    for callchains.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-jg0dh8rmlx7x11e7u7mnasvd@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index eb340571e7d6..3ee9f67d5af0 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -143,4 +143,9 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 	cursor->curr = cursor->curr->next;
 	cursor->pos++;
 }
+
+struct option;
+
+int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
+extern const char record_callchain_help[];
 #endif	/* __PERF_CALLCHAIN_H */

commit 3fd44cd40c920cb26c2697cea59442cd40cc8227
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Jul 18 01:20:59 2012 +0900

    tools: perf: Fix typo in tools/perf
    
    Correct spelling typo in tools/perf.
    
    Signed-off-by: Masanari iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 3bdb407f9cd9..eb340571e7d6 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -58,7 +58,7 @@ struct callchain_list {
 /*
  * A callchain cursor is a single linked list that
  * let one feed a callchain progressively.
- * It keeps persitent allocated entries to minimize
+ * It keeps persistent allocated entries to minimize
  * allocations.
  */
 struct callchain_cursor_node {

commit 472606458f3e1ced5fe3cc5f04e90a6b5a4732cf
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Thu May 31 14:43:26 2012 +0900

    perf callchain: Make callchain cursors TLS
    
    perf top -G has a race on callchain cursor between main thread and
    display thread. Since the callchain cursors are used locally make them
    thread-local data would solve the problem.
    
    Signed-off-by: Namhyung Kim <namhyung.kim@lge.com>
    Reported-by: Sunjin Yang <fan4326@gmail.com>
    Suggested-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Sunjin Yang <fan4326@gmail.com>
    Link: http://lkml.kernel.org/r/1338443007-24857-1-git-send-email-namhyung.kim@lge.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 7f9c0f1ae3a9..3bdb407f9cd9 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -76,6 +76,8 @@ struct callchain_cursor {
 	struct callchain_cursor_node	*curr;
 };
 
+extern __thread struct callchain_cursor callchain_cursor;
+
 static inline void callchain_init(struct callchain_root *root)
 {
 	INIT_LIST_HEAD(&root->node.siblings);

commit d20deb64e0490ee9442b5181bc08a62d2cadcb90
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Nov 25 08:19:45 2011 -0200

    perf tools: Pass tool context in the the perf_event_ops functions
    
    So that we don't need to have that many globals.
    
    Next steps will remove the 'session' pointer, that in most cases is
    not needed.
    
    Then we can rename perf_event_ops to 'perf_tool' that better describes
    this class hierarchy.
    
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-wp4djox7x6w1i2bab1pt4xxp@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 9b4ff16cac96..7f9c0f1ae3a9 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -101,6 +101,9 @@ int callchain_append(struct callchain_root *root,
 int callchain_merge(struct callchain_cursor *cursor,
 		    struct callchain_root *dst, struct callchain_root *src);
 
+struct ip_callchain;
+union perf_event;
+
 bool ip_callchain__valid(struct ip_callchain *chain,
 			 const union perf_event *event);
 /*

commit d797fdc5c5c245fbb05f553e68cb95d962fbdd01
Author: Sam Liao <phyomh@gmail.com>
Date:   Tue Jun 7 23:49:46 2011 +0800

    perf tools: Add inverted call graph report support.
    
    Add "caller/callee" option to support inverted butterfly report,
    in the inverted report (with caller option), the call graph start
    from the callee's ancestor. Users can use such view to catch system's
    performance bottleneck from a sysprof like view. Using this option
    with specified sort order like pid gives us high level view of call
    graph statistics.
    
    Also add "-G" alias for inverted call graph.
    
    Signed-off-by: Sam Liao <phyomh@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: David Ahern <dsahern@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1a79df9f739f..9b4ff16cac96 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -14,6 +14,11 @@ enum chain_mode {
 	CHAIN_GRAPH_REL
 };
 
+enum chain_order {
+	ORDER_CALLER,
+	ORDER_CALLEE
+};
+
 struct callchain_node {
 	struct callchain_node	*parent;
 	struct list_head	siblings;
@@ -41,6 +46,7 @@ struct callchain_param {
 	u32			print_limit;
 	double			min_percent;
 	sort_chain_func_t	sort;
+	enum chain_order	order;
 };
 
 struct callchain_list {

commit 8115d60c323dd9931b95221c0a392aeddc1d6ef3
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sat Jan 29 14:01:45 2011 -0200

    perf tools: Kill event_t typedef, use 'union perf_event' instead
    
    And move the event_t methods to the perf_event__ too.
    
    No code changes, just namespace consistency.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 67137256a1cd..1a79df9f739f 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -95,8 +95,8 @@ int callchain_append(struct callchain_root *root,
 int callchain_merge(struct callchain_cursor *cursor,
 		    struct callchain_root *dst, struct callchain_root *src);
 
-bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);
-
+bool ip_callchain__valid(struct ip_callchain *chain,
+			 const union perf_event *event);
 /*
  * Initialize a cursor before adding entries inside, but keep
  * the previously allocated entries as a cache.

commit 529363b76929beb85b81439c61063130af046a21
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Jan 14 04:52:01 2011 +0100

    perf callchain: Don't give arbitrary gender to callchain tree nodes
    
    Some little callchain tree nodes shyly asked me if they can have
    sisters.
    
    How cute!
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1294977121-5700-5-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 2bb5403010d2..67137256a1cd 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -16,7 +16,7 @@ enum chain_mode {
 
 struct callchain_node {
 	struct callchain_node	*parent;
-	struct list_head	brothers;
+	struct list_head	siblings;
 	struct list_head	children;
 	struct list_head	val;
 	struct rb_node		rb_node; /* to sort nodes in an rbtree */
@@ -72,7 +72,7 @@ struct callchain_cursor {
 
 static inline void callchain_init(struct callchain_root *root)
 {
-	INIT_LIST_HEAD(&root->node.brothers);
+	INIT_LIST_HEAD(&root->node.siblings);
 	INIT_LIST_HEAD(&root->node.children);
 	INIT_LIST_HEAD(&root->node.val);
 

commit 16537f1355017a285b904bfb6bf767464293e69c
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Jan 14 04:52:00 2011 +0100

    perf callchain: Rename register_callchain_param into callchain_register_param
    
    To make the callchain API naming more consistent.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1294977121-5700-4-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 07f71e3e0a71..2bb5403010d2 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -87,7 +87,7 @@ static inline u64 callchain_cumul_hits(struct callchain_node *node)
 	return node->hit + node->children_hit;
 }
 
-int register_callchain_param(struct callchain_param *param);
+int callchain_register_param(struct callchain_param *param);
 int callchain_append(struct callchain_root *root,
 		     struct callchain_cursor *cursor,
 		     u64 period);

commit f08c3154ac439c4b5762a40107d84e839e08fbc5
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Jan 14 04:51:59 2011 +0100

    perf callchain: Rename cumul_hits into callchain_cumul_hits
    
    That makes the callchain API naming more consistent and
    reduce potential naming clashes.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1294977121-5700-3-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index d74a19af4a44..07f71e3e0a71 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -82,7 +82,7 @@ static inline void callchain_init(struct callchain_root *root)
 	root->max_depth = 0;
 }
 
-static inline u64 cumul_hits(struct callchain_node *node)
+static inline u64 callchain_cumul_hits(struct callchain_node *node)
 {
 	return node->hit + node->children_hit;
 }

commit 1b3a0e9592ebf174af934b3908a2bf6a6fa86169
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Jan 14 04:51:58 2011 +0100

    perf callchain: Feed callchains into a cursor
    
    The callchains are fed with an array of a fixed size.
    As a result we iterate over each callchains three times:
    
    - 1st to resolve symbols
    - 2nd to filter out context boundaries
    - 3rd for the insertion into the tree
    
    This also involves some pairs of memory allocation/deallocation
    everytime we insert a callchain, for the filtered out array of
    addresses and for the array of symbols that comes along.
    
    Instead, feed the callchains through a linked list with persistent
    allocations. It brings several pros like:
    
    - Merge the 1st and 2nd iterations in one. That was possible before
    but in a way that would involve allocating an array slightly taller
    than necessary because we don't know in advance the number of context
    boundaries to filter out.
    
    - Much lesser allocations/deallocations. The linked list keeps
    persistent empty entries for the next usages and is extendable at
    will.
    
    - Makes it easier for multiple sources of callchains to feed a
    stacktrace together. This is deemed to pave the way for cfi based
    callchains wherein traditional frame pointer based kernel
    stacktraces will precede cfi based user ones, producing an overall
    callchain which size is hardly predictable. This requirement
    makes the static array obsolete and makes a linked list based
    iterator a much more flexible fit.
    
    Basic testing on a big perf file containing callchains (~ 176 MB)
    has shown a throughput gain of about 11% with perf report.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1294977121-5700-2-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index c15fb8c24ad2..d74a19af4a44 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -49,6 +49,27 @@ struct callchain_list {
 	struct list_head	list;
 };
 
+/*
+ * A callchain cursor is a single linked list that
+ * let one feed a callchain progressively.
+ * It keeps persitent allocated entries to minimize
+ * allocations.
+ */
+struct callchain_cursor_node {
+	u64				ip;
+	struct map			*map;
+	struct symbol			*sym;
+	struct callchain_cursor_node	*next;
+};
+
+struct callchain_cursor {
+	u64				nr;
+	struct callchain_cursor_node	*first;
+	struct callchain_cursor_node	**last;
+	u64				pos;
+	struct callchain_cursor_node	*curr;
+};
+
 static inline void callchain_init(struct callchain_root *root)
 {
 	INIT_LIST_HEAD(&root->node.brothers);
@@ -67,9 +88,48 @@ static inline u64 cumul_hits(struct callchain_node *node)
 }
 
 int register_callchain_param(struct callchain_param *param);
-int callchain_append(struct callchain_root *root, struct ip_callchain *chain,
-		     struct map_symbol *syms, u64 period);
-int callchain_merge(struct callchain_root *dst, struct callchain_root *src);
+int callchain_append(struct callchain_root *root,
+		     struct callchain_cursor *cursor,
+		     u64 period);
+
+int callchain_merge(struct callchain_cursor *cursor,
+		    struct callchain_root *dst, struct callchain_root *src);
 
 bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);
+
+/*
+ * Initialize a cursor before adding entries inside, but keep
+ * the previously allocated entries as a cache.
+ */
+static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
+{
+	cursor->nr = 0;
+	cursor->last = &cursor->first;
+}
+
+int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
+			    struct map *map, struct symbol *sym);
+
+/* Close a cursor writing session. Initialize for the reader */
+static inline void callchain_cursor_commit(struct callchain_cursor *cursor)
+{
+	cursor->curr = cursor->first;
+	cursor->pos = 0;
+}
+
+/* Cursor reading iteration helpers */
+static inline struct callchain_cursor_node *
+callchain_cursor_current(struct callchain_cursor *cursor)
+{
+	if (cursor->pos == cursor->nr)
+		return NULL;
+
+	return cursor->curr;
+}
+
+static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
+{
+	cursor->curr = cursor->curr->next;
+	cursor->pos++;
+}
 #endif	/* __PERF_CALLCHAIN_H */

commit 98ee74a75ca0f047e75400afa712f7bf08268b8e
Merge: 7de5d895b202 5225c45899e8
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Aug 27 02:28:40 2010 +0200

    Merge branch 'perf/urgent' into perf/core
    
    Conflicts:
            tools/perf/util/callchain.h
    
    Merge reason:
            Fix a non-trivial conflict with latest fixes

commit 5225c45899e872383ca39f5533d28ec63c54b39e
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Aug 22 04:29:17 2010 +0200

    perf: Initialize callchains roots's childen hits
    
    Each histogram entry has a callchain root that stores the
    callchain samples. However we forgot to initialize the
    tracking of children hits of these roots, which then got
    random values on their creation.
    
    The root children hits is multiplied by the minimum percentage
    of hits provided by the user, and the result becomes the minimum
    hits expected from children branches. If the random value due
    to the uninitialization is big enough, then this minimum number
    of hits can be huge and eventually filter every children branches.
    
    The end result was invisible callchains. All we need to
    fix this is to initialize the children hits of the root.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: 2.6.32.x-2.6.35.y <stable@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 624a96c636fd..6de4313924fb 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -50,6 +50,7 @@ static inline void callchain_init(struct callchain_node *node)
 	INIT_LIST_HEAD(&node->children);
 	INIT_LIST_HEAD(&node->val);
 
+	node->children_hit = 0;
 	node->parent = NULL;
 	node->hit = 0;
 }

commit 612d4fd7d0c4a866a531099d4cdd0424c1058321
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Aug 22 21:10:35 2010 +0200

    perf: Support for callchains merge
    
    If we sort the histograms by comm, which is the default,
    we need to merge some of them, typically different thread
    histograms of a same process, or just same comm. But during
    this merge, we forgot to merge callchains.
    
    So imagine we have three threads (tids: 1000, 1001, 1002) that
    belong to comm "foo".
    
    tid 1000 got 100 events
    tid 1001 got 10 events
    tid 1002 got 3 events
    
    Once we merge these histograms to get a per comm result, we'll
    finally get:
    
    "foo" got 113 events
    
    The problem is if we merge 1000 and 1001 histograms into 1002, then
    the end merge result, wrt callchains, will be only callchains that
    belong to 1002.
    This is because we haven't handled callchains in the merge. Only those
    from one of the threads inside a common comm survive.
    
    It means during this merge, we can lose a lot of callchains.
    
    Fix this by implementing callchains merge and apply it on histograms
    that collapse.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 85b50fbeae52..51a8f2b600bd 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -68,6 +68,7 @@ static inline u64 cumul_hits(struct callchain_node *node)
 int register_callchain_param(struct callchain_param *param);
 int callchain_append(struct callchain_root *root, struct ip_callchain *chain,
 		     struct map_symbol *syms, u64 period);
+int callchain_merge(struct callchain_root *dst, struct callchain_root *src);
 
 bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);
 #endif	/* __PERF_CALLCHAIN_H */

commit 6cb8e56161c4103af9178ea45ba61ddbde02969a
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Aug 22 20:18:01 2010 +0200

    perf: Rename append_callchain into callchain_append
    
    Do that to start a consistant callchain API namespace.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 9b93a38e88ec..85b50fbeae52 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -66,8 +66,8 @@ static inline u64 cumul_hits(struct callchain_node *node)
 }
 
 int register_callchain_param(struct callchain_param *param);
-int append_chain(struct callchain_root *root, struct ip_callchain *chain,
-		 struct map_symbol *syms, u64 period);
+int callchain_append(struct callchain_root *root, struct ip_callchain *chain,
+		     struct map_symbol *syms, u64 period);
 
 bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);
 #endif	/* __PERF_CALLCHAIN_H */

commit d2009c5130b627d3efccae8ed36cd43450c8486d
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Aug 22 20:05:22 2010 +0200

    perf: Keep track of the max depth of a callchain
    
    In order to implement callchains collapsing, we need to keep
    track of the maximum depth in a histogram tree of callchains.
    This way we'll avoid allocating an arbitrary temporary buffer
    size on callchain merge time.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 624a96c636fd..9b93a38e88ec 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -26,9 +26,14 @@ struct callchain_node {
 	u64			children_hit;
 };
 
+struct callchain_root {
+	u64			max_depth;
+	struct callchain_node	node;
+};
+
 struct callchain_param;
 
-typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_node *,
+typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_root *,
 				 u64, struct callchain_param *);
 
 struct callchain_param {
@@ -44,14 +49,15 @@ struct callchain_list {
 	struct list_head	list;
 };
 
-static inline void callchain_init(struct callchain_node *node)
+static inline void callchain_init(struct callchain_root *root)
 {
-	INIT_LIST_HEAD(&node->brothers);
-	INIT_LIST_HEAD(&node->children);
-	INIT_LIST_HEAD(&node->val);
+	INIT_LIST_HEAD(&root->node.brothers);
+	INIT_LIST_HEAD(&root->node.children);
+	INIT_LIST_HEAD(&root->node.val);
 
-	node->parent = NULL;
-	node->hit = 0;
+	root->node.parent = NULL;
+	root->node.hit = 0;
+	root->max_depth = 0;
 }
 
 static inline u64 cumul_hits(struct callchain_node *node)
@@ -60,7 +66,7 @@ static inline u64 cumul_hits(struct callchain_node *node)
 }
 
 int register_callchain_param(struct callchain_param *param);
-int append_chain(struct callchain_node *root, struct ip_callchain *chain,
+int append_chain(struct callchain_root *root, struct ip_callchain *chain,
 		 struct map_symbol *syms, u64 period);
 
 bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);

commit 9dcdbf7a33d9018ac5d45debcf261be648bdd56a
Merge: cc5edb0eb9ce cd5b8f8755a8
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jul 21 21:43:03 2010 +0200

    Merge branch 'linus' into perf/core
    
    Merge reason: Pick up the latest perf fixes.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 108553e1f3c45a92d23681a378ad9e4c3230eebc
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jul 8 03:41:46 2010 +0200

    perf: Sync callchains with period based hits
    
    Hists have their hits increased by the event period. And this
    period based counting is the foundation of all the stats in
    perf report.
    
    But callchains still use the raw number of hits, without taking
    the period into account. So when we compute the percentage,
    absolute based percentages are totally broken, and relative ones
    too in the first parent level. Because we pass the number of events
    muliplied by their period as the total number of hits to the
    callchain filtering, while callchains expect this number to be
    the number of raw hits.
    
    perf report -g graph was simply not working, showing no graph unless
    the min percent was zero. And even there the percentage of the
    branches was always 0. And may be fractal filtering was broken on
    the first branch level too.
    
    flat also was broken, but it was hidden because of other breakages.
    
    Anyway fix this by counting using periods on callchains.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 22dbaec003d5..f2e9ee164bd8 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -61,7 +61,7 @@ static inline u64 cumul_hits(struct callchain_node *node)
 
 int register_callchain_param(struct callchain_param *param);
 int append_chain(struct callchain_node *root, struct ip_callchain *chain,
-		 struct map_symbol *syms);
+		 struct map_symbol *syms, u64 period);
 
 bool ip_callchain__valid(struct ip_callchain *chain, event_t *event);
 #endif	/* __PERF_CALLCHAIN_H */

commit 97aa1052739c6a06cb6b0467dbf410613d20bc97
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jul 8 06:06:17 2010 +0200

    perf: Resurrect flat callchains
    
    Initialize the callchain radix tree root correctly.
    
    When we walk through the parents, we must stop after the root, but
    since it wasn't well initialized, its parent pointer was random.
    
    Also the number of hits was random because uninitialized, hence it
    was part of the callchain while the root doesn't contain anything.
    
    This fixes segfaults and percentages followed by empty callchains
    while running:
    
            perf report -g flat
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: 2.6.31.x-2.6.34.x <stable@kernel.org>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1ca73e4a2723..22dbaec003d5 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -49,6 +49,9 @@ static inline void callchain_init(struct callchain_node *node)
 	INIT_LIST_HEAD(&node->brothers);
 	INIT_LIST_HEAD(&node->children);
 	INIT_LIST_HEAD(&node->val);
+
+	node->parent = NULL;
+	node->hit = 0;
 }
 
 static inline u64 cumul_hits(struct callchain_node *node)

commit 41a37e20178b081193b08b228030d8f562bfee62
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jun 4 08:02:07 2010 -0300

    perf tools: Make event__preprocess_sample parse the sample
    
    Simplifying the tools that were using both in sequence and allowing
    upcoming simplifications, such as Arun's patch to sort by cpus.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1ca73e4a2723..809850fb75fb 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -60,5 +60,5 @@ int register_callchain_param(struct callchain_param *param);
 int append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		 struct map_symbol *syms);
 
-bool ip_callchain__valid(struct ip_callchain *chain, event_t *event);
+bool ip_callchain__valid(struct ip_callchain *chain, const event_t *event);
 #endif	/* __PERF_CALLCHAIN_H */

commit b36f19d572151abb987ce308a3e066b977a2146f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu May 20 12:15:33 2010 -0300

    perf annotate: Use build-ids to find the right DSO
    
    We were still using the pathname found on the MMAP event, that could not
    be the one we used when recording, so use the build-id cache for that,
    only falling back to use the pathname in the MMAP event if no build-ids
    are available.
    
    With this we now also are able to do secure, seamless offline annotation.
    
    Example:
    
    [root@doppio linux-2.6-tip]# perf report -g none -v 2> /dev/null | head -10
         8.12%     Xorg  /usr/lib64/libpixman-1.so.0.14.0       0x0000000000026d02 B [.] pixman_rasterize_edges
         4.68%  firefox  /usr/lib64/xulrunner-1.9.1/libxul.so   0x00000000005dbdba B [.] 0x000000005dbdba
         3.70%  swapper  /lib/modules/2.6.34-rc6/build/vmlinux  0xffffffff81022cea ! [k] read_hpet
         2.96%     init  /lib/modules/2.6.34-rc6/build/vmlinux  0xffffffff81022cea ! [k] read_hpet
         2.73%  swapper  /lib/modules/2.6.34-rc6/build/vmlinux  0xffffffff8100a738 ! [k] mwait_idle_with_hints
    [root@doppio linux-2.6-tip]# perf annotate -v pixman_rasterize_edges 2>&1 | grep Executing
    Executing: objdump --start-address=0x000000371ce26670 --stop-address=0x000000371ce2709f -dS /root/.debug/.build-id/bd/6ac5199137aaeb279f864717d8d061477466c1|grep -v /root/.debug/.build-id/bd/6ac5199137aaeb279f864717d8d061477466c1|expand
    [root@doppio linux-2.6-tip]# perf buildid-list | grep libpixman-1.so.0.14.0
    bd6ac5199137aaeb279f864717d8d061477466c1 /usr/lib64/libpixman-1.so.0.14.0
    [root@doppio linux-2.6-tip]#
    
    Reported-by: Stephane Eranian <eranian@google.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 1cba1f5504e7..1ca73e4a2723 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -5,7 +5,6 @@
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include "event.h"
-#include "util.h"
 #include "symbol.h"
 
 enum chain_mode {

commit 232a5c948da5e23dff27e48180abf4a4238f7602
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun May 9 20:28:10 2010 -0300

    perf report: Allow limiting the number of entries to print in callchains
    
    Works by adding a third parameter to the '-g' argument, after the graph
    type and minimum percentage, for example:
    
    [root@doppio linux-2.6-tip]# perf report -g fractal,0.5,2
    
    Will show only the first two symbols where at least 0.5% of the samples
    took place.
    
    All the other symbols that don't fall outside these constraints will be
    put together in the last entry, prefixed with "[...]" and the total
    percentage for them.
    
    Suggested-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 0f4da093cbd8..1cba1f5504e7 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -34,6 +34,7 @@ typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_node *,
 
 struct callchain_param {
 	enum chain_mode 	mode;
+	u32			print_limit;
 	double			min_percent;
 	sort_chain_func_t	sort;
 };

commit 139633c6a43781cd44798165b0472a34bf53a1e8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun May 9 11:47:13 2010 -0300

    perf callchain: Move validate_callchain to callchain lib
    
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 8a7e8bbd0fda..0f4da093cbd8 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -4,6 +4,7 @@
 #include "../perf.h"
 #include <linux/list.h>
 #include <linux/rbtree.h>
+#include "event.h"
 #include "util.h"
 #include "symbol.h"
 
@@ -58,4 +59,6 @@ static inline u64 cumul_hits(struct callchain_node *node)
 int register_callchain_param(struct callchain_param *param);
 int append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		 struct map_symbol *syms);
+
+bool ip_callchain__valid(struct ip_callchain *chain, event_t *event);
 #endif	/* __PERF_CALLCHAIN_H */

commit b3c9ac0846c654dea4df095999ee202e8b4cb253
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Mar 24 16:40:18 2010 -0300

    perf callchains: Store the map together with the symbol
    
    We need this to know where a symbol in a callchain came from,
    for various reasons, among them precise annotation from a
    TUI/GUI tool.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frdric Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1269459619-982-5-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index bbd76da27f22..8a7e8bbd0fda 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -39,7 +39,7 @@ struct callchain_param {
 
 struct callchain_list {
 	u64			ip;
-	struct symbol		*sym;
+	struct map_symbol	ms;
 	struct list_head	list;
 };
 
@@ -57,5 +57,5 @@ static inline u64 cumul_hits(struct callchain_node *node)
 
 int register_callchain_param(struct callchain_param *param);
 int append_chain(struct callchain_node *root, struct ip_callchain *chain,
-		 struct symbol **syms);
+		 struct map_symbol *syms);
 #endif	/* __PERF_CALLCHAIN_H */

commit 301fde27c7fcd0380b02b175d547e894ff65d78a
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Mon Mar 22 13:09:33 2010 -0300

    perf: Fix orphan callchain branches
    
    Callchains have markers inside their capture to tell we
    enter a context (kernel, user, ...).
    
    Those are not displayed in the callchains but they are
    incidentally an active part of the radix tree where
    callchains are stored, just like any other address.
    
    If we have the two following callchains:
    
    addr1 -> addr2 -> user context -> addr3
    addr1 -> addr2 -> user context -> addr4
    addr1 -> addr2 -> addr 5
    
    This is pretty common if addr1 and addr2 are part of an
    interrupt path, addr3 and addr4 are user addresses and
    addr5 is a kernel non interrupt path.
    
    This will be stored as follows in the tree:
    
                       addr1
                       addr2
                       /   \
                      /     addr5
                user context
                   /    \
                 addr3  addr4
    
    But we ignore the context markers in the report, hence
    the addr3 and addr4 will appear as orphan branches:
    
        |--28.30%-- hrtimer_interrupt
        |          smp_apic_timer_interrupt
        |          apic_timer_interrupt
        |          |           <------------- here, no parent!
        |          |          |
        |          |          |--11.11%-- 0x7fae7bccb875
        |          |          |
        |          |          |--11.11%-- 0xffffffffff60013b
        |          |          |
        |          |          |--11.11%-- __pthread_mutex_lock_internal
        |          |          |
        |          |          |--11.11%-- __errno_location
    
    Fix this by removing the context markers when we process the
    callchains to the tree.
    
    Reported-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    LKML-Reference: <1269274173-20328-1-git-send-email-acme@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index ad4626de4c2b..bbd76da27f22 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -56,6 +56,6 @@ static inline u64 cumul_hits(struct callchain_node *node)
 }
 
 int register_callchain_param(struct callchain_param *param);
-void append_chain(struct callchain_node *root, struct ip_callchain *chain,
-		  struct symbol **syms);
+int append_chain(struct callchain_node *root, struct ip_callchain *chain,
+		 struct symbol **syms);
 #endif	/* __PERF_CALLCHAIN_H */

commit 8b40f521cf1c9750eab0c04da9075e7484675e9c
Author: John Kacur <jkacur@redhat.com>
Date:   Thu Sep 24 18:02:18 2009 +0200

    perf tools: Protect header files with a consistent style
    
    There was a colorful mix of header guards - standardize them.
    
    Signed-off-by: John Kacur <jkacur@redhat.com>
    LKML-Reference: <alpine.LFD.2.00.0909241756530.11383@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 43cf3ea9e088..ad4626de4c2b 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -58,4 +58,4 @@ static inline u64 cumul_hits(struct callchain_node *node)
 int register_callchain_param(struct callchain_param *param);
 void append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		  struct symbol **syms);
-#endif
+#endif	/* __PERF_CALLCHAIN_H */

commit 66e274f3b8d7fc89d38997e85b900e188f8d5cc0
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Aug 12 11:07:25 2009 +0200

    perf tools: Factorize the map helpers
    
    Factorize the dso mapping helpers into a single purpose common file
    "util/map.c"
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Brice Goglin <Brice.Goglin@inria.fr>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index a926ae4f5a16..43cf3ea9e088 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -4,6 +4,7 @@
 #include "../perf.h"
 #include <linux/list.h>
 #include <linux/rbtree.h>
+#include "util.h"
 #include "symbol.h"
 
 enum chain_mode {

commit b1a88349c37624755b28ac3b3152b48f52c1f487
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat Aug 8 02:16:24 2009 +0200

    perf tools: callchain: Fix 'perf report' display to be callchain by default
    
    If we recorded with -g option to record the callchain, right now
    we require a -g option to perf report as well - and people reported
    this as unnecessary complication: the user already specified -g
    once, no need to require it a second time.
    
    So if the recording includes call-chains, display the callchain by
    default from perf report.
    
    ( The user can override this default using "-g none" option from
      perf report. )
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    LKML-Reference: <1249690585-9145-3-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index b2d128e07c88..a926ae4f5a16 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,6 +7,7 @@
 #include "symbol.h"
 
 enum chain_mode {
+	CHAIN_NONE,
 	CHAIN_FLAT,
 	CHAIN_GRAPH_ABS,
 	CHAIN_GRAPH_REL

commit 1953287bfe8afcbbd235bd6c42c9df06d52438dc
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Aug 7 07:11:05 2009 +0200

    perf tools: Fix call-chain cumul hit based sub-total (fractal mode)
    
    The callchain fractal mode builds each new total hits in a new
    branch of profiling by using the parent's hits of the current
    branch plus the hits of the children.
    
    This is wrong, the total hits of a branch should be made of the
    sum of every children hits, we must ignore the parent hits in
    this scope.
    
    This patch also fixes another mistake with the hit counting.
    
    Now the rates are correct.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 7812122bea1d..b2d128e07c88 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -21,7 +21,7 @@ struct callchain_node {
 	struct rb_root		rb_root; /* sorted tree of children */
 	unsigned int		val_nr;
 	u64			hit;
-	u64			cumul_hit; /* hit + hits of children */
+	u64			children_hit;
 };
 
 struct callchain_param;
@@ -48,6 +48,11 @@ static inline void callchain_init(struct callchain_node *node)
 	INIT_LIST_HEAD(&node->val);
 }
 
+static inline u64 cumul_hits(struct callchain_node *node)
+{
+	return node->hit + node->children_hit;
+}
+
 int register_callchain_param(struct callchain_param *param);
 void append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		  struct symbol **syms);

commit 805d127d62472f17c7d79baa001a7651afe2fa47
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Jul 5 07:39:21 2009 +0200

    perf report: Add "Fractal" mode output - support callchains with relative overhead rate
    
    The current callchain displays the overhead rates as absolute:
    relative to the total overhead.
    
    This patch provides relative overhead percentage, in which each
    branch of the callchain tree is a independant instrumentated object.
    
    This provides a 'fractal' view of the call-chain profile: each
    sub-graph looks like a profile in itself - relative to its parent.
    
    You can produce such output by using the "fractal" mode
    that you can abbreviate via f, fr, fra, frac, etc...
    
    ./perf report -s sym -c fractal
    
    Example:
    
         8.46%  [k] copy_user_generic_string
                    |
                    |--52.01%-- generic_file_aio_read
                    |          do_sync_read
                    |          vfs_read
                    |          |
                    |          |--97.20%-- sys_pread64
                    |          |          system_call_fastpath
                    |          |          pread64
                    |          |
                    |           --2.81%-- sys_read
                    |                     system_call_fastpath
                    |                     __read
                    |
                    |--39.85%-- generic_file_buffered_write
                    |          __generic_file_aio_write_nolock
                    |          generic_file_aio_write
                    |          do_sync_write
                    |          reiserfs_file_write
                    |          vfs_write
                    |          |
                    |          |--97.05%-- sys_pwrite64
                    |          |          system_call_fastpath
                    |          |          __pwrite64
                    |          |
                    |           --2.95%-- sys_write
                    |                     system_call_fastpath
                    |                     __write_nocancel
    [...]
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    LKML-Reference: <1246772361-9960-5-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index f3e4776e7430..7812122bea1d 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -7,8 +7,9 @@
 #include "symbol.h"
 
 enum chain_mode {
-	FLAT,
-	GRAPH
+	CHAIN_FLAT,
+	CHAIN_GRAPH_ABS,
+	CHAIN_GRAPH_REL
 };
 
 struct callchain_node {
@@ -23,6 +24,17 @@ struct callchain_node {
 	u64			cumul_hit; /* hit + hits of children */
 };
 
+struct callchain_param;
+
+typedef void (*sort_chain_func_t)(struct rb_root *, struct callchain_node *,
+				 u64, struct callchain_param *);
+
+struct callchain_param {
+	enum chain_mode 	mode;
+	double			min_percent;
+	sort_chain_func_t	sort;
+};
+
 struct callchain_list {
 	u64			ip;
 	struct symbol		*sym;
@@ -36,10 +48,7 @@ static inline void callchain_init(struct callchain_node *node)
 	INIT_LIST_HEAD(&node->val);
 }
 
+int register_callchain_param(struct callchain_param *param);
 void append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		  struct symbol **syms);
-void sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node,
-		     u64 min_hit);
-void sort_chain_graph(struct rb_root *rb_root, struct callchain_node *node,
-		      u64 min_hit);
 #endif

commit c20ab37ef30f4a874cf27e84c12c73e584e6f5cc
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jul 2 20:14:33 2009 +0200

    perf_counter tools: Set the minimum percent for callchains to be displayed
    
    Callchains output may become a burden on a trace because even
    rarely hit site are exposed. This can be too much information.
    
    Let the user set a threshold as a minimum percent of hits using
    the new pattern for the -c option:
    
        -c mode,min_percent
    
    Example:
    
    $ perf report -s sym -c flat,4
    
         8.25%  [k] copy_user_generic_string
                 4.19%
                    copy_user_generic_string
                    generic_file_aio_read
                    do_sync_read
                    vfs_read
                    sys_pread64
                    system_call_fastpath
                    pread64
    
         5.39%  [k] search_by_key
         4.63%  0x00000000009e0a
         2.36%  [k] memcpy_c
    [...]
    
    $ perf report -s sym -c graph,2
    
         8.25%  [k] copy_user_generic_string
                    |
                    |--4.31%-- generic_file_aio_read
                    |          do_sync_read
                    |          vfs_read
                    |          |
                    |           --4.19%-- sys_pread64
                    |                     system_call_fastpath
                    |                     pread64
                    |
                     --3.24%-- generic_file_buffered_write
                               __generic_file_aio_write_nolock
                               generic_file_aio_write
                               do_sync_write
                               reiserfs_file_write
                               vfs_write
                               |
                                --3.14%-- sys_pwrite64
                                          system_call_fastpath
                                          __pwrite64
    
         5.39%  [k] search_by_key
                    |
                     --2.23%-- reiserfs_update_sd_size
    
         4.63%  0x00000000009e0a
    
         2.36%  [k] memcpy_c
    [...]
    
    You can also omit it and it will default to 0.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    LKML-Reference: <1246558475-10624-1-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index dfa56008d9ad..f3e4776e7430 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -38,6 +38,8 @@ static inline void callchain_init(struct callchain_node *node)
 
 void append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		  struct symbol **syms);
-void sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node);
-void sort_chain_graph(struct rb_root *rb_root, struct callchain_node *node);
+void sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node,
+		     u64 min_hit);
+void sort_chain_graph(struct rb_root *rb_root, struct callchain_node *node,
+		      u64 min_hit);
 #endif

commit 4eb3e4788b8a5e220a0aeb590f88c28850726ebe
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jul 2 17:58:21 2009 +0200

    perf report: Add support for callchain graph output
    
    Currently, the printing of callchains is done in a single
    vertical level, this is the "flat" mode:
    
    8.25%  [k] copy_user_generic_string
                 4.19%
                    copy_user_generic_string
                    generic_file_aio_read
                    do_sync_read
                    vfs_read
                    sys_pread64
                    system_call_fastpath
                    pread64
    
    This patch introduces a new "graph" mode which provides a
    hierarchical output of factorized paths recursively sorted:
    
     8.25%  [k] copy_user_generic_string
                    |
                    |--4.31%-- generic_file_aio_read
                    |          do_sync_read
                    |          vfs_read
                    |          |
                    |          |--4.19%-- sys_pread64
                    |          |          system_call_fastpath
                    |          |          pread64
                    |          |
                    |           --0.12%-- sys_read
                    |                     system_call_fastpath
                    |                     __read
                    |
                    |--3.24%-- generic_file_buffered_write
                    |          __generic_file_aio_write_nolock
                    |          generic_file_aio_write
                    |          do_sync_write
                    |          reiserfs_file_write
                    |          vfs_write
                    |          |
                    |          |--3.14%-- sys_pwrite64
                    |          |          system_call_fastpath
                    |          |          __pwrite64
                    |          |
                    |           --0.10%-- sys_write
    [...]
    
    The command line has then changed.
    
    By providing the -c option, the callchain will output in the
    flat mode by default.
    
    But you can override it:
    
        perf report -c graph
    
    or
    
        perf report -c flat
    
    You can also pass the abreviated mode:
    
        perf report -c g
    
    or
    
        perf report -c gra
    
    will both make use of the graph mode.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    LKML-Reference: <1246550301-8954-3-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index e9bd5e882f38..dfa56008d9ad 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -6,15 +6,21 @@
 #include <linux/rbtree.h>
 #include "symbol.h"
 
+enum chain_mode {
+	FLAT,
+	GRAPH
+};
 
 struct callchain_node {
 	struct callchain_node	*parent;
 	struct list_head	brothers;
 	struct list_head	children;
 	struct list_head	val;
-	struct rb_node		rb_node;
+	struct rb_node		rb_node; /* to sort nodes in an rbtree */
+	struct rb_root		rb_root; /* sorted tree of children */
 	unsigned int		val_nr;
 	u64			hit;
+	u64			cumul_hit; /* hit + hits of children */
 };
 
 struct callchain_list {
@@ -32,5 +38,6 @@ static inline void callchain_init(struct callchain_node *node)
 
 void append_chain(struct callchain_node *root, struct ip_callchain *chain,
 		  struct symbol **syms);
-void sort_chain_to_rbtree(struct rb_root *rb_root, struct callchain_node *node);
+void sort_chain_flat(struct rb_root *rb_root, struct callchain_node *node);
+void sort_chain_graph(struct rb_root *rb_root, struct callchain_node *node);
 #endif

commit 5da50258584469ddfee6545feb4eb2252a8d7e7b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Jul 1 14:46:08 2009 -0300

    perf_counter tools: Share list.h with the kernel
    
    The copy we were using came from another copy I did for the dwarves
    (pahole) package, that came from the kernel years ago.
    
    The only function that is used by the perf tools and that isn't in the
    kernel is list_del_range, that I'm leaving in the perf tools only for
    now.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <20090701174608.GA5823@ghostprotocols.net>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 0606b8fd05a1..e9bd5e882f38 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -2,7 +2,7 @@
 #define __PERF_CALLCHAIN_H
 
 #include "../perf.h"
-#include "list.h"
+#include <linux/list.h>
 #include <linux/rbtree.h>
 #include "symbol.h"
 

commit 43cbcd8acb4c992cbd22d1ec8a08c0591be5d719
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Jul 1 12:28:37 2009 -0300

    perf_counter tools: Share rbtree.with the kernel
    
    The tools/perf/util/rbtree.c copy already drifted by three
    csets:
    
     4b324126e0c6c3a5080ca3ec0981e8766ed6f1ee
     4c60117811171d867d4f27f17ea07d7419d45dae
     16c047add3ceaf0ab882e3e094d1ec904d02312d
    
    So remove the copy and use the lib/rbtree.c directly, sharing
    the source code while still generating a separate object file,
    since tools/perf uses a far more agressive -O6 switch.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <20090701152837.GG15682@ghostprotocols.net>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 251d99ecd225..0606b8fd05a1 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -3,7 +3,7 @@
 
 #include "../perf.h"
 #include "list.h"
-#include "rbtree.h"
+#include <linux/rbtree.h>
 #include "symbol.h"
 
 

commit f37a291c527c954df4da568de718ebb36b8261c0
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jul 1 12:37:06 2009 +0200

    perf_counter tools: Add more warnings and fix/annotate them
    
    Enable -Wextra. This found a few real bugs plus a number
    of signed/unsigned type mismatches/uncleanlinesses. It
    also required a few annotations
    
    All things considered it was still worth it so lets try with
    this enabled for now.
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index c942daa712e6..251d99ecd225 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -10,15 +10,15 @@
 struct callchain_node {
 	struct callchain_node	*parent;
 	struct list_head	brothers;
-	struct list_head 	children;
-	struct list_head 	val;
+	struct list_head	children;
+	struct list_head	val;
 	struct rb_node		rb_node;
-	int			val_nr;
-	int			hit;
+	unsigned int		val_nr;
+	u64			hit;
 };
 
 struct callchain_list {
-	unsigned long		ip;
+	u64			ip;
 	struct symbol		*sym;
 	struct list_head	list;
 };

commit 4424961ad6621a02c6b4c9093e801002c1bb9f65
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Jul 1 05:35:14 2009 +0200

    perf_counter tools: Resolve symbols in callchains
    
    This patch resolves the names, when possible, of each ip
    present in the callchains while using the -c option with perf
    report.
    
    Example:
    
    5.40%  [k] __d_lookup
                 5.37%
                    perf_callchain
                    perf_counter_overflow
                    intel_pmu_handle_irq
                    perf_counter_nmi_handler
                    notifier_call_chain
                    atomic_notifier_call_chain
                    notify_die
                    do_nmi
                    nmi
                    do_lookup
                    __link_path_walk
                    path_walk
                    do_path_lookup
                    user_path_at
                    sys_faccessat
                    sys_access
                    system_call_fastpath
                    0x7fb609846f77
    
                 0.01%
                    perf_callchain
                    perf_counter_overflow
                    intel_pmu_handle_irq
                    perf_counter_nmi_handler
                    notifier_call_chain
                    atomic_notifier_call_chain
                    notify_die
                    do_nmi
                    nmi
                    do_lookup
                    __link_path_walk
                    path_walk
                    do_path_lookup
                    user_path_at
                    sys_faccessat
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    LKML-Reference: <1246419315-9968-3-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index fa1cd2f71fd3..c942daa712e6 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -4,6 +4,7 @@
 #include "../perf.h"
 #include "list.h"
 #include "rbtree.h"
+#include "symbol.h"
 
 
 struct callchain_node {
@@ -18,6 +19,7 @@ struct callchain_node {
 
 struct callchain_list {
 	unsigned long		ip;
+	struct symbol		*sym;
 	struct list_head	list;
 };
 
@@ -28,6 +30,7 @@ static inline void callchain_init(struct callchain_node *node)
 	INIT_LIST_HEAD(&node->val);
 }
 
-void append_chain(struct callchain_node *root, struct ip_callchain *chain);
+void append_chain(struct callchain_node *root, struct ip_callchain *chain,
+		  struct symbol **syms);
 void sort_chain_to_rbtree(struct rb_root *rb_root, struct callchain_node *node);
 #endif

commit 8cb76d99d715741637b6d0884f389e17e9cb05d2
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Jun 26 16:28:00 2009 +0200

    perf_counter tools: Prepare a small callchain framework
    
    We plan to display the callchains depending on some user-configurable
    parameters.
    
    To gather the callchains stats from the recorded stream in a fast way,
    this patch introduces an ad hoc radix tree adapted for callchains and also
    a rbtree to sort these callchains once we have gathered every events
    from the stream.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1246026481-8314-2-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
new file mode 100644
index 000000000000..fa1cd2f71fd3
--- /dev/null
+++ b/tools/perf/util/callchain.h
@@ -0,0 +1,33 @@
+#ifndef __PERF_CALLCHAIN_H
+#define __PERF_CALLCHAIN_H
+
+#include "../perf.h"
+#include "list.h"
+#include "rbtree.h"
+
+
+struct callchain_node {
+	struct callchain_node	*parent;
+	struct list_head	brothers;
+	struct list_head 	children;
+	struct list_head 	val;
+	struct rb_node		rb_node;
+	int			val_nr;
+	int			hit;
+};
+
+struct callchain_list {
+	unsigned long		ip;
+	struct list_head	list;
+};
+
+static inline void callchain_init(struct callchain_node *node)
+{
+	INIT_LIST_HEAD(&node->brothers);
+	INIT_LIST_HEAD(&node->children);
+	INIT_LIST_HEAD(&node->val);
+}
+
+void append_chain(struct callchain_node *root, struct ip_callchain *chain);
+void sort_chain_to_rbtree(struct rb_root *rb_root, struct callchain_node *node);
+#endif
