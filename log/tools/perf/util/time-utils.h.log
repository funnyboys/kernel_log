commit b3509b6ed7a79ec49f6b64e4f3b780f259a2a468
Author: Andi Kleen <ak@linux.intel.com>
Date:   Fri Oct 11 11:21:39 2019 -0700

    perf script: Fix --reltime with --time
    
    My earlier patch to just enable --reltime with --time was a little too
    optimistic.  The --time parsing would accept absolute time, which is
    very confusing to the user.
    
    Support relative time in --time parsing too. This only works with recent
    perf record that records the first sample time. Otherwise we error out.
    
    Fixes: 3714437d3fcc ("perf script: Allow --time with --reltime")
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Link: http://lore.kernel.org/lkml/20191011182140.8353-1-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 4f42988eb2f7..1142b0bddd5e 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -26,6 +26,11 @@ bool perf_time__ranges_skip_sample(struct perf_time_interval *ptime_buf,
 
 struct perf_session;
 
+int perf_time__parse_for_ranges_reltime(const char *str, struct perf_session *session,
+				struct perf_time_interval **ranges,
+				int *range_size, int *range_num,
+				bool reltime);
+
 int perf_time__parse_for_ranges(const char *str, struct perf_session *session,
 				struct perf_time_interval **ranges,
 				int *range_size, int *range_num);

commit f37110205c3065546d6995b1463751c7bbb50e89
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 29 15:16:27 2019 -0300

    perf time-utils: Adopt rdclock() from perf.h
    
    Seems to be a better place for this function to live, further shrinking
    the hodge-podge that perf.h was.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-0zzt1u9rpyjukdy1ccr2u5r9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 72a42ea1d513..4f42988eb2f7 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -3,6 +3,7 @@
 #define _TIME_UTILS_H_
 
 #include <stddef.h>
+#include <time.h>
 #include <linux/types.h>
 
 struct perf_time_interval {
@@ -34,4 +35,12 @@ int timestamp__scnprintf_nsec(u64 timestamp, char *buf, size_t sz);
 
 int fetch_current_timestamp(char *buf, size_t sz);
 
+static inline unsigned long long rdclock(void)
+{
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+	return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
+}
+
 #endif

commit f8c856cb2c947f4fad0a2dff5e95cdcddb801303
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Mar 5 06:47:53 2019 -0800

    perf time-utils: Add utility function to print time stamps in nanoseconds
    
    Add a utility function to print nanosecond timestamps.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20190305144758.12397-11-andi@firstfloor.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index b923de44e36f..72a42ea1d513 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -30,6 +30,7 @@ int perf_time__parse_for_ranges(const char *str, struct perf_session *session,
 				int *range_size, int *range_num);
 
 int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
+int timestamp__scnprintf_nsec(u64 timestamp, char *buf, size_t sz);
 
 int fetch_current_timestamp(char *buf, size_t sz);
 

commit 284c4e18f55e85155fbcbef5f88b6e62d2b1c29c
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Fri Mar 1 18:13:06 2019 +0800

    perf time-utils: Refactor time range parsing code
    
    Jiri points out that we don't need any time checking and time string
    parsing if the --time option is not set. That makes sense.
    
    This patch refactors the time range parsing code, move the duplicated
    code from perf report and perf script to time_utils and check if --time
    option is set before parsing the time string. This patch is no logic
    change expected. So the usage of --time is same as before.
    
    For example:
    
    Select the first and second 10% time slices:
      perf report --time 10%/1,10%/2
      perf script --time 10%/1,10%/2
    
    Select the slices from 0% to 10% and from 30% to 40%:
      perf report --time 0%-10%,30%-40%
      perf script --time 0%-10%,30%-40%
    
    Select the time slices from timestamp 3971 to 3973
      perf report --time 3971,3973
      perf script --time 3971,3973
    
    Committer testing:
    
    Using the above examples, check before and after to see if it remains
    the same:
    
      $ perf record -F 10000 -- find . -name "*.[ch]" -exec cat {} + > /dev/null
      [ perf record: Woken up 3 times to write data ]
      [ perf record: Captured and wrote 1.626 MB perf.data (42392 samples) ]
      $
      $ perf report --time 10%/1,10%/2 > /tmp/report.before.1
      $ perf script --time 10%/1,10%/2 > /tmp/script.before.1
      $ perf report --time 0%-10%,30%-40% > /tmp/report.before.2
      $ perf script --time 0%-10%,30%-40% > /tmp/script.before.2
      $ perf report --time 180457.375844,180457.377717 > /tmp/report.before.3
      $ perf script --time 180457.375844,180457.377717 > /tmp/script.before.3
    
    For example, the 3rd test produces this slice:
    
      $ cat /tmp/script.before.3
            cat  3147 180457.375844:   2143 cycles:uppp:      7f79362590d9 cfree@GLIBC_2.2.5+0x9 (/usr/lib64/libc-2.28.so)
            cat  3147 180457.375986:   2245 cycles:uppp:      558b70f3d86e [unknown] (/usr/bin/cat)
            cat  3147 180457.376012:   2164 cycles:uppp:      7f7936257430 _int_malloc+0x8c0 (/usr/lib64/libc-2.28.so)
            cat  3147 180457.376140:   2921 cycles:uppp:      558b70f3a554 [unknown] (/usr/bin/cat)
            cat  3147 180457.376296:   2844 cycles:uppp:      7f7936258abe malloc+0x4e (/usr/lib64/libc-2.28.so)
            cat  3147 180457.376431:   2717 cycles:uppp:      558b70f3b0ca [unknown] (/usr/bin/cat)
            cat  3147 180457.376667:   2630 cycles:uppp:      558b70f3d86e [unknown] (/usr/bin/cat)
            cat  3147 180457.376795:   2442 cycles:uppp:      7f79362bff55 read+0x15 (/usr/lib64/libc-2.28.so)
            cat  3147 180457.376927:   2376 cycles:uppp:  ffffffff9aa00163 [unknown] ([unknown])
            cat  3147 180457.376954:   2307 cycles:uppp:      7f7936257438 _int_malloc+0x8c8 (/usr/lib64/libc-2.28.so)
            cat  3147 180457.377116:   3091 cycles:uppp:      7f7936258a70 malloc+0x0 (/usr/lib64/libc-2.28.so)
            cat  3147 180457.377362:   2945 cycles:uppp:      558b70f3a3b0 [unknown] (/usr/bin/cat)
            cat  3147 180457.377517:   2727 cycles:uppp:      558b70f3a9aa [unknown] (/usr/bin/cat)
      $
    
    Install 'coreutils-debuginfo' to see cat's guts (symbols), but then, the
    above chunk translates into this 'perf report' output:
    
      $ cat /tmp/report.before.3
      # To display the perf.data header info, please use --header/--header-only options.
      #
      #
      # Total Lost Samples: 0
      #
      # Samples: 13  of event 'cycles:uppp' (time slices: 180457.375844,180457.377717)
      # Event count (approx.): 33552
      #
      # Overhead  Command  Shared Object     Symbol
      # ........  .......  ................  ......................
      #
          17.69%  cat      libc-2.28.so      [.] malloc
          14.53%  cat      cat               [.] 0x000000000000586e
          13.33%  cat      libc-2.28.so      [.] _int_malloc
           8.78%  cat      cat               [.] 0x00000000000023b0
           8.71%  cat      cat               [.] 0x0000000000002554
           8.13%  cat      cat               [.] 0x00000000000029aa
           8.10%  cat      cat               [.] 0x00000000000030ca
           7.28%  cat      libc-2.28.so      [.] read
           7.08%  cat      [unknown]         [k] 0xffffffff9aa00163
           6.39%  cat      libc-2.28.so      [.] cfree@GLIBC_2.2.5
    
      #
      # (Tip: Order by the overhead of source file name and line number: perf report -s srcline)
      #
      $
    
    Now lets see after applying this patch, nothing should change:
    
      $ perf report --time 10%/1,10%/2 > /tmp/report.after.1
      $ perf script --time 10%/1,10%/2 > /tmp/script.after.1
      $ perf report --time 0%-10%,30%-40% > /tmp/report.after.2
      $ perf script --time 0%-10%,30%-40% > /tmp/script.after.2
      $ perf report --time 180457.375844,180457.377717 > /tmp/report.after.3
      $ perf script --time 180457.375844,180457.377717 > /tmp/script.after.3
      $ diff -u /tmp/report.before.1 /tmp/report.after.1
      $ diff -u /tmp/script.before.1 /tmp/script.after.1
      $ diff -u /tmp/report.before.2 /tmp/report.after.2
      --- /tmp/report.before.2      2019-03-01 11:01:53.526094883 -0300
      +++ /tmp/report.after.2       2019-03-01 11:09:18.231770467 -0300
      @@ -352,5 +352,5 @@
    
       #
      -# (Tip: Generate a script for your data: perf script -g <lang>)
      +# (Tip: Treat branches as callchains: perf report --branch-history)
       #
      $ diff -u /tmp/script.before.2 /tmp/script.after.2
      $ diff -u /tmp/report.before.3 /tmp/report.after.3
      --- /tmp/report.before.3      2019-03-01 11:03:08.890045588 -0300
      +++ /tmp/report.after.3       2019-03-01 11:09:40.660224002 -0300
      @@ -22,5 +22,5 @@
    
       #
      -# (Tip: Order by the overhead of source file name and line number: perf report -s srcline)
      +# (Tip: List events using substring match: perf list <keyword>)
       #
      $ diff -u /tmp/script.before.3 /tmp/script.after.3
      $
    
    Cool, just the 'perf report' tips changed, QED.
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jin Yao <yao.jin@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1551435186-6008-1-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 70b177d2b98c..b923de44e36f 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -23,6 +23,12 @@ bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
 bool perf_time__ranges_skip_sample(struct perf_time_interval *ptime_buf,
 				   int num, u64 timestamp);
 
+struct perf_session;
+
+int perf_time__parse_for_ranges(const char *str, struct perf_session *session,
+				struct perf_time_interval **ranges,
+				int *range_size, int *range_num);
+
 int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
 
 int fetch_current_timestamp(char *buf, size_t sz);

commit 5a031f887cb8d60fe87d21159c3cf82c38f55679
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Wed Jan 10 23:00:31 2018 +0800

    perf util: Allocate time slices buffer according to number of comma
    
    Previously we use a magic number 10 to limit the number of time slices.
    It's not very good.
    
    This patch creates a new function perf_time__range_alloc() to allocate
    time slices buffer. The number of buffer entries is determined by the
    number of comma in string but at least it will allocate one entry even
    if no comma is found.
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Suggested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Reviewed-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1515596433-24653-7-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 34d5eba26bf5..70b177d2b98c 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -16,6 +16,8 @@ int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
 int perf_time__percent_parse_str(struct perf_time_interval *ptime_buf, int num,
 				 const char *ostr, u64 start, u64 end);
 
+struct perf_time_interval *perf_time__range_alloc(const char *ostr, int *size);
+
 bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
 
 bool perf_time__ranges_skip_sample(struct perf_time_interval *ptime_buf,

commit 9a9b8b4b2271e763c1600311a3d4ecc2ac359b55
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Fri Dec 8 21:13:44 2017 +0800

    perf tools: Create function to perform multiple time range checking
    
    Previous patch supports the multiple time range.
    
    For example, select the first and second 10% time slices.
    perf report --time 10%/1,10%/2
    
    We need a function to check if a timestamp is in the ranges of
    [0, 10%) and [10%, 20%].
    
    Note that it includes the last element in [10%, 20%] but it doesn't
    include the last element in [0, 10%). It's to avoid the overlap.
    
    This patch implments a new function perf_time__ranges_skip_sample
    for this checking.
    
    Change log:
    
    v4: Let perf_time__ranges_skip_sample be compatible with
        perf_time__skip_sample when only one time range.
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1512738826-2628-5-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 23087231785a..34d5eba26bf5 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -18,6 +18,9 @@ int perf_time__percent_parse_str(struct perf_time_interval *ptime_buf, int num,
 
 bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
 
+bool perf_time__ranges_skip_sample(struct perf_time_interval *ptime_buf,
+				   int num, u64 timestamp);
+
 int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
 
 int fetch_current_timestamp(char *buf, size_t sz);

commit 13a70f350665580708ab11f725d3578eaacbf2d0
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Fri Dec 8 21:13:43 2017 +0800

    perf tools: Create function to parse time percent
    
    Current perf report/script/... have a --time option to limit the time
    range of output. But right now it only supports absolute time, add
    support for time percentage.
    
    For example:
    
    1. Select the second 10% time slice
       perf report --time 10%/2
    
    2. Select from 0% to 10% time slice
       perf report --time 0%-10%
    
    It also support the multiple time ranges.
    
    3. Select the first and second 10% time slices
       perf report --time 10%/1,10%/2
    
    4. Select from 0% to 10% and 30% to 40% slices
       perf report --time 0%-10%,30%-40%
    
    Changelog:
    
    v4: An issue is found. Following passes.
        perf script --time 10%/10x12321xsdfdasfdsafdsafdsa
    
        Now it uses strtol to replace atoi.
    
    Committer notes:
    
    This just puts in place the infrastructure, so the examples in this cset
    comment will only work later, after more patches in this series are
    applied.
    
    Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1512738826-2628-4-git-send-email-yao.jin@linux.intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 15b475c50ccf..23087231785a 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -13,6 +13,9 @@ int parse_nsec_time(const char *str, u64 *ptime);
 
 int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
 
+int perf_time__percent_parse_str(struct perf_time_interval *ptime_buf, int num,
+				 const char *ostr, u64 start, u64 end);
+
 bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
 
 int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 8656be08513b..15b475c50ccf 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _TIME_UTILS_H_
 #define _TIME_UTILS_H_
 

commit c5e4027e056c3027f682f0d69fe9fd75083b65f8
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 19 16:12:39 2017 -0300

    perf tools: Move timestamp routines from util.h to time-utils.h
    
    We already have a header for time utilities, so use it.
    
    Link: http://lkml.kernel.org/n/tip-sijzpbvutlg0c3oxn49hy9ca@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index c1f197c4af6c..8656be08513b 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -1,6 +1,9 @@
 #ifndef _TIME_UTILS_H_
 #define _TIME_UTILS_H_
 
+#include <stddef.h>
+#include <linux/types.h>
+
 struct perf_time_interval {
 	u64 start, end;
 };
@@ -11,4 +14,8 @@ int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
 
 bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
 
+int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
+
+int fetch_current_timestamp(char *buf, size_t sz);
+
 #endif

commit c284d669a20d408b70ce0dc9b2d995971f5fe0c7
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Nov 29 10:15:42 2016 -0700

    perf tools: Move parse_nsec_time to time-utils.c
    
    Code move only; no functional change intended.
    
    Committer notes:
    
    Fix the build on Ubuntu 16.04 x86-64 cross-compiling to S/390, with this
    set of auto-detected features:
    
      ...                         dwarf: [ on  ]
      ...            dwarf_getlocations: [ on  ]
      ...                         glibc: [ on  ]
      ...                          gtk2: [ OFF ]
      ...                      libaudit: [ OFF ]
      ...                        libbfd: [ OFF ]
      ...                        libelf: [ on  ]
      ...                       libnuma: [ OFF ]
      ...        numa_num_possible_cpus: [ OFF ]
      ...                       libperl: [ OFF ]
      ...                     libpython: [ OFF ]
      ...                      libslang: [ OFF ]
      ...                     libcrypto: [ OFF ]
      ...                     libunwind: [ OFF ]
      ...            libdw-dwarf-unwind: [ on  ]
      ...                          zlib: [ on  ]
      ...                          lzma: [ OFF ]
      ...                     get_cpuid: [ OFF ]
      ...                           bpf: [ on  ]
    
    Where it was failing with:
    
        CC       /tmp/build/perf/util/time-utils.o
      util/time-utils.c: In function 'parse_nsec_time':
      util/time-utils.c:17:13: error: implicit declaration of function 'strtoul' [-Werror=implicit-function-declaration]
        time_sec = strtoul(str, &end, 10);
                   ^
      util/time-utils.c:17:2: error: nested extern declaration of 'strtoul' [-Werror=nested-externs]
        time_sec = strtoul(str, &end, 10);
        ^
      util/time-utils.c: In function 'perf_time__parse_str':
      util/time-utils.c:93:2: error: implicit declaration of function 'free' [-Werror=implicit-function-declaration]
        free(str);
        ^
      util/time-utils.c:93:2: error: incompatible implicit declaration of built-in function 'free' [-Werror]
      util/time-utils.c:93:2: note: include '<stdlib.h>' or provide a declaration of 'free'
    
    Do as suggested and add a '#include <stdlib.h>' to get the free() and strtoul()
    declarations and fix the build.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1480439746-42695-3-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
index 8f3e0e370be8..c1f197c4af6c 100644
--- a/tools/perf/util/time-utils.h
+++ b/tools/perf/util/time-utils.h
@@ -5,6 +5,8 @@ struct perf_time_interval {
 	u64 start, end;
 };
 
+int parse_nsec_time(const char *str, u64 *ptime);
+
 int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
 
 bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);

commit fdf9dc4b34f5f40919370c4601eccfd0db726aa5
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Nov 29 10:15:41 2016 -0700

    perf tools: Add time-based utility functions
    
    Add function to parse a user time string of the form <start>,<stop>
    where start and stop are time in sec.nsec format. Both start and stop
    times are optional.
    
    Add function to determine if a sample time is within a given time
    time window of interest.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1480439746-42695-2-git-send-email-dsahern@gmail.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
new file mode 100644
index 000000000000..8f3e0e370be8
--- /dev/null
+++ b/tools/perf/util/time-utils.h
@@ -0,0 +1,12 @@
+#ifndef _TIME_UTILS_H_
+#define _TIME_UTILS_H_
+
+struct perf_time_interval {
+	u64 start, end;
+};
+
+int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
+
+bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
+
+#endif
