commit f2eaea09d684177f57db55a9ce2b67d048083fd5
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 22:15:35 2019 -0300

    perf map_symbol: Rename ms->mg to ms->maps
    
    One more step on the merge of 'struct maps' with 'struct map_groups'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-61rra2wg392rhvdgw421wzpt@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index bb4f515bdff9..7a3dbc259cec 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -81,7 +81,7 @@ static int entry(u64 ip, struct unwind_info *ui)
 		return -1;
 
 	e->ip	  = ip;
-	e->ms.mg  = al.maps;
+	e->ms.maps = al.maps;
 	e->ms.map = al.map;
 	e->ms.sym = al.sym;
 

commit 694520dfeb474619402620b68edf08e60ca36a17
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 22:11:20 2019 -0300

    perf addr_location: Rename al->mg to al->maps
    
    One more step on the merge of 'struct maps' with 'struct map_groups'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-foo95pyyp3bhocbt7yd8qrvq@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 33f655207c62..bb4f515bdff9 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -81,7 +81,7 @@ static int entry(u64 ip, struct unwind_info *ui)
 		return -1;
 
 	e->ip	  = ip;
-	e->ms.mg  = al.mg;
+	e->ms.mg  = al.maps;
 	e->ms.map = al.map;
 	e->ms.sym = al.sym;
 

commit fe87797dea79b59e97a4ea67441bf91f2905bf23
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 25 22:07:43 2019 -0300

    perf thread: Rename thread->mg to thread->maps
    
    One more step on the merge of 'struct maps' with 'struct map_groups'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-69vcr8pubpym90skxhmbwhiw@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index d2a8df01c4a7..33f655207c62 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -200,7 +200,7 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 	struct unwind_info *ui, ui_buf = {
 		.sample		= data,
 		.thread		= thread,
-		.machine	= thread->mg->machine,
+		.machine	= thread->maps->machine,
 		.cb		= cb,
 		.arg		= arg,
 		.max_stack	= max_stack,

commit 08f6680e627edf913c6d6adb9bb9ecc9d57a408d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 16:02:35 2019 -0300

    perf tools: Add a 'struct map_groups' pointer to 'struct map_symbol'
    
    And fill it whenever we setup a a 'struct map_symbol', now we need to
    use it, next cset.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-fzwfcnddenz1o7uj1fzw3g46@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 73c00d776a5f..d2a8df01c4a7 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -81,6 +81,7 @@ static int entry(u64 ip, struct unwind_info *ui)
 		return -1;
 
 	e->ip	  = ip;
+	e->ms.mg  = al.mg;
 	e->ms.map = al.map;
 	e->ms.sym = al.sym;
 

commit c1529738f5eb5fe7c472e0374ad7954d52566df9
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 4 11:58:21 2019 -0300

    perf unwind: Use 'struct map_symbol' in 'struct unwind_entry'
    
    To help in passing that info around to callchain routines that, for the
    same reason, are moving to use 'struct map_symbol'.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-epsiibeprpxa8qpwji47uskc@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 15f6e46d7124..73c00d776a5f 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -80,9 +80,9 @@ static int entry(u64 ip, struct unwind_info *ui)
 	if (__report_module(&al, ip, ui))
 		return -1;
 
-	e->ip  = ip;
-	e->map = al.map;
-	e->sym = al.sym;
+	e->ip	  = ip;
+	e->ms.map = al.map;
+	e->ms.sym = al.sym;
 
 	pr_debug("unwind: %s:ip = 0x%" PRIx64 " (0x%" PRIx64 ")\n",
 		 al.sym ? al.sym->name : "''",

commit fb71c86cc804b8f490fce1b9140014043ec41858
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Sep 3 10:56:06 2019 -0300

    perf tools: Remove util.h from where it is not needed
    
    Check that it is not needed and remove, fixing up some fallout for
    places where it was only serving to get something else.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-9h6dg6lsqe2usyqjh5rrues4@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 9ece188ae48a..15f6e46d7124 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -17,7 +17,6 @@
 #include "event.h"
 #include "perf_regs.h"
 #include "callchain.h"
-#include "util.h"
 
 static char *debuginfo_path;
 

commit 4a3cec84949d14dc3ef7fb8a51b8949af93cac13
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Aug 30 11:11:01 2019 -0300

    perf dsos: Move the dsos struct and its methods to separate source files
    
    So that we can reduce the header dependency tree further, in the process
    noticed that lots of places were getting even things like build-id
    routines and 'struct perf_tool' definition indirectly, so fix all those
    too.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-ti0btma9ow5ndrytyoqdk62j@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 28f71ca6ce1c..9ece188ae48a 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -5,6 +5,7 @@
 #include <inttypes.h>
 #include <errno.h>
 #include "debug.h"
+#include "dso.h"
 #include "unwind.h"
 #include "unwind-libdw.h"
 #include "machine.h"

commit 7f7c536f23e6afaa5d5d4b0e0958b0be8922491f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jul 4 11:32:27 2019 -0300

    tools lib: Adopt zalloc()/zfree() from tools/perf
    
    Eroding a bit more the tools/perf/util/util.h hodpodge header.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-natazosyn9rwjka25tvcnyi0@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 407d0167b942..28f71ca6ce1c 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -12,6 +12,7 @@
 #include "symbol.h"
 #include "thread.h"
 #include <linux/types.h>
+#include <linux/zalloc.h>
 #include "event.h"
 #include "perf_regs.h"
 #include "callchain.h"

commit daecf9e0fa8e1bb3b227fcc15c4070caccbbb14f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Jan 28 00:03:34 2019 +0100

    perf tools: Add missing include for symbols.h
    
    Several places were using definitions found in symbols.h but not
    including it, getting it by sheer luck from some other headers that now
    are in the process of removing that include because they don't need it
    or because simply having struct forward declarations is enough, fix it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-xbcvvx296d70kpg9wb0qmeq9@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 8ea7c89e73fd..407d0167b942 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -9,6 +9,7 @@
 #include "unwind-libdw.h"
 #include "machine.h"
 #include "map.h"
+#include "symbol.h"
 #include "thread.h"
 #include <linux/types.h>
 #include "event.h"

commit 1101f69af5335a863765100d1df1999fd1e8c5bf
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Jan 27 13:42:37 2019 +0100

    pref tools: Add missing map.h includes
    
    Lots of places get the map.h file indirectly, and since we're going to
    remove it from machine.h, then those need to include it directly, do it
    now, before we remove that dep.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-ob8jehdjda8h5jsrv9dqj9tf@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 5eff9bfc5758..8ea7c89e73fd 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -8,6 +8,7 @@
 #include "unwind.h"
 #include "unwind-libdw.h"
 #include "machine.h"
+#include "map.h"
 #include "thread.h"
 #include <linux/types.h>
 #include "event.h"

commit 1fe627da30331024f453faef04d500079b901107
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 29 15:16:44 2018 +0100

    perf unwind: Take pgoff into account when reporting elf to libdwfl
    
    libdwfl parses an ELF file itself and creates mappings for the
    individual sections. perf on the other hand sees raw mmap events which
    represent individual sections. When we encounter an address pointing
    into a mapping with pgoff != 0, we must take that into account and
    report the file at the non-offset base address.
    
    This fixes unwinding with libdwfl in some cases. E.g. for a file like:
    
    ```
    
    using namespace std;
    
    mutex g_mutex;
    
    double worker()
    {
        lock_guard<mutex> guard(g_mutex);
        uniform_real_distribution<double> uniform(-1E5, 1E5);
        default_random_engine engine;
        double s = 0;
        for (int i = 0; i < 1000; ++i) {
            s += norm(complex<double>(uniform(engine), uniform(engine)));
        }
        cout << s << endl;
        return s;
    }
    
    int main()
    {
        vector<std::future<double>> results;
        for (int i = 0; i < 10000; ++i) {
            results.push_back(async(launch::async, worker));
        }
        return 0;
    }
    ```
    
    Compile it with `g++ -g -O2 -lpthread cpp-locking.cpp  -o cpp-locking`,
    then record it with `perf record --call-graph dwarf -e
    sched:sched_switch`.
    
    When you analyze it with `perf script` and libunwind, you should see:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
                7f38e4252d0b arena_get2.part.4+0x2fb (/usr/lib/libc-2.28.so)
                7f38e4255b1c tcache_init.part.6+0xec (/usr/lib/libc-2.28.so)
                7f38e42569e5 __GI___libc_malloc+0x115 (inlined)
                7f38e4241790 __GI__IO_file_doallocate+0x90 (inlined)
                7f38e424fbbf __GI__IO_doallocbuf+0x4f (inlined)
                7f38e424ee47 __GI__IO_file_overflow+0x197 (inlined)
                7f38e424df36 _IO_new_file_xsputn+0x116 (inlined)
                7f38e4242bfb __GI__IO_fwrite+0xdb (inlined)
                7f38e463fa6d std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> >::_M_put(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::__write<char>(std::ostreambuf_iterator<char, std::char_traits<char> >, char const*, int)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<c>
                7f38e464bd70 std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const+0x90 (inl>
                7f38e464bd70 std::ostream& std::ostream::_M_insert<double>(double)+0x90 (/usr/lib/libstdc++.so.6.0.25)
                563b9cb502f7 std::ostream::operator<<(double)+0xb7 (inlined)
                563b9cb502f7 worker()+0xb7 (/ssd/milian/projects/kdab/rnd/hotspot/build/tests/test-clients/cpp-locking/cpp-locking)
                563b9cb506fb double std::__invoke_impl<double, double (*)()>(std::__invoke_other, double (*&&)())+0x2b (inlined)
                563b9cb506fb std::__invoke_result<double (*)()>::type std::__invoke<double (*)()>(double (*&&)())+0x2b (inlined)
                563b9cb506fb decltype (__invoke((_S_declval<0ul>)())) std::thread::_Invoker<std::tuple<double (*)()> >::_M_invoke<0ul>(std::_Index_tuple<0ul>)+0x2b (inlined)
                563b9cb506fb std::thread::_Invoker<std::tuple<double (*)()> >::operator()()+0x2b (inlined)
                563b9cb506fb std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<double>, std::__future_base::_Result_base::_Deleter>, std::thread::_Invoker<std::tuple<double (*)()> >, dou>
                563b9cb506fb std::_Function_handler<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (), std::__future_base::_Task_setter<std::unique_ptr<std::__future_>
                563b9cb507e8 std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::operator()() const+0x28 (inlined)
                563b9cb507e8 std::__future_base::_State_baseV2::_M_do_set(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)+0x28 (/ssd/milian/>
                7f38e46d24fe __pthread_once_slow+0xbe (/usr/lib/libpthread-2.28.so)
                563b9cb51149 __gthread_once+0xe9 (inlined)
                563b9cb51149 void std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>
                563b9cb51149 std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>, bool)+0xe9 (inlined)
                563b9cb51149 std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double (*)()> >&&)::{lambda()#1}::op>
                563b9cb51149 void std::__invoke_impl<void, std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double>
                563b9cb51149 std::__invoke_result<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double (*)()> >>
                563b9cb51149 decltype (__invoke((_S_declval<0ul>)())) std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_>
                563b9cb51149 std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<dou>
                563b9cb51149 std::thread::_State_impl<std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread>
                7f38e45f0062 execute_native_thread_routine+0x12 (/usr/lib/libstdc++.so.6.0.25)
                7f38e46caa9c start_thread+0xfc (/usr/lib/libpthread-2.28.so)
                7f38e42ccb22 __GI___clone+0x42 (inlined)
    ```
    
    Before this patch, using libdwfl, you would see:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
            a041161e77950c5c [unknown] ([unknown])
    ```
    
    With this patch applied, we get a bit further in unwinding:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
                7f38e4252d0b arena_get2.part.4+0x2fb (/usr/lib/libc-2.28.so)
                7f38e4255b1c tcache_init.part.6+0xec (/usr/lib/libc-2.28.so)
                7f38e42569e5 __GI___libc_malloc+0x115 (inlined)
                7f38e4241790 __GI__IO_file_doallocate+0x90 (inlined)
                7f38e424fbbf __GI__IO_doallocbuf+0x4f (inlined)
                7f38e424ee47 __GI__IO_file_overflow+0x197 (inlined)
                7f38e424df36 _IO_new_file_xsputn+0x116 (inlined)
                7f38e4242bfb __GI__IO_fwrite+0xdb (inlined)
                7f38e463fa6d std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> >::_M_put(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::__write<char>(std::ostreambuf_iterator<char, std::char_traits<char> >, char const*, int)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<c>
                7f38e464bd70 std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const+0x90 (inl>
                7f38e464bd70 std::ostream& std::ostream::_M_insert<double>(double)+0x90 (/usr/lib/libstdc++.so.6.0.25)
                563b9cb502f7 std::ostream::operator<<(double)+0xb7 (inlined)
                563b9cb502f7 worker()+0xb7 (/ssd/milian/projects/kdab/rnd/hotspot/build/tests/test-clients/cpp-locking/cpp-locking)
            6eab825c1ee3e4ff [unknown] ([unknown])
    ```
    
    Note that the backtrace is still stopping too early, when compared to
    the nice results obtained via libunwind. It's unclear so far what the
    reason for that is.
    
    Committer note:
    
    Further comment by Milian on the thread started on the Link: tag below:
    
     ---
    The remaining issue is due to a bug in elfutils:
    
    https://sourceware.org/ml/elfutils-devel/2018-q4/msg00089.html
    
    With both patches applied, libunwind and elfutils produce the same output for
    the above scenario.
     ---
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/20181029141644.3907-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 6f318b15950e..5eff9bfc5758 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -45,13 +45,13 @@ static int __report_module(struct addr_location *al, u64 ip,
 		Dwarf_Addr s;
 
 		dwfl_module_info(mod, NULL, &s, NULL, NULL, NULL, NULL, NULL);
-		if (s != al->map->start)
+		if (s != al->map->start - al->map->pgoff)
 			mod = 0;
 	}
 
 	if (!mod)
 		mod = dwfl_report_elf(ui->dwfl, dso->short_name,
-				      (dso->symsrc_filename ? dso->symsrc_filename : dso->long_name), -1, al->map->start,
+				      (dso->symsrc_filename ? dso->symsrc_filename : dso->long_name), -1, al->map->start - al->map->pgoff,
 				      false);
 
 	return mod && dwfl_addrmodule(ui->dwfl, ip) == mod ? 0 : -1;

commit 2a9d5050dc84fa2060f08a52f632976923e0fa7e
Author: Sandipan Das <sandipan@linux.ibm.com>
Date:   Tue Jul 3 17:35:55 2018 +0530

    perf script: Show correct offsets for DWARF-based unwinding
    
    When perf/data is recorded with the dwarf call-graph option, the
    callchain shown by 'perf script' still shows the binary offsets of the
    userspace symbols instead of their virtual addresses. Since the symbol
    offset calculation is based on using virtual address as the ip, we see
    incorrect offsets as well.
    
    The use of virtual addresses affects the ability to find out the
    line number in the corresponding source file to which an address
    maps to as described in commit 67540759151a ("perf unwind: Use
    addr_location::addr instead of ip for entries").
    
    This has also been addressed by temporarily converting the virtual
    address to the correponding binary offset so that it can be mapped
    to the source line number correctly.
    
    This is a follow-up for commit 19610184693c ("perf script: Show
    virtual addresses instead of offsets").
    
    This can be verified on a powerpc64le system running Fedora 27 as
    shown below:
    
      # perf probe -x /usr/lib64/libc-2.26.so -a inet_pton
      # perf record -e probe_libc:inet_pton --call-graph=dwarf ping -6 -c 1 ::1
    
    Before:
    
      # perf report --stdio --no-children -s sym,srcline -g address
    
      # Samples: 1  of event 'probe_libc:inet_pton'
      # Event count (approx.): 1
      #
      # Overhead  Symbol                Source:Line
      # ........  ....................  ...........
      #
         100.00%  [.] __GI___inet_pton  inet_pton.c
                  |
                  ---gaih_inet getaddrinfo.c:537 (inlined)
                     __GI_getaddrinfo getaddrinfo.c:2304 (inlined)
                     main ping.c:519
                     generic_start_main libc-start.c:308 (inlined)
                     __libc_start_main libc-start.c:102
      ...
    
      # perf script -F comm,ip,sym,symoff,srcline,dso
    
      ping
                        15af28 __GI___inet_pton+0xffff000099160008 (/usr/lib64/libc-2.26.so)
        libc-2.26.so[ffff80004ca0af28]
                        10fa53 gaih_inet+0xffff000099160f43
        libc-2.26.so[ffff80004c9bfa53] (inlined)
                        1105b3 __GI_getaddrinfo+0xffff000099160163
        libc-2.26.so[ffff80004c9c05b3] (inlined)
                          2d6f main+0xfffffffd9f1003df (/usr/bin/ping)
        ping[fffffffecf882d6f]
                         2369f generic_start_main+0xffff00009916013f
        libc-2.26.so[ffff80004c8d369f] (inlined)
                         23897 __libc_start_main+0xffff0000991600b7 (/usr/lib64/libc-2.26.so)
        libc-2.26.so[ffff80004c8d3897]
    
    After:
    
      # perf report --stdio --no-children -s sym,srcline -g address
    
      # Samples: 1  of event 'probe_libc:inet_pton'
      # Event count (approx.): 1
      #
      # Overhead  Symbol                Source:Line
      # ........  ....................  ...........
      #
         100.00%  [.] __GI___inet_pton  inet_pton.c
                  |
                  ---gaih_inet.constprop.7 getaddrinfo.c:537
                     getaddrinfo getaddrinfo.c:2304
                     main ping.c:519
                     generic_start_main.isra.0 libc-start.c:308
                     __libc_start_main libc-start.c:102
      ...
    
      # perf script -F comm,ip,sym,symoff,srcline,dso
    
      ping
                  7fffb38aaf28 __GI___inet_pton+0x8 (/usr/lib64/libc-2.26.so)
        inet_pton.c:68
                  7fffb385fa53 gaih_inet.constprop.7+0xf43 (/usr/lib64/libc-2.26.so)
        getaddrinfo.c:537
                  7fffb38605b3 getaddrinfo+0x163 (/usr/lib64/libc-2.26.so)
        getaddrinfo.c:2304
                     130782d6f main+0x3df (/usr/bin/ping)
        ping.c:519
                  7fffb377369f generic_start_main.isra.0+0x13f (/usr/lib64/libc-2.26.so)
        libc-start.c:308
                  7fffb3773897 __libc_start_main+0xb7 (/usr/lib64/libc-2.26.so)
        libc-start.c:102
    
    Signed-off-by: Sandipan Das <sandipan@linux.ibm.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Cc: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Fixes: 67540759151a ("perf unwind: Use addr_location::addr instead of ip for entries")
    Link: http://lkml.kernel.org/r/20180703120555.32971-1-sandipan@linux.ibm.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 538db4e5d1e6..6f318b15950e 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -77,7 +77,7 @@ static int entry(u64 ip, struct unwind_info *ui)
 	if (__report_module(&al, ip, ui))
 		return -1;
 
-	e->ip  = al.addr;
+	e->ip  = ip;
 	e->map = al.map;
 	e->sym = al.sym;
 

commit 404eb5a436c4cbdc3b76896a28a3b72b7ad9294e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 26 09:34:37 2018 -0300

    perf thread: Make thread__find_map() search all maps
    
    We still have the split internally, but users don't see it anymore,
    simplifying the growing number of cases where we end up searching
    in the MAP__VARIABLE maps.
    
    This further paves the way for ditching the split.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-86mfxrztf310konutxvhr5ua@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 17401922cd42..538db4e5d1e6 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -105,16 +105,6 @@ static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
 	ssize_t size;
 
 	if (!thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al)) {
-		/*
-		 * We've seen cases (softice) where DWARF unwinder went
-		 * through non executable mmaps, which we need to lookup
-		 * in MAP__VARIABLE tree.
-		 */
-		__thread__find_map(ui->thread, PERF_RECORD_MISC_USER,
-				   MAP__VARIABLE, addr, &al);
-	}
-
-	if (!al.map) {
 		pr_debug("unwind: no map for %lx\n", (unsigned long)addr);
 		return -1;
 	}

commit 71a84b5aedf5023f4009c3bbf28ecba256201f87
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 24 11:58:56 2018 -0300

    perf thread: Make thread__find_map() return the map
    
    It was returning the searched map just on the addr_location passed, with
    the function itself returning void.
    
    Make it return the map so that we can make the code more compact.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-tzlrrzdeoof4i6ktyqv1t6ks@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index bdc22f1864df..17401922cd42 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -104,8 +104,7 @@ static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
 	struct addr_location al;
 	ssize_t size;
 
-	thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al);
-	if (!al.map) {
+	if (!thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al)) {
 		/*
 		 * We've seen cases (softice) where DWARF unwinder went
 		 * through non executable mmaps, which we need to lookup

commit 4546263d72e22ea84b49dafad26d8ca679d5e83d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 24 11:24:49 2018 -0300

    perf thread: Introduce thread__find_symbol()
    
    Out of thread__find_addr_location(..., MAP__FUNCTION, ...), idea here is to
    continue removing references to MAP__{FUNCTION,VARIABLE} ahead of
    getting both types of symbols in the same rbtree, as various places do
    two lookups, looking first at MAP__FUNCTION, then at MAP__VARIABLE.
    
    So thread__find_symbol() will eventually do just that, and 'struct
    symbol' will have the symbol type, for code that cares about that.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-n7528en9e08yd3flzmb26tth@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 1ce8744649b5..bdc22f1864df 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -28,10 +28,11 @@ static int __report_module(struct addr_location *al, u64 ip,
 {
 	Dwfl_Module *mod;
 	struct dso *dso = NULL;
-
-	thread__find_addr_location(ui->thread,
-				   PERF_RECORD_MISC_USER,
-				   MAP__FUNCTION, ip, al);
+	/*
+	 * Some callers will use al->sym, so we can't just use the
+	 * cheaper thread__find_map() here.
+	 */
+	thread__find_symbol(ui->thread, PERF_RECORD_MISC_USER, ip, al);
 
 	if (al->map)
 		dso = al->map->dso;

commit f07a2d32b521a54635c8efeb0a3180b0afcf780a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 24 10:49:50 2018 -0300

    perf thread: Introduce thread__find_map()
    
    Out of thread__find_add_map(..., MAP__FUNCTION, ...), idea here is to
    continue removing references to MAP__{FUNCTION,VARIABLE} ahead of
    getting both types of symbols in the same rbtree, as various places do
    two lookups, looking first at MAP__FUNCTION, then at MAP__VARIABLE.
    
    So thread__find_map() will eventually do just that, and 'struct symbol'
    will have the symbol type, for code that cares about that.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-q27xee34l4izpfau49w103s6@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 7bdd239c795c..1ce8744649b5 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -103,16 +103,15 @@ static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
 	struct addr_location al;
 	ssize_t size;
 
-	thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
-			      MAP__FUNCTION, addr, &al);
+	thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al);
 	if (!al.map) {
 		/*
 		 * We've seen cases (softice) where DWARF unwinder went
 		 * through non executable mmaps, which we need to lookup
 		 * in MAP__VARIABLE tree.
 		 */
-		thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
-				      MAP__VARIABLE, addr, &al);
+		__thread__find_map(ui->thread, PERF_RECORD_MISC_USER,
+				   MAP__VARIABLE, addr, &al);
 	}
 
 	if (!al.map) {

commit 555fc3b1ef4c850c635be333024dcf67bc1e7cb8
Author: Martin Vuille <jpmv27@aim.com>
Date:   Sun Mar 18 13:50:53 2018 -0400

    perf unwind: Report error from dwfl_attach_state
    
    In verbose level 2, errors returned by libdw are reported in most cases,
    but not when calling dwfl_attach_state.
    
    Since elfutils v 0.160 (2014), dwfl_attach_state sets the error code to
    report failure cause. On failure, log the reported error.
    
    Signed-off-by: Martin Vuille <jpmv27@aim.com>
    Reviewed-by: Kim Phillips <kim.phillips@arm.com>
    Link: http://lkml.kernel.org/r/20180318175053.4222-1-jpmv27@aim.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 8e969f28cc59..7bdd239c795c 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -236,7 +236,8 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 	if (err)
 		goto out;
 
-	if (!dwfl_attach_state(ui->dwfl, EM_NONE, thread->tid, &callbacks, ui))
+	err = !dwfl_attach_state(ui->dwfl, EM_NONE, thread->tid, &callbacks, ui);
+	if (err)
 		goto out;
 
 	err = dwfl_getthread_frames(ui->dwfl, thread->tid, frame_callback, ui);

commit 3d20c6246690219881786de10d2dda93f616d0ac
Author: Martin Vuille <jpmv27@aim.com>
Date:   Sun Feb 11 16:24:20 2018 -0500

    perf unwind: Unwind with libdw doesn't take symfs into account
    
    Path passed to libdw for unwinding doesn't include symfs path
    if specified, so unwinding fails because ELF file is not found.
    
    Similar to unwinding with libunwind, pass symsrc_filename instead
    of long_name. If there is no symsrc_filename, fallback to long_name.
    
    Signed-off-by: Martin Vuille <jpmv27@aim.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/20180211212420.18388-1-jpmv27@aim.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 1e9c974faf67..8e969f28cc59 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -50,7 +50,7 @@ static int __report_module(struct addr_location *al, u64 ip,
 
 	if (!mod)
 		mod = dwfl_report_elf(ui->dwfl, dso->short_name,
-				      dso->long_name, -1, al->map->start,
+				      (dso->symsrc_filename ? dso->symsrc_filename : dso->long_name), -1, al->map->start,
 				      false);
 
 	return mod && dwfl_addrmodule(ui->dwfl, ip) == mod ? 0 : -1;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 7755a5e0fe5e..1e9c974faf67 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/compiler.h>
 #include <elfutils/libdw.h>
 #include <elfutils/libdwfl.h>

commit 9126cbbacecb8917bd0418809ef1d26616b2061e
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Fri Jun 2 16:37:53 2017 +0200

    perf unwind: Report module before querying isactivation in dwfl unwind
    
    The PC returned by dwfl_frame_pc() may map into a not-yet-reported
    module. We have to report it before we continue unwinding. But when we
    query for the isactivation flag in dwfl_frame_pc, libdw will actually do
    one more unwinding step internally which can then break and lead to
    missed frames or broken stacks.
    
    With libunwind we get e.g.:
    
    ~~~~~
      heaptrack_gui  2228 135073.400474:     613969 cycles:
                      108c8e [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1093bc [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      109e7b QLocale::QLocale (/usr/lib/libQt5Core.so.5.8.0)
                      1470ff [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      147f67 QSystemLocale::query (/usr/lib/libQt5Core.so.5.8.0)
                      109fbf QLocalePrivate::updateSystemPrivate (/usr/lib/libQt5Core.so.5.8.0)
                      10aa27 QLocale::QLocale (/usr/lib/libQt5Core.so.5.8.0)
                      1e02c3 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      2113bb [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      211505 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1b5df0 QFileInfo::exists (/usr/lib/libQt5Core.so.5.8.0)
                       92eb2 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                       93423 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                       93d2a QLibraryInfo::location (/usr/lib/libQt5Core.so.5.8.0)
                      2170af [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      297c53 QCoreApplicationPrivate::init (/usr/lib/libQt5Core.so.5.8.0)
                       f7cde QGuiApplicationPrivate::init (/usr/lib/libQt5Gui.so.5.8.0)
                      1589e8 QApplicationPrivate::init (/usr/lib/libQt5Widgets.so.5.8.0)
                       78622 main (/home/milian/projects/compiled/other/bin/heaptrack_gui)
                       20439 __libc_start_main (/usr/lib/libc-2.25.so)
                       78299 _start (/home/milian/projects/compiled/other/bin/heaptrack_gui)
    
      heaptrack_gui  2228 135073.401156:     569521 cycles:
                      131633 QString::endsWith (/usr/lib/libQt5Core.so.5.8.0)
                      1a0701 QDir::cleanPath (/usr/lib/libQt5Core.so.5.8.0)
                      21b82d [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1b3727 QFileInfo::canonicalFilePath (/usr/lib/libQt5Core.so.5.8.0)
                      2780c7 QFactoryLoader::update (/usr/lib/libQt5Core.so.5.8.0)
                      279525 QFactoryLoader::QFactoryLoader (/usr/lib/libQt5Core.so.5.8.0)
                       e5bd0 QPlatformIntegrationFactory::create (/usr/lib/libQt5Gui.so.5.8.0)
                       f5a1c QGuiApplicationPrivate::createPlatformIntegration (/usr/lib/libQt5Gui.so.5.8.0)
                       f650c QGuiApplicationPrivate::createEventDispatcher (/usr/lib/libQt5Gui.so.5.8.0)
                      298524 QCoreApplicationPrivate::init (/usr/lib/libQt5Core.so.5.8.0)
                       f7cde QGuiApplicationPrivate::init (/usr/lib/libQt5Gui.so.5.8.0)
                      1589e8 QApplicationPrivate::init (/usr/lib/libQt5Widgets.so.5.8.0)
                       78622 main (/home/milian/projects/compiled/other/bin/heaptrack_gui)
                       20439 __libc_start_main (/usr/lib/libc-2.25.so)
                       78299 _start (/home/milian/projects/compiled/other/bin/heaptrack_gui)
    ~~~~~
    
    Note the two frames 1589e8 and 78622 in the first sample. These are
    missing when unwinding with libdw. The second sample's breakage is
    more obvious:
    
    ~~~~~
      heaptrack_gui  2228 135073.400474:     613969 cycles:
                      108c8e [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1093bc [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      109e7b QLocale::QLocale (/usr/lib/libQt5Core.so.5.8.0)
                      1470ff [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      147f67 QSystemLocale::query (/usr/lib/libQt5Core.so.5.8.0)
                      109fbf QLocalePrivate::updateSystemPrivate (/usr/lib/libQt5Core.so.5.8.0)
                      10aa27 QLocale::QLocale (/usr/lib/libQt5Core.so.5.8.0)
                      1e02c3 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      2113bb [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      211505 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1b5df0 QFileInfo::exists (/usr/lib/libQt5Core.so.5.8.0)
                       92eb2 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                       93423 [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                       93d2a QLibraryInfo::location (/usr/lib/libQt5Core.so.5.8.0)
                      2170af [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      297c53 QCoreApplicationPrivate::init (/usr/lib/libQt5Core.so.5.8.0)
                       f7cde QGuiApplicationPrivate::init (/usr/lib/libQt5Gui.so.5.8.0)
                       20439 __libc_start_main (/usr/lib/libc-2.25.so)
                       78299 _start (/home/milian/projects/compiled/other/bin/heaptrack_gui)
    
    heaptrack_gui  2228 135073.401156:     569521 cycles:
                      131633 QString::endsWith (/usr/lib/libQt5Core.so.5.8.0)
                      1a0701 QDir::cleanPath (/usr/lib/libQt5Core.so.5.8.0)
                      21b82d [unknown] (/usr/lib/libQt5Core.so.5.8.0)
                      1b3727 QFileInfo::canonicalFilePath (/usr/lib/libQt5Core.so.5.8.0)
                      2780c7 QFactoryLoader::update (/usr/lib/libQt5Core.so.5.8.0)
                      279525 QFactoryLoader::QFactoryLoader (/usr/lib/libQt5Core.so.5.8.0)
                       e5bd0 QPlatformIntegrationFactory::create (/usr/lib/libQt5Gui.so.5.8.0)
                      723dbf [unknown] ([unknown])
    ~~~~~
    
    This patch fixes this issue and the libdw unwinder mimicks the libunwind
    behavior more closely.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Acked-by: Jan Kratochvil <jan.kratochvil@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20170602143753.16907-2-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index da45c4be5fb3..7755a5e0fe5e 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -178,6 +178,14 @@ frame_callback(Dwfl_Frame *state, void *arg)
 	Dwarf_Addr pc;
 	bool isactivation;
 
+	if (!dwfl_frame_pc(state, &pc, NULL)) {
+		pr_err("%s", dwfl_errmsg(-1));
+		return DWARF_CB_ABORT;
+	}
+
+	// report the module before we query for isactivation
+	report_module(pc, ui);
+
 	if (!dwfl_frame_pc(state, &pc, &isactivation)) {
 		pr_err("%s", dwfl_errmsg(-1));
 		return DWARF_CB_ABORT;

commit 2538b9e2450ae255337c04356e9e0f8cb9ec48d9
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Fri Jun 2 16:37:52 2017 +0200

    perf report: Ensure the perf DSO mapping matches what libdw sees
    
    In some situations the libdw unwinder stopped working properly.  I.e.
    with libunwind we see:
    
    ~~~~~
    heaptrack_gui  2228 135073.400112:     641314 cycles:
                        e8ed _dl_fixup (/usr/lib/ld-2.25.so)
                       15f06 _dl_runtime_resolve_sse_vex (/usr/lib/ld-2.25.so)
                       ed94c KDynamicJobTracker::KDynamicJobTracker (/home/milian/projects/compiled/kf5/lib64/libKF5KIOWidgets.so.5.35.0)
                       608f3 _GLOBAL__sub_I_kdynamicjobtracker.cpp (/home/milian/projects/compiled/kf5/lib64/libKF5KIOWidgets.so.5.35.0)
                        f199 call_init.part.0 (/usr/lib/ld-2.25.so)
                        f2a5 _dl_init (/usr/lib/ld-2.25.so)
                         db9 _dl_start_user (/usr/lib/ld-2.25.so)
    ~~~~~
    
    But with libdw and without this patch this sample is not properly
    unwound:
    
    ~~~~~
    heaptrack_gui  2228 135073.400112:     641314 cycles:
                        e8ed _dl_fixup (/usr/lib/ld-2.25.so)
                       15f06 _dl_runtime_resolve_sse_vex (/usr/lib/ld-2.25.so)
                       ed94c KDynamicJobTracker::KDynamicJobTracker (/home/milian/projects/compiled/kf5/lib64/libKF5KIOWidgets.so.5.35.0)
    ~~~~~
    
    Debug output showed me that libdw found a module for the last frame
    address, but it thinks it belongs to /usr/lib/ld-2.25.so. This patch
    double-checks what libdw sees and what perf knows. If the mappings
    mismatch, we now report the elf known to perf. This fixes the situation
    above, and the libdw unwinder produces the same stack as libunwind.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20170602143753.16907-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index b4c20124d2ee..da45c4be5fb3 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -39,6 +39,14 @@ static int __report_module(struct addr_location *al, u64 ip,
 		return 0;
 
 	mod = dwfl_addrmodule(ui->dwfl, ip);
+	if (mod) {
+		Dwarf_Addr s;
+
+		dwfl_module_info(mod, NULL, &s, NULL, NULL, NULL, NULL, NULL);
+		if (s != al->map->start)
+			mod = 0;
+	}
+
 	if (!mod)
 		mod = dwfl_report_elf(ui->dwfl, dso->short_name,
 				      dso->long_name, -1, al->map->start,

commit 5ea0416f51cc93436bbe497c62ab49fd9cb245b6
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Thu Jun 1 23:00:21 2017 +0200

    perf report: Include partial stacks unwound with libdw
    
    So far the whole stack was thrown away when any error occurred before
    the maximum stack depth was unwound. This is actually a very common
    scenario though. The stacks that got unwound so far are still
    interesting. This removes a large chunk of differences when comparing
    perf script output for libunwind and libdw perf unwinding.
    
    E.g. with libunwind:
    
    ~~~~~
    heaptrack_gui  2228 135073.388524:     479408 cycles:
            ffffffff811749ed perf_iterate_ctx ([kernel.kallsyms])
            ffffffff81181662 perf_event_mmap ([kernel.kallsyms])
            ffffffff811cf5ed mmap_region ([kernel.kallsyms])
            ffffffff811cfe6b do_mmap ([kernel.kallsyms])
            ffffffff811b0dca vm_mmap_pgoff ([kernel.kallsyms])
            ffffffff811cdb0c sys_mmap_pgoff ([kernel.kallsyms])
            ffffffff81033acb sys_mmap ([kernel.kallsyms])
            ffffffff81631d37 entry_SYSCALL_64_fastpath ([kernel.kallsyms])
                       192ca mmap64 (/usr/lib/ld-2.25.so)
                        59a9 _dl_map_object_from_fd (/usr/lib/ld-2.25.so)
                        83d0 _dl_map_object (/usr/lib/ld-2.25.so)
                        cda1 openaux (/usr/lib/ld-2.25.so)
                       1834f _dl_catch_error (/usr/lib/ld-2.25.so)
                        cfe2 _dl_map_object_deps (/usr/lib/ld-2.25.so)
                        3481 dl_main (/usr/lib/ld-2.25.so)
                       17387 _dl_sysdep_start (/usr/lib/ld-2.25.so)
                        4d37 _dl_start (/usr/lib/ld-2.25.so)
                         d87 _start (/usr/lib/ld-2.25.so)
    
    heaptrack_gui  2228 135073.388677:     611329 cycles:
                       1a3e0 strcmp (/usr/lib/ld-2.25.so)
                        82b2 _dl_map_object (/usr/lib/ld-2.25.so)
                        cda1 openaux (/usr/lib/ld-2.25.so)
                       1834f _dl_catch_error (/usr/lib/ld-2.25.so)
                        cfe2 _dl_map_object_deps (/usr/lib/ld-2.25.so)
                        3481 dl_main (/usr/lib/ld-2.25.so)
                       17387 _dl_sysdep_start (/usr/lib/ld-2.25.so)
                        4d37 _dl_start (/usr/lib/ld-2.25.so)
                         d87 _start (/usr/lib/ld-2.25.so)
    ~~~~~
    
    With libdw without this patch:
    
    ~~~~~
    heaptrack_gui  2228 135073.388524:     479408 cycles:
            ffffffff811749ed perf_iterate_ctx ([kernel.kallsyms])
            ffffffff81181662 perf_event_mmap ([kernel.kallsyms])
            ffffffff811cf5ed mmap_region ([kernel.kallsyms])
            ffffffff811cfe6b do_mmap ([kernel.kallsyms])
            ffffffff811b0dca vm_mmap_pgoff ([kernel.kallsyms])
            ffffffff811cdb0c sys_mmap_pgoff ([kernel.kallsyms])
            ffffffff81033acb sys_mmap ([kernel.kallsyms])
            ffffffff81631d37 entry_SYSCALL_64_fastpath ([kernel.kallsyms])
    
    heaptrack_gui  2228 135073.388677:     611329 cycles:
    ~~~~~
    
    With this patch applied, the libdw unwinder will produce the same
    output as the libunwind unwinder.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/20170601210021.20046-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 943a06291587..b4c20124d2ee 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -224,7 +224,7 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 
 	err = dwfl_getthread_frames(ui->dwfl, thread->tid, frame_callback, ui);
 
-	if (err && !ui->max_stack)
+	if (err && ui->max_stack != max_stack)
 		err = 0;
 
 	/*

commit 1982ad48fc82c284a5cc55697a012d3357e84d01
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Wed May 24 15:21:25 2017 +0900

    perf report: Fix off-by-one for non-activation frames
    
    As the documentation for dwfl_frame_pc says, frames that
    are no activation frames need to have their program counter
    decremented by one to properly find the function of the caller.
    
    This fixes many cases where perf report currently attributes
    the cost to the next line. I.e. I have code like this:
    
    ~~~~~~~~~~~~~~~
      #include <thread>
      #include <chrono>
    
      using namespace std;
    
      int main()
      {
        this_thread::sleep_for(chrono::milliseconds(1000));
        this_thread::sleep_for(chrono::milliseconds(100));
        this_thread::sleep_for(chrono::milliseconds(10));
    
        return 0;
      }
    ~~~~~~~~~~~~~~~
    
    Now compile and record it:
    
    ~~~~~~~~~~~~~~~
      g++ -std=c++11 -g -O2 test.cpp
      echo 1 | sudo tee /proc/sys/kernel/sched_schedstats
      perf record \
        --event sched:sched_stat_sleep \
        --event sched:sched_process_exit \
        --event sched:sched_switch --call-graph=dwarf \
        --output perf.data.raw \
        ./a.out
      echo 0 | sudo tee /proc/sys/kernel/sched_schedstats
      perf inject --sched-stat --input perf.data.raw --output perf.data
    ~~~~~~~~~~~~~~~
    
    Before this patch, the report clearly shows the off-by-one issue.
    Most notably, the last sleep invocation is incorrectly attributed
    to the "return 0;" line:
    
    ~~~~~~~~~~~~~~~
      Overhead  Source:Line
      ........  ...........
    
       100.00%  core.c:0
                |
                ---__schedule core.c:0
                   schedule
                   do_nanosleep hrtimer.c:0
                   hrtimer_nanosleep
                   sys_nanosleep
                   entry_SYSCALL_64_fastpath .tmp_entry_64.o:0
                   __nanosleep_nocancel .:0
                   std::this_thread::sleep_for<long, std::ratio<1l, 1000l> > thread:323
                   |
                   |--90.08%--main test.cpp:9
                   |          __libc_start_main
                   |          _start
                   |
                   |--9.01%--main test.cpp:10
                   |          __libc_start_main
                   |          _start
                   |
                    --0.91%--main test.cpp:13
                              __libc_start_main
                              _start
    ~~~~~~~~~~~~~~~
    
    With this patch here applied, the issue is fixed. The report becomes
    much more usable:
    
    ~~~~~~~~~~~~~~~
      Overhead  Source:Line
      ........  ...........
    
       100.00%  core.c:0
                |
                ---__schedule core.c:0
                   schedule
                   do_nanosleep hrtimer.c:0
                   hrtimer_nanosleep
                   sys_nanosleep
                   entry_SYSCALL_64_fastpath .tmp_entry_64.o:0
                   __nanosleep_nocancel .:0
                   std::this_thread::sleep_for<long, std::ratio<1l, 1000l> > thread:323
                   |
                   |--90.08%--main test.cpp:8
                   |          __libc_start_main
                   |          _start
                   |
                   |--9.01%--main test.cpp:9
                   |          __libc_start_main
                   |          _start
                   |
                    --0.91%--main test.cpp:10
                              __libc_start_main
                              _start
    ~~~~~~~~~~~~~~~
    
    Similarly it works for signal frames:
    
    ~~~~~~~~~~~~~~~
      __noinline void bar(void)
      {
        volatile long cnt = 0;
    
        for (cnt = 0; cnt < 100000000; cnt++);
      }
    
      __noinline void foo(void)
      {
        bar();
      }
    
      void sig_handler(int sig)
      {
        foo();
      }
    
      int main(void)
      {
        signal(SIGUSR1, sig_handler);
        raise(SIGUSR1);
    
        foo();
        return 0;
      }
    ~~~~~~~~~~~~~~~~
    
    Before, the report wrongly points to `signal.c:29` after raise():
    
    ~~~~~~~~~~~~~~~~
      $ perf report --stdio --no-children -g srcline -s srcline
      ...
       100.00%  signal.c:11
                |
                ---bar signal.c:11
                   |
                   |--50.49%--main signal.c:29
                   |          __libc_start_main
                   |          _start
                   |
                    --49.51%--0x33a8f
                              raise .:0
                              main signal.c:29
                              __libc_start_main
                              _start
    ~~~~~~~~~~~~~~~~
    
    With this patch in, the issue is fixed and we instead get:
    
    ~~~~~~~~~~~~~~~~
       100.00%  signal   signal            [.] bar
                |
                ---bar signal.c:11
                   |
                   |--50.49%--main signal.c:29
                   |          __libc_start_main
                   |          _start
                   |
                    --49.51%--0x33a8f
                              raise .:0
                              main signal.c:27
                              __libc_start_main
                              _start
    ~~~~~~~~~~~~~~~~
    
    Note how this patch fixes this issue for both unwinding methods, i.e.
    both dwfl and libunwind. The former case is straight-forward thanks
    to dwfl_frame_pc(). For libunwind, we replace the functionality via
    unw_is_signal_frame() for any but the very first frame.
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yao Jin <yao.jin@linux.intel.com>
    Cc: kernel-team@lge.com
    Link: http://lkml.kernel.org/r/20170524062129.32529-4-namhyung@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index f90e11a555b2..943a06291587 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -168,12 +168,16 @@ frame_callback(Dwfl_Frame *state, void *arg)
 {
 	struct unwind_info *ui = arg;
 	Dwarf_Addr pc;
+	bool isactivation;
 
-	if (!dwfl_frame_pc(state, &pc, NULL)) {
+	if (!dwfl_frame_pc(state, &pc, &isactivation)) {
 		pr_err("%s", dwfl_errmsg(-1));
 		return DWARF_CB_ABORT;
 	}
 
+	if (!isactivation)
+		--pc;
+
 	return entry(pc, ui) || !(--ui->max_stack) ?
 	       DWARF_CB_ABORT : DWARF_CB_OK;
 }

commit 9a3993d408bc61b839de1a2c6c783477a04860bb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 18 11:33:48 2017 -0300

    perf tools: Move path related functions to util/path.h
    
    Disentangling util.h header mess a bit more.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-aj6je8ly377i4upedmjzdsq6@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 783a53fb7a4e..f90e11a555b2 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -12,6 +12,7 @@
 #include "event.h"
 #include "perf_regs.h"
 #include "callchain.h"
+#include "util.h"
 
 static char *debuginfo_path;
 

commit 67540759151aefafddade3e27c4671ab7b3d230f
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Tue Aug 16 17:39:26 2016 +0200

    perf unwind: Use addr_location::addr instead of ip for entries
    
    This fixes the srcline translation for call chains of user space
    applications.
    
    Before we got:
    
        perf report --stdio --no-children -s sym,srcline -g address
         8.92%  [.] main                                 mandelbrot.h:41
                |
                |--3.70%--main +8390240
                |          __libc_start_main +139950056726769
                |          _start +8388650
                |
                |--2.74%--main +8390189
                |
                 --2.08%--main +8390296
                           __libc_start_main +139950056726769
                           _start +8388650
    
         7.59%  [.] main                                 complex:1326
                |
                |--4.79%--main +8390203
                |          __libc_start_main +139950056726769
                |          _start +8388650
                |
                 --2.80%--main +8390219
    
         7.12%  [.] __muldc3                             libgcc2.c:1945
                |
                |--3.76%--__muldc3 +139950060519490
                |          main +8390224
                |          __libc_start_main +139950056726769
                |          _start +8388650
                |
                 --3.32%--__muldc3 +139950060519512
                           main +8390224
    
    With this patch applied, we instead get:
    
        perf report --stdio --no-children -s sym,srcline -g address
         8.92%  [.] main                                 mandelbrot.h:41
                |
                |--3.70%--main mandelbrot.h:41
                |          __libc_start_main +241
                |          _start +4194346
                |
                |--2.74%--main mandelbrot.h:41
                |
                 --2.08%--main mandelbrot.h:41
                           __libc_start_main +241
                           _start +4194346
    
         7.59%  [.] main                                 complex:1326
                |
                |--4.79%--main complex:1326
                |          __libc_start_main +241
                |          _start +4194346
                |
                 --2.80%--main complex:1326
    
         7.12%  [.] __muldc3                             libgcc2.c:1945
                |
                |--3.76%--__muldc3 libgcc2.c:1945
                |          main mandelbrot.h:39
                |          __libc_start_main +241
                |          _start +4194346
                |
                 --3.32%--__muldc3 libgcc2.c:1945
                           main mandelbrot.h:39
    
    Suggested-and-Acked-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    LPU-Reference: 20160816153926.11288-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index cf5e250bc78e..783a53fb7a4e 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -66,7 +66,7 @@ static int entry(u64 ip, struct unwind_info *ui)
 	if (__report_module(&al, ip, ui))
 		return -1;
 
-	e->ip  = ip;
+	e->ip  = al.addr;
 	e->map = al.map;
 	e->sym = al.sym;
 

commit 0ba98149f8c8b6b2ba36be9938afb731fa719004
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Thu Jan 7 10:14:02 2016 +0100

    perf libdw: Check for mmaps also in MAP__VARIABLE tree
    
    We've seen cases (softice) where DWARF unwinder went through non
    executable mmaps, which we need to lookup in MAP__VARIABLE tree.
    
    Reported-and-Tested-by: Noel Grandin <noelgrandin@gmail.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1452158050-28061-6-git-send-email-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index db8142ba7cb9..cf5e250bc78e 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -95,6 +95,16 @@ static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
 
 	thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 			      MAP__FUNCTION, addr, &al);
+	if (!al.map) {
+		/*
+		 * We've seen cases (softice) where DWARF unwinder went
+		 * through non executable mmaps, which we need to lookup
+		 * in MAP__VARIABLE tree.
+		 */
+		thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
+				      MAP__VARIABLE, addr, &al);
+	}
+
 	if (!al.map) {
 		pr_debug("unwind: no map for %lx\n", (unsigned long)addr);
 		return -1;

commit 8bd508b001629a5d836987d9a0702a6bfc4fc705
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Thu Nov 19 14:01:19 2015 +0100

    perf callchain: Add order support for libdw DWARF unwinder
    
    As reported by Milian, currently for DWARF unwind (both libdw and
    libunwind) we display callchain in callee order only.
    
    Adding the support to follow callchain order setup to libdw DWARF
    unwinder, so we could get following output for report:
    
      $ perf record --call-graph dwarf ls
      ...
    
      $ perf report --no-children --stdio
    
        21.12%  ls       libc-2.21.so      [.] __strcoll_l
                     |
                     ---__strcoll_l
                        mpsort_with_tmp
                        mpsort_with_tmp
                        mpsort_with_tmp
                        sort_files
                        main
                        __libc_start_main
                        _start
    
      $ perf report --stdio --no-children -g caller
    
        21.12%  ls       libc-2.21.so      [.] __strcoll_l
                     |
                     ---_start
                        __libc_start_main
                        main
                        sort_files
                        mpsort_with_tmp
                        mpsort_with_tmp
                        mpsort_with_tmp
                        __strcoll_l
    
    Reported-and-Tested-by: Milian Wolff <milian.wolff@kdab.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Wang Nan <wangnan0@huawei.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jan Kratochvil <jkratoch@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20151119130119.GA26617@krava.brq.redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 2dcfe9a7c8d0..db8142ba7cb9 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -11,6 +11,7 @@
 #include <linux/types.h>
 #include "event.h"
 #include "perf_regs.h"
+#include "callchain.h"
 
 static char *debuginfo_path;
 
@@ -52,25 +53,28 @@ static int report_module(u64 ip, struct unwind_info *ui)
 	return __report_module(&al, ip, ui);
 }
 
+/*
+ * Store all entries within entries array,
+ * we will process it after we finish unwind.
+ */
 static int entry(u64 ip, struct unwind_info *ui)
 
 {
-	struct unwind_entry e;
+	struct unwind_entry *e = &ui->entries[ui->idx++];
 	struct addr_location al;
 
 	if (__report_module(&al, ip, ui))
 		return -1;
 
-	e.ip  = ip;
-	e.map = al.map;
-	e.sym = al.sym;
+	e->ip  = ip;
+	e->map = al.map;
+	e->sym = al.sym;
 
 	pr_debug("unwind: %s:ip = 0x%" PRIx64 " (0x%" PRIx64 ")\n",
 		 al.sym ? al.sym->name : "''",
 		 ip,
 		 al.map ? al.map->map_ip(al.map, ip) : (u64) 0);
-
-	return ui->cb(&e, ui->arg);
+	return 0;
 }
 
 static pid_t next_thread(Dwfl *dwfl, void *arg, void **thread_argp)
@@ -168,7 +172,7 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 			struct perf_sample *data,
 			int max_stack)
 {
-	struct unwind_info ui = {
+	struct unwind_info *ui, ui_buf = {
 		.sample		= data,
 		.thread		= thread,
 		.machine	= thread->mg->machine,
@@ -177,35 +181,54 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 		.max_stack	= max_stack,
 	};
 	Dwarf_Word ip;
-	int err = -EINVAL;
+	int err = -EINVAL, i;
 
 	if (!data->user_regs.regs)
 		return -EINVAL;
 
-	ui.dwfl = dwfl_begin(&offline_callbacks);
-	if (!ui.dwfl)
+	ui = zalloc(sizeof(ui_buf) + sizeof(ui_buf.entries[0]) * max_stack);
+	if (!ui)
+		return -ENOMEM;
+
+	*ui = ui_buf;
+
+	ui->dwfl = dwfl_begin(&offline_callbacks);
+	if (!ui->dwfl)
 		goto out;
 
 	err = perf_reg_value(&ip, &data->user_regs, PERF_REG_IP);
 	if (err)
 		goto out;
 
-	err = report_module(ip, &ui);
+	err = report_module(ip, ui);
 	if (err)
 		goto out;
 
-	if (!dwfl_attach_state(ui.dwfl, EM_NONE, thread->tid, &callbacks, &ui))
+	if (!dwfl_attach_state(ui->dwfl, EM_NONE, thread->tid, &callbacks, ui))
 		goto out;
 
-	err = dwfl_getthread_frames(ui.dwfl, thread->tid, frame_callback, &ui);
+	err = dwfl_getthread_frames(ui->dwfl, thread->tid, frame_callback, ui);
 
-	if (err && !ui.max_stack)
+	if (err && !ui->max_stack)
 		err = 0;
 
+	/*
+	 * Display what we got based on the order setup.
+	 */
+	for (i = 0; i < ui->idx && !err; i++) {
+		int j = i;
+
+		if (callchain_param.order == ORDER_CALLER)
+			j = ui->idx - i - 1;
+
+		err = ui->entries[j].ip ? ui->cb(&ui->entries[j], ui->arg) : 0;
+	}
+
  out:
 	if (err)
 		pr_debug("unwind: failed with '%s'\n", dwfl_errmsg(-1));
 
-	dwfl_end(ui.dwfl);
+	dwfl_end(ui->dwfl);
+	free(ui);
 	return 0;
 }

commit dd8c17a5fe80148aab8844e8774cf341212a4eb1
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Oct 23 16:42:19 2014 -0300

    perf callchains: Use thread->mg->machine
    
    The unwind__get_entries() already receives the thread parameter, from where it can
    obtain the matching machine structure, shorten the signature.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-isjc6bm8mv4612mhi6af64go@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index f24b350ab192..2dcfe9a7c8d0 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -164,14 +164,14 @@ frame_callback(Dwfl_Frame *state, void *arg)
 }
 
 int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
-			struct machine *machine, struct thread *thread,
+			struct thread *thread,
 			struct perf_sample *data,
 			int max_stack)
 {
 	struct unwind_info ui = {
 		.sample		= data,
 		.thread		= thread,
-		.machine	= machine,
+		.machine	= thread->mg->machine,
 		.cb		= cb,
 		.arg		= arg,
 		.max_stack	= max_stack,

commit bb871a9c8d68692ed2513b3f0e1c010c2ac12f44
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Oct 23 12:50:25 2014 -0300

    perf tools: A thread's machine can be found via thread->mg->machine
    
    So stop passing both machine and thread to several thread methods,
    reducing function signature length.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-ckcy19dcp1jfkmdihdjcqdn1@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 7419768c38b1..f24b350ab192 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -26,7 +26,7 @@ static int __report_module(struct addr_location *al, u64 ip,
 	Dwfl_Module *mod;
 	struct dso *dso = NULL;
 
-	thread__find_addr_location(ui->thread, ui->machine,
+	thread__find_addr_location(ui->thread,
 				   PERF_RECORD_MISC_USER,
 				   MAP__FUNCTION, ip, al);
 
@@ -89,7 +89,7 @@ static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
 	struct addr_location al;
 	ssize_t size;
 
-	thread__find_addr_map(ui->thread, ui->machine, PERF_RECORD_MISC_USER,
+	thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 			      MAP__FUNCTION, addr, &al);
 	if (!al.map) {
 		pr_debug("unwind: no map for %lx\n", (unsigned long)addr);

commit 84f5d36f486609277801e827241396334185d11c
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Jul 14 23:46:48 2014 +0200

    perf tools: Move pr_* debug macros into debug object
    
    Moving pr_* debug macros to have it with in same object as debug
    variables, becase we will change them to use verbose variable in next
    patch.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1405374411-29012-3-git-send-email-jolsa@kernel.org
    [ Add missing debug.h include in python scripting glue and in the libdw unwind lib ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 5ec80a575b50..7419768c38b1 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -3,6 +3,7 @@
 #include <elfutils/libdwfl.h>
 #include <inttypes.h>
 #include <errno.h>
+#include "debug.h"
 #include "unwind.h"
 #include "unwind-libdw.h"
 #include "machine.h"

commit d944c4eebcf4c0d5e5d9728fec110cbf0047ad7f
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Apr 25 21:31:02 2014 +0200

    tools: Consolidate types.h
    
    Combine all definitions into a common tools/include/linux/types.h and
    kill the wild growth elsewhere. Move DECLARE_BITMAP to its proper
    bitmap.h header.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Link: http://lkml.kernel.org/n/tip-azczs7qcv6h9xek9od10hiv2@git.kernel.org
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index 67db73ec3dab..5ec80a575b50 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -7,7 +7,7 @@
 #include "unwind-libdw.h"
 #include "machine.h"
 #include "thread.h"
-#include "types.h"
+#include <linux/types.h>
 #include "event.h"
 #include "perf_regs.h"
 

commit 5ea8415407a76c4a85ac971ec82d110161cd77f1
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Wed Feb 19 16:52:57 2014 +0100

    perf tools: Add libdw DWARF post unwind support
    
    Adding libdw DWARF post unwind support, which is part of
    elfutils-devel/libdw-dev package from version 0.158.
    
    The new code is contained in unwin-libdw.c object, and implements
    unwind__get_entries unwind interface function.
    
    New Makefile variable NO_LIBDW_DWARF_UNWIND was added to control its
    compilation, and is marked as disabled now.  It's factored with the rest
    of the Makefile unwind build code in the next patch.
    
    Arch specific code was added for x86.
    
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jean Pihet <jean.pihet@linaro.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1392825179-5228-5-git-send-email-jolsa@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
new file mode 100644
index 000000000000..67db73ec3dab
--- /dev/null
+++ b/tools/perf/util/unwind-libdw.c
@@ -0,0 +1,210 @@
+#include <linux/compiler.h>
+#include <elfutils/libdw.h>
+#include <elfutils/libdwfl.h>
+#include <inttypes.h>
+#include <errno.h>
+#include "unwind.h"
+#include "unwind-libdw.h"
+#include "machine.h"
+#include "thread.h"
+#include "types.h"
+#include "event.h"
+#include "perf_regs.h"
+
+static char *debuginfo_path;
+
+static const Dwfl_Callbacks offline_callbacks = {
+	.find_debuginfo		= dwfl_standard_find_debuginfo,
+	.debuginfo_path		= &debuginfo_path,
+	.section_address	= dwfl_offline_section_address,
+};
+
+static int __report_module(struct addr_location *al, u64 ip,
+			    struct unwind_info *ui)
+{
+	Dwfl_Module *mod;
+	struct dso *dso = NULL;
+
+	thread__find_addr_location(ui->thread, ui->machine,
+				   PERF_RECORD_MISC_USER,
+				   MAP__FUNCTION, ip, al);
+
+	if (al->map)
+		dso = al->map->dso;
+
+	if (!dso)
+		return 0;
+
+	mod = dwfl_addrmodule(ui->dwfl, ip);
+	if (!mod)
+		mod = dwfl_report_elf(ui->dwfl, dso->short_name,
+				      dso->long_name, -1, al->map->start,
+				      false);
+
+	return mod && dwfl_addrmodule(ui->dwfl, ip) == mod ? 0 : -1;
+}
+
+static int report_module(u64 ip, struct unwind_info *ui)
+{
+	struct addr_location al;
+
+	return __report_module(&al, ip, ui);
+}
+
+static int entry(u64 ip, struct unwind_info *ui)
+
+{
+	struct unwind_entry e;
+	struct addr_location al;
+
+	if (__report_module(&al, ip, ui))
+		return -1;
+
+	e.ip  = ip;
+	e.map = al.map;
+	e.sym = al.sym;
+
+	pr_debug("unwind: %s:ip = 0x%" PRIx64 " (0x%" PRIx64 ")\n",
+		 al.sym ? al.sym->name : "''",
+		 ip,
+		 al.map ? al.map->map_ip(al.map, ip) : (u64) 0);
+
+	return ui->cb(&e, ui->arg);
+}
+
+static pid_t next_thread(Dwfl *dwfl, void *arg, void **thread_argp)
+{
+	/* We want only single thread to be processed. */
+	if (*thread_argp != NULL)
+		return 0;
+
+	*thread_argp = arg;
+	return dwfl_pid(dwfl);
+}
+
+static int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,
+			  Dwarf_Word *data)
+{
+	struct addr_location al;
+	ssize_t size;
+
+	thread__find_addr_map(ui->thread, ui->machine, PERF_RECORD_MISC_USER,
+			      MAP__FUNCTION, addr, &al);
+	if (!al.map) {
+		pr_debug("unwind: no map for %lx\n", (unsigned long)addr);
+		return -1;
+	}
+
+	if (!al.map->dso)
+		return -1;
+
+	size = dso__data_read_addr(al.map->dso, al.map, ui->machine,
+				   addr, (u8 *) data, sizeof(*data));
+
+	return !(size == sizeof(*data));
+}
+
+static bool memory_read(Dwfl *dwfl __maybe_unused, Dwarf_Addr addr, Dwarf_Word *result,
+			void *arg)
+{
+	struct unwind_info *ui = arg;
+	struct stack_dump *stack = &ui->sample->user_stack;
+	u64 start, end;
+	int offset;
+	int ret;
+
+	ret = perf_reg_value(&start, &ui->sample->user_regs, PERF_REG_SP);
+	if (ret)
+		return false;
+
+	end = start + stack->size;
+
+	/* Check overflow. */
+	if (addr + sizeof(Dwarf_Word) < addr)
+		return false;
+
+	if (addr < start || addr + sizeof(Dwarf_Word) > end) {
+		ret = access_dso_mem(ui, addr, result);
+		if (ret) {
+			pr_debug("unwind: access_mem 0x%" PRIx64 " not inside range"
+				 " 0x%" PRIx64 "-0x%" PRIx64 "\n",
+				addr, start, end);
+			return false;
+		}
+		return true;
+	}
+
+	offset  = addr - start;
+	*result = *(Dwarf_Word *)&stack->data[offset];
+	pr_debug("unwind: access_mem addr 0x%" PRIx64 ", val %lx, offset %d\n",
+		 addr, (unsigned long)*result, offset);
+	return true;
+}
+
+static const Dwfl_Thread_Callbacks callbacks = {
+	.next_thread		= next_thread,
+	.memory_read		= memory_read,
+	.set_initial_registers	= libdw__arch_set_initial_registers,
+};
+
+static int
+frame_callback(Dwfl_Frame *state, void *arg)
+{
+	struct unwind_info *ui = arg;
+	Dwarf_Addr pc;
+
+	if (!dwfl_frame_pc(state, &pc, NULL)) {
+		pr_err("%s", dwfl_errmsg(-1));
+		return DWARF_CB_ABORT;
+	}
+
+	return entry(pc, ui) || !(--ui->max_stack) ?
+	       DWARF_CB_ABORT : DWARF_CB_OK;
+}
+
+int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
+			struct machine *machine, struct thread *thread,
+			struct perf_sample *data,
+			int max_stack)
+{
+	struct unwind_info ui = {
+		.sample		= data,
+		.thread		= thread,
+		.machine	= machine,
+		.cb		= cb,
+		.arg		= arg,
+		.max_stack	= max_stack,
+	};
+	Dwarf_Word ip;
+	int err = -EINVAL;
+
+	if (!data->user_regs.regs)
+		return -EINVAL;
+
+	ui.dwfl = dwfl_begin(&offline_callbacks);
+	if (!ui.dwfl)
+		goto out;
+
+	err = perf_reg_value(&ip, &data->user_regs, PERF_REG_IP);
+	if (err)
+		goto out;
+
+	err = report_module(ip, &ui);
+	if (err)
+		goto out;
+
+	if (!dwfl_attach_state(ui.dwfl, EM_NONE, thread->tid, &callbacks, &ui))
+		goto out;
+
+	err = dwfl_getthread_frames(ui.dwfl, thread->tid, frame_callback, &ui);
+
+	if (err && !ui.max_stack)
+		err = 0;
+
+ out:
+	if (err)
+		pr_debug("unwind: failed with '%s'\n", dwfl_errmsg(-1));
+
+	dwfl_end(ui.dwfl);
+	return 0;
+}
