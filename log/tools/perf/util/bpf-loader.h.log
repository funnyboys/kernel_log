commit 63503dba87acfab49280d3b05df6705a6f327e8a
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Sun Jul 21 13:23:52 2019 +0200

    perf evlist: Rename struct perf_evlist to struct evlist
    
    Rename struct perf_evlist to struct evlist, so we don't have a name
    clash when we add struct perf_evlist in libperf.
    
    Committer notes:
    
    Added fixes to build on arm64, from Jiri and from me
    (tools/perf/util/cs-etm.c)
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20190721112506.12306-6-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index e2048c978a24..25251d63164c 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -40,7 +40,7 @@ enum bpf_loader_errno {
 };
 
 struct evsel;
-struct perf_evlist;
+struct evlist;
 struct bpf_object;
 struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
@@ -70,18 +70,18 @@ int bpf__foreach_event(struct bpf_object *obj,
 		       bpf_prog_iter_callback_t func, void *arg);
 
 int bpf__config_obj(struct bpf_object *obj, struct parse_events_term *term,
-		    struct perf_evlist *evlist, int *error_pos);
+		    struct evlist *evlist, int *error_pos);
 int bpf__strerror_config_obj(struct bpf_object *obj,
 			     struct parse_events_term *term,
-			     struct perf_evlist *evlist,
+			     struct evlist *evlist,
 			     int *error_pos, int err, char *buf,
 			     size_t size);
 int bpf__apply_obj_config(void);
 int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 
-int bpf__setup_stdout(struct perf_evlist *evlist);
-struct evsel *bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
-int bpf__strerror_setup_output_event(struct perf_evlist *evlist, int err, char *buf, size_t size);
+int bpf__setup_stdout(struct evlist *evlist);
+struct evsel *bpf__setup_output_event(struct evlist *evlist, const char *name);
+int bpf__strerror_setup_output_event(struct evlist *evlist, int err, char *buf, size_t size);
 #else
 #include <errno.h>
 #include <string.h>
@@ -119,7 +119,7 @@ bpf__foreach_event(struct bpf_object *obj __maybe_unused,
 static inline int
 bpf__config_obj(struct bpf_object *obj __maybe_unused,
 		struct parse_events_term *term __maybe_unused,
-		struct perf_evlist *evlist __maybe_unused,
+		struct evlist *evlist __maybe_unused,
 		int *error_pos __maybe_unused)
 {
 	return 0;
@@ -132,13 +132,13 @@ bpf__apply_obj_config(void)
 }
 
 static inline int
-bpf__setup_stdout(struct perf_evlist *evlist __maybe_unused)
+bpf__setup_stdout(struct evlist *evlist __maybe_unused)
 {
 	return 0;
 }
 
 static inline struct evsel *
-bpf__setup_output_event(struct perf_evlist *evlist __maybe_unused, const char *name __maybe_unused)
+bpf__setup_output_event(struct evlist *evlist __maybe_unused, const char *name __maybe_unused)
 {
 	return NULL;
 }
@@ -182,7 +182,7 @@ static inline int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
 static inline int
 bpf__strerror_config_obj(struct bpf_object *obj __maybe_unused,
 			 struct parse_events_term *term __maybe_unused,
-			 struct perf_evlist *evlist __maybe_unused,
+			 struct evlist *evlist __maybe_unused,
 			 int *error_pos __maybe_unused,
 			 int err __maybe_unused,
 			 char *buf, size_t size)
@@ -198,7 +198,7 @@ bpf__strerror_apply_obj_config(int err __maybe_unused,
 }
 
 static inline int
-bpf__strerror_setup_output_event(struct perf_evlist *evlist __maybe_unused,
+bpf__strerror_setup_output_event(struct evlist *evlist __maybe_unused,
 				 int err __maybe_unused, char *buf, size_t size)
 {
 	return __bpf_strerror(buf, size);
@@ -206,7 +206,7 @@ bpf__strerror_setup_output_event(struct perf_evlist *evlist __maybe_unused,
 
 #endif
 
-static inline int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err, char *buf, size_t size)
+static inline int bpf__strerror_setup_stdout(struct evlist *evlist, int err, char *buf, size_t size)
 {
 	return bpf__strerror_setup_output_event(evlist, err, buf, size);
 }

commit 32dcd021d004038ca12ac17319da5aa4756e9312
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Sun Jul 21 13:23:51 2019 +0200

    perf evsel: Rename struct perf_evsel to struct evsel
    
    Rename struct perf_evsel to struct evsel, so we don't have a name clash
    when we add struct perf_evsel in libperf.
    
    Committer notes:
    
    Added fixes for arm64, provided by Jiri.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20190721112506.12306-5-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 8c3441a4b72c..e2048c978a24 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -39,7 +39,7 @@ enum bpf_loader_errno {
 	__BPF_LOADER_ERRNO__END,
 };
 
-struct perf_evsel;
+struct evsel;
 struct perf_evlist;
 struct bpf_object;
 struct parse_events_term;
@@ -80,7 +80,7 @@ int bpf__apply_obj_config(void);
 int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 
 int bpf__setup_stdout(struct perf_evlist *evlist);
-struct perf_evsel *bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
+struct evsel *bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
 int bpf__strerror_setup_output_event(struct perf_evlist *evlist, int err, char *buf, size_t size);
 #else
 #include <errno.h>
@@ -137,7 +137,7 @@ bpf__setup_stdout(struct perf_evlist *evlist __maybe_unused)
 	return 0;
 }
 
-static inline struct perf_evsel *
+static inline struct evsel *
 bpf__setup_output_event(struct perf_evlist *evlist __maybe_unused, const char *name __maybe_unused)
 {
 	return NULL;

commit af4a0991f40a1e50e5caff0317f152df2c82bdeb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Jul 15 16:22:57 2019 -0300

    perf evsel: Store backpointer to attached bpf_object
    
    We may want to get to this bpf_object, to search for other BPF programs,
    etc.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Luis Cláudio Gonçalves <lclaudio@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-3y8hrb6lszjfi23vjlic3cib@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 3f46856e3330..8c3441a4b72c 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -46,7 +46,7 @@ struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
 typedef int (*bpf_prog_iter_callback_t)(const char *group, const char *event,
-					int fd, void *arg);
+					int fd, struct bpf_object *obj, void *arg);
 
 #ifdef HAVE_LIBBPF_SUPPORT
 struct bpf_object *bpf__prepare_load(const char *filename, bool source);

commit ebc52aee6130653b934a86637108ac2a7c95c74c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Jan 29 13:06:18 2019 +0100

    perf bpf-loader: Remove unecessary includes from bpf-loader.h
    
    To cut the header dep tree, to get unecessary object rebuilds to be
    reduced when a change happens in headers.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-ph72xhl9moqa0g1hxcyudwfn@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 62d245a90e1d..3f46856e3330 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -8,11 +8,7 @@
 
 #include <linux/compiler.h>
 #include <linux/err.h>
-#include <string.h>
 #include <bpf/libbpf.h>
-#include "probe-event.h"
-#include "evlist.h"
-#include "debug.h"
 
 enum bpf_loader_errno {
 	__BPF_LOADER_ERRNO__START = __LIBBPF_ERRNO__START - 100,
@@ -44,6 +40,7 @@ enum bpf_loader_errno {
 };
 
 struct perf_evsel;
+struct perf_evlist;
 struct bpf_object;
 struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
@@ -87,6 +84,8 @@ struct perf_evsel *bpf__setup_output_event(struct perf_evlist *evlist, const cha
 int bpf__strerror_setup_output_event(struct perf_evlist *evlist, int err, char *buf, size_t size);
 #else
 #include <errno.h>
+#include <string.h>
+#include "debug.h"
 
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused,

commit 78e890ea8683f7d570f911637b23b23d27be4aed
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Aug 7 16:19:05 2018 -0300

    perf bpf: Make bpf__setup_output_event() return the bpf-output event
    
    We're calling it to setup that event, and we'll need it later to decide
    if the bpf-output event we're handling is the one setup for a specific
    purpose, return it using ERR_PTR, etc.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-zhachv7il2n1lopt9aonwhu7@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 8eca75145ac2..62d245a90e1d 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -43,6 +43,7 @@ enum bpf_loader_errno {
 	__BPF_LOADER_ERRNO__END,
 };
 
+struct perf_evsel;
 struct bpf_object;
 struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
@@ -82,7 +83,7 @@ int bpf__apply_obj_config(void);
 int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 
 int bpf__setup_stdout(struct perf_evlist *evlist);
-int bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
+struct perf_evsel *bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
 int bpf__strerror_setup_output_event(struct perf_evlist *evlist, int err, char *buf, size_t size);
 #else
 #include <errno.h>
@@ -137,10 +138,10 @@ bpf__setup_stdout(struct perf_evlist *evlist __maybe_unused)
 	return 0;
 }
 
-static inline int
+static inline struct perf_evsel *
 bpf__setup_output_event(struct perf_evlist *evlist __maybe_unused, const char *name __maybe_unused)
 {
-	return 0;
+	return NULL;
 }
 
 static inline int

commit aa31be3a4874d91fb40d872f1865805ab411035c
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Aug 6 11:35:37 2018 -0300

    perf bpf: Add bpf__setup_output_event() strerror() counterpart
    
    That is just bpf__strerror_setup_stdout() renamed to the more general
    "setup_output_event" method, keep the existing stdout() as a wrapper.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-nwnveo428qn0b48axj50vkc7@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 6be0eec043c6..8eca75145ac2 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -83,9 +83,7 @@ int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 
 int bpf__setup_stdout(struct perf_evlist *evlist);
 int bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
-int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err,
-			       char *buf, size_t size);
-
+int bpf__strerror_setup_output_event(struct perf_evlist *evlist, int err, char *buf, size_t size);
 #else
 #include <errno.h>
 
@@ -200,11 +198,16 @@ bpf__strerror_apply_obj_config(int err __maybe_unused,
 }
 
 static inline int
-bpf__strerror_setup_stdout(struct perf_evlist *evlist __maybe_unused,
-			   int err __maybe_unused, char *buf,
-			   size_t size)
+bpf__strerror_setup_output_event(struct perf_evlist *evlist __maybe_unused,
+				 int err __maybe_unused, char *buf, size_t size)
 {
 	return __bpf_strerror(buf, size);
 }
+
 #endif
+
+static inline int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err, char *buf, size_t size)
+{
+	return bpf__strerror_setup_output_event(evlist, err, buf, size);
+}
 #endif

commit 92bbe8d834d293c4db7a70fd53884ec1c95d61dc
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Aug 6 09:53:35 2018 -0300

    perf bpf: Generalize bpf__setup_stdout()
    
    We will use it to set up other bpf-output events, for instance to
    generate augmented syscall entry tracepoints with pointer contents.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-4r7kw0nsyi4vyz6xm1tzx6a3@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 5d3aefd6fae7..6be0eec043c6 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -82,6 +82,7 @@ int bpf__apply_obj_config(void);
 int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 
 int bpf__setup_stdout(struct perf_evlist *evlist);
+int bpf__setup_output_event(struct perf_evlist *evlist, const char *name);
 int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err,
 			       char *buf, size_t size);
 
@@ -138,6 +139,12 @@ bpf__setup_stdout(struct perf_evlist *evlist __maybe_unused)
 	return 0;
 }
 
+static inline int
+bpf__setup_output_event(struct perf_evlist *evlist __maybe_unused, const char *name __maybe_unused)
+{
+	return 0;
+}
+
 static inline int
 __bpf_strerror(char *buf, size_t size)
 {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 48863867878b..5d3aefd6fae7 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2015, Wang Nan <wangnan0@huawei.com>
  * Copyright (C) 2015, Huawei Inc.

commit a43783aeec5fac8ef372ff8c0a5bbb3056fc0604
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 18 10:46:11 2017 -0300

    perf tools: Include errno.h where needed
    
    Removing it from util.h, part of an effort to disentangle the includes
    hell, that makes changes to util.h or something included by it to cause
    a complete rebuild of the tools.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-ztrjy52q1rqcchuy3rubfgt2@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index f2b737b225f2..48863867878b 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -85,6 +85,8 @@ int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err,
 			       char *buf, size_t size);
 
 #else
+#include <errno.h>
+
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused,
 		  bool source __maybe_unused)

commit cd102d70fe957b060b9df6bc4f54684de3fe00cd
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 13 10:44:04 2016 +0000

    perf bpf: Rename bpf__foreach_tev() to bpf__foreach_event()
    
    Following commit will allow BPF script attach to tracepoints.
    bpf__foreach_tev() will iterate over all events, not only kprobes.
    Rename it to bpf__foreach_event().
    
    Since only group and event are used by caller, there's no need to pass
    full 'struct probe_trace_event' to bpf_prog_iter_callback_t. Pass only
    these two strings. After this patch bpf_prog_iter_callback_t natually
    support tracepoints.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1468406646-21642-5-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 941e17275aa7..f2b737b225f2 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -46,7 +46,7 @@ struct bpf_object;
 struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
-typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
+typedef int (*bpf_prog_iter_callback_t)(const char *group, const char *event,
 					int fd, void *arg);
 
 #ifdef HAVE_LIBBPF_SUPPORT
@@ -67,8 +67,8 @@ int bpf__strerror_probe(struct bpf_object *obj, int err,
 int bpf__load(struct bpf_object *obj);
 int bpf__strerror_load(struct bpf_object *obj, int err,
 		       char *buf, size_t size);
-int bpf__foreach_tev(struct bpf_object *obj,
-		     bpf_prog_iter_callback_t func, void *arg);
+int bpf__foreach_event(struct bpf_object *obj,
+		       bpf_prog_iter_callback_t func, void *arg);
 
 int bpf__config_obj(struct bpf_object *obj, struct parse_events_term *term,
 		    struct perf_evlist *evlist, int *error_pos);
@@ -107,9 +107,9 @@ static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0
 static inline int bpf__load(struct bpf_object *obj __maybe_unused) { return 0; }
 
 static inline int
-bpf__foreach_tev(struct bpf_object *obj __maybe_unused,
-		 bpf_prog_iter_callback_t func __maybe_unused,
-		 void *arg __maybe_unused)
+bpf__foreach_event(struct bpf_object *obj __maybe_unused,
+		   bpf_prog_iter_callback_t func __maybe_unused,
+		   void *arg __maybe_unused)
 {
 	return 0;
 }

commit d78885739a7df111dc7b081f8a09e08a5fcfecc2
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Apr 8 15:07:24 2016 +0000

    perf bpf: Clone bpf stdout events in multiple bpf scripts
    
    This patch allows cloning bpf-output event configuration among multiple
    bpf scripts. If there exist a map named '__bpf_output__' and not
    configured using 'map:__bpf_output__.event=', this patch clones the
    configuration of another '__bpf_stdout__' map. For example, following
    command:
    
      # perf trace --ev bpf-output/no-inherit,name=evt/ \
                   --ev ./test_bpf_trace.c/map:__bpf_stdout__.event=evt/ \
                   --ev ./test_bpf_trace2.c usleep 100000
    
    equals to:
    
      # perf trace --ev bpf-output/no-inherit,name=evt/ \
                   --ev ./test_bpf_trace.c/map:__bpf_stdout__.event=evt/  \
                   --ev ./test_bpf_trace2.c/map:__bpf_stdout__.event=evt/ \
                   usleep 100000
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Suggested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1460128045-97310-4-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index be4311944e3d..941e17275aa7 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -79,6 +79,11 @@ int bpf__strerror_config_obj(struct bpf_object *obj,
 			     size_t size);
 int bpf__apply_obj_config(void);
 int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
+
+int bpf__setup_stdout(struct perf_evlist *evlist);
+int bpf__strerror_setup_stdout(struct perf_evlist *evlist, int err,
+			       char *buf, size_t size);
+
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused,
@@ -124,6 +129,12 @@ bpf__apply_obj_config(void)
 	return 0;
 }
 
+static inline int
+bpf__setup_stdout(struct perf_evlist *evlist __maybe_unused)
+{
+	return 0;
+}
+
 static inline int
 __bpf_strerror(char *buf, size_t size)
 {
@@ -177,5 +188,13 @@ bpf__strerror_apply_obj_config(int err __maybe_unused,
 {
 	return __bpf_strerror(buf, size);
 }
+
+static inline int
+bpf__strerror_setup_stdout(struct perf_evlist *evlist __maybe_unused,
+			   int err __maybe_unused, char *buf,
+			   size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
 #endif
 #endif

commit 2d055bf253c0d606c5de3fe7749e3188080780ad
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Feb 22 09:10:34 2016 +0000

    perf tools: Support setting different slots in a BPF map separately
    
    This patch introduces basic facilities to support config different slots
    in a BPF map one by one.
    
    array.nr_ranges and array.ranges are introduced into 'struct
    parse_events_term', where ranges is an array of indices range (start,
    length) which will be configured by this config term. nr_ranges is the
    size of the array. The array is passed to 'struct bpf_map_priv'.  To
    indicate the new type of configuration, BPF_MAP_KEY_RANGES is added as a
    new key type. bpf_map_config_foreach_key() is extended to iterate over
    those indices instead of all possible keys.
    
    Code in this commit will be enabled by following commit which enables
    the indices syntax for array configuration.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Cody P Schafer <dev@codyps.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1456132275-98875-8-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 7c7689f800cf..be4311944e3d 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -38,6 +38,7 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTDIM,	/* Event dimension too large */
 	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTINH,	/* Doesn't support inherit event */
 	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTTYPE,	/* Wrong event type for map */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_IDX2BIG,	/* Index too large */
 	__BPF_LOADER_ERRNO__END,
 };
 

commit 7630b3e28dd827fffad13cc0aada14b00ec524d9
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Feb 22 09:10:33 2016 +0000

    perf tools: Enable passing event to BPF object
    
    A new syntax is added to the parser so that the user can access
    predefined perf events in BPF objects.
    
    After this patch, BPF programs for perf are finally able to utilize
    bpf_perf_event_read() introduced in commit 35578d798400 ("bpf: Implement
    function bpf_perf_event_read() that get the selected hardware PMU
    counter").
    
    Test result:
    
      # cat test_bpf_map_2.c
      /************************ BEGIN **************************/
      #include <uapi/linux/bpf.h>
      #define SEC(NAME) __attribute__((section(NAME), used))
      struct bpf_map_def {
          unsigned int type;
          unsigned int key_size;
          unsigned int value_size;
          unsigned int max_entries;
      };
      static int (*trace_printk)(const char *fmt, int fmt_size, ...) =
          (void *)BPF_FUNC_trace_printk;
      static int (*get_smp_processor_id)(void) =
          (void *)BPF_FUNC_get_smp_processor_id;
      static int (*perf_event_read)(struct bpf_map_def *, int) =
          (void *)BPF_FUNC_perf_event_read;
    
      struct bpf_map_def SEC("maps") pmu_map = {
          .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY,
          .key_size = sizeof(int),
          .value_size = sizeof(int),
          .max_entries = __NR_CPUS__,
      };
      SEC("func_write=sys_write")
      int func_write(void *ctx)
      {
          unsigned long long val;
          char fmt[] = "sys_write:        pmu=%llu\n";
          val = perf_event_read(&pmu_map, get_smp_processor_id());
          trace_printk(fmt, sizeof(fmt), val);
          return 0;
      }
    
      SEC("func_write_return=sys_write%return")
      int func_write_return(void *ctx)
      {
          unsigned long long val = 0;
          char fmt[] = "sys_write_return: pmu=%llu\n";
          val = perf_event_read(&pmu_map, get_smp_processor_id());
          trace_printk(fmt, sizeof(fmt), val);
          return 0;
      }
      char _license[] SEC("license") = "GPL";
      int _version SEC("version") = LINUX_VERSION_CODE;
      /************************* END ***************************/
    
    Normal case:
    
      # echo "" > /sys/kernel/debug/tracing/trace
      # perf record -i -e cycles -e './test_bpf_map_2.c/map:pmu_map.event=cycles/' ls /
      [SNIP]
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.013 MB perf.data (7 samples) ]
      # cat /sys/kernel/debug/tracing/trace | grep ls
                    ls-17066 [000] d... 938449.863301: : sys_write:        pmu=1157327
                    ls-17066 [000] dN.. 938449.863342: : sys_write_return: pmu=1225218
                    ls-17066 [000] d... 938449.863349: : sys_write:        pmu=1241922
                    ls-17066 [000] dN.. 938449.863369: : sys_write_return: pmu=1267445
    
    Normal case (system wide):
    
      # echo "" > /sys/kernel/debug/tracing/trace
      # perf record -i -e cycles -e './test_bpf_map_2.c/map:pmu_map.event=cycles/' -a
      ^C[ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.811 MB perf.data (120 samples) ]
    
      # cat /sys/kernel/debug/tracing/trace | grep -v '18446744073709551594' | grep -v perf | head -n 20
      [SNIP]
      #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
      #              | |       |   ||||       |         |
                 gmain-30828 [002] d... 2740551.068992: : sys_write:        pmu=84373
                 gmain-30828 [002] d... 2740551.068992: : sys_write_return: pmu=87696
                 gmain-30828 [002] d... 2740551.068996: : sys_write:        pmu=100658
                 gmain-30828 [002] d... 2740551.068997: : sys_write_return: pmu=102572
    
    Error case 1:
    
      # perf record -e './test_bpf_map_2.c' ls /
      [SNIP]
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.014 MB perf.data ]
      # cat /sys/kernel/debug/tracing/trace | grep ls
                    ls-17115 [007] d... 2724279.665625: : sys_write:        pmu=18446744073709551614
                    ls-17115 [007] dN.. 2724279.665651: : sys_write_return: pmu=18446744073709551614
                    ls-17115 [007] d... 2724279.665658: : sys_write:        pmu=18446744073709551614
                    ls-17115 [007] dN.. 2724279.665677: : sys_write_return: pmu=18446744073709551614
    
      (18446744073709551614 is 0xfffffffffffffffe (-2))
    
    Error case 2:
    
      # perf record -e cycles -e './test_bpf_map_2.c/map:pmu_map.event=evt/' -a
      event syntax error: '..ps:pmu_map.event=evt/'
                                        \___ Event not found for map setting
    
      Hint: Valid config terms:
            map:[<arraymap>].value=[value]
            map:[<eventmap>].event=[event]
      [SNIP]
    
    Error case 3:
      # ls /proc/2348/task/
      2348  2505  2506  2507  2508
      # perf record -i -e cycles -e './test_bpf_map_2.c/map:pmu_map.event=cycles/' -p 2348
      ERROR: Apply config to BPF failed: Cannot set event to BPF map in multi-thread tracing
    
    Error case 4:
      # perf record -e cycles -e './test_bpf_map_2.c/map:pmu_map.event=cycles/' ls /
      ERROR: Apply config to BPF failed: Doesn't support inherit event (Hint: use -i to turn off inherit)
    
    Error case 5:
      # perf record -i -e raw_syscalls:sys_enter -e './test_bpf_map_2.c/map:pmu_map.event=raw_syscalls:sys_enter/' ls
      ERROR: Apply config to BPF failed: Can only put raw, hardware and BPF output event into a BPF map
    
    Error case 6:
      # perf record -i -e './test_bpf_map_2.c/map:pmu_map.event=123/' ls /
      event syntax error: '.._map.event=123/'
                                        \___ Incorrect value type for map
      [SNIP]
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Cody P Schafer <dev@codyps.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1456132275-98875-7-git-send-email-wangnan0@huawei.com
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 5d3b931f9baa..7c7689f800cf 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -33,6 +33,11 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__OBJCONF_MAP_TYPE,	/* Incorrect map type */
 	BPF_LOADER_ERRNO__OBJCONF_MAP_KEYSIZE,	/* Incorrect map key size */
 	BPF_LOADER_ERRNO__OBJCONF_MAP_VALUESIZE,/* Incorrect map value size */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_NOEVT,	/* Event not found for map setting */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_MAPSIZE,	/* Invalid map size for event setting */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTDIM,	/* Event dimension too large */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTINH,	/* Doesn't support inherit event */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_EVTTYPE,	/* Wrong event type for map */
 	__BPF_LOADER_ERRNO__END,
 };
 

commit 8690a2a773703e4ad2a07a7f3912ea6b131307cc
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Feb 22 09:10:32 2016 +0000

    perf record: Apply config to BPF objects before recording
    
    bpf__apply_obj_config() is introduced as the core API to apply object
    config options to all BPF objects. This patch also does the real work
    for setting values for BPF_MAP_TYPE_PERF_ARRAY maps by inserting value
    stored in map's private field into the BPF map.
    
    This patch is required because we are not always able to set all BPF
    config during parsing. Further patch will set events created by perf to
    BPF_MAP_TYPE_PERF_EVENT_ARRAY maps, which is not exist until
    perf_evsel__open().
    
    bpf_map_foreach_key() is introduced to iterate over each key needs to be
    configured. This function would be extended to support more map types
    and different key settings.
    
    In perf record, before start recording, call bpf__apply_config() to turn
    on all BPF config options.
    
    Test result:
    
      # cat ./test_bpf_map_1.c
      /************************ BEGIN **************************/
      #include <uapi/linux/bpf.h>
      #define SEC(NAME) __attribute__((section(NAME), used))
      struct bpf_map_def {
          unsigned int type;
          unsigned int key_size;
          unsigned int value_size;
          unsigned int max_entries;
      };
      static void *(*map_lookup_elem)(struct bpf_map_def *, void *) =
          (void *)BPF_FUNC_map_lookup_elem;
      static int (*trace_printk)(const char *fmt, int fmt_size, ...) =
          (void *)BPF_FUNC_trace_printk;
      struct bpf_map_def SEC("maps") channel = {
          .type = BPF_MAP_TYPE_ARRAY,
          .key_size = sizeof(int),
          .value_size = sizeof(int),
          .max_entries = 1,
      };
      SEC("func=sys_nanosleep")
      int func(void *ctx)
      {
          int key = 0;
          char fmt[] = "%d\n";
          int *pval = map_lookup_elem(&channel, &key);
          if (!pval)
              return 0;
          trace_printk(fmt, sizeof(fmt), *pval);
          return 0;
      }
      char _license[] SEC("license") = "GPL";
      int _version SEC("version") = LINUX_VERSION_CODE;
      /************************* END ***************************/
    
      # echo "" > /sys/kernel/debug/tracing/trace
      # ./perf record -e './test_bpf_map_1.c/map:channel.value=11/' usleep 10
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.012 MB perf.data ]
      # cat /sys/kernel/debug/tracing/trace
      # tracer: nop
      #
      # entries-in-buffer/entries-written: 1/1   #P:8
      [SNIP]
      #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
      #              | |       |   ||||       |         |
                 usleep-18593 [007] d... 2394714.395539: : 11
      # ./perf record -e './test_bpf_map_1.c/map:channel.value=101/' usleep 10
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.012 MB perf.data ]
      # cat /sys/kernel/debug/tracing/trace
      # tracer: nop
      #
      # entries-in-buffer/entries-written: 1/1   #P:8
      [SNIP]
      #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
      #              | |       |   ||||       |         |
                 usleep-18593 [007] d... 2394714.395539: : 11
                 usleep-19000 [006] d... 2394831.057840: : 101
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Cody P Schafer <dev@codyps.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1456132275-98875-6-git-send-email-wangnan0@huawei.com
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index cc46a07b1a62..5d3b931f9baa 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -71,6 +71,8 @@ int bpf__strerror_config_obj(struct bpf_object *obj,
 			     struct perf_evlist *evlist,
 			     int *error_pos, int err, char *buf,
 			     size_t size);
+int bpf__apply_obj_config(void);
+int bpf__strerror_apply_obj_config(int err, char *buf, size_t size);
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused,
@@ -110,6 +112,12 @@ bpf__config_obj(struct bpf_object *obj __maybe_unused,
 	return 0;
 }
 
+static inline int
+bpf__apply_obj_config(void)
+{
+	return 0;
+}
+
 static inline int
 __bpf_strerror(char *buf, size_t size)
 {
@@ -156,5 +164,12 @@ bpf__strerror_config_obj(struct bpf_object *obj __maybe_unused,
 {
 	return __bpf_strerror(buf, size);
 }
+
+static inline int
+bpf__strerror_apply_obj_config(int err __maybe_unused,
+			       char *buf, size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
 #endif
 #endif

commit 066dacbf2a32defb4de23ea4c1af9e77578b5ac2
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Feb 22 09:10:30 2016 +0000

    perf bpf: Add API to set values to map entries in a bpf object
    
    bpf__config_obj() is introduced as a core API to config BPF object after
    loading. One configuration option of maps is introduced. After this
    patch BPF object can accept assignments like:
    
      map:my_map.value=1234
    
    (map.my_map.value looks pretty. However, there's a small but hard to fix
    problem related to flex's greedy matching. Please see [1].  Choose ':'
    to avoid it in a simpler way.)
    
    This patch is more complex than the work it does because the
    consideration of extension. In designing BPF map configuration, the
    following things should be considered:
    
     1. Array indices selection: perf should allow user setting different
        value for different slots in an array, with syntax like:
        map:my_map.value[0,3...6]=1234;
    
     2. A map should be set by different config terms, each for a part
        of it. For example, set each slot to the pid of a thread;
    
     3. Type of value: integer is not the only valid value type. A perf
        counter can also be put into a map after commit 35578d798400
        ("bpf: Implement function bpf_perf_event_read() that get the
          selected hardware PMU counter")
    
     4. For a hash table, it should be possible to use a string or other
        value as a key;
    
     5. It is possible that map configuration is unable to be setup
        during parsing. A perf counter is an example.
    
    Therefore, this patch does the following:
    
     1. Instead of updating map element during parsing, this patch stores
        map config options in 'struct bpf_map_priv'. Following patches
        will apply those configs at an appropriate time;
    
     2. Link map operations in a list so a map can have multiple config
        terms attached, so different parts can be configured separately;
    
     3. Make 'struct bpf_map_priv' extensible so that the following patches
        can add new types of keys and operations;
    
     4. Use bpf_obj_config__map_funcs array to support more map config options.
    
    Since the patch changing the event parser to parse BPF object config is
    relative large, I've put it in another commit. Code in this patch can be
    tested after applying the next patch.
    
    [1] http://lkml.kernel.org/g/564ED621.4050500@huawei.com
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Cody P Schafer <dev@codyps.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1456132275-98875-4-git-send-email-wangnan0@huawei.com
    Signed-off-by: He Kuang <hekuang@huawei.com>
    [ Changes "maps:my_map.value" to "map:my_map.value", improved error messages ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 6fdc0457e2b6..cc46a07b1a62 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -10,6 +10,7 @@
 #include <string.h>
 #include <bpf/libbpf.h>
 #include "probe-event.h"
+#include "evlist.h"
 #include "debug.h"
 
 enum bpf_loader_errno {
@@ -24,10 +25,19 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__PROLOGUE,	/* Failed to generate prologue */
 	BPF_LOADER_ERRNO__PROLOGUE2BIG,	/* Prologue too big for program */
 	BPF_LOADER_ERRNO__PROLOGUEOOB,	/* Offset out of bound for prologue */
+	BPF_LOADER_ERRNO__OBJCONF_OPT,	/* Invalid object config option */
+	BPF_LOADER_ERRNO__OBJCONF_CONF,	/* Config value not set (lost '=')) */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_OPT,	/* Invalid object map config option */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_NOTEXIST,	/* Target map not exist */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_VALUE,	/* Incorrect value type for map */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_TYPE,	/* Incorrect map type */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_KEYSIZE,	/* Incorrect map key size */
+	BPF_LOADER_ERRNO__OBJCONF_MAP_VALUESIZE,/* Incorrect map value size */
 	__BPF_LOADER_ERRNO__END,
 };
 
 struct bpf_object;
+struct parse_events_term;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
 typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
@@ -53,6 +63,14 @@ int bpf__strerror_load(struct bpf_object *obj, int err,
 		       char *buf, size_t size);
 int bpf__foreach_tev(struct bpf_object *obj,
 		     bpf_prog_iter_callback_t func, void *arg);
+
+int bpf__config_obj(struct bpf_object *obj, struct parse_events_term *term,
+		    struct perf_evlist *evlist, int *error_pos);
+int bpf__strerror_config_obj(struct bpf_object *obj,
+			     struct parse_events_term *term,
+			     struct perf_evlist *evlist,
+			     int *error_pos, int err, char *buf,
+			     size_t size);
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused,
@@ -83,6 +101,15 @@ bpf__foreach_tev(struct bpf_object *obj __maybe_unused,
 	return 0;
 }
 
+static inline int
+bpf__config_obj(struct bpf_object *obj __maybe_unused,
+		struct parse_events_term *term __maybe_unused,
+		struct perf_evlist *evlist __maybe_unused,
+		int *error_pos __maybe_unused)
+{
+	return 0;
+}
+
 static inline int
 __bpf_strerror(char *buf, size_t size)
 {
@@ -118,5 +145,16 @@ static inline int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
 {
 	return __bpf_strerror(buf, size);
 }
+
+static inline int
+bpf__strerror_config_obj(struct bpf_object *obj __maybe_unused,
+			 struct parse_events_term *term __maybe_unused,
+			 struct perf_evlist *evlist __maybe_unused,
+			 int *error_pos __maybe_unused,
+			 int err __maybe_unused,
+			 char *buf, size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
 #endif
 #endif

commit 0bb93490170477224f8bd4cc9ce8920517461643
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 27 08:47:37 2015 +0000

    perf bpf: Rename bpf config to program config
    
    Following patches are going to introduce BPF object level configuration
    to enable setting values into BPF maps. To avoid confusion, this patch
    renames existing 'config' in bpf-loader.c to 'program config'. Following
    patches would introduce 'object config'.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1448614067-197576-4-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index a58740b0f31e..6fdc0457e2b6 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -20,7 +20,7 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__EVENTNAME,	/* Event name is missing */
 	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
 	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
-	BPF_LOADER_ERRNO__CONFIG_TERM,	/* Invalid config term in config term */
+	BPF_LOADER_ERRNO__PROGCONF_TERM,/* Invalid program config term in config string */
 	BPF_LOADER_ERRNO__PROLOGUE,	/* Failed to generate prologue */
 	BPF_LOADER_ERRNO__PROLOGUE2BIG,	/* Prologue too big for program */
 	BPF_LOADER_ERRNO__PROLOGUEOOB,	/* Offset out of bound for prologue */

commit bfc077b4cf106793b30bf942e426ee99f1f4ac44
Author: He Kuang <hekuang@huawei.com>
Date:   Mon Nov 16 12:10:12 2015 +0000

    perf bpf: Add prologue for BPF programs for fetching arguments
    
    This patch generates a prologue for a BPF program which fetches arguments for
    it.  With this patch, the program can have arguments as follow:
    
      SEC("lock_page=__lock_page page->flags")
      int lock_page(struct pt_regs *ctx, int err, unsigned long flags)
      {
             return 1;
      }
    
    This patch passes at most 3 arguments from r3, r4 and r5. r1 is still the ctx
    pointer. r2 is used to indicate if dereferencing was done successfully.
    
    This patch uses r6 to hold ctx (struct pt_regs) and r7 to hold stack pointer
    for result. Result of each arguments first store on stack:
    
     low address
     BPF_REG_FP - 24  ARG3
     BPF_REG_FP - 16  ARG2
     BPF_REG_FP - 8   ARG1
     BPF_REG_FP
     high address
    
    Then loaded into r3, r4 and r5.
    
    The output prologue for offn(...off2(off1(reg)))) should be:
    
         r6 <- r1                   // save ctx into a callee saved register
         r7 <- fp
         r7 <- r7 - stack_offset    // pointer to result slot
         /* load r3 with the offset in pt_regs of 'reg' */
         (r7) <- r3                 // make slot valid
         r3 <- r3 + off1            // prepare to read unsafe pointer
         r2 <- 8
         r1 <- r7                   // result put onto stack
         call probe_read            // read unsafe pointer
         jnei r0, 0, err            // error checking
         r3 <- (r7)                 // read result
         r3 <- r3 + off2            // prepare to read unsafe pointer
         r2 <- 8
         r1 <- r7
         call probe_read
         jnei r0, 0, err
         ...
         /* load r2, r3, r4 from stack */
         goto success
    err:
         r2 <- 1
         /* load r3, r4, r5 with 0 */
         goto usercode
    success:
         r2 <- 0
    usercode:
         r1 <- r6   // restore ctx
         // original user code
    
    If all of arguments reside in register (dereferencing is not
    required), gen_prologue_fastpath() will be used to create
    fast prologue:
    
         r3 <- (r1 + offset of reg1)
         r4 <- (r1 + offset of reg2)
         r5 <- (r1 + offset of reg3)
         r2 <- 0
    
    P.S.
    
    eBPF calling convention is defined as:
    
    * r0            - return value from in-kernel function, and exit value
                      for eBPF program
    * r1 - r5       - arguments from eBPF program to in-kernel function
    * r6 - r9       - callee saved registers that in-kernel function will
                      preserve
    * r10           - read-only frame pointer to access stack
    
    Committer note:
    
    At least testing if it builds and loads:
    
      # cat test_probe_arg.c
      struct pt_regs;
    
      __attribute__((section("lock_page=__lock_page page->flags"), used))
      int func(struct pt_regs *ctx, int err, unsigned long flags)
      {
            return 1;
      }
    
      char _license[] __attribute__((section("license"), used)) = "GPL";
      int _version __attribute__((section("version"), used)) = 0x40300;
      # perf record -e ./test_probe_arg.c usleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.016 MB perf.data ]
      # perf evlist
      perf_bpf_probe:lock_page
      #
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1447675815-166222-11-git-send-email-wangnan0@huawei.com
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index d19f5c5d6d74..a58740b0f31e 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -21,6 +21,9 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
 	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
 	BPF_LOADER_ERRNO__CONFIG_TERM,	/* Invalid config term in config term */
+	BPF_LOADER_ERRNO__PROLOGUE,	/* Failed to generate prologue */
+	BPF_LOADER_ERRNO__PROLOGUE2BIG,	/* Prologue too big for program */
+	BPF_LOADER_ERRNO__PROLOGUEOOB,	/* Offset out of bound for prologue */
 	__BPF_LOADER_ERRNO__END,
 };
 

commit 361f2b1d1d7231b8685d990b886f599378a4d5a5
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Nov 16 12:10:05 2015 +0000

    perf bpf: Allow BPF program attach to uprobe events
    
    This patch adds a new syntax to the BPF object section name to support
    probing at uprobe event. Now we can use BPF program like this:
    
      SEC(
      "exec=/lib64/libc.so.6;"
      "libcwrite=__write"
      )
      int libcwrite(void *ctx)
      {
          return 1;
      }
    
    Where, in section name of a program, before the main config string, we
    can use 'key=value' style options. Now the only option key is "exec",
    for uprobes.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1447675815-166222-4-git-send-email-wangnan0@huawei.com
    [ Changed the separator from \n to ; ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 9caf3ae4acf3..d19f5c5d6d74 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -20,6 +20,7 @@ enum bpf_loader_errno {
 	BPF_LOADER_ERRNO__EVENTNAME,	/* Event name is missing */
 	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
 	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
+	BPF_LOADER_ERRNO__CONFIG_TERM,	/* Invalid config term in config term */
 	__BPF_LOADER_ERRNO__END,
 };
 

commit ba1fae431e74bb427a699187434142fd3fe98390
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 6 13:49:43 2015 +0000

    perf test: Add 'perf test BPF'
    
    This patch adds BPF testcase for testing BPF event filtering.
    
    By utilizing the result of 'perf test LLVM', this patch compiles the
    eBPF sample program then test its ability. The BPF script in 'perf test
    LLVM' lets only 50% samples generated by epoll_pwait() to be captured.
    This patch runs that system call for 111 times, so the result should
    contain 56 samples.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1446817783-86722-8-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index 5eb3629eed8b..9caf3ae4acf3 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -34,6 +34,9 @@ struct bpf_object *bpf__prepare_load(const char *filename, bool source);
 int bpf__strerror_prepare_load(const char *filename, bool source,
 			       int err, char *buf, size_t size);
 
+struct bpf_object *bpf__prepare_load_buffer(void *obj_buf, size_t obj_buf_sz,
+					    const char *name);
+
 void bpf__clear(void);
 
 int bpf__probe(struct bpf_object *obj);
@@ -55,6 +58,13 @@ bpf__prepare_load(const char *filename __maybe_unused,
 	return ERR_PTR(-ENOTSUP);
 }
 
+static inline struct bpf_object *
+bpf__prepare_load_buffer(void *obj_buf __maybe_unused,
+					   size_t obj_buf_sz __maybe_unused)
+{
+	return ERR_PTR(-ENOTSUP);
+}
+
 static inline void bpf__clear(void) { }
 
 static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}

commit d3e0ce393057cfa907a0c4fe7b1ff56d5c30cca5
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 6 13:58:09 2015 +0000

    perf bpf: Improve BPF related error messages
    
    A series of bpf loader related error codes were introduced to help error
    reporting. Functions were improved to return these new error codes.
    
    Functions which return pointers were adjusted to encode error codes into
    return value using the ERR_PTR() interface.
    
    bpf_loader_strerror() was improved to convert these error messages to
    strings. It checks the error codes and calls libbpf_strerror() and
    strerror_r() accordingly, so caller don't need to consider checking the
    range of the error code.
    
    In bpf__strerror_load(), print kernel version of running kernel and the
    object's 'version' section to notify user how to fix his/her program.
    
    v1 -> v2:
     Use macro for error code.
    
     Fetch error message based on array index, eliminate for-loop.
    
     Print version strings.
    
    Before:
    
      # perf record -e ./test_kversion_nomatch_program.o sleep 1
      event syntax error: './test_kversion_nomatch_program.o'
                           \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
      SKIP
    
      After:
    
      # perf record -e ./test_kversion_nomatch_program.o ls
      event syntax error: './test_kversion_nomatch_program.o'
                           \___ 'version' (4.4.0) doesn't match running kernel (4.3.0)
      SKIP
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1446818289-87444-1-git-send-email-wangnan0@huawei.com
    [ Add 'static inline' to bpf__strerror_prepare_load() when LIBBPF is disabled ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index ccd8d7fd79d3..5eb3629eed8b 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -8,9 +8,21 @@
 #include <linux/compiler.h>
 #include <linux/err.h>
 #include <string.h>
+#include <bpf/libbpf.h>
 #include "probe-event.h"
 #include "debug.h"
 
+enum bpf_loader_errno {
+	__BPF_LOADER_ERRNO__START = __LIBBPF_ERRNO__START - 100,
+	/* Invalid config string */
+	BPF_LOADER_ERRNO__CONFIG = __BPF_LOADER_ERRNO__START,
+	BPF_LOADER_ERRNO__GROUP,	/* Invalid group name */
+	BPF_LOADER_ERRNO__EVENTNAME,	/* Event name is missing */
+	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
+	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
+	__BPF_LOADER_ERRNO__END,
+};
+
 struct bpf_object;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
@@ -19,6 +31,8 @@ typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
 
 #ifdef HAVE_LIBBPF_SUPPORT
 struct bpf_object *bpf__prepare_load(const char *filename, bool source);
+int bpf__strerror_prepare_load(const char *filename, bool source,
+			       int err, char *buf, size_t size);
 
 void bpf__clear(void);
 
@@ -67,6 +81,15 @@ __bpf_strerror(char *buf, size_t size)
 	return 0;
 }
 
+static inline
+int bpf__strerror_prepare_load(const char *filename __maybe_unused,
+			       bool source __maybe_unused,
+			       int err __maybe_unused,
+			       char *buf, size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
+
 static inline int
 bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
 		    int err __maybe_unused,

commit d509db0473e40134286271b1d1adadccf42ac467
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Oct 14 12:41:20 2015 +0000

    perf tools: Compile scriptlets to BPF objects when passing '.c' to --event
    
    This patch provides infrastructure for passing source files to --event
    directly using:
    
     # perf record --event bpf-file.c command
    
    This patch does following works:
    
     1) Allow passing '.c' file to '--event'. parse_events_load_bpf() is
        expanded to allow caller tell it whether the passed file is source
        file or object.
    
     2) llvm__compile_bpf() is called to compile the '.c' file, the result
        is saved into memory. Use bpf_object__open_buffer() to load the
        in-memory object.
    
    Introduces a bpf-script-example.c so we can manually test it:
    
     # perf record --clang-opt "-DLINUX_VERSION_CODE=0x40200" --event ./bpf-script-example.c sleep 1
    
    Note that '--clang-opt' must put before '--event'.
    
    Futher patches will merge it into a testcase so can be tested automatically.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1444826502-49291-10-git-send-email-wangnan0@huawei.com
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index a8f25ee06fc5..ccd8d7fd79d3 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -18,7 +18,7 @@ typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
 					int fd, void *arg);
 
 #ifdef HAVE_LIBBPF_SUPPORT
-struct bpf_object *bpf__prepare_load(const char *filename);
+struct bpf_object *bpf__prepare_load(const char *filename, bool source);
 
 void bpf__clear(void);
 
@@ -34,7 +34,8 @@ int bpf__foreach_tev(struct bpf_object *obj,
 		     bpf_prog_iter_callback_t func, void *arg);
 #else
 static inline struct bpf_object *
-bpf__prepare_load(const char *filename __maybe_unused)
+bpf__prepare_load(const char *filename __maybe_unused,
+		  bool source __maybe_unused)
 {
 	pr_debug("ERROR: eBPF object loading is disabled during compiling.\n");
 	return ERR_PTR(-ENOTSUP);

commit 4edf30e39e6cff32390eaff6a1508969b3cd967b
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Oct 14 12:41:17 2015 +0000

    perf bpf: Collect perf_evsel in BPF object files
    
    This patch creates a 'struct perf_evsel' for every probe in a BPF object
    file(s) and fills 'struct evlist' with them. The previously introduced
    dummy event is now removed. After this patch, the following command:
    
     # perf record --event filter.o ls
    
    Can trace on each of the probes defined in filter.o.
    
    The core of this patch is bpf__foreach_tev(), which calls a callback
    function for each 'struct probe_trace_event' event for a bpf program
    with each associated file descriptors. The add_bpf_event() callback
    creates evsels by calling parse_events_add_tracepoint().
    
    Since bpf-loader.c will not be built if libbpf is turned off, an empty
    bpf__foreach_tev() is defined in bpf-loader.h to avoid build errors.
    
    Committer notes:
    
    Before:
    
      # /tmp/oldperf record --event /tmp/foo.o -a usleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.198 MB perf.data ]
      # perf evlist
      /tmp/foo.o
      # perf evlist -v
      /tmp/foo.o: type: 1, size: 112, config: 0x9, { sample_period,
      sample_freq }: 4000, sample_type: IP|TID|TIME|CPU|PERIOD, disabled: 1,
      inherit: 1, mmap: 1, comm: 1, freq: 1, task: 1, sample_id_all: 1,
      exclude_guest: 1, mmap2: 1, comm_exec: 1
    
    I.e. we create just the PERF_TYPE_SOFTWARE (type: 1),
    PERF_COUNT_SW_DUMMY(config 0x9) event, now, with this patch:
    
      # perf record --event /tmp/foo.o -a usleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.210 MB perf.data ]
      # perf evlist -v
      perf_bpf_probe:fork: type: 2, size: 112, config: 0x6bd, { sample_period,
      sample_freq }: 1, sample_type: IP|TID|TIME|CPU|PERIOD|RAW, disabled: 1,
      inherit: 1, mmap: 1, comm: 1, task: 1, sample_id_all: 1, exclude_guest:
      1, mmap2: 1, comm_exec: 1
      #
    
    We now have a PERF_TYPE_SOFTWARE (type: 1), but the config states 0x6bd,
    which is how, after setting up the event via the kprobes interface, the
    'perf_bpf_probe:fork' event is accessible via the perf_event_open
    syscall. This is all transient, as soon as the 'perf record' session
    ends, these probes will go away.
    
    To see how it looks like, lets try doing a neverending session, one that
    expects a control+C to end:
    
      # perf record --event /tmp/foo.o -a
    
    So, with that in place, we can use 'perf probe' to see what is in place:
    
      # perf probe -l
        perf_bpf_probe:fork  (on _do_fork@acme/git/linux/kernel/fork.c)
    
    We also can use debugfs:
    
      [root@felicio ~]# cat /sys/kernel/debug/tracing/kprobe_events
      p:perf_bpf_probe/fork _text+638512
    
    Ok, now lets stop and see if we got some forks:
    
      [root@felicio linux]# perf record --event /tmp/foo.o -a
      ^C[ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.325 MB perf.data (111 samples) ]
    
      [root@felicio linux]# perf script
          sshd  1271 [003] 81797.507678: perf_bpf_probe:fork: (ffffffff8109be30)
          sshd 18309 [000] 81797.524917: perf_bpf_probe:fork: (ffffffff8109be30)
          sshd 18309 [001] 81799.381603: perf_bpf_probe:fork: (ffffffff8109be30)
          sshd 18309 [001] 81799.408635: perf_bpf_probe:fork: (ffffffff8109be30)
      <SNIP>
    
    Sure enough, we have 111 forks :-)
    
    Callchains seems to work as well:
    
      # perf report --stdio --no-child
      # To display the perf.data header info, please use --header/--header-only options.
      #
      # Total Lost Samples: 0
      #
      # Samples: 562  of event 'perf_bpf_probe:fork'
      # Event count (approx.): 562
      #
      # Overhead  Command   Shared Object     Symbol
      # ........  ........  ................  ............
      #
          44.66%  sh        [kernel.vmlinux]  [k] _do_fork
                        |
                        ---_do_fork
                           entry_SYSCALL_64_fastpath
                           __libc_fork
                           make_child
    
        26.16%  make      [kernel.vmlinux]  [k] _do_fork
    <SNIP>
      #
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1444826502-49291-7-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index b091ceb19c48..a8f25ee06fc5 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -8,11 +8,15 @@
 #include <linux/compiler.h>
 #include <linux/err.h>
 #include <string.h>
+#include "probe-event.h"
 #include "debug.h"
 
 struct bpf_object;
 #define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
+typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
+					int fd, void *arg);
+
 #ifdef HAVE_LIBBPF_SUPPORT
 struct bpf_object *bpf__prepare_load(const char *filename);
 
@@ -26,6 +30,8 @@ int bpf__strerror_probe(struct bpf_object *obj, int err,
 int bpf__load(struct bpf_object *obj);
 int bpf__strerror_load(struct bpf_object *obj, int err,
 		       char *buf, size_t size);
+int bpf__foreach_tev(struct bpf_object *obj,
+		     bpf_prog_iter_callback_t func, void *arg);
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused)
@@ -40,6 +46,14 @@ static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}
 static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0;}
 static inline int bpf__load(struct bpf_object *obj __maybe_unused) { return 0; }
 
+static inline int
+bpf__foreach_tev(struct bpf_object *obj __maybe_unused,
+		 bpf_prog_iter_callback_t func __maybe_unused,
+		 void *arg __maybe_unused)
+{
+	return 0;
+}
+
 static inline int
 __bpf_strerror(char *buf, size_t size)
 {

commit 1e5e3ee8ff3877db6943032b54a6ac21c095affd
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Oct 14 12:41:16 2015 +0000

    perf tools: Load eBPF object into kernel
    
    This patch utilizes bpf_object__load() provided by libbpf to load all
    objects into kernel.
    
    Committer notes:
    
    Testing it:
    
    When using an incorrect kernel version number, i.e., having this in your
    eBPF proggie:
    
      int _version __attribute__((section("version"), used)) = 0x40100;
    
    For a 4.3.0-rc6+ kernel, say, this happens and needs checking at event
    parsing time, to provide a better error report to the user:
    
      # perf record --event /tmp/foo.o sleep 1
      libbpf: load bpf program failed: Invalid argument
      libbpf: -- BEGIN DUMP LOG ---
      libbpf:
    
      libbpf: -- END LOG --
      libbpf: failed to load program 'fork=_do_fork'
      libbpf: failed to load object '/tmp/foo.o'
      event syntax error: '/tmp/foo.o'
                           \___ Invalid argument: Are you root and runing a CONFIG_BPF_SYSCALL kernel?
    
      (add -v to see detail)
      Run 'perf list' for a list of valid events
    
       Usage: perf record [<options>] [<command>]
          or: perf record [<options>] -- <command> [<options>]
    
          -e, --event <event>   event selector. use 'perf list' to list available events
    
    If we instead make it match, i.e. use 0x40300 on this v4.3.0-rc6+
    kernel, the whole process goes thru:
    
      # perf record --event /tmp/foo.o -a usleep 1
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.202 MB perf.data ]
      # perf evlist -v
      /tmp/foo.o: type: 1, size: 112, config: 0x9, { sample_period,
      sample_freq }: 4000, sample_type: IP|TID|TIME|CPU|PERIOD, disabled: 1,
      inherit: 1, mmap: 1, comm: 1, freq: 1, task: 1, sample_id_all: 1,
      exclude_guest: 1, mmap2: 1, comm_exec: 1
      #
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1444826502-49291-6-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index b819622dc7ce..b091ceb19c48 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -23,6 +23,9 @@ int bpf__unprobe(struct bpf_object *obj);
 int bpf__strerror_probe(struct bpf_object *obj, int err,
 			char *buf, size_t size);
 
+int bpf__load(struct bpf_object *obj);
+int bpf__strerror_load(struct bpf_object *obj, int err,
+		       char *buf, size_t size);
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused)
@@ -35,6 +38,7 @@ static inline void bpf__clear(void) { }
 
 static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}
 static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0;}
+static inline int bpf__load(struct bpf_object *obj __maybe_unused) { return 0; }
 
 static inline int
 __bpf_strerror(char *buf, size_t size)
@@ -55,5 +59,12 @@ bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
 {
 	return __bpf_strerror(buf, size);
 }
+
+static inline int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
+				     int err __maybe_unused,
+				     char *buf, size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
 #endif
 #endif

commit aa3abf30bb28addcf593578d37447d42e3f65fc3
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Oct 14 12:41:15 2015 +0000

    perf tools: Create probe points for BPF programs
    
    This patch introduces bpf__{un,}probe() functions to enable callers to
    create kprobe points based on section names a BPF program. It parses the
    section names in the program and creates corresponding 'struct
    perf_probe_event' structures. The parse_perf_probe_command() function is
    used to do the main parsing work. The resuling 'struct perf_probe_event'
    is stored into program private data for further using.
    
    By utilizing the new probing API, this patch creates probe points during
    event parsing.
    
    To ensure probe points be removed correctly, register an atexit hook so
    even perf quit through exit() bpf__clear() is still called, so probing
    points are cleared. Note that bpf_clear() should be registered before
    bpf__probe() is called, so failure of bpf__probe() can still trigger
    bpf__clear() to remove probe points which are already probed.
    
    strerror style error reporting scaffold is created by this patch.
    bpf__strerror_probe() is the first error reporting function in
    bpf-loader.c.
    
    Committer note:
    
    Trying it:
    
    To build a test eBPF object file:
    
    I am testing using a script I built from the 'perf test -v LLVM' output:
    
      $ cat ~/bin/hello-ebpf
      export KERNEL_INC_OPTIONS="-nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include -I/home/acme/git/linux/arch/x86/include -Iarch/x86/include/generated/uapi -Iarch/x86/include/generated -I/home/acme/git/linux/include -Iinclude -I/home/acme/git/linux/arch/x86/include/uapi -Iarch/x86/include/generated/uapi -I/home/acme/git/linux/include/uapi -Iinclude/generated/uapi -include /home/acme/git/linux/include/linux/kconfig.h"
      export WORKING_DIR=/lib/modules/4.2.0/build
      export CLANG_SOURCE=-
      export CLANG_OPTIONS=-xc
    
      OBJ=/tmp/foo.o
      rm -f $OBJ
      echo '__attribute__((section("fork=do_fork"), used)) int fork(void *ctx) {return 0;} char _license[] __attribute__((section("license"), used)) = "GPL";int _version __attribute__((section("version"), used)) = 0x40100;' | \
      clang -D__KERNEL__ $CLANG_OPTIONS $KERNEL_INC_OPTIONS -Wno-unused-value -Wno-pointer-sign -working-directory $WORKING_DIR -c "$CLANG_SOURCE" -target bpf -O2 -o /tmp/foo.o && file $OBJ
    
     ---
    
    First asking to put a probe in a function not present in the kernel
    (misses the initial _):
    
      $ perf record --event /tmp/foo.o sleep 1
      Probe point 'do_fork' not found.
      event syntax error: '/tmp/foo.o'
                           \___ You need to check probing points in BPF file
    
      (add -v to see detail)
      Run 'perf list' for a list of valid events
    
       Usage: perf record [<options>] [<command>]
          or: perf record [<options>] -- <command> [<options>]
    
          -e, --event <event>   event selector. use 'perf list' to list available events
      $
    
     ---
    
    Now, with "__attribute__((section("fork=_do_fork"), used)):
    
     $ grep _do_fork /proc/kallsyms
     ffffffff81099ab0 T _do_fork
     $ perf record --event /tmp/foo.o sleep 1
     Failed to open kprobe_events: Permission denied
     event syntax error: '/tmp/foo.o'
                          \___ Permission denied
    
     ---
    
    Cool, we need to provide some better hints, "kprobe_events" is too low
    level, one doesn't strictly need to know the precise details of how
    these things are put in place, so something that shows the command
    needed to fix the permissions would be more helpful.
    
    Lets try as root instead:
    
      # perf record --event /tmp/foo.o sleep 1
      Lowering default frequency rate to 1000.
      Please consider tweaking /proc/sys/kernel/perf_event_max_sample_rate.
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.013 MB perf.data ]
      # perf evlist
      /tmp/foo.o
      [root@felicio ~]# perf evlist -v
      /tmp/foo.o: type: 1, size: 112, config: 0x9, { sample_period,
      sample_freq }: 1000, sample_type: IP|TID|TIME|PERIOD, disabled: 1,
      inherit: 1, mmap: 1, comm: 1, freq: 1, enable_on_exec: 1, task: 1,
      sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1
    
     ---
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1444826502-49291-5-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index f402d7c8c288..b819622dc7ce 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -11,11 +11,18 @@
 #include "debug.h"
 
 struct bpf_object;
+#define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 
 #ifdef HAVE_LIBBPF_SUPPORT
 struct bpf_object *bpf__prepare_load(const char *filename);
 
 void bpf__clear(void);
+
+int bpf__probe(struct bpf_object *obj);
+int bpf__unprobe(struct bpf_object *obj);
+int bpf__strerror_probe(struct bpf_object *obj, int err,
+			char *buf, size_t size);
+
 #else
 static inline struct bpf_object *
 bpf__prepare_load(const char *filename __maybe_unused)
@@ -25,5 +32,28 @@ bpf__prepare_load(const char *filename __maybe_unused)
 }
 
 static inline void bpf__clear(void) { }
+
+static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}
+static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0;}
+
+static inline int
+__bpf_strerror(char *buf, size_t size)
+{
+	if (!size)
+		return 0;
+	strncpy(buf,
+		"ERROR: eBPF object loading is disabled during compiling.\n",
+		size);
+	buf[size - 1] = '\0';
+	return 0;
+}
+
+static inline int
+bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+		    int err __maybe_unused,
+		    char *buf, size_t size)
+{
+	return __bpf_strerror(buf, size);
+}
 #endif
 #endif

commit 69d262a93a25cf475012ea2e00aeb29f4932c028
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Oct 14 12:41:13 2015 +0000

    perf ebpf: Add the libbpf glue
    
    The 'bpf-loader.[ch]' files are introduced in this patch. Which will be
    the interface between perf and libbpf. bpf__prepare_load() resides in
    bpf-loader.c. Following patches will enrich these two files.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1444826502-49291-3-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
new file mode 100644
index 000000000000..f402d7c8c288
--- /dev/null
+++ b/tools/perf/util/bpf-loader.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015, Wang Nan <wangnan0@huawei.com>
+ * Copyright (C) 2015, Huawei Inc.
+ */
+#ifndef __BPF_LOADER_H
+#define __BPF_LOADER_H
+
+#include <linux/compiler.h>
+#include <linux/err.h>
+#include <string.h>
+#include "debug.h"
+
+struct bpf_object;
+
+#ifdef HAVE_LIBBPF_SUPPORT
+struct bpf_object *bpf__prepare_load(const char *filename);
+
+void bpf__clear(void);
+#else
+static inline struct bpf_object *
+bpf__prepare_load(const char *filename __maybe_unused)
+{
+	pr_debug("ERROR: eBPF object loading is disabled during compiling.\n");
+	return ERR_PTR(-ENOTSUP);
+}
+
+static inline void bpf__clear(void) { }
+#endif
+#endif
