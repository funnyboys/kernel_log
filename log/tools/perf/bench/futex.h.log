commit d47d77c3f008d3cf02c6ce92ef4f6e32ca270351
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Nov 9 13:07:19 2018 -0800

    perf bench: Move HAVE_PTHREAD_ATTR_SETAFFINITY_NP into bench.h
    
    Both futex and epoll need this call, and can cause build failure on
    systems that don't have it pthread_attr_setaffinity_np().
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181109210719.pr7ohayuwqmfp2wl@linux-r8p5
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index db4853f209c7..31b53cc7d5bc 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -86,16 +86,4 @@ futex_cmp_requeue(u_int32_t *uaddr, u_int32_t val, u_int32_t *uaddr2, int nr_wak
 	return futex(uaddr, FUTEX_CMP_REQUEUE, nr_wake, nr_requeue, uaddr2,
 		 val, opflags);
 }
-
-#ifndef HAVE_PTHREAD_ATTR_SETAFFINITY_NP
-#include <pthread.h>
-#include <linux/compiler.h>
-static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr __maybe_unused,
-					      size_t cpusetsize __maybe_unused,
-					      cpu_set_t *cpuset __maybe_unused)
-{
-	return 0;
-}
-#endif
-
 #endif /* _FUTEX_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index e44fd3239530..db4853f209c7 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Glibc independent futex library for testing kernel functionality.
  * Shamelessly stolen from Darren Hart <dvhltc@us.ibm.com>

commit b8d1fd7ec661f5ccb9facd57589a563f627df230
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Mar 2 15:31:43 2017 -0300

    perf bench futex: Use __maybe_unused
    
    Instead of attributing a variable to itself to silence the compiler, use
    the attribute designed for that, avoiding this:
    
    In file included from bench/futex-hash.c:24:
    bench/futex.h:95:7: error: explicitly assigning value of variable of type 'pthread_attr_t *' to itself [-Werror,-Wself-assign]
            attr = attr;
            ~~~~ ^ ~~~~
    bench/futex.h:96:13: error: explicitly assigning value of variable of type 'size_t' (aka 'unsigned long') to itself [-Werror,-Wself-assign]
            cpusetsize = cpusetsize;
            ~~~~~~~~~~ ^ ~~~~~~~~~~
    bench/futex.h:97:9: error: explicitly assigning value of variable of type 'cpu_set_t *' (aka 'struct cpu_set_t *') to itself [-Werror,-Wself-assign]
            cpuset = cpuset;
            ~~~~~~ ^ ~~~~~~
    
    That is only triggered when HAVE_PTHREAD_ATTR_SETAFFINITY_NP isn't set.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-14ws1d1elj2d5ej8g7cwdqau@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index b2e06d1190d0..e44fd3239530 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -88,13 +88,11 @@ futex_cmp_requeue(u_int32_t *uaddr, u_int32_t val, u_int32_t *uaddr2, int nr_wak
 
 #ifndef HAVE_PTHREAD_ATTR_SETAFFINITY_NP
 #include <pthread.h>
-static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr,
-					      size_t cpusetsize,
-					      cpu_set_t *cpuset)
+#include <linux/compiler.h>
+static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr __maybe_unused,
+					      size_t cpusetsize __maybe_unused,
+					      cpu_set_t *cpuset __maybe_unused)
 {
-	attr = attr;
-	cpusetsize = cpusetsize;
-	cpuset = cpuset;
 	return 0;
 }
 #endif

commit 16cab3226fc91fd8060a3d15d1f27051a7b189fb
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Feb 14 14:12:43 2017 -0300

    Revert "perf bench futex: Sanitize numeric parameters"
    
    This reverts commit 60758d6668b3e2fa8e5fd143d24d0425203d007e.
    
    Now that libsubcmd makes sure that OPT_UINTEGER options will not
    return negative values, we can revert this patch while addressing
    the problem it solved:
    
      # perf bench futex hash -t  -4
      # Running 'futex/hash' benchmark:
       Error: switch `t' expects an unsigned numerical value
       Usage: perf bench futex hash <options>
    
          -t, --threads <n>     Specify amount of threads
      # perf bench futex hash -t-4
      # Running 'futex/hash' benchmark:
       Error: switch `t' expects an unsigned numerical value
       Usage: perf bench futex hash <options>
    
          -t, --threads <n>     Specify amount of threads
      #
    
    IMO it is more reasonable to flat out refuse to process a negative
    number than to silently turn it into an absolute value.
    
    This also helps in silencing clang's complaint about asking for an
    absolute value of an unsigned integer:
    
      bench/futex-hash.c:133:10: error: taking the absolute value of unsigned type 'unsigned int' has no effect [-Werror,-Wabsolute-value]
              nsecs = futexbench_sanitize_numeric(nsecs);
                    ^
      bench/futex.h:104:42: note: expanded from macro 'futexbench_sanitize_numeric'
      #define futexbench_sanitize_numeric(__n) abs((__n))
                                               ^
      bench/futex-hash.c:133:10: note: remove the call to 'abs' since unsigned values cannot be negative
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-2kl68v22or31vw643m2exz8x@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index ba7c735c0c62..b2e06d1190d0 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -7,7 +7,6 @@
 #ifndef _FUTEX_H
 #define _FUTEX_H
 
-#include <stdlib.h>
 #include <unistd.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
@@ -100,7 +99,4 @@ static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr,
 }
 #endif
 
-/* User input sanitation */
-#define futexbench_sanitize_numeric(__n) abs((__n))
-
 #endif /* _FUTEX_H */

commit 60758d6668b3e2fa8e5fd143d24d0425203d007e
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Mon Oct 24 13:56:53 2016 -0700

    perf bench futex: Sanitize numeric parameters
    
    This gets rid of oddities such as:
    
      perf bench futex hash -t -4
      perf: calloc: Cannot allocate memory
    
    Runtime (and many more) are equally busted, i.e. run for bogus amounts of
    time. Just use the abs, instead of, for example errorring out.
    
    Committer note:
    
    After the patch:
    
      $ perf bench futex hash -t -4
      # Running 'futex/hash' benchmark:
      Run summary [PID 10178]: 4 threads, each operating on 1024 [private] futexes for 10 secs.
    
      [thread  0] futexes: 0x34f9fa0 ... 0x34faf9c [ 4702208 ops/sec ]
      [thread  1] futexes: 0x34fb140 ... 0x34fc13c [ 4707020 ops/sec ]
      [thread  2] futexes: 0x34fc2e0 ... 0x34fd2dc [ 4711526 ops/sec ]
      [thread  3] futexes: 0x34fd480 ... 0x34fe47c [ 4709683 ops/sec ]
    
      Averaged 4707609 operations/sec (+- 0.04%), total secs = 10
      $
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Link: http://lkml.kernel.org/r/1477342613-9938-3-git-send-email-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index b2e06d1190d0..ba7c735c0c62 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -7,6 +7,7 @@
 #ifndef _FUTEX_H
 #define _FUTEX_H
 
+#include <stdlib.h>
 #include <unistd.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
@@ -99,4 +100,7 @@ static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr,
 }
 #endif
 
+/* User input sanitation */
+#define futexbench_sanitize_numeric(__n) abs((__n))
+
 #endif /* _FUTEX_H */

commit 73b1794e252b0476cc6e46461c7612cbaa88be45
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Wed Apr 20 20:14:07 2016 -0700

    perf bench futex: Simplify wrapper for LOCK_PI
    
    Given that the 'val' parameter is ignored for FUTEX_LOCK_PI, get rid of
    the bogus deadlock detection flag in the wrapper code and avoid the
    extra argument, making it resemble its unlock counterpart. And if
    nothing else, we already only pass 0 anyway.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Link: http://lkml.kernel.org/r/1461208447-29328-1-git-send-email-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index d44de9f44281..b2e06d1190d0 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -57,13 +57,11 @@ futex_wake(u_int32_t *uaddr, int nr_wake, int opflags)
 
 /**
  * futex_lock_pi() - block on uaddr as a PI mutex
- * @detect:	whether (1) or not (0) to perform deadlock detection
  */
 static inline int
-futex_lock_pi(u_int32_t *uaddr, struct timespec *timeout, int detect,
-	      int opflags)
+futex_lock_pi(u_int32_t *uaddr, struct timespec *timeout, int opflags)
 {
-	return futex(uaddr, FUTEX_LOCK_PI, detect, timeout, NULL, 0, opflags);
+	return futex(uaddr, FUTEX_LOCK_PI, 0, timeout, NULL, 0, opflags);
 }
 
 /**

commit d2f3f5d2e9cae6e73f9642a5ddc8c8a07c35e79b
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Jul 7 01:55:53 2015 -0700

    perf bench futex: Add lock_pi stresser
    
    Allows a way of measuring low level kernel implementation of FUTEX_LOCK_PI and
    FUTEX_UNLOCK_PI.
    
    The program comes in two flavors:
    
    (i) single futex (default), all threads contend on the same uaddr.  For the
    sake of the benchmark, we call into kernel space even when the lock is
    uncontended.  The kernel will set it to TID, any waters that come in and
    contend for the pi futex will be handled respectively by the kernel.
    
    (ii) -M option for multiple futexes, each thread deals with its own futex. This
    is a trivial scenario and only measures kernel handling of 0->TID transition.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Mel Gorman <mgorman@suse.de>
    Link: http://lkml.kernel.org/r/1436259353.12255.78.camel@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index 7ed22ff1e1ac..d44de9f44281 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -55,6 +55,26 @@ futex_wake(u_int32_t *uaddr, int nr_wake, int opflags)
 	return futex(uaddr, FUTEX_WAKE, nr_wake, NULL, NULL, 0, opflags);
 }
 
+/**
+ * futex_lock_pi() - block on uaddr as a PI mutex
+ * @detect:	whether (1) or not (0) to perform deadlock detection
+ */
+static inline int
+futex_lock_pi(u_int32_t *uaddr, struct timespec *timeout, int detect,
+	      int opflags)
+{
+	return futex(uaddr, FUTEX_LOCK_PI, detect, timeout, NULL, 0, opflags);
+}
+
+/**
+ * futex_unlock_pi() - release uaddr as a PI mutex, waking the top waiter
+ */
+static inline int
+futex_unlock_pi(u_int32_t *uaddr, int opflags)
+{
+	return futex(uaddr, FUTEX_UNLOCK_PI, 0, NULL, NULL, 0, opflags);
+}
+
 /**
 * futex_cmp_requeue() - requeue tasks from uaddr to uaddr2
 * @nr_wake:        wake up to this many tasks

commit 459a3df76c99124fd222586be7f10f862547e7a9
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Jan 13 19:13:24 2015 +0530

    perf tools: Provide stub for missing pthread_attr_setaffinity_np
    
    uClibc Linuxthreads.old doesn't support the pthread_attr_setaffinity_np()
    functioo:
    
       ----------------->8-----------------------
      CC       bench/futex-hash.o
      CC       bench/futex-wake.o
    bench/futex-hash.c: In function 'bench_futex_hash':
    bench/futex-hash.c:161:3: error: implicit declaration of function
    'pthread_attr_setaffinity_np' [-Werror=implicit-function-declaration]
       ret = pthread_attr_setaffinity_np(&thread_attr, sizeof(cpu_set_t),
    &cpu);
       ^
    bench/futex-hash.c:161:3: error: nested extern declaration of
    'pthread_attr_setaffinity_np' [-Werror=nested-externs]
       ----------------->8-----------------------
    
    So introduce a test to check that and if not available provide a stub.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1421156604-30603-6-git-send-email-vgupta@synopsys.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index 71f2844cf97f..7ed22ff1e1ac 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -68,4 +68,17 @@ futex_cmp_requeue(u_int32_t *uaddr, u_int32_t val, u_int32_t *uaddr2, int nr_wak
 		 val, opflags);
 }
 
+#ifndef HAVE_PTHREAD_ATTR_SETAFFINITY_NP
+#include <pthread.h>
+static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr,
+					      size_t cpusetsize,
+					      cpu_set_t *cpuset)
+{
+	attr = attr;
+	cpusetsize = cpusetsize;
+	cpuset = cpuset;
+	return 0;
+}
+#endif
+
 #endif /* _FUTEX_H */

commit 0fb298cf95c0d8119557b7d4657724a146e0622e
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:57 2013 -0800

    perf bench: Add futex-requeue microbenchmark
    
    Block a bunch of threads on a futex and requeue them on another, N at a
    time.
    
    This program is particularly useful to measure the latency of nthread
    requeues without waking up any tasks -- thus mimicking a regular
    futex_wait.
    
    An example run:
    
      $ perf bench futex requeue -r 100 -t 64
      Run summary [PID 151011]: Requeuing 64 threads (from 0x7d15c4 to 0x7d15c8), 1 at a time.
    
      [Run 1]: Requeued 64 of 64 threads in 0.0400 ms
      [Run 2]: Requeued 64 of 64 threads in 0.0390 ms
      [Run 3]: Requeued 64 of 64 threads in 0.0400 ms
      ...
      [Run 100]: Requeued 64 of 64 threads in 0.0390 ms
      Requeued 64 of 64 threads in 0.0399 ms (+-0.37%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-4-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index 6ac45093fac4..71f2844cf97f 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -55,4 +55,17 @@ futex_wake(u_int32_t *uaddr, int nr_wake, int opflags)
 	return futex(uaddr, FUTEX_WAKE, nr_wake, NULL, NULL, 0, opflags);
 }
 
+/**
+* futex_cmp_requeue() - requeue tasks from uaddr to uaddr2
+* @nr_wake:        wake up to this many tasks
+* @nr_requeue:        requeue up to this many tasks
+*/
+static inline int
+futex_cmp_requeue(u_int32_t *uaddr, u_int32_t val, u_int32_t *uaddr2, int nr_wake,
+		 int nr_requeue, int opflags)
+{
+	return futex(uaddr, FUTEX_CMP_REQUEUE, nr_wake, nr_requeue, uaddr2,
+		 val, opflags);
+}
+
 #endif /* _FUTEX_H */

commit 27db78307481dbba68c5f3563c6cb694b25521d9
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:56 2013 -0800

    perf bench: Add futex-wake microbenchmark
    
    Block a bunch of threads on a futex and wake them up, N at a time.
    
    This program is particularly useful to measure the latency of nthread
    wakeups in non-error situations:  all waiters are queued and all wake
    calls wakeup one or more tasks.
    
    An example run:
    
      $ perf bench futex wake -t 512 -r 100
      Run summary [PID 27823]: blocking on 512 threads (at futex 0x7e10d4), waking up 1 at a time.
    
      [Run 1]: Wokeup 512 of 512 threads in 6.0080 ms
      [Run 2]: Wokeup 512 of 512 threads in 5.2280 ms
      [Run 3]: Wokeup 512 of 512 threads in 4.8300 ms
      ...
      [Run 100]: Wokeup 512 of 512 threads in 5.0100 ms
      Wokeup 512 of 512 threads in 5.0109 ms (+-2.25%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-3-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
index 7d0bda543e3d..6ac45093fac4 100644
--- a/tools/perf/bench/futex.h
+++ b/tools/perf/bench/futex.h
@@ -45,4 +45,14 @@ futex_wait(u_int32_t *uaddr, u_int32_t val, struct timespec *timeout, int opflag
 	return futex(uaddr, FUTEX_WAIT, val, timeout, NULL, 0, opflags);
 }
 
+/**
+ * futex_wake() - wake one or more tasks blocked on uaddr
+ * @nr_wake:	wake up to this many tasks
+ */
+static inline int
+futex_wake(u_int32_t *uaddr, int nr_wake, int opflags)
+{
+	return futex(uaddr, FUTEX_WAKE, nr_wake, NULL, NULL, 0, opflags);
+}
+
 #endif /* _FUTEX_H */

commit a043971141f163f9845324a2f83502d15011485d
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:55 2013 -0800

    perf bench: Add futex-hash microbenchmark
    
    Introduce futexes to perf-bench and add a program that stresses and
    measures the kernel's implementation of the hash table.
    
    This is a multi-threaded program that simply measures the amount of
    failed futex wait calls - we only want to deal with the hashing
    overhead, so a negative return of futex_wait_setup() is enough to do the
    trick.
    
    An example run:
    
      $ perf bench futex hash -t 32
      Run summary [PID 10989]: 32 threads, each operating on 1024 [private] futexes for 10 secs.
    
      [thread  0] futexes: 0x19d9b10 ... 0x19dab0c [ 418713 ops/sec ]
      [thread  1] futexes: 0x19daca0 ... 0x19dbc9c [ 469913 ops/sec ]
      [thread  2] futexes: 0x19dbe30 ... 0x19dce2c [ 479744 ops/sec ]
      ...
      [thread 31] futexes: 0x19fbb80 ... 0x19fcb7c [ 464179 ops/sec ]
    
      Averaged 454310 operations/sec (+- 0.84%), total secs = 10
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-2-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/futex.h b/tools/perf/bench/futex.h
new file mode 100644
index 000000000000..7d0bda543e3d
--- /dev/null
+++ b/tools/perf/bench/futex.h
@@ -0,0 +1,48 @@
+/*
+ * Glibc independent futex library for testing kernel functionality.
+ * Shamelessly stolen from Darren Hart <dvhltc@us.ibm.com>
+ *    http://git.kernel.org/cgit/linux/kernel/git/dvhart/futextest.git/
+ */
+
+#ifndef _FUTEX_H
+#define _FUTEX_H
+
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <linux/futex.h>
+
+/**
+ * futex() - SYS_futex syscall wrapper
+ * @uaddr:	address of first futex
+ * @op:		futex op code
+ * @val:	typically expected value of uaddr, but varies by op
+ * @timeout:	typically an absolute struct timespec (except where noted
+ *		otherwise). Overloaded by some ops
+ * @uaddr2:	address of second futex for some ops\
+ * @val3:	varies by op
+ * @opflags:	flags to be bitwise OR'd with op, such as FUTEX_PRIVATE_FLAG
+ *
+ * futex() is used by all the following futex op wrappers. It can also be
+ * used for misuse and abuse testing. Generally, the specific op wrappers
+ * should be used instead. It is a macro instead of an static inline function as
+ * some of the types over overloaded (timeout is used for nr_requeue for
+ * example).
+ *
+ * These argument descriptions are the defaults for all
+ * like-named arguments in the following wrappers except where noted below.
+ */
+#define futex(uaddr, op, val, timeout, uaddr2, val3, opflags) \
+	syscall(SYS_futex, uaddr, op | opflags, val, timeout, uaddr2, val3)
+
+/**
+ * futex_wait() - block on uaddr with optional timeout
+ * @timeout:	relative timeout
+ */
+static inline int
+futex_wait(u_int32_t *uaddr, u_int32_t val, struct timespec *timeout, int opflags)
+{
+	return futex(uaddr, FUTEX_WAIT, val, timeout, NULL, 0, opflags);
+}
+
+#endif /* _FUTEX_H */
