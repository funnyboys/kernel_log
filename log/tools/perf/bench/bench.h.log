commit 51876bd45263f62083bbb823220bfb48909f313a
Author: Ian Rogers <irogers@google.com>
Date:   Fri May 1 15:13:13 2020 -0700

    perf bench: Add kallsyms parsing
    
    Add a benchmark for kallsyms parsing. Example output:
    
      Running 'internals/kallsyms-parse' benchmark:
      Average kallsyms__parse took: 103.971 ms (+- 0.121 ms)
    
    Committer testing:
    
    Test Machine: AMD Ryzen 5 3600X 6-Core Processor
    
      [root@five ~]# perf bench internals kallsyms-parse
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 79.692 ms (+- 0.101 ms)
      [root@five ~]# perf stat -r5 perf bench internals kallsyms-parse
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 80.563 ms (+- 0.079 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.046 ms (+- 0.155 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 80.874 ms (+- 0.104 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.173 ms (+- 0.133 ms)
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 81.169 ms (+- 0.074 ms)
    
       Performance counter stats for 'perf bench internals kallsyms-parse' (5 runs):
    
                8,093.54 msec task-clock                #    0.999 CPUs utilized            ( +-  0.14% )
                   3,165      context-switches          #    0.391 K/sec                    ( +-  0.18% )
                      10      cpu-migrations            #    0.001 K/sec                    ( +- 23.13% )
                     744      page-faults               #    0.092 K/sec                    ( +-  0.21% )
          34,551,564,954      cycles                    #    4.269 GHz                      ( +-  0.05% )  (83.33%)
           1,160,584,308      stalled-cycles-frontend   #    3.36% frontend cycles idle     ( +-  1.60% )  (83.33%)
          14,974,323,985      stalled-cycles-backend    #   43.34% backend cycles idle      ( +-  0.24% )  (83.33%)
          58,712,905,705      instructions              #    1.70  insn per cycle
                                                        #    0.26  stalled cycles per insn  ( +-  0.01% )  (83.34%)
          14,136,433,778      branches                  # 1746.632 M/sec                    ( +-  0.01% )  (83.33%)
             141,943,217      branch-misses             #    1.00% of all branches          ( +-  0.04% )  (83.33%)
    
                  8.1040 +- 0.0115 seconds time elapsed  ( +-  0.14% )
    
      [root@five ~]#
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200501221315.54715-2-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 4d669c803237..61cae4966cae 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -44,6 +44,7 @@ int bench_futex_lock_pi(int argc, const char **argv);
 int bench_epoll_wait(int argc, const char **argv);
 int bench_epoll_ctl(int argc, const char **argv);
 int bench_synthesize(int argc, const char **argv);
+int bench_kallsyms_parse(int argc, const char **argv);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 2a4b51666af8bf0b67ccc2e53120bad27351917c
Author: Ian Rogers <irogers@google.com>
Date:   Thu Apr 2 08:43:53 2020 -0700

    perf bench: Add event synthesis benchmark
    
    Event synthesis may occur at the start or end (tail) of a perf command.
    In system-wide mode it can scan every process in /proc, which may add
    seconds of latency before event recording. Add a new benchmark that
    times how long event synthesis takes with and without data synthesis.
    
    An example execution looks like:
    
     $ perf bench internals synthesize
     # Running 'internals/synthesize' benchmark:
     Average synthesis took: 168.253800 usec
     Average data synthesis took: 208.104700 usec
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrey Zhizhikin <andrey.z@gmail.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200402154357.107873-2-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 4aa6de1aa67d..4d669c803237 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -41,9 +41,9 @@ int bench_futex_wake_parallel(int argc, const char **argv);
 int bench_futex_requeue(int argc, const char **argv);
 /* pi futexes */
 int bench_futex_lock_pi(int argc, const char **argv);
-
 int bench_epoll_wait(int argc, const char **argv);
 int bench_epoll_ctl(int argc, const char **argv);
+int bench_synthesize(int argc, const char **argv);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit e4d9b04b973b2dbce7b42af95ea70d07da1c936d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 2 12:09:38 2020 -0300

    perf bench: Share some global variables to fix build with gcc 10
    
    Noticed with gcc 10 (fedora rawhide) that those variables were not being
    declared as static, so end up with:
    
      ld: /tmp/build/perf/bench/epoll-wait.o:/git/perf/tools/perf/bench/epoll-wait.c:93: multiple definition of `end'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      ld: /tmp/build/perf/bench/epoll-wait.o:/git/perf/tools/perf/bench/epoll-wait.c:93: multiple definition of `start'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      ld: /tmp/build/perf/bench/epoll-wait.o:/git/perf/tools/perf/bench/epoll-wait.c:93: multiple definition of `runtime'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      ld: /tmp/build/perf/bench/epoll-ctl.o:/git/perf/tools/perf/bench/epoll-ctl.c:38: multiple definition of `end'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      ld: /tmp/build/perf/bench/epoll-ctl.o:/git/perf/tools/perf/bench/epoll-ctl.c:38: multiple definition of `start'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      ld: /tmp/build/perf/bench/epoll-ctl.o:/git/perf/tools/perf/bench/epoll-ctl.c:38: multiple definition of `runtime'; /tmp/build/perf/bench/futex-hash.o:/git/perf/tools/perf/bench/futex-hash.c:40: first defined here
      make[4]: *** [/git/perf/tools/build/Makefile.build:145: /tmp/build/perf/bench/perf-in.o] Error 1
    
    Prefix those with bench__ and add them to bench/bench.h, so that we can
    share those on the tools needing to access those variables from signal
    handlers.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lore.kernel.org/lkml/20200303155811.GD13702@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index fddb3ced9db6..4aa6de1aa67d 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -2,6 +2,10 @@
 #ifndef BENCH_H
 #define BENCH_H
 
+#include <sys/time.h>
+
+extern struct timeval bench__start, bench__end, bench__runtime;
+
 /*
  * The madvise transparent hugepage constants were added in glibc
  * 2.13. For compatibility with older versions of glibc, define these

commit 231457ec707475c71d4e538a3253f1ed9e294cf0
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Nov 6 07:22:26 2018 -0800

    perf bench: Add epoll_ctl(2) benchmark
    
    Benchmark the various operations allowed for epoll_ctl(2).  The idea is
    to concurrently stress a single epoll instance doing add/mod/del
    operations.
    
    Committer testing:
    
      # perf bench epoll ctl
      # Running 'epoll/ctl' benchmark:
      Run summary [PID 20344]: 4 threads doing epoll_ctl ops 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0x21a46b0 ... 0x21a47ac [ add: 1680960 ops; mod: 1680960 ops; del: 1680960 ops ]
      [thread  1] fdmap: 0x21a4960 ... 0x21a4a5c [ add: 1685440 ops; mod: 1685440 ops; del: 1685440 ops ]
      [thread  2] fdmap: 0x21a4c10 ... 0x21a4d0c [ add: 1674368 ops; mod: 1674368 ops; del: 1674368 ops ]
      [thread  3] fdmap: 0x21a4ec0 ... 0x21a4fbc [ add: 1677568 ops; mod: 1677568 ops; del: 1677568 ops ]
    
      Averaged 1679584 ADD operations (+- 0.14%)
      Averaged 1679584 MOD operations (+- 0.14%)
      Averaged 1679584 DEL operations (+- 0.14%)
      #
    
    Lets measure those calls with 'perf trace' to get a glympse at what this
    benchmark is doing in terms of syscalls:
    
      # perf trace -m32768 -s perf bench epoll ctl
      # Running 'epoll/ctl' benchmark:
      Run summary [PID 20405]: 4 threads doing epoll_ctl ops 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0x21764e0 ... 0x21765dc [ add: 1100480 ops; mod: 1100480 ops; del: 1100480 ops ]
      [thread  1] fdmap: 0x2176790 ... 0x217688c [ add: 1250176 ops; mod: 1250176 ops; del: 1250176 ops ]
      [thread  2] fdmap: 0x2176a40 ... 0x2176b3c [ add: 1022464 ops; mod: 1022464 ops; del: 1022464 ops ]
      [thread  3] fdmap: 0x2176cf0 ... 0x2176dec [ add: 705472 ops; mod: 705472 ops; del: 705472 ops ]
    
      Averaged 1019648 ADD operations (+- 11.27%)
      Averaged 1019648 MOD operations (+- 11.27%)
      Averaged 1019648 DEL operations (+- 11.27%)
    
      Summary of events:
    
      epoll-ctl (20405), 1264 events, 0.0%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       eventfd2             256     9.514     0.001     0.037     5.243     68.00%
       clone                  4     1.245     0.204     0.311     0.531     24.13%
       mprotect              66     0.345     0.002     0.005     0.021      7.43%
       openat                45     0.313     0.004     0.007     0.073     21.93%
       mmap                  88     0.302     0.002     0.003     0.013      5.02%
       futex                  4     0.160     0.002     0.040     0.140     83.43%
       sched_setaffinity      4     0.124     0.005     0.031     0.070     49.39%
       read                  44     0.103     0.001     0.002     0.013     15.54%
       fstat                 40     0.052     0.001     0.001     0.003      5.43%
       close                 39     0.039     0.001     0.001     0.001      1.48%
       stat                   9     0.034     0.003     0.004     0.006      7.30%
       access                 3     0.023     0.007     0.008     0.008      4.25%
       open                   2     0.021     0.008     0.011     0.013     22.60%
       getdents               4     0.019     0.001     0.005     0.009     37.15%
       write                  2     0.013     0.004     0.007     0.009     38.48%
       munmap                 1     0.010     0.010     0.010     0.010      0.00%
       brk                    3     0.006     0.001     0.002     0.003     26.34%
       rt_sigprocmask         2     0.004     0.001     0.002     0.003     43.95%
       rt_sigaction           3     0.004     0.001     0.001     0.002     16.07%
       prlimit64              3     0.004     0.001     0.001     0.001      5.39%
       prctl                  1     0.003     0.003     0.003     0.003      0.00%
       epoll_create           1     0.003     0.003     0.003     0.003      0.00%
       lseek                  2     0.002     0.001     0.001     0.001     11.42%
       sched_getaffinity        1     0.002     0.002     0.002     0.002      0.00%
       arch_prctl             1     0.002     0.002     0.002     0.002      0.00%
       set_tid_address        1     0.001     0.001     0.001     0.001      0.00%
       getpid                 1     0.001     0.001     0.001     0.001      0.00%
       set_robust_list        1     0.001     0.001     0.001     0.001      0.00%
       execve                 1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20406), 1245480 events, 14.6%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         619511  1034.927     0.001     0.002     6.691      0.67%
       nanosleep           3226   616.114     0.006     0.191    10.376      7.57%
       futex                  2    11.336     0.002     5.668    11.334     99.97%
       set_robust_list        1     0.001     0.001     0.001     0.001      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20407), 1243151 events, 14.5%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         618350  1042.181     0.001     0.002     2.512      0.40%
       nanosleep           3220   366.261     0.012     0.114    18.162      9.59%
       futex                  4     5.463     0.001     1.366     5.427     99.12%
       set_robust_list        1     0.002     0.002     0.002     0.002      0.00%
    
     epoll-ctl (20408), 1801690 events, 21.1%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl         896174  1540.581     0.001     0.002     6.987      0.74%
       nanosleep           4667   783.393     0.006     0.168    10.419      7.10%
       futex                  2     4.682     0.002     2.341     4.681     99.93%
       set_robust_list        1     0.002     0.002     0.002     0.002      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
    
     epoll-ctl (20409), 4254890 events, 49.8%
    
       syscall            calls    total       min       avg       max      stddev
                                   (msec)    (msec)    (msec)    (msec)        (%)
       --------------- -------- --------- --------- --------- ---------     ------
       epoll_ctl        2116416  3768.097     0.001     0.002     9.956      0.41%
       nanosleep          11023  1141.778     0.006     0.104     9.447      4.95%
       futex                  3     0.037     0.002     0.012     0.029     70.50%
       set_robust_list        1     0.008     0.008     0.008     0.008      0.00%
       madvise                1     0.005     0.005     0.005     0.005      0.00%
       clone                  1     0.000     0.000     0.000     0.000      0.00%
      #
    
    Committer notes:
    
    Fix build on fedora:24-x-ARC-uClibc, debian:experimental-x-mips,
    debian:experimental-x-mipsel, ubuntu:16.04-x-arm and ubuntu:16.04-x-powerpc
    
        CC       /tmp/build/perf/bench/epoll-ctl.o
      bench/epoll-ctl.c: In function 'init_fdmaps':
      bench/epoll-ctl.c:214:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nfds; i+=inc) {
                      ^
      bench/epoll-ctl.c: In function 'bench_epoll_ctl':
      bench/epoll-ctl.c:377:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nthreads; i++) {
                      ^
      bench/epoll-ctl.c:388:16: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
        for (i = 0; i < nthreads; i++) {
                      ^
      cc1: all warnings being treated as errors
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181106152226.20883-3-dave@stgolabs.net
    [ Use inttypes.h to print rlim_t fields, fixing the build on Alpine Linux / musl libc ]
    [ Check if eventfd() is available, i.e. if HAVE_EVENTFD is defined ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 6e1f091ced96..fddb3ced9db6 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -39,6 +39,7 @@ int bench_futex_requeue(int argc, const char **argv);
 int bench_futex_lock_pi(int argc, const char **argv);
 
 int bench_epoll_wait(int argc, const char **argv);
+int bench_epoll_ctl(int argc, const char **argv);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 121dd9ea0116de3e79a4903a84018190c595e2b6
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Nov 6 07:22:25 2018 -0800

    perf bench: Add epoll parallel epoll_wait benchmark
    
    This program benchmarks concurrent epoll_wait(2) for file descriptors
    that are monitored with with EPOLLIN along various semantics, by a
    single epoll instance. Such conditions can be found when using
    single/combined or multiple queuing when load balancing.
    
    Each thread has a number of private, nonblocking file descriptors,
    referred to as fdmap. A writer thread will constantly be writing to the
    fdmaps of all threads, minimizing each threads's chances of epoll_wait
    not finding any ready read events and blocking as this is not what we
    want to stress. Full details in the start of the C file.
    
    Committer testing:
    
      # perf bench
      Usage:
            perf bench [<common options>] <collection> <benchmark> [<options>]
    
            # List of all available benchmark collections:
    
             sched: Scheduler and IPC benchmarks
               mem: Memory access benchmarks
              numa: NUMA scheduling and MM benchmarks
             futex: Futex stressing benchmarks
             epoll: Epoll stressing benchmarks
               all: All benchmarks
    
      # perf bench epoll
    
            # List of available benchmarks for collection 'epoll':
    
              wait: Benchmark epoll concurrent epoll_waits
               all: Run all futex benchmarks
    
      # perf bench epoll wait
      # Running 'epoll/wait' benchmark:
      Run summary [PID 19295]: 3 threads monitoring on 64 file-descriptors for 8 secs.
    
      [thread  0] fdmap: 0xdaa650 ... 0xdaa74c [ 328241 ops/sec ]
      [thread  1] fdmap: 0xdaa900 ... 0xdaa9fc [ 351695 ops/sec ]
      [thread  2] fdmap: 0xdaabb0 ... 0xdaacac [ 381423 ops/sec ]
    
      Averaged 353786 operations/sec (+- 4.35%), total secs = 8
      #
    
    Committer notes:
    
    Fix the build on debian:experimental-x-mips, debian:experimental-x-mipsel
    and others:
    
        CC       /tmp/build/perf/bench/epoll-wait.o
      bench/epoll-wait.c: In function 'writerfn':
      bench/epoll-wait.c:399:12: error: format '%ld' expects argument of type 'long int', but argument 2 has type 'size_t' {aka 'unsigned int'} [-Werror=format=]
        printinfo("exiting writer-thread (total full-loops: %ld)\n", iter);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ~~~~
      bench/epoll-wait.c:86:31: note: in definition of macro 'printinfo'
        do { if (__verbose) { printf(fmt, ## arg); fflush(stdout); } } while (0)
                                     ^~~
      cc1: all warnings being treated as errors
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com> <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181106152226.20883-2-dave@stgolabs.net
    Link: http://lkml.kernel.org/r/20181106182349.thdkpvshkna5vd7o@linux-r8p5>
    [ Applied above fixup as per Davidlohr's request ]
    [ Use inttypes.h to print rlim_t fields, fixing the build on Alpine Linux / musl libc ]
    [ Check if eventfd() is available, i.e. if HAVE_EVENTFD is defined ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 8299c76046cd..6e1f091ced96 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -38,6 +38,8 @@ int bench_futex_requeue(int argc, const char **argv);
 /* pi futexes */
 int bench_futex_lock_pi(int argc, const char **argv);
 
+int bench_epoll_wait(int argc, const char **argv);
+
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0
 #define BENCH_FORMAT_SIMPLE_STR		"simple"

commit d47d77c3f008d3cf02c6ce92ef4f6e32ca270351
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Nov 9 13:07:19 2018 -0800

    perf bench: Move HAVE_PTHREAD_ATTR_SETAFFINITY_NP into bench.h
    
    Both futex and epoll need this call, and can cause build failure on
    systems that don't have it pthread_attr_setaffinity_np().
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Reported-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Jason Baron <jbaron@akamai.com>
    Link: http://lkml.kernel.org/r/20181109210719.pr7ohayuwqmfp2wl@linux-r8p5
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 6c9fcd757f31..8299c76046cd 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -48,4 +48,15 @@ int bench_futex_lock_pi(int argc, const char **argv);
 extern int bench_format;
 extern unsigned int bench_repeat;
 
+#ifndef HAVE_PTHREAD_ATTR_SETAFFINITY_NP
+#include <pthread.h>
+#include <linux/compiler.h>
+static inline int pthread_attr_setaffinity_np(pthread_attr_t *attr __maybe_unused,
+					      size_t cpusetsize __maybe_unused,
+					      cpu_set_t *cpuset __maybe_unused)
+{
+	return 0;
+}
+#endif
+
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 842ab2781cdc..6c9fcd757f31 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef BENCH_H
 #define BENCH_H
 

commit b0ad8ea66445d64a469df0c710947f4cdb8ef16b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 27 11:47:20 2017 -0300

    perf tools: Remove unused 'prefix' from builtin functions
    
    We got it from the git sources but never used it for anything, with the
    place where this would be somehow used remaining:
    
      static int run_builtin(struct cmd_struct *p, int argc, const char **argv)
      {
            prefix = NULL;
            if (p->option & RUN_SETUP)
                    prefix = NULL; /* setup_perf_directory(); */
    
    Ditch it.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-uw5swz05vol0qpr32c5lpvus@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 579a592990dd..842ab2781cdc 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -25,17 +25,17 @@
 # endif
 #endif
 
-int bench_numa(int argc, const char **argv, const char *prefix);
-int bench_sched_messaging(int argc, const char **argv, const char *prefix);
-int bench_sched_pipe(int argc, const char **argv, const char *prefix);
-int bench_mem_memcpy(int argc, const char **argv, const char *prefix);
-int bench_mem_memset(int argc, const char **argv, const char *prefix);
-int bench_futex_hash(int argc, const char **argv, const char *prefix);
-int bench_futex_wake(int argc, const char **argv, const char *prefix);
-int bench_futex_wake_parallel(int argc, const char **argv, const char *prefix);
-int bench_futex_requeue(int argc, const char **argv, const char *prefix);
+int bench_numa(int argc, const char **argv);
+int bench_sched_messaging(int argc, const char **argv);
+int bench_sched_pipe(int argc, const char **argv);
+int bench_mem_memcpy(int argc, const char **argv);
+int bench_mem_memset(int argc, const char **argv);
+int bench_futex_hash(int argc, const char **argv);
+int bench_futex_wake(int argc, const char **argv);
+int bench_futex_wake_parallel(int argc, const char **argv);
+int bench_futex_requeue(int argc, const char **argv);
 /* pi futexes */
-int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);
+int bench_futex_lock_pi(int argc, const char **argv);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 3938bad44ed2fea41328e4be2ae04a8e94540813
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Mar 23 15:06:35 2016 -0300

    perf tools: Remove needless 'extern' from function prototypes
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-w246stf7ponfamclsai6b9zo@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 7e7e43207bbd..579a592990dd 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -25,19 +25,17 @@
 # endif
 #endif
 
-extern int bench_numa(int argc, const char **argv, const char *prefix);
-extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
-extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
-extern int bench_mem_memcpy(int argc, const char **argv,
-			    const char *prefix);
-extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
-extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
-extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
-extern int bench_futex_wake_parallel(int argc, const char **argv,
-				     const char *prefix);
-extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);
+int bench_numa(int argc, const char **argv, const char *prefix);
+int bench_sched_messaging(int argc, const char **argv, const char *prefix);
+int bench_sched_pipe(int argc, const char **argv, const char *prefix);
+int bench_mem_memcpy(int argc, const char **argv, const char *prefix);
+int bench_mem_memset(int argc, const char **argv, const char *prefix);
+int bench_futex_hash(int argc, const char **argv, const char *prefix);
+int bench_futex_wake(int argc, const char **argv, const char *prefix);
+int bench_futex_wake_parallel(int argc, const char **argv, const char *prefix);
+int bench_futex_requeue(int argc, const char **argv, const char *prefix);
 /* pi futexes */
-extern int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);
+int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit b8f8eb84f4834b5232faf57559adbc80dbcf85da
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 22 13:09:37 2016 -0300

    perf tools: Remove misplaced __maybe_unused
    
    All over the tree.
    
    Cc: David Ahern <dsahern@gmail.com>
    cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Ravi Bangoria <ravi.bangoria@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-8nzhnokxyp8y4v7gf0j00oyb@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index a50df86f2b9b..7e7e43207bbd 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -29,7 +29,7 @@ extern int bench_numa(int argc, const char **argv, const char *prefix);
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
 extern int bench_mem_memcpy(int argc, const char **argv,
-			    const char *prefix __maybe_unused);
+			    const char *prefix);
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
 extern int bench_futex_wake(int argc, const char **argv, const char *prefix);

commit d2f3f5d2e9cae6e73f9642a5ddc8c8a07c35e79b
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Jul 7 01:55:53 2015 -0700

    perf bench futex: Add lock_pi stresser
    
    Allows a way of measuring low level kernel implementation of FUTEX_LOCK_PI and
    FUTEX_UNLOCK_PI.
    
    The program comes in two flavors:
    
    (i) single futex (default), all threads contend on the same uaddr.  For the
    sake of the benchmark, we call into kernel space even when the lock is
    uncontended.  The kernel will set it to TID, any waters that come in and
    contend for the pi futex will be handled respectively by the kernel.
    
    (ii) -M option for multiple futexes, each thread deals with its own futex. This
    is a trivial scenario and only measures kernel handling of 0->TID transition.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Mel Gorman <mgorman@suse.de>
    Link: http://lkml.kernel.org/r/1436259353.12255.78.camel@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 70b2f718cc21..a50df86f2b9b 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -36,6 +36,8 @@ extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
 extern int bench_futex_wake_parallel(int argc, const char **argv,
 				     const char *prefix);
 extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);
+/* pi futexes */
+extern int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit d65817b4e707068c2dd3e002e87c2a0294aabc2c
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri May 8 11:37:59 2015 -0700

    perf bench futex: Support parallel waker threads
    
    The futex-wake benchmark only measures wakeups done within a single
    process. While this has value in its own, it does not really generate
    any hb->lock contention.
    
    A new benchmark 'wake-parallel' is added, by extending the futex-wake
    code such that we can measure parallel waker threads. The program output
    shows the avg per-thread latency in order to complete its share of
    wakeups:
    
    Run summary [PID 13474]: blocking on 512 threads (at [private] futex 0xa88668), 8 threads waking up 64 at a time.
    
    [Run 1]: Avg per-thread latency (waking 64/512 threads) in 0.6230 ms (+-15.31%)
    [Run 2]: Avg per-thread latency (waking 64/512 threads) in 0.5175 ms (+-29.95%)
    [Run 3]: Avg per-thread latency (waking 64/512 threads) in 0.7578 ms (+-18.03%)
    [Run 4]: Avg per-thread latency (waking 64/512 threads) in 0.8944 ms (+-12.54%)
    [Run 5]: Avg per-thread latency (waking 64/512 threads) in 1.1204 ms (+-23.85%)
    Avg per-thread latency (waking 64/512 threads) in 0.7826 ms (+-9.91%)
    
    Naturally, different combinations of numbers of blocking and waker
    threads will exhibit different information.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Link: http://lkml.kernel.org/r/1431110280-20231-1-git-send-email-dave@stgolabs.net
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 3c4dd44d45cb..70b2f718cc21 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -33,6 +33,8 @@ extern int bench_mem_memcpy(int argc, const char **argv,
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
 extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
+extern int bench_futex_wake_parallel(int argc, const char **argv,
+				     const char *prefix);
 extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"

commit b6f0629a94f7ed6089560be7f0561be19f934fc4
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Mon Jun 16 11:14:19 2014 -0700

    perf bench: Add --repeat option
    
    There are a number of benchmarks that do single runs and as a result
    does not really help users gain a general idea of how the workload
    performs. So the user must either manually do multiple runs or just use
    single bogus results.
    
    This option will enable users to specify the amount of runs (arbitrarily
    defaulted to 10, to use the existing benchmarks default) through the
    '--repeat' option.  Add it to perf-bench instead of implementing it
    always in each specific benchmark.
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/1402942467-10671-2-git-send-email-davidlohr@hp.com
    [ Kept the existing default of 10, changing it to something else should
      be done on separate patch ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index eba46709b279..3c4dd44d45cb 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -43,5 +43,6 @@ extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);
 #define BENCH_FORMAT_UNKNOWN		-1
 
 extern int bench_format;
+extern unsigned int bench_repeat;
 
 #endif

commit 0fb298cf95c0d8119557b7d4657724a146e0622e
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:57 2013 -0800

    perf bench: Add futex-requeue microbenchmark
    
    Block a bunch of threads on a futex and requeue them on another, N at a
    time.
    
    This program is particularly useful to measure the latency of nthread
    requeues without waking up any tasks -- thus mimicking a regular
    futex_wait.
    
    An example run:
    
      $ perf bench futex requeue -r 100 -t 64
      Run summary [PID 151011]: Requeuing 64 threads (from 0x7d15c4 to 0x7d15c8), 1 at a time.
    
      [Run 1]: Requeued 64 of 64 threads in 0.0400 ms
      [Run 2]: Requeued 64 of 64 threads in 0.0390 ms
      [Run 3]: Requeued 64 of 64 threads in 0.0400 ms
      ...
      [Run 100]: Requeued 64 of 64 threads in 0.0390 ms
      Requeued 64 of 64 threads in 0.0399 ms (+-0.37%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-4-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 6ac3f1d083cc..eba46709b279 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -33,6 +33,7 @@ extern int bench_mem_memcpy(int argc, const char **argv,
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
 extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
+extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 27db78307481dbba68c5f3563c6cb694b25521d9
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:56 2013 -0800

    perf bench: Add futex-wake microbenchmark
    
    Block a bunch of threads on a futex and wake them up, N at a time.
    
    This program is particularly useful to measure the latency of nthread
    wakeups in non-error situations:  all waiters are queued and all wake
    calls wakeup one or more tasks.
    
    An example run:
    
      $ perf bench futex wake -t 512 -r 100
      Run summary [PID 27823]: blocking on 512 threads (at futex 0x7e10d4), waking up 1 at a time.
    
      [Run 1]: Wokeup 512 of 512 threads in 6.0080 ms
      [Run 2]: Wokeup 512 of 512 threads in 5.2280 ms
      [Run 3]: Wokeup 512 of 512 threads in 4.8300 ms
      ...
      [Run 100]: Wokeup 512 of 512 threads in 5.0100 ms
      Wokeup 512 of 512 threads in 5.0109 ms (+-2.25%)
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-3-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 34edb5c34db3..6ac3f1d083cc 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -32,6 +32,7 @@ extern int bench_mem_memcpy(int argc, const char **argv,
 			    const char *prefix __maybe_unused);
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
+extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit a043971141f163f9845324a2f83502d15011485d
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Sat Dec 14 20:31:55 2013 -0800

    perf bench: Add futex-hash microbenchmark
    
    Introduce futexes to perf-bench and add a program that stresses and
    measures the kernel's implementation of the hash table.
    
    This is a multi-threaded program that simply measures the amount of
    failed futex wait calls - we only want to deal with the hashing
    overhead, so a negative return of futex_wait_setup() is enough to do the
    trick.
    
    An example run:
    
      $ perf bench futex hash -t 32
      Run summary [PID 10989]: 32 threads, each operating on 1024 [private] futexes for 10 secs.
    
      [thread  0] futexes: 0x19d9b10 ... 0x19dab0c [ 418713 ops/sec ]
      [thread  1] futexes: 0x19daca0 ... 0x19dbc9c [ 469913 ops/sec ]
      [thread  2] futexes: 0x19dbe30 ... 0x19dce2c [ 479744 ops/sec ]
      ...
      [thread 31] futexes: 0x19fbb80 ... 0x19fcb7c [ 464179 ops/sec ]
    
      Averaged 454310 operations/sec (+- 0.84%), total secs = 10
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Scott J Norton <scott.norton@hp.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <Waiman.Long@hp.com>
    Link: http://lkml.kernel.org/r/1387081917-9102-2-git-send-email-davidlohr@hp.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 0fdc85269c4d..34edb5c34db3 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -31,6 +31,7 @@ extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
 extern int bench_mem_memcpy(int argc, const char **argv,
 			    const char *prefix __maybe_unused);
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
+extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit d1398ccfec56e54010476efd6a316427d29045a6
Author: Vinson Lee <vlee@twitter.com>
Date:   Wed Mar 13 15:34:24 2013 -0700

    perf tools: Fix LIBNUMA build with glibc 2.12 and older.
    
    The tokens MADV_HUGEPAGE and MADV_NOHUGEPAGE are not available with
    glibc 2.12 and older. Define these tokens if they are not already
    defined.
    
    This patch fixes these build errors with older versions of glibc.
    
        CC bench/numa.o
    bench/numa.c: In function ‘alloc_data’:
    bench/numa.c:334: error: ‘MADV_HUGEPAGE’ undeclared (first use in this function)
    bench/numa.c:334: error: (Each undeclared identifier is reported only once
    bench/numa.c:334: error: for each function it appears in.)
    bench/numa.c:341: error: ‘MADV_NOHUGEPAGE’ undeclared (first use in this function)
    make: *** [bench/numa.o] Error 1
    
    Signed-off-by: Vinson Lee <vlee@twitter.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Irina Tirdea <irina.tirdea@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1363214064-4671-2-git-send-email-vlee@twitter.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index a5223e6a7b43..0fdc85269c4d 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -1,6 +1,30 @@
 #ifndef BENCH_H
 #define BENCH_H
 
+/*
+ * The madvise transparent hugepage constants were added in glibc
+ * 2.13. For compatibility with older versions of glibc, define these
+ * tokens if they are not already defined.
+ *
+ * PA-RISC uses different madvise values from other architectures and
+ * needs to be special-cased.
+ */
+#ifdef __hppa__
+# ifndef MADV_HUGEPAGE
+#  define MADV_HUGEPAGE		67
+# endif
+# ifndef MADV_NOHUGEPAGE
+#  define MADV_NOHUGEPAGE	68
+# endif
+#else
+# ifndef MADV_HUGEPAGE
+#  define MADV_HUGEPAGE		14
+# endif
+# ifndef MADV_NOHUGEPAGE
+#  define MADV_NOHUGEPAGE	15
+# endif
+#endif
+
 extern int bench_numa(int argc, const char **argv, const char *prefix);
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);

commit 1c13f3c9042f9d222959af7c9da6db93ea9f7e4c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Dec 6 13:51:59 2012 +0100

    perf: Add 'perf bench numa mem' NUMA performance measurement suite
    
    Add a suite of NUMA performance benchmarks.
    
    The goal was simulate the behavior and access patterns of real NUMA
    workloads, via a wide range of parameters, so this tool goes well
    beyond simple bzero() measurements that most NUMA micro-benchmarks use:
    
     - It processes the data and creates a chain of data dependencies,
       like a real workload would. Neither the compiler, nor the
       kernel (via KSM and other optimizations) nor the CPU can
       eliminate parts of the workload.
    
     - It randomizes the initial state and also randomizes the target
       addresses of the processing - it's not a simple forward scan
       of addresses.
    
     - It provides flexible options to set process, thread and memory
       relationship information: -G sets "global" memory shared between
       all test processes, -P sets "process" memory shared by all
       threads of a process and -T sets "thread" private memory.
    
     - There's a NUMA convergence monitoring and convergence latency
       measurement option via -c and -m.
    
     - Micro-sleeps and synchronization can be injected to provoke lock
       contention and scheduling, via the -u and -S options. This simulates
       IO and contention.
    
     - The -x option instructs the workload to 'perturb' itself artificially
       every N seconds, by moving to the first and last CPU of the system
       periodically. This way the stability of convergence equilibrium and
       the number of steps taken for the scheduler to reach equilibrium again
       can be measured.
    
     - The amount of work can be specified via the -l loop count, and/or
       via a -s seconds-timeout value.
    
     - CPU and node memory binding options, to test hard binding scenarios.
       THP can be turned on and off via madvise() calls.
    
     - Live reporting of convergence progress in an 'at glance' output format.
       Printing of convergence and deconvergence events.
    
    The 'perf bench numa mem -a' option will start an array of about 30
    individual tests that will each output such measurements:
    
     # Running  5x5-bw-thread, "perf bench numa mem -p 5 -t 5 -P 512 -s 20 -zZ0q --thp  1"
      5x5-bw-thread,                         20.276, secs,           runtime-max/thread
      5x5-bw-thread,                         20.004, secs,           runtime-min/thread
      5x5-bw-thread,                         20.155, secs,           runtime-avg/thread
      5x5-bw-thread,                          0.671, %,              spread-runtime/thread
      5x5-bw-thread,                         21.153, GB,             data/thread
      5x5-bw-thread,                        528.818, GB,             data-total
      5x5-bw-thread,                          0.959, nsecs,          runtime/byte/thread
      5x5-bw-thread,                          1.043, GB/sec,         thread-speed
      5x5-bw-thread,                         26.081, GB/sec,         total-speed
    
    See the help text and the code for more details.
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Hugh Dickins <hughd@google.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 8f89998eeaf4..a5223e6a7b43 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -1,6 +1,7 @@
 #ifndef BENCH_H
 #define BENCH_H
 
+extern int bench_numa(int argc, const char **argv, const char *prefix);
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
 extern int bench_mem_memcpy(int argc, const char **argv,

commit 1d037ca1648b775277fc96401ec2aa233724906c
Author: Irina Tirdea <irina.tirdea@gmail.com>
Date:   Tue Sep 11 01:15:03 2012 +0300

    perf tools: Use __maybe_used for unused variables
    
    perf defines both __used and __unused variables to use for marking
    unused variables. The variable __used is defined to
    __attribute__((__unused__)), which contradicts the kernel definition to
    __attribute__((__used__)) for new gcc versions. On Android, __used is
    also defined in system headers and this leads to warnings like: warning:
    '__used__' attribute ignored
    
    __unused is not defined in the kernel and is not a standard definition.
    If __unused is included everywhere instead of __used, this leads to
    conflicts with glibc headers, since glibc has a variables with this name
    in its headers.
    
    The best approach is to use __maybe_unused, the definition used in the
    kernel for __attribute__((unused)). In this way there is only one
    definition in perf sources (instead of 2 definitions that point to the
    same thing: __used and __unused) and it works on both Linux and Android.
    This patch simply replaces all instances of __used and __unused with
    __maybe_unused.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Acked-by: Pekka Enberg <penberg@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1347315303-29906-7-git-send-email-irina.tirdea@intel.com
    [ committer note: fixed up conflict with a116e05 in builtin-sched.c ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index a09bece6dad2..8f89998eeaf4 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -3,7 +3,8 @@
 
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
-extern int bench_mem_memcpy(int argc, const char **argv, const char *prefix __used);
+extern int bench_mem_memcpy(int argc, const char **argv,
+			    const char *prefix __maybe_unused);
 extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"

commit be3de80dc2e671d9ee15e69fe9cd84d2b71e2225
Author: Jan Beulich <jbeulich@suse.com>
Date:   Tue Jan 24 10:03:22 2012 -0200

    perf bench: Also allow measuring memset()
    
    This simply clones the respective memcpy() implementation.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/4F16D743020000780006D735@nat28.tlf.novell.com
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index f7781c6267c0..a09bece6dad2 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -4,6 +4,7 @@
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
 extern int bench_mem_memcpy(int argc, const char **argv, const char *prefix __used);
+extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 827f3b4974c5db2968d4979fe6a0ae00ab37bdd8
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Wed Nov 18 00:20:09 2009 +0900

    perf bench: Add memcpy() benchmark
    
    'perf bench mem memcpy' is a benchmark suite for measuring memcpy()
    performance.
    
    Example on a Intel(R) Core(TM)2 Duo CPU E6850 @ 3.00GHz:
    
    | % perf bench mem memcpy -l 1GB
    | # Running mem/memcpy benchmark...
    | # Copying 1MB Bytes from 0xb7d98008 to 0xb7e99008 ...
    |
    |     726.216412 MB/Sec
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <1258471212-30281-1-git-send-email-mitake@dcl.info.waseda.ac.jp>
    [ v2: updated changelog, clarified history of builtin-bench.c ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 9fbd8d745fa1..f7781c6267c0 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -3,6 +3,7 @@
 
 extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
 extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
+extern int bench_mem_memcpy(int argc, const char **argv, const char *prefix __used);
 
 #define BENCH_FORMAT_DEFAULT_STR	"default"
 #define BENCH_FORMAT_DEFAULT		0

commit 606bc1e18d346fc7d7fb333909cc95b06b1ca5b1
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Nov 10 20:50:53 2009 +0900

    perf bench: Clean up bench/bench.h
    
    Clean up initializers in bench.h:
    
      - No need to break the line for function prototypes, they are more
        readable in a single line. (even if checkpatch complains about it
    
      - We try to align definitions / structure fields vertically,
        to make it  all a bit more readable.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1257853855-28934-2-git-send-email-mitake@dcl.info.waseda.ac.jp>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 42167ea41944..9fbd8d745fa1 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -1,17 +1,15 @@
 #ifndef BENCH_H
 #define BENCH_H
 
-extern int bench_sched_messaging(int argc, const char **argv,
-				 const char *prefix);
-extern int bench_sched_pipe(int argc, const char **argv,
-			    const char *prefix);
+extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);
+extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);
 
-#define BENCH_FORMAT_DEFAULT_STR "default"
-#define BENCH_FORMAT_DEFAULT 0
-#define BENCH_FORMAT_SIMPLE_STR "simple"
-#define BENCH_FORMAT_SIMPLE 1
+#define BENCH_FORMAT_DEFAULT_STR	"default"
+#define BENCH_FORMAT_DEFAULT		0
+#define BENCH_FORMAT_SIMPLE_STR		"simple"
+#define BENCH_FORMAT_SIMPLE		1
 
-#define BENCH_FORMAT_UNKNOWN -1
+#define BENCH_FORMAT_UNKNOWN		-1
 
 extern int bench_format;
 

commit 242aa14a67f4e19453fc8a51cffc5ac5ee5bcbd1
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Tue Nov 10 08:19:59 2009 +0900

    perf bench: Add format constants to bench.h for unified output formatting
    
    This patch adds some constants and extern declaration to
    bench.h. These are used for unified output formatting
    of 'perf bench'.
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <1257808802-9420-2-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
index 59adb279cd7a..42167ea41944 100644
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@ -6,4 +6,13 @@ extern int bench_sched_messaging(int argc, const char **argv,
 extern int bench_sched_pipe(int argc, const char **argv,
 			    const char *prefix);
 
+#define BENCH_FORMAT_DEFAULT_STR "default"
+#define BENCH_FORMAT_DEFAULT 0
+#define BENCH_FORMAT_SIMPLE_STR "simple"
+#define BENCH_FORMAT_SIMPLE 1
+
+#define BENCH_FORMAT_UNKNOWN -1
+
+extern int bench_format;
+
 #endif

commit c426bba069e65ea438880a04aa4e7c5b880e1728
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Thu Nov 5 09:31:31 2009 +0900

    perf bench: Add new directory and header for new subcommand 'bench'
    
    This patch adds bench/ directory and bench/bench.h.
    
    bench/ directory will contain modules for bench subcommand.
    bench/bench.h is for listing prototypes of module functions.
    
    Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: Jiri Kosina <jkosina@suse.cz>
    LKML-Reference: <1257381097-4743-2-git-send-email-mitake@dcl.info.waseda.ac.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h
new file mode 100644
index 000000000000..59adb279cd7a
--- /dev/null
+++ b/tools/perf/bench/bench.h
@@ -0,0 +1,9 @@
+#ifndef BENCH_H
+#define BENCH_H
+
+extern int bench_sched_messaging(int argc, const char **argv,
+				 const char *prefix);
+extern int bench_sched_pipe(int argc, const char **argv,
+			    const char *prefix);
+
+#endif
