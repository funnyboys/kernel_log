commit fe4eb069edb7ab845160350d9e67d572c026a4a7
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu Mar 12 14:03:30 2020 +0100

    bpftool: Use linux/types.h from source tree for profiler build
    
    When compiling bpftool on a system where the /usr/include/asm symlink
    doesn't exist (e.g. on an Ubuntu system without gcc-multilib installed),
    the build fails with:
    
        CLANG    skeleton/profiler.bpf.o
      In file included from skeleton/profiler.bpf.c:4:
      In file included from /usr/include/linux/bpf.h:11:
      /usr/include/linux/types.h:5:10: fatal error: 'asm/types.h' file not found
      #include <asm/types.h>
               ^~~~~~~~~~~~~
      1 error generated.
      make: *** [Makefile:123: skeleton/profiler.bpf.o] Error 1
    
    This indicates that the build is using linux/types.h from system headers
    instead of source tree headers.
    
    To fix this, adjust the clang search path to include the necessary
    headers from tools/testing/selftests/bpf/include/uapi and
    tools/include/uapi. Also use __bitwise__ instead of __bitwise in
    skeleton/profiler.h to avoid clashing with the definition in
    tools/testing/selftests/bpf/include/uapi/linux/types.h.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Quentin Monnet <quentin@isovalent.com>
    Link: https://lore.kernel.org/bpf/20200312130330.32239-1-tklauser@distanz.ch

diff --git a/tools/bpf/bpftool/skeleton/profiler.h b/tools/bpf/bpftool/skeleton/profiler.h
index e03b53eae767..1f767e9510f7 100644
--- a/tools/bpf/bpftool/skeleton/profiler.h
+++ b/tools/bpf/bpftool/skeleton/profiler.h
@@ -32,16 +32,15 @@ enum {
 #else
 #define __bitwise__
 #endif
-#define __bitwise __bitwise__
 
-typedef __u16 __bitwise __le16;
-typedef __u16 __bitwise __be16;
-typedef __u32 __bitwise __le32;
-typedef __u32 __bitwise __be32;
-typedef __u64 __bitwise __le64;
-typedef __u64 __bitwise __be64;
+typedef __u16 __bitwise__ __le16;
+typedef __u16 __bitwise__ __be16;
+typedef __u32 __bitwise__ __le32;
+typedef __u32 __bitwise__ __be32;
+typedef __u64 __bitwise__ __le64;
+typedef __u64 __bitwise__ __be64;
 
-typedef __u16 __bitwise __sum16;
-typedef __u32 __bitwise __wsum;
+typedef __u16 __bitwise__ __sum16;
+typedef __u32 __bitwise__ __wsum;
 
 #endif /* __PROFILER_H */

commit 47c09d6a9f6794caface4ad50930460b82d7c670
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Mar 9 10:32:15 2020 -0700

    bpftool: Introduce "prog profile" command
    
    With fentry/fexit programs, it is possible to profile BPF program with
    hardware counters. Introduce bpftool "prog profile", which measures key
    metrics of a BPF program.
    
    bpftool prog profile command creates per-cpu perf events. Then it attaches
    fentry/fexit programs to the target BPF program. The fentry program saves
    perf event value to a map. The fexit program reads the perf event again,
    and calculates the difference, which is the instructions/cycles used by
    the target program.
    
    Example input and output:
    
      ./bpftool prog profile id 337 duration 3 cycles instructions llc_misses
    
            4228 run_cnt
         3403698 cycles                                              (84.08%)
         3525294 instructions   #  1.04 insn per cycle               (84.05%)
              13 llc_misses     #  3.69 LLC misses per million isns  (83.50%)
    
    This command measures cycles and instructions for BPF program with id
    337 for 3 seconds. The program has triggered 4228 times. The rest of the
    output is similar to perf-stat. In this example, the counters were only
    counting ~84% of the time because of time multiplexing of perf counters.
    
    Note that, this approach measures cycles and instructions in very small
    increments. So the fentry/fexit programs introduce noticeable errors to
    the measurement results.
    
    The fentry/fexit programs are generated with BPF skeletons. Therefore, we
    build bpftool twice. The first time _bpftool is built without skeletons.
    Then, _bpftool is used to generate the skeletons. The second time, bpftool
    is built with skeletons.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Quentin Monnet <quentin@isovalent.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200309173218.2739965-2-songliubraving@fb.com

diff --git a/tools/bpf/bpftool/skeleton/profiler.h b/tools/bpf/bpftool/skeleton/profiler.h
new file mode 100644
index 000000000000..e03b53eae767
--- /dev/null
+++ b/tools/bpf/bpftool/skeleton/profiler.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+#ifndef __PROFILER_H
+#define __PROFILER_H
+
+/* useful typedefs from vmlinux.h */
+
+typedef signed char __s8;
+typedef unsigned char __u8;
+typedef short int __s16;
+typedef short unsigned int __u16;
+typedef int __s32;
+typedef unsigned int __u32;
+typedef long long int __s64;
+typedef long long unsigned int __u64;
+
+typedef __s8 s8;
+typedef __u8 u8;
+typedef __s16 s16;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __s64 s64;
+typedef __u64 u64;
+
+enum {
+	false = 0,
+	true = 1,
+};
+
+#ifdef __CHECKER__
+#define __bitwise__ __attribute__((bitwise))
+#else
+#define __bitwise__
+#endif
+#define __bitwise __bitwise__
+
+typedef __u16 __bitwise __le16;
+typedef __u16 __bitwise __be16;
+typedef __u32 __bitwise __le32;
+typedef __u32 __bitwise __be32;
+typedef __u64 __bitwise __le64;
+typedef __u64 __bitwise __be64;
+
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+
+#endif /* __PROFILER_H */
