commit 229c3b47b794e7257744224b21a95d3d9938d00a
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Mon Jan 20 14:06:46 2020 +0100

    bpftool: Use consistent include paths for libbpf
    
    Fix bpftool to include libbpf header files with the bpf/ prefix, to be
    consistent with external users of the library. Also ensure that all
    includes of exported libbpf header files (those that are exported on 'make
    install' of the library) use bracketed includes instead of quoted.
    
    To make sure no new files are introduced that doesn't include the bpf/
    prefix in its include, remove tools/lib/bpf from the include path entirely,
    and use tools/lib instead.
    
    Fixes: 6910d7d3867a ("selftests/bpf: Ensure bpf_helper_defs.h are taken from selftests dir")
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157952560684.1683545.4765181397974997027.stgit@toke.dk

diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
index 550a0f537eed..5f65140b003b 100644
--- a/tools/bpf/bpftool/netlink_dumper.c
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -3,11 +3,11 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <libbpf.h>
+#include <bpf/libbpf.h>
 #include <linux/rtnetlink.h>
 #include <linux/tc_act/tc_bpf.h>
 
-#include <nlattr.h>
+#include "bpf/nlattr.h"
 #include "main.h"
 #include "netlink_dumper.h"
 

commit 907b22365115fb86196152909915108d7c8243d1
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Dec 12 19:59:26 2018 -0800

    tools: bpftool: dual license all files
    
    Currently bpftool contains a mix of GPL-only and GPL or BSD2
    licensed files.  Make sure all files are dual licensed under
    GPLv2 and BSD-2-Clause.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Roman Gushchin <guro@fb.com>
    Acked-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Acked-by: Stanislav Fomichev <sdf@google.com>
    Acked-by: Sean Young <sean@mess.org>
    Acked-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: David Calavera <david.calavera@gmail.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Joe Stringer <joe@wand.net.nz>
    Acked-by: David Ahern <dsahern@gmail.com>
    Acked-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Acked-by: Petar Penkov <ppenkov@stanford.edu>
    Acked-by: Sandipan Das <sandipan@linux.ibm.com>
    Acked-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Taeung Song <treeze.taeung@gmail.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    CC: okash.khawaja@gmail.com
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
index 4e9f4531269f..550a0f537eed 100644
--- a/tools/bpf/bpftool/netlink_dumper.c
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0+
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 // Copyright (C) 2018 Facebook
 
 #include <stdlib.h>

commit f04bc8a436e1b32f842a631ff889954bdf56b720
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:40 2018 -0700

    libbpf: Consistent prefixes for interfaces in nlattr.h.
    
    libbpf is used more and more outside kernel tree. That means the library
    should follow good practices in library design and implementation to
    play well with third party code that uses it.
    
    One of such practices is to have a common prefix (or a few) for every
    interface, function or data structure, library provides. I helps to
    avoid name conflicts with other libraries and keeps API consistent.
    
    Inconsistent names in libbpf already cause problems in real life. E.g.
    an application can't use both libbpf and libnl due to conflicting
    symbols.
    
    Having common prefix will help to fix current and avoid future problems.
    
    libbpf already uses the following prefixes for its interfaces:
    * bpf_ for bpf system call wrappers, program/map/elf-object
      abstractions and a few other things;
    * btf_ for BTF related API;
    * libbpf_ for everything else.
    
    The patch adds libbpf_ prefix to interfaces in nlattr.h that use none of
    mentioned above prefixes and doesn't fit well into the first two
    categories.
    
    Since affected part of API is used in bpftool, the patch applies
    corresponding change to bpftool as well. Having it in a separate patch
    will cause a state of tree where bpftool is broken what may not be a
    good idea.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
index 6f5e9cc6836c..4e9f4531269f 100644
--- a/tools/bpf/bpftool/netlink_dumper.c
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -21,7 +21,7 @@ static void xdp_dump_prog_id(struct nlattr **tb, int attr,
 	if (new_json_object)
 		NET_START_OBJECT
 	NET_DUMP_STR("mode", " %s", mode);
-	NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[attr]))
+	NET_DUMP_UINT("id", " id %u", libbpf_nla_getattr_u32(tb[attr]))
 	if (new_json_object)
 		NET_END_OBJECT
 }
@@ -32,13 +32,13 @@ static int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,
 	struct nlattr *tb[IFLA_XDP_MAX + 1];
 	unsigned char mode;
 
-	if (nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)
 		return -1;
 
 	if (!tb[IFLA_XDP_ATTACHED])
 		return 0;
 
-	mode = nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);
+	mode = libbpf_nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);
 	if (mode == XDP_ATTACHED_NONE)
 		return 0;
 
@@ -75,14 +75,14 @@ int do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb)
 		return 0;
 
 	return do_xdp_dump_one(tb[IFLA_XDP], ifinfo->ifi_index,
-			       nla_getattr_str(tb[IFLA_IFNAME]));
+			       libbpf_nla_getattr_str(tb[IFLA_IFNAME]));
 }
 
 static int do_bpf_dump_one_act(struct nlattr *attr)
 {
 	struct nlattr *tb[TCA_ACT_BPF_MAX + 1];
 
-	if (nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	if (!tb[TCA_ACT_BPF_PARMS])
@@ -91,10 +91,10 @@ static int do_bpf_dump_one_act(struct nlattr *attr)
 	NET_START_OBJECT_NESTED2;
 	if (tb[TCA_ACT_BPF_NAME])
 		NET_DUMP_STR("name", "%s",
-			     nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
+			     libbpf_nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
 	if (tb[TCA_ACT_BPF_ID])
 		NET_DUMP_UINT("id", " id %u",
-			      nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
+			      libbpf_nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
 	NET_END_OBJECT_NESTED;
 	return 0;
 }
@@ -106,10 +106,11 @@ static int do_dump_one_act(struct nlattr *attr)
 	if (!attr)
 		return 0;
 
-	if (nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
-	if (tb[TCA_ACT_KIND] && strcmp(nla_data(tb[TCA_ACT_KIND]), "bpf") == 0)
+	if (tb[TCA_ACT_KIND] &&
+	    strcmp(libbpf_nla_data(tb[TCA_ACT_KIND]), "bpf") == 0)
 		return do_bpf_dump_one_act(tb[TCA_ACT_OPTIONS]);
 
 	return 0;
@@ -120,7 +121,7 @@ static int do_bpf_act_dump(struct nlattr *attr)
 	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
 	int act, ret;
 
-	if (nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	NET_START_ARRAY("act", " %s [");
@@ -139,13 +140,15 @@ static int do_bpf_filter_dump(struct nlattr *attr)
 	struct nlattr *tb[TCA_BPF_MAX + 1];
 	int ret;
 
-	if (nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	if (tb[TCA_BPF_NAME])
-		NET_DUMP_STR("name", " %s", nla_getattr_str(tb[TCA_BPF_NAME]));
+		NET_DUMP_STR("name", " %s",
+			     libbpf_nla_getattr_str(tb[TCA_BPF_NAME]));
 	if (tb[TCA_BPF_ID])
-		NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[TCA_BPF_ID]));
+		NET_DUMP_UINT("id", " id %u",
+			      libbpf_nla_getattr_u32(tb[TCA_BPF_ID]));
 	if (tb[TCA_BPF_ACT]) {
 		ret = do_bpf_act_dump(tb[TCA_BPF_ACT]);
 		if (ret)
@@ -160,7 +163,8 @@ int do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind,
 {
 	int ret = 0;
 
-	if (tb[TCA_OPTIONS] && strcmp(nla_data(tb[TCA_KIND]), "bpf") == 0) {
+	if (tb[TCA_OPTIONS] &&
+	    strcmp(libbpf_nla_data(tb[TCA_KIND]), "bpf") == 0) {
 		NET_START_OBJECT;
 		if (devname[0] != '\0')
 			NET_DUMP_STR("devname", "%s", devname);

commit 7900efc19214e326913dc0f0e8ded24adc0018f2
Author: Yonghong Song <yhs@fb.com>
Date:   Mon Sep 17 16:13:00 2018 -0700

    tools/bpf: bpftool: improve output format for bpftool net
    
    This is a followup patch for Commit f6f3bac08ff9
    ("tools/bpf: bpftool: add net support").
    Some improvements are made for the bpftool net output.
    Specially, plain output is more concise such that
    per attachment should nicely fit in one line.
    Compared to previous output, the prog tag is removed
    since it can be easily obtained with program id.
    Similar to xdp attachments, the device name is added
    to tc attachments.
    
    The bpf program attached through shared block
    mechanism is supported as well.
      $ ip link add dev v1 type veth peer name v2
      $ tc qdisc add dev v1 ingress_block 10 egress_block 20 clsact
      $ tc qdisc add dev v2 ingress_block 10 egress_block 20 clsact
      $ tc filter add block 10 protocol ip prio 25 bpf obj bpf_shared.o sec ingress flowid 1:1
      $ tc filter add block 20 protocol ip prio 30 bpf obj bpf_cyclic.o sec classifier flowid 1:1
      $ bpftool net
      xdp:
    
      tc:
      v2(7) clsact/ingress bpf_shared.o:[ingress] id 23
      v2(7) clsact/egress bpf_cyclic.o:[classifier] id 24
      v1(8) clsact/ingress bpf_shared.o:[ingress] id 23
      v1(8) clsact/egress bpf_cyclic.o:[classifier] id 24
    
    The documentation and "bpftool net help" are updated
    to make it clear that current implementation only
    supports xdp and tc attachments. For programs
    attached to cgroups, "bpftool cgroup" can be used
    to dump attachments. For other programs e.g.
    sk_{filter,skb,msg,reuseport} and lwt/seg6,
    iproute2 tools should be used.
    
    The new output:
      $ bpftool net
      xdp:
      eth0(2) driver id 198
    
      tc:
      eth0(2) clsact/ingress fbflow_icmp id 335 act [{icmp_action id 336}]
      eth0(2) clsact/egress fbflow_egress id 334
      $ bpftool -jp net
      [{
            "xdp": [{
                    "devname": "eth0",
                    "ifindex": 2,
                    "mode": "driver",
                    "id": 198
                }
            ],
            "tc": [{
                    "devname": "eth0",
                    "ifindex": 2,
                    "kind": "clsact/ingress",
                    "name": "fbflow_icmp",
                    "id": 335,
                    "act": [{
                            "name": "icmp_action",
                            "id": 336
                        }
                    ]
                },{
                    "devname": "eth0",
                    "ifindex": 2,
                    "kind": "clsact/egress",
                    "name": "fbflow_egress",
                    "id": 334
                }
            ]
        }
      ]
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
index e12494fd1d2e..6f5e9cc6836c 100644
--- a/tools/bpf/bpftool/netlink_dumper.c
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -12,12 +12,18 @@
 #include "netlink_dumper.h"
 
 static void xdp_dump_prog_id(struct nlattr **tb, int attr,
-			     const char *type)
+			     const char *mode,
+			     bool new_json_object)
 {
 	if (!tb[attr])
 		return;
 
-	NET_DUMP_UINT(type, nla_getattr_u32(tb[attr]))
+	if (new_json_object)
+		NET_START_OBJECT
+	NET_DUMP_STR("mode", " %s", mode);
+	NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[attr]))
+	if (new_json_object)
+		NET_END_OBJECT
 }
 
 static int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,
@@ -37,18 +43,26 @@ static int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,
 		return 0;
 
 	NET_START_OBJECT;
-	NET_DUMP_UINT("ifindex", ifindex);
-
 	if (name)
-		NET_DUMP_STR("devname", name);
-
-	if (tb[IFLA_XDP_PROG_ID])
-		NET_DUMP_UINT("prog_id", nla_getattr_u32(tb[IFLA_XDP_PROG_ID]));
+		NET_DUMP_STR("devname", "%s", name);
+	NET_DUMP_UINT("ifindex", "(%d)", ifindex);
 
 	if (mode == XDP_ATTACHED_MULTI) {
-		xdp_dump_prog_id(tb, IFLA_XDP_SKB_PROG_ID, "generic_prog_id");
-		xdp_dump_prog_id(tb, IFLA_XDP_DRV_PROG_ID, "drv_prog_id");
-		xdp_dump_prog_id(tb, IFLA_XDP_HW_PROG_ID, "offload_prog_id");
+		if (json_output) {
+			jsonw_name(json_wtr, "multi_attachments");
+			jsonw_start_array(json_wtr);
+		}
+		xdp_dump_prog_id(tb, IFLA_XDP_SKB_PROG_ID, "generic", true);
+		xdp_dump_prog_id(tb, IFLA_XDP_DRV_PROG_ID, "driver", true);
+		xdp_dump_prog_id(tb, IFLA_XDP_HW_PROG_ID, "offload", true);
+		if (json_output)
+			jsonw_end_array(json_wtr);
+	} else if (mode == XDP_ATTACHED_DRV) {
+		xdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, "driver", false);
+	} else if (mode == XDP_ATTACHED_SKB) {
+		xdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, "generic", false);
+	} else if (mode == XDP_ATTACHED_HW) {
+		xdp_dump_prog_id(tb, IFLA_XDP_PROG_ID, "offload", false);
 	}
 
 	NET_END_OBJECT_FINAL;
@@ -64,26 +78,9 @@ int do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb)
 			       nla_getattr_str(tb[IFLA_IFNAME]));
 }
 
-static char *hexstring_n2a(const unsigned char *str, int len,
-			   char *buf, int blen)
-{
-	char *ptr = buf;
-	int i;
-
-	for (i = 0; i < len; i++) {
-		if (blen < 3)
-			break;
-		sprintf(ptr, "%02x", str[i]);
-		ptr += 2;
-		blen -= 2;
-	}
-	return buf;
-}
-
 static int do_bpf_dump_one_act(struct nlattr *attr)
 {
 	struct nlattr *tb[TCA_ACT_BPF_MAX + 1];
-	char buf[256];
 
 	if (nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
@@ -93,13 +90,11 @@ static int do_bpf_dump_one_act(struct nlattr *attr)
 
 	NET_START_OBJECT_NESTED2;
 	if (tb[TCA_ACT_BPF_NAME])
-		NET_DUMP_STR("name", nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
+		NET_DUMP_STR("name", "%s",
+			     nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
 	if (tb[TCA_ACT_BPF_ID])
-		NET_DUMP_UINT("bpf_id", nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
-	if (tb[TCA_ACT_BPF_TAG])
-		NET_DUMP_STR("tag", hexstring_n2a(nla_data(tb[TCA_ACT_BPF_TAG]),
-						  nla_len(tb[TCA_ACT_BPF_TAG]),
-						  buf, sizeof(buf)));
+		NET_DUMP_UINT("id", " id %u",
+			      nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
 	NET_END_OBJECT_NESTED;
 	return 0;
 }
@@ -128,13 +123,13 @@ static int do_bpf_act_dump(struct nlattr *attr)
 	if (nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
-	NET_START_ARRAY("act", "");
+	NET_START_ARRAY("act", " %s [");
 	for (act = 0; act <= TCA_ACT_MAX_PRIO; act++) {
 		ret = do_dump_one_act(tb[act]);
 		if (ret)
 			break;
 	}
-	NET_END_ARRAY(" ");
+	NET_END_ARRAY("] ");
 
 	return ret;
 }
@@ -142,20 +137,15 @@ static int do_bpf_act_dump(struct nlattr *attr)
 static int do_bpf_filter_dump(struct nlattr *attr)
 {
 	struct nlattr *tb[TCA_BPF_MAX + 1];
-	char buf[256];
 	int ret;
 
 	if (nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	if (tb[TCA_BPF_NAME])
-		NET_DUMP_STR("name", nla_getattr_str(tb[TCA_BPF_NAME]));
+		NET_DUMP_STR("name", " %s", nla_getattr_str(tb[TCA_BPF_NAME]));
 	if (tb[TCA_BPF_ID])
-		NET_DUMP_UINT("prog_id", nla_getattr_u32(tb[TCA_BPF_ID]));
-	if (tb[TCA_BPF_TAG])
-		NET_DUMP_STR("tag", hexstring_n2a(nla_data(tb[TCA_BPF_TAG]),
-						  nla_len(tb[TCA_BPF_TAG]),
-						  buf, sizeof(buf)));
+		NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[TCA_BPF_ID]));
 	if (tb[TCA_BPF_ACT]) {
 		ret = do_bpf_act_dump(tb[TCA_BPF_ACT]);
 		if (ret)
@@ -165,14 +155,17 @@ static int do_bpf_filter_dump(struct nlattr *attr)
 	return 0;
 }
 
-int do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind)
+int do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind,
+		   const char *devname, int ifindex)
 {
 	int ret = 0;
 
 	if (tb[TCA_OPTIONS] && strcmp(nla_data(tb[TCA_KIND]), "bpf") == 0) {
 		NET_START_OBJECT;
-		NET_DUMP_UINT("ifindex", info->tcm_ifindex);
-		NET_DUMP_STR("kind", kind);
+		if (devname[0] != '\0')
+			NET_DUMP_STR("devname", "%s", devname);
+		NET_DUMP_UINT("ifindex", "(%u)", ifindex);
+		NET_DUMP_STR("kind", " %s", kind);
 		ret = do_bpf_filter_dump(tb[TCA_OPTIONS]);
 		NET_END_OBJECT_FINAL;
 	}

commit f6f3bac08ff9855d803081a353a1fafaa8845739
Author: Yonghong Song <yhs@fb.com>
Date:   Wed Sep 5 16:58:06 2018 -0700

    tools/bpf: bpftool: add net support
    
    Add "bpftool net" support. Networking devices are enumerated
    to dump device index/name associated with xdp progs.
    
    For each networking device, tc classes and qdiscs are enumerated
    in order to check their bpf filters.
    In addition, root handle and clsact ingress/egress are also checked for
    bpf filters.  Not all filter information is printed out. Only ifindex,
    kind, filter name, prog_id and tag are printed out, which are good
    enough to show attachment information. If the filter action
    is a bpf action, its bpf program id, bpf name and tag will be
    printed out as well.
    
    For example,
      $ ./bpftool net
      xdp [
      ifindex 2 devname eth0 prog_id 198
      ]
      tc_filters [
      ifindex 2 kind qdisc_htb name prefix_matcher.o:[cls_prefix_matcher_htb]
                prog_id 111727 tag d08fe3b4319bc2fd act []
      ifindex 2 kind qdisc_clsact_ingress name fbflow_icmp
                prog_id 130246 tag 3f265c7f26db62c9 act []
      ifindex 2 kind qdisc_clsact_egress name prefix_matcher.o:[cls_prefix_matcher_clsact]
                prog_id 111726 tag 99a197826974c876
      ifindex 2 kind qdisc_clsact_egress name cls_fg_dscp
                prog_id 108619 tag dc4630674fd72dcc act []
      ifindex 2 kind qdisc_clsact_egress name fbflow_egress
                prog_id 130245 tag 72d2d830d6888d2c
      ]
      $ ./bpftool -jp net
      [{
            "xdp": [{
                    "ifindex": 2,
                    "devname": "eth0",
                    "prog_id": 198
                }
            ],
            "tc_filters": [{
                    "ifindex": 2,
                    "kind": "qdisc_htb",
                    "name": "prefix_matcher.o:[cls_prefix_matcher_htb]",
                    "prog_id": 111727,
                    "tag": "d08fe3b4319bc2fd",
                    "act": []
                },{
                    "ifindex": 2,
                    "kind": "qdisc_clsact_ingress",
                    "name": "fbflow_icmp",
                    "prog_id": 130246,
                    "tag": "3f265c7f26db62c9",
                    "act": []
                },{
                    "ifindex": 2,
                    "kind": "qdisc_clsact_egress",
                    "name": "prefix_matcher.o:[cls_prefix_matcher_clsact]",
                    "prog_id": 111726,
                    "tag": "99a197826974c876"
                },{
                    "ifindex": 2,
                    "kind": "qdisc_clsact_egress",
                    "name": "cls_fg_dscp",
                    "prog_id": 108619,
                    "tag": "dc4630674fd72dcc",
                    "act": []
                },{
                    "ifindex": 2,
                    "kind": "qdisc_clsact_egress",
                    "name": "fbflow_egress",
                    "prog_id": 130245,
                    "tag": "72d2d830d6888d2c"
                }
            ]
        }
      ]
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
new file mode 100644
index 000000000000..e12494fd1d2e
--- /dev/null
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright (C) 2018 Facebook
+
+#include <stdlib.h>
+#include <string.h>
+#include <libbpf.h>
+#include <linux/rtnetlink.h>
+#include <linux/tc_act/tc_bpf.h>
+
+#include <nlattr.h>
+#include "main.h"
+#include "netlink_dumper.h"
+
+static void xdp_dump_prog_id(struct nlattr **tb, int attr,
+			     const char *type)
+{
+	if (!tb[attr])
+		return;
+
+	NET_DUMP_UINT(type, nla_getattr_u32(tb[attr]))
+}
+
+static int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,
+			   const char *name)
+{
+	struct nlattr *tb[IFLA_XDP_MAX + 1];
+	unsigned char mode;
+
+	if (nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)
+		return -1;
+
+	if (!tb[IFLA_XDP_ATTACHED])
+		return 0;
+
+	mode = nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);
+	if (mode == XDP_ATTACHED_NONE)
+		return 0;
+
+	NET_START_OBJECT;
+	NET_DUMP_UINT("ifindex", ifindex);
+
+	if (name)
+		NET_DUMP_STR("devname", name);
+
+	if (tb[IFLA_XDP_PROG_ID])
+		NET_DUMP_UINT("prog_id", nla_getattr_u32(tb[IFLA_XDP_PROG_ID]));
+
+	if (mode == XDP_ATTACHED_MULTI) {
+		xdp_dump_prog_id(tb, IFLA_XDP_SKB_PROG_ID, "generic_prog_id");
+		xdp_dump_prog_id(tb, IFLA_XDP_DRV_PROG_ID, "drv_prog_id");
+		xdp_dump_prog_id(tb, IFLA_XDP_HW_PROG_ID, "offload_prog_id");
+	}
+
+	NET_END_OBJECT_FINAL;
+	return 0;
+}
+
+int do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb)
+{
+	if (!tb[IFLA_XDP])
+		return 0;
+
+	return do_xdp_dump_one(tb[IFLA_XDP], ifinfo->ifi_index,
+			       nla_getattr_str(tb[IFLA_IFNAME]));
+}
+
+static char *hexstring_n2a(const unsigned char *str, int len,
+			   char *buf, int blen)
+{
+	char *ptr = buf;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (blen < 3)
+			break;
+		sprintf(ptr, "%02x", str[i]);
+		ptr += 2;
+		blen -= 2;
+	}
+	return buf;
+}
+
+static int do_bpf_dump_one_act(struct nlattr *attr)
+{
+	struct nlattr *tb[TCA_ACT_BPF_MAX + 1];
+	char buf[256];
+
+	if (nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
+		return -LIBBPF_ERRNO__NLPARSE;
+
+	if (!tb[TCA_ACT_BPF_PARMS])
+		return -LIBBPF_ERRNO__NLPARSE;
+
+	NET_START_OBJECT_NESTED2;
+	if (tb[TCA_ACT_BPF_NAME])
+		NET_DUMP_STR("name", nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
+	if (tb[TCA_ACT_BPF_ID])
+		NET_DUMP_UINT("bpf_id", nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
+	if (tb[TCA_ACT_BPF_TAG])
+		NET_DUMP_STR("tag", hexstring_n2a(nla_data(tb[TCA_ACT_BPF_TAG]),
+						  nla_len(tb[TCA_ACT_BPF_TAG]),
+						  buf, sizeof(buf)));
+	NET_END_OBJECT_NESTED;
+	return 0;
+}
+
+static int do_dump_one_act(struct nlattr *attr)
+{
+	struct nlattr *tb[TCA_ACT_MAX + 1];
+
+	if (!attr)
+		return 0;
+
+	if (nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)
+		return -LIBBPF_ERRNO__NLPARSE;
+
+	if (tb[TCA_ACT_KIND] && strcmp(nla_data(tb[TCA_ACT_KIND]), "bpf") == 0)
+		return do_bpf_dump_one_act(tb[TCA_ACT_OPTIONS]);
+
+	return 0;
+}
+
+static int do_bpf_act_dump(struct nlattr *attr)
+{
+	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
+	int act, ret;
+
+	if (nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
+		return -LIBBPF_ERRNO__NLPARSE;
+
+	NET_START_ARRAY("act", "");
+	for (act = 0; act <= TCA_ACT_MAX_PRIO; act++) {
+		ret = do_dump_one_act(tb[act]);
+		if (ret)
+			break;
+	}
+	NET_END_ARRAY(" ");
+
+	return ret;
+}
+
+static int do_bpf_filter_dump(struct nlattr *attr)
+{
+	struct nlattr *tb[TCA_BPF_MAX + 1];
+	char buf[256];
+	int ret;
+
+	if (nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
+		return -LIBBPF_ERRNO__NLPARSE;
+
+	if (tb[TCA_BPF_NAME])
+		NET_DUMP_STR("name", nla_getattr_str(tb[TCA_BPF_NAME]));
+	if (tb[TCA_BPF_ID])
+		NET_DUMP_UINT("prog_id", nla_getattr_u32(tb[TCA_BPF_ID]));
+	if (tb[TCA_BPF_TAG])
+		NET_DUMP_STR("tag", hexstring_n2a(nla_data(tb[TCA_BPF_TAG]),
+						  nla_len(tb[TCA_BPF_TAG]),
+						  buf, sizeof(buf)));
+	if (tb[TCA_BPF_ACT]) {
+		ret = do_bpf_act_dump(tb[TCA_BPF_ACT]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind)
+{
+	int ret = 0;
+
+	if (tb[TCA_OPTIONS] && strcmp(nla_data(tb[TCA_KIND]), "bpf") == 0) {
+		NET_START_OBJECT;
+		NET_DUMP_UINT("ifindex", info->tcm_ifindex);
+		NET_DUMP_STR("kind", kind);
+		ret = do_bpf_filter_dump(tb[TCA_OPTIONS]);
+		NET_END_OBJECT_FINAL;
+	}
+
+	return ret;
+}
