commit 90040351a832acf862c8f1855c29411303d23755
Author: Quentin Monnet <quentin@isovalent.com>
Date:   Sat May 23 02:07:51 2020 +0100

    tools, bpftool: Clean subcommand help messages
    
    This is a clean-up for the formatting of the do_help functions for
    bpftool's subcommands. The following fixes are included:
    
    - Do not use argv[-2] for "iter" help message, as the help is shown by
      default if no "iter" action is selected, resulting in messages looking
      like "./bpftool bpftool pin...".
    
    - Do not print unused HELP_SPEC_PROGRAM in help message for "bpftool
      link".
    
    - Andrii used argument indexing to avoid having multiple occurrences of
      bin_name and argv[-2] in the fprintf() for the help message, for
      "bpftool gen" and "bpftool link". Let's reuse this for all other help
      functions. We can remove up to thirty arguments for the "bpftool map"
      help message.
    
    - Harmonise all functions, e.g. use ending quotes-comma on a separate
      line.
    
    Signed-off-by: Quentin Monnet <quentin@isovalent.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20200523010751.23465-1-quentin@isovalent.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/iter.c b/tools/bpf/bpftool/iter.c
index eb5987a0c3b6..33240fcc6319 100644
--- a/tools/bpf/bpftool/iter.c
+++ b/tools/bpf/bpftool/iter.c
@@ -68,10 +68,10 @@ static int do_pin(int argc, char **argv)
 static int do_help(int argc, char **argv)
 {
 	fprintf(stderr,
-		"Usage: %s %s pin OBJ PATH\n"
-		"       %s %s help\n"
-		"\n",
-		bin_name, argv[-2], bin_name, argv[-2]);
+		"Usage: %1$s %2$s pin OBJ PATH\n"
+		"       %1$s %2$s help\n"
+		"",
+		bin_name, "iter");
 
 	return 0;
 }

commit 9406b485dea5e25bed7c81cd822747d494cc8bde
Author: Yonghong Song <yhs@fb.com>
Date:   Sat May 9 10:59:20 2020 -0700

    tools/bpftool: Add bpf_iter support for bptool
    
    Currently, only one command is supported
      bpftool iter pin <bpf_prog.o> <path>
    
    It will pin the trace/iter bpf program in
    the object file <bpf_prog.o> to the <path>
    where <path> should be on a bpffs mount.
    
    For example,
      $ bpftool iter pin ./bpf_iter_ipv6_route.o \
        /sys/fs/bpf/my_route
    User can then do a `cat` to print out the results:
      $ cat /sys/fs/bpf/my_route
        fe800000000000000000000000000000 40 00000000000000000000000000000000 ...
        00000000000000000000000000000000 00 00000000000000000000000000000000 ...
        00000000000000000000000000000001 80 00000000000000000000000000000000 ...
        fe800000000000008c0162fffebdfd57 80 00000000000000000000000000000000 ...
        ff000000000000000000000000000000 08 00000000000000000000000000000000 ...
        00000000000000000000000000000000 00 00000000000000000000000000000000 ...
    
    The implementation for ipv6_route iterator is in one of subsequent
    patches.
    
    This patch also added BPF_LINK_TYPE_ITER to link query.
    
    In the future, we may add additional parameters to pin command
    by parameterizing the bpf iterator. For example, a map_id or pid
    may be added to let bpf program only traverses a single map or task,
    similar to kernel seq_file single_open().
    
    We may also add introspection command for targets/iterators by
    leveraging the bpf_iter itself.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200509175920.2477247-1-yhs@fb.com

diff --git a/tools/bpf/bpftool/iter.c b/tools/bpf/bpftool/iter.c
new file mode 100644
index 000000000000..eb5987a0c3b6
--- /dev/null
+++ b/tools/bpf/bpftool/iter.c
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+// Copyright (C) 2020 Facebook
+
+#define _GNU_SOURCE
+#include <linux/err.h>
+#include <bpf/libbpf.h>
+
+#include "main.h"
+
+static int do_pin(int argc, char **argv)
+{
+	const char *objfile, *path;
+	struct bpf_program *prog;
+	struct bpf_object *obj;
+	struct bpf_link *link;
+	int err;
+
+	if (!REQ_ARGS(2))
+		usage();
+
+	objfile = GET_ARG();
+	path = GET_ARG();
+
+	obj = bpf_object__open(objfile);
+	if (IS_ERR(obj)) {
+		p_err("can't open objfile %s", objfile);
+		return -1;
+	}
+
+	err = bpf_object__load(obj);
+	if (err) {
+		p_err("can't load objfile %s", objfile);
+		goto close_obj;
+	}
+
+	prog = bpf_program__next(NULL, obj);
+	if (!prog) {
+		p_err("can't find bpf program in objfile %s", objfile);
+		goto close_obj;
+	}
+
+	link = bpf_program__attach_iter(prog, NULL);
+	if (IS_ERR(link)) {
+		err = PTR_ERR(link);
+		p_err("attach_iter failed for program %s",
+		      bpf_program__name(prog));
+		goto close_obj;
+	}
+
+	err = mount_bpffs_for_pin(path);
+	if (err)
+		goto close_link;
+
+	err = bpf_link__pin(link, path);
+	if (err) {
+		p_err("pin_iter failed for program %s to path %s",
+		      bpf_program__name(prog), path);
+		goto close_link;
+	}
+
+close_link:
+	bpf_link__destroy(link);
+close_obj:
+	bpf_object__close(obj);
+	return err;
+}
+
+static int do_help(int argc, char **argv)
+{
+	fprintf(stderr,
+		"Usage: %s %s pin OBJ PATH\n"
+		"       %s %s help\n"
+		"\n",
+		bin_name, argv[-2], bin_name, argv[-2]);
+
+	return 0;
+}
+
+static const struct cmd cmds[] = {
+	{ "help",	do_help },
+	{ "pin",	do_pin },
+	{ 0 }
+};
+
+int do_iter(int argc, char **argv)
+{
+	return cmd_select(cmds, argc, argv, do_help);
+}
