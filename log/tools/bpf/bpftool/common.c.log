commit c5481f9a954f27b8730c1dfeebbc9b3b5b2b2481
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Apr 28 17:16:12 2020 -0700

    bpftool: Add bpf_link show and pin support
    
    Add `bpftool link show` and `bpftool link pin` commands.
    
    Example plain output for `link show` (with showing pinned paths):
    
    [vmuser@archvm bpf]$ sudo ~/local/linux/tools/bpf/bpftool/bpftool -f link
    1: tracing  prog 12
            prog_type tracing  attach_type fentry
            pinned /sys/fs/bpf/my_test_link
            pinned /sys/fs/bpf/my_test_link2
    2: tracing  prog 13
            prog_type tracing  attach_type fentry
    3: tracing  prog 14
            prog_type tracing  attach_type fentry
    4: tracing  prog 15
            prog_type tracing  attach_type fentry
    5: tracing  prog 16
            prog_type tracing  attach_type fentry
    6: tracing  prog 17
            prog_type tracing  attach_type fentry
    7: raw_tracepoint  prog 21
            tp 'sys_enter'
    8: cgroup  prog 25
            cgroup_id 584  attach_type egress
    9: cgroup  prog 25
            cgroup_id 599  attach_type egress
    10: cgroup  prog 25
            cgroup_id 614  attach_type egress
    11: cgroup  prog 25
            cgroup_id 629  attach_type egress
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Reviewed-by: Quentin Monnet <quentin@isovalent.com>
    Link: https://lore.kernel.org/bpf/20200429001614.1544-9-andriin@fb.com

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index f2223dbdfb0a..c47bdc65de8e 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -262,6 +262,8 @@ int get_fd_type(int fd)
 		return BPF_OBJ_MAP;
 	else if (strstr(buf, "bpf-prog"))
 		return BPF_OBJ_PROG;
+	else if (strstr(buf, "bpf-link"))
+		return BPF_OBJ_LINK;
 
 	return BPF_OBJ_UNKNOWN;
 }

commit 6ae32b29c09ba9b99c4c7317eed029587bd2706d
Author: Quentin Monnet <quentin@isovalent.com>
Date:   Wed Mar 11 02:12:05 2020 +0000

    tools: bpftool: Restore message on failure to guess program type
    
    In commit 4a3d6c6a6e4d ("libbpf: Reduce log level for custom section
    names"), log level for messages for libbpf_attach_type_by_name() and
    libbpf_prog_type_by_name() was downgraded from "info" to "debug". The
    latter function, in particular, is used by bpftool when attempting to
    load programs, and this change caused bpftool to exit with no hint or
    error message when it fails to detect the type of the program to load
    (unless "-d" option was provided).
    
    To help users understand why bpftool fails to load the program, let's do
    a second run of the function with log level in "debug" mode in case of
    failure.
    
    Before:
    
        # bpftool prog load sample_ret0.o /sys/fs/bpf/sample_ret0
        # echo $?
        255
    
    Or really verbose with -d flag:
    
        # bpftool -d prog load sample_ret0.o /sys/fs/bpf/sample_ret0
        libbpf: loading sample_ret0.o
        libbpf: section(1) .strtab, size 134, link 0, flags 0, type=3
        libbpf: skip section(1) .strtab
        libbpf: section(2) .text, size 16, link 0, flags 6, type=1
        libbpf: found program .text
        libbpf: section(3) .debug_abbrev, size 55, link 0, flags 0, type=1
        libbpf: skip section(3) .debug_abbrev
        libbpf: section(4) .debug_info, size 75, link 0, flags 0, type=1
        libbpf: skip section(4) .debug_info
        libbpf: section(5) .rel.debug_info, size 32, link 14, flags 0, type=9
        libbpf: skip relo .rel.debug_info(5) for section(4)
        libbpf: section(6) .debug_str, size 150, link 0, flags 30, type=1
        libbpf: skip section(6) .debug_str
        libbpf: section(7) .BTF, size 155, link 0, flags 0, type=1
        libbpf: section(8) .BTF.ext, size 80, link 0, flags 0, type=1
        libbpf: section(9) .rel.BTF.ext, size 32, link 14, flags 0, type=9
        libbpf: skip relo .rel.BTF.ext(9) for section(8)
        libbpf: section(10) .debug_frame, size 40, link 0, flags 0, type=1
        libbpf: skip section(10) .debug_frame
        libbpf: section(11) .rel.debug_frame, size 16, link 14, flags 0, type=9
        libbpf: skip relo .rel.debug_frame(11) for section(10)
        libbpf: section(12) .debug_line, size 74, link 0, flags 0, type=1
        libbpf: skip section(12) .debug_line
        libbpf: section(13) .rel.debug_line, size 16, link 14, flags 0, type=9
        libbpf: skip relo .rel.debug_line(13) for section(12)
        libbpf: section(14) .symtab, size 96, link 1, flags 0, type=2
        libbpf: looking for externs among 4 symbols...
        libbpf: collected 0 externs total
        libbpf: failed to guess program type from ELF section '.text'
        libbpf: supported section(type) names are: socket sk_reuseport kprobe/ [...]
    
    After:
    
        # bpftool prog load sample_ret0.o /sys/fs/bpf/sample_ret0
        libbpf: failed to guess program type from ELF section '.text'
        libbpf: supported section(type) names are: socket sk_reuseport kprobe/ [...]
    
    Signed-off-by: Quentin Monnet <quentin@isovalent.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Link: https://lore.kernel.org/bpf/20200311021205.9755-1-quentin@isovalent.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index ad634516ba80..f2223dbdfb0a 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -572,3 +572,10 @@ int parse_u32_arg(int *argc, char ***argv, __u32 *val, const char *what)
 
 	return 0;
 }
+
+int __printf(2, 0)
+print_all_levels(__maybe_unused enum libbpf_print_level level,
+		 const char *format, va_list args)
+{
+	return vfprintf(stderr, format, args);
+}

commit 75a1e792c335b5c6d7fdb1014da47aeb64c5944f
Author: Quentin Monnet <quentin@isovalent.com>
Date:   Thu Mar 12 18:46:07 2020 +0000

    tools: bpftool: Allow all prog/map handles for pinning objects
    
    Documentation and interactive help for bpftool have always explained
    that the regular handles for programs (id|name|tag|pinned) and maps
    (id|name|pinned) can be passed to the utility when attempting to pin
    objects (bpftool prog pin PROG / bpftool map pin MAP).
    
    THIS IS A LIE!! The tool actually accepts only ids, as the parsing is
    done in do_pin_any() in common.c instead of reusing the parsing
    functions that have long been generic for program and map handles.
    
    Instead of fixing the doc, fix the code. It is trivial to reuse the
    generic parsing, and to simplify do_pin_any() in the process.
    
    Do not accept to pin multiple objects at the same time with
    prog_parse_fds() or map_parse_fds() (this would require a more complex
    syntax for passing multiple sysfs paths and validating that they
    correspond to the number of e.g. programs we find for a given name or
    tag).
    
    Signed-off-by: Quentin Monnet <quentin@isovalent.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20200312184608.12050-2-quentin@isovalent.com

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index b75b8ec5469c..ad634516ba80 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -211,39 +211,14 @@ int do_pin_fd(int fd, const char *name)
 	return err;
 }
 
-int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
+int do_pin_any(int argc, char **argv, int (*get_fd)(int *, char ***))
 {
-	unsigned int id;
-	char *endptr;
 	int err;
 	int fd;
 
-	if (argc < 3) {
-		p_err("too few arguments, id ID and FILE path is required");
-		return -1;
-	} else if (argc > 3) {
-		p_err("too many arguments");
-		return -1;
-	}
-
-	if (!is_prefix(*argv, "id")) {
-		p_err("expected 'id' got %s", *argv);
-		return -1;
-	}
-	NEXT_ARG();
-
-	id = strtoul(*argv, &endptr, 0);
-	if (*endptr) {
-		p_err("can't parse %s as ID", *argv);
-		return -1;
-	}
-	NEXT_ARG();
-
-	fd = get_fd_by_id(id);
-	if (fd < 0) {
-		p_err("can't open object by id (%u): %s", id, strerror(errno));
-		return -1;
-	}
+	fd = get_fd(&argc, &argv);
+	if (fd < 0)
+		return fd;
 
 	err = do_pin_fd(fd, *argv);
 

commit 229c3b47b794e7257744224b21a95d3d9938d00a
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Mon Jan 20 14:06:46 2020 +0100

    bpftool: Use consistent include paths for libbpf
    
    Fix bpftool to include libbpf header files with the bpf/ prefix, to be
    consistent with external users of the library. Also ensure that all
    includes of exported libbpf header files (those that are exported on 'make
    install' of the library) use bracketed includes instead of quoted.
    
    To make sure no new files are introduced that doesn't include the bpf/
    prefix in its include, remove tools/lib/bpf from the include path entirely,
    and use tools/lib instead.
    
    Fixes: 6910d7d3867a ("selftests/bpf: Ensure bpf_helper_defs.h are taken from selftests dir")
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157952560684.1683545.4765181397974997027.stgit@toke.dk

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 88264abaa738..b75b8ec5469c 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -20,8 +20,8 @@
 #include <sys/stat.h>
 #include <sys/vfs.h>
 
-#include <bpf.h>
-#include <libbpf.h> /* libbpf_num_possible_cpus */
+#include <bpf/bpf.h>
+#include <bpf/libbpf.h> /* libbpf_num_possible_cpus */
 
 #include "main.h"
 

commit 1e46c09ec10049a9e366153b32e41cc557383fdb
Merge: f9bcfe214b00 593f191a8005
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Sep 6 16:49:17 2019 +0200

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next
    
    Daniel Borkmann says:
    
    ====================
    The following pull-request contains BPF updates for your *net-next* tree.
    
    The main changes are:
    
    1) Add the ability to use unaligned chunks in the AF_XDP umem. By
       relaxing where the chunks can be placed, it allows to use an
       arbitrary buffer size and place whenever there is a free
       address in the umem. Helps more seamless DPDK AF_XDP driver
       integration. Support for i40e, ixgbe and mlx5e, from Kevin and
       Maxim.
    
    2) Addition of a wakeup flag for AF_XDP tx and fill rings so the
       application can wake up the kernel for rx/tx processing which
       avoids busy-spinning of the latter, useful when app and driver
       is located on the same core. Support for i40e, ixgbe and mlx5e,
       from Magnus and Maxim.
    
    3) bpftool fixes for printf()-like functions so compiler can actually
       enforce checks, bpftool build system improvements for custom output
       directories, and addition of 'bpftool map freeze' command, from Quentin.
    
    4) Support attaching/detaching XDP programs from 'bpftool net' command,
       from Daniel.
    
    5) Automatic xskmap cleanup when AF_XDP socket is released, and several
       barrier/{read,write}_once fixes in AF_XDP code, from Björn.
    
    6) Relicense of bpf_helpers.h/bpf_endian.h for future libbpf
       inclusion as well as libbpf versioning improvements, from Andrii.
    
    7) Several new BPF kselftests for verifier precision tracking, from Alexei.
    
    8) Several BPF kselftest fixes wrt endianess to run on s390x, from Ilya.
    
    9) And more BPF kselftest improvements all over the place, from Stanislav.
    
    10) Add simple BPF map op cache for nfp driver to batch dumps, from Jakub.
    
    11) AF_XDP socket umem mapping improvements for 32bit archs, from Ivan.
    
    12) Add BPF-to-BPF call and BTF line info support for s390x JIT, from Yauheni.
    
    13) Small optimization in arm64 JIT to spare 1 insns for BPF_MOD, from Jerin.
    
    14) Fix an error check in bpf_tcp_gen_syncookie() helper, from Petar.
    
    15) Various minor fixes and cleanups, from Nathan, Masahiro, Masanari,
        Peter, Wei, Yue.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8918dc42dc85ba6981028f65a989c478eb80bc02
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Aug 15 15:32:20 2019 +0100

    tools: bpftool: move "__printf()" attributes to header file
    
    Some functions in bpftool have a "__printf()" format attributes to tell
    the compiler they should expect printf()-like arguments. But because
    these attributes are not used for the function prototypes in the header
    files, the compiler does not run the checks everywhere the functions are
    used, and some mistakes on format string and corresponding arguments
    slipped in over time.
    
    Let's move the __printf() attributes to the correct places.
    
    Note: We add guards around the definition of GCC_VERSION in
    tools/include/linux/compiler-gcc.h to prevent a conflict in jit_disasm.c
    on GCC_VERSION from headers pulled via libbfd.
    
    Fixes: c101189bc968 ("tools: bpftool: fix -Wmissing declaration warnings")
    Reported-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 5215e0870bcb..a7036c70db48 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -29,7 +29,7 @@
 #define BPF_FS_MAGIC		0xcafe4a11
 #endif
 
-void __printf(1, 2) p_err(const char *fmt, ...)
+void p_err(const char *fmt, ...)
 {
 	va_list ap;
 
@@ -47,7 +47,7 @@ void __printf(1, 2) p_err(const char *fmt, ...)
 	va_end(ap);
 }
 
-void __printf(1, 2) p_info(const char *fmt, ...)
+void p_info(const char *fmt, ...)
 {
 	va_list ap;
 

commit 3c7be384fe6da0d7b1d6fc0ad6b4a33edb73aad5
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Aug 6 17:19:23 2019 -0700

    tools: bpftool: add error message on pin failure
    
    No error message is currently printed if the pin syscall
    itself fails. It got lost in the loadall refactoring.
    
    Fixes: 77380998d91d ("bpftool: add loadall command")
    Reported-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index c52a6ffb8949..6a71324be628 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -204,7 +204,11 @@ int do_pin_fd(int fd, const char *name)
 	if (err)
 		return err;
 
-	return bpf_obj_pin(fd, name);
+	err = bpf_obj_pin(fd, name);
+	if (err)
+		p_err("can't pin the object (%s): %s", name, strerror(errno));
+
+	return err;
 }
 
 int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))

commit b3e78adcbf991a4e8b2ebb23c9889e968ec76c5f
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Aug 6 17:19:22 2019 -0700

    tools: bpftool: fix error message (prog -> object)
    
    Change an error message to work for any object being
    pinned not just programs.
    
    Fixes: 71bb428fe2c1 ("tools: bpf: add bpftool")
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 5215e0870bcb..c52a6ffb8949 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -237,7 +237,7 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 
 	fd = get_fd_by_id(id);
 	if (fd < 0) {
-		p_err("can't get prog by id (%u): %s", id, strerror(errno));
+		p_err("can't open object by id (%u): %s", id, strerror(errno));
 		return -1;
 	}
 

commit 4c587c196d8237169405cbb2195669dbc00fd72b
Author: Hechao Li <hechaol@fb.com>
Date:   Mon Jun 10 17:56:52 2019 -0700

    bpf: use libbpf_num_possible_cpus internally
    
    Use the newly added bpf_num_possible_cpus() in bpftool and selftests
    and remove duplicate implementations.
    
    Signed-off-by: Hechao Li <hechaol@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index f7261fad45c1..5215e0870bcb 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -21,6 +21,7 @@
 #include <sys/vfs.h>
 
 #include <bpf.h>
+#include <libbpf.h> /* libbpf_num_possible_cpus */
 
 #include "main.h"
 
@@ -439,57 +440,13 @@ unsigned int get_page_size(void)
 
 unsigned int get_possible_cpus(void)
 {
-	static unsigned int result;
-	char buf[128];
-	long int n;
-	char *ptr;
-	int fd;
-
-	if (result)
-		return result;
-
-	fd = open("/sys/devices/system/cpu/possible", O_RDONLY);
-	if (fd < 0) {
-		p_err("can't open sysfs possible cpus");
-		exit(-1);
-	}
-
-	n = read(fd, buf, sizeof(buf));
-	if (n < 2) {
-		p_err("can't read sysfs possible cpus");
-		exit(-1);
-	}
-	close(fd);
+	int cpus = libbpf_num_possible_cpus();
 
-	if (n == sizeof(buf)) {
-		p_err("read sysfs possible cpus overflow");
+	if (cpus < 0) {
+		p_err("Can't get # of possible cpus: %s", strerror(-cpus));
 		exit(-1);
 	}
-
-	ptr = buf;
-	n = 0;
-	while (*ptr && *ptr != '\n') {
-		unsigned int a, b;
-
-		if (sscanf(ptr, "%u-%u", &a, &b) == 2) {
-			n += b - a + 1;
-
-			ptr = strchr(ptr, '-') + 1;
-		} else if (sscanf(ptr, "%u", &a) == 1) {
-			n++;
-		} else {
-			assert(0);
-		}
-
-		while (isdigit(*ptr))
-			ptr++;
-		if (*ptr == ',')
-			ptr++;
-	}
-
-	result = n;
-
-	return result;
+	return cpus;
 }
 
 static char *

commit 8c79b35693380d856dcbbc21629682a90f26ca62
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Mon Jan 28 10:01:21 2019 -0800

    tools: bpftool: fix crash with un-owned prog arrays
    
    Prog arrays don't have 'owner_prog_type' and 'owner_jited'
    fields in their fdinfo when they are created.  Those fields
    are set and reported when first program is checked for
    compatibility by bpf_prog_array_compatible().
    
    This means that bpftool cannot expect the fields to always
    be there.  Currently trying to show maps on a system with
    an un-owned prog array leads to a crash:
    
    $ bpftool map show
    389: prog_array  name tail_call_map  flags 0x0
    Error: key 'owner_prog_type' not found in fdinfo
    Error: key 'owner_jited' not found in fdinfo
           key 4B  value 4B  max_entries 4  memlock 4096B
           Segmentation fault (core dumped)
    
    We pass a NULL pointer to atoi().
    
    Remove the assumption that fdinfo keys are always present.
    Add missing validations and remove the p_err() calls which
    may lead to broken JSON output as caller will not propagate
    the failure.
    
    Fixes: 99a44bef5870 ("tools: bpftool: add owner_prog_type and owner_jited to bpftool output")
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 897483457bf0..f7261fad45c1 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -297,10 +297,8 @@ char *get_fdinfo(int fd, const char *key)
 	snprintf(path, sizeof(path), "/proc/self/fdinfo/%d", fd);
 
 	fdi = fopen(path, "r");
-	if (!fdi) {
-		p_err("can't open fdinfo: %s", strerror(errno));
+	if (!fdi)
 		return NULL;
-	}
 
 	while ((n = getline(&line, &line_n, fdi)) > 0) {
 		char *value;
@@ -313,7 +311,6 @@ char *get_fdinfo(int fd, const char *key)
 
 		value = strchr(line, '\t');
 		if (!value || !value[1]) {
-			p_err("malformed fdinfo!?");
 			free(line);
 			return NULL;
 		}
@@ -326,7 +323,6 @@ char *get_fdinfo(int fd, const char *key)
 		return line;
 	}
 
-	p_err("key '%s' not found in fdinfo", key);
 	free(line);
 	fclose(fdi);
 	return NULL;

commit 33221307c3f993500a9cfc6900811058c6bfc152
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Tue Dec 18 10:13:19 2018 +0000

    tools: bpftool: add an option to prevent auto-mount of bpffs, tracefs
    
    In order to make life easier for users, bpftool automatically attempts
    to mount the BPF virtual file system, if it is not mounted already,
    before trying to pin objects in it. Similarly, it attempts to mount
    tracefs if necessary before trying to dump the trace pipe to the
    console.
    
    While mounting file systems on-the-fly can improve user experience, some
    administrators might prefer to avoid that. Let's add an option to block
    these mount attempts. Note that it does not prevent automatic mounting
    of tracefs by debugfs for the "bpftool prog tracelog" command.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 1bad6602a282..897483457bf0 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -177,6 +177,12 @@ int mount_bpffs_for_pin(const char *name)
 		/* nothing to do if already mounted */
 		goto out_free;
 
+	if (block_mount) {
+		p_err("no BPF file system found, not mounting it due to --nomount option");
+		err = -1;
+		goto out_free;
+	}
+
 	err = mnt_fs(dir, "bpf", err_str, ERR_MAX_LEN);
 	if (err) {
 		err_str[ERR_MAX_LEN - 1] = '\0';

commit be3245e22d227ad68ab97785d506561374daa028
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Tue Dec 18 10:13:18 2018 +0000

    tools: bpftool: attempt to mount tracefs if required for tracelog cmd
    
    As a follow-up to commit 30da46b5dc3a ("tools: bpftool: add a command to
    dump the trace pipe"), attempt to mount the tracefs virtual file system
    if it is not detected on the system before trying to dump content of the
    tracing pipe on an invocation of "bpftool prog tracelog".
    
    Usually, tracefs in automatically mounted by debugfs when the user tries
    to access it (e.g. "ls /sys/kernel/debug/tracing" mounts the tracefs).
    So if we failed to find it, it is probably that debugfs is not here
    either. Therefore, we just attempt a single mount, at a location that
    does not involve debugfs: /sys/kernel/tracing.
    
    Suggested-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 24582e8a96fb..1bad6602a282 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -76,7 +76,8 @@ void set_max_rlimit(void)
 	setrlimit(RLIMIT_MEMLOCK, &rinf);
 }
 
-static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
+static int
+mnt_fs(const char *target, const char *type, char *buff, size_t bufflen)
 {
 	bool bind_done = false;
 
@@ -98,15 +99,29 @@ static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
 		bind_done = true;
 	}
 
-	if (mount("bpf", target, "bpf", 0, "mode=0700")) {
-		snprintf(buff, bufflen, "mount -t bpf bpf %s failed: %s",
-			 target, strerror(errno));
+	if (mount(type, target, type, 0, "mode=0700")) {
+		snprintf(buff, bufflen, "mount -t %s %s %s failed: %s",
+			 type, type, target, strerror(errno));
 		return -1;
 	}
 
 	return 0;
 }
 
+int mount_tracefs(const char *target)
+{
+	char err_str[ERR_MAX_LEN];
+	int err;
+
+	err = mnt_fs(target, "tracefs", err_str, ERR_MAX_LEN);
+	if (err) {
+		err_str[ERR_MAX_LEN - 1] = '\0';
+		p_err("can't mount tracefs: %s", err_str);
+	}
+
+	return err;
+}
+
 int open_obj_pinned(char *path, bool quiet)
 {
 	int fd;
@@ -162,7 +177,7 @@ int mount_bpffs_for_pin(const char *name)
 		/* nothing to do if already mounted */
 		goto out_free;
 
-	err = mnt_bpffs(dir, err_str, ERR_MAX_LEN);
+	err = mnt_fs(dir, "bpf", err_str, ERR_MAX_LEN);
 	if (err) {
 		err_str[ERR_MAX_LEN - 1] = '\0';
 		p_err("can't mount BPF file system to pin the object (%s): %s",

commit c101189bc9680675a2686bafe908015a07a0da51
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Fri Dec 14 13:56:01 2018 +0000

    tools: bpftool: fix -Wmissing declaration warnings
    
    Help compiler check arguments for several utility functions used to
    print items to the console by adding the "printf" attribute when
    declaring those functions.
    
    Also, declare as "static" two functions that are only used in prog.c.
    
    All of them discovered by compiling bpftool with
    -Wmissing-format-attribute -Wmissing-declarations.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 99e4027dde75..24582e8a96fb 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -28,7 +28,7 @@
 #define BPF_FS_MAGIC		0xcafe4a11
 #endif
 
-void p_err(const char *fmt, ...)
+void __printf(1, 2) p_err(const char *fmt, ...)
 {
 	va_list ap;
 
@@ -46,7 +46,7 @@ void p_err(const char *fmt, ...)
 	va_end(ap);
 }
 
-void p_info(const char *fmt, ...)
+void __printf(1, 2) p_info(const char *fmt, ...)
 {
 	va_list ap;
 

commit 02ff58dcf70ad7d11b01523dc404166ed11021da
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Dec 12 19:59:25 2018 -0800

    tools: bpftool: replace Netronome boilerplate with SPDX license headers
    
    Replace the repeated license text with SDPX identifiers.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Roman Gushchin <guro@fb.com>
    Acked-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Acked-by: Stanislav Fomichev <sdf@google.com>
    Acked-by: Sean Young <sean@mess.org>
    Acked-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: David Calavera <david.calavera@gmail.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Joe Stringer <joe@wand.net.nz>
    Acked-by: David Ahern <dsahern@gmail.com>
    Acked-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Acked-by: Petar Penkov <ppenkov@stanford.edu>
    Acked-by: Sandipan Das <sandipan@linux.ibm.com>
    Acked-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Taeung Song <treeze.taeung@gmail.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    CC: okash.khawaja@gmail.com
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 172d3761d9ab..99e4027dde75 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -1,35 +1,5 @@
-/*
- * Copyright (C) 2017-2018 Netronome Systems, Inc.
- *
- * This software is dual licensed under the GNU General License Version 2,
- * June 1991 as shown in the file COPYING in the top-level directory of this
- * source tree or the BSD 2-Clause License provided below.  You have the
- * option to license this software under the complete terms of either license.
- *
- * The BSD 2-Clause License:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      1. Redistributions of source code must retain the above
- *         copyright notice, this list of conditions and the following
- *         disclaimer.
- *
- *      2. Redistributions in binary form must reproduce the above
- *         copyright notice, this list of conditions and the following
- *         disclaimer in the documentation and/or other materials
- *         provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/* Copyright (C) 2017-2018 Netronome Systems, Inc. */
 
 #include <ctype.h>
 #include <errno.h>

commit 73f0b9db53836a68c40691fad1467ed44a3123e8
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Fri Nov 30 16:25:47 2018 +0000

    tools: bpftool: mark offloaded programs more explicitly in plain output
    
    In bpftool (plain) output for "bpftool prog show" or "bpftool map show",
    an offloaded BPF object is simply denoted with "dev ifname", which is
    not really explicit. Change it with something that clearly shows the
    program is offloaded.
    
    While at it also add an additional space, as done between other
    information fields.
    
    Example output, before:
    
        # bpftool prog show
        1337: xdp  tag a04f5eef06a7f555 dev foo
                loaded_at 2018-10-19T16:40:36+0100  uid 0
                xlated 16B  not jited  memlock 4096B
    
    After:
    
        # bpftool prog show
        1337: xdp  tag a04f5eef06a7f555  offloaded_to foo
                loaded_at 2018-10-19T16:40:36+0100  uid 0
                xlated 16B  not jited  memlock 4096B
    
    Suggested-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 4349b6683ca8..172d3761d9ab 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -604,7 +604,7 @@ void print_dev_plain(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)
 	if (!ifindex)
 		return;
 
-	printf(" dev ");
+	printf("  offloaded_to ");
 	if (ifindex_to_name_ns(ifindex, ns_dev, ns_inode, name))
 		printf("%s", name);
 	else

commit 327e5dab6dd8559ba28739ec8873350d7b5bb080
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Fri Nov 30 16:25:44 2018 +0000

    tools: bpftool: use "/proc/self/" i.o. crafting links with getpid()
    
    The getpid() function is called in a couple of places in bpftool to
    craft links of the shape "/proc/<pid>/...". Instead, it is possible to
    use the "/proc/self/" shortcut, which makes things a bit easier, in
    particular in jit_disasm.c.
    
    Do the replacement, and remove the includes of <sys/types.h> from the
    relevant files, now we do not use getpid() anymore.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 4e217d57118e..4349b6683ca8 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -48,7 +48,6 @@
 #include <sys/mount.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
-#include <sys/types.h>
 #include <sys/vfs.h>
 
 #include <bpf.h>
@@ -276,7 +275,7 @@ int get_fd_type(int fd)
 	char buf[512];
 	ssize_t n;
 
-	snprintf(path, sizeof(path), "/proc/%d/fd/%d", getpid(), fd);
+	snprintf(path, sizeof(path), "/proc/self/fd/%d", fd);
 
 	n = readlink(path, buf, sizeof(buf));
 	if (n < 0) {
@@ -304,7 +303,7 @@ char *get_fdinfo(int fd, const char *key)
 	ssize_t n;
 	FILE *fdi;
 
-	snprintf(path, sizeof(path), "/proc/%d/fdinfo/%d", getpid(), fd);
+	snprintf(path, sizeof(path), "/proc/self/fdinfo/%d", fd);
 
 	fdi = fopen(path, "r");
 	if (!fdi) {

commit e561bb29b650d2817d10a4858f1817836ed08399
Merge: 62e3a9317882 60b548237fed
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Nov 28 22:10:54 2018 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Trivial conflict in net/core/filter.c, a locally computed
    'sdif' is now an argument to the function.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 77380998d91dee8aafdbe42634776ba1ef692f1e
Author: Stanislav Fomichev <sdf@google.com>
Date:   Fri Nov 9 08:21:44 2018 -0800

    bpftool: add loadall command
    
    This patch adds new *loadall* command which slightly differs from the
    existing *load*. *load* command loads all programs from the obj file,
    but pins only the first programs. *loadall* pins all programs from the
    obj file under specified directory.
    
    The intended usecase is flow_dissector, where we want to load a bunch
    of progs, pin them all and after that construct a jump table.
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 1149565be4b1..cb06a5b6e016 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -177,34 +177,23 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 	return fd;
 }
 
-int do_pin_fd(int fd, const char *name)
+int mount_bpffs_for_pin(const char *name)
 {
 	char err_str[ERR_MAX_LEN];
 	char *file;
 	char *dir;
 	int err = 0;
 
-	err = bpf_obj_pin(fd, name);
-	if (!err)
-		goto out;
-
 	file = malloc(strlen(name) + 1);
 	strcpy(file, name);
 	dir = dirname(file);
 
-	if (errno != EPERM || is_bpffs(dir)) {
-		p_err("can't pin the object (%s): %s", name, strerror(errno));
+	if (is_bpffs(dir))
+		/* nothing to do if already mounted */
 		goto out_free;
-	}
 
-	/* Attempt to mount bpffs, then retry pinning. */
 	err = mnt_bpffs(dir, err_str, ERR_MAX_LEN);
-	if (!err) {
-		err = bpf_obj_pin(fd, name);
-		if (err)
-			p_err("can't pin the object (%s): %s", name,
-			      strerror(errno));
-	} else {
+	if (err) {
 		err_str[ERR_MAX_LEN - 1] = '\0';
 		p_err("can't mount BPF file system to pin the object (%s): %s",
 		      name, err_str);
@@ -212,10 +201,20 @@ int do_pin_fd(int fd, const char *name)
 
 out_free:
 	free(file);
-out:
 	return err;
 }
 
+int do_pin_fd(int fd, const char *name)
+{
+	int err;
+
+	err = mount_bpffs_for_pin(name);
+	if (err)
+		return err;
+
+	return bpf_obj_pin(fd, name);
+}
+
 int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 {
 	unsigned int id;

commit f120919f9905a2cad9dea792a28a11fb623f72c1
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Nov 8 11:52:27 2018 +0000

    tools: bpftool: pass an argument to silence open_obj_pinned()
    
    Function open_obj_pinned() prints error messages when it fails to open a
    link in the BPF virtual file system. However, in some occasions it is
    not desirable to print an error, for example when we parse all links
    under the bpffs root, and the error is due to some paths actually being
    symbolic links.
    
    Example output:
    
        # ls -l /sys/fs/bpf/
        lrwxrwxrwx 1 root root 0 Oct 18 19:00 ip -> /sys/fs/bpf/tc/
        drwx------ 3 root root 0 Oct 18 19:00 tc
        lrwxrwxrwx 1 root root 0 Oct 18 19:00 xdp -> /sys/fs/bpf/tc/
    
        # bpftool --bpffs prog show
        Error: bpf obj get (/sys/fs/bpf): Permission denied
        Error: bpf obj get (/sys/fs/bpf): Permission denied
    
        # strace -e bpf bpftool --bpffs prog show
        bpf(BPF_OBJ_GET, {pathname="/sys/fs/bpf/ip", bpf_fd=0}, 72) = -1 EACCES (Permission denied)
        Error: bpf obj get (/sys/fs/bpf): Permission denied
        bpf(BPF_OBJ_GET, {pathname="/sys/fs/bpf/xdp", bpf_fd=0}, 72) = -1 EACCES (Permission denied)
        Error: bpf obj get (/sys/fs/bpf): Permission denied
        ...
    
    To fix it, pass a bool as a second argument to the function, and prevent
    it from printing an error when the argument is set to true.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index e070b00ac309..70fd48d79f61 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -130,16 +130,17 @@ static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
 	return 0;
 }
 
-int open_obj_pinned(char *path)
+int open_obj_pinned(char *path, bool quiet)
 {
 	int fd;
 
 	fd = bpf_obj_get(path);
 	if (fd < 0) {
-		p_err("bpf obj get (%s): %s", path,
-		      errno == EACCES && !is_bpffs(dirname(path)) ?
-		    "directory not in bpf file system (bpffs)" :
-		    strerror(errno));
+		if (!quiet)
+			p_err("bpf obj get (%s): %s", path,
+			      errno == EACCES && !is_bpffs(dirname(path)) ?
+			    "directory not in bpf file system (bpffs)" :
+			    strerror(errno));
 		return -1;
 	}
 
@@ -151,7 +152,7 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 	enum bpf_obj_type type;
 	int fd;
 
-	fd = open_obj_pinned(path);
+	fd = open_obj_pinned(path, false);
 	if (fd < 0)
 		return -1;
 
@@ -384,7 +385,7 @@ int build_pinned_obj_table(struct pinned_obj_table *tab,
 		while ((ftse = fts_read(fts))) {
 			if (!(ftse->fts_info & FTS_F))
 				continue;
-			fd = open_obj_pinned(ftse->fts_path);
+			fd = open_obj_pinned(ftse->fts_path, true);
 			if (fd < 0)
 				continue;
 

commit 53909030aa29bffe1f8490df62176c2375135652
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Nov 8 11:52:25 2018 +0000

    tools: bpftool: prevent infinite loop in get_fdinfo()
    
    Function getline() returns -1 on failure to read a line, thus creating
    an infinite loop in get_fdinfo() if the key is not found. Fix it by
    calling the function only as long as we get a strictly positive return
    value.
    
    Found by copying the code for a key which is not always present...
    
    Fixes: 71bb428fe2c1 ("tools: bpf: add bpftool")
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 25af85304ebe..e070b00ac309 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -304,7 +304,7 @@ char *get_fdinfo(int fd, const char *key)
 		return NULL;
 	}
 
-	while ((n = getline(&line, &line_n, fdi))) {
+	while ((n = getline(&line, &line_n, fdi)) > 0) {
 		char *value;
 		int len;
 

commit 8302b9bd31d29f29dd24dd6b1e1e5682c302c11c
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Wed Nov 7 12:29:30 2018 +0000

    tools: bpftool: adjust rlimit RLIMIT_MEMLOCK when loading programs, maps
    
    The limit for memory locked in the kernel by a process is usually set to
    64 kbytes by default. This can be an issue when creating large BPF maps
    and/or loading many programs. A workaround is to raise this limit for
    the current process before trying to create a new BPF map. Changing the
    hard limit requires the CAP_SYS_RESOURCE and can usually only be done by
    root user (for non-root users, a call to setrlimit fails (and sets
    errno) and the program simply goes on with its rlimit unchanged).
    
    There is no API to get the current amount of memory locked for a user,
    therefore we cannot raise the limit only when required. One solution,
    used by bcc, is to try to create the map, and on getting a EPERM error,
    raising the limit to infinity before giving another try. Another
    approach, used in iproute2, is to raise the limit in all cases, before
    trying to create the map.
    
    Here we do the same as in iproute2: the rlimit is raised to infinity
    before trying to load programs or to create maps with bpftool.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 25af85304ebe..1149565be4b1 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -46,6 +46,7 @@
 #include <linux/magic.h>
 #include <net/if.h>
 #include <sys/mount.h>
+#include <sys/resource.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/vfs.h>
@@ -99,6 +100,13 @@ static bool is_bpffs(char *path)
 	return (unsigned long)st_fs.f_type == BPF_FS_MAGIC;
 }
 
+void set_max_rlimit(void)
+{
+	struct rlimit rinf = { RLIM_INFINITY, RLIM_INFINITY };
+
+	setrlimit(RLIMIT_MEMLOCK, &rinf);
+}
+
 static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
 {
 	bool bind_done = false;

commit 3ddeac6705aba31b7528c7d7a528eabb74475622
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu Oct 18 11:34:55 2018 -0700

    tools: bpftool: use 4 context mode for the NFP disasm
    
    The nfp driver is currently always JITing the BPF for 4 context/thread
    mode of the NFP flow processors.  Tell this to the disassembler,
    otherwise some registers may be incorrectly decoded.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Jiong Wang <jiong.wang@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 3318da8060bd..25af85304ebe 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -554,7 +554,9 @@ static int read_sysfs_netdev_hex_int(char *devname, const char *entry_name)
 	return read_sysfs_hex_int(full_path);
 }
 
-const char *ifindex_to_bfd_name_ns(__u32 ifindex, __u64 ns_dev, __u64 ns_ino)
+const char *
+ifindex_to_bfd_params(__u32 ifindex, __u64 ns_dev, __u64 ns_ino,
+		      const char **opt)
 {
 	char devname[IF_NAMESIZE];
 	int vendor_id;
@@ -579,6 +581,7 @@ const char *ifindex_to_bfd_name_ns(__u32 ifindex, __u64 ns_dev, __u64 ns_ino)
 		    device_id != 0x6000 &&
 		    device_id != 0x6003)
 			p_info("Unknown NFP device ID, assuming it is NFP-6xxx arch");
+		*opt = "ctx4";
 		return "NFP-6xxx";
 	default:
 		p_err("Can't get bfd arch name for device vendor id 0x%04x",

commit 0b592b5a01bef5416472ec610d3191e019c144a5
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Mon Oct 15 16:30:36 2018 -0700

    tools: bpftool: add map create command
    
    Add a way of creating maps from user space.  The command takes
    as parameters most of the attributes of the map creation system
    call command.  After map is created its pinned to bpffs.  This makes
    it possible to easily and dynamically (without rebuilding programs)
    test various corner cases related to map creation.
    
    Map type names are taken from bpftool's array used for printing.
    In general these days we try to make use of libbpf type names, but
    there are no map type names in libbpf as of today.
    
    As with most features I add the motivation is testing (offloads) :)
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index b3a0709ea7ed..3318da8060bd 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -618,3 +618,24 @@ void print_dev_json(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)
 		jsonw_string_field(json_wtr, "ifname", name);
 	jsonw_end_object(json_wtr);
 }
+
+int parse_u32_arg(int *argc, char ***argv, __u32 *val, const char *what)
+{
+	char *endptr;
+
+	NEXT_ARGP();
+
+	if (*val) {
+		p_err("%s already specified", what);
+		return -1;
+	}
+
+	*val = strtoul(**argv, &endptr, 0);
+	if (*endptr) {
+		p_err("can't parse %s as %s", **argv, what);
+		return -1;
+	}
+	NEXT_ARGP();
+
+	return 0;
+}

commit 19725496da5602b401eae389736ab00d1817e264
Merge: aea5f654e6b7 9981b4fb8684
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 24 19:21:58 2018 -0700

    Merge ra.kernel.org:/pub/scm/linux/kernel/git/davem/net

commit 759b94a00a207ef605f3fd6f6e99570799688145
Author: Taeung Song <treeze.taeung@gmail.com>
Date:   Thu Jul 19 21:10:05 2018 +0900

    tools/bpftool: Fix segfault case regarding 'pin' arguments
    
    Arguments of 'pin' subcommand should be checked
    at the very beginning of do_pin_any().
    Otherwise segfault errors can occur when using
    'map pin' or 'prog pin' commands, so fix it.
    
      # bpftool prog pin id
      Segmentation fault
    
    Fixes: 71bb428fe2c1 ("tools: bpf: add bpftool")
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reported-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Taeung Song <treeze.taeung@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 32f9e397a6c0..3f140eff039f 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -217,6 +217,14 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 	int err;
 	int fd;
 
+	if (argc < 3) {
+		p_err("too few arguments, id ID and FILE path is required");
+		return -1;
+	} else if (argc > 3) {
+		p_err("too many arguments");
+		return -1;
+	}
+
 	if (!is_prefix(*argv, "id")) {
 		p_err("expected 'id' got %s", *argv);
 		return -1;
@@ -230,9 +238,6 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 	}
 	NEXT_ARG();
 
-	if (argc != 1)
-		usage();
-
 	fd = get_fd_by_id(id);
 	if (fd < 0) {
 		p_err("can't get prog by id (%u): %s", id, strerror(errno));

commit 71e07ddcdc03000e37acfc6e757f70c81a963d58
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu Jun 28 14:41:40 2018 -0700

    tools: bpftool: drop unnecessary Author comments
    
    Drop my author comments, those are from the early days of
    bpftool and make little sense in tree, where we have quite
    a few people contributing and git to attribute the work.
    
    While at it bump some copyrights.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 32f9e397a6c0..b432daea4520 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -31,8 +31,6 @@
  * SOFTWARE.
  */
 
-/* Author: Jakub Kicinski <kubakici@wp.pl> */
-
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>

commit f412eed9dfdeeb6becd7de2ffe8b5d0a8b3f81ca
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu May 3 18:37:16 2018 -0700

    tools: bpftool: add simple perf event output reader
    
    Users of BPF sooner or later discover perf_event_output() helpers
    and BPF_MAP_TYPE_PERF_EVENT_ARRAY.  Dumping this array type is
    not possible, however, we can add simple reading of perf events.
    Create a new event_pipe subcommand for maps, this sub command
    will only work with BPF_MAP_TYPE_PERF_EVENT_ARRAY maps.
    
    Parts of the code from samples/bpf/trace_output_user.c.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 9c620770c6ed..32f9e397a6c0 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -331,6 +331,16 @@ char *get_fdinfo(int fd, const char *key)
 	return NULL;
 }
 
+void print_data_json(uint8_t *data, size_t len)
+{
+	unsigned int i;
+
+	jsonw_start_array(json_wtr);
+	for (i = 0; i < len; i++)
+		jsonw_printf(json_wtr, "%d", data[i]);
+	jsonw_end_array(json_wtr);
+}
+
 void print_hex_data_json(uint8_t *data, size_t len)
 {
 	unsigned int i;
@@ -421,6 +431,15 @@ void delete_pinned_obj_table(struct pinned_obj_table *tab)
 	}
 }
 
+unsigned int get_page_size(void)
+{
+	static int result;
+
+	if (!result)
+		result = getpagesize();
+	return result;
+}
+
 unsigned int get_possible_cpus(void)
 {
 	static unsigned int result;

commit e64d52569f6e847495091db40ab58d2d379748ef
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu May 3 18:37:15 2018 -0700

    tools: bpftool: move get_possible_cpus() to common code
    
    Move the get_possible_cpus() function to shared code.  No functional
    changes.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jiong Wang <jiong.wang@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 465995281dcd..9c620770c6ed 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 Netronome Systems, Inc.
+ * Copyright (C) 2017-2018 Netronome Systems, Inc.
  *
  * This software is dual licensed under the GNU General License Version 2,
  * June 1991 as shown in the file COPYING in the top-level directory of this
@@ -33,6 +33,7 @@
 
 /* Author: Jakub Kicinski <kubakici@wp.pl> */
 
+#include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <fts.h>
@@ -420,6 +421,61 @@ void delete_pinned_obj_table(struct pinned_obj_table *tab)
 	}
 }
 
+unsigned int get_possible_cpus(void)
+{
+	static unsigned int result;
+	char buf[128];
+	long int n;
+	char *ptr;
+	int fd;
+
+	if (result)
+		return result;
+
+	fd = open("/sys/devices/system/cpu/possible", O_RDONLY);
+	if (fd < 0) {
+		p_err("can't open sysfs possible cpus");
+		exit(-1);
+	}
+
+	n = read(fd, buf, sizeof(buf));
+	if (n < 2) {
+		p_err("can't read sysfs possible cpus");
+		exit(-1);
+	}
+	close(fd);
+
+	if (n == sizeof(buf)) {
+		p_err("read sysfs possible cpus overflow");
+		exit(-1);
+	}
+
+	ptr = buf;
+	n = 0;
+	while (*ptr && *ptr != '\n') {
+		unsigned int a, b;
+
+		if (sscanf(ptr, "%u-%u", &a, &b) == 2) {
+			n += b - a + 1;
+
+			ptr = strchr(ptr, '-') + 1;
+		} else if (sscanf(ptr, "%u", &a) == 1) {
+			n++;
+		} else {
+			assert(0);
+		}
+
+		while (isdigit(*ptr))
+			ptr++;
+		if (*ptr == ',')
+			ptr++;
+	}
+
+	result = n;
+
+	return result;
+}
+
 static char *
 ifindex_to_name_ns(__u32 ifindex, __u32 ns_dev, __u32 ns_ino, char *buf)
 {

commit 20d5de51e7052ae3fb645d8c5c584ee7383b2a93
Author: Jiri Benc <jbenc@redhat.com>
Date:   Tue Mar 6 14:50:10 2018 +0100

    tools: bpftool: fix compilation with older headers
    
    Compilation of bpftool on a distro that lacks eBPF support in the installed
    kernel headers fails with:
    
    common.c: In function ‘is_bpffs’:
    common.c:96:40: error: ‘BPF_FS_MAGIC’ undeclared (first use in this function)
      return (unsigned long)st_fs.f_type == BPF_FS_MAGIC;
                                            ^
    Fix this the same way it is already in tools/lib/bpf/libbpf.c and
    tools/lib/api/fs/fs.c.
    
    Signed-off-by: Jiri Benc <jbenc@redhat.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 0b482c0070e0..465995281dcd 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -55,6 +55,10 @@
 
 #include "main.h"
 
+#ifndef BPF_FS_MAGIC
+#define BPF_FS_MAGIC		0xcafe4a11
+#endif
+
 void p_err(const char *fmt, ...)
 {
 	va_list ap;

commit e65935969d0fac9df28d9c49bdbab5d8d8286a20
Author: Jiong Wang <jiong.wang@netronome.com>
Date:   Tue Jan 16 16:05:21 2018 -0800

    tools: bpftool: improve architecture detection by using ifindex
    
    The current architecture detection method in bpftool is designed for host
    case.
    
    For offload case, we can't use the architecture of "bpftool" itself.
    Instead, we could call the existing "ifindex_to_name_ns" to get DEVNAME,
    then read pci id from /sys/class/dev/DEVNAME/device/vendor, finally we map
    vendor id to bfd arch name which will finally be used to select bfd backend
    for the disassembler.
    
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 6601c95a9258..0b482c0070e0 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -34,6 +34,7 @@
 /* Author: Jakub Kicinski <kubakici@wp.pl> */
 
 #include <errno.h>
+#include <fcntl.h>
 #include <fts.h>
 #include <libgen.h>
 #include <mntent.h>
@@ -433,6 +434,77 @@ ifindex_to_name_ns(__u32 ifindex, __u32 ns_dev, __u32 ns_ino, char *buf)
 	return if_indextoname(ifindex, buf);
 }
 
+static int read_sysfs_hex_int(char *path)
+{
+	char vendor_id_buf[8];
+	int len;
+	int fd;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		p_err("Can't open %s: %s", path, strerror(errno));
+		return -1;
+	}
+
+	len = read(fd, vendor_id_buf, sizeof(vendor_id_buf));
+	close(fd);
+	if (len < 0) {
+		p_err("Can't read %s: %s", path, strerror(errno));
+		return -1;
+	}
+	if (len >= (int)sizeof(vendor_id_buf)) {
+		p_err("Value in %s too long", path);
+		return -1;
+	}
+
+	vendor_id_buf[len] = 0;
+
+	return strtol(vendor_id_buf, NULL, 0);
+}
+
+static int read_sysfs_netdev_hex_int(char *devname, const char *entry_name)
+{
+	char full_path[64];
+
+	snprintf(full_path, sizeof(full_path), "/sys/class/net/%s/device/%s",
+		 devname, entry_name);
+
+	return read_sysfs_hex_int(full_path);
+}
+
+const char *ifindex_to_bfd_name_ns(__u32 ifindex, __u64 ns_dev, __u64 ns_ino)
+{
+	char devname[IF_NAMESIZE];
+	int vendor_id;
+	int device_id;
+
+	if (!ifindex_to_name_ns(ifindex, ns_dev, ns_ino, devname)) {
+		p_err("Can't get net device name for ifindex %d: %s", ifindex,
+		      strerror(errno));
+		return NULL;
+	}
+
+	vendor_id = read_sysfs_netdev_hex_int(devname, "vendor");
+	if (vendor_id < 0) {
+		p_err("Can't get device vendor id for %s", devname);
+		return NULL;
+	}
+
+	switch (vendor_id) {
+	case 0x19ee:
+		device_id = read_sysfs_netdev_hex_int(devname, "device");
+		if (device_id != 0x4000 &&
+		    device_id != 0x6000 &&
+		    device_id != 0x6003)
+			p_info("Unknown NFP device ID, assuming it is NFP-6xxx arch");
+		return "NFP-6xxx";
+	default:
+		p_err("Can't get bfd arch name for device vendor id 0x%04x",
+		      vendor_id);
+		return NULL;
+	}
+}
+
 void print_dev_plain(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)
 {
 	char name[IF_NAMESIZE];

commit 522622104ebabbc3372d2fad706b4d30cee13319
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Dec 27 18:39:10 2017 -0800

    tools: bpftool: report device information for offloaded programs
    
    Print the just-exposed device information about device to which
    program is bound.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index b62c94e3997a..6601c95a9258 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -44,7 +44,9 @@
 #include <unistd.h>
 #include <linux/limits.h>
 #include <linux/magic.h>
+#include <net/if.h>
 #include <sys/mount.h>
+#include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/vfs.h>
 
@@ -412,3 +414,53 @@ void delete_pinned_obj_table(struct pinned_obj_table *tab)
 		free(obj);
 	}
 }
+
+static char *
+ifindex_to_name_ns(__u32 ifindex, __u32 ns_dev, __u32 ns_ino, char *buf)
+{
+	struct stat st;
+	int err;
+
+	err = stat("/proc/self/ns/net", &st);
+	if (err) {
+		p_err("Can't stat /proc/self: %s", strerror(errno));
+		return NULL;
+	}
+
+	if (st.st_dev != ns_dev || st.st_ino != ns_ino)
+		return NULL;
+
+	return if_indextoname(ifindex, buf);
+}
+
+void print_dev_plain(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)
+{
+	char name[IF_NAMESIZE];
+
+	if (!ifindex)
+		return;
+
+	printf(" dev ");
+	if (ifindex_to_name_ns(ifindex, ns_dev, ns_inode, name))
+		printf("%s", name);
+	else
+		printf("ifindex %u ns_dev %llu ns_ino %llu",
+		       ifindex, ns_dev, ns_inode);
+}
+
+void print_dev_json(__u32 ifindex, __u64 ns_dev, __u64 ns_inode)
+{
+	char name[IF_NAMESIZE];
+
+	if (!ifindex)
+		return;
+
+	jsonw_name(json_wtr, "dev");
+	jsonw_start_object(json_wtr);
+	jsonw_uint_field(json_wtr, "ifindex", ifindex);
+	jsonw_uint_field(json_wtr, "ns_dev", ns_dev);
+	jsonw_uint_field(json_wtr, "ns_inode", ns_inode);
+	if (ifindex_to_name_ns(ifindex, ns_dev, ns_inode, name))
+		jsonw_string_field(json_wtr, "ifname", name);
+	jsonw_end_object(json_wtr);
+}

commit 49a086c201a9356287471aa5846a427bdcecc4f7
Author: Roman Gushchin <guro@fb.com>
Date:   Wed Dec 13 15:18:53 2017 +0000

    bpftool: implement prog load command
    
    Add the prog load command to load a bpf program from a specified
    binary file and pin it to bpffs.
    
    Usage description and examples are given in the corresponding man
    page.
    
    Syntax:
    $ bpftool prog load OBJ FILE
    
    FILE is a non-existing file on bpffs.
    
    Signed-off-by: Roman Gushchin <guro@fb.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Cc: Martin KaFai Lau <kafai@fb.com>
    Cc: Quentin Monnet <quentin.monnet@netronome.com>
    Cc: David Ahern <dsahern@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 2bd3b280e6dd..b62c94e3997a 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -163,13 +163,49 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 	return fd;
 }
 
-int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
+int do_pin_fd(int fd, const char *name)
 {
 	char err_str[ERR_MAX_LEN];
-	unsigned int id;
-	char *endptr;
 	char *file;
 	char *dir;
+	int err = 0;
+
+	err = bpf_obj_pin(fd, name);
+	if (!err)
+		goto out;
+
+	file = malloc(strlen(name) + 1);
+	strcpy(file, name);
+	dir = dirname(file);
+
+	if (errno != EPERM || is_bpffs(dir)) {
+		p_err("can't pin the object (%s): %s", name, strerror(errno));
+		goto out_free;
+	}
+
+	/* Attempt to mount bpffs, then retry pinning. */
+	err = mnt_bpffs(dir, err_str, ERR_MAX_LEN);
+	if (!err) {
+		err = bpf_obj_pin(fd, name);
+		if (err)
+			p_err("can't pin the object (%s): %s", name,
+			      strerror(errno));
+	} else {
+		err_str[ERR_MAX_LEN - 1] = '\0';
+		p_err("can't mount BPF file system to pin the object (%s): %s",
+		      name, err_str);
+	}
+
+out_free:
+	free(file);
+out:
+	return err;
+}
+
+int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
+{
+	unsigned int id;
+	char *endptr;
 	int err;
 	int fd;
 
@@ -195,35 +231,8 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 		return -1;
 	}
 
-	err = bpf_obj_pin(fd, *argv);
-	if (!err)
-		goto out_close;
-
-	file = malloc(strlen(*argv) + 1);
-	strcpy(file, *argv);
-	dir = dirname(file);
-
-	if (errno != EPERM || is_bpffs(dir)) {
-		p_err("can't pin the object (%s): %s", *argv, strerror(errno));
-		goto out_free;
-	}
+	err = do_pin_fd(fd, *argv);
 
-	/* Attempt to mount bpffs, then retry pinning. */
-	err = mnt_bpffs(dir, err_str, ERR_MAX_LEN);
-	if (!err) {
-		err = bpf_obj_pin(fd, *argv);
-		if (err)
-			p_err("can't pin the object (%s): %s", *argv,
-			      strerror(errno));
-	} else {
-		err_str[ERR_MAX_LEN - 1] = '\0';
-		p_err("can't mount BPF file system to pin the object (%s): %s",
-		      *argv, err_str);
-	}
-
-out_free:
-	free(file);
-out_close:
 	close(fd);
 	return err;
 }

commit 4990f1f4610b483a60397ed2768d268df228a551
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Wed Nov 8 13:55:48 2017 +0900

    tools: bpftool: show filenames of pinned objects
    
    Added support to show filenames of pinned objects.
    
    For example:
    
    root@test# ./bpftool prog
    3: tracepoint  name tracepoint__irq  tag f677a7dd722299a3
        loaded_at Oct 26/11:39  uid 0
        xlated 160B  not jited  memlock 4096B  map_ids 4
        pinned /sys/fs/bpf/softirq_prog
    
    4: tracepoint  name tracepoint__irq  tag ea5dc530d00b92b6
        loaded_at Oct 26/11:39  uid 0
        xlated 392B  not jited  memlock 4096B  map_ids 4,6
    
    root@test# ./bpftool --json --pretty prog
    [{
            "id": 3,
            "type": "tracepoint",
            "name": "tracepoint__irq",
            "tag": "f677a7dd722299a3",
            "loaded_at": "Oct 26/11:39",
            "uid": 0,
            "bytes_xlated": 160,
            "jited": false,
            "bytes_memlock": 4096,
            "map_ids": [4
            ],
            "pinned": ["/sys/fs/bpf/softirq_prog"
            ]
        },{
            "id": 4,
            "type": "tracepoint",
            "name": "tracepoint__irq",
            "tag": "ea5dc530d00b92b6",
            "loaded_at": "Oct 26/11:39",
            "uid": 0,
            "bytes_xlated": 392,
            "jited": false,
            "bytes_memlock": 4096,
            "map_ids": [4,6
            ],
            "pinned": []
        }
    ]
    
    root@test# ./bpftool map
    4: hash  name start  flags 0x0
        key 4B  value 16B  max_entries 10240  memlock 1003520B
        pinned /sys/fs/bpf/softirq_map1
    5: hash  name iptr  flags 0x0
        key 4B  value 8B  max_entries 10240  memlock 921600B
    
    root@test# ./bpftool --json --pretty map
    [{
            "id": 4,
            "type": "hash",
            "name": "start",
            "flags": 0,
            "bytes_key": 4,
            "bytes_value": 16,
            "max_entries": 10240,
            "bytes_memlock": 1003520,
            "pinned": ["/sys/fs/bpf/softirq_map1"
            ]
        },{
            "id": 5,
            "type": "hash",
            "name": "iptr",
            "flags": 0,
            "bytes_key": 4,
            "bytes_value": 8,
            "max_entries": 10240,
            "bytes_memlock": 921600,
            "pinned": []
        }
    ]
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index 6b3d25d6a782..2bd3b280e6dd 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -34,7 +34,9 @@
 /* Author: Jakub Kicinski <kubakici@wp.pl> */
 
 #include <errno.h>
+#include <fts.h>
 #include <libgen.h>
+#include <mntent.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -321,3 +323,83 @@ void print_hex_data_json(uint8_t *data, size_t len)
 		jsonw_printf(json_wtr, "\"0x%02hhx\"", data[i]);
 	jsonw_end_array(json_wtr);
 }
+
+int build_pinned_obj_table(struct pinned_obj_table *tab,
+			   enum bpf_obj_type type)
+{
+	struct bpf_prog_info pinned_info = {};
+	struct pinned_obj *obj_node = NULL;
+	__u32 len = sizeof(pinned_info);
+	struct mntent *mntent = NULL;
+	enum bpf_obj_type objtype;
+	FILE *mntfile = NULL;
+	FTSENT *ftse = NULL;
+	FTS *fts = NULL;
+	int fd, err;
+
+	mntfile = setmntent("/proc/mounts", "r");
+	if (!mntfile)
+		return -1;
+
+	while ((mntent = getmntent(mntfile))) {
+		char *path[] = { mntent->mnt_dir, NULL };
+
+		if (strncmp(mntent->mnt_type, "bpf", 3) != 0)
+			continue;
+
+		fts = fts_open(path, 0, NULL);
+		if (!fts)
+			continue;
+
+		while ((ftse = fts_read(fts))) {
+			if (!(ftse->fts_info & FTS_F))
+				continue;
+			fd = open_obj_pinned(ftse->fts_path);
+			if (fd < 0)
+				continue;
+
+			objtype = get_fd_type(fd);
+			if (objtype != type) {
+				close(fd);
+				continue;
+			}
+			memset(&pinned_info, 0, sizeof(pinned_info));
+			err = bpf_obj_get_info_by_fd(fd, &pinned_info, &len);
+			if (err) {
+				close(fd);
+				continue;
+			}
+
+			obj_node = malloc(sizeof(*obj_node));
+			if (!obj_node) {
+				close(fd);
+				fts_close(fts);
+				fclose(mntfile);
+				return -1;
+			}
+
+			memset(obj_node, 0, sizeof(*obj_node));
+			obj_node->id = pinned_info.id;
+			obj_node->path = strdup(ftse->fts_path);
+			hash_add(tab->table, &obj_node->hash, obj_node->id);
+
+			close(fd);
+		}
+		fts_close(fts);
+	}
+	fclose(mntfile);
+	return 0;
+}
+
+void delete_pinned_obj_table(struct pinned_obj_table *tab)
+{
+	struct pinned_obj *obj;
+	struct hlist_node *tmp;
+	unsigned int bkt;
+
+	hash_for_each_safe(tab->table, bkt, tmp, obj, hash) {
+		hash_del(&obj->hash);
+		free(obj->path);
+		free(obj);
+	}
+}

commit 1852719658c0f853b5481c9eaed862f1a9355edc
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Wed Nov 8 13:55:47 2017 +0900

    tools: bpftool: open pinned object without type check
    
    This was needed for opening any file in bpf-fs without knowing
    its object type
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index aa7017098b2a..6b3d25d6a782 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -122,9 +122,8 @@ static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
 	return 0;
 }
 
-int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
+int open_obj_pinned(char *path)
 {
-	enum bpf_obj_type type;
 	int fd;
 
 	fd = bpf_obj_get(path);
@@ -136,6 +135,18 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 		return -1;
 	}
 
+	return fd;
+}
+
+int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
+{
+	enum bpf_obj_type type;
+	int fd;
+
+	fd = open_obj_pinned(path);
+	if (fd < 0)
+		return -1;
+
 	type = get_fd_type(fd);
 	if (type < 0) {
 		close(fd);

commit 0b1c27db12fd338ed912fec18f5cc02d7bd4e54e
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Fri Nov 3 13:59:07 2017 -0700

    tools: bpftool: move p_err() and p_info() from main.h to common.c
    
    The two functions were declared as static inline in a header file. There
    is no particular reason why they should be inlined, they just happened to
    remain in the same header file when they were turned from macros to
    functions in a precious commit.
    
    Make them non-inlined functions and move them to common.c file instead.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index f0288269dae8..aa7017098b2a 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -50,6 +50,37 @@
 
 #include "main.h"
 
+void p_err(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	if (json_output) {
+		jsonw_start_object(json_wtr);
+		jsonw_name(json_wtr, "error");
+		jsonw_vprintf_enquote(json_wtr, fmt, ap);
+		jsonw_end_object(json_wtr);
+	} else {
+		fprintf(stderr, "Error: ");
+		vfprintf(stderr, fmt, ap);
+		fprintf(stderr, "\n");
+	}
+	va_end(ap);
+}
+
+void p_info(const char *fmt, ...)
+{
+	va_list ap;
+
+	if (json_output)
+		return;
+
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	fprintf(stderr, "\n");
+	va_end(ap);
+}
+
 static bool is_bpffs(char *path)
 {
 	struct statfs st_fs;

commit 3fc27b71b894f5e2ad611297d5817b6092c96626
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Tue Oct 24 20:11:28 2017 -0700

    tools: bpftool: try to mount bpffs if required for pinning objects
    
    One possible cause of failure for `bpftool {prog|map} pin * file FILE`
    is the FILE not being in an eBPF virtual file system (bpffs). In this
    case, make bpftool attempt to mount bpffs on the parent directory of the
    FILE. Then, if this operation is successful, try again to pin the
    object.
    
    The code for mnt_bpffs() is a copy of function bpf_mnt_fs() from
    iproute2 package (under lib/bpf.c, taken at commit 4b73d52f8a81), with
    modifications regarding handling of error messages.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index b2533f1cae3e..f0288269dae8 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -42,6 +42,7 @@
 #include <unistd.h>
 #include <linux/limits.h>
 #include <linux/magic.h>
+#include <sys/mount.h>
 #include <sys/types.h>
 #include <sys/vfs.h>
 
@@ -59,6 +60,37 @@ static bool is_bpffs(char *path)
 	return (unsigned long)st_fs.f_type == BPF_FS_MAGIC;
 }
 
+static int mnt_bpffs(const char *target, char *buff, size_t bufflen)
+{
+	bool bind_done = false;
+
+	while (mount("", target, "none", MS_PRIVATE | MS_REC, NULL)) {
+		if (errno != EINVAL || bind_done) {
+			snprintf(buff, bufflen,
+				 "mount --make-private %s failed: %s",
+				 target, strerror(errno));
+			return -1;
+		}
+
+		if (mount(target, target, "none", MS_BIND, NULL)) {
+			snprintf(buff, bufflen,
+				 "mount --bind %s %s failed: %s",
+				 target, target, strerror(errno));
+			return -1;
+		}
+
+		bind_done = true;
+	}
+
+	if (mount("bpf", target, "bpf", 0, "mode=0700")) {
+		snprintf(buff, bufflen, "mount -t bpf bpf %s failed: %s",
+			 target, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
 int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 {
 	enum bpf_obj_type type;
@@ -89,8 +121,11 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 
 int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 {
+	char err_str[ERR_MAX_LEN];
 	unsigned int id;
 	char *endptr;
+	char *file;
+	char *dir;
 	int err;
 	int fd;
 
@@ -117,16 +152,36 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 	}
 
 	err = bpf_obj_pin(fd, *argv);
-	close(fd);
-	if (err) {
-		p_err("can't pin the object (%s): %s", *argv,
-		      errno == EACCES && !is_bpffs(dirname(*argv)) ?
-		    "directory not in bpf file system (bpffs)" :
-		    strerror(errno));
-		return -1;
+	if (!err)
+		goto out_close;
+
+	file = malloc(strlen(*argv) + 1);
+	strcpy(file, *argv);
+	dir = dirname(file);
+
+	if (errno != EPERM || is_bpffs(dir)) {
+		p_err("can't pin the object (%s): %s", *argv, strerror(errno));
+		goto out_free;
 	}
 
-	return 0;
+	/* Attempt to mount bpffs, then retry pinning. */
+	err = mnt_bpffs(dir, err_str, ERR_MAX_LEN);
+	if (!err) {
+		err = bpf_obj_pin(fd, *argv);
+		if (err)
+			p_err("can't pin the object (%s): %s", *argv,
+			      strerror(errno));
+	} else {
+		err_str[ERR_MAX_LEN - 1] = '\0';
+		p_err("can't mount BPF file system to pin the object (%s): %s",
+		      *argv, err_str);
+	}
+
+out_free:
+	free(file);
+out_close:
+	close(fd);
+	return err;
 }
 
 const char *get_fd_type_name(enum bpf_obj_type type)

commit 9a5ab8bf1d6d16ef47fdf55dba1683ec00d751ad
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Mon Oct 23 09:24:13 2017 -0700

    tools: bpftool: turn err() and info() macros into functions
    
    Turn err() and info() macros into functions.
    
    In order to avoid naming conflicts with variables in the code, rename
    them as p_err() and p_info() respectively.
    
    The behavior of these functions is similar to the one of the macros for
    plain output. However, when JSON output is requested, these macros
    return a JSON-formatted "error" object instead of printing a message to
    stderr.
    
    To handle error messages correctly with JSON, a modification was brought
    to their behavior nonetheless: the functions now append a end-of-line
    character at the end of the message. This way, we can remove end-of-line
    characters at the end of the argument strings, and not have them in the
    JSON output.
    
    All error messages are formatted to hold in a single call to p_err(), in
    order to produce a single JSON field.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index e7a756b8ee21..b2533f1cae3e 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -66,8 +66,8 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 
 	fd = bpf_obj_get(path);
 	if (fd < 0) {
-		err("bpf obj get (%s): %s\n", path,
-		    errno == EACCES && !is_bpffs(dirname(path)) ?
+		p_err("bpf obj get (%s): %s", path,
+		      errno == EACCES && !is_bpffs(dirname(path)) ?
 		    "directory not in bpf file system (bpffs)" :
 		    strerror(errno));
 		return -1;
@@ -79,7 +79,7 @@ int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
 		return type;
 	}
 	if (type != exp_type) {
-		err("incorrect object type: %s\n", get_fd_type_name(type));
+		p_err("incorrect object type: %s", get_fd_type_name(type));
 		close(fd);
 		return -1;
 	}
@@ -95,14 +95,14 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 	int fd;
 
 	if (!is_prefix(*argv, "id")) {
-		err("expected 'id' got %s\n", *argv);
+		p_err("expected 'id' got %s", *argv);
 		return -1;
 	}
 	NEXT_ARG();
 
 	id = strtoul(*argv, &endptr, 0);
 	if (*endptr) {
-		err("can't parse %s as ID\n", *argv);
+		p_err("can't parse %s as ID", *argv);
 		return -1;
 	}
 	NEXT_ARG();
@@ -112,15 +112,15 @@ int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
 
 	fd = get_fd_by_id(id);
 	if (fd < 0) {
-		err("can't get prog by id (%u): %s\n", id, strerror(errno));
+		p_err("can't get prog by id (%u): %s", id, strerror(errno));
 		return -1;
 	}
 
 	err = bpf_obj_pin(fd, *argv);
 	close(fd);
 	if (err) {
-		err("can't pin the object (%s): %s\n", *argv,
-		    errno == EACCES && !is_bpffs(dirname(*argv)) ?
+		p_err("can't pin the object (%s): %s", *argv,
+		      errno == EACCES && !is_bpffs(dirname(*argv)) ?
 		    "directory not in bpf file system (bpffs)" :
 		    strerror(errno));
 		return -1;
@@ -153,11 +153,11 @@ int get_fd_type(int fd)
 
 	n = readlink(path, buf, sizeof(buf));
 	if (n < 0) {
-		err("can't read link type: %s\n", strerror(errno));
+		p_err("can't read link type: %s", strerror(errno));
 		return -1;
 	}
 	if (n == sizeof(path)) {
-		err("can't read link type: path too long!\n");
+		p_err("can't read link type: path too long!");
 		return -1;
 	}
 
@@ -181,7 +181,7 @@ char *get_fdinfo(int fd, const char *key)
 
 	fdi = fopen(path, "r");
 	if (!fdi) {
-		err("can't open fdinfo: %s\n", strerror(errno));
+		p_err("can't open fdinfo: %s", strerror(errno));
 		return NULL;
 	}
 
@@ -196,7 +196,7 @@ char *get_fdinfo(int fd, const char *key)
 
 		value = strchr(line, '\t');
 		if (!value || !value[1]) {
-			err("malformed fdinfo!?\n");
+			p_err("malformed fdinfo!?");
 			free(line);
 			return NULL;
 		}
@@ -209,7 +209,7 @@ char *get_fdinfo(int fd, const char *key)
 		return line;
 	}
 
-	err("key '%s' not found in fdinfo\n", key);
+	p_err("key '%s' not found in fdinfo", key);
 	free(line);
 	fclose(fdi);
 	return NULL;

commit f05e2c32f715985f54265b1e237b5cce1b576c71
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Mon Oct 23 09:24:10 2017 -0700

    tools: bpftool: add JSON output for `bpftool prog dump xlated *` command
    
    Add a new printing function to dump translated eBPF instructions as
    JSON. As for plain output, opcodes are printed only on request (when
    `opcodes` is provided on the command line).
    
    The disassembled output is generated by the same code that is used by
    the kernel verifier.
    
    Example output:
    
        $ bpftool --json --pretty prog dump xlated id 1
        [{
                "disasm": "(bf) r6 = r1"
            },{
                "disasm": "(61) r7 = *(u32 *)(r6 +16)"
            },{
                "disasm": "(95) exit"
            }
        ]
    
        $ bpftool --json --pretty prog dump xlated id 1 opcodes
        [{
                "disasm": "(bf) r6 = r1",
                "opcodes": {
                    "code": "0xbf",
                    "src_reg": "0x1",
                    "dst_reg": "0x6",
                    "off": ["0x00","0x00"
                    ],
                    "imm": ["0x00","0x00","0x00","0x00"
                    ]
                }
            },{
                "disasm": "(61) r7 = *(u32 *)(r6 +16)",
                "opcodes": {
                    "code": "0x61",
                    "src_reg": "0x6",
                    "dst_reg": "0x7",
                    "off": ["0x10","0x00"
                    ],
                    "imm": ["0x00","0x00","0x00","0x00"
                    ]
                }
            },{
                "disasm": "(95) exit",
                "opcodes": {
                    "code": "0x95",
                    "src_reg": "0x0",
                    "dst_reg": "0x0",
                    "off": ["0x00","0x00"
                    ],
                    "imm": ["0x00","0x00","0x00","0x00"
                    ]
                }
            }
        ]
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
index df8396a0c400..e7a756b8ee21 100644
--- a/tools/bpf/bpftool/common.c
+++ b/tools/bpf/bpftool/common.c
@@ -214,3 +214,13 @@ char *get_fdinfo(int fd, const char *key)
 	fclose(fdi);
 	return NULL;
 }
+
+void print_hex_data_json(uint8_t *data, size_t len)
+{
+	unsigned int i;
+
+	jsonw_start_array(json_wtr);
+	for (i = 0; i < len; i++)
+		jsonw_printf(json_wtr, "\"0x%02hhx\"", data[i]);
+	jsonw_end_array(json_wtr);
+}

commit 71bb428fe2c19512ac671d5ee16ef3e73e1b49a8
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Oct 4 20:10:04 2017 -0700

    tools: bpf: add bpftool
    
    Add a simple tool for querying and updating BPF objects on the system.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Simon Horman <simon.horman@netronome.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/bpf/bpftool/common.c b/tools/bpf/bpftool/common.c
new file mode 100644
index 000000000000..df8396a0c400
--- /dev/null
+++ b/tools/bpf/bpftool/common.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2017 Netronome Systems, Inc.
+ *
+ * This software is dual licensed under the GNU General License Version 2,
+ * June 1991 as shown in the file COPYING in the top-level directory of this
+ * source tree or the BSD 2-Clause License provided below.  You have the
+ * option to license this software under the complete terms of either license.
+ *
+ * The BSD 2-Clause License:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      1. Redistributions of source code must retain the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer.
+ *
+ *      2. Redistributions in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials
+ *         provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/* Author: Jakub Kicinski <kubakici@wp.pl> */
+
+#include <errno.h>
+#include <libgen.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <linux/limits.h>
+#include <linux/magic.h>
+#include <sys/types.h>
+#include <sys/vfs.h>
+
+#include <bpf.h>
+
+#include "main.h"
+
+static bool is_bpffs(char *path)
+{
+	struct statfs st_fs;
+
+	if (statfs(path, &st_fs) < 0)
+		return false;
+
+	return (unsigned long)st_fs.f_type == BPF_FS_MAGIC;
+}
+
+int open_obj_pinned_any(char *path, enum bpf_obj_type exp_type)
+{
+	enum bpf_obj_type type;
+	int fd;
+
+	fd = bpf_obj_get(path);
+	if (fd < 0) {
+		err("bpf obj get (%s): %s\n", path,
+		    errno == EACCES && !is_bpffs(dirname(path)) ?
+		    "directory not in bpf file system (bpffs)" :
+		    strerror(errno));
+		return -1;
+	}
+
+	type = get_fd_type(fd);
+	if (type < 0) {
+		close(fd);
+		return type;
+	}
+	if (type != exp_type) {
+		err("incorrect object type: %s\n", get_fd_type_name(type));
+		close(fd);
+		return -1;
+	}
+
+	return fd;
+}
+
+int do_pin_any(int argc, char **argv, int (*get_fd_by_id)(__u32))
+{
+	unsigned int id;
+	char *endptr;
+	int err;
+	int fd;
+
+	if (!is_prefix(*argv, "id")) {
+		err("expected 'id' got %s\n", *argv);
+		return -1;
+	}
+	NEXT_ARG();
+
+	id = strtoul(*argv, &endptr, 0);
+	if (*endptr) {
+		err("can't parse %s as ID\n", *argv);
+		return -1;
+	}
+	NEXT_ARG();
+
+	if (argc != 1)
+		usage();
+
+	fd = get_fd_by_id(id);
+	if (fd < 0) {
+		err("can't get prog by id (%u): %s\n", id, strerror(errno));
+		return -1;
+	}
+
+	err = bpf_obj_pin(fd, *argv);
+	close(fd);
+	if (err) {
+		err("can't pin the object (%s): %s\n", *argv,
+		    errno == EACCES && !is_bpffs(dirname(*argv)) ?
+		    "directory not in bpf file system (bpffs)" :
+		    strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+const char *get_fd_type_name(enum bpf_obj_type type)
+{
+	static const char * const names[] = {
+		[BPF_OBJ_UNKNOWN]	= "unknown",
+		[BPF_OBJ_PROG]		= "prog",
+		[BPF_OBJ_MAP]		= "map",
+	};
+
+	if (type < 0 || type >= ARRAY_SIZE(names) || !names[type])
+		return names[BPF_OBJ_UNKNOWN];
+
+	return names[type];
+}
+
+int get_fd_type(int fd)
+{
+	char path[PATH_MAX];
+	char buf[512];
+	ssize_t n;
+
+	snprintf(path, sizeof(path), "/proc/%d/fd/%d", getpid(), fd);
+
+	n = readlink(path, buf, sizeof(buf));
+	if (n < 0) {
+		err("can't read link type: %s\n", strerror(errno));
+		return -1;
+	}
+	if (n == sizeof(path)) {
+		err("can't read link type: path too long!\n");
+		return -1;
+	}
+
+	if (strstr(buf, "bpf-map"))
+		return BPF_OBJ_MAP;
+	else if (strstr(buf, "bpf-prog"))
+		return BPF_OBJ_PROG;
+
+	return BPF_OBJ_UNKNOWN;
+}
+
+char *get_fdinfo(int fd, const char *key)
+{
+	char path[PATH_MAX];
+	char *line = NULL;
+	size_t line_n = 0;
+	ssize_t n;
+	FILE *fdi;
+
+	snprintf(path, sizeof(path), "/proc/%d/fdinfo/%d", getpid(), fd);
+
+	fdi = fopen(path, "r");
+	if (!fdi) {
+		err("can't open fdinfo: %s\n", strerror(errno));
+		return NULL;
+	}
+
+	while ((n = getline(&line, &line_n, fdi))) {
+		char *value;
+		int len;
+
+		if (!strstr(line, key))
+			continue;
+
+		fclose(fdi);
+
+		value = strchr(line, '\t');
+		if (!value || !value[1]) {
+			err("malformed fdinfo!?\n");
+			free(line);
+			return NULL;
+		}
+		value++;
+
+		len = strlen(value);
+		memmove(line, value, len);
+		line[len - 1] = '\0';
+
+		return line;
+	}
+
+	err("key '%s' not found in fdinfo\n", key);
+	free(line);
+	fclose(fdi);
+	return NULL;
+}
