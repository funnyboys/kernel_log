commit c55cc97a252488a8e2a9181c1c36713cad69ee18
Merge: 003e6cc3a22d 208a68c8393d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 10:58:13 2019 +0200

    Merge tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of IIO device support, features, cleanups and minor fixes for 5.3.
    
    A few bits for the counters subsystem mixed in here as well.
    There are some late breaking fixes as well, which aren't so urgent
    they can't wait for the merge window.
    
    New Device Support
    * adf4371
      - New driver + bindings.
      - Support the adf4372 PLL. Mostly ID and bindings.
    * ad8366 (note includes rework of driver needed to allow support for these).
      - Support the ADL5240 variable gain amplifier (VGA).
      - Support the ADA4961 digital gain amplifier (DGA).
    * dps310
      - New driver, in several parts from different authors for this temp
        and pressure sensor.
      - Includes errata workaround for a temperature reading issue.
    * stk3310
      - Support the stk3335, mostly ID.
    
    Features and cleanups
    * core
      - drop error handling on debugfs registration.
      - harden by making sure we don't overrun iio_chan_info_postfix.
    * docs
      - convert remaining docs to rst. At somepoint we'll fit these few
        into the main IIO docs.
      - improve sampling_frequency_available docs but explaining the
        range form.
    * ad_sigma_delta
      - Drop a pointless goto.
    * ad2s1210
      - Drop pointless platform data null check seeing as we don't actually
        use platform data anymore.
    * ad7124
      - Relax limitation on channel numbers to allow pseudo different channels.
      - Support control of whether the input is buffered via DT.
      - Use dynamic allocation for channel configuration to make it easier
        to support new devices.
      - YAML binding conversion.
    * ad7150
      - Comment tidy up.
      - Consistent and simple if (ret) handling of i2c errors.
      - FIELD_GET and GENMASK.
      - Ternary rather than !!(condition) for readability.
      - Use macros to avoid repetition of channel definitions.
    * ad7606
      - Add software channel config (rather that pin controlled)
      - Refactor to simplify addition of new part in future.
    * ad7746
      - of_deivce_id table.
    * ad7780
      - MAINTAINERS entry
      - YAML DT bindings.
    * ad8366
      - Stop using core mlock in favour of well scoped local lock.
      - SPDX + copyright date update.
    * ad9834
      - of_device_id table
    * adf4371
      - Add support for output stage muting before lock on has occured.
    * adis library
      - MAINTAINERS entry to reflect that this now Alexandru's problem ;)
    * adis162xx:
      - Fix a slightly incorrect set of comments and print statements on
        minimum supported voltage.
    * adis16203
      - of_device_id table.
    * adis16240
      - Add of_device_id table (in two parts as first patch only used it for
        MODULE_DEVICE_TABLE.)
    * adt7316-spi
      - of_device_id table
    * adxl372
      - YAML DT binding conversion.
      - Cleanup use of buffer callback functions (precursor to core rework).
    * bh1710
      - Simplify getting the i2c adapter from the client.
    * dht11
      - Mote to newer GPIO consumer interface.
    * kxcjk-1013.c
      - Add binding for sensor in display of some ultrabooks after userspace
        tools updated for it not be a problem to report two similar sensors.
    * imx7d
      - drop unused variables.
      - white space
      - define instead of variable for clock frequency that is fixed.
      - drop pointless error message.
    * messon_saradc
      - SPDX
    * sps30
      - MAINTAINERS entry
      - YAML binding conversion.
    * st_accel
      - Tidy up ordering in various buffer related callbacks. This is
        part of a long running effort to simplify the core code.
    * stm32-dfsdm:
      - Manage the resolution cleanly in triggerd modes.
      - Add fast mode support which allows more flexible filter choices.
      - Add a comment on the reason for a 16 bit record when technically
        not 'required'.
    * st_lsm6dsx
      - Embed device name in the sensor_settings struct as i3c doesn't
        have a convenient name field to use for this.
    * xilinx-adc
      - Relax constraints on supported platforms to reflect that this
        can used with FPGAs on PCIe cards and hence many architectures.
    * counters/ftm-quaddec
      - Fix some formatting io MODULE_AUTHOR
      - MAINTAINERS entry
    
    Fixes
    * tools
      - fix incorrect handling of 32 bit channels.
    * sca3000
      - Potential endian bug that is unlikely to bite anyone (be64 host
        seems unlikely for this old part).
    * stm32-adc
      - Add vdda-supply. On some boards it needs to be turned on to supply
        the ADC.  DT bindings included.
    * stm32-dfsdm
      - Fix output resolution to work with filter orders other than 3.
      - Fix output datatype as it's signed and previously claimed not to be.
    
    * tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (68 commits)
      iio: iio-utils: Fix possible incorrect mask calculation
      iio: frequency: adf4371: Add support for output stage mute
      dt-bindings: iio: frequency: Add ADF4372 PLL documentation
      iio: frequency: adf4371: Add support for ADF4372 PLL
      dt-bindings: iio: adc: Add buffered input property
      Convert AD7124 bindings documentation to YAML format.
      iio: adc: ad7124: Shift to dynamic allocation for channel configuration
      iio: adc: ad7124: Add buffered input support
      iio: adc: ad7124: Remove input number limitation
      MAINTAINERS: add ADIS IMU driver library entry
      iio: adis162xx: fix low-power docs & reports
      counter/ftm-quaddec: Add missing '>' in MODULE_AUTHOR
      iio: core: no need to check return value of debugfs_create functions
      docs: iio: convert to ReST
      iio: adc: stm32-adc: add missing vdda-supply
      dt-bindings: iio: adc: stm32: add missing vdda supply
      iio: adc: stm32-dfsdm: add comment for 16 bits record
      iio: adc: stm32-dfsdm: add fast mode support
      iio: adc: stm32-dfsdm: manage data resolution in trigger mode
      iio: adc: stm32-dfsdm: fix data type
      ...

commit 208a68c8393d6041a90862992222f3d7943d44d6
Author: Bastien Nocera <hadess@hadess.net>
Date:   Thu Jun 27 09:20:45 2019 +0200

    iio: iio-utils: Fix possible incorrect mask calculation
    
    On some machines, iio-sensor-proxy was returning all 0's for IIO sensor
    values. It turns out that the bits_used for this sensor is 32, which makes
    the mask calculation:
    
    *mask = (1 << 32) - 1;
    
    If the compiler interprets the 1 literals as 32-bit ints, it generates
    undefined behavior depending on compiler version and optimization level.
    On my system, it optimizes out the shift, so the mask value becomes
    
    *mask = (1) - 1;
    
    With a mask value of 0, iio-sensor-proxy will always return 0 for every axis.
    
    Avoid incorrect 0 values caused by compiler optimization.
    
    See original fix by Brett Dutro <brett.dutro@gmail.com> in
    iio-sensor-proxy:
    https://github.com/hadess/iio-sensor-proxy/commit/9615ceac7c134d838660e209726cd86aa2064fd3
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 7a6d61c6c012..55272fef3b50 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -159,9 +159,9 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			*be = (endianchar == 'b');
 			*bytes = padint / 8;
 			if (*bits_used == 64)
-				*mask = ~0;
+				*mask = ~(0ULL);
 			else
-				*mask = (1ULL << *bits_used) - 1;
+				*mask = (1ULL << *bits_used) - 1ULL;
 
 			*is_signed = (signchar == 's');
 			if (fclose(sysfsfp)) {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 7a6d61c6c012..a22b6e8fad46 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* IIO - useful set of util functionality
  *
  * Copyright (c) 2008 Jonathan Cameron
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 #include <string.h>
 #include <stdlib.h>

commit 6356f1b9b7e3ccd24bec93c7ed4e226464f44774
Author: Matt Ranostay <mranostay@gmail.com>
Date:   Mon Aug 22 15:19:37 2016 -0700

    iio: iio-utils: use channel modifier scaling if it exists
    
    Now there are channel modifiers with their own scaling those should be
    used when possible over the generic channel type scaling.
    
    Examples are of IIO_TEMP channel having a generic scaling value, and
    another having IIO_MOD_TEMP_AMBIENT modifier with another scaling value.
    
    Previously the first scaling value for a channel type would be applied
    to all channels of like type in iio_generic_buffer
    
    Signed-off-by: Matt Ranostay <mranostay@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 5eb6793f3972..7a6d61c6c012 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -121,10 +121,6 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 
 	ret = -ENOENT;
 	while (ent = readdir(dp), ent)
-		/*
-		 * Do we allow devices to override a generic name with
-		 * a specific one?
-		 */
 		if ((strcmp(builtname, ent->d_name) == 0) ||
 		    (strcmp(builtname_generic, ent->d_name) == 0)) {
 			ret = asprintf(&filename,
@@ -178,6 +174,13 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			sysfsfp = 0;
 			free(filename);
 			filename = 0;
+
+			/*
+			 * Avoid having a more generic entry overwriting
+			 * the settings.
+			 */
+			if (strcmp(builtname, ent->d_name) == 0)
+				break;
 		}
 
 error_close_sysfsfp:

commit 95ddd3f4b17e1df20b5e23d7b81614e7c8a643da
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Sat Jul 25 01:23:29 2015 +1000

    tools: iio: remove unnecessary double pointer
    
    Remove unnecessary double pointer from channel sorting function.
    
    Signed-off-by: Joo Aun Saw <jasaw@dius.com.au>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 8475b832ee39..5eb6793f3972 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -286,17 +286,17 @@ int iioutils_get_param_float(float *output, const char *param_name,
  * @cnt: the amount of array elements
  **/
 
-void bsort_channel_array_by_index(struct iio_channel_info **ci_array, int cnt)
+void bsort_channel_array_by_index(struct iio_channel_info *ci_array, int cnt)
 {
 	struct iio_channel_info temp;
 	int x, y;
 
 	for (x = 0; x < cnt; x++)
 		for (y = 0; y < (cnt - 1); y++)
-			if ((*ci_array)[y].index > (*ci_array)[y + 1].index) {
-				temp = (*ci_array)[y + 1];
-				(*ci_array)[y + 1] = (*ci_array)[y];
-				(*ci_array)[y] = temp;
+			if (ci_array[y].index > ci_array[y + 1].index) {
+				temp = ci_array[y + 1];
+				ci_array[y + 1] = ci_array[y];
+				ci_array[y] = temp;
 			}
 }
 
@@ -516,7 +516,7 @@ int build_channel_array(const char *device_dir,
 
 	free(scan_el_dir);
 	/* reorder so that the array is in index order */
-	bsort_channel_array_by_index(ci_array, *counter);
+	bsort_channel_array_by_index(*ci_array, *counter);
 
 	return 0;
 

commit 6b20f40679108e3c04e9bdb3d719e364ec29289e
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Sat Jul 25 01:23:28 2015 +1000

    tools: iio: Set caller's ci_array pointer to NULL after free
    
    On error, caller's ci_array is freed and set to NULL to avoid
    potential double free if some other user of this code is not
    sufficiently careful. Counter is reset to zero for consistency.
    
    Signed-off-by: Joo Aun Saw <jasaw@dius.com.au>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 4bbd6e7959cd..8475b832ee39 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -526,6 +526,8 @@ int build_channel_array(const char *device_dir,
 		free((*ci_array)[i].generic_name);
 	}
 	free(*ci_array);
+	*ci_array = NULL;
+	*counter = 0;
 error_close_dir:
 	if (dp)
 		if (closedir(dp) == -1)

commit 5e37c523921480093323c06529ab854f0635c59d
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Tue Jul 28 11:46:13 2015 +1000

    tools: iio: iio_utils: Make calc_digits static
    
    Signed-off-by: Joo Aun Saw <jasaw@dius.com.au>
    Acked-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 31aca9ab078b..4bbd6e7959cd 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -537,7 +537,7 @@ int build_channel_array(const char *device_dir,
 	return ret;
 }
 
-int calc_digits(int num)
+static int calc_digits(int num)
 {
 	int count = 0;
 

commit 280f09256ab6f6180132da193b9f2e0b2fa61c51
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Wed Jul 29 01:12:24 2015 +1000

    tools: iio: iio_utils: remove unnecessary define guard
    
    Signed-off-by: Joo Aun Saw <jasaw@dius.com.au>
    Acked-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index a95270f33353..31aca9ab078b 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -6,9 +6,6 @@
  * under the terms of the GNU General Public License version 2 as published by
  * the Free Software Foundation.
  */
-#ifndef _IIO_UTILS_H
-#define _IIO_UTILS_H
-
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -990,5 +987,3 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 
 	return ret;
 }
-
-#endif /* _IIO_UTILS_H */

commit ae067cb68d2ef42d4a84eeaf07411fe2936f48c4
Author: Irina Tirdea <irina.tirdea@intel.com>
Date:   Fri Jul 24 16:28:05 2015 +0300

    tools: iio: fix mask for 32 bit sensor data
    
    When the the sensor data uses 32 bits out of 32, generic_buffer prints
    the value 0 for all data read.
    
    In this case, the mask is shifted 32 bits, which is beyond the size of
    an integer. This will lead to the mask always being 0. Before printing,
    the mask is applied to the raw value, thus generating a final value of 0.
    
    Fix the mask by shifting a 64 bit value instead of an integer.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 1dcdf03955cb..a95270f33353 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -168,7 +168,7 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			if (*bits_used == 64)
 				*mask = ~0;
 			else
-				*mask = (1 << *bits_used) - 1;
+				*mask = (1ULL << *bits_used) - 1;
 
 			*is_signed = (signchar == 's');
 			if (fclose(sysfsfp)) {

commit 7868dfd216074fc5f902e7befacda2a0ec76e403
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Thu Jul 23 12:53:47 2015 +1000

    tools: iio: make scale and offset files optional
    
    Make scale and offset optional by adding -ENOENT check as not all
    drivers implement them.
    
    Signed-off-by: Joo Aun Saw <jasaw@dius.com.au>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index c3f9e37333e7..1dcdf03955cb 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -487,7 +487,7 @@ int build_channel_array(const char *device_dir,
 						       device_dir,
 						       current->name,
 						       current->generic_name);
-			if (ret < 0)
+			if ((ret < 0) && (ret != -ENOENT))
 				goto error_cleanup_array;
 
 			ret = iioutils_get_param_float(&current->offset,
@@ -495,7 +495,7 @@ int build_channel_array(const char *device_dir,
 						       device_dir,
 						       current->name,
 						       current->generic_name);
-			if (ret < 0)
+			if ((ret < 0) && (ret != -ENOENT))
 				goto error_cleanup_array;
 
 			ret = iioutils_get_type(&current->is_signed,

commit d9abc615ea1659b6967a00e95b1b3a7fd4079b80
Author: Cristina Opriceana <cristina.opriceana@gmail.com>
Date:   Fri Jul 17 18:43:42 2015 +0300

    tools: iio: Send error messages to stderr
    
    This patch indends to make some cleanup and send printf
    error messages to stderr. The changes were performed with coccinelle
    for failure messages and manual for other cases, such as wrong usage
    messages.
    
    Signed-off-by: Cristina Opriceana <cristina.opriceana@gmail.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index e177f4022d40..c3f9e37333e7 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -140,7 +140,8 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			sysfsfp = fopen(filename, "r");
 			if (!sysfsfp) {
 				ret = -errno;
-				printf("failed to open %s\n", filename);
+				fprintf(stderr, "failed to open %s\n",
+					filename);
 				goto error_free_filename;
 			}
 
@@ -152,11 +153,13 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 				     &padint, shift);
 			if (ret < 0) {
 				ret = -errno;
-				printf("failed to pass scan type description\n");
+				fprintf(stderr,
+					"failed to pass scan type description\n");
 				goto error_close_sysfsfp;
 			} else if (ret != 5) {
 				ret = -EIO;
-				printf("scan type description didn't match\n");
+				fprintf(stderr,
+					"scan type description didn't match\n");
 				goto error_close_sysfsfp;
 			}
 
@@ -170,7 +173,8 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			*is_signed = (signchar == 's');
 			if (fclose(sysfsfp)) {
 				ret = -errno;
-				printf("Failed to close %s\n", filename);
+				fprintf(stderr, "Failed to close %s\n",
+					filename);
 				goto error_free_filename;
 			}
 
@@ -454,7 +458,8 @@ int build_channel_array(const char *device_dir,
 			sysfsfp = fopen(filename, "r");
 			if (!sysfsfp) {
 				ret = -errno;
-				printf("failed to open %s\n", filename);
+				fprintf(stderr, "failed to open %s\n",
+					filename);
 				free(filename);
 				goto error_cleanup_array;
 			}
@@ -568,7 +573,7 @@ int find_type_by_name(const char *name, const char *type)
 
 	dp = opendir(iio_dir);
 	if (!dp) {
-		printf("No industrialio devices available\n");
+		fprintf(stderr, "No industrialio devices available\n");
 		return -ENODEV;
 	}
 
@@ -581,11 +586,13 @@ int find_type_by_name(const char *name, const char *type)
 			ret = sscanf(ent->d_name + strlen(type), "%d", &number);
 			if (ret < 0) {
 				ret = -errno;
-				printf("failed to read element number\n");
+				fprintf(stderr,
+					"failed to read element number\n");
 				goto error_close_dir;
 			} else if (ret != 1) {
 				ret = -EIO;
-				printf("failed to match element number\n");
+				fprintf(stderr,
+					"failed to match element number\n");
 				goto error_close_dir;
 			}
 
@@ -664,7 +671,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 	sysfsfp = fopen(temp, "w");
 	if (!sysfsfp) {
 		ret = -errno;
-		printf("failed to open %s\n", temp);
+		fprintf(stderr, "failed to open %s\n", temp);
 		goto error_free;
 	}
 
@@ -685,7 +692,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 		sysfsfp = fopen(temp, "r");
 		if (!sysfsfp) {
 			ret = -errno;
-			printf("failed to open %s\n", temp);
+			fprintf(stderr, "failed to open %s\n", temp);
 			goto error_free;
 		}
 
@@ -703,8 +710,9 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 		}
 
 		if (test != val) {
-			printf("Possible failure in int write %d to %s/%s\n",
-			       val, basedir, filename);
+			fprintf(stderr,
+				"Possible failure in int write %d to %s/%s\n",
+				val, basedir, filename);
 			ret = -1;
 		}
 	}
@@ -750,7 +758,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
 	if (!temp) {
-		printf("Memory allocation failed\n");
+		fprintf(stderr, "Memory allocation failed\n");
 		return -ENOMEM;
 	}
 
@@ -761,7 +769,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 	sysfsfp = fopen(temp, "w");
 	if (!sysfsfp) {
 		ret = -errno;
-		printf("Could not open %s\n", temp);
+		fprintf(stderr, "Could not open %s\n", temp);
 		goto error_free;
 	}
 
@@ -782,7 +790,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		sysfsfp = fopen(temp, "r");
 		if (!sysfsfp) {
 			ret = -errno;
-			printf("Could not open file to verify\n");
+			fprintf(stderr, "Could not open file to verify\n");
 			goto error_free;
 		}
 
@@ -800,9 +808,10 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		}
 
 		if (strcmp(temp, val) != 0) {
-			printf("Possible failure in string write of %s "
-			       "Should be %s written to %s/%s\n", temp, val,
-			       basedir, filename);
+			fprintf(stderr,
+				"Possible failure in string write of %s "
+				"Should be %s written to %s/%s\n", temp, val,
+				basedir, filename);
 			ret = -1;
 		}
 	}
@@ -856,7 +865,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
 	if (!temp) {
-		printf("Memory allocation failed");
+		fprintf(stderr, "Memory allocation failed");
 		return -ENOMEM;
 	}
 
@@ -903,7 +912,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
 	if (!temp) {
-		printf("Memory allocation failed");
+		fprintf(stderr, "Memory allocation failed");
 		return -ENOMEM;
 	}
 
@@ -950,7 +959,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
 	if (!temp) {
-		printf("Memory allocation failed");
+		fprintf(stderr, "Memory allocation failed");
 		return -ENOMEM;
 	}
 

commit 34cbea1908fb686b037e01e5b1ab8e0e67b09ed3
Author: Cristina Opriceana <cristina.opriceana@gmail.com>
Date:   Mon Jul 13 16:20:11 2015 +0300

    tools: iio: Add ARRAY_SIZE macro
    
    Calculation of the length of an array can be done with the ARRAY_SIZE
    macro to make code more abstract and remove the associated
    checkpatch.pl warning.
    
    Signed-off-by: Cristina Opriceana <cristina.opriceana@gmail.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 4a7e4801cebf..e177f4022d40 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -39,7 +39,7 @@ int iioutils_break_up_name(const char *full_name, char **generic_name)
 	char *working, *prefix = "";
 	int i, ret;
 
-	for (i = 0; i < sizeof(iio_direction) / sizeof(iio_direction[0]); i++)
+	for (i = 0; i < ARRAY_SIZE(iio_direction); i++)
 		if (!strncmp(full_name, iio_direction[i],
 			     strlen(iio_direction[i]))) {
 			prefix = iio_direction[i];

commit ff1ac639b395d58bbd99ff4a36b10eebb81544a3
Author: Cristina Opriceana <cristina.opriceana@gmail.com>
Date:   Mon Jul 13 16:15:56 2015 +0300

    tools: iio: Remove explicit NULL comparison
    
    Remove explicit NULL comparison and write it in its simpler form as
    recommended by checkpatch.pl.
    
    Signed-off-by: Cristina Opriceana <cristina.opriceana@gmail.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 8fb3214c70f2..4a7e4801cebf 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -117,13 +117,13 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 	}
 
 	dp = opendir(scan_el_dir);
-	if (dp == NULL) {
+	if (!dp) {
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
 
 	ret = -ENOENT;
-	while (ent = readdir(dp), ent != NULL)
+	while (ent = readdir(dp), ent)
 		/*
 		 * Do we allow devices to override a generic name with
 		 * a specific one?
@@ -138,7 +138,7 @@ int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
 			}
 
 			sysfsfp = fopen(filename, "r");
-			if (sysfsfp == NULL) {
+			if (!sysfsfp) {
 				ret = -errno;
 				printf("failed to open %s\n", filename);
 				goto error_free_filename;
@@ -235,13 +235,13 @@ int iioutils_get_param_float(float *output, const char *param_name,
 	}
 
 	dp = opendir(device_dir);
-	if (dp == NULL) {
+	if (!dp) {
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
 
 	ret = -ENOENT;
-	while (ent = readdir(dp), ent != NULL)
+	while (ent = readdir(dp), ent)
 		if ((strcmp(builtname, ent->d_name) == 0) ||
 		    (strcmp(builtname_generic, ent->d_name) == 0)) {
 			ret = asprintf(&filename,
@@ -325,12 +325,12 @@ int build_channel_array(const char *device_dir,
 		return -ENOMEM;
 
 	dp = opendir(scan_el_dir);
-	if (dp == NULL) {
+	if (!dp) {
 		ret = -errno;
 		goto error_free_name;
 	}
 
-	while (ent = readdir(dp), ent != NULL)
+	while (ent = readdir(dp), ent)
 		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
 			   "_en") == 0) {
 			ret = asprintf(&filename,
@@ -341,7 +341,7 @@ int build_channel_array(const char *device_dir,
 			}
 
 			sysfsfp = fopen(filename, "r");
-			if (sysfsfp == NULL) {
+			if (!sysfsfp) {
 				ret = -errno;
 				free(filename);
 				goto error_close_dir;
@@ -369,13 +369,13 @@ int build_channel_array(const char *device_dir,
 		}
 
 	*ci_array = malloc(sizeof(**ci_array) * (*counter));
-	if (*ci_array == NULL) {
+	if (!*ci_array) {
 		ret = -ENOMEM;
 		goto error_close_dir;
 	}
 
 	seekdir(dp, 0);
-	while (ent = readdir(dp), ent != NULL) {
+	while (ent = readdir(dp), ent) {
 		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
 			   "_en") == 0) {
 			int current_enabled = 0;
@@ -391,7 +391,7 @@ int build_channel_array(const char *device_dir,
 			}
 
 			sysfsfp = fopen(filename, "r");
-			if (sysfsfp == NULL) {
+			if (!sysfsfp) {
 				ret = -errno;
 				free(filename);
 				count--;
@@ -424,7 +424,7 @@ int build_channel_array(const char *device_dir,
 			current->name = strndup(ent->d_name,
 						strlen(ent->d_name) -
 						strlen("_en"));
-			if (current->name == NULL) {
+			if (!current->name) {
 				free(filename);
 				ret = -ENOMEM;
 				count--;
@@ -452,7 +452,7 @@ int build_channel_array(const char *device_dir,
 			}
 
 			sysfsfp = fopen(filename, "r");
-			if (sysfsfp == NULL) {
+			if (!sysfsfp) {
 				ret = -errno;
 				printf("failed to open %s\n", filename);
 				free(filename);
@@ -567,12 +567,12 @@ int find_type_by_name(const char *name, const char *type)
 	char *filename;
 
 	dp = opendir(iio_dir);
-	if (dp == NULL) {
+	if (!dp) {
 		printf("No industrialio devices available\n");
 		return -ENODEV;
 	}
 
-	while (ent = readdir(dp), ent != NULL) {
+	while (ent = readdir(dp), ent) {
 		if (strcmp(ent->d_name, ".") != 0 &&
 		    strcmp(ent->d_name, "..") != 0 &&
 		    strlen(ent->d_name) > strlen(type) &&
@@ -595,7 +595,7 @@ int find_type_by_name(const char *name, const char *type)
 			    ":", 1) != 0) {
 				filename = malloc(strlen(iio_dir) + strlen(type)
 						  + numstrlen + 6);
-				if (filename == NULL) {
+				if (!filename) {
 					ret = -ENOMEM;
 					goto error_close_dir;
 				}
@@ -654,7 +654,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 	int test;
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
-	if (temp == NULL)
+	if (!temp)
 		return -ENOMEM;
 
 	ret = sprintf(temp, "%s/%s", basedir, filename);
@@ -662,7 +662,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 		goto error_free;
 
 	sysfsfp = fopen(temp, "w");
-	if (sysfsfp == NULL) {
+	if (!sysfsfp) {
 		ret = -errno;
 		printf("failed to open %s\n", temp);
 		goto error_free;
@@ -683,7 +683,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
-		if (sysfsfp == NULL) {
+		if (!sysfsfp) {
 			ret = -errno;
 			printf("failed to open %s\n", temp);
 			goto error_free;
@@ -749,7 +749,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 	FILE  *sysfsfp;
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
-	if (temp == NULL) {
+	if (!temp) {
 		printf("Memory allocation failed\n");
 		return -ENOMEM;
 	}
@@ -759,7 +759,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		goto error_free;
 
 	sysfsfp = fopen(temp, "w");
-	if (sysfsfp == NULL) {
+	if (!sysfsfp) {
 		ret = -errno;
 		printf("Could not open %s\n", temp);
 		goto error_free;
@@ -780,7 +780,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
-		if (sysfsfp == NULL) {
+		if (!sysfsfp) {
 			ret = -errno;
 			printf("Could not open file to verify\n");
 			goto error_free;
@@ -855,7 +855,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 	FILE  *sysfsfp;
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
-	if (temp == NULL) {
+	if (!temp) {
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
@@ -865,7 +865,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 		goto error_free;
 
 	sysfsfp = fopen(temp, "r");
-	if (sysfsfp == NULL) {
+	if (!sysfsfp) {
 		ret = -errno;
 		goto error_free;
 	}
@@ -902,7 +902,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 	FILE  *sysfsfp;
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
-	if (temp == NULL) {
+	if (!temp) {
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
@@ -912,7 +912,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 		goto error_free;
 
 	sysfsfp = fopen(temp, "r");
-	if (sysfsfp == NULL) {
+	if (!sysfsfp) {
 		ret = -errno;
 		goto error_free;
 	}
@@ -949,7 +949,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 	FILE  *sysfsfp;
 	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
 
-	if (temp == NULL) {
+	if (!temp) {
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
@@ -959,7 +959,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 		goto error_free;
 
 	sysfsfp = fopen(temp, "r");
-	if (sysfsfp == NULL) {
+	if (!sysfsfp) {
 		ret = -errno;
 		goto error_free;
 	}

commit a9d7acc8b0d52ae2f15f6280f63ac9d1e73cfb78
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Wed Jun 10 21:51:21 2015 +0200

    tools:iio: rename variables
    
    Use more appropriate/common variable names:
      * namepf instead of nameFile in iio_utils.c
      * ret instead of retval in lsiio.c
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 4eac11ad38c4..8fb3214c70f2 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -561,7 +561,7 @@ int find_type_by_name(const char *name, const char *type)
 	const struct dirent *ent;
 	int number, numstrlen, ret;
 
-	FILE *nameFile;
+	FILE *namefp;
 	DIR *dp;
 	char thisname[IIO_MAX_NAME_LENGTH];
 	char *filename;
@@ -607,20 +607,20 @@ int find_type_by_name(const char *name, const char *type)
 					goto error_close_dir;
 				}
 
-				nameFile = fopen(filename, "r");
-				if (!nameFile) {
+				namefp = fopen(filename, "r");
+				if (!namefp) {
 					free(filename);
 					continue;
 				}
 
 				free(filename);
 				errno = 0;
-				if (fscanf(nameFile, "%s", thisname) != 1) {
+				if (fscanf(namefp, "%s", thisname) != 1) {
 					ret = errno ? -errno : -ENODATA;
 					goto error_close_dir;
 				}
 
-				if (fclose(nameFile)) {
+				if (fclose(namefp)) {
 					ret = -errno;
 					goto error_close_dir;
 				}

commit 7663a4aac625268674060d78ee00f97a36a03af7
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Wed Jun 10 21:51:20 2015 +0200

    tools:iio: adjust coding style
    
    Fix various coding style issues, including:
      * have spaces around operators
      * indentation
      * consolidate parameters in same line
      * required braces
      * adjust/drop comments
      * multiline comment style
      * delete unnecessary empty lines
      * add empty lines to visualize logial code blocks
      * typos
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index ec9ab7f9ae4c..4eac11ad38c4 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -32,8 +32,7 @@ static char * const iio_direction[] = {
  *
  * Returns 0 on success, or a negative error code if string extraction failed.
  **/
-int iioutils_break_up_name(const char *full_name,
-				  char **generic_name)
+int iioutils_break_up_name(const char *full_name, char **generic_name)
 {
 	char *current;
 	char *w, *r;
@@ -65,6 +64,7 @@ int iioutils_break_up_name(const char *full_name,
 			*w = *r;
 			w++;
 		}
+
 		r++;
 	}
 	*w = '\0';
@@ -88,15 +88,10 @@ int iioutils_break_up_name(const char *full_name,
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int iioutils_get_type(unsigned *is_signed,
-			     unsigned *bytes,
-			     unsigned *bits_used,
-			     unsigned *shift,
-			     uint64_t *mask,
-			     unsigned *be,
-			     const char *device_dir,
-			     const char *name,
-			     const char *generic_name)
+int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
+		      unsigned *shift, uint64_t *mask, unsigned *be,
+		      const char *device_dir, const char *name,
+		      const char *generic_name)
 {
 	FILE *sysfsfp;
 	int ret;
@@ -126,6 +121,7 @@ int iioutils_get_type(unsigned *is_signed,
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
+
 	ret = -ENOENT;
 	while (ent = readdir(dp), ent != NULL)
 		/*
@@ -140,6 +136,7 @@ int iioutils_get_type(unsigned *is_signed,
 				ret = -ENOMEM;
 				goto error_closedir;
 			}
+
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
 				ret = -errno;
@@ -162,12 +159,14 @@ int iioutils_get_type(unsigned *is_signed,
 				printf("scan type description didn't match\n");
 				goto error_close_sysfsfp;
 			}
+
 			*be = (endianchar == 'b');
 			*bytes = padint / 8;
 			if (*bits_used == 64)
 				*mask = ~0;
 			else
 				*mask = (1 << *bits_used) - 1;
+
 			*is_signed = (signchar == 's');
 			if (fclose(sysfsfp)) {
 				ret = -errno;
@@ -177,9 +176,9 @@ int iioutils_get_type(unsigned *is_signed,
 
 			sysfsfp = 0;
 			free(filename);
-
 			filename = 0;
 		}
+
 error_close_sysfsfp:
 	if (sysfsfp)
 		if (fclose(sysfsfp))
@@ -188,6 +187,7 @@ int iioutils_get_type(unsigned *is_signed,
 error_free_filename:
 	if (filename)
 		free(filename);
+
 error_closedir:
 	if (closedir(dp) == -1)
 		perror("iioutils_get_type(): Failed to close directory");
@@ -212,11 +212,9 @@ int iioutils_get_type(unsigned *is_signed,
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int iioutils_get_param_float(float *output,
-				    const char *param_name,
-				    const char *device_dir,
-				    const char *name,
-				    const char *generic_name)
+int iioutils_get_param_float(float *output, const char *param_name,
+			     const char *device_dir, const char *name,
+			     const char *generic_name)
 {
 	FILE *sysfsfp;
 	int ret;
@@ -235,11 +233,13 @@ int iioutils_get_param_float(float *output,
 		ret = -ENOMEM;
 		goto error_free_builtname;
 	}
+
 	dp = opendir(device_dir);
 	if (dp == NULL) {
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
+
 	ret = -ENOENT;
 	while (ent = readdir(dp), ent != NULL)
 		if ((strcmp(builtname, ent->d_name) == 0) ||
@@ -250,11 +250,13 @@ int iioutils_get_param_float(float *output,
 				ret = -ENOMEM;
 				goto error_closedir;
 			}
+
 			sysfsfp = fopen(filename, "r");
 			if (!sysfsfp) {
 				ret = -errno;
 				goto error_free_filename;
 			}
+
 			errno = 0;
 			if (fscanf(sysfsfp, "%f", output) != 1)
 				ret = errno ? -errno : -ENODATA;
@@ -264,6 +266,7 @@ int iioutils_get_param_float(float *output,
 error_free_filename:
 	if (filename)
 		free(filename);
+
 error_closedir:
 	if (closedir(dp) == -1)
 		perror("iioutils_get_param_float(): Failed to close directory");
@@ -282,16 +285,14 @@ int iioutils_get_param_float(float *output,
  * @cnt: the amount of array elements
  **/
 
-void bsort_channel_array_by_index(struct iio_channel_info **ci_array,
-					 int cnt)
+void bsort_channel_array_by_index(struct iio_channel_info **ci_array, int cnt)
 {
-
 	struct iio_channel_info temp;
 	int x, y;
 
 	for (x = 0; x < cnt; x++)
 		for (y = 0; y < (cnt - 1); y++)
-			if ((*ci_array)[y].index > (*ci_array)[y+1].index) {
+			if ((*ci_array)[y].index > (*ci_array)[y + 1].index) {
 				temp = (*ci_array)[y + 1];
 				(*ci_array)[y + 1] = (*ci_array)[y];
 				(*ci_array)[y] = temp;
@@ -307,8 +308,7 @@ void bsort_channel_array_by_index(struct iio_channel_info **ci_array,
  * Returns 0 on success, otherwise a negative error code.
  **/
 int build_channel_array(const char *device_dir,
-			      struct iio_channel_info **ci_array,
-			      int *counter)
+			struct iio_channel_info **ci_array, int *counter)
 {
 	DIR *dp;
 	FILE *sysfsfp;
@@ -329,6 +329,7 @@ int build_channel_array(const char *device_dir,
 		ret = -errno;
 		goto error_free_name;
 	}
+
 	while (ent = readdir(dp), ent != NULL)
 		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
 			   "_en") == 0) {
@@ -338,12 +339,14 @@ int build_channel_array(const char *device_dir,
 				ret = -ENOMEM;
 				goto error_close_dir;
 			}
+
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
 				ret = -errno;
 				free(filename);
 				goto error_close_dir;
 			}
+
 			errno = 0;
 			if (fscanf(sysfsfp, "%i", &ret) != 1) {
 				ret = errno ? -errno : -ENODATA;
@@ -353,9 +356,9 @@ int build_channel_array(const char *device_dir,
 				free(filename);
 				goto error_close_dir;
 			}
-
 			if (ret == 1)
 				(*counter)++;
+
 			if (fclose(sysfsfp)) {
 				ret = -errno;
 				free(filename);
@@ -364,11 +367,13 @@ int build_channel_array(const char *device_dir,
 
 			free(filename);
 		}
+
 	*ci_array = malloc(sizeof(**ci_array) * (*counter));
 	if (*ci_array == NULL) {
 		ret = -ENOMEM;
 		goto error_close_dir;
 	}
+
 	seekdir(dp, 0);
 	while (ent = readdir(dp), ent != NULL) {
 		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
@@ -384,6 +389,7 @@ int build_channel_array(const char *device_dir,
 				count--;
 				goto error_cleanup_array;
 			}
+
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
 				ret = -errno;
@@ -391,6 +397,7 @@ int build_channel_array(const char *device_dir,
 				count--;
 				goto error_cleanup_array;
 			}
+
 			errno = 0;
 			if (fscanf(sysfsfp, "%i", &current_enabled) != 1) {
 				ret = errno ? -errno : -ENODATA;
@@ -423,6 +430,7 @@ int build_channel_array(const char *device_dir,
 				count--;
 				goto error_cleanup_array;
 			}
+
 			/* Get the generic and specific name elements */
 			ret = iioutils_break_up_name(current->name,
 						     &current->generic_name);
@@ -432,6 +440,7 @@ int build_channel_array(const char *device_dir,
 				count--;
 				goto error_cleanup_array;
 			}
+
 			ret = asprintf(&filename,
 				       "%s/%s_index",
 				       scan_el_dir,
@@ -441,6 +450,7 @@ int build_channel_array(const char *device_dir,
 				ret = -ENOMEM;
 				goto error_cleanup_array;
 			}
+
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
 				ret = -errno;
@@ -474,6 +484,7 @@ int build_channel_array(const char *device_dir,
 						       current->generic_name);
 			if (ret < 0)
 				goto error_cleanup_array;
+
 			ret = iioutils_get_param_float(&current->offset,
 						       "offset",
 						       device_dir,
@@ -481,6 +492,7 @@ int build_channel_array(const char *device_dir,
 						       current->generic_name);
 			if (ret < 0)
 				goto error_cleanup_array;
+
 			ret = iioutils_get_type(&current->is_signed,
 						&current->bytes,
 						&current->bits_used,
@@ -562,9 +574,9 @@ int find_type_by_name(const char *name, const char *type)
 
 	while (ent = readdir(dp), ent != NULL) {
 		if (strcmp(ent->d_name, ".") != 0 &&
-			strcmp(ent->d_name, "..") != 0 &&
-			strlen(ent->d_name) > strlen(type) &&
-			strncmp(ent->d_name, type, strlen(type)) == 0) {
+		    strcmp(ent->d_name, "..") != 0 &&
+		    strlen(ent->d_name) > strlen(type) &&
+		    strncmp(ent->d_name, type, strlen(type)) == 0) {
 			errno = 0;
 			ret = sscanf(ent->d_name + strlen(type), "%d", &number);
 			if (ret < 0) {
@@ -580,12 +592,9 @@ int find_type_by_name(const char *name, const char *type)
 			numstrlen = calc_digits(number);
 			/* verify the next character is not a colon */
 			if (strncmp(ent->d_name + strlen(type) + numstrlen,
-					":",
-					1) != 0) {
-				filename = malloc(strlen(iio_dir)
-						+ strlen(type)
-						+ numstrlen
-						+ 6);
+			    ":", 1) != 0) {
+				filename = malloc(strlen(iio_dir) + strlen(type)
+						  + numstrlen + 6);
 				if (filename == NULL) {
 					ret = -ENOMEM;
 					goto error_close_dir;
@@ -603,6 +612,7 @@ int find_type_by_name(const char *name, const char *type)
 					free(filename);
 					continue;
 				}
+
 				free(filename);
 				errno = 0;
 				if (fscanf(nameFile, "%s", thisname) != 1) {
@@ -618,6 +628,7 @@ int find_type_by_name(const char *name, const char *type)
 				if (strcmp(name, thisname) == 0) {
 					if (closedir(dp) == -1)
 						return -errno;
+
 					return number;
 				}
 			}
@@ -631,6 +642,7 @@ int find_type_by_name(const char *name, const char *type)
 error_close_dir:
 	if (closedir(dp) == -1)
 		perror("find_type_by_name(): Failed to close directory");
+
 	return ret;
 }
 
@@ -644,6 +656,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 
 	if (temp == NULL)
 		return -ENOMEM;
+
 	ret = sprintf(temp, "%s/%s", basedir, filename);
 	if (ret < 0)
 		goto error_free;
@@ -654,6 +667,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 		printf("failed to open %s\n", temp);
 		goto error_free;
 	}
+
 	ret = fprintf(sysfsfp, "%d", val);
 	if (ret < 0) {
 		if (fclose(sysfsfp))
@@ -674,6 +688,7 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 			printf("failed to open %s\n", temp);
 			goto error_free;
 		}
+
 		if (fscanf(sysfsfp, "%d", &test) != 1) {
 			ret = errno ? -errno : -ENODATA;
 			if (fclose(sysfsfp))
@@ -688,13 +703,12 @@ static int _write_sysfs_int(const char *filename, const char *basedir, int val,
 		}
 
 		if (test != val) {
-			printf("Possible failure in int write %d to %s%s\n",
-				val,
-				basedir,
-				filename);
+			printf("Possible failure in int write %d to %s/%s\n",
+			       val, basedir, filename);
 			ret = -1;
 		}
 	}
+
 error_free:
 	free(temp);
 	return ret;
@@ -739,6 +753,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		printf("Memory allocation failed\n");
 		return -ENOMEM;
 	}
+
 	ret = sprintf(temp, "%s/%s", basedir, filename);
 	if (ret < 0)
 		goto error_free;
@@ -749,6 +764,7 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		printf("Could not open %s\n", temp);
 		goto error_free;
 	}
+
 	ret = fprintf(sysfsfp, "%s", val);
 	if (ret < 0) {
 		if (fclose(sysfsfp))
@@ -766,9 +782,10 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 		sysfsfp = fopen(temp, "r");
 		if (sysfsfp == NULL) {
 			ret = -errno;
-			printf("could not open file to verify\n");
+			printf("Could not open file to verify\n");
 			goto error_free;
 		}
+
 		if (fscanf(sysfsfp, "%s", temp) != 1) {
 			ret = errno ? -errno : -ENODATA;
 			if (fclose(sysfsfp))
@@ -784,15 +801,12 @@ static int _write_sysfs_string(const char *filename, const char *basedir,
 
 		if (strcmp(temp, val) != 0) {
 			printf("Possible failure in string write of %s "
-				"Should be %s "
-				"written to %s\%s\n",
-				temp,
-				val,
-				basedir,
-				filename);
+			       "Should be %s written to %s/%s\n", temp, val,
+			       basedir, filename);
 			ret = -1;
 		}
 	}
+
 error_free:
 	free(temp);
 
@@ -845,6 +859,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
+
 	ret = sprintf(temp, "%s/%s", basedir, filename);
 	if (ret < 0)
 		goto error_free;
@@ -854,6 +869,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 		ret = -errno;
 		goto error_free;
 	}
+
 	errno = 0;
 	if (fscanf(sysfsfp, "%d\n", &ret) != 1) {
 		ret = errno ? -errno : -ENODATA;
@@ -868,6 +884,7 @@ int read_sysfs_posint(const char *filename, const char *basedir)
 
 error_free:
 	free(temp);
+
 	return ret;
 }
 
@@ -889,6 +906,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
+
 	ret = sprintf(temp, "%s/%s", basedir, filename);
 	if (ret < 0)
 		goto error_free;
@@ -898,6 +916,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 		ret = -errno;
 		goto error_free;
 	}
+
 	errno = 0;
 	if (fscanf(sysfsfp, "%f\n", val) != 1) {
 		ret = errno ? -errno : -ENODATA;
@@ -912,6 +931,7 @@ int read_sysfs_float(const char *filename, const char *basedir, float *val)
 
 error_free:
 	free(temp);
+
 	return ret;
 }
 
@@ -933,6 +953,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
+
 	ret = sprintf(temp, "%s/%s", basedir, filename);
 	if (ret < 0)
 		goto error_free;
@@ -942,6 +963,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 		ret = -errno;
 		goto error_free;
 	}
+
 	errno = 0;
 	if (fscanf(sysfsfp, "%s\n", str) != 1) {
 		ret = errno ? -errno : -ENODATA;
@@ -956,6 +978,7 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 
 error_free:
 	free(temp);
+
 	return ret;
 }
 

commit 9d4752544d17a10a40be5fc5ef68edcae5363599
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:36 2015 +0200

    tools:iio:iio_utils: pass strings as const
    
    Mark strings, which are not supposed to be changed (basedir, filename,
    value), as const in function parameters.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index dfee1a3f3f63..ec9ab7f9ae4c 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -634,7 +634,8 @@ int find_type_by_name(const char *name, const char *type)
 	return ret;
 }
 
-static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
+static int _write_sysfs_int(const char *filename, const char *basedir, int val,
+			    int verify)
 {
 	int ret = 0;
 	FILE *sysfsfp;
@@ -707,7 +708,7 @@ static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int write_sysfs_int(char *filename, char *basedir, int val)
+int write_sysfs_int(const char *filename, const char *basedir, int val)
 {
 	return _write_sysfs_int(filename, basedir, val, 0);
 }
@@ -721,13 +722,14 @@ int write_sysfs_int(char *filename, char *basedir, int val)
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int write_sysfs_int_and_verify(char *filename, char *basedir, int val)
+int write_sysfs_int_and_verify(const char *filename, const char *basedir,
+			       int val)
 {
 	return _write_sysfs_int(filename, basedir, val, 1);
 }
 
-static int _write_sysfs_string(char *filename, char *basedir, char *val,
-			       int verify)
+static int _write_sysfs_string(const char *filename, const char *basedir,
+			       const char *val, int verify)
 {
 	int ret = 0;
 	FILE  *sysfsfp;
@@ -805,7 +807,8 @@ static int _write_sysfs_string(char *filename, char *basedir, char *val,
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int write_sysfs_string_and_verify(char *filename, char *basedir, char *val)
+int write_sysfs_string_and_verify(const char *filename, const char *basedir,
+				  const char *val)
 {
 	return _write_sysfs_string(filename, basedir, val, 1);
 }
@@ -818,7 +821,8 @@ int write_sysfs_string_and_verify(char *filename, char *basedir, char *val)
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int write_sysfs_string(char *filename, char *basedir, char *val)
+int write_sysfs_string(const char *filename, const char *basedir,
+		       const char *val)
 {
 	return _write_sysfs_string(filename, basedir, val, 0);
 }
@@ -831,7 +835,7 @@ int write_sysfs_string(char *filename, char *basedir, char *val)
  * Returns the read integer value >= 0 on success, otherwise a negative error
  * code.
  **/
-int read_sysfs_posint(char *filename, char *basedir)
+int read_sysfs_posint(const char *filename, const char *basedir)
 {
 	int ret;
 	FILE  *sysfsfp;
@@ -875,7 +879,7 @@ int read_sysfs_posint(char *filename, char *basedir)
  *
  * Returns a value >= 0 on success, otherwise a negative error code.
  **/
-int read_sysfs_float(char *filename, char *basedir, float *val)
+int read_sysfs_float(const char *filename, const char *basedir, float *val)
 {
 	int ret = 0;
 	FILE  *sysfsfp;

commit 1e7c34788de3c0e5b18b6f27c42c191da5811c74
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:21 2015 +0200

    tools:iio:iio_utils: initialize count during declaration
    
    In build_channel_array(), count can be initialized already during variable
    declaration.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 7c0abb306f5a..dfee1a3f3f63 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -312,7 +312,7 @@ int build_channel_array(const char *device_dir,
 {
 	DIR *dp;
 	FILE *sysfsfp;
-	int count, i;
+	int count = 0, i;
 	struct iio_channel_info *current;
 	int ret;
 	const struct dirent *ent;
@@ -370,7 +370,6 @@ int build_channel_array(const char *device_dir,
 		goto error_close_dir;
 	}
 	seekdir(dp, 0);
-	count = 0;
 	while (ent = readdir(dp), ent != NULL) {
 		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
 			   "_en") == 0) {

commit ace76e42bcd5d67e5be303997a4dc325d44366ce
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:20 2015 +0200

    tools:iio:iio_utils: move up reset of sysfsfp
    
    In iioutils_get_type() it is logically better fitting to have sysfsfp
    assigned zero right after closing it.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index c83f4dfe71d6..7c0abb306f5a 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -175,10 +175,10 @@ int iioutils_get_type(unsigned *is_signed,
 				goto error_free_filename;
 			}
 
+			sysfsfp = 0;
 			free(filename);
 
 			filename = 0;
-			sysfsfp = 0;
 		}
 error_close_sysfsfp:
 	if (sysfsfp)

commit 33ebcb21a67f257faf1128f08a6d7c0299cb0da2
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:19 2015 +0200

    tools:iio:iio_utils: refactor assignment of is_signed
    
    Change the assignment of *is_signed in iioutils_get_type() to a one-liner,
    as already done with *be.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 0524725279bb..c83f4dfe71d6 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -168,10 +168,7 @@ int iioutils_get_type(unsigned *is_signed,
 				*mask = ~0;
 			else
 				*mask = (1 << *bits_used) - 1;
-			if (signchar == 's')
-				*is_signed = 1;
-			else
-				*is_signed = 0;
+			*is_signed = (signchar == 's');
 			if (fclose(sysfsfp)) {
 				ret = -errno;
 				printf("Failed to close %s\n", filename);

commit 0e799878175aa7d08f5882b6a391de4724c52e9e
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:17 2015 +0200

    tools:iio: return values directly
    
    Return directly, if no common cleanup is required.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 5d5831d7dfd0..0524725279bb 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -107,10 +107,9 @@ int iioutils_get_type(unsigned *is_signed,
 	const struct dirent *ent;
 
 	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
-	if (ret < 0) {
-		ret = -ENOMEM;
-		goto error_ret;
-	}
+	if (ret < 0)
+		return -ENOMEM;
+
 	ret = asprintf(&builtname, FORMAT_TYPE_FILE, name);
 	if (ret < 0) {
 		ret = -ENOMEM;
@@ -202,7 +201,7 @@ int iioutils_get_type(unsigned *is_signed,
 	free(builtname);
 error_free_scan_el_dir:
 	free(scan_el_dir);
-error_ret:
+
 	return ret;
 }
 
@@ -230,10 +229,9 @@ int iioutils_get_param_float(float *output,
 	const struct dirent *ent;
 
 	ret = asprintf(&builtname, "%s_%s", name, param_name);
-	if (ret < 0) {
-		ret = -ENOMEM;
-		goto error_ret;
-	}
+	if (ret < 0)
+		return -ENOMEM;
+
 	ret = asprintf(&builtname_generic,
 		       "%s_%s", generic_name, param_name);
 	if (ret < 0) {
@@ -277,7 +275,7 @@ int iioutils_get_param_float(float *output,
 	free(builtname_generic);
 error_free_builtname:
 	free(builtname);
-error_ret:
+
 	return ret;
 }
 
@@ -326,10 +324,9 @@ int build_channel_array(const char *device_dir,
 
 	*counter = 0;
 	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
-	if (ret < 0) {
-		ret = -ENOMEM;
-		goto error_ret;
-	}
+	if (ret < 0)
+		return -ENOMEM;
+
 	dp = opendir(scan_el_dir);
 	if (dp == NULL) {
 		ret = -errno;
@@ -526,7 +523,7 @@ int build_channel_array(const char *device_dir,
 
 error_free_name:
 	free(scan_el_dir);
-error_ret:
+
 	return ret;
 }
 

commit 5dc65d791ddafc9f6d944391e379708b6056fc48
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:16 2015 +0200

    tools:iio:iio_utils: add missing documentation
    
    Fully document public functions and elements.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index e1828d0d8a38..5d5831d7dfd0 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -29,6 +29,8 @@ static char * const iio_direction[] = {
  * iioutils_break_up_name() - extract generic name from full channel name
  * @full_name: the full channel name
  * @generic_name: the output generic channel name
+ *
+ * Returns 0 on success, or a negative error code if string extraction failed.
  **/
 int iioutils_break_up_name(const char *full_name,
 				  char **generic_name)
@@ -76,11 +78,15 @@ int iioutils_break_up_name(const char *full_name,
  * iioutils_get_type() - find and process _type attribute data
  * @is_signed: output whether channel is signed
  * @bytes: output how many bytes the channel storage occupies
+ * @bits_used: output number of valid bits of data
+ * @shift: output amount of bits to shift right data before applying bit mask
  * @mask: output a bit mask for the raw data
- * @be: big endian
- * @device_dir: the iio device directory
+ * @be: output if data in big endian
+ * @device_dir: the IIO device directory
  * @name: the channel name
  * @generic_name: the channel type name
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
  **/
 int iioutils_get_type(unsigned *is_signed,
 			     unsigned *bytes,
@@ -200,6 +206,16 @@ int iioutils_get_type(unsigned *is_signed,
 	return ret;
 }
 
+/**
+ * iioutils_get_param_float() - read a float value from a channel parameter
+ * @output: output the float value
+ * @param_name: the parameter name to read
+ * @device_dir: the IIO device directory in sysfs
+ * @name: the channel name
+ * @generic_name: the channel type name
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int iioutils_get_param_float(float *output,
 				    const char *param_name,
 				    const char *device_dir,
@@ -266,8 +282,9 @@ int iioutils_get_param_float(float *output,
 }
 
 /**
- * bsort_channel_array_by_index() - reorder so that the array is in index order
- *
+ * bsort_channel_array_by_index() - sort the array in index order
+ * @ci_array: the iio_channel_info array to be sorted
+ * @cnt: the amount of array elements
  **/
 
 void bsort_channel_array_by_index(struct iio_channel_info **ci_array,
@@ -289,7 +306,10 @@ void bsort_channel_array_by_index(struct iio_channel_info **ci_array,
 /**
  * build_channel_array() - function to figure out what channels are present
  * @device_dir: the IIO device directory in sysfs
- * @
+ * @ci_array: output the resulting array of iio_channel_info
+ * @counter: output the amount of array elements
+ *
+ * Returns 0 on success, otherwise a negative error code.
  **/
 int build_channel_array(const char *device_dir,
 			      struct iio_channel_info **ci_array,
@@ -525,8 +545,10 @@ int calc_digits(int num)
 /**
  * find_type_by_name() - function to match top level types by name
  * @name: top level type instance name
- * @type: the type of top level instance being sort
+ * @type: the type of top level instance being searched
  *
+ * Returns the device number of a matched IIO device on success, otherwise a
+ * negative error code.
  * Typical types this is used for are device and trigger.
  **/
 int find_type_by_name(const char *name, const char *type)
@@ -684,11 +706,28 @@ static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 	return ret;
 }
 
+/**
+ * write_sysfs_int() - write an integer value to a sysfs file
+ * @filename: name of the file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: integer value to write to file
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int write_sysfs_int(char *filename, char *basedir, int val)
 {
 	return _write_sysfs_int(filename, basedir, val, 0);
 }
 
+/**
+ * write_sysfs_int_and_verify() - write an integer value to a sysfs file
+ *				  and verify
+ * @filename: name of the file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: integer value to write to file
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int write_sysfs_int_and_verify(char *filename, char *basedir, int val)
 {
 	return _write_sysfs_int(filename, basedir, val, 1);
@@ -770,17 +809,35 @@ static int _write_sysfs_string(char *filename, char *basedir, char *val,
  * @filename: name of file to write to
  * @basedir: the sysfs directory in which the file is to be found
  * @val: the string to write
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
  **/
 int write_sysfs_string_and_verify(char *filename, char *basedir, char *val)
 {
 	return _write_sysfs_string(filename, basedir, val, 1);
 }
 
+/**
+ * write_sysfs_string() - write string to a sysfs file
+ * @filename: name of file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: the string to write
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int write_sysfs_string(char *filename, char *basedir, char *val)
 {
 	return _write_sysfs_string(filename, basedir, val, 0);
 }
 
+/**
+ * read_sysfs_posint() - read an integer value from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ *
+ * Returns the read integer value >= 0 on success, otherwise a negative error
+ * code.
+ **/
 int read_sysfs_posint(char *filename, char *basedir)
 {
 	int ret;
@@ -817,6 +874,14 @@ int read_sysfs_posint(char *filename, char *basedir)
 	return ret;
 }
 
+/**
+ * read_sysfs_float() - read a float value from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: output the read float value
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int read_sysfs_float(char *filename, char *basedir, float *val)
 {
 	int ret = 0;
@@ -853,6 +918,14 @@ int read_sysfs_float(char *filename, char *basedir, float *val)
 	return ret;
 }
 
+/**
+ * read_sysfs_string() - read a string from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ * @str: output the read string
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
 int read_sysfs_string(const char *filename, const char *basedir, char *str)
 {
 	int ret = 0;

commit 53118557b6a9c263e4a80825da367b2116529541
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:14 2015 +0200

    tools:iio:iio_utils: add error handling
    
    Add error handling to calls which can indicate a major problem by
    returning an error code.
    This also sets ret to -ENOENT in iioutils_get_type() and
    iioutils_get_param_float() to indicate if no matching directory entry was
    found.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index f0896f46847f..e1828d0d8a38 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -50,6 +50,10 @@ int iioutils_break_up_name(const char *full_name,
 		return -ENOMEM;
 
 	working = strtok(current, "_\0");
+	if (!working) {
+		free(current);
+		return -EINVAL;
+	}
 
 	w = working;
 	r = working;
@@ -117,6 +121,7 @@ int iioutils_get_type(unsigned *is_signed,
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
+	ret = -ENOENT;
 	while (ent = readdir(dp), ent != NULL)
 		/*
 		 * Do we allow devices to override a generic name with
@@ -162,7 +167,12 @@ int iioutils_get_type(unsigned *is_signed,
 				*is_signed = 1;
 			else
 				*is_signed = 0;
-			fclose(sysfsfp);
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				printf("Failed to close %s\n", filename);
+				goto error_free_filename;
+			}
+
 			free(filename);
 
 			filename = 0;
@@ -170,12 +180,16 @@ int iioutils_get_type(unsigned *is_signed,
 		}
 error_close_sysfsfp:
 	if (sysfsfp)
-		fclose(sysfsfp);
+		if (fclose(sysfsfp))
+			perror("iioutils_get_type(): Failed to close file");
+
 error_free_filename:
 	if (filename)
 		free(filename);
 error_closedir:
-	closedir(dp);
+	if (closedir(dp) == -1)
+		perror("iioutils_get_type(): Failed to close directory");
+
 error_free_builtname_generic:
 	free(builtname_generic);
 error_free_builtname:
@@ -215,6 +229,7 @@ int iioutils_get_param_float(float *output,
 		ret = -errno;
 		goto error_free_builtname_generic;
 	}
+	ret = -ENOENT;
 	while (ent = readdir(dp), ent != NULL)
 		if ((strcmp(builtname, ent->d_name) == 0) ||
 		    (strcmp(builtname_generic, ent->d_name) == 0)) {
@@ -229,14 +244,19 @@ int iioutils_get_param_float(float *output,
 				ret = -errno;
 				goto error_free_filename;
 			}
-			fscanf(sysfsfp, "%f", output);
+			errno = 0;
+			if (fscanf(sysfsfp, "%f", output) != 1)
+				ret = errno ? -errno : -ENODATA;
+
 			break;
 		}
 error_free_filename:
 	if (filename)
 		free(filename);
 error_closedir:
-	closedir(dp);
+	if (closedir(dp) == -1)
+		perror("iioutils_get_param_float(): Failed to close directory");
+
 error_free_builtname_generic:
 	free(builtname_generic);
 error_free_builtname:
@@ -310,10 +330,24 @@ int build_channel_array(const char *device_dir,
 				free(filename);
 				goto error_close_dir;
 			}
-			fscanf(sysfsfp, "%i", &ret);
+			errno = 0;
+			if (fscanf(sysfsfp, "%i", &ret) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				if (fclose(sysfsfp))
+					perror("build_channel_array(): Failed to close file");
+
+				free(filename);
+				goto error_close_dir;
+			}
+
 			if (ret == 1)
 				(*counter)++;
-			fclose(sysfsfp);
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				goto error_close_dir;
+			}
+
 			free(filename);
 		}
 	*ci_array = malloc(sizeof(**ci_array) * (*counter));
@@ -344,8 +378,20 @@ int build_channel_array(const char *device_dir,
 				count--;
 				goto error_cleanup_array;
 			}
-			fscanf(sysfsfp, "%i", &current_enabled);
-			fclose(sysfsfp);
+			errno = 0;
+			if (fscanf(sysfsfp, "%i", &current_enabled) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				free(filename);
+				count--;
+				goto error_cleanup_array;
+			}
+
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				count--;
+				goto error_cleanup_array;
+			}
 
 			if (!current_enabled) {
 				free(filename);
@@ -383,8 +429,29 @@ int build_channel_array(const char *device_dir,
 				goto error_cleanup_array;
 			}
 			sysfsfp = fopen(filename, "r");
-			fscanf(sysfsfp, "%u", &current->index);
-			fclose(sysfsfp);
+			if (sysfsfp == NULL) {
+				ret = -errno;
+				printf("failed to open %s\n", filename);
+				free(filename);
+				goto error_cleanup_array;
+			}
+
+			errno = 0;
+			if (fscanf(sysfsfp, "%u", &current->index) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				if (fclose(sysfsfp))
+					perror("build_channel_array(): Failed to close file");
+
+				free(filename);
+				goto error_cleanup_array;
+			}
+
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				goto error_cleanup_array;
+			}
+
 			free(filename);
 			/* Find the scale */
 			ret = iioutils_get_param_float(&current->scale,
@@ -410,10 +477,16 @@ int build_channel_array(const char *device_dir,
 						device_dir,
 						current->name,
 						current->generic_name);
+			if (ret < 0)
+				goto error_cleanup_array;
 		}
 	}
 
-	closedir(dp);
+	if (closedir(dp) == -1) {
+		ret = -errno;
+		goto error_cleanup_array;
+	}
+
 	free(scan_el_dir);
 	/* reorder so that the array is in index order */
 	bsort_channel_array_by_index(ci_array, *counter);
@@ -427,7 +500,10 @@ int build_channel_array(const char *device_dir,
 	}
 	free(*ci_array);
 error_close_dir:
-	closedir(dp);
+	if (dp)
+		if (closedir(dp) == -1)
+			perror("build_channel_array(): Failed to close dir");
+
 error_free_name:
 	free(scan_el_dir);
 error_ret:
@@ -496,29 +572,45 @@ int find_type_by_name(const char *name, const char *type)
 						+ numstrlen
 						+ 6);
 				if (filename == NULL) {
-					closedir(dp);
-					return -ENOMEM;
+					ret = -ENOMEM;
+					goto error_close_dir;
+				}
+
+				ret = sprintf(filename, "%s%s%d/name", iio_dir,
+					      type, number);
+				if (ret < 0) {
+					free(filename);
+					goto error_close_dir;
 				}
-				sprintf(filename, "%s%s%d/name",
-					iio_dir,
-					type,
-					number);
+
 				nameFile = fopen(filename, "r");
 				if (!nameFile) {
 					free(filename);
 					continue;
 				}
 				free(filename);
-				fscanf(nameFile, "%s", thisname);
-				fclose(nameFile);
+				errno = 0;
+				if (fscanf(nameFile, "%s", thisname) != 1) {
+					ret = errno ? -errno : -ENODATA;
+					goto error_close_dir;
+				}
+
+				if (fclose(nameFile)) {
+					ret = -errno;
+					goto error_close_dir;
+				}
+
 				if (strcmp(name, thisname) == 0) {
-					closedir(dp);
+					if (closedir(dp) == -1)
+						return -errno;
 					return number;
 				}
 			}
 		}
 	}
-	closedir(dp);
+	if (closedir(dp) == -1)
+		return -errno;
+
 	return -ENODEV;
 
 error_close_dir:
@@ -536,15 +628,29 @@ static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 
 	if (temp == NULL)
 		return -ENOMEM;
-	sprintf(temp, "%s/%s", basedir, filename);
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
 	sysfsfp = fopen(temp, "w");
 	if (sysfsfp == NULL) {
 		ret = -errno;
 		printf("failed to open %s\n", temp);
 		goto error_free;
 	}
-	fprintf(sysfsfp, "%d", val);
-	fclose(sysfsfp);
+	ret = fprintf(sysfsfp, "%d", val);
+	if (ret < 0) {
+		if (fclose(sysfsfp))
+			perror("_write_sysfs_int(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp)) {
+		ret = -errno;
+		goto error_free;
+	}
+
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
 		if (sysfsfp == NULL) {
@@ -552,8 +658,19 @@ static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 			printf("failed to open %s\n", temp);
 			goto error_free;
 		}
-		fscanf(sysfsfp, "%d", &test);
-		fclose(sysfsfp);
+		if (fscanf(sysfsfp, "%d", &test) != 1) {
+			ret = errno ? -errno : -ENODATA;
+			if (fclose(sysfsfp))
+				perror("_write_sysfs_int(): Failed to close dir");
+
+			goto error_free;
+		}
+
+		if (fclose(sysfsfp)) {
+			ret = -errno;
+			goto error_free;
+		}
+
 		if (test != val) {
 			printf("Possible failure in int write %d to %s%s\n",
 				val,
@@ -588,15 +705,29 @@ static int _write_sysfs_string(char *filename, char *basedir, char *val,
 		printf("Memory allocation failed\n");
 		return -ENOMEM;
 	}
-	sprintf(temp, "%s/%s", basedir, filename);
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
 	sysfsfp = fopen(temp, "w");
 	if (sysfsfp == NULL) {
 		ret = -errno;
 		printf("Could not open %s\n", temp);
 		goto error_free;
 	}
-	fprintf(sysfsfp, "%s", val);
-	fclose(sysfsfp);
+	ret = fprintf(sysfsfp, "%s", val);
+	if (ret < 0) {
+		if (fclose(sysfsfp))
+			perror("_write_sysfs_string(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp)) {
+		ret = -errno;
+		goto error_free;
+	}
+
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
 		if (sysfsfp == NULL) {
@@ -604,8 +735,19 @@ static int _write_sysfs_string(char *filename, char *basedir, char *val,
 			printf("could not open file to verify\n");
 			goto error_free;
 		}
-		fscanf(sysfsfp, "%s", temp);
-		fclose(sysfsfp);
+		if (fscanf(sysfsfp, "%s", temp) != 1) {
+			ret = errno ? -errno : -ENODATA;
+			if (fclose(sysfsfp))
+				perror("_write_sysfs_string(): Failed to close dir");
+
+			goto error_free;
+		}
+
+		if (fclose(sysfsfp)) {
+			ret = -errno;
+			goto error_free;
+		}
+
 		if (strcmp(temp, val) != 0) {
 			printf("Possible failure in string write of %s "
 				"Should be %s "
@@ -649,14 +791,27 @@ int read_sysfs_posint(char *filename, char *basedir)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
-	sprintf(temp, "%s/%s", basedir, filename);
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
 	sysfsfp = fopen(temp, "r");
 	if (sysfsfp == NULL) {
 		ret = -errno;
 		goto error_free;
 	}
-	fscanf(sysfsfp, "%d\n", &ret);
-	fclose(sysfsfp);
+	errno = 0;
+	if (fscanf(sysfsfp, "%d\n", &ret) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_posint(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
 error_free:
 	free(temp);
 	return ret;
@@ -672,14 +827,27 @@ int read_sysfs_float(char *filename, char *basedir, float *val)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
-	sprintf(temp, "%s/%s", basedir, filename);
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
 	sysfsfp = fopen(temp, "r");
 	if (sysfsfp == NULL) {
 		ret = -errno;
 		goto error_free;
 	}
-	fscanf(sysfsfp, "%f\n", val);
-	fclose(sysfsfp);
+	errno = 0;
+	if (fscanf(sysfsfp, "%f\n", val) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_float(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
 error_free:
 	free(temp);
 	return ret;
@@ -695,14 +863,27 @@ int read_sysfs_string(const char *filename, const char *basedir, char *str)
 		printf("Memory allocation failed");
 		return -ENOMEM;
 	}
-	sprintf(temp, "%s/%s", basedir, filename);
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
 	sysfsfp = fopen(temp, "r");
 	if (sysfsfp == NULL) {
 		ret = -errno;
 		goto error_free;
 	}
-	fscanf(sysfsfp, "%s\n", str);
-	fclose(sysfsfp);
+	errno = 0;
+	if (fscanf(sysfsfp, "%s\n", str) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_string(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
 error_free:
 	free(temp);
 	return ret;

commit e9e45b43b8f06273d9b78f187042dff0bf5be0a5
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:02 2015 +0200

    tools:iio: catch errors in string allocation
    
    This patch catches errors in string allocation in generic_buffer.c,
    iio_event_monitor.c, iio_utils.c and lsiio.c.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 812153ff18c3..f0896f46847f 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -36,7 +36,7 @@ int iioutils_break_up_name(const char *full_name,
 	char *current;
 	char *w, *r;
 	char *working, *prefix = "";
-	int i;
+	int i, ret;
 
 	for (i = 0; i < sizeof(iio_direction) / sizeof(iio_direction[0]); i++)
 		if (!strncmp(full_name, iio_direction[i],
@@ -46,6 +46,9 @@ int iioutils_break_up_name(const char *full_name,
 		}
 
 	current = strdup(full_name + strlen(prefix) + 1);
+	if (!current)
+		return -ENOMEM;
+
 	working = strtok(current, "_\0");
 
 	w = working;
@@ -59,10 +62,10 @@ int iioutils_break_up_name(const char *full_name,
 		r++;
 	}
 	*w = '\0';
-	asprintf(generic_name, "%s_%s", prefix, working);
+	ret = asprintf(generic_name, "%s_%s", prefix, working);
 	free(current);
 
-	return 0;
+	return (ret == -1) ? -ENOMEM : 0;
 }
 
 /**

commit 2156b179993e3d5b422976181ba17d91153313e1
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:01 2015 +0200

    tools:iio:iio_utils: mark private function static
    
    Functions _write_sysfs_int() and _write_sysfs_string() are supposed to
    be called only by public wrappers, so make them static.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 60e5ec4165b7..812153ff18c3 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -524,7 +524,7 @@ int find_type_by_name(const char *name, const char *type)
 	return ret;
 }
 
-int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
+static int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 {
 	int ret = 0;
 	FILE *sysfsfp;
@@ -574,7 +574,8 @@ int write_sysfs_int_and_verify(char *filename, char *basedir, int val)
 	return _write_sysfs_int(filename, basedir, val, 1);
 }
 
-int _write_sysfs_string(char *filename, char *basedir, char *val, int verify)
+static int _write_sysfs_string(char *filename, char *basedir, char *val,
+			       int verify)
 {
 	int ret = 0;
 	FILE  *sysfsfp;

commit 096f9b862e605fe08bb30e4f7a381684a8ff82ed
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:40:00 2015 +0200

    tools:iio:iio_utils: implement digit calculation
    
    Previously, the return value of sscanf() was treated as an indication of
    the digits it would have read. Yet, sscanf() only returns the amount of
    valid matches.
    Therefore, introduce a function to calculate the decimal digits of the
    read number and use this one to commence a colon search, as originally
    intended.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index c5b4136e648a..60e5ec4165b7 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -431,6 +431,18 @@ int build_channel_array(const char *device_dir,
 	return ret;
 }
 
+int calc_digits(int num)
+{
+	int count = 0;
+
+	while (num != 0) {
+		num /= 10;
+		count++;
+	}
+
+	return count;
+}
+
 /**
  * find_type_by_name() - function to match top level types by name
  * @name: top level type instance name
@@ -441,7 +453,7 @@ int build_channel_array(const char *device_dir,
 int find_type_by_name(const char *name, const char *type)
 {
 	const struct dirent *ent;
-	int number, numstrlen;
+	int number, numstrlen, ret;
 
 	FILE *nameFile;
 	DIR *dp;
@@ -459,9 +471,19 @@ int find_type_by_name(const char *name, const char *type)
 			strcmp(ent->d_name, "..") != 0 &&
 			strlen(ent->d_name) > strlen(type) &&
 			strncmp(ent->d_name, type, strlen(type)) == 0) {
-			numstrlen = sscanf(ent->d_name + strlen(type),
-					   "%d",
-					   &number);
+			errno = 0;
+			ret = sscanf(ent->d_name + strlen(type), "%d", &number);
+			if (ret < 0) {
+				ret = -errno;
+				printf("failed to read element number\n");
+				goto error_close_dir;
+			} else if (ret != 1) {
+				ret = -EIO;
+				printf("failed to match element number\n");
+				goto error_close_dir;
+			}
+
+			numstrlen = calc_digits(number);
 			/* verify the next character is not a colon */
 			if (strncmp(ent->d_name + strlen(type) + numstrlen,
 					":",
@@ -495,6 +517,11 @@ int find_type_by_name(const char *name, const char *type)
 	}
 	closedir(dp);
 	return -ENODEV;
+
+error_close_dir:
+	if (closedir(dp) == -1)
+		perror("find_type_by_name(): Failed to close directory");
+	return ret;
 }
 
 int _write_sysfs_int(char *filename, char *basedir, int val, int verify)

commit dc8b5d6e633f8e54f70594d0be87aaf401ea0559
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:39:59 2015 +0200

    tools:iio:iio_utils: check amount of matches
    
    fscanf() usually returns the number of input items successfully matched
    and assigned, which can be fewer than provided (or even zero).
    Add a check in iioutils_get_type() to make sure all items are matched.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index f12bc2e81c80..c5b4136e648a 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -144,6 +144,10 @@ int iioutils_get_type(unsigned *is_signed,
 				ret = -errno;
 				printf("failed to pass scan type description\n");
 				goto error_close_sysfsfp;
+			} else if (ret != 5) {
+				ret = -EIO;
+				printf("scan type description didn't match\n");
+				goto error_close_sysfsfp;
 			}
 			*be = (endianchar == 'b');
 			*bytes = padint / 8;

commit 2b6a6e67af6f8f644a48f75efc1f44544c0d74f6
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:39:48 2015 +0200

    tools:iio: save errno first
    
    The man-page of errno states, that errno should be saved before doing any
    library call, as that call may have changed the value of errno. So, when
    encountering any error, save errno first.
    This patch affects generic_buffer.c, iio_event_monitor.c and iio_utils.c.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 1c0ca2f89e18..f12bc2e81c80 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -129,8 +129,8 @@ int iioutils_get_type(unsigned *is_signed,
 			}
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
-				printf("failed to open %s\n", filename);
 				ret = -errno;
+				printf("failed to open %s\n", filename);
 				goto error_free_filename;
 			}
 
@@ -141,8 +141,8 @@ int iioutils_get_type(unsigned *is_signed,
 				     bits_used,
 				     &padint, shift);
 			if (ret < 0) {
-				printf("failed to pass scan type description\n");
 				ret = -errno;
+				printf("failed to pass scan type description\n");
 				goto error_close_sysfsfp;
 			}
 			*be = (endianchar == 'b');
@@ -332,8 +332,8 @@ int build_channel_array(const char *device_dir,
 			}
 			sysfsfp = fopen(filename, "r");
 			if (sysfsfp == NULL) {
-				free(filename);
 				ret = -errno;
+				free(filename);
 				count--;
 				goto error_cleanup_array;
 			}
@@ -505,8 +505,8 @@ int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 	sprintf(temp, "%s/%s", basedir, filename);
 	sysfsfp = fopen(temp, "w");
 	if (sysfsfp == NULL) {
-		printf("failed to open %s\n", temp);
 		ret = -errno;
+		printf("failed to open %s\n", temp);
 		goto error_free;
 	}
 	fprintf(sysfsfp, "%d", val);
@@ -514,8 +514,8 @@ int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
 		if (sysfsfp == NULL) {
-			printf("failed to open %s\n", temp);
 			ret = -errno;
+			printf("failed to open %s\n", temp);
 			goto error_free;
 		}
 		fscanf(sysfsfp, "%d", &test);
@@ -556,8 +556,8 @@ int _write_sysfs_string(char *filename, char *basedir, char *val, int verify)
 	sprintf(temp, "%s/%s", basedir, filename);
 	sysfsfp = fopen(temp, "w");
 	if (sysfsfp == NULL) {
-		printf("Could not open %s\n", temp);
 		ret = -errno;
+		printf("Could not open %s\n", temp);
 		goto error_free;
 	}
 	fprintf(sysfsfp, "%s", val);
@@ -565,8 +565,8 @@ int _write_sysfs_string(char *filename, char *basedir, char *val, int verify)
 	if (verify) {
 		sysfsfp = fopen(temp, "r");
 		if (sysfsfp == NULL) {
-			printf("could not open file to verify\n");
 			ret = -errno;
+			printf("could not open file to verify\n");
 			goto error_free;
 		}
 		fscanf(sysfsfp, "%s", temp);

commit 121b5e505fe86ea52603c946865d658a5fe8130b
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:39:45 2015 +0200

    tools:iio:iio_utils: fix allocation handling
    
    In build_channel_array(), count needs to be decreased in more places since
    current->name and current->generic_name would be freed on the error path,
    although they have not been allocated, yet.
    This also requires to free current->name, when it is allocated, but
    current->generic_name is not yet allocated.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 6daf98fdde1a..1c0ca2f89e18 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -334,6 +334,7 @@ int build_channel_array(const char *device_dir,
 			if (sysfsfp == NULL) {
 				free(filename);
 				ret = -errno;
+				count--;
 				goto error_cleanup_array;
 			}
 			fscanf(sysfsfp, "%i", &current_enabled);
@@ -353,6 +354,7 @@ int build_channel_array(const char *device_dir,
 			if (current->name == NULL) {
 				free(filename);
 				ret = -ENOMEM;
+				count--;
 				goto error_cleanup_array;
 			}
 			/* Get the generic and specific name elements */
@@ -360,6 +362,8 @@ int build_channel_array(const char *device_dir,
 						     &current->generic_name);
 			if (ret) {
 				free(filename);
+				free(current->name);
+				count--;
 				goto error_cleanup_array;
 			}
 			ret = asprintf(&filename,

commit 63f05c855f3825b89b92cd21df0415e6e32af3dd
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:39:44 2015 +0200

    tools:iio: free channel-array completely
    
    In iio_utils.c build_channel_array() dynamically allocates the string
    generic_name in the current iio_channel_info, which doesn't got freed in
    case of an error.
    This dynamically allocated channel-array is used by generic_buffer, and
    needs to be freed on the error/exit path.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index f879ad7b88bc..6daf98fdde1a 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -410,8 +410,10 @@ int build_channel_array(const char *device_dir,
 	return 0;
 
 error_cleanup_array:
-	for (i = count - 1;  i >= 0; i--)
+	for (i = count - 1;  i >= 0; i--) {
 		free((*ci_array)[i].name);
+		free((*ci_array)[i].generic_name);
+	}
 	free(*ci_array);
 error_close_dir:
 	closedir(dp);

commit 66dd08fde06e5ad6f0f86c7a780d60973e9d9cf0
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Sun May 31 14:39:43 2015 +0200

    tools:iio:iio_utils: free scan_el_dir on exit
    
    In the error path, the string scan_el_dir got freed, while it was missing when
    build_channel_array() finished without errors.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 6f6452167b67..f879ad7b88bc 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -403,6 +403,7 @@ int build_channel_array(const char *device_dir,
 	}
 
 	closedir(dp);
+	free(scan_el_dir);
 	/* reorder so that the array is in index order */
 	bsort_channel_array_by_index(ci_array, *counter);
 

commit d9d7b990473889a17b0f54e860a65b141733799c
Author: Irina Tirdea <irina.tirdea@intel.com>
Date:   Fri Mar 27 13:53:00 2015 +0200

    tools: iio: generic_buffer: Fix generic scale extraction
    
    When using generic_buffer to read data, the scale is not properly
    detected for scale shared by type. This is caused by a problem
    with the generation of generic name out of the full name.
    E.g.: for current->name in_accel_z, the extracted generic name
    is "in" (when it should be "in_accel"). This is used in generic_buffer
    to generate scale and offset paths (in_accel_scale).
    
    Consider the in_ or out_ prefix when extracting the generic name
    from the full name.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
index 2680a2e0f113..6f6452167b67 100644
--- a/tools/iio/iio_utils.c
+++ b/tools/iio/iio_utils.c
@@ -20,6 +20,11 @@
 
 const char *iio_dir = "/sys/bus/iio/devices/";
 
+static char * const iio_direction[] = {
+	"in",
+	"out",
+};
+
 /**
  * iioutils_break_up_name() - extract generic name from full channel name
  * @full_name: the full channel name
@@ -30,10 +35,19 @@ int iioutils_break_up_name(const char *full_name,
 {
 	char *current;
 	char *w, *r;
-	char *working;
+	char *working, *prefix = "";
+	int i;
 
-	current = strdup(full_name);
+	for (i = 0; i < sizeof(iio_direction) / sizeof(iio_direction[0]); i++)
+		if (!strncmp(full_name, iio_direction[i],
+			     strlen(iio_direction[i]))) {
+			prefix = iio_direction[i];
+			break;
+		}
+
+	current = strdup(full_name + strlen(prefix) + 1);
 	working = strtok(current, "_\0");
+
 	w = working;
 	r = working;
 
@@ -45,7 +59,7 @@ int iioutils_break_up_name(const char *full_name,
 		r++;
 	}
 	*w = '\0';
-	*generic_name = strdup(working);
+	asprintf(generic_name, "%s_%s", prefix, working);
 	free(current);
 
 	return 0;

commit dc5f2c5f6aa159ebf4b29b169aa1f71cf98d3d6a
Merge: c754ff966d54 c0644160a8b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 24 22:53:52 2015 +0100

    Merge tag 'iio-for-4.1a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First set of new drivers, cleanups and functionality for IIO in the 4.1 cycle.
    
    New drivers
    * CM3323 color sensor.
    * MS5611 pressure and temperature sensor.
    
    New functionality
    * mup6050 - create mux clients for devices described via ACPI. The reasoning
         and approach taken in this patch are complex.  Basically there is no
         otherway of finding out what is there than by some esoteric look ups in
         the ACPI data.
    * cm3232 - PM support
    * itg3200 - suspend/resume support
    * mcp320x - add more ADCs to the kconfig to reflect what the driver supports
         (this patch and the bindings got left behind when the support was added
          a while back).
    
    Docs / utils
    * ti-adc128s052 - DT bindings.
    * mcp3422 - DT bindings.
    * mcp320x - DT bindings
    * ABI docs for event threshold scale attributes, in_magn_offset, proximity
      scan_element and thresh falling/rising values for accelerometers.  All
      elements long in use that have slipped by being explicitly documented.
    * Tidy up the tools previously in drivers/staging/iio/Documentation and move
      them out to /tools/iio. Yet another move that should have happened long ago.
      This time Roberta Dobrescu did the leg work.  Thanks!
    
    Core Cleanups
    * Export userspace IIO headers.  We should have done the appropriate header
      splitting a long time ago. Thanks to Daniel for sorting this out.
    
    * Refactor the registring of attributes for buffers to move all non-custom
      ones to a vector allowing easier additions to the current set in the future.
    
    Driver Cleanups
    * gpiod related cleanups.  Make use of the additional parameter to specify
            initial direciton to avoid extra code.
    * bmc150 - Various refactorings to reduce code repitition and prepare for
               hardware buffer support.  Some of these cleanups are good even
               without the new functionality.
    * kmx61 - direct use of index to an array avoiding a structure element which
              was always the index to an element in an array of that structure.
    * vf610 - avoid incorrect type for return from wait_for_completion_timeout.
    * gp2ap020a00f - use put_unaligned_le32 for slight code simplification.
    * ade7754 - improve error handling including suppressing some build warnings.
    * ade7759 - improve error handling including suppressing some build warnings.
    * hmc5843 - Long line and indentation fixes. Also some constifying of various
          constant data.
    * ade7854 - 80+ character line splitting.
    * ad2s1210 - fix wrong printf format string.
    * mxs-lradc - fix wrong printf format string.
    * ade7954-i2c - code alignment fixes and other trivial but worthwhile bits.
    * periodic rtc trigger - make the frequency type an unsigned int as it
      is always treated as such.
    * jsa1212 - constify struct regmap_config as it is constant.
    * ad7793 - typo in the MODULE_DESCRIPTION
    * mma9551 - check gpiod_to_irq errors.  Note that this doesn't actually cause
        any trouble but is worth tidying up as obviously incorrect.
    * mlx90614 - refactor the register symbols to make it clear which reads are to
        RAM not PROM.

commit 817020cfb3a2649064a1e14e083934234e2c208d
Author: Roberta Dobrescu <roberta.dobrescu@gmail.com>
Date:   Thu Feb 26 10:49:25 2015 +0200

    iio: Move iio userspace applications out of staging
    
    This patch moves iio userspace applications out of staging, to tools/iio/
    and adds a Makefile in order to compile them easily. It also adds tools/iio/
    to MAINTAINERS file.
    
    Signed-off-by: Roberta Dobrescu <roberta.dobrescu@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/tools/iio/iio_utils.c b/tools/iio/iio_utils.c
new file mode 100644
index 000000000000..aea928210187
--- /dev/null
+++ b/tools/iio/iio_utils.c
@@ -0,0 +1,651 @@
+/* IIO - useful set of util functionality
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <dirent.h>
+#include <errno.h>
+#include <ctype.h>
+#include "iio_utils.h"
+
+const char *iio_dir = "/sys/bus/iio/devices/";
+
+/**
+ * iioutils_break_up_name() - extract generic name from full channel name
+ * @full_name: the full channel name
+ * @generic_name: the output generic channel name
+ **/
+int iioutils_break_up_name(const char *full_name,
+				  char **generic_name)
+{
+	char *current;
+	char *w, *r;
+	char *working;
+
+	current = strdup(full_name);
+	working = strtok(current, "_\0");
+	w = working;
+	r = working;
+
+	while (*r != '\0') {
+		if (!isdigit(*r)) {
+			*w = *r;
+			w++;
+		}
+		r++;
+	}
+	*w = '\0';
+	*generic_name = strdup(working);
+	free(current);
+
+	return 0;
+}
+
+/**
+ * iioutils_get_type() - find and process _type attribute data
+ * @is_signed: output whether channel is signed
+ * @bytes: output how many bytes the channel storage occupies
+ * @mask: output a bit mask for the raw data
+ * @be: big endian
+ * @device_dir: the iio device directory
+ * @name: the channel name
+ * @generic_name: the channel type name
+ **/
+int iioutils_get_type(unsigned *is_signed,
+			     unsigned *bytes,
+			     unsigned *bits_used,
+			     unsigned *shift,
+			     uint64_t *mask,
+			     unsigned *be,
+			     const char *device_dir,
+			     const char *name,
+			     const char *generic_name)
+{
+	FILE *sysfsfp;
+	int ret;
+	DIR *dp;
+	char *scan_el_dir, *builtname, *builtname_generic, *filename = 0;
+	char signchar, endianchar;
+	unsigned padint;
+	const struct dirent *ent;
+
+	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+	ret = asprintf(&builtname, FORMAT_TYPE_FILE, name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_scan_el_dir;
+	}
+	ret = asprintf(&builtname_generic, FORMAT_TYPE_FILE, generic_name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_builtname;
+	}
+
+	dp = opendir(scan_el_dir);
+	if (dp == NULL) {
+		ret = -errno;
+		goto error_free_builtname_generic;
+	}
+	while (ent = readdir(dp), ent != NULL)
+		/*
+		 * Do we allow devices to override a generic name with
+		 * a specific one?
+		 */
+		if ((strcmp(builtname, ent->d_name) == 0) ||
+		    (strcmp(builtname_generic, ent->d_name) == 0)) {
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_closedir;
+			}
+			sysfsfp = fopen(filename, "r");
+			if (sysfsfp == NULL) {
+				printf("failed to open %s\n", filename);
+				ret = -errno;
+				goto error_free_filename;
+			}
+
+			ret = fscanf(sysfsfp,
+				     "%ce:%c%u/%u>>%u",
+				     &endianchar,
+				     &signchar,
+				     bits_used,
+				     &padint, shift);
+			if (ret < 0) {
+				printf("failed to pass scan type description\n");
+				ret = -errno;
+				goto error_close_sysfsfp;
+			}
+			*be = (endianchar == 'b');
+			*bytes = padint / 8;
+			if (*bits_used == 64)
+				*mask = ~0;
+			else
+				*mask = (1 << *bits_used) - 1;
+			if (signchar == 's')
+				*is_signed = 1;
+			else
+				*is_signed = 0;
+			fclose(sysfsfp);
+			free(filename);
+
+			filename = 0;
+			sysfsfp = 0;
+		}
+error_close_sysfsfp:
+	if (sysfsfp)
+		fclose(sysfsfp);
+error_free_filename:
+	if (filename)
+		free(filename);
+error_closedir:
+	closedir(dp);
+error_free_builtname_generic:
+	free(builtname_generic);
+error_free_builtname:
+	free(builtname);
+error_free_scan_el_dir:
+	free(scan_el_dir);
+error_ret:
+	return ret;
+}
+
+int iioutils_get_param_float(float *output,
+				    const char *param_name,
+				    const char *device_dir,
+				    const char *name,
+				    const char *generic_name)
+{
+	FILE *sysfsfp;
+	int ret;
+	DIR *dp;
+	char *builtname, *builtname_generic;
+	char *filename = NULL;
+	const struct dirent *ent;
+
+	ret = asprintf(&builtname, "%s_%s", name, param_name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+	ret = asprintf(&builtname_generic,
+		       "%s_%s", generic_name, param_name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_builtname;
+	}
+	dp = opendir(device_dir);
+	if (dp == NULL) {
+		ret = -errno;
+		goto error_free_builtname_generic;
+	}
+	while (ent = readdir(dp), ent != NULL)
+		if ((strcmp(builtname, ent->d_name) == 0) ||
+		    (strcmp(builtname_generic, ent->d_name) == 0)) {
+			ret = asprintf(&filename,
+				       "%s/%s", device_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_closedir;
+			}
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				goto error_free_filename;
+			}
+			fscanf(sysfsfp, "%f", output);
+			break;
+		}
+error_free_filename:
+	if (filename)
+		free(filename);
+error_closedir:
+	closedir(dp);
+error_free_builtname_generic:
+	free(builtname_generic);
+error_free_builtname:
+	free(builtname);
+error_ret:
+	return ret;
+}
+
+/**
+ * bsort_channel_array_by_index() - reorder so that the array is in index order
+ *
+ **/
+
+void bsort_channel_array_by_index(struct iio_channel_info **ci_array,
+					 int cnt)
+{
+
+	struct iio_channel_info temp;
+	int x, y;
+
+	for (x = 0; x < cnt; x++)
+		for (y = 0; y < (cnt - 1); y++)
+			if ((*ci_array)[y].index > (*ci_array)[y+1].index) {
+				temp = (*ci_array)[y + 1];
+				(*ci_array)[y + 1] = (*ci_array)[y];
+				(*ci_array)[y] = temp;
+			}
+}
+
+/**
+ * build_channel_array() - function to figure out what channels are present
+ * @device_dir: the IIO device directory in sysfs
+ * @
+ **/
+int build_channel_array(const char *device_dir,
+			      struct iio_channel_info **ci_array,
+			      int *counter)
+{
+	DIR *dp;
+	FILE *sysfsfp;
+	int count, i;
+	struct iio_channel_info *current;
+	int ret;
+	const struct dirent *ent;
+	char *scan_el_dir;
+	char *filename;
+
+	*counter = 0;
+	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+	dp = opendir(scan_el_dir);
+	if (dp == NULL) {
+		ret = -errno;
+		goto error_free_name;
+	}
+	while (ent = readdir(dp), ent != NULL)
+		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
+			   "_en") == 0) {
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_close_dir;
+			}
+			sysfsfp = fopen(filename, "r");
+			if (sysfsfp == NULL) {
+				ret = -errno;
+				free(filename);
+				goto error_close_dir;
+			}
+			fscanf(sysfsfp, "%i", &ret);
+			if (ret == 1)
+				(*counter)++;
+			fclose(sysfsfp);
+			free(filename);
+		}
+	*ci_array = malloc(sizeof(**ci_array) * (*counter));
+	if (*ci_array == NULL) {
+		ret = -ENOMEM;
+		goto error_close_dir;
+	}
+	seekdir(dp, 0);
+	count = 0;
+	while (ent = readdir(dp), ent != NULL) {
+		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
+			   "_en") == 0) {
+			int current_enabled = 0;
+
+			current = &(*ci_array)[count++];
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				/* decrement count to avoid freeing name */
+				count--;
+				goto error_cleanup_array;
+			}
+			sysfsfp = fopen(filename, "r");
+			if (sysfsfp == NULL) {
+				free(filename);
+				ret = -errno;
+				goto error_cleanup_array;
+			}
+			fscanf(sysfsfp, "%i", &current_enabled);
+			fclose(sysfsfp);
+
+			if (!current_enabled) {
+				free(filename);
+				count--;
+				continue;
+			}
+
+			current->scale = 1.0;
+			current->offset = 0;
+			current->name = strndup(ent->d_name,
+						strlen(ent->d_name) -
+						strlen("_en"));
+			if (current->name == NULL) {
+				free(filename);
+				ret = -ENOMEM;
+				goto error_cleanup_array;
+			}
+			/* Get the generic and specific name elements */
+			ret = iioutils_break_up_name(current->name,
+						     &current->generic_name);
+			if (ret) {
+				free(filename);
+				goto error_cleanup_array;
+			}
+			ret = asprintf(&filename,
+				       "%s/%s_index",
+				       scan_el_dir,
+				       current->name);
+			if (ret < 0) {
+				free(filename);
+				ret = -ENOMEM;
+				goto error_cleanup_array;
+			}
+			sysfsfp = fopen(filename, "r");
+			fscanf(sysfsfp, "%u", &current->index);
+			fclose(sysfsfp);
+			free(filename);
+			/* Find the scale */
+			ret = iioutils_get_param_float(&current->scale,
+						       "scale",
+						       device_dir,
+						       current->name,
+						       current->generic_name);
+			if (ret < 0)
+				goto error_cleanup_array;
+			ret = iioutils_get_param_float(&current->offset,
+						       "offset",
+						       device_dir,
+						       current->name,
+						       current->generic_name);
+			if (ret < 0)
+				goto error_cleanup_array;
+			ret = iioutils_get_type(&current->is_signed,
+						&current->bytes,
+						&current->bits_used,
+						&current->shift,
+						&current->mask,
+						&current->be,
+						device_dir,
+						current->name,
+						current->generic_name);
+		}
+	}
+
+	closedir(dp);
+	/* reorder so that the array is in index order */
+	bsort_channel_array_by_index(ci_array, *counter);
+
+	return 0;
+
+error_cleanup_array:
+	for (i = count - 1;  i >= 0; i--)
+		free((*ci_array)[i].name);
+	free(*ci_array);
+error_close_dir:
+	closedir(dp);
+error_free_name:
+	free(scan_el_dir);
+error_ret:
+	return ret;
+}
+
+/**
+ * find_type_by_name() - function to match top level types by name
+ * @name: top level type instance name
+ * @type: the type of top level instance being sort
+ *
+ * Typical types this is used for are device and trigger.
+ **/
+int find_type_by_name(const char *name, const char *type)
+{
+	const struct dirent *ent;
+	int number, numstrlen;
+
+	FILE *nameFile;
+	DIR *dp;
+	char thisname[IIO_MAX_NAME_LENGTH];
+	char *filename;
+
+	dp = opendir(iio_dir);
+	if (dp == NULL) {
+		printf("No industrialio devices available\n");
+		return -ENODEV;
+	}
+
+	while (ent = readdir(dp), ent != NULL) {
+		if (strcmp(ent->d_name, ".") != 0 &&
+			strcmp(ent->d_name, "..") != 0 &&
+			strlen(ent->d_name) > strlen(type) &&
+			strncmp(ent->d_name, type, strlen(type)) == 0) {
+			numstrlen = sscanf(ent->d_name + strlen(type),
+					   "%d",
+					   &number);
+			/* verify the next character is not a colon */
+			if (strncmp(ent->d_name + strlen(type) + numstrlen,
+					":",
+					1) != 0) {
+				filename = malloc(strlen(iio_dir)
+						+ strlen(type)
+						+ numstrlen
+						+ 6);
+				if (filename == NULL) {
+					closedir(dp);
+					return -ENOMEM;
+				}
+				sprintf(filename, "%s%s%d/name",
+					iio_dir,
+					type,
+					number);
+				nameFile = fopen(filename, "r");
+				if (!nameFile) {
+					free(filename);
+					continue;
+				}
+				free(filename);
+				fscanf(nameFile, "%s", thisname);
+				fclose(nameFile);
+				if (strcmp(name, thisname) == 0) {
+					closedir(dp);
+					return number;
+				}
+			}
+		}
+	}
+	closedir(dp);
+	return -ENODEV;
+}
+
+int _write_sysfs_int(char *filename, char *basedir, int val, int verify)
+{
+	int ret = 0;
+	FILE *sysfsfp;
+	int test;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (temp == NULL)
+		return -ENOMEM;
+	sprintf(temp, "%s/%s", basedir, filename);
+	sysfsfp = fopen(temp, "w");
+	if (sysfsfp == NULL) {
+		printf("failed to open %s\n", temp);
+		ret = -errno;
+		goto error_free;
+	}
+	fprintf(sysfsfp, "%d", val);
+	fclose(sysfsfp);
+	if (verify) {
+		sysfsfp = fopen(temp, "r");
+		if (sysfsfp == NULL) {
+			printf("failed to open %s\n", temp);
+			ret = -errno;
+			goto error_free;
+		}
+		fscanf(sysfsfp, "%d", &test);
+		fclose(sysfsfp);
+		if (test != val) {
+			printf("Possible failure in int write %d to %s%s\n",
+				val,
+				basedir,
+				filename);
+			ret = -1;
+		}
+	}
+error_free:
+	free(temp);
+	return ret;
+}
+
+int write_sysfs_int(char *filename, char *basedir, int val)
+{
+	return _write_sysfs_int(filename, basedir, val, 0);
+}
+
+int write_sysfs_int_and_verify(char *filename, char *basedir, int val)
+{
+	return _write_sysfs_int(filename, basedir, val, 1);
+}
+
+int _write_sysfs_string(char *filename, char *basedir, char *val, int verify)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (temp == NULL) {
+		printf("Memory allocation failed\n");
+		return -ENOMEM;
+	}
+	sprintf(temp, "%s/%s", basedir, filename);
+	sysfsfp = fopen(temp, "w");
+	if (sysfsfp == NULL) {
+		printf("Could not open %s\n", temp);
+		ret = -errno;
+		goto error_free;
+	}
+	fprintf(sysfsfp, "%s", val);
+	fclose(sysfsfp);
+	if (verify) {
+		sysfsfp = fopen(temp, "r");
+		if (sysfsfp == NULL) {
+			printf("could not open file to verify\n");
+			ret = -errno;
+			goto error_free;
+		}
+		fscanf(sysfsfp, "%s", temp);
+		fclose(sysfsfp);
+		if (strcmp(temp, val) != 0) {
+			printf("Possible failure in string write of %s "
+				"Should be %s "
+				"written to %s\%s\n",
+				temp,
+				val,
+				basedir,
+				filename);
+			ret = -1;
+		}
+	}
+error_free:
+	free(temp);
+
+	return ret;
+}
+
+/**
+ * write_sysfs_string_and_verify() - string write, readback and verify
+ * @filename: name of file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: the string to write
+ **/
+int write_sysfs_string_and_verify(char *filename, char *basedir, char *val)
+{
+	return _write_sysfs_string(filename, basedir, val, 1);
+}
+
+int write_sysfs_string(char *filename, char *basedir, char *val)
+{
+	return _write_sysfs_string(filename, basedir, val, 0);
+}
+
+int read_sysfs_posint(char *filename, char *basedir)
+{
+	int ret;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (temp == NULL) {
+		printf("Memory allocation failed");
+		return -ENOMEM;
+	}
+	sprintf(temp, "%s/%s", basedir, filename);
+	sysfsfp = fopen(temp, "r");
+	if (sysfsfp == NULL) {
+		ret = -errno;
+		goto error_free;
+	}
+	fscanf(sysfsfp, "%d\n", &ret);
+	fclose(sysfsfp);
+error_free:
+	free(temp);
+	return ret;
+}
+
+int read_sysfs_float(char *filename, char *basedir, float *val)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (temp == NULL) {
+		printf("Memory allocation failed");
+		return -ENOMEM;
+	}
+	sprintf(temp, "%s/%s", basedir, filename);
+	sysfsfp = fopen(temp, "r");
+	if (sysfsfp == NULL) {
+		ret = -errno;
+		goto error_free;
+	}
+	fscanf(sysfsfp, "%f\n", val);
+	fclose(sysfsfp);
+error_free:
+	free(temp);
+	return ret;
+}
+
+int read_sysfs_string(const char *filename, const char *basedir, char *str)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (temp == NULL) {
+		printf("Memory allocation failed");
+		return -ENOMEM;
+	}
+	sprintf(temp, "%s/%s", basedir, filename);
+	sysfsfp = fopen(temp, "r");
+	if (sysfsfp == NULL) {
+		ret = -errno;
+		goto error_free;
+	}
+	fscanf(sysfsfp, "%s\n", str);
+	fclose(sysfsfp);
+error_free:
+	free(temp);
+	return ret;
+}
