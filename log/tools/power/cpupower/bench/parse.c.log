commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 84caee38418f..e63dc11fa3a5 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*  cpufreq-bench CPUFreq microbenchmark
  *
  *  Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
 #include <stdio.h>

commit 8a7e2d2ea080d10a189a1d611344b0330468ebc3
Author: Anders Roxell <anders.roxell@linaro.org>
Date:   Tue Aug 28 11:31:18 2018 +0200

    cpupower: remove stringop-truncation waring
    
    The strncpy doesn't null terminate the string because the size is too
    short by one byte.
    
    parse.c: In function ‘prepare_default_config’:
    parse.c:148:2: warning: ‘strncpy’ output truncated before terminating
        nul copying 8 bytes from a string of the same length
        [-Wstringop-truncation]
      strncpy(config->governor, "ondemand", 8);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    The normal method of passing the length of the destination buffer works
    correctly here.
    
    Fixes: 7fe2f6399a84 ("cpupowerutils - cpufrequtils extended with quite some features")
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 9ba8a44ad2a7..84caee38418f 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -145,7 +145,7 @@ struct config *prepare_default_config()
 	config->cpu = 0;
 	config->prio = SCHED_HIGH;
 	config->verbose = 0;
-	strncpy(config->governor, "ondemand", 8);
+	strncpy(config->governor, "ondemand", sizeof(config->governor));
 
 	config->output = stdout;
 

commit 9fd0c40451468754754271ba0cbb63b6927911df
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu May 3 10:09:10 2018 +0100

    cpupower: fix spelling mistake: "logilename" -> "logfilename"
    
    Trivial fix to spelling mistake in dprintf message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 9b65f052081f..9ba8a44ad2a7 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -104,7 +104,7 @@ FILE *prepare_output(const char *dirname)
 			dirname, time(NULL));
 	}
 
-	dprintf("logilename: %s\n", filename);
+	dprintf("logfilename: %s\n", filename);
 
 	output = fopen(filename, "w+");
 	if (output == NULL) {

commit 0b81561c1d30bb44e65d3725042e27b548bb1a86
Author: Arjun Sreedharan <arjun024@gmail.com>
Date:   Fri Apr 29 09:00:14 2016 +0200

    cpupower: fix potential memory leak
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 2d09c9221ff1..9b65f052081f 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -65,7 +65,7 @@ FILE *prepare_output(const char *dirname)
 {
 	FILE *output = NULL;
 	int len;
-	char *filename;
+	char *filename, *filename_tmp;
 	struct utsname sysdata;
 	DIR *dir;
 
@@ -88,13 +88,15 @@ FILE *prepare_output(const char *dirname)
 
 	if (uname(&sysdata) == 0) {
 		len += strlen(sysdata.nodename) + strlen(sysdata.release);
-		filename = realloc(filename, sizeof(char) * len);
+		filename_tmp = realloc(filename, sizeof(*filename) * len);
 
-		if (!filename) {
+		if (filename_tmp == NULL) {
+			free(filename);
 			perror("realloc");
 			goto out_dir;
 		}
 
+		filename = filename_tmp;
 		snprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log",
 			dirname, sysdata.nodename, sysdata.release, time(NULL));
 	} else {

commit 983d9e065b37dac5aaa2d5a819bdd5b5a0b78c8c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Apr 28 15:24:37 2016 +0200

    cpupower: bench: parse.c: fix several resource leaks
    
    The error handling in prepare_output has several issues with
    resource leaks.  Ensure that filename is free'd and the directory
    stream DIR is closed before returning.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index f503fb53824e..2d09c9221ff1 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -81,14 +81,18 @@ FILE *prepare_output(const char *dirname)
 
 	len = strlen(dirname) + 30;
 	filename = malloc(sizeof(char) * len);
+	if (!filename) {
+		perror("malloc");
+		goto out_dir;
+	}
 
 	if (uname(&sysdata) == 0) {
 		len += strlen(sysdata.nodename) + strlen(sysdata.release);
 		filename = realloc(filename, sizeof(char) * len);
 
-		if (filename == NULL) {
+		if (!filename) {
 			perror("realloc");
-			return NULL;
+			goto out_dir;
 		}
 
 		snprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log",
@@ -104,12 +108,16 @@ FILE *prepare_output(const char *dirname)
 	if (output == NULL) {
 		perror("fopen");
 		fprintf(stderr, "error: unable to open logfile\n");
+		goto out;
 	}
 
 	fprintf(stdout, "Logfile: %s\n", filename);
 
-	free(filename);
 	fprintf(output, "#round load sleep performance powersave percentage\n");
+out:
+	free(filename);
+out_dir:
+	closedir(dir);
 	return output;
 }
 

commit 13f6de52b149c030b0d529a3d8d68267ed20f01c
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Tue Jul 29 18:12:19 2014 +0200

    cpupower: bench: parse.c: Fix several minor errors
    
    Resolved several minor errors in prepare_config() and made some additional improvements.
    Earlier, the risk of file stream that was not closed. Misuse of strncpy, and the use of strncmp with strlen that makes it pointless.
    I also check that sscanf has been successful, otherwise continue to the next line. And minimized the use of magic numbers.
    
    This was found using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 543bba14ae2c..f503fb53824e 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -158,14 +158,15 @@ struct config *prepare_default_config()
 int prepare_config(const char *path, struct config *config)
 {
 	size_t len = 0;
-	char *opt, *val, *line = NULL;
-	FILE *configfile = fopen(path, "r");
+	char opt[16], val[32], *line = NULL;
+	FILE *configfile;
 
 	if (config == NULL) {
 		fprintf(stderr, "error: config is NULL\n");
 		return 1;
 	}
 
+	configfile = fopen(path, "r");
 	if (configfile == NULL) {
 		perror("fopen");
 		fprintf(stderr, "error: unable to read configfile\n");
@@ -174,52 +175,54 @@ int prepare_config(const char *path, struct config *config)
 	}
 
 	while (getline(&line, &len, configfile) != -1) {
-		if (line[0] == '#' || line[0] == ' ')
+		if (line[0] == '#' || line[0] == ' ' || line[0] == '\n')
 			continue;
 
-		sscanf(line, "%as = %as", &opt, &val);
+		if (sscanf(line, "%14s = %30s", opt, val) < 2)
+			continue;
 
 		dprintf("parsing: %s -> %s\n", opt, val);
 
-		if (strncmp("sleep", opt, strlen(opt)) == 0)
+		if (strcmp("sleep", opt) == 0)
 			sscanf(val, "%li", &config->sleep);
 
-		else if (strncmp("load", opt, strlen(opt)) == 0)
+		else if (strcmp("load", opt) == 0)
 			sscanf(val, "%li", &config->load);
 
-		else if (strncmp("load_step", opt, strlen(opt)) == 0)
+		else if (strcmp("load_step", opt) == 0)
 			sscanf(val, "%li", &config->load_step);
 
-		else if (strncmp("sleep_step", opt, strlen(opt)) == 0)
+		else if (strcmp("sleep_step", opt) == 0)
 			sscanf(val, "%li", &config->sleep_step);
 
-		else if (strncmp("cycles", opt, strlen(opt)) == 0)
+		else if (strcmp("cycles", opt) == 0)
 			sscanf(val, "%u", &config->cycles);
 
-		else if (strncmp("rounds", opt, strlen(opt)) == 0)
+		else if (strcmp("rounds", opt) == 0)
 			sscanf(val, "%u", &config->rounds);
 
-		else if (strncmp("verbose", opt, strlen(opt)) == 0)
+		else if (strcmp("verbose", opt) == 0)
 			sscanf(val, "%u", &config->verbose);
 
-		else if (strncmp("output", opt, strlen(opt)) == 0)
+		else if (strcmp("output", opt) == 0)
 			config->output = prepare_output(val); 
 
-		else if (strncmp("cpu", opt, strlen(opt)) == 0)
+		else if (strcmp("cpu", opt) == 0)
 			sscanf(val, "%u", &config->cpu);
 
-		else if (strncmp("governor", opt, 14) == 0)
-			strncpy(config->governor, val, 14);
+		else if (strcmp("governor", opt) == 0) {
+			strncpy(config->governor, val,
+					sizeof(config->governor));
+			config->governor[sizeof(config->governor) - 1] = '\0';
+		}
 
-		else if (strncmp("priority", opt, strlen(opt)) == 0) {
+		else if (strcmp("priority", opt) == 0) {
 			if (string_to_prio(val) != SCHED_ERR)
 				config->prio = string_to_prio(val);
 		}
 	}
 
 	free(line);
-	free(opt);
-	free(val);
 
 	return 0;
 }

commit 02af3cb5aac13d8ef7edb7876260564b7d42ad2b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:20:12 2011 +0200

    cpupowerutils: bench - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
index 3b270ac92c46..543bba14ae2c 100644
--- a/tools/power/cpupower/bench/parse.c
+++ b/tools/power/cpupower/bench/parse.c
@@ -86,20 +86,22 @@ FILE *prepare_output(const char *dirname)
 		len += strlen(sysdata.nodename) + strlen(sysdata.release);
 		filename = realloc(filename, sizeof(char) * len);
 
-		if(filename == NULL) {
+		if (filename == NULL) {
 			perror("realloc");
 			return NULL;
 		}
 
-		snprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log", 
+		snprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log",
 			dirname, sysdata.nodename, sysdata.release, time(NULL));
 	} else {
-		snprintf(filename, len -1, "%s/benchmark_%li.log", dirname, time(NULL));
+		snprintf(filename, len - 1, "%s/benchmark_%li.log",
+			dirname, time(NULL));
 	}
 
 	dprintf("logilename: %s\n", filename);
 
-	if ((output = fopen(filename, "w+")) == NULL) {
+	output = fopen(filename, "w+");
+	if (output == NULL) {
 		perror("fopen");
 		fprintf(stderr, "error: unable to open logfile\n");
 	}
@@ -130,7 +132,7 @@ struct config *prepare_default_config()
 	config->load_step = 500000;
 	config->cycles = 5;
 	config->rounds = 50;
-	config->cpu = 0;	
+	config->cpu = 0;
 	config->prio = SCHED_HIGH;
 	config->verbose = 0;
 	strncpy(config->governor, "ondemand", 8);
@@ -166,13 +168,12 @@ int prepare_config(const char *path, struct config *config)
 
 	if (configfile == NULL) {
 		perror("fopen");
-                fprintf(stderr, "error: unable to read configfile\n");
+		fprintf(stderr, "error: unable to read configfile\n");
 		free(config);
 		return 1;
 	}
 
-	while (getline(&line, &len, configfile) != -1)
-	{
+	while (getline(&line, &len, configfile) != -1) {
 		if (line[0] == '#' || line[0] == ' ')
 			continue;
 
@@ -183,35 +184,35 @@ int prepare_config(const char *path, struct config *config)
 		if (strncmp("sleep", opt, strlen(opt)) == 0)
 			sscanf(val, "%li", &config->sleep);
 
-		else if (strncmp("load", opt, strlen(opt)) == 0) 
+		else if (strncmp("load", opt, strlen(opt)) == 0)
 			sscanf(val, "%li", &config->load);
 
-		else if (strncmp("load_step", opt, strlen(opt)) == 0) 
+		else if (strncmp("load_step", opt, strlen(opt)) == 0)
 			sscanf(val, "%li", &config->load_step);
 
-		else if (strncmp("sleep_step", opt, strlen(opt)) == 0) 
+		else if (strncmp("sleep_step", opt, strlen(opt)) == 0)
 			sscanf(val, "%li", &config->sleep_step);
 
-		else if (strncmp("cycles", opt, strlen(opt)) == 0) 
+		else if (strncmp("cycles", opt, strlen(opt)) == 0)
 			sscanf(val, "%u", &config->cycles);
 
-		else if (strncmp("rounds", opt, strlen(opt)) == 0) 
+		else if (strncmp("rounds", opt, strlen(opt)) == 0)
 			sscanf(val, "%u", &config->rounds);
 
-		else if (strncmp("verbose", opt, strlen(opt)) == 0) 
+		else if (strncmp("verbose", opt, strlen(opt)) == 0)
 			sscanf(val, "%u", &config->verbose);
 
-		else if (strncmp("output", opt, strlen(opt)) == 0) 
+		else if (strncmp("output", opt, strlen(opt)) == 0)
 			config->output = prepare_output(val); 
 
-		else if (strncmp("cpu", opt, strlen(opt)) == 0) 
+		else if (strncmp("cpu", opt, strlen(opt)) == 0)
 			sscanf(val, "%u", &config->cpu);
 
-		else if (strncmp("governor", opt, 14) == 0) 
+		else if (strncmp("governor", opt, 14) == 0)
 			strncpy(config->governor, val, 14);
 
 		else if (strncmp("priority", opt, strlen(opt)) == 0) {
-			if (string_to_prio(val) != SCHED_ERR) 
+			if (string_to_prio(val) != SCHED_ERR)
 				config->prio = string_to_prio(val);
 		}
 	}

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/bench/parse.c b/tools/power/cpupower/bench/parse.c
new file mode 100644
index 000000000000..3b270ac92c46
--- /dev/null
+++ b/tools/power/cpupower/bench/parse.c
@@ -0,0 +1,224 @@
+/*  cpufreq-bench CPUFreq microbenchmark
+ *
+ *  Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <dirent.h>
+
+#include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "parse.h"
+#include "config.h"
+
+/**
+ * converts priority string to priority
+ *
+ * @param str string that represents a scheduler priority
+ *
+ * @retval priority
+ * @retval SCHED_ERR when the priority doesn't exit
+ **/
+
+enum sched_prio string_to_prio(const char *str)
+{
+	if (strncasecmp("high", str, strlen(str)) == 0)
+		return  SCHED_HIGH;
+	else if (strncasecmp("default", str, strlen(str)) == 0)
+		return SCHED_DEFAULT;
+	else if (strncasecmp("low", str, strlen(str)) == 0)
+		return SCHED_LOW;
+	else
+		return SCHED_ERR;
+}
+
+/**
+ * create and open logfile
+ *
+ * @param dir directory in which the logfile should be created
+ *
+ * @retval logfile on success
+ * @retval NULL when the file can't be created
+ **/
+
+FILE *prepare_output(const char *dirname)
+{
+	FILE *output = NULL;
+	int len;
+	char *filename;
+	struct utsname sysdata;
+	DIR *dir;
+
+	dir = opendir(dirname);
+	if (dir == NULL) {
+		if (mkdir(dirname, 0755)) {
+			perror("mkdir");
+			fprintf(stderr, "error: Cannot create dir %s\n",
+				dirname);
+			return NULL;
+		}
+	}
+
+	len = strlen(dirname) + 30;
+	filename = malloc(sizeof(char) * len);
+
+	if (uname(&sysdata) == 0) {
+		len += strlen(sysdata.nodename) + strlen(sysdata.release);
+		filename = realloc(filename, sizeof(char) * len);
+
+		if(filename == NULL) {
+			perror("realloc");
+			return NULL;
+		}
+
+		snprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log", 
+			dirname, sysdata.nodename, sysdata.release, time(NULL));
+	} else {
+		snprintf(filename, len -1, "%s/benchmark_%li.log", dirname, time(NULL));
+	}
+
+	dprintf("logilename: %s\n", filename);
+
+	if ((output = fopen(filename, "w+")) == NULL) {
+		perror("fopen");
+		fprintf(stderr, "error: unable to open logfile\n");
+	}
+
+	fprintf(stdout, "Logfile: %s\n", filename);
+
+	free(filename);
+	fprintf(output, "#round load sleep performance powersave percentage\n");
+	return output;
+}
+
+/**
+ * returns the default config
+ *
+ * @retval default config on success
+ * @retval NULL when the output file can't be created
+ **/
+
+struct config *prepare_default_config()
+{
+	struct config *config = malloc(sizeof(struct config));
+
+	dprintf("loading defaults\n");
+
+	config->sleep = 500000;
+	config->load = 500000;
+	config->sleep_step = 500000;
+	config->load_step = 500000;
+	config->cycles = 5;
+	config->rounds = 50;
+	config->cpu = 0;	
+	config->prio = SCHED_HIGH;
+	config->verbose = 0;
+	strncpy(config->governor, "ondemand", 8);
+
+	config->output = stdout;
+
+#ifdef DEFAULT_CONFIG_FILE
+	if (prepare_config(DEFAULT_CONFIG_FILE, config))
+		return NULL;
+#endif
+	return config;
+}
+
+/**
+ * parses config file and returns the config to the caller
+ *
+ * @param path config file name
+ *
+ * @retval 1 on error
+ * @retval 0 on success
+ **/
+
+int prepare_config(const char *path, struct config *config)
+{
+	size_t len = 0;
+	char *opt, *val, *line = NULL;
+	FILE *configfile = fopen(path, "r");
+
+	if (config == NULL) {
+		fprintf(stderr, "error: config is NULL\n");
+		return 1;
+	}
+
+	if (configfile == NULL) {
+		perror("fopen");
+                fprintf(stderr, "error: unable to read configfile\n");
+		free(config);
+		return 1;
+	}
+
+	while (getline(&line, &len, configfile) != -1)
+	{
+		if (line[0] == '#' || line[0] == ' ')
+			continue;
+
+		sscanf(line, "%as = %as", &opt, &val);
+
+		dprintf("parsing: %s -> %s\n", opt, val);
+
+		if (strncmp("sleep", opt, strlen(opt)) == 0)
+			sscanf(val, "%li", &config->sleep);
+
+		else if (strncmp("load", opt, strlen(opt)) == 0) 
+			sscanf(val, "%li", &config->load);
+
+		else if (strncmp("load_step", opt, strlen(opt)) == 0) 
+			sscanf(val, "%li", &config->load_step);
+
+		else if (strncmp("sleep_step", opt, strlen(opt)) == 0) 
+			sscanf(val, "%li", &config->sleep_step);
+
+		else if (strncmp("cycles", opt, strlen(opt)) == 0) 
+			sscanf(val, "%u", &config->cycles);
+
+		else if (strncmp("rounds", opt, strlen(opt)) == 0) 
+			sscanf(val, "%u", &config->rounds);
+
+		else if (strncmp("verbose", opt, strlen(opt)) == 0) 
+			sscanf(val, "%u", &config->verbose);
+
+		else if (strncmp("output", opt, strlen(opt)) == 0) 
+			config->output = prepare_output(val); 
+
+		else if (strncmp("cpu", opt, strlen(opt)) == 0) 
+			sscanf(val, "%u", &config->cpu);
+
+		else if (strncmp("governor", opt, 14) == 0) 
+			strncpy(config->governor, val, 14);
+
+		else if (strncmp("priority", opt, strlen(opt)) == 0) {
+			if (string_to_prio(val) != SCHED_ERR) 
+				config->prio = string_to_prio(val);
+		}
+	}
+
+	free(line);
+	free(opt);
+	free(val);
+
+	return 0;
+}
