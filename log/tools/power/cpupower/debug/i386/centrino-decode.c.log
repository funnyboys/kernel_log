commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/debug/i386/centrino-decode.c b/tools/power/cpupower/debug/i386/centrino-decode.c
index 7ef24cce4926..700cd31a7d02 100644
--- a/tools/power/cpupower/debug/i386/centrino-decode.c
+++ b/tools/power/cpupower/debug/i386/centrino-decode.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2003 - 2004  Dominik Brodowski <linux@dominikbrodowski.de>
  *
- *  Licensed under the terms of the GNU GPL License version 2.
- *
  * Based on code found in
  * linux/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
  * and originally developed by Jeremy Fitzhardinge.

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/debug/i386/centrino-decode.c b/tools/power/cpupower/debug/i386/centrino-decode.c
new file mode 100644
index 000000000000..7ef24cce4926
--- /dev/null
+++ b/tools/power/cpupower/debug/i386/centrino-decode.c
@@ -0,0 +1,113 @@
+/*
+ *  (C) 2003 - 2004  Dominik Brodowski <linux@dominikbrodowski.de>
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ *
+ * Based on code found in
+ * linux/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
+ * and originally developed by Jeremy Fitzhardinge.
+ *
+ * USAGE: simply run it to decode the current settings on CPU 0,
+ *	  or pass the CPU number as argument, or pass the MSR content
+ *	  as argument.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#define MCPU	32
+
+#define MSR_IA32_PERF_STATUS	0x198
+
+static int rdmsr(unsigned int cpu, unsigned int msr,
+		 unsigned int *lo, unsigned int *hi)
+{
+	int fd;
+	char file[20];
+	unsigned long long val;
+	int retval = -1;
+
+	*lo = *hi = 0;
+
+	if (cpu > MCPU)
+		goto err1;
+
+	sprintf(file, "/dev/cpu/%d/msr", cpu);
+	fd = open(file, O_RDONLY);
+
+	if (fd < 0)
+		goto err1;
+
+	if (lseek(fd, msr, SEEK_CUR) == -1)
+		goto err2;
+
+	if (read(fd, &val, 8) != 8)
+		goto err2;
+
+	*lo = (uint32_t )(val & 0xffffffffull);
+	*hi = (uint32_t )(val>>32 & 0xffffffffull);
+
+	retval = 0;
+err2:
+	close(fd);
+err1:
+	return retval;
+}
+
+static void decode (unsigned int msr)
+{
+	unsigned int multiplier;
+	unsigned int mv;
+
+	multiplier = ((msr >> 8) & 0xFF);
+
+	mv = (((msr & 0xFF) * 16) + 700);
+
+	printf("0x%x means multiplier %d @ %d mV\n", msr, multiplier, mv);
+}
+
+static int decode_live(unsigned int cpu)
+{
+	unsigned int lo, hi;
+	int err;
+
+	err = rdmsr(cpu, MSR_IA32_PERF_STATUS, &lo, &hi);
+
+	if (err) {
+		printf("can't get MSR_IA32_PERF_STATUS for cpu %d\n", cpu);
+		printf("Possible trouble: you don't run an Enhanced SpeedStep capable cpu\n");
+		printf("or you are not root, or the msr driver is not present\n");
+		return 1;
+	}
+
+	decode(lo);
+
+	return 0;
+}
+
+int main (int argc, char **argv)
+{
+	unsigned int cpu, mode = 0;
+
+	if (argc < 2)
+		cpu = 0;
+	else {
+		cpu = strtoul(argv[1], NULL, 0);
+		if (cpu >= MCPU)
+			mode = 1;
+	}
+
+	if (mode)
+		decode(cpu);
+	else
+		decode_live(cpu);
+
+	return 0;
+}
