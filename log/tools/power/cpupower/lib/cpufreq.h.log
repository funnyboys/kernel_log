commit 41ddb7e1f79693d904502ae9bea609837973eff8
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jan 17 08:55:54 2020 +0100

    cpupower: Revert library ABI changes from commit ae2917093fb60bdc1ed3e
    
    Commit ae2917093fb6 ("tools/power/cpupower: Display boost frequency
    separately") modified the library function:
    
    struct cpufreq_available_frequencies
    *cpufreq_get_available_frequencies(unsigned int cpu)
    
    to
    struct cpufreq_frequencies
    *cpufreq_get_frequencies(const char *type, unsigned int cpu)
    
    This patch recovers the old API and implements the new functionality
    in a newly introduce method:
    struct cpufreq_boost_frequencies
    *cpufreq_get_available_frequencies(unsigned int cpu)
    
    This one should get merged into stable kernels back to 5.0 when
    the above had been introduced.
    
    Fixes: ae2917093fb6 ("tools/power/cpupower: Display boost frequency separately")
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index a55f0d19215b..95f4fd9e2656 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -20,10 +20,10 @@ struct cpufreq_available_governors {
 	struct cpufreq_available_governors *first;
 };
 
-struct cpufreq_frequencies {
+struct cpufreq_available_frequencies {
 	unsigned long frequency;
-	struct cpufreq_frequencies *next;
-	struct cpufreq_frequencies *first;
+	struct cpufreq_available_frequencies *next;
+	struct cpufreq_available_frequencies *first;
 };
 
 
@@ -124,11 +124,17 @@ void cpufreq_put_available_governors(
  * cpufreq_put_frequencies after use.
  */
 
-struct cpufreq_frequencies
-*cpufreq_get_frequencies(const char *type, unsigned int cpu);
+struct cpufreq_available_frequencies
+*cpufreq_get_available_frequencies(unsigned int cpu);
 
-void cpufreq_put_frequencies(
-		struct cpufreq_frequencies *first);
+void cpufreq_put_available_frequencies(
+		struct cpufreq_available_frequencies *first);
+
+struct cpufreq_available_frequencies
+*cpufreq_get_boost_frequencies(unsigned int cpu);
+
+void cpufreq_put_boost_frequencies(
+		struct cpufreq_available_frequencies *first);
 
 
 /* determine affected CPUs

commit 8e8e69d67e5fad1a1edf97acebd649a6c8f1febd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 285
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 100 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.918357685@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index 775738269cbf..a55f0d19215b 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -1,16 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  cpufreq.h - definitions for libcpufreq
  *
  *  Copyright (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #ifndef __CPUPOWER_CPUFREQ_H__

commit ae2917093fb60bdc1ed3e5757b74801420569a9a
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Tue Feb 5 04:51:28 2019 -0600

    tools/power/cpupower: Display boost frequency separately
    
    cpufreq driver creates sysfs file "scaling_boost_frequency" for platforms
    which support boost frequency. Cpupower now prints boost frequencies
    separately. For few x86 vendors who already have different way to get boost
    frequency, will continue to use the existing logic. Rest of the platforms
    will rely on "scaling_boost_frequency" file to display boost frequency.
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Signed-off-by: Shuah Khan <shuah@kernel.org>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index 60beaf5ed2ea..775738269cbf 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -28,10 +28,10 @@ struct cpufreq_available_governors {
 	struct cpufreq_available_governors *first;
 };
 
-struct cpufreq_available_frequencies {
+struct cpufreq_frequencies {
 	unsigned long frequency;
-	struct cpufreq_available_frequencies *next;
-	struct cpufreq_available_frequencies *first;
+	struct cpufreq_frequencies *next;
+	struct cpufreq_frequencies *first;
 };
 
 
@@ -129,14 +129,14 @@ void cpufreq_put_available_governors(
  *
  * Only present on _some_ ->target() cpufreq drivers. For information purposes
  * only. Please free allocated memory by calling
- * cpufreq_put_available_frequencies after use.
+ * cpufreq_put_frequencies after use.
  */
 
-struct cpufreq_available_frequencies
-*cpufreq_get_available_frequencies(unsigned int cpu);
+struct cpufreq_frequencies
+*cpufreq_get_frequencies(const char *type, unsigned int cpu);
 
-void cpufreq_put_available_frequencies(
-		struct cpufreq_available_frequencies *first);
+void cpufreq_put_frequencies(
+		struct cpufreq_frequencies *first);
 
 
 /* determine affected CPUs

commit 0e96a0c83f0842d5cfd83b0a896bc82ff61f9849
Author: Laura Abbott <labbott@redhat.com>
Date:   Thu Dec 14 17:16:29 2017 -0800

    cpupower: Remove FSF address
    
    Checkpatch in the kernel now complains about having the FSF address
    in comments. Other tools such as rpmlint are now starting to do the
    same thing. Remove the FSF address to reduce warnings on multiple tools.
    
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index 3b005c39f068..60beaf5ed2ea 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -11,10 +11,6 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef __CPUPOWER_CPUFREQ_H__

commit ac5a181d065d74fb6b213d538f743392f27bcdbd
Author: Thomas Renninger <trenn@suse.com>
Date:   Thu Apr 28 15:24:40 2016 +0200

    cpupower: Add cpuidle parts into library
    
    This more or less is a renaming and moving of functions and should not
    introduce any functional change.
    
    cpupower was built from cpufrequtils (which had a C library providing easy
    access to cpu frequency platform info). In the meantime it got enhanced
    by quite some neat cpuidle userspace tools.
    
    Now the cpu idle functions have been separated and added to the cpupower.so
    library.
    So beside an already existing public header file:
    cpufreq.h
    cpupower now also exports these cpu idle functions in:
    cpuidle.h
    
    Here again pasted for better review of the interfaces:
    
    ======================================
    int cpuidle_is_state_disabled(unsigned int cpu,
                                           unsigned int idlestate);
    int cpuidle_state_disable(unsigned int cpu, unsigned int idlestate,
                                       unsigned int disable);
    unsigned long cpuidle_state_latency(unsigned int cpu,
                                                    unsigned int idlestate);
    unsigned long cpuidle_state_usage(unsigned int cpu,
                                            unsigned int idlestate);
    unsigned long long cpuidle_state_time(unsigned int cpu,
                                                    unsigned int idlestate);
    char *cpuidle_state_name(unsigned int cpu,
                                    unsigned int idlestate);
    char *cpuidle_state_desc(unsigned int cpu,
                                    unsigned int idlestate);
    unsigned int cpuidle_state_count(unsigned int cpu);
    
    char *cpuidle_get_governor(void);
    char *cpuidle_get_driver(void);
    
    ======================================
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index 3aae8e7a0839..3b005c39f068 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -17,8 +17,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef _CPUFREQ_H
-#define _CPUFREQ_H 1
+#ifndef __CPUPOWER_CPUFREQ_H__
+#define __CPUPOWER_CPUFREQ_H__
 
 struct cpufreq_policy {
 	unsigned long min;
@@ -58,13 +58,6 @@ struct cpufreq_stats {
 extern "C" {
 #endif
 
-/*
- * returns 0 if the specified CPU is present (it doesn't say
- * whether it is online!), and an error value if not.
- */
-
-extern int cpufreq_cpu_exists(unsigned int cpu);
-
 /* determine current CPU frequency
  * - _kernel variant means kernel's opinion of CPU frequency
  * - _hardware variant means actual hardware CPU frequency,
@@ -73,9 +66,9 @@ extern int cpufreq_cpu_exists(unsigned int cpu);
  * returns 0 on failure, else frequency in kHz.
  */
 
-extern unsigned long cpufreq_get_freq_kernel(unsigned int cpu);
+unsigned long cpufreq_get_freq_kernel(unsigned int cpu);
 
-extern unsigned long cpufreq_get_freq_hardware(unsigned int cpu);
+unsigned long cpufreq_get_freq_hardware(unsigned int cpu);
 
 #define cpufreq_get(cpu) cpufreq_get_freq_kernel(cpu);
 
@@ -84,7 +77,7 @@ extern unsigned long cpufreq_get_freq_hardware(unsigned int cpu);
  *
  * returns 0 on failure, else transition latency in 10^(-9) s = nanoseconds
  */
-extern unsigned long cpufreq_get_transition_latency(unsigned int cpu);
+unsigned long cpufreq_get_transition_latency(unsigned int cpu);
 
 
 /* determine hardware CPU frequency limits
@@ -93,7 +86,7 @@ extern unsigned long cpufreq_get_transition_latency(unsigned int cpu);
  * considerations by cpufreq policy notifiers in the kernel.
  */
 
-extern int cpufreq_get_hardware_limits(unsigned int cpu,
+int cpufreq_get_hardware_limits(unsigned int cpu,
 				unsigned long *min,
 				unsigned long *max);
 
@@ -104,9 +97,9 @@ extern int cpufreq_get_hardware_limits(unsigned int cpu,
  * to avoid memory leakage, please.
  */
 
-extern char *cpufreq_get_driver(unsigned int cpu);
+char *cpufreq_get_driver(unsigned int cpu);
 
-extern void cpufreq_put_driver(char *ptr);
+void cpufreq_put_driver(char *ptr);
 
 
 /* determine CPUfreq policy currently used
@@ -116,9 +109,9 @@ extern void cpufreq_put_driver(char *ptr);
  */
 
 
-extern struct cpufreq_policy *cpufreq_get_policy(unsigned int cpu);
+struct cpufreq_policy *cpufreq_get_policy(unsigned int cpu);
 
-extern void cpufreq_put_policy(struct cpufreq_policy *policy);
+void cpufreq_put_policy(struct cpufreq_policy *policy);
 
 
 /* determine CPUfreq governors currently available
@@ -129,10 +122,10 @@ extern void cpufreq_put_policy(struct cpufreq_policy *policy);
  */
 
 
-extern struct cpufreq_available_governors
+struct cpufreq_available_governors
 *cpufreq_get_available_governors(unsigned int cpu);
 
-extern void cpufreq_put_available_governors(
+void cpufreq_put_available_governors(
 	struct cpufreq_available_governors *first);
 
 
@@ -143,10 +136,10 @@ extern void cpufreq_put_available_governors(
  * cpufreq_put_available_frequencies after use.
  */
 
-extern struct cpufreq_available_frequencies
+struct cpufreq_available_frequencies
 *cpufreq_get_available_frequencies(unsigned int cpu);
 
-extern void cpufreq_put_available_frequencies(
+void cpufreq_put_available_frequencies(
 		struct cpufreq_available_frequencies *first);
 
 
@@ -156,10 +149,10 @@ extern void cpufreq_put_available_frequencies(
  * to avoid memory leakage, please.
  */
 
-extern struct cpufreq_affected_cpus *cpufreq_get_affected_cpus(unsigned
+struct cpufreq_affected_cpus *cpufreq_get_affected_cpus(unsigned
 							int cpu);
 
-extern void cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *first);
+void cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *first);
 
 
 /* determine related CPUs
@@ -168,10 +161,10 @@ extern void cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *first);
  * to avoid memory leakage, please.
  */
 
-extern struct cpufreq_affected_cpus *cpufreq_get_related_cpus(unsigned
+struct cpufreq_affected_cpus *cpufreq_get_related_cpus(unsigned
 							int cpu);
 
-extern void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
+void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
 
 
 /* determine stats for cpufreq subsystem
@@ -179,12 +172,12 @@ extern void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
  * This is not available in all kernel versions or configurations.
  */
 
-extern struct cpufreq_stats *cpufreq_get_stats(unsigned int cpu,
+struct cpufreq_stats *cpufreq_get_stats(unsigned int cpu,
 					unsigned long long *total_time);
 
-extern void cpufreq_put_stats(struct cpufreq_stats *stats);
+void cpufreq_put_stats(struct cpufreq_stats *stats);
 
-extern unsigned long cpufreq_get_transitions(unsigned int cpu);
+unsigned long cpufreq_get_transitions(unsigned int cpu);
 
 
 /* set new cpufreq policy
@@ -193,7 +186,7 @@ extern unsigned long cpufreq_get_transitions(unsigned int cpu);
  * but results may differ depending e.g. on governors being available.
  */
 
-extern int cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy);
+int cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy);
 
 
 /* modify a policy by only changing min/max freq or governor
@@ -201,9 +194,9 @@ extern int cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy);
  * Does not check whether result is what was intended.
  */
 
-extern int cpufreq_modify_policy_min(unsigned int cpu, unsigned long min_freq);
-extern int cpufreq_modify_policy_max(unsigned int cpu, unsigned long max_freq);
-extern int cpufreq_modify_policy_governor(unsigned int cpu, char *governor);
+int cpufreq_modify_policy_min(unsigned int cpu, unsigned long min_freq);
+int cpufreq_modify_policy_max(unsigned int cpu, unsigned long max_freq);
+int cpufreq_modify_policy_governor(unsigned int cpu, char *governor);
 
 
 /* set a specific frequency
@@ -213,7 +206,7 @@ extern int cpufreq_modify_policy_governor(unsigned int cpu, char *governor);
  * occurs. Also does not work on ->range() cpufreq drivers.
  */
 
-extern int cpufreq_set_frequency(unsigned int cpu,
+int cpufreq_set_frequency(unsigned int cpu,
 				unsigned long target_frequency);
 
 #ifdef __cplusplus

commit 6c2b8185517fea46bdb1e4e70c7005901fcc89ab
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:42:33 2011 +0200

    cpupowerutils: lib - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
index 03be906581b5..3aae8e7a0839 100644
--- a/tools/power/cpupower/lib/cpufreq.h
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -93,9 +93,9 @@ extern unsigned long cpufreq_get_transition_latency(unsigned int cpu);
  * considerations by cpufreq policy notifiers in the kernel.
  */
 
-extern int cpufreq_get_hardware_limits(unsigned int cpu, 
-				       unsigned long *min, 
-				       unsigned long *max);
+extern int cpufreq_get_hardware_limits(unsigned int cpu,
+				unsigned long *min,
+				unsigned long *max);
 
 
 /* determine CPUfreq driver used
@@ -104,9 +104,9 @@ extern int cpufreq_get_hardware_limits(unsigned int cpu,
  * to avoid memory leakage, please.
  */
 
-extern char * cpufreq_get_driver(unsigned int cpu);
+extern char *cpufreq_get_driver(unsigned int cpu);
 
-extern void   cpufreq_put_driver(char * ptr);
+extern void cpufreq_put_driver(char *ptr);
 
 
 /* determine CPUfreq policy currently used
@@ -116,7 +116,7 @@ extern void   cpufreq_put_driver(char * ptr);
  */
 
 
-extern struct cpufreq_policy * cpufreq_get_policy(unsigned int cpu);
+extern struct cpufreq_policy *cpufreq_get_policy(unsigned int cpu);
 
 extern void cpufreq_put_policy(struct cpufreq_policy *policy);
 
@@ -129,41 +129,47 @@ extern void cpufreq_put_policy(struct cpufreq_policy *policy);
  */
 
 
-extern struct cpufreq_available_governors * cpufreq_get_available_governors(unsigned int cpu);
+extern struct cpufreq_available_governors
+*cpufreq_get_available_governors(unsigned int cpu);
 
-extern void cpufreq_put_available_governors(struct cpufreq_available_governors *first);
+extern void cpufreq_put_available_governors(
+	struct cpufreq_available_governors *first);
 
 
 /* determine CPU frequency states available
  *
- * only present on _some_ ->target() cpufreq drivers. For information purposes
- * only. Please free allocated memory by calling cpufreq_put_available_frequencies
- * after use.
+ * Only present on _some_ ->target() cpufreq drivers. For information purposes
+ * only. Please free allocated memory by calling
+ * cpufreq_put_available_frequencies after use.
  */
 
-extern struct cpufreq_available_frequencies * cpufreq_get_available_frequencies(unsigned int cpu);
+extern struct cpufreq_available_frequencies
+*cpufreq_get_available_frequencies(unsigned int cpu);
 
-extern void cpufreq_put_available_frequencies(struct cpufreq_available_frequencies *first);
+extern void cpufreq_put_available_frequencies(
+		struct cpufreq_available_frequencies *first);
 
 
-/* determine affected CPUs 
+/* determine affected CPUs
  *
  * Remember to call cpufreq_put_affected_cpus when no longer needed
  * to avoid memory leakage, please.
  */
 
-extern struct cpufreq_affected_cpus * cpufreq_get_affected_cpus(unsigned int cpu);
+extern struct cpufreq_affected_cpus *cpufreq_get_affected_cpus(unsigned
+							int cpu);
 
 extern void cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *first);
 
 
-/* determine related CPUs 
+/* determine related CPUs
  *
  * Remember to call cpufreq_put_related_cpus when no longer needed
  * to avoid memory leakage, please.
  */
 
-extern struct cpufreq_affected_cpus * cpufreq_get_related_cpus(unsigned int cpu);
+extern struct cpufreq_affected_cpus *cpufreq_get_related_cpus(unsigned
+							int cpu);
 
 extern void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
 
@@ -173,15 +179,16 @@ extern void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
  * This is not available in all kernel versions or configurations.
  */
 
-extern struct cpufreq_stats * cpufreq_get_stats(unsigned int cpu, unsigned long long *total_time);
+extern struct cpufreq_stats *cpufreq_get_stats(unsigned int cpu,
+					unsigned long long *total_time);
 
 extern void cpufreq_put_stats(struct cpufreq_stats *stats);
 
 extern unsigned long cpufreq_get_transitions(unsigned int cpu);
 
 
-/* set new cpufreq policy 
- * 
+/* set new cpufreq policy
+ *
  * Tries to set the passed policy as new policy as close as possible,
  * but results may differ depending e.g. on governors being available.
  */
@@ -189,7 +196,7 @@ extern unsigned long cpufreq_get_transitions(unsigned int cpu);
 extern int cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy);
 
 
-/* modify a policy by only changing min/max freq or governor 
+/* modify a policy by only changing min/max freq or governor
  *
  * Does not check whether result is what was intended.
  */
@@ -202,11 +209,12 @@ extern int cpufreq_modify_policy_governor(unsigned int cpu, char *governor);
 /* set a specific frequency
  *
  * Does only work if userspace governor can be used and no external
- * interference (other calls to this function or to set/modify_policy) 
+ * interference (other calls to this function or to set/modify_policy)
  * occurs. Also does not work on ->range() cpufreq drivers.
  */
 
-extern int cpufreq_set_frequency(unsigned int cpu, unsigned long target_frequency);
+extern int cpufreq_set_frequency(unsigned int cpu,
+				unsigned long target_frequency);
 
 #ifdef __cplusplus
 }

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/lib/cpufreq.h b/tools/power/cpupower/lib/cpufreq.h
new file mode 100644
index 000000000000..03be906581b5
--- /dev/null
+++ b/tools/power/cpupower/lib/cpufreq.h
@@ -0,0 +1,215 @@
+/*
+ *  cpufreq.h - definitions for libcpufreq
+ *
+ *  Copyright (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _CPUFREQ_H
+#define _CPUFREQ_H 1
+
+struct cpufreq_policy {
+	unsigned long min;
+	unsigned long max;
+	char *governor;
+};
+
+struct cpufreq_available_governors {
+	char *governor;
+	struct cpufreq_available_governors *next;
+	struct cpufreq_available_governors *first;
+};
+
+struct cpufreq_available_frequencies {
+	unsigned long frequency;
+	struct cpufreq_available_frequencies *next;
+	struct cpufreq_available_frequencies *first;
+};
+
+
+struct cpufreq_affected_cpus {
+	unsigned int cpu;
+	struct cpufreq_affected_cpus *next;
+	struct cpufreq_affected_cpus *first;
+};
+
+struct cpufreq_stats {
+	unsigned long frequency;
+	unsigned long long time_in_state;
+	struct cpufreq_stats *next;
+	struct cpufreq_stats *first;
+};
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * returns 0 if the specified CPU is present (it doesn't say
+ * whether it is online!), and an error value if not.
+ */
+
+extern int cpufreq_cpu_exists(unsigned int cpu);
+
+/* determine current CPU frequency
+ * - _kernel variant means kernel's opinion of CPU frequency
+ * - _hardware variant means actual hardware CPU frequency,
+ *    which is only available to root.
+ *
+ * returns 0 on failure, else frequency in kHz.
+ */
+
+extern unsigned long cpufreq_get_freq_kernel(unsigned int cpu);
+
+extern unsigned long cpufreq_get_freq_hardware(unsigned int cpu);
+
+#define cpufreq_get(cpu) cpufreq_get_freq_kernel(cpu);
+
+
+/* determine CPU transition latency
+ *
+ * returns 0 on failure, else transition latency in 10^(-9) s = nanoseconds
+ */
+extern unsigned long cpufreq_get_transition_latency(unsigned int cpu);
+
+
+/* determine hardware CPU frequency limits
+ *
+ * These may be limited further by thermal, energy or other
+ * considerations by cpufreq policy notifiers in the kernel.
+ */
+
+extern int cpufreq_get_hardware_limits(unsigned int cpu, 
+				       unsigned long *min, 
+				       unsigned long *max);
+
+
+/* determine CPUfreq driver used
+ *
+ * Remember to call cpufreq_put_driver when no longer needed
+ * to avoid memory leakage, please.
+ */
+
+extern char * cpufreq_get_driver(unsigned int cpu);
+
+extern void   cpufreq_put_driver(char * ptr);
+
+
+/* determine CPUfreq policy currently used
+ *
+ * Remember to call cpufreq_put_policy when no longer needed
+ * to avoid memory leakage, please.
+ */
+
+
+extern struct cpufreq_policy * cpufreq_get_policy(unsigned int cpu);
+
+extern void cpufreq_put_policy(struct cpufreq_policy *policy);
+
+
+/* determine CPUfreq governors currently available
+ *
+ * may be modified by modprobe'ing or rmmod'ing other governors. Please
+ * free allocated memory by calling cpufreq_put_available_governors
+ * after use.
+ */
+
+
+extern struct cpufreq_available_governors * cpufreq_get_available_governors(unsigned int cpu);
+
+extern void cpufreq_put_available_governors(struct cpufreq_available_governors *first);
+
+
+/* determine CPU frequency states available
+ *
+ * only present on _some_ ->target() cpufreq drivers. For information purposes
+ * only. Please free allocated memory by calling cpufreq_put_available_frequencies
+ * after use.
+ */
+
+extern struct cpufreq_available_frequencies * cpufreq_get_available_frequencies(unsigned int cpu);
+
+extern void cpufreq_put_available_frequencies(struct cpufreq_available_frequencies *first);
+
+
+/* determine affected CPUs 
+ *
+ * Remember to call cpufreq_put_affected_cpus when no longer needed
+ * to avoid memory leakage, please.
+ */
+
+extern struct cpufreq_affected_cpus * cpufreq_get_affected_cpus(unsigned int cpu);
+
+extern void cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *first);
+
+
+/* determine related CPUs 
+ *
+ * Remember to call cpufreq_put_related_cpus when no longer needed
+ * to avoid memory leakage, please.
+ */
+
+extern struct cpufreq_affected_cpus * cpufreq_get_related_cpus(unsigned int cpu);
+
+extern void cpufreq_put_related_cpus(struct cpufreq_affected_cpus *first);
+
+
+/* determine stats for cpufreq subsystem
+ *
+ * This is not available in all kernel versions or configurations.
+ */
+
+extern struct cpufreq_stats * cpufreq_get_stats(unsigned int cpu, unsigned long long *total_time);
+
+extern void cpufreq_put_stats(struct cpufreq_stats *stats);
+
+extern unsigned long cpufreq_get_transitions(unsigned int cpu);
+
+
+/* set new cpufreq policy 
+ * 
+ * Tries to set the passed policy as new policy as close as possible,
+ * but results may differ depending e.g. on governors being available.
+ */
+
+extern int cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy);
+
+
+/* modify a policy by only changing min/max freq or governor 
+ *
+ * Does not check whether result is what was intended.
+ */
+
+extern int cpufreq_modify_policy_min(unsigned int cpu, unsigned long min_freq);
+extern int cpufreq_modify_policy_max(unsigned int cpu, unsigned long max_freq);
+extern int cpufreq_modify_policy_governor(unsigned int cpu, char *governor);
+
+
+/* set a specific frequency
+ *
+ * Does only work if userspace governor can be used and no external
+ * interference (other calls to this function or to set/modify_policy) 
+ * occurs. Also does not work on ->range() cpufreq drivers.
+ */
+
+extern int cpufreq_set_frequency(unsigned int cpu, unsigned long target_frequency);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CPUFREQ_H */
