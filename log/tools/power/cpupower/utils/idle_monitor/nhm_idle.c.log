commit 7b0bf99b9ee497cc0f079472566aff716d033d43
Author: Zou Wei <zou_wei@huawei.com>
Date:   Tue Apr 28 17:43:15 2020 +0800

    cpupower: Remove unneeded semicolon
    
    Fixes coccicheck warnings:
    
    tools/power/cpupower/utils/cpupower-info.c:65:2-3: Unneeded semicolon
    tools/power/cpupower/utils/cpupower-set.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c:120:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:175:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:56:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/hsw_ext_idle.c:82:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/nhm_idle.c:94:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/snb_idle.c:80:2-3: Unneeded semicolon
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zou Wei <zou_wei@huawei.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
index 114271165182..16eaf006f61f 100644
--- a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -91,7 +91,7 @@ static int nhm_get_count(enum intel_nhm_id id, unsigned long long *val,
 		break;
 	default:
 		return -1;
-	};
+	}
 	if (read_msr(cpu, msr, val))
 		return -1;
 

commit d3f5d2a192a299f56579ae6e6283f9011b00208f
Author: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
Date:   Tue Nov 5 17:16:52 2019 +0000

    cpupower: Move needs_root variable into a sub-struct
    
    Move the needs_root variable into a sub-struct. This is in preparation
    for adding a new flag for cpuidle_monitor.
    
    Update all uses of the needs_root variable to reflect this change.
    
    Signed-off-by: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
index be7256696a37..114271165182 100644
--- a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -208,7 +208,7 @@ struct cpuidle_monitor intel_nhm_monitor = {
 	.stop			= nhm_stop,
 	.do_register		= intel_nhm_register,
 	.unregister		= intel_nhm_unregister,
-	.needs_root		= 1,
+	.flags.needs_root	= 1,
 	.overflow_s		= 922000000 /* 922337203 seconds TSC overflow
 					       at 20GHz */
 };

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
index abf8cb5f7349..be7256696a37 100644
--- a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
  *
- *  Licensed under the terms of the GNU GPL License version 2.
- *
  *  Based on Len Brown's <lenb@kernel.org> turbostat tool.
  */
 

commit d0e4a193c33adaa4f91128d5393aa3589c2f3e9e
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Jul 31 07:56:06 2017 -0400

    tools/power/cpupower: allow running without cpu0
    
    Linux-3.7 added CONFIG_BOOTPARAM_HOTPLUG_CPU0,
    allowing systems to offline cpu0.
    
    But when cpu0 is offline, cpupower monitor will not display all
    processor and Mperf information:
    
    [root@intel-skylake-dh-03 cpupower]# ./cpupower monitor
    WARNING: at least one cpu is offline
        |Idle_Stats
    CPU | POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S
       4|  0.00|  0.00|  0.00|  0.00|  0.90|  0.00| 96.13
       1|  0.00|  0.00|  5.49|  0.00|  0.01|  0.00| 92.26
       5|  0.00|  0.00|  0.00|  0.00|  0.46|  0.00| 99.50
       2| 45.42|  0.00|  0.00|  0.00| 22.94|  0.00| 28.84
       6|  0.00| 37.54|  0.00|  0.00|  0.00|  0.00|  0.00
       3|  0.00|  0.00|  0.00|  0.00|  0.30|  0.00| 91.99
       7|  0.00|  0.00|  0.00|  0.00|  4.70|  0.00|  0.70
    
    This patch replaces the hard-coded use of cpu0 in cpupower with the
    current cpu, allowing it to run without a cpu0.
    
    After the patch is applied,
    
    [root@intel-skylake-dh-03 cpupower]# ./cpupower monitor
    WARNING: at least one cpu is offline
        |Nehalem                    || Mperf              || Idle_Stats
    CPU | C3   | C6   | PC3  | PC6  || C0   | Cx   | Freq || POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S
       4|  0.01|  1.27|  0.00|  0.00||  0.04| 99.96|  3957||  0.00|  0.00|  0.00|  0.00|  1.43|  0.00| 98.52
       1|  0.00| 98.82|  0.00|  0.00||  0.05| 99.95|  3361||  0.00|  0.00|  0.01|  0.00|  0.03|  0.00| 99.88
       5|  0.00| 98.82|  0.00|  0.00||  0.09| 99.91|  3917||  0.00|  0.00|  0.00|  0.00| 99.38|  0.00|  0.50
       2|  0.33|  0.00|  0.00|  0.00||  0.00|100.00|  3890||  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|100.00
       6|  0.33|  0.00|  0.00|  0.00||  0.01| 99.99|  3903||  0.00|  0.00|  0.00|  0.00|  0.00|  0.00| 99.99
       3|  0.01|  0.71|  0.00|  0.00||  0.06| 99.94|  3678||  0.00|  0.00|  0.00|  0.00|  0.80|  0.00| 99.13
       7|  0.01|  0.71|  0.00|  0.00||  0.03| 99.97|  3538||  0.00|  0.69| 11.70|  0.00|  0.00|  0.00| 87.57
    
    There are some minor cleanups included in this patch.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
index d2a91dd0d563..abf8cb5f7349 100644
--- a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -129,7 +129,7 @@ static int nhm_start(void)
 	int num, cpu;
 	unsigned long long dbg, val;
 
-	nhm_get_count(TSC, &tsc_at_measure_start, 0);
+	nhm_get_count(TSC, &tsc_at_measure_start, base_cpu);
 
 	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
 		for (cpu = 0; cpu < cpu_count; cpu++) {
@@ -137,7 +137,7 @@ static int nhm_start(void)
 			previous_count[num][cpu] = val;
 		}
 	}
-	nhm_get_count(TSC, &dbg, 0);
+	nhm_get_count(TSC, &dbg, base_cpu);
 	dprint("TSC diff: %llu\n", dbg - tsc_at_measure_start);
 	return 0;
 }
@@ -148,7 +148,7 @@ static int nhm_stop(void)
 	unsigned long long dbg;
 	int num, cpu;
 
-	nhm_get_count(TSC, &tsc_at_measure_end, 0);
+	nhm_get_count(TSC, &tsc_at_measure_end, base_cpu);
 
 	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
 		for (cpu = 0; cpu < cpu_count; cpu++) {
@@ -156,7 +156,7 @@ static int nhm_stop(void)
 			current_count[num][cpu] = val;
 		}
 	}
-	nhm_get_count(TSC, &dbg, 0);
+	nhm_get_count(TSC, &dbg, base_cpu);
 	dprint("TSC diff: %llu\n", dbg - tsc_at_measure_end);
 
 	return 0;

commit b510b54127a4d4112a9a3f200339719bcb463c15
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:58:59 2011 +0200

    cpupowerutils: idle_monitor - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
index 6424b6dd3fa5..d2a91dd0d563 100644
--- a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -69,11 +69,12 @@ static unsigned long long *current_count[NHM_CSTATE_COUNT];
 /* valid flag for all CPUs. If a MSR read failed it will be zero */
 static int *is_valid;
 
-static int nhm_get_count(enum intel_nhm_id id, unsigned long long *val, unsigned int cpu)
+static int nhm_get_count(enum intel_nhm_id id, unsigned long long *val,
+			unsigned int cpu)
 {
 	int msr;
 
-	switch(id) {
+	switch (id) {
 	case C3:
 		msr = MSR_CORE_C3_RESIDENCY;
 		break;
@@ -106,12 +107,13 @@ static int nhm_get_count_percent(unsigned int id, double *percent,
 	if (!is_valid[cpu])
 		return -1;
 
-	*percent = (100.0 * (current_count[id][cpu] - previous_count[id][cpu])) /
+	*percent = (100.0 *
+		(current_count[id][cpu] - previous_count[id][cpu])) /
 		(tsc_at_measure_end - tsc_at_measure_start);
 
-	dprint("%s: previous: %llu - current: %llu - (%u)\n", nhm_cstates[id].name,
-	       previous_count[id][cpu], current_count[id][cpu],
-	       cpu);
+	dprint("%s: previous: %llu - current: %llu - (%u)\n",
+		nhm_cstates[id].name, previous_count[id][cpu],
+		current_count[id][cpu], cpu);
 
 	dprint("%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\n",
 	       nhm_cstates[id].name,
@@ -162,7 +164,8 @@ static int nhm_stop(void)
 
 struct cpuidle_monitor intel_nhm_monitor;
 
-struct cpuidle_monitor* intel_nhm_register(void) {
+struct cpuidle_monitor *intel_nhm_register(void)
+{
 	int num;
 
 	if (cpupower_cpu_info.vendor != X86_VENDOR_INTEL)
@@ -175,19 +178,20 @@ struct cpuidle_monitor* intel_nhm_register(void) {
 		return NULL;
 
 	/* Free this at program termination */
-	is_valid = calloc(cpu_count, sizeof (int));
+	is_valid = calloc(cpu_count, sizeof(int));
 	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
-		previous_count[num] = calloc (cpu_count,
-					      sizeof(unsigned long long));
-		current_count[num]  = calloc (cpu_count,
-					      sizeof(unsigned long long));
+		previous_count[num] = calloc(cpu_count,
+					sizeof(unsigned long long));
+		current_count[num]  = calloc(cpu_count,
+					sizeof(unsigned long long));
 	}
 
 	intel_nhm_monitor.name_len = strlen(intel_nhm_monitor.name);
 	return &intel_nhm_monitor;
 }
 
-void intel_nhm_unregister(void) {
+void intel_nhm_unregister(void)
+{
 	int num;
 
 	for (num = 0; num < NHM_CSTATE_COUNT; num++) {

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/nhm_idle.c b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
new file mode 100644
index 000000000000..6424b6dd3fa5
--- /dev/null
+++ b/tools/power/cpupower/utils/idle_monitor/nhm_idle.c
@@ -0,0 +1,212 @@
+/*
+ *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ *
+ *  Based on Len Brown's <lenb@kernel.org> turbostat tool.
+ */
+
+#if defined(__i386__) || defined(__x86_64__)
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "helpers/helpers.h"
+#include "idle_monitor/cpupower-monitor.h"
+
+#define MSR_PKG_C3_RESIDENCY	0x3F8
+#define MSR_PKG_C6_RESIDENCY	0x3F9
+#define MSR_CORE_C3_RESIDENCY	0x3FC
+#define MSR_CORE_C6_RESIDENCY	0x3FD
+
+#define MSR_TSC	0x10
+
+#define NHM_CSTATE_COUNT 4
+
+enum intel_nhm_id { C3 = 0, C6, PC3, PC6, TSC = 0xFFFF };
+
+static int nhm_get_count_percent(unsigned int self_id, double *percent,
+				 unsigned int cpu);
+
+static cstate_t nhm_cstates[NHM_CSTATE_COUNT] = {
+	{
+		.name			= "C3",
+		.desc			= N_("Processor Core C3"),
+		.id			= C3,
+		.range			= RANGE_CORE,
+		.get_count_percent	= nhm_get_count_percent,
+	},
+	{
+		.name			= "C6",
+		.desc			= N_("Processor Core C6"),
+		.id			= C6,
+		.range			= RANGE_CORE,
+		.get_count_percent	= nhm_get_count_percent,
+	},
+
+	{
+		.name			= "PC3",
+		.desc			= N_("Processor Package C3"),
+		.id			= PC3,
+		.range			= RANGE_PACKAGE,
+		.get_count_percent	= nhm_get_count_percent,
+	},
+	{
+		.name			= "PC6",
+		.desc			= N_("Processor Package C6"),
+		.id			= PC6,
+		.range			= RANGE_PACKAGE,
+		.get_count_percent	= nhm_get_count_percent,
+	},
+};
+
+static unsigned long long tsc_at_measure_start;
+static unsigned long long tsc_at_measure_end;
+static unsigned long long *previous_count[NHM_CSTATE_COUNT];
+static unsigned long long *current_count[NHM_CSTATE_COUNT];
+/* valid flag for all CPUs. If a MSR read failed it will be zero */
+static int *is_valid;
+
+static int nhm_get_count(enum intel_nhm_id id, unsigned long long *val, unsigned int cpu)
+{
+	int msr;
+
+	switch(id) {
+	case C3:
+		msr = MSR_CORE_C3_RESIDENCY;
+		break;
+	case C6:
+		msr = MSR_CORE_C6_RESIDENCY;
+		break;
+	case PC3:
+		msr = MSR_PKG_C3_RESIDENCY;
+		break;
+	case PC6:
+		msr = MSR_PKG_C6_RESIDENCY;
+		break;
+	case TSC:
+		msr = MSR_TSC;
+		break;
+	default:
+		return -1;
+	};
+	if (read_msr(cpu, msr, val))
+		return -1;
+
+	return 0;
+}
+
+static int nhm_get_count_percent(unsigned int id, double *percent,
+				 unsigned int cpu)
+{
+	*percent = 0.0;
+
+	if (!is_valid[cpu])
+		return -1;
+
+	*percent = (100.0 * (current_count[id][cpu] - previous_count[id][cpu])) /
+		(tsc_at_measure_end - tsc_at_measure_start);
+
+	dprint("%s: previous: %llu - current: %llu - (%u)\n", nhm_cstates[id].name,
+	       previous_count[id][cpu], current_count[id][cpu],
+	       cpu);
+
+	dprint("%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\n",
+	       nhm_cstates[id].name,
+	       (unsigned long long) tsc_at_measure_end - tsc_at_measure_start,
+	       current_count[id][cpu] - previous_count[id][cpu],
+	       *percent, cpu);
+
+	return 0;
+}
+
+static int nhm_start(void)
+{
+	int num, cpu;
+	unsigned long long dbg, val;
+
+	nhm_get_count(TSC, &tsc_at_measure_start, 0);
+
+	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
+		for (cpu = 0; cpu < cpu_count; cpu++) {
+			is_valid[cpu] = !nhm_get_count(num, &val, cpu);
+			previous_count[num][cpu] = val;
+		}
+	}
+	nhm_get_count(TSC, &dbg, 0);
+	dprint("TSC diff: %llu\n", dbg - tsc_at_measure_start);
+	return 0;
+}
+
+static int nhm_stop(void)
+{
+	unsigned long long val;
+	unsigned long long dbg;
+	int num, cpu;
+
+	nhm_get_count(TSC, &tsc_at_measure_end, 0);
+
+	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
+		for (cpu = 0; cpu < cpu_count; cpu++) {
+			is_valid[cpu] = !nhm_get_count(num, &val, cpu);
+			current_count[num][cpu] = val;
+		}
+	}
+	nhm_get_count(TSC, &dbg, 0);
+	dprint("TSC diff: %llu\n", dbg - tsc_at_measure_end);
+
+	return 0;
+}
+
+struct cpuidle_monitor intel_nhm_monitor;
+
+struct cpuidle_monitor* intel_nhm_register(void) {
+	int num;
+
+	if (cpupower_cpu_info.vendor != X86_VENDOR_INTEL)
+		return NULL;
+
+	if (!(cpupower_cpu_info.caps & CPUPOWER_CAP_INV_TSC))
+		return NULL;
+
+	if (!(cpupower_cpu_info.caps & CPUPOWER_CAP_APERF))
+		return NULL;
+
+	/* Free this at program termination */
+	is_valid = calloc(cpu_count, sizeof (int));
+	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
+		previous_count[num] = calloc (cpu_count,
+					      sizeof(unsigned long long));
+		current_count[num]  = calloc (cpu_count,
+					      sizeof(unsigned long long));
+	}
+
+	intel_nhm_monitor.name_len = strlen(intel_nhm_monitor.name);
+	return &intel_nhm_monitor;
+}
+
+void intel_nhm_unregister(void) {
+	int num;
+
+	for (num = 0; num < NHM_CSTATE_COUNT; num++) {
+		free(previous_count[num]);
+		free(current_count[num]);
+	}
+	free(is_valid);
+}
+
+struct cpuidle_monitor intel_nhm_monitor = {
+	.name			= "Nehalem",
+	.hw_states_num		= NHM_CSTATE_COUNT,
+	.hw_states		= nhm_cstates,
+	.start			= nhm_start,
+	.stop			= nhm_stop,
+	.do_register		= intel_nhm_register,
+	.unregister		= intel_nhm_unregister,
+	.needs_root		= 1,
+	.overflow_s		= 922000000 /* 922337203 seconds TSC overflow
+					       at 20GHz */
+};
+#endif
