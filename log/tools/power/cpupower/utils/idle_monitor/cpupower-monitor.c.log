commit 2de7fb60a4740135e03cf55c1982e393ccb87b6b
Author: Mike Gilbert <floppym@gentoo.org>
Date:   Wed Feb 26 14:33:59 2020 -0500

    cpupower: avoid multiple definition with gcc -fno-common
    
    Building cpupower with -fno-common in CFLAGS results in errors due to
    multiple definitions of the 'cpu_count' and 'start_time' variables.
    
    ./utils/idle_monitor/snb_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    multiple definition of `cpu_count';
    ./utils/idle_monitor/nhm_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    first defined here
    ...
    ./utils/idle_monitor/cpuidle_sysfs.o:./utils/idle_monitor/cpuidle_sysfs.c:22:
    multiple definition of `start_time';
    ./utils/idle_monitor/amd_fam14h_idle.o:./utils/idle_monitor/amd_fam14h_idle.c:85:
    first defined here
    
    The -fno-common option will be enabled by default in GCC 10.
    
    Bug: https://bugs.gentoo.org/707462
    Signed-off-by: Mike Gilbert <floppym@gentoo.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 6d44fec55ad5..7c77045fef52 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -27,6 +27,8 @@ struct cpuidle_monitor *all_monitors[] = {
 0
 };
 
+int cpu_count;
+
 static struct cpuidle_monitor *monitors[MONITORS_MAX];
 static unsigned int avail_monitors;
 

commit d3f5d2a192a299f56579ae6e6283f9011b00208f
Author: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
Date:   Tue Nov 5 17:16:52 2019 +0000

    cpupower: Move needs_root variable into a sub-struct
    
    Move the needs_root variable into a sub-struct. This is in preparation
    for adding a new flag for cpuidle_monitor.
    
    Update all uses of the needs_root variable to reflect this change.
    
    Signed-off-by: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index d3c3e6e7aa26..6d44fec55ad5 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -408,7 +408,7 @@ int cmd_monitor(int argc, char **argv)
 		dprint("Try to register: %s\n", all_monitors[num]->name);
 		test_mon = all_monitors[num]->do_register();
 		if (test_mon) {
-			if (test_mon->needs_root && !run_as_root) {
+			if (test_mon->flags.needs_root && !run_as_root) {
 				fprintf(stderr, _("Available monitor %s needs "
 					  "root access\n"), test_mon->name);
 				continue;

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 051da0a7c454..d3c3e6e7aa26 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -1,10 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
  *
- *  Licensed under the terms of the GNU GPL License version 2.
- *
  *  Output format inspired by Len Brown's <lenb@kernel.org> turbostat tool.
- *
  */
 
 

commit f9652d5cae04eb5e85303c087f5842d320499c65
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Mon May 28 06:03:03 2018 -0500

    cpupower : Fix header name to read idle state name
    
    The names of the idle states in the output of cpupower monitor command are
    truncated to 4 characters. On POWER9, this creates ambiguity as the states
    are named "stop0", "stop1", etc.
    
    root:~# cpupower monitor
                  |Idle_Stats
    PKG |CORE|CPU | snoo | stop | stop | stop | stop | stop | stop
       0|   0|   0|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  1.90
       0|   0|   1|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   2|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   3|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
    
    This patch modifies the output to print the state name that results in a
    legible output. The names will be printed with atmost 1 padding in left.
    
    root:~# cpupower monitor
                  | Idle_Stats
     PKG|CORE| CPU|snooze|stop0L| stop0|stop1L| stop1|stop2L| stop2
       0|   0|   0|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.72
       0|   0|   1|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   2|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   3|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
    
    This patch does not affect the output for intel.
    Output for intel before applying the patch:
    
    root:~# cpupower monitor
        |Idle_Stats
    CPU | POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S | C9-S | C10-
       0|  0.00|  0.14|  0.39|  0.35|  7.41|  0.00| 17.67|  1.01| 70.03
       2|  0.00|  0.19|  0.47|  0.10|  6.50|  0.00| 29.66|  2.17| 58.07
       1|  0.00|  0.11|  0.50|  1.50|  9.11|  0.18| 18.19|  0.40| 66.63
       3|  0.00|  0.67|  0.42|  0.03|  5.84|  0.00| 12.58|  0.77| 77.14
    
    Output for intel after applying the patch:
    
    root:~# cpupower monitor
        | Idle_Stats
     CPU| POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S | C9-S | C10-
       0|  0.03|  0.33|  1.01|  0.27|  3.03|  0.00| 19.18|  0.00| 71.24
       2|  0.00|  1.58|  0.58|  0.42|  8.55|  0.09| 21.11|  0.99| 63.32
       1|  0.00|  1.26|  0.88|  0.43|  9.00|  0.02|  7.78|  4.65| 71.91
       3|  0.00|  0.30|  0.42|  0.06| 13.62|  0.21| 30.29|  0.00| 52.45
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 05f953f0f0a0..051da0a7c454 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -70,36 +70,43 @@ void print_n_spaces(int n)
 		printf(" ");
 }
 
-/* size of s must be at least n + 1 */
+/*s is filled with left and right spaces
+ *to make its length atleast n+1
+ */
 int fill_string_with_spaces(char *s, int n)
 {
+	char *temp;
 	int len = strlen(s);
-	if (len > n)
+
+	if (len >= n)
 		return -1;
+
+	temp = malloc(sizeof(char) * (n+1));
 	for (; len < n; len++)
 		s[len] = ' ';
 	s[len] = '\0';
+	snprintf(temp, n+1, " %s", s);
+	strcpy(s, temp);
+	free(temp);
 	return 0;
 }
 
+#define MAX_COL_WIDTH 6
 void print_header(int topology_depth)
 {
 	int unsigned mon;
 	int state, need_len;
 	cstate_t s;
 	char buf[128] = "";
-	int percent_width = 4;
 
 	fill_string_with_spaces(buf, topology_depth * 5 - 1);
 	printf("%s|", buf);
 
 	for (mon = 0; mon < avail_monitors; mon++) {
-		need_len = monitors[mon]->hw_states_num * (percent_width + 3)
+		need_len = monitors[mon]->hw_states_num * (MAX_COL_WIDTH + 1)
 			- 1;
-		if (mon != 0) {
-			printf("|| ");
-			need_len--;
-		}
+		if (mon != 0)
+			printf("||");
 		sprintf(buf, "%s", monitors[mon]->name);
 		fill_string_with_spaces(buf, need_len);
 		printf("%s", buf);
@@ -107,23 +114,21 @@ void print_header(int topology_depth)
 	printf("\n");
 
 	if (topology_depth > 2)
-		printf("PKG |");
+		printf(" PKG|");
 	if (topology_depth > 1)
 		printf("CORE|");
 	if (topology_depth > 0)
-		printf("CPU |");
+		printf(" CPU|");
 
 	for (mon = 0; mon < avail_monitors; mon++) {
 		if (mon != 0)
-			printf("|| ");
-		else
-			printf(" ");
+			printf("||");
 		for (state = 0; state < monitors[mon]->hw_states_num; state++) {
 			if (state != 0)
-				printf(" | ");
+				printf("|");
 			s = monitors[mon]->hw_states[state];
 			sprintf(buf, "%s", s.name);
-			fill_string_with_spaces(buf, percent_width);
+			fill_string_with_spaces(buf, MAX_COL_WIDTH);
 			printf("%s", buf);
 		}
 		printf(" ");

commit 20102ac5bee3c7c1ffff43f220e37328b6fffd16
Author: Jacob Tanenbaum <jtanenba@redhat.com>
Date:   Thu Oct 22 17:17:05 2015 +0200

    cpupower: cpupower monitor reports uninitialized values for offline cpus
    
    [root@hp-dl980g7-02 linux]# cpupower monitor
    ...
    5472|   0|   1|******|******|******|******|| 0.00|  0.00|  0.00|  0.00|  0.00 *is offline
    10567|   0| 159|******|******|******|******||  0.00|  0.00|  0.00|  0.00|  0.00 *is offline
    1661206560|859272560| 150|******|******|******|******|| 0.00|  0.00|  0.00|  0.00|  0.00 *is offline
    1661206560|943093104| 140|******|******|******|******|| 0.00|  0.00|  0.00|  0.00|  0.00 *is offline
    
    because of this cpupower also holds the incorrect value for the number
    of physical packages in the machine
    
    Changed cpupower to initialize the values of an offline cpu's socket and
    core to -1, warn the user that one or more cpus is/are
    offline and not print statistics for offline cpus.
    
    This fix hides offlined cores where topology cannot be accessed.
    With a recent kernel patch suggested from Prarit Bhargava it may be possible
    that soft offlined cores' topology can still be parsed.
    This patch would then show which cores in which package/socket are offline,
    when sane toplogoy information is available.
    
    Signed-off-by: Jacob Tanenbaum <jtanenba@redhat.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index c4bae9203a69..05f953f0f0a0 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -143,6 +143,9 @@ void print_results(int topology_depth, int cpu)
 	/* Be careful CPUs may got resorted for pkg value do not just use cpu */
 	if (!bitmask_isbitset(cpus_chosen, cpu_top.core_info[cpu].cpu))
 		return;
+	if (!cpu_top.core_info[cpu].is_online &&
+	    cpu_top.core_info[cpu].pkg == -1)
+		return;
 
 	if (topology_depth > 2)
 		printf("%4d|", cpu_top.core_info[cpu].pkg);
@@ -191,7 +194,8 @@ void print_results(int topology_depth, int cpu)
 	 * It's up to the monitor plug-in to check .is_online, this one
 	 * is just for additional info.
 	 */
-	if (!cpu_top.core_info[cpu].is_online) {
+	if (!cpu_top.core_info[cpu].is_online &&
+	    cpu_top.core_info[cpu].pkg != -1) {
 		printf(_(" *is offline\n"));
 		return;
 	} else
@@ -388,6 +392,9 @@ int cmd_monitor(int argc, char **argv)
 		return EXIT_FAILURE;
 	}
 
+	if (!cpu_top.core_info[0].is_online)
+		printf("WARNING: at least one cpu is offline\n");
+
 	/* Default is: monitor all CPUs */
 	if (bitmask_isallclear(cpus_chosen))
 		bitmask_setall(cpus_chosen);

commit c8cfc3c6bf404b0f110631d5bba234982e6ad24f
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Nov 27 13:17:48 2012 +0100

    cpupower: Provide -c param for cpupower monitor to schedule process on all cores
    
    If an MSR based monitor is run in parallel this is not needed. This is the
    default case on all/most Intel machines.
    
    But when only sysfs info is read via cpupower monitor -m Idle_Stats (typically
    the case for non root users) or when other monitors are PCI based (AMD),
    Idle_Stats, read from sysfs can be totally bogus:
    
    cpupower monitor -m Idle_Stats
    PKG |CORE|CPU | POLL | C1-N | C3-N | C6-N
       0|   0|   0|  0.00|  0.00|  0.24| 99.81
       0|   0|  32|  0.00|  0.00|  0.00| 100.7
    ...
       0|  17|  20|  0.00|  0.00|  0.00| 173.1
       0|  17|  52|  0.00|  0.00|  0.07| 173.0
       0|  18|  68|  0.00|  0.00|  0.00|  0.00
       0|  18|  76|  0.00|  0.00|  0.00|  0.00
    ...
    
    With the -c option all cores are woken up and the kernel
    did update cpuidle statistics before reading out sysfs.
    This causes some overhead. Therefore avoid if possible, use
    if needed:
    
    cpupower monitor -c -m Idle_Stats
    PKG |CORE|CPU | POLL | C1-N | C3-N | C6-N
       0|   0|   0|  0.00|  0.00|  0.00| 100.2
       0|   0|  32|  0.00|  0.00|  0.00| 100.2
    ...
       0|   8|   8|  0.00|  0.00|  0.00| 99.82
       0|   8|  40|  0.00|  0.00|  0.00| 99.81
       0|   9|  24|  0.00|  0.00|  0.00| 100.3
       0|   9|  56|  0.00|  0.00|  0.00| 100.2
       0|  16|   4|  0.00|  0.00|  0.00| 99.75
       0|  16|  36|  0.00|  0.00|  0.00| 99.38
    ...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 7a657f3da23b..c4bae9203a69 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -39,6 +39,7 @@ static int mode;
 static int interval = 1;
 static char *show_monitors_param;
 static struct cpupower_topology cpu_top;
+static unsigned int wake_cpus;
 
 /* ToDo: Document this in the manpage */
 static char range_abbr[RANGE_MAX] = { 'T', 'C', 'P', 'M', };
@@ -314,16 +315,28 @@ int fork_it(char **argv)
 int do_interval_measure(int i)
 {
 	unsigned int num;
+	int cpu;
+
+	if (wake_cpus)
+		for (cpu = 0; cpu < cpu_count; cpu++)
+			bind_cpu(cpu);
 
 	for (num = 0; num < avail_monitors; num++) {
 		dprint("HW C-state residency monitor: %s - States: %d\n",
 		       monitors[num]->name, monitors[num]->hw_states_num);
 		monitors[num]->start();
 	}
+
 	sleep(i);
+
+	if (wake_cpus)
+		for (cpu = 0; cpu < cpu_count; cpu++)
+			bind_cpu(cpu);
+
 	for (num = 0; num < avail_monitors; num++)
 		monitors[num]->stop();
 
+
 	return 0;
 }
 
@@ -332,7 +345,7 @@ static void cmdline(int argc, char *argv[])
 	int opt;
 	progname = basename(argv[0]);
 
-	while ((opt = getopt(argc, argv, "+li:m:")) != -1) {
+	while ((opt = getopt(argc, argv, "+lci:m:")) != -1) {
 		switch (opt) {
 		case 'l':
 			if (mode)
@@ -351,6 +364,9 @@ static void cmdline(int argc, char *argv[])
 			mode = show;
 			show_monitors_param = optarg;
 			break;
+		case 'c':
+			wake_cpus = 1;
+			break;
 		default:
 			print_wrong_arg_exit();
 		}

commit fb8eaeb7ab96b09c910e36abf7df7f9ecbb0fb60
Author: Palmer Cox <p@lmercox.com>
Date:   Tue Nov 27 13:17:44 2012 +0100

    cpupower tools: Fix minor warnings
    
    Fix minor warnings reported with GCC 4.6:
    * The sysfs_write_file function is unused - remove it.
    * The pr_mon_len in the print_header function is unsed - remove it.
    
    Signed-off-by: Palmer Cox <p@lmercox.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 0d6571e418db..7a657f3da23b 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -84,7 +84,7 @@ int fill_string_with_spaces(char *s, int n)
 void print_header(int topology_depth)
 {
 	int unsigned mon;
-	int state, need_len, pr_mon_len;
+	int state, need_len;
 	cstate_t s;
 	char buf[128] = "";
 	int percent_width = 4;
@@ -93,7 +93,6 @@ void print_header(int topology_depth)
 	printf("%s|", buf);
 
 	for (mon = 0; mon < avail_monitors; mon++) {
-		pr_mon_len = 0;
 		need_len = monitors[mon]->hw_states_num * (percent_width + 3)
 			- 1;
 		if (mon != 0) {

commit 498ca793d90aef8ad38a852a969c257f62832738
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 6 18:11:43 2011 +0200

    cpupower: use man(1) when calling "cpupower help subcommand"
    
    Instead of printing something non-formatted to stdout, call
    man(1) to show the man page for the proper subcommand.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 6cb8d9e6bb6b..0d6571e418db 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -43,6 +43,12 @@ static struct cpupower_topology cpu_top;
 /* ToDo: Document this in the manpage */
 static char range_abbr[RANGE_MAX] = { 'T', 'C', 'P', 'M', };
 
+static void print_wrong_arg_exit(void)
+{
+	printf(_("invalid or unknown argument\n"));
+	exit(EXIT_FAILURE);
+}
+
 long long timespec_diff_us(struct timespec start, struct timespec end)
 {
 	struct timespec temp;
@@ -56,21 +62,6 @@ long long timespec_diff_us(struct timespec start, struct timespec end)
 	return (temp.tv_sec * 1000000) + (temp.tv_nsec / 1000);
 }
 
-void monitor_help(void)
-{
-	printf(_("cpupower monitor: [-m <mon1>,[<mon2>],.. ] command\n"));
-	printf(_("cpupower monitor: [-m <mon1>,[<mon2>],.. ] [ -i interval_sec ]\n"));
-	printf(_("cpupower monitor: -l\n"));
-	printf(_("\t command: pass an arbitrary command to measure specific workload\n"));
-	printf(_("\t -i: time intervall to measure for in seconds (default 1)\n"));
-	printf(_("\t -l: list available CPU sleep monitors (for use with -m)\n"));
-	printf(_("\t -m: show specific CPU sleep monitors only (in same order)\n"));
-	printf(_("\t -h: print this help\n"));
-	printf("\n");
-	printf(_("only one of: -l, -m are allowed\nIf none of them is passed,"));
-	printf(_(" all supported monitors are shown\n"));
-}
-
 void print_n_spaces(int n)
 {
 	int x;
@@ -246,7 +237,6 @@ static void parse_monitor_param(char *param)
 	if (hits == 0) {
 		printf(_("No matching monitor found in %s, "
 			 "try -l option\n"), param);
-		monitor_help();
 		exit(EXIT_FAILURE);
 	}
 	/* Override detected/registerd monitors array with requested one */
@@ -343,37 +333,27 @@ static void cmdline(int argc, char *argv[])
 	int opt;
 	progname = basename(argv[0]);
 
-	while ((opt = getopt(argc, argv, "+hli:m:")) != -1) {
+	while ((opt = getopt(argc, argv, "+li:m:")) != -1) {
 		switch (opt) {
-		case 'h':
-			monitor_help();
-			exit(EXIT_SUCCESS);
 		case 'l':
-			if (mode) {
-				monitor_help();
-				exit(EXIT_FAILURE);
-			}
+			if (mode)
+				print_wrong_arg_exit();
 			mode = list;
 			break;
 		case 'i':
 			/* only allow -i with -m or no option */
-			if (mode && mode != show) {
-				monitor_help();
-				exit(EXIT_FAILURE);
-			}
+			if (mode && mode != show)
+				print_wrong_arg_exit();
 			interval = atoi(optarg);
 			break;
 		case 'm':
-			if (mode) {
-				monitor_help();
-				exit(EXIT_FAILURE);
-			}
+			if (mode)
+				print_wrong_arg_exit();
 			mode = show;
 			show_monitors_param = optarg;
 			break;
 		default:
-			monitor_help();
-			exit(EXIT_FAILURE);
+			print_wrong_arg_exit();
 		}
 	}
 	if (!mode)

commit 9ee31f618a3c8209b2bd4bedd71fd5f2be7786bd
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 12 01:11:38 2011 +0200

    cpupower: Make monitor command -c/--cpu aware
    
    This allows for example:
    cpupower -c 2-4,6 monitor -m Mperf
                  |Mperf
    PKG |CORE|CPU | C0   | Cx   | Freq
       0|   8|   4|  2.42| 97.58|  1353
       0|  16|   2| 14.38| 85.62|  1928
       0|  24|   6|  1.76| 98.24|  1442
       1|  16|   3| 15.53| 84.47|  1650
    
    CPUs always get resorted for package, core then cpu id if it could get read out
    (or however you name these topology levels...).
    Still this is a nice way to keep the overview if a test binary is bound to
    a specific CPU or if one wants to show all CPUs inside a package or similar.
    
    Still missing: Do not measure not available cores to reduce the overhead
    and achieve better results.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index dd8e1ea6e6f2..6cb8d9e6bb6b 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -149,6 +149,10 @@ void print_results(int topology_depth, int cpu)
 	unsigned long long result;
 	cstate_t s;
 
+	/* Be careful CPUs may got resorted for pkg value do not just use cpu */
+	if (!bitmask_isbitset(cpus_chosen, cpu_top.core_info[cpu].cpu))
+		return;
+
 	if (topology_depth > 2)
 		printf("%4d|", cpu_top.core_info[cpu].pkg);
 	if (topology_depth > 1)
@@ -389,6 +393,10 @@ int cmd_monitor(int argc, char **argv)
 		return EXIT_FAILURE;
 	}
 
+	/* Default is: monitor all CPUs */
+	if (bitmask_isallclear(cpus_chosen))
+		bitmask_setall(cpus_chosen);
+
 	dprint("System has up to %d CPU cores\n", cpu_count);
 
 	for (num = 0; all_monitors[num]; num++) {

commit 7c74d2bc5a9d43d33d6f16c1e706147162e2bc52
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 12 01:11:37 2011 +0200

    cpupower: Better detect offlined CPUs
    
    Before, checking for offlined CPUs was done dirty and
    it was checked whether topology parsing returned -1 values.
    But this is a valid case on a Xen (and possibly other) kernels.
    
    Do proper online/offline checking, also take CONFIG_HOTPLUG_CPU
    option into account (no /sys/devices/../cpuX/online file).
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index ba4bf068380d..dd8e1ea6e6f2 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -190,9 +190,13 @@ void print_results(int topology_depth, int cpu)
 			}
 		}
 	}
-	/* cpu offline */
-	if (cpu_top.core_info[cpu].pkg == -1 ||
-	    cpu_top.core_info[cpu].core == -1) {
+	/*
+	 * The monitor could still provide useful data, for example
+	 * AMD HW counters partly sit in PCI config space.
+	 * It's up to the monitor plug-in to check .is_online, this one
+	 * is just for additional info.
+	 */
+	if (!cpu_top.core_info[cpu].is_online) {
 		printf(_(" *is offline\n"));
 		return;
 	} else

commit b510b54127a4d4112a9a3f200339719bcb463c15
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:58:59 2011 +0200

    cpupowerutils: idle_monitor - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
index 3e96e79de3c2..ba4bf068380d 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -24,7 +24,7 @@
 
 /* Define pointers to all monitors.  */
 #define DEF(x) & x ## _monitor ,
-struct cpuidle_monitor * all_monitors[] = {
+struct cpuidle_monitor *all_monitors[] = {
 #include "idle_monitors.def"
 0
 };
@@ -76,19 +76,19 @@ void print_n_spaces(int n)
 	int x;
 	for (x = 0; x < n; x++)
 		printf(" ");
-}	
+}
 
 /* size of s must be at least n + 1 */
 int fill_string_with_spaces(char *s, int n)
 {
-        int len = strlen(s);
+	int len = strlen(s);
 	if (len > n)
 		return -1;
-        for (; len < n; len++)
-                s[len] = ' ';
-        s[len] = '\0';
+	for (; len < n; len++)
+		s[len] = ' ';
+	s[len] = '\0';
 	return 0;
-} 
+}
 
 void print_header(int topology_depth)
 {
@@ -107,7 +107,7 @@ void print_header(int topology_depth)
 			- 1;
 		if (mon != 0) {
 			printf("|| ");
-			need_len --;
+			need_len--;
 		}
 		sprintf(buf, "%s", monitors[mon]->name);
 		fill_string_with_spaces(buf, need_len);
@@ -169,26 +169,24 @@ void print_results(int topology_depth, int cpu)
 			if (s.get_count_percent) {
 				ret = s.get_count_percent(s.id, &percent,
 						  cpu_top.core_info[cpu].cpu);
-				if (ret) {
+				if (ret)
 					printf("******");
-				} else if (percent >= 100.0)
+				else if (percent >= 100.0)
 					printf("%6.1f", percent);
 				else
 					printf("%6.2f", percent);
-			}
-			else if (s.get_count) {
+			} else if (s.get_count) {
 				ret = s.get_count(s.id, &result,
 						  cpu_top.core_info[cpu].cpu);
-				if (ret) {
+				if (ret)
 					printf("******");
-				} else
+				else
 					printf("%6llu", result);
-			}
-			else {
+			} else {
 				printf(_("Monitor %s, Counter %s has no count "
 					 "function. Implementation error\n"),
 				       monitors[mon]->name, s.name);
-				exit (EXIT_FAILURE);
+				exit(EXIT_FAILURE);
 			}
 		}
 	}
@@ -211,7 +209,7 @@ void print_results(int topology_depth, int cpu)
  * Monitors get sorted in the same order the user passes them
 */
 
-static void parse_monitor_param(char* param)
+static void parse_monitor_param(char *param)
 {
 	unsigned int num;
 	int mon, hits = 0;
@@ -219,7 +217,7 @@ static void parse_monitor_param(char* param)
 	struct cpuidle_monitor *tmp_mons[MONITORS_MAX];
 
 
-	for (mon = 0; mon < MONITORS_MAX;mon++, tmp = NULL) {
+	for (mon = 0; mon < MONITORS_MAX; mon++, tmp = NULL) {
 		token = strtok(tmp, ",");
 		if (token == NULL)
 			break;
@@ -235,7 +233,7 @@ static void parse_monitor_param(char* param)
 				tmp_mons[hits] = monitors[num];
 				hits++;
 			}
-		}	
+		}
 	}
 	if (hits == 0) {
 		printf(_("No matching monitor found in %s, "
@@ -244,20 +242,23 @@ static void parse_monitor_param(char* param)
 		exit(EXIT_FAILURE);
 	}
 	/* Override detected/registerd monitors array with requested one */
-	memcpy(monitors, tmp_mons, sizeof(struct cpuidle_monitor*) * MONITORS_MAX);
+	memcpy(monitors, tmp_mons,
+		sizeof(struct cpuidle_monitor *) * MONITORS_MAX);
 	avail_monitors = hits;
 }
 
-void list_monitors(void) {
+void list_monitors(void)
+{
 	unsigned int mon;
 	int state;
 	cstate_t s;
 
 	for (mon = 0; mon < avail_monitors; mon++) {
 		printf(_("Monitor \"%s\" (%d states) - Might overflow after %u "
-			 "s\n"), monitors[mon]->name, monitors[mon]->hw_states_num,
-		       monitors[mon]->overflow_s);
-		       
+			 "s\n"),
+			monitors[mon]->name, monitors[mon]->hw_states_num,
+			monitors[mon]->overflow_s);
+
 		for (state = 0; state < monitors[mon]->hw_states_num; state++) {
 			s = monitors[mon]->hw_states[state];
 			/*
@@ -308,7 +309,8 @@ int fork_it(char **argv)
 	timediff = timespec_diff_us(start, end);
 	if (WIFEXITED(status))
 		printf(_("%s took %.5f seconds and exited with status %d\n"),
-		       argv[0], timediff / (1000.0 * 1000), WEXITSTATUS(status));
+			argv[0], timediff / (1000.0 * 1000),
+			WEXITSTATUS(status));
 	return 0;
 }
 
@@ -322,9 +324,9 @@ int do_interval_measure(int i)
 		monitors[num]->start();
 	}
 	sleep(i);
-	for (num = 0; num < avail_monitors; num++) {
+	for (num = 0; num < avail_monitors; num++)
 		monitors[num]->stop();
-	}
+
 	return 0;
 }
 
@@ -384,7 +386,7 @@ int cmd_monitor(int argc, char **argv)
 	}
 
 	dprint("System has up to %d CPU cores\n", cpu_count);
-	
+
 	for (num = 0; all_monitors[num]; num++) {
 		dprint("Try to register: %s\n", all_monitors[num]->name);
 		test_mon = all_monitors[num]->do_register();
@@ -438,9 +440,9 @@ int cmd_monitor(int argc, char **argv)
 			print_results(1, cpu);
 	}
 
-	for (num = 0; num < avail_monitors; num++) {
+	for (num = 0; num < avail_monitors; num++)
 		monitors[num]->unregister();
-	}
+
 	cpu_topology_release(cpu_top);
 	return 0;
 }

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
new file mode 100644
index 000000000000..3e96e79de3c2
--- /dev/null
+++ b/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c
@@ -0,0 +1,446 @@
+/*
+ *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ *
+ *  Output format inspired by Len Brown's <lenb@kernel.org> turbostat tool.
+ *
+ */
+
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <libgen.h>
+
+#include "idle_monitor/cpupower-monitor.h"
+#include "idle_monitor/idle_monitors.h"
+#include "helpers/helpers.h"
+
+/* Define pointers to all monitors.  */
+#define DEF(x) & x ## _monitor ,
+struct cpuidle_monitor * all_monitors[] = {
+#include "idle_monitors.def"
+0
+};
+
+static struct cpuidle_monitor *monitors[MONITORS_MAX];
+static unsigned int avail_monitors;
+
+static char *progname;
+
+enum operation_mode_e { list = 1, show, show_all };
+static int mode;
+static int interval = 1;
+static char *show_monitors_param;
+static struct cpupower_topology cpu_top;
+
+/* ToDo: Document this in the manpage */
+static char range_abbr[RANGE_MAX] = { 'T', 'C', 'P', 'M', };
+
+long long timespec_diff_us(struct timespec start, struct timespec end)
+{
+	struct timespec temp;
+	if ((end.tv_nsec - start.tv_nsec) < 0) {
+		temp.tv_sec = end.tv_sec - start.tv_sec - 1;
+		temp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
+	} else {
+		temp.tv_sec = end.tv_sec - start.tv_sec;
+		temp.tv_nsec = end.tv_nsec - start.tv_nsec;
+	}
+	return (temp.tv_sec * 1000000) + (temp.tv_nsec / 1000);
+}
+
+void monitor_help(void)
+{
+	printf(_("cpupower monitor: [-m <mon1>,[<mon2>],.. ] command\n"));
+	printf(_("cpupower monitor: [-m <mon1>,[<mon2>],.. ] [ -i interval_sec ]\n"));
+	printf(_("cpupower monitor: -l\n"));
+	printf(_("\t command: pass an arbitrary command to measure specific workload\n"));
+	printf(_("\t -i: time intervall to measure for in seconds (default 1)\n"));
+	printf(_("\t -l: list available CPU sleep monitors (for use with -m)\n"));
+	printf(_("\t -m: show specific CPU sleep monitors only (in same order)\n"));
+	printf(_("\t -h: print this help\n"));
+	printf("\n");
+	printf(_("only one of: -l, -m are allowed\nIf none of them is passed,"));
+	printf(_(" all supported monitors are shown\n"));
+}
+
+void print_n_spaces(int n)
+{
+	int x;
+	for (x = 0; x < n; x++)
+		printf(" ");
+}	
+
+/* size of s must be at least n + 1 */
+int fill_string_with_spaces(char *s, int n)
+{
+        int len = strlen(s);
+	if (len > n)
+		return -1;
+        for (; len < n; len++)
+                s[len] = ' ';
+        s[len] = '\0';
+	return 0;
+} 
+
+void print_header(int topology_depth)
+{
+	int unsigned mon;
+	int state, need_len, pr_mon_len;
+	cstate_t s;
+	char buf[128] = "";
+	int percent_width = 4;
+
+	fill_string_with_spaces(buf, topology_depth * 5 - 1);
+	printf("%s|", buf);
+
+	for (mon = 0; mon < avail_monitors; mon++) {
+		pr_mon_len = 0;
+		need_len = monitors[mon]->hw_states_num * (percent_width + 3)
+			- 1;
+		if (mon != 0) {
+			printf("|| ");
+			need_len --;
+		}
+		sprintf(buf, "%s", monitors[mon]->name);
+		fill_string_with_spaces(buf, need_len);
+		printf("%s", buf);
+	}
+	printf("\n");
+
+	if (topology_depth > 2)
+		printf("PKG |");
+	if (topology_depth > 1)
+		printf("CORE|");
+	if (topology_depth > 0)
+		printf("CPU |");
+
+	for (mon = 0; mon < avail_monitors; mon++) {
+		if (mon != 0)
+			printf("|| ");
+		else
+			printf(" ");
+		for (state = 0; state < monitors[mon]->hw_states_num; state++) {
+			if (state != 0)
+				printf(" | ");
+			s = monitors[mon]->hw_states[state];
+			sprintf(buf, "%s", s.name);
+			fill_string_with_spaces(buf, percent_width);
+			printf("%s", buf);
+		}
+		printf(" ");
+	}
+	printf("\n");
+}
+
+
+void print_results(int topology_depth, int cpu)
+{
+	unsigned int mon;
+	int state, ret;
+	double percent;
+	unsigned long long result;
+	cstate_t s;
+
+	if (topology_depth > 2)
+		printf("%4d|", cpu_top.core_info[cpu].pkg);
+	if (topology_depth > 1)
+		printf("%4d|", cpu_top.core_info[cpu].core);
+	if (topology_depth > 0)
+		printf("%4d|", cpu_top.core_info[cpu].cpu);
+
+	for (mon = 0; mon < avail_monitors; mon++) {
+		if (mon != 0)
+			printf("||");
+
+		for (state = 0; state < monitors[mon]->hw_states_num; state++) {
+			if (state != 0)
+				printf("|");
+
+			s = monitors[mon]->hw_states[state];
+
+			if (s.get_count_percent) {
+				ret = s.get_count_percent(s.id, &percent,
+						  cpu_top.core_info[cpu].cpu);
+				if (ret) {
+					printf("******");
+				} else if (percent >= 100.0)
+					printf("%6.1f", percent);
+				else
+					printf("%6.2f", percent);
+			}
+			else if (s.get_count) {
+				ret = s.get_count(s.id, &result,
+						  cpu_top.core_info[cpu].cpu);
+				if (ret) {
+					printf("******");
+				} else
+					printf("%6llu", result);
+			}
+			else {
+				printf(_("Monitor %s, Counter %s has no count "
+					 "function. Implementation error\n"),
+				       monitors[mon]->name, s.name);
+				exit (EXIT_FAILURE);
+			}
+		}
+	}
+	/* cpu offline */
+	if (cpu_top.core_info[cpu].pkg == -1 ||
+	    cpu_top.core_info[cpu].core == -1) {
+		printf(_(" *is offline\n"));
+		return;
+	} else
+		printf("\n");
+}
+
+
+/* param: string passed by -m param (The list of monitors to show)
+ *
+ * Monitors must have been registered already, matching monitors
+ * are picked out and available monitors array is overridden
+ * with matching ones
+ *
+ * Monitors get sorted in the same order the user passes them
+*/
+
+static void parse_monitor_param(char* param)
+{
+	unsigned int num;
+	int mon, hits = 0;
+	char *tmp = param, *token;
+	struct cpuidle_monitor *tmp_mons[MONITORS_MAX];
+
+
+	for (mon = 0; mon < MONITORS_MAX;mon++, tmp = NULL) {
+		token = strtok(tmp, ",");
+		if (token == NULL)
+			break;
+		if (strlen(token) >= MONITOR_NAME_LEN) {
+			printf(_("%s: max monitor name length"
+				 " (%d) exceeded\n"), token, MONITOR_NAME_LEN);
+			continue;
+		}
+
+		for (num = 0; num < avail_monitors; num++) {
+			if (!strcmp(monitors[num]->name, token)) {
+				dprint("Found requested monitor: %s\n", token);
+				tmp_mons[hits] = monitors[num];
+				hits++;
+			}
+		}	
+	}
+	if (hits == 0) {
+		printf(_("No matching monitor found in %s, "
+			 "try -l option\n"), param);
+		monitor_help();
+		exit(EXIT_FAILURE);
+	}
+	/* Override detected/registerd monitors array with requested one */
+	memcpy(monitors, tmp_mons, sizeof(struct cpuidle_monitor*) * MONITORS_MAX);
+	avail_monitors = hits;
+}
+
+void list_monitors(void) {
+	unsigned int mon;
+	int state;
+	cstate_t s;
+
+	for (mon = 0; mon < avail_monitors; mon++) {
+		printf(_("Monitor \"%s\" (%d states) - Might overflow after %u "
+			 "s\n"), monitors[mon]->name, monitors[mon]->hw_states_num,
+		       monitors[mon]->overflow_s);
+		       
+		for (state = 0; state < monitors[mon]->hw_states_num; state++) {
+			s = monitors[mon]->hw_states[state];
+			/*
+			 * ToDo show more state capabilities:
+			 * percent, time (granlarity)
+			 */
+			printf("%s\t[%c] -> %s\n", s.name, range_abbr[s.range],
+			       gettext(s.desc));
+		}
+	}
+}
+
+int fork_it(char **argv)
+{
+	int status;
+	unsigned int num;
+	unsigned long long timediff;
+	pid_t child_pid;
+	struct timespec start, end;
+
+	child_pid = fork();
+	clock_gettime(CLOCK_REALTIME, &start);
+
+	for (num = 0; num < avail_monitors; num++)
+		monitors[num]->start();
+
+	if (!child_pid) {
+		/* child */
+		execvp(argv[0], argv);
+	} else {
+		/* parent */
+		if (child_pid == -1) {
+			perror("fork");
+			exit(1);
+		}
+
+		signal(SIGINT, SIG_IGN);
+		signal(SIGQUIT, SIG_IGN);
+		if (waitpid(child_pid, &status, 0) == -1) {
+			perror("wait");
+			exit(1);
+		}
+	}
+	clock_gettime(CLOCK_REALTIME, &end);
+	for (num = 0; num < avail_monitors; num++)
+		monitors[num]->stop();
+
+	timediff = timespec_diff_us(start, end);
+	if (WIFEXITED(status))
+		printf(_("%s took %.5f seconds and exited with status %d\n"),
+		       argv[0], timediff / (1000.0 * 1000), WEXITSTATUS(status));
+	return 0;
+}
+
+int do_interval_measure(int i)
+{
+	unsigned int num;
+
+	for (num = 0; num < avail_monitors; num++) {
+		dprint("HW C-state residency monitor: %s - States: %d\n",
+		       monitors[num]->name, monitors[num]->hw_states_num);
+		monitors[num]->start();
+	}
+	sleep(i);
+	for (num = 0; num < avail_monitors; num++) {
+		monitors[num]->stop();
+	}
+	return 0;
+}
+
+static void cmdline(int argc, char *argv[])
+{
+	int opt;
+	progname = basename(argv[0]);
+
+	while ((opt = getopt(argc, argv, "+hli:m:")) != -1) {
+		switch (opt) {
+		case 'h':
+			monitor_help();
+			exit(EXIT_SUCCESS);
+		case 'l':
+			if (mode) {
+				monitor_help();
+				exit(EXIT_FAILURE);
+			}
+			mode = list;
+			break;
+		case 'i':
+			/* only allow -i with -m or no option */
+			if (mode && mode != show) {
+				monitor_help();
+				exit(EXIT_FAILURE);
+			}
+			interval = atoi(optarg);
+			break;
+		case 'm':
+			if (mode) {
+				monitor_help();
+				exit(EXIT_FAILURE);
+			}
+			mode = show;
+			show_monitors_param = optarg;
+			break;
+		default:
+			monitor_help();
+			exit(EXIT_FAILURE);
+		}
+	}
+	if (!mode)
+		mode = show_all;
+}
+
+int cmd_monitor(int argc, char **argv)
+{
+	unsigned int num;
+	struct cpuidle_monitor *test_mon;
+	int cpu;
+
+	cmdline(argc, argv);
+	cpu_count = get_cpu_topology(&cpu_top);
+	if (cpu_count < 0) {
+		printf(_("Cannot read number of available processors\n"));
+		return EXIT_FAILURE;
+	}
+
+	dprint("System has up to %d CPU cores\n", cpu_count);
+	
+	for (num = 0; all_monitors[num]; num++) {
+		dprint("Try to register: %s\n", all_monitors[num]->name);
+		test_mon = all_monitors[num]->do_register();
+		if (test_mon) {
+			if (test_mon->needs_root && !run_as_root) {
+				fprintf(stderr, _("Available monitor %s needs "
+					  "root access\n"), test_mon->name);
+				continue;
+			}
+			monitors[avail_monitors] = test_mon;
+			dprint("%s registered\n", all_monitors[num]->name);
+			avail_monitors++;
+		}
+	}
+
+	if (avail_monitors == 0) {
+		printf(_("No HW Cstate monitors found\n"));
+		return 1;
+	}
+
+	if (mode == list) {
+		list_monitors();
+		exit(EXIT_SUCCESS);
+	}
+
+	if (mode == show)
+		parse_monitor_param(show_monitors_param);
+
+	dprint("Packages: %d - Cores: %d - CPUs: %d\n",
+	       cpu_top.pkgs, cpu_top.cores, cpu_count);
+
+	/*
+	 * if any params left, it must be a command to fork
+	 */
+	if (argc - optind)
+		fork_it(argv + optind);
+	else
+		do_interval_measure(interval);
+
+	/* ToDo: Topology parsing needs fixing first to do
+	   this more generically */
+	if (cpu_top.pkgs > 1)
+		print_header(3);
+	else
+		print_header(1);
+
+	for (cpu = 0; cpu < cpu_count; cpu++) {
+		if (cpu_top.pkgs > 1)
+			print_results(3, cpu);
+		else
+			print_results(1, cpu);
+	}
+
+	for (num = 0; num < avail_monitors; num++) {
+		monitors[num]->unregister();
+	}
+	cpu_topology_release(cpu_top);
+	return 0;
+}
