commit 7b0bf99b9ee497cc0f079472566aff716d033d43
Author: Zou Wei <zou_wei@huawei.com>
Date:   Tue Apr 28 17:43:15 2020 +0800

    cpupower: Remove unneeded semicolon
    
    Fixes coccicheck warnings:
    
    tools/power/cpupower/utils/cpupower-info.c:65:2-3: Unneeded semicolon
    tools/power/cpupower/utils/cpupower-set.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c:120:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:175:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:56:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/hsw_ext_idle.c:82:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/nhm_idle.c:94:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/snb_idle.c:80:2-3: Unneeded semicolon
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zou Wei <zou_wei@huawei.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index a65f7d011513..8b42c2f0a5b0 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -53,7 +53,7 @@ static int cpuidle_start(void)
 			dprint("CPU %d - State: %d - Val: %llu\n",
 			       cpu, state, previous_count[cpu][state]);
 		}
-	};
+	}
 	return 0;
 }
 
@@ -72,7 +72,7 @@ static int cpuidle_stop(void)
 			dprint("CPU %d - State: %d - Val: %llu\n",
 			       cpu, state, previous_count[cpu][state]);
 		}
-	};
+	}
 	return 0;
 }
 
@@ -172,7 +172,7 @@ static struct cpuidle_monitor *cpuidle_register(void)
 		cpuidle_cstates[num].id = num;
 		cpuidle_cstates[num].get_count_percent =
 			cpuidle_get_count_percent;
-	};
+	}
 
 	/* Free this at program termination */
 	previous_count = malloc(sizeof(long long *) * cpu_count);

commit 2de7fb60a4740135e03cf55c1982e393ccb87b6b
Author: Mike Gilbert <floppym@gentoo.org>
Date:   Wed Feb 26 14:33:59 2020 -0500

    cpupower: avoid multiple definition with gcc -fno-common
    
    Building cpupower with -fno-common in CFLAGS results in errors due to
    multiple definitions of the 'cpu_count' and 'start_time' variables.
    
    ./utils/idle_monitor/snb_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    multiple definition of `cpu_count';
    ./utils/idle_monitor/nhm_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    first defined here
    ...
    ./utils/idle_monitor/cpuidle_sysfs.o:./utils/idle_monitor/cpuidle_sysfs.c:22:
    multiple definition of `start_time';
    ./utils/idle_monitor/amd_fam14h_idle.o:./utils/idle_monitor/amd_fam14h_idle.c:85:
    first defined here
    
    The -fno-common option will be enabled by default in GCC 10.
    
    Bug: https://bugs.gentoo.org/707462
    Signed-off-by: Mike Gilbert <floppym@gentoo.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index 3c4cee160b0e..a65f7d011513 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -19,7 +19,7 @@ struct cpuidle_monitor cpuidle_sysfs_monitor;
 
 static unsigned long long **previous_count;
 static unsigned long long **current_count;
-struct timespec start_time;
+static struct timespec start_time;
 static unsigned long long timediff;
 
 static int cpuidle_get_count_percent(unsigned int id, double *percent,

commit d3f5d2a192a299f56579ae6e6283f9011b00208f
Author: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
Date:   Tue Nov 5 17:16:52 2019 +0000

    cpupower: Move needs_root variable into a sub-struct
    
    Move the needs_root variable into a sub-struct. This is in preparation
    for adding a new flag for cpuidle_monitor.
    
    Update all uses of the needs_root variable to reflect this change.
    
    Signed-off-by: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index f634aeb65c5f..3c4cee160b0e 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -207,6 +207,6 @@ struct cpuidle_monitor cpuidle_sysfs_monitor = {
 	.stop			= cpuidle_stop,
 	.do_register		= cpuidle_register,
 	.unregister		= cpuidle_unregister,
-	.needs_root		= 0,
+	.flags.needs_root	= 0,
 	.overflow_s		= UINT_MAX,
 };

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index 5b8c4956ff9a..f634aeb65c5f 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -1,8 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc
- *
- *  Licensed under the terms of the GNU GPL License version 2.
- *
  */
 
 #include <stdio.h>

commit f9652d5cae04eb5e85303c087f5842d320499c65
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Mon May 28 06:03:03 2018 -0500

    cpupower : Fix header name to read idle state name
    
    The names of the idle states in the output of cpupower monitor command are
    truncated to 4 characters. On POWER9, this creates ambiguity as the states
    are named "stop0", "stop1", etc.
    
    root:~# cpupower monitor
                  |Idle_Stats
    PKG |CORE|CPU | snoo | stop | stop | stop | stop | stop | stop
       0|   0|   0|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  1.90
       0|   0|   1|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   2|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   3|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
    
    This patch modifies the output to print the state name that results in a
    legible output. The names will be printed with atmost 1 padding in left.
    
    root:~# cpupower monitor
                  | Idle_Stats
     PKG|CORE| CPU|snooze|stop0L| stop0|stop1L| stop1|stop2L| stop2
       0|   0|   0|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.72
       0|   0|   1|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   2|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
       0|   0|   3|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00|  0.00
    
    This patch does not affect the output for intel.
    Output for intel before applying the patch:
    
    root:~# cpupower monitor
        |Idle_Stats
    CPU | POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S | C9-S | C10-
       0|  0.00|  0.14|  0.39|  0.35|  7.41|  0.00| 17.67|  1.01| 70.03
       2|  0.00|  0.19|  0.47|  0.10|  6.50|  0.00| 29.66|  2.17| 58.07
       1|  0.00|  0.11|  0.50|  1.50|  9.11|  0.18| 18.19|  0.40| 66.63
       3|  0.00|  0.67|  0.42|  0.03|  5.84|  0.00| 12.58|  0.77| 77.14
    
    Output for intel after applying the patch:
    
    root:~# cpupower monitor
        | Idle_Stats
     CPU| POLL | C1-S | C1E- | C3-S | C6-S | C7s- | C8-S | C9-S | C10-
       0|  0.03|  0.33|  1.01|  0.27|  3.03|  0.00| 19.18|  0.00| 71.24
       2|  0.00|  1.58|  0.58|  0.42|  8.55|  0.09| 21.11|  0.99| 63.32
       1|  0.00|  1.26|  0.88|  0.43|  9.00|  0.02|  7.78|  4.65| 71.91
       3|  0.00|  0.30|  0.42|  0.06| 13.62|  0.21| 30.29|  0.00| 52.45
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index 5b3205f16217..5b8c4956ff9a 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -126,6 +126,20 @@ void fix_up_intel_idle_driver_name(char *tmp, int num)
 	}
 }
 
+#ifdef __powerpc__
+void map_power_idle_state_name(char *tmp)
+{
+	if (!strncmp(tmp, "stop0_lite", CSTATE_NAME_LEN))
+		strcpy(tmp, "stop0L");
+	else if (!strncmp(tmp, "stop1_lite", CSTATE_NAME_LEN))
+		strcpy(tmp, "stop1L");
+	else if (!strncmp(tmp, "stop2_lite", CSTATE_NAME_LEN))
+		strcpy(tmp, "stop2L");
+}
+#else
+void map_power_idle_state_name(char *tmp) { }
+#endif
+
 static struct cpuidle_monitor *cpuidle_register(void)
 {
 	int num;
@@ -145,6 +159,7 @@ static struct cpuidle_monitor *cpuidle_register(void)
 		if (tmp == NULL)
 			continue;
 
+		map_power_idle_state_name(tmp);
 		fix_up_intel_idle_driver_name(tmp, num);
 		strncpy(cpuidle_cstates[num].name, tmp, CSTATE_NAME_LEN - 1);
 		free(tmp);

commit dbdc468f35ee827cab2753caa1c660bdb832243a
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Wed Nov 15 14:10:02 2017 +0530

    cpupower : Fix cpupower working when cpu0 is offline
    
    cpuidle_monitor used to assume that cpu0 is always online which is not
    a valid assumption on POWER machines. This patch fixes this by getting
    the cpu on which the current thread is running, instead of always using
    cpu0 for monitoring which may not be online.
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index 1b5da0066ebf..5b3205f16217 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -130,15 +130,18 @@ static struct cpuidle_monitor *cpuidle_register(void)
 {
 	int num;
 	char *tmp;
+	int this_cpu;
+
+	this_cpu = sched_getcpu();
 
 	/* Assume idle state count is the same for all CPUs */
-	cpuidle_sysfs_monitor.hw_states_num = cpuidle_state_count(0);
+	cpuidle_sysfs_monitor.hw_states_num = cpuidle_state_count(this_cpu);
 
 	if (cpuidle_sysfs_monitor.hw_states_num <= 0)
 		return NULL;
 
 	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num++) {
-		tmp = cpuidle_state_name(0, num);
+		tmp = cpuidle_state_name(this_cpu, num);
 		if (tmp == NULL)
 			continue;
 
@@ -146,7 +149,7 @@ static struct cpuidle_monitor *cpuidle_register(void)
 		strncpy(cpuidle_cstates[num].name, tmp, CSTATE_NAME_LEN - 1);
 		free(tmp);
 
-		tmp = cpuidle_state_desc(0, num);
+		tmp = cpuidle_state_desc(this_cpu, num);
 		if (tmp == NULL)
 			continue;
 		strncpy(cpuidle_cstates[num].desc, tmp,	CSTATE_DESC_LEN - 1);

commit ac5a181d065d74fb6b213d538f743392f27bcdbd
Author: Thomas Renninger <trenn@suse.com>
Date:   Thu Apr 28 15:24:40 2016 +0200

    cpupower: Add cpuidle parts into library
    
    This more or less is a renaming and moving of functions and should not
    introduce any functional change.
    
    cpupower was built from cpufrequtils (which had a C library providing easy
    access to cpu frequency platform info). In the meantime it got enhanced
    by quite some neat cpuidle userspace tools.
    
    Now the cpu idle functions have been separated and added to the cpupower.so
    library.
    So beside an already existing public header file:
    cpufreq.h
    cpupower now also exports these cpu idle functions in:
    cpuidle.h
    
    Here again pasted for better review of the interfaces:
    
    ======================================
    int cpuidle_is_state_disabled(unsigned int cpu,
                                           unsigned int idlestate);
    int cpuidle_state_disable(unsigned int cpu, unsigned int idlestate,
                                       unsigned int disable);
    unsigned long cpuidle_state_latency(unsigned int cpu,
                                                    unsigned int idlestate);
    unsigned long cpuidle_state_usage(unsigned int cpu,
                                            unsigned int idlestate);
    unsigned long long cpuidle_state_time(unsigned int cpu,
                                                    unsigned int idlestate);
    char *cpuidle_state_name(unsigned int cpu,
                                    unsigned int idlestate);
    char *cpuidle_state_desc(unsigned int cpu,
                                    unsigned int idlestate);
    unsigned int cpuidle_state_count(unsigned int cpu);
    
    char *cpuidle_get_governor(void);
    char *cpuidle_get_driver(void);
    
    ======================================
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index bcd22a1a3970..1b5da0066ebf 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -10,8 +10,8 @@
 #include <stdint.h>
 #include <string.h>
 #include <limits.h>
+#include <cpuidle.h>
 
-#include "helpers/sysfs.h"
 #include "helpers/helpers.h"
 #include "idle_monitor/cpupower-monitor.h"
 
@@ -51,7 +51,7 @@ static int cpuidle_start(void)
 		for (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;
 		     state++) {
 			previous_count[cpu][state] =
-				sysfs_get_idlestate_time(cpu, state);
+				cpuidle_state_time(cpu, state);
 			dprint("CPU %d - State: %d - Val: %llu\n",
 			       cpu, state, previous_count[cpu][state]);
 		}
@@ -70,7 +70,7 @@ static int cpuidle_stop(void)
 		for (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;
 		     state++) {
 			current_count[cpu][state] =
-				sysfs_get_idlestate_time(cpu, state);
+				cpuidle_state_time(cpu, state);
 			dprint("CPU %d - State: %d - Val: %llu\n",
 			       cpu, state, previous_count[cpu][state]);
 		}
@@ -132,13 +132,13 @@ static struct cpuidle_monitor *cpuidle_register(void)
 	char *tmp;
 
 	/* Assume idle state count is the same for all CPUs */
-	cpuidle_sysfs_monitor.hw_states_num = sysfs_get_idlestate_count(0);
+	cpuidle_sysfs_monitor.hw_states_num = cpuidle_state_count(0);
 
 	if (cpuidle_sysfs_monitor.hw_states_num <= 0)
 		return NULL;
 
 	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num++) {
-		tmp = sysfs_get_idlestate_name(0, num);
+		tmp = cpuidle_state_name(0, num);
 		if (tmp == NULL)
 			continue;
 
@@ -146,7 +146,7 @@ static struct cpuidle_monitor *cpuidle_register(void)
 		strncpy(cpuidle_cstates[num].name, tmp, CSTATE_NAME_LEN - 1);
 		free(tmp);
 
-		tmp = sysfs_get_idlestate_desc(0, num);
+		tmp = cpuidle_state_desc(0, num);
 		if (tmp == NULL)
 			continue;
 		strncpy(cpuidle_cstates[num].desc, tmp,	CSTATE_DESC_LEN - 1);

commit 88f984e0e235f82a5d34f4a99244eeb14e1413e0
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 12 01:11:36 2011 +0200

    cpupower: Do not show an empty Idle_Stats monitor if no idle driver is available
    
    By taking error values of:
    sysfs_get_idlestate_count(..);
    into account.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index d048b96a6155..bcd22a1a3970 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -134,7 +134,7 @@ static struct cpuidle_monitor *cpuidle_register(void)
 	/* Assume idle state count is the same for all CPUs */
 	cpuidle_sysfs_monitor.hw_states_num = sysfs_get_idlestate_count(0);
 
-	if (cpuidle_sysfs_monitor.hw_states_num == 0)
+	if (cpuidle_sysfs_monitor.hw_states_num <= 0)
 		return NULL;
 
 	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num++) {

commit b510b54127a4d4112a9a3f200339719bcb463c15
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:58:59 2011 +0200

    cpupowerutils: idle_monitor - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
index 63f6d670517b..d048b96a6155 100644
--- a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -36,10 +36,10 @@ static int cpuidle_get_count_percent(unsigned int id, double *percent,
 		*percent = 0.0;
 	else
 		*percent = ((100.0 * statediff) / timediff);
-	
+
 	dprint("%s: - timediff: %llu - statediff: %llu - percent: %f (%u)\n",
 	       cpuidle_cstates[id].name, timediff, statediff, *percent, cpu);
-	
+
 	return 0;
 }
 
@@ -55,7 +55,6 @@ static int cpuidle_start(void)
 			dprint("CPU %d - State: %d - Val: %llu\n",
 			       cpu, state, previous_count[cpu][state]);
 		}
-		
 	};
 	return 0;
 }
@@ -83,40 +82,51 @@ void fix_up_intel_idle_driver_name(char *tmp, int num)
 {
 	/* fix up cpuidle name for intel idle driver */
 	if (!strncmp(tmp, "NHM-", 4)) {
-		switch(num) {
-		case 1: strcpy(tmp, "C1");
+		switch (num) {
+		case 1:
+			strcpy(tmp, "C1");
 			break;
-		case 2: strcpy(tmp, "C3");
+		case 2:
+			strcpy(tmp, "C3");
 			break;
-		case 3: strcpy(tmp, "C6");
+		case 3:
+			strcpy(tmp, "C6");
 			break;
 		}
 	} else if (!strncmp(tmp, "SNB-", 4)) {
-		switch(num) {
-		case 1: strcpy(tmp, "C1");
+		switch (num) {
+		case 1:
+			strcpy(tmp, "C1");
 			break;
-		case 2: strcpy(tmp, "C3");
+		case 2:
+			strcpy(tmp, "C3");
 			break;
-		case 3: strcpy(tmp, "C6");
+		case 3:
+			strcpy(tmp, "C6");
 			break;
-		case 4: strcpy(tmp, "C7");
+		case 4:
+			strcpy(tmp, "C7");
 			break;
 		}
 	} else if (!strncmp(tmp, "ATM-", 4)) {
-		switch(num) {
-		case 1: strcpy(tmp, "C1");
+		switch (num) {
+		case 1:
+			strcpy(tmp, "C1");
 			break;
-		case 2: strcpy(tmp, "C2");
+		case 2:
+			strcpy(tmp, "C2");
 			break;
-		case 3: strcpy(tmp, "C4");
+		case 3:
+			strcpy(tmp, "C4");
 			break;
-		case 4: strcpy(tmp, "C6");
+		case 4:
+			strcpy(tmp, "C6");
 			break;
 		}
 	}
 }
 
-static struct cpuidle_monitor* cpuidle_register(void)
+static struct cpuidle_monitor *cpuidle_register(void)
 {
 	int num;
 	char *tmp;
@@ -127,7 +137,7 @@ static struct cpuidle_monitor* cpuidle_register(void)
 	if (cpuidle_sysfs_monitor.hw_states_num == 0)
 		return NULL;
 
-	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num ++) {
+	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num++) {
 		tmp = sysfs_get_idlestate_name(0, num);
 		if (tmp == NULL)
 			continue;
@@ -144,17 +154,18 @@ static struct cpuidle_monitor* cpuidle_register(void)
 
 		cpuidle_cstates[num].range = RANGE_THREAD;
 		cpuidle_cstates[num].id = num;
-		cpuidle_cstates[num].get_count_percent = cpuidle_get_count_percent;
- 	};
+		cpuidle_cstates[num].get_count_percent =
+			cpuidle_get_count_percent;
+	};
 
 	/* Free this at program termination */
-	previous_count = malloc(sizeof (long long*) * cpu_count);
-	current_count = malloc(sizeof (long long*) * cpu_count);
+	previous_count = malloc(sizeof(long long *) * cpu_count);
+	current_count = malloc(sizeof(long long *) * cpu_count);
 	for (num = 0; num < cpu_count; num++) {
-		previous_count[num] = malloc (sizeof(long long) *
-					      cpuidle_sysfs_monitor.hw_states_num);
-		current_count[num] = malloc (sizeof(long long) *
-					     cpuidle_sysfs_monitor.hw_states_num);
+		previous_count[num] = malloc(sizeof(long long) *
+					cpuidle_sysfs_monitor.hw_states_num);
+		current_count[num] = malloc(sizeof(long long) *
+					cpuidle_sysfs_monitor.hw_states_num);
 	}
 
 	cpuidle_sysfs_monitor.name_len = strlen(cpuidle_sysfs_monitor.name);

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
new file mode 100644
index 000000000000..63f6d670517b
--- /dev/null
+++ b/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c
@@ -0,0 +1,185 @@
+/*
+ *  (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <limits.h>
+
+#include "helpers/sysfs.h"
+#include "helpers/helpers.h"
+#include "idle_monitor/cpupower-monitor.h"
+
+#define CPUIDLE_STATES_MAX 10
+static cstate_t cpuidle_cstates[CPUIDLE_STATES_MAX];
+struct cpuidle_monitor cpuidle_sysfs_monitor;
+
+static unsigned long long **previous_count;
+static unsigned long long **current_count;
+struct timespec start_time;
+static unsigned long long timediff;
+
+static int cpuidle_get_count_percent(unsigned int id, double *percent,
+				     unsigned int cpu)
+{
+	unsigned long long statediff = current_count[cpu][id]
+		- previous_count[cpu][id];
+	dprint("%s: - diff: %llu - percent: %f (%u)\n",
+	       cpuidle_cstates[id].name, timediff, *percent, cpu);
+
+	if (timediff == 0)
+		*percent = 0.0;
+	else
+		*percent = ((100.0 * statediff) / timediff);
+	
+	dprint("%s: - timediff: %llu - statediff: %llu - percent: %f (%u)\n",
+	       cpuidle_cstates[id].name, timediff, statediff, *percent, cpu);
+	
+	return 0;
+}
+
+static int cpuidle_start(void)
+{
+	int cpu, state;
+	clock_gettime(CLOCK_REALTIME, &start_time);
+	for (cpu = 0; cpu < cpu_count; cpu++) {
+		for (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;
+		     state++) {
+			previous_count[cpu][state] =
+				sysfs_get_idlestate_time(cpu, state);
+			dprint("CPU %d - State: %d - Val: %llu\n",
+			       cpu, state, previous_count[cpu][state]);
+		}
+		
+	};
+	return 0;
+}
+
+static int cpuidle_stop(void)
+{
+	int cpu, state;
+	struct timespec end_time;
+	clock_gettime(CLOCK_REALTIME, &end_time);
+	timediff = timespec_diff_us(start_time, end_time);
+
+	for (cpu = 0; cpu < cpu_count; cpu++) {
+		for (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;
+		     state++) {
+			current_count[cpu][state] =
+				sysfs_get_idlestate_time(cpu, state);
+			dprint("CPU %d - State: %d - Val: %llu\n",
+			       cpu, state, previous_count[cpu][state]);
+		}
+	};
+	return 0;
+}
+
+void fix_up_intel_idle_driver_name(char *tmp, int num)
+{
+	/* fix up cpuidle name for intel idle driver */
+	if (!strncmp(tmp, "NHM-", 4)) {
+		switch(num) {
+		case 1: strcpy(tmp, "C1");
+			break;
+		case 2: strcpy(tmp, "C3");
+			break;
+		case 3: strcpy(tmp, "C6");
+			break;
+		}
+	} else if (!strncmp(tmp, "SNB-", 4)) {
+		switch(num) {
+		case 1: strcpy(tmp, "C1");
+			break;
+		case 2: strcpy(tmp, "C3");
+			break;
+		case 3: strcpy(tmp, "C6");
+			break;
+		case 4: strcpy(tmp, "C7");
+			break;
+		}
+	} else if (!strncmp(tmp, "ATM-", 4)) {
+		switch(num) {
+		case 1: strcpy(tmp, "C1");
+			break;
+		case 2: strcpy(tmp, "C2");
+			break;
+		case 3: strcpy(tmp, "C4");
+			break;
+		case 4: strcpy(tmp, "C6");
+			break;
+		}
+	}
+}
+
+static struct cpuidle_monitor* cpuidle_register(void)
+{
+	int num;
+	char *tmp;
+
+	/* Assume idle state count is the same for all CPUs */
+	cpuidle_sysfs_monitor.hw_states_num = sysfs_get_idlestate_count(0);
+
+	if (cpuidle_sysfs_monitor.hw_states_num == 0)
+		return NULL;
+
+	for (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num ++) {
+		tmp = sysfs_get_idlestate_name(0, num);
+		if (tmp == NULL)
+			continue;
+
+		fix_up_intel_idle_driver_name(tmp, num);
+		strncpy(cpuidle_cstates[num].name, tmp, CSTATE_NAME_LEN - 1);
+		free(tmp);
+
+		tmp = sysfs_get_idlestate_desc(0, num);
+		if (tmp == NULL)
+			continue;
+		strncpy(cpuidle_cstates[num].desc, tmp,	CSTATE_DESC_LEN - 1);
+		free(tmp);
+
+		cpuidle_cstates[num].range = RANGE_THREAD;
+		cpuidle_cstates[num].id = num;
+		cpuidle_cstates[num].get_count_percent = cpuidle_get_count_percent;
+ 	};
+
+	/* Free this at program termination */
+	previous_count = malloc(sizeof (long long*) * cpu_count);
+	current_count = malloc(sizeof (long long*) * cpu_count);
+	for (num = 0; num < cpu_count; num++) {
+		previous_count[num] = malloc (sizeof(long long) *
+					      cpuidle_sysfs_monitor.hw_states_num);
+		current_count[num] = malloc (sizeof(long long) *
+					     cpuidle_sysfs_monitor.hw_states_num);
+	}
+
+	cpuidle_sysfs_monitor.name_len = strlen(cpuidle_sysfs_monitor.name);
+	return &cpuidle_sysfs_monitor;
+}
+
+void cpuidle_unregister(void)
+{
+	int num;
+
+	for (num = 0; num < cpu_count; num++) {
+		free(previous_count[num]);
+		free(current_count[num]);
+	}
+	free(previous_count);
+	free(current_count);
+}
+
+struct cpuidle_monitor cpuidle_sysfs_monitor = {
+	.name			= "Idle_Stats",
+	.hw_states		= cpuidle_cstates,
+	.start			= cpuidle_start,
+	.stop			= cpuidle_stop,
+	.do_register		= cpuidle_register,
+	.unregister		= cpuidle_unregister,
+	.needs_root		= 0,
+	.overflow_s		= UINT_MAX,
+};
