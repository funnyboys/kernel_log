commit 7b0bf99b9ee497cc0f079472566aff716d033d43
Author: Zou Wei <zou_wei@huawei.com>
Date:   Tue Apr 28 17:43:15 2020 +0800

    cpupower: Remove unneeded semicolon
    
    Fixes coccicheck warnings:
    
    tools/power/cpupower/utils/cpupower-info.c:65:2-3: Unneeded semicolon
    tools/power/cpupower/utils/cpupower-set.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c:120:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:175:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:56:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/hsw_ext_idle.c:82:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/nhm_idle.c:94:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/snb_idle.c:80:2-3: Unneeded semicolon
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zou Wei <zou_wei@huawei.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 20f46348271b..5edd35bd9ee9 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -117,7 +117,7 @@ static int amd_fam14h_get_pci_info(struct cstate *state,
 		break;
 	default:
 		return -1;
-	};
+	}
 	return 0;
 }
 

commit 2de7fb60a4740135e03cf55c1982e393ccb87b6b
Author: Mike Gilbert <floppym@gentoo.org>
Date:   Wed Feb 26 14:33:59 2020 -0500

    cpupower: avoid multiple definition with gcc -fno-common
    
    Building cpupower with -fno-common in CFLAGS results in errors due to
    multiple definitions of the 'cpu_count' and 'start_time' variables.
    
    ./utils/idle_monitor/snb_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    multiple definition of `cpu_count';
    ./utils/idle_monitor/nhm_idle.o:./utils/idle_monitor/cpupower-monitor.h:28:
    first defined here
    ...
    ./utils/idle_monitor/cpuidle_sysfs.o:./utils/idle_monitor/cpuidle_sysfs.c:22:
    multiple definition of `start_time';
    ./utils/idle_monitor/amd_fam14h_idle.o:./utils/idle_monitor/amd_fam14h_idle.c:85:
    first defined here
    
    The -fno-common option will be enabled by default in GCC 10.
    
    Bug: https://bugs.gentoo.org/707462
    Signed-off-by: Mike Gilbert <floppym@gentoo.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 33dc34db4f3c..20f46348271b 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -82,7 +82,7 @@ static struct pci_access *pci_acc;
 static struct pci_dev *amd_fam14h_pci_dev;
 static int nbp1_entered;
 
-struct timespec start_time;
+static struct timespec start_time;
 static unsigned long long timediff;
 
 #ifdef DEBUG

commit d3f5d2a192a299f56579ae6e6283f9011b00208f
Author: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
Date:   Tue Nov 5 17:16:52 2019 +0000

    cpupower: Move needs_root variable into a sub-struct
    
    Move the needs_root variable into a sub-struct. This is in preparation
    for adding a new flag for cpuidle_monitor.
    
    Update all uses of the needs_root variable to reflect this change.
    
    Signed-off-by: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 3f893b99b337..33dc34db4f3c 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -328,7 +328,7 @@ struct cpuidle_monitor amd_fam14h_monitor = {
 	.stop			= amd_fam14h_stop,
 	.do_register		= amd_fam14h_register,
 	.unregister		= amd_fam14h_unregister,
-	.needs_root		= 1,
+	.flags.needs_root	= 1,
 	.overflow_s		= OVERFLOW_MS / 1000,
 };
 #endif /* #if defined(__i386__) || defined(__x86_64__) */

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 2116df9ad832..3f893b99b337 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2010,2011      Thomas Renninger <trenn@suse.de>, Novell Inc.
  *
- *  Licensed under the terms of the GNU GPL License version 2.
- *
  *  PCI initialization based on example code from:
  *  Andreas Herrmann <andreas.herrmann3@amd.com>
  */

commit f642089ce0e89931bc2f8484f6ce862536f2b8e9
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Oct 11 15:33:51 2011 +0200

    cpupower: AMD fam14h/Ontario monitor can also be used by fam12h cpus
    
    The name of the monitor is updated at runtime to the name of the
    CPU type.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: Andreas Herrmann <herrmann.der.user@googlemail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 108108dfa680..2116df9ad832 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -281,13 +281,13 @@ struct cpuidle_monitor *amd_fam14h_register(void)
 	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD)
 		return NULL;
 
-	if (cpupower_cpu_info.family == 0x14) {
-		if (cpu_count <= 0 || cpu_count > 2) {
-			fprintf(stderr, "AMD fam14h: Invalid cpu count: %d\n",
-				cpu_count);
-			return NULL;
-		}
-	} else
+	if (cpupower_cpu_info.family == 0x14)
+		strncpy(amd_fam14h_monitor.name, "Fam_14h",
+			MONITOR_NAME_LEN - 1);
+	else if (cpupower_cpu_info.family == 0x12)
+		strncpy(amd_fam14h_monitor.name, "Fam_12h",
+			MONITOR_NAME_LEN - 1);
+	else
 		return NULL;
 
 	/* We do not alloc for nbp1 machine wide counter */
@@ -322,7 +322,7 @@ static void amd_fam14h_unregister(void)
 }
 
 struct cpuidle_monitor amd_fam14h_monitor = {
-	.name			= "Ontario",
+	.name			= "",
 	.hw_states		= amd_fam14h_cstates,
 	.hw_states_num		= AMD_FAM14H_STATE_NUM,
 	.start			= amd_fam14h_start,

commit 568a89904c7fc93071efd7f811fc58aff6d5774a
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Oct 11 15:33:50 2011 +0200

    cpupower: Better interface for accessing AMD pci registers
    
    AMD's BKDG (Bios and Kernel Developers Guide) talks in the CPU spec of their
    CPU families about PCI registers defined by "device" (slot) and func(tion).
    
    Assuming that CPU specific configuration PCI devices are always on domain
    and bus zero a pci_slot_func_init() func which gets the slot and func of
    the desired PCI device passed looks like the most convenient way.
    
    This also obsoletes the PCI device id maintenance.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: Andreas Herrmann <herrmann.der.user@googlemail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 202e555988be..108108dfa680 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -20,8 +20,6 @@
 #include "idle_monitor/cpupower-monitor.h"
 #include "helpers/helpers.h"
 
-/******** PCI parts could go into own file and get shared ***************/
-
 #define PCI_NON_PC0_OFFSET	0xb0
 #define PCI_PC1_OFFSET		0xb4
 #define PCI_PC6_OFFSET		0xb8
@@ -82,10 +80,7 @@ static cstate_t amd_fam14h_cstates[AMD_FAM14H_STATE_NUM] = {
 };
 
 static struct pci_access *pci_acc;
-static int pci_vendor_id = 0x1022;
-static int pci_dev_ids[2] = {0x1716, 0};
 static struct pci_dev *amd_fam14h_pci_dev;
-
 static int nbp1_entered;
 
 struct timespec start_time;
@@ -303,7 +298,9 @@ struct cpuidle_monitor *amd_fam14h_register(void)
 					      sizeof(unsigned long long));
 	}
 
-	amd_fam14h_pci_dev = pci_acc_init(&pci_acc, pci_vendor_id, pci_dev_ids);
+	/* We need PCI device: Slot 18, Func 6, compare with BKDG
+	   for fam 12h/14h */
+	amd_fam14h_pci_dev = pci_slot_func_init(&pci_acc, 0x18, 6);
 	if (amd_fam14h_pci_dev == NULL || pci_acc == NULL)
 		return NULL;
 

commit b510b54127a4d4112a9a3f200339719bcb463c15
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 19:58:59 2011 +0200

    cpupowerutils: idle_monitor - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
index 3de94322dfb8..202e555988be 100644
--- a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -104,7 +104,7 @@ static int amd_fam14h_get_pci_info(struct cstate *state,
 				   unsigned int *enable_bit,
 				   unsigned int cpu)
 {
-	switch(state->id) {
+	switch (state->id) {
 	case NON_PC0:
 		*enable_bit = PCI_NON_PC0_ENABLE_BIT;
 		*pci_offset = PCI_NON_PC0_OFFSET;
@@ -177,7 +177,7 @@ static int amd_fam14h_disable(cstate_t *state, unsigned int cpu)
 		/* was the bit whether NBP1 got entered set? */
 		nbp1_entered = (val & (1 << PCI_NBP1_ACTIVE_BIT)) |
 			(val & (1 << PCI_NBP1_ENTERED_BIT));
-			
+
 		dprint("NBP1 was %sentered - 0x%x - enable_bit: "
 		       "%d - pci_offset: 0x%x\n",
 		       nbp1_entered ? "" : "not ",
@@ -214,7 +214,7 @@ static int fam14h_get_count_percent(unsigned int id, double *percent,
 				    unsigned int cpu)
 {
 	unsigned long diff;
-	
+
 	if (id >= AMD_FAM14H_STATE_NUM)
 		return -1;
 	/* residency count in 80ns -> divide through 12.5 to get us residency */
@@ -236,9 +236,8 @@ static int amd_fam14h_start(void)
 	int num, cpu;
 	clock_gettime(CLOCK_REALTIME, &start_time);
 	for (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {
-		for (cpu = 0; cpu < cpu_count; cpu++) {
+		for (cpu = 0; cpu < cpu_count; cpu++)
 			amd_fam14h_init(&amd_fam14h_cstates[num], cpu);
-		}
 	}
 #ifdef DEBUG
 	clock_gettime(CLOCK_REALTIME, &dbg_time);
@@ -257,9 +256,8 @@ static int amd_fam14h_stop(void)
 	clock_gettime(CLOCK_REALTIME, &end_time);
 
 	for (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {
-		for (cpu = 0; cpu < cpu_count; cpu++) {
+		for (cpu = 0; cpu < cpu_count; cpu++)
 			amd_fam14h_disable(&amd_fam14h_cstates[num], cpu);
-		}
 	}
 #ifdef DEBUG
 	clock_gettime(CLOCK_REALTIME, &dbg_time);
@@ -281,8 +279,8 @@ static int is_nbp1_capable(void)
 	return val & (1 << 31);
 }
 
-struct cpuidle_monitor* amd_fam14h_register(void) {
-
+struct cpuidle_monitor *amd_fam14h_register(void)
+{
 	int num;
 
 	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD)
@@ -299,9 +297,9 @@ struct cpuidle_monitor* amd_fam14h_register(void) {
 
 	/* We do not alloc for nbp1 machine wide counter */
 	for (num = 0; num < AMD_FAM14H_STATE_NUM - 1; num++) {
-		previous_count[num] = calloc (cpu_count,
+		previous_count[num] = calloc(cpu_count,
 					      sizeof(unsigned long long));
-		current_count[num]  = calloc (cpu_count,
+		current_count[num]  = calloc(cpu_count,
 					      sizeof(unsigned long long));
 	}
 

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
new file mode 100644
index 000000000000..3de94322dfb8
--- /dev/null
+++ b/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c
@@ -0,0 +1,340 @@
+/*
+ *  (C) 2010,2011      Thomas Renninger <trenn@suse.de>, Novell Inc.
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ *
+ *  PCI initialization based on example code from:
+ *  Andreas Herrmann <andreas.herrmann3@amd.com>
+ */
+
+#if defined(__i386__) || defined(__x86_64__)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <time.h>
+#include <string.h>
+
+#include <pci/pci.h>
+
+#include "idle_monitor/cpupower-monitor.h"
+#include "helpers/helpers.h"
+
+/******** PCI parts could go into own file and get shared ***************/
+
+#define PCI_NON_PC0_OFFSET	0xb0
+#define PCI_PC1_OFFSET		0xb4
+#define PCI_PC6_OFFSET		0xb8
+
+#define PCI_MONITOR_ENABLE_REG  0xe0
+
+#define PCI_NON_PC0_ENABLE_BIT	0
+#define PCI_PC1_ENABLE_BIT	1
+#define PCI_PC6_ENABLE_BIT	2
+
+#define PCI_NBP1_STAT_OFFSET	0x98
+#define PCI_NBP1_ACTIVE_BIT	2
+#define PCI_NBP1_ENTERED_BIT	1
+
+#define PCI_NBP1_CAP_OFFSET	0x90
+#define PCI_NBP1_CAPABLE_BIT    31
+
+#define OVERFLOW_MS		343597 /* 32 bit register filled at 12500 HZ
+					  (1 tick per 80ns) */
+
+enum amd_fam14h_states {NON_PC0 = 0, PC1, PC6, NBP1,
+			AMD_FAM14H_STATE_NUM};
+
+static int fam14h_get_count_percent(unsigned int self_id, double *percent,
+				    unsigned int cpu);
+static int fam14h_nbp1_count(unsigned int id, unsigned long long *count,
+			     unsigned int cpu);
+
+static cstate_t amd_fam14h_cstates[AMD_FAM14H_STATE_NUM] = {
+	{
+		.name			= "!PC0",
+		.desc			= N_("Package in sleep state (PC1 or deeper)"),
+		.id			= NON_PC0,
+		.range			= RANGE_PACKAGE,
+		.get_count_percent	= fam14h_get_count_percent,
+	},
+	{
+		.name			= "PC1",
+		.desc			= N_("Processor Package C1"),
+		.id			= PC1,
+		.range			= RANGE_PACKAGE,
+		.get_count_percent	= fam14h_get_count_percent,
+	},
+	{
+		.name			= "PC6",
+		.desc			= N_("Processor Package C6"),
+		.id			= PC6,
+		.range			= RANGE_PACKAGE,
+		.get_count_percent	= fam14h_get_count_percent,
+	},
+	{
+		.name			= "NBP1",
+		.desc			= N_("North Bridge P1 boolean counter (returns 0 or 1)"),
+		.id			= NBP1,
+		.range			= RANGE_PACKAGE,
+		.get_count		= fam14h_nbp1_count,
+	},
+};
+
+static struct pci_access *pci_acc;
+static int pci_vendor_id = 0x1022;
+static int pci_dev_ids[2] = {0x1716, 0};
+static struct pci_dev *amd_fam14h_pci_dev;
+
+static int nbp1_entered;
+
+struct timespec start_time;
+static unsigned long long timediff;
+
+#ifdef DEBUG
+struct timespec dbg_time;
+long dbg_timediff;
+#endif
+
+static unsigned long long *previous_count[AMD_FAM14H_STATE_NUM];
+static unsigned long long *current_count[AMD_FAM14H_STATE_NUM];
+
+static int amd_fam14h_get_pci_info(struct cstate *state,
+				   unsigned int *pci_offset,
+				   unsigned int *enable_bit,
+				   unsigned int cpu)
+{
+	switch(state->id) {
+	case NON_PC0:
+		*enable_bit = PCI_NON_PC0_ENABLE_BIT;
+		*pci_offset = PCI_NON_PC0_OFFSET;
+		break;
+	case PC1:
+		*enable_bit = PCI_PC1_ENABLE_BIT;
+		*pci_offset = PCI_PC1_OFFSET;
+		break;
+	case PC6:
+		*enable_bit = PCI_PC6_ENABLE_BIT;
+		*pci_offset = PCI_PC6_OFFSET;
+		break;
+	case NBP1:
+		*enable_bit = PCI_NBP1_ENTERED_BIT;
+		*pci_offset = PCI_NBP1_STAT_OFFSET;
+		break;
+	default:
+		return -1;
+	};
+	return 0;
+}
+
+static int amd_fam14h_init(cstate_t *state, unsigned int cpu)
+{
+	int enable_bit, pci_offset, ret;
+	uint32_t val;
+
+	ret = amd_fam14h_get_pci_info(state, &pci_offset, &enable_bit, cpu);
+	if (ret)
+		return ret;
+
+	/* NBP1 needs extra treating -> write 1 to D18F6x98 bit 1 for init */
+	if (state->id == NBP1) {
+		val = pci_read_long(amd_fam14h_pci_dev, pci_offset);
+		val |= 1 << enable_bit;
+		val = pci_write_long(amd_fam14h_pci_dev, pci_offset, val);
+		return ret;
+	}
+
+	/* Enable monitor */
+	val = pci_read_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG);
+	dprint("Init %s: read at offset: 0x%x val: %u\n", state->name,
+	       PCI_MONITOR_ENABLE_REG, (unsigned int) val);
+	val |= 1 << enable_bit;
+	pci_write_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG, val);
+
+	dprint("Init %s: offset: 0x%x enable_bit: %d - val: %u (%u)\n",
+	       state->name, PCI_MONITOR_ENABLE_REG, enable_bit,
+	       (unsigned int) val, cpu);
+
+	/* Set counter to zero */
+	pci_write_long(amd_fam14h_pci_dev, pci_offset, 0);
+	previous_count[state->id][cpu] = 0;
+
+	return 0;
+}
+
+static int amd_fam14h_disable(cstate_t *state, unsigned int cpu)
+{
+	int enable_bit, pci_offset, ret;
+	uint32_t val;
+
+	ret = amd_fam14h_get_pci_info(state, &pci_offset, &enable_bit, cpu);
+	if (ret)
+		return ret;
+
+	val = pci_read_long(amd_fam14h_pci_dev, pci_offset);
+	dprint("%s: offset: 0x%x %u\n", state->name, pci_offset, val);
+	if (state->id == NBP1) {
+		/* was the bit whether NBP1 got entered set? */
+		nbp1_entered = (val & (1 << PCI_NBP1_ACTIVE_BIT)) |
+			(val & (1 << PCI_NBP1_ENTERED_BIT));
+			
+		dprint("NBP1 was %sentered - 0x%x - enable_bit: "
+		       "%d - pci_offset: 0x%x\n",
+		       nbp1_entered ? "" : "not ",
+		       val, enable_bit, pci_offset);
+		return ret;
+	}
+	current_count[state->id][cpu] = val;
+
+	dprint("%s: Current -  %llu (%u)\n", state->name,
+	       current_count[state->id][cpu], cpu);
+	dprint("%s: Previous - %llu (%u)\n", state->name,
+	       previous_count[state->id][cpu], cpu);
+
+	val = pci_read_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG);
+	val &= ~(1 << enable_bit);
+	pci_write_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG, val);
+
+	return 0;
+}
+
+static int fam14h_nbp1_count(unsigned int id, unsigned long long *count,
+			     unsigned int cpu)
+{
+	if (id == NBP1) {
+		if (nbp1_entered)
+			*count = 1;
+		else
+			*count = 0;
+		return 0;
+	}
+	return -1;
+}
+static int fam14h_get_count_percent(unsigned int id, double *percent,
+				    unsigned int cpu)
+{
+	unsigned long diff;
+	
+	if (id >= AMD_FAM14H_STATE_NUM)
+		return -1;
+	/* residency count in 80ns -> divide through 12.5 to get us residency */
+	diff = current_count[id][cpu] - previous_count[id][cpu];
+
+	if (timediff == 0)
+		*percent = 0.0;
+	else
+		*percent = 100.0 * diff / timediff / 12.5;
+
+	dprint("Timediff: %llu - res~: %lu us - percent: %.2f %%\n",
+	       timediff, diff * 10 / 125, *percent);
+
+	return 0;
+}
+
+static int amd_fam14h_start(void)
+{
+	int num, cpu;
+	clock_gettime(CLOCK_REALTIME, &start_time);
+	for (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {
+		for (cpu = 0; cpu < cpu_count; cpu++) {
+			amd_fam14h_init(&amd_fam14h_cstates[num], cpu);
+		}
+	}
+#ifdef DEBUG
+	clock_gettime(CLOCK_REALTIME, &dbg_time);
+	dbg_timediff = timespec_diff_us(start_time, dbg_time);
+	dprint("Enabling counters took: %lu us\n",
+	       dbg_timediff);
+#endif
+	return 0;
+}
+
+static int amd_fam14h_stop(void)
+{
+	int num, cpu;
+	struct timespec end_time;
+
+	clock_gettime(CLOCK_REALTIME, &end_time);
+
+	for (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {
+		for (cpu = 0; cpu < cpu_count; cpu++) {
+			amd_fam14h_disable(&amd_fam14h_cstates[num], cpu);
+		}
+	}
+#ifdef DEBUG
+	clock_gettime(CLOCK_REALTIME, &dbg_time);
+	dbg_timediff = timespec_diff_us(end_time, dbg_time);
+	dprint("Disabling counters took: %lu ns\n", dbg_timediff);
+#endif
+	timediff = timespec_diff_us(start_time, end_time);
+	if (timediff / 1000 > OVERFLOW_MS)
+		print_overflow_err((unsigned int)timediff / 1000000,
+				   OVERFLOW_MS / 1000);
+
+	return 0;
+}
+
+static int is_nbp1_capable(void)
+{
+	uint32_t val;
+	val = pci_read_long(amd_fam14h_pci_dev, PCI_NBP1_CAP_OFFSET);
+	return val & (1 << 31);
+}
+
+struct cpuidle_monitor* amd_fam14h_register(void) {
+
+	int num;
+
+	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD)
+		return NULL;
+
+	if (cpupower_cpu_info.family == 0x14) {
+		if (cpu_count <= 0 || cpu_count > 2) {
+			fprintf(stderr, "AMD fam14h: Invalid cpu count: %d\n",
+				cpu_count);
+			return NULL;
+		}
+	} else
+		return NULL;
+
+	/* We do not alloc for nbp1 machine wide counter */
+	for (num = 0; num < AMD_FAM14H_STATE_NUM - 1; num++) {
+		previous_count[num] = calloc (cpu_count,
+					      sizeof(unsigned long long));
+		current_count[num]  = calloc (cpu_count,
+					      sizeof(unsigned long long));
+	}
+
+	amd_fam14h_pci_dev = pci_acc_init(&pci_acc, pci_vendor_id, pci_dev_ids);
+	if (amd_fam14h_pci_dev == NULL || pci_acc == NULL)
+		return NULL;
+
+	if (!is_nbp1_capable())
+		amd_fam14h_monitor.hw_states_num = AMD_FAM14H_STATE_NUM - 1;
+
+	amd_fam14h_monitor.name_len = strlen(amd_fam14h_monitor.name);
+	return &amd_fam14h_monitor;
+}
+
+static void amd_fam14h_unregister(void)
+{
+	int num;
+	for (num = 0; num < AMD_FAM14H_STATE_NUM - 1; num++) {
+		free(previous_count[num]);
+		free(current_count[num]);
+	}
+	pci_cleanup(pci_acc);
+}
+
+struct cpuidle_monitor amd_fam14h_monitor = {
+	.name			= "Ontario",
+	.hw_states		= amd_fam14h_cstates,
+	.hw_states_num		= AMD_FAM14H_STATE_NUM,
+	.start			= amd_fam14h_start,
+	.stop			= amd_fam14h_stop,
+	.do_register		= amd_fam14h_register,
+	.unregister		= amd_fam14h_unregister,
+	.needs_root		= 1,
+	.overflow_s		= OVERFLOW_MS / 1000,
+};
+#endif /* #if defined(__i386__) || defined(__x86_64__) */
