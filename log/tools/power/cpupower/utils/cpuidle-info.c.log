commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index b59c85defa05..f2b202c5552a 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
  *  (C) 2010       Thomas Renninger <trenn@suse.de>
- *
- *  Licensed under the terms of the GNU GPL License version 2.
  */
 
 

commit ac5a181d065d74fb6b213d538f743392f27bcdbd
Author: Thomas Renninger <trenn@suse.com>
Date:   Thu Apr 28 15:24:40 2016 +0200

    cpupower: Add cpuidle parts into library
    
    This more or less is a renaming and moving of functions and should not
    introduce any functional change.
    
    cpupower was built from cpufrequtils (which had a C library providing easy
    access to cpu frequency platform info). In the meantime it got enhanced
    by quite some neat cpuidle userspace tools.
    
    Now the cpu idle functions have been separated and added to the cpupower.so
    library.
    So beside an already existing public header file:
    cpufreq.h
    cpupower now also exports these cpu idle functions in:
    cpuidle.h
    
    Here again pasted for better review of the interfaces:
    
    ======================================
    int cpuidle_is_state_disabled(unsigned int cpu,
                                           unsigned int idlestate);
    int cpuidle_state_disable(unsigned int cpu, unsigned int idlestate,
                                       unsigned int disable);
    unsigned long cpuidle_state_latency(unsigned int cpu,
                                                    unsigned int idlestate);
    unsigned long cpuidle_state_usage(unsigned int cpu,
                                            unsigned int idlestate);
    unsigned long long cpuidle_state_time(unsigned int cpu,
                                                    unsigned int idlestate);
    char *cpuidle_state_name(unsigned int cpu,
                                    unsigned int idlestate);
    char *cpuidle_state_desc(unsigned int cpu,
                                    unsigned int idlestate);
    unsigned int cpuidle_state_count(unsigned int cpu);
    
    char *cpuidle_get_governor(void);
    char *cpuidle_get_driver(void);
    
    ======================================
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 8bf8ab5ffa25..b59c85defa05 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -13,8 +13,10 @@
 #include <string.h>
 #include <getopt.h>
 
-#include "helpers/helpers.h"
+#include <cpuidle.h>
+
 #include "helpers/sysfs.h"
+#include "helpers/helpers.h"
 #include "helpers/bitmask.h"
 
 #define LINE_LEN 10
@@ -24,7 +26,7 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	unsigned int idlestates, idlestate;
 	char *tmp;
 
-	idlestates = sysfs_get_idlestate_count(cpu);
+	idlestates = cpuidle_state_count(cpu);
 	if (idlestates == 0) {
 		printf(_("CPU %u: No idle states\n"), cpu);
 		return;
@@ -33,7 +35,7 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	printf(_("Number of idle states: %d\n"), idlestates);
 	printf(_("Available idle states:"));
 	for (idlestate = 0; idlestate < idlestates; idlestate++) {
-		tmp = sysfs_get_idlestate_name(cpu, idlestate);
+		tmp = cpuidle_state_name(cpu, idlestate);
 		if (!tmp)
 			continue;
 		printf(" %s", tmp);
@@ -45,28 +47,28 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 		return;
 
 	for (idlestate = 0; idlestate < idlestates; idlestate++) {
-		int disabled = sysfs_is_idlestate_disabled(cpu, idlestate);
+		int disabled = cpuidle_is_state_disabled(cpu, idlestate);
 		/* Disabled interface not supported on older kernels */
 		if (disabled < 0)
 			disabled = 0;
-		tmp = sysfs_get_idlestate_name(cpu, idlestate);
+		tmp = cpuidle_state_name(cpu, idlestate);
 		if (!tmp)
 			continue;
 		printf("%s%s:\n", tmp, (disabled) ? " (DISABLED) " : "");
 		free(tmp);
 
-		tmp = sysfs_get_idlestate_desc(cpu, idlestate);
+		tmp = cpuidle_state_desc(cpu, idlestate);
 		if (!tmp)
 			continue;
 		printf(_("Flags/Description: %s\n"), tmp);
 		free(tmp);
 
 		printf(_("Latency: %lu\n"),
-		       sysfs_get_idlestate_latency(cpu, idlestate));
+		       cpuidle_state_latency(cpu, idlestate));
 		printf(_("Usage: %lu\n"),
-		       sysfs_get_idlestate_usage(cpu, idlestate));
+		       cpuidle_state_usage(cpu, idlestate));
 		printf(_("Duration: %llu\n"),
-		       sysfs_get_idlestate_time(cpu, idlestate));
+		       cpuidle_state_time(cpu, idlestate));
 	}
 }
 
@@ -74,7 +76,7 @@ static void cpuidle_general_output(void)
 {
 	char *tmp;
 
-	tmp = sysfs_get_cpuidle_driver();
+	tmp = cpuidle_get_driver();
 	if (!tmp) {
 		printf(_("Could not determine cpuidle driver\n"));
 		return;
@@ -83,7 +85,7 @@ static void cpuidle_general_output(void)
 	printf(_("CPUidle driver: %s\n"), tmp);
 	free(tmp);
 
-	tmp = sysfs_get_cpuidle_governor();
+	tmp = cpuidle_get_governor();
 	if (!tmp) {
 		printf(_("Could not determine cpuidle governor\n"));
 		return;
@@ -98,7 +100,7 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 	long max_allowed_cstate = 2000000000;
 	unsigned int cstate, cstates;
 
-	cstates = sysfs_get_idlestate_count(cpu);
+	cstates = cpuidle_state_count(cpu);
 	if (cstates == 0) {
 		printf(_("CPU %u: No C-states info\n"), cpu);
 		return;
@@ -113,11 +115,11 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 			 "type[C%d] "), cstate, cstate);
 		printf(_("promotion[--] demotion[--] "));
 		printf(_("latency[%03lu] "),
-		       sysfs_get_idlestate_latency(cpu, cstate));
+		       cpuidle_state_latency(cpu, cstate));
 		printf(_("usage[%08lu] "),
-		       sysfs_get_idlestate_usage(cpu, cstate));
+		       cpuidle_state_usage(cpu, cstate));
 		printf(_("duration[%020Lu] \n"),
-		       sysfs_get_idlestate_time(cpu, cstate));
+		       cpuidle_state_time(cpu, cstate));
 	}
 }
 

commit ce512b84045459f4a6c119a109c950c6bc4a6f3a
Author: Thomas Renninger <trenn@suse.com>
Date:   Tue Dec 1 17:14:15 2015 +0100

    cpupower: Do not analyse offlined cpus
    
    Use sysfs_is_cpu_online(cpu) instead of cpufreq_cpu_exists(cpu) to detect offlined cpus.
    
    Re-arrange printfs slightly to have a consistent output even if you have multiple CPUs
    as output and even if offlined cores are in between.
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 750c1d82c3f7..8bf8ab5ffa25 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -12,7 +12,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <getopt.h>
-#include <cpufreq.h>
 
 #include "helpers/helpers.h"
 #include "helpers/sysfs.h"
@@ -25,8 +24,6 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	unsigned int idlestates, idlestate;
 	char *tmp;
 
-	printf(_ ("Analyzing CPU %d:\n"), cpu);
-
 	idlestates = sysfs_get_idlestate_count(cpu);
 	if (idlestates == 0) {
 		printf(_("CPU %u: No idle states\n"), cpu);
@@ -71,7 +68,6 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 		printf(_("Duration: %llu\n"),
 		       sysfs_get_idlestate_time(cpu, idlestate));
 	}
-	printf("\n");
 }
 
 static void cpuidle_general_output(void)
@@ -189,10 +185,17 @@ int cmd_idle_info(int argc, char **argv)
 	for (cpu = bitmask_first(cpus_chosen);
 	     cpu <= bitmask_last(cpus_chosen); cpu++) {
 
-		if (!bitmask_isbitset(cpus_chosen, cpu) ||
-		    cpufreq_cpu_exists(cpu))
+		if (!bitmask_isbitset(cpus_chosen, cpu))
 			continue;
 
+		printf(_("analyzing CPU %d:\n"), cpu);
+
+		if (sysfs_is_cpu_online(cpu) != 1) {
+			printf(_(" *is offline\n"));
+			printf("\n");
+			continue;
+		}
+
 		switch (output_param) {
 
 		case 'o':
@@ -203,6 +206,7 @@ int cmd_idle_info(int argc, char **argv)
 			cpuidle_cpu_output(cpu, verbose);
 			break;
 		}
+		printf("\n");
 	}
 	return EXIT_SUCCESS;
 }

commit 57ab3b08725163bfe385aaeea6837f9b1213af3d
Author: Sriram Raghunathan <sriram@marirs.net.in>
Date:   Fri Oct 23 09:52:45 2015 +0200

    Creating a common structure initialization pattern for struct option
    
    This patch tries to creates a common structure initialization
    within the cpupower tool.
    
    Previously the ``struct option`` was initialized
    using `designated initializer` technique which was
    not needed. There were conflicting initialization methods seen with
    
    bench/main.c & others.
    
    Signed-off-by: Sriram Raghunathan <sriram@marirs.net.in>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 75e66de7e7a7..750c1d82c3f7 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -126,8 +126,8 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 }
 
 static struct option info_opts[] = {
-	{ .name = "silent",	.has_arg = no_argument,	.flag = NULL,	.val = 's'},
-	{ .name = "proc",	.has_arg = no_argument,	.flag = NULL,	.val = 'o'},
+	{"silent", no_argument, NULL, 's'},
+	{"proc", no_argument, NULL, 'o'},
 	{ },
 };
 

commit c4f3610eba69321b9cf35779cd67e68b5138cc16
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jun 28 15:34:31 2013 +0200

    cpupower: Introduce idle-set subcommand and C-state enabling/disabling
    
    Example:
    
    cpupower idle-set -d 3
    
    will disable C-state 3 on all processors (set commands are active on
    all CPUs by default), same as:
    
    cpupower -c all idle-set -d 3
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index edd5dba3e249..75e66de7e7a7 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -48,10 +48,14 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 		return;
 
 	for (idlestate = 0; idlestate < idlestates; idlestate++) {
+		int disabled = sysfs_is_idlestate_disabled(cpu, idlestate);
+		/* Disabled interface not supported on older kernels */
+		if (disabled < 0)
+			disabled = 0;
 		tmp = sysfs_get_idlestate_name(cpu, idlestate);
 		if (!tmp)
 			continue;
-		printf("%s:\n", tmp);
+		printf("%s%s:\n", tmp, (disabled) ? " (DISABLED) " : "");
 		free(tmp);
 
 		tmp = sysfs_get_idlestate_desc(cpu, idlestate);

commit f605181abd95a109031a23c67a824eb8e5dcfe67
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jun 28 15:34:29 2013 +0200

    cpupower: Make idlestate usage unsigned
    
    Use unsigned int as the data type for some variables related to CPU
    idle states which allows the code to be simplified slightly.
    
    [rjw: Changelog]
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 8145af5f93a6..edd5dba3e249 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -22,7 +22,7 @@
 
 static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 {
-	int idlestates, idlestate;
+	unsigned int idlestates, idlestate;
 	char *tmp;
 
 	printf(_ ("Analyzing CPU %d:\n"), cpu);
@@ -31,10 +31,8 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	if (idlestates == 0) {
 		printf(_("CPU %u: No idle states\n"), cpu);
 		return;
-	} else if (idlestates <= 0) {
-		printf(_("CPU %u: Can't read idle state info\n"), cpu);
-		return;
 	}
+
 	printf(_("Number of idle states: %d\n"), idlestates);
 	printf(_("Available idle states:"));
 	for (idlestate = 0; idlestate < idlestates; idlestate++) {
@@ -98,21 +96,13 @@ static void cpuidle_general_output(void)
 static void proc_cpuidle_cpu_output(unsigned int cpu)
 {
 	long max_allowed_cstate = 2000000000;
-	int cstates, cstate;
+	unsigned int cstate, cstates;
 
 	cstates = sysfs_get_idlestate_count(cpu);
 	if (cstates == 0) {
-		/*
-		 * Go on and print same useless info as you'd see with
-		 * cat /proc/acpi/processor/../power
-		 *	printf(_("CPU %u: No C-states available\n"), cpu);
-		 *	return;
-		 */
-	} else if (cstates <= 0) {
-		printf(_("CPU %u: Can't read C-state info\n"), cpu);
+		printf(_("CPU %u: No C-states info\n"), cpu);
 		return;
 	}
-	/* printf("Cstates: %d\n", cstates); */
 
 	printf(_("active state:            C0\n"));
 	printf(_("max_cstate:              C%u\n"), cstates-1);

commit e0c6082daeb982df70f00bbb122fed66f7f57c3e
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Dec 16 15:35:54 2011 +0100

    cpupower: Remove unneeded code and by that fix a memleak
    
    Looks like some not needed debug code slipped in.
    Also this code:
    tmp = sysfs_get_idlestate_name(cpu, idlestates - 1);
    performs a strdup and the mem was not freed again.
    -> delete it.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index e076bebde1c4..8145af5f93a6 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -35,13 +35,6 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 		printf(_("CPU %u: Can't read idle state info\n"), cpu);
 		return;
 	}
-	tmp = sysfs_get_idlestate_name(cpu, idlestates - 1);
-	if (!tmp) {
-		printf(_("Could not determine max idle state %u\n"),
-		       idlestates - 1);
-		return;
-	}
-
 	printf(_("Number of idle states: %d\n"), idlestates);
 	printf(_("Available idle states:"));
 	for (idlestate = 0; idlestate < idlestates; idlestate++) {

commit 0b37ee65e5d5e626b50852718ed72979160f7be0
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Dec 16 15:35:53 2011 +0100

    cpupower: Fix number of idle states
    
    The number of idle states was wrong.
    The POLL idle state (on X86) was missed out:
    Number of idle states: 4
    Available idle states: C1-NHM C3-NHM C6-NHM
    
    While the POLL is not a real idle state, its
    statistics should still be shown. It's now also
    explained in a detailed manpage.
    This should fix a bug of missing the first idle
    state on other archs.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index b028267c1376..e076bebde1c4 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -43,9 +43,8 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	}
 
 	printf(_("Number of idle states: %d\n"), idlestates);
-
 	printf(_("Available idle states:"));
-	for (idlestate = 1; idlestate < idlestates; idlestate++) {
+	for (idlestate = 0; idlestate < idlestates; idlestate++) {
 		tmp = sysfs_get_idlestate_name(cpu, idlestate);
 		if (!tmp)
 			continue;
@@ -57,7 +56,7 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	if (!verbose)
 		return;
 
-	for (idlestate = 1; idlestate < idlestates; idlestate++) {
+	for (idlestate = 0; idlestate < idlestates; idlestate++) {
 		tmp = sysfs_get_idlestate_name(cpu, idlestate);
 		if (!tmp)
 			continue;

commit 498ca793d90aef8ad38a852a969c257f62832738
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 6 18:11:43 2011 +0200

    cpupower: use man(1) when calling "cpupower help subcommand"
    
    Instead of printing something non-formatted to stdout, call
    man(1) to show the man page for the proper subcommand.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 70da3574f1e9..b028267c1376 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -139,30 +139,14 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 	}
 }
 
-/* --freq / -f */
-
-void idle_info_help(void)
-{
-	printf(_ ("Usage: cpupower idleinfo [options]\n"));
-	printf(_ ("Options:\n"));
-	printf(_ ("  -s, --silent         Only show general C-state information\n"));
-	printf(_ ("  -o, --proc           Prints out information like provided by the /proc/acpi/processor/*/power\n"
-	       "                       interface in older kernels\n"));
-	printf(_ ("  -h, --help           Prints out this screen\n"));
-
-	printf("\n");
-}
-
 static struct option info_opts[] = {
 	{ .name = "silent",	.has_arg = no_argument,	.flag = NULL,	.val = 's'},
 	{ .name = "proc",	.has_arg = no_argument,	.flag = NULL,	.val = 'o'},
-	{ .name = "help",	.has_arg = no_argument,	.flag = NULL,	.val = 'h'},
 	{ },
 };
 
 static inline void cpuidle_exit(int fail)
 {
-	idle_info_help();
 	exit(EXIT_FAILURE);
 }
 
@@ -174,7 +158,7 @@ int cmd_idle_info(int argc, char **argv)
 	unsigned int cpu = 0;
 
 	do {
-		ret = getopt_long(argc, argv, "hos", info_opts, NULL);
+		ret = getopt_long(argc, argv, "os", info_opts, NULL);
 		if (ret == -1)
 			break;
 		switch (ret) {
@@ -182,10 +166,6 @@ int cmd_idle_info(int argc, char **argv)
 			output_param = '?';
 			cont = 0;
 			break;
-		case 'h':
-			output_param = 'h';
-			cont = 0;
-			break;
 		case 's':
 			verbose = 0;
 			break;
@@ -211,8 +191,6 @@ int cmd_idle_info(int argc, char **argv)
 	case '?':
 		printf(_("invalid or unknown argument\n"));
 		cpuidle_exit(EXIT_FAILURE);
-	case 'h':
-		cpuidle_exit(EXIT_SUCCESS);
 	}
 
 	/* Default is: show output of CPU 0 only */

commit a1ce5ba2b7d08ab6347dc254f86f70e91c5f1a44
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 20:33:50 2011 +0200

    cpupowerutils: utils - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
index 635468224e74..70da3574f1e9 100644
--- a/tools/power/cpupower/utils/cpuidle-info.c
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -31,8 +31,7 @@ static void cpuidle_cpu_output(unsigned int cpu, int verbose)
 	if (idlestates == 0) {
 		printf(_("CPU %u: No idle states\n"), cpu);
 		return;
-	}
-	else if (idlestates <= 0) {
+	} else if (idlestates <= 0) {
 		printf(_("CPU %u: Can't read idle state info\n"), cpu);
 		return;
 	}
@@ -92,7 +91,7 @@ static void cpuidle_general_output(void)
 	}
 
 	printf(_("CPUidle driver: %s\n"), tmp);
-	free (tmp);
+	free(tmp);
 
 	tmp = sysfs_get_cpuidle_governor();
 	if (!tmp) {
@@ -101,7 +100,7 @@ static void cpuidle_general_output(void)
 	}
 
 	printf(_("CPUidle governor: %s\n"), tmp);
-	free (tmp);
+	free(tmp);
 }
 
 static void proc_cpuidle_cpu_output(unsigned int cpu)
@@ -117,8 +116,7 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 		 *	printf(_("CPU %u: No C-states available\n"), cpu);
 		 *	return;
 		 */
-	}
-	else if (cstates <= 0) {
+	} else if (cstates <= 0) {
 		printf(_("CPU %u: Can't read C-state info\n"), cpu);
 		return;
 	}
@@ -143,7 +141,8 @@ static void proc_cpuidle_cpu_output(unsigned int cpu)
 
 /* --freq / -f */
 
-void idle_info_help(void) {
+void idle_info_help(void)
+{
 	printf(_ ("Usage: cpupower idleinfo [options]\n"));
 	printf(_ ("Options:\n"));
 	printf(_ ("  -s, --silent         Only show general C-state information\n"));
@@ -155,9 +154,9 @@ void idle_info_help(void) {
 }
 
 static struct option info_opts[] = {
-	{ .name="silent",	.has_arg=no_argument,		.flag=NULL,	.val='s'},
-	{ .name="proc",		.has_arg=no_argument,		.flag=NULL,	.val='o'},
-	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ .name = "silent",	.has_arg = no_argument,	.flag = NULL,	.val = 's'},
+	{ .name = "proc",	.has_arg = no_argument,	.flag = NULL,	.val = 'o'},
+	{ .name = "help",	.has_arg = no_argument,	.flag = NULL,	.val = 'h'},
 	{ },
 };
 
@@ -202,7 +201,7 @@ int cmd_idle_info(int argc, char **argv)
 			output_param = ret;
 			break;
 		}
-	} while(cont);
+	} while (cont);
 
 	switch (output_param) {
 	case -1:
@@ -219,10 +218,10 @@ int cmd_idle_info(int argc, char **argv)
 	/* Default is: show output of CPU 0 only */
 	if (bitmask_isallclear(cpus_chosen))
 		bitmask_setbit(cpus_chosen, 0);
-		
+
 	if (output_param == 0)
 		cpuidle_general_output();
-			
+
 	for (cpu = bitmask_first(cpus_chosen);
 	     cpu <= bitmask_last(cpus_chosen); cpu++) {
 
@@ -241,5 +240,5 @@ int cmd_idle_info(int argc, char **argv)
 			break;
 		}
 	}
-	return (EXIT_SUCCESS);
+	return EXIT_SUCCESS;
 }

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpuidle-info.c b/tools/power/cpupower/utils/cpuidle-info.c
new file mode 100644
index 000000000000..635468224e74
--- /dev/null
+++ b/tools/power/cpupower/utils/cpuidle-info.c
@@ -0,0 +1,245 @@
+/*
+ *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
+ *  (C) 2010       Thomas Renninger <trenn@suse.de>
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ */
+
+
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <cpufreq.h>
+
+#include "helpers/helpers.h"
+#include "helpers/sysfs.h"
+#include "helpers/bitmask.h"
+
+#define LINE_LEN 10
+
+static void cpuidle_cpu_output(unsigned int cpu, int verbose)
+{
+	int idlestates, idlestate;
+	char *tmp;
+
+	printf(_ ("Analyzing CPU %d:\n"), cpu);
+
+	idlestates = sysfs_get_idlestate_count(cpu);
+	if (idlestates == 0) {
+		printf(_("CPU %u: No idle states\n"), cpu);
+		return;
+	}
+	else if (idlestates <= 0) {
+		printf(_("CPU %u: Can't read idle state info\n"), cpu);
+		return;
+	}
+	tmp = sysfs_get_idlestate_name(cpu, idlestates - 1);
+	if (!tmp) {
+		printf(_("Could not determine max idle state %u\n"),
+		       idlestates - 1);
+		return;
+	}
+
+	printf(_("Number of idle states: %d\n"), idlestates);
+
+	printf(_("Available idle states:"));
+	for (idlestate = 1; idlestate < idlestates; idlestate++) {
+		tmp = sysfs_get_idlestate_name(cpu, idlestate);
+		if (!tmp)
+			continue;
+		printf(" %s", tmp);
+		free(tmp);
+	}
+	printf("\n");
+
+	if (!verbose)
+		return;
+
+	for (idlestate = 1; idlestate < idlestates; idlestate++) {
+		tmp = sysfs_get_idlestate_name(cpu, idlestate);
+		if (!tmp)
+			continue;
+		printf("%s:\n", tmp);
+		free(tmp);
+
+		tmp = sysfs_get_idlestate_desc(cpu, idlestate);
+		if (!tmp)
+			continue;
+		printf(_("Flags/Description: %s\n"), tmp);
+		free(tmp);
+
+		printf(_("Latency: %lu\n"),
+		       sysfs_get_idlestate_latency(cpu, idlestate));
+		printf(_("Usage: %lu\n"),
+		       sysfs_get_idlestate_usage(cpu, idlestate));
+		printf(_("Duration: %llu\n"),
+		       sysfs_get_idlestate_time(cpu, idlestate));
+	}
+	printf("\n");
+}
+
+static void cpuidle_general_output(void)
+{
+	char *tmp;
+
+	tmp = sysfs_get_cpuidle_driver();
+	if (!tmp) {
+		printf(_("Could not determine cpuidle driver\n"));
+		return;
+	}
+
+	printf(_("CPUidle driver: %s\n"), tmp);
+	free (tmp);
+
+	tmp = sysfs_get_cpuidle_governor();
+	if (!tmp) {
+		printf(_("Could not determine cpuidle governor\n"));
+		return;
+	}
+
+	printf(_("CPUidle governor: %s\n"), tmp);
+	free (tmp);
+}
+
+static void proc_cpuidle_cpu_output(unsigned int cpu)
+{
+	long max_allowed_cstate = 2000000000;
+	int cstates, cstate;
+
+	cstates = sysfs_get_idlestate_count(cpu);
+	if (cstates == 0) {
+		/*
+		 * Go on and print same useless info as you'd see with
+		 * cat /proc/acpi/processor/../power
+		 *	printf(_("CPU %u: No C-states available\n"), cpu);
+		 *	return;
+		 */
+	}
+	else if (cstates <= 0) {
+		printf(_("CPU %u: Can't read C-state info\n"), cpu);
+		return;
+	}
+	/* printf("Cstates: %d\n", cstates); */
+
+	printf(_("active state:            C0\n"));
+	printf(_("max_cstate:              C%u\n"), cstates-1);
+	printf(_("maximum allowed latency: %lu usec\n"), max_allowed_cstate);
+	printf(_("states:\t\n"));
+	for (cstate = 1; cstate < cstates; cstate++) {
+		printf(_("    C%d:                  "
+			 "type[C%d] "), cstate, cstate);
+		printf(_("promotion[--] demotion[--] "));
+		printf(_("latency[%03lu] "),
+		       sysfs_get_idlestate_latency(cpu, cstate));
+		printf(_("usage[%08lu] "),
+		       sysfs_get_idlestate_usage(cpu, cstate));
+		printf(_("duration[%020Lu] \n"),
+		       sysfs_get_idlestate_time(cpu, cstate));
+	}
+}
+
+/* --freq / -f */
+
+void idle_info_help(void) {
+	printf(_ ("Usage: cpupower idleinfo [options]\n"));
+	printf(_ ("Options:\n"));
+	printf(_ ("  -s, --silent         Only show general C-state information\n"));
+	printf(_ ("  -o, --proc           Prints out information like provided by the /proc/acpi/processor/*/power\n"
+	       "                       interface in older kernels\n"));
+	printf(_ ("  -h, --help           Prints out this screen\n"));
+
+	printf("\n");
+}
+
+static struct option info_opts[] = {
+	{ .name="silent",	.has_arg=no_argument,		.flag=NULL,	.val='s'},
+	{ .name="proc",		.has_arg=no_argument,		.flag=NULL,	.val='o'},
+	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ },
+};
+
+static inline void cpuidle_exit(int fail)
+{
+	idle_info_help();
+	exit(EXIT_FAILURE);
+}
+
+int cmd_idle_info(int argc, char **argv)
+{
+	extern char *optarg;
+	extern int optind, opterr, optopt;
+	int ret = 0, cont = 1, output_param = 0, verbose = 1;
+	unsigned int cpu = 0;
+
+	do {
+		ret = getopt_long(argc, argv, "hos", info_opts, NULL);
+		if (ret == -1)
+			break;
+		switch (ret) {
+		case '?':
+			output_param = '?';
+			cont = 0;
+			break;
+		case 'h':
+			output_param = 'h';
+			cont = 0;
+			break;
+		case 's':
+			verbose = 0;
+			break;
+		case -1:
+			cont = 0;
+			break;
+		case 'o':
+			if (output_param) {
+				output_param = -1;
+				cont = 0;
+				break;
+			}
+			output_param = ret;
+			break;
+		}
+	} while(cont);
+
+	switch (output_param) {
+	case -1:
+		printf(_("You can't specify more than one "
+			 "output-specific argument\n"));
+		cpuidle_exit(EXIT_FAILURE);
+	case '?':
+		printf(_("invalid or unknown argument\n"));
+		cpuidle_exit(EXIT_FAILURE);
+	case 'h':
+		cpuidle_exit(EXIT_SUCCESS);
+	}
+
+	/* Default is: show output of CPU 0 only */
+	if (bitmask_isallclear(cpus_chosen))
+		bitmask_setbit(cpus_chosen, 0);
+		
+	if (output_param == 0)
+		cpuidle_general_output();
+			
+	for (cpu = bitmask_first(cpus_chosen);
+	     cpu <= bitmask_last(cpus_chosen); cpu++) {
+
+		if (!bitmask_isbitset(cpus_chosen, cpu) ||
+		    cpufreq_cpu_exists(cpu))
+			continue;
+
+		switch (output_param) {
+
+		case 'o':
+			proc_cpuidle_cpu_output(cpu);
+			break;
+		case 0:
+			printf("\n");
+			cpuidle_cpu_output(cpu, verbose);
+			break;
+		}
+	}
+	return (EXIT_SUCCESS);
+}
