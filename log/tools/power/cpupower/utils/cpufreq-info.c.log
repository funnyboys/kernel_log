commit 41ddb7e1f79693d904502ae9bea609837973eff8
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jan 17 08:55:54 2020 +0100

    cpupower: Revert library ABI changes from commit ae2917093fb60bdc1ed3e
    
    Commit ae2917093fb6 ("tools/power/cpupower: Display boost frequency
    separately") modified the library function:
    
    struct cpufreq_available_frequencies
    *cpufreq_get_available_frequencies(unsigned int cpu)
    
    to
    struct cpufreq_frequencies
    *cpufreq_get_frequencies(const char *type, unsigned int cpu)
    
    This patch recovers the old API and implements the new functionality
    in a newly introduce method:
    struct cpufreq_boost_frequencies
    *cpufreq_get_available_frequencies(unsigned int cpu)
    
    This one should get merged into stable kernels back to 5.0 when
    the above had been introduced.
    
    Fixes: ae2917093fb6 ("tools/power/cpupower: Display boost frequency separately")
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index e63cf55f81cf..6efc0f6b1b11 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -244,14 +244,14 @@ static int get_boost_mode_x86(unsigned int cpu)
 
 static int get_boost_mode(unsigned int cpu)
 {
-	struct cpufreq_frequencies *freqs;
+	struct cpufreq_available_frequencies *freqs;
 
 	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD ||
 	    cpupower_cpu_info.vendor == X86_VENDOR_HYGON ||
 	    cpupower_cpu_info.vendor == X86_VENDOR_INTEL)
 		return get_boost_mode_x86(cpu);
 
-	freqs = cpufreq_get_frequencies("boost", cpu);
+	freqs = cpufreq_get_boost_frequencies(cpu);
 	if (freqs) {
 		printf(_("  boost frequency steps: "));
 		while (freqs->next) {
@@ -261,7 +261,7 @@ static int get_boost_mode(unsigned int cpu)
 		}
 		print_speed(freqs->frequency);
 		printf("\n");
-		cpufreq_put_frequencies(freqs);
+		cpufreq_put_available_frequencies(freqs);
 	}
 
 	return 0;
@@ -475,7 +475,7 @@ static int get_latency(unsigned int cpu, unsigned int human)
 
 static void debug_output_one(unsigned int cpu)
 {
-	struct cpufreq_frequencies *freqs;
+	struct cpufreq_available_frequencies *freqs;
 
 	get_driver(cpu);
 	get_related_cpus(cpu);
@@ -483,7 +483,7 @@ static void debug_output_one(unsigned int cpu)
 	get_latency(cpu, 1);
 	get_hardware_limits(cpu, 1);
 
-	freqs = cpufreq_get_frequencies("available", cpu);
+	freqs = cpufreq_get_available_frequencies(cpu);
 	if (freqs) {
 		printf(_("  available frequency steps:  "));
 		while (freqs->next) {
@@ -493,7 +493,7 @@ static void debug_output_one(unsigned int cpu)
 		}
 		print_speed(freqs->frequency);
 		printf("\n");
-		cpufreq_put_frequencies(freqs);
+		cpufreq_put_available_frequencies(freqs);
 	}
 
 	get_available_governors(cpu);

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 10290b308797..e63cf55f81cf 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -1,7 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
- *
- *  Licensed under the terms of the GNU GPL License version 2.
  */
 
 

commit ae2917093fb60bdc1ed3e5757b74801420569a9a
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Tue Feb 5 04:51:28 2019 -0600

    tools/power/cpupower: Display boost frequency separately
    
    cpufreq driver creates sysfs file "scaling_boost_frequency" for platforms
    which support boost frequency. Cpupower now prints boost frequencies
    separately. For few x86 vendors who already have different way to get boost
    frequency, will continue to use the existing logic. Rest of the platforms
    will rely on "scaling_boost_frequency" file to display boost frequency.
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Signed-off-by: Shuah Khan <shuah@kernel.org>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index c3f39d5128ee..10290b308797 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -161,19 +161,12 @@ static void print_duration(unsigned long duration)
 	return;
 }
 
-/* --boost / -b */
-
-static int get_boost_mode(unsigned int cpu)
+static int get_boost_mode_x86(unsigned int cpu)
 {
 	int support, active, b_states = 0, ret, pstate_no, i;
 	/* ToDo: Make this more global */
 	unsigned long pstates[MAX_HW_PSTATES] = {0,};
 
-	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD &&
-	    cpupower_cpu_info.vendor != X86_VENDOR_HYGON &&
-	    cpupower_cpu_info.vendor != X86_VENDOR_INTEL)
-		return 0;
-
 	ret = cpufreq_has_boost_support(cpu, &support, &active, &b_states);
 	if (ret) {
 		printf(_("Error while evaluating Boost Capabilities"
@@ -248,6 +241,33 @@ static int get_boost_mode(unsigned int cpu)
 	return 0;
 }
 
+/* --boost / -b */
+
+static int get_boost_mode(unsigned int cpu)
+{
+	struct cpufreq_frequencies *freqs;
+
+	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD ||
+	    cpupower_cpu_info.vendor == X86_VENDOR_HYGON ||
+	    cpupower_cpu_info.vendor == X86_VENDOR_INTEL)
+		return get_boost_mode_x86(cpu);
+
+	freqs = cpufreq_get_frequencies("boost", cpu);
+	if (freqs) {
+		printf(_("  boost frequency steps: "));
+		while (freqs->next) {
+			print_speed(freqs->frequency);
+			printf(", ");
+			freqs = freqs->next;
+		}
+		print_speed(freqs->frequency);
+		printf("\n");
+		cpufreq_put_frequencies(freqs);
+	}
+
+	return 0;
+}
+
 /* --freq / -f */
 
 static int get_freq_kernel(unsigned int cpu, unsigned int human)
@@ -456,7 +476,7 @@ static int get_latency(unsigned int cpu, unsigned int human)
 
 static void debug_output_one(unsigned int cpu)
 {
-	struct cpufreq_available_frequencies *freqs;
+	struct cpufreq_frequencies *freqs;
 
 	get_driver(cpu);
 	get_related_cpus(cpu);
@@ -464,7 +484,7 @@ static void debug_output_one(unsigned int cpu)
 	get_latency(cpu, 1);
 	get_hardware_limits(cpu, 1);
 
-	freqs = cpufreq_get_available_frequencies(cpu);
+	freqs = cpufreq_get_frequencies("available", cpu);
 	if (freqs) {
 		printf(_("  available frequency steps:  "));
 		while (freqs->next) {
@@ -474,7 +494,7 @@ static void debug_output_one(unsigned int cpu)
 		}
 		print_speed(freqs->frequency);
 		printf("\n");
-		cpufreq_put_available_frequencies(freqs);
+		cpufreq_put_frequencies(freqs);
 	}
 
 	get_available_governors(cpu);

commit fec98069fb72fb656304a3e52265e0c2fc9adf87
Merge: 04ce7fae3d4e 995d5f64b62f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 16:16:40 2018 +0100

    Merge branch 'x86-cpu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 cpu updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Add support for the "Dhyana" x86 CPUs by Hygon: these are licensed
         based on the AMD Zen architecture, and are built and sold in China,
         for domestic datacenter use. The code is pretty close to AMD
         support, mostly with a few quirks and enumeration differences. (Pu
         Wen)
    
       - Enable CPUID support on Cyrix 6x86/6x86L processors"
    
    * 'x86-cpu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tools/cpupower: Add Hygon Dhyana support
      cpufreq: Add Hygon Dhyana support
      ACPI: Add Hygon Dhyana support
      x86/xen: Add Hygon Dhyana support to Xen
      x86/kvm: Add Hygon Dhyana support to KVM
      x86/mce: Add Hygon Dhyana support to the MCA infrastructure
      x86/bugs: Add Hygon Dhyana to the respective mitigation machinery
      x86/apic: Add Hygon Dhyana support
      x86/pci, x86/amd_nb: Add Hygon Dhyana support to PCI and northbridge
      x86/amd_nb: Check vendor in AMD-only functions
      x86/alternative: Init ideal_nops for Hygon Dhyana
      x86/events: Add Hygon Dhyana support to PMU infrastructure
      x86/smpboot: Do not use BSP INIT delay and MWAIT to idle on Dhyana
      x86/cpu/mtrr: Support TOP_MEM2 and get MTRR number
      x86/cpu: Get cache info and setup cache cpumap for Hygon Dhyana
      x86/cpu: Create Hygon Dhyana architecture support file
      x86/CPU: Change query logic so CPUID is enabled before testing
      x86/CPU: Use correct macros for Cyrix calls

commit f69ffc5d3db8f1f03fd6d1df5930f9a1fbd787b6
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Oct 8 11:06:19 2018 -0400

    cpupower: Fix coredump on VMWare
    
    cpupower crashes on VMWare guests.  The guests have the AMD PStateDef MSR
    (0xC0010064 + state number) set to zero.  As a result fid and did are zero
    and the crash occurs because of a divide by zero (cof = fid/did).  This
    can be prevented by checking the enable bit in the PStateDef MSR before
    calculating cof.  By doing this the value of pstate[i] remains zero and
    the value can be tested before displaying the active Pstates.
    
    Check the enable bit in the PstateDef register for all supported families
    and only print out enabled Pstates.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: Stafford Horne <shorne@gmail.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index df43cd45d810..ccd08dd00996 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -200,6 +200,8 @@ static int get_boost_mode(unsigned int cpu)
 		printf(_("    Boost States: %d\n"), b_states);
 		printf(_("    Total States: %d\n"), pstate_no);
 		for (i = 0; i < pstate_no; i++) {
+			if (!pstates[i])
+				continue;
 			if (i < b_states)
 				printf(_("    Pstate-Pb%d: %luMHz (boost state)"
 					 "\n"), i, pstates[i]);

commit 995d5f64b62f20f05b8e0972f07ec4d6c23333c9
Author: Pu Wen <puwen@hygon.cn>
Date:   Thu Oct 4 09:21:43 2018 +0800

    tools/cpupower: Add Hygon Dhyana support
    
    The tool cpupower is useful to get CPU frequency information and monitor
    power stats on the Hygon Dhyana platform. So add Hygon Dhyana support to
    it by checking vendor and family to share the code path of AMD family
    17h.
    
    Signed-off-by: Pu Wen <puwen@hygon.cn>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
    CC: Prarit Bhargava <prarit@redhat.com>
    CC: Shuah Khan <shuah@kernel.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Thomas Renninger <trenn@suse.com>
    CC: linux-pm@vger.kernel.org
    Link: http://lkml.kernel.org/r/5ce86123a7b9dad925ac583d88d2f921040e859b.1538583282.git.puwen@hygon.cn

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index df43cd45d810..56e54eabc65c 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -170,6 +170,7 @@ static int get_boost_mode(unsigned int cpu)
 	unsigned long pstates[MAX_HW_PSTATES] = {0,};
 
 	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD &&
+	    cpupower_cpu_info.vendor != X86_VENDOR_HYGON &&
 	    cpupower_cpu_info.vendor != X86_VENDOR_INTEL)
 		return 0;
 
@@ -190,8 +191,9 @@ static int get_boost_mode(unsigned int cpu)
 	printf(_("    Supported: %s\n"), support ? _("yes") : _("no"));
 	printf(_("    Active: %s\n"), active ? _("yes") : _("no"));
 
-	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&
-	    cpupower_cpu_info.family >= 0x10) {
+	if ((cpupower_cpu_info.vendor == X86_VENDOR_AMD &&
+	     cpupower_cpu_info.family >= 0x10) ||
+	     cpupower_cpu_info.vendor == X86_VENDOR_HYGON) {
 		ret = decode_pstates(cpu, cpupower_cpu_info.family, b_states,
 				     pstates, &pstate_no);
 		if (ret)

commit 9da779c324db87ca340e0eb1259c949874f17bed
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Oct 25 09:51:32 2017 -0400

    cpupower: Fix no-rounding MHz frequency output
    
    'cpupower frequency-info -ln' returns kHz values on systems with MHz range
    minimum CPU frequency range.  For example, on a 800MHz to 4.20GHz system
    the command returns
    
    hardware limits: 800000 MHz - 4.200000 GHz
    
    The code that causes this error can be removed.  The next else if clause
    will handle the output correctly such that
    
    hardware limits: 800.000 MHz - 4.200000 GHz
    
    is displayed correctly.
    
    [v2]: Remove two lines instead of fixing broken code.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Renninger <trenn@suse.com>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Reviewed-by: Stafford Horne <shorne@gmail.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 3e701f0e9c14..df43cd45d810 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -93,8 +93,6 @@ static void print_speed(unsigned long speed)
 		if (speed > 1000000)
 			printf("%u.%06u GHz", ((unsigned int) speed/1000000),
 				((unsigned int) speed%1000000));
-		else if (speed > 100000)
-			printf("%u MHz", (unsigned int) speed);
 		else if (speed > 1000)
 			printf("%u.%03u MHz", ((unsigned int) speed/1000),
 				(unsigned int) (speed%1000));

commit 4da39ceb269cee9f96815a54f97931a7e59f9e7f
Author: Stafford Horne <shorne@gmail.com>
Date:   Thu Jan 12 00:16:04 2017 +0900

    cpupower: Restore format of frequency-info limit
    
    The intel_pstate kselftest expects that the output of
    `cpupower frequency-info -l | tail -1 | awk ' { print $1 } '`
    to get frequency limits.  This does not work after the following two
    changes.
    
     - 562e5f1a3: rework the "cpupower frequency-info" command
       (Jacob Tanenbaum) removed parsable limit output
     - ce512b840: Do not analyse offlined cpus
       (Thomas Renninger) added newline to break limit parsing more
    
    This change preserves human readable output if wanted as well as
    parsable output for scripts/tests.
    
    Cc: Thomas Renninger <trenn@suse.com>
    Cc: "Shreyas B. Prabhu" <shreyas@linux.vnet.ibm.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Stafford Horne <shorne@gmail.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 590d12a25f6e..3e701f0e9c14 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -285,20 +285,24 @@ static int get_freq_hardware(unsigned int cpu, unsigned int human)
 
 /* --hwlimits / -l */
 
-static int get_hardware_limits(unsigned int cpu)
+static int get_hardware_limits(unsigned int cpu, unsigned int human)
 {
 	unsigned long min, max;
 
-	printf(_("  hardware limits: "));
 	if (cpufreq_get_hardware_limits(cpu, &min, &max)) {
 		printf(_("Not Available\n"));
 		return -EINVAL;
 	}
 
-	print_speed(min);
-	printf(" - ");
-	print_speed(max);
-	printf("\n");
+	if (human) {
+		printf(_("  hardware limits: "));
+		print_speed(min);
+		printf(" - ");
+		print_speed(max);
+		printf("\n");
+	} else {
+		printf("%lu %lu\n", min, max);
+	}
 	return 0;
 }
 
@@ -456,7 +460,7 @@ static void debug_output_one(unsigned int cpu)
 	get_related_cpus(cpu);
 	get_affected_cpus(cpu);
 	get_latency(cpu, 1);
-	get_hardware_limits(cpu);
+	get_hardware_limits(cpu, 1);
 
 	freqs = cpufreq_get_available_frequencies(cpu);
 	if (freqs) {
@@ -622,7 +626,7 @@ int cmd_freq_info(int argc, char **argv)
 			ret = get_driver(cpu);
 			break;
 		case 'l':
-			ret = get_hardware_limits(cpu);
+			ret = get_hardware_limits(cpu, human);
 			break;
 		case 'w':
 			ret = get_freq_hardware(cpu, human);
@@ -639,7 +643,6 @@ int cmd_freq_info(int argc, char **argv)
 		}
 		if (ret)
 			return ret;
-		printf("\n");
 	}
 	return ret;
 }

commit 38cb76a307821f76c7f9dff7449f73aeb014d5cc
Author: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
Date:   Mon Jan 18 20:44:43 2016 +0530

    cpupower: Fix build error in cpufreq-info
    
    Fix the following build error by including limits.h -
    
    utils/cpufreq-info.c: In function ‘get_latency’:
    utils/cpufreq-info.c:437:29: error: ‘UINT_MAX’ undeclared (first use in
    this function)
      if (!latency || latency == UINT_MAX) {
                                 ^
    Signed-off-by: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
    Fixes: e98f033f94f3 (cpupower: fix how "cpupower frequency-info" interprets latency)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 8f3f5bb9c74e..590d12a25f6e 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
 
 #include <getopt.h>
 

commit e98f033f94f385a9cf498d4e9f2ac1e6198b545a
Author: Jacob Tanenbaum <jtanenba@redhat.com>
Date:   Tue Dec 1 17:14:17 2015 +0100

    cpupower: fix how "cpupower frequency-info" interprets latency
    
    the intel-pstate driver does not support the ondemand governor and does not
    have a valid value in
    /sys/devices/system/cpu/cpu[x]/cpufreq/cpuinfo_transition_latency. The
    intel-pstate driver sets cpuinfo_transition_latency to CPUFREQ_ETERNAL (-1),
    the value written into cpuinfo_transition_latency is defind as an unsigned
    int so checking the read value against max unsigned int will determine if the
    value is valid.
    
    Signed-off-by: Jacob Tanenbaum <jtanenba@redhat.com>
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index c13bc8c7c860..8f3f5bb9c74e 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -434,8 +434,8 @@ static int get_latency(unsigned int cpu, unsigned int human)
 	unsigned long latency = cpufreq_get_transition_latency(cpu);
 
 	printf(_("  maximum transition latency: "));
-	if (!latency) {
-		printf(_(" Cannot determine latency.\n"));
+	if (!latency || latency == UINT_MAX) {
+		printf(_(" Cannot determine or is not supported.\n"));
 		return -EINVAL;
 	}
 

commit 562e5f1a352977f45d0d0ed3279b556d3e41e1ba
Author: Jacob Tanenbaum <jtanenba@redhat.com>
Date:   Tue Dec 1 17:14:16 2015 +0100

    cpupower: rework the "cpupower frequency-info" command
    
    this patch makes two changes to the way that "cpupower
    frequancy-info" operates
    
    1. make it so that querying individual values always returns a
       message to the user
    
    currently cpupower frequency info doesn't return anything to the user when
    querying an individual value cannot be returned
    
    [root@amd-dinar-09 cpupower]# cpupower -c 4 frequency-info -d
    analyzing CPU 4:
    [root@amd-dinar-09 cpupower]#
    
    I added messages so that each query prints a message to the terminal
    
    [root@amd-dinar-09 cpupower]# ./cpupower -c 4 frequency-info -d
    analyzing CPU 4:
      no or unknown cpufreq driver is active on this CPU
    [root@amd-dinar-09 cpupower]#
    
    (this is just one example)
    
    2. change debug_output_one() to use the functions already provided
       by cpufreq-info.c to query individual values of interest.
    
    Signed-off-by: Jacob Tanenbaum <jtanenba@redhat.com>
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 522b357f4110..c13bc8c7c860 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -245,149 +245,21 @@ static int get_boost_mode(unsigned int cpu)
 	return 0;
 }
 
-static void debug_output_one(unsigned int cpu)
-{
-	char *driver;
-	struct cpufreq_affected_cpus *cpus;
-	struct cpufreq_available_frequencies *freqs;
-	unsigned long min, max, freq_kernel, freq_hardware;
-	unsigned long total_trans, latency;
-	unsigned long long total_time;
-	struct cpufreq_policy *policy;
-	struct cpufreq_available_governors *governors;
-	struct cpufreq_stats *stats;
-
-	if (cpufreq_cpu_exists(cpu))
-		return;
-
-	freq_kernel = cpufreq_get_freq_kernel(cpu);
-	freq_hardware = cpufreq_get_freq_hardware(cpu);
-
-	driver = cpufreq_get_driver(cpu);
-	if (!driver) {
-		printf(_("  no or unknown cpufreq driver is active on this CPU\n"));
-	} else {
-		printf(_("  driver: %s\n"), driver);
-		cpufreq_put_driver(driver);
-	}
-
-	cpus = cpufreq_get_related_cpus(cpu);
-	if (cpus) {
-		printf(_("  CPUs which run at the same hardware frequency: "));
-		while (cpus->next) {
-			printf("%d ", cpus->cpu);
-			cpus = cpus->next;
-		}
-		printf("%d\n", cpus->cpu);
-		cpufreq_put_related_cpus(cpus);
-	}
-
-	cpus = cpufreq_get_affected_cpus(cpu);
-	if (cpus) {
-		printf(_("  CPUs which need to have their frequency coordinated by software: "));
-		while (cpus->next) {
-			printf("%d ", cpus->cpu);
-			cpus = cpus->next;
-		}
-		printf("%d\n", cpus->cpu);
-		cpufreq_put_affected_cpus(cpus);
-	}
-
-	latency = cpufreq_get_transition_latency(cpu);
-	if (latency) {
-		printf(_("  maximum transition latency: "));
-		print_duration(latency);
-		printf(".\n");
-	}
-
-	if (!(cpufreq_get_hardware_limits(cpu, &min, &max))) {
-		printf(_("  hardware limits: "));
-		print_speed(min);
-		printf(" - ");
-		print_speed(max);
-		printf("\n");
-	}
-
-	freqs = cpufreq_get_available_frequencies(cpu);
-	if (freqs) {
-		printf(_("  available frequency steps: "));
-		while (freqs->next) {
-			print_speed(freqs->frequency);
-			printf(", ");
-			freqs = freqs->next;
-		}
-		print_speed(freqs->frequency);
-		printf("\n");
-		cpufreq_put_available_frequencies(freqs);
-	}
-
-	governors = cpufreq_get_available_governors(cpu);
-	if (governors) {
-		printf(_("  available cpufreq governors: "));
-		while (governors->next) {
-			printf("%s, ", governors->governor);
-			governors = governors->next;
-		}
-		printf("%s\n", governors->governor);
-		cpufreq_put_available_governors(governors);
-	}
-
-	policy = cpufreq_get_policy(cpu);
-	if (policy) {
-		printf(_("  current policy: frequency should be within "));
-		print_speed(policy->min);
-		printf(_(" and "));
-		print_speed(policy->max);
-
-		printf(".\n                  ");
-		printf(_("The governor \"%s\" may"
-		       " decide which speed to use\n                  within this range.\n"),
-		       policy->governor);
-		cpufreq_put_policy(policy);
-	}
-
-	if (freq_kernel || freq_hardware) {
-		printf(_("  current CPU frequency is "));
-		if (freq_hardware) {
-			print_speed(freq_hardware);
-			printf(_(" (asserted by call to hardware)"));
-		} else
-			print_speed(freq_kernel);
-		printf(".\n");
-	}
-	stats = cpufreq_get_stats(cpu, &total_time);
-	if (stats) {
-		printf(_("  cpufreq stats: "));
-		while (stats) {
-			print_speed(stats->frequency);
-			printf(":%.2f%%", (100.0 * stats->time_in_state) / total_time);
-			stats = stats->next;
-			if (stats)
-				printf(", ");
-		}
-		cpufreq_put_stats(stats);
-		total_trans = cpufreq_get_transitions(cpu);
-		if (total_trans)
-			printf("  (%lu)\n", total_trans);
-		else
-			printf("\n");
-	}
-	get_boost_mode(cpu);
-
-}
-
 /* --freq / -f */
 
 static int get_freq_kernel(unsigned int cpu, unsigned int human)
 {
 	unsigned long freq = cpufreq_get_freq_kernel(cpu);
-	if (!freq)
+	printf(_("  current CPU frequency: "));
+	if (!freq) {
+		printf(_(" Unable to call to kernel\n"));
 		return -EINVAL;
+	}
 	if (human) {
 		print_speed(freq);
-		printf("\n");
 	} else
-		printf("%lu\n", freq);
+		printf("%lu", freq);
+	printf(_(" (asserted by call to kernel)\n"));
 	return 0;
 }
 
@@ -397,13 +269,16 @@ static int get_freq_kernel(unsigned int cpu, unsigned int human)
 static int get_freq_hardware(unsigned int cpu, unsigned int human)
 {
 	unsigned long freq = cpufreq_get_freq_hardware(cpu);
-	if (!freq)
+	printf(_("  current CPU frequency: "));
+	if (!freq) {
+		printf("Unable to call hardware\n");
 		return -EINVAL;
+	}
 	if (human) {
 		print_speed(freq);
-		printf("\n");
 	} else
-		printf("%lu\n", freq);
+		printf("%lu", freq);
+	printf(_(" (asserted by call to hardware)\n"));
 	return 0;
 }
 
@@ -412,9 +287,17 @@ static int get_freq_hardware(unsigned int cpu, unsigned int human)
 static int get_hardware_limits(unsigned int cpu)
 {
 	unsigned long min, max;
-	if (cpufreq_get_hardware_limits(cpu, &min, &max))
+
+	printf(_("  hardware limits: "));
+	if (cpufreq_get_hardware_limits(cpu, &min, &max)) {
+		printf(_("Not Available\n"));
 		return -EINVAL;
-	printf("%lu %lu\n", min, max);
+	}
+
+	print_speed(min);
+	printf(" - ");
+	print_speed(max);
+	printf("\n");
 	return 0;
 }
 
@@ -423,9 +306,11 @@ static int get_hardware_limits(unsigned int cpu)
 static int get_driver(unsigned int cpu)
 {
 	char *driver = cpufreq_get_driver(cpu);
-	if (!driver)
+	if (!driver) {
+		printf(_("  no or unknown cpufreq driver is active on this CPU\n"));
 		return -EINVAL;
-	printf("%s\n", driver);
+	}
+	printf("  driver: %s\n", driver);
 	cpufreq_put_driver(driver);
 	return 0;
 }
@@ -435,9 +320,19 @@ static int get_driver(unsigned int cpu)
 static int get_policy(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_get_policy(cpu);
-	if (!policy)
+	if (!policy) {
+		printf(_("  Unable to determine current policy\n"));
 		return -EINVAL;
-	printf("%lu %lu %s\n", policy->min, policy->max, policy->governor);
+	}
+	printf(_("  current policy: frequency should be within "));
+	print_speed(policy->min);
+	printf(_(" and "));
+	print_speed(policy->max);
+
+	printf(".\n                  ");
+	printf(_("The governor \"%s\" may decide which speed to use\n"
+	       "                  within this range.\n"),
+	       policy->governor);
 	cpufreq_put_policy(policy);
 	return 0;
 }
@@ -448,8 +343,12 @@ static int get_available_governors(unsigned int cpu)
 {
 	struct cpufreq_available_governors *governors =
 		cpufreq_get_available_governors(cpu);
-	if (!governors)
+
+	printf(_("  available cpufreq governors: "));
+	if (!governors) {
+		printf(_("Not Available\n"));
 		return -EINVAL;
+	}
 
 	while (governors->next) {
 		printf("%s ", governors->governor);
@@ -466,8 +365,12 @@ static int get_available_governors(unsigned int cpu)
 static int get_affected_cpus(unsigned int cpu)
 {
 	struct cpufreq_affected_cpus *cpus = cpufreq_get_affected_cpus(cpu);
-	if (!cpus)
+
+	printf(_("  CPUs which need to have their frequency coordinated by software: "));
+	if (!cpus) {
+		printf(_("Not Available\n"));
 		return -EINVAL;
+	}
 
 	while (cpus->next) {
 		printf("%d ", cpus->cpu);
@@ -483,8 +386,12 @@ static int get_affected_cpus(unsigned int cpu)
 static int get_related_cpus(unsigned int cpu)
 {
 	struct cpufreq_affected_cpus *cpus = cpufreq_get_related_cpus(cpu);
-	if (!cpus)
+
+	printf(_("  CPUs which run at the same hardware frequency: "));
+	if (!cpus) {
+		printf(_("Not Available\n"));
 		return -EINVAL;
+	}
 
 	while (cpus->next) {
 		printf("%d ", cpus->cpu);
@@ -525,8 +432,12 @@ static int get_freq_stats(unsigned int cpu, unsigned int human)
 static int get_latency(unsigned int cpu, unsigned int human)
 {
 	unsigned long latency = cpufreq_get_transition_latency(cpu);
-	if (!latency)
+
+	printf(_("  maximum transition latency: "));
+	if (!latency) {
+		printf(_(" Cannot determine latency.\n"));
 		return -EINVAL;
+	}
 
 	if (human) {
 		print_duration(latency);
@@ -536,6 +447,36 @@ static int get_latency(unsigned int cpu, unsigned int human)
 	return 0;
 }
 
+static void debug_output_one(unsigned int cpu)
+{
+	struct cpufreq_available_frequencies *freqs;
+
+	get_driver(cpu);
+	get_related_cpus(cpu);
+	get_affected_cpus(cpu);
+	get_latency(cpu, 1);
+	get_hardware_limits(cpu);
+
+	freqs = cpufreq_get_available_frequencies(cpu);
+	if (freqs) {
+		printf(_("  available frequency steps:  "));
+		while (freqs->next) {
+			print_speed(freqs->frequency);
+			printf(", ");
+			freqs = freqs->next;
+		}
+		print_speed(freqs->frequency);
+		printf("\n");
+		cpufreq_put_available_frequencies(freqs);
+	}
+
+	get_available_governors(cpu);
+	get_policy(cpu);
+	if (get_freq_hardware(cpu, 1) < 0)
+		get_freq_kernel(cpu, 1);
+	get_boost_mode(cpu);
+}
+
 static struct option info_opts[] = {
 	{"debug",	 no_argument,		 NULL,	 'e'},
 	{"boost",	 no_argument,		 NULL,	 'b'},

commit ce512b84045459f4a6c119a109c950c6bc4a6f3a
Author: Thomas Renninger <trenn@suse.com>
Date:   Tue Dec 1 17:14:15 2015 +0100

    cpupower: Do not analyse offlined cpus
    
    Use sysfs_is_cpu_online(cpu) instead of cpufreq_cpu_exists(cpu) to detect offlined cpus.
    
    Re-arrange printfs slightly to have a consistent output even if you have multiple CPUs
    as output and even if offlined cores are in between.
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 0e6764330241..522b357f4110 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -14,6 +14,7 @@
 #include <getopt.h>
 
 #include "cpufreq.h"
+#include "helpers/sysfs.h"
 #include "helpers/helpers.h"
 #include "helpers/bitmask.h"
 
@@ -647,11 +648,14 @@ int cmd_freq_info(int argc, char **argv)
 
 		if (!bitmask_isbitset(cpus_chosen, cpu))
 			continue;
-		if (cpufreq_cpu_exists(cpu)) {
-			printf(_("couldn't analyze CPU %d as it doesn't seem to be present\n"), cpu);
+
+		printf(_("analyzing CPU %d:\n"), cpu);
+
+		if (sysfs_is_cpu_online(cpu) != 1) {
+			printf(_(" *is offline\n"));
+			printf("\n");
 			continue;
 		}
-		printf(_("analyzing CPU %d:\n"), cpu);
 
 		switch (output_param) {
 		case 'b':
@@ -693,6 +697,7 @@ int cmd_freq_info(int argc, char **argv)
 		}
 		if (ret)
 			return ret;
+		printf("\n");
 	}
 	return ret;
 }

commit 57ab3b08725163bfe385aaeea6837f9b1213af3d
Author: Sriram Raghunathan <sriram@marirs.net.in>
Date:   Fri Oct 23 09:52:45 2015 +0200

    Creating a common structure initialization pattern for struct option
    
    This patch tries to creates a common structure initialization
    within the cpupower tool.
    
    Previously the ``struct option`` was initialized
    using `designated initializer` technique which was
    not needed. There were conflicting initialization methods seen with
    
    bench/main.c & others.
    
    Signed-off-by: Sriram Raghunathan <sriram@marirs.net.in>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index b4b90a97662c..0e6764330241 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -536,21 +536,21 @@ static int get_latency(unsigned int cpu, unsigned int human)
 }
 
 static struct option info_opts[] = {
-	{ .name = "debug",	.has_arg = no_argument,		.flag = NULL,	.val = 'e'},
-	{ .name = "boost",	.has_arg = no_argument,		.flag = NULL,	.val = 'b'},
-	{ .name = "freq",	.has_arg = no_argument,		.flag = NULL,	.val = 'f'},
-	{ .name = "hwfreq",	.has_arg = no_argument,		.flag = NULL,	.val = 'w'},
-	{ .name = "hwlimits",	.has_arg = no_argument,		.flag = NULL,	.val = 'l'},
-	{ .name = "driver",	.has_arg = no_argument,		.flag = NULL,	.val = 'd'},
-	{ .name = "policy",	.has_arg = no_argument,		.flag = NULL,	.val = 'p'},
-	{ .name = "governors",	.has_arg = no_argument,		.flag = NULL,	.val = 'g'},
-	{ .name = "related-cpus", .has_arg = no_argument,	.flag = NULL,	.val = 'r'},
-	{ .name = "affected-cpus",.has_arg = no_argument,	.flag = NULL,	.val = 'a'},
-	{ .name = "stats",	.has_arg = no_argument,		.flag = NULL,	.val = 's'},
-	{ .name = "latency",	.has_arg = no_argument,		.flag = NULL,	.val = 'y'},
-	{ .name = "proc",	.has_arg = no_argument,		.flag = NULL,	.val = 'o'},
-	{ .name = "human",	.has_arg = no_argument,		.flag = NULL,	.val = 'm'},
-	{ .name = "no-rounding", .has_arg = no_argument,	.flag = NULL,	.val = 'n'},
+	{"debug",	 no_argument,		 NULL,	 'e'},
+	{"boost",	 no_argument,		 NULL,	 'b'},
+	{"freq",	 no_argument,		 NULL,	 'f'},
+	{"hwfreq",	 no_argument,		 NULL,	 'w'},
+	{"hwlimits",	 no_argument,		 NULL,	 'l'},
+	{"driver",	 no_argument,		 NULL,	 'd'},
+	{"policy",	 no_argument,		 NULL,	 'p'},
+	{"governors",	 no_argument,		 NULL,	 'g'},
+	{"related-cpus",  no_argument,	 NULL,	 'r'},
+	{"affected-cpus", no_argument,	 NULL,	 'a'},
+	{"stats",	 no_argument,		 NULL,	 's'},
+	{"latency",	 no_argument,		 NULL,	 'y'},
+	{"proc",	 no_argument,		 NULL,	 'o'},
+	{"human",	 no_argument,		 NULL,	 'm'},
+	{"no-rounding", no_argument,	 NULL,	 'n'},
 	{ },
 };
 

commit e091abc7f92b45010992df1ceb5da023d8faf13b
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Apr 24 10:32:07 2014 -0400

    PM / tools: cpupower: add option to display values without round offs
    
    The command "cpupower frequency-info" can be used when using cpupower to
    monitor and test processor behaviour to determine if the processor is
    behaving as expected.  This data can be compared to the output of
    /proc/cpuinfo or the output of
    /sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies
    to determine if the cpu is in an expected state.
    
    When doing this I noticed comparison test failures due to the way the
    data is displayed in cpupower.  For example,
    
    [root@intel-s3e37-02 cpupower]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
    2262000 2261000 2128000 1995000 1862000 1729000 1596000 1463000 1330000
    1197000 1064000
    
    compared to
    
    [root@intel-s3e37-02 cpupower]# cpupower frequency-info
    analyzing CPU 0:
      driver: acpi-cpufreq
      CPUs which run at the same hardware frequency: 0
      CPUs which need to have their frequency coordinated by software: 0
      maximum transition latency: 10.0 us.
      hardware limits: 1.06 GHz - 2.26 GHz
      available frequency steps: 2.26 GHz, 2.26 GHz, 2.13 GHz, 2.00 GHz, 1.86 GHz, 1.73 GHz, 1.60 GHz, 1.46 GHz, 1.33 GHz, 1.20 GHz, 1.06 GHz
      available cpufreq governors: conservative, userspace, powersave, ondemand, performance
      current policy: frequency should be within 1.06 GHz and 2.26 GHz.
                      The governor "performance" may decide which speed to use
                      within this range.
      current CPU frequency is 2.26 GHz (asserted by call to hardware).
      boost state support:
        Supported: yes
        Active: yes
    
    shows very different values for the available frequency steps.  The cpupower
    output rounds off values at 2 decimal points and this causes problems with
    test scripts.  For example, with the data above,
    
    1.064 is 1.06
    1.197 is 1.20
    1.596 is 1.60
    1.995 is 2.00
    2.128 is 2.13
    
    and most confusingly,
    
    2.261 is 2.26
    2.262 is 2.26
    
    Truncating these values serves no real purpose other than making the output
    pretty.  Since the default has been to round off these values I am adding
    a -n/--no-rounding option to the cpupower utility that will display the
    data without rounding off the still significant digits.
    
    After patch,
    
    analyzing CPU 0:
      driver: acpi-cpufreq
      CPUs which run at the same hardware frequency: 0
      CPUs which need to have their frequency coordinated by software: 0
      maximum transition latency: 10.000 us.
      hardware limits: 1.064000 GHz - 2.262000 GHz
      available frequency steps: 2.262000 GHz, 2.261000 GHz, 2.128000 GHz, 1.995000 GHz, 1.862000 GHz, 1.729000 GHz, 1.596000 GHz, 1.463000 GHz, 1.330000 GHz, 1.197000 GHz, 1.064000 GHz
      available cpufreq governors: conservative, userspace, powersave, ondemand, performance
      current policy: frequency should be within 1.064000 GHz and 2.262000 GHz.
                      The governor "performance" may decide which speed to use
                      within this range.
      current CPU frequency is 2.262000 GHz (asserted by call to hardware).
      boost state support:
        Supported: yes
        Active: yes
    
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [rjw: Subject]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 28953c9a7bd5..b4b90a97662c 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -82,29 +82,42 @@ static void proc_cpufreq_output(void)
 	}
 }
 
+static int no_rounding;
 static void print_speed(unsigned long speed)
 {
 	unsigned long tmp;
 
-	if (speed > 1000000) {
-		tmp = speed % 10000;
-		if (tmp >= 5000)
-			speed += 10000;
-		printf("%u.%02u GHz", ((unsigned int) speed/1000000),
-			((unsigned int) (speed%1000000)/10000));
-	} else if (speed > 100000) {
-		tmp = speed % 1000;
-		if (tmp >= 500)
-			speed += 1000;
-		printf("%u MHz", ((unsigned int) speed / 1000));
-	} else if (speed > 1000) {
-		tmp = speed % 100;
-		if (tmp >= 50)
-			speed += 100;
-		printf("%u.%01u MHz", ((unsigned int) speed/1000),
-			((unsigned int) (speed%1000)/100));
-	} else
-		printf("%lu kHz", speed);
+	if (no_rounding) {
+		if (speed > 1000000)
+			printf("%u.%06u GHz", ((unsigned int) speed/1000000),
+				((unsigned int) speed%1000000));
+		else if (speed > 100000)
+			printf("%u MHz", (unsigned int) speed);
+		else if (speed > 1000)
+			printf("%u.%03u MHz", ((unsigned int) speed/1000),
+				(unsigned int) (speed%1000));
+		else
+			printf("%lu kHz", speed);
+	} else {
+		if (speed > 1000000) {
+			tmp = speed%10000;
+			if (tmp >= 5000)
+				speed += 10000;
+			printf("%u.%02u GHz", ((unsigned int) speed/1000000),
+				((unsigned int) (speed%1000000)/10000));
+		} else if (speed > 100000) {
+			tmp = speed%1000;
+			if (tmp >= 500)
+				speed += 1000;
+			printf("%u MHz", ((unsigned int) speed/1000));
+		} else if (speed > 1000) {
+			tmp = speed%100;
+			if (tmp >= 50)
+				speed += 100;
+			printf("%u.%01u MHz", ((unsigned int) speed/1000),
+				((unsigned int) (speed%1000)/100));
+		}
+	}
 
 	return;
 }
@@ -113,26 +126,38 @@ static void print_duration(unsigned long duration)
 {
 	unsigned long tmp;
 
-	if (duration > 1000000) {
-		tmp = duration % 10000;
-		if (tmp >= 5000)
-			duration += 10000;
-		printf("%u.%02u ms", ((unsigned int) duration/1000000),
-			((unsigned int) (duration%1000000)/10000));
-	} else if (duration > 100000) {
-		tmp = duration % 1000;
-		if (tmp >= 500)
-			duration += 1000;
-		printf("%u us", ((unsigned int) duration / 1000));
-	} else if (duration > 1000) {
-		tmp = duration % 100;
-		if (tmp >= 50)
-			duration += 100;
-		printf("%u.%01u us", ((unsigned int) duration/1000),
-			((unsigned int) (duration%1000)/100));
-	} else
-		printf("%lu ns", duration);
-
+	if (no_rounding) {
+		if (duration > 1000000)
+			printf("%u.%06u ms", ((unsigned int) duration/1000000),
+				((unsigned int) duration%1000000));
+		else if (duration > 100000)
+			printf("%u us", ((unsigned int) duration/1000));
+		else if (duration > 1000)
+			printf("%u.%03u us", ((unsigned int) duration/1000),
+				((unsigned int) duration%1000));
+		else
+			printf("%lu ns", duration);
+	} else {
+		if (duration > 1000000) {
+			tmp = duration%10000;
+			if (tmp >= 5000)
+				duration += 10000;
+			printf("%u.%02u ms", ((unsigned int) duration/1000000),
+				((unsigned int) (duration%1000000)/10000));
+		} else if (duration > 100000) {
+			tmp = duration%1000;
+			if (tmp >= 500)
+				duration += 1000;
+			printf("%u us", ((unsigned int) duration / 1000));
+		} else if (duration > 1000) {
+			tmp = duration%100;
+			if (tmp >= 50)
+				duration += 100;
+			printf("%u.%01u us", ((unsigned int) duration/1000),
+				((unsigned int) (duration%1000)/100));
+		} else
+			printf("%lu ns", duration);
+	}
 	return;
 }
 
@@ -525,6 +550,7 @@ static struct option info_opts[] = {
 	{ .name = "latency",	.has_arg = no_argument,		.flag = NULL,	.val = 'y'},
 	{ .name = "proc",	.has_arg = no_argument,		.flag = NULL,	.val = 'o'},
 	{ .name = "human",	.has_arg = no_argument,		.flag = NULL,	.val = 'm'},
+	{ .name = "no-rounding", .has_arg = no_argument,	.flag = NULL,	.val = 'n'},
 	{ },
 };
 
@@ -538,7 +564,8 @@ int cmd_freq_info(int argc, char **argv)
 	int output_param = 0;
 
 	do {
-		ret = getopt_long(argc, argv, "oefwldpgrasmyb", info_opts, NULL);
+		ret = getopt_long(argc, argv, "oefwldpgrasmybn", info_opts,
+				  NULL);
 		switch (ret) {
 		case '?':
 			output_param = '?';
@@ -575,6 +602,9 @@ int cmd_freq_info(int argc, char **argv)
 			}
 			human = 1;
 			break;
+		case 'n':
+			no_rounding = 1;
+			break;
 		default:
 			fprintf(stderr, "invalid or unknown argument\n");
 			return EXIT_FAILURE;

commit 498ca793d90aef8ad38a852a969c257f62832738
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 6 18:11:43 2011 +0200

    cpupower: use man(1) when calling "cpupower help subcommand"
    
    Instead of printing something non-formatted to stdout, call
    man(1) to show the man page for the proper subcommand.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 5a1d25f056b3..28953c9a7bd5 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -510,37 +510,6 @@ static int get_latency(unsigned int cpu, unsigned int human)
 	return 0;
 }
 
-void freq_info_help(void)
-{
-	printf(_("Usage: cpupower freqinfo [options]\n"));
-	printf(_("Options:\n"));
-	printf(_("  -e, --debug          Prints out debug information [default]\n"));
-	printf(_("  -f, --freq           Get frequency the CPU currently runs at, according\n"
-	       "                       to the cpufreq core *\n"));
-	printf(_("  -w, --hwfreq         Get frequency the CPU currently runs at, by reading\n"
-	       "                       it from hardware (only available to root) *\n"));
-	printf(_("  -l, --hwlimits       Determine the minimum and maximum CPU frequency allowed *\n"));
-	printf(_("  -d, --driver         Determines the used cpufreq kernel driver *\n"));
-	printf(_("  -p, --policy         Gets the currently used cpufreq policy *\n"));
-	printf(_("  -g, --governors      Determines available cpufreq governors *\n"));
-	printf(_("  -r, --related-cpus   Determines which CPUs run at the same hardware frequency *\n"));
-	printf(_("  -a, --affected-cpus  Determines which CPUs need to have their frequency\n"
-			"                       coordinated by software *\n"));
-	printf(_("  -s, --stats          Shows cpufreq statistics if available\n"));
-	printf(_("  -y, --latency        Determines the maximum latency on CPU frequency changes *\n"));
-	printf(_("  -b, --boost          Checks for turbo or boost modes  *\n"));
-	printf(_("  -o, --proc           Prints out information like provided by the /proc/cpufreq\n"
-	       "                       interface in 2.4. and early 2.6. kernels\n"));
-	printf(_("  -m, --human          human-readable output for the -f, -w, -s and -y parameters\n"));
-	printf(_("  -h, --help           Prints out this screen\n"));
-
-	printf("\n");
-	printf(_("If no argument is given, full output about\n"
-	       "cpufreq is printed which is useful e.g. for reporting bugs.\n\n"));
-	printf(_("By default info of CPU 0 is shown which can be overridden\n"
-		 "with the cpupower --cpu main command option.\n"));
-}
-
 static struct option info_opts[] = {
 	{ .name = "debug",	.has_arg = no_argument,		.flag = NULL,	.val = 'e'},
 	{ .name = "boost",	.has_arg = no_argument,		.flag = NULL,	.val = 'b'},
@@ -556,7 +525,6 @@ static struct option info_opts[] = {
 	{ .name = "latency",	.has_arg = no_argument,		.flag = NULL,	.val = 'y'},
 	{ .name = "proc",	.has_arg = no_argument,		.flag = NULL,	.val = 'o'},
 	{ .name = "human",	.has_arg = no_argument,		.flag = NULL,	.val = 'm'},
-	{ .name = "help",	.has_arg = no_argument,		.flag = NULL,	.val = 'h'},
 	{ },
 };
 
@@ -570,16 +538,12 @@ int cmd_freq_info(int argc, char **argv)
 	int output_param = 0;
 
 	do {
-		ret = getopt_long(argc, argv, "hoefwldpgrasmyb", info_opts, NULL);
+		ret = getopt_long(argc, argv, "oefwldpgrasmyb", info_opts, NULL);
 		switch (ret) {
 		case '?':
 			output_param = '?';
 			cont = 0;
 			break;
-		case 'h':
-			output_param = 'h';
-			cont = 0;
-			break;
 		case -1:
 			cont = 0;
 			break;
@@ -642,11 +606,7 @@ int cmd_freq_info(int argc, char **argv)
 		return -EINVAL;
 	case '?':
 		printf(_("invalid or unknown argument\n"));
-		freq_info_help();
 		return -EINVAL;
-	case 'h':
-		freq_info_help();
-		return EXIT_SUCCESS;
 	case 'o':
 		proc_cpufreq_output();
 		return EXIT_SUCCESS;

commit 8fb2e440b223b966f74a04a48f6f71f288fa671b
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Jul 21 11:54:53 2011 +0200

    cpupower: Show Intel turbo ratio support via ./cpupower frequency-info
    
    This adds the last piece missing from turbostat (if called with -v).
    It shows on Intel machines supporting Turbo Boost how many cores
    have to be active/idle to enter which boost mode (frequency).
    
    Whether the HW really enters these boost modes can be verified via
    ./cpupower monitor.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: lenb@kernel.org
    CC: linux@dominikbrodowski.net
    CC: cpufreq@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index 8628644188cf..5a1d25f056b3 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -165,26 +165,56 @@ static int get_boost_mode(unsigned int cpu)
 	printf(_("    Supported: %s\n"), support ? _("yes") : _("no"));
 	printf(_("    Active: %s\n"), active ? _("yes") : _("no"));
 
-	/* ToDo: Only works for AMD for now... */
-
 	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&
 	    cpupower_cpu_info.family >= 0x10) {
 		ret = decode_pstates(cpu, cpupower_cpu_info.family, b_states,
 				     pstates, &pstate_no);
 		if (ret)
 			return ret;
-	} else
-		return 0;
 
-	printf(_("    Boost States: %d\n"), b_states);
-	printf(_("    Total States: %d\n"), pstate_no);
-	for (i = 0; i < pstate_no; i++) {
-		if (i < b_states)
-			printf(_("    Pstate-Pb%d: %luMHz (boost state)\n"),
-			       i, pstates[i]);
+		printf(_("    Boost States: %d\n"), b_states);
+		printf(_("    Total States: %d\n"), pstate_no);
+		for (i = 0; i < pstate_no; i++) {
+			if (i < b_states)
+				printf(_("    Pstate-Pb%d: %luMHz (boost state)"
+					 "\n"), i, pstates[i]);
+			else
+				printf(_("    Pstate-P%d:  %luMHz\n"),
+				       i - b_states, pstates[i]);
+		}
+	} else if (cpupower_cpu_info.caps & CPUPOWER_CAP_HAS_TURBO_RATIO) {
+		double bclk;
+		unsigned long long intel_turbo_ratio = 0;
+		unsigned int ratio;
+
+		/* Any way to autodetect this ? */
+		if (cpupower_cpu_info.caps & CPUPOWER_CAP_IS_SNB)
+			bclk = 100.00;
 		else
-			printf(_("    Pstate-P%d:  %luMHz\n"),
-			       i - b_states, pstates[i]);
+			bclk = 133.33;
+		intel_turbo_ratio = msr_intel_get_turbo_ratio(cpu);
+		dprint ("    Ratio: 0x%llx - bclk: %f\n",
+			intel_turbo_ratio, bclk);
+
+		ratio = (intel_turbo_ratio >> 24) & 0xFF;
+		if (ratio)
+			printf(_("    %.0f MHz max turbo 4 active cores\n"),
+			       ratio * bclk);
+
+		ratio = (intel_turbo_ratio >> 16) & 0xFF;
+		if (ratio)
+			printf(_("    %.0f MHz max turbo 3 active cores\n"),
+			       ratio * bclk);
+
+		ratio = (intel_turbo_ratio >> 8) & 0xFF;
+		if (ratio)
+			printf(_("    %.0f MHz max turbo 2 active cores\n"),
+			       ratio * bclk);
+
+		ratio = (intel_turbo_ratio >> 0) & 0xFF;
+		if (ratio)
+			printf(_("    %.0f MHz max turbo 1 active cores\n"),
+			       ratio * bclk);
 	}
 	return 0;
 }

commit a1ce5ba2b7d08ab6347dc254f86f70e91c5f1a44
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 20:33:50 2011 +0200

    cpupowerutils: utils - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
index eaa8be06edfa..8628644188cf 100644
--- a/tools/power/cpupower/utils/cpufreq-info.c
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -27,7 +27,7 @@ static unsigned int count_cpus(void)
 	unsigned int cpunr = 0;
 
 	fp = fopen("/proc/stat", "r");
-	if(!fp) {
+	if (!fp) {
 		printf(_("Couldn't count the number of CPUs (%s: %s), assuming 1\n"), "/proc/stat", strerror(errno));
 		return 1;
 	}
@@ -48,7 +48,7 @@ static unsigned int count_cpus(void)
 	fclose(fp);
 
 	/* cpu count starts from 0, on error return 1 (UP) */
-	return (ret+1);
+	return ret + 1;
 }
 
 
@@ -63,7 +63,7 @@ static void proc_cpufreq_output(void)
 	printf(_("          minimum CPU frequency  -  maximum CPU frequency  -  governor\n"));
 
 	nr_cpus = count_cpus();
-	for (cpu=0; cpu < nr_cpus; cpu++) {
+	for (cpu = 0; cpu < nr_cpus; cpu++) {
 		policy = cpufreq_get_policy(cpu);
 		if (!policy)
 			continue;
@@ -75,7 +75,8 @@ static void proc_cpufreq_output(void)
 			max_pctg = (policy->max * 100) / max;
 		}
 		printf("CPU%3d    %9lu kHz (%3d %%)  -  %9lu kHz (%3d %%)  -  %s\n",
-		       cpu , policy->min, max ? min_pctg : 0, policy->max, max ? max_pctg : 0, policy->governor);
+			cpu , policy->min, max ? min_pctg : 0, policy->max,
+			max ? max_pctg : 0, policy->governor);
 
 		cpufreq_put_policy(policy);
 	}
@@ -89,21 +90,21 @@ static void print_speed(unsigned long speed)
 		tmp = speed % 10000;
 		if (tmp >= 5000)
 			speed += 10000;
-		printf ("%u.%02u GHz", ((unsigned int) speed/1000000),
+		printf("%u.%02u GHz", ((unsigned int) speed/1000000),
 			((unsigned int) (speed%1000000)/10000));
 	} else if (speed > 100000) {
 		tmp = speed % 1000;
 		if (tmp >= 500)
 			speed += 1000;
-		printf ("%u MHz", ((unsigned int) speed / 1000));
+		printf("%u MHz", ((unsigned int) speed / 1000));
 	} else if (speed > 1000) {
 		tmp = speed % 100;
 		if (tmp >= 50)
 			speed += 100;
-		printf ("%u.%01u MHz", ((unsigned int) speed/1000),
+		printf("%u.%01u MHz", ((unsigned int) speed/1000),
 			((unsigned int) (speed%1000)/100));
 	} else
-		printf ("%lu kHz", speed);
+		printf("%lu kHz", speed);
 
 	return;
 }
@@ -116,28 +117,29 @@ static void print_duration(unsigned long duration)
 		tmp = duration % 10000;
 		if (tmp >= 5000)
 			duration += 10000;
-		printf ("%u.%02u ms", ((unsigned int) duration/1000000),
+		printf("%u.%02u ms", ((unsigned int) duration/1000000),
 			((unsigned int) (duration%1000000)/10000));
 	} else if (duration > 100000) {
 		tmp = duration % 1000;
 		if (tmp >= 500)
 			duration += 1000;
-		printf ("%u us", ((unsigned int) duration / 1000));
+		printf("%u us", ((unsigned int) duration / 1000));
 	} else if (duration > 1000) {
 		tmp = duration % 100;
 		if (tmp >= 50)
 			duration += 100;
-		printf ("%u.%01u us", ((unsigned int) duration/1000),
+		printf("%u.%01u us", ((unsigned int) duration/1000),
 			((unsigned int) (duration%1000)/100));
 	} else
-		printf ("%lu ns", duration);
+		printf("%lu ns", duration);
 
 	return;
 }
 
 /* --boost / -b */
 
-static int get_boost_mode(unsigned int cpu) {
+static int get_boost_mode(unsigned int cpu)
+{
 	int support, active, b_states = 0, ret, pstate_no, i;
 	/* ToDo: Make this more global */
 	unsigned long pstates[MAX_HW_PSTATES] = {0,};
@@ -158,13 +160,13 @@ static int get_boost_mode(unsigned int cpu) {
 	   && (cpuid_edx(0x80000007) & (1 << 7)))
 	*/
 
-	printf(_("  boost state support: \n"));
+	printf(_("  boost state support:\n"));
 
 	printf(_("    Supported: %s\n"), support ? _("yes") : _("no"));
 	printf(_("    Active: %s\n"), active ? _("yes") : _("no"));
 
 	/* ToDo: Only works for AMD for now... */
-	
+
 	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&
 	    cpupower_cpu_info.family >= 0x10) {
 		ret = decode_pstates(cpu, cpupower_cpu_info.family, b_states,
@@ -196,12 +198,11 @@ static void debug_output_one(unsigned int cpu)
 	unsigned long total_trans, latency;
 	unsigned long long total_time;
 	struct cpufreq_policy *policy;
-	struct cpufreq_available_governors * governors;
+	struct cpufreq_available_governors *governors;
 	struct cpufreq_stats *stats;
 
-	if (cpufreq_cpu_exists(cpu)) {
+	if (cpufreq_cpu_exists(cpu))
 		return;
-	}
 
 	freq_kernel = cpufreq_get_freq_kernel(cpu);
 	freq_hardware = cpufreq_get_freq_hardware(cpu);
@@ -294,8 +295,7 @@ static void debug_output_one(unsigned int cpu)
 		if (freq_hardware) {
 			print_speed(freq_hardware);
 			printf(_(" (asserted by call to hardware)"));
-		}
-		else
+		} else
 			print_speed(freq_kernel);
 		printf(".\n");
 	}
@@ -322,7 +322,8 @@ static void debug_output_one(unsigned int cpu)
 
 /* --freq / -f */
 
-static int get_freq_kernel(unsigned int cpu, unsigned int human) {
+static int get_freq_kernel(unsigned int cpu, unsigned int human)
+{
 	unsigned long freq = cpufreq_get_freq_kernel(cpu);
 	if (!freq)
 		return -EINVAL;
@@ -337,7 +338,8 @@ static int get_freq_kernel(unsigned int cpu, unsigned int human) {
 
 /* --hwfreq / -w */
 
-static int get_freq_hardware(unsigned int cpu, unsigned int human) {
+static int get_freq_hardware(unsigned int cpu, unsigned int human)
+{
 	unsigned long freq = cpufreq_get_freq_hardware(cpu);
 	if (!freq)
 		return -EINVAL;
@@ -351,7 +353,8 @@ static int get_freq_hardware(unsigned int cpu, unsigned int human) {
 
 /* --hwlimits / -l */
 
-static int get_hardware_limits(unsigned int cpu) {
+static int get_hardware_limits(unsigned int cpu)
+{
 	unsigned long min, max;
 	if (cpufreq_get_hardware_limits(cpu, &min, &max))
 		return -EINVAL;
@@ -361,7 +364,8 @@ static int get_hardware_limits(unsigned int cpu) {
 
 /* --driver / -d */
 
-static int get_driver(unsigned int cpu) {
+static int get_driver(unsigned int cpu)
+{
 	char *driver = cpufreq_get_driver(cpu);
 	if (!driver)
 		return -EINVAL;
@@ -372,7 +376,8 @@ static int get_driver(unsigned int cpu) {
 
 /* --policy / -p */
 
-static int get_policy(unsigned int cpu) {
+static int get_policy(unsigned int cpu)
+{
 	struct cpufreq_policy *policy = cpufreq_get_policy(cpu);
 	if (!policy)
 		return -EINVAL;
@@ -383,8 +388,10 @@ static int get_policy(unsigned int cpu) {
 
 /* --governors / -g */
 
-static int get_available_governors(unsigned int cpu) {
-	struct cpufreq_available_governors *governors = cpufreq_get_available_governors(cpu);
+static int get_available_governors(unsigned int cpu)
+{
+	struct cpufreq_available_governors *governors =
+		cpufreq_get_available_governors(cpu);
 	if (!governors)
 		return -EINVAL;
 
@@ -400,7 +407,8 @@ static int get_available_governors(unsigned int cpu) {
 
 /* --affected-cpus  / -a */
 
-static int get_affected_cpus(unsigned int cpu) {
+static int get_affected_cpus(unsigned int cpu)
+{
 	struct cpufreq_affected_cpus *cpus = cpufreq_get_affected_cpus(cpu);
 	if (!cpus)
 		return -EINVAL;
@@ -416,7 +424,8 @@ static int get_affected_cpus(unsigned int cpu) {
 
 /* --related-cpus  / -r */
 
-static int get_related_cpus(unsigned int cpu) {
+static int get_related_cpus(unsigned int cpu)
+{
 	struct cpufreq_affected_cpus *cpus = cpufreq_get_related_cpus(cpu);
 	if (!cpus)
 		return -EINVAL;
@@ -432,17 +441,19 @@ static int get_related_cpus(unsigned int cpu) {
 
 /* --stats / -s */
 
-static int get_freq_stats(unsigned int cpu, unsigned int human) {
+static int get_freq_stats(unsigned int cpu, unsigned int human)
+{
 	unsigned long total_trans = cpufreq_get_transitions(cpu);
 	unsigned long long total_time;
 	struct cpufreq_stats *stats = cpufreq_get_stats(cpu, &total_time);
 	while (stats) {
 		if (human) {
 			print_speed(stats->frequency);
-			printf(":%.2f%%", (100.0 * stats->time_in_state) / total_time);
-		}
-		else
-			printf("%lu:%llu", stats->frequency, stats->time_in_state);
+			printf(":%.2f%%",
+				(100.0 * stats->time_in_state) / total_time);
+		} else
+			printf("%lu:%llu",
+				stats->frequency, stats->time_in_state);
 		stats = stats->next;
 		if (stats)
 			printf(", ");
@@ -455,7 +466,8 @@ static int get_freq_stats(unsigned int cpu, unsigned int human) {
 
 /* --latency / -y */
 
-static int get_latency(unsigned int cpu, unsigned int human) {
+static int get_latency(unsigned int cpu, unsigned int human)
+{
 	unsigned long latency = cpufreq_get_transition_latency(cpu);
 	if (!latency)
 		return -EINVAL;
@@ -468,7 +480,8 @@ static int get_latency(unsigned int cpu, unsigned int human) {
 	return 0;
 }
 
-void freq_info_help(void) {
+void freq_info_help(void)
+{
 	printf(_("Usage: cpupower freqinfo [options]\n"));
 	printf(_("Options:\n"));
 	printf(_("  -e, --debug          Prints out debug information [default]\n"));
@@ -494,26 +507,26 @@ void freq_info_help(void) {
 	printf("\n");
 	printf(_("If no argument is given, full output about\n"
 	       "cpufreq is printed which is useful e.g. for reporting bugs.\n\n"));
-	printf(_("By default info of CPU 0 is shown which can be overridden \n"
+	printf(_("By default info of CPU 0 is shown which can be overridden\n"
 		 "with the cpupower --cpu main command option.\n"));
 }
 
 static struct option info_opts[] = {
-	{ .name="debug",	.has_arg=no_argument,		.flag=NULL,	.val='e'},
-	{ .name="boost",	.has_arg=no_argument,		.flag=NULL,	.val='b'},
-	{ .name="freq",		.has_arg=no_argument,		.flag=NULL,	.val='f'},
-	{ .name="hwfreq",	.has_arg=no_argument,		.flag=NULL,	.val='w'},
-	{ .name="hwlimits",	.has_arg=no_argument,		.flag=NULL,	.val='l'},
-	{ .name="driver",	.has_arg=no_argument,		.flag=NULL,	.val='d'},
-	{ .name="policy",	.has_arg=no_argument,		.flag=NULL,	.val='p'},
-	{ .name="governors",	.has_arg=no_argument,		.flag=NULL,	.val='g'},
-	{ .name="related-cpus", .has_arg=no_argument,		.flag=NULL,	.val='r'},
-	{ .name="affected-cpus",.has_arg=no_argument,		.flag=NULL,	.val='a'},
-	{ .name="stats",	.has_arg=no_argument,		.flag=NULL,	.val='s'},
-	{ .name="latency",	.has_arg=no_argument,		.flag=NULL,	.val='y'},
-	{ .name="proc",		.has_arg=no_argument,		.flag=NULL,	.val='o'},
-	{ .name="human",	.has_arg=no_argument,		.flag=NULL,	.val='m'},
-	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ .name = "debug",	.has_arg = no_argument,		.flag = NULL,	.val = 'e'},
+	{ .name = "boost",	.has_arg = no_argument,		.flag = NULL,	.val = 'b'},
+	{ .name = "freq",	.has_arg = no_argument,		.flag = NULL,	.val = 'f'},
+	{ .name = "hwfreq",	.has_arg = no_argument,		.flag = NULL,	.val = 'w'},
+	{ .name = "hwlimits",	.has_arg = no_argument,		.flag = NULL,	.val = 'l'},
+	{ .name = "driver",	.has_arg = no_argument,		.flag = NULL,	.val = 'd'},
+	{ .name = "policy",	.has_arg = no_argument,		.flag = NULL,	.val = 'p'},
+	{ .name = "governors",	.has_arg = no_argument,		.flag = NULL,	.val = 'g'},
+	{ .name = "related-cpus", .has_arg = no_argument,	.flag = NULL,	.val = 'r'},
+	{ .name = "affected-cpus",.has_arg = no_argument,	.flag = NULL,	.val = 'a'},
+	{ .name = "stats",	.has_arg = no_argument,		.flag = NULL,	.val = 's'},
+	{ .name = "latency",	.has_arg = no_argument,		.flag = NULL,	.val = 'y'},
+	{ .name = "proc",	.has_arg = no_argument,		.flag = NULL,	.val = 'o'},
+	{ .name = "human",	.has_arg = no_argument,		.flag = NULL,	.val = 'm'},
+	{ .name = "help",	.has_arg = no_argument,		.flag = NULL,	.val = 'h'},
 	{ },
 };
 
@@ -572,7 +585,7 @@ int cmd_freq_info(int argc, char **argv)
 			fprintf(stderr, "invalid or unknown argument\n");
 			return EXIT_FAILURE;
 		}
-	} while(cont);
+	} while (cont);
 
 	switch (output_param) {
 	case 'o':
@@ -591,7 +604,7 @@ int cmd_freq_info(int argc, char **argv)
 	/* Default is: show output of CPU 0 only */
 	if (bitmask_isallclear(cpus_chosen))
 		bitmask_setbit(cpus_chosen, 0);
-		
+
 	switch (output_param) {
 	case -1:
 		printf(_("You can't specify more than one --cpu parameter and/or\n"
@@ -659,7 +672,7 @@ int cmd_freq_info(int argc, char **argv)
 			break;
 		}
 		if (ret)
-			return (ret);
+			return ret;
 	}
 	return ret;
 }

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpufreq-info.c b/tools/power/cpupower/utils/cpufreq-info.c
new file mode 100644
index 000000000000..eaa8be06edfa
--- /dev/null
+++ b/tools/power/cpupower/utils/cpufreq-info.c
@@ -0,0 +1,665 @@
+/*
+ *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ */
+
+
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <getopt.h>
+
+#include "cpufreq.h"
+#include "helpers/helpers.h"
+#include "helpers/bitmask.h"
+
+#define LINE_LEN 10
+
+static unsigned int count_cpus(void)
+{
+	FILE *fp;
+	char value[LINE_LEN];
+	unsigned int ret = 0;
+	unsigned int cpunr = 0;
+
+	fp = fopen("/proc/stat", "r");
+	if(!fp) {
+		printf(_("Couldn't count the number of CPUs (%s: %s), assuming 1\n"), "/proc/stat", strerror(errno));
+		return 1;
+	}
+
+	while (!feof(fp)) {
+		if (!fgets(value, LINE_LEN, fp))
+			continue;
+		value[LINE_LEN - 1] = '\0';
+		if (strlen(value) < (LINE_LEN - 2))
+			continue;
+		if (strstr(value, "cpu "))
+			continue;
+		if (sscanf(value, "cpu%d ", &cpunr) != 1)
+			continue;
+		if (cpunr > ret)
+			ret = cpunr;
+	}
+	fclose(fp);
+
+	/* cpu count starts from 0, on error return 1 (UP) */
+	return (ret+1);
+}
+
+
+static void proc_cpufreq_output(void)
+{
+	unsigned int cpu, nr_cpus;
+	struct cpufreq_policy *policy;
+	unsigned int min_pctg = 0;
+	unsigned int max_pctg = 0;
+	unsigned long min, max;
+
+	printf(_("          minimum CPU frequency  -  maximum CPU frequency  -  governor\n"));
+
+	nr_cpus = count_cpus();
+	for (cpu=0; cpu < nr_cpus; cpu++) {
+		policy = cpufreq_get_policy(cpu);
+		if (!policy)
+			continue;
+
+		if (cpufreq_get_hardware_limits(cpu, &min, &max)) {
+			max = 0;
+		} else {
+			min_pctg = (policy->min * 100) / max;
+			max_pctg = (policy->max * 100) / max;
+		}
+		printf("CPU%3d    %9lu kHz (%3d %%)  -  %9lu kHz (%3d %%)  -  %s\n",
+		       cpu , policy->min, max ? min_pctg : 0, policy->max, max ? max_pctg : 0, policy->governor);
+
+		cpufreq_put_policy(policy);
+	}
+}
+
+static void print_speed(unsigned long speed)
+{
+	unsigned long tmp;
+
+	if (speed > 1000000) {
+		tmp = speed % 10000;
+		if (tmp >= 5000)
+			speed += 10000;
+		printf ("%u.%02u GHz", ((unsigned int) speed/1000000),
+			((unsigned int) (speed%1000000)/10000));
+	} else if (speed > 100000) {
+		tmp = speed % 1000;
+		if (tmp >= 500)
+			speed += 1000;
+		printf ("%u MHz", ((unsigned int) speed / 1000));
+	} else if (speed > 1000) {
+		tmp = speed % 100;
+		if (tmp >= 50)
+			speed += 100;
+		printf ("%u.%01u MHz", ((unsigned int) speed/1000),
+			((unsigned int) (speed%1000)/100));
+	} else
+		printf ("%lu kHz", speed);
+
+	return;
+}
+
+static void print_duration(unsigned long duration)
+{
+	unsigned long tmp;
+
+	if (duration > 1000000) {
+		tmp = duration % 10000;
+		if (tmp >= 5000)
+			duration += 10000;
+		printf ("%u.%02u ms", ((unsigned int) duration/1000000),
+			((unsigned int) (duration%1000000)/10000));
+	} else if (duration > 100000) {
+		tmp = duration % 1000;
+		if (tmp >= 500)
+			duration += 1000;
+		printf ("%u us", ((unsigned int) duration / 1000));
+	} else if (duration > 1000) {
+		tmp = duration % 100;
+		if (tmp >= 50)
+			duration += 100;
+		printf ("%u.%01u us", ((unsigned int) duration/1000),
+			((unsigned int) (duration%1000)/100));
+	} else
+		printf ("%lu ns", duration);
+
+	return;
+}
+
+/* --boost / -b */
+
+static int get_boost_mode(unsigned int cpu) {
+	int support, active, b_states = 0, ret, pstate_no, i;
+	/* ToDo: Make this more global */
+	unsigned long pstates[MAX_HW_PSTATES] = {0,};
+
+	if (cpupower_cpu_info.vendor != X86_VENDOR_AMD &&
+	    cpupower_cpu_info.vendor != X86_VENDOR_INTEL)
+		return 0;
+
+	ret = cpufreq_has_boost_support(cpu, &support, &active, &b_states);
+	if (ret) {
+		printf(_("Error while evaluating Boost Capabilities"
+				" on CPU %d -- are you root?\n"), cpu);
+		return ret;
+	}
+	/* P state changes via MSR are identified via cpuid 80000007
+	   on Intel and AMD, but we assume boost capable machines can do that
+	   if (cpuid_eax(0x80000000) >= 0x80000007
+	   && (cpuid_edx(0x80000007) & (1 << 7)))
+	*/
+
+	printf(_("  boost state support: \n"));
+
+	printf(_("    Supported: %s\n"), support ? _("yes") : _("no"));
+	printf(_("    Active: %s\n"), active ? _("yes") : _("no"));
+
+	/* ToDo: Only works for AMD for now... */
+	
+	if (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&
+	    cpupower_cpu_info.family >= 0x10) {
+		ret = decode_pstates(cpu, cpupower_cpu_info.family, b_states,
+				     pstates, &pstate_no);
+		if (ret)
+			return ret;
+	} else
+		return 0;
+
+	printf(_("    Boost States: %d\n"), b_states);
+	printf(_("    Total States: %d\n"), pstate_no);
+	for (i = 0; i < pstate_no; i++) {
+		if (i < b_states)
+			printf(_("    Pstate-Pb%d: %luMHz (boost state)\n"),
+			       i, pstates[i]);
+		else
+			printf(_("    Pstate-P%d:  %luMHz\n"),
+			       i - b_states, pstates[i]);
+	}
+	return 0;
+}
+
+static void debug_output_one(unsigned int cpu)
+{
+	char *driver;
+	struct cpufreq_affected_cpus *cpus;
+	struct cpufreq_available_frequencies *freqs;
+	unsigned long min, max, freq_kernel, freq_hardware;
+	unsigned long total_trans, latency;
+	unsigned long long total_time;
+	struct cpufreq_policy *policy;
+	struct cpufreq_available_governors * governors;
+	struct cpufreq_stats *stats;
+
+	if (cpufreq_cpu_exists(cpu)) {
+		return;
+	}
+
+	freq_kernel = cpufreq_get_freq_kernel(cpu);
+	freq_hardware = cpufreq_get_freq_hardware(cpu);
+
+	driver = cpufreq_get_driver(cpu);
+	if (!driver) {
+		printf(_("  no or unknown cpufreq driver is active on this CPU\n"));
+	} else {
+		printf(_("  driver: %s\n"), driver);
+		cpufreq_put_driver(driver);
+	}
+
+	cpus = cpufreq_get_related_cpus(cpu);
+	if (cpus) {
+		printf(_("  CPUs which run at the same hardware frequency: "));
+		while (cpus->next) {
+			printf("%d ", cpus->cpu);
+			cpus = cpus->next;
+		}
+		printf("%d\n", cpus->cpu);
+		cpufreq_put_related_cpus(cpus);
+	}
+
+	cpus = cpufreq_get_affected_cpus(cpu);
+	if (cpus) {
+		printf(_("  CPUs which need to have their frequency coordinated by software: "));
+		while (cpus->next) {
+			printf("%d ", cpus->cpu);
+			cpus = cpus->next;
+		}
+		printf("%d\n", cpus->cpu);
+		cpufreq_put_affected_cpus(cpus);
+	}
+
+	latency = cpufreq_get_transition_latency(cpu);
+	if (latency) {
+		printf(_("  maximum transition latency: "));
+		print_duration(latency);
+		printf(".\n");
+	}
+
+	if (!(cpufreq_get_hardware_limits(cpu, &min, &max))) {
+		printf(_("  hardware limits: "));
+		print_speed(min);
+		printf(" - ");
+		print_speed(max);
+		printf("\n");
+	}
+
+	freqs = cpufreq_get_available_frequencies(cpu);
+	if (freqs) {
+		printf(_("  available frequency steps: "));
+		while (freqs->next) {
+			print_speed(freqs->frequency);
+			printf(", ");
+			freqs = freqs->next;
+		}
+		print_speed(freqs->frequency);
+		printf("\n");
+		cpufreq_put_available_frequencies(freqs);
+	}
+
+	governors = cpufreq_get_available_governors(cpu);
+	if (governors) {
+		printf(_("  available cpufreq governors: "));
+		while (governors->next) {
+			printf("%s, ", governors->governor);
+			governors = governors->next;
+		}
+		printf("%s\n", governors->governor);
+		cpufreq_put_available_governors(governors);
+	}
+
+	policy = cpufreq_get_policy(cpu);
+	if (policy) {
+		printf(_("  current policy: frequency should be within "));
+		print_speed(policy->min);
+		printf(_(" and "));
+		print_speed(policy->max);
+
+		printf(".\n                  ");
+		printf(_("The governor \"%s\" may"
+		       " decide which speed to use\n                  within this range.\n"),
+		       policy->governor);
+		cpufreq_put_policy(policy);
+	}
+
+	if (freq_kernel || freq_hardware) {
+		printf(_("  current CPU frequency is "));
+		if (freq_hardware) {
+			print_speed(freq_hardware);
+			printf(_(" (asserted by call to hardware)"));
+		}
+		else
+			print_speed(freq_kernel);
+		printf(".\n");
+	}
+	stats = cpufreq_get_stats(cpu, &total_time);
+	if (stats) {
+		printf(_("  cpufreq stats: "));
+		while (stats) {
+			print_speed(stats->frequency);
+			printf(":%.2f%%", (100.0 * stats->time_in_state) / total_time);
+			stats = stats->next;
+			if (stats)
+				printf(", ");
+		}
+		cpufreq_put_stats(stats);
+		total_trans = cpufreq_get_transitions(cpu);
+		if (total_trans)
+			printf("  (%lu)\n", total_trans);
+		else
+			printf("\n");
+	}
+	get_boost_mode(cpu);
+
+}
+
+/* --freq / -f */
+
+static int get_freq_kernel(unsigned int cpu, unsigned int human) {
+	unsigned long freq = cpufreq_get_freq_kernel(cpu);
+	if (!freq)
+		return -EINVAL;
+	if (human) {
+		print_speed(freq);
+		printf("\n");
+	} else
+		printf("%lu\n", freq);
+	return 0;
+}
+
+
+/* --hwfreq / -w */
+
+static int get_freq_hardware(unsigned int cpu, unsigned int human) {
+	unsigned long freq = cpufreq_get_freq_hardware(cpu);
+	if (!freq)
+		return -EINVAL;
+	if (human) {
+		print_speed(freq);
+		printf("\n");
+	} else
+		printf("%lu\n", freq);
+	return 0;
+}
+
+/* --hwlimits / -l */
+
+static int get_hardware_limits(unsigned int cpu) {
+	unsigned long min, max;
+	if (cpufreq_get_hardware_limits(cpu, &min, &max))
+		return -EINVAL;
+	printf("%lu %lu\n", min, max);
+	return 0;
+}
+
+/* --driver / -d */
+
+static int get_driver(unsigned int cpu) {
+	char *driver = cpufreq_get_driver(cpu);
+	if (!driver)
+		return -EINVAL;
+	printf("%s\n", driver);
+	cpufreq_put_driver(driver);
+	return 0;
+}
+
+/* --policy / -p */
+
+static int get_policy(unsigned int cpu) {
+	struct cpufreq_policy *policy = cpufreq_get_policy(cpu);
+	if (!policy)
+		return -EINVAL;
+	printf("%lu %lu %s\n", policy->min, policy->max, policy->governor);
+	cpufreq_put_policy(policy);
+	return 0;
+}
+
+/* --governors / -g */
+
+static int get_available_governors(unsigned int cpu) {
+	struct cpufreq_available_governors *governors = cpufreq_get_available_governors(cpu);
+	if (!governors)
+		return -EINVAL;
+
+	while (governors->next) {
+		printf("%s ", governors->governor);
+		governors = governors->next;
+	}
+	printf("%s\n", governors->governor);
+	cpufreq_put_available_governors(governors);
+	return 0;
+}
+
+
+/* --affected-cpus  / -a */
+
+static int get_affected_cpus(unsigned int cpu) {
+	struct cpufreq_affected_cpus *cpus = cpufreq_get_affected_cpus(cpu);
+	if (!cpus)
+		return -EINVAL;
+
+	while (cpus->next) {
+		printf("%d ", cpus->cpu);
+		cpus = cpus->next;
+	}
+	printf("%d\n", cpus->cpu);
+	cpufreq_put_affected_cpus(cpus);
+	return 0;
+}
+
+/* --related-cpus  / -r */
+
+static int get_related_cpus(unsigned int cpu) {
+	struct cpufreq_affected_cpus *cpus = cpufreq_get_related_cpus(cpu);
+	if (!cpus)
+		return -EINVAL;
+
+	while (cpus->next) {
+		printf("%d ", cpus->cpu);
+		cpus = cpus->next;
+	}
+	printf("%d\n", cpus->cpu);
+	cpufreq_put_related_cpus(cpus);
+	return 0;
+}
+
+/* --stats / -s */
+
+static int get_freq_stats(unsigned int cpu, unsigned int human) {
+	unsigned long total_trans = cpufreq_get_transitions(cpu);
+	unsigned long long total_time;
+	struct cpufreq_stats *stats = cpufreq_get_stats(cpu, &total_time);
+	while (stats) {
+		if (human) {
+			print_speed(stats->frequency);
+			printf(":%.2f%%", (100.0 * stats->time_in_state) / total_time);
+		}
+		else
+			printf("%lu:%llu", stats->frequency, stats->time_in_state);
+		stats = stats->next;
+		if (stats)
+			printf(", ");
+	}
+	cpufreq_put_stats(stats);
+	if (total_trans)
+		printf("  (%lu)\n", total_trans);
+	return 0;
+}
+
+/* --latency / -y */
+
+static int get_latency(unsigned int cpu, unsigned int human) {
+	unsigned long latency = cpufreq_get_transition_latency(cpu);
+	if (!latency)
+		return -EINVAL;
+
+	if (human) {
+		print_duration(latency);
+		printf("\n");
+	} else
+		printf("%lu\n", latency);
+	return 0;
+}
+
+void freq_info_help(void) {
+	printf(_("Usage: cpupower freqinfo [options]\n"));
+	printf(_("Options:\n"));
+	printf(_("  -e, --debug          Prints out debug information [default]\n"));
+	printf(_("  -f, --freq           Get frequency the CPU currently runs at, according\n"
+	       "                       to the cpufreq core *\n"));
+	printf(_("  -w, --hwfreq         Get frequency the CPU currently runs at, by reading\n"
+	       "                       it from hardware (only available to root) *\n"));
+	printf(_("  -l, --hwlimits       Determine the minimum and maximum CPU frequency allowed *\n"));
+	printf(_("  -d, --driver         Determines the used cpufreq kernel driver *\n"));
+	printf(_("  -p, --policy         Gets the currently used cpufreq policy *\n"));
+	printf(_("  -g, --governors      Determines available cpufreq governors *\n"));
+	printf(_("  -r, --related-cpus   Determines which CPUs run at the same hardware frequency *\n"));
+	printf(_("  -a, --affected-cpus  Determines which CPUs need to have their frequency\n"
+			"                       coordinated by software *\n"));
+	printf(_("  -s, --stats          Shows cpufreq statistics if available\n"));
+	printf(_("  -y, --latency        Determines the maximum latency on CPU frequency changes *\n"));
+	printf(_("  -b, --boost          Checks for turbo or boost modes  *\n"));
+	printf(_("  -o, --proc           Prints out information like provided by the /proc/cpufreq\n"
+	       "                       interface in 2.4. and early 2.6. kernels\n"));
+	printf(_("  -m, --human          human-readable output for the -f, -w, -s and -y parameters\n"));
+	printf(_("  -h, --help           Prints out this screen\n"));
+
+	printf("\n");
+	printf(_("If no argument is given, full output about\n"
+	       "cpufreq is printed which is useful e.g. for reporting bugs.\n\n"));
+	printf(_("By default info of CPU 0 is shown which can be overridden \n"
+		 "with the cpupower --cpu main command option.\n"));
+}
+
+static struct option info_opts[] = {
+	{ .name="debug",	.has_arg=no_argument,		.flag=NULL,	.val='e'},
+	{ .name="boost",	.has_arg=no_argument,		.flag=NULL,	.val='b'},
+	{ .name="freq",		.has_arg=no_argument,		.flag=NULL,	.val='f'},
+	{ .name="hwfreq",	.has_arg=no_argument,		.flag=NULL,	.val='w'},
+	{ .name="hwlimits",	.has_arg=no_argument,		.flag=NULL,	.val='l'},
+	{ .name="driver",	.has_arg=no_argument,		.flag=NULL,	.val='d'},
+	{ .name="policy",	.has_arg=no_argument,		.flag=NULL,	.val='p'},
+	{ .name="governors",	.has_arg=no_argument,		.flag=NULL,	.val='g'},
+	{ .name="related-cpus", .has_arg=no_argument,		.flag=NULL,	.val='r'},
+	{ .name="affected-cpus",.has_arg=no_argument,		.flag=NULL,	.val='a'},
+	{ .name="stats",	.has_arg=no_argument,		.flag=NULL,	.val='s'},
+	{ .name="latency",	.has_arg=no_argument,		.flag=NULL,	.val='y'},
+	{ .name="proc",		.has_arg=no_argument,		.flag=NULL,	.val='o'},
+	{ .name="human",	.has_arg=no_argument,		.flag=NULL,	.val='m'},
+	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ },
+};
+
+int cmd_freq_info(int argc, char **argv)
+{
+	extern char *optarg;
+	extern int optind, opterr, optopt;
+	int ret = 0, cont = 1;
+	unsigned int cpu = 0;
+	unsigned int human = 0;
+	int output_param = 0;
+
+	do {
+		ret = getopt_long(argc, argv, "hoefwldpgrasmyb", info_opts, NULL);
+		switch (ret) {
+		case '?':
+			output_param = '?';
+			cont = 0;
+			break;
+		case 'h':
+			output_param = 'h';
+			cont = 0;
+			break;
+		case -1:
+			cont = 0;
+			break;
+		case 'b':
+		case 'o':
+		case 'a':
+		case 'r':
+		case 'g':
+		case 'p':
+		case 'd':
+		case 'l':
+		case 'w':
+		case 'f':
+		case 'e':
+		case 's':
+		case 'y':
+			if (output_param) {
+				output_param = -1;
+				cont = 0;
+				break;
+			}
+			output_param = ret;
+			break;
+		case 'm':
+			if (human) {
+				output_param = -1;
+				cont = 0;
+				break;
+			}
+			human = 1;
+			break;
+		default:
+			fprintf(stderr, "invalid or unknown argument\n");
+			return EXIT_FAILURE;
+		}
+	} while(cont);
+
+	switch (output_param) {
+	case 'o':
+		if (!bitmask_isallclear(cpus_chosen)) {
+			printf(_("The argument passed to this tool can't be "
+				 "combined with passing a --cpu argument\n"));
+			return -EINVAL;
+		}
+		break;
+	case 0:
+		output_param = 'e';
+	}
+
+	ret = 0;
+
+	/* Default is: show output of CPU 0 only */
+	if (bitmask_isallclear(cpus_chosen))
+		bitmask_setbit(cpus_chosen, 0);
+		
+	switch (output_param) {
+	case -1:
+		printf(_("You can't specify more than one --cpu parameter and/or\n"
+		       "more than one output-specific argument\n"));
+		return -EINVAL;
+	case '?':
+		printf(_("invalid or unknown argument\n"));
+		freq_info_help();
+		return -EINVAL;
+	case 'h':
+		freq_info_help();
+		return EXIT_SUCCESS;
+	case 'o':
+		proc_cpufreq_output();
+		return EXIT_SUCCESS;
+	}
+
+	for (cpu = bitmask_first(cpus_chosen);
+	     cpu <= bitmask_last(cpus_chosen); cpu++) {
+
+		if (!bitmask_isbitset(cpus_chosen, cpu))
+			continue;
+		if (cpufreq_cpu_exists(cpu)) {
+			printf(_("couldn't analyze CPU %d as it doesn't seem to be present\n"), cpu);
+			continue;
+		}
+		printf(_("analyzing CPU %d:\n"), cpu);
+
+		switch (output_param) {
+		case 'b':
+			get_boost_mode(cpu);
+			break;
+		case 'e':
+			debug_output_one(cpu);
+			break;
+		case 'a':
+			ret = get_affected_cpus(cpu);
+			break;
+		case 'r':
+			ret = get_related_cpus(cpu);
+			break;
+		case 'g':
+			ret = get_available_governors(cpu);
+			break;
+		case 'p':
+			ret = get_policy(cpu);
+			break;
+		case 'd':
+			ret = get_driver(cpu);
+			break;
+		case 'l':
+			ret = get_hardware_limits(cpu);
+			break;
+		case 'w':
+			ret = get_freq_hardware(cpu, human);
+			break;
+		case 'f':
+			ret = get_freq_kernel(cpu, human);
+			break;
+		case 's':
+			ret = get_freq_stats(cpu, human);
+			break;
+		case 'y':
+			ret = get_latency(cpu, human);
+			break;
+		}
+		if (ret)
+			return (ret);
+	}
+	return ret;
+}
