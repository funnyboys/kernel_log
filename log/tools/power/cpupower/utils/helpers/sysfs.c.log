commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 4e8fe2c7b054..e13ff38329a0 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
  *  (C) 2011       Thomas Renninger <trenn@novell.com> Novell Inc.
- *
- *  Licensed under the terms of the GNU GPL License version 2.
  */
 
 #include <stdio.h>

commit a59e5109f648f703d877d3c33cc5a7ef283dba83
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Sun Dec 14 09:06:38 2014 -0500

    tools / cpupower: Fix no idle state information return value
    
    sysfs_get_idlestate_count() returns an unsigned int.  Returning -ENODEV
    is not the right thing to do here, and in any case is handled the same
    way as if there are no states found.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 09afe5d87f2b..4e8fe2c7b054 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -361,7 +361,7 @@ unsigned int sysfs_get_idlestate_count(unsigned int cpu)
 
 	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpuidle");
 	if (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
-		return -ENODEV;
+		return 0;
 
 	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpu%u/cpuidle/state0", cpu);
 	if (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))

commit 788606cb8864765bb16be23d368725df84d0e3cc
Author: Andrey Utkin <andrey.krieger.utkin@gmail.com>
Date:   Sat Jul 19 22:14:04 2014 +0300

    PM / tools: cpupower: drop negativity check on unsigned value
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=80621
    Reported-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Andrey Utkin <andrey.krieger.utkin@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 851c7a16ca49..09afe5d87f2b 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -81,7 +81,7 @@ int sysfs_is_cpu_online(unsigned int cpu)
 	close(fd);
 
 	value = strtoull(linebuf, &endp, 0);
-	if (value > 1 || value < 0)
+	if (value > 1)
 		return -EINVAL;
 
 	return value;

commit f4a5d17efec95ee74113df62943494a2197c8bae
Author: Thomas Renninger <trenn@suse.de>
Date:   Sat Nov 16 14:39:22 2013 +0100

    tools: cpupower: fix wrong err msg not supported vs not available
    
    idlestates in sysfs are counted from 0.
    
    This fixes a wrong error message.
    Current behavior on a machine with 4 sleep states is:
    
    cpupower idle-set -e 4
    Idlestate 4 enabled on CPU 0
    
    -----Wrong---------------------
    cpupower idle-set -e 5
    Idlestate enabling not supported by kernel
    -----Must and now will be -----
    cpupower idle-set -e 5
    Idlestate 6 not available on CPU 0
    -------------------------------
    
    cpupower idle-set -e 6
    Idlestate 6 not available on CPU 0
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 5cdc600e8152..851c7a16ca49 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -278,7 +278,7 @@ static char *sysfs_idlestate_get_one_string(unsigned int cpu,
 int sysfs_is_idlestate_disabled(unsigned int cpu,
 				unsigned int idlestate)
 {
-	if (sysfs_get_idlestate_count(cpu) < idlestate)
+	if (sysfs_get_idlestate_count(cpu) <= idlestate)
 		return -1;
 
 	if (!sysfs_idlestate_file_exists(cpu, idlestate,
@@ -303,7 +303,7 @@ int sysfs_idlestate_disable(unsigned int cpu,
 	char value[SYSFS_PATH_MAX];
 	int bytes_written;
 
-	if (sysfs_get_idlestate_count(cpu) < idlestate)
+	if (sysfs_get_idlestate_count(cpu) <= idlestate)
 		return -1;
 
 	if (!sysfs_idlestate_file_exists(cpu, idlestate,

commit 0924c369bc5492cf181a066fc2d459aa18ffa5ac
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jun 28 15:34:30 2013 +0200

    cpupower: Implement disabling of cstate interface
    
    Latest kernel allows to disable C-states via:
    /sys/devices/system/cpu/cpuX/cpuidle/stateY/disable
    
    This patch provides lower level sysfs access functions to make use of
    this interface.  A later patch will implement the higher level stuff.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 891f6710d026..5cdc600e8152 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -87,8 +87,35 @@ int sysfs_is_cpu_online(unsigned int cpu)
 	return value;
 }
 
+/* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
+
+
 /* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
 
+/*
+ * helper function to check whether a file under "../cpuX/cpuidle/stateX/" dir
+ * exists.
+ * For example the functionality to disable c-states was introduced in later
+ * kernel versions, this function can be used to explicitly check for this
+ * feature.
+ *
+ * returns 1 if the file exists, 0 otherwise.
+ */
+unsigned int sysfs_idlestate_file_exists(unsigned int cpu,
+					 unsigned int idlestate,
+					 const char *fname)
+{
+	char path[SYSFS_PATH_MAX];
+	struct stat statbuf;
+
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u/cpuidle/state%u/%s",
+		 cpu, idlestate, fname);
+	if (stat(path, &statbuf) != 0)
+		return 0;
+	return 1;
+}
+
 /*
  * helper function to read file from /sys into given buffer
  * fname is a relative path under "cpuX/cpuidle/stateX/" dir
@@ -121,6 +148,40 @@ unsigned int sysfs_idlestate_read_file(unsigned int cpu, unsigned int idlestate,
 	return (unsigned int) numread;
 }
 
+/* 
+ * helper function to write a new value to a /sys file
+ * fname is a relative path under "../cpuX/cpuidle/cstateY/" dir
+ *
+ * Returns the number of bytes written or 0 on error
+ */
+static
+unsigned int sysfs_idlestate_write_file(unsigned int cpu,
+					unsigned int idlestate,
+					const char *fname,
+					const char *value, size_t len)
+{
+	char path[SYSFS_PATH_MAX];
+	int fd;
+	ssize_t numwrite;
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u/cpuidle/state%u/%s",
+		 cpu, idlestate, fname);
+
+	fd = open(path, O_WRONLY);
+	if (fd == -1)
+		return 0;
+
+	numwrite = write(fd, value, len);
+	if (numwrite < 1) {
+		close(fd);
+		return 0;
+	}
+
+	close(fd);
+
+	return (unsigned int) numwrite;
+}
+
 /* read access to files which contain one numeric value */
 
 enum idlestate_value {
@@ -128,6 +189,7 @@ enum idlestate_value {
 	IDLESTATE_POWER,
 	IDLESTATE_LATENCY,
 	IDLESTATE_TIME,
+	IDLESTATE_DISABLE,
 	MAX_IDLESTATE_VALUE_FILES
 };
 
@@ -136,6 +198,7 @@ static const char *idlestate_value_files[MAX_IDLESTATE_VALUE_FILES] = {
 	[IDLESTATE_POWER] = "power",
 	[IDLESTATE_LATENCY] = "latency",
 	[IDLESTATE_TIME]  = "time",
+	[IDLESTATE_DISABLE]  = "disable",
 };
 
 static unsigned long long sysfs_idlestate_get_one_value(unsigned int cpu,
@@ -205,8 +268,59 @@ static char *sysfs_idlestate_get_one_string(unsigned int cpu,
 	return result;
 }
 
+/*
+ * Returns:
+ *    1  if disabled
+ *    0  if enabled
+ *    -1 if idlestate is not available
+ *    -2 if disabling is not supported by the kernel
+ */
+int sysfs_is_idlestate_disabled(unsigned int cpu,
+				unsigned int idlestate)
+{
+	if (sysfs_get_idlestate_count(cpu) < idlestate)
+		return -1;
+
+	if (!sysfs_idlestate_file_exists(cpu, idlestate,
+				 idlestate_value_files[IDLESTATE_DISABLE]))
+		return -2;
+	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_DISABLE);
+}
+
+/*
+ * Pass 1 as last argument to disable or 0 to enable the state
+ * Returns:
+ *    0  on success
+ *    negative values on error, for example:
+ *      -1 if idlestate is not available
+ *      -2 if disabling is not supported by the kernel
+ *      -3 No write access to disable/enable C-states
+ */
+int sysfs_idlestate_disable(unsigned int cpu,
+			    unsigned int idlestate,
+			    unsigned int disable)
+{
+	char value[SYSFS_PATH_MAX];
+	int bytes_written;
+
+	if (sysfs_get_idlestate_count(cpu) < idlestate)
+		return -1;
+
+	if (!sysfs_idlestate_file_exists(cpu, idlestate,
+				 idlestate_value_files[IDLESTATE_DISABLE]))
+		return -2;
+
+	snprintf(value, SYSFS_PATH_MAX, "%u", disable);
+
+	bytes_written = sysfs_idlestate_write_file(cpu, idlestate, "disable",
+						   value, sizeof(disable));
+	if (bytes_written)
+		return 0;
+	return -3;
+}
+
 unsigned long sysfs_get_idlestate_latency(unsigned int cpu,
-					unsigned int idlestate)
+					  unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_LATENCY);
 }

commit f605181abd95a109031a23c67a824eb8e5dcfe67
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jun 28 15:34:29 2013 +0200

    cpupower: Make idlestate usage unsigned
    
    Use unsigned int as the data type for some variables related to CPU
    idle states which allows the code to be simplified slightly.
    
    [rjw: Changelog]
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 38ab91629463..891f6710d026 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -238,7 +238,7 @@ char *sysfs_get_idlestate_desc(unsigned int cpu, unsigned int idlestate)
  * Negativ in error case
  * Zero if cpuidle does not export any C-states
  */
-int sysfs_get_idlestate_count(unsigned int cpu)
+unsigned int sysfs_get_idlestate_count(unsigned int cpu)
 {
 	char file[SYSFS_PATH_MAX];
 	struct stat statbuf;

commit fb8eaeb7ab96b09c910e36abf7df7f9ecbb0fb60
Author: Palmer Cox <p@lmercox.com>
Date:   Tue Nov 27 13:17:44 2012 +0100

    cpupower tools: Fix minor warnings
    
    Fix minor warnings reported with GCC 4.6:
    * The sysfs_write_file function is unused - remove it.
    * The pr_mon_len in the print_header function is unsed - remove it.
    
    Signed-off-by: Palmer Cox <p@lmercox.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 96e28c124b5c..38ab91629463 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -37,25 +37,6 @@ unsigned int sysfs_read_file(const char *path, char *buf, size_t buflen)
 	return (unsigned int) numread;
 }
 
-static unsigned int sysfs_write_file(const char *path,
-				     const char *value, size_t len)
-{
-	int fd;
-	ssize_t numwrite;
-
-	fd = open(path, O_WRONLY);
-	if (fd == -1)
-		return 0;
-
-	numwrite = write(fd, value, len);
-	if (numwrite < 1) {
-		close(fd);
-		return 0;
-	}
-	close(fd);
-	return (unsigned int) numwrite;
-}
-
 /*
  * Detect whether a CPU is online
  *

commit 8e7fbcbc22c12414bcc9dfdd683637f58fb32759
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Jan 9 11:28:35 2012 +0100

    sched: Remove stale power aware scheduling remnants and dysfunctional knobs
    
    It's been broken forever (i.e. it's not scheduling in a power
    aware fashion), as reported by Suresh and others sending
    patches, and nobody cares enough to fix it properly ...
    so remove it to make space free for something better.
    
    There's various problems with the code as it stands today, first
    and foremost the user interface which is bound to topology
    levels and has multiple values per level. This results in a
    state explosion which the administrator or distro needs to
    master and almost nobody does.
    
    Furthermore large configuration state spaces aren't good, it
    means the thing doesn't just work right because it's either
    under so many impossibe to meet constraints, or even if
    there's an achievable state workloads have to be aware of
    it precisely and can never meet it for dynamic workloads.
    
    So pushing this kind of decision to user-space was a bad idea
    even with a single knob - it's exponentially worse with knobs
    on every node of the topology.
    
    There is a proposal to replace the user interface with a single
    3 state knob:
    
     sched_balance_policy := { performance, power, auto }
    
    where 'auto' would be the preferred default which looks at things
    like Battery/AC mode and possible cpufreq state or whatever the hw
    exposes to show us power use expectations - but there's been no
    progress on it in the past many months.
    
    Aside from that, the actual implementation of the various knobs
    is known to be broken. There have been sporadic attempts at
    fixing things but these always stop short of reaching a mergable
    state.
    
    Therefore this wholesale removal with the hopes of spurring
    people who care to come forward once again and work on a
    coherent replacement.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Vaidyanathan Srinivasan <svaidy@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1326104915.2442.53.camel@twins
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index c6343024a611..96e28c124b5c 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -362,22 +362,7 @@ char *sysfs_get_cpuidle_driver(void)
  */
 int sysfs_get_sched(const char *smt_mc)
 {
-	unsigned long value;
-	char linebuf[MAX_LINE_LEN];
-	char *endp;
-	char path[SYSFS_PATH_MAX];
-
-	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
-		return -EINVAL;
-
-	snprintf(path, sizeof(path),
-		PATH_TO_CPU "sched_%s_power_savings", smt_mc);
-	if (sysfs_read_file(path, linebuf, MAX_LINE_LEN) == 0)
-		return -1;
-	value = strtoul(linebuf, &endp, 0);
-	if (endp == linebuf || errno == ERANGE)
-		return -1;
-	return value;
+	return -ENODEV;
 }
 
 /*
@@ -388,21 +373,5 @@ int sysfs_get_sched(const char *smt_mc)
  */
 int sysfs_set_sched(const char *smt_mc, int val)
 {
-	char linebuf[MAX_LINE_LEN];
-	char path[SYSFS_PATH_MAX];
-	struct stat statbuf;
-
-	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
-		return -EINVAL;
-
-	snprintf(path, sizeof(path),
-		PATH_TO_CPU "sched_%s_power_savings", smt_mc);
-	sprintf(linebuf, "%d", val);
-
-	if (stat(path, &statbuf) != 0)
-		return -ENODEV;
-
-	if (sysfs_write_file(path, linebuf, MAX_LINE_LEN) == 0)
-		return -1;
-	return 0;
+	return -ENODEV;
 }

commit 7c74d2bc5a9d43d33d6f16c1e706147162e2bc52
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Aug 12 01:11:37 2011 +0200

    cpupower: Better detect offlined CPUs
    
    Before, checking for offlined CPUs was done dirty and
    it was checked whether topology parsing returned -1 values.
    But this is a valid case on a Xen (and possibly other) kernels.
    
    Do proper online/offline checking, also take CONFIG_HOTPLUG_CPU
    option into account (no /sys/devices/../cpuX/online file).
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 55e2466674c6..c6343024a611 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -56,6 +56,56 @@ static unsigned int sysfs_write_file(const char *path,
 	return (unsigned int) numwrite;
 }
 
+/*
+ * Detect whether a CPU is online
+ *
+ * Returns:
+ *     1 -> if CPU is online
+ *     0 -> if CPU is offline
+ *     negative errno values in error case
+ */
+int sysfs_is_cpu_online(unsigned int cpu)
+{
+	char path[SYSFS_PATH_MAX];
+	int fd;
+	ssize_t numread;
+	unsigned long long value;
+	char linebuf[MAX_LINE_LEN];
+	char *endp;
+	struct stat statbuf;
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u", cpu);
+
+	if (stat(path, &statbuf) != 0)
+		return 0;
+
+	/*
+	 * kernel without CONFIG_HOTPLUG_CPU
+	 * -> cpuX directory exists, but not cpuX/online file
+	 */
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u/online", cpu);
+	if (stat(path, &statbuf) != 0)
+		return 1;
+
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
+		return -errno;
+
+	numread = read(fd, linebuf, MAX_LINE_LEN - 1);
+	if (numread < 1) {
+		close(fd);
+		return -EIO;
+	}
+	linebuf[numread] = '\0';
+	close(fd);
+
+	value = strtoull(linebuf, &endp, 0);
+	if (value > 1 || value < 0)
+		return -EINVAL;
+
+	return value;
+}
+
 /* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
 
 /*

commit 2cd005cac6d586b8ca324814a9c58ed0c08ffe40
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 20:16:05 2011 +0200

    cpupowerutils: helpers - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
index 0c534e79652b..55e2466674c6 100644
--- a/tools/power/cpupower/utils/helpers/sysfs.c
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -19,14 +19,14 @@
 unsigned int sysfs_read_file(const char *path, char *buf, size_t buflen)
 {
 	int fd;
-	size_t numread;
+	ssize_t numread;
 
-	if ( ( fd = open(path, O_RDONLY) ) == -1 )
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
 		return 0;
 
 	numread = read(fd, buf, buflen - 1);
-	if ( numread < 1 )
-	{
+	if (numread < 1) {
 		close(fd);
 		return 0;
 	}
@@ -34,26 +34,26 @@ unsigned int sysfs_read_file(const char *path, char *buf, size_t buflen)
 	buf[numread] = '\0';
 	close(fd);
 
-	return numread;
+	return (unsigned int) numread;
 }
 
 static unsigned int sysfs_write_file(const char *path,
 				     const char *value, size_t len)
 {
 	int fd;
-	size_t numwrite;
+	ssize_t numwrite;
 
-	if ( ( fd = open(path, O_WRONLY) ) == -1 )
+	fd = open(path, O_WRONLY);
+	if (fd == -1)
 		return 0;
 
 	numwrite = write(fd, value, len);
-	if ( numwrite < 1 )
-	{
+	if (numwrite < 1) {
 		close(fd);
 		return 0;
 	}
 	close(fd);
-	return numwrite;
+	return (unsigned int) numwrite;
 }
 
 /* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
@@ -69,17 +69,17 @@ unsigned int sysfs_idlestate_read_file(unsigned int cpu, unsigned int idlestate,
 {
 	char path[SYSFS_PATH_MAX];
 	int fd;
-	size_t numread;
+	ssize_t numread;
 
 	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u/cpuidle/state%u/%s",
 		 cpu, idlestate, fname);
 
-	if ( ( fd = open(path, O_RDONLY) ) == -1 )
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
 		return 0;
 
 	numread = read(fd, buf, buflen - 1);
-	if ( numread < 1 )
-	{
+	if (numread < 1) {
 		close(fd);
 		return 0;
 	}
@@ -87,7 +87,7 @@ unsigned int sysfs_idlestate_read_file(unsigned int cpu, unsigned int idlestate,
 	buf[numread] = '\0';
 	close(fd);
 
-	return numread;
+	return (unsigned int) numread;
 }
 
 /* read access to files which contain one numeric value */
@@ -116,19 +116,18 @@ static unsigned long long sysfs_idlestate_get_one_value(unsigned int cpu,
 	char linebuf[MAX_LINE_LEN];
 	char *endp;
 
-	if ( which >= MAX_IDLESTATE_VALUE_FILES )
+	if (which >= MAX_IDLESTATE_VALUE_FILES)
 		return 0;
 
-	if ( ( len = sysfs_idlestate_read_file(cpu, idlestate,
-					    idlestate_value_files[which],
-					    linebuf, sizeof(linebuf))) == 0 )
-	{
+	len = sysfs_idlestate_read_file(cpu, idlestate,
+					idlestate_value_files[which],
+					linebuf, sizeof(linebuf));
+	if (len == 0)
 		return 0;
-	}
 
 	value = strtoull(linebuf, &endp, 0);
 
-	if ( endp == linebuf || errno == ERANGE )
+	if (endp == linebuf || errno == ERANGE)
 		return 0;
 
 	return value;
@@ -148,9 +147,9 @@ static const char *idlestate_string_files[MAX_IDLESTATE_STRING_FILES] = {
 };
 
 
-static char * sysfs_idlestate_get_one_string(unsigned int cpu,
-					  unsigned int idlestate,
-					  enum idlestate_string which)
+static char *sysfs_idlestate_get_one_string(unsigned int cpu,
+					unsigned int idlestate,
+					enum idlestate_string which)
 {
 	char linebuf[MAX_LINE_LEN];
 	char *result;
@@ -159,12 +158,14 @@ static char * sysfs_idlestate_get_one_string(unsigned int cpu,
 	if (which >= MAX_IDLESTATE_STRING_FILES)
 		return NULL;
 
-	if ( ( len = sysfs_idlestate_read_file(cpu, idlestate,
-					    idlestate_string_files[which],
-					    linebuf, sizeof(linebuf))) == 0 )
+	len = sysfs_idlestate_read_file(cpu, idlestate,
+					idlestate_string_files[which],
+					linebuf, sizeof(linebuf));
+	if (len == 0)
 		return NULL;
 
-	if ( ( result = strdup(linebuf) ) == NULL )
+	result = strdup(linebuf);
+	if (result == NULL)
 		return NULL;
 
 	if (result[strlen(result) - 1] == '\n')
@@ -173,27 +174,30 @@ static char * sysfs_idlestate_get_one_string(unsigned int cpu,
 	return result;
 }
 
-unsigned long sysfs_get_idlestate_latency(unsigned int cpu, unsigned int idlestate)
+unsigned long sysfs_get_idlestate_latency(unsigned int cpu,
+					unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_LATENCY);
 }
 
-unsigned long sysfs_get_idlestate_usage(unsigned int cpu, unsigned int idlestate)
+unsigned long sysfs_get_idlestate_usage(unsigned int cpu,
+					unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_USAGE);
 }
 
-unsigned long long sysfs_get_idlestate_time(unsigned int cpu, unsigned int idlestate)
+unsigned long long sysfs_get_idlestate_time(unsigned int cpu,
+					unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_TIME);
 }
 
-char * sysfs_get_idlestate_name(unsigned int cpu, unsigned int idlestate)
+char *sysfs_get_idlestate_name(unsigned int cpu, unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_NAME);
 }
 
-char * sysfs_get_idlestate_desc(unsigned int cpu, unsigned int idlestate)
+char *sysfs_get_idlestate_desc(unsigned int cpu, unsigned int idlestate)
 {
 	return sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_DESC);
 }
@@ -211,14 +215,14 @@ int sysfs_get_idlestate_count(unsigned int cpu)
 
 
 	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpuidle");
-	if ( stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
+	if (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
 		return -ENODEV;
 
 	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpu%u/cpuidle/state0", cpu);
-	if ( stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
+	if (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
 		return 0;
 
-	while(stat(file, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)) {
+	while (stat(file, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)) {
 		snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU
 			 "cpu%u/cpuidle/state%d", cpu, idlestates);
 		idlestates++;
@@ -261,7 +265,7 @@ static const char *cpuidle_string_files[MAX_CPUIDLE_STRING_FILES] = {
 };
 
 
-static char * sysfs_cpuidle_get_one_string(enum cpuidle_string which)
+static char *sysfs_cpuidle_get_one_string(enum cpuidle_string which)
 {
 	char linebuf[MAX_LINE_LEN];
 	char *result;
@@ -270,11 +274,13 @@ static char * sysfs_cpuidle_get_one_string(enum cpuidle_string which)
 	if (which >= MAX_CPUIDLE_STRING_FILES)
 		return NULL;
 
-	if ( ( len = sysfs_cpuidle_read_file(cpuidle_string_files[which],
-					    linebuf, sizeof(linebuf))) == 0 )
+	len = sysfs_cpuidle_read_file(cpuidle_string_files[which],
+				linebuf, sizeof(linebuf));
+	if (len == 0)
 		return NULL;
 
-	if ( ( result = strdup(linebuf) ) == NULL )
+	result = strdup(linebuf);
+	if (result == NULL)
 		return NULL;
 
 	if (result[strlen(result) - 1] == '\n')
@@ -283,7 +289,7 @@ static char * sysfs_cpuidle_get_one_string(enum cpuidle_string which)
 	return result;
 }
 
-char * sysfs_get_cpuidle_governor(void)
+char *sysfs_get_cpuidle_governor(void)
 {
 	char *tmp = sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR_RO);
 	if (!tmp)
@@ -292,7 +298,7 @@ char * sysfs_get_cpuidle_governor(void)
 		return tmp;
 }
 
-char * sysfs_get_cpuidle_driver(void)
+char *sysfs_get_cpuidle_driver(void)
 {
 	return sysfs_cpuidle_get_one_string(CPUIDLE_DRIVER);
 }
@@ -304,9 +310,9 @@ char * sysfs_get_cpuidle_driver(void)
  *
  * Returns negative value on failure
  */
-int sysfs_get_sched(const char* smt_mc)
+int sysfs_get_sched(const char *smt_mc)
 {
- 	unsigned long value;
+	unsigned long value;
 	char linebuf[MAX_LINE_LEN];
 	char *endp;
 	char path[SYSFS_PATH_MAX];
@@ -314,11 +320,12 @@ int sysfs_get_sched(const char* smt_mc)
 	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
 		return -EINVAL;
 
-	snprintf(path, sizeof(path), PATH_TO_CPU "sched_%s_power_savings", smt_mc);
-	if (sysfs_read_file(path, linebuf, MAX_LINE_LEN) == 0 )
+	snprintf(path, sizeof(path),
+		PATH_TO_CPU "sched_%s_power_savings", smt_mc);
+	if (sysfs_read_file(path, linebuf, MAX_LINE_LEN) == 0)
 		return -1;
 	value = strtoul(linebuf, &endp, 0);
-	if ( endp == linebuf || errno == ERANGE )
+	if (endp == linebuf || errno == ERANGE)
 		return -1;
 	return value;
 }
@@ -329,7 +336,7 @@ int sysfs_get_sched(const char* smt_mc)
  *
  * Returns negative value on failure
  */
-int sysfs_set_sched(const char* smt_mc, int val)
+int sysfs_set_sched(const char *smt_mc, int val)
 {
 	char linebuf[MAX_LINE_LEN];
 	char path[SYSFS_PATH_MAX];
@@ -338,13 +345,14 @@ int sysfs_set_sched(const char* smt_mc, int val)
 	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
 		return -EINVAL;
 
-	snprintf(path, sizeof(path), PATH_TO_CPU "sched_%s_power_savings", smt_mc);
+	snprintf(path, sizeof(path),
+		PATH_TO_CPU "sched_%s_power_savings", smt_mc);
 	sprintf(linebuf, "%d", val);
 
-	if ( stat(path, &statbuf) != 0 )
+	if (stat(path, &statbuf) != 0)
 		return -ENODEV;
 
-	if (sysfs_write_file(path, linebuf, MAX_LINE_LEN) == 0 )
+	if (sysfs_write_file(path, linebuf, MAX_LINE_LEN) == 0)
 		return -1;
 	return 0;
 }

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/helpers/sysfs.c b/tools/power/cpupower/utils/helpers/sysfs.c
new file mode 100644
index 000000000000..0c534e79652b
--- /dev/null
+++ b/tools/power/cpupower/utils/helpers/sysfs.c
@@ -0,0 +1,350 @@
+/*
+ *  (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
+ *  (C) 2011       Thomas Renninger <trenn@novell.com> Novell Inc.
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "helpers/sysfs.h"
+
+unsigned int sysfs_read_file(const char *path, char *buf, size_t buflen)
+{
+	int fd;
+	size_t numread;
+
+	if ( ( fd = open(path, O_RDONLY) ) == -1 )
+		return 0;
+
+	numread = read(fd, buf, buflen - 1);
+	if ( numread < 1 )
+	{
+		close(fd);
+		return 0;
+	}
+
+	buf[numread] = '\0';
+	close(fd);
+
+	return numread;
+}
+
+static unsigned int sysfs_write_file(const char *path,
+				     const char *value, size_t len)
+{
+	int fd;
+	size_t numwrite;
+
+	if ( ( fd = open(path, O_WRONLY) ) == -1 )
+		return 0;
+
+	numwrite = write(fd, value, len);
+	if ( numwrite < 1 )
+	{
+		close(fd);
+		return 0;
+	}
+	close(fd);
+	return numwrite;
+}
+
+/* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
+
+/*
+ * helper function to read file from /sys into given buffer
+ * fname is a relative path under "cpuX/cpuidle/stateX/" dir
+ * cstates starting with 0, C0 is not counted as cstate.
+ * This means if you want C1 info, pass 0 as idlestate param
+ */
+unsigned int sysfs_idlestate_read_file(unsigned int cpu, unsigned int idlestate,
+			     const char *fname, char *buf, size_t buflen)
+{
+	char path[SYSFS_PATH_MAX];
+	int fd;
+	size_t numread;
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpu%u/cpuidle/state%u/%s",
+		 cpu, idlestate, fname);
+
+	if ( ( fd = open(path, O_RDONLY) ) == -1 )
+		return 0;
+
+	numread = read(fd, buf, buflen - 1);
+	if ( numread < 1 )
+	{
+		close(fd);
+		return 0;
+	}
+
+	buf[numread] = '\0';
+	close(fd);
+
+	return numread;
+}
+
+/* read access to files which contain one numeric value */
+
+enum idlestate_value {
+	IDLESTATE_USAGE,
+	IDLESTATE_POWER,
+	IDLESTATE_LATENCY,
+	IDLESTATE_TIME,
+	MAX_IDLESTATE_VALUE_FILES
+};
+
+static const char *idlestate_value_files[MAX_IDLESTATE_VALUE_FILES] = {
+	[IDLESTATE_USAGE] = "usage",
+	[IDLESTATE_POWER] = "power",
+	[IDLESTATE_LATENCY] = "latency",
+	[IDLESTATE_TIME]  = "time",
+};
+
+static unsigned long long sysfs_idlestate_get_one_value(unsigned int cpu,
+						     unsigned int idlestate,
+						     enum idlestate_value which)
+{
+	unsigned long long value;
+	unsigned int len;
+	char linebuf[MAX_LINE_LEN];
+	char *endp;
+
+	if ( which >= MAX_IDLESTATE_VALUE_FILES )
+		return 0;
+
+	if ( ( len = sysfs_idlestate_read_file(cpu, idlestate,
+					    idlestate_value_files[which],
+					    linebuf, sizeof(linebuf))) == 0 )
+	{
+		return 0;
+	}
+
+	value = strtoull(linebuf, &endp, 0);
+
+	if ( endp == linebuf || errno == ERANGE )
+		return 0;
+
+	return value;
+}
+
+/* read access to files which contain one string */
+
+enum idlestate_string {
+	IDLESTATE_DESC,
+	IDLESTATE_NAME,
+	MAX_IDLESTATE_STRING_FILES
+};
+
+static const char *idlestate_string_files[MAX_IDLESTATE_STRING_FILES] = {
+	[IDLESTATE_DESC] = "desc",
+	[IDLESTATE_NAME] = "name",
+};
+
+
+static char * sysfs_idlestate_get_one_string(unsigned int cpu,
+					  unsigned int idlestate,
+					  enum idlestate_string which)
+{
+	char linebuf[MAX_LINE_LEN];
+	char *result;
+	unsigned int len;
+
+	if (which >= MAX_IDLESTATE_STRING_FILES)
+		return NULL;
+
+	if ( ( len = sysfs_idlestate_read_file(cpu, idlestate,
+					    idlestate_string_files[which],
+					    linebuf, sizeof(linebuf))) == 0 )
+		return NULL;
+
+	if ( ( result = strdup(linebuf) ) == NULL )
+		return NULL;
+
+	if (result[strlen(result) - 1] == '\n')
+		result[strlen(result) - 1] = '\0';
+
+	return result;
+}
+
+unsigned long sysfs_get_idlestate_latency(unsigned int cpu, unsigned int idlestate)
+{
+	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_LATENCY);
+}
+
+unsigned long sysfs_get_idlestate_usage(unsigned int cpu, unsigned int idlestate)
+{
+	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_USAGE);
+}
+
+unsigned long long sysfs_get_idlestate_time(unsigned int cpu, unsigned int idlestate)
+{
+	return sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_TIME);
+}
+
+char * sysfs_get_idlestate_name(unsigned int cpu, unsigned int idlestate)
+{
+	return sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_NAME);
+}
+
+char * sysfs_get_idlestate_desc(unsigned int cpu, unsigned int idlestate)
+{
+	return sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_DESC);
+}
+
+/*
+ * Returns number of supported C-states of CPU core cpu
+ * Negativ in error case
+ * Zero if cpuidle does not export any C-states
+ */
+int sysfs_get_idlestate_count(unsigned int cpu)
+{
+	char file[SYSFS_PATH_MAX];
+	struct stat statbuf;
+	int idlestates = 1;
+
+
+	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpuidle");
+	if ( stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
+		return -ENODEV;
+
+	snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU "cpu%u/cpuidle/state0", cpu);
+	if ( stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
+		return 0;
+
+	while(stat(file, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)) {
+		snprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU
+			 "cpu%u/cpuidle/state%d", cpu, idlestates);
+		idlestates++;
+	}
+	idlestates--;
+	return idlestates;
+}
+
+/* CPUidle general /sys/devices/system/cpu/cpuidle/ sysfs access ********/
+
+/*
+ * helper function to read file from /sys into given buffer
+ * fname is a relative path under "cpu/cpuidle/" dir
+ */
+static unsigned int sysfs_cpuidle_read_file(const char *fname, char *buf,
+					    size_t buflen)
+{
+	char path[SYSFS_PATH_MAX];
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "cpuidle/%s", fname);
+
+	return sysfs_read_file(path, buf, buflen);
+}
+
+
+
+/* read access to files which contain one string */
+
+enum cpuidle_string {
+	CPUIDLE_GOVERNOR,
+	CPUIDLE_GOVERNOR_RO,
+	CPUIDLE_DRIVER,
+	MAX_CPUIDLE_STRING_FILES
+};
+
+static const char *cpuidle_string_files[MAX_CPUIDLE_STRING_FILES] = {
+	[CPUIDLE_GOVERNOR]	= "current_governor",
+	[CPUIDLE_GOVERNOR_RO]	= "current_governor_ro",
+	[CPUIDLE_DRIVER]	= "current_driver",
+};
+
+
+static char * sysfs_cpuidle_get_one_string(enum cpuidle_string which)
+{
+	char linebuf[MAX_LINE_LEN];
+	char *result;
+	unsigned int len;
+
+	if (which >= MAX_CPUIDLE_STRING_FILES)
+		return NULL;
+
+	if ( ( len = sysfs_cpuidle_read_file(cpuidle_string_files[which],
+					    linebuf, sizeof(linebuf))) == 0 )
+		return NULL;
+
+	if ( ( result = strdup(linebuf) ) == NULL )
+		return NULL;
+
+	if (result[strlen(result) - 1] == '\n')
+		result[strlen(result) - 1] = '\0';
+
+	return result;
+}
+
+char * sysfs_get_cpuidle_governor(void)
+{
+	char *tmp = sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR_RO);
+	if (!tmp)
+		return sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR);
+	else
+		return tmp;
+}
+
+char * sysfs_get_cpuidle_driver(void)
+{
+	return sysfs_cpuidle_get_one_string(CPUIDLE_DRIVER);
+}
+/* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */
+
+/*
+ * Get sched_mc or sched_smt settings
+ * Pass "mc" or "smt" as argument
+ *
+ * Returns negative value on failure
+ */
+int sysfs_get_sched(const char* smt_mc)
+{
+ 	unsigned long value;
+	char linebuf[MAX_LINE_LEN];
+	char *endp;
+	char path[SYSFS_PATH_MAX];
+
+	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
+		return -EINVAL;
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "sched_%s_power_savings", smt_mc);
+	if (sysfs_read_file(path, linebuf, MAX_LINE_LEN) == 0 )
+		return -1;
+	value = strtoul(linebuf, &endp, 0);
+	if ( endp == linebuf || errno == ERANGE )
+		return -1;
+	return value;
+}
+
+/*
+ * Get sched_mc or sched_smt settings
+ * Pass "mc" or "smt" as argument
+ *
+ * Returns negative value on failure
+ */
+int sysfs_set_sched(const char* smt_mc, int val)
+{
+	char linebuf[MAX_LINE_LEN];
+	char path[SYSFS_PATH_MAX];
+	struct stat statbuf;
+
+	if (strcmp("mc", smt_mc) && strcmp("smt", smt_mc))
+		return -EINVAL;
+
+	snprintf(path, sizeof(path), PATH_TO_CPU "sched_%s_power_savings", smt_mc);
+	sprintf(linebuf, "%d", val);
+
+	if ( stat(path, &statbuf) != 0 )
+		return -ENODEV;
+
+	if (sysfs_write_file(path, linebuf, MAX_LINE_LEN) == 0 )
+		return -1;
+	return 0;
+}
