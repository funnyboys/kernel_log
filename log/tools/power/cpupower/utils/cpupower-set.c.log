commit 7b0bf99b9ee497cc0f079472566aff716d033d43
Author: Zou Wei <zou_wei@huawei.com>
Date:   Tue Apr 28 17:43:15 2020 +0800

    cpupower: Remove unneeded semicolon
    
    Fixes coccicheck warnings:
    
    tools/power/cpupower/utils/cpupower-info.c:65:2-3: Unneeded semicolon
    tools/power/cpupower/utils/cpupower-set.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c:120:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:175:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:56:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c:75:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/hsw_ext_idle.c:82:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/nhm_idle.c:94:2-3: Unneeded semicolon
    tools/power/cpupower/utils/idle_monitor/snb_idle.c:80:2-3: Unneeded semicolon
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zou Wei <zou_wei@huawei.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 3cca6f715dd9..052044d7e012 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -72,7 +72,7 @@ int cmd_set(int argc, char **argv)
 		default:
 			print_wrong_arg_exit();
 		}
-	};
+	}
 
 	if (!params.params)
 		print_wrong_arg_exit();

commit d80a4ac20800035c46a3868ad9e11ebda0049c7d
Author: Abhishek Goel <huntbag@linux.vnet.ibm.com>
Date:   Thu Oct 17 00:56:39 2019 -0500

    cpupower : Handle set and info subcommands correctly
    
    Cpupower tool has set and info options which are being used only by
    x86 machines. This patch removes support for these two subcommands
    from cpupower utility for POWER. Thus, these two subcommands will now be
    available only for intel.
    This removes the ambiguous error message while using set option in case
    of using non-intel systems.
    
    Without this patch on a POWER system:
    
    root@ubuntu:~# cpupower info
    System does not support Intel's performance bias setting
    
    root@ubuntu:~# cpupower set -b 10
    Error setting perf-bias value on CPU
    
    With this patch on a POWER box:
    
    root@ubuntu:~# cpupower info
    Subcommand not supported on POWER
    
    Same result for set subcommand.
    This patch does not affect results on a intel box.
    
    Signed-off-by: Abhishek Goel <huntbag@linux.vnet.ibm.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Reviewed-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 3cd95c6cb974..3cca6f715dd9 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <string.h>
 #include <getopt.h>
+#include <sys/utsname.h>
 
 #include "helpers/helpers.h"
 #include "helpers/sysfs.h"
@@ -31,6 +32,7 @@ int cmd_set(int argc, char **argv)
 	extern char *optarg;
 	extern int optind, opterr, optopt;
 	unsigned int cpu;
+	struct utsname uts;
 
 	union {
 		struct {
@@ -41,6 +43,13 @@ int cmd_set(int argc, char **argv)
 	int perf_bias = 0;
 	int ret = 0;
 
+	ret = uname(&uts);
+	if (!ret && (!strcmp(uts.machine, "ppc64le") ||
+		     !strcmp(uts.machine, "ppc64"))) {
+		fprintf(stderr, _("Subcommand not supported on POWER.\n"));
+		return ret;
+	}
+
 	setlocale(LC_ALL, "");
 	textdomain(PACKAGE);
 

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 532f46b9a335..3cd95c6cb974 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -1,7 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  (C) 2011 Thomas Renninger <trenn@suse.de>, Novell Inc.
- *
- *  Licensed under the terms of the GNU GPL License version 2.
  */
 
 

commit ce512b84045459f4a6c119a109c950c6bc4a6f3a
Author: Thomas Renninger <trenn@suse.com>
Date:   Tue Dec 1 17:14:15 2015 +0100

    cpupower: Do not analyse offlined cpus
    
    Use sysfs_is_cpu_online(cpu) instead of cpufreq_cpu_exists(cpu) to detect offlined cpus.
    
    Re-arrange printfs slightly to have a consistent output even if you have multiple CPUs
    as output and even if offlined cores are in between.
    
    Signed-off-by: Thomas Renninger <trenn@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 3e6f374f8dd7..532f46b9a335 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -12,7 +12,6 @@
 #include <string.h>
 #include <getopt.h>
 
-#include <cpufreq.h>
 #include "helpers/helpers.h"
 #include "helpers/sysfs.h"
 #include "helpers/bitmask.h"
@@ -78,10 +77,15 @@ int cmd_set(int argc, char **argv)
 	for (cpu = bitmask_first(cpus_chosen);
 	     cpu <= bitmask_last(cpus_chosen); cpu++) {
 
-		if (!bitmask_isbitset(cpus_chosen, cpu) ||
-		    cpufreq_cpu_exists(cpu))
+		if (!bitmask_isbitset(cpus_chosen, cpu))
 			continue;
 
+		if (sysfs_is_cpu_online(cpu) != 1){
+			fprintf(stderr, _("Cannot set values on CPU %d:"), cpu);
+			fprintf(stderr, _(" *is offline\n"));
+			continue;
+		}
+
 		if (params.perf_bias) {
 			ret = msr_intel_set_perf_bias(cpu, perf_bias);
 			if (ret) {

commit 57ab3b08725163bfe385aaeea6837f9b1213af3d
Author: Sriram Raghunathan <sriram@marirs.net.in>
Date:   Fri Oct 23 09:52:45 2015 +0200

    Creating a common structure initialization pattern for struct option
    
    This patch tries to creates a common structure initialization
    within the cpupower tool.
    
    Previously the ``struct option`` was initialized
    using `designated initializer` technique which was
    not needed. There were conflicting initialization methods seen with
    
    bench/main.c & others.
    
    Signed-off-by: Sriram Raghunathan <sriram@marirs.net.in>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 573c75f8e3f5..3e6f374f8dd7 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -18,7 +18,7 @@
 #include "helpers/bitmask.h"
 
 static struct option set_opts[] = {
-	{ .name = "perf-bias",	.has_arg = required_argument,	.flag = NULL,	.val = 'b'},
+	{"perf-bias", required_argument, NULL, 'b'},
 	{ },
 };
 

commit 7ea1bdb8e162ef7b90eef2450e9a2eaefeb58d61
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue May 13 12:41:45 2014 +0200

    cpupower: Remove mc and smt power aware scheduler info/settings
    
    These kernel interfaces got removed by:
    
    commit 8e7fbcbc22c12414bcc9dfdd683637f58fb32759
    Author: Peter Zijlstra <peterz@infradead.org>
    Date:   Mon Jan 9 11:28:35 2012 +0100
    
        sched: Remove stale power aware scheduling remnants and dysfunctional knobs
    
    No need to further keep them as userspace configurations.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index bcf1d2f0b791..573c75f8e3f5 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -19,8 +19,6 @@
 
 static struct option set_opts[] = {
 	{ .name = "perf-bias",	.has_arg = required_argument,	.flag = NULL,	.val = 'b'},
-	{ .name = "sched-mc",	.has_arg = required_argument,	.flag = NULL,	.val = 'm'},
-	{ .name = "sched-smt",	.has_arg = required_argument,	.flag = NULL,	.val = 's'},
 	{ },
 };
 
@@ -38,13 +36,11 @@ int cmd_set(int argc, char **argv)
 
 	union {
 		struct {
-			int sched_mc:1;
-			int sched_smt:1;
 			int perf_bias:1;
 		};
 		int params;
 	} params;
-	int sched_mc = 0, sched_smt = 0, perf_bias = 0;
+	int perf_bias = 0;
 	int ret = 0;
 
 	setlocale(LC_ALL, "");
@@ -52,7 +48,7 @@ int cmd_set(int argc, char **argv)
 
 	params.params = 0;
 	/* parameter parsing */
-	while ((ret = getopt_long(argc, argv, "m:s:b:",
+	while ((ret = getopt_long(argc, argv, "b:",
 						set_opts, NULL)) != -1) {
 		switch (ret) {
 		case 'b':
@@ -66,28 +62,6 @@ int cmd_set(int argc, char **argv)
 			}
 			params.perf_bias = 1;
 			break;
-		case 'm':
-			if (params.sched_mc)
-				print_wrong_arg_exit();
-			sched_mc = atoi(optarg);
-			if (sched_mc < 0 || sched_mc > 2) {
-				printf(_("--sched-mc param out "
-					 "of range [0-%d]\n"), 2);
-				print_wrong_arg_exit();
-			}
-			params.sched_mc = 1;
-			break;
-		case 's':
-			if (params.sched_smt)
-				print_wrong_arg_exit();
-			sched_smt = atoi(optarg);
-			if (sched_smt < 0 || sched_smt > 2) {
-				printf(_("--sched-smt param out "
-					 "of range [0-%d]\n"), 2);
-				print_wrong_arg_exit();
-			}
-			params.sched_smt = 1;
-			break;
 		default:
 			print_wrong_arg_exit();
 		}
@@ -96,19 +70,6 @@ int cmd_set(int argc, char **argv)
 	if (!params.params)
 		print_wrong_arg_exit();
 
-	if (params.sched_mc) {
-		ret = sysfs_set_sched("mc", sched_mc);
-		if (ret)
-			fprintf(stderr, _("Error setting sched-mc %s\n"),
-				(ret == -ENODEV) ? "not supported" : "");
-	}
-	if (params.sched_smt) {
-		ret = sysfs_set_sched("smt", sched_smt);
-		if (ret)
-			fprintf(stderr, _("Error setting sched-smt %s\n"),
-				(ret == -ENODEV) ? "not supported" : "");
-	}
-
 	/* Default is: set all CPUs */
 	if (bitmask_isallclear(cpus_chosen))
 		bitmask_setall(cpus_chosen);

commit f447ef4a56dee4b68a91460bcdfe06b5011085f2
Author: Josh Boyer <jwboyer@redhat.com>
Date:   Fri Oct 11 08:45:51 2013 -0400

    cpupower: Fix segfault due to incorrect getopt_long arugments
    
    If a user calls 'cpupower set --perf-bias 15', the process will end with
    a SIGSEGV in libc because cpupower-set passes a NULL optarg to the atoi
    call.  This is because the getopt_long structure currently has all of
    the options as having an optional_argument when they really have a
    required argument.  We change the structure to use required_argument to
    match the short options and it resolves the issue.
    
    This fixes https://bugzilla.redhat.com/show_bug.cgi?id=1000439
    
    Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index dc4de3762111..bcf1d2f0b791 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -18,9 +18,9 @@
 #include "helpers/bitmask.h"
 
 static struct option set_opts[] = {
-	{ .name = "perf-bias",	.has_arg = optional_argument,	.flag = NULL,	.val = 'b'},
-	{ .name = "sched-mc",	.has_arg = optional_argument,	.flag = NULL,	.val = 'm'},
-	{ .name = "sched-smt",	.has_arg = optional_argument,	.flag = NULL,	.val = 's'},
+	{ .name = "perf-bias",	.has_arg = required_argument,	.flag = NULL,	.val = 'b'},
+	{ .name = "sched-mc",	.has_arg = required_argument,	.flag = NULL,	.val = 'm'},
+	{ .name = "sched-smt",	.has_arg = required_argument,	.flag = NULL,	.val = 's'},
 	{ },
 };
 

commit 498ca793d90aef8ad38a852a969c257f62832738
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 6 18:11:43 2011 +0200

    cpupower: use man(1) when calling "cpupower help subcommand"
    
    Instead of printing something non-formatted to stdout, call
    man(1) to show the man page for the proper subcommand.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index bc1b391e46f0..dc4de3762111 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -17,30 +17,16 @@
 #include "helpers/sysfs.h"
 #include "helpers/bitmask.h"
 
-void set_help(void)
-{
-	printf(_("Usage: cpupower set [ -b val ] [ -m val ] [ -s val ]\n"));
-	printf(_("Options:\n"));
-	printf(_("  -b, --perf-bias [VAL]    Sets CPU's power vs performance policy on some\n"
-	       "                           Intel models [0-15], see manpage for details\n"));
-	printf(_("  -m, --sched-mc  [VAL]    Sets the kernel's multi core scheduler policy.\n"));
-	printf(_("  -s, --sched-smt [VAL]    Sets the kernel's thread sibling scheduler policy.\n"));
-	printf(_("  -h, --help               Prints out this screen\n"));
-	printf("\n");
-}
-
 static struct option set_opts[] = {
 	{ .name = "perf-bias",	.has_arg = optional_argument,	.flag = NULL,	.val = 'b'},
 	{ .name = "sched-mc",	.has_arg = optional_argument,	.flag = NULL,	.val = 'm'},
 	{ .name = "sched-smt",	.has_arg = optional_argument,	.flag = NULL,	.val = 's'},
-	{ .name = "help",	.has_arg = no_argument,		.flag = NULL,	.val = 'h'},
 	{ },
 };
 
 static void print_wrong_arg_exit(void)
 {
 	printf(_("invalid or unknown argument\n"));
-	set_help();
 	exit(EXIT_FAILURE);
 }
 
@@ -66,12 +52,9 @@ int cmd_set(int argc, char **argv)
 
 	params.params = 0;
 	/* parameter parsing */
-	while ((ret = getopt_long(argc, argv, "m:s:b:h",
+	while ((ret = getopt_long(argc, argv, "m:s:b:",
 						set_opts, NULL)) != -1) {
 		switch (ret) {
-		case 'h':
-			set_help();
-			return 0;
 		case 'b':
 			if (params.perf_bias)
 				print_wrong_arg_exit();
@@ -110,10 +93,8 @@ int cmd_set(int argc, char **argv)
 		}
 	};
 
-	if (!params.params) {
-		set_help();
-		return -EINVAL;
-	}
+	if (!params.params)
+		print_wrong_arg_exit();
 
 	if (params.sched_mc) {
 		ret = sysfs_set_sched("mc", sched_mc);

commit a1ce5ba2b7d08ab6347dc254f86f70e91c5f1a44
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Apr 19 20:33:50 2011 +0200

    cpupowerutils: utils - ConfigStyle bugfixes
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
index 3f807bc7a567..bc1b391e46f0 100644
--- a/tools/power/cpupower/utils/cpupower-set.c
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -30,10 +30,10 @@ void set_help(void)
 }
 
 static struct option set_opts[] = {
-	{ .name="perf-bias",	.has_arg=optional_argument,	.flag=NULL,	.val='b'},
-	{ .name="sched-mc",	.has_arg=optional_argument,	.flag=NULL,	.val='m'},
-	{ .name="sched-smt",	.has_arg=optional_argument,	.flag=NULL,	.val='s'},
-	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ .name = "perf-bias",	.has_arg = optional_argument,	.flag = NULL,	.val = 'b'},
+	{ .name = "sched-mc",	.has_arg = optional_argument,	.flag = NULL,	.val = 'm'},
+	{ .name = "sched-smt",	.has_arg = optional_argument,	.flag = NULL,	.val = 's'},
+	{ .name = "help",	.has_arg = no_argument,		.flag = NULL,	.val = 'h'},
 	{ },
 };
 
@@ -57,17 +57,17 @@ int cmd_set(int argc, char **argv)
 			int perf_bias:1;
 		};
 		int params;
-			
 	} params;
 	int sched_mc = 0, sched_smt = 0, perf_bias = 0;
 	int ret = 0;
 
 	setlocale(LC_ALL, "");
-	textdomain (PACKAGE);
+	textdomain(PACKAGE);
 
 	params.params = 0;
 	/* parameter parsing */
-	while ((ret = getopt_long(argc, argv, "m:s:b:h", set_opts, NULL)) != -1) {
+	while ((ret = getopt_long(argc, argv, "m:s:b:h",
+						set_opts, NULL)) != -1) {
 		switch (ret) {
 		case 'h':
 			set_help();
@@ -135,7 +135,7 @@ int cmd_set(int argc, char **argv)
 	/* loop over CPUs */
 	for (cpu = bitmask_first(cpus_chosen);
 	     cpu <= bitmask_last(cpus_chosen); cpu++) {
-		
+
 		if (!bitmask_isbitset(cpus_chosen, cpu) ||
 		    cpufreq_cpu_exists(cpu))
 			continue;

commit 7fe2f6399a84760a9af8896ac152728250f82adb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Mar 30 16:30:11 2011 +0200

    cpupowerutils - cpufrequtils extended with quite some features
    
    CPU power consumption vs performance tuning is no longer
    limited to CPU frequency switching anymore: deep sleep states,
    traditional dynamic frequency scaling and hidden turbo/boost
    frequencies are tied close together and depend on each other.
    The first two exist on different architectures like PPC, Itanium and
    ARM, the latter (so far) only on X86. On X86 the APU (CPU+GPU) will
    only run most efficiently if CPU and GPU has proper power management
    in place.
    
    Users and Developers want to have *one* tool to get an overview what
    their system supports and to monitor and debug CPU power management
    in detail. The tool should compile and work on as many architectures
    as possible.
    
    Once this tool stabilizes a bit, it is intended to replace the
    Intel-specific tools in tools/power/x86
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/tools/power/cpupower/utils/cpupower-set.c b/tools/power/cpupower/utils/cpupower-set.c
new file mode 100644
index 000000000000..3f807bc7a567
--- /dev/null
+++ b/tools/power/cpupower/utils/cpupower-set.c
@@ -0,0 +1,153 @@
+/*
+ *  (C) 2011 Thomas Renninger <trenn@suse.de>, Novell Inc.
+ *
+ *  Licensed under the terms of the GNU GPL License version 2.
+ */
+
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <getopt.h>
+
+#include <cpufreq.h>
+#include "helpers/helpers.h"
+#include "helpers/sysfs.h"
+#include "helpers/bitmask.h"
+
+void set_help(void)
+{
+	printf(_("Usage: cpupower set [ -b val ] [ -m val ] [ -s val ]\n"));
+	printf(_("Options:\n"));
+	printf(_("  -b, --perf-bias [VAL]    Sets CPU's power vs performance policy on some\n"
+	       "                           Intel models [0-15], see manpage for details\n"));
+	printf(_("  -m, --sched-mc  [VAL]    Sets the kernel's multi core scheduler policy.\n"));
+	printf(_("  -s, --sched-smt [VAL]    Sets the kernel's thread sibling scheduler policy.\n"));
+	printf(_("  -h, --help               Prints out this screen\n"));
+	printf("\n");
+}
+
+static struct option set_opts[] = {
+	{ .name="perf-bias",	.has_arg=optional_argument,	.flag=NULL,	.val='b'},
+	{ .name="sched-mc",	.has_arg=optional_argument,	.flag=NULL,	.val='m'},
+	{ .name="sched-smt",	.has_arg=optional_argument,	.flag=NULL,	.val='s'},
+	{ .name="help",		.has_arg=no_argument,		.flag=NULL,	.val='h'},
+	{ },
+};
+
+static void print_wrong_arg_exit(void)
+{
+	printf(_("invalid or unknown argument\n"));
+	set_help();
+	exit(EXIT_FAILURE);
+}
+
+int cmd_set(int argc, char **argv)
+{
+	extern char *optarg;
+	extern int optind, opterr, optopt;
+	unsigned int cpu;
+
+	union {
+		struct {
+			int sched_mc:1;
+			int sched_smt:1;
+			int perf_bias:1;
+		};
+		int params;
+			
+	} params;
+	int sched_mc = 0, sched_smt = 0, perf_bias = 0;
+	int ret = 0;
+
+	setlocale(LC_ALL, "");
+	textdomain (PACKAGE);
+
+	params.params = 0;
+	/* parameter parsing */
+	while ((ret = getopt_long(argc, argv, "m:s:b:h", set_opts, NULL)) != -1) {
+		switch (ret) {
+		case 'h':
+			set_help();
+			return 0;
+		case 'b':
+			if (params.perf_bias)
+				print_wrong_arg_exit();
+			perf_bias = atoi(optarg);
+			if (perf_bias < 0 || perf_bias > 15) {
+				printf(_("--perf-bias param out "
+					 "of range [0-%d]\n"), 15);
+				print_wrong_arg_exit();
+			}
+			params.perf_bias = 1;
+			break;
+		case 'm':
+			if (params.sched_mc)
+				print_wrong_arg_exit();
+			sched_mc = atoi(optarg);
+			if (sched_mc < 0 || sched_mc > 2) {
+				printf(_("--sched-mc param out "
+					 "of range [0-%d]\n"), 2);
+				print_wrong_arg_exit();
+			}
+			params.sched_mc = 1;
+			break;
+		case 's':
+			if (params.sched_smt)
+				print_wrong_arg_exit();
+			sched_smt = atoi(optarg);
+			if (sched_smt < 0 || sched_smt > 2) {
+				printf(_("--sched-smt param out "
+					 "of range [0-%d]\n"), 2);
+				print_wrong_arg_exit();
+			}
+			params.sched_smt = 1;
+			break;
+		default:
+			print_wrong_arg_exit();
+		}
+	};
+
+	if (!params.params) {
+		set_help();
+		return -EINVAL;
+	}
+
+	if (params.sched_mc) {
+		ret = sysfs_set_sched("mc", sched_mc);
+		if (ret)
+			fprintf(stderr, _("Error setting sched-mc %s\n"),
+				(ret == -ENODEV) ? "not supported" : "");
+	}
+	if (params.sched_smt) {
+		ret = sysfs_set_sched("smt", sched_smt);
+		if (ret)
+			fprintf(stderr, _("Error setting sched-smt %s\n"),
+				(ret == -ENODEV) ? "not supported" : "");
+	}
+
+	/* Default is: set all CPUs */
+	if (bitmask_isallclear(cpus_chosen))
+		bitmask_setall(cpus_chosen);
+
+	/* loop over CPUs */
+	for (cpu = bitmask_first(cpus_chosen);
+	     cpu <= bitmask_last(cpus_chosen); cpu++) {
+		
+		if (!bitmask_isbitset(cpus_chosen, cpu) ||
+		    cpufreq_cpu_exists(cpu))
+			continue;
+
+		if (params.perf_bias) {
+			ret = msr_intel_set_perf_bias(cpu, perf_bias);
+			if (ret) {
+				fprintf(stderr, _("Error setting perf-bias "
+						  "value on CPU %d\n"), cpu);
+				break;
+			}
+		}
+	}
+	return ret;
+}
