commit e78fded4ca016a35e580595d08b3e149e174e120
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Mar 20 17:17:15 2020 -0700

    tools/power/x86/intel-speed-select: Change debug to error
    
    When turbo-freq is enabled, we can't disable core-power. Currently
    it prints debug message to warn. Change this to error message.
    
    While here remove "\n" from calls to isst_display_error_info_message(),
    as it will be added again during actual print.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 67c9b1139631..a7f4337c5777 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -912,16 +912,16 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 			return ret;
 
 		if (ctdp_level.fact_enabled) {
-			debug_printf("Turbo-freq feature must be disabled first\n");
+			isst_display_error_info_message(1, "Ignoring request, turbo-freq feature is still enabled", 0, 0);
 			return -EINVAL;
 		}
 		ret = isst_write_pm_config(cpu, 0);
 		if (ret)
-			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error\n", 0, 0);
+			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error", 0, 0);
 	} else {
 		ret = isst_write_pm_config(cpu, 1);
 		if (ret)
-			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error\n", 0, 0);
+			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error", 0, 0);
 	}
 
 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,

commit fe6fb2165ade451d7a354787a8e4f00fa5bd3e44
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:31 2020 -0800

    tools/power/x86/intel-speed-select: Improve core-power result and error display
    
    This change adds improved error display and handling for commands related
    to core-power feature. The changes include:
    - Replace perror with helpful error message
    - Use ordered priority for SKX based platform by default as the
    proportional priority is not supported
    - Don't show weight and epp in help and also give error when user
    tries to set them in SKX based platforms
    - Range check for epp and weights and display error
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 89b3068a2685..67c9b1139631 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -917,17 +917,19 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 		}
 		ret = isst_write_pm_config(cpu, 0);
 		if (ret)
-			perror("isst_write_pm_config\n");
+			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error\n", 0, 0);
 	} else {
 		ret = isst_write_pm_config(cpu, 1);
 		if (ret)
-			perror("isst_write_pm_config\n");
+			isst_display_error_info_message(0, "WRITE_PM_CONFIG command failed, ignoring error\n", 0, 0);
 	}
 
 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
 				     &resp);
-	if (ret)
+	if (ret) {
+		isst_display_error_info_message(1, "CLOS_PM_QOS_CONFIG command failed", 0, 0);
 		return ret;
+	}
 
 	debug_printf("cpu:%d CLOS_PM_QOS_CONFIG resp:%x\n", cpu, resp);
 
@@ -939,7 +941,7 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 		req = req & ~BIT(1);
 
 	if (priority_type > 1)
-		fprintf(stderr, "Invalid priority type: Changing type to ordered\n");
+		isst_display_error_info_message(1, "Invalid priority type: Changing type to ordered", 0, 0);
 
 	if (priority_type)
 		req = req | BIT(2);

commit a9fd6ae739ef9624f9017df08edf0970c7d170e2
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:29 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for turbo-freq feature
    
    This change adds improved error display and handling for commands related
    to turbo-freq feature. The changes include:
    - Replace perror/fprintf with helpful error message
    - Error for not specifying TDP level when required
    - Show error for invalid bucket number
    - Show message to enable core-power before enabling turbo-freq feature
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 7836f9f08af1..89b3068a2685 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -516,7 +516,7 @@ int isst_set_pbf_fact_status(int cpu, int pbf, int enable)
 	} else {
 
 		if (enable && !ctdp_level.sst_cp_enabled)
-			fprintf(stderr, "Make sure to execute before: core-power enable\n");
+			isst_display_error_info_message(0, "Make sure to execute before: core-power enable", 0, 0);
 
 		if (ctdp_level.pbf_enabled)
 			req = BIT(17);
@@ -603,18 +603,30 @@ int isst_get_fact_bucket_info(int cpu, int level,
 	return 0;
 }
 
-int isst_get_fact_info(int cpu, int level, struct isst_fact_info *fact_info)
+int isst_get_fact_info(int cpu, int level, int fact_bucket, struct isst_fact_info *fact_info)
 {
 	struct isst_pkg_ctdp_level_info ctdp_level;
+	struct isst_pkg_ctdp pkg_dev;
 	unsigned int resp;
-	int ret;
+	int j, ret, print;
+
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get number of levels", 0, 0);
+		return ret;
+	}
+
+	if (level > pkg_dev.levels) {
+		isst_display_error_info_message(1, "Invalid level", 1, level);
+		return -1;
+	}
 
 	ret = isst_get_ctdp_control(cpu, level, &ctdp_level);
 	if (ret)
 		return ret;
 
 	if (!ctdp_level.fact_support) {
-		fprintf(stderr, "turbo-freq feature is not present at this level:%d\n", level);
+		isst_display_error_info_message(1, "turbo-freq feature is not present at this level", 1, level);
 		return -1;
 	}
 
@@ -632,8 +644,25 @@ int isst_get_fact_info(int cpu, int level, struct isst_fact_info *fact_info)
 	fact_info->lp_clipping_ratio_license_avx512 = (resp >> 16) & 0xff;
 
 	ret = isst_get_fact_bucket_info(cpu, level, fact_info->bucket_info);
+	if (ret)
+		return ret;
 
-	return ret;
+	print = 0;
+	for (j = 0; j < ISST_FACT_MAX_BUCKETS; ++j) {
+		if (fact_bucket != 0xff && fact_bucket != j)
+			continue;
+
+		if (!fact_info->bucket_info[j].high_priority_cores_count)
+			break;
+
+		print = 1;
+	}
+	if (!print) {
+		isst_display_error_info_message(1, "Invalid bucket", 0, 0);
+		return -1;
+	}
+
+	return 0;
 }
 
 int isst_set_trl(int cpu, unsigned long long trl)
@@ -769,7 +798,7 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		}
 
 		if (ctdp_level->fact_support) {
-			ret = isst_get_fact_info(cpu, i,
+			ret = isst_get_fact_info(cpu, i, 0xff,
 						 &ctdp_level->fact_info);
 			if (ret)
 				return ret;

commit 39bae0fce48f6431ceb3ab9cff91cb749c736c48
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:28 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for base-freq feature
    
    This change adds improved error display and handling for commands related
    to base-freq feature. The changes include:
    - Replace perror/fprintf with helpful error message
    - Error for not specifying TDP level when required
    - For CLX show help which shows limitation
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index f69c009ef6f6..7836f9f08af1 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -395,15 +395,27 @@ int isst_set_tdp_level(int cpu, int tdp_level)
 int isst_get_pbf_info(int cpu, int level, struct isst_pbf_info *pbf_info)
 {
 	struct isst_pkg_ctdp_level_info ctdp_level;
+	struct isst_pkg_ctdp pkg_dev;
 	int i, ret, core_cnt, max;
 	unsigned int req, resp;
 
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get number of levels", 0, 0);
+		return ret;
+	}
+
+	if (level > pkg_dev.levels) {
+		isst_display_error_info_message(1, "Invalid level", 1, level);
+		return -1;
+	}
+
 	ret = isst_get_ctdp_control(cpu, level, &ctdp_level);
 	if (ret)
 		return ret;
 
 	if (!ctdp_level.pbf_support) {
-		fprintf(stderr, "base-freq feature is not present at this level:%d\n", level);
+		isst_display_error_info_message(1, "base-freq feature is not present at this level", 1, level);
 		return -1;
 	}
 

commit 6d1f2dc8a5d9d1675e664c11ebecbcef739bf058
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:25 2020 -0800

    tools/power/x86/intel-speed-select: Display error for invalid priority type
    
    When priority type for core-power enable command is anything more than 1
    display error before change to 1, which is ordered priority.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 732d9a5eacf1..f69c009ef6f6 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -897,6 +897,9 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 	else
 		req = req & ~BIT(1);
 
+	if (priority_type > 1)
+		fprintf(stderr, "Invalid priority type: Changing type to ordered\n");
+
 	if (priority_type)
 		req = req | BIT(2);
 	else

commit 6c8edba37cc58f44e02f846c4ab50702b64564fd
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:24 2020 -0800

    tools/power/x86/intel-speed-select: Check feature status first
    
    Before looking for information about the base-freq or turbo-freq details,
    first check if the feature is supported at that level. If not print error
    and return.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 2f3921cd87f3..732d9a5eacf1 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -394,9 +394,19 @@ int isst_set_tdp_level(int cpu, int tdp_level)
 
 int isst_get_pbf_info(int cpu, int level, struct isst_pbf_info *pbf_info)
 {
+	struct isst_pkg_ctdp_level_info ctdp_level;
 	int i, ret, core_cnt, max;
 	unsigned int req, resp;
 
+	ret = isst_get_ctdp_control(cpu, level, &ctdp_level);
+	if (ret)
+		return ret;
+
+	if (!ctdp_level.pbf_support) {
+		fprintf(stderr, "base-freq feature is not present at this level:%d\n", level);
+		return -1;
+	}
+
 	pbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);
 
 	core_cnt = get_core_count(get_physical_package_id(cpu), get_physical_die_id(cpu));
@@ -492,6 +502,10 @@ int isst_set_pbf_fact_status(int cpu, int pbf, int enable)
 		else
 			req &= ~BIT(17);
 	} else {
+
+		if (enable && !ctdp_level.sst_cp_enabled)
+			fprintf(stderr, "Make sure to execute before: core-power enable\n");
+
 		if (ctdp_level.pbf_enabled)
 			req = BIT(17);
 
@@ -579,9 +593,19 @@ int isst_get_fact_bucket_info(int cpu, int level,
 
 int isst_get_fact_info(int cpu, int level, struct isst_fact_info *fact_info)
 {
+	struct isst_pkg_ctdp_level_info ctdp_level;
 	unsigned int resp;
 	int ret;
 
+	ret = isst_get_ctdp_control(cpu, level, &ctdp_level);
+	if (ret)
+		return ret;
+
+	if (!ctdp_level.fact_support) {
+		fprintf(stderr, "turbo-freq feature is not present at this level:%d\n", level);
+		return -1;
+	}
+
 	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
 				     CONFIG_TDP_GET_FACT_LP_CLIPPING_RATIO, 0,
 				     level, &resp);

commit ac9d05ea4cfb99dd24767f2510ca526282fffa13
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:23 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for perf-profile feature
    
    This change adds improved error display and handling for commands related
    to perf-profile feature. The changes include:
    - When invalid TDP level is passed. display error and exit
    - Replace perror with helpful error message
    - Show error when TDP level can't be set
    - Print error when information can't be read for a level
    - Validate user options for invalid level
    - Display error for TDP lock status
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 81a119f688a3..2f3921cd87f3 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -114,8 +114,10 @@ int isst_get_tdp_info(int cpu, int config_index,
 
 	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_TDP_INFO,
 				     0, config_index, &resp);
-	if (ret)
+	if (ret) {
+		isst_display_error_info_message(1, "Invalid level, Can't get TDP information at level", 1, config_index);
 		return ret;
+	}
 
 	ctdp_level->pkg_tdp = resp & GENMASK(14, 0);
 	ctdp_level->tdp_ratio = (resp & GENMASK(23, 16)) >> 16;
@@ -352,7 +354,7 @@ int isst_set_tdp_level_msr(int cpu, int tdp_level)
 	debug_printf("cpu: tdp_level via MSR %d\n", cpu, tdp_level);
 
 	if (isst_get_config_tdp_lock_status(cpu)) {
-		debug_printf("cpu: tdp_locked %d\n", cpu);
+		isst_display_error_info_message(1, "tdp_locked", 0, 0);
 		return -1;
 	}
 
@@ -373,10 +375,19 @@ int isst_set_tdp_level(int cpu, int tdp_level)
 	unsigned int resp;
 	int ret;
 
+
+	if (isst_get_config_tdp_lock_status(cpu)) {
+		isst_display_error_info_message(1, "TDP is locked", 0, 0);
+		return -1;
+
+	}
+
 	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_SET_LEVEL, 0,
 				     tdp_level, &resp);
-	if (ret)
-		return isst_set_tdp_level_msr(cpu, tdp_level);
+	if (ret) {
+		isst_display_error_info_message(1, "Set TDP level failed for level", 1, tdp_level);
+		return ret;
+	}
 
 	return 0;
 }
@@ -671,7 +682,7 @@ void isst_get_process_ctdp_complete(int cpu, struct isst_pkg_ctdp *pkg_dev)
 
 int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 {
-	int i, ret;
+	int i, ret, valid = 0;
 
 	if (pkg_dev->processed)
 		return 0;
@@ -684,6 +695,14 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		     cpu, pkg_dev->enabled, pkg_dev->current_level,
 		     pkg_dev->levels);
 
+	if (tdp_level != 0xff && tdp_level > pkg_dev->levels) {
+		isst_display_error_info_message(1, "Invalid level", 0, 0);
+		return -1;
+	}
+
+	if (!pkg_dev->enabled)
+		isst_display_error_info_message(0, "perf-profile feature is not supported, just base-config level 0 is valid", 0, 0);
+
 	for (i = 0; i <= pkg_dev->levels; ++i) {
 		struct isst_pkg_ctdp_level_info *ctdp_level;
 
@@ -703,6 +722,7 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		if (ret)
 			continue;
 
+		valid = 1;
 		pkg_dev->processed = 1;
 		ctdp_level->processed = 1;
 
@@ -775,6 +795,9 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		isst_get_uncore_mem_freq(cpu, i, ctdp_level);
 	}
 
+	if (!valid)
+		isst_display_error_info_message(0, "Invalid level, Can't get TDP control information at specified levels on cpu", 1, cpu);
+
 	return 0;
 }
 

commit 645feeb2f571acfc36a7205a6302e8c7e442d617
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Jan 14 11:22:14 2020 -0800

    tools/power/x86/intel-speed-select: Add support for core-power discovery
    
    It is possible that BIOS may not enable core-power feature. In this case
    this additional interface will allow to enable from this utility. Also
    the information dump, includes the current status of core-power.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index d14c7bcd327a..81a119f688a3 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -6,6 +6,44 @@
 
 #include "isst.h"
 
+int isst_write_pm_config(int cpu, int cp_state)
+{
+	unsigned int req, resp;
+	int ret;
+
+	if (cp_state)
+		req = BIT(16);
+	else
+		req = 0;
+
+	ret = isst_send_mbox_command(cpu, WRITE_PM_CONFIG, PM_FEATURE, 0, req,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d WRITE_PM_CONFIG resp:%x\n", cpu, resp);
+
+	return 0;
+}
+
+int isst_read_pm_config(int cpu, int *cp_state, int *cp_cap)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, READ_PM_CONFIG, PM_FEATURE, 0, 0,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d READ_PM_CONFIG resp:%x\n", cpu, resp);
+
+	*cp_state = resp & BIT(16);
+	*cp_cap = resp & BIT(0) ? 1 : 0;
+
+	return 0;
+}
+
 int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
 {
 	unsigned int resp;
@@ -36,6 +74,7 @@ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
 int isst_get_ctdp_control(int cpu, int config_index,
 			  struct isst_pkg_ctdp_level_info *ctdp_level)
 {
+	int cp_state, cp_cap;
 	unsigned int resp;
 	int ret;
 
@@ -50,6 +89,15 @@ int isst_get_ctdp_control(int cpu, int config_index,
 	ctdp_level->fact_enabled = !!(resp & BIT(16));
 	ctdp_level->pbf_enabled = !!(resp & BIT(17));
 
+	ret = isst_read_pm_config(cpu, &cp_state, &cp_cap);
+	if (ret) {
+		debug_printf("cpu:%d pm_config is not supported \n", cpu);
+	} else {
+		debug_printf("cpu:%d pm_config SST-CP state:%d cap:%d \n", cpu, cp_state, cp_cap);
+		ctdp_level->sst_cp_support = cp_cap;
+		ctdp_level->sst_cp_enabled = cp_state;
+	}
+
 	debug_printf(
 		"cpu:%d CONFIG_TDP_GET_TDP_CONTROL resp:%x fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\n",
 		cpu, resp, ctdp_level->fact_support, ctdp_level->pbf_support,
@@ -779,6 +827,13 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 			debug_printf("Turbo-freq feature must be disabled first\n");
 			return -EINVAL;
 		}
+		ret = isst_write_pm_config(cpu, 0);
+		if (ret)
+			perror("isst_write_pm_config\n");
+	} else {
+		ret = isst_write_pm_config(cpu, 1);
+		if (ret)
+			perror("isst_write_pm_config\n");
 	}
 
 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,

commit 1434a3d357d656d4b11fcbdc9b6c35dc673292a0
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Nov 19 16:22:54 2019 -0800

    tools/power/x86/intel-speed-select: Display TRL buckets for just base config level
    
    When only base config level is present, this tool is displaying TRL
    (Turbo-ratio-limits) by reading legacy MSR. In this case, also present
    core count for TRL by reading MSR 0x1AE.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index aa19c9998e6c..d14c7bcd327a 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -681,6 +681,7 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 			}
 
 			isst_get_get_trl_from_msr(cpu, ctdp_level->trl_sse_active_cores);
+			isst_get_trl_bucket_info(cpu, &ctdp_level->buckets_info);
 			continue;
 		}
 

commit 20183ccd3e4d01d23b0a01fe9f3ee73fbae312fa
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Nov 15 12:35:22 2019 -0800

    tools/power/x86/intel-speed-select: Ignore missing config level
    
    It is possible that certain config levels are not available, even
    if the max level includes the level. There can be missing levels in
    some platforms. So ignore the level when called for information dump
    for all levels and fail if specifically ask for the missing level.
    
    Here the changes is to continue reading information about other levels
    even if we fail to get information for the current level. But use the
    "processed" flag to indicate the failure. When the "processed" flag is
    not set, don't dump information about that level.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 52698553de92..aa19c9998e6c 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -646,7 +646,6 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 			     i);
 		ctdp_level = &pkg_dev->ctdp_level[i];
 
-		ctdp_level->processed = 1;
 		ctdp_level->level = i;
 		ctdp_level->control_cpu = cpu;
 		ctdp_level->pkg_id = get_physical_package_id(cpu);
@@ -654,7 +653,10 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 
 		ret = isst_get_ctdp_control(cpu, i, ctdp_level);
 		if (ret)
-			return ret;
+			continue;
+
+		pkg_dev->processed = 1;
+		ctdp_level->processed = 1;
 
 		if (ctdp_level->pbf_support) {
 			ret = isst_get_pbf_info(cpu, i, &ctdp_level->pbf_info);
@@ -724,8 +726,6 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		isst_get_uncore_mem_freq(cpu, i, ctdp_level);
 	}
 
-	pkg_dev->processed = 1;
-
 	return 0;
 }
 

commit de7f9d3ddc8c71a116fbdfa298a19abd8d46e696
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:45 2019 -0800

    tools/power/x86/intel-speed-select: Use core count for base-freq mask
    
    Some firmware implementation gives error when a command is sent get mask
    for core count 32-61. So use core count to decide.
    
    But there is no function to get core count. So introduce one function to
    get core count.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 8b3e1c7abb42..52698553de92 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -335,12 +335,15 @@ int isst_set_tdp_level(int cpu, int tdp_level)
 
 int isst_get_pbf_info(int cpu, int level, struct isst_pbf_info *pbf_info)
 {
+	int i, ret, core_cnt, max;
 	unsigned int req, resp;
-	int i, ret;
 
 	pbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);
 
-	for (i = 0; i < 2; ++i) {
+	core_cnt = get_core_count(get_physical_package_id(cpu), get_physical_die_id(cpu));
+	max = core_cnt > 32 ? 2 : 1;
+
+	for (i = 0; i < max; ++i) {
 		unsigned long long mask;
 		int count;
 

commit 7af5a95bb752702bfc91fc513d37f1f799e6fd1f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:44 2019 -0800

    tools/power/x86/intel-speed-select: Support platform with limited Intel(R) Speed Select
    
    There are some platforms, where there limited support of Intel(R) SST
    features. Here perf-profile has only one base configuration and limited
    support of commands. But still has support for discovery of base-freq and
    turbo-freq features. So it is important to show minimum features to use
    base-freq and turbo-freq features.
    
    Here the change are:
    - When there is no support of CONFIG_TDP_GET_LEVELS_INFO, then instead
    of treating this as fatal error, treat this with number of config levels
    = 0, that means only base level 0 is present.
    - There is no support of mail box commands to get base frequencies or
    turbo frequencies. Here present base frequency by reading cpufreq
    base freq and turbo frequency by reading MSR 0x1AD.
    - Don't display any field, which has value == 0.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index ca3bd5b2cf45..8b3e1c7abb42 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -13,8 +13,14 @@ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
 
 	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
 				     CONFIG_TDP_GET_LEVELS_INFO, 0, 0, &resp);
-	if (ret)
-		return ret;
+	if (ret) {
+		pkg_dev->levels = 0;
+		pkg_dev->locked = 1;
+		pkg_dev->current_level = 0;
+		pkg_dev->version = 0;
+		pkg_dev->enabled = 0;
+		return 0;
+	}
 
 	debug_printf("cpu:%d CONFIG_TDP_GET_LEVELS_INFO resp:%x\n", cpu, resp);
 
@@ -212,6 +218,27 @@ int isst_get_coremask_info(int cpu, int config_index,
 	return 0;
 }
 
+int isst_get_get_trl_from_msr(int cpu, int *trl)
+{
+	unsigned long long msr_trl;
+	int ret;
+
+	ret = isst_send_msr_command(cpu, 0x1AD, 0, &msr_trl);
+	if (ret)
+		return ret;
+
+	trl[0] = msr_trl & GENMASK(7, 0);
+	trl[1] = (msr_trl & GENMASK(15, 8)) >> 8;
+	trl[2] = (msr_trl & GENMASK(23, 16)) >> 16;
+	trl[3] = (msr_trl & GENMASK(31, 24)) >> 24;
+	trl[4] = (msr_trl & GENMASK(39, 32)) >> 32;
+	trl[5] = (msr_trl & GENMASK(47, 40)) >> 40;
+	trl[6] = (msr_trl & GENMASK(55, 48)) >> 48;
+	trl[7] = (msr_trl & GENMASK(63, 56)) >> 56;
+
+	return 0;
+}
+
 int isst_get_get_trl(int cpu, int level, int avx_level, int *trl)
 {
 	unsigned int req, resp;
@@ -321,7 +348,7 @@ int isst_get_pbf_info(int cpu, int level, struct isst_pbf_info *pbf_info)
 					     CONFIG_TDP_PBF_GET_CORE_MASK_INFO,
 					     0, (i << 8) | level, &resp);
 		if (ret)
-			return ret;
+			break;
 
 		debug_printf(
 			"cpu:%d CONFIG_TDP_PBF_GET_CORE_MASK_INFO resp:%x\n",
@@ -386,7 +413,7 @@ int isst_set_pbf_fact_status(int cpu, int pbf, int enable)
 
 	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
 	if (ret)
-		return ret;
+		debug_printf("cpu:%d No support for dynamic ISST\n", cpu);
 
 	current_level = pkg_dev.current_level;
 
@@ -626,6 +653,32 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		if (ret)
 			return ret;
 
+		if (ctdp_level->pbf_support) {
+			ret = isst_get_pbf_info(cpu, i, &ctdp_level->pbf_info);
+			if (!ret)
+				ctdp_level->pbf_found = 1;
+		}
+
+		if (ctdp_level->fact_support) {
+			ret = isst_get_fact_info(cpu, i,
+						 &ctdp_level->fact_info);
+			if (ret)
+				return ret;
+		}
+
+		if (!pkg_dev->enabled) {
+			int freq;
+
+			freq = get_cpufreq_base_freq(cpu);
+			if (freq > 0) {
+				ctdp_level->sse_p1 = freq / 100000;
+				ctdp_level->tdp_ratio = ctdp_level->sse_p1;
+			}
+
+			isst_get_get_trl_from_msr(cpu, ctdp_level->trl_sse_active_cores);
+			continue;
+		}
+
 		ret = isst_get_tdp_info(cpu, i, ctdp_level);
 		if (ret)
 			return ret;
@@ -666,19 +719,6 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		isst_get_uncore_p0_p1_info(cpu, i, ctdp_level);
 		isst_get_p1_info(cpu, i, ctdp_level);
 		isst_get_uncore_mem_freq(cpu, i, ctdp_level);
-
-		if (ctdp_level->pbf_support) {
-			ret = isst_get_pbf_info(cpu, i, &ctdp_level->pbf_info);
-			if (!ret)
-				ctdp_level->pbf_found = 1;
-		}
-
-		if (ctdp_level->fact_support) {
-			ret = isst_get_fact_info(cpu, i,
-						 &ctdp_level->fact_info);
-			if (ret)
-				return ret;
-		}
 	}
 
 	pkg_dev->processed = 1;

commit 263225c983aa27719fe06836426e270b658036ed
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:37 2019 -0800

    tools/power/x86/intel-speed-select: Extend command set for perf-profile
    
    Add support for uncore P0, uncore P1, P1 for base and AVX levels and
    memory frequency. These commands are optional, so continue on
    failure.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 67d32f2b9bea..ca3bd5b2cf45 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -95,6 +95,69 @@ int isst_get_pwr_info(int cpu, int config_index,
 	return 0;
 }
 
+void isst_get_uncore_p0_p1_info(int cpu, int config_index,
+				struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_UNCORE_P0_P1_INFO, 0,
+				     config_index, &resp);
+	if (ret) {
+		ctdp_level->uncore_p0 = 0;
+		ctdp_level->uncore_p1 = 0;
+		return;
+	}
+
+	ctdp_level->uncore_p0 = resp & GENMASK(7, 0);
+	ctdp_level->uncore_p1 = (resp & GENMASK(15, 8)) >> 8;
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_UNCORE_P0_P1_INFO resp:%x uncore p0:%d uncore p1:%d\n",
+		cpu, config_index, resp, ctdp_level->uncore_p0,
+		ctdp_level->uncore_p1);
+}
+
+void isst_get_p1_info(int cpu, int config_index,
+		      struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_P1_INFO, 0,
+				     config_index, &resp);
+	if (ret) {
+		ctdp_level->sse_p1 = 0;
+		ctdp_level->avx2_p1 = 0;
+		ctdp_level->avx512_p1 = 0;
+		return;
+	}
+
+	ctdp_level->sse_p1 = resp & GENMASK(7, 0);
+	ctdp_level->avx2_p1 = (resp & GENMASK(15, 8)) >> 8;
+	ctdp_level->avx512_p1 = (resp & GENMASK(23, 16)) >> 16;
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_P1_INFO resp:%x sse_p1:%d avx2_p1:%d avx512_p1:%d\n",
+		cpu, config_index, resp, ctdp_level->sse_p1,
+		ctdp_level->avx2_p1, ctdp_level->avx512_p1);
+}
+
+void isst_get_uncore_mem_freq(int cpu, int config_index,
+			      struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_MEM_FREQ,
+				     0, config_index, &resp);
+	if (ret) {
+		ctdp_level->mem_freq = 0;
+		return;
+	}
+
+	ctdp_level->mem_freq = resp & GENMASK(7, 0);
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_MEM_FREQ resp:%x uncore mem_freq:%d\n",
+		cpu, config_index, resp, ctdp_level->mem_freq);
+}
+
 int isst_get_tjmax_info(int cpu, int config_index,
 			struct isst_pkg_ctdp_level_info *ctdp_level)
 {
@@ -600,6 +663,10 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		if (ret)
 			return ret;
 
+		isst_get_uncore_p0_p1_info(cpu, i, ctdp_level);
+		isst_get_p1_info(cpu, i, ctdp_level);
+		isst_get_uncore_mem_freq(cpu, i, ctdp_level);
+
 		if (ctdp_level->pbf_support) {
 			ret = isst_get_pbf_info(cpu, i, &ctdp_level->pbf_info);
 			if (!ret)

commit 4e26fabfe15ca67125f1b6984671c2e9048d64a5
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 10 13:29:39 2019 -0700

    tools/power/x86/intel-speed-select: Refuse to disable core-power when getting used
    
    The turbo-freq feature is dependent on the core-power feature. If the
    core-power feature is disabled while the turbo-freq feature is enabled,
    this will break the turbo-freq feature. This is a firmware limitation,
    where they can't return error under this scenario.
    
    So when trying to disable core-power, make sure that the turbo-freq
    feature is not enabled. If it enabled, return error if user is trying to
    disable the core-power feature.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 6dee5332c9d3..67d32f2b9bea 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -649,6 +649,27 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 	unsigned int req, resp;
 	int ret;
 
+	if (!enable_clos) {
+		struct isst_pkg_ctdp pkg_dev;
+		struct isst_pkg_ctdp_level_info ctdp_level;
+
+		ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+		if (ret) {
+			debug_printf("isst_get_ctdp_levels\n");
+			return ret;
+		}
+
+		ret = isst_get_ctdp_control(cpu, pkg_dev.current_level,
+					    &ctdp_level);
+		if (ret)
+			return ret;
+
+		if (ctdp_level.fact_enabled) {
+			debug_printf("Turbo-freq feature must be disabled first\n");
+			return -EINVAL;
+		}
+	}
+
 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
 				     &resp);
 	if (ret)

commit 188afed9db7db3aefc8c9c33150be2f8f398da9a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Sep 14 12:45:47 2019 -0700

    tools/power/x86/intel-speed-select: Extend core-power command set
    
    Add additional command to get the clos enable and priority type. The
    current info option is actually dumping per clos QOS config, so name
    the command appropriately to get-config.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 0bf341ad9697..6dee5332c9d3 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -619,6 +619,31 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 	return 0;
 }
 
+int isst_clos_get_clos_information(int cpu, int *enable, int *type)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PM_QOS_CONFIG resp:%x\n", cpu, resp);
+
+	if (resp & BIT(1))
+		*enable = 1;
+	else
+		*enable = 0;
+
+	if (resp & BIT(2))
+		*type = 1;
+	else
+		*type = 0;
+
+	return 0;
+}
+
 int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
 {
 	unsigned int req, resp;

commit 1233c7b95c7045905e40c11484493f20ab521d21
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sun Sep 8 07:42:25 2019 -0700

    tools/power/x86/intel-speed-select: Display core count for bucket
    
    Read the bucket and core count relationship via MSR and display
    when displaying turbo ratio limits.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index f724322856ed..0bf341ad9697 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -188,6 +188,24 @@ int isst_get_get_trl(int cpu, int level, int avx_level, int *trl)
 	return 0;
 }
 
+int isst_get_trl_bucket_info(int cpu, unsigned long long *buckets_info)
+{
+	int ret;
+
+	debug_printf("cpu:%d bucket info via MSR\n", cpu);
+
+	*buckets_info = 0;
+
+	ret = isst_send_msr_command(cpu, 0x1ae, 0, buckets_info);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d bucket info via MSR successful 0x%llx\n", cpu,
+		     *buckets_info);
+
+	return 0;
+}
+
 int isst_set_tdp_level_msr(int cpu, int tdp_level)
 {
 	unsigned long long level = tdp_level;
@@ -563,6 +581,10 @@ int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
 		if (ret)
 			return ret;
 
+		ret = isst_get_trl_bucket_info(cpu, &ctdp_level->buckets_info);
+		if (ret)
+			return ret;
+
 		ret = isst_get_get_trl(cpu, i, 0,
 				       ctdp_level->trl_sse_active_cores);
 		if (ret)

commit 010764b8856e5ee5056113704dc4b914ebc88f1d
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Aug 21 10:14:03 2019 +0300

    tools/power/x86/intel-speed-select: Fix a read overflow in isst_set_tdp_level_msr()
    
    The isst_send_msr_command() function will read 8 bytes but we are
    passing an address to an int (4 bytes) so it results in a read overflow.
    
    Fixes: 3fb4f7cd472c ("tools/power/x86: A tool to validate Intel Speed Select commands")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
index 8de4ac39a008..f724322856ed 100644
--- a/tools/power/x86/intel-speed-select/isst-core.c
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -190,6 +190,7 @@ int isst_get_get_trl(int cpu, int level, int avx_level, int *trl)
 
 int isst_set_tdp_level_msr(int cpu, int tdp_level)
 {
+	unsigned long long level = tdp_level;
 	int ret;
 
 	debug_printf("cpu: tdp_level via MSR %d\n", cpu, tdp_level);
@@ -202,8 +203,7 @@ int isst_set_tdp_level_msr(int cpu, int tdp_level)
 	if (tdp_level > 2)
 		return -1; /* invalid value */
 
-	ret = isst_send_msr_command(cpu, 0x64b, 1,
-				    (unsigned long long *)&tdp_level);
+	ret = isst_send_msr_command(cpu, 0x64b, 1, &level);
 	if (ret)
 		return ret;
 

commit 3fb4f7cd472c7f5905c91508e988f6b28372210d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sun Jun 30 10:14:08 2019 -0700

    tools/power/x86: A tool to validate Intel Speed Select commands
    
    The Intel(R) Speed select technologies contains four features.
    
    Performance profile:An non architectural mechanism that allows multiple
    optimized performance profiles per system via static and/or dynamic
    adjustment of core count, workload, Tjmax, and TDP, etc. aka ISS
    in the documentation.
    
    Base Frequency: Enables users to increase guaranteed base frequency on
    certain cores (high priority cores) in exchange for lower base frequency
    on remaining cores (low priority cores). aka PBF in the documenation.
    
    Turbo frequency: Enables the ability to set different turbo ratio limits
    to cores based on priority. aka FACT in the documentation.
    
    Core power: An Interface that allows user to define per core/tile
    priority.
    
    There is a multi level help for commands and options. This can be used
    to check required arguments for each feature and commands for the
    feature.
    
    To start navigating the features start with
    
    $sudo intel-speed-select --help
    
    For help on a specific feature for example
    $sudo intel-speed-select perf-profile --help
    
    To get help for a command for a feature for example
    $sudo intel-speed-select perf-profile get-lock-status --help
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
new file mode 100644
index 000000000000..8de4ac39a008
--- /dev/null
+++ b/tools/power/x86/intel-speed-select/isst-core.c
@@ -0,0 +1,721 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Speed Select -- Enumerate and control features
+ * Copyright (c) 2019 Intel Corporation.
+ */
+
+#include "isst.h"
+
+int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_LEVELS_INFO, 0, 0, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_GET_LEVELS_INFO resp:%x\n", cpu, resp);
+
+	pkg_dev->version = resp & 0xff;
+	pkg_dev->levels = (resp >> 8) & 0xff;
+	pkg_dev->current_level = (resp >> 16) & 0xff;
+	pkg_dev->locked = !!(resp & BIT(24));
+	pkg_dev->enabled = !!(resp & BIT(31));
+
+	return 0;
+}
+
+int isst_get_ctdp_control(int cpu, int config_index,
+			  struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_TDP_CONTROL, 0,
+				     config_index, &resp);
+	if (ret)
+		return ret;
+
+	ctdp_level->fact_support = resp & BIT(0);
+	ctdp_level->pbf_support = !!(resp & BIT(1));
+	ctdp_level->fact_enabled = !!(resp & BIT(16));
+	ctdp_level->pbf_enabled = !!(resp & BIT(17));
+
+	debug_printf(
+		"cpu:%d CONFIG_TDP_GET_TDP_CONTROL resp:%x fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\n",
+		cpu, resp, ctdp_level->fact_support, ctdp_level->pbf_support,
+		ctdp_level->fact_enabled, ctdp_level->pbf_enabled);
+
+	return 0;
+}
+
+int isst_get_tdp_info(int cpu, int config_index,
+		      struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_TDP_INFO,
+				     0, config_index, &resp);
+	if (ret)
+		return ret;
+
+	ctdp_level->pkg_tdp = resp & GENMASK(14, 0);
+	ctdp_level->tdp_ratio = (resp & GENMASK(23, 16)) >> 16;
+
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_TDP_INFO resp:%x tdp_ratio:%d pkg_tdp:%d\n",
+		cpu, config_index, resp, ctdp_level->tdp_ratio,
+		ctdp_level->pkg_tdp);
+	return 0;
+}
+
+int isst_get_pwr_info(int cpu, int config_index,
+		      struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_PWR_INFO,
+				     0, config_index, &resp);
+	if (ret)
+		return ret;
+
+	ctdp_level->pkg_max_power = resp & GENMASK(14, 0);
+	ctdp_level->pkg_min_power = (resp & GENMASK(30, 16)) >> 16;
+
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_PWR_INFO resp:%x pkg_max_power:%d pkg_min_power:%d\n",
+		cpu, config_index, resp, ctdp_level->pkg_max_power,
+		ctdp_level->pkg_min_power);
+
+	return 0;
+}
+
+int isst_get_tjmax_info(int cpu, int config_index,
+			struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_GET_TJMAX_INFO,
+				     0, config_index, &resp);
+	if (ret)
+		return ret;
+
+	ctdp_level->t_proc_hot = resp & GENMASK(7, 0);
+
+	debug_printf(
+		"cpu:%d ctdp:%d CONFIG_TDP_GET_TJMAX_INFO resp:%x t_proc_hot:%d\n",
+		cpu, config_index, resp, ctdp_level->t_proc_hot);
+
+	return 0;
+}
+
+int isst_get_coremask_info(int cpu, int config_index,
+			   struct isst_pkg_ctdp_level_info *ctdp_level)
+{
+	unsigned int resp;
+	int i, ret;
+
+	ctdp_level->cpu_count = 0;
+	for (i = 0; i < 2; ++i) {
+		unsigned long long mask;
+		int cpu_count = 0;
+
+		ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+					     CONFIG_TDP_GET_CORE_MASK, 0,
+					     (i << 8) | config_index, &resp);
+		if (ret)
+			return ret;
+
+		debug_printf(
+			"cpu:%d ctdp:%d mask:%d CONFIG_TDP_GET_CORE_MASK resp:%x\n",
+			cpu, config_index, i, resp);
+
+		mask = (unsigned long long)resp << (32 * i);
+		set_cpu_mask_from_punit_coremask(cpu, mask,
+						 ctdp_level->core_cpumask_size,
+						 ctdp_level->core_cpumask,
+						 &cpu_count);
+		ctdp_level->cpu_count += cpu_count;
+		debug_printf("cpu:%d ctdp:%d mask:%d cpu count:%d\n", cpu,
+			     config_index, i, ctdp_level->cpu_count);
+	}
+
+	return 0;
+}
+
+int isst_get_get_trl(int cpu, int level, int avx_level, int *trl)
+{
+	unsigned int req, resp;
+	int ret;
+
+	req = level | (avx_level << 16);
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_TURBO_LIMIT_RATIOS, 0, req,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf(
+		"cpu:%d CONFIG_TDP_GET_TURBO_LIMIT_RATIOS req:%x resp:%x\n",
+		cpu, req, resp);
+
+	trl[0] = resp & GENMASK(7, 0);
+	trl[1] = (resp & GENMASK(15, 8)) >> 8;
+	trl[2] = (resp & GENMASK(23, 16)) >> 16;
+	trl[3] = (resp & GENMASK(31, 24)) >> 24;
+
+	req = level | BIT(8) | (avx_level << 16);
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_TURBO_LIMIT_RATIOS, 0, req,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_GET_TURBO_LIMIT req:%x resp:%x\n", cpu,
+		     req, resp);
+
+	trl[4] = resp & GENMASK(7, 0);
+	trl[5] = (resp & GENMASK(15, 8)) >> 8;
+	trl[6] = (resp & GENMASK(23, 16)) >> 16;
+	trl[7] = (resp & GENMASK(31, 24)) >> 24;
+
+	return 0;
+}
+
+int isst_set_tdp_level_msr(int cpu, int tdp_level)
+{
+	int ret;
+
+	debug_printf("cpu: tdp_level via MSR %d\n", cpu, tdp_level);
+
+	if (isst_get_config_tdp_lock_status(cpu)) {
+		debug_printf("cpu: tdp_locked %d\n", cpu);
+		return -1;
+	}
+
+	if (tdp_level > 2)
+		return -1; /* invalid value */
+
+	ret = isst_send_msr_command(cpu, 0x64b, 1,
+				    (unsigned long long *)&tdp_level);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu: tdp_level via MSR successful %d\n", cpu, tdp_level);
+
+	return 0;
+}
+
+int isst_set_tdp_level(int cpu, int tdp_level)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP, CONFIG_TDP_SET_LEVEL, 0,
+				     tdp_level, &resp);
+	if (ret)
+		return isst_set_tdp_level_msr(cpu, tdp_level);
+
+	return 0;
+}
+
+int isst_get_pbf_info(int cpu, int level, struct isst_pbf_info *pbf_info)
+{
+	unsigned int req, resp;
+	int i, ret;
+
+	pbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);
+
+	for (i = 0; i < 2; ++i) {
+		unsigned long long mask;
+		int count;
+
+		ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+					     CONFIG_TDP_PBF_GET_CORE_MASK_INFO,
+					     0, (i << 8) | level, &resp);
+		if (ret)
+			return ret;
+
+		debug_printf(
+			"cpu:%d CONFIG_TDP_PBF_GET_CORE_MASK_INFO resp:%x\n",
+			cpu, resp);
+
+		mask = (unsigned long long)resp << (32 * i);
+		set_cpu_mask_from_punit_coremask(cpu, mask,
+						 pbf_info->core_cpumask_size,
+						 pbf_info->core_cpumask,
+						 &count);
+	}
+
+	req = level;
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_PBF_GET_P1HI_P1LO_INFO, 0, req,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_PBF_GET_P1HI_P1LO_INFO resp:%x\n", cpu,
+		     resp);
+
+	pbf_info->p1_low = resp & 0xff;
+	pbf_info->p1_high = (resp & GENMASK(15, 8)) >> 8;
+
+	req = level;
+	ret = isst_send_mbox_command(
+		cpu, CONFIG_TDP, CONFIG_TDP_PBF_GET_TDP_INFO, 0, req, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_PBF_GET_TDP_INFO resp:%x\n", cpu, resp);
+
+	pbf_info->tdp = resp & 0xffff;
+
+	req = level;
+	ret = isst_send_mbox_command(
+		cpu, CONFIG_TDP, CONFIG_TDP_PBF_GET_TJ_MAX_INFO, 0, req, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_PBF_GET_TJ_MAX_INFO resp:%x\n", cpu,
+		     resp);
+	pbf_info->t_control = (resp >> 8) & 0xff;
+	pbf_info->t_prochot = resp & 0xff;
+
+	return 0;
+}
+
+void isst_get_pbf_info_complete(struct isst_pbf_info *pbf_info)
+{
+	free_cpu_set(pbf_info->core_cpumask);
+}
+
+int isst_set_pbf_fact_status(int cpu, int pbf, int enable)
+{
+	struct isst_pkg_ctdp pkg_dev;
+	struct isst_pkg_ctdp_level_info ctdp_level;
+	int current_level;
+	unsigned int req = 0, resp;
+	int ret;
+
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret)
+		return ret;
+
+	current_level = pkg_dev.current_level;
+
+	ret = isst_get_ctdp_control(cpu, current_level, &ctdp_level);
+	if (ret)
+		return ret;
+
+	if (pbf) {
+		if (ctdp_level.fact_enabled)
+			req = BIT(16);
+
+		if (enable)
+			req |= BIT(17);
+		else
+			req &= ~BIT(17);
+	} else {
+		if (ctdp_level.pbf_enabled)
+			req = BIT(17);
+
+		if (enable)
+			req |= BIT(16);
+		else
+			req &= ~BIT(16);
+	}
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_SET_TDP_CONTROL, 0, req, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_SET_TDP_CONTROL pbf/fact:%d req:%x\n",
+		     cpu, pbf, req);
+
+	return 0;
+}
+
+int isst_get_fact_bucket_info(int cpu, int level,
+			      struct isst_fact_bucket_info *bucket_info)
+{
+	unsigned int resp;
+	int i, k, ret;
+
+	for (i = 0; i < 2; ++i) {
+		int j;
+
+		ret = isst_send_mbox_command(
+			cpu, CONFIG_TDP,
+			CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_NUMCORES, 0,
+			(i << 8) | level, &resp);
+		if (ret)
+			return ret;
+
+		debug_printf(
+			"cpu:%d CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_NUMCORES index:%d level:%d resp:%x\n",
+			cpu, i, level, resp);
+
+		for (j = 0; j < 4; ++j) {
+			bucket_info[j + (i * 4)].high_priority_cores_count =
+				(resp >> (j * 8)) & 0xff;
+		}
+	}
+
+	for (k = 0; k < 3; ++k) {
+		for (i = 0; i < 2; ++i) {
+			int j;
+
+			ret = isst_send_mbox_command(
+				cpu, CONFIG_TDP,
+				CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_RATIOS, 0,
+				(k << 16) | (i << 8) | level, &resp);
+			if (ret)
+				return ret;
+
+			debug_printf(
+				"cpu:%d CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_RATIOS index:%d level:%d avx:%d resp:%x\n",
+				cpu, i, level, k, resp);
+
+			for (j = 0; j < 4; ++j) {
+				switch (k) {
+				case 0:
+					bucket_info[j + (i * 4)].sse_trl =
+						(resp >> (j * 8)) & 0xff;
+					break;
+				case 1:
+					bucket_info[j + (i * 4)].avx_trl =
+						(resp >> (j * 8)) & 0xff;
+					break;
+				case 2:
+					bucket_info[j + (i * 4)].avx512_trl =
+						(resp >> (j * 8)) & 0xff;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+int isst_get_fact_info(int cpu, int level, struct isst_fact_info *fact_info)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_TDP,
+				     CONFIG_TDP_GET_FACT_LP_CLIPPING_RATIO, 0,
+				     level, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CONFIG_TDP_GET_FACT_LP_CLIPPING_RATIO resp:%x\n",
+		     cpu, resp);
+
+	fact_info->lp_clipping_ratio_license_sse = resp & 0xff;
+	fact_info->lp_clipping_ratio_license_avx2 = (resp >> 8) & 0xff;
+	fact_info->lp_clipping_ratio_license_avx512 = (resp >> 16) & 0xff;
+
+	ret = isst_get_fact_bucket_info(cpu, level, fact_info->bucket_info);
+
+	return ret;
+}
+
+int isst_set_trl(int cpu, unsigned long long trl)
+{
+	int ret;
+
+	if (!trl)
+		trl = 0xFFFFFFFFFFFFFFFFULL;
+
+	ret = isst_send_msr_command(cpu, 0x1AD, 1, &trl);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int isst_set_trl_from_current_tdp(int cpu, unsigned long long trl)
+{
+	unsigned long long msr_trl;
+	int ret;
+
+	if (trl) {
+		msr_trl = trl;
+	} else {
+		struct isst_pkg_ctdp pkg_dev;
+		int trl[8];
+		int i;
+
+		ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+		if (ret)
+			return ret;
+
+		ret = isst_get_get_trl(cpu, pkg_dev.current_level, 0, trl);
+		if (ret)
+			return ret;
+
+		msr_trl = 0;
+		for (i = 0; i < 8; ++i) {
+			unsigned long long _trl = trl[i];
+
+			msr_trl |= (_trl << (i * 8));
+		}
+	}
+	ret = isst_send_msr_command(cpu, 0x1AD, 1, &msr_trl);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/* Return 1 if locked */
+int isst_get_config_tdp_lock_status(int cpu)
+{
+	unsigned long long tdp_control = 0;
+	int ret;
+
+	ret = isst_send_msr_command(cpu, 0x64b, 0, &tdp_control);
+	if (ret)
+		return ret;
+
+	ret = !!(tdp_control & BIT(31));
+
+	return ret;
+}
+
+void isst_get_process_ctdp_complete(int cpu, struct isst_pkg_ctdp *pkg_dev)
+{
+	int i;
+
+	if (!pkg_dev->processed)
+		return;
+
+	for (i = 0; i < pkg_dev->levels; ++i) {
+		struct isst_pkg_ctdp_level_info *ctdp_level;
+
+		ctdp_level = &pkg_dev->ctdp_level[i];
+		if (ctdp_level->pbf_support)
+			free_cpu_set(ctdp_level->pbf_info.core_cpumask);
+		free_cpu_set(ctdp_level->core_cpumask);
+	}
+}
+
+int isst_get_process_ctdp(int cpu, int tdp_level, struct isst_pkg_ctdp *pkg_dev)
+{
+	int i, ret;
+
+	if (pkg_dev->processed)
+		return 0;
+
+	ret = isst_get_ctdp_levels(cpu, pkg_dev);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu: %d ctdp enable:%d current level: %d levels:%d\n",
+		     cpu, pkg_dev->enabled, pkg_dev->current_level,
+		     pkg_dev->levels);
+
+	for (i = 0; i <= pkg_dev->levels; ++i) {
+		struct isst_pkg_ctdp_level_info *ctdp_level;
+
+		if (tdp_level != 0xff && i != tdp_level)
+			continue;
+
+		debug_printf("cpu:%d Get Information for TDP level:%d\n", cpu,
+			     i);
+		ctdp_level = &pkg_dev->ctdp_level[i];
+
+		ctdp_level->processed = 1;
+		ctdp_level->level = i;
+		ctdp_level->control_cpu = cpu;
+		ctdp_level->pkg_id = get_physical_package_id(cpu);
+		ctdp_level->die_id = get_physical_die_id(cpu);
+
+		ret = isst_get_ctdp_control(cpu, i, ctdp_level);
+		if (ret)
+			return ret;
+
+		ret = isst_get_tdp_info(cpu, i, ctdp_level);
+		if (ret)
+			return ret;
+
+		ret = isst_get_pwr_info(cpu, i, ctdp_level);
+		if (ret)
+			return ret;
+
+		ret = isst_get_tjmax_info(cpu, i, ctdp_level);
+		if (ret)
+			return ret;
+
+		ctdp_level->core_cpumask_size =
+			alloc_cpu_set(&ctdp_level->core_cpumask);
+		ret = isst_get_coremask_info(cpu, i, ctdp_level);
+		if (ret)
+			return ret;
+
+		ret = isst_get_get_trl(cpu, i, 0,
+				       ctdp_level->trl_sse_active_cores);
+		if (ret)
+			return ret;
+
+		ret = isst_get_get_trl(cpu, i, 1,
+				       ctdp_level->trl_avx_active_cores);
+		if (ret)
+			return ret;
+
+		ret = isst_get_get_trl(cpu, i, 2,
+				       ctdp_level->trl_avx_512_active_cores);
+		if (ret)
+			return ret;
+
+		if (ctdp_level->pbf_support) {
+			ret = isst_get_pbf_info(cpu, i, &ctdp_level->pbf_info);
+			if (!ret)
+				ctdp_level->pbf_found = 1;
+		}
+
+		if (ctdp_level->fact_support) {
+			ret = isst_get_fact_info(cpu, i,
+						 &ctdp_level->fact_info);
+			if (ret)
+				return ret;
+		}
+	}
+
+	pkg_dev->processed = 1;
+
+	return 0;
+}
+
+int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
+{
+	unsigned int req, resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PM_QOS_CONFIG resp:%x\n", cpu, resp);
+
+	req = resp;
+
+	if (enable_clos)
+		req = req | BIT(1);
+	else
+		req = req & ~BIT(1);
+
+	if (priority_type)
+		req = req | BIT(2);
+	else
+		req = req & ~BIT(2);
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG,
+				     BIT(MBOX_CMD_WRITE_BIT), req, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PM_QOS_CONFIG priority type:%d req:%x\n", cpu,
+		     priority_type, req);
+
+	return 0;
+}
+
+int isst_pm_get_clos(int cpu, int clos, struct isst_clos_config *clos_config)
+{
+	unsigned int resp;
+	int ret;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_CLOS, clos, 0,
+				     &resp);
+	if (ret)
+		return ret;
+
+	clos_config->pkg_id = get_physical_package_id(cpu);
+	clos_config->die_id = get_physical_die_id(cpu);
+
+	clos_config->epp = resp & 0x0f;
+	clos_config->clos_prop_prio = (resp >> 4) & 0x0f;
+	clos_config->clos_min = (resp >> 8) & 0xff;
+	clos_config->clos_max = (resp >> 16) & 0xff;
+	clos_config->clos_desired = (resp >> 24) & 0xff;
+
+	return 0;
+}
+
+int isst_set_clos(int cpu, int clos, struct isst_clos_config *clos_config)
+{
+	unsigned int req, resp;
+	unsigned int param;
+	int ret;
+
+	req = clos_config->epp & 0x0f;
+	req |= (clos_config->clos_prop_prio & 0x0f) << 4;
+	req |= (clos_config->clos_min & 0xff) << 8;
+	req |= (clos_config->clos_max & 0xff) << 16;
+	req |= (clos_config->clos_desired & 0xff) << 24;
+
+	param = BIT(MBOX_CMD_WRITE_BIT) | clos;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_CLOS, param, req,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PM_CLOS param:%x req:%x\n", cpu, param, req);
+
+	return 0;
+}
+
+int isst_clos_get_assoc_status(int cpu, int *clos_id)
+{
+	unsigned int resp;
+	unsigned int param;
+	int core_id, ret;
+
+	core_id = find_phy_core_num(cpu);
+	param = core_id;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PQR_ASSOC, param, 0,
+				     &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PQR_ASSOC param:%x resp:%x\n", cpu, param,
+		     resp);
+	*clos_id = (resp >> 16) & 0x03;
+
+	return 0;
+}
+
+int isst_clos_associate(int cpu, int clos_id)
+{
+	unsigned int req, resp;
+	unsigned int param;
+	int core_id, ret;
+
+	req = (clos_id & 0x03) << 16;
+	core_id = find_phy_core_num(cpu);
+	param = BIT(MBOX_CMD_WRITE_BIT) | core_id;
+
+	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PQR_ASSOC, param,
+				     req, &resp);
+	if (ret)
+		return ret;
+
+	debug_printf("cpu:%d CLOS_PQR_ASSOC param:%x req:%x\n", cpu, param,
+		     req);
+
+	return 0;
+}
