commit 873e391ff33e742189cd7da5ed4bfd941e83edd7
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue May 19 16:28:34 2020 -0700

    tools/power/x86/intel-speed-select: Fix invalid core mask
    
    The core mask display is wrong in some cases. This is showing more
    cpus than the mask has. This is because mask is 64 bit but it used
    with BIT() macro to get the presence of CPU which doesn't support
    unsigned long long. Added a new macro for BIT_ULL and use that
    to get the presence of a CPU.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 8b99e403e68c..9f68f51ca652 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -653,7 +653,7 @@ void set_cpu_mask_from_punit_coremask(int cpu, unsigned long long core_mask,
 	pkg_id = get_physical_package_id(cpu);
 
 	for (i = 0; i < 64; ++i) {
-		if (core_mask & BIT(i)) {
+		if (core_mask & BIT_ULL(i)) {
 			int j;
 
 			for (j = 0; j < topo_max_cpus; ++j) {

commit e16ea66365e43d5e3b338ba8d406dec38c6c3d39
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri May 15 12:46:37 2020 -0700

    tools/power/x86/intel-speed-select: Increase CPU count
    
    Increase CPU count so that more than 64 is supported in one request.
    
    For example:
    sudo ./intel-speed-select -d --cpu 0-66 core-power assoc -clos 0
    The above command stops at 63. With this change, it can support more
    CPU numbers from 0-255.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 4cccabb226db..8b99e403e68c 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -25,7 +25,7 @@ static FILE *outf;
 static int cpu_model;
 static int cpu_stepping;
 
-#define MAX_CPUS_IN_ONE_REQ 64
+#define MAX_CPUS_IN_ONE_REQ 256
 static short max_target_cpus;
 static unsigned short target_cpus[MAX_CPUS_IN_ONE_REQ];
 

commit b14cd9d5981a26bdfddf2bd7efe6ed5137de0289
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri May 8 11:44:58 2020 -0700

    tools/power/x86/intel-speed-select: Update version
    
    Update version to include 5.8 series enhancements.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index aec0c48b77c9..4cccabb226db 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -15,7 +15,7 @@ struct process_cmd_struct {
 	int arg;
 };
 
-static const char *version_str = "v1.3";
+static const char *version_str = "v1.4";
 static const int supported_api_ver = 1;
 static struct isst_if_platform_info isst_platform_info;
 static char *progname;

commit 7983ed6f86d67c6bd5e1940b059ce76241f474c5
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri May 1 00:51:59 2020 +0300

    tools/power/x86/intel-speed-select: Enable clos for turbo-freq enable
    
    turbo-freq enable, requires clos enable. So this is a two step process,
    when "-a" option is used. This is causing confusion to users. So enable
    clos by default for turbo-freq enable.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2e64b9b6eb2e..aec0c48b77c9 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1816,7 +1816,7 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		goto disp_results;
 	}
 
-	if (auto_mode && status) {
+	if (status) {
 		ret = isst_pm_qos_config(cpu, 1, 1);
 		if (ret)
 			goto disp_results;

commit 28c59ae6965ca0626e3150e2f2863e0f0c810ed7
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Apr 2 14:07:32 2020 -0400

    tools/power/x86/intel-speed-select: Fix CLX-N package information output
    
    On CLX-N the perf-profile output is missing the package, die, and cpu
    output.  On CLX-N the pkg_dev struct will never be evaluated by the core
    code so pkg_dev.processed is always 0 and the package, die, and cpu
    information is never output.
    
    Set the pkg_dev.processed flag to 1 for CLX-N processors.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: andriy.shevchenko@linux.intel.com
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: platform-driver-x86@vger.kernel.org

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index d1ac57be0cbd..2e64b9b6eb2e 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1169,6 +1169,7 @@ static void dump_clx_n_config_for_cpu(int cpu, void *arg1, void *arg2,
 
 		ctdp_level = &clx_n_pkg_dev.ctdp_level[0];
 		pbf_info = &ctdp_level->pbf_info;
+		clx_n_pkg_dev.processed = 1;
 		isst_ctdp_display_information(cpu, outf, tdp_level, &clx_n_pkg_dev);
 		free_cpu_set(ctdp_level->core_cpumask);
 		free_cpu_set(pbf_info->core_cpumask);

commit 3d904f066f0f8778780bf8ae67ad756a2f99858c
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Mar 20 10:50:17 2020 -0700

    tools/power/x86/intel-speed-select: Check support status before enable
    
    When turbo-freq or base-freq feature is not supported, the enable will
    fail. So first check support status and print error.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index b73763489410..d1ac57be0cbd 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1631,6 +1631,8 @@ static int set_pbf_core_power(int cpu)
 static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 			    void *arg4)
 {
+	struct isst_pkg_ctdp_level_info ctdp_level;
+	struct isst_pkg_ctdp pkg_dev;
 	int ret;
 	int status = *(int *)arg4;
 
@@ -1646,6 +1648,24 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		goto disp_result;
 	}
 
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get number of levels", 0, 0);
+		goto disp_result;
+	}
+
+	ret = isst_get_ctdp_control(cpu, pkg_dev.current_level, &ctdp_level);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get current level", 0, 0);
+		goto disp_result;
+	}
+
+	if (!ctdp_level.pbf_support) {
+		isst_display_error_info_message(1, "base-freq feature is not present at this level", 1, pkg_dev.current_level);
+		ret = -1;
+		goto disp_result;
+	}
+
 	if (auto_mode && status) {
 		ret = set_pbf_core_power(cpu);
 		if (ret)
@@ -1772,9 +1792,29 @@ static void dump_fact_config(int arg)
 static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 			     void *arg4)
 {
+	struct isst_pkg_ctdp_level_info ctdp_level;
+	struct isst_pkg_ctdp pkg_dev;
 	int ret;
 	int status = *(int *)arg4;
 
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get number of levels", 0, 0);
+		goto disp_results;
+	}
+
+	ret = isst_get_ctdp_control(cpu, pkg_dev.current_level, &ctdp_level);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get current level", 0, 0);
+		goto disp_results;
+	}
+
+	if (!ctdp_level.fact_support) {
+		isst_display_error_info_message(1, "turbo-freq feature is not present at this level", 1, pkg_dev.current_level);
+		ret = -1;
+		goto disp_results;
+	}
+
 	if (auto_mode && status) {
 		ret = isst_pm_qos_config(cpu, 1, 1);
 		if (ret)

commit 9945a2479893682bee8ae46e2ce5f180d4f6b1b2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Mar 9 17:54:44 2020 +0900

    tools/power/x86/intel-speed-select: Fix a typo in error message
    
    This patch fix a spelling typo in error message.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index cd803a40ee40..b73763489410 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -831,7 +831,7 @@ int isst_send_msr_command(unsigned int cpu, unsigned int msr, int write,
 		msr_cmds.msr_cmd[0].data = *req_resp;
 
 	if (ioctl(fd, ISST_IF_MSR_COMMAND, &msr_cmds) == -1) {
-		perror("ISST_IF_MSR_COMMAD");
+		perror("ISST_IF_MSR_COMMAND");
 		fprintf(outf, "Error: msr_cmd cpu:%d msr:%x read_write:%d\n",
 			cpu, msr, write);
 	} else {

commit 1e46d1d59a6ca950a4ddccfea4c7e33455e10b27
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:38 2020 -0800

    tools/power/x86/intel-speed-select: Update version
    
    Fair number of changes including bug fixes done to change version.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 924cb871d6d2..cd803a40ee40 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -15,7 +15,7 @@ struct process_cmd_struct {
 	int arg;
 };
 
-static const char *version_str = "v1.2";
+static const char *version_str = "v1.3";
 static const int supported_api_ver = 1;
 static struct isst_if_platform_info isst_platform_info;
 static char *progname;

commit 4a9603534aff2bc6e36f36144eb25731a888e835
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:35 2020 -0800

    tools/power/x86/intel-speed-select: Print friendly warning for bad command line
    
    When user specifies invalid option, display "Unknown Option: ignore",
    instead of "no match". Also display error for garbage on the command
    line.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2a81fb881f04..924cb871d6d2 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -2400,9 +2400,12 @@ static void parse_cmd_args(int argc, int start, char **argv)
 			}
 			break;
 		default:
-			printf("no match\n");
+			printf("Unknown option: ignore\n");
 		}
 	}
+
+	if (argv[optind])
+		printf("Garbage at the end of command: ignore\n");
 }
 
 static void isst_help(void)

commit b86639e1957fe09362a1681b8a061aafacd1b486
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:34 2020 -0800

    tools/power/x86/intel-speed-select: Fix avx options for turbo-freq feature
    
    Specifying "avx2" and "avx512" option for display filter doesn't work
    with short option "-r", only works with --try-type. Also compare full
    6 characters for "avx512" string.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index a44ec2f76f52..2a81fb881f04 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -2329,7 +2329,7 @@ static void parse_cmd_args(int argc, int start, char **argv)
 	option_index = start;
 
 	optind = start + 1;
-	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:hoa",
+	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:r:hoa",
 				  long_options, &option_index)) != -1) {
 		switch (opt) {
 		case 'a':
@@ -2355,7 +2355,7 @@ static void parse_cmd_args(int argc, int start, char **argv)
 				fact_avx = 0x01;
 			} else if (!strncmp(optarg, "avx2", 4)) {
 				fact_avx = 0x02;
-			} else if (!strncmp(optarg, "avx512", 4)) {
+			} else if (!strncmp(optarg, "avx512", 6)) {
 				fact_avx = 0x04;
 			} else {
 				fprintf(outf, "Invalid sse,avx options\n");

commit 7fc9fefd994b3b0c6c4dc204a993f1a4c451f4d4
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:33 2020 -0800

    tools/power/x86/intel-speed-select: Improve CLX commands
    
    CLX doesn't have capability to change the feature in the hardware, but
    this acts as "--auto | -a" option. So even if user didn't specify the
    option, use this as --auto | -a to set cpufreq scaling frequency limits.
    
    Also remove perror with debug_printf as they don't bring any value.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 386791aaeca1..a44ec2f76f52 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1162,7 +1162,7 @@ static void dump_clx_n_config_for_cpu(int cpu, void *arg1, void *arg2,
 
 	ret = clx_n_config(cpu);
 	if (ret) {
-		perror("isst_get_process_ctdp");
+		debug_printf("clx_n_config failed");
 	} else {
 		struct isst_pkg_ctdp_level_info *ctdp_level;
 		struct isst_pbf_info *pbf_info;
@@ -1419,7 +1419,7 @@ static int set_clx_pbf_cpufreq_scaling_min_max(int cpu)
 
 	ret = clx_n_config(cpu);
 	if (ret) {
-		perror("set_clx_pbf_cpufreq_scaling_min_max");
+		debug_printf("cpufreq_scaling_min_max failed for CLX");
 		return ret;
 	}
 
@@ -1635,17 +1635,13 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int status = *(int *)arg4;
 
 	if (is_clx_n_platform()) {
+		ret = 0;
 		if (status) {
-			ret = 0;
-			if (auto_mode)
-				set_clx_pbf_cpufreq_scaling_min_max(cpu);
+			set_clx_pbf_cpufreq_scaling_min_max(cpu);
 
 		} else {
-			ret = -1;
-			if (auto_mode) {
-				set_scaling_max_to_cpuinfo_max(cpu);
-				set_scaling_min_to_cpuinfo_min(cpu);
-			}
+			set_scaling_max_to_cpuinfo_max(cpu);
+			set_scaling_min_to_cpuinfo_min(cpu);
 		}
 		goto disp_result;
 	}

commit 070fdea13d4ba3ba6ae5a239fe334947921a1b9f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:32 2020 -0800

    tools/power/x86/intel-speed-select: Show error for invalid CPUs in the options
    
    When --cpu or -c is used to specify target CPUs and non of them are valid,
    display error.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 7a8a315ac8d1..386791aaeca1 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -425,7 +425,7 @@ static void for_each_online_target_cpu_in_set(
 	void (*callback)(int, void *, void *, void *, void *), void *arg1,
 	void *arg2, void *arg3, void *arg4)
 {
-	int i;
+	int i, found = 0;
 
 	for (i = 0; i < topo_max_cpus; ++i) {
 		int online;
@@ -439,9 +439,14 @@ static void for_each_online_target_cpu_in_set(
 			online =
 				1; /* online entry for CPU 0 needs some special configs */
 
-		if (online && callback)
+		if (online && callback) {
 			callback(i, arg1, arg2, arg3, arg4);
+			found = 1;
+		}
 	}
+
+	if (!found)
+		fprintf(stderr, "No valid CPU in the list\n");
 }
 
 #define BITMASK_SIZE 32

commit fe6fb2165ade451d7a354787a8e4f00fa5bd3e44
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:31 2020 -0800

    tools/power/x86/intel-speed-select: Improve core-power result and error display
    
    This change adds improved error display and handling for commands related
    to core-power feature. The changes include:
    - Replace perror with helpful error message
    - Use ordered priority for SKX based platform by default as the
    proportional priority is not supported
    - Don't show weight and epp in help and also give error when user
    tries to set them in SKX based platforms
    - Range check for epp and weights and display error
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2ab902c18bcc..7a8a315ac8d1 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1361,7 +1361,7 @@ static int set_clos_param(int cpu, int clos, int epp, int wt, int min, int max)
 
 	ret = isst_pm_get_clos(cpu, clos, &clos_config);
 	if (ret) {
-		perror("isst_pm_get_clos");
+		isst_display_error_info_message(1, "isst_pm_get_clos failed", 0, 0);
 		return ret;
 	}
 	clos_config.clos_min = min;
@@ -1370,7 +1370,7 @@ static int set_clos_param(int cpu, int clos, int epp, int wt, int min, int max)
 	clos_config.clos_prop_prio = wt;
 	ret = isst_set_clos(cpu, clos, &clos_config);
 	if (ret) {
-		perror("isst_pm_set_clos");
+		isst_display_error_info_message(1, "isst_set_clos failed", 0, 0);
 		return ret;
 	}
 
@@ -1577,7 +1577,7 @@ static int set_core_priority_and_min(int cpu, int mask_size,
 		debug_printf("Associate cpu: %d clos: %d\n", i, clos);
 		ret = isst_clos_associate(i, clos);
 		if (ret) {
-			perror("isst_clos_associate");
+			isst_display_error_info_message(1, "isst_clos_associate failed", 0, 0);
 			return ret;
 		}
 	}
@@ -1593,14 +1593,14 @@ static int set_pbf_core_power(int cpu)
 
 	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
 	if (ret) {
-		perror("isst_get_ctdp_levels");
+		debug_printf("isst_get_ctdp_levels failed");
 		return ret;
 	}
 	debug_printf("Current_level: %d\n", pkg_dev.current_level);
 
 	ret = isst_get_pbf_info(cpu, pkg_dev.current_level, &pbf_info);
 	if (ret) {
-		perror("isst_get_pbf_info");
+		debug_printf("isst_get_pbf_info failed");
 		return ret;
 	}
 	debug_printf("p1_high: %d p1_low: %d\n", pbf_info.p1_high,
@@ -1610,13 +1610,13 @@ static int set_pbf_core_power(int cpu)
 					pbf_info.core_cpumask,
 					pbf_info.p1_high, pbf_info.p1_low);
 	if (ret) {
-		perror("set_core_priority_and_min");
+		debug_printf("set_core_priority_and_min failed");
 		return ret;
 	}
 
 	ret = isst_pm_qos_config(cpu, 1, 1);
 	if (ret) {
-		perror("isst_pm_qos_config");
+		debug_printf("isst_pm_qos_config failed");
 		return ret;
 	}
 
@@ -1666,7 +1666,7 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	}
 
 	if (auto_mode && !status)
-		isst_pm_qos_config(cpu, 0, 0);
+		isst_pm_qos_config(cpu, 0, 1);
 
 disp_result:
 	if (status)
@@ -1933,9 +1933,12 @@ static void enable_clos_qos_config(int cpu, void *arg1, void *arg2, void *arg3,
 	int ret;
 	int status = *(int *)arg4;
 
+	if (is_skx_based_platform())
+		clos_priority_type = 1;
+
 	ret = isst_pm_qos_config(cpu, status, clos_priority_type);
 	if (ret)
-		perror("isst_pm_qos_config");
+		isst_display_error_info_message(1, "isst_pm_qos_config failed", 0, 0);
 
 	if (status)
 		isst_display_result(cpu, outf, "core-power", "enable",
@@ -1953,9 +1956,11 @@ static void set_clos_enable(int arg)
 		if (enable) {
 			fprintf(stderr,
 				"Enable core-power for a package/die\n");
-			fprintf(stderr,
-				"\tClos Enable: Specify priority type with [--priority|-p]\n");
-			fprintf(stderr, "\t\t 0: Proportional, 1: Ordered\n");
+			if (!is_skx_based_platform()) {
+				fprintf(stderr,
+					"\tClos Enable: Specify priority type with [--priority|-p]\n");
+				fprintf(stderr, "\t\t 0: Proportional, 1: Ordered\n");
+			}
 		} else {
 			fprintf(stderr,
 				"Disable core-power: [No command arguments are required]\n");
@@ -1986,7 +1991,7 @@ static void dump_clos_config_for_cpu(int cpu, void *arg1, void *arg2,
 
 	ret = isst_pm_get_clos(cpu, current_clos, &clos_config);
 	if (ret)
-		perror("isst_pm_get_clos");
+		isst_display_error_info_message(1, "isst_pm_get_clos failed", 0, 0);
 	else
 		isst_clos_display_information(cpu, outf, current_clos,
 					      &clos_config);
@@ -2002,7 +2007,8 @@ static void dump_clos_config(int arg)
 		exit(0);
 	}
 	if (current_clos < 0 || current_clos > 3) {
-		fprintf(stderr, "Invalid clos id\n");
+		isst_display_error_info_message(1, "Invalid clos id\n", 0, 0);
+		isst_ctdp_display_information_end(outf);
 		exit(0);
 	}
 
@@ -2023,7 +2029,7 @@ static void get_clos_info_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_clos_get_clos_information(cpu, &enable, &prio_type);
 	if (ret)
-		perror("isst_clos_get_info");
+		isst_display_error_info_message(1, "isst_clos_get_info failed", 0, 0);
 	else {
 		int cp_state, cp_cap;
 
@@ -2069,7 +2075,7 @@ static void set_clos_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	clos_config.clos_desired = clos_desired;
 	ret = isst_set_clos(cpu, current_clos, &clos_config);
 	if (ret)
-		perror("isst_set_clos");
+		isst_display_error_info_message(1, "isst_set_clos failed", 0, 0);
 	else
 		isst_display_result(cpu, outf, "core-power", "config", ret);
 }
@@ -2081,26 +2087,27 @@ static void set_clos_config(int arg)
 			"Set core-power configuration for one of the four clos ids\n");
 		fprintf(stderr,
 			"\tSpecify targeted clos id with [--clos|-c]\n");
-		fprintf(stderr, "\tSpecify clos EPP with [--epp|-e]\n");
-		fprintf(stderr,
-			"\tSpecify clos Proportional Priority [--weight|-w]\n");
+		if (!is_skx_based_platform()) {
+			fprintf(stderr, "\tSpecify clos EPP with [--epp|-e]\n");
+			fprintf(stderr,
+				"\tSpecify clos Proportional Priority [--weight|-w]\n");
+		}
 		fprintf(stderr, "\tSpecify clos min in MHz with [--min|-n]\n");
 		fprintf(stderr, "\tSpecify clos max in MHz with [--max|-m]\n");
-		fprintf(stderr, "\tSpecify clos desired in MHz with [--desired|-d]\n");
 		exit(0);
 	}
 
 	if (current_clos < 0 || current_clos > 3) {
-		fprintf(stderr, "Invalid clos id\n");
+		isst_display_error_info_message(1, "Invalid clos id\n", 0, 0);
 		exit(0);
 	}
-	if (clos_epp < 0 || clos_epp > 0x0F) {
-		fprintf(stderr, "clos epp is not specified, default: 0\n");
+	if (!is_skx_based_platform() && (clos_epp < 0 || clos_epp > 0x0F)) {
+		fprintf(stderr, "clos epp is not specified or invalid, default: 0\n");
 		clos_epp = 0;
 	}
-	if (clos_prop_prio < 0 || clos_prop_prio > 0x0F) {
+	if (!is_skx_based_platform() && (clos_prop_prio < 0 || clos_prop_prio > 0x0F)) {
 		fprintf(stderr,
-			"clos frequency weight is not specified, default: 0\n");
+			"clos frequency weight is not specified or invalid, default: 0\n");
 		clos_prop_prio = 0;
 	}
 	if (clos_min < 0) {
@@ -2108,11 +2115,11 @@ static void set_clos_config(int arg)
 		clos_min = 0;
 	}
 	if (clos_max < 0) {
-		fprintf(stderr, "clos max is not specified, default: 25500 MHz\n");
+		fprintf(stderr, "clos max is not specified, default: Max frequency (ratio 0xff)\n");
 		clos_max = 0xff;
 	}
-	if (clos_desired < 0) {
-		fprintf(stderr, "clos desired is not specified, default: 0\n");
+	if (clos_desired) {
+		fprintf(stderr, "clos desired is not supported on this platform\n");
 		clos_desired = 0x00;
 	}
 
@@ -2133,7 +2140,7 @@ static void set_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_clos_associate(cpu, current_clos);
 	if (ret)
-		perror("isst_clos_associate");
+		debug_printf("isst_clos_associate failed");
 	else
 		isst_display_result(cpu, outf, "core-power", "assoc", ret);
 }
@@ -2152,15 +2159,14 @@ static void set_clos_assoc(int arg)
 	}
 
 	if (current_clos < 0 || current_clos > 3) {
-		fprintf(stderr, "Invalid clos id\n");
+		isst_display_error_info_message(1, "Invalid clos id\n", 0, 0);
 		exit(0);
 	}
 	if (max_target_cpus)
 		for_each_online_target_cpu_in_set(set_clos_assoc_for_cpu, NULL,
 						  NULL, NULL, NULL);
 	else {
-		fprintf(stderr,
-			"Invalid target cpu. Specify with [-c|--cpu]\n");
+		isst_display_error_info_message(1, "Invalid target cpu. Specify with [-c|--cpu]", 0, 0);
 	}
 }
 
@@ -2171,7 +2177,7 @@ static void get_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_clos_get_assoc_status(cpu, &clos);
 	if (ret)
-		perror("isst_clos_get_assoc_status");
+		isst_display_error_info_message(1, "isst_clos_get_assoc_status failed", 0, 0);
 	else
 		isst_clos_display_assoc_information(cpu, outf, clos);
 }
@@ -2185,8 +2191,7 @@ static void get_clos_assoc(int arg)
 	}
 
 	if (!max_target_cpus) {
-		fprintf(stderr,
-			"Invalid target cpu. Specify with [-c|--cpu]\n");
+		isst_display_error_info_message(1, "Invalid target cpu. Specify with [-c|--cpu]", 0, 0);
 		exit(0);
 	}
 
@@ -2366,6 +2371,10 @@ static void parse_cmd_args(int argc, int start, char **argv)
 			break;
 		case 'e':
 			clos_epp = atoi(optarg);
+			if (is_skx_based_platform()) {
+				isst_display_error_info_message(1, "epp can't be specified on this platform", 0, 0);
+				exit(0);
+			}
 			break;
 		case 'n':
 			clos_min = atoi(optarg);
@@ -2377,9 +2386,17 @@ static void parse_cmd_args(int argc, int start, char **argv)
 			break;
 		case 'p':
 			clos_priority_type = atoi(optarg);
+			if (is_skx_based_platform() && !clos_priority_type) {
+				isst_display_error_info_message(1, "Invalid clos priority type: proportional for this platform", 0, 0);
+				exit(0);
+			}
 			break;
 		case 'w':
 			clos_prop_prio = atoi(optarg);
+			if (is_skx_based_platform()) {
+				isst_display_error_info_message(1, "weight can't be specified on this platform", 0, 0);
+				exit(0);
+			}
 			break;
 		default:
 			printf("no match\n");

commit 95f8e5694580cbf80599c6a5874cf4fba8b17141
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:30 2020 -0800

    tools/power/x86/intel-speed-select: Kernel interface error handling
    
    Treat a case when mailbox/mmio command can't be handled by the kernel
    drivers when the module is removed or send a command which no driver can
    handle. In this case ENOTTY result is returned, so print error.
    
    Also when the isst_if_mmio module is removed, we can't send CLOS message
    messages via Mailbox on non SKX based platforms. When this module is
    removed,  isst_platform_info.mmio_supported is set to 0. So it can't be
    used as a condition to send via mailbox. Here replace check for Skylake
    based platform to send via mailbox, other platforms can't use mailbox in
    lieu of MMIO.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 48915470c572..2ab902c18bcc 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -95,6 +95,14 @@ int is_clx_n_platform(void)
 	return 0;
 }
 
+int is_skx_based_platform(void)
+{
+	if (cpu_model == 0x55)
+		return 1;
+
+	return 0;
+}
+
 static int update_cpu_model(void)
 {
 	unsigned int ebx, ecx, edx;
@@ -695,7 +703,11 @@ static int isst_send_mmio_command(unsigned int cpu, unsigned int reg, int write,
 	}
 
 	if (ioctl(fd, cmd, &io_regs) == -1) {
-		perror("ISST_IF_IO_CMD");
+		if (errno == ENOTTY) {
+			perror("ISST_IF_IO_COMMAND\n");
+			fprintf(stderr, "Check presence of kernel modules: isst_if_mmio\n");
+			exit(0);
+		}
 		fprintf(outf, "Error: mmio_cmd cpu:%d reg:%x read_write:%x\n",
 			cpu, reg, write);
 	} else {
@@ -724,7 +736,7 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 		"mbox_send: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
 		cpu, command, sub_command, parameter, req_data);
 
-	if (isst_platform_info.mmio_supported && command == CONFIG_CLOS &&
+	if (!is_skx_based_platform() && command == CONFIG_CLOS &&
 	    sub_command != CLOS_PM_QOS_CONFIG) {
 		unsigned int value;
 		int write = 0;
@@ -774,10 +786,14 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 		err(-1, "%s open failed", pathname);
 
 	if (ioctl(fd, ISST_IF_MBOX_COMMAND, &mbox_cmds) == -1) {
-		perror("ISST_IF_MBOX_COMMAND");
-		fprintf(outf,
-			"Error: mbox_cmd cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
-			cpu, command, sub_command, parameter, req_data);
+		if (errno == ENOTTY) {
+			perror("ISST_IF_MBOX_COMMAND\n");
+			fprintf(stderr, "Check presence of kernel modules: isst_if_mbox_pci or isst_if_mbox_msr\n");
+			exit(0);
+		}
+		debug_printf(
+			"Error: mbox_cmd cpu:%d command:%x sub_command:%x parameter:%x req_data:%x errorno:%d\n",
+			cpu, command, sub_command, parameter, req_data, errno);
 		return -1;
 	} else {
 		*resp = mbox_cmds.mbox_cmd[0].resp_data;

commit a9fd6ae739ef9624f9017df08edf0970c7d170e2
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:29 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for turbo-freq feature
    
    This change adds improved error display and handling for commands related
    to turbo-freq feature. The changes include:
    - Replace perror/fprintf with helpful error message
    - Error for not specifying TDP level when required
    - Show error for invalid bucket number
    - Show message to enable core-power before enabling turbo-freq feature
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 95602f98a138..48915470c572 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1712,12 +1712,15 @@ static void dump_fact_config_for_cpu(int cpu, void *arg1, void *arg2,
 	struct isst_fact_info fact_info;
 	int ret;
 
-	ret = isst_get_fact_info(cpu, tdp_level, &fact_info);
-	if (ret)
-		perror("isst_get_fact_bucket_info");
-	else
+	ret = isst_get_fact_info(cpu, tdp_level, fact_bucket, &fact_info);
+	if (ret) {
+		isst_display_error_info_message(1, "Failed to get turbo-freq info at this level", 1, tdp_level);
+		isst_ctdp_display_information_end(outf);
+		exit(1);
+	} else {
 		isst_fact_display_information(cpu, outf, tdp_level, fact_bucket,
 					      fact_avx, &fact_info);
+	}
 }
 
 static void dump_fact_config(int arg)
@@ -1735,7 +1738,7 @@ static void dump_fact_config(int arg)
 	}
 
 	if (tdp_level == 0xff) {
-		fprintf(outf, "Invalid command: specify tdp_level\n");
+		isst_display_error_info_message(1, "Invalid command: specify tdp_level\n", 0, 0);
 		exit(1);
 	}
 
@@ -1763,7 +1766,7 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_set_pbf_fact_status(cpu, 0, status);
 	if (ret) {
-		perror("isst_set_fact");
+		debug_printf("isst_set_pbf_fact_status failed");
 		if (auto_mode)
 			isst_pm_qos_config(cpu, 0, 0);
 

commit 39bae0fce48f6431ceb3ab9cff91cb749c736c48
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:28 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for base-freq feature
    
    This change adds improved error display and handling for commands related
    to base-freq feature. The changes include:
    - Replace perror/fprintf with helpful error message
    - Error for not specifying TDP level when required
    - For CLX show help which shows limitation
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 362a352e6266..95602f98a138 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1276,7 +1276,7 @@ static void clx_n_dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2,
 
 	ret = clx_n_config(cpu);
 	if (ret) {
-		perror("isst_get_process_ctdp");
+		isst_display_error_info_message(1, "clx_n_config failed", 0, 0);
 	} else {
 		struct isst_pkg_ctdp_level_info *ctdp_level;
 		struct isst_pbf_info *pbf_info;
@@ -1297,7 +1297,9 @@ static void dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_get_pbf_info(cpu, tdp_level, &pbf_info);
 	if (ret) {
-		perror("isst_get_pbf_info");
+		isst_display_error_info_message(1, "Failed to get base-freq info at this level", 1, tdp_level);
+		isst_ctdp_display_information_end(outf);
+		exit(1);
 	} else {
 		isst_pbf_display_information(cpu, outf, tdp_level, &pbf_info);
 		isst_get_pbf_info_complete(&pbf_info);
@@ -1317,7 +1319,7 @@ static void dump_pbf_config(int arg)
 	}
 
 	if (tdp_level == 0xff) {
-		fprintf(outf, "Invalid command: specify tdp_level\n");
+		isst_display_error_info_message(1, "Invalid command: specify tdp_level", 0, 0);
 		exit(1);
 	}
 
@@ -1635,7 +1637,7 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 	ret = isst_set_pbf_fact_status(cpu, 1, status);
 	if (ret) {
-		perror("isst_set_pbf");
+		debug_printf("isst_set_pbf_fact_status failed");
 		if (auto_mode)
 			isst_pm_qos_config(cpu, 0, 0);
 	} else {
@@ -1667,10 +1669,25 @@ static void set_pbf_enable(int arg)
 		if (enable) {
 			fprintf(stderr,
 				"Enable Intel Speed Select Technology base frequency feature\n");
+			if (is_clx_n_platform()) {
+				fprintf(stderr,
+					"\tOn this platform this command doesn't enable feature in the hardware.\n");
+				fprintf(stderr,
+					"\tIt updates the cpufreq scaling_min_freq to match cpufreq base_frequency.\n");
+				exit(0);
+
+			}
 			fprintf(stderr,
 				"\tOptional Arguments: -a|--auto : Use priority of cores to set core-power associations\n");
 		} else {
 
+			if (is_clx_n_platform()) {
+				fprintf(stderr,
+					"\tOn this platform this command doesn't disable feature in the hardware.\n");
+				fprintf(stderr,
+					"\tIt updates the cpufreq scaling_min_freq to match cpuinfo_min_freq\n");
+				exit(0);
+			}
 			fprintf(stderr,
 				"Disable Intel Speed Select Technology base frequency feature\n");
 			fprintf(stderr,

commit 3d1a8579813eff7d1d4b2f186bd718877407cfdb
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:27 2020 -0800

    tools/power/x86/intel-speed-select: Improve output of perf-profile commands
    
    Improve output of perf-profile commands:
    get-config-enabled
    get-lock-status
    
    Instead of showing 0/1, show meaningful strings. Also show error when
    command is failed.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 75c8e1a933ef..362a352e6266 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -953,6 +953,7 @@ static void isst_print_platform_information(void)
 	exit(0);
 }
 
+static char *local_str0, *local_str1;
 static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 				 void *arg4)
 {
@@ -962,13 +963,14 @@ static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	fn_ptr = arg1;
 	ret = fn_ptr(cpu, arg2);
 	if (ret)
-		perror("get_tdp_*");
+		isst_display_error_info_message(1, "get_tdp_* failed", 0, 0);
 	else
 		isst_ctdp_display_core_info(cpu, outf, arg3,
-					    *(unsigned int *)arg4);
+					    *(unsigned int *)arg4,
+					    local_str0, local_str1);
 }
 
-#define _get_tdp_level(desc, suffix, object, help)                                \
+#define _get_tdp_level(desc, suffix, object, help, str0, str1)			\
 	static void get_tdp_##object(int arg)                                    \
 	{                                                                         \
 		struct isst_pkg_ctdp ctdp;                                        \
@@ -979,6 +981,8 @@ static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 				help);                                            \
 			exit(0);                                                  \
 		}                                                                 \
+		local_str0 = str0;						  \
+		local_str1 = str1;						  \
 		isst_ctdp_display_information_start(outf);                        \
 		if (max_target_cpus)                                              \
 			for_each_online_target_cpu_in_set(                        \
@@ -992,12 +996,12 @@ static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		isst_ctdp_display_information_end(outf);                          \
 	}
 
-_get_tdp_level("get-config-levels", levels, levels, "TDP levels");
-_get_tdp_level("get-config-version", levels, version, "TDP version");
-_get_tdp_level("get-config-enabled", levels, enabled, "TDP enable status");
+_get_tdp_level("get-config-levels", levels, levels, "Max TDP level", NULL, NULL);
+_get_tdp_level("get-config-version", levels, version, "TDP version", NULL, NULL);
+_get_tdp_level("get-config-enabled", levels, enabled, "perf-profile enable status", "disabled", "enabled");
 _get_tdp_level("get-config-current_level", levels, current_level,
-	       "Current TDP Level");
-_get_tdp_level("get-lock-status", levels, locked, "TDP lock status");
+	       "Current TDP Level", NULL, NULL);
+_get_tdp_level("get-lock-status", levels, locked, "TDP lock status", "unlocked", "locked");
 
 struct isst_pkg_ctdp clx_n_pkg_dev;
 

commit 68e2f109717b55daeec0565dda219b43bebcbb1d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:26 2020 -0800

    tools/power/x86/intel-speed-select: Enhance help for core-power assoc
    
    Enhance help to specify CPU and clos by an example.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 4230a19664d3..75c8e1a933ef 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -2104,6 +2104,10 @@ static void set_clos_assoc(int arg)
 		fprintf(stderr, "Associate a clos id to a CPU\n");
 		fprintf(stderr,
 			"\tSpecify targeted clos id with [--clos|-c]\n");
+		fprintf(stderr,
+			"\tFor example to associate clos 1 to CPU 0: issue\n");
+		fprintf(stderr,
+			"\tintel-speed-select --cpu 0 core-power assoc --clos 1\n");
 		exit(0);
 	}
 

commit ac9d05ea4cfb99dd24767f2510ca526282fffa13
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:23 2020 -0800

    tools/power/x86/intel-speed-select: Improve error display for perf-profile feature
    
    This change adds improved error display and handling for commands related
    to perf-profile feature. The changes include:
    - When invalid TDP level is passed. display error and exit
    - Replace perror with helpful error message
    - Show error when TDP level can't be set
    - Print error when information can't be read for a level
    - Validate user options for invalid level
    - Display error for TDP lock status
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 360fa00f9c7a..4230a19664d3 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1130,6 +1130,11 @@ static void dump_clx_n_config_for_cpu(int cpu, void *arg1, void *arg2,
 {
 	int ret;
 
+	if (tdp_level != 0xff && tdp_level != 0) {
+		isst_display_error_info_message(1, "Invalid level", 1, tdp_level);
+		exit(0);
+	}
+
 	ret = clx_n_config(cpu);
 	if (ret) {
 		perror("isst_get_process_ctdp");
@@ -1154,7 +1159,9 @@ static void dump_isst_config_for_cpu(int cpu, void *arg1, void *arg2,
 	memset(&pkg_dev, 0, sizeof(pkg_dev));
 	ret = isst_get_process_ctdp(cpu, tdp_level, &pkg_dev);
 	if (ret) {
-		perror("isst_get_process_ctdp");
+		isst_display_error_info_message(1, "Failed to get perf-profile info on cpu", 1, cpu);
+		isst_ctdp_display_information_end(outf);
+		exit(1);
 	} else {
 		isst_ctdp_display_information(cpu, outf, tdp_level, &pkg_dev);
 		isst_get_process_ctdp_complete(cpu, &pkg_dev);
@@ -1197,9 +1204,11 @@ static void set_tdp_level_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int ret;
 
 	ret = isst_set_tdp_level(cpu, tdp_level);
-	if (ret)
-		perror("set_tdp_level_for_cpu");
-	else {
+	if (ret) {
+		isst_display_error_info_message(1, "Set TDP level failed", 0, 0);
+		isst_ctdp_display_information_end(outf);
+		exit(1);
+	} else {
 		isst_display_result(cpu, outf, "perf-profile", "set_tdp_level",
 				    ret);
 		if (force_online_offline) {
@@ -1237,11 +1246,13 @@ static void set_tdp_level(int arg)
 			"\t Arguments: -l|--level : Specify tdp level\n");
 		fprintf(stderr,
 			"\t Optional Arguments: -o | online : online/offline for the tdp level\n");
+		fprintf(stderr,
+			"\t  online/offline operation has limitations, refer to Linux hotplug documentation\n");
 		exit(0);
 	}
 
 	if (tdp_level == 0xff) {
-		fprintf(outf, "Invalid command: specify tdp_level\n");
+		isst_display_error_info_message(1, "Invalid command: specify tdp_level", 0, 0);
 		exit(1);
 	}
 	isst_ctdp_display_information_start(outf);

commit 87e115b3256c1c5a324ab495eab722c0ec7d5c34
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:22 2020 -0800

    tools/power/x86/intel-speed-select: Add an API for error/information print
    
    Add a common API which can be used to print all error and information
    messages. In this way a common format can be used.
    
    For json output an error index in suffixed to make unique error key.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 65110d06394f..360fa00f9c7a 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -69,6 +69,11 @@ struct cpu_topology {
 	short die_id;
 };
 
+FILE *get_output_file(void)
+{
+	return outf;
+}
+
 void debug_printf(const char *format, ...)
 {
 	va_list args;

commit 1ba148ae9e11324817685a8b13f5968c4bc1cbfd
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:21 2020 -0800

    tools/power/x86/intel-speed-select: Enhance --info option
    
    Add additional information, which will allow user to detect available
    features. This will allow users to check presence of features before
    continue to test.
    A sample output:
    
    $sudo ./intel-speed-select --info
    
    Intel(R) Speed Select Technology
    Executing on CPU model:85[0x55]
    Platform: API version : 1
    Platform: Driver version : 1
    Platform: mbox supported : 1
    Platform: mmio supported : 0
    Intel(R) SST-PP (feature perf-profile) is not supported
    Only performance level 0 (base level) is present
    TDP level change control is locked
    Intel(R) SST-TF (feature turbo-freq) is supported
    Intel(R) SST-BF (feature base-freq) is supported
    Intel(R) SST-CP (feature core-power) is supported
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 5302a552f87f..65110d06394f 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -846,12 +846,85 @@ static int isst_fill_platform_info(void)
 	return 0;
 }
 
+static void isst_print_extended_platform_info(void)
+{
+	int cp_state, cp_cap, fact_support = 0, pbf_support = 0;
+	struct isst_pkg_ctdp_level_info ctdp_level;
+	struct isst_pkg_ctdp pkg_dev;
+	int ret, i, j;
+	FILE *filep;
+
+	for (i = 0; i < 256; ++i) {
+		char path[256];
+
+		snprintf(path, sizeof(path),
+			 "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+		filep = fopen(path, "r");
+		if (filep)
+			break;
+	}
+
+	if (!filep)
+		return;
+
+	fclose(filep);
+
+	ret = isst_get_ctdp_levels(i, &pkg_dev);
+	if (ret)
+		return;
+
+	if (pkg_dev.enabled) {
+		fprintf(outf, "Intel(R) SST-PP (feature perf-profile) is supported\n");
+	} else {
+		fprintf(outf, "Intel(R) SST-PP (feature perf-profile) is not supported\n");
+		fprintf(outf, "Only performance level 0 (base level) is present\n");
+	}
+
+	if (pkg_dev.locked)
+		fprintf(outf, "TDP level change control is locked\n");
+	else
+		fprintf(outf, "TDP level change control is unlocked, max level: %d \n", pkg_dev.levels);
+
+	for (j = 0; j <= pkg_dev.levels; ++j) {
+		ret = isst_get_ctdp_control(i, j, &ctdp_level);
+		if (ret)
+			continue;
+
+		if (!fact_support && ctdp_level.fact_support)
+			fact_support = 1;
+
+		if (!pbf_support && ctdp_level.pbf_support)
+			pbf_support = 1;
+	}
+
+	if (fact_support)
+		fprintf(outf, "Intel(R) SST-TF (feature turbo-freq) is supported\n");
+	else
+		fprintf(outf, "Intel(R) SST-TF (feature turbo-freq) is not supported\n");
+
+	if (pbf_support)
+		fprintf(outf, "Intel(R) SST-BF (feature base-freq) is supported\n");
+	else
+		fprintf(outf, "Intel(R) SST-BF (feature base-freq) is not supported\n");
+
+	ret = isst_read_pm_config(i, &cp_state, &cp_cap);
+	if (cp_cap)
+		fprintf(outf, "Intel(R) SST-CP (feature core-power) is supported\n");
+	else
+		fprintf(outf, "Intel(R) SST-CP (feature core-power) is not supported\n");
+}
+
 static void isst_print_platform_information(void)
 {
 	struct isst_if_platform_info platform_info;
 	const char *pathname = "/dev/isst_interface";
 	int fd;
 
+	if (is_clx_n_platform()) {
+		fprintf(stderr, "\nThis option in not supported on this platform\n");
+		exit(0);
+	}
+
 	fd = open(pathname, O_RDWR);
 	if (fd < 0)
 		err(-1, "%s open failed", pathname);
@@ -867,6 +940,7 @@ static void isst_print_platform_information(void)
 			platform_info.mbox_supported);
 		fprintf(outf, "Platform: mmio supported : %d\n",
 			platform_info.mmio_supported);
+		isst_print_extended_platform_info();
 	}
 
 	close(fd);

commit addd116d8daf941485bf68eff22f43ff6525b76d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:20 2020 -0800

    tools/power/x86/intel-speed-select: Enhance help
    
    Enhance help message which adds some example. The changes include:
    - Print help when options are not recognized.
    - For CLX, display only options which are applicable.
    - Sort options in alphatical order.
    - Disply help() instead of error:
    "Feature name and|or command not specified"
    - Remove duplicate display of
    Intel(R) Speed Select Technology
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 9bf461e57a34..5302a552f87f 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -2368,11 +2368,18 @@ void process_command(int argc, char **argv,
 
 static void usage(void)
 {
-	printf("Intel(R) Speed Select Technology\n");
+	if (is_clx_n_platform()) {
+		fprintf(stderr, "\nThere is limited support of Intel Speed Select features on this platform.\n");
+		fprintf(stderr, "Everything is pre-configured using BIOS options, this tool can't enable any feature in the hardware.\n\n");
+	}
+
 	printf("\nUsage:\n");
 	printf("intel-speed-select [OPTIONS] FEATURE COMMAND COMMAND_ARGUMENTS\n");
-	printf("\nUse this tool to enumerate and control the Intel Speed Select Technology features,\n");
-	printf("\nFEATURE : [perf-profile|base-freq|turbo-freq|core-power]\n");
+	printf("\nUse this tool to enumerate and control the Intel Speed Select Technology features:\n");
+	if (is_clx_n_platform())
+		printf("\nFEATURE : [perf-profile|base-freq]\n");
+	else
+		printf("\nFEATURE : [perf-profile|base-freq|turbo-freq|core-power]\n");
 	printf("\nFor help on each feature, use -h|--help\n");
 	printf("\tFor example:  intel-speed-select perf-profile -h\n");
 
@@ -2385,17 +2392,29 @@ static void usage(void)
 	printf("\t\tDefault: Die scoped for all dies in the system with multiple dies/package\n");
 	printf("\t\t\t Or Package scoped for all Packages when each package contains one die\n");
 	printf("\t[-d|--debug] : Debug mode\n");
+	printf("\t[-f|--format] : output format [json|text]. Default: text\n");
 	printf("\t[-h|--help] : Print help\n");
 	printf("\t[-i|--info] : Print platform information\n");
 	printf("\t[-o|--out] : Output file\n");
 	printf("\t\t\tDefault : stderr\n");
-	printf("\t[-f|--format] : output format [json|text]. Default: text\n");
 	printf("\t[-v|--version] : Print version\n");
 
 	printf("\nResult format\n");
 	printf("\tResult display uses a common format for each command:\n");
 	printf("\tResults are formatted in text/JSON with\n");
 	printf("\t\tPackage, Die, CPU, and command specific results.\n");
+
+	printf("\nExamples\n");
+	printf("\tTo get platform information:\n");
+	printf("\t\tintel-speed-select --info\n");
+	printf("\tTo get full perf-profile information dump:\n");
+	printf("\t\tintel-speed-select perf-profile info\n");
+	printf("\tTo get full base-freq information dump:\n");
+	printf("\t\tintel-speed-select base-freq info -l 0\n");
+	if (!is_clx_n_platform()) {
+		printf("\tTo get full turbo-freq information dump:\n");
+		printf("\t\tintel-speed-select turbo-freq info -l 0\n");
+	}
 	exit(1);
 }
 
@@ -2482,7 +2501,7 @@ static void cmdline(int argc, char **argv)
 	}
 
 	if (optind > (argc - 2)) {
-		fprintf(stderr, "Feature name and|or command not specified\n");
+		usage();
 		exit(0);
 	}
 	set_max_cpu_num();

commit f362cdccca07c2b90fc4fac9bf13d9ce975e9aa7
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:19 2020 -0800

    tools/power/x86/intel-speed-select: Helpful warning for missing kernel interface
    
    When the device file "/dev/isst_interface" is not present, instead of
    failing on access, check at the start and print a helpful warning.
    
    Here CLX platform is an exception, which doesn't depend on the device
    file. So continue for CLX platform.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 4773970cda9b..9bf461e57a34 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -2408,6 +2408,8 @@ static void print_version(void)
 
 static void cmdline(int argc, char **argv)
 {
+	const char *pathname = "/dev/isst_interface";
+	FILE *fp;
 	int opt;
 	int option_index = 0;
 	int ret;
@@ -2423,6 +2425,28 @@ static void cmdline(int argc, char **argv)
 		{ 0, 0, 0, 0 }
 	};
 
+	if (geteuid() != 0) {
+		fprintf(stderr, "Must run as root\n");
+		exit(0);
+	}
+
+	ret = update_cpu_model();
+	if (ret)
+		err(-1, "Invalid CPU model (%d)\n", cpu_model);
+	printf("Intel(R) Speed Select Technology\n");
+	printf("Executing on CPU model:%d[0x%x]\n", cpu_model, cpu_model);
+
+	if (!is_clx_n_platform()) {
+		fp = fopen(pathname, "rb");
+		if (!fp) {
+			fprintf(stderr, "Intel speed select drivers are not loaded on this system.\n");
+			fprintf(stderr, "Verify that kernel config includes CONFIG_INTEL_SPEED_SELECT_INTERFACE.\n");
+			fprintf(stderr, "If the config is included then this is not a supported platform.\n");
+			exit(0);
+		}
+		fclose(fp);
+	}
+
 	progname = argv[0];
 	while ((opt = getopt_long_only(argc, argv, "+c:df:hio:v", long_options,
 				       &option_index)) != -1) {
@@ -2457,20 +2481,10 @@ static void cmdline(int argc, char **argv)
 		}
 	}
 
-	if (geteuid() != 0) {
-		fprintf(stderr, "Must run as root\n");
-		exit(0);
-	}
-
 	if (optind > (argc - 2)) {
 		fprintf(stderr, "Feature name and|or command not specified\n");
 		exit(0);
 	}
-	ret = update_cpu_model();
-	if (ret)
-		err(-1, "Invalid CPU model (%d)\n", cpu_model);
-	printf("Intel(R) Speed Select Technology\n");
-	printf("Executing on CPU model:%d[0x%x]\n", cpu_model, cpu_model);
 	set_max_cpu_num();
 	store_cpu_topology();
 	set_cpu_present_cpu_mask();

commit fb186158283958984fecf7c1bbc0833dc76e375b
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:18 2020 -0800

    tools/power/x86/intel-speed-select: Store topology information
    
    Once the CPU is offline, the topology information (core-id, package-id,
    die-id) is not accessible via sysfs. So when user selects a config level
    more than base config 0 and offlined CPUs to match the config level,
    to return to base config he has to manually online CPUs before. Without
    this CPUs information mapping from Punit CPU numbering will lot work
    as it needs atlest package id for each CPU.
    
    To avoid this additional steps store the topology information in a file
    , which is created on the very first run after boot. Since system boots
    in base config and all CPUs are online, we can get information about
    every CPU.
    
    Once any of the APIs like get_physical_package_id(),
    get_physical_core_id() or get_physical_die_id() fails to read from
    sysfs, read from the stored mapping file.
    
    This mapping file is stored in /tmp file system. so on every boot
    it is recreated to make sure that any new CPUs are added to the
    system before boot are taken into account.
    
    But don't use the stored physical device id  when trying to get
    information for CPU to send message in for_each_online_package_in_set().
    Here use the real value from syfs and in case fails try the next CPU.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index c773c6cc02a5..4773970cda9b 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -62,6 +62,13 @@ struct _cpu_map {
 };
 struct _cpu_map *cpu_map;
 
+struct cpu_topology {
+	short cpu;
+	short core_id;
+	short pkg_id;
+	short die_id;
+};
+
 void debug_printf(const char *format, ...)
 {
 	va_list args;
@@ -176,25 +183,137 @@ int out_format_is_json(void)
 	return out_format_json;
 }
 
+static int get_stored_topology_info(int cpu, int *core_id, int *pkg_id, int *die_id)
+{
+	const char *pathname = "/tmp/isst_cpu_topology.dat";
+	struct cpu_topology cpu_top;
+	FILE *fp;
+	int ret;
+
+	fp = fopen(pathname, "rb");
+	if (!fp)
+		return -1;
+
+	ret = fseek(fp, cpu * sizeof(cpu_top), SEEK_SET);
+	if (ret)
+		goto err_ret;
+
+	ret = fread(&cpu_top, sizeof(cpu_top), 1, fp);
+	if (ret != 1) {
+		ret = -1;
+		goto err_ret;
+	}
+
+	*pkg_id = cpu_top.pkg_id;
+	*core_id = cpu_top.core_id;
+	*die_id = cpu_top.die_id;
+	ret = 0;
+
+err_ret:
+	fclose(fp);
+
+	return ret;
+}
+
+static void store_cpu_topology(void)
+{
+	const char *pathname = "/tmp/isst_cpu_topology.dat";
+	FILE *fp;
+	int i;
+
+	fp = fopen(pathname, "rb");
+	if (fp) {
+		/* Mapping already exists */
+		fclose(fp);
+		return;
+	}
+
+	fp = fopen(pathname, "wb");
+	if (!fp) {
+		fprintf(stderr, "Can't create file:%s\n", pathname);
+		return;
+	}
+
+	for (i = 0; i < topo_max_cpus; ++i) {
+		struct cpu_topology cpu_top;
+
+		cpu_top.core_id = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/core_id", i);
+		if (cpu_top.core_id < 0)
+			cpu_top.core_id = -1;
+
+		cpu_top.pkg_id = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i);
+		if (cpu_top.pkg_id < 0)
+			cpu_top.pkg_id = -1;
+
+		cpu_top.die_id = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/die_id", i);
+		if (cpu_top.die_id < 0)
+			cpu_top.die_id = -1;
+
+		cpu_top.cpu = i;
+
+		if (fwrite(&cpu_top, sizeof(cpu_top), 1, fp) != 1) {
+			fprintf(stderr, "Can't write to:%s\n", pathname);
+			break;
+		}
+	}
+
+	fclose(fp);
+}
+
 int get_physical_package_id(int cpu)
 {
-	return parse_int_file(
-		0, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id",
-		cpu);
+	int ret;
+
+	ret = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/physical_package_id",
+			cpu);
+	if (ret < 0) {
+		int core_id, pkg_id, die_id;
+
+		ret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);
+		if (!ret)
+			return pkg_id;
+	}
+
+	return ret;
 }
 
 int get_physical_core_id(int cpu)
 {
-	return parse_int_file(
-		0, "/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);
+	int ret;
+
+	ret = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/core_id",
+			cpu);
+	if (ret < 0) {
+		int core_id, pkg_id, die_id;
+
+		ret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);
+		if (!ret)
+			return core_id;
+	}
+
+	return ret;
 }
 
 int get_physical_die_id(int cpu)
 {
 	int ret;
 
-	ret = parse_int_file(0, "/sys/devices/system/cpu/cpu%d/topology/die_id",
-			     cpu);
+	ret = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/die_id",
+			cpu);
+	if (ret < 0) {
+		int core_id, pkg_id, die_id;
+
+		ret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);
+		if (!ret)
+			return die_id;
+	}
+
 	if (ret < 0)
 		ret = 0;
 
@@ -266,11 +385,12 @@ static void for_each_online_package_in_set(void (*callback)(int, void *, void *,
 		die_id = get_physical_die_id(i);
 		if (die_id < 0)
 			die_id = 0;
-		pkg_id = get_physical_package_id(i);
-		if (pkg_id < 0) {
-			fprintf(stderr, "Failed to get package id, CPU %d may be offline\n", i);
+
+		pkg_id = parse_int_file(0,
+			"/sys/devices/system/cpu/cpu%d/topology/physical_package_id", i);
+		if (pkg_id < 0)
 			continue;
-		}
+
 		/* Create an unique id for package, die combination to store */
 		pkg_id = (MAX_PACKAGE_COUNT * pkg_id + die_id);
 
@@ -2352,6 +2472,7 @@ static void cmdline(int argc, char **argv)
 	printf("Intel(R) Speed Select Technology\n");
 	printf("Executing on CPU model:%d[0x%x]\n", cpu_model, cpu_model);
 	set_max_cpu_num();
+	store_cpu_topology();
 	set_cpu_present_cpu_mask();
 	set_cpu_target_cpu_mask();
 

commit 864dc09e692f55fc7a5a87c7411da0a348ac1094
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:17 2020 -0800

    tools/power/x86/intel-speed-select: Max CPU count calculation when CPU0 is offline
    
    Currently /sys/devices/system/cpu/cpu0/topology/thread_siblings is used to
    get the max CPU count. But when CPU0 is offline, then this file will be
    absent.
    
    So add processing so that we can get count from any first CPU in the
    system. which is online.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index b8f4846d7c78..c773c6cc02a5 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -316,10 +316,24 @@ static void set_max_cpu_num(void)
 {
 	FILE *filep;
 	unsigned long dummy;
+	int i;
 
 	topo_max_cpus = 0;
-	filep = fopen_or_exit(
-		"/sys/devices/system/cpu/cpu0/topology/thread_siblings", "r");
+	for (i = 0; i < 256; ++i) {
+		char path[256];
+
+		snprintf(path, sizeof(path),
+			 "/sys/devices/system/cpu/cpu%d/topology/thread_siblings", i);
+		filep = fopen(path, "r");
+		if (filep)
+			break;
+	}
+
+	if (!filep) {
+		fprintf(stderr, "Can't get max cpu number\n");
+		exit(0);
+	}
+
 	while (fscanf(filep, "%lx,", &dummy) == 1)
 		topo_max_cpus += BITMASK_SIZE;
 	fclose(filep);

commit 696691985c3191f2c4c76f09b1c7c5f3ca99d5ed
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:16 2020 -0800

    tools/power/x86/intel-speed-select: Special handling for CPU 0 online/offline
    
    When "-o" option for force online/offline is used with command:
    perf-profile set-config-level
    
    If the config level calls for CPU 0 online/offline, then call fails
    as there is special kernel setup required for CPU 0 online/offline
    and the currently not setup for that.
    
    But when call is for online CPU 0, then don't fail. Just warn that
    this system is not setup for CPU 0 online/offline.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 405b03cba248..b8f4846d7c78 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -220,8 +220,14 @@ static void set_cpu_online_offline(int cpu, int state)
 		 "/sys/devices/system/cpu/cpu%d/online", cpu);
 
 	fd = open(buffer, O_WRONLY);
-	if (fd < 0)
+	if (fd < 0) {
+		if (!cpu && state) {
+			fprintf(stderr, "This system is not configured for CPU 0 online/offline\n");
+			fprintf(stderr, "Ignoring online request for CPU 0 as this is already online\n");
+			return;
+		}
 		err(-1, "%s open failed", buffer);
+	}
 
 	if (state)
 		ret = write(fd, "1\n", 2);

commit 143ad32209af647c76b4ce06144eb093375a8562
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:14 2020 -0800

    tools/power/x86/intel-speed-select: Enhance core-power info command
    
    In addition to CLOS enable status, also show the core-power feature
    status. This will help why clos enable status didn't give desired
    results as the core-power feature may be disabled or unsupported.
    
    The new display looks as follows:
    
    $intel-speed-select core-power info
    Intel(R) Speed Select Technology
    ..
     package-0
      die-0
        cpu-0
          core-power
            support-status:supported
            enable-status:enabled
            clos-enable-status:1
            priority-type:0
    
    In the above display "support-status" and "enable-status", shows the
    status of the core-power feature and "clos-enable-status", shows the
    status of the clos.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index c0de18e10cda..405b03cba248 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1754,8 +1754,13 @@ static void get_clos_info_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	ret = isst_clos_get_clos_information(cpu, &enable, &prio_type);
 	if (ret)
 		perror("isst_clos_get_info");
-	else
-		isst_clos_display_clos_information(cpu, outf, enable, prio_type);
+	else {
+		int cp_state, cp_cap;
+
+		isst_read_pm_config(cpu, &cp_state, &cp_cap);
+		isst_clos_display_clos_information(cpu, outf, enable, prio_type,
+						   cp_state, cp_cap);
+	}
 }
 
 static void dump_clos_info(int arg)

commit f5205f493100f1cdbecdf5498abb4c3dbdce08c5
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:13 2020 -0800

    tools/power/x86/intel-speed-select: Make target CPU optional for core-power info
    
    Currently "-c" is a mandatory option for "core-power info" command. Make
    this optional as this is a per package/die property. When not specified,
    it will print info for every package/die.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 3f019f4f90df..c0de18e10cda 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1763,19 +1763,17 @@ static void dump_clos_info(int arg)
 	if (cmd_help) {
 		fprintf(stderr,
 			"Print Intel Speed Select Technology core power information\n");
-		fprintf(stderr, "\tSpecify targeted cpu id with [--cpu|-c]\n");
-		exit(0);
-	}
-
-	if (!max_target_cpus) {
-		fprintf(stderr,
-			"Invalid target cpu. Specify with [-c|--cpu]\n");
+		fprintf(stderr, "\t Optionally specify targeted cpu id with [--cpu|-c]\n");
 		exit(0);
 	}
 
 	isst_ctdp_display_information_start(outf);
-	for_each_online_target_cpu_in_set(get_clos_info_for_cpu, NULL,
-					  NULL, NULL, NULL);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(get_clos_info_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(get_clos_info_for_cpu, NULL,
+					       NULL, NULL, NULL);
 	isst_ctdp_display_information_end(outf);
 
 }

commit f0e0b4d17baaaf4968664f8fe79c66a7417aaab0
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Mar 5 14:45:12 2020 -0800

    tools/power/x86/intel-speed-select: Warn for invalid package id
    
    When CPU is offline, we can't get package id. So print error for this
    and don't use output.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index c922cfd7ba50..3f019f4f90df 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -261,6 +261,10 @@ static void for_each_online_package_in_set(void (*callback)(int, void *, void *,
 		if (die_id < 0)
 			die_id = 0;
 		pkg_id = get_physical_package_id(i);
+		if (pkg_id < 0) {
+			fprintf(stderr, "Failed to get package id, CPU %d may be offline\n", i);
+			continue;
+		}
 		/* Create an unique id for package, die combination to store */
 		pkg_id = (MAX_PACKAGE_COUNT * pkg_id + die_id);
 
@@ -362,6 +366,10 @@ static void set_cpu_present_cpu_mask(void)
 				die_id = 0;
 
 			pkg_id = get_physical_package_id(i);
+			if (pkg_id < 0) {
+				fprintf(stderr, "Failed to get package id, CPU %d may be offline\n", i);
+				continue;
+			}
 			if (pkg_id < MAX_PACKAGE_COUNT &&
 			    die_id < MAX_DIE_PER_PACKAGE) {
 				int core_id = get_physical_core_id(i);

commit ced2f5304d1409805edd661b5f32092f3878be05
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Mar 3 14:50:44 2020 -0800

    tools/power/x86/intel-speed-select: Fix last cpu number
    
    Here topology_max_cpus is used for total CPU count, not the last CPU
    number. So remove "-1".
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 50db0cd23d8c..c922cfd7ba50 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -313,7 +313,6 @@ static void set_max_cpu_num(void)
 	while (fscanf(filep, "%lx,", &dummy) == 1)
 		topo_max_cpus += BITMASK_SIZE;
 	fclose(filep);
-	topo_max_cpus--; /* 0 based */
 
 	debug_printf("max cpus %d\n", topo_max_cpus);
 }

commit 8ddbda76245f5d10e00020db34455404019efc91
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Mar 3 14:50:43 2020 -0800

    tools/power/x86/intel-speed-select: Fix mailbox usage for CLOS_PM_QOS_CONFIG
    
    Even for the products using MMIO, this message needs to be sent via
    mail box. The previous fix done for this didn't properly address this.
    That fix simply removed sending command via MMIO, but still didn't
    trigger sending via mailbox.
    
    Add additional condition to check for CLOS_PM_QOS_CONFIG, when MMIO
    is supported on a platform.
    
    Fixes: cd0e63706549 (tools/power/x86/intel-speed-select: Use mailbox for CLOS_PM_QOS_CONFIG)
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 0cf3548681f8..50db0cd23d8c 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -572,7 +572,8 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 		"mbox_send: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
 		cpu, command, sub_command, parameter, req_data);
 
-	if (isst_platform_info.mmio_supported && command == CONFIG_CLOS) {
+	if (isst_platform_info.mmio_supported && command == CONFIG_CLOS &&
+	    sub_command != CLOS_PM_QOS_CONFIG) {
 		unsigned int value;
 		int write = 0;
 		int clos_id, core_id, ret = 0;

commit 14a8aa4964e01aafcd684499315d3d4ea1de428f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Jan 30 21:45:17 2020 -0800

    tools/power/x86/intel-speed-select: Fix display for turbo-freq auto mode
    
    When mailbox command for the turbo-freq enable fails, then don't display
    result for auto-mode. When turbo-freq enable fails, there is no point
    to set CPU priorities.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2b2b8167c65b..0cf3548681f8 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -42,6 +42,7 @@ static int out_format_json;
 static int cmd_help;
 static int force_online_offline;
 static int auto_mode;
+static int fact_enable_fail;
 
 /* clos related */
 static int current_clos = -1;
@@ -1527,6 +1528,8 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 disp_results:
 	if (status) {
 		isst_display_result(cpu, outf, "turbo-freq", "enable", ret);
+		if (ret)
+			fact_enable_fail = ret;
 	} else {
 		/* Since we modified TRL during Fact enable, restore it */
 		isst_set_trl_from_current_tdp(cpu, fact_trl);
@@ -1568,7 +1571,7 @@ static void set_fact_enable(int arg)
 					       NULL, &enable);
 	isst_ctdp_display_information_end(outf);
 
-	if (enable && auto_mode) {
+	if (!fact_enable_fail && enable && auto_mode) {
 		/*
 		 * When we adjust CLOS param, we have to set for siblings also.
 		 * So for the each user specified CPU, also add the sibling

commit 19be0b2a2e4444d41ca70554422a1f0c1d5312d6
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Jan 14 11:22:17 2020 -0800

    tools/power/x86/intel-speed-select: Update version
    
    As we added new set of mailbox commands, increment version.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 84baba34d311..2b2b8167c65b 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -15,7 +15,7 @@ struct process_cmd_struct {
 	int arg;
 };
 
-static const char *version_str = "v1.1";
+static const char *version_str = "v1.2";
 static const int supported_api_ver = 1;
 static struct isst_if_platform_info isst_platform_info;
 static char *progname;

commit 097a522257ea3446b1e3b03f5c2498c23f9cd84f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Jan 14 11:22:16 2020 -0800

    tools/power/x86/intel-speed-select: Change the order for clos disable
    
    In turbo-freq or base-freq auto mode, for disable, first disable the feature and
    then disable clos.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index e22a694e6410..84baba34d311 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1384,14 +1384,10 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		goto disp_result;
 	}
 
-	if (auto_mode) {
-		if (status) {
-			ret = set_pbf_core_power(cpu);
-			if (ret)
-				goto disp_result;
-		} else {
-			isst_pm_qos_config(cpu, 0, 0);
-		}
+	if (auto_mode && status) {
+		ret = set_pbf_core_power(cpu);
+		if (ret)
+			goto disp_result;
 	}
 
 	ret = isst_set_pbf_fact_status(cpu, 1, status);
@@ -1408,6 +1404,9 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		}
 	}
 
+	if (auto_mode && !status)
+		isst_pm_qos_config(cpu, 0, 0);
+
 disp_result:
 	if (status)
 		isst_display_result(cpu, outf, "base-freq", "enable",
@@ -1496,14 +1495,10 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int ret;
 	int status = *(int *)arg4;
 
-	if (auto_mode) {
-		if (status) {
-			ret = isst_pm_qos_config(cpu, 1, 1);
-			if (ret)
-				goto disp_results;
-		} else {
-			isst_pm_qos_config(cpu, 0, 0);
-		}
+	if (auto_mode && status) {
+		ret = isst_pm_qos_config(cpu, 1, 1);
+		if (ret)
+			goto disp_results;
 	}
 
 	ret = isst_set_pbf_fact_status(cpu, 0, status);
@@ -1524,6 +1519,9 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 			ret = isst_set_trl(cpu, fact_trl);
 		if (ret && auto_mode)
 			isst_pm_qos_config(cpu, 0, 0);
+	} else {
+		if (auto_mode)
+			isst_pm_qos_config(cpu, 0, 0);
 	}
 
 disp_results:

commit 78e77b7dfd9abdf0bb003b679e0afbde78d98f47
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Jan 14 11:22:15 2020 -0800

    tools/power/x86/intel-speed-select: Fix result display for turbo-freq auto mode
    
    The turbo-freq enable with auto mode, prints result for the last possible
    CPU, which is not correct when either CPU is not present or user wants
    command to be limited to a single die/package. For example, in the
    below command user wants to limit to die/package 0, but the
    "turbo-freq --auto" result is displayed using the other package.
    
    $ sudo intel-speed-select -c 0 turbo-freq enable -a
    Intel(R) Speed Select Technology
     package-0
      die-0
        cpu-0
          turbo-freq
            enable:success
     package--1
      die-0
        cpu-31
          turbo-freq --auto
            enable:success
    
    Since we do have to traverse all CPUs, don't display CPU info for
    "turbo-freq --auto", as we already displayed the result for
    turbo-freq enable with the CPU information.
    
    With the fix, the same command results in:
    
    $ sudo intel-speed-select -c 0 turbo-freq enable -a
    Intel(R) Speed Select Technology
    package-0
      die-0
        cpu-0
          turbo-freq
            enable:success
          turbo-freq --auto
            enable:success
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 944183f9ed5a..e22a694e6410 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1638,7 +1638,7 @@ static void set_fact_enable(int arg)
 			if (ret)
 				goto error_disp;
 		}
-		isst_display_result(i, outf, "turbo-freq --auto", "enable", 0);
+		isst_display_result(-1, outf, "turbo-freq --auto", "enable", 0);
 	}
 
 	return;

commit 5c14aba77874d350db8973f4c980fd92c8b1fa07
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:46 2019 -0800

    tools/power/x86/intel-speed-select: Increment version
    
    Since the tool now adds support for another Intel SST implementation,
    increment version number.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index e0bad43697dc..944183f9ed5a 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -15,7 +15,7 @@ struct process_cmd_struct {
 	int arg;
 };
 
-static const char *version_str = "v1.0";
+static const char *version_str = "v1.1";
 static const int supported_api_ver = 1;
 static struct isst_if_platform_info isst_platform_info;
 static char *progname;

commit de7f9d3ddc8c71a116fbdfa298a19abd8d46e696
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:45 2019 -0800

    tools/power/x86/intel-speed-select: Use core count for base-freq mask
    
    Some firmware implementation gives error when a command is sent get mask
    for core count 32-61. So use core count to decide.
    
    But there is no function to get core count. So introduce one function to
    get core count.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2dffb67d3194..e0bad43697dc 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -338,6 +338,7 @@ void free_cpu_set(cpu_set_t *cpu_set)
 }
 
 static int cpu_cnt[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE];
+static long long core_mask[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE];
 static void set_cpu_present_cpu_mask(void)
 {
 	size_t size;
@@ -362,13 +363,33 @@ static void set_cpu_present_cpu_mask(void)
 
 			pkg_id = get_physical_package_id(i);
 			if (pkg_id < MAX_PACKAGE_COUNT &&
-			    die_id < MAX_DIE_PER_PACKAGE)
+			    die_id < MAX_DIE_PER_PACKAGE) {
+				int core_id = get_physical_core_id(i);
+
 				cpu_cnt[pkg_id][die_id]++;
+				core_mask[pkg_id][die_id] |= (1ULL << core_id);
+			}
 		}
 		closedir(dir);
 	}
 }
 
+int get_core_count(int pkg_id, int die_id)
+{
+	int cnt = 0;
+
+	if (pkg_id < MAX_PACKAGE_COUNT && die_id < MAX_DIE_PER_PACKAGE) {
+		int i;
+
+		for (i = 0; i < sizeof(long long) * 8; ++i) {
+			if (core_mask[pkg_id][die_id] & (1ULL << i))
+				cnt++;
+		}
+	}
+
+	return cnt;
+}
+
 int get_cpu_count(int pkg_id, int die_id)
 {
 	if (pkg_id < MAX_PACKAGE_COUNT && die_id < MAX_DIE_PER_PACKAGE)

commit 7af5a95bb752702bfc91fc513d37f1f799e6fd1f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:44 2019 -0800

    tools/power/x86/intel-speed-select: Support platform with limited Intel(R) Speed Select
    
    There are some platforms, where there limited support of Intel(R) SST
    features. Here perf-profile has only one base configuration and limited
    support of commands. But still has support for discovery of base-freq and
    turbo-freq features. So it is important to show minimum features to use
    base-freq and turbo-freq features.
    
    Here the change are:
    - When there is no support of CONFIG_TDP_GET_LEVELS_INFO, then instead
    of treating this as fatal error, treat this with number of config levels
    = 0, that means only base level 0 is present.
    - There is no support of mail box commands to get base frequencies or
    turbo frequencies. Here present base frequency by reading cpufreq
    base freq and turbo frequency by reading MSR 0x1AD.
    - Don't display any field, which has value == 0.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2d7ed27af7e0..2dffb67d3194 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -200,6 +200,11 @@ int get_physical_die_id(int cpu)
 	return ret;
 }
 
+int get_cpufreq_base_freq(int cpu)
+{
+	return parse_int_file(0, "/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency", cpu);
+}
+
 int get_topo_max_cpus(void)
 {
 	return topo_max_cpus;
@@ -598,6 +603,7 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 		fprintf(outf,
 			"Error: mbox_cmd cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
 			cpu, command, sub_command, parameter, req_data);
+		return -1;
 	} else {
 		*resp = mbox_cmds.mbox_cmd[0].resp_data;
 		debug_printf(

commit 21c3390d61286912cef312dc4752719142ce0d54
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:43 2019 -0800

    tools/power/x86/intel-speed-select: Use Frequency weight for CLOS
    
    Use different frequency weights for CLOS 0 and and CLOS1-3, to define
    relative priority for power budgeting. This will be used for --auto
    mode to enable base-freq and turbo-freq feature.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index a8ada9a4f020..2d7ed27af7e0 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1260,15 +1260,15 @@ static int set_core_priority_and_min(int cpu, int mask_size,
 	if (ret)
 		return ret;
 
-	ret = set_clos_param(cpu, 1, 15, 0, min_low, 0xff);
+	ret = set_clos_param(cpu, 1, 15, 15, min_low, 0xff);
 	if (ret)
 		return ret;
 
-	ret = set_clos_param(cpu, 2, 15, 0, min_low, 0xff);
+	ret = set_clos_param(cpu, 2, 15, 15, min_low, 0xff);
 	if (ret)
 		return ret;
 
-	ret = set_clos_param(cpu, 3, 15, 0, min_low, 0xff);
+	ret = set_clos_param(cpu, 3, 15, 15, min_low, 0xff);
 	if (ret)
 		return ret;
 
@@ -1589,15 +1589,15 @@ static void set_fact_enable(int arg)
 			if (ret)
 				goto error_disp;
 
-			ret = set_clos_param(i, 1, 15, 0, 0, 0xff);
+			ret = set_clos_param(i, 1, 15, 15, 0, 0xff);
 			if (ret)
 				goto error_disp;
 
-			ret = set_clos_param(i, 2, 15, 0, 0, 0xff);
+			ret = set_clos_param(i, 2, 15, 15, 0, 0xff);
 			if (ret)
 				goto error_disp;
 
-			ret = set_clos_param(i, 3, 15, 0, 0, 0xff);
+			ret = set_clos_param(i, 3, 15, 15, 0, 0xff);
 			if (ret)
 				goto error_disp;
 

commit 40dee9dda37d5596ad119d3c3962ca49d3f035a5
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:42 2019 -0800

    tools/power/x86/intel-speed-select: Make CLOS frequency in MHz
    
    To be consistant with the other frequency units, change the CLOS
    unit to MHz instead of ratios.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2a3650f025b9..a8ada9a4f020 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1775,9 +1775,9 @@ static void set_clos_config(int arg)
 		fprintf(stderr, "\tSpecify clos EPP with [--epp|-e]\n");
 		fprintf(stderr,
 			"\tSpecify clos Proportional Priority [--weight|-w]\n");
-		fprintf(stderr, "\tSpecify clos min with [--min|-n]\n");
-		fprintf(stderr, "\tSpecify clos max with [--max|-m]\n");
-		fprintf(stderr, "\tSpecify clos desired with [--desired|-d]\n");
+		fprintf(stderr, "\tSpecify clos min in MHz with [--min|-n]\n");
+		fprintf(stderr, "\tSpecify clos max in MHz with [--max|-m]\n");
+		fprintf(stderr, "\tSpecify clos desired in MHz with [--desired|-d]\n");
 		exit(0);
 	}
 
@@ -1799,7 +1799,7 @@ static void set_clos_config(int arg)
 		clos_min = 0;
 	}
 	if (clos_max < 0) {
-		fprintf(stderr, "clos max is not specified, default: 0xff\n");
+		fprintf(stderr, "clos max is not specified, default: 25500 MHz\n");
 		clos_max = 0xff;
 	}
 	if (clos_desired < 0) {
@@ -2049,15 +2049,18 @@ static void parse_cmd_args(int argc, int start, char **argv)
 			break;
 		case 'd':
 			clos_desired = atoi(optarg);
+			clos_desired /= DISP_FREQ_MULTIPLIER;
 			break;
 		case 'e':
 			clos_epp = atoi(optarg);
 			break;
 		case 'n':
 			clos_min = atoi(optarg);
+			clos_min /= DISP_FREQ_MULTIPLIER;
 			break;
 		case 'm':
 			clos_max = atoi(optarg);
+			clos_max /= DISP_FREQ_MULTIPLIER;
 			break;
 		case 'p':
 			clos_priority_type = atoi(optarg);

commit cd0e63706549c3e0d61f5fe48806a4528c575035
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:41 2019 -0800

    tools/power/x86/intel-speed-select: Use mailbox for CLOS_PM_QOS_CONFIG
    
    Use mailbox to read/write CLOS_PM_QOS_CONFIG instead of read/write to
    MMIO offset.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index c563ecaf44e1..2a3650f025b9 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -574,12 +574,6 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 			if (!ret && !write)
 				*resp = value;
 			break;
-		case CLOS_PM_QOS_CONFIG:
-			ret = isst_send_mmio_command(cpu, PM_QOS_CONFIG_OFFSET,
-						     write, &value);
-			if (!ret && !write)
-				*resp = value;
-			break;
 		case CLOS_STATUS:
 			break;
 		default:

commit a9b2f8e2fa6c0f791f2345afb826d47c6a0f0e2c
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:40 2019 -0800

    tools/power/x86/intel-speed-select: Auto mode for CLX
    
    There is an expectation in the CLX platform for SST base-freq feature that
    Scaling min frequency be different for high and low priority cores.
    This is the way the firmware will understand the priority.
    
    So this change will look at high priority and low priority cores, and set
    scaling_min_freq to P1High for high priority cores and P1Low to low
    priority cores.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index bfa42fc6c4d2..c563ecaf44e1 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1095,7 +1095,73 @@ static int set_clos_param(int cpu, int clos, int epp, int wt, int min, int max)
 	return 0;
 }
 
-static int set_cpufreq_cpuinfo_scaling_min(int cpu, int max)
+static int set_cpufreq_scaling_min_max(int cpu, int max, int freq)
+{
+	char buffer[128], freq_str[16];
+	int fd, ret, len;
+
+	if (max)
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq", cpu);
+	else
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq", cpu);
+
+	fd = open(buffer, O_WRONLY);
+	if (fd < 0)
+		return fd;
+
+	snprintf(freq_str, sizeof(freq_str), "%d", freq);
+	len = strlen(freq_str);
+	ret = write(fd, freq_str, len);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+	close(fd);
+
+	return 0;
+}
+
+static int set_clx_pbf_cpufreq_scaling_min_max(int cpu)
+{
+	struct isst_pkg_ctdp_level_info *ctdp_level;
+	struct isst_pbf_info *pbf_info;
+	int i, pkg_id, die_id, freq, freq_high, freq_low;
+	int ret;
+
+	ret = clx_n_config(cpu);
+	if (ret) {
+		perror("set_clx_pbf_cpufreq_scaling_min_max");
+		return ret;
+	}
+
+	ctdp_level = &clx_n_pkg_dev.ctdp_level[0];
+	pbf_info = &ctdp_level->pbf_info;
+	freq_high = pbf_info->p1_high * 100000;
+	freq_low = pbf_info->p1_low * 100000;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+	for (i = 0; i < get_topo_max_cpus(); ++i) {
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		if (CPU_ISSET_S(i, pbf_info->core_cpumask_size,
+				  pbf_info->core_cpumask))
+			freq = freq_high;
+		else
+			freq = freq_low;
+
+		set_cpufreq_scaling_min_max(i, 1, freq);
+		set_cpufreq_scaling_min_max(i, 0, freq);
+	}
+
+	return 0;
+}
+
+static int set_cpufreq_scaling_min_max_from_cpuinfo(int cpu, int cpuinfo_max, int scaling_max)
 {
 	char buffer[128], min_freq[16];
 	int fd, ret, len;
@@ -1103,7 +1169,7 @@ static int set_cpufreq_cpuinfo_scaling_min(int cpu, int max)
 	if (!CPU_ISSET_S(cpu, present_cpumask_size, present_cpumask))
 		return -1;
 
-	if (max)
+	if (cpuinfo_max)
 		snprintf(buffer, sizeof(buffer),
 			 "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", cpu);
 	else
@@ -1120,8 +1186,12 @@ static int set_cpufreq_cpuinfo_scaling_min(int cpu, int max)
 	if (len < 0)
 		return len;
 
-	snprintf(buffer, sizeof(buffer),
-		 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq", cpu);
+	if (scaling_max)
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq", cpu);
+	else
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq", cpu);
 
 	fd = open(buffer, O_WRONLY);
 	if (fd < 0)
@@ -1149,7 +1219,7 @@ static void set_scaling_min_to_cpuinfo_max(int cpu)
 		    die_id != get_physical_die_id(i))
 			continue;
 
-		set_cpufreq_cpuinfo_scaling_min(i, 1);
+		set_cpufreq_scaling_min_max_from_cpuinfo(i, 1, 0);
 	}
 }
 
@@ -1164,7 +1234,22 @@ static void set_scaling_min_to_cpuinfo_min(int cpu)
 		    die_id != get_physical_die_id(i))
 			continue;
 
-		set_cpufreq_cpuinfo_scaling_min(i, 0);
+		set_cpufreq_scaling_min_max_from_cpuinfo(i, 0, 0);
+	}
+}
+
+static void set_scaling_max_to_cpuinfo_max(int cpu)
+{
+	int i, pkg_id, die_id;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+	for (i = 0; i < get_topo_max_cpus(); ++i) {
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		set_cpufreq_scaling_min_max_from_cpuinfo(i, 1, 1);
 	}
 }
 
@@ -1263,14 +1348,17 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int status = *(int *)arg4;
 
 	if (is_clx_n_platform()) {
-		if (status == 0) {
-			ret = -1;
-			if (auto_mode)
-				set_scaling_min_to_cpuinfo_min(cpu);
-		} else {
+		if (status) {
 			ret = 0;
 			if (auto_mode)
-				set_scaling_min_to_cpuinfo_max(cpu);
+				set_clx_pbf_cpufreq_scaling_min_max(cpu);
+
+		} else {
+			ret = -1;
+			if (auto_mode) {
+				set_scaling_max_to_cpuinfo_max(cpu);
+				set_scaling_min_to_cpuinfo_min(cpu);
+			}
 		}
 		goto disp_result;
 	}

commit 91d928147bb0d03219fd6cc079e16fd74e232e2b
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Nov 4 03:02:39 2019 -0800

    tools/power/x86/intel-speed-select: Correct CLX-N frequency units
    
    In CLX_N base_frequency is read from cpufreq sysfs, where units are in
    KHz. The internal units in the code matches the real ratios which are
    in 100MHz scale. So when storing units for CLX-N frequencies, convert
    to 100MHz scale.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 1c20048b42e7..bfa42fc6c4d2 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -840,8 +840,8 @@ static int clx_n_config(int cpu)
 	}
 
 	/* convert frequencies back to ratios */
-	pbf_info->p1_high = pbf_info->p1_high / DISP_FREQ_MULTIPLIER;
-	pbf_info->p1_low = pbf_info->p1_low / DISP_FREQ_MULTIPLIER;
+	pbf_info->p1_high = pbf_info->p1_high / 100000;
+	pbf_info->p1_low = pbf_info->p1_low / 100000;
 
 	/* create high priority cpu mask */
 	pbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);
@@ -856,7 +856,7 @@ static int clx_n_config(int cpu)
 		cpu_bf = parse_int_file(1,
 			"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency",
 					i);
-		cpu_bf = cpu_bf / DISP_FREQ_MULTIPLIER;
+		cpu_bf = cpu_bf / 100000;
 		if (cpu_bf == pbf_info->p1_high)
 			CPU_SET_S(i, pbf_info->core_cpumask_size,
 				  pbf_info->core_cpumask);

commit 1aa7177cdcb38d114e0a80dc27482e645d8068f2
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:45 2019 -0700

    tools/power/x86/intel-speed-select: Implement base-freq commands on CascadeLake-N
    
    Add functionality for base-freq info|enable|disable info on CascadeLake-N.
    
    Sample output:
    Intel(R) Speed Select Technology
    Executing on CPU model:85[0x55]
     package-0
      die-0
        cpu-0
          speed-select-base-freq
            high-priority-base-frequency(MHz):2700000
            high-priority-cpu-mask:00000000,0000e8c0
            high-priority-cpu-list:6,7,11,13,14,15
            low-priority-base-frequency(MHz):2100000
     package-1
      die-0
        cpu-20
          speed-select-base-freq
            high-priority-base-frequency(MHz):2700000
            high-priority-cpu-mask:0000000e,8c000000
            high-priority-cpu-list:26,27,31,33,34,35
            low-priority-base-frequency(MHz):2100000
    
    The enable command always returns success, and the disable command always
    returns failed because SST-BF cannot be enabled or disabled from the OS on
    CascadeLake-N.
    
    Enable command also have support for --auto|-a option, which sets cpufreq
    scaling_min to max, so that the high priority base frequency can be the
    required minimum for high priority cores. Disable command with -a/--auto
    option reset the setting back to the min frequency.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 3c0eb4240df4..1c20048b42e7 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1005,6 +1005,26 @@ static void set_tdp_level(int arg)
 	isst_ctdp_display_information_end(outf);
 }
 
+static void clx_n_dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2,
+				       void *arg3, void *arg4)
+{
+	int ret;
+
+	ret = clx_n_config(cpu);
+	if (ret) {
+		perror("isst_get_process_ctdp");
+	} else {
+		struct isst_pkg_ctdp_level_info *ctdp_level;
+		struct isst_pbf_info *pbf_info;
+
+		ctdp_level = &clx_n_pkg_dev.ctdp_level[0];
+		pbf_info = &ctdp_level->pbf_info;
+		isst_pbf_display_information(cpu, outf, tdp_level, pbf_info);
+		free_cpu_set(ctdp_level->core_cpumask);
+		free_cpu_set(pbf_info->core_cpumask);
+	}
+}
+
 static void dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 				    void *arg4)
 {
@@ -1022,6 +1042,8 @@ static void dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 
 static void dump_pbf_config(int arg)
 {
+	void *fn;
+
 	if (cmd_help) {
 		fprintf(stderr,
 			"Print Intel(R) Speed Select Technology base frequency configuration for a TDP level\n");
@@ -1035,13 +1057,18 @@ static void dump_pbf_config(int arg)
 		exit(1);
 	}
 
+	if (!is_clx_n_platform())
+		fn = dump_pbf_config_for_cpu;
+	else
+		fn = clx_n_dump_pbf_config_for_cpu;
+
 	isst_ctdp_display_information_start(outf);
+
 	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(dump_pbf_config_for_cpu, NULL,
-						  NULL, NULL, NULL);
+		for_each_online_target_cpu_in_set(fn, NULL, NULL, NULL, NULL);
 	else
-		for_each_online_package_in_set(dump_pbf_config_for_cpu, NULL,
-					       NULL, NULL, NULL);
+		for_each_online_package_in_set(fn, NULL, NULL, NULL, NULL);
+
 	isst_ctdp_display_information_end(outf);
 }
 
@@ -1235,6 +1262,19 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int ret;
 	int status = *(int *)arg4;
 
+	if (is_clx_n_platform()) {
+		if (status == 0) {
+			ret = -1;
+			if (auto_mode)
+				set_scaling_min_to_cpuinfo_min(cpu);
+		} else {
+			ret = 0;
+			if (auto_mode)
+				set_scaling_min_to_cpuinfo_max(cpu);
+		}
+		goto disp_result;
+	}
+
 	if (auto_mode) {
 		if (status) {
 			ret = set_pbf_core_power(cpu);
@@ -1763,6 +1803,9 @@ static void get_clos_assoc(int arg)
 
 static struct process_cmd_struct clx_n_cmds[] = {
 	{ "perf-profile", "info", dump_isst_config, 0 },
+	{ "base-freq", "info", dump_pbf_config, 0 },
+	{ "base-freq", "enable", set_pbf_enable, 1 },
+	{ "base-freq", "disable", set_pbf_enable, 0 },
 	{ NULL, NULL, NULL, 0 }
 };
 

commit 062e4aac92e8acbab2fd135e90b580b903c3724b
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:44 2019 -0700

    tools/power/x86/intel-speed-select: Implement 'perf-profile info' on CascadeLake-N
    
    Add functionality for "perf-profile info" on CascadeLake-N.
    
    Sample output:
    intel-speed-select perf-profile info
    Intel(R) Speed Select Technology
    Executing on CPU model:85[0x55]
     package-0
      die-0
        cpu-0
          perf-profile-level-0
            cpu-count:20
            enable-cpu-mask:00000000,000fffff
            enable-cpu-list:0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
            thermal-design-power-ratio:23
            base-frequency(MHz):2300
            speed-select-turbo-freq:unsupported
            speed-select-base-freq:enabled
            speed-select-base-freq
              high-priority-base-frequency(MHz):2700000
              high-priority-cpu-mask:00000000,0000e8c0
              high-priority-cpu-list:6,7,11,13,14,15
              low-priority-base-frequency(MHz):2100000
     package-1
      die-0
        cpu-20
          perf-profile-level-0
            cpu-count:20
            enable-cpu-mask:000000ff,fff00000
            enable-cpu-list:20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39
            thermal-design-power-ratio:23
            base-frequency(MHz):2300
            speed-select-turbo-freq:unsupported
            speed-select-base-freq:enabled
            speed-select-base-freq
              high-priority-base-frequency(MHz):2700000
              high-priority-cpu-mask:0000000e,8c000000
              high-priority-cpu-list:26,27,31,33,34,35
              low-priority-base-frequency(MHz):2100000
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 449025c6ea46..3c0eb4240df4 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -750,6 +750,152 @@ _get_tdp_level("get-config-current_level", levels, current_level,
 	       "Current TDP Level");
 _get_tdp_level("get-lock-status", levels, locked, "TDP lock status");
 
+struct isst_pkg_ctdp clx_n_pkg_dev;
+
+static int clx_n_get_base_ratio(void)
+{
+	FILE *fp;
+	char *begin, *end, *line = NULL;
+	char number[5];
+	float value = 0;
+	size_t n = 0;
+
+	fp = fopen("/proc/cpuinfo", "r");
+	if (!fp)
+		err(-1, "cannot open /proc/cpuinfo\n");
+
+	while (getline(&line, &n, fp) > 0) {
+		if (strstr(line, "model name")) {
+			/* this is true for CascadeLake-N */
+			begin = strstr(line, "@ ") + 2;
+			end = strstr(line, "GHz");
+			strncpy(number, begin, end - begin);
+			value = atof(number) * 10;
+			break;
+		}
+	}
+	free(line);
+	fclose(fp);
+
+	return (int)(value);
+}
+
+static int clx_n_config(int cpu)
+{
+	int i, ret, pkg_id, die_id;
+	unsigned long cpu_bf;
+	struct isst_pkg_ctdp_level_info *ctdp_level;
+	struct isst_pbf_info *pbf_info;
+
+	ctdp_level = &clx_n_pkg_dev.ctdp_level[0];
+	pbf_info = &ctdp_level->pbf_info;
+	ctdp_level->core_cpumask_size =
+			alloc_cpu_set(&ctdp_level->core_cpumask);
+
+	/* find the frequency base ratio */
+	ctdp_level->tdp_ratio = clx_n_get_base_ratio();
+	if (ctdp_level->tdp_ratio == 0) {
+		debug_printf("CLX: cn base ratio is zero\n");
+		ret = -1;
+		goto error_ret;
+	}
+
+	/* find the high and low priority frequencies */
+	pbf_info->p1_high = 0;
+	pbf_info->p1_low = ~0;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+
+	for (i = 0; i < topo_max_cpus; i++) {
+		if (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))
+			continue;
+
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		CPU_SET_S(i, ctdp_level->core_cpumask_size,
+			  ctdp_level->core_cpumask);
+
+		cpu_bf = parse_int_file(1,
+			"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency",
+					i);
+		if (cpu_bf > pbf_info->p1_high)
+			pbf_info->p1_high = cpu_bf;
+		if (cpu_bf < pbf_info->p1_low)
+			pbf_info->p1_low = cpu_bf;
+	}
+
+	if (pbf_info->p1_high == ~0UL) {
+		debug_printf("CLX: maximum base frequency not set\n");
+		ret = -1;
+		goto error_ret;
+	}
+
+	if (pbf_info->p1_low == 0) {
+		debug_printf("CLX: minimum base frequency not set\n");
+		ret = -1;
+		goto error_ret;
+	}
+
+	/* convert frequencies back to ratios */
+	pbf_info->p1_high = pbf_info->p1_high / DISP_FREQ_MULTIPLIER;
+	pbf_info->p1_low = pbf_info->p1_low / DISP_FREQ_MULTIPLIER;
+
+	/* create high priority cpu mask */
+	pbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);
+	for (i = 0; i < topo_max_cpus; i++) {
+		if (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))
+			continue;
+
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		cpu_bf = parse_int_file(1,
+			"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency",
+					i);
+		cpu_bf = cpu_bf / DISP_FREQ_MULTIPLIER;
+		if (cpu_bf == pbf_info->p1_high)
+			CPU_SET_S(i, pbf_info->core_cpumask_size,
+				  pbf_info->core_cpumask);
+	}
+
+	/* extra ctdp & pbf struct parameters */
+	ctdp_level->processed = 1;
+	ctdp_level->pbf_support = 1; /* PBF is always supported and enabled */
+	ctdp_level->pbf_enabled = 1;
+	ctdp_level->fact_support = 0; /* FACT is never supported */
+	ctdp_level->fact_enabled = 0;
+
+	return 0;
+
+error_ret:
+	free_cpu_set(ctdp_level->core_cpumask);
+	return ret;
+}
+
+static void dump_clx_n_config_for_cpu(int cpu, void *arg1, void *arg2,
+				   void *arg3, void *arg4)
+{
+	int ret;
+
+	ret = clx_n_config(cpu);
+	if (ret) {
+		perror("isst_get_process_ctdp");
+	} else {
+		struct isst_pkg_ctdp_level_info *ctdp_level;
+		struct isst_pbf_info *pbf_info;
+
+		ctdp_level = &clx_n_pkg_dev.ctdp_level[0];
+		pbf_info = &ctdp_level->pbf_info;
+		isst_ctdp_display_information(cpu, outf, tdp_level, &clx_n_pkg_dev);
+		free_cpu_set(ctdp_level->core_cpumask);
+		free_cpu_set(pbf_info->core_cpumask);
+	}
+}
+
 static void dump_isst_config_for_cpu(int cpu, void *arg1, void *arg2,
 				     void *arg3, void *arg4)
 {
@@ -768,6 +914,8 @@ static void dump_isst_config_for_cpu(int cpu, void *arg1, void *arg2,
 
 static void dump_isst_config(int arg)
 {
+	void *fn;
+
 	if (cmd_help) {
 		fprintf(stderr,
 			"Print Intel(R) Speed Select Technology Performance profile configuration\n");
@@ -779,14 +927,17 @@ static void dump_isst_config(int arg)
 		exit(0);
 	}
 
+	if (!is_clx_n_platform())
+		fn = dump_isst_config_for_cpu;
+	else
+		fn = dump_clx_n_config_for_cpu;
+
 	isst_ctdp_display_information_start(outf);
 
 	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(dump_isst_config_for_cpu,
-						  NULL, NULL, NULL, NULL);
+		for_each_online_target_cpu_in_set(fn, NULL, NULL, NULL, NULL);
 	else
-		for_each_online_package_in_set(dump_isst_config_for_cpu, NULL,
-					       NULL, NULL, NULL);
+		for_each_online_package_in_set(fn, NULL, NULL, NULL, NULL);
 
 	isst_ctdp_display_information_end(outf);
 }
@@ -1611,6 +1762,7 @@ static void get_clos_assoc(int arg)
 }
 
 static struct process_cmd_struct clx_n_cmds[] = {
+	{ "perf-profile", "info", dump_isst_config, 0 },
 	{ NULL, NULL, NULL, 0 }
 };
 
@@ -1888,7 +2040,8 @@ void process_command(int argc, char **argv,
 		}
 	}
 
-	create_cpu_map();
+	if (!is_clx_n_platform())
+		create_cpu_map();
 
 	i = 0;
 	while (cmds[i].feature) {

commit c829f0ef7bfc4b294e67506779853547e8b52c68
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:43 2019 -0700

    tools/power/x86/intel-speed-select: Implement CascadeLake-N help and command functions structures
    
    CascadeLake-N only supports SST-BF and needs some of the perf-profile
    commands, and the base-freq commands.
    
    Add help functions, and create an empty command structures (the functions
    will be implemented later in this patchset).  Call these functions
    when running on CascadeLake-N.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 67a866e2dac4..449025c6ea46 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1610,6 +1610,10 @@ static void get_clos_assoc(int arg)
 	isst_ctdp_display_information_end(outf);
 }
 
+static struct process_cmd_struct clx_n_cmds[] = {
+	{ NULL, NULL, NULL, 0 }
+};
+
 static struct process_cmd_struct isst_cmds[] = {
 	{ "perf-profile", "get-lock-status", get_tdp_locked, 0 },
 	{ "perf-profile", "get-config-levels", get_tdp_levels, 0 },
@@ -1798,12 +1802,15 @@ static void isst_help(void)
 		TDP, etc.\n");
 	printf("\nCommands : For feature=perf-profile\n");
 	printf("\tinfo\n");
-	printf("\tget-lock-status\n");
-	printf("\tget-config-levels\n");
-	printf("\tget-config-version\n");
-	printf("\tget-config-enabled\n");
-	printf("\tget-config-current-level\n");
-	printf("\tset-config-level\n");
+
+	if (!is_clx_n_platform()) {
+		printf("\tget-lock-status\n");
+		printf("\tget-config-levels\n");
+		printf("\tget-config-version\n");
+		printf("\tget-config-enabled\n");
+		printf("\tget-config-current-level\n");
+		printf("\tset-config-level\n");
+	}
 }
 
 static void pbf_help(void)
@@ -1853,6 +1860,12 @@ static struct process_cmd_help_struct isst_help_cmds[] = {
 	{ NULL, NULL }
 };
 
+static struct process_cmd_help_struct clx_n_help_cmds[] = {
+	{ "perf-profile", isst_help },
+	{ "base-freq", pbf_help },
+	{ NULL, NULL }
+};
+
 void process_command(int argc, char **argv,
 		     struct process_cmd_help_struct *help_cmds,
 		     struct process_cmd_struct *cmds)
@@ -2001,11 +2014,15 @@ static void cmdline(int argc, char **argv)
 	set_max_cpu_num();
 	set_cpu_present_cpu_mask();
 	set_cpu_target_cpu_mask();
-	ret = isst_fill_platform_info();
-	if (ret)
-		goto out;
 
-	process_command(argc, argv, isst_help_cmds, isst_cmds);
+	if (!is_clx_n_platform()) {
+		ret = isst_fill_platform_info();
+		if (ret)
+			goto out;
+		process_command(argc, argv, isst_help_cmds, isst_cmds);
+	} else {
+		process_command(argc, argv, clx_n_help_cmds, clx_n_cmds);
+	}
 out:
 	free_cpu_set(present_cpumask);
 	free_cpu_set(target_cpumask);

commit 1c1d935c8418a63d110b2b31c57ba3d75f94f49d
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:42 2019 -0700

    tools/power/x86/intel-speed-select: Add check for CascadeLake-N models
    
    Three CascadeLake-N models (6252N, 6230N, and 5218N) have SST-PBF support.
    
    Return an error if the CascadeLake processor is not one of these specific
    models.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 907b79e16c68..67a866e2dac4 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -23,6 +23,7 @@ static int debug_flag;
 static FILE *outf;
 
 static int cpu_model;
+static int cpu_stepping;
 
 #define MAX_CPUS_IN_ONE_REQ 64
 static short max_target_cpus;
@@ -72,7 +73,16 @@ void debug_printf(const char *format, ...)
 	va_end(args);
 }
 
-static void update_cpu_model(void)
+
+int is_clx_n_platform(void)
+{
+	if (cpu_model == 0x55)
+		if (cpu_stepping == 0x6 || cpu_stepping == 0x7)
+			return 1;
+	return 0;
+}
+
+static int update_cpu_model(void)
 {
 	unsigned int ebx, ecx, edx;
 	unsigned int fms, family;
@@ -82,6 +92,33 @@ static void update_cpu_model(void)
 	cpu_model = (fms >> 4) & 0xf;
 	if (family == 6 || family == 0xf)
 		cpu_model += ((fms >> 16) & 0xf) << 4;
+
+	cpu_stepping = fms & 0xf;
+	/* only three CascadeLake-N models are supported */
+	if (is_clx_n_platform()) {
+		FILE *fp;
+		size_t n = 0;
+		char *line = NULL;
+		int ret = 1;
+
+		fp = fopen("/proc/cpuinfo", "r");
+		if (!fp)
+			err(-1, "cannot open /proc/cpuinfo\n");
+
+		while (getline(&line, &n, fp) > 0) {
+			if (strstr(line, "model name")) {
+				if (strstr(line, "6252N") ||
+				    strstr(line, "6230N") ||
+				    strstr(line, "5218N"))
+					ret = 0;
+				break;
+			}
+		}
+		free(line);
+		fclose(fp);
+		return ret;
+	}
+	return 0;
 }
 
 /* Open a file, and exit on failure */
@@ -1956,7 +1993,9 @@ static void cmdline(int argc, char **argv)
 		fprintf(stderr, "Feature name and|or command not specified\n");
 		exit(0);
 	}
-	update_cpu_model();
+	ret = update_cpu_model();
+	if (ret)
+		err(-1, "Invalid CPU model (%d)\n", cpu_model);
 	printf("Intel(R) Speed Select Technology\n");
 	printf("Executing on CPU model:%d[0x%x]\n", cpu_model, cpu_model);
 	set_max_cpu_num();

commit 210369dc73b23fab1b9727fba35c2f83d00b6277
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:41 2019 -0700

    tools/power/x86/intel-speed-select: Make process_command generic
    
    Make the process_command take any help command and command list.  This
    will make it easier to help commands and a command list for CascadeLake-N.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 4927aebee306..907b79e16c68 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1816,7 +1816,9 @@ static struct process_cmd_help_struct isst_help_cmds[] = {
 	{ NULL, NULL }
 };
 
-void process_command(int argc, char **argv)
+void process_command(int argc, char **argv,
+		     struct process_cmd_help_struct *help_cmds,
+		     struct process_cmd_struct *cmds)
 {
 	int i = 0, matched = 0;
 	char *feature = argv[optind];
@@ -1827,9 +1829,9 @@ void process_command(int argc, char **argv)
 
 	debug_printf("feature name [%s] command [%s]\n", feature, cmd);
 	if (!strcmp(cmd, "-h") || !strcmp(cmd, "--help")) {
-		while (isst_help_cmds[i].feature) {
-			if (!strcmp(isst_help_cmds[i].feature, feature)) {
-				isst_help_cmds[i].process_fn();
+		while (help_cmds[i].feature) {
+			if (!strcmp(help_cmds[i].feature, feature)) {
+				help_cmds[i].process_fn();
 				exit(0);
 			}
 			++i;
@@ -1839,11 +1841,11 @@ void process_command(int argc, char **argv)
 	create_cpu_map();
 
 	i = 0;
-	while (isst_cmds[i].feature) {
-		if (!strcmp(isst_cmds[i].feature, feature) &&
-		    !strcmp(isst_cmds[i].command, cmd)) {
+	while (cmds[i].feature) {
+		if (!strcmp(cmds[i].feature, feature) &&
+		    !strcmp(cmds[i].command, cmd)) {
 			parse_cmd_args(argc, optind + 1, argv);
-			isst_cmds[i].process_fn(isst_cmds[i].arg);
+			cmds[i].process_fn(cmds[i].arg);
 			matched = 1;
 			break;
 		}
@@ -1964,7 +1966,7 @@ static void cmdline(int argc, char **argv)
 	if (ret)
 		goto out;
 
-	process_command(argc, argv);
+	process_command(argc, argv, isst_help_cmds, isst_cmds);
 out:
 	free_cpu_set(present_cpumask);
 	free_cpu_set(target_cpumask);

commit ce1326a2f9f7bf8920bc7f07e7b13ce8737b4681
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Oct 10 13:29:40 2019 -0700

    tools/power/x86/intel-speed-select: Add int argument to command functions
    
    The current code structure has similar but separate command functions for
    the enable and disable operations.  This can be improved by adding an int
    argument to the command function structure, and interpreting 1 as enable
    and 0 as disable.  This change results in the removal of the disable
    command functions.
    
    Add int argument to the command function structure.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index e1ca7c5b8037..4927aebee306 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -11,7 +11,8 @@
 struct process_cmd_struct {
 	char *feature;
 	char *command;
-	void (*process_fn)(void);
+	void (*process_fn)(int arg);
+	int arg;
 };
 
 static const char *version_str = "v1.0";
@@ -682,7 +683,7 @@ static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 }
 
 #define _get_tdp_level(desc, suffix, object, help)                                \
-	static void get_tdp_##object(void)                                        \
+	static void get_tdp_##object(int arg)                                    \
 	{                                                                         \
 		struct isst_pkg_ctdp ctdp;                                        \
 \
@@ -728,7 +729,7 @@ static void dump_isst_config_for_cpu(int cpu, void *arg1, void *arg2,
 	}
 }
 
-static void dump_isst_config(void)
+static void dump_isst_config(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -791,7 +792,7 @@ static void set_tdp_level_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	}
 }
 
-static void set_tdp_level(void)
+static void set_tdp_level(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr, "Set Config TDP level\n");
@@ -831,7 +832,7 @@ static void dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	}
 }
 
-static void dump_pbf_config(void)
+static void dump_pbf_config(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -1079,48 +1080,33 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 				    ret);
 }
 
-static void set_pbf_enable(void)
+static void set_pbf_enable(int arg)
 {
-	int status = 1;
+	int enable = arg;
 
 	if (cmd_help) {
-		fprintf(stderr,
-			"Enable Intel Speed Select Technology base frequency feature\n");
-		fprintf(stderr,
-			"\tOptional Arguments: -a|--auto : Use priority of cores to set core-power associations\n");
-
-		exit(0);
-	}
-
-	isst_ctdp_display_information_start(outf);
-	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(set_pbf_for_cpu, NULL, NULL,
-						  NULL, &status);
-	else
-		for_each_online_package_in_set(set_pbf_for_cpu, NULL, NULL,
-					       NULL, &status);
-	isst_ctdp_display_information_end(outf);
-}
-
-static void set_pbf_disable(void)
-{
-	int status = 0;
+		if (enable) {
+			fprintf(stderr,
+				"Enable Intel Speed Select Technology base frequency feature\n");
+			fprintf(stderr,
+				"\tOptional Arguments: -a|--auto : Use priority of cores to set core-power associations\n");
+		} else {
 
-	if (cmd_help) {
-		fprintf(stderr,
-			"Disable Intel Speed Select Technology base frequency feature\n");
-		fprintf(stderr,
-			"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
+			fprintf(stderr,
+				"Disable Intel Speed Select Technology base frequency feature\n");
+			fprintf(stderr,
+				"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
+		}
 		exit(0);
 	}
 
 	isst_ctdp_display_information_start(outf);
 	if (max_target_cpus)
 		for_each_online_target_cpu_in_set(set_pbf_for_cpu, NULL, NULL,
-						  NULL, &status);
+						  NULL, &enable);
 	else
 		for_each_online_package_in_set(set_pbf_for_cpu, NULL, NULL,
-					       NULL, &status);
+					       NULL, &enable);
 	isst_ctdp_display_information_end(outf);
 }
 
@@ -1138,7 +1124,7 @@ static void dump_fact_config_for_cpu(int cpu, void *arg1, void *arg2,
 					      fact_avx, &fact_info);
 }
 
-static void dump_fact_config(void)
+static void dump_fact_config(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -1213,31 +1199,41 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	}
 }
 
-static void set_fact_enable(void)
+static void set_fact_enable(int arg)
 {
-	int status = 1, i, ret;
+	int i, ret, enable = arg;
 
 	if (cmd_help) {
-		fprintf(stderr,
-			"Enable Intel Speed Select Technology Turbo frequency feature\n");
-		fprintf(stderr,
-			"Optional: -t|--trl : Specify turbo ratio limit\n");
-		fprintf(stderr,
-			"\tOptional Arguments: -a|--auto : Designate specified target CPUs with");
-		fprintf(stderr, "-C|--cpu option as as high priority using core-power feature\n");
+		if (enable) {
+			fprintf(stderr,
+				"Enable Intel Speed Select Technology Turbo frequency feature\n");
+			fprintf(stderr,
+				"Optional: -t|--trl : Specify turbo ratio limit\n");
+			fprintf(stderr,
+				"\tOptional Arguments: -a|--auto : Designate specified target CPUs with");
+			fprintf(stderr,
+				"-C|--cpu option as as high priority using core-power feature\n");
+		} else {
+			fprintf(stderr,
+				"Disable Intel Speed Select Technology turbo frequency feature\n");
+			fprintf(stderr,
+				"Optional: -t|--trl : Specify turbo ratio limit\n");
+			fprintf(stderr,
+				"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
+		}
 		exit(0);
 	}
 
 	isst_ctdp_display_information_start(outf);
 	if (max_target_cpus)
 		for_each_online_target_cpu_in_set(set_fact_for_cpu, NULL, NULL,
-						  NULL, &status);
+						  NULL, &enable);
 	else
 		for_each_online_package_in_set(set_fact_for_cpu, NULL, NULL,
-					       NULL, &status);
+					       NULL, &enable);
 	isst_ctdp_display_information_end(outf);
 
-	if (auto_mode) {
+	if (enable && auto_mode) {
 		/*
 		 * When we adjust CLOS param, we have to set for siblings also.
 		 * So for the each user specified CPU, also add the sibling
@@ -1315,30 +1311,6 @@ static void set_fact_enable(void)
 
 }
 
-static void set_fact_disable(void)
-{
-	int status = 0;
-
-	if (cmd_help) {
-		fprintf(stderr,
-			"Disable Intel Speed Select Technology turbo frequency feature\n");
-		fprintf(stderr,
-			"Optional: -t|--trl : Specify turbo ratio limit\n");
-		fprintf(stderr,
-			"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
-		exit(0);
-	}
-
-	isst_ctdp_display_information_start(outf);
-	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(set_fact_for_cpu, NULL, NULL,
-						  NULL, &status);
-	else
-		for_each_online_package_in_set(set_fact_for_cpu, NULL, NULL,
-					       NULL, &status);
-	isst_ctdp_display_information_end(outf);
-}
-
 static void enable_clos_qos_config(int cpu, void *arg1, void *arg2, void *arg3,
 				   void *arg4)
 {
@@ -1357,19 +1329,25 @@ static void enable_clos_qos_config(int cpu, void *arg1, void *arg2, void *arg3,
 				    ret);
 }
 
-static void set_clos_enable(void)
+static void set_clos_enable(int arg)
 {
-	int status = 1;
+	int enable = arg;
 
 	if (cmd_help) {
-		fprintf(stderr, "Enable core-power for a package/die\n");
-		fprintf(stderr,
-			"\tClos Enable: Specify priority type with [--priority|-p]\n");
-		fprintf(stderr, "\t\t 0: Proportional, 1: Ordered\n");
+		if (enable) {
+			fprintf(stderr,
+				"Enable core-power for a package/die\n");
+			fprintf(stderr,
+				"\tClos Enable: Specify priority type with [--priority|-p]\n");
+			fprintf(stderr, "\t\t 0: Proportional, 1: Ordered\n");
+		} else {
+			fprintf(stderr,
+				"Disable core-power: [No command arguments are required]\n");
+		}
 		exit(0);
 	}
 
-	if (cpufreq_sysfs_present()) {
+	if (enable && cpufreq_sysfs_present()) {
 		fprintf(stderr,
 			"cpufreq subsystem and core-power enable will interfere with each other!\n");
 	}
@@ -1377,30 +1355,10 @@ static void set_clos_enable(void)
 	isst_ctdp_display_information_start(outf);
 	if (max_target_cpus)
 		for_each_online_target_cpu_in_set(enable_clos_qos_config, NULL,
-						  NULL, NULL, &status);
-	else
-		for_each_online_package_in_set(enable_clos_qos_config, NULL,
-					       NULL, NULL, &status);
-	isst_ctdp_display_information_end(outf);
-}
-
-static void set_clos_disable(void)
-{
-	int status = 0;
-
-	if (cmd_help) {
-		fprintf(stderr,
-			"Disable core-power: [No command arguments are required]\n");
-		exit(0);
-	}
-
-	isst_ctdp_display_information_start(outf);
-	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(enable_clos_qos_config, NULL,
-						  NULL, NULL, &status);
+						  NULL, NULL, &enable);
 	else
 		for_each_online_package_in_set(enable_clos_qos_config, NULL,
-					       NULL, NULL, &status);
+					       NULL, NULL, &enable);
 	isst_ctdp_display_information_end(outf);
 }
 
@@ -1418,7 +1376,7 @@ static void dump_clos_config_for_cpu(int cpu, void *arg1, void *arg2,
 					      &clos_config);
 }
 
-static void dump_clos_config(void)
+static void dump_clos_config(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -1454,7 +1412,7 @@ static void get_clos_info_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		isst_clos_display_clos_information(cpu, outf, enable, prio_type);
 }
 
-static void dump_clos_info(void)
+static void dump_clos_info(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -1497,7 +1455,7 @@ static void set_clos_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		isst_display_result(cpu, outf, "core-power", "config", ret);
 }
 
-static void set_clos_config(void)
+static void set_clos_config(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr,
@@ -1561,7 +1519,7 @@ static void set_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		isst_display_result(cpu, outf, "core-power", "assoc", ret);
 }
 
-static void set_clos_assoc(void)
+static void set_clos_assoc(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr, "Associate a clos id to a CPU\n");
@@ -1595,7 +1553,7 @@ static void get_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 		isst_clos_display_assoc_information(cpu, outf, clos);
 }
 
-static void get_clos_assoc(void)
+static void get_clos_assoc(int arg)
 {
 	if (cmd_help) {
 		fprintf(stderr, "Get associate clos id to a CPU\n");
@@ -1616,26 +1574,27 @@ static void get_clos_assoc(void)
 }
 
 static struct process_cmd_struct isst_cmds[] = {
-	{ "perf-profile", "get-lock-status", get_tdp_locked },
-	{ "perf-profile", "get-config-levels", get_tdp_levels },
-	{ "perf-profile", "get-config-version", get_tdp_version },
-	{ "perf-profile", "get-config-enabled", get_tdp_enabled },
-	{ "perf-profile", "get-config-current-level", get_tdp_current_level },
-	{ "perf-profile", "set-config-level", set_tdp_level },
-	{ "perf-profile", "info", dump_isst_config },
-	{ "base-freq", "info", dump_pbf_config },
-	{ "base-freq", "enable", set_pbf_enable },
-	{ "base-freq", "disable", set_pbf_disable },
-	{ "turbo-freq", "info", dump_fact_config },
-	{ "turbo-freq", "enable", set_fact_enable },
-	{ "turbo-freq", "disable", set_fact_disable },
-	{ "core-power", "info", dump_clos_info },
-	{ "core-power", "enable", set_clos_enable },
-	{ "core-power", "disable", set_clos_disable },
-	{ "core-power", "config", set_clos_config },
-	{ "core-power", "get-config", dump_clos_config },
-	{ "core-power", "assoc", set_clos_assoc },
-	{ "core-power", "get-assoc", get_clos_assoc },
+	{ "perf-profile", "get-lock-status", get_tdp_locked, 0 },
+	{ "perf-profile", "get-config-levels", get_tdp_levels, 0 },
+	{ "perf-profile", "get-config-version", get_tdp_version, 0 },
+	{ "perf-profile", "get-config-enabled", get_tdp_enabled, 0 },
+	{ "perf-profile", "get-config-current-level", get_tdp_current_level,
+	 0 },
+	{ "perf-profile", "set-config-level", set_tdp_level, 0 },
+	{ "perf-profile", "info", dump_isst_config, 0 },
+	{ "base-freq", "info", dump_pbf_config, 0 },
+	{ "base-freq", "enable", set_pbf_enable, 1 },
+	{ "base-freq", "disable", set_pbf_enable, 0 },
+	{ "turbo-freq", "info", dump_fact_config, 0 },
+	{ "turbo-freq", "enable", set_fact_enable, 1 },
+	{ "turbo-freq", "disable", set_fact_enable, 0 },
+	{ "core-power", "info", dump_clos_info, 0 },
+	{ "core-power", "enable", set_clos_enable, 1 },
+	{ "core-power", "disable", set_clos_enable, 0 },
+	{ "core-power", "config", set_clos_config, 0 },
+	{ "core-power", "get-config", dump_clos_config, 0 },
+	{ "core-power", "assoc", set_clos_assoc, 0 },
+	{ "core-power", "get-assoc", get_clos_assoc, 0 },
 	{ NULL, NULL, NULL }
 };
 
@@ -1884,7 +1843,7 @@ void process_command(int argc, char **argv)
 		if (!strcmp(isst_cmds[i].feature, feature) &&
 		    !strcmp(isst_cmds[i].command, cmd)) {
 			parse_cmd_args(argc, optind + 1, argv);
-			isst_cmds[i].process_fn();
+			isst_cmds[i].process_fn(isst_cmds[i].arg);
 			matched = 1;
 			break;
 		}

commit a6a82f9bcd2ad3fab5f20fc406727dc62775db92
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 10 13:29:38 2019 -0700

    tools/power/x86/intel-speed-select: Turbo-freq feature auto mode
    
    Introduce --auto|-a option to turbo-freq enable feature, so that it
    does in one step for users who are OK by setting all passed target cores
    as high priority and set in CLOS 0 and remaining in CLOS 3. In this way,
    users don't have to take multiple steps to enable turbo-freq feature. For
    users who want more fine grain control, they can always use core-power
    feature to set custom CLOS configuration and assignment.
    
    While here also print the error to output when clos configuration fails.
    
    For example
    intel-speed-select -c 0-4 turbo-freq enable --auto
    
    The above command will enable turbo-freq and core-power feature. Also
    mark CPU 0 to CPU 4 as high priority.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 82502a38446e..e1ca7c5b8037 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1173,40 +1173,58 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	int ret;
 	int status = *(int *)arg4;
 
+	if (auto_mode) {
+		if (status) {
+			ret = isst_pm_qos_config(cpu, 1, 1);
+			if (ret)
+				goto disp_results;
+		} else {
+			isst_pm_qos_config(cpu, 0, 0);
+		}
+	}
+
 	ret = isst_set_pbf_fact_status(cpu, 0, status);
-	if (ret)
+	if (ret) {
 		perror("isst_set_fact");
-	else {
-		if (status) {
-			struct isst_pkg_ctdp pkg_dev;
+		if (auto_mode)
+			isst_pm_qos_config(cpu, 0, 0);
 
-			ret = isst_get_ctdp_levels(cpu, &pkg_dev);
-			if (ret) {
-				isst_display_result(cpu, outf, "turbo-freq",
-						    "enable", ret);
-				return;
-			}
+		goto disp_results;
+	}
+
+	/* Set TRL */
+	if (status) {
+		struct isst_pkg_ctdp pkg_dev;
+
+		ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+		if (!ret)
 			ret = isst_set_trl(cpu, fact_trl);
-			isst_display_result(cpu, outf, "turbo-freq", "enable",
-					    ret);
-		} else {
-			/* Since we modified TRL during Fact enable, restore it */
-			isst_set_trl_from_current_tdp(cpu, fact_trl);
-			isst_display_result(cpu, outf, "turbo-freq", "disable",
-					    ret);
-		}
+		if (ret && auto_mode)
+			isst_pm_qos_config(cpu, 0, 0);
+	}
+
+disp_results:
+	if (status) {
+		isst_display_result(cpu, outf, "turbo-freq", "enable", ret);
+	} else {
+		/* Since we modified TRL during Fact enable, restore it */
+		isst_set_trl_from_current_tdp(cpu, fact_trl);
+		isst_display_result(cpu, outf, "turbo-freq", "disable", ret);
 	}
 }
 
 static void set_fact_enable(void)
 {
-	int status = 1;
+	int status = 1, i, ret;
 
 	if (cmd_help) {
 		fprintf(stderr,
 			"Enable Intel Speed Select Technology Turbo frequency feature\n");
 		fprintf(stderr,
 			"Optional: -t|--trl : Specify turbo ratio limit\n");
+		fprintf(stderr,
+			"\tOptional Arguments: -a|--auto : Designate specified target CPUs with");
+		fprintf(stderr, "-C|--cpu option as as high priority using core-power feature\n");
 		exit(0);
 	}
 
@@ -1218,6 +1236,83 @@ static void set_fact_enable(void)
 		for_each_online_package_in_set(set_fact_for_cpu, NULL, NULL,
 					       NULL, &status);
 	isst_ctdp_display_information_end(outf);
+
+	if (auto_mode) {
+		/*
+		 * When we adjust CLOS param, we have to set for siblings also.
+		 * So for the each user specified CPU, also add the sibling
+		 * in the present_cpu_mask.
+		 */
+		for (i = 0; i < get_topo_max_cpus(); ++i) {
+			char buffer[128], sibling_list[128], *cpu_str;
+			int fd, len;
+
+			if (!CPU_ISSET_S(i, target_cpumask_size, target_cpumask))
+				continue;
+
+			snprintf(buffer, sizeof(buffer),
+				 "/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list", i);
+
+			fd = open(buffer, O_RDONLY);
+			if (fd < 0)
+				continue;
+
+			len = read(fd, sibling_list, sizeof(sibling_list));
+			close(fd);
+
+			if (len < 0)
+				continue;
+
+			cpu_str = strtok(sibling_list, ",");
+			while (cpu_str != NULL) {
+				int cpu;
+
+				sscanf(cpu_str, "%d", &cpu);
+				CPU_SET_S(cpu, target_cpumask_size, target_cpumask);
+				cpu_str = strtok(NULL, ",");
+			}
+		}
+
+		for (i = 0; i < get_topo_max_cpus(); ++i) {
+			int clos;
+
+			if (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))
+				continue;
+
+			ret = set_clos_param(i, 0, 0, 0, 0, 0xff);
+			if (ret)
+				goto error_disp;
+
+			ret = set_clos_param(i, 1, 15, 0, 0, 0xff);
+			if (ret)
+				goto error_disp;
+
+			ret = set_clos_param(i, 2, 15, 0, 0, 0xff);
+			if (ret)
+				goto error_disp;
+
+			ret = set_clos_param(i, 3, 15, 0, 0, 0xff);
+			if (ret)
+				goto error_disp;
+
+			if (CPU_ISSET_S(i, target_cpumask_size, target_cpumask))
+				clos = 0;
+			else
+				clos = 3;
+
+			debug_printf("Associate cpu: %d clos: %d\n", i, clos);
+			ret = isst_clos_associate(i, clos);
+			if (ret)
+				goto error_disp;
+		}
+		isst_display_result(i, outf, "turbo-freq --auto", "enable", 0);
+	}
+
+	return;
+
+error_disp:
+	isst_display_result(i, outf, "turbo-freq --auto", "enable", ret);
+
 }
 
 static void set_fact_disable(void)
@@ -1229,6 +1324,8 @@ static void set_fact_disable(void)
 			"Disable Intel Speed Select Technology turbo frequency feature\n");
 		fprintf(stderr,
 			"Optional: -t|--trl : Specify turbo ratio limit\n");
+		fprintf(stderr,
+			"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
 		exit(0);
 	}
 
@@ -1249,16 +1346,15 @@ static void enable_clos_qos_config(int cpu, void *arg1, void *arg2, void *arg3,
 	int status = *(int *)arg4;
 
 	ret = isst_pm_qos_config(cpu, status, clos_priority_type);
-	if (ret) {
+	if (ret)
 		perror("isst_pm_qos_config");
-	} else {
-		if (status)
-			isst_display_result(cpu, outf, "core-power", "enable",
-					    ret);
-		else
-			isst_display_result(cpu, outf, "core-power", "disable",
-					    ret);
-	}
+
+	if (status)
+		isst_display_result(cpu, outf, "core-power", "enable",
+				    ret);
+	else
+		isst_display_result(cpu, outf, "core-power", "disable",
+				    ret);
 }
 
 static void set_clos_enable(void)

commit 354bd06f40c4ba7b2f12d9f0f119dff62a2f922f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 10 13:29:37 2019 -0700

    tools/power/x86/intel-speed-select: Base-freq feature auto mode
    
    Introduce --auto|-a option to base-freq enable feature, so that it
    does in one step for users who are OK by setting all cores with higher
    base frequency to be set in CLOS 0 and remaining in CLOS 3. This option
    also sets corresponding clos.min to CLOS 0 and CLOS3. In this way, users
    don't have to take multiple steps to enable base-freq feature. For users
    who want more fine grain control, they can always use core-power feature
    to set custom CLOS configuration and assignment.
    
    Also adjust cpufreq/scaling_min_freq for higher and lower priority cores.
    
    For example user can use:
    intel-speed-select base-freq enable --auto
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 21fcfe621d3a..82502a38446e 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -39,6 +39,7 @@ static unsigned long long fact_trl;
 static int out_format_json;
 static int cmd_help;
 static int force_online_offline;
+static int auto_mode;
 
 /* clos related */
 static int current_clos = -1;
@@ -855,23 +856,227 @@ static void dump_pbf_config(void)
 	isst_ctdp_display_information_end(outf);
 }
 
+static int set_clos_param(int cpu, int clos, int epp, int wt, int min, int max)
+{
+	struct isst_clos_config clos_config;
+	int ret;
+
+	ret = isst_pm_get_clos(cpu, clos, &clos_config);
+	if (ret) {
+		perror("isst_pm_get_clos");
+		return ret;
+	}
+	clos_config.clos_min = min;
+	clos_config.clos_max = max;
+	clos_config.epp = epp;
+	clos_config.clos_prop_prio = wt;
+	ret = isst_set_clos(cpu, clos, &clos_config);
+	if (ret) {
+		perror("isst_pm_set_clos");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int set_cpufreq_cpuinfo_scaling_min(int cpu, int max)
+{
+	char buffer[128], min_freq[16];
+	int fd, ret, len;
+
+	if (!CPU_ISSET_S(cpu, present_cpumask_size, present_cpumask))
+		return -1;
+
+	if (max)
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq", cpu);
+	else
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_min_freq", cpu);
+
+	fd = open(buffer, O_RDONLY);
+	if (fd < 0)
+		return fd;
+
+	len = read(fd, min_freq, sizeof(min_freq));
+	close(fd);
+
+	if (len < 0)
+		return len;
+
+	snprintf(buffer, sizeof(buffer),
+		 "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq", cpu);
+
+	fd = open(buffer, O_WRONLY);
+	if (fd < 0)
+		return fd;
+
+	len = strlen(min_freq);
+	ret = write(fd, min_freq, len);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+	close(fd);
+
+	return 0;
+}
+
+static void set_scaling_min_to_cpuinfo_max(int cpu)
+{
+	int i, pkg_id, die_id;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+	for (i = 0; i < get_topo_max_cpus(); ++i) {
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		set_cpufreq_cpuinfo_scaling_min(i, 1);
+	}
+}
+
+static void set_scaling_min_to_cpuinfo_min(int cpu)
+{
+	int i, pkg_id, die_id;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+	for (i = 0; i < get_topo_max_cpus(); ++i) {
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		set_cpufreq_cpuinfo_scaling_min(i, 0);
+	}
+}
+
+static int set_core_priority_and_min(int cpu, int mask_size,
+				     cpu_set_t *cpu_mask, int min_high,
+				     int min_low)
+{
+	int pkg_id, die_id, ret, i;
+
+	if (!CPU_COUNT_S(mask_size, cpu_mask))
+		return -1;
+
+	ret = set_clos_param(cpu, 0, 0, 0, min_high, 0xff);
+	if (ret)
+		return ret;
+
+	ret = set_clos_param(cpu, 1, 15, 0, min_low, 0xff);
+	if (ret)
+		return ret;
+
+	ret = set_clos_param(cpu, 2, 15, 0, min_low, 0xff);
+	if (ret)
+		return ret;
+
+	ret = set_clos_param(cpu, 3, 15, 0, min_low, 0xff);
+	if (ret)
+		return ret;
+
+	pkg_id = get_physical_package_id(cpu);
+	die_id = get_physical_die_id(cpu);
+	for (i = 0; i < get_topo_max_cpus(); ++i) {
+		int clos;
+
+		if (pkg_id != get_physical_package_id(i) ||
+		    die_id != get_physical_die_id(i))
+			continue;
+
+		if (CPU_ISSET_S(i, mask_size, cpu_mask))
+			clos = 0;
+		else
+			clos = 3;
+
+		debug_printf("Associate cpu: %d clos: %d\n", i, clos);
+		ret = isst_clos_associate(i, clos);
+		if (ret) {
+			perror("isst_clos_associate");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int set_pbf_core_power(int cpu)
+{
+	struct isst_pbf_info pbf_info;
+	struct isst_pkg_ctdp pkg_dev;
+	int ret;
+
+	ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+	if (ret) {
+		perror("isst_get_ctdp_levels");
+		return ret;
+	}
+	debug_printf("Current_level: %d\n", pkg_dev.current_level);
+
+	ret = isst_get_pbf_info(cpu, pkg_dev.current_level, &pbf_info);
+	if (ret) {
+		perror("isst_get_pbf_info");
+		return ret;
+	}
+	debug_printf("p1_high: %d p1_low: %d\n", pbf_info.p1_high,
+		     pbf_info.p1_low);
+
+	ret = set_core_priority_and_min(cpu, pbf_info.core_cpumask_size,
+					pbf_info.core_cpumask,
+					pbf_info.p1_high, pbf_info.p1_low);
+	if (ret) {
+		perror("set_core_priority_and_min");
+		return ret;
+	}
+
+	ret = isst_pm_qos_config(cpu, 1, 1);
+	if (ret) {
+		perror("isst_pm_qos_config");
+		return ret;
+	}
+
+	return 0;
+}
+
 static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 			    void *arg4)
 {
 	int ret;
 	int status = *(int *)arg4;
 
+	if (auto_mode) {
+		if (status) {
+			ret = set_pbf_core_power(cpu);
+			if (ret)
+				goto disp_result;
+		} else {
+			isst_pm_qos_config(cpu, 0, 0);
+		}
+	}
+
 	ret = isst_set_pbf_fact_status(cpu, 1, status);
 	if (ret) {
 		perror("isst_set_pbf");
+		if (auto_mode)
+			isst_pm_qos_config(cpu, 0, 0);
 	} else {
-		if (status)
-			isst_display_result(cpu, outf, "base-freq", "enable",
-					    ret);
-		else
-			isst_display_result(cpu, outf, "base-freq", "disable",
-					    ret);
+		if (auto_mode) {
+			if (status)
+				set_scaling_min_to_cpuinfo_max(cpu);
+			else
+				set_scaling_min_to_cpuinfo_min(cpu);
+		}
 	}
+
+disp_result:
+	if (status)
+		isst_display_result(cpu, outf, "base-freq", "enable",
+				    ret);
+	else
+		isst_display_result(cpu, outf, "base-freq", "disable",
+				    ret);
 }
 
 static void set_pbf_enable(void)
@@ -880,7 +1085,10 @@ static void set_pbf_enable(void)
 
 	if (cmd_help) {
 		fprintf(stderr,
-			"Enable Intel Speed Select Technology base frequency feature [No command arguments are required]\n");
+			"Enable Intel Speed Select Technology base frequency feature\n");
+		fprintf(stderr,
+			"\tOptional Arguments: -a|--auto : Use priority of cores to set core-power associations\n");
+
 		exit(0);
 	}
 
@@ -900,7 +1108,9 @@ static void set_pbf_disable(void)
 
 	if (cmd_help) {
 		fprintf(stderr,
-			"Disable Intel Speed Select Technology base frequency feature [No command arguments are required]\n");
+			"Disable Intel Speed Select Technology base frequency feature\n");
+		fprintf(stderr,
+			"\tOptional Arguments: -a|--auto : Also disable core-power associations\n");
 		exit(0);
 	}
 
@@ -1420,15 +1630,19 @@ static void parse_cmd_args(int argc, int start, char **argv)
 		{ "max", required_argument, 0, 'm' },
 		{ "priority", required_argument, 0, 'p' },
 		{ "weight", required_argument, 0, 'w' },
+		{ "auto", no_argument, 0, 'a' },
 		{ 0, 0, 0, 0 }
 	};
 
 	option_index = start;
 
 	optind = start + 1;
-	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:ho",
+	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:hoa",
 				  long_options, &option_index)) != -1) {
 		switch (opt) {
+		case 'a':
+			auto_mode = 1;
+			break;
 		case 'b':
 			fact_bucket = atoi(optarg);
 			break;

commit abd120e3bdf3dd72ba1ed9ac077a861e0e3dc43a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Oct 10 13:29:36 2019 -0700

    tools/power/x86/intel-speed-select: Remove warning for unused result
    
    Fix warning for:
    isst-config.c: In function set_cpu_online_offline:
    isst-config.c:221:3: warning: ignoring return value of write,
    declared with attribute warn_unused_result [-Wunused-result]
       write(fd, "1\n", 2);
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 2a9890c8395a..21fcfe621d3a 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -169,7 +169,7 @@ int get_topo_max_cpus(void)
 static void set_cpu_online_offline(int cpu, int state)
 {
 	char buffer[128];
-	int fd;
+	int fd, ret;
 
 	snprintf(buffer, sizeof(buffer),
 		 "/sys/devices/system/cpu/cpu%d/online", cpu);
@@ -179,9 +179,12 @@ static void set_cpu_online_offline(int cpu, int state)
 		err(-1, "%s open failed", buffer);
 
 	if (state)
-		write(fd, "1\n", 2);
+		ret = write(fd, "1\n", 2);
 	else
-		write(fd, "0\n", 2);
+		ret = write(fd, "0\n", 2);
+
+	if (ret == -1)
+		perror("Online/Offline: Operation failed\n");
 
 	close(fd);
 }

commit b3abfd778bf1dbdd96f70bd7d00671d027f67c62
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Sep 17 17:52:37 2019 -0700

    tools/power/x86/intel-speed-select: Fix perf-profile command output
    
    commit "c016ae8f9fa04d361efc8629de49ad3af12b5262
    "tools/power/x86/intel-speed-select: Output success/failed for command
    output" introduced a regression in perf-profile outputs. With this
    the result field is changed to string interpreting every non zero
    value as errors. But these commands display on zero (>0) result.
    For example before this commit the display was:
    
    package-1
      die-0
        cpu-14
            get-config-levels:4
    
    Here the get-config-levels is interpreted as error and displayed
    as error with the above commit:
    
    package-1
      die-0
        cpu-14
            get-config-levels:failed(error 4)
    
    Fix this issue by not using isst_display_result() to display such results,
    but define a new function which formats this data and prints.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 6a54e165672d..2a9890c8395a 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -673,8 +673,8 @@ static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	if (ret)
 		perror("get_tdp_*");
 	else
-		isst_display_result(cpu, outf, "perf-profile", (char *)arg3,
-				    *(unsigned int *)arg4);
+		isst_ctdp_display_core_info(cpu, outf, arg3,
+					    *(unsigned int *)arg4);
 }
 
 #define _get_tdp_level(desc, suffix, object, help)                                \

commit 188afed9db7db3aefc8c9c33150be2f8f398da9a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Sep 14 12:45:47 2019 -0700

    tools/power/x86/intel-speed-select: Extend core-power command set
    
    Add additional command to get the clos enable and priority type. The
    current info option is actually dumping per clos QOS config, so name
    the command appropriately to get-config.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 889396d676cb..6a54e165672d 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1133,6 +1133,40 @@ static void dump_clos_config(void)
 	isst_ctdp_display_information_end(outf);
 }
 
+static void get_clos_info_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				  void *arg4)
+{
+	int enable, ret, prio_type;
+
+	ret = isst_clos_get_clos_information(cpu, &enable, &prio_type);
+	if (ret)
+		perror("isst_clos_get_info");
+	else
+		isst_clos_display_clos_information(cpu, outf, enable, prio_type);
+}
+
+static void dump_clos_info(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Print Intel Speed Select Technology core power information\n");
+		fprintf(stderr, "\tSpecify targeted cpu id with [--cpu|-c]\n");
+		exit(0);
+	}
+
+	if (!max_target_cpus) {
+		fprintf(stderr,
+			"Invalid target cpu. Specify with [-c|--cpu]\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	for_each_online_target_cpu_in_set(get_clos_info_for_cpu, NULL,
+					  NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+
+}
+
 static void set_clos_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 				    void *arg4)
 {
@@ -1286,10 +1320,11 @@ static struct process_cmd_struct isst_cmds[] = {
 	{ "turbo-freq", "info", dump_fact_config },
 	{ "turbo-freq", "enable", set_fact_enable },
 	{ "turbo-freq", "disable", set_fact_disable },
-	{ "core-power", "info", dump_clos_config },
+	{ "core-power", "info", dump_clos_info },
 	{ "core-power", "enable", set_clos_enable },
 	{ "core-power", "disable", set_clos_disable },
 	{ "core-power", "config", set_clos_config },
+	{ "core-power", "get-config", dump_clos_config },
 	{ "core-power", "assoc", set_clos_assoc },
 	{ "core-power", "get-assoc", get_clos_assoc },
 	{ NULL, NULL, NULL }
@@ -1491,6 +1526,7 @@ static void core_power_help(void)
 	printf("\tenable\n");
 	printf("\tdisable\n");
 	printf("\tconfig\n");
+	printf("\tget-config\n");
 	printf("\tassoc\n");
 	printf("\tget-assoc\n");
 }

commit d2d1f304dc965e6a06e7f105b09bffceb477fccc
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Sep 14 12:45:46 2019 -0700

    tools/power/x86/intel-speed-select: Fix some debug prints
    
    Fix wrong debug print for cpu, which is displayed as CLOS. Also
    avoid printing clos id, when user is specify clos as parameter.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index c2892d86be36..889396d676cb 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -508,7 +508,7 @@ int isst_send_mbox_command(unsigned int cpu, unsigned char command,
 		int write = 0;
 		int clos_id, core_id, ret = 0;
 
-		debug_printf("CLOS %d\n", cpu);
+		debug_printf("CPU %d\n", cpu);
 
 		if (parameter & BIT(MBOX_CMD_WRITE_BIT)) {
 			value = req_data;
@@ -1421,7 +1421,6 @@ static void parse_cmd_args(int argc, int start, char **argv)
 		/* CLOS related */
 		case 'c':
 			current_clos = atoi(optarg);
-			printf("clos %d\n", current_clos);
 			break;
 		case 'd':
 			clos_desired = atoi(optarg);

commit e118fbe366d817175b2c47bfa338959bbff5bd37
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Sep 14 12:45:45 2019 -0700

    tools/power/x86/intel-speed-select: Format get-assoc information
    
    Format the get-assoc command output consistant with other commands.
    For example:
    
    Intel(R) Speed Select Technology
    Executing on CPU model:142[0x8e]
     package-0
      die-0
        cpu-0
          get-assoc
            clos:0
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index e505aaf2beef..c2892d86be36 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1249,7 +1249,7 @@ static void get_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	if (ret)
 		perror("isst_clos_get_assoc_status");
 	else
-		isst_display_result(cpu, outf, "core-power", "get-assoc", clos);
+		isst_clos_display_assoc_information(cpu, outf, clos);
 }
 
 static void get_clos_assoc(void)
@@ -1259,13 +1259,17 @@ static void get_clos_assoc(void)
 		fprintf(stderr, "\tSpecify targeted cpu id with [--cpu|-c]\n");
 		exit(0);
 	}
-	if (max_target_cpus)
-		for_each_online_target_cpu_in_set(get_clos_assoc_for_cpu, NULL,
-						  NULL, NULL, NULL);
-	else {
+
+	if (!max_target_cpus) {
 		fprintf(stderr,
 			"Invalid target cpu. Specify with [-c|--cpu]\n");
+		exit(0);
 	}
+
+	isst_ctdp_display_information_start(outf);
+	for_each_online_target_cpu_in_set(get_clos_assoc_for_cpu, NULL,
+					  NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
 }
 
 static struct process_cmd_struct isst_cmds[] = {

commit 3c64c81ad1f06823b603e9143193dcb4f3121a2f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Sep 14 12:45:44 2019 -0700

    tools/power/x86/intel-speed-select: Allow online/offline based on tdp
    
    Using enable core mask, do online offline CPUs. There is a new option
    --online|-o for set-config-level.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 83ac72902b36..e505aaf2beef 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -38,6 +38,7 @@ static int fact_avx = 0xFF;
 static unsigned long long fact_trl;
 static int out_format_json;
 static int cmd_help;
+static int force_online_offline;
 
 /* clos related */
 static int current_clos = -1;
@@ -138,14 +139,14 @@ int out_format_is_json(void)
 int get_physical_package_id(int cpu)
 {
 	return parse_int_file(
-		1, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id",
+		0, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id",
 		cpu);
 }
 
 int get_physical_core_id(int cpu)
 {
 	return parse_int_file(
-		1, "/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);
+		0, "/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);
 }
 
 int get_physical_die_id(int cpu)
@@ -165,6 +166,26 @@ int get_topo_max_cpus(void)
 	return topo_max_cpus;
 }
 
+static void set_cpu_online_offline(int cpu, int state)
+{
+	char buffer[128];
+	int fd;
+
+	snprintf(buffer, sizeof(buffer),
+		 "/sys/devices/system/cpu/cpu%d/online", cpu);
+
+	fd = open(buffer, O_WRONLY);
+	if (fd < 0)
+		err(-1, "%s open failed", buffer);
+
+	if (state)
+		write(fd, "1\n", 2);
+	else
+		write(fd, "0\n", 2);
+
+	close(fd);
+}
+
 #define MAX_PACKAGE_COUNT 8
 #define MAX_DIE_PER_PACKAGE 2
 static void for_each_online_package_in_set(void (*callback)(int, void *, void *,
@@ -736,9 +757,34 @@ static void set_tdp_level_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
 	ret = isst_set_tdp_level(cpu, tdp_level);
 	if (ret)
 		perror("set_tdp_level_for_cpu");
-	else
+	else {
 		isst_display_result(cpu, outf, "perf-profile", "set_tdp_level",
 				    ret);
+		if (force_online_offline) {
+			struct isst_pkg_ctdp_level_info ctdp_level;
+			int pkg_id = get_physical_package_id(cpu);
+			int die_id = get_physical_die_id(cpu);
+
+			fprintf(stderr, "Option is set to online/offline\n");
+			ctdp_level.core_cpumask_size =
+				alloc_cpu_set(&ctdp_level.core_cpumask);
+			isst_get_coremask_info(cpu, tdp_level, &ctdp_level);
+			if (ctdp_level.cpu_count) {
+				int i, max_cpus = get_topo_max_cpus();
+				for (i = 0; i < max_cpus; ++i) {
+					if (pkg_id != get_physical_package_id(i) || die_id != get_physical_die_id(i))
+						continue;
+					if (CPU_ISSET_S(i, ctdp_level.core_cpumask_size, ctdp_level.core_cpumask)) {
+						fprintf(stderr, "online cpu %d\n", i);
+						set_cpu_online_offline(i, 1);
+					} else {
+						fprintf(stderr, "offline cpu %d\n", i);
+						set_cpu_online_offline(i, 0);
+					}
+				}
+			}
+		}
+	}
 }
 
 static void set_tdp_level(void)
@@ -747,6 +793,8 @@ static void set_tdp_level(void)
 		fprintf(stderr, "Set Config TDP level\n");
 		fprintf(stderr,
 			"\t Arguments: -l|--level : Specify tdp level\n");
+		fprintf(stderr,
+			"\t Optional Arguments: -o | online : online/offline for the tdp level\n");
 		exit(0);
 	}
 
@@ -1319,6 +1367,7 @@ static void parse_cmd_args(int argc, int start, char **argv)
 	static struct option long_options[] = {
 		{ "bucket", required_argument, 0, 'b' },
 		{ "level", required_argument, 0, 'l' },
+		{ "online", required_argument, 0, 'o' },
 		{ "trl-type", required_argument, 0, 'r' },
 		{ "trl", required_argument, 0, 't' },
 		{ "help", no_argument, 0, 'h' },
@@ -1335,7 +1384,7 @@ static void parse_cmd_args(int argc, int start, char **argv)
 	option_index = start;
 
 	optind = start + 1;
-	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:h",
+	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:ho",
 				  long_options, &option_index)) != -1) {
 		switch (opt) {
 		case 'b':
@@ -1347,6 +1396,9 @@ static void parse_cmd_args(int argc, int start, char **argv)
 		case 'l':
 			tdp_level = atoi(optarg);
 			break;
+		case 'o':
+			force_online_offline = 1;
+			break;
 		case 't':
 			sscanf(optarg, "0x%llx", &fact_trl);
 			break;

commit 44460efe44e05eae2f21e57d06d542bbbb792e65
Author: Youquan Song <youquan.song@intel.com>
Date:   Sat Sep 14 12:45:43 2019 -0700

    tools/power/x86/intel-speed-select: Fix high priority core mask over count
    
    If the CPU package has the less logical CPU than topo_max_cpus, but un-present
    CPU's punit_cpu_core will be initiated to 0 and they will be count to core 0
    
    Like below, there are only 10 high priority cores (20 logical CPUs) in the CPU
    package, but it count to 27 logic CPUs.
    
    ./intel-speed-select base-freq info -l 0 | grep mask
            high-priority-cpu-mask:7f000179,f000179f
    
    With the fix patch:
    ./intel-speed-select base-freq info -l 0
            high-priority-cpu-mask:00000179,f000179f
    
    Signed-off-by: Youquan Song <youquan.song@intel.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 59753b3917bb..83ac72902b36 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -402,6 +402,9 @@ void set_cpu_mask_from_punit_coremask(int cpu, unsigned long long core_mask,
 			int j;
 
 			for (j = 0; j < topo_max_cpus; ++j) {
+				if (!CPU_ISSET_S(j, present_cpumask_size, present_cpumask))
+					continue;
+
 				if (cpu_map[j].pkg_id == pkg_id &&
 				    cpu_map[j].die_id == die_id &&
 				    cpu_map[j].punit_cpu_core == i) {

commit 3bc3d30ca324bfc3045a1a7fe1f5fe5ad5d92fd9
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Sep 5 08:03:11 2019 -0400

    tools/power/x86/intel-speed-select: Fix memory leak
    
    cpumasks are allocated by calling the alloc_cpu_mask() function and are
    never free'd.  They should be free'd after the commands have run.
    
    Fix the memory leaks by calling free_cpu_set().
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: David Arcari <darcari@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 78f0cebda1da..59753b3917bb 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -603,6 +603,10 @@ static int isst_fill_platform_info(void)
 
 	close(fd);
 
+	if (isst_platform_info.api_version > supported_api_ver) {
+		printf("Incompatible API versions; Upgrade of tool is required\n");
+		return -1;
+	}
 	return 0;
 }
 
@@ -1528,6 +1532,7 @@ static void cmdline(int argc, char **argv)
 {
 	int opt;
 	int option_index = 0;
+	int ret;
 
 	static struct option long_options[] = {
 		{ "cpu", required_argument, 0, 'c' },
@@ -1589,13 +1594,14 @@ static void cmdline(int argc, char **argv)
 	set_max_cpu_num();
 	set_cpu_present_cpu_mask();
 	set_cpu_target_cpu_mask();
-	isst_fill_platform_info();
-	if (isst_platform_info.api_version > supported_api_ver) {
-		printf("Incompatible API versions; Upgrade of tool is required\n");
-		exit(0);
-	}
+	ret = isst_fill_platform_info();
+	if (ret)
+		goto out;
 
 	process_command(argc, argv);
+out:
+	free_cpu_set(present_cpumask);
+	free_cpu_set(target_cpumask);
 }
 
 int main(int argc, char **argv)

commit 522586a9d5c32b5d7569237eebbfd8241f196419
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Sep 5 08:03:10 2019 -0400

    tools/power/x86/intel-speed-select: Output success/failed for command output
    
    Command output has confusing data, returning "0" on success.  For example
    
    |# ./intel-speed-select -c 14 turbo-freq enable
    Intel(R) Speed Select Technology
    Executing on CPU model:106[0x6a]
     package-1
       die-0
         cpu-14
           turbo-freq
             enable:0
    
    To avoid confusion change the command output to 'success' or 'failed'.
    
    v2: Remove help output line.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: David Arcari <darcari@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index f81a28c6b586..78f0cebda1da 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1514,7 +1514,6 @@ static void usage(void)
 	printf("\tResult display uses a common format for each command:\n");
 	printf("\tResults are formatted in text/JSON with\n");
 	printf("\t\tPackage, Die, CPU, and command specific results.\n");
-	printf("\t\t\tFor Set commands, status is 0 for success and rest for failures\n");
 	exit(1);
 }
 

commit 3ec2aef1b03eefeffe93817bd04068d3805d4a98
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Sep 5 08:03:05 2019 -0400

    tools/power/x86/intel-speed-select: Fix cpu-count output
    
    I have a system with 28 threads/socket but intel-speed-select reports
    a cpu-count of 29.
    
    Fix an off-by-one error in the cpu_count() function.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: David Arcari <darcari@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index d32af8210427..f81a28c6b586 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -304,7 +304,7 @@ static void set_cpu_present_cpu_mask(void)
 int get_cpu_count(int pkg_id, int die_id)
 {
 	if (pkg_id < MAX_PACKAGE_COUNT && die_id < MAX_DIE_PER_PACKAGE)
-		return cpu_cnt[pkg_id][die_id] + 1;
+		return cpu_cnt[pkg_id][die_id];
 
 	return 0;
 }

commit 43774c0dccb405a0b63a10829d45db4b74c29e40
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Sep 5 08:03:04 2019 -0400

    tools/power/x86/intel-speed-select: Fix help option typo
    
    Help is -h, not --h.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: David Arcari <darcari@redhat.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
index 91c5ad1685a1..d32af8210427 100644
--- a/tools/power/x86/intel-speed-select/isst-config.c
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -1491,7 +1491,7 @@ static void usage(void)
 	printf("intel-speed-select [OPTIONS] FEATURE COMMAND COMMAND_ARGUMENTS\n");
 	printf("\nUse this tool to enumerate and control the Intel Speed Select Technology features,\n");
 	printf("\nFEATURE : [perf-profile|base-freq|turbo-freq|core-power]\n");
-	printf("\nFor help on each feature, use --h|--help\n");
+	printf("\nFor help on each feature, use -h|--help\n");
 	printf("\tFor example:  intel-speed-select perf-profile -h\n");
 
 	printf("\nFor additional help on each command for a feature, use --h|--help\n");

commit 3fb4f7cd472c7f5905c91508e988f6b28372210d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sun Jun 30 10:14:08 2019 -0700

    tools/power/x86: A tool to validate Intel Speed Select commands
    
    The Intel(R) Speed select technologies contains four features.
    
    Performance profile:An non architectural mechanism that allows multiple
    optimized performance profiles per system via static and/or dynamic
    adjustment of core count, workload, Tjmax, and TDP, etc. aka ISS
    in the documentation.
    
    Base Frequency: Enables users to increase guaranteed base frequency on
    certain cores (high priority cores) in exchange for lower base frequency
    on remaining cores (low priority cores). aka PBF in the documenation.
    
    Turbo frequency: Enables the ability to set different turbo ratio limits
    to cores based on priority. aka FACT in the documentation.
    
    Core power: An Interface that allows user to define per core/tile
    priority.
    
    There is a multi level help for commands and options. This can be used
    to check required arguments for each feature and commands for the
    feature.
    
    To start navigating the features start with
    
    $sudo intel-speed-select --help
    
    For help on a specific feature for example
    $sudo intel-speed-select perf-profile --help
    
    To get help for a command for a feature for example
    $sudo intel-speed-select perf-profile get-lock-status --help
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
new file mode 100644
index 000000000000..91c5ad1685a1
--- /dev/null
+++ b/tools/power/x86/intel-speed-select/isst-config.c
@@ -0,0 +1,1607 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Speed Select -- Enumerate and control features
+ * Copyright (c) 2019 Intel Corporation.
+ */
+
+#include <linux/isst_if.h>
+
+#include "isst.h"
+
+struct process_cmd_struct {
+	char *feature;
+	char *command;
+	void (*process_fn)(void);
+};
+
+static const char *version_str = "v1.0";
+static const int supported_api_ver = 1;
+static struct isst_if_platform_info isst_platform_info;
+static char *progname;
+static int debug_flag;
+static FILE *outf;
+
+static int cpu_model;
+
+#define MAX_CPUS_IN_ONE_REQ 64
+static short max_target_cpus;
+static unsigned short target_cpus[MAX_CPUS_IN_ONE_REQ];
+
+static int topo_max_cpus;
+static size_t present_cpumask_size;
+static cpu_set_t *present_cpumask;
+static size_t target_cpumask_size;
+static cpu_set_t *target_cpumask;
+static int tdp_level = 0xFF;
+static int fact_bucket = 0xFF;
+static int fact_avx = 0xFF;
+static unsigned long long fact_trl;
+static int out_format_json;
+static int cmd_help;
+
+/* clos related */
+static int current_clos = -1;
+static int clos_epp = -1;
+static int clos_prop_prio = -1;
+static int clos_min = -1;
+static int clos_max = -1;
+static int clos_desired = -1;
+static int clos_priority_type;
+
+struct _cpu_map {
+	unsigned short core_id;
+	unsigned short pkg_id;
+	unsigned short die_id;
+	unsigned short punit_cpu;
+	unsigned short punit_cpu_core;
+};
+struct _cpu_map *cpu_map;
+
+void debug_printf(const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+
+	if (debug_flag)
+		vprintf(format, args);
+
+	va_end(args);
+}
+
+static void update_cpu_model(void)
+{
+	unsigned int ebx, ecx, edx;
+	unsigned int fms, family;
+
+	__cpuid(1, fms, ebx, ecx, edx);
+	family = (fms >> 8) & 0xf;
+	cpu_model = (fms >> 4) & 0xf;
+	if (family == 6 || family == 0xf)
+		cpu_model += ((fms >> 16) & 0xf) << 4;
+}
+
+/* Open a file, and exit on failure */
+static FILE *fopen_or_exit(const char *path, const char *mode)
+{
+	FILE *filep = fopen(path, mode);
+
+	if (!filep)
+		err(1, "%s: open failed", path);
+
+	return filep;
+}
+
+/* Parse a file containing a single int */
+static int parse_int_file(int fatal, const char *fmt, ...)
+{
+	va_list args;
+	char path[PATH_MAX];
+	FILE *filep;
+	int value;
+
+	va_start(args, fmt);
+	vsnprintf(path, sizeof(path), fmt, args);
+	va_end(args);
+	if (fatal) {
+		filep = fopen_or_exit(path, "r");
+	} else {
+		filep = fopen(path, "r");
+		if (!filep)
+			return -1;
+	}
+	if (fscanf(filep, "%d", &value) != 1)
+		err(1, "%s: failed to parse number from file", path);
+	fclose(filep);
+
+	return value;
+}
+
+int cpufreq_sysfs_present(void)
+{
+	DIR *dir;
+
+	dir = opendir("/sys/devices/system/cpu/cpu0/cpufreq");
+	if (dir) {
+		closedir(dir);
+		return 1;
+	}
+
+	return 0;
+}
+
+int out_format_is_json(void)
+{
+	return out_format_json;
+}
+
+int get_physical_package_id(int cpu)
+{
+	return parse_int_file(
+		1, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id",
+		cpu);
+}
+
+int get_physical_core_id(int cpu)
+{
+	return parse_int_file(
+		1, "/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);
+}
+
+int get_physical_die_id(int cpu)
+{
+	int ret;
+
+	ret = parse_int_file(0, "/sys/devices/system/cpu/cpu%d/topology/die_id",
+			     cpu);
+	if (ret < 0)
+		ret = 0;
+
+	return ret;
+}
+
+int get_topo_max_cpus(void)
+{
+	return topo_max_cpus;
+}
+
+#define MAX_PACKAGE_COUNT 8
+#define MAX_DIE_PER_PACKAGE 2
+static void for_each_online_package_in_set(void (*callback)(int, void *, void *,
+							    void *, void *),
+					   void *arg1, void *arg2, void *arg3,
+					   void *arg4)
+{
+	int max_packages[MAX_PACKAGE_COUNT * MAX_PACKAGE_COUNT];
+	int pkg_index = 0, i;
+
+	memset(max_packages, 0xff, sizeof(max_packages));
+	for (i = 0; i < topo_max_cpus; ++i) {
+		int j, online, pkg_id, die_id = 0, skip = 0;
+
+		if (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))
+			continue;
+		if (i)
+			online = parse_int_file(
+				1, "/sys/devices/system/cpu/cpu%d/online", i);
+		else
+			online =
+				1; /* online entry for CPU 0 needs some special configs */
+
+		die_id = get_physical_die_id(i);
+		if (die_id < 0)
+			die_id = 0;
+		pkg_id = get_physical_package_id(i);
+		/* Create an unique id for package, die combination to store */
+		pkg_id = (MAX_PACKAGE_COUNT * pkg_id + die_id);
+
+		for (j = 0; j < pkg_index; ++j) {
+			if (max_packages[j] == pkg_id) {
+				skip = 1;
+				break;
+			}
+		}
+
+		if (!skip && online && callback) {
+			callback(i, arg1, arg2, arg3, arg4);
+			max_packages[pkg_index++] = pkg_id;
+		}
+	}
+}
+
+static void for_each_online_target_cpu_in_set(
+	void (*callback)(int, void *, void *, void *, void *), void *arg1,
+	void *arg2, void *arg3, void *arg4)
+{
+	int i;
+
+	for (i = 0; i < topo_max_cpus; ++i) {
+		int online;
+
+		if (!CPU_ISSET_S(i, target_cpumask_size, target_cpumask))
+			continue;
+		if (i)
+			online = parse_int_file(
+				1, "/sys/devices/system/cpu/cpu%d/online", i);
+		else
+			online =
+				1; /* online entry for CPU 0 needs some special configs */
+
+		if (online && callback)
+			callback(i, arg1, arg2, arg3, arg4);
+	}
+}
+
+#define BITMASK_SIZE 32
+static void set_max_cpu_num(void)
+{
+	FILE *filep;
+	unsigned long dummy;
+
+	topo_max_cpus = 0;
+	filep = fopen_or_exit(
+		"/sys/devices/system/cpu/cpu0/topology/thread_siblings", "r");
+	while (fscanf(filep, "%lx,", &dummy) == 1)
+		topo_max_cpus += BITMASK_SIZE;
+	fclose(filep);
+	topo_max_cpus--; /* 0 based */
+
+	debug_printf("max cpus %d\n", topo_max_cpus);
+}
+
+size_t alloc_cpu_set(cpu_set_t **cpu_set)
+{
+	cpu_set_t *_cpu_set;
+	size_t size;
+
+	_cpu_set = CPU_ALLOC((topo_max_cpus + 1));
+	if (_cpu_set == NULL)
+		err(3, "CPU_ALLOC");
+	size = CPU_ALLOC_SIZE((topo_max_cpus + 1));
+	CPU_ZERO_S(size, _cpu_set);
+
+	*cpu_set = _cpu_set;
+	return size;
+}
+
+void free_cpu_set(cpu_set_t *cpu_set)
+{
+	CPU_FREE(cpu_set);
+}
+
+static int cpu_cnt[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE];
+static void set_cpu_present_cpu_mask(void)
+{
+	size_t size;
+	DIR *dir;
+	int i;
+
+	size = alloc_cpu_set(&present_cpumask);
+	present_cpumask_size = size;
+	for (i = 0; i < topo_max_cpus; ++i) {
+		char buffer[256];
+
+		snprintf(buffer, sizeof(buffer),
+			 "/sys/devices/system/cpu/cpu%d", i);
+		dir = opendir(buffer);
+		if (dir) {
+			int pkg_id, die_id;
+
+			CPU_SET_S(i, size, present_cpumask);
+			die_id = get_physical_die_id(i);
+			if (die_id < 0)
+				die_id = 0;
+
+			pkg_id = get_physical_package_id(i);
+			if (pkg_id < MAX_PACKAGE_COUNT &&
+			    die_id < MAX_DIE_PER_PACKAGE)
+				cpu_cnt[pkg_id][die_id]++;
+		}
+		closedir(dir);
+	}
+}
+
+int get_cpu_count(int pkg_id, int die_id)
+{
+	if (pkg_id < MAX_PACKAGE_COUNT && die_id < MAX_DIE_PER_PACKAGE)
+		return cpu_cnt[pkg_id][die_id] + 1;
+
+	return 0;
+}
+
+static void set_cpu_target_cpu_mask(void)
+{
+	size_t size;
+	int i;
+
+	size = alloc_cpu_set(&target_cpumask);
+	target_cpumask_size = size;
+	for (i = 0; i < max_target_cpus; ++i) {
+		if (!CPU_ISSET_S(target_cpus[i], present_cpumask_size,
+				 present_cpumask))
+			continue;
+
+		CPU_SET_S(target_cpus[i], size, target_cpumask);
+	}
+}
+
+static void create_cpu_map(void)
+{
+	const char *pathname = "/dev/isst_interface";
+	int i, fd = 0;
+	struct isst_if_cpu_maps map;
+
+	cpu_map = malloc(sizeof(*cpu_map) * topo_max_cpus);
+	if (!cpu_map)
+		err(3, "cpumap");
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	for (i = 0; i < topo_max_cpus; ++i) {
+		if (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))
+			continue;
+
+		map.cmd_count = 1;
+		map.cpu_map[0].logical_cpu = i;
+
+		debug_printf(" map logical_cpu:%d\n",
+			     map.cpu_map[0].logical_cpu);
+		if (ioctl(fd, ISST_IF_GET_PHY_ID, &map) == -1) {
+			perror("ISST_IF_GET_PHY_ID");
+			fprintf(outf, "Error: map logical_cpu:%d\n",
+				map.cpu_map[0].logical_cpu);
+			continue;
+		}
+		cpu_map[i].core_id = get_physical_core_id(i);
+		cpu_map[i].pkg_id = get_physical_package_id(i);
+		cpu_map[i].die_id = get_physical_die_id(i);
+		cpu_map[i].punit_cpu = map.cpu_map[0].physical_cpu;
+		cpu_map[i].punit_cpu_core = (map.cpu_map[0].physical_cpu >>
+					     1); // shift to get core id
+
+		debug_printf(
+			"map logical_cpu:%d core: %d die:%d pkg:%d punit_cpu:%d punit_core:%d\n",
+			i, cpu_map[i].core_id, cpu_map[i].die_id,
+			cpu_map[i].pkg_id, cpu_map[i].punit_cpu,
+			cpu_map[i].punit_cpu_core);
+	}
+
+	if (fd)
+		close(fd);
+}
+
+int find_logical_cpu(int pkg_id, int die_id, int punit_core_id)
+{
+	int i;
+
+	for (i = 0; i < topo_max_cpus; ++i) {
+		if (cpu_map[i].pkg_id == pkg_id &&
+		    cpu_map[i].die_id == die_id &&
+		    cpu_map[i].punit_cpu_core == punit_core_id)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+void set_cpu_mask_from_punit_coremask(int cpu, unsigned long long core_mask,
+				      size_t core_cpumask_size,
+				      cpu_set_t *core_cpumask, int *cpu_cnt)
+{
+	int i, cnt = 0;
+	int die_id, pkg_id;
+
+	*cpu_cnt = 0;
+	die_id = get_physical_die_id(cpu);
+	pkg_id = get_physical_package_id(cpu);
+
+	for (i = 0; i < 64; ++i) {
+		if (core_mask & BIT(i)) {
+			int j;
+
+			for (j = 0; j < topo_max_cpus; ++j) {
+				if (cpu_map[j].pkg_id == pkg_id &&
+				    cpu_map[j].die_id == die_id &&
+				    cpu_map[j].punit_cpu_core == i) {
+					CPU_SET_S(j, core_cpumask_size,
+						  core_cpumask);
+					++cnt;
+				}
+			}
+		}
+	}
+
+	*cpu_cnt = cnt;
+}
+
+int find_phy_core_num(int logical_cpu)
+{
+	if (logical_cpu < topo_max_cpus)
+		return cpu_map[logical_cpu].punit_cpu_core;
+
+	return -EINVAL;
+}
+
+static int isst_send_mmio_command(unsigned int cpu, unsigned int reg, int write,
+				  unsigned int *value)
+{
+	struct isst_if_io_regs io_regs;
+	const char *pathname = "/dev/isst_interface";
+	int cmd;
+	int fd;
+
+	debug_printf("mmio_cmd cpu:%d reg:%d write:%d\n", cpu, reg, write);
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	io_regs.req_count = 1;
+	io_regs.io_reg[0].logical_cpu = cpu;
+	io_regs.io_reg[0].reg = reg;
+	cmd = ISST_IF_IO_CMD;
+	if (write) {
+		io_regs.io_reg[0].read_write = 1;
+		io_regs.io_reg[0].value = *value;
+	} else {
+		io_regs.io_reg[0].read_write = 0;
+	}
+
+	if (ioctl(fd, cmd, &io_regs) == -1) {
+		perror("ISST_IF_IO_CMD");
+		fprintf(outf, "Error: mmio_cmd cpu:%d reg:%x read_write:%x\n",
+			cpu, reg, write);
+	} else {
+		if (!write)
+			*value = io_regs.io_reg[0].value;
+
+		debug_printf(
+			"mmio_cmd response: cpu:%d reg:%x rd_write:%x resp:%x\n",
+			cpu, reg, write, *value);
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+int isst_send_mbox_command(unsigned int cpu, unsigned char command,
+			   unsigned char sub_command, unsigned int parameter,
+			   unsigned int req_data, unsigned int *resp)
+{
+	const char *pathname = "/dev/isst_interface";
+	int fd;
+	struct isst_if_mbox_cmds mbox_cmds = { 0 };
+
+	debug_printf(
+		"mbox_send: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
+		cpu, command, sub_command, parameter, req_data);
+
+	if (isst_platform_info.mmio_supported && command == CONFIG_CLOS) {
+		unsigned int value;
+		int write = 0;
+		int clos_id, core_id, ret = 0;
+
+		debug_printf("CLOS %d\n", cpu);
+
+		if (parameter & BIT(MBOX_CMD_WRITE_BIT)) {
+			value = req_data;
+			write = 1;
+		}
+
+		switch (sub_command) {
+		case CLOS_PQR_ASSOC:
+			core_id = parameter & 0xff;
+			ret = isst_send_mmio_command(
+				cpu, PQR_ASSOC_OFFSET + core_id * 4, write,
+				&value);
+			if (!ret && !write)
+				*resp = value;
+			break;
+		case CLOS_PM_CLOS:
+			clos_id = parameter & 0x03;
+			ret = isst_send_mmio_command(
+				cpu, PM_CLOS_OFFSET + clos_id * 4, write,
+				&value);
+			if (!ret && !write)
+				*resp = value;
+			break;
+		case CLOS_PM_QOS_CONFIG:
+			ret = isst_send_mmio_command(cpu, PM_QOS_CONFIG_OFFSET,
+						     write, &value);
+			if (!ret && !write)
+				*resp = value;
+			break;
+		case CLOS_STATUS:
+			break;
+		default:
+			break;
+		}
+		return ret;
+	}
+
+	mbox_cmds.cmd_count = 1;
+	mbox_cmds.mbox_cmd[0].logical_cpu = cpu;
+	mbox_cmds.mbox_cmd[0].command = command;
+	mbox_cmds.mbox_cmd[0].sub_command = sub_command;
+	mbox_cmds.mbox_cmd[0].parameter = parameter;
+	mbox_cmds.mbox_cmd[0].req_data = req_data;
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	if (ioctl(fd, ISST_IF_MBOX_COMMAND, &mbox_cmds) == -1) {
+		perror("ISST_IF_MBOX_COMMAND");
+		fprintf(outf,
+			"Error: mbox_cmd cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\n",
+			cpu, command, sub_command, parameter, req_data);
+	} else {
+		*resp = mbox_cmds.mbox_cmd[0].resp_data;
+		debug_printf(
+			"mbox_cmd response: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x resp:%x\n",
+			cpu, command, sub_command, parameter, req_data, *resp);
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+int isst_send_msr_command(unsigned int cpu, unsigned int msr, int write,
+			  unsigned long long *req_resp)
+{
+	struct isst_if_msr_cmds msr_cmds;
+	const char *pathname = "/dev/isst_interface";
+	int fd;
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	msr_cmds.cmd_count = 1;
+	msr_cmds.msr_cmd[0].logical_cpu = cpu;
+	msr_cmds.msr_cmd[0].msr = msr;
+	msr_cmds.msr_cmd[0].read_write = write;
+	if (write)
+		msr_cmds.msr_cmd[0].data = *req_resp;
+
+	if (ioctl(fd, ISST_IF_MSR_COMMAND, &msr_cmds) == -1) {
+		perror("ISST_IF_MSR_COMMAD");
+		fprintf(outf, "Error: msr_cmd cpu:%d msr:%x read_write:%d\n",
+			cpu, msr, write);
+	} else {
+		if (!write)
+			*req_resp = msr_cmds.msr_cmd[0].data;
+
+		debug_printf(
+			"msr_cmd response: cpu:%d msr:%x rd_write:%x resp:%llx %llx\n",
+			cpu, msr, write, *req_resp, msr_cmds.msr_cmd[0].data);
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+static int isst_fill_platform_info(void)
+{
+	const char *pathname = "/dev/isst_interface";
+	int fd;
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	if (ioctl(fd, ISST_IF_GET_PLATFORM_INFO, &isst_platform_info) == -1) {
+		perror("ISST_IF_GET_PLATFORM_INFO");
+		close(fd);
+		return -1;
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+static void isst_print_platform_information(void)
+{
+	struct isst_if_platform_info platform_info;
+	const char *pathname = "/dev/isst_interface";
+	int fd;
+
+	fd = open(pathname, O_RDWR);
+	if (fd < 0)
+		err(-1, "%s open failed", pathname);
+
+	if (ioctl(fd, ISST_IF_GET_PLATFORM_INFO, &platform_info) == -1) {
+		perror("ISST_IF_GET_PLATFORM_INFO");
+	} else {
+		fprintf(outf, "Platform: API version : %d\n",
+			platform_info.api_version);
+		fprintf(outf, "Platform: Driver version : %d\n",
+			platform_info.driver_version);
+		fprintf(outf, "Platform: mbox supported : %d\n",
+			platform_info.mbox_supported);
+		fprintf(outf, "Platform: mmio supported : %d\n",
+			platform_info.mmio_supported);
+	}
+
+	close(fd);
+
+	exit(0);
+}
+
+static void exec_on_get_ctdp_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				 void *arg4)
+{
+	int (*fn_ptr)(int cpu, void *arg);
+	int ret;
+
+	fn_ptr = arg1;
+	ret = fn_ptr(cpu, arg2);
+	if (ret)
+		perror("get_tdp_*");
+	else
+		isst_display_result(cpu, outf, "perf-profile", (char *)arg3,
+				    *(unsigned int *)arg4);
+}
+
+#define _get_tdp_level(desc, suffix, object, help)                                \
+	static void get_tdp_##object(void)                                        \
+	{                                                                         \
+		struct isst_pkg_ctdp ctdp;                                        \
+\
+		if (cmd_help) {                                                   \
+			fprintf(stderr,                                           \
+				"Print %s [No command arguments are required]\n", \
+				help);                                            \
+			exit(0);                                                  \
+		}                                                                 \
+		isst_ctdp_display_information_start(outf);                        \
+		if (max_target_cpus)                                              \
+			for_each_online_target_cpu_in_set(                        \
+				exec_on_get_ctdp_cpu, isst_get_ctdp_##suffix,     \
+				&ctdp, desc, &ctdp.object);                       \
+		else                                                              \
+			for_each_online_package_in_set(exec_on_get_ctdp_cpu,      \
+						       isst_get_ctdp_##suffix,    \
+						       &ctdp, desc,               \
+						       &ctdp.object);             \
+		isst_ctdp_display_information_end(outf);                          \
+	}
+
+_get_tdp_level("get-config-levels", levels, levels, "TDP levels");
+_get_tdp_level("get-config-version", levels, version, "TDP version");
+_get_tdp_level("get-config-enabled", levels, enabled, "TDP enable status");
+_get_tdp_level("get-config-current_level", levels, current_level,
+	       "Current TDP Level");
+_get_tdp_level("get-lock-status", levels, locked, "TDP lock status");
+
+static void dump_isst_config_for_cpu(int cpu, void *arg1, void *arg2,
+				     void *arg3, void *arg4)
+{
+	struct isst_pkg_ctdp pkg_dev;
+	int ret;
+
+	memset(&pkg_dev, 0, sizeof(pkg_dev));
+	ret = isst_get_process_ctdp(cpu, tdp_level, &pkg_dev);
+	if (ret) {
+		perror("isst_get_process_ctdp");
+	} else {
+		isst_ctdp_display_information(cpu, outf, tdp_level, &pkg_dev);
+		isst_get_process_ctdp_complete(cpu, &pkg_dev);
+	}
+}
+
+static void dump_isst_config(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Print Intel(R) Speed Select Technology Performance profile configuration\n");
+		fprintf(stderr,
+			"including base frequency and turbo frequency configurations\n");
+		fprintf(stderr, "Optional: -l|--level : Specify tdp level\n");
+		fprintf(stderr,
+			"\tIf no arguments, dump information for all TDP levels\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(dump_isst_config_for_cpu,
+						  NULL, NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(dump_isst_config_for_cpu, NULL,
+					       NULL, NULL, NULL);
+
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_tdp_level_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				  void *arg4)
+{
+	int ret;
+
+	ret = isst_set_tdp_level(cpu, tdp_level);
+	if (ret)
+		perror("set_tdp_level_for_cpu");
+	else
+		isst_display_result(cpu, outf, "perf-profile", "set_tdp_level",
+				    ret);
+}
+
+static void set_tdp_level(void)
+{
+	if (cmd_help) {
+		fprintf(stderr, "Set Config TDP level\n");
+		fprintf(stderr,
+			"\t Arguments: -l|--level : Specify tdp level\n");
+		exit(0);
+	}
+
+	if (tdp_level == 0xff) {
+		fprintf(outf, "Invalid command: specify tdp_level\n");
+		exit(1);
+	}
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_tdp_level_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(set_tdp_level_for_cpu, NULL,
+					       NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void dump_pbf_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				    void *arg4)
+{
+	struct isst_pbf_info pbf_info;
+	int ret;
+
+	ret = isst_get_pbf_info(cpu, tdp_level, &pbf_info);
+	if (ret) {
+		perror("isst_get_pbf_info");
+	} else {
+		isst_pbf_display_information(cpu, outf, tdp_level, &pbf_info);
+		isst_get_pbf_info_complete(&pbf_info);
+	}
+}
+
+static void dump_pbf_config(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Print Intel(R) Speed Select Technology base frequency configuration for a TDP level\n");
+		fprintf(stderr,
+			"\tArguments: -l|--level : Specify tdp level\n");
+		exit(0);
+	}
+
+	if (tdp_level == 0xff) {
+		fprintf(outf, "Invalid command: specify tdp_level\n");
+		exit(1);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(dump_pbf_config_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(dump_pbf_config_for_cpu, NULL,
+					       NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+			    void *arg4)
+{
+	int ret;
+	int status = *(int *)arg4;
+
+	ret = isst_set_pbf_fact_status(cpu, 1, status);
+	if (ret) {
+		perror("isst_set_pbf");
+	} else {
+		if (status)
+			isst_display_result(cpu, outf, "base-freq", "enable",
+					    ret);
+		else
+			isst_display_result(cpu, outf, "base-freq", "disable",
+					    ret);
+	}
+}
+
+static void set_pbf_enable(void)
+{
+	int status = 1;
+
+	if (cmd_help) {
+		fprintf(stderr,
+			"Enable Intel Speed Select Technology base frequency feature [No command arguments are required]\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_pbf_for_cpu, NULL, NULL,
+						  NULL, &status);
+	else
+		for_each_online_package_in_set(set_pbf_for_cpu, NULL, NULL,
+					       NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_pbf_disable(void)
+{
+	int status = 0;
+
+	if (cmd_help) {
+		fprintf(stderr,
+			"Disable Intel Speed Select Technology base frequency feature [No command arguments are required]\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_pbf_for_cpu, NULL, NULL,
+						  NULL, &status);
+	else
+		for_each_online_package_in_set(set_pbf_for_cpu, NULL, NULL,
+					       NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void dump_fact_config_for_cpu(int cpu, void *arg1, void *arg2,
+				     void *arg3, void *arg4)
+{
+	struct isst_fact_info fact_info;
+	int ret;
+
+	ret = isst_get_fact_info(cpu, tdp_level, &fact_info);
+	if (ret)
+		perror("isst_get_fact_bucket_info");
+	else
+		isst_fact_display_information(cpu, outf, tdp_level, fact_bucket,
+					      fact_avx, &fact_info);
+}
+
+static void dump_fact_config(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Print complete Intel Speed Select Technology turbo frequency configuration for a TDP level. Other arguments are optional.\n");
+		fprintf(stderr,
+			"\tArguments: -l|--level : Specify tdp level\n");
+		fprintf(stderr,
+			"\tArguments: -b|--bucket : Bucket index to dump\n");
+		fprintf(stderr,
+			"\tArguments: -r|--trl-type : Specify trl type: sse|avx2|avx512\n");
+		exit(0);
+	}
+
+	if (tdp_level == 0xff) {
+		fprintf(outf, "Invalid command: specify tdp_level\n");
+		exit(1);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(dump_fact_config_for_cpu,
+						  NULL, NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(dump_fact_config_for_cpu, NULL,
+					       NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+			     void *arg4)
+{
+	int ret;
+	int status = *(int *)arg4;
+
+	ret = isst_set_pbf_fact_status(cpu, 0, status);
+	if (ret)
+		perror("isst_set_fact");
+	else {
+		if (status) {
+			struct isst_pkg_ctdp pkg_dev;
+
+			ret = isst_get_ctdp_levels(cpu, &pkg_dev);
+			if (ret) {
+				isst_display_result(cpu, outf, "turbo-freq",
+						    "enable", ret);
+				return;
+			}
+			ret = isst_set_trl(cpu, fact_trl);
+			isst_display_result(cpu, outf, "turbo-freq", "enable",
+					    ret);
+		} else {
+			/* Since we modified TRL during Fact enable, restore it */
+			isst_set_trl_from_current_tdp(cpu, fact_trl);
+			isst_display_result(cpu, outf, "turbo-freq", "disable",
+					    ret);
+		}
+	}
+}
+
+static void set_fact_enable(void)
+{
+	int status = 1;
+
+	if (cmd_help) {
+		fprintf(stderr,
+			"Enable Intel Speed Select Technology Turbo frequency feature\n");
+		fprintf(stderr,
+			"Optional: -t|--trl : Specify turbo ratio limit\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_fact_for_cpu, NULL, NULL,
+						  NULL, &status);
+	else
+		for_each_online_package_in_set(set_fact_for_cpu, NULL, NULL,
+					       NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_fact_disable(void)
+{
+	int status = 0;
+
+	if (cmd_help) {
+		fprintf(stderr,
+			"Disable Intel Speed Select Technology turbo frequency feature\n");
+		fprintf(stderr,
+			"Optional: -t|--trl : Specify turbo ratio limit\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_fact_for_cpu, NULL, NULL,
+						  NULL, &status);
+	else
+		for_each_online_package_in_set(set_fact_for_cpu, NULL, NULL,
+					       NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void enable_clos_qos_config(int cpu, void *arg1, void *arg2, void *arg3,
+				   void *arg4)
+{
+	int ret;
+	int status = *(int *)arg4;
+
+	ret = isst_pm_qos_config(cpu, status, clos_priority_type);
+	if (ret) {
+		perror("isst_pm_qos_config");
+	} else {
+		if (status)
+			isst_display_result(cpu, outf, "core-power", "enable",
+					    ret);
+		else
+			isst_display_result(cpu, outf, "core-power", "disable",
+					    ret);
+	}
+}
+
+static void set_clos_enable(void)
+{
+	int status = 1;
+
+	if (cmd_help) {
+		fprintf(stderr, "Enable core-power for a package/die\n");
+		fprintf(stderr,
+			"\tClos Enable: Specify priority type with [--priority|-p]\n");
+		fprintf(stderr, "\t\t 0: Proportional, 1: Ordered\n");
+		exit(0);
+	}
+
+	if (cpufreq_sysfs_present()) {
+		fprintf(stderr,
+			"cpufreq subsystem and core-power enable will interfere with each other!\n");
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(enable_clos_qos_config, NULL,
+						  NULL, NULL, &status);
+	else
+		for_each_online_package_in_set(enable_clos_qos_config, NULL,
+					       NULL, NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_clos_disable(void)
+{
+	int status = 0;
+
+	if (cmd_help) {
+		fprintf(stderr,
+			"Disable core-power: [No command arguments are required]\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(enable_clos_qos_config, NULL,
+						  NULL, NULL, &status);
+	else
+		for_each_online_package_in_set(enable_clos_qos_config, NULL,
+					       NULL, NULL, &status);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void dump_clos_config_for_cpu(int cpu, void *arg1, void *arg2,
+				     void *arg3, void *arg4)
+{
+	struct isst_clos_config clos_config;
+	int ret;
+
+	ret = isst_pm_get_clos(cpu, current_clos, &clos_config);
+	if (ret)
+		perror("isst_pm_get_clos");
+	else
+		isst_clos_display_information(cpu, outf, current_clos,
+					      &clos_config);
+}
+
+static void dump_clos_config(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Print Intel Speed Select Technology core power configuration\n");
+		fprintf(stderr,
+			"\tArguments: [-c | --clos]: Specify clos id\n");
+		exit(0);
+	}
+	if (current_clos < 0 || current_clos > 3) {
+		fprintf(stderr, "Invalid clos id\n");
+		exit(0);
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(dump_clos_config_for_cpu,
+						  NULL, NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(dump_clos_config_for_cpu, NULL,
+					       NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_clos_config_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				    void *arg4)
+{
+	struct isst_clos_config clos_config;
+	int ret;
+
+	clos_config.pkg_id = get_physical_package_id(cpu);
+	clos_config.die_id = get_physical_die_id(cpu);
+
+	clos_config.epp = clos_epp;
+	clos_config.clos_prop_prio = clos_prop_prio;
+	clos_config.clos_min = clos_min;
+	clos_config.clos_max = clos_max;
+	clos_config.clos_desired = clos_desired;
+	ret = isst_set_clos(cpu, current_clos, &clos_config);
+	if (ret)
+		perror("isst_set_clos");
+	else
+		isst_display_result(cpu, outf, "core-power", "config", ret);
+}
+
+static void set_clos_config(void)
+{
+	if (cmd_help) {
+		fprintf(stderr,
+			"Set core-power configuration for one of the four clos ids\n");
+		fprintf(stderr,
+			"\tSpecify targeted clos id with [--clos|-c]\n");
+		fprintf(stderr, "\tSpecify clos EPP with [--epp|-e]\n");
+		fprintf(stderr,
+			"\tSpecify clos Proportional Priority [--weight|-w]\n");
+		fprintf(stderr, "\tSpecify clos min with [--min|-n]\n");
+		fprintf(stderr, "\tSpecify clos max with [--max|-m]\n");
+		fprintf(stderr, "\tSpecify clos desired with [--desired|-d]\n");
+		exit(0);
+	}
+
+	if (current_clos < 0 || current_clos > 3) {
+		fprintf(stderr, "Invalid clos id\n");
+		exit(0);
+	}
+	if (clos_epp < 0 || clos_epp > 0x0F) {
+		fprintf(stderr, "clos epp is not specified, default: 0\n");
+		clos_epp = 0;
+	}
+	if (clos_prop_prio < 0 || clos_prop_prio > 0x0F) {
+		fprintf(stderr,
+			"clos frequency weight is not specified, default: 0\n");
+		clos_prop_prio = 0;
+	}
+	if (clos_min < 0) {
+		fprintf(stderr, "clos min is not specified, default: 0\n");
+		clos_min = 0;
+	}
+	if (clos_max < 0) {
+		fprintf(stderr, "clos max is not specified, default: 0xff\n");
+		clos_max = 0xff;
+	}
+	if (clos_desired < 0) {
+		fprintf(stderr, "clos desired is not specified, default: 0\n");
+		clos_desired = 0x00;
+	}
+
+	isst_ctdp_display_information_start(outf);
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_clos_config_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else
+		for_each_online_package_in_set(set_clos_config_for_cpu, NULL,
+					       NULL, NULL, NULL);
+	isst_ctdp_display_information_end(outf);
+}
+
+static void set_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				   void *arg4)
+{
+	int ret;
+
+	ret = isst_clos_associate(cpu, current_clos);
+	if (ret)
+		perror("isst_clos_associate");
+	else
+		isst_display_result(cpu, outf, "core-power", "assoc", ret);
+}
+
+static void set_clos_assoc(void)
+{
+	if (cmd_help) {
+		fprintf(stderr, "Associate a clos id to a CPU\n");
+		fprintf(stderr,
+			"\tSpecify targeted clos id with [--clos|-c]\n");
+		exit(0);
+	}
+
+	if (current_clos < 0 || current_clos > 3) {
+		fprintf(stderr, "Invalid clos id\n");
+		exit(0);
+	}
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(set_clos_assoc_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else {
+		fprintf(stderr,
+			"Invalid target cpu. Specify with [-c|--cpu]\n");
+	}
+}
+
+static void get_clos_assoc_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+				   void *arg4)
+{
+	int clos, ret;
+
+	ret = isst_clos_get_assoc_status(cpu, &clos);
+	if (ret)
+		perror("isst_clos_get_assoc_status");
+	else
+		isst_display_result(cpu, outf, "core-power", "get-assoc", clos);
+}
+
+static void get_clos_assoc(void)
+{
+	if (cmd_help) {
+		fprintf(stderr, "Get associate clos id to a CPU\n");
+		fprintf(stderr, "\tSpecify targeted cpu id with [--cpu|-c]\n");
+		exit(0);
+	}
+	if (max_target_cpus)
+		for_each_online_target_cpu_in_set(get_clos_assoc_for_cpu, NULL,
+						  NULL, NULL, NULL);
+	else {
+		fprintf(stderr,
+			"Invalid target cpu. Specify with [-c|--cpu]\n");
+	}
+}
+
+static struct process_cmd_struct isst_cmds[] = {
+	{ "perf-profile", "get-lock-status", get_tdp_locked },
+	{ "perf-profile", "get-config-levels", get_tdp_levels },
+	{ "perf-profile", "get-config-version", get_tdp_version },
+	{ "perf-profile", "get-config-enabled", get_tdp_enabled },
+	{ "perf-profile", "get-config-current-level", get_tdp_current_level },
+	{ "perf-profile", "set-config-level", set_tdp_level },
+	{ "perf-profile", "info", dump_isst_config },
+	{ "base-freq", "info", dump_pbf_config },
+	{ "base-freq", "enable", set_pbf_enable },
+	{ "base-freq", "disable", set_pbf_disable },
+	{ "turbo-freq", "info", dump_fact_config },
+	{ "turbo-freq", "enable", set_fact_enable },
+	{ "turbo-freq", "disable", set_fact_disable },
+	{ "core-power", "info", dump_clos_config },
+	{ "core-power", "enable", set_clos_enable },
+	{ "core-power", "disable", set_clos_disable },
+	{ "core-power", "config", set_clos_config },
+	{ "core-power", "assoc", set_clos_assoc },
+	{ "core-power", "get-assoc", get_clos_assoc },
+	{ NULL, NULL, NULL }
+};
+
+/*
+ * parse cpuset with following syntax
+ * 1,2,4..6,8-10 and set bits in cpu_subset
+ */
+void parse_cpu_command(char *optarg)
+{
+	unsigned int start, end;
+	char *next;
+
+	next = optarg;
+
+	while (next && *next) {
+		if (*next == '-') /* no negative cpu numbers */
+			goto error;
+
+		start = strtoul(next, &next, 10);
+
+		if (max_target_cpus < MAX_CPUS_IN_ONE_REQ)
+			target_cpus[max_target_cpus++] = start;
+
+		if (*next == '\0')
+			break;
+
+		if (*next == ',') {
+			next += 1;
+			continue;
+		}
+
+		if (*next == '-') {
+			next += 1; /* start range */
+		} else if (*next == '.') {
+			next += 1;
+			if (*next == '.')
+				next += 1; /* start range */
+			else
+				goto error;
+		}
+
+		end = strtoul(next, &next, 10);
+		if (end <= start)
+			goto error;
+
+		while (++start <= end) {
+			if (max_target_cpus < MAX_CPUS_IN_ONE_REQ)
+				target_cpus[max_target_cpus++] = start;
+		}
+
+		if (*next == ',')
+			next += 1;
+		else if (*next != '\0')
+			goto error;
+	}
+
+#ifdef DEBUG
+	{
+		int i;
+
+		for (i = 0; i < max_target_cpus; ++i)
+			printf("cpu [%d] in arg\n", target_cpus[i]);
+	}
+#endif
+	return;
+
+error:
+	fprintf(stderr, "\"--cpu %s\" malformed\n", optarg);
+	exit(-1);
+}
+
+static void parse_cmd_args(int argc, int start, char **argv)
+{
+	int opt;
+	int option_index;
+
+	static struct option long_options[] = {
+		{ "bucket", required_argument, 0, 'b' },
+		{ "level", required_argument, 0, 'l' },
+		{ "trl-type", required_argument, 0, 'r' },
+		{ "trl", required_argument, 0, 't' },
+		{ "help", no_argument, 0, 'h' },
+		{ "clos", required_argument, 0, 'c' },
+		{ "desired", required_argument, 0, 'd' },
+		{ "epp", required_argument, 0, 'e' },
+		{ "min", required_argument, 0, 'n' },
+		{ "max", required_argument, 0, 'm' },
+		{ "priority", required_argument, 0, 'p' },
+		{ "weight", required_argument, 0, 'w' },
+		{ 0, 0, 0, 0 }
+	};
+
+	option_index = start;
+
+	optind = start + 1;
+	while ((opt = getopt_long(argc, argv, "b:l:t:c:d:e:n:m:p:w:h",
+				  long_options, &option_index)) != -1) {
+		switch (opt) {
+		case 'b':
+			fact_bucket = atoi(optarg);
+			break;
+		case 'h':
+			cmd_help = 1;
+			break;
+		case 'l':
+			tdp_level = atoi(optarg);
+			break;
+		case 't':
+			sscanf(optarg, "0x%llx", &fact_trl);
+			break;
+		case 'r':
+			if (!strncmp(optarg, "sse", 3)) {
+				fact_avx = 0x01;
+			} else if (!strncmp(optarg, "avx2", 4)) {
+				fact_avx = 0x02;
+			} else if (!strncmp(optarg, "avx512", 4)) {
+				fact_avx = 0x04;
+			} else {
+				fprintf(outf, "Invalid sse,avx options\n");
+				exit(1);
+			}
+			break;
+		/* CLOS related */
+		case 'c':
+			current_clos = atoi(optarg);
+			printf("clos %d\n", current_clos);
+			break;
+		case 'd':
+			clos_desired = atoi(optarg);
+			break;
+		case 'e':
+			clos_epp = atoi(optarg);
+			break;
+		case 'n':
+			clos_min = atoi(optarg);
+			break;
+		case 'm':
+			clos_max = atoi(optarg);
+			break;
+		case 'p':
+			clos_priority_type = atoi(optarg);
+			break;
+		case 'w':
+			clos_prop_prio = atoi(optarg);
+			break;
+		default:
+			printf("no match\n");
+		}
+	}
+}
+
+static void isst_help(void)
+{
+	printf("perf-profile:\tAn architectural mechanism that allows multiple optimized \n\
+		performance profiles per system via static and/or dynamic\n\
+		adjustment of core count, workload, Tjmax, and\n\
+		TDP, etc.\n");
+	printf("\nCommands : For feature=perf-profile\n");
+	printf("\tinfo\n");
+	printf("\tget-lock-status\n");
+	printf("\tget-config-levels\n");
+	printf("\tget-config-version\n");
+	printf("\tget-config-enabled\n");
+	printf("\tget-config-current-level\n");
+	printf("\tset-config-level\n");
+}
+
+static void pbf_help(void)
+{
+	printf("base-freq:\tEnables users to increase guaranteed base frequency\n\
+		on certain cores (high priority cores) in exchange for lower\n\
+		base frequency on remaining cores (low priority cores).\n");
+	printf("\tcommand : info\n");
+	printf("\tcommand : enable\n");
+	printf("\tcommand : disable\n");
+}
+
+static void fact_help(void)
+{
+	printf("turbo-freq:\tEnables the ability to set different turbo ratio\n\
+		limits to cores based on priority.\n");
+	printf("\nCommand: For feature=turbo-freq\n");
+	printf("\tcommand : info\n");
+	printf("\tcommand : enable\n");
+	printf("\tcommand : disable\n");
+}
+
+static void core_power_help(void)
+{
+	printf("core-power:\tInterface that allows user to define per core/tile\n\
+		priority.\n");
+	printf("\nCommands : For feature=core-power\n");
+	printf("\tinfo\n");
+	printf("\tenable\n");
+	printf("\tdisable\n");
+	printf("\tconfig\n");
+	printf("\tassoc\n");
+	printf("\tget-assoc\n");
+}
+
+struct process_cmd_help_struct {
+	char *feature;
+	void (*process_fn)(void);
+};
+
+static struct process_cmd_help_struct isst_help_cmds[] = {
+	{ "perf-profile", isst_help },
+	{ "base-freq", pbf_help },
+	{ "turbo-freq", fact_help },
+	{ "core-power", core_power_help },
+	{ NULL, NULL }
+};
+
+void process_command(int argc, char **argv)
+{
+	int i = 0, matched = 0;
+	char *feature = argv[optind];
+	char *cmd = argv[optind + 1];
+
+	if (!feature || !cmd)
+		return;
+
+	debug_printf("feature name [%s] command [%s]\n", feature, cmd);
+	if (!strcmp(cmd, "-h") || !strcmp(cmd, "--help")) {
+		while (isst_help_cmds[i].feature) {
+			if (!strcmp(isst_help_cmds[i].feature, feature)) {
+				isst_help_cmds[i].process_fn();
+				exit(0);
+			}
+			++i;
+		}
+	}
+
+	create_cpu_map();
+
+	i = 0;
+	while (isst_cmds[i].feature) {
+		if (!strcmp(isst_cmds[i].feature, feature) &&
+		    !strcmp(isst_cmds[i].command, cmd)) {
+			parse_cmd_args(argc, optind + 1, argv);
+			isst_cmds[i].process_fn();
+			matched = 1;
+			break;
+		}
+		++i;
+	}
+
+	if (!matched)
+		fprintf(stderr, "Invalid command\n");
+}
+
+static void usage(void)
+{
+	printf("Intel(R) Speed Select Technology\n");
+	printf("\nUsage:\n");
+	printf("intel-speed-select [OPTIONS] FEATURE COMMAND COMMAND_ARGUMENTS\n");
+	printf("\nUse this tool to enumerate and control the Intel Speed Select Technology features,\n");
+	printf("\nFEATURE : [perf-profile|base-freq|turbo-freq|core-power]\n");
+	printf("\nFor help on each feature, use --h|--help\n");
+	printf("\tFor example:  intel-speed-select perf-profile -h\n");
+
+	printf("\nFor additional help on each command for a feature, use --h|--help\n");
+	printf("\tFor example:  intel-speed-select perf-profile get-lock-status -h\n");
+	printf("\t\t This will print help for the command \"get-lock-status\" for the feature \"perf-profile\"\n");
+
+	printf("\nOPTIONS\n");
+	printf("\t[-c|--cpu] : logical cpu number\n");
+	printf("\t\tDefault: Die scoped for all dies in the system with multiple dies/package\n");
+	printf("\t\t\t Or Package scoped for all Packages when each package contains one die\n");
+	printf("\t[-d|--debug] : Debug mode\n");
+	printf("\t[-h|--help] : Print help\n");
+	printf("\t[-i|--info] : Print platform information\n");
+	printf("\t[-o|--out] : Output file\n");
+	printf("\t\t\tDefault : stderr\n");
+	printf("\t[-f|--format] : output format [json|text]. Default: text\n");
+	printf("\t[-v|--version] : Print version\n");
+
+	printf("\nResult format\n");
+	printf("\tResult display uses a common format for each command:\n");
+	printf("\tResults are formatted in text/JSON with\n");
+	printf("\t\tPackage, Die, CPU, and command specific results.\n");
+	printf("\t\t\tFor Set commands, status is 0 for success and rest for failures\n");
+	exit(1);
+}
+
+static void print_version(void)
+{
+	fprintf(outf, "Version %s\n", version_str);
+	fprintf(outf, "Build date %s time %s\n", __DATE__, __TIME__);
+	exit(0);
+}
+
+static void cmdline(int argc, char **argv)
+{
+	int opt;
+	int option_index = 0;
+
+	static struct option long_options[] = {
+		{ "cpu", required_argument, 0, 'c' },
+		{ "debug", no_argument, 0, 'd' },
+		{ "format", required_argument, 0, 'f' },
+		{ "help", no_argument, 0, 'h' },
+		{ "info", no_argument, 0, 'i' },
+		{ "out", required_argument, 0, 'o' },
+		{ "version", no_argument, 0, 'v' },
+		{ 0, 0, 0, 0 }
+	};
+
+	progname = argv[0];
+	while ((opt = getopt_long_only(argc, argv, "+c:df:hio:v", long_options,
+				       &option_index)) != -1) {
+		switch (opt) {
+		case 'c':
+			parse_cpu_command(optarg);
+			break;
+		case 'd':
+			debug_flag = 1;
+			printf("Debug Mode ON\n");
+			break;
+		case 'f':
+			if (!strncmp(optarg, "json", 4))
+				out_format_json = 1;
+			break;
+		case 'h':
+			usage();
+			break;
+		case 'i':
+			isst_print_platform_information();
+			break;
+		case 'o':
+			if (outf)
+				fclose(outf);
+			outf = fopen_or_exit(optarg, "w");
+			break;
+		case 'v':
+			print_version();
+			break;
+		default:
+			usage();
+		}
+	}
+
+	if (geteuid() != 0) {
+		fprintf(stderr, "Must run as root\n");
+		exit(0);
+	}
+
+	if (optind > (argc - 2)) {
+		fprintf(stderr, "Feature name and|or command not specified\n");
+		exit(0);
+	}
+	update_cpu_model();
+	printf("Intel(R) Speed Select Technology\n");
+	printf("Executing on CPU model:%d[0x%x]\n", cpu_model, cpu_model);
+	set_max_cpu_num();
+	set_cpu_present_cpu_mask();
+	set_cpu_target_cpu_mask();
+	isst_fill_platform_info();
+	if (isst_platform_info.api_version > supported_api_ver) {
+		printf("Incompatible API versions; Upgrade of tool is required\n");
+		exit(0);
+	}
+
+	process_command(argc, argv);
+}
+
+int main(int argc, char **argv)
+{
+	outf = stderr;
+	cmdline(argc, argv);
+	return 0;
+}
