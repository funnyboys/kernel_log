commit f15c648f202cd0232d4a9c98627bc08bcd6d11ee
Author: Matt Helsley <mhelsley@vmware.com>
Date:   Tue May 19 13:55:31 2020 -0700

    objtool: Exit successfully when requesting help
    
    When the user requests help it's not an error so do not exit with
    a non-zero exit code. This is not especially useful for a user but
    any script that might wish to check that objtool --help is at least
    available can't rely on the exit code to crudely check that, for
    example, building an objtool executable succeeds.
    
    Signed-off-by: Matt Helsley <mhelsley@vmware.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index 0b3528f05053..58fdda510653 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -58,7 +58,9 @@ static void cmd_usage(void)
 
 	printf("\n");
 
-	exit(129);
+	if (!help)
+		exit(129);
+	exit(0);
 }
 
 static void handle_options(int *argc, const char ***argv)

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index 07f329919828..0b3528f05053 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -1,18 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*

commit 6a93bb7e4a7d6670677d5b0eb980936eb9cc5d2e
Author: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
Date:   Sat Oct 14 20:17:54 2017 +0530

    objtool: Print top level commands on incorrect usage
    
    Print top-level objtool commands, along with the error on incorrect
    command line usage. Objtool command line parser exit's with code 129,
    for incorrect usage. Convert the cmd_usage() exit code also, to maintain
    consistency across objtool.
    
    After the patch:
    
      $ ./objtool -j
    
      Unknown option: -j
    
      usage: objtool COMMAND [ARGS]
    
      Commands:
         check   Perform stack metadata validation on an object file
         orc     Generate in-place ORC unwind tables for an object file
    
      $ echo $?
      129
    
    Signed-off-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1507992474-16142-1-git-send-email-kamalesh@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index 31e0f9143840..07f329919828 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -70,7 +70,7 @@ static void cmd_usage(void)
 
 	printf("\n");
 
-	exit(1);
+	exit(129);
 }
 
 static void handle_options(int *argc, const char ***argv)
@@ -86,9 +86,7 @@ static void handle_options(int *argc, const char ***argv)
 			break;
 		} else {
 			fprintf(stderr, "Unknown option: %s\n", cmd);
-			fprintf(stderr, "\n Usage: %s\n",
-				objtool_usage_string);
-			exit(1);
+			cmd_usage();
 		}
 
 		(*argv)++;

commit 627fce14809ba5610b0cb476cd0186d3fcedecfc
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Jul 11 10:33:42 2017 -0500

    objtool: Add ORC unwind table generation
    
    Now that objtool knows the states of all registers on the stack for each
    instruction, it's straightforward to generate debuginfo for an unwinder
    to use.
    
    Instead of generating DWARF, generate a new format called ORC, which is
    more suitable for an in-kernel unwinder.  See
    Documentation/x86/orc-unwinder.txt for a more detailed description of
    this new debuginfo format and why it's preferable to DWARF.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/c9b9f01ba6c5ed2bdc9bb0957b78167fdbf9632e.1499786555.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index ecc5b1b5d15d..31e0f9143840 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -42,10 +42,11 @@ struct cmd_struct {
 };
 
 static const char objtool_usage_string[] =
-	"objtool [OPTIONS] COMMAND [ARGS]";
+	"objtool COMMAND [ARGS]";
 
 static struct cmd_struct objtool_cmds[] = {
 	{"check",	cmd_check,	"Perform stack metadata validation on an object file" },
+	{"orc",		cmd_orc,	"Generate in-place ORC unwind tables for an object file" },
 };
 
 bool help;

commit 0061459744cb985ef31a484bcd9b2fc3cfd01c1b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Apr 17 11:58:55 2017 -0300

    objtool: Drop ARRAY_SIZE() definition, tools/include/linux/kernel.h has it now
    
    And with the goodies present in the kernel.h counterpart, i.e. checking
    that the parameter is an array at build time.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-roiwxwgwgld4kygn65if60wa@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index 46c326db4f46..ecc5b1b5d15d 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -31,11 +31,10 @@
 #include <stdlib.h>
 #include <subcmd/exec-cmd.h>
 #include <subcmd/pager.h>
+#include <linux/kernel.h>
 
 #include "builtin.h"
 
-#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
-
 struct cmd_struct {
 	const char *name;
 	int (*fn)(int, const char **);

commit 442f04c34a1a467759d024a1d2c1df0f744dcb06
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Sun Feb 28 22:22:41 2016 -0600

    objtool: Add tool to perform compile-time stack metadata validation
    
    This adds a host tool named objtool which has a "check" subcommand which
    analyzes .o files to ensure the validity of stack metadata.  It enforces
    a set of rules on asm code and C inline assembly code so that stack
    traces can be reliable.
    
    For each function, it recursively follows all possible code paths and
    validates the correct frame pointer state at each instruction.
    
    It also follows code paths involving kernel special sections, like
    .altinstructions, __jump_table, and __ex_table, which can add
    alternative execution paths to a given instruction (or set of
    instructions).  Similarly, it knows how to follow switch statements, for
    which gcc sometimes uses jump tables.
    
    Here are some of the benefits of validating stack metadata:
    
    a) More reliable stack traces for frame pointer enabled kernels
    
       Frame pointers are used for debugging purposes.  They allow runtime
       code and debug tools to be able to walk the stack to determine the
       chain of function call sites that led to the currently executing
       code.
    
       For some architectures, frame pointers are enabled by
       CONFIG_FRAME_POINTER.  For some other architectures they may be
       required by the ABI (sometimes referred to as "backchain pointers").
    
       For C code, gcc automatically generates instructions for setting up
       frame pointers when the -fno-omit-frame-pointer option is used.
    
       But for asm code, the frame setup instructions have to be written by
       hand, which most people don't do.  So the end result is that
       CONFIG_FRAME_POINTER is honored for C code but not for most asm code.
    
       For stack traces based on frame pointers to be reliable, all
       functions which call other functions must first create a stack frame
       and update the frame pointer.  If a first function doesn't properly
       create a stack frame before calling a second function, the *caller*
       of the first function will be skipped on the stack trace.
    
       For example, consider the following example backtrace with frame
       pointers enabled:
    
         [<ffffffff81812584>] dump_stack+0x4b/0x63
         [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30
         [<ffffffff8127f568>] seq_read+0x108/0x3e0
         [<ffffffff812cce62>] proc_reg_read+0x42/0x70
         [<ffffffff81256197>] __vfs_read+0x37/0x100
         [<ffffffff81256b16>] vfs_read+0x86/0x130
         [<ffffffff81257898>] SyS_read+0x58/0xd0
         [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76
    
       It correctly shows that the caller of cmdline_proc_show() is
       seq_read().
    
       If we remove the frame pointer logic from cmdline_proc_show() by
       replacing the frame pointer related instructions with nops, here's
       what it looks like instead:
    
         [<ffffffff81812584>] dump_stack+0x4b/0x63
         [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30
         [<ffffffff812cce62>] proc_reg_read+0x42/0x70
         [<ffffffff81256197>] __vfs_read+0x37/0x100
         [<ffffffff81256b16>] vfs_read+0x86/0x130
         [<ffffffff81257898>] SyS_read+0x58/0xd0
         [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76
    
       Notice that cmdline_proc_show()'s caller, seq_read(), has been
       skipped.  Instead the stack trace seems to show that
       cmdline_proc_show() was called by proc_reg_read().
    
       The benefit of "objtool check" here is that because it ensures that
       *all* functions honor CONFIG_FRAME_POINTER, no functions will ever[*]
       be skipped on a stack trace.
    
       [*] unless an interrupt or exception has occurred at the very
           beginning of a function before the stack frame has been created,
           or at the very end of the function after the stack frame has been
           destroyed.  This is an inherent limitation of frame pointers.
    
    b) 100% reliable stack traces for DWARF enabled kernels
    
       This is not yet implemented.  For more details about what is planned,
       see tools/objtool/Documentation/stack-validation.txt.
    
    c) Higher live patching compatibility rate
    
       This is not yet implemented.  For more details about what is planned,
       see tools/objtool/Documentation/stack-validation.txt.
    
    To achieve the validation, "objtool check" enforces the following rules:
    
    1. Each callable function must be annotated as such with the ELF
       function type.  In asm code, this is typically done using the
       ENTRY/ENDPROC macros.  If objtool finds a return instruction
       outside of a function, it flags an error since that usually indicates
       callable code which should be annotated accordingly.
    
       This rule is needed so that objtool can properly identify each
       callable function in order to analyze its stack metadata.
    
    2. Conversely, each section of code which is *not* callable should *not*
       be annotated as an ELF function.  The ENDPROC macro shouldn't be used
       in this case.
    
       This rule is needed so that objtool can ignore non-callable code.
       Such code doesn't have to follow any of the other rules.
    
    3. Each callable function which calls another function must have the
       correct frame pointer logic, if required by CONFIG_FRAME_POINTER or
       the architecture's back chain rules.  This can by done in asm code
       with the FRAME_BEGIN/FRAME_END macros.
    
       This rule ensures that frame pointer based stack traces will work as
       designed.  If function A doesn't create a stack frame before calling
       function B, the _caller_ of function A will be skipped on the stack
       trace.
    
    4. Dynamic jumps and jumps to undefined symbols are only allowed if:
    
       a) the jump is part of a switch statement; or
    
       b) the jump matches sibling call semantics and the frame pointer has
          the same value it had on function entry.
    
       This rule is needed so that objtool can reliably analyze all of a
       function's code paths.  If a function jumps to code in another file,
       and it's not a sibling call, objtool has no way to follow the jump
       because it only analyzes a single file at a time.
    
    5. A callable function may not execute kernel entry/exit instructions.
       The only code which needs such instructions is kernel entry code,
       which shouldn't be be in callable functions anyway.
    
       This rule is just a sanity check to ensure that callable functions
       return normally.
    
    It currently only supports x86_64.  I tried to make the code generic so
    that support for other architectures can hopefully be plugged in
    relatively easily.
    
    On my Lenovo laptop with a i7-4810MQ 4-core/8-thread CPU, building the
    kernel with objtool checking every .o file adds about three seconds of
    total build time.  It hasn't been optimized for performance yet, so
    there are probably some opportunities for better build performance.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris J Arges <chris.j.arges@canonical.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Pedro Alves <palves@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/f3efb173de43bd067b060de73f856567c0fa1174.1456719558.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
new file mode 100644
index 000000000000..46c326db4f46
--- /dev/null
+++ b/tools/objtool/objtool.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * objtool:
+ *
+ * The 'check' subcmd analyzes every .o file and ensures the validity of its
+ * stack trace metadata.  It enforces a set of rules on asm code and C inline
+ * assembly code so that stack traces can be reliable.
+ *
+ * For more information, see tools/objtool/Documentation/stack-validation.txt.
+ */
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdlib.h>
+#include <subcmd/exec-cmd.h>
+#include <subcmd/pager.h>
+
+#include "builtin.h"
+
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
+
+struct cmd_struct {
+	const char *name;
+	int (*fn)(int, const char **);
+	const char *help;
+};
+
+static const char objtool_usage_string[] =
+	"objtool [OPTIONS] COMMAND [ARGS]";
+
+static struct cmd_struct objtool_cmds[] = {
+	{"check",	cmd_check,	"Perform stack metadata validation on an object file" },
+};
+
+bool help;
+
+static void cmd_usage(void)
+{
+	unsigned int i, longest = 0;
+
+	printf("\n usage: %s\n\n", objtool_usage_string);
+
+	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
+		if (longest < strlen(objtool_cmds[i].name))
+			longest = strlen(objtool_cmds[i].name);
+	}
+
+	puts(" Commands:");
+	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
+		printf("   %-*s   ", longest, objtool_cmds[i].name);
+		puts(objtool_cmds[i].help);
+	}
+
+	printf("\n");
+
+	exit(1);
+}
+
+static void handle_options(int *argc, const char ***argv)
+{
+	while (*argc > 0) {
+		const char *cmd = (*argv)[0];
+
+		if (cmd[0] != '-')
+			break;
+
+		if (!strcmp(cmd, "--help") || !strcmp(cmd, "-h")) {
+			help = true;
+			break;
+		} else {
+			fprintf(stderr, "Unknown option: %s\n", cmd);
+			fprintf(stderr, "\n Usage: %s\n",
+				objtool_usage_string);
+			exit(1);
+		}
+
+		(*argv)++;
+		(*argc)--;
+	}
+}
+
+static void handle_internal_command(int argc, const char **argv)
+{
+	const char *cmd = argv[0];
+	unsigned int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(objtool_cmds); i++) {
+		struct cmd_struct *p = objtool_cmds+i;
+
+		if (strcmp(p->name, cmd))
+			continue;
+
+		ret = p->fn(argc, argv);
+
+		exit(ret);
+	}
+
+	cmd_usage();
+}
+
+int main(int argc, const char **argv)
+{
+	static const char *UNUSED = "OBJTOOL_NOT_IMPLEMENTED";
+
+	/* libsubcmd init */
+	exec_cmd_init("objtool", UNUSED, UNUSED, UNUSED);
+	pager_init(UNUSED);
+
+	argv++;
+	argc--;
+	handle_options(&argc, &argv);
+
+	if (!argc || help)
+		cmd_usage();
+
+	handle_internal_command(argc, argv);
+
+	return 0;
+}
