commit fdabdd0b05e0bdf232340d5da86563ed142a99a7
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Jun 12 15:43:00 2020 +0200

    objtool: Provide elf_write_{insn,reloc}()
    
    This provides infrastructure to rewrite instructions; this is
    immediately useful for helping out with KCOV-vs-noinstr, but will
    also come in handy for a bunch of variable sized jump-label patches
    that are still on ice.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index aa9c64da379f..7324e772583e 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -64,9 +64,10 @@ struct rela {
 	GElf_Rela rela;
 	struct section *sec;
 	struct symbol *sym;
-	unsigned int type;
 	unsigned long offset;
+	unsigned int type;
 	int addend;
+	int idx;
 	bool jump_table_start;
 };
 
@@ -119,6 +120,10 @@ struct elf *elf_open_read(const char *name, int flags);
 struct section *elf_create_section(struct elf *elf, const char *name, size_t entsize, int nr);
 struct section *elf_create_rela_section(struct elf *elf, struct section *base);
 void elf_add_rela(struct elf *elf, struct rela *rela);
+int elf_write_insn(struct elf *elf, struct section *sec,
+		   unsigned long offset, unsigned int len,
+		   const char *insn);
+int elf_write_rela(struct elf *elf, struct rela *rela);
 int elf_write(struct elf *elf);
 void elf_close(struct elf *elf);
 

commit 2b10be23ac0f8e107fd575397361ddbaebc2944b
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Apr 17 23:15:00 2020 +0200

    objtool: Clean up elf_write() condition
    
    With there being multiple ways to change the ELF data, let's more
    concisely track modification.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index f4fe1d6ea392..aa9c64da379f 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -76,6 +76,7 @@ struct elf {
 	Elf *elf;
 	GElf_Ehdr ehdr;
 	int fd;
+	bool changed;
 	char *name;
 	struct list_head sections;
 	DECLARE_HASHTABLE(symbol_hash, ELF_HASH_BITS);
@@ -118,7 +119,7 @@ struct elf *elf_open_read(const char *name, int flags);
 struct section *elf_create_section(struct elf *elf, const char *name, size_t entsize, int nr);
 struct section *elf_create_rela_section(struct elf *elf, struct section *base);
 void elf_add_rela(struct elf *elf, struct rela *rela);
-int elf_write(const struct elf *elf);
+int elf_write(struct elf *elf);
 void elf_close(struct elf *elf);
 
 struct section *find_section_by_name(const struct elf *elf, const char *name);
@@ -130,7 +131,7 @@ struct rela *find_rela_by_dest(const struct elf *elf, struct section *sec, unsig
 struct rela *find_rela_by_dest_range(const struct elf *elf, struct section *sec,
 				     unsigned long offset, unsigned int len);
 struct symbol *find_func_containing(struct section *sec, unsigned long offset);
-int elf_rebuild_rela_section(struct section *sec);
+int elf_rebuild_rela_section(struct elf *elf, struct section *sec);
 
 #define for_each_sec(file, sec)						\
 	list_for_each_entry(sec, &file->elf->sections, list)

commit 7c0577f4e609f7278ebd6d21e2de82b42f110944
Merge: 6b5dd716da8f b9bbe6ed63b2
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 18 13:00:36 2020 +0300

    Merge tag 'v5.7-rc6' into objtool/core, to pick up fixes and resolve semantic conflict
    
    Resolve structural conflict between:
    
      59566b0b622e: ("x86/ftrace: Have ftrace trampolines turn read-only at the end of system boot up")
    
    which introduced a new reference to 'ftrace_epilogue', and:
    
      0298739b7983: ("x86,ftrace: Fix ftrace_regs_caller() unwind")
    
    Which renamed it to 'ftrace_caller_end'. Rename the new usage site in the merge commit.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c14cab2688d09b851349acbb83e5fce8e0d4ca42
Merge: 8b00083219af fb9cbbc895eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 10 11:59:53 2020 -0700

    Merge tag 'x86-urgent-2020-05-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 fixes from Thomas Gleixner:
     "A set of fixes for x86:
    
       - Ensure that direct mapping alias is always flushed when changing
         page attributes. The optimization for small ranges failed to do so
         when the virtual address was in the vmalloc or module space.
    
       - Unbreak the trace event registration for syscalls without arguments
         caused by the refactoring of the SYSCALL_DEFINE0() macro.
    
       - Move the printk in the TSC deadline timer code to a place where it
         is guaranteed to only be called once during boot and cannot be
         rearmed by clearing warn_once after boot. If it's invoked post boot
         then lockdep rightfully complains about a potential deadlock as the
         calling context is different.
    
       - A series of fixes for objtool and the ORC unwinder addressing
         variety of small issues:
    
           - Stack offset tracking for indirect CFAs in objtool ignored
             subsequent pushs and pops
    
           - Repair the unwind hints in the register clearing entry ASM code
    
           - Make the unwinding in the low level exit to usermode code stop
             after switching to the trampoline stack. The unwind hint is no
             longer valid and the ORC unwinder emits a warning as it can't
             find the registers anymore.
    
           - Fix unwind hints in switch_to_asm() and rewind_stack_do_exit()
             which caused objtool to generate bogus ORC data.
    
           - Prevent unwinder warnings when dumping the stack of a
             non-current task as there is no way to be sure about the
             validity because the dumped stack can be a moving target.
    
           - Make the ORC unwinder behave the same way as the frame pointer
             unwinder when dumping an inactive tasks stack and do not skip
             the first frame.
    
           - Prevent ORC unwinding before ORC data has been initialized
    
           - Immediately terminate unwinding when a unknown ORC entry type
             is found.
    
           - Prevent premature stop of the unwinder caused by IRET frames.
    
           - Fix another infinite loop in objtool caused by a negative
             offset which was not catched.
    
           - Address a few build warnings in the ORC unwinder and add
             missing static/ro_after_init annotations"
    
    * tag 'x86-urgent-2020-05-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/unwind/orc: Move ORC sorting variables under !CONFIG_MODULES
      x86/apic: Move TSC deadline timer debug printk
      ftrace/x86: Fix trace event registration for syscalls without arguments
      x86/mm/cpa: Flush direct map alias during cpa
      objtool: Fix infinite loop in for_offset_range()
      x86/unwind/orc: Fix premature unwind stoppage due to IRET frames
      x86/unwind/orc: Fix error path for bad ORC entry type
      x86/unwind/orc: Prevent unwinding before ORC initialization
      x86/unwind/orc: Don't skip the first frame for inactive tasks
      x86/unwind: Prevent false warnings for non-current tasks
      x86/unwind/orc: Convert global variables to static
      x86/entry/64: Fix unwind hints in rewind_stack_do_exit()
      x86/entry/64: Fix unwind hints in __switch_to_asm()
      x86/entry/64: Fix unwind hints in kernel exit path
      x86/entry/64: Fix unwind hints in register clearing code
      objtool: Fix stack offset tracking for indirect CFAs

commit b490f45362002fef57996388e395efc974b013f4
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Fri Apr 24 16:30:42 2020 +0200

    objtool: Move the IRET hack into the arch decoder
    
    Quoting Julien:
    
      "And the other suggestion is my other email was that you don't even
      need to add INSN_EXCEPTION_RETURN. You can keep IRET as
      INSN_CONTEXT_SWITCH by default and x86 decoder lookups the symbol
      conaining an iret. If it's a function symbol, it can just set the type
      to INSN_OTHER so that it caries on to the next instruction after
      having handled the stack_op."
    
    Suggested-by: Julien Thierry <jthierry@redhat.com>
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200428191659.913283807@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 5e76ac38cf99..9d6bb072849c 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -124,7 +124,7 @@ struct section *find_section_by_name(const struct elf *elf, const char *name);
 struct symbol *find_func_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_name(const struct elf *elf, const char *name);
-struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
+struct symbol *find_symbol_containing(const struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest(const struct elf *elf, struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(const struct elf *elf, struct section *sec,
 				     unsigned long offset, unsigned int len);

commit 53fb6e990d782ded62d7c76d566e107c03393b74
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Sat Apr 25 14:19:01 2020 -0500

    objtool: Fix infinite loop in for_offset_range()
    
    Randy reported that objtool got stuck in an infinite loop when
    processing drivers/i2c/busses/i2c-parport.o.  It was caused by the
    following code:
    
      00000000000001fd <line_set>:
       1fd: 48 b8 00 00 00 00 00    movabs $0x0,%rax
       204: 00 00 00
                            1ff: R_X86_64_64        .rodata-0x8
       207: 41 55                   push   %r13
       209: 41 89 f5                mov    %esi,%r13d
       20c: 41 54                   push   %r12
       20e: 49 89 fc                mov    %rdi,%r12
       211: 55                      push   %rbp
       212: 48 89 d5                mov    %rdx,%rbp
       215: 53                      push   %rbx
       216: 0f b6 5a 01             movzbl 0x1(%rdx),%ebx
       21a: 48 8d 34 dd 00 00 00    lea    0x0(,%rbx,8),%rsi
       221: 00
                            21e: R_X86_64_32S       .rodata
       222: 48 89 f1                mov    %rsi,%rcx
       225: 48 29 c1                sub    %rax,%rcx
    
    find_jump_table() saw the .rodata reference and tried to find a jump
    table associated with it (though there wasn't one).  The -0x8 rela
    addend is unusual.  It caused find_jump_table() to send a negative
    table_offset (unsigned 0xfffffffffffffff8) to find_rela_by_dest().
    
    The negative offset should have been harmless, but it actually threw
    for_offset_range() for a loop... literally.  When the mask value got
    incremented past the end value, it also wrapped to zero, causing the
    loop exit condition to remain true forever.
    
    Prevent this scenario from happening by ensuring the incremented value
    is always >= the starting value.
    
    Fixes: 74b873e49d92 ("objtool: Optimize find_rela_by_dest_range()")
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Julien Thierry <jthierry@redhat.com>
    Cc: Miroslav Benes <mbenes@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lore.kernel.org/r/02b719674b031800b61e33c30b2e823183627c19.1587842122.git.jpoimboe@redhat.com

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index ebbb10c61e24..c227a2e55751 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -87,9 +87,10 @@ struct elf {
 #define OFFSET_STRIDE		(1UL << OFFSET_STRIDE_BITS)
 #define OFFSET_STRIDE_MASK	(~(OFFSET_STRIDE - 1))
 
-#define for_offset_range(_offset, _start, _end)		\
-	for (_offset = ((_start) & OFFSET_STRIDE_MASK);	\
-	     _offset <= ((_end) & OFFSET_STRIDE_MASK);	\
+#define for_offset_range(_offset, _start, _end)			\
+	for (_offset = ((_start) & OFFSET_STRIDE_MASK);		\
+	     _offset >= ((_start) & OFFSET_STRIDE_MASK) &&	\
+	     _offset <= ((_end) & OFFSET_STRIDE_MASK);		\
 	     _offset += OFFSET_STRIDE)
 
 static inline u32 sec_offset_hash(struct section *sec, unsigned long offset)

commit bc359ff2f6f3e8a9df38c39017e269bc442357c7
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Apr 22 12:32:04 2020 +0200

    objtool: Rename elf_read() to elf_open_read()
    
    'struct elf *' handling is an open/close paradigm, make sure the naming
    matches that:
    
       elf_open_read()
       elf_write()
       elf_close()
    
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sami Tolvanen <samitolvanen@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200422103205.61900-3-mingo@kernel.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index a55bcde9f1b1..5e76ac38cf99 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -113,7 +113,7 @@ static inline u32 rela_hash(struct rela *rela)
 	return sec_offset_hash(rela->sec, rela->offset);
 }
 
-struct elf *elf_read(const char *name, int flags);
+struct elf *elf_open_read(const char *name, int flags);
 struct section *elf_create_section(struct elf *elf, const char *name, size_t entsize, int nr);
 struct section *elf_create_rela_section(struct elf *elf, struct section *base);
 void elf_add_rela(struct elf *elf, struct rela *rela);

commit 894e48cada64ec384873fad4fe1b0d0c7de31a29
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Apr 22 12:32:03 2020 +0200

    objtool: Constify 'struct elf *' parameters
    
    In preparation to parallelize certain parts of objtool, map out which uses
    of various data structures are read-only vs. read-write.
    
    As a first step constify 'struct elf' pointer passing, most of the secondary
    uses of it in find_symbol_*() methods are read-only.
    
    Also, while at it, better group the 'struct elf' handling methods in elf.h.
    
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sami Tolvanen <samitolvanen@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200422103205.61900-2-mingo@kernel.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 2811d04346c9..a55bcde9f1b1 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -114,22 +114,22 @@ static inline u32 rela_hash(struct rela *rela)
 }
 
 struct elf *elf_read(const char *name, int flags);
-struct section *find_section_by_name(struct elf *elf, const char *name);
+struct section *elf_create_section(struct elf *elf, const char *name, size_t entsize, int nr);
+struct section *elf_create_rela_section(struct elf *elf, struct section *base);
+void elf_add_rela(struct elf *elf, struct rela *rela);
+int elf_write(const struct elf *elf);
+void elf_close(struct elf *elf);
+
+struct section *find_section_by_name(const struct elf *elf, const char *name);
 struct symbol *find_func_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
-struct symbol *find_symbol_by_name(struct elf *elf, const char *name);
+struct symbol *find_symbol_by_name(const struct elf *elf, const char *name);
 struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
-struct rela *find_rela_by_dest(struct elf *elf, struct section *sec, unsigned long offset);
-struct rela *find_rela_by_dest_range(struct elf *elf, struct section *sec,
+struct rela *find_rela_by_dest(const struct elf *elf, struct section *sec, unsigned long offset);
+struct rela *find_rela_by_dest_range(const struct elf *elf, struct section *sec,
 				     unsigned long offset, unsigned int len);
 struct symbol *find_func_containing(struct section *sec, unsigned long offset);
-struct section *elf_create_section(struct elf *elf, const char *name, size_t
-				   entsize, int nr);
-struct section *elf_create_rela_section(struct elf *elf, struct section *base);
 int elf_rebuild_rela_section(struct section *sec);
-int elf_write(struct elf *elf);
-void elf_close(struct elf *elf);
-void elf_add_rela(struct elf *elf, struct rela *rela);
 
 #define for_each_sec(file, sec)						\
 	list_for_each_entry(sec, &file->elf->sections, list)

commit df2b384366fc427eeaa8bd0e761390180b311df0
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Apr 20 10:33:32 2020 +0200

    objtool: Fix 32bit cross builds
    
    Apparently there's people doing 64bit builds on 32bit machines.
    
    Fixes: 74b873e49d92 ("objtool: Optimize find_rela_by_dest_range()")
    Reported-by: youling257@gmail.com
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index ebbb10c61e24..0b79c2353a21 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -99,7 +99,7 @@ static inline u32 sec_offset_hash(struct section *sec, unsigned long offset)
 	offset &= OFFSET_STRIDE_MASK;
 
 	ol = offset;
-	oh = offset >> 32;
+	oh = (offset >> 16) >> 16;
 
 	__jhash_mix(ol, oh, idx);
 

commit 34f7c96d96d5e11b03a612017fcc3a6e645bb481
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 14:29:38 2020 +0100

    objtool: Optimize !vmlinux.o again
    
    When doing kbuild tests to see if the objtool changes affected those I
    found that there was a measurable regression:
    
              pre             post
    
      real    1m13.594        1m16.488s
      user    34m58.246s      35m23.947s
      sys     4m0.393s        4m27.312s
    
    Perf showed that for small files the increased hash-table sizes were a
    measurable difference. Since we already have -l "vmlinux" to
    distinguish between the modes, make it also use a smaller portion of
    the hash-tables.
    
    This flips it into a small win:
    
      real    1m14.143s
      user    34m49.292s
      sys     3m44.746s
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200416115119.167588731@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index eb79cb999209..2811d04346c9 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -70,17 +70,19 @@ struct rela {
 	bool jump_table_start;
 };
 
+#define ELF_HASH_BITS	20
+
 struct elf {
 	Elf *elf;
 	GElf_Ehdr ehdr;
 	int fd;
 	char *name;
 	struct list_head sections;
-	DECLARE_HASHTABLE(symbol_hash, 20);
-	DECLARE_HASHTABLE(symbol_name_hash, 20);
-	DECLARE_HASHTABLE(section_hash, 16);
-	DECLARE_HASHTABLE(section_name_hash, 16);
-	DECLARE_HASHTABLE(rela_hash, 20);
+	DECLARE_HASHTABLE(symbol_hash, ELF_HASH_BITS);
+	DECLARE_HASHTABLE(symbol_name_hash, ELF_HASH_BITS);
+	DECLARE_HASHTABLE(section_hash, ELF_HASH_BITS);
+	DECLARE_HASHTABLE(section_name_hash, ELF_HASH_BITS);
+	DECLARE_HASHTABLE(rela_hash, ELF_HASH_BITS);
 };
 
 #define OFFSET_STRIDE_BITS	4
@@ -127,6 +129,7 @@ struct section *elf_create_rela_section(struct elf *elf, struct section *base);
 int elf_rebuild_rela_section(struct section *sec);
 int elf_write(struct elf *elf);
 void elf_close(struct elf *elf);
+void elf_add_rela(struct elf *elf, struct rela *rela);
 
 #define for_each_sec(file, sec)						\
 	list_for_each_entry(sec, &file->elf->sections, list)

commit c4a33939a7eb396acbb05569e57eebe4374cc57c
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Mar 10 18:57:41 2020 +0100

    objtool: Implement noinstr validation
    
    Validate that any call out of .noinstr.text is in between
    instr_begin() and instr_end() annotations.
    
    This annotation is useful to ensure correct behaviour wrt tracing
    sensitive code like entry/exit and idle code. When we run code in a
    sensitive context we want a guarantee no unknown code is ran.
    
    Since this validation relies on knowing the section of call
    destination symbols, we must run it on vmlinux.o instead of on
    individual object files.
    
    Add two options:
    
     -d/--duplicate "duplicate validation for vmlinux"
     -l/--vmlinux "vmlinux.o validation"
    
    Where the latter auto-detects when objname ends with "vmlinux.o" and
    the former will force all validations, also those already done on
    !vmlinux object files.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200416115119.106268040@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 0b79c2353a21..eb79cb999209 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -39,7 +39,7 @@ struct section {
 	char *name;
 	int idx;
 	unsigned int len;
-	bool changed, text, rodata;
+	bool changed, text, rodata, noinstr;
 };
 
 struct symbol {

commit 963d5669171adcd59b45cad58fab81bbd599c3c8
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Apr 20 10:33:32 2020 +0200

    objtool: Fix 32bit cross builds
    
    Apparently there's people doing 64bit builds on 32bit machines.
    
    Fixes: 74b873e49d92 ("objtool: Optimize find_rela_by_dest_range()")
    Reported-by: youling257@gmail.com
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index ebbb10c61e24..0b79c2353a21 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -99,7 +99,7 @@ static inline u32 sec_offset_hash(struct section *sec, unsigned long offset)
 	offset &= OFFSET_STRIDE_MASK;
 
 	ol = offset;
-	oh = offset >> 32;
+	oh = (offset >> 16) >> 16;
 
 	__jhash_mix(ol, oh, idx);
 

commit 74b873e49d92f90deb41d1a2a8fbb70328aebd67
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 11:30:50 2020 +0100

    objtool: Optimize find_rela_by_dest_range()
    
    Perf shows there is significant time in find_rela_by_dest(); this is
    because we have to iterate the address space per byte, looking for
    relocation entries.
    
    Optimize this by reducing the address space granularity.
    
    This reduces objtool on vmlinux.o runtime from 4.8 to 4.4 seconds.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.861321325@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index dfd2431ef693..ebbb10c61e24 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -83,9 +83,23 @@ struct elf {
 	DECLARE_HASHTABLE(rela_hash, 20);
 };
 
+#define OFFSET_STRIDE_BITS	4
+#define OFFSET_STRIDE		(1UL << OFFSET_STRIDE_BITS)
+#define OFFSET_STRIDE_MASK	(~(OFFSET_STRIDE - 1))
+
+#define for_offset_range(_offset, _start, _end)		\
+	for (_offset = ((_start) & OFFSET_STRIDE_MASK);	\
+	     _offset <= ((_end) & OFFSET_STRIDE_MASK);	\
+	     _offset += OFFSET_STRIDE)
+
 static inline u32 sec_offset_hash(struct section *sec, unsigned long offset)
 {
-	u32 ol = offset, oh = offset >> 32, idx = sec->idx;
+	u32 ol, oh, idx = sec->idx;
+
+	offset &= OFFSET_STRIDE_MASK;
+
+	ol = offset;
+	oh = offset >> 32;
 
 	__jhash_mix(ol, oh, idx);
 

commit 8b5fa6bc326bf02f293b5a39a8f5b3de816265d3
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 11:23:36 2020 +0100

    objtool: Optimize read_sections()
    
    Perf showed that __hash_init() is a significant portion of
    read_sections(), so instead of doing a per section rela_hash, use an
    elf-wide rela_hash.
    
    Statistics show us there are about 1.1 million relas, so size it
    accordingly.
    
    This reduces the objtool on vmlinux.o runtime to a third, from 15 to 5
    seconds.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.739153726@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 3088d925d640..dfd2431ef693 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -33,7 +33,6 @@ struct section {
 	struct rb_root symbol_tree;
 	struct list_head symbol_list;
 	struct list_head rela_list;
-	DECLARE_HASHTABLE(rela_hash, 16);
 	struct section *base, *rela;
 	struct symbol *sym;
 	Elf_Data *data;
@@ -81,8 +80,22 @@ struct elf {
 	DECLARE_HASHTABLE(symbol_name_hash, 20);
 	DECLARE_HASHTABLE(section_hash, 16);
 	DECLARE_HASHTABLE(section_name_hash, 16);
+	DECLARE_HASHTABLE(rela_hash, 20);
 };
 
+static inline u32 sec_offset_hash(struct section *sec, unsigned long offset)
+{
+	u32 ol = offset, oh = offset >> 32, idx = sec->idx;
+
+	__jhash_mix(ol, oh, idx);
+
+	return ol;
+}
+
+static inline u32 rela_hash(struct rela *rela)
+{
+	return sec_offset_hash(rela->sec, rela->offset);
+}
 
 struct elf *elf_read(const char *name, int flags);
 struct section *find_section_by_name(struct elf *elf, const char *name);
@@ -90,9 +103,9 @@ struct symbol *find_func_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
-struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
-struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
-				     unsigned int len);
+struct rela *find_rela_by_dest(struct elf *elf, struct section *sec, unsigned long offset);
+struct rela *find_rela_by_dest_range(struct elf *elf, struct section *sec,
+				     unsigned long offset, unsigned int len);
 struct symbol *find_func_containing(struct section *sec, unsigned long offset);
 struct section *elf_create_section(struct elf *elf, const char *name, size_t
 				   entsize, int nr);

commit cdb3d057a17d56363a831e486ea39e4c389a6cf9
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 10:17:38 2020 +0100

    objtool: Optimize find_symbol_by_name()
    
    Perf showed that find_symbol_by_name() takes time; add a symbol name
    hash.
    
    This shaves another second off of objtool on vmlinux.o runtime, down
    to 15 seconds.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.676865656@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index d18f466829b0..3088d925d640 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -47,6 +47,7 @@ struct symbol {
 	struct list_head list;
 	struct rb_node node;
 	struct hlist_node hash;
+	struct hlist_node name_hash;
 	GElf_Sym sym;
 	struct section *sec;
 	char *name;
@@ -77,6 +78,7 @@ struct elf {
 	char *name;
 	struct list_head sections;
 	DECLARE_HASHTABLE(symbol_hash, 20);
+	DECLARE_HASHTABLE(symbol_name_hash, 20);
 	DECLARE_HASHTABLE(section_hash, 16);
 	DECLARE_HASHTABLE(section_name_hash, 16);
 };

commit 53d20720bbc8718ef86fdfe53dec0accfb593ef8
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 16 10:36:53 2020 +0100

    objtool: Rename find_containing_func()
    
    For consistency; we have:
    
      find_symbol_by_offset() / find_symbol_containing()
      find_func_by_offset()   / find_containing_func()
    
    fix that.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.558470724@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index e4a8d68f2ef7..d18f466829b0 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -91,7 +91,7 @@ struct symbol *find_symbol_containing(struct section *sec, unsigned long offset)
 struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 				     unsigned int len);
-struct symbol *find_containing_func(struct section *sec, unsigned long offset);
+struct symbol *find_func_containing(struct section *sec, unsigned long offset);
 struct section *elf_create_section(struct elf *elf, const char *name, size_t
 				   entsize, int nr);
 struct section *elf_create_rela_section(struct elf *elf, struct section *base);

commit 2a362ecc3ec9632aeea4b9a9062db91b2bd9975a
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 09:34:42 2020 +0100

    objtool: Optimize find_symbol_*() and read_symbols()
    
    All of:
    
      read_symbols(), find_symbol_by_offset(), find_symbol_containing(),
      find_containing_func()
    
    do a linear search of the symbols. Add an RB tree to make it go
    faster.
    
    This about halves objtool runtime on vmlinux.o, from 34s to 18s.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.499016559@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index ac7c46f7d9ab..e4a8d68f2ef7 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -10,6 +10,7 @@
 #include <gelf.h>
 #include <linux/list.h>
 #include <linux/hashtable.h>
+#include <linux/rbtree.h>
 #include <linux/jhash.h>
 
 #ifdef LIBELF_USE_DEPRECATED
@@ -29,6 +30,7 @@ struct section {
 	struct hlist_node hash;
 	struct hlist_node name_hash;
 	GElf_Shdr sh;
+	struct rb_root symbol_tree;
 	struct list_head symbol_list;
 	struct list_head rela_list;
 	DECLARE_HASHTABLE(rela_hash, 16);
@@ -43,6 +45,7 @@ struct section {
 
 struct symbol {
 	struct list_head list;
+	struct rb_node node;
 	struct hlist_node hash;
 	GElf_Sym sym;
 	struct section *sec;

commit ae358196fac3a0b4d2a7d47a4f401e3421027b03
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 12 09:32:10 2020 +0100

    objtool: Optimize find_section_by_name()
    
    In order to avoid yet another linear search of (20k) sections, add a
    name based hash.
    
    This reduces objtool runtime on vmlinux.o by some 10s to around 35s.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.440174280@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 8c272eb515c8..ac7c46f7d9ab 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -10,6 +10,7 @@
 #include <gelf.h>
 #include <linux/list.h>
 #include <linux/hashtable.h>
+#include <linux/jhash.h>
 
 #ifdef LIBELF_USE_DEPRECATED
 # define elf_getshdrnum    elf_getshnum
@@ -26,6 +27,7 @@
 struct section {
 	struct list_head list;
 	struct hlist_node hash;
+	struct hlist_node name_hash;
 	GElf_Shdr sh;
 	struct list_head symbol_list;
 	struct list_head rela_list;
@@ -73,6 +75,7 @@ struct elf {
 	struct list_head sections;
 	DECLARE_HASHTABLE(symbol_hash, 20);
 	DECLARE_HASHTABLE(section_hash, 16);
+	DECLARE_HASHTABLE(section_name_hash, 16);
 };
 
 

commit 530389968739883a61192767e1c215653ba4ba2b
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Mar 10 18:43:35 2020 +0100

    objtool: Optimize find_section_by_index()
    
    In order to avoid a linear search (over 20k entries), add an
    section_hash to the elf object.
    
    This reduces objtool on vmlinux.o from a few minutes to around 45
    seconds.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.381249993@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 12229801b13f..8c272eb515c8 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -25,6 +25,7 @@
 
 struct section {
 	struct list_head list;
+	struct hlist_node hash;
 	GElf_Shdr sh;
 	struct list_head symbol_list;
 	struct list_head rela_list;
@@ -71,6 +72,7 @@ struct elf {
 	char *name;
 	struct list_head sections;
 	DECLARE_HASHTABLE(symbol_hash, 20);
+	DECLARE_HASHTABLE(section_hash, 16);
 };
 
 

commit 65fb11a7f6aeae678043738d06248a4e21f4e4e4
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Mar 10 18:39:45 2020 +0100

    objtool: Optimize find_symbol_by_index()
    
    The symbol index is object wide, not per section, so it makes no sense
    to have the symbol_hash be part of the section object. By moving it to
    the elf object we avoid the linear sections iteration.
    
    This reduces the runtime of objtool on vmlinux.o from over 3 hours (I
    gave up) to a few minutes. The defconfig vmlinux.o has around 20k
    sections.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20200324160924.261852348@infradead.org

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index a1963259b930..12229801b13f 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -27,7 +27,6 @@ struct section {
 	struct list_head list;
 	GElf_Shdr sh;
 	struct list_head symbol_list;
-	DECLARE_HASHTABLE(symbol_hash, 8);
 	struct list_head rela_list;
 	DECLARE_HASHTABLE(rela_hash, 16);
 	struct section *base, *rela;
@@ -71,7 +70,7 @@ struct elf {
 	int fd;
 	char *name;
 	struct list_head sections;
-	DECLARE_HASHTABLE(rela_hash, 16);
+	DECLARE_HASHTABLE(symbol_hash, 20);
 };
 
 

commit 7acfe5315312fc56c2a94c9216448087b38ae909
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Feb 17 21:41:54 2020 -0600

    objtool: Improve call destination function detection
    
    A recent clang change, combined with a binutils bug, can trigger a
    situation where a ".Lprintk$local" STT_NOTYPE symbol gets created at the
    same offset as the "printk" STT_FUNC symbol.  This confuses objtool:
    
      kernel/printk/printk.o: warning: objtool: ignore_loglevel_setup()+0x10: can't find call dest symbol at .text+0xc67
    
    Improve the call destination detection by looking specifically for an
    STT_FUNC symbol.
    
    Reported-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Link: https://github.com/ClangBuiltLinux/linux/issues/872
    Link: https://sourceware.org/bugzilla/show_bug.cgi?id=25551
    Link: https://lkml.kernel.org/r/0a7ee320bc0ea4469bd3dc450a7b4725669e0ea9.1581997059.git.jpoimboe@redhat.com

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 44150204db4d..a1963259b930 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -77,6 +77,7 @@ struct elf {
 
 struct elf *elf_read(const char *name, int flags);
 struct section *find_section_by_name(struct elf *elf, const char *name);
+struct symbol *find_func_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);

commit bd98c81346468fc2f86aeeb44d4d0d6f763a62b7
Author: Jann Horn <jannh@google.com>
Date:   Wed Jul 17 20:36:54 2019 -0500

    objtool: Support repeated uses of the same C jump table
    
    This fixes objtool for both a GCC issue and a Clang issue:
    
    1) GCC issue:
    
       kernel/bpf/core.o: warning: objtool: ___bpf_prog_run()+0x8d5: sibling call from callable instruction with modified stack frame
    
       With CONFIG_RETPOLINE=n, GCC is doing the following optimization in
       ___bpf_prog_run().
    
       Before:
    
               select_insn:
                       jmp *jumptable(,%rax,8)
                       ...
               ALU64_ADD_X:
                       ...
                       jmp select_insn
               ALU_ADD_X:
                       ...
                       jmp select_insn
    
       After:
    
               select_insn:
                       jmp *jumptable(, %rax, 8)
                       ...
               ALU64_ADD_X:
                       ...
                       jmp *jumptable(, %rax, 8)
               ALU_ADD_X:
                       ...
                       jmp *jumptable(, %rax, 8)
    
       This confuses objtool.  It has never seen multiple indirect jump
       sites which use the same jump table.
    
       For GCC switch tables, the only way of detecting the size of a table
       is by continuing to scan for more tables.  The size of the previous
       table can only be determined after another switch table is found, or
       when the scan reaches the end of the function.
    
       That logic was reused for C jump tables, and was based on the
       assumption that each jump table only has a single jump site.  The
       above optimization breaks that assumption.
    
    2) Clang issue:
    
       drivers/usb/misc/sisusbvga/sisusb.o: warning: objtool: sisusb_write_mem_bulk()+0x588: can't find switch jump table
    
       With clang 9, code can be generated where a function contains two
       indirect jump instructions which use the same switch table.
    
    The fix is the same for both issues: split the jump table parsing into
    two passes.
    
    In the first pass, locate the heads of all switch tables for the
    function and mark their locations.
    
    In the second pass, parse the switch tables and add them.
    
    Fixes: e55a73251da3 ("bpf: Fix ORC unwinding in non-JIT BPF code")
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/e995befaada9d4d8b2cf788ff3f566ba900d2b4d.1563413318.git.jpoimboe@redhat.com
    
    Co-developed-by: Josh Poimboeuf <jpoimboe@redhat.com>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index d4d3e0528d4a..44150204db4d 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -62,6 +62,7 @@ struct rela {
 	unsigned int type;
 	unsigned long offset;
 	int addend;
+	bool jump_table_start;
 };
 
 struct elf {

commit e7c2bc37bfae120bce3e7cc8c8abf9d110af0757
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Jul 17 20:36:53 2019 -0500

    objtool: Refactor jump table code
    
    Now that C jump tables are supported, call them "jump tables" instead of
    "switch tables".  Also rename some other variables, add comments, and
    simplify the code flow a bit.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/cf951b0c0641628e0b9b81f7ceccd9bcabcb4bd8.1563413318.git.jpoimboe@redhat.com

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 2fe0b0aa741d..d4d3e0528d4a 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -57,7 +57,7 @@ struct rela {
 	struct list_head list;
 	struct hlist_node hash;
 	GElf_Rela rela;
-	struct section *rela_sec;
+	struct section *sec;
 	struct symbol *sym;
 	unsigned int type;
 	unsigned long offset;

commit 8e144797f1a67c52e386161863da4614a23ad913
Author: Michael Forney <mforney@mforney.org>
Date:   Wed Jul 10 16:20:11 2019 -0500

    objtool: Rename elf_open() to prevent conflict with libelf from elftoolchain
    
    The elftoolchain version of libelf has a function named elf_open().
    
    The function name isn't quite accurate anyway, since it also reads all
    the ELF data.  Rename it to elf_read(), which is more accurate.
    
    [ jpoimboe: rename to elf_read(); write commit description ]
    
    Signed-off-by: Michael Forney <mforney@mforney.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/7ce2d1b35665edf19fd0eb6fbc0b17b81a48e62f.1562793604.git.jpoimboe@redhat.com

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index e44ca5d51871..2fe0b0aa741d 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -74,7 +74,7 @@ struct elf {
 };
 
 
-struct elf *elf_open(const char *name, int flags);
+struct elf *elf_read(const char *name, int flags);
 struct section *find_section_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_by_name(struct elf *elf, const char *name);

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 2cc2ed49322d..e44ca5d51871 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -1,18 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef _OBJTOOL_ELF_H

commit ea24213d8088f9da73e1b6aadf7abd2435b70397
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Feb 25 12:50:09 2019 +0100

    objtool: Add UACCESS validation
    
    It is important that UACCESS regions are as small as possible;
    furthermore the UACCESS state is not scheduled, so doing anything that
    might directly call into the scheduler will cause random code to be
    ran with UACCESS enabled.
    
    Teach objtool too track UACCESS state and warn about any CALL made
    while UACCESS is enabled. This very much includes the __fentry__()
    and __preempt_schedule() calls.
    
    Note that exceptions _do_ save/restore the UACCESS state, and therefore
    they can drive preemption. This also means that all exception handlers
    must have an otherwise redundant UACCESS disable instruction;
    therefore ignore this warning for !STT_FUNC code (exception handlers
    are not normal functions).
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 968265b4b4cd..2cc2ed49322d 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -62,6 +62,7 @@ struct symbol {
 	unsigned long offset;
 	unsigned int len;
 	struct symbol *pfunc, *cfunc, *alias;
+	bool uaccess_safe;
 };
 
 struct rela {

commit 09f30d83d33029faf6377a86f5ae80a658af9254
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Feb 28 14:17:50 2019 +0100

    objtool: Handle function aliases
    
    Function aliases result in different symbols for the same set of
    instructions; track a canonical symbol so there is a unique point of
    access.
    
    This again prepares the way for function attributes. And in particular
    the need for aliases comes from how KASAN uses them.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index bc97ed86b9cd..968265b4b4cd 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -61,7 +61,7 @@ struct symbol {
 	unsigned char bind, type;
 	unsigned long offset;
 	unsigned int len;
-	struct symbol *pfunc, *cfunc;
+	struct symbol *pfunc, *cfunc, *alias;
 };
 
 struct rela {

commit 4a60aa05a0634241ce17f957bf9fb5ac1eed6576
Author: Allan Xavier <allan.x.xavier@oracle.com>
Date:   Fri Sep 7 08:12:01 2018 -0500

    objtool: Support per-function rodata sections
    
    Add support for processing switch jump tables in objects with multiple
    .rodata sections, such as those created by '-ffunction-sections' and
    '-fdata-sections'.  Currently, objtool always looks in .rodata for jump
    table information, which results in many "sibling call from callable
    instruction with modified stack frame" warnings with objects compiled
    using those flags.
    
    The fix is comprised of three parts:
    
    1. Flagging all .rodata sections when importing ELF information for
       easier checking later.
    
    2. Keeping a reference to the section each relocation is from in order
       to get the list_head for the other relocations in that section.
    
    3. Finding jump tables by following relocations to .rodata sections,
       rather than always referencing a single global .rodata section.
    
    The patch has been tested without data sections enabled and no
    differences in the resulting orc unwind information were seen.
    
    Note that as objtool adds terminators to end of each .text section the
    unwind information generated between a function+data sections build and
    a normal build aren't directly comparable. Manual inspection suggests
    that objtool is now generating the correct information, or at least
    making more of an effort to do so than it did previously.
    
    Signed-off-by: Allan Xavier <allan.x.xavier@oracle.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/099bdc375195c490dda04db777ee0b95d566ded1.1536325914.git.jpoimboe@redhat.com

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index de5cd2ddded9..bc97ed86b9cd 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -48,7 +48,7 @@ struct section {
 	char *name;
 	int idx;
 	unsigned int len;
-	bool changed, text;
+	bool changed, text, rodata;
 };
 
 struct symbol {
@@ -68,6 +68,7 @@ struct rela {
 	struct list_head list;
 	struct hlist_node hash;
 	GElf_Rela rela;
+	struct section *rela_sec;
 	struct symbol *sym;
 	unsigned int type;
 	unsigned long offset;

commit 13810435b9a7014fb92eb715f77da488f3b65b99
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed May 9 22:39:15 2018 -0500

    objtool: Support GCC 8's cold subfunctions
    
    GCC 8 moves a lot of unlikely code out of line to "cold" subfunctions in
    .text.unlikely.  Properly detect the new subfunctions and treat them as
    extensions of the original functions.
    
    This fixes a bunch of warnings like:
    
      kernel/cgroup/cgroup.o: warning: objtool: parse_cgroup_root_flags()+0x33: sibling call from callable instruction with modified stack frame
      kernel/cgroup/cgroup.o: warning: objtool: cgroup_addrm_files()+0x290: sibling call from callable instruction with modified stack frame
      kernel/cgroup/cgroup.o: warning: objtool: cgroup_apply_control_enable()+0x25b: sibling call from callable instruction with modified stack frame
      kernel/cgroup/cgroup.o: warning: objtool: rebind_subsystems()+0x325: sibling call from callable instruction with modified stack frame
    
    Reported-and-tested-by: damian <damian.tometzki@icloud.com>
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/0965e7fcfc5f31a276f0c7f298ff770c19b68706.1525923412.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index d86e2ff14466..de5cd2ddded9 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -61,6 +61,7 @@ struct symbol {
 	unsigned char bind, type;
 	unsigned long offset;
 	unsigned int len;
+	struct symbol *pfunc, *cfunc;
 };
 
 struct rela {
@@ -86,6 +87,7 @@ struct elf {
 struct elf *elf_open(const char *name, int flags);
 struct section *find_section_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
+struct symbol *find_symbol_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,

commit 627fce14809ba5610b0cb476cd0186d3fcedecfc
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Jul 11 10:33:42 2017 -0500

    objtool: Add ORC unwind table generation
    
    Now that objtool knows the states of all registers on the stack for each
    instruction, it's straightforward to generate debuginfo for an unwinder
    to use.
    
    Instead of generating DWARF, generate a new format called ORC, which is
    more suitable for an in-kernel unwinder.  See
    Documentation/x86/orc-unwinder.txt for a more detailed description of
    this new debuginfo format and why it's preferable to DWARF.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/c9b9f01ba6c5ed2bdc9bb0957b78167fdbf9632e.1499786555.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 343968b778cb..d86e2ff14466 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -28,6 +28,13 @@
 # define elf_getshdrstrndx elf_getshstrndx
 #endif
 
+/*
+ * Fallback for systems without this "read, mmaping if possible" cmd.
+ */
+#ifndef ELF_C_READ_MMAP
+#define ELF_C_READ_MMAP ELF_C_READ
+#endif
+
 struct section {
 	struct list_head list;
 	GElf_Shdr sh;
@@ -41,6 +48,7 @@ struct section {
 	char *name;
 	int idx;
 	unsigned int len;
+	bool changed, text;
 };
 
 struct symbol {
@@ -75,7 +83,7 @@ struct elf {
 };
 
 
-struct elf *elf_open(const char *name);
+struct elf *elf_open(const char *name, int flags);
 struct section *find_section_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
 struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
@@ -83,6 +91,11 @@ struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 				     unsigned int len);
 struct symbol *find_containing_func(struct section *sec, unsigned long offset);
+struct section *elf_create_section(struct elf *elf, const char *name, size_t
+				   entsize, int nr);
+struct section *elf_create_rela_section(struct elf *elf, struct section *base);
+int elf_rebuild_rela_section(struct section *sec);
+int elf_write(struct elf *elf);
 void elf_close(struct elf *elf);
 
 #define for_each_sec(file, sec)						\

commit baa41469a7b992c1e3db2a39854219cc7442e48f
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Jun 28 10:11:07 2017 -0500

    objtool: Implement stack validation 2.0
    
    This is a major rewrite of objtool.  Instead of only tracking frame
    pointer changes, it now tracks all stack-related operations, including
    all register saves/restores.
    
    In addition to making stack validation more robust, this also paves the
    way for undwarf generation.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/678bd94c0566c6129bcc376cddb259c4c5633004.1498659915.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 731973e1a3f5..343968b778cb 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -37,10 +37,9 @@ struct section {
 	DECLARE_HASHTABLE(rela_hash, 16);
 	struct section *base, *rela;
 	struct symbol *sym;
-	Elf_Data *elf_data;
+	Elf_Data *data;
 	char *name;
 	int idx;
-	unsigned long data;
 	unsigned int len;
 };
 
@@ -86,6 +85,7 @@ struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 struct symbol *find_containing_func(struct section *sec, unsigned long offset);
 void elf_close(struct elf *elf);
 
-
+#define for_each_sec(file, sec)						\
+	list_for_each_entry(sec, &file->elf->sections, list)
 
 #endif /* _OBJTOOL_ELF_H */

commit 5c51f4ae84df0f9df33ac08aa5be50061a8b4242
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Thu Mar 2 16:57:23 2017 -0600

    objtool: Fix another GCC jump table detection issue
    
    Arnd Bergmann reported a (false positive) objtool warning:
    
      drivers/infiniband/sw/rxe/rxe_resp.o: warning: objtool: rxe_responder()+0xfe: sibling call from callable instruction with changed frame pointer
    
    The issue is in find_switch_table().  It tries to find a switch
    statement's jump table by walking backwards from an indirect jump
    instruction, looking for a relocation to the .rodata section.  In this
    case it stopped walking prematurely: the first .rodata relocation it
    encountered was for a variable (resp_state_name) instead of a jump
    table, so it just assumed there wasn't a jump table.
    
    The fix is to ignore any .rodata relocation which refers to an ELF
    object symbol.  This works because the jump tables are anonymous and
    have no symbols associated with them.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 3732710ff6f2 ("objtool: Improve rare switch jump table pattern detection")
    Link: http://lkml.kernel.org/r/20170302225723.3ndbsnl4hkqbne7a@treble
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index aa1ff6596684..731973e1a3f5 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -79,6 +79,7 @@ struct elf {
 struct elf *elf_open(const char *name);
 struct section *find_section_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
+struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 				     unsigned int len);

commit 2e51f26245701cb28f154552836b7807159088a8
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon May 16 15:31:07 2016 -0500

    objtool: Allow building with older libelf
    
    The switch to elf_getshdr{num,strndx} post-dates the oldest tool chain
    the kernel is supposed to be able to build with, so try to cope with
    such an environment.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: <stable@vger.kernel.org> # for v4.6
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Link: http://lkml.kernel.org/r/732dae6872b7ff187d94f22bb699a12849d3fe04.1463430618.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 7f3e00a2f907..aa1ff6596684 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -23,6 +23,11 @@
 #include <linux/list.h>
 #include <linux/hashtable.h>
 
+#ifdef LIBELF_USE_DEPRECATED
+# define elf_getshdrnum    elf_getshnum
+# define elf_getshdrstrndx elf_getshstrndx
+#endif
+
 struct section {
 	struct list_head list;
 	GElf_Shdr sh;

commit 042ba73fe7eb63872ee2d6ac86410052210c1f16
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Mar 9 00:07:00 2016 -0600

    objtool: Add several performance improvements
    
    Use hash tables for instruction and rela lookups (and keep the linked
    lists around for sequential access).
    
    Also cache the section struct for the "__func_stack_frame_non_standard"
    section.
    
    With this change, "objtool check net/wireless/nl80211.o" goes from:
    
      real  0m1.168s
      user  0m1.163s
      sys   0m0.005s
    
    to:
    
      real  0m0.059s
      user  0m0.042s
      sys   0m0.017s
    
    for a 20x speedup.
    
    With the same object, it should be noted that the memory heap usage grew
    from 8MB to 62MB.  Reducing the memory usage is on the TODO list.
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris J Arges <chris.j.arges@canonical.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Pedro Alves <palves@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/dd0d8e1449506cfa7701b4e7ba73577077c44253.1457502970.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 57e4653f8383..7f3e00a2f907 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -21,12 +21,15 @@
 #include <stdio.h>
 #include <gelf.h>
 #include <linux/list.h>
+#include <linux/hashtable.h>
 
 struct section {
 	struct list_head list;
 	GElf_Shdr sh;
 	struct list_head symbol_list;
+	DECLARE_HASHTABLE(symbol_hash, 8);
 	struct list_head rela_list;
+	DECLARE_HASHTABLE(rela_hash, 16);
 	struct section *base, *rela;
 	struct symbol *sym;
 	Elf_Data *elf_data;
@@ -38,10 +41,11 @@ struct section {
 
 struct symbol {
 	struct list_head list;
+	struct hlist_node hash;
 	GElf_Sym sym;
 	struct section *sec;
 	char *name;
-	int idx;
+	unsigned int idx;
 	unsigned char bind, type;
 	unsigned long offset;
 	unsigned int len;
@@ -49,10 +53,11 @@ struct symbol {
 
 struct rela {
 	struct list_head list;
+	struct hlist_node hash;
 	GElf_Rela rela;
 	struct symbol *sym;
 	unsigned int type;
-	int offset;
+	unsigned long offset;
 	int addend;
 };
 
@@ -62,6 +67,7 @@ struct elf {
 	int fd;
 	char *name;
 	struct list_head sections;
+	DECLARE_HASHTABLE(rela_hash, 16);
 };
 
 

commit a196e17198224cacd2d992f12cb6d81d354de82f
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Mar 9 00:06:57 2016 -0600

    objtool: Rename some variables and functions
    
    Rename some list heads to distinguish them from hash node heads, which
    are added later in the patch series.
    
    Also rename the get_*() functions to add_*(), which is more descriptive:
    they "add" data to the objtool_file struct.
    
    Also rename rodata_rela and text_rela to be clearer:
    - text_rela refers to a rela entry in .rela.text.
    - rodata_rela refers to a rela entry in .rela.rodata.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris J Arges <chris.j.arges@canonical.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Pedro Alves <palves@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/ee0eca2bba8482aa45758958c5586c00a7b71e62.1457502970.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
index 66919de57e68..57e4653f8383 100644
--- a/tools/objtool/elf.h
+++ b/tools/objtool/elf.h
@@ -25,8 +25,8 @@
 struct section {
 	struct list_head list;
 	GElf_Shdr sh;
-	struct list_head symbols;
-	struct list_head relas;
+	struct list_head symbol_list;
+	struct list_head rela_list;
 	struct section *base, *rela;
 	struct symbol *sym;
 	Elf_Data *elf_data;

commit 442f04c34a1a467759d024a1d2c1df0f744dcb06
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Sun Feb 28 22:22:41 2016 -0600

    objtool: Add tool to perform compile-time stack metadata validation
    
    This adds a host tool named objtool which has a "check" subcommand which
    analyzes .o files to ensure the validity of stack metadata.  It enforces
    a set of rules on asm code and C inline assembly code so that stack
    traces can be reliable.
    
    For each function, it recursively follows all possible code paths and
    validates the correct frame pointer state at each instruction.
    
    It also follows code paths involving kernel special sections, like
    .altinstructions, __jump_table, and __ex_table, which can add
    alternative execution paths to a given instruction (or set of
    instructions).  Similarly, it knows how to follow switch statements, for
    which gcc sometimes uses jump tables.
    
    Here are some of the benefits of validating stack metadata:
    
    a) More reliable stack traces for frame pointer enabled kernels
    
       Frame pointers are used for debugging purposes.  They allow runtime
       code and debug tools to be able to walk the stack to determine the
       chain of function call sites that led to the currently executing
       code.
    
       For some architectures, frame pointers are enabled by
       CONFIG_FRAME_POINTER.  For some other architectures they may be
       required by the ABI (sometimes referred to as "backchain pointers").
    
       For C code, gcc automatically generates instructions for setting up
       frame pointers when the -fno-omit-frame-pointer option is used.
    
       But for asm code, the frame setup instructions have to be written by
       hand, which most people don't do.  So the end result is that
       CONFIG_FRAME_POINTER is honored for C code but not for most asm code.
    
       For stack traces based on frame pointers to be reliable, all
       functions which call other functions must first create a stack frame
       and update the frame pointer.  If a first function doesn't properly
       create a stack frame before calling a second function, the *caller*
       of the first function will be skipped on the stack trace.
    
       For example, consider the following example backtrace with frame
       pointers enabled:
    
         [<ffffffff81812584>] dump_stack+0x4b/0x63
         [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30
         [<ffffffff8127f568>] seq_read+0x108/0x3e0
         [<ffffffff812cce62>] proc_reg_read+0x42/0x70
         [<ffffffff81256197>] __vfs_read+0x37/0x100
         [<ffffffff81256b16>] vfs_read+0x86/0x130
         [<ffffffff81257898>] SyS_read+0x58/0xd0
         [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76
    
       It correctly shows that the caller of cmdline_proc_show() is
       seq_read().
    
       If we remove the frame pointer logic from cmdline_proc_show() by
       replacing the frame pointer related instructions with nops, here's
       what it looks like instead:
    
         [<ffffffff81812584>] dump_stack+0x4b/0x63
         [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30
         [<ffffffff812cce62>] proc_reg_read+0x42/0x70
         [<ffffffff81256197>] __vfs_read+0x37/0x100
         [<ffffffff81256b16>] vfs_read+0x86/0x130
         [<ffffffff81257898>] SyS_read+0x58/0xd0
         [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76
    
       Notice that cmdline_proc_show()'s caller, seq_read(), has been
       skipped.  Instead the stack trace seems to show that
       cmdline_proc_show() was called by proc_reg_read().
    
       The benefit of "objtool check" here is that because it ensures that
       *all* functions honor CONFIG_FRAME_POINTER, no functions will ever[*]
       be skipped on a stack trace.
    
       [*] unless an interrupt or exception has occurred at the very
           beginning of a function before the stack frame has been created,
           or at the very end of the function after the stack frame has been
           destroyed.  This is an inherent limitation of frame pointers.
    
    b) 100% reliable stack traces for DWARF enabled kernels
    
       This is not yet implemented.  For more details about what is planned,
       see tools/objtool/Documentation/stack-validation.txt.
    
    c) Higher live patching compatibility rate
    
       This is not yet implemented.  For more details about what is planned,
       see tools/objtool/Documentation/stack-validation.txt.
    
    To achieve the validation, "objtool check" enforces the following rules:
    
    1. Each callable function must be annotated as such with the ELF
       function type.  In asm code, this is typically done using the
       ENTRY/ENDPROC macros.  If objtool finds a return instruction
       outside of a function, it flags an error since that usually indicates
       callable code which should be annotated accordingly.
    
       This rule is needed so that objtool can properly identify each
       callable function in order to analyze its stack metadata.
    
    2. Conversely, each section of code which is *not* callable should *not*
       be annotated as an ELF function.  The ENDPROC macro shouldn't be used
       in this case.
    
       This rule is needed so that objtool can ignore non-callable code.
       Such code doesn't have to follow any of the other rules.
    
    3. Each callable function which calls another function must have the
       correct frame pointer logic, if required by CONFIG_FRAME_POINTER or
       the architecture's back chain rules.  This can by done in asm code
       with the FRAME_BEGIN/FRAME_END macros.
    
       This rule ensures that frame pointer based stack traces will work as
       designed.  If function A doesn't create a stack frame before calling
       function B, the _caller_ of function A will be skipped on the stack
       trace.
    
    4. Dynamic jumps and jumps to undefined symbols are only allowed if:
    
       a) the jump is part of a switch statement; or
    
       b) the jump matches sibling call semantics and the frame pointer has
          the same value it had on function entry.
    
       This rule is needed so that objtool can reliably analyze all of a
       function's code paths.  If a function jumps to code in another file,
       and it's not a sibling call, objtool has no way to follow the jump
       because it only analyzes a single file at a time.
    
    5. A callable function may not execute kernel entry/exit instructions.
       The only code which needs such instructions is kernel entry code,
       which shouldn't be be in callable functions anyway.
    
       This rule is just a sanity check to ensure that callable functions
       return normally.
    
    It currently only supports x86_64.  I tried to make the code generic so
    that support for other architectures can hopefully be plugged in
    relatively easily.
    
    On my Lenovo laptop with a i7-4810MQ 4-core/8-thread CPU, building the
    kernel with objtool checking every .o file adds about three seconds of
    total build time.  It hasn't been optimized for performance yet, so
    there are probably some opportunities for better build performance.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris J Arges <chris.j.arges@canonical.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Pedro Alves <palves@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: live-patching@vger.kernel.org
    Link: http://lkml.kernel.org/r/f3efb173de43bd067b060de73f856567c0fa1174.1456719558.git.jpoimboe@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h
new file mode 100644
index 000000000000..66919de57e68
--- /dev/null
+++ b/tools/objtool/elf.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _OBJTOOL_ELF_H
+#define _OBJTOOL_ELF_H
+
+#include <stdio.h>
+#include <gelf.h>
+#include <linux/list.h>
+
+struct section {
+	struct list_head list;
+	GElf_Shdr sh;
+	struct list_head symbols;
+	struct list_head relas;
+	struct section *base, *rela;
+	struct symbol *sym;
+	Elf_Data *elf_data;
+	char *name;
+	int idx;
+	unsigned long data;
+	unsigned int len;
+};
+
+struct symbol {
+	struct list_head list;
+	GElf_Sym sym;
+	struct section *sec;
+	char *name;
+	int idx;
+	unsigned char bind, type;
+	unsigned long offset;
+	unsigned int len;
+};
+
+struct rela {
+	struct list_head list;
+	GElf_Rela rela;
+	struct symbol *sym;
+	unsigned int type;
+	int offset;
+	int addend;
+};
+
+struct elf {
+	Elf *elf;
+	GElf_Ehdr ehdr;
+	int fd;
+	char *name;
+	struct list_head sections;
+};
+
+
+struct elf *elf_open(const char *name);
+struct section *find_section_by_name(struct elf *elf, const char *name);
+struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
+struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
+struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
+				     unsigned int len);
+struct symbol *find_containing_func(struct section *sec, unsigned long offset);
+void elf_close(struct elf *elf);
+
+
+
+#endif /* _OBJTOOL_ELF_H */
