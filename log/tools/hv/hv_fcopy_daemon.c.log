commit 9fc3c01a1fae669a2ef9f13ee1e1a26e057d79f8
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 25 21:49:41 2020 -0800

    Tools: hv: Reopen the devices if read() or write() returns errors
    
    The state machine in the hv_utils driver can run out of order in some
    corner cases, e.g. if the kvp daemon doesn't call write() fast enough
    due to some reason, kvp_timeout_func() can run first and move the state
    to HVUTIL_READY; next, when kvp_on_msg() is called it returns -EINVAL
    since kvp_transaction.state is smaller than HVUTIL_USERSPACE_REQ; later,
    the daemon's write() gets an error -EINVAL, and the daemon will exit().
    
    We can reproduce the issue by sending a SIGSTOP signal to the daemon, wait
    for 1 minute, and send a SIGCONT signal to the daemon: the daemon will
    exit() quickly.
    
    We can fix the issue by forcing a reset of the device (which means the
    daemon can close() and open() the device again) and doing extra necessary
    clean-up.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index aea2d91ab364..16d629b22c25 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -80,6 +80,8 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 
 	error = 0;
 done:
+	if (error)
+		target_fname[0] = '\0';
 	return error;
 }
 
@@ -108,15 +110,29 @@ static int hv_copy_data(struct hv_do_fcopy *cpmsg)
 	return ret;
 }
 
+/*
+ * Reset target_fname to "" in the two below functions for hibernation: if
+ * the fcopy operation is aborted by hibernation, the daemon should remove the
+ * partially-copied file; to achieve this, the hv_utils driver always fakes a
+ * CANCEL_FCOPY message upon suspend, and later when the VM resumes back,
+ * the daemon calls hv_copy_cancel() to remove the file; if a file is copied
+ * successfully before suspend, hv_copy_finished() must reset target_fname to
+ * avoid that the file can be incorrectly removed upon resume, since the faked
+ * CANCEL_FCOPY message is spurious in this case.
+ */
 static int hv_copy_finished(void)
 {
 	close(target_fd);
+	target_fname[0] = '\0';
 	return 0;
 }
 static int hv_copy_cancel(void)
 {
 	close(target_fd);
-	unlink(target_fname);
+	if (strlen(target_fname) > 0) {
+		unlink(target_fname);
+		target_fname[0] = '\0';
+	}
 	return 0;
 
 }
@@ -131,7 +147,7 @@ void print_usage(char *argv[])
 
 int main(int argc, char *argv[])
 {
-	int fcopy_fd;
+	int fcopy_fd = -1;
 	int error;
 	int daemonize = 1, long_index = 0, opt;
 	int version = FCOPY_CURRENT_VERSION;
@@ -141,7 +157,7 @@ int main(int argc, char *argv[])
 		struct hv_do_fcopy copy;
 		__u32 kernel_modver;
 	} buffer = { };
-	int in_handshake = 1;
+	int in_handshake;
 
 	static struct option long_options[] = {
 		{"help",	no_argument,	   0,  'h' },
@@ -170,6 +186,12 @@ int main(int argc, char *argv[])
 	openlog("HV_FCOPY", 0, LOG_USER);
 	syslog(LOG_INFO, "starting; pid is:%d", getpid());
 
+reopen_fcopy_fd:
+	if (fcopy_fd != -1)
+		close(fcopy_fd);
+	/* Remove any possible partially-copied file on error */
+	hv_copy_cancel();
+	in_handshake = 1;
 	fcopy_fd = open("/dev/vmbus/hv_fcopy", O_RDWR);
 
 	if (fcopy_fd < 0) {
@@ -196,7 +218,7 @@ int main(int argc, char *argv[])
 		len = pread(fcopy_fd, &buffer, sizeof(buffer), 0);
 		if (len < 0) {
 			syslog(LOG_ERR, "pread failed: %s", strerror(errno));
-			exit(EXIT_FAILURE);
+			goto reopen_fcopy_fd;
 		}
 
 		if (in_handshake) {
@@ -231,9 +253,14 @@ int main(int argc, char *argv[])
 
 		}
 
+		/*
+		 * pwrite() may return an error due to the faked CANCEL_FCOPY
+		 * message upon hibernation. Ignore the error by resetting the
+		 * dev file, i.e. closing and re-opening it.
+		 */
 		if (pwrite(fcopy_fd, &error, sizeof(int), 0) != sizeof(int)) {
 			syslog(LOG_ERR, "pwrite failed: %s", strerror(errno));
-			exit(EXIT_FAILURE);
+			goto reopen_fcopy_fd;
 		}
 	}
 }

commit 43aa31327bb36002f52026b13d5f1bde35a1fc14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:54 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 280
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose good title or non infringement see
      the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.459653302@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 8ff8cb1a11f4..aea2d91ab364 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -1,19 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * An implementation of host to guest copy functionality for Linux.
  *
  * Copyright (C) 2014, Microsoft, Inc.
  *
  * Author : K. Y. Srinivasan <kys@microsoft.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
  */
 
 

commit c2d68afba86d1ff01e7300c68bc16a9234dcd8e9
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Sep 17 04:14:55 2018 +0000

    tools: hv: fcopy: set 'error' in case an unknown operation was requested
    
    'error' variable is left uninitialized in case we see an unknown operation.
    As we don't immediately return and proceed to pwrite() we need to set it
    to something, HV_E_FAIL sounds good enough.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index d78aed86af09..8ff8cb1a11f4 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -234,6 +234,7 @@ int main(int argc, char *argv[])
 			break;
 
 		default:
+			error = HV_E_FAIL;
 			syslog(LOG_ERR, "Unknown operation: %d",
 				buffer.hdr.operation);
 

commit aba8a53264963514917e462f3fbbb66b3de79951
Author: Olaf Hering <olaf@aepfle.de>
Date:   Sun Mar 4 22:17:15 2018 -0700

    tools: hv: include string.h in hv_fcopy_daemon
    
    The usage of strchr requires inclusion of string.h.
    
    Fixes: 0c38cda64aec ("tools: hv: remove unnecessary header files and netlink related code")
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 785f4e95148c..d78aed86af09 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -21,6 +21,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <string.h>
 #include <errno.h>
 #include <linux/hyperv.h>
 #include <linux/limits.h>

commit 1330fc35327f3ecdfa1aa645e7321ced7349b2cd
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sun Mar 4 22:17:14 2018 -0700

    tools: hv: fix compiler warnings about major/target_fname
    
    This patch fixes the below warnings with new glibc and gcc:
    
    hv_vss_daemon.c:100:13: warning: In the GNU C Library, "major" is defined
     by <sys/sysmacros.h>. For historical compatibility, it is currently
    defined by <sys/types.h> as well, but we plan to  remove this soon.
    To use "major", include <sys/sysmacros.h>  directly.
    
    hv_fcopy_daemon.c:42:2: note: 'snprintf' output between 2 and 1040
    bytes into a destination of size 260
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 457a1521f32f..785f4e95148c 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -23,13 +23,14 @@
 #include <unistd.h>
 #include <errno.h>
 #include <linux/hyperv.h>
+#include <linux/limits.h>
 #include <syslog.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <getopt.h>
 
 static int target_fd;
-static char target_fname[W_MAX_PATH];
+static char target_fname[PATH_MAX];
 static unsigned long long filesize;
 
 static int hv_start_fcopy(struct hv_start_fcopy *smsg)

commit 3f2baa8a7d2efaa836f1dc4b8ee8c3ca4ba9e101
Author: Olaf Hering <olaf@aepfle.de>
Date:   Thu Aug 10 15:45:16 2017 -0700

    Tools: hv: update buffer handling in hv_fcopy_daemon
    
    Currently this warning is triggered when compiling hv_fcopy_daemon:
    
    hv_fcopy_daemon.c:216:4: warning: dereferencing type-punned pointer will break
    strict-aliasing rules [-Wstrict-aliasing]
        kernel_modver = *(__u32 *)buffer;
    
    Convert the send/receive buffer to a union and pass individual members as
    needed. This also gives the correct size for the buffer.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 26ae609a9448..457a1521f32f 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -138,14 +138,17 @@ void print_usage(char *argv[])
 
 int main(int argc, char *argv[])
 {
-	int fcopy_fd, len;
+	int fcopy_fd;
 	int error;
 	int daemonize = 1, long_index = 0, opt;
 	int version = FCOPY_CURRENT_VERSION;
-	char *buffer[4096 * 2];
-	struct hv_fcopy_hdr *in_msg;
+	union {
+		struct hv_fcopy_hdr hdr;
+		struct hv_start_fcopy start;
+		struct hv_do_fcopy copy;
+		__u32 kernel_modver;
+	} buffer = { };
 	int in_handshake = 1;
-	__u32 kernel_modver;
 
 	static struct option long_options[] = {
 		{"help",	no_argument,	   0,  'h' },
@@ -195,32 +198,31 @@ int main(int argc, char *argv[])
 		 * In this loop we process fcopy messages after the
 		 * handshake is complete.
 		 */
-		len = pread(fcopy_fd, buffer, (4096 * 2), 0);
+		ssize_t len;
+
+		len = pread(fcopy_fd, &buffer, sizeof(buffer), 0);
 		if (len < 0) {
 			syslog(LOG_ERR, "pread failed: %s", strerror(errno));
 			exit(EXIT_FAILURE);
 		}
 
 		if (in_handshake) {
-			if (len != sizeof(kernel_modver)) {
+			if (len != sizeof(buffer.kernel_modver)) {
 				syslog(LOG_ERR, "invalid version negotiation");
 				exit(EXIT_FAILURE);
 			}
-			kernel_modver = *(__u32 *)buffer;
 			in_handshake = 0;
-			syslog(LOG_INFO, "kernel module version: %d",
-			       kernel_modver);
+			syslog(LOG_INFO, "kernel module version: %u",
+			       buffer.kernel_modver);
 			continue;
 		}
 
-		in_msg = (struct hv_fcopy_hdr *)buffer;
-
-		switch (in_msg->operation) {
+		switch (buffer.hdr.operation) {
 		case START_FILE_COPY:
-			error = hv_start_fcopy((struct hv_start_fcopy *)in_msg);
+			error = hv_start_fcopy(&buffer.start);
 			break;
 		case WRITE_TO_FILE:
-			error = hv_copy_data((struct hv_do_fcopy *)in_msg);
+			error = hv_copy_data(&buffer.copy);
 			break;
 		case COMPLETE_FCOPY:
 			error = hv_copy_finished();
@@ -231,7 +233,7 @@ int main(int argc, char *argv[])
 
 		default:
 			syslog(LOG_ERR, "Unknown operation: %d",
-				in_msg->operation);
+				buffer.hdr.operation);
 
 		}
 

commit 0c38cda64aecb4a821210bb2d3d04092c181c0ae
Author: Weibing Zhang <atheism.zhang@gmail.com>
Date:   Sun Nov 6 13:14:15 2016 -0800

    tools: hv: remove unnecessary header files and netlink related code
    
    Remove unnecessary header files and netlink related code as the daemons
    do not use netlink to communicate with the kernel now.
    
    Signed-off-by: Weibing Zhang <atheism.zhang@gmail.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index fdc9ca4c0356..26ae609a9448 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -18,21 +18,14 @@
 
 
 #include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/poll.h>
-#include <linux/types.h>
-#include <linux/kdev_t.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <string.h>
-#include <ctype.h>
 #include <errno.h>
 #include <linux/hyperv.h>
 #include <syslog.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#include <dirent.h>
 #include <getopt.h>
 
 static int target_fd;

commit 6dfb867cea9e93ae9220f0b2e702b0440e4c8b4b
Author: Olaf Hering <olaf@aepfle.de>
Date:   Mon Dec 14 16:01:35 2015 -0800

    tools: hv: remove repeated HV_FCOPY string
    
    HV_FCOPY is already used as identifier in syslog.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index f1d742682317..fdc9ca4c0356 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -179,7 +179,7 @@ int main(int argc, char *argv[])
 	}
 
 	openlog("HV_FCOPY", 0, LOG_USER);
-	syslog(LOG_INFO, "HV_FCOPY starting; pid is:%d", getpid());
+	syslog(LOG_INFO, "starting; pid is:%d", getpid());
 
 	fcopy_fd = open("/dev/vmbus/hv_fcopy", O_RDWR);
 
@@ -215,7 +215,7 @@ int main(int argc, char *argv[])
 			}
 			kernel_modver = *(__u32 *)buffer;
 			in_handshake = 0;
-			syslog(LOG_INFO, "HV_FCOPY: kernel module version: %d",
+			syslog(LOG_INFO, "kernel module version: %d",
 			       kernel_modver);
 			continue;
 		}

commit b4ed5d1682c6613988c2eb1de55df5ac9988afcc
Author: Olaf Hering <olaf@aepfle.de>
Date:   Mon Dec 14 16:01:34 2015 -0800

    tools: hv: report ENOSPC errors in hv_fcopy_daemon
    
    Currently some "Unspecified error 0x80004005" is reported on the Windows
    side if something fails. Handle the ENOSPC case and return
    ERROR_DISK_FULL, which allows at least Copy-VMFile to report a meaning
    full error.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 5480e4e424eb..f1d742682317 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -37,12 +37,14 @@
 
 static int target_fd;
 static char target_fname[W_MAX_PATH];
+static unsigned long long filesize;
 
 static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 {
 	int error = HV_E_FAIL;
 	char *q, *p;
 
+	filesize = 0;
 	p = (char *)smsg->path_name;
 	snprintf(target_fname, sizeof(target_fname), "%s/%s",
 		 (char *)smsg->path_name, (char *)smsg->file_name);
@@ -98,14 +100,26 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 static int hv_copy_data(struct hv_do_fcopy *cpmsg)
 {
 	ssize_t bytes_written;
+	int ret = 0;
 
 	bytes_written = pwrite(target_fd, cpmsg->data, cpmsg->size,
 				cpmsg->offset);
 
-	if (bytes_written != cpmsg->size)
-		return HV_E_FAIL;
+	filesize += cpmsg->size;
+	if (bytes_written != cpmsg->size) {
+		switch (errno) {
+		case ENOSPC:
+			ret = HV_ERROR_DISK_FULL;
+			break;
+		default:
+			ret = HV_E_FAIL;
+			break;
+		}
+		syslog(LOG_ERR, "pwrite failed to write %llu bytes: %ld (%s)",
+		       filesize, (long)bytes_written, strerror(errno));
+	}
 
-	return 0;
+	return ret;
 }
 
 static int hv_copy_finished(void)

commit a4d1ee5b0255a135fead1d62a7fc7e6fe718b66e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Apr 11 18:07:58 2015 -0700

    Drivers: hv: fcopy: full handshake support
    
    Introduce FCOPY_VERSION_1 to support kernel replying to the negotiation
    message with its own version.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Tested-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 9445d8f264a4..5480e4e424eb 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -137,6 +137,8 @@ int main(int argc, char *argv[])
 	int version = FCOPY_CURRENT_VERSION;
 	char *buffer[4096 * 2];
 	struct hv_fcopy_hdr *in_msg;
+	int in_handshake = 1;
+	__u32 kernel_modver;
 
 	static struct option long_options[] = {
 		{"help",	no_argument,	   0,  'h' },
@@ -191,6 +193,19 @@ int main(int argc, char *argv[])
 			syslog(LOG_ERR, "pread failed: %s", strerror(errno));
 			exit(EXIT_FAILURE);
 		}
+
+		if (in_handshake) {
+			if (len != sizeof(kernel_modver)) {
+				syslog(LOG_ERR, "invalid version negotiation");
+				exit(EXIT_FAILURE);
+			}
+			kernel_modver = *(__u32 *)buffer;
+			in_handshake = 0;
+			syslog(LOG_INFO, "HV_FCOPY: kernel module version: %d",
+			       kernel_modver);
+			continue;
+		}
+
 		in_msg = (struct hv_fcopy_hdr *)buffer;
 
 		switch (in_msg->operation) {

commit c1136da62170465920eea1ae9ba9ce2234091f77
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Jan 9 22:18:55 2015 -0800

    Tools: hv: do not add redundant '/' in hv_start_fcopy()
    
    We don't need to add additional '/' to smsg->path_name as snprintf("%s/%s")
    does the right thing. Without the patch we get doubled '//' in the log message.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 1a238726dda6..9445d8f264a4 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -43,12 +43,6 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 	int error = HV_E_FAIL;
 	char *q, *p;
 
-	/*
-	 * If possile append a path seperator to the path.
-	 */
-	if (strlen((char *)smsg->path_name) < (W_MAX_PATH - 2))
-		strcat((char *)smsg->path_name, "/");
-
 	p = (char *)smsg->path_name;
 	snprintf(target_fname, sizeof(target_fname), "%s/%s",
 		 (char *)smsg->path_name, (char *)smsg->file_name);

commit aba474b8185d60ca8cdbf3049fe6d655aa761e23
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Jan 9 22:18:54 2015 -0800

    Tools: hv: address compiler warnings for hv_fcopy_daemon.c
    
    This patch addresses two types of compiler warnings:
    ... warning: unused variable .fd. [-Wunused-variable]
    and
    ... warning: format .%s. expects argument of type .char *., but argument 5 has type .__u16 *. [-Wformat=]
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index f437d739f37d..1a238726dda6 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -51,7 +51,7 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 
 	p = (char *)smsg->path_name;
 	snprintf(target_fname, sizeof(target_fname), "%s/%s",
-		(char *)smsg->path_name, smsg->file_name);
+		 (char *)smsg->path_name, (char *)smsg->file_name);
 
 	syslog(LOG_INFO, "Target file name: %s", target_fname);
 	/*
@@ -137,7 +137,7 @@ void print_usage(char *argv[])
 
 int main(int argc, char *argv[])
 {
-	int fd, fcopy_fd, len;
+	int fcopy_fd, len;
 	int error;
 	int daemonize = 1, long_index = 0, opt;
 	int version = FCOPY_CURRENT_VERSION;

commit 170f4bea2008054e5098f99359e29823a7b4b1b9
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 22 18:07:11 2014 +0200

    tools: hv: introduce -n/--no-daemon option
    
    All tools/hv daemons do mandatory daemon() on startup. However, no pidfile
    is created, this make it difficult for an init system to track such daemons.
    Modern linux distros use systemd as their init system. It can handle the
    daemonizing by itself, however, it requires a daemon to stay in foreground
    for that. Some distros already carry distro-specific patch for hv tools
    which switches off daemon().
    
    Introduce -n/--no-daemon option for all 3 daemons in hv/tools. Parse options
    with getopt() to make this part easily expandable.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 8f96b3ee0724..f437d739f37d 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -33,6 +33,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <dirent.h>
+#include <getopt.h>
 
 static int target_fd;
 static char target_fname[W_MAX_PATH];
@@ -126,15 +127,43 @@ static int hv_copy_cancel(void)
 
 }
 
-int main(void)
+void print_usage(char *argv[])
+{
+	fprintf(stderr, "Usage: %s [options]\n"
+		"Options are:\n"
+		"  -n, --no-daemon        stay in foreground, don't daemonize\n"
+		"  -h, --help             print this help\n", argv[0]);
+}
+
+int main(int argc, char *argv[])
 {
 	int fd, fcopy_fd, len;
 	int error;
+	int daemonize = 1, long_index = 0, opt;
 	int version = FCOPY_CURRENT_VERSION;
 	char *buffer[4096 * 2];
 	struct hv_fcopy_hdr *in_msg;
 
-	if (daemon(1, 0)) {
+	static struct option long_options[] = {
+		{"help",	no_argument,	   0,  'h' },
+		{"no-daemon",	no_argument,	   0,  'n' },
+		{0,		0,		   0,  0   }
+	};
+
+	while ((opt = getopt_long(argc, argv, "hn", long_options,
+				  &long_index)) != -1) {
+		switch (opt) {
+		case 'n':
+			daemonize = 0;
+			break;
+		case 'h':
+		default:
+			print_usage(argv);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (daemonize && daemon(1, 0)) {
 		syslog(LOG_ERR, "daemon() failed; error: %s", strerror(errno));
 		exit(EXIT_FAILURE);
 	}

commit e013ac312c79379b26cf29012cfbb37c68f79283
Author: Yue Zhang <yuezha@microsoft.com>
Date:   Fri Jun 27 18:19:48 2014 -0700

    Tools: hv: fix file overwriting of hv_fcopy_daemon
    
    hv_fcopy_daemon fails to overwrite a file if the target file already
    exits.
    
    Add O_TRUNC flag on opening.
    
    Signed-off-by: Yue Zhang <yuezha@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index fba1c75aa484..8f96b3ee0724 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -88,7 +88,8 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 		}
 	}
 
-	target_fd = open(target_fname, O_RDWR | O_CREAT | O_CLOEXEC, 0744);
+	target_fd = open(target_fname,
+			 O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0744);
 	if (target_fd == -1) {
 		syslog(LOG_INFO, "Open Failed: %s", strerror(errno));
 		goto done;

commit 314672a2c2780212fb770bb02d2fffaa1019823f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 9 17:24:16 2014 -0700

    Tools: hv: Handle the case when the target file exists correctly
    
    Return the appropriate error code and handle the case when the target
    file exists correctly. This fixes a bug.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org> [3.14]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
index 4ecc4fd0bc1b..fba1c75aa484 100644
--- a/tools/hv/hv_fcopy_daemon.c
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -82,8 +82,10 @@ static int hv_start_fcopy(struct hv_start_fcopy *smsg)
 
 	if (!access(target_fname, F_OK)) {
 		syslog(LOG_INFO, "File: %s exists", target_fname);
-		if (!smsg->copy_flags & OVER_WRITE)
+		if (!(smsg->copy_flags & OVER_WRITE)) {
+			error = HV_ERROR_ALREADY_EXISTS;
 			goto done;
+		}
 	}
 
 	target_fd = open(target_fname, O_RDWR | O_CREAT | O_CLOEXEC, 0744);

commit 01325476d6e46185031be4a9bc6443832dbc807c
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Feb 16 11:34:30 2014 -0800

    Drivers: hv: Implement the file copy service
    
    Implement the file copy service for Linux guests on Hyper-V. This permits the
    host to copy a file (over VMBUS) into the guest. This facility is part of
    "guest integration services" supported on the Windows platform.
    Here is a link that provides additional details on this functionality:
    
    http://technet.microsoft.com/en-us/library/dn464282.aspx
    
    In V1 version of the patch I have addressed comments from
    Olaf Hering <olaf@aepfle.de> and Dan Carpenter <dan.carpenter@oracle.com>
    
    In V2 version of this patch I did some minor cleanup (making some globals
    static). In V4 version of the patch I have addressed all of Olaf's
    most recent set of comments/concerns.
    
    In V5 version of the patch I had addressed Greg's most recent comments.
    I would like to thank Greg for suggesting that I use misc device; it has
    significantly simplified the code.
    
    In V6 version of the patch I have cleaned up error message based on Olaf's
    comments. I have also rebased the patch based on the current tip.
    
    In this version of the patch, I have addressed the latest comments from Greg.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_fcopy_daemon.c b/tools/hv/hv_fcopy_daemon.c
new file mode 100644
index 000000000000..4ecc4fd0bc1b
--- /dev/null
+++ b/tools/hv/hv_fcopy_daemon.c
@@ -0,0 +1,195 @@
+/*
+ * An implementation of host to guest copy functionality for Linux.
+ *
+ * Copyright (C) 2014, Microsoft, Inc.
+ *
+ * Author : K. Y. Srinivasan <kys@microsoft.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <linux/hyperv.h>
+#include <syslog.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+
+static int target_fd;
+static char target_fname[W_MAX_PATH];
+
+static int hv_start_fcopy(struct hv_start_fcopy *smsg)
+{
+	int error = HV_E_FAIL;
+	char *q, *p;
+
+	/*
+	 * If possile append a path seperator to the path.
+	 */
+	if (strlen((char *)smsg->path_name) < (W_MAX_PATH - 2))
+		strcat((char *)smsg->path_name, "/");
+
+	p = (char *)smsg->path_name;
+	snprintf(target_fname, sizeof(target_fname), "%s/%s",
+		(char *)smsg->path_name, smsg->file_name);
+
+	syslog(LOG_INFO, "Target file name: %s", target_fname);
+	/*
+	 * Check to see if the path is already in place; if not,
+	 * create if required.
+	 */
+	while ((q = strchr(p, '/')) != NULL) {
+		if (q == p) {
+			p++;
+			continue;
+		}
+		*q = '\0';
+		if (access((char *)smsg->path_name, F_OK)) {
+			if (smsg->copy_flags & CREATE_PATH) {
+				if (mkdir((char *)smsg->path_name, 0755)) {
+					syslog(LOG_ERR, "Failed to create %s",
+						(char *)smsg->path_name);
+					goto done;
+				}
+			} else {
+				syslog(LOG_ERR, "Invalid path: %s",
+					(char *)smsg->path_name);
+				goto done;
+			}
+		}
+		p = q + 1;
+		*q = '/';
+	}
+
+	if (!access(target_fname, F_OK)) {
+		syslog(LOG_INFO, "File: %s exists", target_fname);
+		if (!smsg->copy_flags & OVER_WRITE)
+			goto done;
+	}
+
+	target_fd = open(target_fname, O_RDWR | O_CREAT | O_CLOEXEC, 0744);
+	if (target_fd == -1) {
+		syslog(LOG_INFO, "Open Failed: %s", strerror(errno));
+		goto done;
+	}
+
+	error = 0;
+done:
+	return error;
+}
+
+static int hv_copy_data(struct hv_do_fcopy *cpmsg)
+{
+	ssize_t bytes_written;
+
+	bytes_written = pwrite(target_fd, cpmsg->data, cpmsg->size,
+				cpmsg->offset);
+
+	if (bytes_written != cpmsg->size)
+		return HV_E_FAIL;
+
+	return 0;
+}
+
+static int hv_copy_finished(void)
+{
+	close(target_fd);
+	return 0;
+}
+static int hv_copy_cancel(void)
+{
+	close(target_fd);
+	unlink(target_fname);
+	return 0;
+
+}
+
+int main(void)
+{
+	int fd, fcopy_fd, len;
+	int error;
+	int version = FCOPY_CURRENT_VERSION;
+	char *buffer[4096 * 2];
+	struct hv_fcopy_hdr *in_msg;
+
+	if (daemon(1, 0)) {
+		syslog(LOG_ERR, "daemon() failed; error: %s", strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	openlog("HV_FCOPY", 0, LOG_USER);
+	syslog(LOG_INFO, "HV_FCOPY starting; pid is:%d", getpid());
+
+	fcopy_fd = open("/dev/vmbus/hv_fcopy", O_RDWR);
+
+	if (fcopy_fd < 0) {
+		syslog(LOG_ERR, "open /dev/vmbus/hv_fcopy failed; error: %d %s",
+			errno, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	/*
+	 * Register with the kernel.
+	 */
+	if ((write(fcopy_fd, &version, sizeof(int))) != sizeof(int)) {
+		syslog(LOG_ERR, "Registration failed: %s", strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	while (1) {
+		/*
+		 * In this loop we process fcopy messages after the
+		 * handshake is complete.
+		 */
+		len = pread(fcopy_fd, buffer, (4096 * 2), 0);
+		if (len < 0) {
+			syslog(LOG_ERR, "pread failed: %s", strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+		in_msg = (struct hv_fcopy_hdr *)buffer;
+
+		switch (in_msg->operation) {
+		case START_FILE_COPY:
+			error = hv_start_fcopy((struct hv_start_fcopy *)in_msg);
+			break;
+		case WRITE_TO_FILE:
+			error = hv_copy_data((struct hv_do_fcopy *)in_msg);
+			break;
+		case COMPLETE_FCOPY:
+			error = hv_copy_finished();
+			break;
+		case CANCEL_FCOPY:
+			error = hv_copy_cancel();
+			break;
+
+		default:
+			syslog(LOG_ERR, "Unknown operation: %d",
+				in_msg->operation);
+
+		}
+
+		if (pwrite(fcopy_fd, &error, sizeof(int), 0) != sizeof(int)) {
+			syslog(LOG_ERR, "pwrite failed: %s", strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+	}
+}
