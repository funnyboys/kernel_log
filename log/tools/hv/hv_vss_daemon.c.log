commit 9fc3c01a1fae669a2ef9f13ee1e1a26e057d79f8
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 25 21:49:41 2020 -0800

    Tools: hv: Reopen the devices if read() or write() returns errors
    
    The state machine in the hv_utils driver can run out of order in some
    corner cases, e.g. if the kvp daemon doesn't call write() fast enough
    due to some reason, kvp_timeout_func() can run first and move the state
    to HVUTIL_READY; next, when kvp_on_msg() is called it returns -EINVAL
    since kvp_transaction.state is smaller than HVUTIL_USERSPACE_REQ; later,
    the daemon's write() gets an error -EINVAL, and the daemon will exit().
    
    We can reproduce the issue by sending a SIGSTOP signal to the daemon, wait
    for 1 minute, and send a SIGCONT signal to the daemon: the daemon will
    exit() quickly.
    
    We can fix the issue by forcing a reset of the device (which means the
    daemon can close() and open() the device again) and doing extra necessary
    clean-up.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 92902a88f671..dd111870beee 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -28,6 +28,8 @@
 #include <stdbool.h>
 #include <dirent.h>
 
+static bool fs_frozen;
+
 /* Don't use syslog() in the function since that can cause write to disk */
 static int vss_do_freeze(char *dir, unsigned int cmd)
 {
@@ -155,18 +157,27 @@ static int vss_operate(int operation)
 			continue;
 		}
 		error |= vss_do_freeze(ent->mnt_dir, cmd);
-		if (error && operation == VSS_OP_FREEZE)
-			goto err;
+		if (operation == VSS_OP_FREEZE) {
+			if (error)
+				goto err;
+			fs_frozen = true;
+		}
 	}
 
 	endmntent(mounts);
 
 	if (root_seen) {
 		error |= vss_do_freeze("/", cmd);
-		if (error && operation == VSS_OP_FREEZE)
-			goto err;
+		if (operation == VSS_OP_FREEZE) {
+			if (error)
+				goto err;
+			fs_frozen = true;
+		}
 	}
 
+	if (operation == VSS_OP_THAW && !error)
+		fs_frozen = false;
+
 	goto out;
 err:
 	save_errno = errno;
@@ -175,6 +186,7 @@ static int vss_operate(int operation)
 		endmntent(mounts);
 	}
 	vss_operate(VSS_OP_THAW);
+	fs_frozen = false;
 	/* Call syslog after we thaw all filesystems */
 	if (ent)
 		syslog(LOG_ERR, "FREEZE of %s failed; error:%d %s",
@@ -196,13 +208,13 @@ void print_usage(char *argv[])
 
 int main(int argc, char *argv[])
 {
-	int vss_fd, len;
+	int vss_fd = -1, len;
 	int error;
 	struct pollfd pfd;
 	int	op;
 	struct hv_vss_msg vss_msg[1];
 	int daemonize = 1, long_index = 0, opt;
-	int in_handshake = 1;
+	int in_handshake;
 	__u32 kernel_modver;
 
 	static struct option long_options[] = {
@@ -232,6 +244,18 @@ int main(int argc, char *argv[])
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
 
+reopen_vss_fd:
+	if (vss_fd != -1)
+		close(vss_fd);
+	if (fs_frozen) {
+		if (vss_operate(VSS_OP_THAW) || fs_frozen) {
+			syslog(LOG_ERR, "failed to thaw file system: err=%d",
+			       errno);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	in_handshake = 1;
 	vss_fd = open("/dev/vmbus/hv_vss", O_RDWR);
 	if (vss_fd < 0) {
 		syslog(LOG_ERR, "open /dev/vmbus/hv_vss failed; error: %d %s",
@@ -284,8 +308,7 @@ int main(int argc, char *argv[])
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, "read failed; error:%d %s",
 			       errno, strerror(errno));
-			close(vss_fd);
-			return EXIT_FAILURE;
+			goto reopen_vss_fd;
 		}
 
 		op = vss_msg->vss_hdr.operation;
@@ -312,14 +335,18 @@ int main(int argc, char *argv[])
 		default:
 			syslog(LOG_ERR, "Illegal op:%d\n", op);
 		}
+
+		/*
+		 * The write() may return an error due to the faked VSS_OP_THAW
+		 * message upon hibernation. Ignore the error by resetting the
+		 * dev file, i.e. closing and re-opening it.
+		 */
 		vss_msg->error = error;
 		len = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, "write failed; error: %d %s", errno,
 			       strerror(errno));
-
-			if (op == VSS_OP_FREEZE)
-				vss_operate(VSS_OP_THAW);
+			goto reopen_vss_fd;
 		}
 	}
 

commit 2d35c66036b2494c329a32468c85405493370e75
Author: Adrian Vladu <avladu@cloudbasesolutions.com>
Date:   Mon May 6 16:51:24 2019 +0000

    tools: hv: fix typos in toolchain
    
    Fix typos in the HyperV toolchain.
    
    Signed-off-by: Adrian Vladu <avladu@cloudbasesolutions.com>
    
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Alessandro Pilotti <apilotti@cloudbasesolutions.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 8f813f5233d4..92902a88f671 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -42,7 +42,7 @@ static int vss_do_freeze(char *dir, unsigned int cmd)
 	 * If a partition is mounted more than once, only the first
 	 * FREEZE/THAW can succeed and the later ones will get
 	 * EBUSY/EINVAL respectively: there could be 2 cases:
-	 * 1) a user may mount the same partition to differnt directories
+	 * 1) a user may mount the same partition to different directories
 	 *  by mistake or on purpose;
 	 * 2) The subvolume of btrfs appears to have the same partition
 	 * mounted more than once.

commit b0995156071b0ff29a5902964a9dc8cfad6f81c0
Author: Adrian Vladu <avladu@cloudbasesolutions.com>
Date:   Mon May 6 16:50:58 2019 +0000

    tools: hv: fix KVP and VSS daemons exit code
    
    HyperV KVP and VSS daemons should exit with 0 when the '--help'
    or '-h' flags are used.
    
    Signed-off-by: Adrian Vladu <avladu@cloudbasesolutions.com>
    
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Alessandro Pilotti <apilotti@cloudbasesolutions.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index efe1e34dd91b..8f813f5233d4 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -218,6 +218,8 @@ int main(int argc, char *argv[])
 			daemonize = 0;
 			break;
 		case 'h':
+			print_usage(argv);
+			exit(0);
 		default:
 			print_usage(argv);
 			exit(EXIT_FAILURE);

commit 43aa31327bb36002f52026b13d5f1bde35a1fc14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:54 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 280
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose good title or non infringement see
      the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.459653302@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index b13300172762..efe1e34dd91b 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * An implementation of the host initiated guest snapshot for Hyper-V.
  *
- *
  * Copyright (C) 2013, Microsoft, Inc.
  * Author : K. Y. Srinivasan <kys@microsoft.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
  */
 
 

commit 07136793ccad877727afada2b0c926031f10cf52
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue Jun 5 13:37:56 2018 -0700

    Tools: hv: vss: fix loop device detection
    
    Commit ea81fdf0981d ("Tools: hv: vss: Skip freezing filesystems backed by
    loop") added skip for filesystems backed by loop device. However, it seems
    the detection of such cases is incomplete.
    
    It was found that with 'devicemapper' storage driver docker creates the
    following chain:
    
    NAME                                    MAJ:MIN
    loop0                                   7:0
    ..docker-8:4-8473394-pool               253:0
      ..docker-8:4-8473394-eac...           253:1
    
    so when we're looking at the mounted device we see major '253' and not '7'.
    
    Solve the issue by walking /sys/dev/block/*/slaves chain and checking if
    there's a loop device somewhere.
    
    Other than that, don't skip mountpoints silently when stat() fails. In case
    e.g. SELinux is failing stat we don't want to skip freezing everything
    without letting user know about the failure.
    
    Fixes: ea81fdf0981d ("Tools: hv: vss: Skip freezing filesystems backed by loop")
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 34031a297f02..b13300172762 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -36,6 +36,8 @@
 #include <linux/hyperv.h>
 #include <syslog.h>
 #include <getopt.h>
+#include <stdbool.h>
+#include <dirent.h>
 
 /* Don't use syslog() in the function since that can cause write to disk */
 static int vss_do_freeze(char *dir, unsigned int cmd)
@@ -68,6 +70,55 @@ static int vss_do_freeze(char *dir, unsigned int cmd)
 	return !!ret;
 }
 
+static bool is_dev_loop(const char *blkname)
+{
+	char *buffer;
+	DIR *dir;
+	struct dirent *entry;
+	bool ret = false;
+
+	buffer = malloc(PATH_MAX);
+	if (!buffer) {
+		syslog(LOG_ERR, "Can't allocate memory!");
+		exit(1);
+	}
+
+	snprintf(buffer, PATH_MAX, "%s/loop", blkname);
+	if (!access(buffer, R_OK | X_OK)) {
+		ret = true;
+		goto free_buffer;
+	} else if (errno != ENOENT) {
+		syslog(LOG_ERR, "Can't access: %s; error:%d %s!",
+		       buffer, errno, strerror(errno));
+	}
+
+	snprintf(buffer, PATH_MAX, "%s/slaves", blkname);
+	dir = opendir(buffer);
+	if (!dir) {
+		if (errno != ENOENT)
+			syslog(LOG_ERR, "Can't opendir: %s; error:%d %s!",
+			       buffer, errno, strerror(errno));
+		goto free_buffer;
+	}
+
+	while ((entry = readdir(dir)) != NULL) {
+		if (strcmp(entry->d_name, ".") == 0 ||
+		    strcmp(entry->d_name, "..") == 0)
+			continue;
+
+		snprintf(buffer, PATH_MAX, "%s/slaves/%s", blkname,
+			 entry->d_name);
+		if (is_dev_loop(buffer)) {
+			ret = true;
+			break;
+		}
+	}
+	closedir(dir);
+free_buffer:
+	free(buffer);
+	return ret;
+}
+
 static int vss_operate(int operation)
 {
 	char match[] = "/dev/";
@@ -75,6 +126,7 @@ static int vss_operate(int operation)
 	struct mntent *ent;
 	struct stat sb;
 	char errdir[1024] = {0};
+	char blkdir[23]; /* /sys/dev/block/XXX:XXX */
 	unsigned int cmd;
 	int error = 0, root_seen = 0, save_errno = 0;
 
@@ -96,10 +148,15 @@ static int vss_operate(int operation)
 	while ((ent = getmntent(mounts))) {
 		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
-		if (stat(ent->mnt_fsname, &sb) == -1)
-			continue;
-		if (S_ISBLK(sb.st_mode) && major(sb.st_rdev) == LOOP_MAJOR)
-			continue;
+		if (stat(ent->mnt_fsname, &sb)) {
+			syslog(LOG_ERR, "Can't stat: %s; error:%d %s!",
+			       ent->mnt_fsname, errno, strerror(errno));
+		} else {
+			sprintf(blkdir, "/sys/dev/block/%d:%d",
+				major(sb.st_rdev), minor(sb.st_rdev));
+			if (is_dev_loop(blkdir))
+				continue;
+		}
 		if (hasmntopt(ent, MNTOPT_RO) != NULL)
 			continue;
 		if (strcmp(ent->mnt_type, "vfat") == 0)

commit 1330fc35327f3ecdfa1aa645e7321ced7349b2cd
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sun Mar 4 22:17:14 2018 -0700

    tools: hv: fix compiler warnings about major/target_fname
    
    This patch fixes the below warnings with new glibc and gcc:
    
    hv_vss_daemon.c:100:13: warning: In the GNU C Library, "major" is defined
     by <sys/sysmacros.h>. For historical compatibility, it is currently
    defined by <sys/types.h> as well, but we plan to  remove this soon.
    To use "major", include <sys/sysmacros.h>  directly.
    
    hv_fcopy_daemon.c:42:2: note: 'snprintf' output between 2 and 1040
    bytes into a destination of size 260
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index b2b4ebffab8c..34031a297f02 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -22,6 +22,7 @@
 #include <sys/poll.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <mntent.h>

commit ea81fdf0981d9a4a998a015d325bed67624811f7
Author: Alex Ng <alexng@messages.microsoft.com>
Date:   Sun Aug 6 13:12:52 2017 -0700

    Tools: hv: vss: Skip freezing filesystems backed by loop
    
    Since a loop device is backed by a file, a backup will already result in
    its parent filesystem being frozen. It's sufficient to just freeze the
    parent filesystem, so we can skip the loop device.
    
    This avoids a situation where a loop device and its parent filesystem are
    both frozen and then thawed out of order. For example, if the loop device
    is enumerated first, we would thaw it while its parent filesystem is still
    frozen. The thaw operation fails and the loop device remains frozen.
    
    Signed-off-by: Alex Ng <alexng@messages.microsoft.com>
    Signed-off-by: Vyronas Tsingaras <vyronas@vtsingaras.me>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 7ba54195934c..b2b4ebffab8c 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -21,6 +21,7 @@
 #include <sys/types.h>
 #include <sys/poll.h>
 #include <sys/ioctl.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <mntent.h>
@@ -30,6 +31,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <linux/fs.h>
+#include <linux/major.h>
 #include <linux/hyperv.h>
 #include <syslog.h>
 #include <getopt.h>
@@ -70,6 +72,7 @@ static int vss_operate(int operation)
 	char match[] = "/dev/";
 	FILE *mounts;
 	struct mntent *ent;
+	struct stat sb;
 	char errdir[1024] = {0};
 	unsigned int cmd;
 	int error = 0, root_seen = 0, save_errno = 0;
@@ -92,6 +95,10 @@ static int vss_operate(int operation)
 	while ((ent = getmntent(mounts))) {
 		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
+		if (stat(ent->mnt_fsname, &sb) == -1)
+			continue;
+		if (S_ISBLK(sb.st_mode) && major(sb.st_rdev) == LOOP_MAJOR)
+			continue;
 		if (hasmntopt(ent, MNTOPT_RO) != NULL)
 			continue;
 		if (strcmp(ent->mnt_type, "vfat") == 0)

commit 6113e3d28149dee33f10e92df6a16efb2b9cf473
Author: Alex Ng <alexng@messages.microsoft.com>
Date:   Sun Apr 30 16:21:14 2017 -0700

    Tools: hv: vss: Thaw the filesystem and continue if freeze call has timed out
    
    If a FREEZE operation takes too long, the driver may time out and move on
    to another  operation. The daemon is unaware of this and attempts to
    notify the driver that the FREEZE succeeded. This results in an error from
    the driver and the daemon leaves the filesystem in frozen state.
    
    Fix this by thawing the filesystem and continuing.
    
    Signed-off-by: Michael Gissing <mg@faulpeltz.net>
    Signed-off-by: Alex Ng <alexng@messages.microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index e0829809c897..7ba54195934c 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -261,7 +261,9 @@ int main(int argc, char *argv[])
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, "write failed; error: %d %s", errno,
 			       strerror(errno));
-			exit(EXIT_FAILURE);
+
+			if (op == VSS_OP_FREEZE)
+				vss_operate(VSS_OP_THAW);
 		}
 	}
 

commit db886e4d24c2b3d334be2cc1bd1bd05d547eb4c4
Author: Alex Ng <alexng@messages.microsoft.com>
Date:   Fri Sep 2 05:58:25 2016 -0700

    Drivers: hv: utils: Check VSS daemon is listening before a hot backup
    
    Hyper-V host will send a VSS_OP_HOT_BACKUP request to check if guest is
    ready for a live backup/snapshot. The driver should respond to the check
    only if the daemon is running and listening to requests. This allows the
    host to fallback to standard snapshots in case the VSS daemon is not
    running.
    
    Signed-off-by: Alex Ng <alexng@messages.microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 5d51d6ff08e6..e0829809c897 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -250,6 +250,9 @@ int main(int argc, char *argv[])
 				syslog(LOG_ERR, "/etc/fstab and /proc/mounts");
 			}
 			break;
+		case VSS_OP_HOT_BACKUP:
+			syslog(LOG_INFO, "VSS: op=CHECK HOT BACKUP\n");
+			break;
 		default:
 			syslog(LOG_ERR, "Illegal op:%d\n", op);
 		}

commit a689d2510f188e75391dbebacbddfd74d42f2a7e
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 14 16:01:58 2015 -0800

    tools: hv: vss: fix the write()'s argument: error -> vss_msg
    
    Fix the write()'s argument in the daemon code.
    
    Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 96234b638249..5d51d6ff08e6 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -254,7 +254,7 @@ int main(int argc, char *argv[])
 			syslog(LOG_ERR, "Illegal op:%d\n", op);
 		}
 		vss_msg->error = error;
-		len = write(vss_fd, &error, sizeof(struct hv_vss_msg));
+		len = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, "write failed; error: %d %s", errno,
 			       strerror(errno));

commit cd8dc0548511efff7a97d978f989ce67a883f9a5
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Apr 11 18:07:57 2015 -0700

    Drivers: hv: vss: full handshake support
    
    Introduce VSS_OP_REGISTER1 to support kernel replying to the negotiation
    message with its own version.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Tested-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 36f18211afa7..96234b638249 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -148,6 +148,8 @@ int main(int argc, char *argv[])
 	int	op;
 	struct hv_vss_msg vss_msg[1];
 	int daemonize = 1, long_index = 0, opt;
+	int in_handshake = 1;
+	__u32 kernel_modver;
 
 	static struct option long_options[] = {
 		{"help",	no_argument,	   0,  'h' },
@@ -211,6 +213,18 @@ int main(int argc, char *argv[])
 
 		len = read(vss_fd, vss_msg, sizeof(struct hv_vss_msg));
 
+		if (in_handshake) {
+			if (len != sizeof(kernel_modver)) {
+				syslog(LOG_ERR, "invalid version negotiation");
+				exit(EXIT_FAILURE);
+			}
+			kernel_modver = *(__u32 *)vss_msg;
+			in_handshake = 0;
+			syslog(LOG_INFO, "VSS: kernel module version: %d",
+			       kernel_modver);
+			continue;
+		}
+
 		if (len != sizeof(struct hv_vss_msg)) {
 			syslog(LOG_ERR, "read failed; error:%d %s",
 			       errno, strerror(errno));

commit f5722b9bd418e29b7429bd9a43bd100599b26d4f
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Apr 11 18:07:56 2015 -0700

    Tools: hv: vss: use misc char device to communicate with kernel
    
    Use /dev/vmbus/hv_vss instead of netlink.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Tested-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 506dd0148828..36f18211afa7 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -19,7 +19,6 @@
 
 
 #include <sys/types.h>
-#include <sys/socket.h>
 #include <sys/poll.h>
 #include <sys/ioctl.h>
 #include <fcntl.h>
@@ -30,21 +29,11 @@
 #include <string.h>
 #include <ctype.h>
 #include <errno.h>
-#include <arpa/inet.h>
 #include <linux/fs.h>
-#include <linux/connector.h>
 #include <linux/hyperv.h>
-#include <linux/netlink.h>
 #include <syslog.h>
 #include <getopt.h>
 
-static struct sockaddr_nl addr;
-
-#ifndef SOL_NETLINK
-#define SOL_NETLINK 270
-#endif
-
-
 /* Don't use syslog() in the function since that can cause write to disk */
 static int vss_do_freeze(char *dir, unsigned int cmd)
 {
@@ -143,33 +132,6 @@ static int vss_operate(int operation)
 	return error;
 }
 
-static int netlink_send(int fd, struct cn_msg *msg)
-{
-	struct nlmsghdr nlh = { .nlmsg_type = NLMSG_DONE };
-	unsigned int size;
-	struct msghdr message;
-	struct iovec iov[2];
-
-	size = sizeof(struct cn_msg) + msg->len;
-
-	nlh.nlmsg_pid = getpid();
-	nlh.nlmsg_len = NLMSG_LENGTH(size);
-
-	iov[0].iov_base = &nlh;
-	iov[0].iov_len = sizeof(nlh);
-
-	iov[1].iov_base = msg;
-	iov[1].iov_len = size;
-
-	memset(&message, 0, sizeof(message));
-	message.msg_name = &addr;
-	message.msg_namelen = sizeof(addr);
-	message.msg_iov = iov;
-	message.msg_iovlen = 2;
-
-	return sendmsg(fd, &message, 0);
-}
-
 void print_usage(char *argv[])
 {
 	fprintf(stderr, "Usage: %s [options]\n"
@@ -180,16 +142,11 @@ void print_usage(char *argv[])
 
 int main(int argc, char *argv[])
 {
-	int fd, len, nl_group;
+	int vss_fd, len;
 	int error;
-	struct cn_msg *message;
 	struct pollfd pfd;
-	struct nlmsghdr *incoming_msg;
-	struct cn_msg	*incoming_cn_msg;
 	int	op;
-	struct hv_vss_msg *vss_msg;
-	char *vss_recv_buffer;
-	size_t vss_recv_buffer_len;
+	struct hv_vss_msg vss_msg[1];
 	int daemonize = 1, long_index = 0, opt;
 
 	static struct option long_options[] = {
@@ -217,98 +174,50 @@ int main(int argc, char *argv[])
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
 
-	vss_recv_buffer_len = NLMSG_LENGTH(0) + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);
-	vss_recv_buffer = calloc(1, vss_recv_buffer_len);
-	if (!vss_recv_buffer) {
-		syslog(LOG_ERR, "Failed to allocate netlink buffers");
-		exit(EXIT_FAILURE);
-	}
-
-	fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
-	if (fd < 0) {
-		syslog(LOG_ERR, "netlink socket creation failed; error:%d %s",
-				errno, strerror(errno));
-		exit(EXIT_FAILURE);
-	}
-	addr.nl_family = AF_NETLINK;
-	addr.nl_pad = 0;
-	addr.nl_pid = 0;
-	addr.nl_groups = 0;
-
-
-	error = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
-	if (error < 0) {
-		syslog(LOG_ERR, "bind failed; error:%d %s", errno, strerror(errno));
-		close(fd);
-		exit(EXIT_FAILURE);
-	}
-	nl_group = CN_VSS_IDX;
-	if (setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group)) < 0) {
-		syslog(LOG_ERR, "setsockopt failed; error:%d %s", errno, strerror(errno));
-		close(fd);
+	vss_fd = open("/dev/vmbus/hv_vss", O_RDWR);
+	if (vss_fd < 0) {
+		syslog(LOG_ERR, "open /dev/vmbus/hv_vss failed; error: %d %s",
+		       errno, strerror(errno));
 		exit(EXIT_FAILURE);
 	}
 	/*
 	 * Register ourselves with the kernel.
 	 */
-	message = (struct cn_msg *)vss_recv_buffer;
-	message->id.idx = CN_VSS_IDX;
-	message->id.val = CN_VSS_VAL;
-	message->ack = 0;
-	vss_msg = (struct hv_vss_msg *)message->data;
-	vss_msg->vss_hdr.operation = VSS_OP_REGISTER;
-
-	message->len = sizeof(struct hv_vss_msg);
+	vss_msg->vss_hdr.operation = VSS_OP_REGISTER1;
 
-	len = netlink_send(fd, message);
+	len = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));
 	if (len < 0) {
-		syslog(LOG_ERR, "netlink_send failed; error:%d %s", errno, strerror(errno));
-		close(fd);
+		syslog(LOG_ERR, "registration to kernel failed; error: %d %s",
+		       errno, strerror(errno));
+		close(vss_fd);
 		exit(EXIT_FAILURE);
 	}
 
-	pfd.fd = fd;
+	pfd.fd = vss_fd;
 
 	while (1) {
-		struct sockaddr *addr_p = (struct sockaddr *) &addr;
-		socklen_t addr_l = sizeof(addr);
 		pfd.events = POLLIN;
 		pfd.revents = 0;
 
 		if (poll(&pfd, 1, -1) < 0) {
 			syslog(LOG_ERR, "poll failed; error:%d %s", errno, strerror(errno));
 			if (errno == EINVAL) {
-				close(fd);
+				close(vss_fd);
 				exit(EXIT_FAILURE);
 			}
 			else
 				continue;
 		}
 
-		len = recvfrom(fd, vss_recv_buffer, vss_recv_buffer_len, 0,
-				addr_p, &addr_l);
+		len = read(vss_fd, vss_msg, sizeof(struct hv_vss_msg));
 
-		if (len < 0) {
-			syslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",
-					addr.nl_pid, errno, strerror(errno));
-			close(fd);
-			return -1;
-		}
-
-		if (addr.nl_pid) {
-			syslog(LOG_WARNING,
-				"Received packet from untrusted pid:%u",
-				addr.nl_pid);
-			continue;
+		if (len != sizeof(struct hv_vss_msg)) {
+			syslog(LOG_ERR, "read failed; error:%d %s",
+			       errno, strerror(errno));
+			close(vss_fd);
+			return EXIT_FAILURE;
 		}
 
-		incoming_msg = (struct nlmsghdr *)vss_recv_buffer;
-
-		if (incoming_msg->nlmsg_type != NLMSG_DONE)
-			continue;
-
-		incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);
-		vss_msg = (struct hv_vss_msg *)incoming_cn_msg->data;
 		op = vss_msg->vss_hdr.operation;
 		error =  HV_S_OK;
 
@@ -331,12 +240,14 @@ int main(int argc, char *argv[])
 			syslog(LOG_ERR, "Illegal op:%d\n", op);
 		}
 		vss_msg->error = error;
-		len = netlink_send(fd, incoming_cn_msg);
-		if (len < 0) {
-			syslog(LOG_ERR, "net_link send failed; error:%d %s",
-					errno, strerror(errno));
+		len = write(vss_fd, &error, sizeof(struct hv_vss_msg));
+		if (len != sizeof(struct hv_vss_msg)) {
+			syslog(LOG_ERR, "write failed; error: %d %s", errno,
+			       strerror(errno));
 			exit(EXIT_FAILURE);
 		}
 	}
 
+	close(vss_fd);
+	exit(0);
 }

commit 4ce50e9491c5c92baf8bb7af85eb25398d3f70af
Author: Vaughan Cao <vaughan.cao@oracle.com>
Date:   Wed Mar 18 12:29:28 2015 -0700

    hv: hypervvssd: call endmntent before call setmntent again
    
    If freeze fails, vss_operate will re-enter itself to thaw. But it forgets
    to call endmntent() before it recalls setmntent() again.
    
    Signed-off-by: Vaughan Cao <vaughan.cao@oracle.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 5e63f70bd956..506dd0148828 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -81,6 +81,7 @@ static int vss_operate(int operation)
 	char match[] = "/dev/";
 	FILE *mounts;
 	struct mntent *ent;
+	char errdir[1024] = {0};
 	unsigned int cmd;
 	int error = 0, root_seen = 0, save_errno = 0;
 
@@ -115,6 +116,8 @@ static int vss_operate(int operation)
 			goto err;
 	}
 
+	endmntent(mounts);
+
 	if (root_seen) {
 		error |= vss_do_freeze("/", cmd);
 		if (error && operation == VSS_OP_FREEZE)
@@ -124,16 +127,19 @@ static int vss_operate(int operation)
 	goto out;
 err:
 	save_errno = errno;
+	if (ent) {
+		strncpy(errdir, ent->mnt_dir, sizeof(errdir)-1);
+		endmntent(mounts);
+	}
 	vss_operate(VSS_OP_THAW);
 	/* Call syslog after we thaw all filesystems */
 	if (ent)
 		syslog(LOG_ERR, "FREEZE of %s failed; error:%d %s",
-		       ent->mnt_dir, save_errno, strerror(save_errno));
+		       errdir, save_errno, strerror(save_errno));
 	else
 		syslog(LOG_ERR, "FREEZE of / failed; error:%d %s", save_errno,
 		       strerror(save_errno));
 out:
-	endmntent(mounts);
 	return error;
 }
 

commit 9e5db05aae4657c7ade34ccc4b93f27ab647498e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Nov 10 17:37:02 2014 +0100

    Tools: hv: vssdaemon: skip all filesystems mounted readonly
    
    Instead of making a list of exceptions for readonly filesystems
    in addition to iso9660 we already have it is better to skip freeze
    operation for all readonly-mounted filesystems.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Acked-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index ee44f0d730ef..5e63f70bd956 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -102,7 +102,7 @@ static int vss_operate(int operation)
 	while ((ent = getmntent(mounts))) {
 		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
-		if (strcmp(ent->mnt_type, "iso9660") == 0)
+		if (hasmntopt(ent, MNTOPT_RO) != NULL)
 			continue;
 		if (strcmp(ent->mnt_type, "vfat") == 0)
 			continue;

commit 7a401744d517864f8f2f2afba589e58a71d03aa6
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Nov 10 17:37:01 2014 +0100

    Tools: hv: vssdaemon: report freeze errors
    
    When ioctl(fd, FIFREEZE, 0) results in an error we cannot report it
    to syslog instantly since that can cause write to a frozen disk.
    However, the name of the filesystem which caused the error and errno
    are valuable and we would like to get a nice human-readable message
    in the log. Save errno before calling vss_operate(VSS_OP_THAW) and
    report the error right after.
    
    Unfortunately, FITHAW errors cannot be reported the same way as we
    need to finish thawing all filesystems before calling syslog().
    
    We should also avoid calling endmntent() for the second time in
    case we encountered an error during freezing of '/' as it usually
    results in SEGSEGV.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Acked-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index b720d8f0f901..ee44f0d730ef 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -82,7 +82,7 @@ static int vss_operate(int operation)
 	FILE *mounts;
 	struct mntent *ent;
 	unsigned int cmd;
-	int error = 0, root_seen = 0;
+	int error = 0, root_seen = 0, save_errno = 0;
 
 	switch (operation) {
 	case VSS_OP_FREEZE:
@@ -114,7 +114,6 @@ static int vss_operate(int operation)
 		if (error && operation == VSS_OP_FREEZE)
 			goto err;
 	}
-	endmntent(mounts);
 
 	if (root_seen) {
 		error |= vss_do_freeze("/", cmd);
@@ -122,10 +121,19 @@ static int vss_operate(int operation)
 			goto err;
 	}
 
-	return error;
+	goto out;
 err:
-	endmntent(mounts);
+	save_errno = errno;
 	vss_operate(VSS_OP_THAW);
+	/* Call syslog after we thaw all filesystems */
+	if (ent)
+		syslog(LOG_ERR, "FREEZE of %s failed; error:%d %s",
+		       ent->mnt_dir, save_errno, strerror(save_errno));
+	else
+		syslog(LOG_ERR, "FREEZE of / failed; error:%d %s", save_errno,
+		       strerror(save_errno));
+out:
+	endmntent(mounts);
 	return error;
 }
 

commit 170f4bea2008054e5098f99359e29823a7b4b1b9
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 22 18:07:11 2014 +0200

    tools: hv: introduce -n/--no-daemon option
    
    All tools/hv daemons do mandatory daemon() on startup. However, no pidfile
    is created, this make it difficult for an init system to track such daemons.
    Modern linux distros use systemd as their init system. It can handle the
    daemonizing by itself, however, it requires a daemon to stay in foreground
    for that. Some distros already carry distro-specific patch for hv tools
    which switches off daemon().
    
    Introduce -n/--no-daemon option for all 3 daemons in hv/tools. Parse options
    with getopt() to make this part easily expandable.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 1db9430d3fe4..b720d8f0f901 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -36,6 +36,7 @@
 #include <linux/hyperv.h>
 #include <linux/netlink.h>
 #include <syslog.h>
+#include <getopt.h>
 
 static struct sockaddr_nl addr;
 
@@ -155,7 +156,15 @@ static int netlink_send(int fd, struct cn_msg *msg)
 	return sendmsg(fd, &message, 0);
 }
 
-int main(void)
+void print_usage(char *argv[])
+{
+	fprintf(stderr, "Usage: %s [options]\n"
+		"Options are:\n"
+		"  -n, --no-daemon        stay in foreground, don't daemonize\n"
+		"  -h, --help             print this help\n", argv[0]);
+}
+
+int main(int argc, char *argv[])
 {
 	int fd, len, nl_group;
 	int error;
@@ -167,8 +176,28 @@ int main(void)
 	struct hv_vss_msg *vss_msg;
 	char *vss_recv_buffer;
 	size_t vss_recv_buffer_len;
+	int daemonize = 1, long_index = 0, opt;
+
+	static struct option long_options[] = {
+		{"help",	no_argument,	   0,  'h' },
+		{"no-daemon",	no_argument,	   0,  'n' },
+		{0,		0,		   0,  0   }
+	};
+
+	while ((opt = getopt_long(argc, argv, "hn", long_options,
+				  &long_index)) != -1) {
+		switch (opt) {
+		case 'n':
+			daemonize = 0;
+			break;
+		case 'h':
+		default:
+			print_usage(argv);
+			exit(EXIT_FAILURE);
+		}
+	}
 
-	if (daemon(1, 0))
+	if (daemonize && daemon(1, 0))
 		return 1;
 
 	openlog("Hyper-V VSS", 0, LOG_USER);

commit 4f689190bb55d171d2f6614f8a6cbd4b868e48bd
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 25 21:52:04 2014 -0700

    Tools: hv: vssdaemon: ignore the EBUSY on multiple freezing the same partition
    
    If a partition appears mounted more than once in /proc/mounts, vss_do_freeze()
    succeeds only for the first time and gets EBUSY (on freeze) or EINVAL (on
    thaw) for the second time. The patch ignores these to make the backup feature
    work.
    
    Also improved the error handling in case a freeze operation fails.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 6a213b8cd7b9..1db9430d3fe4 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -44,21 +44,39 @@ static struct sockaddr_nl addr;
 #endif
 
 
-static int vss_do_freeze(char *dir, unsigned int cmd, char *fs_op)
+/* Don't use syslog() in the function since that can cause write to disk */
+static int vss_do_freeze(char *dir, unsigned int cmd)
 {
 	int ret, fd = open(dir, O_RDONLY);
 
 	if (fd < 0)
 		return 1;
+
 	ret = ioctl(fd, cmd, 0);
-	syslog(LOG_INFO, "VSS: %s of %s: %s\n", fs_op, dir, strerror(errno));
+
+	/*
+	 * If a partition is mounted more than once, only the first
+	 * FREEZE/THAW can succeed and the later ones will get
+	 * EBUSY/EINVAL respectively: there could be 2 cases:
+	 * 1) a user may mount the same partition to differnt directories
+	 *  by mistake or on purpose;
+	 * 2) The subvolume of btrfs appears to have the same partition
+	 * mounted more than once.
+	 */
+	if (ret) {
+		if ((cmd == FIFREEZE && errno == EBUSY) ||
+		    (cmd == FITHAW && errno == EINVAL)) {
+			close(fd);
+			return 0;
+		}
+	}
+
 	close(fd);
 	return !!ret;
 }
 
 static int vss_operate(int operation)
 {
-	char *fs_op;
 	char match[] = "/dev/";
 	FILE *mounts;
 	struct mntent *ent;
@@ -68,11 +86,9 @@ static int vss_operate(int operation)
 	switch (operation) {
 	case VSS_OP_FREEZE:
 		cmd = FIFREEZE;
-		fs_op = "freeze";
 		break;
 	case VSS_OP_THAW:
 		cmd = FITHAW;
-		fs_op = "thaw";
 		break;
 	default:
 		return -1;
@@ -93,14 +109,22 @@ static int vss_operate(int operation)
 			root_seen = 1;
 			continue;
 		}
-		error |= vss_do_freeze(ent->mnt_dir, cmd, fs_op);
+		error |= vss_do_freeze(ent->mnt_dir, cmd);
+		if (error && operation == VSS_OP_FREEZE)
+			goto err;
 	}
 	endmntent(mounts);
 
 	if (root_seen) {
-		error |= vss_do_freeze("/", cmd, fs_op);
+		error |= vss_do_freeze("/", cmd);
+		if (error && operation == VSS_OP_FREEZE)
+			goto err;
 	}
 
+	return error;
+err:
+	endmntent(mounts);
+	vss_operate(VSS_OP_THAW);
 	return error;
 }
 
@@ -249,8 +273,16 @@ int main(void)
 		case VSS_OP_FREEZE:
 		case VSS_OP_THAW:
 			error = vss_operate(op);
-			if (error)
+			syslog(LOG_INFO, "VSS: op=%s: %s\n",
+				op == VSS_OP_FREEZE ? "FREEZE" : "THAW",
+				error ? "failed" : "succeeded");
+
+			if (error) {
 				error = HV_E_FAIL;
+				syslog(LOG_ERR, "op=%d failed!", op);
+				syslog(LOG_ERR, "report it with these files:");
+				syslog(LOG_ERR, "/etc/fstab and /proc/mounts");
+			}
 			break;
 		default:
 			syslog(LOG_ERR, "Illegal op:%d\n", op);

commit f33b215549938f89aebf862b942366d2aa41c191
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Feb 12 08:40:22 2014 -0800

    Tools: hv: vssdaemon: Ignore VFAT mounts during the Freeze operation
    
    If the guest has a FAT file system mounted, skip it during the FREEZE
    operation. With this change we can support host initiated backup of
    the guest even when the guest may have FAT file systems mounted.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 520de3304571..6a213b8cd7b9 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -87,6 +87,8 @@ static int vss_operate(int operation)
 			continue;
 		if (strcmp(ent->mnt_type, "iso9660") == 0)
 			continue;
+		if (strcmp(ent->mnt_type, "vfat") == 0)
+			continue;
 		if (strcmp(ent->mnt_dir, "/") == 0) {
 			root_seen = 1;
 			continue;

commit 51b68128ef55200fbe03d82c9ac5722f255e58b7
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Dec 4 14:25:55 2013 +0100

    Tools: hv: remove inclusion of linux/types.h
    
    With very old libc headers the inclusion of sys/types.h causes conflicts
    with linux/types.h. Since the latter is not required anyway, remove it
    from the source files. If any of the headers really needs linux/types.h
    it has to include it itself.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 8bcb04096eb2..520de3304571 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -22,7 +22,6 @@
 #include <sys/socket.h>
 #include <sys/poll.h>
 #include <sys/ioctl.h>
-#include <linux/types.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <mntent.h>

commit 269ce62bbc00c4e80bf3ca2aa21823f20625bcf6
Author: Olaf Hering <olaf@aepfle.de>
Date:   Tue Aug 6 20:55:38 2013 +0200

    Tools: hv: use single send+recv buffer
    
    send_buffer is used only once during registration. To reduce runtime
    memory usage reuse the recv_buffer for registration. Also use
    NLMSG_LENGTH instead of NLMSG_HDRLEN to take alignment into account.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 8611962c672c..8bcb04096eb2 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -140,7 +140,6 @@ int main(void)
 	struct cn_msg	*incoming_cn_msg;
 	int	op;
 	struct hv_vss_msg *vss_msg;
-	char *vss_send_buffer;
 	char *vss_recv_buffer;
 	size_t vss_recv_buffer_len;
 
@@ -150,10 +149,9 @@ int main(void)
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
 
-	vss_recv_buffer_len = NLMSG_HDRLEN + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);
-	vss_send_buffer = calloc(1, vss_recv_buffer_len);
+	vss_recv_buffer_len = NLMSG_LENGTH(0) + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);
 	vss_recv_buffer = calloc(1, vss_recv_buffer_len);
-	if (!(vss_send_buffer && vss_recv_buffer)) {
+	if (!vss_recv_buffer) {
 		syslog(LOG_ERR, "Failed to allocate netlink buffers");
 		exit(EXIT_FAILURE);
 	}
@@ -185,7 +183,7 @@ int main(void)
 	/*
 	 * Register ourselves with the kernel.
 	 */
-	message = (struct cn_msg *)vss_send_buffer;
+	message = (struct cn_msg *)vss_recv_buffer;
 	message->id.idx = CN_VSS_IDX;
 	message->id.val = CN_VSS_VAL;
 	message->ack = 0;

commit b4fb0ca26055bb39b18a1427eea633877a3dcc80
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Aug 7 15:45:12 2013 +0200

    Tools: hv: use full nlmsghdr in netlink_send
    
    There is no need to have a nlmsghdr pointer to another temporary buffer.
    Instead use a full struct nlmsghdr.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 7cd2544aa49b..8611962c672c 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -105,23 +105,18 @@ static int vss_operate(int operation)
 
 static int netlink_send(int fd, struct cn_msg *msg)
 {
-	struct nlmsghdr *nlh;
+	struct nlmsghdr nlh = { .nlmsg_type = NLMSG_DONE };
 	unsigned int size;
 	struct msghdr message;
-	char buffer[64];
 	struct iovec iov[2];
 
 	size = sizeof(struct cn_msg) + msg->len;
 
-	nlh = (struct nlmsghdr *)buffer;
-	nlh->nlmsg_seq = 0;
-	nlh->nlmsg_pid = getpid();
-	nlh->nlmsg_type = NLMSG_DONE;
-	nlh->nlmsg_len = NLMSG_LENGTH(size - sizeof(*nlh));
-	nlh->nlmsg_flags = 0;
+	nlh.nlmsg_pid = getpid();
+	nlh.nlmsg_len = NLMSG_LENGTH(size);
 
-	iov[0].iov_base = nlh;
-	iov[0].iov_len = sizeof(*nlh);
+	iov[0].iov_base = &nlh;
+	iov[0].iov_len = sizeof(nlh);
 
 	iov[1].iov_base = msg;
 	iov[1].iov_len = size;

commit 2bc41ea3b3fd4c2f2473ec84f4ee3ef5ff21e49b
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Aug 7 15:07:21 2013 +0200

    Tools: hv: correct payload size in netlink_send
    
    netlink_send is supposed to send just the cn_msg+hv_kvp_msg via netlink.
    Currently it sets an incorrect iovec size, as reported by valgrind.
    
    In the case of registering with the kernel the allocated buffer is large
    enough to hold nlmsghdr+cn_msg+hv_kvp_msg, no overrun happens. In the
    case of responding to the kernel the cn_msg is located in the middle of
    recv_buffer, after the nlmsghdr. Currently the code in netlink_send adds
    also the size of nlmsghdr to the payload. But nlmsghdr is a separate
    iovec. This leads to an (harmless) out-of-bounds access when the kernel
    processes the iovec. Correct the iovec size of the cn_msg to be just
    cn_msg + its payload.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 4213d0e3083f..7cd2544aa49b 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -111,7 +111,7 @@ static int netlink_send(int fd, struct cn_msg *msg)
 	char buffer[64];
 	struct iovec iov[2];
 
-	size = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);
+	size = sizeof(struct cn_msg) + msg->len;
 
 	nlh = (struct nlmsghdr *)buffer;
 	nlh->nlmsg_seq = 0;

commit b4919a5f95c09992f66d4b7cbe392c33731a5cec
Author: Olaf Hering <olaf@aepfle.de>
Date:   Thu Aug 1 14:34:26 2013 +0200

    Tools: hv: fix send/recv buffer allocation
    
    hv_kvp_daemon fails to start in current openSuSE 13.1 snapshots because
    the kvp_send_buffer is too small to hold cn_msg+hv_kvp_msg, the very
    first sendmsg returns with EFAULT. In addition it fixes the Network info
    tab in Windows Server 2012R2 in SLES11.
    
    Adjust the code in kvp and vss daemon to allocate the needed buffers at
    runtime. To keep the code simple, the buffer_len includes also the
    nlmsghdr, although only the recv_buffer needs this extra space.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 826d499dc354..4213d0e3083f 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -38,8 +38,6 @@
 #include <linux/netlink.h>
 #include <syslog.h>
 
-static char vss_recv_buffer[4096];
-static char vss_send_buffer[4096];
 static struct sockaddr_nl addr;
 
 #ifndef SOL_NETLINK
@@ -147,6 +145,9 @@ int main(void)
 	struct cn_msg	*incoming_cn_msg;
 	int	op;
 	struct hv_vss_msg *vss_msg;
+	char *vss_send_buffer;
+	char *vss_recv_buffer;
+	size_t vss_recv_buffer_len;
 
 	if (daemon(1, 0))
 		return 1;
@@ -154,6 +155,14 @@ int main(void)
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
 
+	vss_recv_buffer_len = NLMSG_HDRLEN + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);
+	vss_send_buffer = calloc(1, vss_recv_buffer_len);
+	vss_recv_buffer = calloc(1, vss_recv_buffer_len);
+	if (!(vss_send_buffer && vss_recv_buffer)) {
+		syslog(LOG_ERR, "Failed to allocate netlink buffers");
+		exit(EXIT_FAILURE);
+	}
+
 	fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
 	if (fd < 0) {
 		syslog(LOG_ERR, "netlink socket creation failed; error:%d %s",
@@ -215,7 +224,7 @@ int main(void)
 				continue;
 		}
 
-		len = recvfrom(fd, vss_recv_buffer, sizeof(vss_recv_buffer), 0,
+		len = recvfrom(fd, vss_recv_buffer, vss_recv_buffer_len, 0,
 				addr_p, &addr_l);
 
 		if (len < 0) {

commit d12e14692448e9f256028f53926a9bd3c3091e11
Author: Tomas Hozza <thozza@redhat.com>
Date:   Thu Jun 27 13:52:48 2013 +0200

    tools: hv: Check return value of setsockopt call
    
    Check return value of setsockopt call and if it fails print error to the
    system log and exit with non-zero value.
    
    Signed-off-by: Tomas Hozza <thozza@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 5febe3542f79..826d499dc354 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -173,7 +173,11 @@ int main(void)
 		exit(EXIT_FAILURE);
 	}
 	nl_group = CN_VSS_IDX;
-	setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group));
+	if (setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group)) < 0) {
+		syslog(LOG_ERR, "setsockopt failed; error:%d %s", errno, strerror(errno));
+		close(fd);
+		exit(EXIT_FAILURE);
+	}
 	/*
 	 * Register ourselves with the kernel.
 	 */

commit 9561d479314f16b41563f73511fb61d91de4642f
Author: Tomas Hozza <thozza@redhat.com>
Date:   Thu Jun 27 13:52:49 2013 +0200

    tools: hv: Check return value of poll call
    
    Check return value of poll call and if it fails print error to the
    system log. If errno is EINVAL then exit with non-zero value otherwise
    continue the while loop and call poll again.
    
    Signed-off-by: Tomas Hozza <thozza@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 64112e193552..5febe3542f79 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -200,7 +200,16 @@ int main(void)
 		socklen_t addr_l = sizeof(addr);
 		pfd.events = POLLIN;
 		pfd.revents = 0;
-		poll(&pfd, 1, -1);
+
+		if (poll(&pfd, 1, -1) < 0) {
+			syslog(LOG_ERR, "poll failed; error:%d %s", errno, strerror(errno));
+			if (errno == EINVAL) {
+				close(fd);
+				exit(EXIT_FAILURE);
+			}
+			else
+				continue;
+		}
 
 		len = recvfrom(fd, vss_recv_buffer, sizeof(vss_recv_buffer), 0,
 				addr_p, &addr_l);

commit 5c2892698184bf82e1f7d5c557ad81c9570b569a
Author: Tomas Hozza <thozza@redhat.com>
Date:   Thu Jun 27 13:52:47 2013 +0200

    tools: hv: Improve error logging in VSS daemon.
    
    Use errno and strerror() when logging errors to provide more
    information.
    
    Signed-off-by: Tomas Hozza <thozza@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index fea03a3edaf4..64112e193552 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -156,7 +156,8 @@ int main(void)
 
 	fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
 	if (fd < 0) {
-		syslog(LOG_ERR, "netlink socket creation failed; error:%d", fd);
+		syslog(LOG_ERR, "netlink socket creation failed; error:%d %s",
+				errno, strerror(errno));
 		exit(EXIT_FAILURE);
 	}
 	addr.nl_family = AF_NETLINK;
@@ -167,7 +168,7 @@ int main(void)
 
 	error = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
 	if (error < 0) {
-		syslog(LOG_ERR, "bind failed; error:%d", error);
+		syslog(LOG_ERR, "bind failed; error:%d %s", errno, strerror(errno));
 		close(fd);
 		exit(EXIT_FAILURE);
 	}
@@ -187,7 +188,7 @@ int main(void)
 
 	len = netlink_send(fd, message);
 	if (len < 0) {
-		syslog(LOG_ERR, "netlink_send failed; error:%d", len);
+		syslog(LOG_ERR, "netlink_send failed; error:%d %s", errno, strerror(errno));
 		close(fd);
 		exit(EXIT_FAILURE);
 	}
@@ -241,7 +242,8 @@ int main(void)
 		vss_msg->error = error;
 		len = netlink_send(fd, incoming_cn_msg);
 		if (len < 0) {
-			syslog(LOG_ERR, "net_link send failed; error:%d", len);
+			syslog(LOG_ERR, "net_link send failed; error:%d %s",
+					errno, strerror(errno));
 			exit(EXIT_FAILURE);
 		}
 	}

commit 0e27263926699fcbbd574cff4dd6920007a50e8a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 24 07:48:54 2013 -0700

    Tools: hv: Fix a checkpatch warning
    
    Fix a checkpatch warning.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 712cfc516c65..fea03a3edaf4 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -85,7 +85,7 @@ static int vss_operate(int operation)
 	if (mounts == NULL)
 		return -1;
 
-	while((ent = getmntent(mounts))) {
+	while ((ent = getmntent(mounts))) {
 		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
 		if (strcmp(ent->mnt_type, "iso9660") == 0)

commit 10b637b4c8a21b299f691cecc4b6f16f44936c6d
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Apr 24 07:48:53 2013 -0700

    tools: hv: skip iso9660 mounts in hv_vss_daemon
    
    fsreeze does not work for iso9660 filesystems. A ENOSUPP may be caught
    in the freeze case, but the subsequent thaw call would fail and leads to
    a false error.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index dc73a897d8c6..712cfc516c65 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -88,6 +88,8 @@ static int vss_operate(int operation)
 	while((ent = getmntent(mounts))) {
 		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
+		if (strcmp(ent->mnt_type, "iso9660") == 0)
+			continue;
 		if (strcmp(ent->mnt_dir, "/") == 0) {
 			root_seen = 1;
 			continue;

commit 7b413b65531422cc3d12a8acf53a43bc0d3c9f7b
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Apr 24 07:48:52 2013 -0700

    tools: hv: use FIFREEZE/FITHAW in hv_vss_daemon
    
    As suggested by Paolo Bonzini, use ioctl instead of calling fsfreeze.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index a5da91df4f76..dc73a897d8c6 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -21,7 +21,9 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/poll.h>
+#include <sys/ioctl.h>
 #include <linux/types.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <mntent.h>
 #include <stdlib.h>
@@ -30,6 +32,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <arpa/inet.h>
+#include <linux/fs.h>
 #include <linux/connector.h>
 #include <linux/hyperv.h>
 #include <linux/netlink.h>
@@ -44,21 +47,35 @@ static struct sockaddr_nl addr;
 #endif
 
 
+static int vss_do_freeze(char *dir, unsigned int cmd, char *fs_op)
+{
+	int ret, fd = open(dir, O_RDONLY);
+
+	if (fd < 0)
+		return 1;
+	ret = ioctl(fd, cmd, 0);
+	syslog(LOG_INFO, "VSS: %s of %s: %s\n", fs_op, dir, strerror(errno));
+	close(fd);
+	return !!ret;
+}
+
 static int vss_operate(int operation)
 {
 	char *fs_op;
-	char cmd[512];
 	char match[] = "/dev/";
 	FILE *mounts;
 	struct mntent *ent;
+	unsigned int cmd;
 	int error = 0, root_seen = 0;
 
 	switch (operation) {
 	case VSS_OP_FREEZE:
-		fs_op = "-f ";
+		cmd = FIFREEZE;
+		fs_op = "freeze";
 		break;
 	case VSS_OP_THAW:
-		fs_op = "-u ";
+		cmd = FITHAW;
+		fs_op = "thaw";
 		break;
 	default:
 		return -1;
@@ -75,16 +92,12 @@ static int vss_operate(int operation)
 			root_seen = 1;
 			continue;
 		}
-		snprintf(cmd, sizeof(cmd), "fsfreeze %s '%s'", fs_op, ent->mnt_dir);
-		syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
-		error |= system(cmd);
+		error |= vss_do_freeze(ent->mnt_dir, cmd, fs_op);
 	}
 	endmntent(mounts);
 
 	if (root_seen) {
-		sprintf(cmd, "fsfreeze %s /", fs_op);
-		syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
-		error |= system(cmd);
+		error |= vss_do_freeze("/", cmd, fs_op);
 	}
 
 	return error;

commit d3d1ee3ab28711360937839423158cc185f710f2
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Apr 24 07:48:51 2013 -0700

    tools: hv: use getmntent in hv_vss_daemon
    
    As suggested by Paolo Bonzini, use getmntent instead of parsing output
    of mount(1).
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 921c1bec0305..a5da91df4f76 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -23,6 +23,7 @@
 #include <sys/poll.h>
 #include <linux/types.h>
 #include <stdio.h>
+#include <mntent.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
@@ -47,11 +48,10 @@ static int vss_operate(int operation)
 {
 	char *fs_op;
 	char cmd[512];
-	char buf[512];
-	FILE *file;
-	char *p;
-	char *x;
-	int error = 0;
+	char match[] = "/dev/";
+	FILE *mounts;
+	struct mntent *ent;
+	int error = 0, root_seen = 0;
 
 	switch (operation) {
 	case VSS_OP_FREEZE:
@@ -64,25 +64,28 @@ static int vss_operate(int operation)
 		return -1;
 	}
 
-	file = popen("mount | awk '/^\\/dev\\// { print $3}'", "r");
-	if (file == NULL)
+	mounts = setmntent("/proc/mounts", "r");
+	if (mounts == NULL)
 		return -1;
 
-	while ((p = fgets(buf, sizeof(buf), file)) != NULL) {
-		x = strchr(p, '\n');
-		*x = '\0';
-		if (!strncmp(p, "/", sizeof("/")))
+	while((ent = getmntent(mounts))) {
+		if (strncmp(ent->mnt_fsname, match, strlen(match)))
 			continue;
-
-		sprintf(cmd, "%s %s %s", "fsfreeze ", fs_op, p);
+		if (strcmp(ent->mnt_dir, "/") == 0) {
+			root_seen = 1;
+			continue;
+		}
+		snprintf(cmd, sizeof(cmd), "fsfreeze %s '%s'", fs_op, ent->mnt_dir);
 		syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
-		error = system(cmd);
+		error |= system(cmd);
 	}
-	pclose(file);
+	endmntent(mounts);
 
-	sprintf(cmd, "%s %s %s", "fsfreeze ", fs_op, "/");
-	syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
-	error = system(cmd);
+	if (root_seen) {
+		sprintf(cmd, "fsfreeze %s /", fs_op);
+		syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
+		error |= system(cmd);
+	}
 
 	return error;
 }

commit 038336a5b40ceeea394a6eb3e8c6fc75701eec47
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 24 07:48:50 2013 -0700

    Tools: hv: Fix a checkpatch warning
    
    Fix a checkpatch warning.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index dc3eb1e44c8a..921c1bec0305 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -194,8 +194,9 @@ int main(void)
 		}
 
 		if (addr.nl_pid) {
-			syslog(LOG_WARNING, "Received packet from untrusted pid:%u",
-					addr.nl_pid);
+			syslog(LOG_WARNING,
+				"Received packet from untrusted pid:%u",
+				addr.nl_pid);
 			continue;
 		}
 

commit 5edf5ee42a4dfbc500e9b9531335305d4c81a129
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Apr 24 07:48:49 2013 -0700

    tools: hv: fix checks for origin of netlink message in hv_vss_daemon
    
    Similar to what commit 95a69adab9acfc3981c504737a2b6578e4d846ef ("tools:
    hv: Netlink source address validation allows DoS") does in
    hv_kvp_daemon, improve checks for origin of netlink connector message.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 2a03d0b4e213..dc3eb1e44c8a 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -186,13 +186,19 @@ int main(void)
 		len = recvfrom(fd, vss_recv_buffer, sizeof(vss_recv_buffer), 0,
 				addr_p, &addr_l);
 
-		if (len < 0 || addr.nl_pid) {
+		if (len < 0) {
 			syslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",
 					addr.nl_pid, errno, strerror(errno));
 			close(fd);
 			return -1;
 		}
 
+		if (addr.nl_pid) {
+			syslog(LOG_WARNING, "Received packet from untrusted pid:%u",
+					addr.nl_pid);
+			continue;
+		}
+
 		incoming_msg = (struct nlmsghdr *)vss_recv_buffer;
 
 		if (incoming_msg->nlmsg_type != NLMSG_DONE)

commit eb8905b8ff4a887901779504d2ede95dc072bb16
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Apr 24 07:48:48 2013 -0700

    Tools: hv: fix warnings in hv_vss_daemon
    
    This change fixes a few compile errors:
    
    hv_vss_daemon.c:64:15: warning: unknown escape sequence '\/'
    hv_vss_daemon.c:64:15: warning: unknown escape sequence '\/'
    hv_vss_daemon.c: In function 'vss_operate':
    hv_vss_daemon.c:66: warning: 'return' with no value, in function returning non-void
    hv_vss_daemon.c: In function 'main':
    hv_vss_daemon.c:130: warning: ignoring return value of 'daemon', declared with attribute warn_unused_result
    hv_vss_daemon.c: In function 'vss_operate':
    hv_vss_daemon.c:47: warning: 'fs_op' may be used uninitialized in this function
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
index 95269952aa92..2a03d0b4e213 100644
--- a/tools/hv/hv_vss_daemon.c
+++ b/tools/hv/hv_vss_daemon.c
@@ -51,7 +51,7 @@ static int vss_operate(int operation)
 	FILE *file;
 	char *p;
 	char *x;
-	int error;
+	int error = 0;
 
 	switch (operation) {
 	case VSS_OP_FREEZE:
@@ -60,11 +60,13 @@ static int vss_operate(int operation)
 	case VSS_OP_THAW:
 		fs_op = "-u ";
 		break;
+	default:
+		return -1;
 	}
 
-	file = popen("mount | awk '/^\/dev\// { print $3}'", "r");
+	file = popen("mount | awk '/^\\/dev\\// { print $3}'", "r");
 	if (file == NULL)
-		return;
+		return -1;
 
 	while ((p = fgets(buf, sizeof(buf), file)) != NULL) {
 		x = strchr(p, '\n');
@@ -128,7 +130,9 @@ int main(void)
 	int	op;
 	struct hv_vss_msg *vss_msg;
 
-	daemon(1, 0);
+	if (daemon(1, 0))
+		return 1;
+
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
 

commit 96dd86fa588169b745a71aedf2070e80f4943623
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Mar 15 12:30:06 2013 -0700

    Drivers: hv: Add a new driver to support host initiated backup
    
    This driver supports host initiated backup of the guest. On Windows guests,
    the host can generate application consistent backups using the Windows VSS
    framework. On Linux, we ensure that the backup will be file system consistent.
    This driver allows the host to initiate a  "Freeze" operation on all the mounted
    file systems in the guest. Once the mounted file systems in the guest are frozen,
    the host snapshots the guest's file systems. Once this is done, the guest's file
    systems are "thawed".
    
    This driver has a user-level component (daemon) that invokes the appropriate
    operation on all the mounted file systems in response to the requests from
    the host. The duration for which the guest is frozen is very short - a few seconds.
    During this interval, the diff disk is comitted.
    
    In this version of the patch I have addressed the feedback from Olaf Herring.
    Also, some of the connector related issues have been fixed.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/hv/hv_vss_daemon.c b/tools/hv/hv_vss_daemon.c
new file mode 100644
index 000000000000..95269952aa92
--- /dev/null
+++ b/tools/hv/hv_vss_daemon.c
@@ -0,0 +1,220 @@
+/*
+ * An implementation of the host initiated guest snapshot for Hyper-V.
+ *
+ *
+ * Copyright (C) 2013, Microsoft, Inc.
+ * Author : K. Y. Srinivasan <kys@microsoft.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ */
+
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <linux/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <linux/connector.h>
+#include <linux/hyperv.h>
+#include <linux/netlink.h>
+#include <syslog.h>
+
+static char vss_recv_buffer[4096];
+static char vss_send_buffer[4096];
+static struct sockaddr_nl addr;
+
+#ifndef SOL_NETLINK
+#define SOL_NETLINK 270
+#endif
+
+
+static int vss_operate(int operation)
+{
+	char *fs_op;
+	char cmd[512];
+	char buf[512];
+	FILE *file;
+	char *p;
+	char *x;
+	int error;
+
+	switch (operation) {
+	case VSS_OP_FREEZE:
+		fs_op = "-f ";
+		break;
+	case VSS_OP_THAW:
+		fs_op = "-u ";
+		break;
+	}
+
+	file = popen("mount | awk '/^\/dev\// { print $3}'", "r");
+	if (file == NULL)
+		return;
+
+	while ((p = fgets(buf, sizeof(buf), file)) != NULL) {
+		x = strchr(p, '\n');
+		*x = '\0';
+		if (!strncmp(p, "/", sizeof("/")))
+			continue;
+
+		sprintf(cmd, "%s %s %s", "fsfreeze ", fs_op, p);
+		syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
+		error = system(cmd);
+	}
+	pclose(file);
+
+	sprintf(cmd, "%s %s %s", "fsfreeze ", fs_op, "/");
+	syslog(LOG_INFO, "VSS cmd is %s\n", cmd);
+	error = system(cmd);
+
+	return error;
+}
+
+static int netlink_send(int fd, struct cn_msg *msg)
+{
+	struct nlmsghdr *nlh;
+	unsigned int size;
+	struct msghdr message;
+	char buffer[64];
+	struct iovec iov[2];
+
+	size = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);
+
+	nlh = (struct nlmsghdr *)buffer;
+	nlh->nlmsg_seq = 0;
+	nlh->nlmsg_pid = getpid();
+	nlh->nlmsg_type = NLMSG_DONE;
+	nlh->nlmsg_len = NLMSG_LENGTH(size - sizeof(*nlh));
+	nlh->nlmsg_flags = 0;
+
+	iov[0].iov_base = nlh;
+	iov[0].iov_len = sizeof(*nlh);
+
+	iov[1].iov_base = msg;
+	iov[1].iov_len = size;
+
+	memset(&message, 0, sizeof(message));
+	message.msg_name = &addr;
+	message.msg_namelen = sizeof(addr);
+	message.msg_iov = iov;
+	message.msg_iovlen = 2;
+
+	return sendmsg(fd, &message, 0);
+}
+
+int main(void)
+{
+	int fd, len, nl_group;
+	int error;
+	struct cn_msg *message;
+	struct pollfd pfd;
+	struct nlmsghdr *incoming_msg;
+	struct cn_msg	*incoming_cn_msg;
+	int	op;
+	struct hv_vss_msg *vss_msg;
+
+	daemon(1, 0);
+	openlog("Hyper-V VSS", 0, LOG_USER);
+	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
+
+	fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
+	if (fd < 0) {
+		syslog(LOG_ERR, "netlink socket creation failed; error:%d", fd);
+		exit(EXIT_FAILURE);
+	}
+	addr.nl_family = AF_NETLINK;
+	addr.nl_pad = 0;
+	addr.nl_pid = 0;
+	addr.nl_groups = 0;
+
+
+	error = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
+	if (error < 0) {
+		syslog(LOG_ERR, "bind failed; error:%d", error);
+		close(fd);
+		exit(EXIT_FAILURE);
+	}
+	nl_group = CN_VSS_IDX;
+	setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group));
+	/*
+	 * Register ourselves with the kernel.
+	 */
+	message = (struct cn_msg *)vss_send_buffer;
+	message->id.idx = CN_VSS_IDX;
+	message->id.val = CN_VSS_VAL;
+	message->ack = 0;
+	vss_msg = (struct hv_vss_msg *)message->data;
+	vss_msg->vss_hdr.operation = VSS_OP_REGISTER;
+
+	message->len = sizeof(struct hv_vss_msg);
+
+	len = netlink_send(fd, message);
+	if (len < 0) {
+		syslog(LOG_ERR, "netlink_send failed; error:%d", len);
+		close(fd);
+		exit(EXIT_FAILURE);
+	}
+
+	pfd.fd = fd;
+
+	while (1) {
+		struct sockaddr *addr_p = (struct sockaddr *) &addr;
+		socklen_t addr_l = sizeof(addr);
+		pfd.events = POLLIN;
+		pfd.revents = 0;
+		poll(&pfd, 1, -1);
+
+		len = recvfrom(fd, vss_recv_buffer, sizeof(vss_recv_buffer), 0,
+				addr_p, &addr_l);
+
+		if (len < 0 || addr.nl_pid) {
+			syslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",
+					addr.nl_pid, errno, strerror(errno));
+			close(fd);
+			return -1;
+		}
+
+		incoming_msg = (struct nlmsghdr *)vss_recv_buffer;
+
+		if (incoming_msg->nlmsg_type != NLMSG_DONE)
+			continue;
+
+		incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);
+		vss_msg = (struct hv_vss_msg *)incoming_cn_msg->data;
+		op = vss_msg->vss_hdr.operation;
+		error =  HV_S_OK;
+
+		switch (op) {
+		case VSS_OP_FREEZE:
+		case VSS_OP_THAW:
+			error = vss_operate(op);
+			if (error)
+				error = HV_E_FAIL;
+			break;
+		default:
+			syslog(LOG_ERR, "Illegal op:%d\n", op);
+		}
+		vss_msg->error = error;
+		len = netlink_send(fd, incoming_cn_msg);
+		if (len < 0) {
+			syslog(LOG_ERR, "net_link send failed; error:%d", len);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+}
