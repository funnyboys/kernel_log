commit 53df2b93441289848f5c2e76d19d1569816b2b9d
Author: Ian Rogers <irogers@google.com>
Date:   Fri May 1 15:13:14 2020 -0700

    libsymbols kallsyms: Parse using io api
    
    'perf record' will call kallsyms__parse 4 times during startup and
    process megabytes of data. This changes kallsyms__parse to use the io
    library rather than fgets to improve performance of the user code by
    over 8%.
    
    Before:
    
      Running 'internals/kallsyms-parse' benchmark:
      Average kallsyms__parse took: 103.988 ms (+- 0.203 ms)
    
    After:
    
      Running 'internals/kallsyms-parse' benchmark:
      Average kallsyms__parse took: 95.571 ms (+- 0.006 ms)
    
    For a workload like:
    
      $ perf record /bin/true
      Run under 'perf record -e cycles:u -g' the time goes from:
      Before
      30.10%     1.67%  perf     perf                [.] kallsyms__parse
      After
      25.55%    20.04%  perf     perf                [.] kallsyms__parse
    
    So a little under 5% of the start-up time is removed. A lot of what
    remains is on the kernel side, but caching kallsyms within perf would at
    least impact memory footprint.
    
    Committer notes:
    
    The internal/kallsyms-parse bench is run using:
    
      [root@five ~]# perf bench internals kallsyms-parse
      # Running 'internals/kallsyms-parse' benchmark:
        Average kallsyms__parse took: 80.381 ms (+- 0.115 ms)
      [root@five ~]#
    
    And this pre-existing test uses these routines to parse kallsyms and
    then compare with the info obtained from the matching ELF symtab:
    
      [root@five ~]# perf test vmlinux
       1: vmlinux symtab matches kallsyms                       : Ok
      [root@five ~]#
    
    Also we can't remove hex2u64() in this patch as this breaks the build:
    
      /usr/bin/ld: /tmp/build/perf/perf-in.o: in function `modules__parse':
      /home/acme/git/perf/tools/perf/util/symbol.c:607: undefined reference to `hex2u64'
      /usr/bin/ld: /home/acme/git/perf/tools/perf/util/symbol.c:607: undefined reference to `hex2u64'
      /usr/bin/ld: /tmp/build/perf/perf-in.o: in function `dso__load_perf_map':
      /home/acme/git/perf/tools/perf/util/symbol.c:1477: undefined reference to `hex2u64'
      /usr/bin/ld: /home/acme/git/perf/tools/perf/util/symbol.c:1483: undefined reference to `hex2u64'
      collect2: error: ld returned 1 exit status
    
    Leave it there, move it in the next patch.
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200501221315.54715-3-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/api/io.h b/tools/lib/api/io.h
index b7e55b5f8a4a..777c20f6b604 100644
--- a/tools/lib/api/io.h
+++ b/tools/lib/api/io.h
@@ -7,6 +7,9 @@
 #ifndef __API_IO__
 #define __API_IO__
 
+#include <stdlib.h>
+#include <unistd.h>
+
 struct io {
 	/* File descriptor being read/ */
 	int fd;

commit e95770af4c4a280fab2080529d30452a7628d45d
Author: Ian Rogers <irogers@google.com>
Date:   Tue Apr 14 22:40:49 2020 -0700

    tools api: Add a lightweight buffered reading api
    
    The synthesize benchmark shows the majority of execution time going to
    fgets and sscanf, necessary to parse /proc/pid/maps. Add a new buffered
    reading library that will be used to replace these calls in a follow-up
    CL. Add tests for the library to perf test.
    
    Committer tests:
    
      $ perf test api
      63: Test api io                                           : Ok
      $
    
    Signed-off-by: Ian Rogers <irogers@google.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrey Zhizhikin <andrey.z@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lore.kernel.org/lkml/20200415054050.31645-3-irogers@google.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/api/io.h b/tools/lib/api/io.h
new file mode 100644
index 000000000000..b7e55b5f8a4a
--- /dev/null
+++ b/tools/lib/api/io.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Lightweight buffered reading library.
+ *
+ * Copyright 2019 Google LLC.
+ */
+#ifndef __API_IO__
+#define __API_IO__
+
+struct io {
+	/* File descriptor being read/ */
+	int fd;
+	/* Size of the read buffer. */
+	unsigned int buf_len;
+	/* Pointer to storage for buffering read. */
+	char *buf;
+	/* End of the storage. */
+	char *end;
+	/* Currently accessed data pointer. */
+	char *data;
+	/* Set true on when the end of file on read error. */
+	bool eof;
+};
+
+static inline void io__init(struct io *io, int fd,
+			    char *buf, unsigned int buf_len)
+{
+	io->fd = fd;
+	io->buf_len = buf_len;
+	io->buf = buf;
+	io->end = buf;
+	io->data = buf;
+	io->eof = false;
+}
+
+/* Reads one character from the "io" file with similar semantics to fgetc. */
+static inline int io__get_char(struct io *io)
+{
+	char *ptr = io->data;
+
+	if (io->eof)
+		return -1;
+
+	if (ptr == io->end) {
+		ssize_t n = read(io->fd, io->buf, io->buf_len);
+
+		if (n <= 0) {
+			io->eof = true;
+			return -1;
+		}
+		ptr = &io->buf[0];
+		io->end = &io->buf[n];
+	}
+	io->data = ptr + 1;
+	return *ptr;
+}
+
+/* Read a hexadecimal value with no 0x prefix into the out argument hex. If the
+ * first character isn't hexadecimal returns -2, io->eof returns -1, otherwise
+ * returns the character after the hexadecimal value which may be -1 for eof.
+ * If the read value is larger than a u64 the high-order bits will be dropped.
+ */
+static inline int io__get_hex(struct io *io, __u64 *hex)
+{
+	bool first_read = true;
+
+	*hex = 0;
+	while (true) {
+		int ch = io__get_char(io);
+
+		if (ch < 0)
+			return ch;
+		if (ch >= '0' && ch <= '9')
+			*hex = (*hex << 4) | (ch - '0');
+		else if (ch >= 'a' && ch <= 'f')
+			*hex = (*hex << 4) | (ch - 'a' + 10);
+		else if (ch >= 'A' && ch <= 'F')
+			*hex = (*hex << 4) | (ch - 'A' + 10);
+		else if (first_read)
+			return -2;
+		else
+			return ch;
+		first_read = false;
+	}
+}
+
+/* Read a positive decimal value with out argument dec. If the first character
+ * isn't a decimal returns -2, io->eof returns -1, otherwise returns the
+ * character after the decimal value which may be -1 for eof. If the read value
+ * is larger than a u64 the high-order bits will be dropped.
+ */
+static inline int io__get_dec(struct io *io, __u64 *dec)
+{
+	bool first_read = true;
+
+	*dec = 0;
+	while (true) {
+		int ch = io__get_char(io);
+
+		if (ch < 0)
+			return ch;
+		if (ch >= '0' && ch <= '9')
+			*dec = (*dec * 10) + ch - '0';
+		else if (first_read)
+			return -2;
+		else
+			return ch;
+		first_read = false;
+	}
+}
+
+#endif /* __API_IO__ */
