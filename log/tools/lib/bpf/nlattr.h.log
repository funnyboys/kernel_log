commit 1bc38b8ff6cc54b1cd925525c0a9ffa7eef4d23b
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Fri Oct 5 16:40:00 2018 -0700

    libbpf: relicense libbpf as LGPL-2.1 OR BSD-2-Clause
    
    libbpf is maturing as a library and gaining features that no other bpf libraries support
    (BPF Type Format, bpf to bpf calls, etc)
    Many Apache2 licensed projects (like bcc, bpftrace, gobpf, cilium, etc)
    would like to use libbpf, but cannot do this yet, since Apache Foundation explicitly
    states that LGPL is incompatible with Apache2.
    Hence let's relicense libbpf as dual license LGPL-2.1 or BSD-2-Clause,
    since BSD-2 is compatible with Apache2.
    Dual LGPL or Apache2 is invalid combination.
    Fix license mistake in Makefile as well.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@kernel.org>
    Acked-by: Björn Töpel <bjorn.topel@intel.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: David Beckett <david.beckett@netronome.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Joe Stringer <joe@ovn.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Roman Gushchin <guro@fb.com>
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/nlattr.h b/tools/lib/bpf/nlattr.h
index 7198584a3040..6cc3ac91690f 100644
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@ -1,13 +1,8 @@
-/* SPDX-License-Identifier: LGPL-2.1 */
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
 
 /*
  * NETLINK      Netlink attributes
  *
- *	This library is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation version 2.1
- *	of the License.
- *
  * Copyright (c) 2003-2013 Thomas Graf <tgraf@suug.ch>
  */
 

commit eff8190880c005e754d7d1bd315fc53a3ae9f876
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:42 2018 -0700

    libbpf: Make include guards consistent
    
    Rename include guards to have consistent names "__LIBBPF_<header_name>".
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/nlattr.h b/tools/lib/bpf/nlattr.h
index 755a3312c87f..7198584a3040 100644
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@ -11,8 +11,8 @@
  * Copyright (c) 2003-2013 Thomas Graf <tgraf@suug.ch>
  */
 
-#ifndef __NLATTR_H
-#define __NLATTR_H
+#ifndef __LIBBPF_NLATTR_H
+#define __LIBBPF_NLATTR_H
 
 #include <stdint.h>
 #include <linux/netlink.h>
@@ -108,4 +108,4 @@ int libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,
 
 int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);
 
-#endif /* __NLATTR_H */
+#endif /* __LIBBPF_NLATTR_H */

commit f04bc8a436e1b32f842a631ff889954bdf56b720
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:40 2018 -0700

    libbpf: Consistent prefixes for interfaces in nlattr.h.
    
    libbpf is used more and more outside kernel tree. That means the library
    should follow good practices in library design and implementation to
    play well with third party code that uses it.
    
    One of such practices is to have a common prefix (or a few) for every
    interface, function or data structure, library provides. I helps to
    avoid name conflicts with other libraries and keeps API consistent.
    
    Inconsistent names in libbpf already cause problems in real life. E.g.
    an application can't use both libbpf and libnl due to conflicting
    symbols.
    
    Having common prefix will help to fix current and avoid future problems.
    
    libbpf already uses the following prefixes for its interfaces:
    * bpf_ for bpf system call wrappers, program/map/elf-object
      abstractions and a few other things;
    * btf_ for BTF related API;
    * libbpf_ for everything else.
    
    The patch adds libbpf_ prefix to interfaces in nlattr.h that use none of
    mentioned above prefixes and doesn't fit well into the first two
    categories.
    
    Since affected part of API is used in bpftool, the patch applies
    corresponding change to bpftool as well. Having it in a separate patch
    will cause a state of tree where bpftool is broken what may not be a
    good idea.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/nlattr.h b/tools/lib/bpf/nlattr.h
index a6e2396bce7c..755a3312c87f 100644
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@ -23,19 +23,19 @@
  * Standard attribute types to specify validation policy
  */
 enum {
-	NLA_UNSPEC,	/**< Unspecified type, binary data chunk */
-	NLA_U8,		/**< 8 bit integer */
-	NLA_U16,	/**< 16 bit integer */
-	NLA_U32,	/**< 32 bit integer */
-	NLA_U64,	/**< 64 bit integer */
-	NLA_STRING,	/**< NUL terminated character string */
-	NLA_FLAG,	/**< Flag */
-	NLA_MSECS,	/**< Micro seconds (64bit) */
-	NLA_NESTED,	/**< Nested attributes */
-	__NLA_TYPE_MAX,
+	LIBBPF_NLA_UNSPEC,	/**< Unspecified type, binary data chunk */
+	LIBBPF_NLA_U8,		/**< 8 bit integer */
+	LIBBPF_NLA_U16,		/**< 16 bit integer */
+	LIBBPF_NLA_U32,		/**< 32 bit integer */
+	LIBBPF_NLA_U64,		/**< 64 bit integer */
+	LIBBPF_NLA_STRING,	/**< NUL terminated character string */
+	LIBBPF_NLA_FLAG,	/**< Flag */
+	LIBBPF_NLA_MSECS,	/**< Micro seconds (64bit) */
+	LIBBPF_NLA_NESTED,	/**< Nested attributes */
+	__LIBBPF_NLA_TYPE_MAX,
 };
 
-#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)
+#define LIBBPF_NLA_TYPE_MAX (__LIBBPF_NLA_TYPE_MAX - 1)
 
 /**
  * @ingroup attr
@@ -43,8 +43,8 @@ enum {
  *
  * See section @core_doc{core_attr_parse,Attribute Parsing} for more details.
  */
-struct nla_policy {
-	/** Type of attribute or NLA_UNSPEC */
+struct libbpf_nla_policy {
+	/** Type of attribute or LIBBPF_NLA_UNSPEC */
 	uint16_t	type;
 
 	/** Minimal length of payload required */
@@ -62,49 +62,50 @@ struct nla_policy {
  * @arg len	length of attribute stream
  * @arg rem	initialized to len, holds bytes currently remaining in stream
  */
-#define nla_for_each_attr(pos, head, len, rem) \
+#define libbpf_nla_for_each_attr(pos, head, len, rem) \
 	for (pos = head, rem = len; \
 	     nla_ok(pos, rem); \
 	     pos = nla_next(pos, &(rem)))
 
 /**
- * nla_data - head of payload
+ * libbpf_nla_data - head of payload
  * @nla: netlink attribute
  */
-static inline void *nla_data(const struct nlattr *nla)
+static inline void *libbpf_nla_data(const struct nlattr *nla)
 {
 	return (char *) nla + NLA_HDRLEN;
 }
 
-static inline uint8_t nla_getattr_u8(const struct nlattr *nla)
+static inline uint8_t libbpf_nla_getattr_u8(const struct nlattr *nla)
 {
-	return *(uint8_t *)nla_data(nla);
+	return *(uint8_t *)libbpf_nla_data(nla);
 }
 
-static inline uint32_t nla_getattr_u32(const struct nlattr *nla)
+static inline uint32_t libbpf_nla_getattr_u32(const struct nlattr *nla)
 {
-	return *(uint32_t *)nla_data(nla);
+	return *(uint32_t *)libbpf_nla_data(nla);
 }
 
-static inline const char *nla_getattr_str(const struct nlattr *nla)
+static inline const char *libbpf_nla_getattr_str(const struct nlattr *nla)
 {
-	return (const char *)nla_data(nla);
+	return (const char *)libbpf_nla_data(nla);
 }
 
 /**
- * nla_len - length of payload
+ * libbpf_nla_len - length of payload
  * @nla: netlink attribute
  */
-static inline int nla_len(const struct nlattr *nla)
+static inline int libbpf_nla_len(const struct nlattr *nla)
 {
 	return nla->nla_len - NLA_HDRLEN;
 }
 
-int nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head, int len,
-	      struct nla_policy *policy);
-int nla_parse_nested(struct nlattr *tb[], int maxtype, struct nlattr *nla,
-		     struct nla_policy *policy);
+int libbpf_nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head,
+		     int len, struct libbpf_nla_policy *policy);
+int libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,
+			    struct nlattr *nla,
+			    struct libbpf_nla_policy *policy);
 
-int nla_dump_errormsg(struct nlmsghdr *nlh);
+int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);
 
 #endif /* __NLATTR_H */

commit 36f1678d9e0b5d2e0236046d9659e0348b4719a8
Author: Yonghong Song <yhs@fb.com>
Date:   Wed Sep 5 16:58:05 2018 -0700

    tools/bpf: add more netlink functionalities in lib/bpf
    
    This patch added a few netlink attribute parsing functions
    and the netlink API functions to query networking links, tc classes,
    tc qdiscs and tc filters. For example, the following API is
    to get networking links:
      int nl_get_link(int sock, unsigned int nl_pid,
                      dump_nlmsg_t dump_link_nlmsg,
                      void *cookie);
    
    Note that when the API is called, the user also provided a
    callback function with the following signature:
      int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
    
    The "cookie" is the parameter the user passed to the API and will
    be available for the callback function.
    The "msg" is the information about the result, e.g., ifinfomsg or
    tcmsg. The "tb" is the parsed netlink attributes.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/nlattr.h b/tools/lib/bpf/nlattr.h
index 931a71f68f93..a6e2396bce7c 100644
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@ -67,6 +67,44 @@ struct nla_policy {
 	     nla_ok(pos, rem); \
 	     pos = nla_next(pos, &(rem)))
 
+/**
+ * nla_data - head of payload
+ * @nla: netlink attribute
+ */
+static inline void *nla_data(const struct nlattr *nla)
+{
+	return (char *) nla + NLA_HDRLEN;
+}
+
+static inline uint8_t nla_getattr_u8(const struct nlattr *nla)
+{
+	return *(uint8_t *)nla_data(nla);
+}
+
+static inline uint32_t nla_getattr_u32(const struct nlattr *nla)
+{
+	return *(uint32_t *)nla_data(nla);
+}
+
+static inline const char *nla_getattr_str(const struct nlattr *nla)
+{
+	return (const char *)nla_data(nla);
+}
+
+/**
+ * nla_len - length of payload
+ * @nla: netlink attribute
+ */
+static inline int nla_len(const struct nlattr *nla)
+{
+	return nla->nla_len - NLA_HDRLEN;
+}
+
+int nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head, int len,
+	      struct nla_policy *policy);
+int nla_parse_nested(struct nlattr *tb[], int maxtype, struct nlattr *nla,
+		     struct nla_policy *policy);
+
 int nla_dump_errormsg(struct nlmsghdr *nlh);
 
 #endif /* __NLATTR_H */

commit bbf48c18ee0cd18b53712aa09aefa29b64b3976e
Author: Eric Leblond <eric@regit.org>
Date:   Tue Jan 30 21:55:02 2018 +0100

    libbpf: add error reporting in XDP
    
    Parse netlink ext attribute to get the error message returned by
    the card. Code is partially take from libnl.
    
    We add netlink.h to the uapi include of tools. And we need to
    avoid include of userspace netlink header to have a successful
    build of sample so nlattr.h has a define to avoid
    the inclusion. Using a direct define could have been an issue
    as NLMSGERR_ATTR_MAX can change in the future.
    
    We also define SOL_NETLINK if not defined to avoid to have to
    copy socket.h for a fixed value.
    
    Signed-off-by: Eric Leblond <eric@regit.org>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/nlattr.h b/tools/lib/bpf/nlattr.h
new file mode 100644
index 000000000000..931a71f68f93
--- /dev/null
+++ b/tools/lib/bpf/nlattr.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: LGPL-2.1 */
+
+/*
+ * NETLINK      Netlink attributes
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2003-2013 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NLATTR_H
+#define __NLATTR_H
+
+#include <stdint.h>
+#include <linux/netlink.h>
+/* avoid multiple definition of netlink features */
+#define __LINUX_NETLINK_H
+
+/**
+ * Standard attribute types to specify validation policy
+ */
+enum {
+	NLA_UNSPEC,	/**< Unspecified type, binary data chunk */
+	NLA_U8,		/**< 8 bit integer */
+	NLA_U16,	/**< 16 bit integer */
+	NLA_U32,	/**< 32 bit integer */
+	NLA_U64,	/**< 64 bit integer */
+	NLA_STRING,	/**< NUL terminated character string */
+	NLA_FLAG,	/**< Flag */
+	NLA_MSECS,	/**< Micro seconds (64bit) */
+	NLA_NESTED,	/**< Nested attributes */
+	__NLA_TYPE_MAX,
+};
+
+#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)
+
+/**
+ * @ingroup attr
+ * Attribute validation policy.
+ *
+ * See section @core_doc{core_attr_parse,Attribute Parsing} for more details.
+ */
+struct nla_policy {
+	/** Type of attribute or NLA_UNSPEC */
+	uint16_t	type;
+
+	/** Minimal length of payload required */
+	uint16_t	minlen;
+
+	/** Maximal length of payload allowed */
+	uint16_t	maxlen;
+};
+
+/**
+ * @ingroup attr
+ * Iterate over a stream of attributes
+ * @arg pos	loop counter, set to current attribute
+ * @arg head	head of attribute stream
+ * @arg len	length of attribute stream
+ * @arg rem	initialized to len, holds bytes currently remaining in stream
+ */
+#define nla_for_each_attr(pos, head, len, rem) \
+	for (pos = head, rem = len; \
+	     nla_ok(pos, rem); \
+	     pos = nla_next(pos, &(rem)))
+
+int nla_dump_errormsg(struct nlmsghdr *nlh);
+
+#endif /* __NLATTR_H */
