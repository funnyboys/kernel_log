commit d60d81acc2c180e33244857e35ef60072573b000
Author: Jakub Sitnicki <jakub@cloudflare.com>
Date:   Sun May 31 10:28:40 2020 +0200

    libbpf: Add support for bpf_link-based netns attachment
    
    Add bpf_program__attach_nets(), which uses LINK_CREATE subcommand to create
    an FD-based kernel bpf_link, for attach types tied to network namespace,
    that is BPF_FLOW_DISSECTOR for the moment.
    
    Signed-off-by: Jakub Sitnicki <jakub@cloudflare.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200531082846.2117903-7-jakub@cloudflare.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8528a02d5af8..334437af3014 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -253,6 +253,8 @@ LIBBPF_API struct bpf_link *
 bpf_program__attach_lsm(struct bpf_program *prog);
 LIBBPF_API struct bpf_link *
 bpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_netns(struct bpf_program *prog, int netns_fd);
 
 struct bpf_map;
 

commit bf99c936f9478a05d51e9f101f90de70bee9a89c
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri May 29 00:54:21 2020 -0700

    libbpf: Add BPF ring buffer support
    
    Declaring and instantiating BPF ring buffer doesn't require any changes to
    libbpf, as it's just another type of maps. So using existing BTF-defined maps
    syntax with __uint(type, BPF_MAP_TYPE_RINGBUF) and __uint(max_elements,
    <size-of-ring-buf>) is all that's necessary to create and use BPF ring buffer.
    
    This patch adds BPF ring buffer consumer to libbpf. It is very similar to
    perf_buffer implementation in terms of API, but also attempts to fix some
    minor problems and inconveniences with existing perf_buffer API.
    
    ring_buffer support both single ring buffer use case (with just using
    ring_buffer__new()), as well as allows to add more ring buffers, each with its
    own callback and context. This allows to efficiently poll and consume
    multiple, potentially completely independent, ring buffers, using single
    epoll instance.
    
    The latter is actually a problem in practice for applications
    that are using multiple sets of perf buffers. They have to create multiple
    instances for struct perf_buffer and poll them independently or in a loop,
    each approach having its own problems (e.g., inability to use a common poll
    timeout). struct ring_buffer eliminates this problem by aggregating many
    independent ring buffer instances under the single "ring buffer manager".
    
    Second, perf_buffer's callback can't return error, so applications that need
    to stop polling due to error in data or data signalling the end, have to use
    extra mechanisms to signal that polling has to stop. ring_buffer's callback
    can return error, which will be passed through back to user code and can be
    acted upon appropariately.
    
    Two APIs allow to consume ring buffer data:
      - ring_buffer__poll(), which will wait for data availability notification
        and will consume data only from reported ring buffer(s); this API allows
        to efficiently use resources by reading data only when it becomes
        available;
      - ring_buffer__consume(), will attempt to read new records regardless of
        data availablity notification sub-system. This API is useful for cases
        when lowest latency is required, in expense of burning CPU resources.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20200529075424.3139988-3-andriin@fb.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1e2e399a5f2c..8528a02d5af8 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -478,6 +478,27 @@ LIBBPF_API int bpf_get_link_xdp_id(int ifindex, __u32 *prog_id, __u32 flags);
 LIBBPF_API int bpf_get_link_xdp_info(int ifindex, struct xdp_link_info *info,
 				     size_t info_size, __u32 flags);
 
+/* Ring buffer APIs */
+struct ring_buffer;
+
+typedef int (*ring_buffer_sample_fn)(void *ctx, void *data, size_t size);
+
+struct ring_buffer_opts {
+	size_t sz; /* size of this struct, for forward/backward compatiblity */
+};
+
+#define ring_buffer_opts__last_field sz
+
+LIBBPF_API struct ring_buffer *
+ring_buffer__new(int map_fd, ring_buffer_sample_fn sample_cb, void *ctx,
+		 const struct ring_buffer_opts *opts);
+LIBBPF_API void ring_buffer__free(struct ring_buffer *rb);
+LIBBPF_API int ring_buffer__add(struct ring_buffer *rb, int map_fd,
+				ring_buffer_sample_fn sample_cb, void *ctx);
+LIBBPF_API int ring_buffer__poll(struct ring_buffer *rb, int timeout_ms);
+LIBBPF_API int ring_buffer__consume(struct ring_buffer *rb);
+
+/* Perf buffer APIs */
 struct perf_buffer;
 
 typedef void (*perf_buffer_sample_fn)(void *ctx, int cpu,

commit 272d51af32890632134845ddf35318c11da20c7b
Author: Eelco Chaudron <echaudro@redhat.com>
Date:   Tue May 26 11:21:42 2020 +0200

    libbpf: Add API to consume the perf ring buffer content
    
    This new API, perf_buffer__consume, can be used as follows:
    
    - When you have a perf ring where wakeup_events is higher than 1,
      and you have remaining data in the rings you would like to pull
      out on exit (or maybe based on a timeout).
    
    - For low latency cases where you burn a CPU that constantly polls
      the queues.
    
    Signed-off-by: Eelco Chaudron <echaudro@redhat.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/159048487929.89441.7465713173442594608.stgit@ebuild
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8ea69558f0a8..1e2e399a5f2c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -533,6 +533,7 @@ perf_buffer__new_raw(int map_fd, size_t page_cnt,
 
 LIBBPF_API void perf_buffer__free(struct perf_buffer *pb);
 LIBBPF_API int perf_buffer__poll(struct perf_buffer *pb, int timeout_ms);
+LIBBPF_API int perf_buffer__consume(struct perf_buffer *pb);
 
 typedef enum bpf_perf_event_ret
 	(*bpf_perf_event_print_t)(struct perf_event_header *hdr,

commit c09add2fbc5aece00a5b54a48ce39fd4e3284d87
Author: Yonghong Song <yhs@fb.com>
Date:   Sat May 9 10:59:17 2020 -0700

    tools/libbpf: Add bpf_iter support
    
    Two new libbpf APIs are added to support bpf_iter:
      - bpf_program__attach_iter
        Given a bpf program and additional parameters, which is
        none now, returns a bpf_link.
      - bpf_iter_create
        syscall level API to create a bpf iterator.
    
    The macro BPF_SEQ_PRINTF are also introduced. The format
    looks like:
      BPF_SEQ_PRINTF(seq, "task id %d\n", pid);
    
    This macro can help bpf program writers with
    nicer bpf_seq_printf syntax similar to the kernel one.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20200509175917.2476936-1-yhs@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f1dacecb1619..8ea69558f0a8 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -258,6 +258,15 @@ struct bpf_map;
 
 LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
 
+struct bpf_iter_attach_opts {
+	size_t sz; /* size of this struct for forward/backward compatibility */
+};
+#define bpf_iter_attach_opts__last_field sz
+
+LIBBPF_API struct bpf_link *
+bpf_program__attach_iter(struct bpf_program *prog,
+			 const struct bpf_iter_attach_opts *opts);
+
 struct bpf_insn;
 
 /*

commit 49b452c382da2c2d1ccee1265cbb92da905c82f7
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Tue Apr 14 16:50:24 2020 +0200

    libbpf: Fix type of old_fd in bpf_xdp_set_link_opts
    
    The 'old_fd' parameter used for atomic replacement of XDP programs is
    supposed to be an FD, but was left as a u32 from an earlier iteration of
    the patch that added it. It was converted to an int when read, so things
    worked correctly even with negative values, but better change the
    definition to correctly reflect the intention.
    
    Fixes: bd5ca3ef93cd ("libbpf: Add function to set link XDP fd while specifying old program")
    Reported-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: David Ahern <dsahern@gmail.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20200414145025.182163-1-toke@redhat.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 44df1d3e7287..f1dacecb1619 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -458,7 +458,7 @@ struct xdp_link_info {
 
 struct bpf_xdp_set_link_opts {
 	size_t sz;
-	__u32 old_fd;
+	int old_fd;
 };
 #define bpf_xdp_set_link_opts__last_field old_fd
 

commit cc4f864bb118e0ae7bf9f4e3418eaeb083aa34f2
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Sun Mar 29 20:00:00 2020 -0700

    libbpf: Add support for bpf_link-based cgroup attachment
    
    Add bpf_program__attach_cgroup(), which uses BPF_LINK_CREATE subcommand to
    create an FD-based kernel bpf_link. Also add low-level bpf_link_create() API.
    
    If expected_attach_type is not specified explicitly with
    bpf_program__set_expected_attach_type(), libbpf will try to determine proper
    attach type from BPF program's section definition.
    
    Also add support for bpf_link's underlying BPF program replacement:
      - unconditional through high-level bpf_link__update_program() API;
      - cmpxchg-like with specifying expected current BPF program through
        low-level bpf_link_update() API.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200330030001.2312810-4-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 55348724c355..44df1d3e7287 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -224,6 +224,8 @@ LIBBPF_API int bpf_link__fd(const struct bpf_link *link);
 LIBBPF_API const char *bpf_link__pin_path(const struct bpf_link *link);
 LIBBPF_API int bpf_link__pin(struct bpf_link *link, const char *path);
 LIBBPF_API int bpf_link__unpin(struct bpf_link *link);
+LIBBPF_API int bpf_link__update_program(struct bpf_link *link,
+					struct bpf_program *prog);
 LIBBPF_API void bpf_link__disconnect(struct bpf_link *link);
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
@@ -245,13 +247,17 @@ bpf_program__attach_tracepoint(struct bpf_program *prog,
 LIBBPF_API struct bpf_link *
 bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
 				   const char *tp_name);
-
 LIBBPF_API struct bpf_link *
 bpf_program__attach_trace(struct bpf_program *prog);
 LIBBPF_API struct bpf_link *
 bpf_program__attach_lsm(struct bpf_program *prog);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd);
+
 struct bpf_map;
+
 LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
+
 struct bpf_insn;
 
 /*

commit 1e092a0318292637cde832868016f37e942eed24
Author: KP Singh <kpsingh@google.com>
Date:   Sun Mar 29 01:43:54 2020 +0100

    tools/libbpf: Add support for BPF_PROG_TYPE_LSM
    
    Since BPF_PROG_TYPE_LSM uses the same attaching mechanism as
    BPF_PROG_TYPE_TRACING, the common logic is refactored into a static
    function bpf_program__attach_btf_id.
    
    A new API call bpf_program__attach_lsm is still added to avoid userspace
    conflicts if this ever changes in the future.
    
    Signed-off-by: KP Singh <kpsingh@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Brendan Jackman <jackmanb@google.com>
    Reviewed-by: Florent Revest <revest@google.com>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20200329004356.27286-7-kpsingh@chromium.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 958ae71c116e..55348724c355 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -248,6 +248,8 @@ bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
 
 LIBBPF_API struct bpf_link *
 bpf_program__attach_trace(struct bpf_program *prog);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_lsm(struct bpf_program *prog);
 struct bpf_map;
 LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
 struct bpf_insn;
@@ -321,6 +323,7 @@ LIBBPF_API int bpf_program__set_socket_filter(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_tracepoint(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_raw_tracepoint(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_kprobe(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_lsm(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_sched_cls(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
@@ -347,6 +350,7 @@ LIBBPF_API bool bpf_program__is_socket_filter(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_tracepoint(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_raw_tracepoint(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_kprobe(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_lsm(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_sched_cls(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_sched_act(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);

commit e2842be53d4f31962a9992eab39391cdf637fa2e
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sun Mar 29 15:22:52 2020 +0200

    libbpf: Add setter for initial value for internal maps
    
    For internal maps (most notably the maps backing global variables), libbpf
    uses an internal mmaped area to store the data after opening the object.
    This data is subsequently copied into the kernel map when the object is
    loaded.
    
    This adds a function to set a new value for that data, which can be used to
    before it is loaded into the kernel. This is especially relevant for RODATA
    maps, since those are frozen on load.
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20200329132253.232541-1-toke@redhat.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index bf7a35a9556d..958ae71c116e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -407,6 +407,8 @@ typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 LIBBPF_API int bpf_map__set_priv(struct bpf_map *map, void *priv,
 				 bpf_map_clear_priv_t clear_priv);
 LIBBPF_API void *bpf_map__priv(const struct bpf_map *map);
+LIBBPF_API int bpf_map__set_initial_value(struct bpf_map *map,
+					  const void *data, size_t size);
 LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
 LIBBPF_API int bpf_map__resize(struct bpf_map *map, __u32 max_entries);
 LIBBPF_API bool bpf_map__is_offload_neutral(const struct bpf_map *map);

commit bd5ca3ef93cd8fb7e913f15eeb78e67a0d802274
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Wed Mar 25 18:23:28 2020 +0100

    libbpf: Add function to set link XDP fd while specifying old program
    
    This adds a new function to set the XDP fd while specifying the FD of the
    program to replace, using the newly added IFLA_XDP_EXPECTED_FD netlink
    parameter. The new function uses the opts struct mechanism to be extendable
    in the future.
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/158515700857.92963.7052131201257841700.stgit@toke.dk

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index d38d7a629417..bf7a35a9556d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -444,7 +444,15 @@ struct xdp_link_info {
 	__u8 attach_mode;
 };
 
+struct bpf_xdp_set_link_opts {
+	size_t sz;
+	__u32 old_fd;
+};
+#define bpf_xdp_set_link_opts__last_field old_fd
+
 LIBBPF_API int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
+LIBBPF_API int bpf_set_link_xdp_fd_opts(int ifindex, int fd, __u32 flags,
+					const struct bpf_xdp_set_link_opts *opts);
 LIBBPF_API int bpf_get_link_xdp_id(int ifindex, __u32 *prog_id, __u32 flags);
 LIBBPF_API int bpf_get_link_xdp_info(int ifindex, struct xdp_link_info *info,
 				     size_t info_size, __u32 flags);

commit c016b68edc7a2adf3db0f11fb649797c1f9216ea
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Mar 2 20:31:58 2020 -0800

    libbpf: Add bpf_link pinning/unpinning
    
    With bpf_link abstraction supported by kernel explicitly, add
    pinning/unpinning API for links. Also allow to create (open) bpf_link from BPF
    FS file.
    
    This API allows to have an "ephemeral" FD-based BPF links (like raw tracepoint
    or fexit/freplace attachments) surviving user process exit, by pinning them in
    a BPF FS, which is an important use case for long-running BPF programs.
    
    As part of this, expose underlying FD for bpf_link. While legacy bpf_link's
    might not have a FD associated with them (which will be expressed as
    a bpf_link with fd=-1), kernel's abstraction is based around FD-based usage,
    so match it closely. This, subsequently, allows to have a generic
    pinning/unpinning API for generalized bpf_link. For some types of bpf_links
    kernel might not support pinning, in which case bpf_link__pin() will return
    error.
    
    With FD being part of generic bpf_link, also get rid of bpf_link_fd in favor
    of using vanialla bpf_link.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200303043159.323675-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 02fc58a21a7f..d38d7a629417 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -219,6 +219,11 @@ LIBBPF_API void bpf_program__unload(struct bpf_program *prog);
 
 struct bpf_link;
 
+LIBBPF_API struct bpf_link *bpf_link__open(const char *path);
+LIBBPF_API int bpf_link__fd(const struct bpf_link *link);
+LIBBPF_API const char *bpf_link__pin_path(const struct bpf_link *link);
+LIBBPF_API int bpf_link__pin(struct bpf_link *link, const char *path);
+LIBBPF_API int bpf_link__unpin(struct bpf_link *link);
 LIBBPF_API void bpf_link__disconnect(struct bpf_link *link);
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 

commit ff26ce5cd7680ebc9c5446cda013e2087decc60f
Author: Eelco Chaudron <echaudro@redhat.com>
Date:   Thu Feb 20 13:26:35 2020 +0000

    libbpf: Add support for dynamic program attach target
    
    Currently when you want to attach a trace program to a bpf program
    the section name needs to match the tracepoint/function semantics.
    
    However the addition of the bpf_program__set_attach_target() API
    allows you to specify the tracepoint/function dynamically.
    
    The call flow would look something like this:
    
      xdp_fd = bpf_prog_get_fd_by_id(id);
      trace_obj = bpf_object__open_file("func.o", NULL);
      prog = bpf_object__find_program_by_title(trace_obj,
                                               "fentry/myfunc");
      bpf_program__set_expected_attach_type(prog, BPF_TRACE_FENTRY);
      bpf_program__set_attach_target(prog, xdp_fd,
                                     "xdpfilt_blk_all");
      bpf_object__load(trace_obj)
    
    Signed-off-by: Eelco Chaudron <echaudro@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/158220519486.127661.7964708960649051384.stgit@xdp-tutorial

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 3fe12c9d1f92..02fc58a21a7f 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -334,6 +334,10 @@ LIBBPF_API void
 bpf_program__set_expected_attach_type(struct bpf_program *prog,
 				      enum bpf_attach_type type);
 
+LIBBPF_API int
+bpf_program__set_attach_target(struct bpf_program *prog, int attach_prog_fd,
+			       const char *attach_func_name);
+
 LIBBPF_API bool bpf_program__is_socket_filter(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_tracepoint(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_raw_tracepoint(const struct bpf_program *prog);

commit d7a252708dbc950ca2064310217e8b9f85846e2f
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Thu Jan 23 21:38:37 2020 -0800

    libbpf: Improve handling of failed CO-RE relocations
    
    Previously, if libbpf failed to resolve CO-RE relocation for some
    instructions, it would either return error immediately, or, if
    .relaxed_core_relocs option was set, would replace relocatable offset/imm part
    of an instruction with a bogus value (-1). Neither approach is good, because
    there are many possible scenarios where relocation is expected to fail (e.g.,
    when some field knowingly can be missing on specific kernel versions). On the
    other hand, replacing offset with invalid one can hide programmer errors, if
    this relocation failue wasn't anticipated.
    
    This patch deprecates .relaxed_core_relocs option and changes the approach to
    always replacing instruction, for which relocation failed, with invalid BPF
    helper call instruction. For cases where this is expected, BPF program should
    already ensure that that instruction is unreachable, in which case this
    invalid instruction is going to be silently ignored. But if instruction wasn't
    guarded, BPF program will be rejected at verification step with verifier log
    pointing precisely to the place in assembly where the problem is.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20200124053837.2434679-1-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2a5e3b087002..3fe12c9d1f92 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -77,7 +77,11 @@ struct bpf_object_open_opts {
 	const char *object_name;
 	/* parse map definitions non-strictly, allowing extra attributes/data */
 	bool relaxed_maps;
-	/* process CO-RE relocations non-strictly, allowing them to fail */
+	/* DEPRECATED: handle CO-RE relocations non-strictly, allowing failures.
+	 * Value is ignored. Relocations always are processed non-strictly.
+	 * Non-relocatable instructions are replaced with invalid ones to
+	 * prevent accidental errors.
+	 * */
 	bool relaxed_core_relocs;
 	/* maps that set the 'pinning' attribute in their definition will have
 	 * their pin_path attribute set to a file in this directory, and be

commit 2db6eab18b9778d55f48c804f8efebd7097e7958
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Mon Jan 20 16:53:47 2020 -0800

    libbpf: Add support for program extensions
    
    Add minimal support for program extensions. bpf_object_open_opts() needs to be
    called with attach_prog_fd = target_prog_fd and BPF program extension needs to
    have in .c file section definition like SEC("freplace/func_to_be_replaced").
    libbpf will search for "func_to_be_replaced" in the target_prog_fd's BTF and
    will pass it in attach_btf_id to the kernel. This approach works for tests, but
    more compex use case may need to request function name (and attach_btf_id that
    kernel sees) to be more dynamic. Such API will be added in future patches.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/20200121005348.2769920-3-ast@kernel.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 01639f9a1062..2a5e3b087002 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -318,6 +318,7 @@ LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_tracing(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_struct_ops(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_extension(struct bpf_program *prog);
 
 LIBBPF_API enum bpf_prog_type bpf_program__get_type(struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
@@ -339,6 +340,7 @@ LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_perf_event(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_tracing(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_struct_ops(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_extension(const struct bpf_program *prog);
 
 /*
  * No need for __attribute__((packed)), all members of 'bpf_map_def'

commit 590a0088825016ca7ec53f1aef7e84e1211778d8
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Wed Jan 8 16:35:14 2020 -0800

    bpf: libbpf: Add STRUCT_OPS support
    
    This patch adds BPF STRUCT_OPS support to libbpf.
    
    The only sec_name convention is SEC(".struct_ops") to identify the
    struct_ops implemented in BPF,
    e.g. To implement a tcp_congestion_ops:
    
    SEC(".struct_ops")
    struct tcp_congestion_ops dctcp = {
            .init           = (void *)dctcp_init,  /* <-- a bpf_prog */
            /* ... some more func prts ... */
            .name           = "bpf_dctcp",
    };
    
    Each struct_ops is defined as a global variable under SEC(".struct_ops")
    as above.  libbpf creates a map for each variable and the variable name
    is the map's name.  Multiple struct_ops is supported under
    SEC(".struct_ops").
    
    In the bpf_object__open phase, libbpf will look for the SEC(".struct_ops")
    section and find out what is the btf-type the struct_ops is
    implementing.  Note that the btf-type here is referring to
    a type in the bpf_prog.o's btf.  A "struct bpf_map" is added
    by bpf_object__add_map() as other maps do.  It will then
    collect (through SHT_REL) where are the bpf progs that the
    func ptrs are referring to.  No btf_vmlinux is needed in
    the open phase.
    
    In the bpf_object__load phase, the map-fields, which depend
    on the btf_vmlinux, are initialized (in bpf_map__init_kern_struct_ops()).
    It will also set the prog->type, prog->attach_btf_id, and
    prog->expected_attach_type.  Thus, the prog's properties do
    not rely on its section name.
    [ Currently, the bpf_prog's btf-type ==> btf_vmlinux's btf-type matching
      process is as simple as: member-name match + btf-kind match + size match.
      If these matching conditions fail, libbpf will reject.
      The current targeting support is "struct tcp_congestion_ops" which
      most of its members are function pointers.
      The member ordering of the bpf_prog's btf-type can be different from
      the btf_vmlinux's btf-type. ]
    
    Then, all obj->maps are created as usual (in bpf_object__create_maps()).
    
    Once the maps are created and prog's properties are all set,
    the libbpf will proceed to load all the progs.
    
    bpf_map__attach_struct_ops() is added to register a struct_ops
    map to a kernel subsystem.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200109003514.3856730-1-kafai@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 26bf539f1b3c..01639f9a1062 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -239,6 +239,8 @@ bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
 
 LIBBPF_API struct bpf_link *
 bpf_program__attach_trace(struct bpf_program *prog);
+struct bpf_map;
+LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
 struct bpf_insn;
 
 /*
@@ -315,6 +317,7 @@ LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_tracing(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_struct_ops(struct bpf_program *prog);
 
 LIBBPF_API enum bpf_prog_type bpf_program__get_type(struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
@@ -335,6 +338,7 @@ LIBBPF_API bool bpf_program__is_sched_act(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_perf_event(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_tracing(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_struct_ops(const struct bpf_program *prog);
 
 /*
  * No need for __attribute__((packed)), all members of 'bpf_map_def'
@@ -354,7 +358,6 @@ struct bpf_map_def {
  * The 'struct bpf_map' in include/linux/bpf.h is internal to the kernel,
  * so no need to worry about a name clash.
  */
-struct bpf_map;
 LIBBPF_API struct bpf_map *
 bpf_object__find_map_by_name(const struct bpf_object *obj, const char *name);
 

commit 5ff051200308ab6f4c64c0fe52187bf4a1234dac
Author: Michal Rostecki <mrostecki@opensuse.org>
Date:   Wed Jan 8 17:23:52 2020 +0100

    libbpf: Add probe for large INSN limit
    
    Introduce a new probe which checks whether kernel has large maximum
    program size which was increased in the following commit:
    
    c04c0d2b968a ("bpf: increase complexity limit and maximum program size")
    
    Based on the similar check in Cilium[0], authored by Daniel Borkmann.
    
      [0] https://github.com/cilium/cilium/commit/657d0f585afd26232cfa5d4e70b6f64d2ea91596
    
    Co-authored-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Michal Rostecki <mrostecki@opensuse.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Link: https://lore.kernel.org/bpf/20200108162428.25014-2-mrostecki@opensuse.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index fe592ef48f1b..26bf539f1b3c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -521,6 +521,7 @@ LIBBPF_API bool bpf_probe_prog_type(enum bpf_prog_type prog_type,
 LIBBPF_API bool bpf_probe_map_type(enum bpf_map_type map_type, __u32 ifindex);
 LIBBPF_API bool bpf_probe_helper(enum bpf_func_id id,
 				 enum bpf_prog_type prog_type, __u32 ifindex);
+LIBBPF_API bool bpf_probe_large_insn_limit(__u32 ifindex);
 
 /*
  * Get bpf_prog_info in continuous memory

commit 8601fd422148a8f7ff5f7eaf75b6703d5166332c
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Dec 18 16:28:35 2019 -0800

    libbpf: Allow to augment system Kconfig through extra optional config
    
    Instead of all or nothing approach of overriding Kconfig file location, allow
    to extend it with extra values and override chosen subset of values though
    optional user-provided extra config, passed as a string through open options'
    .kconfig option. If same config key is present in both user-supplied config
    and Kconfig, user-supplied one wins. This allows applications to more easily
    test various conditions despite host kernel's real configuration. If all of
    BPF object's __kconfig externs are satisfied from user-supplied config, system
    Kconfig won't be read at all.
    
    Simplify selftests by not needing to create temporary Kconfig files.
    
    Suggested-by: Alexei Starovoitov <ast@fb.com>
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191219002837.3074619-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ad8c1c127933..fe592ef48f1b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -85,12 +85,12 @@ struct bpf_object_open_opts {
 	 */
 	const char *pin_root_path;
 	__u32 attach_prog_fd;
-	/* kernel config file path override (for CONFIG_ externs); can point
-	 * to either uncompressed text file or .gz file
+	/* Additional kernel config content that augments and overrides
+	 * system Kconfig for CONFIG_xxx externs.
 	 */
-	const char *kconfig_path;
+	const char *kconfig;
 };
-#define bpf_object_open_opts__last_field kconfig_path
+#define bpf_object_open_opts__last_field kconfig
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *

commit d69587062c347314a019cf6ee27f2e4b494868e1
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Dec 18 14:50:39 2019 -0800

    libbpf: Add bpf_link__disconnect() API to preserve underlying BPF resource
    
    There are cases in which BPF resource (program, map, etc) has to outlive
    userspace program that "installed" it in the system in the first place.
    When BPF program is attached, libbpf returns bpf_link object, which
    is supposed to be destroyed after no longer necessary through
    bpf_link__destroy() API. Currently, bpf_link destruction causes both automatic
    detachment and frees up any resources allocated to for bpf_link in-memory
    representation. This is inconvenient for the case described above because of
    coupling of detachment and resource freeing.
    
    This patch introduces bpf_link__disconnect() API call, which marks bpf_link as
    disconnected from its underlying BPF resouces. This means that when bpf_link
    is destroyed later, all its memory resources will be freed, but BPF resource
    itself won't be detached.
    
    This design allows to follow strict and resource-leak-free design by default,
    while giving easy and straightforward way for user code to opt for keeping BPF
    resource attached beyond lifetime of a bpf_link. For some BPF programs (i.e.,
    FS-based tracepoints, kprobes, raw tracepoint, etc), user has to make sure to
    pin BPF program to prevent kernel to automatically detach it on process exit.
    This should typically be achived by pinning BPF program (or map in some cases)
    in BPF FS.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191218225039.2668205-1-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f7084235bae9..ad8c1c127933 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -215,6 +215,7 @@ LIBBPF_API void bpf_program__unload(struct bpf_program *prog);
 
 struct bpf_link;
 
+LIBBPF_API void bpf_link__disconnect(struct bpf_link *link);
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
 LIBBPF_API struct bpf_link *

commit 3bf3c79b772f4155312c000310abab700aba2200
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Dec 17 21:25:51 2019 -0800

    libbpf: Remove BPF_EMBED_OBJ macro from libbpf.h
    
    Drop BPF_EMBED_OBJ and struct bpf_embed_data now that skeleton automatically
    embeds contents of its source object file. While BPF_EMBED_OBJ is useful
    independently of skeleton, we are currently don't have any use cases utilizing
    it, so let's remove them until/if we need it.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20191218052552.2915188-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 6340823871e2..f7084235bae9 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -600,41 +600,6 @@ bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear);
  */
 LIBBPF_API int libbpf_num_possible_cpus(void);
 
-struct bpf_embed_data {
-	void *data;
-	size_t size;
-};
-
-#define BPF_EMBED_OBJ_DECLARE(NAME)					\
-extern struct bpf_embed_data NAME##_embed;				\
-extern char NAME##_data[];						\
-extern char NAME##_data_end[];
-
-#define __BPF_EMBED_OBJ(NAME, PATH, SZ, ASM_TYPE)			\
-asm (									\
-"	.pushsection \".rodata\", \"a\", @progbits		\n"	\
-"	.global "#NAME"_data					\n"	\
-#NAME"_data:							\n"	\
-"	.incbin \"" PATH "\"					\n"	\
-"	.global "#NAME"_data_end				\n"	\
-#NAME"_data_end:						\n"	\
-"	.global "#NAME"_embed					\n"	\
-"	.type "#NAME"_embed, @object				\n"	\
-"	.size "#NAME"_size, "#SZ"				\n"	\
-"	.align 8,						\n"	\
-#NAME"_embed:							\n"	\
-"	"ASM_TYPE" "#NAME"_data					\n"	\
-"	"ASM_TYPE" "#NAME"_data_end - "#NAME"_data 		\n"	\
-"	.popsection						\n"	\
-);									\
-BPF_EMBED_OBJ_DECLARE(NAME)
-
-#if __SIZEOF_POINTER__ == 4
-#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 8, ".long")
-#else
-#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 16, ".quad")
-#endif
-
 struct bpf_map_skeleton {
 	const char *name;
 	struct bpf_map **map;

commit 166750bc1dd256b2184b22588fb9fe6d3fbb93ae
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:47:08 2019 -0800

    libbpf: Support libbpf-provided extern variables
    
    Add support for extern variables, provided to BPF program by libbpf. Currently
    the following extern variables are supported:
      - LINUX_KERNEL_VERSION; version of a kernel in which BPF program is
        executing, follows KERNEL_VERSION() macro convention, can be 4- and 8-byte
        long;
      - CONFIG_xxx values; a set of values of actual kernel config. Tristate,
        boolean, strings, and integer values are supported.
    
    Set of possible values is determined by declared type of extern variable.
    Supported types of variables are:
    - Tristate values. Are represented as `enum libbpf_tristate`. Accepted values
      are **strictly** 'y', 'n', or 'm', which are represented as TRI_YES, TRI_NO,
      or TRI_MODULE, respectively.
    - Boolean values. Are represented as bool (_Bool) types. Accepted values are
      'y' and 'n' only, turning into true/false values, respectively.
    - Single-character values. Can be used both as a substritute for
      bool/tristate, or as a small-range integer:
      - 'y'/'n'/'m' are represented as is, as characters 'y', 'n', or 'm';
      - integers in a range [-128, 127] or [0, 255] (depending on signedness of
        char in target architecture) are recognized and represented with
        respective values of char type.
    - Strings. String values are declared as fixed-length char arrays. String of
      up to that length will be accepted and put in first N bytes of char array,
      with the rest of bytes zeroed out. If config string value is longer than
      space alloted, it will be truncated and warning message emitted. Char array
      is always zero terminated. String literals in config have to be enclosed in
      double quotes, just like C-style string literals.
    - Integers. 8-, 16-, 32-, and 64-bit integers are supported, both signed and
      unsigned variants. Libbpf enforces parsed config value to be in the
      supported range of corresponding integer type. Integers values in config can
      be:
      - decimal integers, with optional + and - signs;
      - hexadecimal integers, prefixed with 0x or 0X;
      - octal integers, starting with 0.
    
    Config file itself is searched in /boot/config-$(uname -r) location with
    fallback to /proc/config.gz, unless config path is specified explicitly
    through bpf_object_open_opts' kernel_config_path option. Both gzipped and
    plain text formats are supported. Libbpf adds explicit dependency on zlib
    because of this, but this shouldn't be a problem, given libelf already depends
    on zlib.
    
    All detected extern variables, are put into a separate .extern internal map.
    It, similarly to .rodata map, is marked as read-only from BPF program side, as
    well as is frozen on load. This allows BPF verifier to track extern values as
    constants and perform enhanced branch prediction and dead code elimination.
    This can be relied upon for doing kernel version/feature detection and using
    potentially unsupported field relocations or BPF helpers in a CO-RE-based BPF
    program, while still having a single version of BPF program running on old and
    new kernels. Selftests are validating this explicitly for unexisting BPF
    helper.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191214014710.3449601-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 623191e71415..6340823871e2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -85,8 +85,12 @@ struct bpf_object_open_opts {
 	 */
 	const char *pin_root_path;
 	__u32 attach_prog_fd;
+	/* kernel config file path override (for CONFIG_ externs); can point
+	 * to either uncompressed text file or .gz file
+	 */
+	const char *kconfig_path;
 };
-#define bpf_object_open_opts__last_field attach_prog_fd
+#define bpf_object_open_opts__last_field kconfig_path
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
@@ -669,6 +673,12 @@ LIBBPF_API int bpf_object__attach_skeleton(struct bpf_object_skeleton *s);
 LIBBPF_API void bpf_object__detach_skeleton(struct bpf_object_skeleton *s);
 LIBBPF_API void bpf_object__destroy_skeleton(struct bpf_object_skeleton *s);
 
+enum libbpf_tristate {
+	TRI_NO = 0,
+	TRI_YES = 1,
+	TRI_MODULE = 2,
+};
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit d66562fba1ce66975bd61b0786fb8b1810f33caa
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:36 2019 -0800

    libbpf: Add BPF object skeleton support
    
    Add new set of APIs, allowing to open/load/attach BPF object through BPF
    object skeleton, generated by bpftool for a specific BPF object file. All the
    xxx_skeleton() APIs wrap up corresponding bpf_object_xxx() APIs, but
    additionally also automate map/program lookups by name, global data
    initialization and mmap()-ing, etc.  All this greatly improves and simplifies
    userspace usability of working with BPF programs. See follow up patches for
    examples.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-13-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f37bd4a3e14b..623191e71415 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -631,6 +631,44 @@ BPF_EMBED_OBJ_DECLARE(NAME)
 #define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 16, ".quad")
 #endif
 
+struct bpf_map_skeleton {
+	const char *name;
+	struct bpf_map **map;
+	void **mmaped;
+};
+
+struct bpf_prog_skeleton {
+	const char *name;
+	struct bpf_program **prog;
+	struct bpf_link **link;
+};
+
+struct bpf_object_skeleton {
+	size_t sz; /* size of this struct, for forward/backward compatibility */
+
+	const char *name;
+	void *data;
+	size_t data_sz;
+
+	struct bpf_object **obj;
+
+	int map_cnt;
+	int map_skel_sz; /* sizeof(struct bpf_skeleton_map) */
+	struct bpf_map_skeleton *maps;
+
+	int prog_cnt;
+	int prog_skel_sz; /* sizeof(struct bpf_skeleton_prog) */
+	struct bpf_prog_skeleton *progs;
+};
+
+LIBBPF_API int
+bpf_object__open_skeleton(struct bpf_object_skeleton *s,
+			  const struct bpf_object_open_opts *opts);
+LIBBPF_API int bpf_object__load_skeleton(struct bpf_object_skeleton *s);
+LIBBPF_API int bpf_object__attach_skeleton(struct bpf_object_skeleton *s);
+LIBBPF_API void bpf_object__detach_skeleton(struct bpf_object_skeleton *s);
+LIBBPF_API void bpf_object__destroy_skeleton(struct bpf_object_skeleton *s);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit 01af3bf06755dc5cda7050fe5d898998e5775e63
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:32 2019 -0800

    libbpf: Expose BPF program's function name
    
    Add APIs to get BPF program function name, as opposed to bpf_program__title(),
    which returns BPF program function's section name. Function name has a benefit
    of being a valid C identifier and uniquely identifies a specific BPF program,
    while section name can be duplicated across multiple independent BPF programs.
    
    Add also bpf_object__find_program_by_name(), similar to
    bpf_object__find_program_by_title(), to facilitate looking up BPF programs by
    their C function names.
    
    Convert one of selftests to new API for look up.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-9-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 49e6fa01024b..f37bd4a3e14b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -90,10 +90,10 @@ struct bpf_object_open_opts {
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
-bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts);
+bpf_object__open_file(const char *path, const struct bpf_object_open_opts *opts);
 LIBBPF_API struct bpf_object *
 bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
-		     struct bpf_object_open_opts *opts);
+		     const struct bpf_object_open_opts *opts);
 
 /* deprecated bpf_object__open variants */
 LIBBPF_API struct bpf_object *
@@ -132,6 +132,7 @@ struct bpf_object_load_attr {
 LIBBPF_API int bpf_object__load(struct bpf_object *obj);
 LIBBPF_API int bpf_object__load_xattr(struct bpf_object_load_attr *attr);
 LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
+
 LIBBPF_API const char *bpf_object__name(const struct bpf_object *obj);
 LIBBPF_API unsigned int bpf_object__kversion(const struct bpf_object *obj);
 
@@ -142,6 +143,9 @@ LIBBPF_API int bpf_object__btf_fd(const struct bpf_object *obj);
 LIBBPF_API struct bpf_program *
 bpf_object__find_program_by_title(const struct bpf_object *obj,
 				  const char *title);
+LIBBPF_API struct bpf_program *
+bpf_object__find_program_by_name(const struct bpf_object *obj,
+				 const char *name);
 
 LIBBPF_API struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
@@ -185,6 +189,7 @@ LIBBPF_API void *bpf_program__priv(const struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
 					 __u32 ifindex);
 
+LIBBPF_API const char *bpf_program__name(const struct bpf_program *prog);
 LIBBPF_API const char *bpf_program__title(const struct bpf_program *prog,
 					  bool needs_copy);
 

commit 544402d4b49332a4a9b2b8fff20f9d9f5ef86559
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:29 2019 -0800

    libbpf: Extract common user-facing helpers
    
    LIBBPF_API and DECLARE_LIBBPF_OPTS are needed in many public libbpf API
    headers. Extract them into libbpf_common.h to avoid unnecessary
    interdependency between btf.h, libbpf.h, and bpf.h or code duplication.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-6-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index fa803dde1f46..49e6fa01024b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -17,14 +17,12 @@
 #include <sys/types.h>  // for size_t
 #include <linux/bpf.h>
 
+#include "libbpf_common.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#ifndef LIBBPF_API
-#define LIBBPF_API __attribute__((visibility("default")))
-#endif
-
 enum libbpf_errno {
 	__LIBBPF_ERRNO__START = 4000,
 
@@ -67,28 +65,6 @@ struct bpf_object_open_attr {
 	enum bpf_prog_type prog_type;
 };
 
-/* Helper macro to declare and initialize libbpf options struct
- *
- * This dance with uninitialized declaration, followed by memset to zero,
- * followed by assignment using compound literal syntax is done to preserve
- * ability to use a nice struct field initialization syntax and **hopefully**
- * have all the padding bytes initialized to zero. It's not guaranteed though,
- * when copying literal, that compiler won't copy garbage in literal's padding
- * bytes, but that's the best way I've found and it seems to work in practice.
- *
- * Macro declares opts struct of given type and name, zero-initializes,
- * including any extra padding, it with memset() and then assigns initial
- * values provided by users in struct initializer-syntax as varargs.
- */
-#define DECLARE_LIBBPF_OPTS(TYPE, NAME, ...)				    \
-	struct TYPE NAME = ({ 						    \
-		memset(&NAME, 0, sizeof(struct TYPE));			    \
-		(struct TYPE) {						    \
-			.sz = sizeof(struct TYPE),			    \
-			__VA_ARGS__					    \
-		};							    \
-	})
-
 struct bpf_object_open_opts {
 	/* size of this struct, for forward/backward compatiblity */
 	size_t sz;

commit 917f6b7b07a46e53fa73e112d23c97d1b201a877
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:28 2019 -0800

    libbpf: Add BPF_EMBED_OBJ macro for embedding BPF .o files
    
    Add a convenience macro BPF_EMBED_OBJ, which allows to embed other files
    (typically used to embed BPF .o files) into a hosting userspace programs. To
    C program it is exposed as struct bpf_embed_data, containing a pointer to
    raw data and its size in bytes.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-5-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2698fbcb0c79..fa803dde1f46 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -615,6 +615,41 @@ bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear);
  */
 LIBBPF_API int libbpf_num_possible_cpus(void);
 
+struct bpf_embed_data {
+	void *data;
+	size_t size;
+};
+
+#define BPF_EMBED_OBJ_DECLARE(NAME)					\
+extern struct bpf_embed_data NAME##_embed;				\
+extern char NAME##_data[];						\
+extern char NAME##_data_end[];
+
+#define __BPF_EMBED_OBJ(NAME, PATH, SZ, ASM_TYPE)			\
+asm (									\
+"	.pushsection \".rodata\", \"a\", @progbits		\n"	\
+"	.global "#NAME"_data					\n"	\
+#NAME"_data:							\n"	\
+"	.incbin \"" PATH "\"					\n"	\
+"	.global "#NAME"_data_end				\n"	\
+#NAME"_data_end:						\n"	\
+"	.global "#NAME"_embed					\n"	\
+"	.type "#NAME"_embed, @object				\n"	\
+"	.size "#NAME"_size, "#SZ"				\n"	\
+"	.align 8,						\n"	\
+#NAME"_embed:							\n"	\
+"	"ASM_TYPE" "#NAME"_data					\n"	\
+"	"ASM_TYPE" "#NAME"_data_end - "#NAME"_data 		\n"	\
+"	.popsection						\n"	\
+);									\
+BPF_EMBED_OBJ_DECLARE(NAME)
+
+#if __SIZEOF_POINTER__ == 4
+#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 8, ".long")
+#else
+#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 16, ".quad")
+#endif
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit 612d05be250aa8804d3baba7a12445a267a580d3
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:27 2019 -0800

    libbpf: Move non-public APIs from libbpf.h to libbpf_internal.h
    
    Few libbpf APIs are not public but currently exposed through libbpf.h to be
    used by bpftool. Move them to libbpf_internal.h, where intent of being
    non-stable and non-public is much more obvious.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-4-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 804f445c9957..2698fbcb0c79 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -126,11 +126,6 @@ bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
 LIBBPF_API struct bpf_object *
 bpf_object__open_xattr(struct bpf_object_open_attr *attr);
 
-int bpf_object__section_size(const struct bpf_object *obj, const char *name,
-			     __u32 *size);
-int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
-				__u32 *off);
-
 enum libbpf_pin_type {
 	LIBBPF_PIN_NONE,
 	/* PIN_BY_NAME: pin maps by name (in /sys/fs/bpf by default) */
@@ -514,18 +509,6 @@ bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
 			   void **copy_mem, size_t *copy_size,
 			   bpf_perf_event_print_t fn, void *private_data);
 
-struct nlattr;
-typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
-int libbpf_netlink_open(unsigned int *nl_pid);
-int libbpf_nl_get_link(int sock, unsigned int nl_pid,
-		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
-int libbpf_nl_get_class(int sock, unsigned int nl_pid, int ifindex,
-			libbpf_dump_nlmsg_t dump_class_nlmsg, void *cookie);
-int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
-			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
-int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
-			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
-
 struct bpf_prog_linfo;
 struct bpf_prog_info;
 

commit d7a18ea7e8b612669acd0131fd075e5c735c1ce5
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:26 2019 -0800

    libbpf: Add generic bpf_program__attach()
    
    Generalize BPF program attaching and allow libbpf to auto-detect type (and
    extra parameters, where applicable) and attach supported BPF program types
    based on program sections. Currently this is supported for:
    - kprobe/kretprobe;
    - tracepoint;
    - raw tracepoint;
    - tracing programs (typed raw TP/fentry/fexit).
    
    More types support can be trivially added within this framework.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 0dbf4bfba0c4..804f445c9957 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -237,6 +237,8 @@ struct bpf_link;
 
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
+LIBBPF_API struct bpf_link *
+bpf_program__attach(struct bpf_program *prog);
 LIBBPF_API struct bpf_link *
 bpf_program__attach_perf_event(struct bpf_program *prog, int pfd);
 LIBBPF_API struct bpf_link *

commit e7bf94dbb882b7d679a6a18e40e4f28076eb249f
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Thu Nov 14 10:57:18 2019 -0800

    libbpf: Add support for attaching BPF programs to other BPF programs
    
    Extend libbpf api to pass attach_prog_fd into bpf_object__open.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20191114185720.1641606-19-ast@kernel.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index fbff419f6daf..0dbf4bfba0c4 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -108,8 +108,9 @@ struct bpf_object_open_opts {
 	 * auto-pinned to that path on load; defaults to "/sys/fs/bpf".
 	 */
 	const char *pin_root_path;
+	__u32 attach_prog_fd;
 };
-#define bpf_object_open_opts__last_field pin_root_path
+#define bpf_object_open_opts__last_field attach_prog_fd
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *

commit b8c54ea455dc2e0bda7ea9b0370279c224e21045
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Thu Nov 14 10:57:06 2019 -0800

    libbpf: Add support to attach to fentry/fexit tracing progs
    
    Teach libbpf to recognize tracing programs types and attach them to
    fentry/fexit.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20191114185720.1641606-7-ast@kernel.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 5aa27caad6c2..fbff419f6daf 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -188,6 +188,8 @@ libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
 			 enum bpf_attach_type *expected_attach_type);
 LIBBPF_API int libbpf_attach_type_by_name(const char *name,
 					  enum bpf_attach_type *attach_type);
+LIBBPF_API int libbpf_find_vmlinux_btf_id(const char *name,
+					  enum bpf_attach_type attach_type);
 
 /* Accessors of bpf_program */
 struct bpf_program;
@@ -251,6 +253,8 @@ LIBBPF_API struct bpf_link *
 bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
 				   const char *tp_name);
 
+LIBBPF_API struct bpf_link *
+bpf_program__attach_trace(struct bpf_program *prog);
 struct bpf_insn;
 
 /*

commit 1a734efe06948c17122808f74f0c8cc550c10cf5
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sat Nov 9 21:37:32 2019 +0100

    libbpf: Add getter for program size
    
    This adds a new getter for the BPF program size (in bytes). This is useful
    for a caller that is trying to predict how much memory will be locked by
    loading a BPF object into the kernel.
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/157333185272.88376.10996937115395724683.stgit@toke.dk

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f0947cc949d2..5aa27caad6c2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -214,6 +214,9 @@ LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
 LIBBPF_API const char *bpf_program__title(const struct bpf_program *prog,
 					  bool needs_copy);
 
+/* returns program size in bytes */
+LIBBPF_API size_t bpf_program__size(const struct bpf_program *prog);
+
 LIBBPF_API int bpf_program__load(struct bpf_program *prog, char *license,
 				 __u32 kern_version);
 LIBBPF_API int bpf_program__fd(const struct bpf_program *prog);

commit 473f4e133a12dd083bae044ba1782be4767177c1
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sat Nov 9 21:37:31 2019 +0100

    libbpf: Add bpf_get_link_xdp_info() function to get more XDP information
    
    Currently, libbpf only provides a function to get a single ID for the XDP
    program attached to the interface. However, it can be useful to get the
    full set of program IDs attached, along with the attachment mode, in one
    go. Add a new getter function to support this, using an extendible
    structure to carry the information. Express the old bpf_get_link_id()
    function in terms of the new function.
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157333185164.88376.7520653040667637246.stgit@toke.dk

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 6ddc0419337b..f0947cc949d2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -427,8 +427,18 @@ LIBBPF_API int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
 LIBBPF_API int bpf_prog_load(const char *file, enum bpf_prog_type type,
 			     struct bpf_object **pobj, int *prog_fd);
 
+struct xdp_link_info {
+	__u32 prog_id;
+	__u32 drv_prog_id;
+	__u32 hw_prog_id;
+	__u32 skb_prog_id;
+	__u8 attach_mode;
+};
+
 LIBBPF_API int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
 LIBBPF_API int bpf_get_link_xdp_id(int ifindex, __u32 *prog_id, __u32 flags);
+LIBBPF_API int bpf_get_link_xdp_info(int ifindex, struct xdp_link_info *info,
+				     size_t info_size, __u32 flags);
 
 struct perf_buffer;
 

commit 57a00f41644f20b11c12a27061d814655f633544
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sat Nov 2 12:09:41 2019 +0100

    libbpf: Add auto-pinning of maps when loading BPF objects
    
    This adds support to libbpf for setting map pinning information as part of
    the BTF map declaration, to get automatic map pinning (and reuse) on load.
    The pinning type currently only supports a single PIN_BY_NAME mode, where
    each map will be pinned by its name in a path that can be overridden, but
    defaults to /sys/fs/bpf.
    
    Since auto-pinning only does something if any maps actually have a
    'pinning' BTF attribute set, we default the new option to enabled, on the
    assumption that seamless pinning is what most callers want.
    
    When a map has a pin_path set at load time, libbpf will compare the map
    pinned at that location (if any), and if the attributes match, will re-use
    that map instead of creating a new one. If no existing map is found, the
    newly created map will instead be pinned at the location.
    
    Programs wanting to customise the pinning can override the pinning paths
    using bpf_map__set_pin_path() before calling bpf_object__load() (including
    setting it to NULL to disable pinning of a particular map).
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157269298092.394725.3966306029218559681.stgit@toke.dk

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e71773a6bfdf..6ddc0419337b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -103,8 +103,13 @@ struct bpf_object_open_opts {
 	bool relaxed_maps;
 	/* process CO-RE relocations non-strictly, allowing them to fail */
 	bool relaxed_core_relocs;
+	/* maps that set the 'pinning' attribute in their definition will have
+	 * their pin_path attribute set to a file in this directory, and be
+	 * auto-pinned to that path on load; defaults to "/sys/fs/bpf".
+	 */
+	const char *pin_root_path;
 };
-#define bpf_object_open_opts__last_field relaxed_core_relocs
+#define bpf_object_open_opts__last_field pin_root_path
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
@@ -125,6 +130,12 @@ int bpf_object__section_size(const struct bpf_object *obj, const char *name,
 int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
 				__u32 *off);
 
+enum libbpf_pin_type {
+	LIBBPF_PIN_NONE,
+	/* PIN_BY_NAME: pin maps by name (in /sys/fs/bpf by default) */
+	LIBBPF_PIN_BY_NAME,
+};
+
 /* pin_maps and unpin_maps can both be called with a NULL path, in which case
  * they will use the pin_path attribute of each map (and ignore all maps that
  * don't have a pin_path set).

commit 4580b25fcee5347327aaffcec31c615ec28a889a
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sat Nov 2 12:09:38 2019 +0100

    libbpf: Store map pin path and status in struct bpf_map
    
    Support storing and setting a pin path in struct bpf_map, which can be used
    for automatic pinning. Also store the pin status so we can avoid attempts
    to re-pin a map that has already been pinned (or reused from a previous
    pinning).
    
    The behaviour of bpf_object__{un,}pin_maps() is changed so that if it is
    called with a NULL path argument (which was previously illegal), it will
    (un)pin only those maps that have a pin_path set.
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157269297876.394725.14782206533681896279.stgit@toke.dk

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2b126ee5e173..e71773a6bfdf 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -124,6 +124,11 @@ int bpf_object__section_size(const struct bpf_object *obj, const char *name,
 			     __u32 *size);
 int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
 				__u32 *off);
+
+/* pin_maps and unpin_maps can both be called with a NULL path, in which case
+ * they will use the pin_path attribute of each map (and ignore all maps that
+ * don't have a pin_path set).
+ */
 LIBBPF_API int bpf_object__pin_maps(struct bpf_object *obj, const char *path);
 LIBBPF_API int bpf_object__unpin_maps(struct bpf_object *obj,
 				      const char *path);
@@ -387,6 +392,9 @@ LIBBPF_API int bpf_map__resize(struct bpf_map *map, __u32 max_entries);
 LIBBPF_API bool bpf_map__is_offload_neutral(const struct bpf_map *map);
 LIBBPF_API bool bpf_map__is_internal(const struct bpf_map *map);
 LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
+LIBBPF_API int bpf_map__set_pin_path(struct bpf_map *map, const char *path);
+LIBBPF_API const char *bpf_map__get_pin_path(const struct bpf_map *map);
+LIBBPF_API bool bpf_map__is_pinned(const struct bpf_map *map);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
 LIBBPF_API int bpf_map__unpin(struct bpf_map *map, const char *path);
 

commit 12a8654b2e5aab37b22c9608d008f9f0565862c0
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Wed Oct 30 15:32:12 2019 -0700

    libbpf: Add support for prog_tracing
    
    Cleanup libbpf from expected_attach_type == attach_btf_id hack
    and introduce BPF_PROG_TYPE_TRACING.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191030223212.953010-3-ast@kernel.org

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index c63e2ff84abc..2b126ee5e173 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -307,6 +307,7 @@ LIBBPF_API int bpf_program__set_sched_cls(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_tracing(struct bpf_program *prog);
 
 LIBBPF_API enum bpf_prog_type bpf_program__get_type(struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
@@ -326,6 +327,7 @@ LIBBPF_API bool bpf_program__is_sched_cls(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_sched_act(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);
 LIBBPF_API bool bpf_program__is_perf_event(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_tracing(const struct bpf_program *prog);
 
 /*
  * No need for __attribute__((packed)), all members of 'bpf_map_def'

commit e00aca65e646da08f8dce31c9b89f11dab76198c
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Oct 22 10:21:00 2019 -0700

    libbpf: Make DECLARE_LIBBPF_OPTS macro strictly a variable declaration
    
    LIBBPF_OPTS is implemented as a mix of field declaration and memset
    + assignment. This makes it neither variable declaration nor purely
    statements, which is a problem, because you can't mix it with either
    other variable declarations nor other function statements, because C90
    compiler mode emits warning on mixing all that together.
    
    This patch changes LIBBPF_OPTS into a strictly declaration of variable
    and solves this problem, as can be seen in case of bpftool, which
    previously would emit compiler warning, if done this way (LIBBPF_OPTS as
    part of function variables declaration block).
    
    This patch also renames LIBBPF_OPTS into DECLARE_LIBBPF_OPTS to follow
    kernel convention for similar macros more closely.
    
    v1->v2:
    - rename LIBBPF_OPTS into DECLARE_LIBBPF_OPTS (Jakub Sitnicki).
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/20191022172100.3281465-1-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 0fdf086beba7..c63e2ff84abc 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -75,14 +75,19 @@ struct bpf_object_open_attr {
  * have all the padding bytes initialized to zero. It's not guaranteed though,
  * when copying literal, that compiler won't copy garbage in literal's padding
  * bytes, but that's the best way I've found and it seems to work in practice.
+ *
+ * Macro declares opts struct of given type and name, zero-initializes,
+ * including any extra padding, it with memset() and then assigns initial
+ * values provided by users in struct initializer-syntax as varargs.
  */
-#define LIBBPF_OPTS(TYPE, NAME, ...)					    \
-	struct TYPE NAME;						    \
-	memset(&NAME, 0, sizeof(struct TYPE));				    \
-	NAME = (struct TYPE) {						    \
-		.sz = sizeof(struct TYPE),				    \
-		__VA_ARGS__						    \
-	}
+#define DECLARE_LIBBPF_OPTS(TYPE, NAME, ...)				    \
+	struct TYPE NAME = ({ 						    \
+		memset(&NAME, 0, sizeof(struct TYPE));			    \
+		(struct TYPE) {						    \
+			.sz = sizeof(struct TYPE),			    \
+			__VA_ARGS__					    \
+		};							    \
+	})
 
 struct bpf_object_open_opts {
 	/* size of this struct, for forward/backward compatiblity */

commit f1eead9e3ceef67b98be4b55ed1bfcfa4497b7db
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Sun Oct 20 20:38:57 2019 -0700

    libbpf: Add bpf_program__get_{type, expected_attach_type) APIs
    
    There are bpf_program__set_type() and
    bpf_program__set_expected_attach_type(), but no corresponding getters,
    which seems rather incomplete. Fix this.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20191021033902.3856966-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 53ce212764e0..0fdf086beba7 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -302,8 +302,13 @@ LIBBPF_API int bpf_program__set_sched_cls(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
+
+LIBBPF_API enum bpf_prog_type bpf_program__get_type(struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
 				      enum bpf_prog_type type);
+
+LIBBPF_API enum bpf_attach_type
+bpf_program__get_expected_attach_type(struct bpf_program *prog);
 LIBBPF_API void
 bpf_program__set_expected_attach_type(struct bpf_program *prog,
 				      enum bpf_attach_type type);

commit 62561eb442bd095f06534ce637b116b278e5e912
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Oct 15 11:28:47 2019 -0700

    libbpf: Add support for field existance CO-RE relocation
    
    Add support for BPF_FRK_EXISTS relocation kind to detect existence of
    captured field in a destination BTF, allowing conditional logic to
    handle incompatible differences between kernels.
    
    Also introduce opt-in relaxed CO-RE relocation handling option, which
    makes libbpf emit warning for failed relocations, but proceed with other
    relocations. Instruction, for which relocation failed, is patched with
    (u32)-1 value.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191015182849.3922287-4-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 667e6853e51f..53ce212764e0 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -96,8 +96,10 @@ struct bpf_object_open_opts {
 	const char *object_name;
 	/* parse map definitions non-strictly, allowing extra attributes/data */
 	bool relaxed_maps;
+	/* process CO-RE relocations non-strictly, allowing them to fail */
+	bool relaxed_core_relocs;
 };
-#define bpf_object_open_opts__last_field relaxed_maps
+#define bpf_object_open_opts__last_field relaxed_core_relocs
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *

commit 2ce8450ef5a381e5ffeb4682c0093a3ab5d07008
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Oct 4 15:40:35 2019 -0700

    libbpf: add bpf_object__open_{file, mem} w/ extensible opts
    
    Add new set of bpf_object__open APIs using new approach to optional
    parameters extensibility allowing simpler ABI compatibility approach.
    
    This patch demonstrates an approach to implementing libbpf APIs that
    makes it easy to extend existing APIs with extra optional parameters in
    such a way, that ABI compatibility is preserved without having to do
    symbol versioning and generating lots of boilerplate code to handle it.
    To facilitate succinct code for working with options, add OPTS_VALID,
    OPTS_HAS, and OPTS_GET macros that hide all the NULL, size, and zero
    checks.
    
    Additionally, newly added libbpf APIs are encouraged to follow similar
    pattern of having all mandatory parameters as formal function parameters
    and always have optional (NULL-able) xxx_opts struct, which should
    always have real struct size as a first field and the rest would be
    optional parameters added over time, which tune the behavior of existing
    API, if specified by user.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2905dffd70b2..667e6853e51f 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -67,12 +67,52 @@ struct bpf_object_open_attr {
 	enum bpf_prog_type prog_type;
 };
 
+/* Helper macro to declare and initialize libbpf options struct
+ *
+ * This dance with uninitialized declaration, followed by memset to zero,
+ * followed by assignment using compound literal syntax is done to preserve
+ * ability to use a nice struct field initialization syntax and **hopefully**
+ * have all the padding bytes initialized to zero. It's not guaranteed though,
+ * when copying literal, that compiler won't copy garbage in literal's padding
+ * bytes, but that's the best way I've found and it seems to work in practice.
+ */
+#define LIBBPF_OPTS(TYPE, NAME, ...)					    \
+	struct TYPE NAME;						    \
+	memset(&NAME, 0, sizeof(struct TYPE));				    \
+	NAME = (struct TYPE) {						    \
+		.sz = sizeof(struct TYPE),				    \
+		__VA_ARGS__						    \
+	}
+
+struct bpf_object_open_opts {
+	/* size of this struct, for forward/backward compatiblity */
+	size_t sz;
+	/* object name override, if provided:
+	 * - for object open from file, this will override setting object
+	 *   name from file path's base name;
+	 * - for object open from memory buffer, this will specify an object
+	 *   name and will override default "<addr>-<buf-size>" name;
+	 */
+	const char *object_name;
+	/* parse map definitions non-strictly, allowing extra attributes/data */
+	bool relaxed_maps;
+};
+#define bpf_object_open_opts__last_field relaxed_maps
+
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
+bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts);
+LIBBPF_API struct bpf_object *
+bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
+		     struct bpf_object_open_opts *opts);
+
+/* deprecated bpf_object__open variants */
+LIBBPF_API struct bpf_object *
+bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
+			const char *name);
+LIBBPF_API struct bpf_object *
 bpf_object__open_xattr(struct bpf_object_open_attr *attr);
-LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
-						      size_t obj_buf_sz,
-						      const char *name);
+
 int bpf_object__section_size(const struct bpf_object *obj, const char *name,
 			     __u32 *size);
 int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,

commit 5e61f27070292d4ad3af51dc68eebab6c1df69d3
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Oct 4 15:40:34 2019 -0700

    libbpf: stop enforcing kern_version, populate it for users
    
    Kernel version enforcement for kprobes/kretprobes was removed from
    5.0 kernel in 6c4fc209fcf9 ("bpf: remove useless version check for prog load").
    Since then, BPF programs were specifying SEC("version") just to please
    libbpf. We should stop enforcing this in libbpf, if even kernel doesn't
    care. Furthermore, libbpf now will pre-populate current kernel version
    of the host system, in case we are still running on old kernel.
    
    This patch also removes __bpf_object__open_xattr from libbpf.h, as
    nothing in libbpf is relying on having it in that header. That function
    was never exported as LIBBPF_API and even name suggests its internal
    version. So this should be safe to remove, as it doesn't break ABI.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e8f70977d137..2905dffd70b2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -70,8 +70,6 @@ struct bpf_object_open_attr {
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
 bpf_object__open_xattr(struct bpf_object_open_attr *attr);
-struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
-					    int flags);
 LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 						      size_t obj_buf_sz,
 						      const char *name);

commit ddc7c3042614e273044f698d2beab25cc3842d45
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Aug 7 14:39:51 2019 -0700

    libbpf: implement BPF CO-RE offset relocation algorithm
    
    This patch implements the core logic for BPF CO-RE offsets relocations.
    Every instruction that needs to be relocated has corresponding
    bpf_offset_reloc as part of BTF.ext. Relocations are performed by trying
    to match recorded "local" relocation spec against potentially many
    compatible "target" types, creating corresponding spec. Details of the
    algorithm are noted in corresponding comments in the code.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8a9d462a6f6d..e8f70977d137 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -92,6 +92,7 @@ LIBBPF_API void bpf_object__close(struct bpf_object *object);
 struct bpf_object_load_attr {
 	struct bpf_object *obj;
 	int log_level;
+	const char *target_btf_path;
 };
 
 /* Load/unload object into/from kernel */

commit e87fd8bae44c3eaa6205c9c81419e773896dc157
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Sat Jul 27 20:25:26 2019 -0700

    libbpf: return previous print callback from libbpf_set_print
    
    By returning previously set print callback from libbpf_set_print, it's
    possible to restore it, eventually. This is useful when running many
    independent test with one default print function, but overriding log
    verbosity for particular subset of tests.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 5cbf459ece0b..8a9d462a6f6d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -57,7 +57,7 @@ enum libbpf_print_level {
 typedef int (*libbpf_print_fn_t)(enum libbpf_print_level level,
 				 const char *, va_list ap);
 
-LIBBPF_API void libbpf_set_print(libbpf_print_fn_t fn);
+LIBBPF_API libbpf_print_fn_t libbpf_set_print(libbpf_print_fn_t fn);
 
 /* Hide internal to user */
 struct bpf_object;

commit fb84b8224655309e7d38f989e426b82a4543f115
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Sat Jul 6 11:06:24 2019 -0700

    libbpf: add perf buffer API
    
    BPF_MAP_TYPE_PERF_EVENT_ARRAY map is often used to send data from BPF program
    to user space for additional processing. libbpf already has very low-level API
    to read single CPU perf buffer, bpf_perf_event_read_simple(), but it's hard to
    use and requires a lot of code to set everything up. This patch adds
    perf_buffer abstraction on top of it, abstracting setting up and polling
    per-CPU logic into simple and convenient API, similar to what BCC provides.
    
    perf_buffer__new() sets up per-CPU ring buffers and updates corresponding BPF
    map entries. It accepts two user-provided callbacks: one for handling raw
    samples and one for get notifications of lost samples due to buffer overflow.
    
    perf_buffer__new_raw() is similar, but provides more control over how
    perf events are set up (by accepting user-provided perf_event_attr), how
    they are handled (perf_event_header pointer is passed directly to
    user-provided callback), and on which CPUs ring buffers are created
    (it's possible to provide a list of CPUs and corresponding map keys to
    update). This API allows advanced users fuller control.
    
    perf_buffer__poll() is used to fetch ring buffer data across all CPUs,
    utilizing epoll instance.
    
    perf_buffer__free() does corresponding clean up and unsets FDs from BPF map.
    
    All APIs are not thread-safe. User should ensure proper locking/coordination if
    used in multi-threaded set up.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f55933784f95..5cbf459ece0b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -358,6 +358,26 @@ LIBBPF_API int bpf_prog_load(const char *file, enum bpf_prog_type type,
 LIBBPF_API int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
 LIBBPF_API int bpf_get_link_xdp_id(int ifindex, __u32 *prog_id, __u32 flags);
 
+struct perf_buffer;
+
+typedef void (*perf_buffer_sample_fn)(void *ctx, int cpu,
+				      void *data, __u32 size);
+typedef void (*perf_buffer_lost_fn)(void *ctx, int cpu, __u64 cnt);
+
+/* common use perf buffer options */
+struct perf_buffer_opts {
+	/* if specified, sample_cb is called for each sample */
+	perf_buffer_sample_fn sample_cb;
+	/* if specified, lost_cb is called for each batch of lost samples */
+	perf_buffer_lost_fn lost_cb;
+	/* ctx is provided to sample_cb and lost_cb */
+	void *ctx;
+};
+
+LIBBPF_API struct perf_buffer *
+perf_buffer__new(int map_fd, size_t page_cnt,
+		 const struct perf_buffer_opts *opts);
+
 enum bpf_perf_event_ret {
 	LIBBPF_PERF_EVENT_DONE	= 0,
 	LIBBPF_PERF_EVENT_ERROR	= -1,
@@ -365,6 +385,35 @@ enum bpf_perf_event_ret {
 };
 
 struct perf_event_header;
+
+typedef enum bpf_perf_event_ret
+(*perf_buffer_event_fn)(void *ctx, int cpu, struct perf_event_header *event);
+
+/* raw perf buffer options, giving most power and control */
+struct perf_buffer_raw_opts {
+	/* perf event attrs passed directly into perf_event_open() */
+	struct perf_event_attr *attr;
+	/* raw event callback */
+	perf_buffer_event_fn event_cb;
+	/* ctx is provided to event_cb */
+	void *ctx;
+	/* if cpu_cnt == 0, open all on all possible CPUs (up to the number of
+	 * max_entries of given PERF_EVENT_ARRAY map)
+	 */
+	int cpu_cnt;
+	/* if cpu_cnt > 0, cpus is an array of CPUs to open ring buffers on */
+	int *cpus;
+	/* if cpu_cnt > 0, map_keys specify map keys to set per-CPU FDs for */
+	int *map_keys;
+};
+
+LIBBPF_API struct perf_buffer *
+perf_buffer__new_raw(int map_fd, size_t page_cnt,
+		     const struct perf_buffer_raw_opts *opts);
+
+LIBBPF_API void perf_buffer__free(struct perf_buffer *pb);
+LIBBPF_API int perf_buffer__poll(struct perf_buffer *pb, int timeout_ms);
+
 typedef enum bpf_perf_event_ret
 	(*bpf_perf_event_print_t)(struct perf_event_header *hdr,
 				  void *private_data);

commit 84bf5e1f4f174fc4f06bc747dafa1a7cfa4e9a67
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jul 1 16:59:00 2019 -0700

    libbpf: add raw tracepoint attach API
    
    Add a wrapper utilizing bpf_link "infrastructure" to allow attaching BPF
    programs to raw tracepoints.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 60611f4b4e1d..f55933784f95 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -182,6 +182,9 @@ LIBBPF_API struct bpf_link *
 bpf_program__attach_tracepoint(struct bpf_program *prog,
 			       const char *tp_category,
 			       const char *tp_name);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
+				   const char *tp_name);
 
 struct bpf_insn;
 

commit f6de59c17f111b3efc701c95b438e46245c4aeb1
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jul 1 16:58:59 2019 -0700

    libbpf: add tracepoint attach API
    
    Allow attaching BPF programs to kernel tracepoint BPF hooks specified by
    category and name.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index bd767cc11967..60611f4b4e1d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -178,6 +178,10 @@ LIBBPF_API struct bpf_link *
 bpf_program__attach_uprobe(struct bpf_program *prog, bool retprobe,
 			   pid_t pid, const char *binary_path,
 			   size_t func_offset);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_tracepoint(struct bpf_program *prog,
+			       const char *tp_category,
+			       const char *tp_name);
 
 struct bpf_insn;
 

commit b26500274767bacbe571c75926fee2489f91ba28
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jul 1 16:58:58 2019 -0700

    libbpf: add kprobe/uprobe attach API
    
    Add ability to attach to kernel and user probes and retprobes.
    Implementation depends on perf event support for kprobes/uprobes.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1bf66c4a9330..bd767cc11967 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -171,6 +171,13 @@ LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
 LIBBPF_API struct bpf_link *
 bpf_program__attach_perf_event(struct bpf_program *prog, int pfd);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_kprobe(struct bpf_program *prog, bool retprobe,
+			   const char *func_name);
+LIBBPF_API struct bpf_link *
+bpf_program__attach_uprobe(struct bpf_program *prog, bool retprobe,
+			   pid_t pid, const char *binary_path,
+			   size_t func_offset);
 
 struct bpf_insn;
 

commit 63f2f5ee856ba9db751123bc5519be099a3849a7
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jul 1 16:58:57 2019 -0700

    libbpf: add ability to attach/detach BPF program to perf event
    
    bpf_program__attach_perf_event allows to attach BPF program to existing
    perf event hook, providing most generic and most low-level way to attach BPF
    programs. It returns struct bpf_link, which should be passed to
    bpf_link__destroy to detach and free resources, associated with a link.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 5082a5ebb0c2..1bf66c4a9330 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -169,6 +169,9 @@ struct bpf_link;
 
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
+LIBBPF_API struct bpf_link *
+bpf_program__attach_perf_event(struct bpf_program *prog, int pfd);
+
 struct bpf_insn;
 
 /*

commit 1c2e9efc26f389effc86e9b4d41f85d101f17629
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jul 1 16:58:56 2019 -0700

    libbpf: introduce concept of bpf_link
    
    bpf_link is an abstraction of an association of a BPF program and one of
    many possible BPF attachment points (hooks). This allows to have uniform
    interface for detaching BPF programs regardless of the nature of link
    and how it was created. Details of creation and setting up of a specific
    bpf_link is handled by corresponding attachment methods
    (bpf_program__attach_xxx) added in subsequent commits. Once successfully
    created, bpf_link has to be eventually destroyed with
    bpf_link__destroy(), at which point BPF program is disassociated from
    a hook and all the relevant resources are freed.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index d639f47e3110..5082a5ebb0c2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -165,6 +165,10 @@ LIBBPF_API int bpf_program__pin(struct bpf_program *prog, const char *path);
 LIBBPF_API int bpf_program__unpin(struct bpf_program *prog, const char *path);
 LIBBPF_API void bpf_program__unload(struct bpf_program *prog);
 
+struct bpf_link;
+
+LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
+
 struct bpf_insn;
 
 /*

commit a324aae32fa9bfdd03e89078e20ebcbd7737fda5
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jun 17 15:48:58 2019 -0700

    libbpf: constify getter APIs
    
    Add const qualifiers to bpf_object/bpf_program/bpf_map arguments for
    getter APIs. There is no need for them to not be const pointers.
    
    Verified that
    
    make -C tools/lib/bpf
    make -C tools/testing/selftests/bpf
    make -C tools/perf
    
    all build without warnings.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2e594a0fa961..d639f47e3110 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -98,15 +98,16 @@ struct bpf_object_load_attr {
 LIBBPF_API int bpf_object__load(struct bpf_object *obj);
 LIBBPF_API int bpf_object__load_xattr(struct bpf_object_load_attr *attr);
 LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
-LIBBPF_API const char *bpf_object__name(struct bpf_object *obj);
-LIBBPF_API unsigned int bpf_object__kversion(struct bpf_object *obj);
+LIBBPF_API const char *bpf_object__name(const struct bpf_object *obj);
+LIBBPF_API unsigned int bpf_object__kversion(const struct bpf_object *obj);
 
 struct btf;
-LIBBPF_API struct btf *bpf_object__btf(struct bpf_object *obj);
+LIBBPF_API struct btf *bpf_object__btf(const struct bpf_object *obj);
 LIBBPF_API int bpf_object__btf_fd(const struct bpf_object *obj);
 
 LIBBPF_API struct bpf_program *
-bpf_object__find_program_by_title(struct bpf_object *obj, const char *title);
+bpf_object__find_program_by_title(const struct bpf_object *obj,
+				  const char *title);
 
 LIBBPF_API struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
@@ -118,7 +119,7 @@ LIBBPF_API struct bpf_object *bpf_object__next(struct bpf_object *prev);
 typedef void (*bpf_object_clear_priv_t)(struct bpf_object *, void *);
 LIBBPF_API int bpf_object__set_priv(struct bpf_object *obj, void *priv,
 				    bpf_object_clear_priv_t clear_priv);
-LIBBPF_API void *bpf_object__priv(struct bpf_object *prog);
+LIBBPF_API void *bpf_object__priv(const struct bpf_object *prog);
 
 LIBBPF_API int
 libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
@@ -129,7 +130,7 @@ LIBBPF_API int libbpf_attach_type_by_name(const char *name,
 /* Accessors of bpf_program */
 struct bpf_program;
 LIBBPF_API struct bpf_program *bpf_program__next(struct bpf_program *prog,
-						 struct bpf_object *obj);
+						 const struct bpf_object *obj);
 
 #define bpf_object__for_each_program(pos, obj)		\
 	for ((pos) = bpf_program__next(NULL, (obj));	\
@@ -137,24 +138,23 @@ LIBBPF_API struct bpf_program *bpf_program__next(struct bpf_program *prog,
 	     (pos) = bpf_program__next((pos), (obj)))
 
 LIBBPF_API struct bpf_program *bpf_program__prev(struct bpf_program *prog,
-						 struct bpf_object *obj);
+						 const struct bpf_object *obj);
 
-typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
-					 void *);
+typedef void (*bpf_program_clear_priv_t)(struct bpf_program *, void *);
 
 LIBBPF_API int bpf_program__set_priv(struct bpf_program *prog, void *priv,
 				     bpf_program_clear_priv_t clear_priv);
 
-LIBBPF_API void *bpf_program__priv(struct bpf_program *prog);
+LIBBPF_API void *bpf_program__priv(const struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
 					 __u32 ifindex);
 
-LIBBPF_API const char *bpf_program__title(struct bpf_program *prog,
+LIBBPF_API const char *bpf_program__title(const struct bpf_program *prog,
 					  bool needs_copy);
 
 LIBBPF_API int bpf_program__load(struct bpf_program *prog, char *license,
 				 __u32 kern_version);
-LIBBPF_API int bpf_program__fd(struct bpf_program *prog);
+LIBBPF_API int bpf_program__fd(const struct bpf_program *prog);
 LIBBPF_API int bpf_program__pin_instance(struct bpf_program *prog,
 					 const char *path,
 					 int instance);
@@ -227,7 +227,7 @@ typedef int (*bpf_program_prep_t)(struct bpf_program *prog, int n,
 LIBBPF_API int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
 				     bpf_program_prep_t prep);
 
-LIBBPF_API int bpf_program__nth_fd(struct bpf_program *prog, int n);
+LIBBPF_API int bpf_program__nth_fd(const struct bpf_program *prog, int n);
 
 /*
  * Adjust type of BPF program. Default is kprobe.
@@ -246,14 +246,14 @@ LIBBPF_API void
 bpf_program__set_expected_attach_type(struct bpf_program *prog,
 				      enum bpf_attach_type type);
 
-LIBBPF_API bool bpf_program__is_socket_filter(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_tracepoint(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_raw_tracepoint(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_kprobe(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_sched_cls(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_sched_act(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_xdp(struct bpf_program *prog);
-LIBBPF_API bool bpf_program__is_perf_event(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_socket_filter(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_tracepoint(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_raw_tracepoint(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_kprobe(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_sched_cls(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_sched_act(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_perf_event(const struct bpf_program *prog);
 
 /*
  * No need for __attribute__((packed)), all members of 'bpf_map_def'
@@ -275,10 +275,10 @@ struct bpf_map_def {
  */
 struct bpf_map;
 LIBBPF_API struct bpf_map *
-bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
+bpf_object__find_map_by_name(const struct bpf_object *obj, const char *name);
 
 LIBBPF_API int
-bpf_object__find_map_fd_by_name(struct bpf_object *obj, const char *name);
+bpf_object__find_map_fd_by_name(const struct bpf_object *obj, const char *name);
 
 /*
  * Get bpf_map through the offset of corresponding struct bpf_map_def
@@ -288,7 +288,7 @@ LIBBPF_API struct bpf_map *
 bpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset);
 
 LIBBPF_API struct bpf_map *
-bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
+bpf_map__next(const struct bpf_map *map, const struct bpf_object *obj);
 #define bpf_object__for_each_map(pos, obj)		\
 	for ((pos) = bpf_map__next(NULL, (obj));	\
 	     (pos) != NULL;				\
@@ -296,22 +296,22 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 #define bpf_map__for_each bpf_object__for_each_map
 
 LIBBPF_API struct bpf_map *
-bpf_map__prev(struct bpf_map *map, struct bpf_object *obj);
+bpf_map__prev(const struct bpf_map *map, const struct bpf_object *obj);
 
-LIBBPF_API int bpf_map__fd(struct bpf_map *map);
-LIBBPF_API const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
-LIBBPF_API const char *bpf_map__name(struct bpf_map *map);
+LIBBPF_API int bpf_map__fd(const struct bpf_map *map);
+LIBBPF_API const struct bpf_map_def *bpf_map__def(const struct bpf_map *map);
+LIBBPF_API const char *bpf_map__name(const struct bpf_map *map);
 LIBBPF_API __u32 bpf_map__btf_key_type_id(const struct bpf_map *map);
 LIBBPF_API __u32 bpf_map__btf_value_type_id(const struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 LIBBPF_API int bpf_map__set_priv(struct bpf_map *map, void *priv,
 				 bpf_map_clear_priv_t clear_priv);
-LIBBPF_API void *bpf_map__priv(struct bpf_map *map);
+LIBBPF_API void *bpf_map__priv(const struct bpf_map *map);
 LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
 LIBBPF_API int bpf_map__resize(struct bpf_map *map, __u32 max_entries);
-LIBBPF_API bool bpf_map__is_offload_neutral(struct bpf_map *map);
-LIBBPF_API bool bpf_map__is_internal(struct bpf_map *map);
+LIBBPF_API bool bpf_map__is_offload_neutral(const struct bpf_map *map);
+LIBBPF_API bool bpf_map__is_internal(const struct bpf_map *map);
 LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
 LIBBPF_API int bpf_map__unpin(struct bpf_map *map, const char *path);

commit 6446b3155521aab37f5a2b99ac264803ea7dced8
Author: Hechao Li <hechaol@fb.com>
Date:   Mon Jun 10 17:56:50 2019 -0700

    bpf: add a new API libbpf_num_possible_cpus()
    
    Adding a new API libbpf_num_possible_cpus() that helps user with
    per-CPU map operations.
    
    Signed-off-by: Hechao Li <hechaol@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1af0d48178c8..2e594a0fa961 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -454,6 +454,22 @@ bpf_program__bpil_addr_to_offs(struct bpf_prog_info_linear *info_linear);
 LIBBPF_API void
 bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear);
 
+/*
+ * A helper function to get the number of possible CPUs before looking up
+ * per-CPU maps. Negative errno is returned on failure.
+ *
+ * Example usage:
+ *
+ *     int ncpus = libbpf_num_possible_cpus();
+ *     if (ncpus < 0) {
+ *          // error handling
+ *     }
+ *     long values[ncpus];
+ *     bpf_map_lookup_elem(per_cpu_map_fd, key, values);
+ *
+ */
+LIBBPF_API int libbpf_num_possible_cpus(void);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit 60276f9849988d3d3a54943c9ec27222c5819dae
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Fri May 24 11:36:47 2019 +0100

    libbpf: add bpf_object__load_xattr() API function to pass log_level
    
    libbpf was recently made aware of the log_level attribute for programs,
    used to specify the level of information expected to be dumped by the
    verifier. Function bpf_prog_load_xattr() got support for this log_level
    parameter.
    
    But some applications using libbpf rely on another function to load
    programs, bpf_object__load(), which does accept any parameter for log
    level. Create an API function based on bpf_object__load(), but accepting
    an "attr" object as a parameter. Then add a log_level field to that
    object, so that applications calling the new bpf_object__load_xattr()
    can pick the desired log level.
    
    v3:
    - Rewrite commit log.
    
    v2:
    - We are in a new cycle, bump libbpf extraversion number.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 5abc2375defd..1af0d48178c8 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -89,8 +89,14 @@ LIBBPF_API int bpf_object__unpin_programs(struct bpf_object *obj,
 LIBBPF_API int bpf_object__pin(struct bpf_object *object, const char *path);
 LIBBPF_API void bpf_object__close(struct bpf_object *object);
 
+struct bpf_object_load_attr {
+	struct bpf_object *obj;
+	int log_level;
+};
+
 /* Load/unload object into/from kernel */
 LIBBPF_API int bpf_object__load(struct bpf_object *obj);
+LIBBPF_API int bpf_object__load_xattr(struct bpf_object_load_attr *attr);
 LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
 LIBBPF_API const char *bpf_object__name(struct bpf_object *obj);
 LIBBPF_API unsigned int bpf_object__kversion(struct bpf_object *obj);

commit 046561981b948e07df096a8402f9efc80bc784d9
Author: Jiong Wang <jiong.wang@netronome.com>
Date:   Fri May 24 23:25:19 2019 +0100

    libbpf: add "prog_flags" to bpf_program/bpf_prog_load_attr/bpf_load_program_attr
    
    libbpf doesn't allow passing "prog_flags" during bpf program load in a
    couple of load related APIs, "bpf_load_program_xattr", "load_program" and
    "bpf_prog_load_xattr".
    
    It makes sense to allow passing "prog_flags" which is useful for
    customizing program loading.
    
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index c5ff00515ce7..5abc2375defd 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -320,6 +320,7 @@ struct bpf_prog_load_attr {
 	enum bpf_attach_type expected_attach_type;
 	int ifindex;
 	int log_level;
+	int prog_flags;
 };
 
 LIBBPF_API int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,

commit 1713d68b3bf039d029afd74653c9325f5003ccbe
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Tue Apr 9 23:20:14 2019 +0200

    bpf, libbpf: add support for BTF Var and DataSec
    
    This adds libbpf support for BTF Var and DataSec kinds. Main point
    here is that libbpf needs to do some preparatory work before the
    whole BTF object can be loaded into the kernel, that is, fixing up
    of DataSec size taken from the ELF section size and non-static
    variable offset which needs to be taken from the ELF's string section.
    
    Upstream LLVM doesn't fix these up since at time of BTF emission
    it is too early in the compilation process thus this information
    isn't available yet, hence loader needs to take care of it.
    
    Note, deduplication handling has not been in the scope of this work
    and needs to be addressed in a future commit.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://reviews.llvm.org/D59441
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 12db2822c8e7..c5ff00515ce7 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -75,6 +75,10 @@ struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 						      size_t obj_buf_sz,
 						      const char *name);
+int bpf_object__section_size(const struct bpf_object *obj, const char *name,
+			     __u32 *size);
+int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
+				__u32 *off);
 LIBBPF_API int bpf_object__pin_maps(struct bpf_object *obj, const char *path);
 LIBBPF_API int bpf_object__unpin_maps(struct bpf_object *obj,
 				      const char *path);

commit d859900c4c56dc4f0f8894c92a01dad86917453e
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Tue Apr 9 23:20:13 2019 +0200

    bpf, libbpf: support global data/bss/rodata sections
    
    This work adds BPF loader support for global data sections
    to libbpf. This allows to write BPF programs in more natural
    C-like way by being able to define global variables and const
    data.
    
    Back at LPC 2018 [0] we presented a first prototype which
    implemented support for global data sections by extending BPF
    syscall where union bpf_attr would get additional memory/size
    pair for each section passed during prog load in order to later
    add this base address into the ldimm64 instruction along with
    the user provided offset when accessing a variable. Consensus
    from LPC was that for proper upstream support, it would be
    more desirable to use maps instead of bpf_attr extension as
    this would allow for introspection of these sections as well
    as potential live updates of their content. This work follows
    this path by taking the following steps from loader side:
    
     1) In bpf_object__elf_collect() step we pick up ".data",
        ".rodata", and ".bss" section information.
    
     2) If present, in bpf_object__init_internal_map() we add
        maps to the obj's map array that corresponds to each
        of the present sections. Given section size and access
        properties can differ, a single entry array map is
        created with value size that is corresponding to the
        ELF section size of .data, .bss or .rodata. These
        internal maps are integrated into the normal map
        handling of libbpf such that when user traverses all
        obj maps, they can be differentiated from user-created
        ones via bpf_map__is_internal(). In later steps when
        we actually create these maps in the kernel via
        bpf_object__create_maps(), then for .data and .rodata
        sections their content is copied into the map through
        bpf_map_update_elem(). For .bss this is not necessary
        since array map is already zero-initialized by default.
        Additionally, for .rodata the map is frozen as read-only
        after setup, such that neither from program nor syscall
        side writes would be possible.
    
     3) In bpf_program__collect_reloc() step, we record the
        corresponding map, insn index, and relocation type for
        the global data.
    
     4) And last but not least in the actual relocation step in
        bpf_program__relocate(), we mark the ldimm64 instruction
        with src_reg = BPF_PSEUDO_MAP_VALUE where in the first
        imm field the map's file descriptor is stored as similarly
        done as in BPF_PSEUDO_MAP_FD, and in the second imm field
        (as ldimm64 is 2-insn wide) we store the access offset
        into the section. Given these maps have only single element
        ldimm64's off remains zero in both parts.
    
     5) On kernel side, this special marked BPF_PSEUDO_MAP_VALUE
        load will then store the actual target address in order
        to have a 'map-lookup'-free access. That is, the actual
        map value base address + offset. The destination register
        in the verifier will then be marked as PTR_TO_MAP_VALUE,
        containing the fixed offset as reg->off and backing BPF
        map as reg->map_ptr. Meaning, it's treated as any other
        normal map value from verification side, only with
        efficient, direct value access instead of actual call to
        map lookup helper as in the typical case.
    
    Currently, only support for static global variables has been
    added, and libbpf rejects non-static global variables from
    loading. This can be lifted until we have proper semantics
    for how BPF will treat multi-object BPF loads. From BTF side,
    libbpf will set the value type id of the types corresponding
    to the ".bss", ".data" and ".rodata" names which LLVM will
    emit without the object name prefix. The key type will be
    left as zero, thus making use of the key-less BTF option in
    array maps.
    
    Simple example dump of program using globals vars in each
    section:
    
      # bpftool prog
      [...]
      6784: sched_cls  name load_static_dat  tag a7e1291567277844  gpl
            loaded_at 2019-03-11T15:39:34+0000  uid 0
            xlated 1776B  jited 993B  memlock 4096B  map_ids 2238,2237,2235,2236,2239,2240
    
      # bpftool map show id 2237
      2237: array  name test_glo.bss  flags 0x0
            key 4B  value 64B  max_entries 1  memlock 4096B
      # bpftool map show id 2235
      2235: array  name test_glo.data  flags 0x0
            key 4B  value 64B  max_entries 1  memlock 4096B
      # bpftool map show id 2236
      2236: array  name test_glo.rodata  flags 0x80
            key 4B  value 96B  max_entries 1  memlock 4096B
    
      # bpftool prog dump xlated id 6784
      int load_static_data(struct __sk_buff * skb):
      ; int load_static_data(struct __sk_buff *skb)
         0: (b7) r6 = 0
      ; test_reloc(number, 0, &num0);
         1: (63) *(u32 *)(r10 -4) = r6
         2: (bf) r2 = r10
      ; int load_static_data(struct __sk_buff *skb)
         3: (07) r2 += -4
      ; test_reloc(number, 0, &num0);
         4: (18) r1 = map[id:2238]
         6: (18) r3 = map[id:2237][0]+0    <-- direct addr in .bss area
         8: (b7) r4 = 0
         9: (85) call array_map_update_elem#100464
        10: (b7) r1 = 1
      ; test_reloc(number, 1, &num1);
      [...]
      ; test_reloc(string, 2, str2);
       120: (18) r8 = map[id:2237][0]+16   <-- same here at offset +16
       122: (18) r1 = map[id:2239]
       124: (18) r3 = map[id:2237][0]+16
       126: (b7) r4 = 0
       127: (85) call array_map_update_elem#100464
       128: (b7) r1 = 120
      ; str1[5] = 'x';
       129: (73) *(u8 *)(r9 +5) = r1
      ; test_reloc(string, 3, str1);
       130: (b7) r1 = 3
       131: (63) *(u32 *)(r10 -4) = r1
       132: (b7) r9 = 3
       133: (bf) r2 = r10
      ; int load_static_data(struct __sk_buff *skb)
       134: (07) r2 += -4
      ; test_reloc(string, 3, str1);
       135: (18) r1 = map[id:2239]
       137: (18) r3 = map[id:2235][0]+16   <-- direct addr in .data area
       139: (b7) r4 = 0
       140: (85) call array_map_update_elem#100464
       141: (b7) r1 = 111
      ; __builtin_memcpy(&str2[2], "hello", sizeof("hello"));
       142: (73) *(u8 *)(r8 +6) = r1       <-- further access based on .bss data
       143: (b7) r1 = 108
       144: (73) *(u8 *)(r8 +5) = r1
      [...]
    
    For Cilium use-case in particular, this enables migrating configuration
    constants from Cilium daemon's generated header defines into global
    data sections such that expensive runtime recompilations with LLVM can
    be avoided altogether. Instead, the ELF file becomes effectively a
    "template", meaning, it is compiled only once (!) and the Cilium daemon
    will then rewrite relevant configuration data from the ELF's .data or
    .rodata sections directly instead of recompiling the program. The
    updated ELF is then loaded into the kernel and atomically replaces
    the existing program in the networking datapath. More info in [0].
    
    Based upon recent fix in LLVM, commit c0db6b6bd444 ("[BPF] Don't fail
    for static variables").
    
      [0] LPC 2018, BPF track, "ELF relocation for static data in BPF",
          http://vger.kernel.org/lpc-bpf2018.html#session-3
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 531323391d07..12db2822c8e7 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -301,6 +301,7 @@ LIBBPF_API void *bpf_map__priv(struct bpf_map *map);
 LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
 LIBBPF_API int bpf_map__resize(struct bpf_map *map, __u32 max_entries);
 LIBBPF_API bool bpf_map__is_offload_neutral(struct bpf_map *map);
+LIBBPF_API bool bpf_map__is_internal(struct bpf_map *map);
 LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
 LIBBPF_API int bpf_map__unpin(struct bpf_map *map, const char *path);

commit da11b417583ece875f862d84578259a2ab27ad86
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Mon Apr 1 21:27:47 2019 -0700

    libbpf: teach libbpf about log_level bit 2
    
    Allow bpf_prog_load_xattr() to specify log_level for program loading.
    
    Teach libbpf to accept log_level with bit 2 set.
    
    Increase default BPF_LOG_BUF_SIZE from 256k to 16M.
    There is no downside to increase it to a maximum allowed by old kernels.
    Existing 256k limit caused ENOSPC errors and users were not able to see
    verifier error which is printed at the end of the verifier log.
    
    If ENOSPC is hit, double the verifier log and try again to capture
    the verifier error.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index c70785cc8ef5..531323391d07 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -314,6 +314,7 @@ struct bpf_prog_load_attr {
 	enum bpf_prog_type prog_type;
 	enum bpf_attach_type expected_attach_type;
 	int ifindex;
+	int log_level;
 };
 
 LIBBPF_API int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,

commit 34be16466d4dc06f3d604dafbcdb3327b72e78da
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Mar 11 22:30:38 2019 -0700

    tools lib bpf: Introduce bpf_program__get_prog_info_linear()
    
    Currently, bpf_prog_info includes 9 arrays. The user has the option to
    fetch any combination of these arrays. However, this requires a lot of
    handling.
    
    This work becomes more tricky when we need to store bpf_prog_info to a
    file, because these arrays are allocated independently.
    
    This patch introduces 'struct bpf_prog_info_linear', which stores arrays
    of bpf_prog_info in continuous memory.
    
    Helper functions are introduced to unify the work to get different sets
    of bpf_prog_info.  Specifically, bpf_program__get_prog_info_linear()
    allows the user to select which arrays to fetch, and handles details for
    the user.
    
    Please see the comments right before 'enum bpf_prog_info_array' for more
    details and examples.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Jiri Olsa <jolsa@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lkml.kernel.org/r/ce92c091-e80d-a0c1-4aa0-987706c42b20@iogearbox.net
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: kernel-team@fb.com
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stanislav Fomichev <sdf@google.com>
    Link: http://lkml.kernel.org/r/20190312053051.2690567-3-songliubraving@fb.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index aa1521a51687..c70785cc8ef5 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -378,6 +378,69 @@ LIBBPF_API bool bpf_probe_map_type(enum bpf_map_type map_type, __u32 ifindex);
 LIBBPF_API bool bpf_probe_helper(enum bpf_func_id id,
 				 enum bpf_prog_type prog_type, __u32 ifindex);
 
+/*
+ * Get bpf_prog_info in continuous memory
+ *
+ * struct bpf_prog_info has multiple arrays. The user has option to choose
+ * arrays to fetch from kernel. The following APIs provide an uniform way to
+ * fetch these data. All arrays in bpf_prog_info are stored in a single
+ * continuous memory region. This makes it easy to store the info in a
+ * file.
+ *
+ * Before writing bpf_prog_info_linear to files, it is necessary to
+ * translate pointers in bpf_prog_info to offsets. Helper functions
+ * bpf_program__bpil_addr_to_offs() and bpf_program__bpil_offs_to_addr()
+ * are introduced to switch between pointers and offsets.
+ *
+ * Examples:
+ *   # To fetch map_ids and prog_tags:
+ *   __u64 arrays = (1UL << BPF_PROG_INFO_MAP_IDS) |
+ *           (1UL << BPF_PROG_INFO_PROG_TAGS);
+ *   struct bpf_prog_info_linear *info_linear =
+ *           bpf_program__get_prog_info_linear(fd, arrays);
+ *
+ *   # To save data in file
+ *   bpf_program__bpil_addr_to_offs(info_linear);
+ *   write(f, info_linear, sizeof(*info_linear) + info_linear->data_len);
+ *
+ *   # To read data from file
+ *   read(f, info_linear, <proper_size>);
+ *   bpf_program__bpil_offs_to_addr(info_linear);
+ */
+enum bpf_prog_info_array {
+	BPF_PROG_INFO_FIRST_ARRAY = 0,
+	BPF_PROG_INFO_JITED_INSNS = 0,
+	BPF_PROG_INFO_XLATED_INSNS,
+	BPF_PROG_INFO_MAP_IDS,
+	BPF_PROG_INFO_JITED_KSYMS,
+	BPF_PROG_INFO_JITED_FUNC_LENS,
+	BPF_PROG_INFO_FUNC_INFO,
+	BPF_PROG_INFO_LINE_INFO,
+	BPF_PROG_INFO_JITED_LINE_INFO,
+	BPF_PROG_INFO_PROG_TAGS,
+	BPF_PROG_INFO_LAST_ARRAY,
+};
+
+struct bpf_prog_info_linear {
+	/* size of struct bpf_prog_info, when the tool is compiled */
+	__u32			info_len;
+	/* total bytes allocated for data, round up to 8 bytes */
+	__u32			data_len;
+	/* which arrays are included in data */
+	__u64			arrays;
+	struct bpf_prog_info	info;
+	__u8			data[];
+};
+
+LIBBPF_API struct bpf_prog_info_linear *
+bpf_program__get_prog_info_linear(int fd, __u64 arrays);
+
+LIBBPF_API void
+bpf_program__bpil_addr_to_offs(struct bpf_prog_info_linear *info_linear);
+
+LIBBPF_API void
+bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit dfcbc2f2994b8a3af3605a26dc29c07ad7378bf4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 11 17:07:52 2019 -0300

    tools lib bpf: Fix the build by adding a missing stdarg.h include
    
    The libbpf_print_fn_t typedef uses va_list without including the header
    where that type is defined, stdarg.h, breaking in places where we're
    unlucky for that type not to be already defined by some previously
    included header.
    
    Noticed while building on fedora 24 cross building tools/perf to the ARC
    architecture using the uClibc C library:
    
      28 fedora:24-x-ARC-uClibc   : FAIL arc-linux-gcc (ARCompact ISA Linux uClibc toolchain 2017.09-rc2) 7.1.1 20170710
    
        CC       /tmp/build/perf/tests/llvm.o
      In file included from tests/llvm.c:3:0:
      /git/linux/tools/lib/bpf/libbpf.h:57:20: error: unknown type name 'va_list'
            const char *, va_list ap);
                          ^~~~~~~
      /git/linux/tools/lib/bpf/libbpf.h:59:34: error: unknown type name 'libbpf_print_fn_t'
       LIBBPF_API void libbpf_set_print(libbpf_print_fn_t fn);
                                        ^~~~~~~~~~~~~~~~~
      mv: cannot stat '/tmp/build/perf/tests/.llvm.o.tmp': No such file or directory
    
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Jakub Kicinski <jakub.kicinski@netronome.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Quentin Monnet <quentin.monnet@netronome.com>
    Cc: Stanislav Fomichev <sdf@google.com>
    Cc: Yonghong Song <yhs@fb.com>
    Fixes: a8a1f7d09cfc ("libbpf: fix libbpf_print")
    Link: https://lkml.kernel.org/n/tip-5270n2quu2gqz22o7itfdx00@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index b4652aa1a58a..aa1521a51687 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -10,6 +10,7 @@
 #ifndef __LIBBPF_LIBBPF_H
 #define __LIBBPF_LIBBPF_H
 
+#include <stdarg.h>
 #include <stdio.h>
 #include <stdint.h>
 #include <stdbool.h>

commit f74a53d9a567f6bc6f6d8460e84c76bd2a45d016
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Feb 27 19:04:12 2019 -0800

    tools: libbpf: add a correctly named define for map iteration
    
    For historical reasons the helper to loop over maps in an object
    is called bpf_map__for_each while it really should be called
    bpf_object__for_each_map.  Rename and add a correctly named
    define for backward compatibility.
    
    Switch all in-tree users to the correct name (Quentin).
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 6c0168f8bba5..b4652aa1a58a 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -278,10 +278,11 @@ bpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset);
 
 LIBBPF_API struct bpf_map *
 bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
-#define bpf_map__for_each(pos, obj)		\
+#define bpf_object__for_each_map(pos, obj)		\
 	for ((pos) = bpf_map__next(NULL, (obj));	\
 	     (pos) != NULL;				\
 	     (pos) = bpf_map__next((pos), (obj)))
+#define bpf_map__for_each bpf_object__for_each_map
 
 LIBBPF_API struct bpf_map *
 bpf_map__prev(struct bpf_map *map, struct bpf_object *obj);

commit 789f6bab849e04ea029c09b81dc8401dc0268cf9
Author: Andrey Ignatov <rdna@fb.com>
Date:   Thu Feb 14 15:01:43 2019 -0800

    libbpf: Introduce bpf_object__btf
    
    Add new accessor for bpf_object to get opaque struct btf * from it.
    
    struct btf * is needed for all operations with BTF and it's present in
    bpf_object. The only thing missing is a way to get it.
    
    Example use-case is to get BTF key_type_id and value_type_id for a map in
    bpf_object. It can be done with btf__get_map_kv_tids() but that function
    requires struct btf *.
    
    Similar API can be added for struct btf_ext but no use-case for it yet.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 987fd92661d6..6c0168f8bba5 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -89,6 +89,9 @@ LIBBPF_API int bpf_object__load(struct bpf_object *obj);
 LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
 LIBBPF_API const char *bpf_object__name(struct bpf_object *obj);
 LIBBPF_API unsigned int bpf_object__kversion(struct bpf_object *obj);
+
+struct btf;
+LIBBPF_API struct btf *bpf_object__btf(struct bpf_object *obj);
 LIBBPF_API int bpf_object__btf_fd(const struct bpf_object *obj);
 
 LIBBPF_API struct bpf_program *

commit 1a11a4c74f73adb840d61371c3bb560ed4d7a87f
Author: Andrey Ignatov <rdna@fb.com>
Date:   Thu Feb 14 15:01:42 2019 -0800

    libbpf: Introduce bpf_map__resize
    
    Add bpf_map__resize() to change max_entries for a map.
    
    Quite often necessary map size is unknown at compile time and can be
    calculated only at run time.
    
    Currently the following approach is used to do so:
    * bpf_object__open_buffer() to open Elf file from a buffer;
    * bpf_object__find_map_by_name() to find relevant map;
    * bpf_map__def() to get map attributes and create struct
      bpf_create_map_attr from them;
    * update max_entries in bpf_create_map_attr;
    * bpf_create_map_xattr() to create new map with updated max_entries;
    * bpf_map__reuse_fd() to replace the map in bpf_object with newly
      created one.
    
    And after all this bpf_object can finally be loaded. The map will have
    new size.
    
    It 1) is quite a lot of steps; 2) doesn't take BTF into account.
    
    For "2)" even more steps should be made and some of them require changes
    to libbpf (e.g. to get struct btf * from bpf_object).
    
    Instead the whole problem can be solved by introducing simple
    bpf_map__resize() API that checks the map and sets new max_entries if
    the map is not loaded yet.
    
    So the new steps are:
    * bpf_object__open_buffer() to open Elf file from a buffer;
    * bpf_object__find_map_by_name() to find relevant map;
    * bpf_map__resize() to update max_entries.
    
    That's much simpler and works with BTF.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 69a7c25eaccc..987fd92661d6 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -294,6 +294,7 @@ LIBBPF_API int bpf_map__set_priv(struct bpf_map *map, void *priv,
 				 bpf_map_clear_priv_t clear_priv);
 LIBBPF_API void *bpf_map__priv(struct bpf_map *map);
 LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
+LIBBPF_API int bpf_map__resize(struct bpf_map *map, __u32 max_entries);
 LIBBPF_API bool bpf_map__is_offload_neutral(struct bpf_map *map);
 LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);

commit a8a1f7d09cfc7e18874786c7634c9e71384fcd4e
Author: Stanislav Fomichev <sdf@google.com>
Date:   Mon Feb 4 16:20:55 2019 -0800

    libbpf: fix libbpf_print
    
    With the recent print rework we now have the following problem:
    pr_{warning,info,debug} expand to __pr which calls libbpf_print.
    libbpf_print does va_start and calls __libbpf_pr with va_list argument.
    In __base_pr we again do va_start. Because the next argument is a
    va_list, we don't get correct pointer to the argument (and print noting
    in my case, I don't know why it doesn't crash tbh).
    
    Fix this by changing libbpf_print_fn_t signature to accept va_list and
    remove unneeded calls to va_start in the existing users.
    
    Alternatively, this can we solved by exporting __libbpf_pr and
    changing __pr macro to (and killing libbpf_print):
    {
            if (__libbpf_pr)
                    __libbpf_pr(level, "libbpf: " fmt, ##__VA_ARGS__)
    }
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 19dbc1bed960..69a7c25eaccc 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -54,8 +54,7 @@ enum libbpf_print_level {
 };
 
 typedef int (*libbpf_print_fn_t)(enum libbpf_print_level level,
-				 const char *, ...)
-	__attribute__((format(printf, 2, 3)));
+				 const char *, va_list ap);
 
 LIBBPF_API void libbpf_set_print(libbpf_print_fn_t fn);
 

commit 6f1ae8b6628b9e054d3a8c959cf472234944a578
Author: Yonghong Song <yhs@fb.com>
Date:   Fri Feb 1 16:14:17 2019 -0800

    tools/bpf: simplify libbpf API function libbpf_set_print()
    
    Currently, the libbpf API function libbpf_set_print()
    takes three function pointer parameters for warning, info
    and debug printout respectively.
    
    This patch changes the API to have just one function pointer
    parameter and the function pointer has one additional
    parameter "debugging level". So if in the future, if
    the debug level is increased, the function signature
    won't change.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 0fb32cc04633..19dbc1bed960 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -53,17 +53,11 @@ enum libbpf_print_level {
         LIBBPF_DEBUG,
 };
 
-/*
- * __printf is defined in include/linux/compiler-gcc.h. However,
- * it would be better if libbpf.h didn't depend on Linux header files.
- * So instead of __printf, here we use gcc attribute directly.
- */
-typedef int (*libbpf_print_fn_t)(const char *, ...)
-	__attribute__((format(printf, 1, 2)));
+typedef int (*libbpf_print_fn_t)(enum libbpf_print_level level,
+				 const char *, ...)
+	__attribute__((format(printf, 2, 3)));
 
-LIBBPF_API void libbpf_set_print(libbpf_print_fn_t warn,
-				 libbpf_print_fn_t info,
-				 libbpf_print_fn_t debug);
+LIBBPF_API void libbpf_set_print(libbpf_print_fn_t fn);
 
 /* Hide internal to user */
 struct bpf_object;

commit 8461ef8b7ef286212ca954d8b82dac3ceecb219d
Author: Yonghong Song <yhs@fb.com>
Date:   Fri Feb 1 16:14:14 2019 -0800

    tools/bpf: move libbpf pr_* debug print functions to headers
    
    A global function libbpf_print, which is invisible
    outside the shared library, is defined to print based
    on levels. The pr_warning, pr_info and pr_debug
    macros are moved into the newly created header
    common.h. So any .c file including common.h can
    use these macros directly.
    
    Currently btf__new and btf_ext__new API has an argument getting
    __pr_debug function pointer into btf.c so the debugging information
    can be printed there. This patch removed this parameter
    from btf__new and btf_ext__new and directly using pr_debug in btf.c.
    
    Another global function libbpf_print_level_available, also
    invisible outside the shared library, can test
    whether a particular level debug printing is
    available or not. It is used in btf.c to
    test whether DEBUG level debug printing is availabl or not,
    based on which the log buffer will be allocated when loading
    btf to the kernel.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 43c77e98df6f..0fb32cc04633 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -47,6 +47,12 @@ enum libbpf_errno {
 
 LIBBPF_API int libbpf_strerror(int err, char *buf, size_t size);
 
+enum libbpf_print_level {
+        LIBBPF_WARN,
+        LIBBPF_INFO,
+        LIBBPF_DEBUG,
+};
+
 /*
  * __printf is defined in include/linux/compiler-gcc.h. However,
  * it would be better if libbpf.h didn't depend on Linux header files.

commit 50db9f0731889b9f3839cab5f44163733eb44f04
Author: Maciej Fijalkowski <maciejromanfijalkowski@gmail.com>
Date:   Fri Feb 1 22:42:29 2019 +0100

    libbpf: Add a support for getting xdp prog id on ifindex
    
    Since we have a dedicated netlink attributes for xdp setup on a
    particular interface, it is now possible to retrieve the program id that
    is currently attached to the interface. The use case is targeted for
    sample xdp programs, which will store the program id just after loading
    bpf program onto iface. On shutdown, the sample will make sure that it
    can unload the program by querying again the iface and verifying that
    both program id's matches.
    
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 931be6f3408c..43c77e98df6f 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -317,6 +317,7 @@ LIBBPF_API int bpf_prog_load(const char *file, enum bpf_prog_type type,
 			     struct bpf_object **pobj, int *prog_fd);
 
 LIBBPF_API int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
+LIBBPF_API int bpf_get_link_xdp_id(int ifindex, __u32 *prog_id, __u32 flags);
 
 enum bpf_perf_event_ret {
 	LIBBPF_PERF_EVENT_DONE	= 0,

commit f3cea32d56e96c510af454616104e3979f7626dd
Author: Maciej Fijalkowski <maciejromanfijalkowski@gmail.com>
Date:   Fri Feb 1 22:42:23 2019 +0100

    libbpf: Add a helper for retrieving a map fd for a given name
    
    XDP samples are mostly cooperating with eBPF maps through their file
    descriptors. In case of a eBPF program that contains multiple maps it
    might be tiresome to iterate through them and call bpf_map__fd for each
    one. Add a helper mostly based on bpf_object__find_map_by_name, but
    instead of returning the struct bpf_map pointer, return map fd.
    
    Suggested-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 62ae6cb93da1..931be6f3408c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -264,6 +264,9 @@ struct bpf_map;
 LIBBPF_API struct bpf_map *
 bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
 
+LIBBPF_API int
+bpf_object__find_map_fd_by_name(struct bpf_object *obj, const char *name);
+
 /*
  * Get bpf_map through the offset of corresponding struct bpf_map_def
  * in the BPF object file.

commit 2d3ea5e85dd867712ba8747cb01c2d88376ead5c
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Jan 17 15:27:55 2019 +0000

    tools: bpftool: add probes for eBPF helper functions
    
    Similarly to what was done for program types and map types, add a set of
    probes to test the availability of the different eBPF helper functions
    on the current system.
    
    For each known program type, all known helpers are tested, in order to
    establish a compatibility matrix. Output is provided as a set of lists
    of available helpers, one per program type.
    
    Sample output:
    
        # bpftool feature probe kernel
        ...
        Scanning eBPF helper functions...
        eBPF helpers supported for program type socket_filter:
                - bpf_map_lookup_elem
                - bpf_map_update_elem
                - bpf_map_delete_elem
        ...
        eBPF helpers supported for program type kprobe:
                - bpf_map_lookup_elem
                - bpf_map_update_elem
                - bpf_map_delete_elem
        ...
    
        # bpftool --json --pretty feature probe kernel
        {
            ...
            "helpers": {
                "socket_filter_available_helpers": ["bpf_map_lookup_elem", \
                        "bpf_map_update_elem","bpf_map_delete_elem", ...
                ],
                "kprobe_available_helpers": ["bpf_map_lookup_elem", \
                        "bpf_map_update_elem","bpf_map_delete_elem", ...
                ],
                ...
            }
        }
    
    v5:
    - In libbpf.map, move global symbol to the new LIBBPF_0.0.2 section.
    
    v4:
    - Use "enum bpf_func_id" instead of "__u32" in bpf_probe_helper()
      declaration for the type of the argument used to pass the id of
      the helper to probe.
    - Undef BPF_HELPER_MAKE_ENTRY after using it.
    
    v3:
    - Do not pass kernel version from bpftool to libbpf probes (kernel
      version for testing program with kprobes is retrieved directly from
      libbpf).
    - Dump one list of available helpers per program type (instead of one
      list of compatible program types per helper).
    
    v2:
    - Move probes from bpftool to libbpf.
    - Test all program types for each helper, print a list of working prog
      types for each helper.
    - Fall back on include/uapi/linux/bpf.h for names and ids of helpers.
    - Remove C-style macros output from this patch.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 72385f6f9415..62ae6cb93da1 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -366,6 +366,8 @@ bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo,
 LIBBPF_API bool bpf_probe_prog_type(enum bpf_prog_type prog_type,
 				    __u32 ifindex);
 LIBBPF_API bool bpf_probe_map_type(enum bpf_map_type map_type, __u32 ifindex);
+LIBBPF_API bool bpf_probe_helper(enum bpf_func_id id,
+				 enum bpf_prog_type prog_type, __u32 ifindex);
 
 #ifdef __cplusplus
 } /* extern "C" */

commit f99e166397f0298fe78bce24c55c6d074f9bf196
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Jan 17 15:27:54 2019 +0000

    tools: bpftool: add probes for eBPF map types
    
    Add new probes for eBPF map types, to detect what are the ones available
    on the system. Try creating one map of each type, and see if the kernel
    complains.
    
    Sample output:
    
        # bpftool feature probe kernel
        ...
        Scanning eBPF map types...
        eBPF map_type hash is available
        eBPF map_type array is available
        eBPF map_type prog_array is available
        ...
    
        # bpftool --json --pretty feature probe kernel
        {
            ...
            "map_types": {
                "have_hash_map_type": true,
                "have_array_map_type": true,
                "have_prog_array_map_type": true,
                ...
            }
        }
    
    v5:
    - In libbpf.map, move global symbol to the new LIBBPF_0.0.2 section.
    
    v3:
    - Use a switch with all enum values for setting specific map parameters,
      so that gcc complains at compile time (-Wswitch-enum) if new map types
      were added to the kernel but libbpf was not updated.
    
    v2:
    - Move probes from bpftool to libbpf.
    - Remove C-style macros output from this patch.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8e63821109ab..72385f6f9415 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -365,6 +365,7 @@ bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo,
  */
 LIBBPF_API bool bpf_probe_prog_type(enum bpf_prog_type prog_type,
 				    __u32 ifindex);
+LIBBPF_API bool bpf_probe_map_type(enum bpf_map_type map_type, __u32 ifindex);
 
 #ifdef __cplusplus
 } /* extern "C" */

commit 1bf4b05810fe38c5f09973295e8d4234a4fd5d87
Author: Quentin Monnet <quentin.monnet@netronome.com>
Date:   Thu Jan 17 15:27:53 2019 +0000

    tools: bpftool: add probes for eBPF program types
    
    Introduce probes for supported BPF program types in libbpf, and call it
    from bpftool to test what types are available on the system. The probe
    simply consists in loading a very basic program of that type and see if
    the verifier complains or not.
    
    Sample output:
    
        # bpftool feature probe kernel
        ...
        Scanning eBPF program types...
        eBPF program_type socket_filter is available
        eBPF program_type kprobe is available
        eBPF program_type sched_cls is available
        ...
    
        # bpftool --json --pretty feature probe kernel
        {
            ...
            "program_types": {
                "have_socket_filter_prog_type": true,
                "have_kprobe_prog_type": true,
                "have_sched_cls_prog_type": true,
                ...
            }
        }
    
    v5:
    - In libbpf.map, move global symbol to a new LIBBPF_0.0.2 section.
    - Rename (non-API function) prog_load() as probe_load().
    
    v3:
    - Get kernel version for checking kprobes availability from libbpf
      instead of from bpftool. Do not pass kernel_version as an argument
      when calling libbpf probes.
    - Use a switch with all enum values for setting specific program
      parameters just before probing, so that gcc complains at compile time
      (-Wswitch-enum) if new prog types were added to the kernel but libbpf
      was not updated.
    - Add a comment in libbpf.h about setrlimit() usage to allow many
      consecutive probe attempts.
    
    v2:
    - Move probes from bpftool to libbpf.
    - Remove C-style macros output from this patch.
    
    Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 5f68d7b75215..8e63821109ab 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -355,6 +355,17 @@ LIBBPF_API const struct bpf_line_info *
 bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo,
 		      __u32 insn_off, __u32 nr_skip);
 
+/*
+ * Probe for supported system features
+ *
+ * Note that running many of these probes in a short amount of time can cause
+ * the kernel to reach the maximal size of lockable memory allowed for the
+ * user, causing subsequent probes to fail. In this case, the caller may want
+ * to adjust that limit with setrlimit().
+ */
+LIBBPF_API bool bpf_probe_prog_type(enum bpf_prog_type prog_type,
+				    __u32 ifindex);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit b053b439b72ad152257ecc3f71cfb4c619b0137e
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Fri Dec 7 16:42:32 2018 -0800

    bpf: libbpf: bpftool: Print bpf_line_info during prog dump
    
    This patch adds print bpf_line_info function in 'prog dump jitted'
    and 'prog dump xlated':
    
    [root@arch-fb-vm1 bpf]# ~/devshare/fb-kernel/linux/tools/bpf/bpftool/bpftool prog dump jited pinned /sys/fs/bpf/test_btf_haskv
    [...]
    int test_long_fname_2(struct dummy_tracepoint_args * arg):
    bpf_prog_44a040bf25481309_test_long_fname_2:
    ; static int test_long_fname_2(struct dummy_tracepoint_args *arg)
       0:   push   %rbp
       1:   mov    %rsp,%rbp
       4:   sub    $0x30,%rsp
       b:   sub    $0x28,%rbp
       f:   mov    %rbx,0x0(%rbp)
      13:   mov    %r13,0x8(%rbp)
      17:   mov    %r14,0x10(%rbp)
      1b:   mov    %r15,0x18(%rbp)
      1f:   xor    %eax,%eax
      21:   mov    %rax,0x20(%rbp)
      25:   xor    %esi,%esi
    ; int key = 0;
      27:   mov    %esi,-0x4(%rbp)
    ; if (!arg->sock)
      2a:   mov    0x8(%rdi),%rdi
    ; if (!arg->sock)
      2e:   cmp    $0x0,%rdi
      32:   je     0x0000000000000070
      34:   mov    %rbp,%rsi
    ; counts = bpf_map_lookup_elem(&btf_map, &key);
      37:   add    $0xfffffffffffffffc,%rsi
      3b:   movabs $0xffff8881139d7480,%rdi
      45:   add    $0x110,%rdi
      4c:   mov    0x0(%rsi),%eax
      4f:   cmp    $0x4,%rax
      53:   jae    0x000000000000005e
      55:   shl    $0x3,%rax
      59:   add    %rdi,%rax
      5c:   jmp    0x0000000000000060
      5e:   xor    %eax,%eax
    ; if (!counts)
      60:   cmp    $0x0,%rax
      64:   je     0x0000000000000070
    ; counts->v6++;
      66:   mov    0x4(%rax),%edi
      69:   add    $0x1,%rdi
      6d:   mov    %edi,0x4(%rax)
      70:   mov    0x0(%rbp),%rbx
      74:   mov    0x8(%rbp),%r13
      78:   mov    0x10(%rbp),%r14
      7c:   mov    0x18(%rbp),%r15
      80:   add    $0x28,%rbp
      84:   leaveq
      85:   retq
    [...]
    
    With linum:
    [root@arch-fb-vm1 bpf]# ~/devshare/fb-kernel/linux/tools/bpf/bpftool/bpftool prog dump jited pinned /sys/fs/bpf/test_btf_haskv linum
    int _dummy_tracepoint(struct dummy_tracepoint_args * arg):
    bpf_prog_b07ccb89267cf242__dummy_tracepoint:
    ; return test_long_fname_1(arg); [file:/data/users/kafai/fb-kernel/linux/tools/testing/selftests/bpf/test_btf_haskv.c line_num:54 line_col:9]
       0:   push   %rbp
       1:   mov    %rsp,%rbp
       4:   sub    $0x28,%rsp
       b:   sub    $0x28,%rbp
       f:   mov    %rbx,0x0(%rbp)
      13:   mov    %r13,0x8(%rbp)
      17:   mov    %r14,0x10(%rbp)
      1b:   mov    %r15,0x18(%rbp)
      1f:   xor    %eax,%eax
      21:   mov    %rax,0x20(%rbp)
      25:   callq  0x000000000000851e
    ; return test_long_fname_1(arg); [file:/data/users/kafai/fb-kernel/linux/tools/testing/selftests/bpf/test_btf_haskv.c line_num:54 line_col:2]
      2a:   xor    %eax,%eax
      2c:   mov    0x0(%rbp),%rbx
      30:   mov    0x8(%rbp),%r13
      34:   mov    0x10(%rbp),%r14
      38:   mov    0x18(%rbp),%r15
      3c:   add    $0x28,%rbp
      40:   leaveq
      41:   retq
    [...]
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f30c3d07bb7d..5f68d7b75215 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -342,6 +342,19 @@ int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
 int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
 			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
 
+struct bpf_prog_linfo;
+struct bpf_prog_info;
+
+LIBBPF_API void bpf_prog_linfo__free(struct bpf_prog_linfo *prog_linfo);
+LIBBPF_API struct bpf_prog_linfo *
+bpf_prog_linfo__new(const struct bpf_prog_info *info);
+LIBBPF_API const struct bpf_line_info *
+bpf_prog_linfo__lfind_addr_func(const struct bpf_prog_linfo *prog_linfo,
+				__u64 addr, __u32 func_idx, __u32 nr_skip);
+LIBBPF_API const struct bpf_line_info *
+bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo,
+		      __u32 insn_off, __u32 nr_skip);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif

commit addb9fc90f13898e7779da54f471792e3dfb0d55
Author: Nikita V. Shirokov <tehnerd@tehnerd.com>
Date:   Tue Nov 20 20:55:56 2018 -0800

    bpf: adding support for map in map in libbpf
    
    idea is pretty simple. for specified map (pointed by struct bpf_map)
    we would provide descriptor of already loaded map, which is going to be
    used as a prototype for inner map. proposed workflow:
    1) open bpf's object (bpf_object__open)
    2) create bpf's map which is going to be used as a prototype
    3) find (by name) map-in-map which you want to load and update w/
    descriptor of inner map w/ a new helper from this patch
    4) load bpf program w/ bpf_object__load
    
    Signed-off-by: Nikita V. Shirokov <tehnerd@tehnerd.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 74e57e041705..f30c3d07bb7d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -297,6 +297,8 @@ LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
 LIBBPF_API int bpf_map__unpin(struct bpf_map *map, const char *path);
 
+LIBBPF_API int bpf_map__set_inner_map_fd(struct bpf_map *map, int fd);
+
 LIBBPF_API long libbpf_get_error(const void *ptr);
 
 struct bpf_prog_load_attr {

commit 8c4905b995c649ac71e21611abc2fcefc904b56a
Author: Stanislav Fomichev <sdf@google.com>
Date:   Wed Nov 21 09:29:44 2018 -0800

    libbpf: make sure bpf headers are c++ include-able
    
    Wrap headers in extern "C", to turn off C++ mangling.
    This simplifies including libbpf in c++ and linking against it.
    
    v2 changes:
    * do the same for btf.h
    
    v3 changes:
    * test_libbpf.cpp to test for possible future c++ breakages
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index b1686a787102..74e57e041705 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -16,6 +16,10 @@
 #include <sys/types.h>  // for size_t
 #include <linux/bpf.h>
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #ifndef LIBBPF_API
 #define LIBBPF_API __attribute__((visibility("default")))
 #endif
@@ -335,4 +339,9 @@ int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
 			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
 int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
 			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
 #endif /* __LIBBPF_LIBBPF_H */

commit 0c19a9fbc9cdba29c7effb34fd5a97226bf934e6
Author: Stanislav Fomichev <sdf@google.com>
Date:   Fri Nov 9 08:21:41 2018 -0800

    libbpf: cleanup after partial failure in bpf_object__pin
    
    bpftool will use bpf_object__pin in the next commits to pin all programs
    and maps from the file; in case of a partial failure, we need to get
    back to the clean state (undo previous program/map pins).
    
    As part of a cleanup, I've added and exported separate routines to
    pin all maps (bpf_object__pin_maps) and progs (bpf_object__pin_programs)
    of an object.
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1f3468dad8b2..b1686a787102 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -71,6 +71,13 @@ struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 						      size_t obj_buf_sz,
 						      const char *name);
+LIBBPF_API int bpf_object__pin_maps(struct bpf_object *obj, const char *path);
+LIBBPF_API int bpf_object__unpin_maps(struct bpf_object *obj,
+				      const char *path);
+LIBBPF_API int bpf_object__pin_programs(struct bpf_object *obj,
+					const char *path);
+LIBBPF_API int bpf_object__unpin_programs(struct bpf_object *obj,
+					  const char *path);
 LIBBPF_API int bpf_object__pin(struct bpf_object *object, const char *path);
 LIBBPF_API void bpf_object__close(struct bpf_object *object);
 
@@ -112,6 +119,9 @@ LIBBPF_API struct bpf_program *bpf_program__next(struct bpf_program *prog,
 	     (pos) != NULL;				\
 	     (pos) = bpf_program__next((pos), (obj)))
 
+LIBBPF_API struct bpf_program *bpf_program__prev(struct bpf_program *prog,
+						 struct bpf_object *obj);
+
 typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
 					 void *);
 
@@ -131,7 +141,11 @@ LIBBPF_API int bpf_program__fd(struct bpf_program *prog);
 LIBBPF_API int bpf_program__pin_instance(struct bpf_program *prog,
 					 const char *path,
 					 int instance);
+LIBBPF_API int bpf_program__unpin_instance(struct bpf_program *prog,
+					   const char *path,
+					   int instance);
 LIBBPF_API int bpf_program__pin(struct bpf_program *prog, const char *path);
+LIBBPF_API int bpf_program__unpin(struct bpf_program *prog, const char *path);
 LIBBPF_API void bpf_program__unload(struct bpf_program *prog);
 
 struct bpf_insn;
@@ -260,6 +274,9 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 	     (pos) != NULL;				\
 	     (pos) = bpf_map__next((pos), (obj)))
 
+LIBBPF_API struct bpf_map *
+bpf_map__prev(struct bpf_map *map, struct bpf_object *obj);
+
 LIBBPF_API int bpf_map__fd(struct bpf_map *map);
 LIBBPF_API const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 LIBBPF_API const char *bpf_map__name(struct bpf_map *map);
@@ -274,6 +291,7 @@ LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
 LIBBPF_API bool bpf_map__is_offload_neutral(struct bpf_map *map);
 LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
+LIBBPF_API int bpf_map__unpin(struct bpf_map *map, const char *path);
 
 LIBBPF_API long libbpf_get_error(const void *ptr);
 

commit 3dca21156b5f809510e8c3efe7f1046e27242e3d
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Sun Oct 21 02:09:28 2018 +0200

    bpf, libbpf: simplify and cleanup perf ring buffer walk
    
    Simplify bpf_perf_event_read_simple() a bit and fix up some minor
    things along the way: the return code in the header is not of type
    int but enum bpf_perf_event_ret instead. Once callback indicated
    to break the loop walking event data, it also needs to be consumed
    in data_tail since it has been processed already.
    
    Moreover, bpf_perf_event_print_t callback should avoid void * as
    we actually get a pointer to struct perf_event_header and thus
    applications can make use of container_of() to have type checks.
    The walk also doesn't have to use modulo op since the ring size is
    required to be power of two.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1354cc9f8cba..1f3468dad8b2 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -297,13 +297,14 @@ enum bpf_perf_event_ret {
 	LIBBPF_PERF_EVENT_CONT	= -2,
 };
 
-typedef enum bpf_perf_event_ret (*bpf_perf_event_print_t)(void *event,
-							  void *priv);
-LIBBPF_API int bpf_perf_event_read_simple(void *mem, unsigned long size,
-					  unsigned long page_size,
-					  void **buf, size_t *buf_len,
-					  bpf_perf_event_print_t fn,
-					  void *priv);
+struct perf_event_header;
+typedef enum bpf_perf_event_ret
+	(*bpf_perf_event_print_t)(struct perf_event_header *hdr,
+				  void *private_data);
+LIBBPF_API enum bpf_perf_event_ret
+bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
+			   void **copy_mem, size_t *copy_size,
+			   bpf_perf_event_print_t fn, void *private_data);
 
 struct nlattr;
 typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);

commit ab9e084821221b2eda57a512535fe35b49e672d8
Author: Andrey Ignatov <rdna@fb.com>
Date:   Mon Oct 15 22:50:34 2018 -0700

    libbpf: Per-symbol visibility for DSO
    
    Make global symbols in libbpf DSO hidden by default with
    -fvisibility=hidden and export symbols that are part of ABI explicitly
    with __attribute__((visibility("default"))).
    
    This is common practice that should prevent from accidentally exporting
    a symbol, that is not supposed to be a part of ABI what, in turn,
    improves both libbpf developer- and user-experiences. See [1] for more
    details.
    
    Export control becomes more important since more and more projects use
    libbpf.
    
    The patch doesn't export a bunch of netlink related functions since as
    agreed in [2] they'll be reworked. That doesn't break bpftool since
    bpftool links libbpf statically.
    
    [1] https://www.akkadia.org/drepper/dsohowto.pdf (2.2 Export Control)
    [2] https://www.mail-archive.com/netdev@vger.kernel.org/msg251434.html
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 7e9c801a9fdd..1354cc9f8cba 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -16,6 +16,10 @@
 #include <sys/types.h>  // for size_t
 #include <linux/bpf.h>
 
+#ifndef LIBBPF_API
+#define LIBBPF_API __attribute__((visibility("default")))
+#endif
+
 enum libbpf_errno {
 	__LIBBPF_ERRNO__START = 4000,
 
@@ -37,7 +41,7 @@ enum libbpf_errno {
 	__LIBBPF_ERRNO__END,
 };
 
-int libbpf_strerror(int err, char *buf, size_t size);
+LIBBPF_API int libbpf_strerror(int err, char *buf, size_t size);
 
 /*
  * __printf is defined in include/linux/compiler-gcc.h. However,
@@ -47,9 +51,9 @@ int libbpf_strerror(int err, char *buf, size_t size);
 typedef int (*libbpf_print_fn_t)(const char *, ...)
 	__attribute__((format(printf, 1, 2)));
 
-void libbpf_set_print(libbpf_print_fn_t warn,
-		      libbpf_print_fn_t info,
-		      libbpf_print_fn_t debug);
+LIBBPF_API void libbpf_set_print(libbpf_print_fn_t warn,
+				 libbpf_print_fn_t info,
+				 libbpf_print_fn_t debug);
 
 /* Hide internal to user */
 struct bpf_object;
@@ -59,27 +63,28 @@ struct bpf_object_open_attr {
 	enum bpf_prog_type prog_type;
 };
 
-struct bpf_object *bpf_object__open(const char *path);
-struct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr);
+LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
+LIBBPF_API struct bpf_object *
+bpf_object__open_xattr(struct bpf_object_open_attr *attr);
 struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 					    int flags);
-struct bpf_object *bpf_object__open_buffer(void *obj_buf,
-					   size_t obj_buf_sz,
-					   const char *name);
-int bpf_object__pin(struct bpf_object *object, const char *path);
-void bpf_object__close(struct bpf_object *object);
+LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
+						      size_t obj_buf_sz,
+						      const char *name);
+LIBBPF_API int bpf_object__pin(struct bpf_object *object, const char *path);
+LIBBPF_API void bpf_object__close(struct bpf_object *object);
 
 /* Load/unload object into/from kernel */
-int bpf_object__load(struct bpf_object *obj);
-int bpf_object__unload(struct bpf_object *obj);
-const char *bpf_object__name(struct bpf_object *obj);
-unsigned int bpf_object__kversion(struct bpf_object *obj);
-int bpf_object__btf_fd(const struct bpf_object *obj);
+LIBBPF_API int bpf_object__load(struct bpf_object *obj);
+LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
+LIBBPF_API const char *bpf_object__name(struct bpf_object *obj);
+LIBBPF_API unsigned int bpf_object__kversion(struct bpf_object *obj);
+LIBBPF_API int bpf_object__btf_fd(const struct bpf_object *obj);
 
-struct bpf_program *
+LIBBPF_API struct bpf_program *
 bpf_object__find_program_by_title(struct bpf_object *obj, const char *title);
 
-struct bpf_object *bpf_object__next(struct bpf_object *prev);
+LIBBPF_API struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
 	for ((pos) = bpf_object__next(NULL),		\
 		(tmp) = bpf_object__next(pos);		\
@@ -87,19 +92,20 @@ struct bpf_object *bpf_object__next(struct bpf_object *prev);
 	     (pos) = (tmp), (tmp) = bpf_object__next(tmp))
 
 typedef void (*bpf_object_clear_priv_t)(struct bpf_object *, void *);
-int bpf_object__set_priv(struct bpf_object *obj, void *priv,
-			 bpf_object_clear_priv_t clear_priv);
-void *bpf_object__priv(struct bpf_object *prog);
+LIBBPF_API int bpf_object__set_priv(struct bpf_object *obj, void *priv,
+				    bpf_object_clear_priv_t clear_priv);
+LIBBPF_API void *bpf_object__priv(struct bpf_object *prog);
 
-int libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
-			     enum bpf_attach_type *expected_attach_type);
-int libbpf_attach_type_by_name(const char *name,
-			       enum bpf_attach_type *attach_type);
+LIBBPF_API int
+libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
+			 enum bpf_attach_type *expected_attach_type);
+LIBBPF_API int libbpf_attach_type_by_name(const char *name,
+					  enum bpf_attach_type *attach_type);
 
 /* Accessors of bpf_program */
 struct bpf_program;
-struct bpf_program *bpf_program__next(struct bpf_program *prog,
-				      struct bpf_object *obj);
+LIBBPF_API struct bpf_program *bpf_program__next(struct bpf_program *prog,
+						 struct bpf_object *obj);
 
 #define bpf_object__for_each_program(pos, obj)		\
 	for ((pos) = bpf_program__next(NULL, (obj));	\
@@ -109,21 +115,24 @@ struct bpf_program *bpf_program__next(struct bpf_program *prog,
 typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
 					 void *);
 
-int bpf_program__set_priv(struct bpf_program *prog, void *priv,
-			  bpf_program_clear_priv_t clear_priv);
+LIBBPF_API int bpf_program__set_priv(struct bpf_program *prog, void *priv,
+				     bpf_program_clear_priv_t clear_priv);
 
-void *bpf_program__priv(struct bpf_program *prog);
-void bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex);
+LIBBPF_API void *bpf_program__priv(struct bpf_program *prog);
+LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
+					 __u32 ifindex);
 
-const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
+LIBBPF_API const char *bpf_program__title(struct bpf_program *prog,
+					  bool needs_copy);
 
-int bpf_program__load(struct bpf_program *prog, char *license,
-		      __u32 kern_version);
-int bpf_program__fd(struct bpf_program *prog);
-int bpf_program__pin_instance(struct bpf_program *prog, const char *path,
-			      int instance);
-int bpf_program__pin(struct bpf_program *prog, const char *path);
-void bpf_program__unload(struct bpf_program *prog);
+LIBBPF_API int bpf_program__load(struct bpf_program *prog, char *license,
+				 __u32 kern_version);
+LIBBPF_API int bpf_program__fd(struct bpf_program *prog);
+LIBBPF_API int bpf_program__pin_instance(struct bpf_program *prog,
+					 const char *path,
+					 int instance);
+LIBBPF_API int bpf_program__pin(struct bpf_program *prog, const char *path);
+LIBBPF_API void bpf_program__unload(struct bpf_program *prog);
 
 struct bpf_insn;
 
@@ -184,34 +193,36 @@ typedef int (*bpf_program_prep_t)(struct bpf_program *prog, int n,
 				  struct bpf_insn *insns, int insns_cnt,
 				  struct bpf_prog_prep_result *res);
 
-int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
-			  bpf_program_prep_t prep);
+LIBBPF_API int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
+				     bpf_program_prep_t prep);
 
-int bpf_program__nth_fd(struct bpf_program *prog, int n);
+LIBBPF_API int bpf_program__nth_fd(struct bpf_program *prog, int n);
 
 /*
  * Adjust type of BPF program. Default is kprobe.
  */
-int bpf_program__set_socket_filter(struct bpf_program *prog);
-int bpf_program__set_tracepoint(struct bpf_program *prog);
-int bpf_program__set_raw_tracepoint(struct bpf_program *prog);
-int bpf_program__set_kprobe(struct bpf_program *prog);
-int bpf_program__set_sched_cls(struct bpf_program *prog);
-int bpf_program__set_sched_act(struct bpf_program *prog);
-int bpf_program__set_xdp(struct bpf_program *prog);
-int bpf_program__set_perf_event(struct bpf_program *prog);
-void bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type);
-void bpf_program__set_expected_attach_type(struct bpf_program *prog,
-					   enum bpf_attach_type type);
-
-bool bpf_program__is_socket_filter(struct bpf_program *prog);
-bool bpf_program__is_tracepoint(struct bpf_program *prog);
-bool bpf_program__is_raw_tracepoint(struct bpf_program *prog);
-bool bpf_program__is_kprobe(struct bpf_program *prog);
-bool bpf_program__is_sched_cls(struct bpf_program *prog);
-bool bpf_program__is_sched_act(struct bpf_program *prog);
-bool bpf_program__is_xdp(struct bpf_program *prog);
-bool bpf_program__is_perf_event(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_socket_filter(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_tracepoint(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_raw_tracepoint(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_kprobe(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_sched_cls(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
+LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
+LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
+				      enum bpf_prog_type type);
+LIBBPF_API void
+bpf_program__set_expected_attach_type(struct bpf_program *prog,
+				      enum bpf_attach_type type);
+
+LIBBPF_API bool bpf_program__is_socket_filter(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_tracepoint(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_raw_tracepoint(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_kprobe(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_sched_cls(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_sched_act(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_xdp(struct bpf_program *prog);
+LIBBPF_API bool bpf_program__is_perf_event(struct bpf_program *prog);
 
 /*
  * No need for __attribute__((packed)), all members of 'bpf_map_def'
@@ -232,39 +243,39 @@ struct bpf_map_def {
  * so no need to worry about a name clash.
  */
 struct bpf_map;
-struct bpf_map *
+LIBBPF_API struct bpf_map *
 bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
 
 /*
  * Get bpf_map through the offset of corresponding struct bpf_map_def
  * in the BPF object file.
  */
-struct bpf_map *
+LIBBPF_API struct bpf_map *
 bpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset);
 
-struct bpf_map *
+LIBBPF_API struct bpf_map *
 bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 #define bpf_map__for_each(pos, obj)		\
 	for ((pos) = bpf_map__next(NULL, (obj));	\
 	     (pos) != NULL;				\
 	     (pos) = bpf_map__next((pos), (obj)))
 
-int bpf_map__fd(struct bpf_map *map);
-const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
-const char *bpf_map__name(struct bpf_map *map);
-__u32 bpf_map__btf_key_type_id(const struct bpf_map *map);
-__u32 bpf_map__btf_value_type_id(const struct bpf_map *map);
+LIBBPF_API int bpf_map__fd(struct bpf_map *map);
+LIBBPF_API const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
+LIBBPF_API const char *bpf_map__name(struct bpf_map *map);
+LIBBPF_API __u32 bpf_map__btf_key_type_id(const struct bpf_map *map);
+LIBBPF_API __u32 bpf_map__btf_value_type_id(const struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
-int bpf_map__set_priv(struct bpf_map *map, void *priv,
-		      bpf_map_clear_priv_t clear_priv);
-void *bpf_map__priv(struct bpf_map *map);
-int bpf_map__reuse_fd(struct bpf_map *map, int fd);
-bool bpf_map__is_offload_neutral(struct bpf_map *map);
-void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
-int bpf_map__pin(struct bpf_map *map, const char *path);
+LIBBPF_API int bpf_map__set_priv(struct bpf_map *map, void *priv,
+				 bpf_map_clear_priv_t clear_priv);
+LIBBPF_API void *bpf_map__priv(struct bpf_map *map);
+LIBBPF_API int bpf_map__reuse_fd(struct bpf_map *map, int fd);
+LIBBPF_API bool bpf_map__is_offload_neutral(struct bpf_map *map);
+LIBBPF_API void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
+LIBBPF_API int bpf_map__pin(struct bpf_map *map, const char *path);
 
-long libbpf_get_error(const void *ptr);
+LIBBPF_API long libbpf_get_error(const void *ptr);
 
 struct bpf_prog_load_attr {
 	const char *file;
@@ -273,12 +284,12 @@ struct bpf_prog_load_attr {
 	int ifindex;
 };
 
-int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
-			struct bpf_object **pobj, int *prog_fd);
-int bpf_prog_load(const char *file, enum bpf_prog_type type,
-		  struct bpf_object **pobj, int *prog_fd);
+LIBBPF_API int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
+				   struct bpf_object **pobj, int *prog_fd);
+LIBBPF_API int bpf_prog_load(const char *file, enum bpf_prog_type type,
+			     struct bpf_object **pobj, int *prog_fd);
 
-int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
+LIBBPF_API int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
 
 enum bpf_perf_event_ret {
 	LIBBPF_PERF_EVENT_DONE	= 0,
@@ -288,10 +299,11 @@ enum bpf_perf_event_ret {
 
 typedef enum bpf_perf_event_ret (*bpf_perf_event_print_t)(void *event,
 							  void *priv);
-int bpf_perf_event_read_simple(void *mem, unsigned long size,
-			       unsigned long page_size,
-			       void **buf, size_t *buf_len,
-			       bpf_perf_event_print_t fn, void *priv);
+LIBBPF_API int bpf_perf_event_read_simple(void *mem, unsigned long size,
+					  unsigned long page_size,
+					  void **buf, size_t *buf_len,
+					  bpf_perf_event_print_t fn,
+					  void *priv);
 
 struct nlattr;
 typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);

commit c034a177d3c898f370f52877e7252da8c4f8235c
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Mon Oct 15 11:19:55 2018 -0700

    bpf: bpftool, add flag to allow non-compat map definitions
    
    Multiple map definition structures exist and user may have non-zero
    fields in their definition that are not recognized by bpftool and
    libbpf. The normal behavior is to then fail loading the map. Although
    this is a good default behavior users may still want to load the map
    for debugging or other reasons. This patch adds a --mapcompat flag
    that can be used to override the default behavior and allow loading
    the map even when it has additional non-zero fields.
    
    For now the only user is 'bpftool prog' we can switch over other
    subcommands as needed. The library exposes an API that consumes
    a flags field now but I kept the original API around also in case
    users of the API don't want to expose this. The flags field is an
    int in case we need more control over how the API call handles
    errors/features/etc in the future.
    
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8af8d3663991..7e9c801a9fdd 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -61,6 +61,8 @@ struct bpf_object_open_attr {
 
 struct bpf_object *bpf_object__open(const char *path);
 struct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr);
+struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
+					    int flags);
 struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 					   size_t obj_buf_sz,
 					   const char *name);

commit 1bc38b8ff6cc54b1cd925525c0a9ffa7eef4d23b
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Fri Oct 5 16:40:00 2018 -0700

    libbpf: relicense libbpf as LGPL-2.1 OR BSD-2-Clause
    
    libbpf is maturing as a library and gaining features that no other bpf libraries support
    (BPF Type Format, bpf to bpf calls, etc)
    Many Apache2 licensed projects (like bcc, bpftrace, gobpf, cilium, etc)
    would like to use libbpf, but cannot do this yet, since Apache Foundation explicitly
    states that LGPL is incompatible with Apache2.
    Hence let's relicense libbpf as dual license LGPL-2.1 or BSD-2-Clause,
    since BSD-2 is compatible with Apache2.
    Dual LGPL or Apache2 is invalid combination.
    Fix license mistake in Makefile as well.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@kernel.org>
    Acked-by: Björn Töpel <bjorn.topel@intel.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: David Beckett <david.beckett@netronome.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Joe Stringer <joe@ovn.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Roman Gushchin <guro@fb.com>
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index fbfc2aec0f0d..8af8d3663991 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: LGPL-2.1 */
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
 
 /*
  * Common eBPF ELF object loading operations.
@@ -6,19 +6,6 @@
  * Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
  * Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  * Copyright (C) 2015 Huawei Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation;
- * version 2.1 of the License (not later!)
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not,  see <http://www.gnu.org/licenses>
  */
 #ifndef __LIBBPF_LIBBPF_H
 #define __LIBBPF_LIBBPF_H

commit e5b0863c2064f2d40de9de4862317f9db4ccffff
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:43 2018 -0700

    libbpf: Use __u32 instead of u32 in bpf_program__load
    
    Make bpf_program__load consistent with other interfaces: use __u32
    instead of u32. That in turn fixes build of samples:
    
    In file included from ./samples/bpf/trace_output_user.c:21:0:
    ./tools/lib/bpf/libbpf.h:132:9: error: unknown type name ‘u32’
             u32 kern_version);
             ^
    
    Fixes: commit 29cd77f41620d ("libbpf: Support loading individual progs")
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 28f83dd6022b..fbfc2aec0f0d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -129,7 +129,7 @@ void bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex);
 const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
 int bpf_program__load(struct bpf_program *prog, char *license,
-		      u32 kern_version);
+		      __u32 kern_version);
 int bpf_program__fd(struct bpf_program *prog);
 int bpf_program__pin_instance(struct bpf_program *prog, const char *path,
 			      int instance);

commit eff8190880c005e754d7d1bd315fc53a3ae9f876
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:42 2018 -0700

    libbpf: Make include guards consistent
    
    Rename include guards to have consistent names "__LIBBPF_<header_name>".
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 710ff5724980..28f83dd6022b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -20,8 +20,8 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this program; if not,  see <http://www.gnu.org/licenses>
  */
-#ifndef __BPF_LIBBPF_H
-#define __BPF_LIBBPF_H
+#ifndef __LIBBPF_LIBBPF_H
+#define __LIBBPF_LIBBPF_H
 
 #include <stdio.h>
 #include <stdint.h>
@@ -315,4 +315,4 @@ int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
 			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
 int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
 			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
-#endif
+#endif /* __LIBBPF_LIBBPF_H */

commit aae57780107d92de2463e605cb054656ebd233d1
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:39 2018 -0700

    libbpf: Consistent prefixes for interfaces in libbpf.h.
    
    libbpf is used more and more outside kernel tree. That means the library
    should follow good practices in library design and implementation to
    play well with third party code that uses it.
    
    One of such practices is to have a common prefix (or a few) for every
    interface, function or data structure, library provides. I helps to
    avoid name conflicts with other libraries and keeps API consistent.
    
    Inconsistent names in libbpf already cause problems in real life. E.g.
    an application can't use both libbpf and libnl due to conflicting
    symbols.
    
    Having common prefix will help to fix current and avoid future problems.
    
    libbpf already uses the following prefixes for its interfaces:
    * bpf_ for bpf system call wrappers, program/map/elf-object
      abstractions and a few other things;
    * btf_ for BTF related API;
    * libbpf_ for everything else.
    
    The patch adds libbpf_ prefix to functions and typedef in libbpf.h that
    use none of mentioned above prefixes and doesn't fit well into the first
    two categories.
    
    Since affected part of API is used in bpftool, the patch applies
    corresponding change to bpftool as well. Having it in a separate patch
    will cause a state of tree where bpftool is broken what may not be a
    good idea.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8388be525388..710ff5724980 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -305,14 +305,14 @@ int bpf_perf_event_read_simple(void *mem, unsigned long size,
 			       bpf_perf_event_print_t fn, void *priv);
 
 struct nlattr;
-typedef int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
-int bpf_netlink_open(unsigned int *nl_pid);
-int nl_get_link(int sock, unsigned int nl_pid, dump_nlmsg_t dump_link_nlmsg,
-		void *cookie);
-int nl_get_class(int sock, unsigned int nl_pid, int ifindex,
-		 dump_nlmsg_t dump_class_nlmsg, void *cookie);
-int nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
-		 dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
-int nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
-		  dump_nlmsg_t dump_filter_nlmsg, void *cookie);
+typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
+int libbpf_netlink_open(unsigned int *nl_pid);
+int libbpf_nl_get_link(int sock, unsigned int nl_pid,
+		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
+int libbpf_nl_get_class(int sock, unsigned int nl_pid, int ifindex,
+			libbpf_dump_nlmsg_t dump_class_nlmsg, void *cookie);
+int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
+			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
+int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
+			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
 #endif

commit 434fe9d4b4bfa8becb0959ef32b9b9fa628ef6fe
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Oct 3 15:26:38 2018 -0700

    libbpf: Move __dump_nlmsg_t from API to implementation
    
    This typedef is used only by implementation in netlink.c. Nothing uses
    it in public API. Move it to netlink.c.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2ed24d3f80b3..8388be525388 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -304,11 +304,8 @@ int bpf_perf_event_read_simple(void *mem, unsigned long size,
 			       void **buf, size_t *buf_len,
 			       bpf_perf_event_print_t fn, void *priv);
 
-struct nlmsghdr;
 struct nlattr;
 typedef int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
-typedef int (*__dump_nlmsg_t)(struct nlmsghdr *nlmsg, dump_nlmsg_t,
-			      void *cookie);
 int bpf_netlink_open(unsigned int *nl_pid);
 int nl_get_link(int sock, unsigned int nl_pid, dump_nlmsg_t dump_link_nlmsg,
 		void *cookie);

commit 29cd77f41620dca22bdee092217c16b49ece8915
Author: Joe Stringer <joe@wand.net.nz>
Date:   Tue Oct 2 13:35:39 2018 -0700

    libbpf: Support loading individual progs
    
    Allow the individual program load to be invoked. This will help with
    testing, where a single ELF may contain several sections, some of which
    denote subprograms that are expected to fail verification, along with
    some which are expected to pass verification. By allowing programs to be
    iterated and individually loaded, each program can be independently
    checked against its expected verification result.
    
    Signed-off-by: Joe Stringer <joe@wand.net.nz>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 511c1294dcbf..2ed24d3f80b3 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -128,10 +128,13 @@ void bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex);
 
 const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
+int bpf_program__load(struct bpf_program *prog, char *license,
+		      u32 kern_version);
 int bpf_program__fd(struct bpf_program *prog);
 int bpf_program__pin_instance(struct bpf_program *prog, const char *path,
 			      int instance);
 int bpf_program__pin(struct bpf_program *prog, const char *path);
+void bpf_program__unload(struct bpf_program *prog);
 
 struct bpf_insn;
 

commit 956b620fcf0b64de403cd26a56bc41e6e4826ea6
Author: Andrey Ignatov <rdna@fb.com>
Date:   Wed Sep 26 15:24:53 2018 -0700

    libbpf: Introduce libbpf_attach_type_by_name
    
    There is a common use-case when ELF object contains multiple BPF
    programs and every program has its own section name. If it's cgroup-bpf
    then programs have to be 1) loaded and 2) attached to a cgroup.
    
    It's convenient to have information necessary to load BPF program
    together with program itself. This is where section name works fine in
    conjunction with libbpf_prog_type_by_name that identifies prog_type and
    expected_attach_type and these can be used with BPF_PROG_LOAD.
    
    But there is currently no way to identify attach_type by section name
    and it leads to messy code in user space that reinvents guessing logic
    every time it has to identify attach type to use with BPF_PROG_ATTACH.
    
    The patch introduces libbpf_attach_type_by_name that guesses attach type
    by section name if a program can be attached.
    
    The difference between expected_attach_type provided by
    libbpf_prog_type_by_name and attach_type provided by
    libbpf_attach_type_by_name is the former is used at BPF_PROG_LOAD time
    and can be zero if a program of prog_type X has only one corresponding
    attach type Y whether the latter provides specific attach type to use
    with BPF_PROG_ATTACH.
    
    No new section names were added to section_names array. Only existing
    ones were reorganized and attach_type was added where appropriate.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e3b00e23e181..511c1294dcbf 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -104,6 +104,8 @@ void *bpf_object__priv(struct bpf_object *prog);
 
 int libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
 			     enum bpf_attach_type *expected_attach_type);
+int libbpf_attach_type_by_name(const char *name,
+			       enum bpf_attach_type *attach_type);
 
 /* Accessors of bpf_program */
 struct bpf_program;

commit 36f1678d9e0b5d2e0236046d9659e0348b4719a8
Author: Yonghong Song <yhs@fb.com>
Date:   Wed Sep 5 16:58:05 2018 -0700

    tools/bpf: add more netlink functionalities in lib/bpf
    
    This patch added a few netlink attribute parsing functions
    and the netlink API functions to query networking links, tc classes,
    tc qdiscs and tc filters. For example, the following API is
    to get networking links:
      int nl_get_link(int sock, unsigned int nl_pid,
                      dump_nlmsg_t dump_link_nlmsg,
                      void *cookie);
    
    Note that when the API is called, the user also provided a
    callback function with the following signature:
      int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
    
    The "cookie" is the parameter the user passed to the API and will
    be available for the callback function.
    The "msg" is the information about the result, e.g., ifinfomsg or
    tcmsg. The "tb" is the parsed netlink attributes.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 96c55fac54c3..e3b00e23e181 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -46,6 +46,7 @@ enum libbpf_errno {
 	LIBBPF_ERRNO__PROGTYPE,	/* Kernel doesn't support this program type */
 	LIBBPF_ERRNO__WRNGPID,	/* Wrong pid in netlink message */
 	LIBBPF_ERRNO__INVSEQ,	/* Invalid netlink sequence */
+	LIBBPF_ERRNO__NLPARSE,	/* netlink parsing error */
 	__LIBBPF_ERRNO__END,
 };
 
@@ -297,4 +298,19 @@ int bpf_perf_event_read_simple(void *mem, unsigned long size,
 			       unsigned long page_size,
 			       void **buf, size_t *buf_len,
 			       bpf_perf_event_print_t fn, void *priv);
+
+struct nlmsghdr;
+struct nlattr;
+typedef int (*dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
+typedef int (*__dump_nlmsg_t)(struct nlmsghdr *nlmsg, dump_nlmsg_t,
+			      void *cookie);
+int bpf_netlink_open(unsigned int *nl_pid);
+int nl_get_link(int sock, unsigned int nl_pid, dump_nlmsg_t dump_link_nlmsg,
+		void *cookie);
+int nl_get_class(int sock, unsigned int nl_pid, int ifindex,
+		 dump_nlmsg_t dump_class_nlmsg, void *cookie);
+int nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
+		 dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
+int nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
+		  dump_nlmsg_t dump_filter_nlmsg, void *cookie);
 #endif

commit 1ba982806ce58baac44c52e6c7812245afad27c8
Merge: c5d99d2b35da 85fc4b16aaf0
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 7 11:02:05 2018 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next
    
    Daniel Borkmann says:
    
    ====================
    pull-request: bpf-next 2018-08-07
    
    The following pull-request contains BPF updates for your *net-next* tree.
    
    The main changes are:
    
    1) Add cgroup local storage for BPF programs, which provides a fast
       accessible memory for storing various per-cgroup data like number
       of transmitted packets, etc, from Roman.
    
    2) Support bpf_get_socket_cookie() BPF helper in several more program
       types that have a full socket available, from Andrey.
    
    3) Significantly improve the performance of perf events which are
       reported from BPF offload. Also convert a couple of BPF AF_XDP
       samples overto use libbpf, both from Jakub.
    
    4) seg6local LWT provides the End.DT6 action, which allows to
       decapsulate an outer IPv6 header containing a Segment Routing Header.
       Adds this action now to the seg6local BPF interface, from Mathieu.
    
    5) Do not mark dst register as unbounded in MOV64 instruction when
       both src and dst register are the same, from Arthur.
    
    6) Define u_smp_rmb() and u_smp_wmb() to their respective barrier
       instructions on arm64 for the AF_XDP sample code, from Brian.
    
    7) Convert the tcp_client.py and tcp_server.py BPF selftest scripts
       over from Python 2 to Python 3, from Jeremy.
    
    8) Enable BTF build flags to the BPF sample code Makefile, from Taeung.
    
    9) Remove an unnecessary rcu_read_lock() in run_lwt_bpf(), from Taehee.
    
    10) Several improvements to the README.rst from the BPF documentation
        to make it more consistent with RST format, from Tobin.
    
    11) Replace all occurrences of strerror() by calls to strerror_r()
        in libbpf and fix a FORTIFY_SOURCE build error along with it,
        from Thomas.
    
    12) Fix a bug in bpftool's get_btf() function to correctly propagate
        an error via PTR_ERR(), from Yue.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 89b1698c93a9dee043154f33d96bca9964e705f1
Merge: ffd7ce3cd9c2 e30cb13c5a09
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Aug 2 10:55:32 2018 -0700

    Merge ra.kernel.org:/pub/scm/linux/kernel/git/davem/net
    
    The BTF conflicts were simple overlapping changes.
    
    The virtio_net conflict was an overlap of a fix of statistics counter,
    happening alongisde a move over to a bonafide statistics structure
    rather than counting value on the stack.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6d4b198b0b23ca2a75785173a9b27afd1eee7040
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu Jul 26 14:32:19 2018 -0700

    tools: libbpf: add bpf_object__find_program_by_title()
    
    Allow users to find programs by section names.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 1f8fc2060460..a295fe2f822b 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -86,6 +86,9 @@ const char *bpf_object__name(struct bpf_object *obj);
 unsigned int bpf_object__kversion(struct bpf_object *obj);
 int bpf_object__btf_fd(const struct bpf_object *obj);
 
+struct bpf_program *
+bpf_object__find_program_by_title(struct bpf_object *obj, const char *title);
+
 struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
 	for ((pos) = bpf_object__next(NULL),		\

commit 5b891af7fca14526b2a87c6f38b004e2df655ef4
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Tue Jul 24 08:40:21 2018 -0700

    bpf: Replace [u]int32_t and [u]int64_t in libbpf
    
    This patch replaces [u]int32_t and [u]int64_t usage with
    __[su]32 and __[su]64.  The same change goes for [u]int16_t
    and [u]int8_t.
    
    Fixes: 8a138aed4a80 ("bpf: btf: Add BTF support to libbpf")
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 09976531aa74..b33ae02f7d0e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -244,8 +244,8 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 int bpf_map__fd(struct bpf_map *map);
 const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
-uint32_t bpf_map__btf_key_type_id(const struct bpf_map *map);
-uint32_t bpf_map__btf_value_type_id(const struct bpf_map *map);
+__u32 bpf_map__btf_key_type_id(const struct bpf_map *map);
+__u32 bpf_map__btf_value_type_id(const struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,

commit 26736eb9a483715c2e971a8866f55fbb156903e2
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Jul 10 14:43:06 2018 -0700

    tools: libbpf: allow map reuse
    
    More advanced applications may want to only replace programs without
    destroying associated maps.  Allow libbpf users to achieve that.
    Instead of always creating all of the maps at load time, expose to
    users an API to reconstruct the map object from already existing
    map.
    
    The map parameters are read from the kernel and replace the parameters
    of the ELF map.  libbpf does not restrict the map replacement, i.e.
    the reused map does not have to be compatible with the ELF map
    definition.  We relay on the verifier for checking the compatibility
    between maps and programs.  The ELF map definition is completely
    overwritten by the information read from the kernel, to make sure
    libbpf's view of map object corresponds to the actual map.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e911ad32d02e..1f8fc2060460 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -261,6 +261,7 @@ typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,
 		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
+int bpf_map__reuse_fd(struct bpf_map *map, int fd);
 bool bpf_map__is_offload_neutral(struct bpf_map *map);
 void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 int bpf_map__pin(struct bpf_map *map, const char *path);

commit 07f2d4eac2a850fc9649b27aa935cdcd263fb1ff
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Jul 10 14:43:02 2018 -0700

    tools: libbpf: add extended attributes version of bpf_object__open()
    
    Similarly to bpf_prog_load() users of bpf_object__open() may need
    to specify the expected program type.  Program type is needed at
    open to avoid the kernel version check for program types which don't
    require it.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 749acf58a5da..e911ad32d02e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -66,7 +66,13 @@ void libbpf_set_print(libbpf_print_fn_t warn,
 /* Hide internal to user */
 struct bpf_object;
 
+struct bpf_object_open_attr {
+	const char *file;
+	enum bpf_prog_type prog_type;
+};
+
 struct bpf_object *bpf_object__open(const char *path);
+struct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr);
 struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 					   size_t obj_buf_sz,
 					   const char *name);

commit f83fb22c6c68fdbc98c76291c9e12a40d1eb7ca5
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Jul 10 14:43:01 2018 -0700

    tools: libbpf: recognize offload neutral maps
    
    Add helper to libbpf for recognizing maps which should not have
    ifindex set when program is loaded.  These maps only contain
    host metadata and therefore are not marked for offload, e.g.
    the perf event map.
    
    Use this helper in bpf_prog_load_xattr().
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index d1ce5c828e2e..749acf58a5da 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -255,6 +255,7 @@ typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,
 		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
+bool bpf_map__is_offload_neutral(struct bpf_map *map);
 void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 int bpf_map__pin(struct bpf_map *map, const char *path);
 

commit b60df2a0e11fcd24186c312b0307ab8494031e27
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Tue Jul 10 14:42:59 2018 -0700

    tools: libbpf: expose the prog type guessing from section name logic
    
    libbpf can guess program type based on ELF section names.  As libbpf
    becomes more popular its association between section name strings and
    types becomes more of a standard.  Allow libbpf users to use the same
    logic for matching strings to types, e.g. when the string originates
    from command line.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 564f4be9bae0..d1ce5c828e2e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -92,6 +92,9 @@ int bpf_object__set_priv(struct bpf_object *obj, void *priv,
 			 bpf_object_clear_priv_t clear_priv);
 void *bpf_object__priv(struct bpf_object *prog);
 
+int libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,
+			     enum bpf_attach_type *expected_attach_type);
+
 /* Accessors of bpf_program */
 struct bpf_program;
 struct bpf_program *bpf_program__next(struct bpf_program *prog,

commit 9aba36139a5f9ee1d11a60d0a3a90944b8d56385
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu Jun 28 14:41:37 2018 -0700

    tools: libbpf: allow setting ifindex for programs and maps
    
    Users of bpf_object__open()/bpf_object__load() APIs may want to
    load the programs and maps onto a device for offload.  Allow
    setting ifindex on those sub-objects.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 09976531aa74..564f4be9bae0 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -109,6 +109,7 @@ int bpf_program__set_priv(struct bpf_program *prog, void *priv,
 			  bpf_program_clear_priv_t clear_priv);
 
 void *bpf_program__priv(struct bpf_program *prog);
+void bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex);
 
 const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
@@ -251,6 +252,7 @@ typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,
 		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
+void bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);
 int bpf_map__pin(struct bpf_map *map, const char *path);
 
 long libbpf_get_error(const void *ptr);

commit 61746dbe1aa27c9e23293621665b8442dfed7698
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Tue May 22 15:04:24 2018 -0700

    bpf: btf: Add tests for the btf uapi changes
    
    This patch does the followings:
    1. Modify libbpf and test_btf to reflect the uapi changes in btf
    2. Add test for the btf_header changes
    3. Add tests for array->index_type
    4. Add err_str check to the tests
    5. Fix a 4 bytes hole in "struct test #1" by swapping "m" and "n"
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index cd3fd8d782c7..09976531aa74 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -244,8 +244,8 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 int bpf_map__fd(struct bpf_map *map);
 const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
-uint32_t bpf_map__btf_key_id(const struct bpf_map *map);
-uint32_t bpf_map__btf_value_id(const struct bpf_map *map);
+uint32_t bpf_map__btf_key_type_id(const struct bpf_map *map);
+uint32_t bpf_map__btf_value_type_id(const struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,

commit f0307a7ed17fa8925321a4f58f5ca56eeedd4fa3
Author: David Beckett <david.beckett@netronome.com>
Date:   Wed May 16 14:02:49 2018 -0700

    libbpf: add ifindex to enable offload support
    
    BPF programs currently can only be offloaded using iproute2. This
    patch will allow programs to be offloaded using libbpf calls.
    
    Signed-off-by: David Beckett <david.beckett@netronome.com>
    Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 4574b9563278..cd3fd8d782c7 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -259,6 +259,7 @@ struct bpf_prog_load_attr {
 	const char *file;
 	enum bpf_prog_type prog_type;
 	enum bpf_attach_type expected_attach_type;
+	int ifindex;
 };
 
 int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,

commit 2eb57bb8f6769fe94f8f9865342ffa0f6c257e0a
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu May 10 10:24:41 2018 -0700

    tools: bpf: improve comments in libbpf.h
    
    Fix spelling mistakes, improve and clarify the language of comments
    in libbpf.h.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ce681097584e..4574b9563278 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -52,8 +52,8 @@ enum libbpf_errno {
 int libbpf_strerror(int err, char *buf, size_t size);
 
 /*
- * In include/linux/compiler-gcc.h, __printf is defined. However
- * it should be better if libbpf.h doesn't depend on Linux header file.
+ * __printf is defined in include/linux/compiler-gcc.h. However,
+ * it would be better if libbpf.h didn't depend on Linux header files.
  * So instead of __printf, here we use gcc attribute directly.
  */
 typedef int (*libbpf_print_fn_t)(const char *, ...)
@@ -92,7 +92,7 @@ int bpf_object__set_priv(struct bpf_object *obj, void *priv,
 			 bpf_object_clear_priv_t clear_priv);
 void *bpf_object__priv(struct bpf_object *prog);
 
-/* Accessors of bpf_program. */
+/* Accessors of bpf_program */
 struct bpf_program;
 struct bpf_program *bpf_program__next(struct bpf_program *prog,
 				      struct bpf_object *obj);
@@ -121,28 +121,28 @@ struct bpf_insn;
 
 /*
  * Libbpf allows callers to adjust BPF programs before being loaded
- * into kernel. One program in an object file can be transform into
- * multiple variants to be attached to different code.
+ * into kernel. One program in an object file can be transformed into
+ * multiple variants to be attached to different hooks.
  *
  * bpf_program_prep_t, bpf_program__set_prep and bpf_program__nth_fd
- * are APIs for this propose.
+ * form an API for this purpose.
  *
  * - bpf_program_prep_t:
- *   It defines 'preprocessor', which is a caller defined function
+ *   Defines a 'preprocessor', which is a caller defined function
  *   passed to libbpf through bpf_program__set_prep(), and will be
  *   called before program is loaded. The processor should adjust
- *   the program one time for each instances according to the number
+ *   the program one time for each instance according to the instance id
  *   passed to it.
  *
  * - bpf_program__set_prep:
- *   Attachs a preprocessor to a BPF program. The number of instances
- *   whould be created is also passed through this function.
+ *   Attaches a preprocessor to a BPF program. The number of instances
+ *   that should be created is also passed through this function.
  *
  * - bpf_program__nth_fd:
- *   After the program is loaded, get resuling fds from bpf program for
- *   each instances.
+ *   After the program is loaded, get resulting FD of a given instance
+ *   of the BPF program.
  *
- * If bpf_program__set_prep() is not used, the program whould be loaded
+ * If bpf_program__set_prep() is not used, the program would be loaded
  * without adjustment during bpf_object__load(). The program has only
  * one instance. In this case bpf_program__fd(prog) is equal to
  * bpf_program__nth_fd(prog, 0).
@@ -156,7 +156,7 @@ struct bpf_prog_prep_result {
 	struct bpf_insn *new_insn_ptr;
 	int new_insn_cnt;
 
-	/* If not NULL, result fd is set to it */
+	/* If not NULL, result FD is written to it. */
 	int *pfd;
 };
 
@@ -169,8 +169,8 @@ struct bpf_prog_prep_result {
  *  - res:	Output parameter, result of transformation.
  *
  * Return value:
- *  - Zero: pre-processing success.
- *  - Non-zero: pre-processing, stop loading.
+ *  - Zero:	pre-processing success.
+ *  - Non-zero:	pre-processing error, stop loading.
  */
 typedef int (*bpf_program_prep_t)(struct bpf_program *prog, int n,
 				  struct bpf_insn *insns, int insns_cnt,
@@ -182,7 +182,7 @@ int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
 int bpf_program__nth_fd(struct bpf_program *prog, int n);
 
 /*
- * Adjust type of bpf program. Default is kprobe.
+ * Adjust type of BPF program. Default is kprobe.
  */
 int bpf_program__set_socket_filter(struct bpf_program *prog);
 int bpf_program__set_tracepoint(struct bpf_program *prog);
@@ -206,10 +206,10 @@ bool bpf_program__is_xdp(struct bpf_program *prog);
 bool bpf_program__is_perf_event(struct bpf_program *prog);
 
 /*
- * We don't need __attribute__((packed)) now since it is
- * unnecessary for 'bpf_map_def' because they are all aligned.
- * In addition, using it will trigger -Wpacked warning message,
- * and will be treated as an error due to -Werror.
+ * No need for __attribute__((packed)), all members of 'bpf_map_def'
+ * are all aligned.  In addition, using __attribute__((packed))
+ * would trigger a -Wpacked warning message, and lead to an error
+ * if -Werror is set.
  */
 struct bpf_map_def {
 	unsigned int type;
@@ -220,8 +220,8 @@ struct bpf_map_def {
 };
 
 /*
- * There is another 'struct bpf_map' in include/linux/map.h. However,
- * it is not a uapi header so no need to consider name clash.
+ * The 'struct bpf_map' in include/linux/bpf.h is internal to the kernel,
+ * so no need to worry about a name clash.
  */
 struct bpf_map;
 struct bpf_map *
@@ -229,7 +229,7 @@ bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
 
 /*
  * Get bpf_map through the offset of corresponding struct bpf_map_def
- * in the bpf object file.
+ * in the BPF object file.
  */
 struct bpf_map *
 bpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset);

commit d0cabbb021bee5c4b831a0235af9534ad07f8d3d
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu May 10 10:24:40 2018 -0700

    tools: bpf: move the event reading loop to libbpf
    
    There are two copies of event reading loop - in bpftool and
    trace_helpers "library".  Consolidate them and move the code
    to libbpf.  Return codes from trace_helpers are kept, but
    renamed to include LIBBPF prefix.
    
    Suggested-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 197f9ce2248c..ce681097584e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -267,4 +267,17 @@ int bpf_prog_load(const char *file, enum bpf_prog_type type,
 		  struct bpf_object **pobj, int *prog_fd);
 
 int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
+
+enum bpf_perf_event_ret {
+	LIBBPF_PERF_EVENT_DONE	= 0,
+	LIBBPF_PERF_EVENT_ERROR	= -1,
+	LIBBPF_PERF_EVENT_CONT	= -2,
+};
+
+typedef enum bpf_perf_event_ret (*bpf_perf_event_print_t)(void *event,
+							  void *priv);
+int bpf_perf_event_read_simple(void *mem, unsigned long size,
+			       unsigned long page_size,
+			       void **buf, size_t *buf_len,
+			       bpf_perf_event_print_t fn, void *priv);
 #endif

commit 16962b2404ac88cde0281fe2176d6ae3820ed320
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Mon Apr 23 14:30:38 2018 -0700

    bpf: sockmap, add selftests
    
    This adds a new test program test_sockmap which is the old sample
    sockmap program. By moving the sample program here we can now run it
    as part of the self tests suite. To support this a populate_progs()
    routine is added to load programs and maps which was previously done
    with load_bpf_file(). This is needed because self test libs do not
    provide a similar routine. Also we now use the cgroup_helpers
    routines to manage cgroup use instead of manually creating one and
    supplying it to the CLI.
    
    Notice we keep the CLI around though because it is useful for dbg
    and specialized testing.
    
    To run use ./test_sockmap and the result should be,
    
    Summary 660 PASSED, 0 SKIPPED, 0 FAILED
    
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index d6ac4fa6f472..197f9ce2248c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -193,6 +193,8 @@ int bpf_program__set_sched_act(struct bpf_program *prog);
 int bpf_program__set_xdp(struct bpf_program *prog);
 int bpf_program__set_perf_event(struct bpf_program *prog);
 void bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type);
+void bpf_program__set_expected_attach_type(struct bpf_program *prog,
+					   enum bpf_attach_type type);
 
 bool bpf_program__is_socket_filter(struct bpf_program *prog);
 bool bpf_program__is_tracepoint(struct bpf_program *prog);

commit 8a138aed4a807ceb143882fb23a423d524dcdb35
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Wed Apr 18 15:56:05 2018 -0700

    bpf: btf: Add BTF support to libbpf
    
    If the ".BTF" elf section exists, libbpf will try to create
    a btf_fd (through BPF_BTF_LOAD).  If that fails, it will still
    continue loading the bpf prog/map without the BTF.
    
    If the bpf_object has a BTF loaded, it will create a map with the btf_fd.
    libbpf will try to figure out the btf_key_id and btf_value_id of a map by
    finding the BTF type with name "<map_name>_key" and "<map_name>_value".
    If they cannot be found, it will continue without using the BTF.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Alexei Starovoitov <ast@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8b242486b464..d6ac4fa6f472 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -78,6 +78,7 @@ int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
 const char *bpf_object__name(struct bpf_object *obj);
 unsigned int bpf_object__kversion(struct bpf_object *obj);
+int bpf_object__btf_fd(const struct bpf_object *obj);
 
 struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
@@ -241,6 +242,8 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 int bpf_map__fd(struct bpf_map *map);
 const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
+uint32_t bpf_map__btf_key_id(const struct bpf_map *map);
+uint32_t bpf_map__btf_value_id(const struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,

commit e14c93fd5be14369d7c0190f4c908a81bfeae922
Author: Andrey Ignatov <rdna@fb.com>
Date:   Tue Apr 17 10:28:46 2018 -0700

    libbpf: Type functions for raw tracepoints
    
    Add missing pieces for BPF_PROG_TYPE_RAW_TRACEPOINT in libbpf:
    * is- and set- functions;
    * support guessing prog type.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index a3a62a583f27..8b242486b464 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -185,6 +185,7 @@ int bpf_program__nth_fd(struct bpf_program *prog, int n);
  */
 int bpf_program__set_socket_filter(struct bpf_program *prog);
 int bpf_program__set_tracepoint(struct bpf_program *prog);
+int bpf_program__set_raw_tracepoint(struct bpf_program *prog);
 int bpf_program__set_kprobe(struct bpf_program *prog);
 int bpf_program__set_sched_cls(struct bpf_program *prog);
 int bpf_program__set_sched_act(struct bpf_program *prog);
@@ -194,6 +195,7 @@ void bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type);
 
 bool bpf_program__is_socket_filter(struct bpf_program *prog);
 bool bpf_program__is_tracepoint(struct bpf_program *prog);
+bool bpf_program__is_raw_tracepoint(struct bpf_program *prog);
 bool bpf_program__is_kprobe(struct bpf_program *prog);
 bool bpf_program__is_sched_cls(struct bpf_program *prog);
 bool bpf_program__is_sched_act(struct bpf_program *prog);

commit d7be143b67c2cf99bf93279217b1cf93a1e8a6b1
Author: Andrey Ignatov <rdna@fb.com>
Date:   Fri Mar 30 15:08:01 2018 -0700

    libbpf: Support expected_attach_type at prog load
    
    Support setting `expected_attach_type` at prog load time in both
    `bpf/bpf.h` and `bpf/libbpf.h`.
    
    Since both headers already have API to load programs, new functions are
    added not to break backward compatibility for existing ones:
    * `bpf_load_program_xattr()` is added to `bpf/bpf.h`;
    * `bpf_prog_load_xattr()` is added to `bpf/libbpf.h`.
    
    Both new functions accept structures, `struct bpf_load_program_attr` and
    `struct bpf_prog_load_attr` correspondingly, where new fields can be
    added in the future w/o changing the API.
    
    Standard `_xattr` suffix is used to name the new API functions.
    
    Since `bpf_load_program_name()` is not used as heavily as
    `bpf_load_program()`, it was removed in favor of more generic
    `bpf_load_program_xattr()`.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f85906533cdd..a3a62a583f27 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -248,6 +248,14 @@ int bpf_map__pin(struct bpf_map *map, const char *path);
 
 long libbpf_get_error(const void *ptr);
 
+struct bpf_prog_load_attr {
+	const char *file;
+	enum bpf_prog_type prog_type;
+	enum bpf_attach_type expected_attach_type;
+};
+
+int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
+			struct bpf_object **pobj, int *prog_fd);
 int bpf_prog_load(const char *file, enum bpf_prog_type type,
 		  struct bpf_object **pobj, int *prog_fd);
 

commit 6061a3d6720600c976b877c3ac1402b3ef0a8a55
Author: Eric Leblond <eric@regit.org>
Date:   Tue Jan 30 21:55:03 2018 +0100

    libbpf: add missing SPDX-License-Identifier
    
    Signed-off-by: Eric Leblond <eric@regit.org>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e42f96900318..f85906533cdd 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -1,3 +1,5 @@
+/* SPDX-License-Identifier: LGPL-2.1 */
+
 /*
  * Common eBPF ELF object loading operations.
  *

commit 949abbe88436c000cc63fce2bdfeb48b7d06a7df
Author: Eric Leblond <eric@regit.org>
Date:   Tue Jan 30 21:55:01 2018 +0100

    libbpf: add function to setup XDP
    
    Most of the code is taken from set_link_xdp_fd() in bpf_load.c and
    slightly modified to be library compliant.
    
    Signed-off-by: Eric Leblond <eric@regit.org>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 6e20003109e0..e42f96900318 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -42,6 +42,8 @@ enum libbpf_errno {
 	LIBBPF_ERRNO__PROG2BIG,	/* Program too big */
 	LIBBPF_ERRNO__KVER,	/* Incorrect kernel version */
 	LIBBPF_ERRNO__PROGTYPE,	/* Kernel doesn't support this program type */
+	LIBBPF_ERRNO__WRNGPID,	/* Wrong pid in netlink message */
+	LIBBPF_ERRNO__INVSEQ,	/* Invalid netlink sequence */
 	__LIBBPF_ERRNO__END,
 };
 
@@ -246,4 +248,6 @@ long libbpf_get_error(const void *ptr);
 
 int bpf_prog_load(const char *file, enum bpf_prog_type type,
 		  struct bpf_object **pobj, int *prog_fd);
+
+int bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags);
 #endif

commit fe9b5f774b28143dcc2957eadffefdca6171a26a
Author: Craig Gallek <kraig@google.com>
Date:   Thu Oct 5 10:41:58 2017 -0400

    libbpf: use map_flags when creating maps
    
    This is required to use BPF_MAP_TYPE_LPM_TRIE or any other map type
    which requires flags.
    
    Signed-off-by: Craig Gallek <kraig@google.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 7959086eb9c9..6e20003109e0 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -207,6 +207,7 @@ struct bpf_map_def {
 	unsigned int key_size;
 	unsigned int value_size;
 	unsigned int max_entries;
+	unsigned int map_flags;
 };
 
 /*

commit 6f6d33f3b3d0f53799d120d28abd13ad90041549
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Tue Aug 15 22:34:22 2017 -0700

    bpf: selftests add sockmap tests
    
    This generates a set of sockets, attaches BPF programs, and sends some
    simple traffic using basic send/recv pattern. Additionally, we do a bunch
    of negative tests to ensure adding/removing socks out of the sockmap fail
    correctly.
    
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 32c7252f734e..7959086eb9c9 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -243,4 +243,6 @@ int bpf_map__pin(struct bpf_map *map, const char *path);
 
 long libbpf_get_error(const void *ptr);
 
+int bpf_prog_load(const char *file, enum bpf_prog_type type,
+		  struct bpf_object **pobj, int *prog_fd);
 #endif

commit dd26b7f54a08fd1a9fd804b51b9fce8e16628349
Author: Alexei Starovoitov <ast@fb.com>
Date:   Thu Mar 30 21:45:40 2017 -0700

    tools/lib/bpf: expose bpf_program__set_type()
    
    expose bpf_program__set_type() to set program type
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index b30394f9947a..32c7252f734e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -25,6 +25,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <sys/types.h>  // for size_t
+#include <linux/bpf.h>
 
 enum libbpf_errno {
 	__LIBBPF_ERRNO__START = 4000,
@@ -185,6 +186,7 @@ int bpf_program__set_sched_cls(struct bpf_program *prog);
 int bpf_program__set_sched_act(struct bpf_program *prog);
 int bpf_program__set_xdp(struct bpf_program *prog);
 int bpf_program__set_perf_event(struct bpf_program *prog);
+void bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type);
 
 bool bpf_program__is_socket_filter(struct bpf_program *prog);
 bool bpf_program__is_tracepoint(struct bpf_program *prog);

commit d5148d8554d08f03b3e34ecc286ab1729c35c24c
Author: Joe Stringer <joe@ovn.org>
Date:   Thu Jan 26 13:19:58 2017 -0800

    tools lib bpf: Add bpf_object__pin()
    
    Add a new API to pin a BPF object to the filesystem. The user can
    specify the path within a BPF filesystem to pin the object.
    Programs will be pinned under a subdirectory named the same as the
    program, with each instance appearing as a numbered file under that
    directory, and maps will be pinned under the path using the name of
    the map as the file basename.
    
    For example, with the directory '/sys/fs/bpf/foo' and a BPF object which
    contains two instances of a program named 'bar', and a map named 'baz':
    
    /sys/fs/bpf/foo/bar/0
    /sys/fs/bpf/foo/bar/1
    /sys/fs/bpf/foo/baz
    
    Signed-off-by: Joe Stringer <joe@ovn.org>
    Cc: Alexei Starovoitov <ast@fb.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170126212001.14103-4-joe@ovn.org
    [ Check snprintf >= for truncation, as snprintf(bf, size, ...) == size also means truncation ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2addf9d5b13c..b30394f9947a 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -65,6 +65,7 @@ struct bpf_object *bpf_object__open(const char *path);
 struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 					   size_t obj_buf_sz,
 					   const char *name);
+int bpf_object__pin(struct bpf_object *object, const char *path);
 void bpf_object__close(struct bpf_object *object);
 
 /* Load/unload object into/from kernel */

commit b6989f35e80bf830f8dc97b74128d619faef0273
Author: Joe Stringer <joe@ovn.org>
Date:   Thu Jan 26 13:19:57 2017 -0800

    tools lib bpf: Add bpf_map__pin()
    
    Add a new API to pin a BPF map to the filesystem. The user can specify
    the path full path within a BPF filesystem to pin the map.
    
    Signed-off-by: Joe Stringer <joe@ovn.org>
    Cc: Alexei Starovoitov <ast@fb.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170126212001.14103-3-joe@ovn.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 9f8aa63b95f4..2addf9d5b13c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -236,6 +236,7 @@ typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_priv(struct bpf_map *map, void *priv,
 		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
+int bpf_map__pin(struct bpf_map *map, const char *path);
 
 long libbpf_get_error(const void *ptr);
 

commit f367540c8c13d65603c431e29a0b87a7db893d6c
Author: Joe Stringer <joe@ovn.org>
Date:   Thu Jan 26 13:19:56 2017 -0800

    tools lib bpf: Add BPF program pinning APIs
    
    Add new APIs to pin a BPF program (or specific instances) to the
    filesystem.  The user can specify the path full path within a BPF
    filesystem to pin the program.
    
    bpf_program__pin_instance(prog, path, n) will pin the nth instance of
    'prog' to the specified path.
    
    bpf_program__pin(prog, path) will create the directory 'path' (if it
    does not exist) and pin each instance within that directory. For
    instance, path/0, path/1, path/2.
    
    Committer notes:
    
    - Add missing headers for mkdir()
    
    - Check strdup() for failure
    
    - Check snprintf >= size, not >, as == also means truncated, see 'man
      snprintf', return value.
    
    - Conditionally define BPF_FS_MAGIC, as it isn't in magic.h in older
      systems and we're not yet having a tools/include/uapi/linux/magic.h
      copy.
    
    - Do not include linux/magic.h, not present in older distros.
    
    Signed-off-by: Joe Stringer <joe@ovn.org>
    Cc: Alexei Starovoitov <ast@fb.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Wang Nan <wangnan0@huawei.com>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170126212001.14103-2-joe@ovn.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 4014d1ba5e3d..9f8aa63b95f4 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -106,6 +106,9 @@ void *bpf_program__priv(struct bpf_program *prog);
 const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
 int bpf_program__fd(struct bpf_program *prog);
+int bpf_program__pin_instance(struct bpf_program *prog, const char *path,
+			      int instance);
+int bpf_program__pin(struct bpf_program *prog, const char *path);
 
 struct bpf_insn;
 

commit e28ff1a8382ee02b10cf11cf3b48541dc3d14a58
Author: Joe Stringer <joe@ovn.org>
Date:   Sun Jan 22 17:11:25 2017 -0800

    tools lib bpf: Add libbpf_get_error()
    
    This function will turn a libbpf pointer into a standard error code (or
    0 if the pointer is valid).
    
    This also allows removal of the dependency on linux/err.h in the public
    header file, which causes problems in userspace programs built against
    libbpf.
    
    Signed-off-by: Joe Stringer <joe@ovn.org>
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@fb.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170123011128.26534-5-joe@ovn.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 2188ccdc0e2d..4014d1ba5e3d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -22,8 +22,8 @@
 #define __BPF_LIBBPF_H
 
 #include <stdio.h>
+#include <stdint.h>
 #include <stdbool.h>
-#include <linux/err.h>
 #include <sys/types.h>  // for size_t
 
 enum libbpf_errno {
@@ -234,4 +234,6 @@ int bpf_map__set_priv(struct bpf_map *map, void *priv,
 		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
 
+long libbpf_get_error(const void *ptr);
+
 #endif

commit 7803ba73099867d1f6ca866857277d92e0da4080
Author: Joe Stringer <joe@ovn.org>
Date:   Sun Jan 22 17:11:24 2017 -0800

    tools lib bpf: Add set/is helpers for all prog types
    
    These bpf_prog_types were exposed in the uapi but there were no
    corresponding functions to set these types for programs in libbpf.
    
    Signed-off-by: Joe Stringer <joe@ovn.org>
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@fb.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170123011128.26534-4-joe@ovn.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index a5a8b86a06fe..2188ccdc0e2d 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -174,11 +174,21 @@ int bpf_program__nth_fd(struct bpf_program *prog, int n);
 /*
  * Adjust type of bpf program. Default is kprobe.
  */
+int bpf_program__set_socket_filter(struct bpf_program *prog);
 int bpf_program__set_tracepoint(struct bpf_program *prog);
 int bpf_program__set_kprobe(struct bpf_program *prog);
+int bpf_program__set_sched_cls(struct bpf_program *prog);
+int bpf_program__set_sched_act(struct bpf_program *prog);
+int bpf_program__set_xdp(struct bpf_program *prog);
+int bpf_program__set_perf_event(struct bpf_program *prog);
 
+bool bpf_program__is_socket_filter(struct bpf_program *prog);
 bool bpf_program__is_tracepoint(struct bpf_program *prog);
 bool bpf_program__is_kprobe(struct bpf_program *prog);
+bool bpf_program__is_sched_cls(struct bpf_program *prog);
+bool bpf_program__is_sched_act(struct bpf_program *prog);
+bool bpf_program__is_xdp(struct bpf_program *prog);
+bool bpf_program__is_perf_event(struct bpf_program *prog);
 
 /*
  * We don't need __attribute__((packed)) now since it is

commit 5a6acad17d2e81765dd4c2fce7346a6f045eab25
Author: Wang Nan <wangnan0@huawei.com>
Date:   Sat Nov 26 07:03:27 2016 +0000

    tools lib bpf: Retrive bpf_map through offset of bpf_map_def
    
    Add a new API to libbpf, caller is able to get bpf_map through the
    offset of bpf_map_def to 'maps' section.
    
    The API will be used to help jitted perf hook code find fd of a map.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Joe Stringer <joe@ovn.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/20161126070354.141764-4-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 0c0b0127e03e..a5a8b86a06fe 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -24,6 +24,7 @@
 #include <stdio.h>
 #include <stdbool.h>
 #include <linux/err.h>
+#include <sys/types.h>  // for size_t
 
 enum libbpf_errno {
 	__LIBBPF_ERRNO__START = 4000,
@@ -200,6 +201,13 @@ struct bpf_map;
 struct bpf_map *
 bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
 
+/*
+ * Get bpf_map through the offset of corresponding struct bpf_map_def
+ * in the bpf object file.
+ */
+struct bpf_map *
+bpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset);
+
 struct bpf_map *
 bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 #define bpf_map__for_each(pos, obj)		\

commit 10931d2413478239bdceac5546cce85d7a497a4e
Author: Wang Nan <wangnan0@huawei.com>
Date:   Sat Nov 26 07:03:26 2016 +0000

    tools lib bpf: Add private field for bpf_object
    
    Similar to other classes defined in libbpf.h (map and program), allow
    'object' class has its own private data.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Joe Stringer <joe@ovn.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/20161126070354.141764-3-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index dd7a513efb10..0c0b0127e03e 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -79,6 +79,11 @@ struct bpf_object *bpf_object__next(struct bpf_object *prev);
 	     (pos) != NULL;				\
 	     (pos) = (tmp), (tmp) = bpf_object__next(tmp))
 
+typedef void (*bpf_object_clear_priv_t)(struct bpf_object *, void *);
+int bpf_object__set_priv(struct bpf_object *obj, void *priv,
+			 bpf_object_clear_priv_t clear_priv);
+void *bpf_object__priv(struct bpf_object *prog);
+
 /* Accessors of bpf_program. */
 struct bpf_program;
 struct bpf_program *bpf_program__next(struct bpf_program *prog,

commit 705fa2190dfb3d02f83adcd1abdb4e7dc3434597
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 13 10:44:02 2016 +0000

    tools lib bpf: Report error when kernel doesn't support program type
    
    Now libbpf support tracepoint program type. Report meaningful error when kernel
    version is less than 4.7.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1468406646-21642-3-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index eb2a4c45f6b6..dd7a513efb10 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -39,6 +39,7 @@ enum libbpf_errno {
 	LIBBPF_ERRNO__VERIFY,	/* Kernel verifier blocks program loading */
 	LIBBPF_ERRNO__PROG2BIG,	/* Program too big */
 	LIBBPF_ERRNO__KVER,	/* Incorrect kernel version */
+	LIBBPF_ERRNO__PROGTYPE,	/* Kernel doesn't support this program type */
 	__LIBBPF_ERRNO__END,
 };
 

commit 5f44e4c810bf3ace5a97a84554d4eeccbb563ca5
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 13 10:44:01 2016 +0000

    tools lib bpf: New API to adjust type of a BPF program
    
    Add 4 new APIs to adjust and query the type of a BPF program.
    Load program according to type set by caller. Default is set to
    BPF_PROG_TYPE_KPROBE.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1468406646-21642-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f392c5e04cc1..eb2a4c45f6b6 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -164,6 +164,15 @@ int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
 
 int bpf_program__nth_fd(struct bpf_program *prog, int n);
 
+/*
+ * Adjust type of bpf program. Default is kprobe.
+ */
+int bpf_program__set_tracepoint(struct bpf_program *prog);
+int bpf_program__set_kprobe(struct bpf_program *prog);
+
+bool bpf_program__is_tracepoint(struct bpf_program *prog);
+bool bpf_program__is_kprobe(struct bpf_program *prog);
+
 /*
  * We don't need __attribute__((packed)) now since it is
  * unnecessary for 'bpf_map_def' because they are all aligned.

commit 203d1cacaddfc1e320f1e2625502fd1e0de465bd
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Jul 4 11:02:42 2016 +0000

    tools lib bpf: Add license header
    
    Adding a missing license descriptopn header to files in libbpf, make it
    LGPL-2.1.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Eric Leblond <eleblond@stamus-networks.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1467630162-193121-1-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 148df3640ba0..f392c5e04cc1 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -4,6 +4,19 @@
  * Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
  * Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  * Copyright (C) 2015 Huawei Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * version 2.1 of the License (not later!)
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not,  see <http://www.gnu.org/licenses>
  */
 #ifndef __BPF_LIBBPF_H
 #define __BPF_LIBBPF_H

commit de8a63bd5076761fad4e236c93350fdf297708be
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jun 28 13:23:37 2016 +0100

    tools lib bpf: Fix spelling mistake: "missmatch" -> "mismatch"
    
    Trivial fix to spelling mistake
    
    Signed-off-by: Colin King <colin.king@canonical.com>
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/r/1467116617-8318-1-git-send-email-colin.king@canonical.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 722f46b2d553..148df3640ba0 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -19,7 +19,7 @@ enum libbpf_errno {
 	LIBBPF_ERRNO__LIBELF = __LIBBPF_ERRNO__START,
 	LIBBPF_ERRNO__FORMAT,	/* BPF object format invalid */
 	LIBBPF_ERRNO__KVERSION,	/* Incorrect or no 'version' section */
-	LIBBPF_ERRNO__ENDIAN,	/* Endian missmatch */
+	LIBBPF_ERRNO__ENDIAN,	/* Endian mismatch */
 	LIBBPF_ERRNO__INTERNAL,	/* Internal error in libbpf */
 	LIBBPF_ERRNO__RELOC,	/* Relocation failed */
 	LIBBPF_ERRNO__LOAD,	/* Load program failure for unknown reason */

commit edb13ed47c1a196eca4b669b7c20d26b27260813
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jun 3 12:38:21 2016 -0300

    tools lib bpf: Rename set_private() to set_priv()
    
    For consistency with class__priv() elsewhere, and with the callback
    typedef for clearing those areas (e.g. bpf_map_clear_priv_t).
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-rnbiyv27ohw8xppsgx0el3xb@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 372cecbde207..722f46b2d553 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -78,8 +78,8 @@ struct bpf_program *bpf_program__next(struct bpf_program *prog,
 typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
 					 void *);
 
-int bpf_program__set_private(struct bpf_program *prog, void *priv,
-			     bpf_program_clear_priv_t clear_priv);
+int bpf_program__set_priv(struct bpf_program *prog, void *priv,
+			  bpf_program_clear_priv_t clear_priv);
 
 void *bpf_program__priv(struct bpf_program *prog);
 
@@ -184,8 +184,8 @@ const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
-int bpf_map__set_private(struct bpf_map *map, void *priv,
-			 bpf_map_clear_priv_t clear_priv);
+int bpf_map__set_priv(struct bpf_map *map, void *priv,
+		      bpf_map_clear_priv_t clear_priv);
 void *bpf_map__priv(struct bpf_map *map);
 
 #endif

commit be834ffbd15ea9d73ba96fdbdcb1012add7e3bdf
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jun 3 12:36:39 2016 -0300

    tools lib bpf: Make bpf_program__get_private() use IS_ERR()
    
    For consistency with bpf_map__priv() and elsewhere.
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-x17nk5mrazkf45z0l0ahlmo8@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ea65775e8302..372cecbde207 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -81,8 +81,7 @@ typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
 int bpf_program__set_private(struct bpf_program *prog, void *priv,
 			     bpf_program_clear_priv_t clear_priv);
 
-int bpf_program__get_private(struct bpf_program *prog,
-			     void **ppriv);
+void *bpf_program__priv(struct bpf_program *prog);
 
 const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 

commit a7fe0450b0142d0eb4a543840a43e22682debf25
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jun 3 12:22:51 2016 -0300

    tools lib bpf: Remove _get_ from non-refcount method names
    
    The use of this term is not warranted here, we use it in the kernel
    sources and in tools/ for refcounting, so, for consistency, rename them.
    
    Acked-bu: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-4ya1ot2e2fkrz48ws9ebiofs@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index cb838d0ea753..ea65775e8302 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -55,8 +55,8 @@ void bpf_object__close(struct bpf_object *object);
 /* Load/unload object into/from kernel */
 int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
-const char *bpf_object__get_name(struct bpf_object *obj);
-unsigned int bpf_object__get_kversion(struct bpf_object *obj);
+const char *bpf_object__name(struct bpf_object *obj);
+unsigned int bpf_object__kversion(struct bpf_object *obj);
 
 struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
@@ -171,7 +171,7 @@ struct bpf_map_def {
  */
 struct bpf_map;
 struct bpf_map *
-bpf_object__get_map_by_name(struct bpf_object *obj, const char *name);
+bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);
 
 struct bpf_map *
 bpf_map__next(struct bpf_map *map, struct bpf_object *obj);

commit 6e009e65a1e5202313fdaccde3bcb94272989eba
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jun 3 12:15:52 2016 -0300

    tools lib bpf: Rename bpf_map__get_fd() to bpf_map__fd()
    
    For consistency, leaving "get" for reference counting.
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-msy8sxfz9th6gl2xjeci2btm@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index bad5bac58db4..cb838d0ea753 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -180,7 +180,7 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 	     (pos) != NULL;				\
 	     (pos) = bpf_map__next((pos), (obj)))
 
-int bpf_map__get_fd(struct bpf_map *map);
+int bpf_map__fd(struct bpf_map *map);
 const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
 

commit 53897a78ca6d4bd64e8c17d76cfec65d237f9447
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jun 2 14:21:06 2016 -0300

    tools lib bpf: Use IS_ERR() reporting macros with bpf_map__get_def()
    
    And for consistency, rename it to bpf_map__def(), leaving "get" for
    reference counting.
    
    Also make it return a const pointer, as suggested by Wang.
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-mer00xqkiho0ymg66b5i9luw@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f8fbba4ccef3..bad5bac58db4 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -181,7 +181,7 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 	     (pos) = bpf_map__next((pos), (obj)))
 
 int bpf_map__get_fd(struct bpf_map *map);
-int bpf_map__get_def(struct bpf_map *map, struct bpf_map_def *pdef);
+const struct bpf_map_def *bpf_map__def(struct bpf_map *map);
 const char *bpf_map__name(struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);

commit 009ad5d5945697a887f0c1b2d581503d92dcde6f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jun 2 11:02:05 2016 -0300

    tools lib bpf: Rename bpf_map__get_name() to bpf_map__name()
    
    For consistency, leaving "get" for reference counting.
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-crnflv84ejyhpba933ec71gs@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 916abf971249..f8fbba4ccef3 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -182,7 +182,7 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 
 int bpf_map__get_fd(struct bpf_map *map);
 int bpf_map__get_def(struct bpf_map *map, struct bpf_map_def *pdef);
-const char *bpf_map__get_name(struct bpf_map *map);
+const char *bpf_map__name(struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_private(struct bpf_map *map, void *priv,

commit b4cbfa5670414a567a8a3b368047538f522eff6a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Jun 2 10:51:59 2016 -0300

    tools lib bpf: Use IS_ERR() reporting macros with bpf_map__get_private()
    
    To try to, over time, consistently use the IS_ERR() interface instead of
    using two return values, i.e. the integer return value for an error and
    the pointer address to return the bpf_map->priv pointer.
    
    Also rename it to bpf__priv(), to leave the "get" term for reference
    counting.
    
    Noticed while working on using BPF for collecting non-integer syscall
    argument payloads (struct sockaddr in calls such as connect(), for
    instance), where we need to use BPF maps and thus generalise
    bpf__setup_stdout() to connect bpf_output events with maps in a bpf
    proggie.
    
    Acked-by: Wang Nan <wangnan0@huawei.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: http://lkml.kernel.org/n/tip-saypxyd6ptrct379jqgxx4bl@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index a51594c7b518..916abf971249 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -187,6 +187,6 @@ const char *bpf_map__get_name(struct bpf_map *map);
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_private(struct bpf_map *map, void *priv,
 			 bpf_map_clear_priv_t clear_priv);
-int bpf_map__get_private(struct bpf_map *map, void **ppriv);
+void *bpf_map__priv(struct bpf_map *map);
 
 #endif

commit 561bbccac72d08babafaa33fd7fa9100ec4c9fb6
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 27 08:47:36 2015 +0000

    tools lib bpf: Extract and collect map names from BPF object file
    
    This patch collects name of maps in BPF object files and saves them into
    'maps' field in 'struct bpf_object'. 'bpf_object__get_map_by_name' is
    introduced to retrive fd and definitions of a map through its name.
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1448614067-197576-3-git-send-email-wangnan0@huawei.com
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ef631255dfaa..a51594c7b518 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -170,6 +170,8 @@ struct bpf_map_def {
  * it is not a uapi header so no need to consider name clash.
  */
 struct bpf_map;
+struct bpf_map *
+bpf_object__get_map_by_name(struct bpf_object *obj, const char *name);
 
 struct bpf_map *
 bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
@@ -180,6 +182,7 @@ bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
 
 int bpf_map__get_fd(struct bpf_map *map);
 int bpf_map__get_def(struct bpf_map *map, struct bpf_map_def *pdef);
+const char *bpf_map__get_name(struct bpf_map *map);
 
 typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
 int bpf_map__set_private(struct bpf_map *map, void *priv,

commit 9d759a9b4ac2690077d8b21258e6e95c3e34bfa9
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 27 08:47:35 2015 +0000

    tools lib bpf: Collect map definition in bpf_object
    
    This patch collects more information from maps sections in BPF object
    files into 'struct bpf_object', enables later patches access those
    information (such as the type and size of the map).
    
    In this patch, a new handler 'struct bpf_map' is extracted in parallel
    with bpf_object and bpf_program. Its iterator and accessor is also
    created.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1448614067-197576-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 949df4b346cf..ef631255dfaa 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -165,4 +165,25 @@ struct bpf_map_def {
 	unsigned int max_entries;
 };
 
+/*
+ * There is another 'struct bpf_map' in include/linux/map.h. However,
+ * it is not a uapi header so no need to consider name clash.
+ */
+struct bpf_map;
+
+struct bpf_map *
+bpf_map__next(struct bpf_map *map, struct bpf_object *obj);
+#define bpf_map__for_each(pos, obj)		\
+	for ((pos) = bpf_map__next(NULL, (obj));	\
+	     (pos) != NULL;				\
+	     (pos) = bpf_map__next((pos), (obj)))
+
+int bpf_map__get_fd(struct bpf_map *map);
+int bpf_map__get_def(struct bpf_map *map, struct bpf_map_def *pdef);
+
+typedef void (*bpf_map_clear_priv_t)(struct bpf_map *, void *);
+int bpf_map__set_private(struct bpf_map *map, void *priv,
+			 bpf_map_clear_priv_t clear_priv);
+int bpf_map__get_private(struct bpf_map *map, void **ppriv);
+
 #endif

commit b580563e38487d9db8e94080149644da71c533c1
Author: Wang Nan <wangnan0@huawei.com>
Date:   Mon Nov 16 12:10:09 2015 +0000

    bpf tools: Load a program with different instances using preprocessor
    
    This patch is a preparation for BPF prologue support which allows
    generating a series of BPF bytecode for fetching kernel data before
    calling program code. With the newly introduced multiple instances
    support, perf is able to create different prologues for different kprobe
    points.
    
    Before this patch, a bpf_program can be loaded into kernel only once,
    and get the only resulting fd. What this patch does is to allow creating
    and loading different variants of one bpf_program, then fetching their
    fds.
    
    Here we describe the basic idea in this patch. The detailed description
    of the newly introduced APIs can be found in comments in the patch body.
    
    The key of this patch is the new mechanism in bpf_program__load().
    Instead of loading BPF program into kernel directly, it calls a
    'pre-processor' to generate program instances which would be finally
    loaded into the kernel based on the original code. To enable the
    generation of multiple instances, libbpf passes an index to the
    pre-processor so it know which instance is being loaded.
    
    Pre-processor should be called from libbpf's user (perf) using
    bpf_program__set_prep(). The number of instances and the relationship
    between indices and the target instance should be clear when calling
    bpf_program__set_prep().
    
    To retrieve a fd for a specific instance of a program,
    bpf_program__nth_fd() is introduced. It returns the resulting fd
    according to index.
    
    Signed-off-by: He Kuang <hekuang@huawei.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1447675815-166222-8-git-send-email-wangnan0@huawei.com
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    [ Enclosed multi-line if/else blocks with {}, (*func_ptr)() -> func_ptr() ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index c9a9aef2806c..949df4b346cf 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -88,6 +88,70 @@ const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
 int bpf_program__fd(struct bpf_program *prog);
 
+struct bpf_insn;
+
+/*
+ * Libbpf allows callers to adjust BPF programs before being loaded
+ * into kernel. One program in an object file can be transform into
+ * multiple variants to be attached to different code.
+ *
+ * bpf_program_prep_t, bpf_program__set_prep and bpf_program__nth_fd
+ * are APIs for this propose.
+ *
+ * - bpf_program_prep_t:
+ *   It defines 'preprocessor', which is a caller defined function
+ *   passed to libbpf through bpf_program__set_prep(), and will be
+ *   called before program is loaded. The processor should adjust
+ *   the program one time for each instances according to the number
+ *   passed to it.
+ *
+ * - bpf_program__set_prep:
+ *   Attachs a preprocessor to a BPF program. The number of instances
+ *   whould be created is also passed through this function.
+ *
+ * - bpf_program__nth_fd:
+ *   After the program is loaded, get resuling fds from bpf program for
+ *   each instances.
+ *
+ * If bpf_program__set_prep() is not used, the program whould be loaded
+ * without adjustment during bpf_object__load(). The program has only
+ * one instance. In this case bpf_program__fd(prog) is equal to
+ * bpf_program__nth_fd(prog, 0).
+ */
+
+struct bpf_prog_prep_result {
+	/*
+	 * If not NULL, load new instruction array.
+	 * If set to NULL, don't load this instance.
+	 */
+	struct bpf_insn *new_insn_ptr;
+	int new_insn_cnt;
+
+	/* If not NULL, result fd is set to it */
+	int *pfd;
+};
+
+/*
+ * Parameters of bpf_program_prep_t:
+ *  - prog:	The bpf_program being loaded.
+ *  - n:	Index of instance being generated.
+ *  - insns:	BPF instructions array.
+ *  - insns_cnt:Number of instructions in insns.
+ *  - res:	Output parameter, result of transformation.
+ *
+ * Return value:
+ *  - Zero: pre-processing success.
+ *  - Non-zero: pre-processing, stop loading.
+ */
+typedef int (*bpf_program_prep_t)(struct bpf_program *prog, int n,
+				  struct bpf_insn *insns, int insns_cnt,
+				  struct bpf_prog_prep_result *res);
+
+int bpf_program__set_prep(struct bpf_program *prog, int nr_instance,
+			  bpf_program_prep_t prep);
+
+int bpf_program__nth_fd(struct bpf_program *prog, int n);
+
 /*
  * We don't need __attribute__((packed)) now since it is
  * unnecessary for 'bpf_map_def' because they are all aligned.

commit 45825d8ab8ef6287f5d05aea141419d8d4278852
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 6 13:49:38 2015 +0000

    bpf tools: Add new API bpf_object__get_kversion()
    
    bpf_object__get_kversion() can be used to fetch value of object's
    'version' section. Following patch will use it for error reporting.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1446817783-86722-3-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 30a40e9fa503..c9a9aef2806c 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -56,6 +56,7 @@ void bpf_object__close(struct bpf_object *object);
 int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
 const char *bpf_object__get_name(struct bpf_object *obj);
+unsigned int bpf_object__get_kversion(struct bpf_object *obj);
 
 struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\

commit 6371ca3b541c82d8aa6a9002bd52d92bcdda5944
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Nov 6 13:49:37 2015 +0000

    bpf tools: Improve libbpf error reporting
    
    In this patch, a series of libbpf specific error numbers and
    libbpf_strerror() are introduced to help reporting errors.
    
    Functions are updated to pass correct the error number through the
    CHECK_ERR() macro.
    
    All users of bpf_object__open{_buffer}() and bpf_program__title() in
    perf are modified accordingly. In addition, due to the error codes
    changing, bpf__strerror_load() is also modified to use them.
    
    bpf__strerror_head() is also changed accordingly so it can parse libbpf
    errors. bpf_loader_strerror() is introduced for that purpose, and will
    be improved by the following patch.
    
    load_program() is improved not to dump log buffer if it is empty. log
    buffer is also used to deduce whether the error was caused by an invalid
    program or other problem.
    
    v1 -> v2:
    
     - Using macro for error code.
    
     - Fetch error message based on array index, eliminate for-loop.
    
     - Use log buffer to detect the reason of failure. 3 new error code
       are introduced to replace LIBBPF_ERRNO__LOAD.
    
    In v1:
    
      # perf record -e ./test_ill_program.o ls
      event syntax error: './test_ill_program.o'
                           \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
      SKIP
    
      # perf record -e ./test_kversion_nomatch_program.o ls
      event syntax error: './test_kversion_nomatch_program.o'
                           \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
      SKIP
    
      # perf record -e ./test_big_program.o ls
      event syntax error: './test_big_program.o'
                           \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
      SKIP
    
      In v2:
    
      # perf record -e ./test_ill_program.o ls
      event syntax error: './test_ill_program.o'
                           \___ Kernel verifier blocks program loading
      SKIP
    
      # perf record -e ./test_kversion_nomatch_program.o
      event syntax error: './test_kversion_nomatch_program.o'
                           \___ Incorrect kernel version
      SKIP
      (Will be further improved by following patches)
    
      # perf record -e ./test_big_program.o
      event syntax error: './test_big_program.o'
                           \___ Program too big
      SKIP
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1446817783-86722-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index bc80af03c6f4..30a40e9fa503 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -10,6 +10,26 @@
 
 #include <stdio.h>
 #include <stdbool.h>
+#include <linux/err.h>
+
+enum libbpf_errno {
+	__LIBBPF_ERRNO__START = 4000,
+
+	/* Something wrong in libelf */
+	LIBBPF_ERRNO__LIBELF = __LIBBPF_ERRNO__START,
+	LIBBPF_ERRNO__FORMAT,	/* BPF object format invalid */
+	LIBBPF_ERRNO__KVERSION,	/* Incorrect or no 'version' section */
+	LIBBPF_ERRNO__ENDIAN,	/* Endian missmatch */
+	LIBBPF_ERRNO__INTERNAL,	/* Internal error in libbpf */
+	LIBBPF_ERRNO__RELOC,	/* Relocation failed */
+	LIBBPF_ERRNO__LOAD,	/* Load program failure for unknown reason */
+	LIBBPF_ERRNO__VERIFY,	/* Kernel verifier blocks program loading */
+	LIBBPF_ERRNO__PROG2BIG,	/* Program too big */
+	LIBBPF_ERRNO__KVER,	/* Incorrect kernel version */
+	__LIBBPF_ERRNO__END,
+};
+
+int libbpf_strerror(int err, char *buf, size_t size);
 
 /*
  * In include/linux/compiler-gcc.h, __printf is defined. However

commit 715f8db9102f1ab40ea4a87bedfe86399323698f
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Tue Nov 3 20:21:05 2015 +0900

    tools lib bpf: Fix compiler warning on CentOS 6
    
        CC       libbpf.o
      cc1: warnings being treated as errors
      libbpf.c: In function 'bpf_program__title':
      libbpf.c:1037: error: declaration of 'dup' shadows a global declaration
      /usr/include/unistd.h:528: error: shadowed declaration is here
      mv: cannot stat `./.libbpf.o.tmp': No such file or directory
      make[3]: *** [libbpf.o] Error 1
      make[2]: *** [libbpf-in.o] Error 2
      make[1]: *** [/linux/tools/lib/bpf/libbpf.a] Error 2
      make[1]: *** Waiting for unfinished jobs....
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/1446549665-2342-1-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index f16170c95ffd..bc80af03c6f4 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -63,7 +63,7 @@ int bpf_program__set_private(struct bpf_program *prog, void *priv,
 int bpf_program__get_private(struct bpf_program *prog,
 			     void **ppriv);
 
-const char *bpf_program__title(struct bpf_program *prog, bool dup);
+const char *bpf_program__title(struct bpf_program *prog, bool needs_copy);
 
 int bpf_program__fd(struct bpf_program *prog);
 

commit acf860ae7c53cc8b0c5d372c218332aac3eeba4f
Author: Wang Nan <wangnan0@huawei.com>
Date:   Thu Aug 27 02:30:55 2015 +0000

    bpf tools: New API to get name from a BPF object
    
    Before this patch there's no way to connect a loaded bpf object
    to its source file. However, during applying perf's '--filter' to BPF
    object, without this connection makes things harder, because perf loads
    all programs together, but '--filter' setting is for each object.
    
    The API of bpf_object__open_buffer() is changed to allow passing a name.
    Fortunately, at this time there's only one user of it (perf test LLVM),
    so we change it together.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1440742821-44548-2-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ea8adc206b62..f16170c95ffd 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -28,12 +28,14 @@ struct bpf_object;
 
 struct bpf_object *bpf_object__open(const char *path);
 struct bpf_object *bpf_object__open_buffer(void *obj_buf,
-					   size_t obj_buf_sz);
+					   size_t obj_buf_sz,
+					   const char *name);
 void bpf_object__close(struct bpf_object *object);
 
 /* Load/unload object into/from kernel */
 int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
+const char *bpf_object__get_name(struct bpf_object *obj);
 
 struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\

commit 9a208effd1832e50e1f7ea002f400f8b9ca8b1ed
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:14:10 2015 +0000

    bpf tools: Link all bpf objects onto a list
    
    To allow enumeration of all bpf_objects, keep them in a list (hidden to
    caller). bpf_object__for_each_safe() is introduced to do this iteration.
    It is safe even user close the object during iteration.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-23-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 657e497bd586..ea8adc206b62 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -35,6 +35,13 @@ void bpf_object__close(struct bpf_object *object);
 int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
 
+struct bpf_object *bpf_object__next(struct bpf_object *prev);
+#define bpf_object__for_each_safe(pos, tmp)			\
+	for ((pos) = bpf_object__next(NULL),		\
+		(tmp) = bpf_object__next(pos);		\
+	     (pos) != NULL;				\
+	     (pos) = (tmp), (tmp) = bpf_object__next(tmp))
+
 /* Accessors of bpf_program. */
 struct bpf_program;
 struct bpf_program *bpf_program__next(struct bpf_program *prog,

commit aa9b1ac33c7979d0d91eff8b70cffc4916f5555c
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:14:08 2015 +0000

    bpf tools: Introduce accessors for struct bpf_program
    
    This patch introduces accessors for user of libbpf to retrieve section
    name and fd of a opened/loaded eBPF program. 'struct bpf_prog_handler'
    is used for that purpose. Accessors of programs section name and file
    descriptor are provided. Set/get private data are also impelmented.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Link: http://lkml.kernel.org/r/1435716878-189507-21-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 3e6960075835..657e497bd586 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -9,6 +9,7 @@
 #define __BPF_LIBBPF_H
 
 #include <stdio.h>
+#include <stdbool.h>
 
 /*
  * In include/linux/compiler-gcc.h, __printf is defined. However
@@ -34,6 +35,29 @@ void bpf_object__close(struct bpf_object *object);
 int bpf_object__load(struct bpf_object *obj);
 int bpf_object__unload(struct bpf_object *obj);
 
+/* Accessors of bpf_program. */
+struct bpf_program;
+struct bpf_program *bpf_program__next(struct bpf_program *prog,
+				      struct bpf_object *obj);
+
+#define bpf_object__for_each_program(pos, obj)		\
+	for ((pos) = bpf_program__next(NULL, (obj));	\
+	     (pos) != NULL;				\
+	     (pos) = bpf_program__next((pos), (obj)))
+
+typedef void (*bpf_program_clear_priv_t)(struct bpf_program *,
+					 void *);
+
+int bpf_program__set_private(struct bpf_program *prog, void *priv,
+			     bpf_program_clear_priv_t clear_priv);
+
+int bpf_program__get_private(struct bpf_program *prog,
+			     void **ppriv);
+
+const char *bpf_program__title(struct bpf_program *prog, bool dup);
+
+int bpf_program__fd(struct bpf_program *prog);
+
 /*
  * We don't need __attribute__((packed)) now since it is
  * unnecessary for 'bpf_map_def' because they are all aligned.

commit 52d3352e79815307521bef6121dba00b6c3477c6
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:14:04 2015 +0000

    bpf tools: Create eBPF maps defined in an object file
    
    This patch creates maps based on 'map' section in object file using
    bpf_create_map(), and stores the fds into an array in 'struct
    bpf_object'.
    
    Previous patches parse ELF object file and collects required data, but
    doesn't play with the kernel. They belong to the 'opening' phase. This
    patch is the first patch in 'loading' phase. The 'loaded' field is
    introduced in 'struct bpf_object' to avoid loading an object twice,
    because the loading phase clears resources collected during the opening
    which becomes useless after loading. In this patch, maps_buf is cleared.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-17-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 6e75acdb9112..3e6960075835 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -30,6 +30,10 @@ struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 					   size_t obj_buf_sz);
 void bpf_object__close(struct bpf_object *object);
 
+/* Load/unload object into/from kernel */
+int bpf_object__load(struct bpf_object *obj);
+int bpf_object__unload(struct bpf_object *obj);
+
 /*
  * We don't need __attribute__((packed)) now since it is
  * unnecessary for 'bpf_map_def' because they are all aligned.

commit 340909152ae5a588b9a77a85df35d61ec3523833
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:14:02 2015 +0000

    bpf tools: Record map accessing instructions for each program
    
    This patch records the indices of instructions which are needed to be
    relocated. That information is saved in the 'reloc_desc' field in
    'struct bpf_program'. In the loading phase (this patch takes effect in
    the opening phase), the collected instructions will be replaced by map
    loading instructions.
    
    Since we are going to close the ELF file and clear all data at the end
    of the 'opening' phase, the ELF information will no longer be valid in
    the 'loading' phase. We have to locate the instructions before maps are
    loaded, instead of directly modifying the instruction.
    
    'struct bpf_map_def' is introduced in this patch to let us know how many
    maps are defined in the object.
    
    This is the third part of map relocation. The principle of map relocation
    is described in commit message of 'bpf tools: Collect symbol table from
    SHT_SYMTAB section'.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-15-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index dc966dd9fd75..6e75acdb9112 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -30,4 +30,17 @@ struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 					   size_t obj_buf_sz);
 void bpf_object__close(struct bpf_object *object);
 
+/*
+ * We don't need __attribute__((packed)) now since it is
+ * unnecessary for 'bpf_map_def' because they are all aligned.
+ * In addition, using it will trigger -Wpacked warning message,
+ * and will be treated as an error due to -Werror.
+ */
+struct bpf_map_def {
+	unsigned int type;
+	unsigned int key_size;
+	unsigned int value_size;
+	unsigned int max_entries;
+};
+
 #endif

commit 6c956392b0486c170e382476ab9dd97a696fd169
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:13:54 2015 +0000

    bpf tools: Read eBPF object from buffer
    
    To support dynamic compiling, this patch allows caller to pass a
    in-memory buffer to libbpf by bpf_object__open_buffer(). libbpf calls
    elf_memory() to open it as ELF object file.
    
    Because __bpf_object__open() collects all required data and won't need
    that buffer anymore, libbpf uses that buffer directly instead of clone a
    new buffer. Caller of libbpf can free that buffer or use it do other
    things after bpf_object__open_buffer() return.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-7-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index ec3301ceeb85..dc966dd9fd75 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -26,6 +26,8 @@ void libbpf_set_print(libbpf_print_fn_t warn,
 struct bpf_object;
 
 struct bpf_object *bpf_object__open(const char *path);
+struct bpf_object *bpf_object__open_buffer(void *obj_buf,
+					   size_t obj_buf_sz);
 void bpf_object__close(struct bpf_object *object);
 
 #endif

commit 1a5e3fb1e9a4a3e3695cd57c33c169a90d16fd3b
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:13:53 2015 +0000

    bpf tools: Open eBPF object file and do basic validation
    
    This patch defines basic interface of libbpf. 'struct bpf_object' will
    be the handler of each object file. Its internal structure is hide to
    user. eBPF object files are compiled by LLVM as ELF format. In this
    patch, libelf is used to open those files, read EHDR and do basic
    validation according to e_type and e_machine.
    
    All elf related staffs are grouped together and reside in efile field of
    'struct bpf_object'. bpf_object__elf_finish() is introduced to clear it.
    
    After all eBPF programs in an object file are loaded, related ELF
    information is useless. Close the object file and free those memory.
    
    The zfree() and zclose() functions are introduced to ensure setting NULL
    pointers and negative file descriptors after resources are released.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-6-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 8d1eebafa958..ec3301ceeb85 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -8,6 +8,8 @@
 #ifndef __BPF_LIBBPF_H
 #define __BPF_LIBBPF_H
 
+#include <stdio.h>
+
 /*
  * In include/linux/compiler-gcc.h, __printf is defined. However
  * it should be better if libbpf.h doesn't depend on Linux header file.
@@ -20,4 +22,10 @@ void libbpf_set_print(libbpf_print_fn_t warn,
 		      libbpf_print_fn_t info,
 		      libbpf_print_fn_t debug);
 
+/* Hide internal to user */
+struct bpf_object;
+
+struct bpf_object *bpf_object__open(const char *path);
+void bpf_object__close(struct bpf_object *object);
+
 #endif

commit b3f59d66e22b8be4ccae67c8eaffa2cbb9e54eb1
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:13:52 2015 +0000

    bpf tools: Allow caller to set printing function
    
    By libbpf_set_print(), users of libbpf are allowed to register he/she
    own debug, info and warning printing functions. Libbpf will use those
    functions to print messages. If not provided, default info and warning
    printing functions are fprintf(stderr, ...); default debug printing
    is NULL.
    
    This API is designed to be used by perf, enables it to register its own
    logging functions to make all logs uniform, instead of separated
    logging level control.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Cc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-5-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index a6f46d908097..8d1eebafa958 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -8,4 +8,16 @@
 #ifndef __BPF_LIBBPF_H
 #define __BPF_LIBBPF_H
 
+/*
+ * In include/linux/compiler-gcc.h, __printf is defined. However
+ * it should be better if libbpf.h doesn't depend on Linux header file.
+ * So instead of __printf, here we use gcc attribute directly.
+ */
+typedef int (*libbpf_print_fn_t)(const char *, ...)
+	__attribute__((format(printf, 1, 2)));
+
+void libbpf_set_print(libbpf_print_fn_t warn,
+		      libbpf_print_fn_t info,
+		      libbpf_print_fn_t debug);
+
 #endif

commit 1b76c13e4b36f978ea45af079f38ad423a229630
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Jul 1 02:13:51 2015 +0000

    bpf tools: Introduce 'bpf' library and add bpf feature check
    
    This is the first patch of libbpf. The goal of libbpf is to create a
    standard way for accessing eBPF object files. This patch creates
    'Makefile' and 'Build' for it, allows 'make' to build libbpf.a and
    libbpf.so, 'make install' to put them into proper directories.
    Most part of Makefile is borrowed from traceevent.
    
    Before building, it checks the existence of libelf in Makefile, and deny
    to build if not found. Instead of throwing an error if libelf not found,
    the error raises in a phony target "elfdep". This design is to ensure
    'make clean' still workable even if libelf is not found.
    
    Because libbpf requires 'kern_version' field set for 'union bpf_attr'
    (bpfdep" is used for that dependency), Kernel BPF API is also checked
    by intruducing a new feature check 'bpf' into tools/build/feature,
    which checks the existence and version of linux/bpf.h. When building
    libbpf, it searches that file from include/uapi/linux in kernel source
    tree (controlled by FEATURE_CHECK_CFLAGS-bpf). Since it searches kernel
    source tree it reside, installing of newest kernel headers is not
    required, except we are trying to port these files to an old kernel.
    
    To avoid checking that file when perf building, the newly introduced
    'bpf' feature check doesn't added into FEATURE_TESTS and
    FEATURE_DISPLAY by default in tools/build/Makefile.feature, but added
    into libbpf's specific.
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: He Kuang <hekuang@huawei.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Kaixu Xia <xiakaixu@huawei.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Zefan Li <lizefan@huawei.com>
    Bcc: pi3orama@163.com
    Link: http://lkml.kernel.org/r/1435716878-189507-4-git-send-email-wangnan0@huawei.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
new file mode 100644
index 000000000000..a6f46d908097
--- /dev/null
+++ b/tools/lib/bpf/libbpf.h
@@ -0,0 +1,11 @@
+/*
+ * Common eBPF ELF object loading operations.
+ *
+ * Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
+ * Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
+ * Copyright (C) 2015 Huawei Inc.
+ */
+#ifndef __BPF_LIBBPF_H
+#define __BPF_LIBBPF_H
+
+#endif
