commit 385bbf7b119a4feb6d6bcf3586f1bb1dd9c5b0a0
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:50:57 2020 -0500

    bpf, libbpf: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200507185057.GA13981@embeddedor

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 8c3afbd97747..50d70e90d5f1 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -153,7 +153,7 @@ struct btf_ext_info_sec {
 	__u32	sec_name_off;
 	__u32	num_info;
 	/* Followed by num_info * record_size number of bytes */
-	__u8	data[0];
+	__u8	data[];
 };
 
 /* The minimum bpf_func_info checked by the loader */

commit 12dd14b230b3c742b80272ecb8a83cdf824625ca
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Thu Dec 19 13:07:14 2019 +0100

    libbpf: Add missing newline in opts validation macro
    
    The error log output in the opts validation macro was missing a newline.
    
    Fixes: 2ce8450ef5a3 ("libbpf: add bpf_object__open_{file, mem} w/ extensible opts")
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20191219120714.928380-1-toke@redhat.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 7d71621bb7e8..8c3afbd97747 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -76,7 +76,7 @@ static inline bool libbpf_validate_opts(const char *opts,
 
 		for (i = opts_sz; i < user_sz; i++) {
 			if (opts[i]) {
-				pr_warn("%s has non-zero extra bytes",
+				pr_warn("%s has non-zero extra bytes\n",
 					type_name);
 				return false;
 			}

commit 612d05be250aa8804d3baba7a12445a267a580d3
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:43:27 2019 -0800

    libbpf: Move non-public APIs from libbpf.h to libbpf_internal.h
    
    Few libbpf APIs are not public but currently exposed through libbpf.h to be
    used by bpftool. Move them to libbpf_internal.h, where intent of being
    non-stable and non-public is much more obvious.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191214014341.3442258-4-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index f4f10715db40..7d71621bb7e8 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -100,6 +100,23 @@ int parse_cpu_mask_file(const char *fcpu, bool **mask, int *mask_sz);
 int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
 			 const char *str_sec, size_t str_len);
 
+int bpf_object__section_size(const struct bpf_object *obj, const char *name,
+			     __u32 *size);
+int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
+				__u32 *off);
+
+struct nlattr;
+typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
+int libbpf_netlink_open(unsigned int *nl_pid);
+int libbpf_nl_get_link(int sock, unsigned int nl_pid,
+		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
+int libbpf_nl_get_class(int sock, unsigned int nl_pid, int ifindex,
+			libbpf_dump_nlmsg_t dump_class_nlmsg, void *cookie);
+int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
+			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
+int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
+			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
+
 struct btf_ext_info {
 	/*
 	 * info points to the individual info section (e.g. func_info and

commit 6803ee25f0ead1e836808acb14396bb9a9849113
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Dec 11 17:35:48 2019 -0800

    libbpf: Extract and generalize CPU mask parsing logic
    
    This logic is re-used for parsing a set of online CPUs. Having it as an
    isolated piece of code working with input string makes it conveninent to test
    this logic as well. While refactoring, also improve the robustness of original
    implementation.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191212013548.1690564-1-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 97ac17a64a58..f4f10715db40 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -95,6 +95,8 @@ static inline bool libbpf_validate_opts(const char *opts,
 #define OPTS_GET(opts, field, fallback_value) \
 	(OPTS_HAS(opts, field) ? (opts)->field : fallback_value)
 
+int parse_cpu_mask_str(const char *s, bool **mask, int *mask_sz);
+int parse_cpu_mask_file(const char *fcpu, bool **mask, int *mask_sz);
 int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
 			 const char *str_sec, size_t str_len);
 

commit ee26dade0e3bcd8a34ae7520e373fb69365fce7a
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Nov 1 15:28:07 2019 -0700

    libbpf: Add support for relocatable bitfields
    
    Add support for the new field relocation kinds, necessary to support
    relocatable bitfield reads. Provide macro for abstracting necessary code doing
    full relocatable bitfield extraction into u64 value. Two separate macros are
    provided:
    - BPF_CORE_READ_BITFIELD macro for direct memory read-enabled BPF programs
    (e.g., typed raw tracepoints). It uses direct memory dereference to extract
    bitfield backing integer value.
    - BPF_CORE_READ_BITFIELD_PROBED macro for cases where bpf_probe_read() needs
    to be used to extract same backing integer value.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20191101222810.1246166-3-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index bd6f48ea407b..97ac17a64a58 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -158,7 +158,11 @@ struct bpf_line_info_min {
  */
 enum bpf_field_info_kind {
 	BPF_FIELD_BYTE_OFFSET = 0,	/* field byte offset */
+	BPF_FIELD_BYTE_SIZE = 1,
 	BPF_FIELD_EXISTS = 2,		/* field existence in target kernel */
+	BPF_FIELD_SIGNED = 3,
+	BPF_FIELD_LSHIFT_U64 = 4,
+	BPF_FIELD_RSHIFT_U64 = 5,
 };
 
 /* The minimum bpf_field_reloc checked by the loader

commit 5b7fe93db008ff013db24239136a25f3ac5142ac
Merge: b951248518e6 027cbaaf6198
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 26 22:57:27 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next
    
    Daniel Borkmann says:
    
    ====================
    pull-request: bpf-next 2019-10-27
    
    The following pull-request contains BPF updates for your *net-next* tree.
    
    We've added 52 non-merge commits during the last 11 day(s) which contain
    a total of 65 files changed, 2604 insertions(+), 1100 deletions(-).
    
    The main changes are:
    
     1) Revolutionize BPF tracing by using in-kernel BTF to type check BPF
        assembly code. The work here teaches BPF verifier to recognize
        kfree_skb()'s first argument as 'struct sk_buff *' in tracepoints
        such that verifier allows direct use of bpf_skb_event_output() helper
        used in tc BPF et al (w/o probing memory access) that dumps skb data
        into perf ring buffer. Also add direct loads to probe memory in order
        to speed up/replace bpf_probe_read() calls, from Alexei Starovoitov.
    
     2) Big batch of changes to improve libbpf and BPF kselftests. Besides
        others: generalization of libbpf's CO-RE relocation support to now
        also include field existence relocations, revamp the BPF kselftest
        Makefile to add test runner concept allowing to exercise various
        ways to build BPF programs, and teach bpf_object__open() and friends
        to automatically derive BPF program type/expected attach type from
        section names to ease their use, from Andrii Nakryiko.
    
     3) Fix deadlock in stackmap's build-id lookup on rq_lock(), from Song Liu.
    
     4) Allow to read BTF as raw data from bpftool. Most notable use case
        is to dump /sys/kernel/btf/vmlinux through this, from Jiri Olsa.
    
     5) Use bpf_redirect_map() helper in libbpf's AF_XDP helper prog which
        manages to improve "rx_drop" performance by ~4%., from Björn Töpel.
    
     6) Fix to restore the flow dissector after reattach BPF test and also
        fix error handling in bpf_helper_defs.h generation, from Jakub Sitnicki.
    
     7) Improve verifier's BTF ctx access for use outside of raw_tp, from
        Martin KaFai Lau.
    
     8) Improve documentation for AF_XDP with new sections and to reflect
        latest features, from Magnus Karlsson.
    
     9) Add back 'version' section parsing to libbpf for old kernels, from
        John Fastabend.
    
    10) Fix strncat bounds error in libbpf's libbpf_prog_type_by_name(),
        from KP Singh.
    
    11) Turn on -mattr=+alu32 in LLVM by default for BPF kselftests in order
        to improve insn coverage for built BPF progs, from Yonghong Song.
    
    12) Misc minor cleanups and fixes, from various others.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit be18010ea2d83c184cc32afdc895410a1cf2cbd5
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Mon Oct 21 13:55:32 2019 +0800

    tools, bpf: Rename pr_warning to pr_warn to align with kernel logging
    
    For kernel logging macros, pr_warning() is completely removed and
    replaced by pr_warn(). By using pr_warn() in tools/lib/bpf/ for
    symmetry to kernel logging macros, we could eventually drop the
    use of pr_warning() in the whole kernel tree.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20191021055532.185245-1-wangkefeng.wang@huawei.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 5bfe85d4f8aa..b2880766e6b9 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -43,7 +43,7 @@ do {				\
 	libbpf_print(level, "libbpf: " fmt, ##__VA_ARGS__);	\
 } while (0)
 
-#define pr_warning(fmt, ...)	__pr(LIBBPF_WARN, fmt, ##__VA_ARGS__)
+#define pr_warn(fmt, ...)	__pr(LIBBPF_WARN, fmt, ##__VA_ARGS__)
 #define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
 #define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
 
@@ -52,7 +52,7 @@ static inline bool libbpf_validate_opts(const char *opts,
 					const char *type_name)
 {
 	if (user_sz < sizeof(size_t)) {
-		pr_warning("%s size (%zu) is too small\n", type_name, user_sz);
+		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
 		return false;
 	}
 	if (user_sz > opts_sz) {
@@ -60,8 +60,8 @@ static inline bool libbpf_validate_opts(const char *opts,
 
 		for (i = opts_sz; i < user_sz; i++) {
 			if (opts[i]) {
-				pr_warning("%s has non-zero extra bytes",
-					   type_name);
+				pr_warn("%s has non-zero extra bytes",
+					type_name);
 				return false;
 			}
 		}

commit 2f184393e0c2d409c62262f57f2a57efdf9370b8
Merge: ebcd670d05d5 531e93d11470
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 19 22:51:25 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Several cases of overlapping changes which were for the most
    part trivially resolvable.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 511bb0085c6fe48353c35cd3d25f4f8720579a6d
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Oct 15 11:28:45 2019 -0700

    libbpf: Update BTF reloc support to latest Clang format
    
    BTF offset reloc was generalized in recent Clang into field relocation,
    capturing extra u32 field, specifying what aspect of captured field
    needs to be relocated. This changes .BTF.ext's record size for this
    relocation from 12 bytes to 16 bytes. Given these format changes
    happened in Clang before official released version, it's ok to not
    support outdated 12-byte record size w/o breaking ABI.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191015182849.3922287-2-andriin@fb.com

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index f51444fc7eb7..5bfe85d4f8aa 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -110,7 +110,7 @@ struct btf_ext {
 	};
 	struct btf_ext_info func_info;
 	struct btf_ext_info line_info;
-	struct btf_ext_info offset_reloc_info;
+	struct btf_ext_info field_reloc_info;
 	__u32 data_size;
 };
 
@@ -135,13 +135,23 @@ struct bpf_line_info_min {
 	__u32	line_col;
 };
 
-/* The minimum bpf_offset_reloc checked by the loader
+/* bpf_field_info_kind encodes which aspect of captured field has to be
+ * adjusted by relocations. Currently supported values are:
+ *   - BPF_FIELD_BYTE_OFFSET: field offset (in bytes);
+ *   - BPF_FIELD_EXISTS: field existence (1, if field exists; 0, otherwise);
+ */
+enum bpf_field_info_kind {
+	BPF_FIELD_BYTE_OFFSET = 0,	/* field byte offset */
+	BPF_FIELD_EXISTS = 2,		/* field existence in target kernel */
+};
+
+/* The minimum bpf_field_reloc checked by the loader
  *
- * Offset relocation captures the following data:
+ * Field relocation captures the following data:
  * - insn_off - instruction offset (in bytes) within a BPF program that needs
- *   its insn->imm field to be relocated with actual offset;
+ *   its insn->imm field to be relocated with actual field info;
  * - type_id - BTF type ID of the "root" (containing) entity of a relocatable
- *   offset;
+ *   field;
  * - access_str_off - offset into corresponding .BTF string section. String
  *   itself encodes an accessed field using a sequence of field and array
  *   indicies, separated by colon (:). It's conceptually very close to LLVM's
@@ -172,15 +182,16 @@ struct bpf_line_info_min {
  * bpf_probe_read(&dst, sizeof(dst),
  *		  __builtin_preserve_access_index(&src->a.b.c));
  *
- * In this case Clang will emit offset relocation recording necessary data to
+ * In this case Clang will emit field relocation recording necessary data to
  * be able to find offset of embedded `a.b.c` field within `src` struct.
  *
  *   [0] https://llvm.org/docs/LangRef.html#getelementptr-instruction
  */
-struct bpf_offset_reloc {
+struct bpf_field_reloc {
 	__u32   insn_off;
 	__u32   type_id;
 	__u32   access_str_off;
+	enum bpf_field_info_kind kind;
 };
 
 #endif /* __LIBBPF_LIBBPF_INTERNAL_H */

commit 2ce8450ef5a381e5ffeb4682c0093a3ab5d07008
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Oct 4 15:40:35 2019 -0700

    libbpf: add bpf_object__open_{file, mem} w/ extensible opts
    
    Add new set of bpf_object__open APIs using new approach to optional
    parameters extensibility allowing simpler ABI compatibility approach.
    
    This patch demonstrates an approach to implementing libbpf APIs that
    makes it easy to extend existing APIs with extra optional parameters in
    such a way, that ABI compatibility is preserved without having to do
    symbol versioning and generating lots of boilerplate code to handle it.
    To facilitate succinct code for working with options, add OPTS_VALID,
    OPTS_HAS, and OPTS_GET macros that hide all the NULL, size, and zero
    checks.
    
    Additionally, newly added libbpf APIs are encouraged to follow similar
    pattern of having all mandatory parameters as formal function parameters
    and always have optional (NULL-able) xxx_opts struct, which should
    always have real struct size as a first field and the rest would be
    optional parameters added over time, which tune the behavior of existing
    API, if specified by user.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 2e83a34f8c79..f51444fc7eb7 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -47,6 +47,38 @@ do {				\
 #define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
 #define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
 
+static inline bool libbpf_validate_opts(const char *opts,
+					size_t opts_sz, size_t user_sz,
+					const char *type_name)
+{
+	if (user_sz < sizeof(size_t)) {
+		pr_warning("%s size (%zu) is too small\n", type_name, user_sz);
+		return false;
+	}
+	if (user_sz > opts_sz) {
+		size_t i;
+
+		for (i = opts_sz; i < user_sz; i++) {
+			if (opts[i]) {
+				pr_warning("%s has non-zero extra bytes",
+					   type_name);
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+#define OPTS_VALID(opts, type)						      \
+	(!(opts) || libbpf_validate_opts((const char *)opts,		      \
+					 offsetofend(struct type,	      \
+						     type##__last_field),     \
+					 (opts)->sz, #type))
+#define OPTS_HAS(opts, field) \
+	((opts) && opts->sz >= offsetofend(typeof(*(opts)), field))
+#define OPTS_GET(opts, field, fallback_value) \
+	(OPTS_HAS(opts, field) ? (opts)->field : fallback_value)
+
 int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
 			 const char *str_sec, size_t str_len);
 

commit 1bd63524593b964934a33afd442df16b8f90e2b5
Author: Yonghong Song <yhs@fb.com>
Date:   Mon Sep 30 14:02:03 2019 -0700

    libbpf: handle symbol versioning properly for libbpf.a
    
    bcc uses libbpf repo as a submodule. It brings in libbpf source
    code and builds everything together to produce shared libraries.
    With latest libbpf, I got the following errors:
      /bin/ld: libbcc_bpf.so.0.10.0: version node not found for symbol xsk_umem__create@LIBBPF_0.0.2
      /bin/ld: failed to set dynamic section sizes: Bad value
      collect2: error: ld returned 1 exit status
      make[2]: *** [src/cc/libbcc_bpf.so.0.10.0] Error 1
    
    In xsk.c, we have
      asm(".symver xsk_umem__create_v0_0_2, xsk_umem__create@LIBBPF_0.0.2");
      asm(".symver xsk_umem__create_v0_0_4, xsk_umem__create@@LIBBPF_0.0.4");
    The linker thinks the built is for LIBBPF but cannot find proper version
    LIBBPF_0.0.2/4, so emit errors.
    
    I also confirmed that using libbpf.a to produce a shared library also
    has issues:
      -bash-4.4$ cat t.c
      extern void *xsk_umem__create;
      void * test() { return xsk_umem__create; }
      -bash-4.4$ gcc -c -fPIC t.c
      -bash-4.4$ gcc -shared t.o libbpf.a -o t.so
      /bin/ld: t.so: version node not found for symbol xsk_umem__create@LIBBPF_0.0.2
      /bin/ld: failed to set dynamic section sizes: Bad value
      collect2: error: ld returned 1 exit status
      -bash-4.4$
    
    Symbol versioning does happens in commonly used libraries, e.g., elfutils
    and glibc. For static libraries, for a versioned symbol, the old definitions
    will be ignored, and the symbol will be an alias to the latest definition.
    For example, glibc sched_setaffinity is versioned.
      -bash-4.4$ readelf -s /usr/lib64/libc.so.6 | grep sched_setaffinity
         756: 000000000013d3d0    13 FUNC    GLOBAL DEFAULT   13 sched_setaffinity@GLIBC_2.3.3
         757: 00000000000e2e70   455 FUNC    GLOBAL DEFAULT   13 sched_setaffinity@@GLIBC_2.3.4
        1800: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sched_setaffinity.c
        4228: 00000000000e2e70   455 FUNC    LOCAL  DEFAULT   13 __sched_setaffinity_new
        4648: 000000000013d3d0    13 FUNC    LOCAL  DEFAULT   13 __sched_setaffinity_old
        7338: 000000000013d3d0    13 FUNC    GLOBAL DEFAULT   13 sched_setaffinity@GLIBC_2
        7380: 00000000000e2e70   455 FUNC    GLOBAL DEFAULT   13 sched_setaffinity@@GLIBC_
      -bash-4.4$
    For static library, the definition of sched_setaffinity aliases to the new definition.
      -bash-4.4$ readelf -s /usr/lib64/libc.a | grep sched_setaffinity
      File: /usr/lib64/libc.a(sched_setaffinity.o)
         8: 0000000000000000   455 FUNC    GLOBAL DEFAULT    1 __sched_setaffinity_new
        12: 0000000000000000   455 FUNC    WEAK   DEFAULT    1 sched_setaffinity
    
    For both elfutils and glibc, additional macros are used to control different handling
    of symbol versioning w.r.t static and shared libraries.
    For elfutils, the macro is SYMBOL_VERSIONING
    (https://sourceware.org/git/?p=elfutils.git;a=blob;f=lib/eu-config.h).
    For glibc, the macro is SHARED
    (https://sourceware.org/git/?p=glibc.git;a=blob;f=include/shlib-compat.h;hb=refs/heads/master)
    
    This patch used SHARED as the macro name. After this patch, the libbpf.a has
      -bash-4.4$ readelf -s libbpf.a | grep xsk_umem__create
         372: 0000000000017145  1190 FUNC    GLOBAL DEFAULT    1 xsk_umem__create_v0_0_4
         405: 0000000000017145  1190 FUNC    GLOBAL DEFAULT    1 xsk_umem__create
         499: 00000000000175eb   103 FUNC    GLOBAL DEFAULT    1 xsk_umem__create_v0_0_2
      -bash-4.4$
    No versioned symbols for xsk_umem__create.
    The libbpf.a can be used to build a shared library succesfully.
      -bash-4.4$ cat t.c
      extern void *xsk_umem__create;
      void * test() { return xsk_umem__create; }
      -bash-4.4$ gcc -c -fPIC t.c
      -bash-4.4$ gcc -shared t.o libbpf.a -o t.so
      -bash-4.4$
    
    Fixes: 10d30e301732 ("libbpf: add flags to umem config")
    Cc: Kevin Laatz <kevin.laatz@intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 2e83a34f8c79..98216a69c32f 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -34,6 +34,22 @@
 	(offsetof(TYPE, FIELD) + sizeof(((TYPE *)0)->FIELD))
 #endif
 
+/* Symbol versioning is different between static and shared library.
+ * Properly versioned symbols are needed for shared library, but
+ * only the symbol of the new version is needed for static library.
+ */
+#ifdef SHARED
+# define COMPAT_VERSION(internal_name, api_name, version) \
+	asm(".symver " #internal_name "," #api_name "@" #version);
+# define DEFAULT_VERSION(internal_name, api_name, version) \
+	asm(".symver " #internal_name "," #api_name "@@" #version);
+#else
+# define COMPAT_VERSION(internal_name, api_name, version)
+# define DEFAULT_VERSION(internal_name, api_name, version) \
+	extern typeof(internal_name) api_name \
+	__attribute__((alias(#internal_name)));
+#endif
+
 extern void libbpf_print(enum libbpf_print_level level,
 			 const char *format, ...)
 	__attribute__((format(printf, 2, 3)));

commit 4cedc0dad9b5bf55c4180c833be35e27e5d6cdbb
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Aug 7 14:39:50 2019 -0700

    libbpf: add .BTF.ext offset relocation section loading
    
    Add support for BPF CO-RE offset relocations. Add section/record
    iteration macros for .BTF.ext. These macro are useful for iterating over
    each .BTF.ext record, either for dumping out contents or later for BPF
    CO-RE relocation handling.
    
    To enable other parts of libbpf to work with .BTF.ext contents, moved
    a bunch of type definitions into libbpf_internal.h.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 2ac29bd36226..2e83a34f8c79 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -29,6 +29,10 @@
 #ifndef max
 # define max(x, y) ((x) < (y) ? (y) : (x))
 #endif
+#ifndef offsetofend
+# define offsetofend(TYPE, FIELD) \
+	(offsetof(TYPE, FIELD) + sizeof(((TYPE *)0)->FIELD))
+#endif
 
 extern void libbpf_print(enum libbpf_print_level level,
 			 const char *format, ...)
@@ -46,4 +50,105 @@ do {				\
 int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
 			 const char *str_sec, size_t str_len);
 
+struct btf_ext_info {
+	/*
+	 * info points to the individual info section (e.g. func_info and
+	 * line_info) from the .BTF.ext. It does not include the __u32 rec_size.
+	 */
+	void *info;
+	__u32 rec_size;
+	__u32 len;
+};
+
+#define for_each_btf_ext_sec(seg, sec)					\
+	for (sec = (seg)->info;						\
+	     (void *)sec < (seg)->info + (seg)->len;			\
+	     sec = (void *)sec + sizeof(struct btf_ext_info_sec) +	\
+		   (seg)->rec_size * sec->num_info)
+
+#define for_each_btf_ext_rec(seg, sec, i, rec)				\
+	for (i = 0, rec = (void *)&(sec)->data;				\
+	     i < (sec)->num_info;					\
+	     i++, rec = (void *)rec + (seg)->rec_size)
+
+struct btf_ext {
+	union {
+		struct btf_ext_header *hdr;
+		void *data;
+	};
+	struct btf_ext_info func_info;
+	struct btf_ext_info line_info;
+	struct btf_ext_info offset_reloc_info;
+	__u32 data_size;
+};
+
+struct btf_ext_info_sec {
+	__u32	sec_name_off;
+	__u32	num_info;
+	/* Followed by num_info * record_size number of bytes */
+	__u8	data[0];
+};
+
+/* The minimum bpf_func_info checked by the loader */
+struct bpf_func_info_min {
+	__u32   insn_off;
+	__u32   type_id;
+};
+
+/* The minimum bpf_line_info checked by the loader */
+struct bpf_line_info_min {
+	__u32	insn_off;
+	__u32	file_name_off;
+	__u32	line_off;
+	__u32	line_col;
+};
+
+/* The minimum bpf_offset_reloc checked by the loader
+ *
+ * Offset relocation captures the following data:
+ * - insn_off - instruction offset (in bytes) within a BPF program that needs
+ *   its insn->imm field to be relocated with actual offset;
+ * - type_id - BTF type ID of the "root" (containing) entity of a relocatable
+ *   offset;
+ * - access_str_off - offset into corresponding .BTF string section. String
+ *   itself encodes an accessed field using a sequence of field and array
+ *   indicies, separated by colon (:). It's conceptually very close to LLVM's
+ *   getelementptr ([0]) instruction's arguments for identifying offset to 
+ *   a field.
+ *
+ * Example to provide a better feel.
+ *
+ *   struct sample {
+ *       int a;
+ *       struct {
+ *           int b[10];
+ *       };
+ *   };
+ *
+ *   struct sample *s = ...;
+ *   int x = &s->a;     // encoded as "0:0" (a is field #0)
+ *   int y = &s->b[5];  // encoded as "0:1:0:5" (anon struct is field #1, 
+ *                      // b is field #0 inside anon struct, accessing elem #5)
+ *   int z = &s[10]->b; // encoded as "10:1" (ptr is used as an array)
+ *
+ * type_id for all relocs in this example  will capture BTF type id of
+ * `struct sample`.
+ *
+ * Such relocation is emitted when using __builtin_preserve_access_index()
+ * Clang built-in, passing expression that captures field address, e.g.:
+ *
+ * bpf_probe_read(&dst, sizeof(dst),
+ *		  __builtin_preserve_access_index(&src->a.b.c));
+ *
+ * In this case Clang will emit offset relocation recording necessary data to
+ * be able to find offset of embedded `a.b.c` field within `src` struct.
+ *
+ *   [0] https://llvm.org/docs/LangRef.html#getelementptr-instruction
+ */
+struct bpf_offset_reloc {
+	__u32   insn_off;
+	__u32   type_id;
+	__u32   access_str_off;
+};
+
 #endif /* __LIBBPF_LIBBPF_INTERNAL_H */

commit dca73a65a68329ee386d3ff473152bac66eaab39
Merge: 497ad9f5b2dc 94079b64255f
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 20 00:06:27 2019 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next
    
    Alexei Starovoitov says:
    
    ====================
    pull-request: bpf-next 2019-06-19
    
    The following pull-request contains BPF updates for your *net-next* tree.
    
    The main changes are:
    
    1) new SO_REUSEPORT_DETACH_BPF setsocktopt, from Martin.
    
    2) BTF based map definition, from Andrii.
    
    3) support bpf_map_lookup_elem for xskmap, from Jonathan.
    
    4) bounded loops and scalar precision logic in the verifier, from Alexei.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 13091aa30535b719e269f20a7bc34002bf5afae5
Merge: f97252a8c33f 29f785ff76b6
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jun 17 19:48:13 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Honestly all the conflicts were simple overlapping changes,
    nothing really interesting to report.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d7fe74f9404a9736e9d4f754c30e43640a822c17
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Mon Jun 17 12:26:50 2019 -0700

    libbpf: add common min/max macro to libbpf_internal.h
    
    Multiple files in libbpf redefine their own definitions for min/max.
    Let's define them in libbpf_internal.h and use those everywhere.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 850f7bdec5cb..554a7856dc2d 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -23,6 +23,13 @@
 #define BTF_PARAM_ENC(name, type) (name), (type)
 #define BTF_VAR_SECINFO_ENC(type, offset, size) (type), (offset), (size)
 
+#ifndef min
+# define min(x, y) ((x) < (y) ? (x) : (y))
+#endif
+#ifndef max
+# define max(x, y) ((x) < (y) ? (y) : (x))
+#endif
+
 extern void libbpf_print(enum libbpf_print_level level,
 			 const char *format, ...)
 	__attribute__((format(printf, 2, 3)));

commit cfd4921049269ee6765b4a1cb820b95d0df5dda5
Author: Michal Rostecki <mrostecki@opensuse.org>
Date:   Wed May 29 20:31:09 2019 +0200

    libbpf: Return btf_fd for load_sk_storage_btf
    
    Before this change, function load_sk_storage_btf expected that
    libbpf__probe_raw_btf was returning a BTF descriptor, but in fact it was
    returning an information about whether the probe was successful (0 or
    1). load_sk_storage_btf was using that value as an argument of the close
    function, which was resulting in closing stdout and thus terminating the
    process which called that function.
    
    That bug was visible in bpftool. `bpftool feature` subcommand was always
    exiting too early (because of closed stdout) and it didn't display all
    requested probes. `bpftool -j feature` or `bpftool -p feature` were not
    returning a valid json object.
    
    This change renames the libbpf__probe_raw_btf function to
    libbpf__load_raw_btf, which now returns a BTF descriptor, as expected in
    load_sk_storage_btf.
    
    v2:
    - Fix typo in the commit message.
    
    v3:
    - Simplify BTF descriptor handling in bpf_object__probe_btf_* functions.
    - Rename libbpf__probe_raw_btf function to libbpf__load_raw_btf and
    return a BTF descriptor.
    
    v4:
    - Fix typo in the commit message.
    
    Fixes: d7c4b3980c18 ("libbpf: detect supported kernel BTF features and sanitize BTF")
    Signed-off-by: Michal Rostecki <mrostecki@opensuse.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index f3025b4d90e1..dfab8012185c 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -34,7 +34,7 @@ do {				\
 #define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
 #define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
 
-int libbpf__probe_raw_btf(const char *raw_types, size_t types_len,
-			  const char *str_sec, size_t str_len);
+int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
+			 const char *str_sec, size_t str_len);
 
 #endif /* __LIBBPF_LIBBPF_INTERNAL_H */

commit 1d7a08b3bdaec1e25ba7979ff598272b7e34318f
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri May 24 11:58:56 2019 -0700

    libbpf: ensure libbpf.h is included along libbpf_internal.h
    
    libbpf_internal.h expects a bunch of stuff defined in libbpf.h to be
    defined. This patch makes sure that libbpf.h is always included.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index f3025b4d90e1..850f7bdec5cb 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -9,6 +9,8 @@
 #ifndef __LIBBPF_LIBBPF_INTERNAL_H
 #define __LIBBPF_LIBBPF_INTERNAL_H
 
+#include "libbpf.h"
+
 #define BTF_INFO_ENC(kind, kind_flag, vlen) \
 	((!!(kind_flag) << 31) | ((kind) << 24) | ((vlen) & BTF_MAX_VLEN))
 #define BTF_TYPE_ENC(name, info, size_or_type) (name), (info), (size_or_type)

commit d72386fe7a8472f859333b078fd8bb9d254d51f2
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed May 15 20:39:27 2019 -0700

    libbpf: move logging helpers into libbpf_internal.h
    
    libbpf_util.h header was recently exposed as public as a dependency of
    xsk.h. In addition to memory barriers, it contained logging helpers,
    which are not supposed to be exposed. This patch moves those into
    libbpf_internal.h, which is kept as an internal header.
    
    Cc: Stanislav Fomichev <sdf@google.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Fixes: 7080da890984 ("libbpf: add libbpf_util.h to header install.")
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 789e435b5900..f3025b4d90e1 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -21,6 +21,19 @@
 #define BTF_PARAM_ENC(name, type) (name), (type)
 #define BTF_VAR_SECINFO_ENC(type, offset, size) (type), (offset), (size)
 
+extern void libbpf_print(enum libbpf_print_level level,
+			 const char *format, ...)
+	__attribute__((format(printf, 2, 3)));
+
+#define __pr(level, fmt, ...)	\
+do {				\
+	libbpf_print(level, "libbpf: " fmt, ##__VA_ARGS__);	\
+} while (0)
+
+#define pr_warning(fmt, ...)	__pr(LIBBPF_WARN, fmt, ##__VA_ARGS__)
+#define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
+#define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
+
 int libbpf__probe_raw_btf(const char *raw_types, size_t types_len,
 			  const char *str_sec, size_t str_len);
 

commit d7c4b3980c18e81c0470f5df6d96d832f446d26f
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri May 10 14:13:15 2019 -0700

    libbpf: detect supported kernel BTF features and sanitize BTF
    
    Depending on used versions of libbpf, Clang, and kernel, it's possible to
    have valid BPF object files with valid BTF information, that still won't
    load successfully due to Clang emitting newer BTF features (e.g.,
    BTF_KIND_FUNC, .BTF.ext's line_info/func_info, BTF_KIND_DATASEC, etc), that
    are not yet supported by older kernel.
    
    This patch adds detection of BTF features and sanitizes BPF object's BTF
    by substituting various supported BTF kinds, which have compatible layout:
      - BTF_KIND_FUNC -> BTF_KIND_TYPEDEF
      - BTF_KIND_FUNC_PROTO -> BTF_KIND_ENUM
      - BTF_KIND_VAR -> BTF_KIND_INT
      - BTF_KIND_DATASEC -> BTF_KIND_STRUCT
    
    Replacement is done in such a way as to preserve as much information as
    possible (names, sizes, etc) where possible without violating kernel's
    validation rules.
    
    v2->v3:
      - remove duplicate #defines from libbpf_util.h
    
    v1->v2:
      - add internal libbpf_internal.h w/ common stuff
      - switch SK storage BTF to use new libbpf__probe_raw_btf()
    
    Reported-by: Alexei Starovoitov <ast@fb.com>
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
new file mode 100644
index 000000000000..789e435b5900
--- /dev/null
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+
+/*
+ * Internal libbpf helpers.
+ *
+ * Copyright (c) 2019 Facebook
+ */
+
+#ifndef __LIBBPF_LIBBPF_INTERNAL_H
+#define __LIBBPF_LIBBPF_INTERNAL_H
+
+#define BTF_INFO_ENC(kind, kind_flag, vlen) \
+	((!!(kind_flag) << 31) | ((kind) << 24) | ((vlen) & BTF_MAX_VLEN))
+#define BTF_TYPE_ENC(name, info, size_or_type) (name), (info), (size_or_type)
+#define BTF_INT_ENC(encoding, bits_offset, nr_bits) \
+	((encoding) << 24 | (bits_offset) << 16 | (nr_bits))
+#define BTF_TYPE_INT_ENC(name, encoding, bits_offset, bits, sz) \
+	BTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_INT, 0, 0), sz), \
+	BTF_INT_ENC(encoding, bits_offset, bits)
+#define BTF_MEMBER_ENC(name, type, bits_offset) (name), (type), (bits_offset)
+#define BTF_PARAM_ENC(name, type) (name), (type)
+#define BTF_VAR_SECINFO_ENC(type, offset, size) (type), (offset), (size)
+
+int libbpf__probe_raw_btf(const char *raw_types, size_t types_len,
+			  const char *str_sec, size_t str_len);
+
+#endif /* __LIBBPF_LIBBPF_INTERNAL_H */
