commit 5fbc220862fc7a53a0455ccd2d96c82141e222d4
Author: Yonghong Song <yhs@fb.com>
Date:   Sat May 9 10:59:19 2020 -0700

    tools/libpf: Add offsetof/container_of macro in bpf_helpers.h
    
    These two helpers will be used later in bpf_iter bpf program
    bpf_iter_netlink.c. Put them in bpf_helpers.h since they could
    be useful in other cases.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/20200509175919.2477104-1-yhs@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index da00b87aa199..f67dce2af802 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -36,6 +36,20 @@
 #define __weak __attribute__((weak))
 #endif
 
+/*
+ * Helper macro to manipulate data structures
+ */
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE *)0)->MEMBER)
+#endif
+#ifndef container_of
+#define container_of(ptr, type, member)				\
+	({							\
+		void *__mptr = (void *)(ptr);			\
+		((type *)(__mptr - offsetof(type, member)));	\
+	})
+#endif
+
 /*
  * Helper structure used by eBPF C program
  * to describe BPF map attributes to libbpf loader

commit 646f02ffdd49c466cb81642c2b013beb80092d01
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Apr 28 17:27:39 2020 -0700

    libbpf: Add BTF-defined map-in-map support
    
    As discussed at LPC 2019 ([0]), this patch brings (a quite belated) support
    for declarative BTF-defined map-in-map support in libbpf. It allows to define
    ARRAY_OF_MAPS and HASH_OF_MAPS BPF maps without any user-space initialization
    code involved.
    
    Additionally, it allows to initialize outer map's slots with references to
    respective inner maps at load time, also completely declaratively.
    
    Despite a weak type system of C, the way BTF-defined map-in-map definition
    works, it's actually quite hard to accidentally initialize outer map with
    incompatible inner maps. This being C, of course, it's still possible, but
    even that would be caught at load time and error returned with helpful debug
    log pointing exactly to the slot that failed to be initialized.
    
    As an example, here's a rather advanced HASH_OF_MAPS declaration and
    initialization example, filling slots #0 and #4 with two inner maps:
    
      #include <bpf/bpf_helpers.h>
    
      struct inner_map {
              __uint(type, BPF_MAP_TYPE_ARRAY);
              __uint(max_entries, 1);
              __type(key, int);
              __type(value, int);
      } inner_map1 SEC(".maps"),
        inner_map2 SEC(".maps");
    
      struct outer_hash {
              __uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);
              __uint(max_entries, 5);
              __uint(key_size, sizeof(int));
              __array(values, struct inner_map);
      } outer_hash SEC(".maps") = {
              .values = {
                      [0] = &inner_map2,
                      [4] = &inner_map1,
              },
      };
    
    Here's the relevant part of libbpf debug log showing pretty clearly of what's
    going on with map-in-map initialization:
    
      libbpf: .maps relo #0: for 6 value 0 rel.r_offset 96 name 260 ('inner_map1')
      libbpf: .maps relo #0: map 'outer_arr' slot [0] points to map 'inner_map1'
      libbpf: .maps relo #1: for 7 value 32 rel.r_offset 112 name 249 ('inner_map2')
      libbpf: .maps relo #1: map 'outer_arr' slot [2] points to map 'inner_map2'
      libbpf: .maps relo #2: for 7 value 32 rel.r_offset 144 name 249 ('inner_map2')
      libbpf: .maps relo #2: map 'outer_hash' slot [0] points to map 'inner_map2'
      libbpf: .maps relo #3: for 6 value 0 rel.r_offset 176 name 260 ('inner_map1')
      libbpf: .maps relo #3: map 'outer_hash' slot [4] points to map 'inner_map1'
      libbpf: map 'inner_map1': created successfully, fd=4
      libbpf: map 'inner_map2': created successfully, fd=5
      libbpf: map 'outer_hash': created successfully, fd=7
      libbpf: map 'outer_hash': slot [0] set to map 'inner_map2' fd=5
      libbpf: map 'outer_hash': slot [4] set to map 'inner_map1' fd=4
    
    Notice from the log above that fd=6 (not logged explicitly) is used for inner
    "prototype" map, necessary for creation of outer map. It is destroyed
    immediately after outer map is created.
    
    See also included selftest with some extra comments explaining extra details
    of usage. Additionally, similar initialization syntax and libbpf functionality
    can be used to do initialization of BPF_PROG_ARRAY with references to BPF
    sub-programs. This can be done in follow up patches, if there will be a demand
    for this.
    
      [0] https://linuxplumbersconf.org/event/4/contributions/448/
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/20200429002739.48006-4-andriin@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 60aad054eea1..da00b87aa199 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -12,6 +12,7 @@
 
 #define __uint(name, val) int (*name)[val]
 #define __type(name, val) typeof(val) *name
+#define __array(name, val) typeof(val) *name[]
 
 /* Helper macro to print out debug messages */
 #define bpf_printk(fmt, ...)				\

commit ae460c022453337850bdc36a36bf7596a6cfcf99
Author: Yoshiki Komachi <komachi.yoshiki@gmail.com>
Date:   Tue Apr 21 09:05:27 2020 +0900

    bpf_helpers.h: Add note for building with vmlinux.h or linux/types.h
    
    The following error was shown when a bpf program was compiled without
    vmlinux.h auto-generated from BTF:
    
     # clang -I./linux/tools/lib/ -I/lib/modules/$(uname -r)/build/include/ \
       -O2 -Wall -target bpf -emit-llvm -c bpf_prog.c -o bpf_prog.bc
     ...
     In file included from linux/tools/lib/bpf/bpf_helpers.h:5:
     linux/tools/lib/bpf/bpf_helper_defs.h:56:82: error: unknown type name '__u64'
     ...
    
    It seems that bpf programs are intended for being built together with
    the vmlinux.h (which will have all the __u64 and other typedefs). But
    users may mistakenly think "include <linux/types.h>" is missing
    because the vmlinux.h is not common for non-bpf developers. IMO, an
    explicit comment therefore should be added to bpf_helpers.h as this
    patch shows.
    
    Signed-off-by: Yoshiki Komachi <komachi.yoshiki@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/1587427527-29399-1-git-send-email-komachi.yoshiki@gmail.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index f69cc208778a..60aad054eea1 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -2,6 +2,12 @@
 #ifndef __BPF_HELPERS__
 #define __BPF_HELPERS__
 
+/*
+ * Note that bpf programs need to include either
+ * vmlinux.h (auto-generated from BTF) or linux/types.h
+ * in advance since bpf_helper_defs.h uses such types
+ * as __u64.
+ */
 #include "bpf_helper_defs.h"
 
 #define __uint(name, val) int (*name)[val]

commit 81bfdd087bf31a87c5ff25cc7004d5308954a35c
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Wed Dec 18 16:28:34 2019 -0800

    libbpf: Put Kconfig externs into .kconfig section
    
    Move Kconfig-provided externs into custom .kconfig section. Add __kconfig into
    bpf_helpers.h for user convenience. Update selftests accordingly.
    
    Suggested-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191219002837.3074619-2-andriin@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index aa46700075e1..f69cc208778a 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -53,4 +53,6 @@ enum libbpf_tristate {
 	TRI_MODULE = 2,
 };
 
+#define __kconfig __attribute__((section(".kconfig")))
+
 #endif

commit 166750bc1dd256b2184b22588fb9fe6d3fbb93ae
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:47:08 2019 -0800

    libbpf: Support libbpf-provided extern variables
    
    Add support for extern variables, provided to BPF program by libbpf. Currently
    the following extern variables are supported:
      - LINUX_KERNEL_VERSION; version of a kernel in which BPF program is
        executing, follows KERNEL_VERSION() macro convention, can be 4- and 8-byte
        long;
      - CONFIG_xxx values; a set of values of actual kernel config. Tristate,
        boolean, strings, and integer values are supported.
    
    Set of possible values is determined by declared type of extern variable.
    Supported types of variables are:
    - Tristate values. Are represented as `enum libbpf_tristate`. Accepted values
      are **strictly** 'y', 'n', or 'm', which are represented as TRI_YES, TRI_NO,
      or TRI_MODULE, respectively.
    - Boolean values. Are represented as bool (_Bool) types. Accepted values are
      'y' and 'n' only, turning into true/false values, respectively.
    - Single-character values. Can be used both as a substritute for
      bool/tristate, or as a small-range integer:
      - 'y'/'n'/'m' are represented as is, as characters 'y', 'n', or 'm';
      - integers in a range [-128, 127] or [0, 255] (depending on signedness of
        char in target architecture) are recognized and represented with
        respective values of char type.
    - Strings. String values are declared as fixed-length char arrays. String of
      up to that length will be accepted and put in first N bytes of char array,
      with the rest of bytes zeroed out. If config string value is longer than
      space alloted, it will be truncated and warning message emitted. Char array
      is always zero terminated. String literals in config have to be enclosed in
      double quotes, just like C-style string literals.
    - Integers. 8-, 16-, 32-, and 64-bit integers are supported, both signed and
      unsigned variants. Libbpf enforces parsed config value to be in the
      supported range of corresponding integer type. Integers values in config can
      be:
      - decimal integers, with optional + and - signs;
      - hexadecimal integers, prefixed with 0x or 0X;
      - octal integers, starting with 0.
    
    Config file itself is searched in /boot/config-$(uname -r) location with
    fallback to /proc/config.gz, unless config path is specified explicitly
    through bpf_object_open_opts' kernel_config_path option. Both gzipped and
    plain text formats are supported. Libbpf adds explicit dependency on zlib
    because of this, but this shouldn't be a problem, given libelf already depends
    on zlib.
    
    All detected extern variables, are put into a separate .extern internal map.
    It, similarly to .rodata map, is marked as read-only from BPF program side, as
    well as is frozen on load. This allows BPF verifier to track extern values as
    constants and perform enhanced branch prediction and dead code elimination.
    This can be relied upon for doing kernel version/feature detection and using
    potentially unsupported field relocations or BPF helpers in a CO-RE-based BPF
    program, while still having a single version of BPF program running on old and
    new kernels. Selftests are validating this explicitly for unexisting BPF
    helper.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191214014710.3449601-3-andriin@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 0c7d28292898..aa46700075e1 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -25,6 +25,9 @@
 #ifndef __always_inline
 #define __always_inline __attribute__((always_inline))
 #endif
+#ifndef __weak
+#define __weak __attribute__((weak))
+#endif
 
 /*
  * Helper structure used by eBPF C program
@@ -44,4 +47,10 @@ enum libbpf_pin_type {
 	LIBBPF_PIN_BY_NAME,
 };
 
+enum libbpf_tristate {
+	TRI_NO = 0,
+	TRI_YES = 1,
+	TRI_MODULE = 2,
+};
+
 #endif

commit f9a7cf6eb17cd0110c8c47d9e7969fc2716e5772
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Sat Nov 23 12:25:04 2019 -0800

    bpf: Introduce BPF_TRACE_x helper for the tracing tests
    
    For BPF_PROG_TYPE_TRACING, the bpf_prog's ctx is an array of u64.
    This patch borrows the idea from BPF_CALL_x in filter.h to
    convert a u64 to the arg type of the traced function.
    
    The new BPF_TRACE_x has an arg to specify the return type of a bpf_prog.
    It will be used in the future TCP-ops bpf_prog that may return "void".
    
    The new macros are defined in the new header file "bpf_trace_helpers.h".
    It is under selftests/bpf/ for now.  It could be moved to libbpf later
    after seeing more upcoming non-tracing use cases.
    
    The tests are changed to use these new macros also.  Hence,
    the k[s]u8/16/32/64 are no longer needed and they are removed
    from the bpf_helpers.h.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191123202504.1502696-1-kafai@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index c63ab1add126..0c7d28292898 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -44,17 +44,4 @@ enum libbpf_pin_type {
 	LIBBPF_PIN_BY_NAME,
 };
 
-/* The following types should be used by BPF_PROG_TYPE_TRACING program to
- * access kernel function arguments. BPF trampoline and raw tracepoints
- * typecast arguments to 'unsigned long long'.
- */
-typedef int __attribute__((aligned(8))) ks32;
-typedef char __attribute__((aligned(8))) ks8;
-typedef short __attribute__((aligned(8))) ks16;
-typedef long long __attribute__((aligned(8))) ks64;
-typedef unsigned int __attribute__((aligned(8))) ku32;
-typedef unsigned char __attribute__((aligned(8))) ku8;
-typedef unsigned short __attribute__((aligned(8))) ku16;
-typedef unsigned long long __attribute__((aligned(8))) ku64;
-
 #endif

commit 11d1e2eefffe86339b3b0b773bd31ef3b88faf7d
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Thu Nov 14 10:57:09 2019 -0800

    selftests/bpf: Add test for BPF trampoline
    
    Add sanity test for BPF trampoline that checks kernel functions
    with up to 6 arguments of different sizes.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20191114185720.1641606-10-ast@kernel.org

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 0c7d28292898..c63ab1add126 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -44,4 +44,17 @@ enum libbpf_pin_type {
 	LIBBPF_PIN_BY_NAME,
 };
 
+/* The following types should be used by BPF_PROG_TYPE_TRACING program to
+ * access kernel function arguments. BPF trampoline and raw tracepoints
+ * typecast arguments to 'unsigned long long'.
+ */
+typedef int __attribute__((aligned(8))) ks32;
+typedef char __attribute__((aligned(8))) ks8;
+typedef short __attribute__((aligned(8))) ks16;
+typedef long long __attribute__((aligned(8))) ks64;
+typedef unsigned int __attribute__((aligned(8))) ku32;
+typedef unsigned char __attribute__((aligned(8))) ku8;
+typedef unsigned short __attribute__((aligned(8))) ku16;
+typedef unsigned long long __attribute__((aligned(8))) ku64;
+
 #endif

commit 57a00f41644f20b11c12a27061d814655f633544
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Sat Nov 2 12:09:41 2019 +0100

    libbpf: Add auto-pinning of maps when loading BPF objects
    
    This adds support to libbpf for setting map pinning information as part of
    the BTF map declaration, to get automatic map pinning (and reuse) on load.
    The pinning type currently only supports a single PIN_BY_NAME mode, where
    each map will be pinned by its name in a path that can be overridden, but
    defaults to /sys/fs/bpf.
    
    Since auto-pinning only does something if any maps actually have a
    'pinning' BTF attribute set, we default the new option to enabled, on the
    assumption that seamless pinning is what most callers want.
    
    When a map has a pin_path set at load time, libbpf will compare the map
    pinned at that location (if any), and if the attributes match, will re-use
    that map instead of creating a new one. If no existing map is found, the
    newly created map will instead be pinned at the location.
    
    Programs wanting to customise the pinning can override the pinning paths
    using bpf_map__set_pin_path() before calling bpf_object__load() (including
    setting it to NULL to disable pinning of a particular map).
    
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157269298092.394725.3966306029218559681.stgit@toke.dk

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 2203595f38c3..0c7d28292898 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -38,4 +38,10 @@ struct bpf_map_def {
 	unsigned int map_flags;
 };
 
+enum libbpf_pin_type {
+	LIBBPF_PIN_NONE,
+	/* PIN_BY_NAME: pin maps by name (in /sys/fs/bpf by default) */
+	LIBBPF_PIN_BY_NAME,
+};
+
 #endif

commit 7db3822ab99157e16c41caa5e7d788834d5a3c7c
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Oct 8 10:59:41 2019 -0700

    libbpf: Add BPF_CORE_READ/BPF_CORE_READ_INTO helpers
    
    Add few macros simplifying BCC-like multi-level probe reads, while also
    emitting CO-RE relocations for each read.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20191008175942.1769476-7-andriin@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 6d059c0a7845..2203595f38c3 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -7,7 +7,7 @@
 #define __uint(name, val) int (*name)[val]
 #define __type(name, val) typeof(val) *name
 
-/* helper macro to print out debug messages */
+/* Helper macro to print out debug messages */
 #define bpf_printk(fmt, ...)				\
 ({							\
 	char ____fmt[] = fmt;				\
@@ -15,13 +15,19 @@
 			 ##__VA_ARGS__);		\
 })
 
-/* helper macro to place programs, maps, license in
+/*
+ * Helper macro to place programs, maps, license in
  * different sections in elf_bpf file. Section names
  * are interpreted by elf_bpf loader
  */
 #define SEC(NAME) __attribute__((section(NAME), used))
 
-/* a helper structure used by eBPF C program
+#ifndef __always_inline
+#define __always_inline __attribute__((always_inline))
+#endif
+
+/*
+ * Helper structure used by eBPF C program
  * to describe BPF map attributes to libbpf loader
  */
 struct bpf_map_def {
@@ -32,24 +38,4 @@ struct bpf_map_def {
 	unsigned int map_flags;
 };
 
-/*
- * bpf_core_read() abstracts away bpf_probe_read() call and captures offset
- * relocation for source address using __builtin_preserve_access_index()
- * built-in, provided by Clang.
- *
- * __builtin_preserve_access_index() takes as an argument an expression of
- * taking an address of a field within struct/union. It makes compiler emit
- * a relocation, which records BTF type ID describing root struct/union and an
- * accessor string which describes exact embedded field that was used to take
- * an address. See detailed description of this relocation format and
- * semantics in comments to struct bpf_offset_reloc in libbpf_internal.h.
- *
- * This relocation allows libbpf to adjust BPF instruction to use correct
- * actual field offset, based on target kernel BTF type that matches original
- * (local) BTF, used to record relocation.
- */
-#define bpf_core_read(dst, sz, src)					    \
-	bpf_probe_read(dst, sz,						    \
-		       (const void *)__builtin_preserve_access_index(src))
-
 #endif

commit e01a75c159691714607b8a22daa2ba7be275dd01
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue Oct 8 10:59:40 2019 -0700

    libbpf: Move bpf_{helpers, helper_defs, endian, tracing}.h into libbpf
    
    Move bpf_helpers.h, bpf_tracing.h, and bpf_endian.h into libbpf. Move
    bpf_helper_defs.h generation into libbpf's Makefile. Ensure all those
    headers are installed along the other libbpf headers. Also, adjust
    selftests and samples include path to include libbpf now.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20191008175942.1769476-6-andriin@fb.com

diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
new file mode 100644
index 000000000000..6d059c0a7845
--- /dev/null
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+#ifndef __BPF_HELPERS__
+#define __BPF_HELPERS__
+
+#include "bpf_helper_defs.h"
+
+#define __uint(name, val) int (*name)[val]
+#define __type(name, val) typeof(val) *name
+
+/* helper macro to print out debug messages */
+#define bpf_printk(fmt, ...)				\
+({							\
+	char ____fmt[] = fmt;				\
+	bpf_trace_printk(____fmt, sizeof(____fmt),	\
+			 ##__VA_ARGS__);		\
+})
+
+/* helper macro to place programs, maps, license in
+ * different sections in elf_bpf file. Section names
+ * are interpreted by elf_bpf loader
+ */
+#define SEC(NAME) __attribute__((section(NAME), used))
+
+/* a helper structure used by eBPF C program
+ * to describe BPF map attributes to libbpf loader
+ */
+struct bpf_map_def {
+	unsigned int type;
+	unsigned int key_size;
+	unsigned int value_size;
+	unsigned int max_entries;
+	unsigned int map_flags;
+};
+
+/*
+ * bpf_core_read() abstracts away bpf_probe_read() call and captures offset
+ * relocation for source address using __builtin_preserve_access_index()
+ * built-in, provided by Clang.
+ *
+ * __builtin_preserve_access_index() takes as an argument an expression of
+ * taking an address of a field within struct/union. It makes compiler emit
+ * a relocation, which records BTF type ID describing root struct/union and an
+ * accessor string which describes exact embedded field that was used to take
+ * an address. See detailed description of this relocation format and
+ * semantics in comments to struct bpf_offset_reloc in libbpf_internal.h.
+ *
+ * This relocation allows libbpf to adjust BPF instruction to use correct
+ * actual field offset, based on target kernel BTF type that matches original
+ * (local) BTF, used to record relocation.
+ */
+#define bpf_core_read(dst, sz, src)					    \
+	bpf_probe_read(dst, sz,						    \
+		       (const void *)__builtin_preserve_access_index(src))
+
+#endif
