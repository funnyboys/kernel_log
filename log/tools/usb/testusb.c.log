commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 2d89b5f686b1..ee8208b2f946 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* $(CROSS_COMPILE)cc -Wall -Wextra -g -lpthread -o testusb testusb.c */
 
 /*
  * Copyright (c) 2002 by David Brownell
  * Copyright (c) 2010 by Samsung Electronics
  * Author: Michal Nazarewicz <mina86@mina86.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /*

commit a7ea58f3814398ccfc154e2461f2a2011cc4a1bd
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Tue Apr 25 14:23:41 2017 +0300

    tools: usb: testusb: update default vary for superspeed
    
    Currently, default vary will not accomodate superspeed endpoints
    causing unexpected babble errors in the IN direction. Let's update
    default 'vary' parameter so that we can maintain a "short-less"
    transfer as hinted at the comment.
    
    Reported-by: Ammy Yi <ammy.yi@intel.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 0692d99b6d8f..2d89b5f686b1 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -387,15 +387,17 @@ int main (int argc, char **argv)
 	/* pick defaults that works with all speeds, without short packets.
 	 *
 	 * Best per-frame data rates:
-	 *     high speed, bulk       512 * 13 * 8 = 53248
-	 *                 interrupt 1024 *  3 * 8 = 24576
-	 *     full speed, bulk/intr   64 * 19     =  1216
-	 *                 interrupt   64 *  1     =    64
-	 *      low speed, interrupt    8 *  1     =     8
+	 *     super speed,bulk      1024 * 16 * 8 = 131072
+	 *                 interrupt 1024 *  3 * 8 =  24576
+	 *     high speed, bulk       512 * 13 * 8 =  53248
+	 *                 interrupt 1024 *  3 * 8 =  24576
+	 *     full speed, bulk/intr   64 * 19     =   1216
+	 *                 interrupt   64 *  1     =     64
+	 *      low speed, interrupt    8 *  1     =      8
 	 */
 	param.iterations = 1000;
 	param.length = 1024;
-	param.vary = 512;
+	param.vary = 1024;
 	param.sglen = 32;
 
 	/* for easy use when hotplugging */
@@ -457,7 +459,7 @@ int main (int argc, char **argv)
 			"\t-c iterations		default 1000\n"
 			"\t-s transfer length	default 1024\n"
 			"\t-g sglen		default 32\n"
-			"\t-v vary			default 512\n",
+			"\t-v vary			default 1024\n",
 			argv[0]);
 		return 1;
 	}

commit 9e44d194b90b2d9e6e26cd0381db856fa7cd7e19
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 1 09:48:04 2015 +0800

    tools: usb: testusb: change the default value for length from 512 to 1024
    
    For ctrl out test, it needs length > vary, so in order to run it with
    default parameters, we do this change.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 863d9e2b3424..0692d99b6d8f 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -394,7 +394,7 @@ int main (int argc, char **argv)
 	 *      low speed, interrupt    8 *  1     =     8
 	 */
 	param.iterations = 1000;
-	param.length = 512;
+	param.length = 1024;
 	param.vary = 512;
 	param.sglen = 32;
 
@@ -455,7 +455,7 @@ int main (int argc, char **argv)
 			"\t-n		no test running, show devices to be tested\n"
 			"Case arguments:\n"
 			"\t-c iterations		default 1000\n"
-			"\t-s transfer length	default 512\n"
+			"\t-s transfer length	default 1024\n"
 			"\t-g sglen		default 32\n"
 			"\t-v vary			default 512\n",
 			argv[0]);

commit 0f286379ed72cfc2f9e9a4fd52e79b92d4edaa01
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 1 09:48:03 2015 +0800

    tools: usb: testusb: change the help text
    
    The 'length' is the transfer length, not the packet size, so
    change the help text.
    
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 879f9870a6bc..863d9e2b3424 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -454,10 +454,10 @@ int main (int argc, char **argv)
 			"\t-t testnum	only run specified case\n"
 			"\t-n		no test running, show devices to be tested\n"
 			"Case arguments:\n"
-			"\t-c iterations	default 1000\n"
-			"\t-s packetsize	default 512\n"
-			"\t-g sglen	default 32\n"
-			"\t-v vary		default 512\n",
+			"\t-c iterations		default 1000\n"
+			"\t-s transfer length	default 512\n"
+			"\t-g sglen		default 32\n"
+			"\t-v vary			default 512\n",
 			argv[0]);
 		return 1;
 	}

commit 9742aecda4d02976535051db4af4830bd98373a1
Author: Sergei Shtylyov <sshtylyov@dev.rtsoft.ru>
Date:   Fri Feb 8 18:48:03 2013 +0300

    testusb: remove all mentions of 'usbfs'
    
    Commit 8a424bf40d772fedacc91862ecc86f10541fabb3 (tools/usb: remove last USBFS
    user) removed 'usbfs' files from the source but retained mentions of 'usbfs'
    all over the place, most importantly in the misleading error messages printed
    in case USB device files are not there.  Remove all the  mentions of 'usbfs'
    for good now!
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@dev.rtsoft.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 643cd77fa980..879f9870a6bc 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -279,8 +279,7 @@ static int find_testdev(const char *name, const struct stat *sb, int flag)
 
 	entry->ifnum = ifnum;
 
-	/* FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO so
-	 * it tells about high speed etc */
+	/* FIXME update USBDEVFS_CONNECTINFO so it tells about high speed etc */
 
 	fprintf(stderr, "%s speed\t%s\t%u\n",
 		speed(entry->speed), entry->name, entry->ifnum);
@@ -351,7 +350,7 @@ static void *handle_testdev (void *arg)
 	return arg;
 }
 
-static const char *usbfs_dir_find(void)
+static const char *usb_dir_find(void)
 {
 	static char udev_usb_path[] = "/dev/bus/usb";
 
@@ -380,7 +379,7 @@ int main (int argc, char **argv)
 	int			c;
 	struct testdev		*entry;
 	char			*device;
-	const char		*usbfs_dir = NULL;
+	const char		*usb_dir = NULL;
 	int			all = 0, forever = 0, not = 0;
 	int			test = -1 /* all */;
 	struct usbtest_param	param;
@@ -407,8 +406,8 @@ int main (int argc, char **argv)
 	case 'D':	/* device, if only one */
 		device = optarg;
 		continue;
-	case 'A':	/* use all devices with specified usbfs dir */
-		usbfs_dir = optarg;
+	case 'A':	/* use all devices with specified USB dir */
+		usb_dir = optarg;
 		/* FALL THROUGH */
 	case 'a':	/* use all devices */
 		device = NULL;
@@ -449,7 +448,7 @@ int main (int argc, char **argv)
 			"usage: %s [options]\n"
 			"Options:\n"
 			"\t-D dev		only test specific device\n"
-			"\t-A usbfs-dir\n"
+			"\t-A usb-dir\n"
 			"\t-a		test all recognized devices\n"
 			"\t-l		loop forever(for stress test)\n"
 			"\t-t testnum	only run specified case\n"
@@ -470,18 +469,18 @@ int main (int argc, char **argv)
 		goto usage;
 	}
 
-	/* Find usbfs mount point */
-	if (!usbfs_dir) {
-		usbfs_dir = usbfs_dir_find();
-		if (!usbfs_dir) {
-			fputs ("usbfs files are missing\n", stderr);
+	/* Find usb device subdirectory */
+	if (!usb_dir) {
+		usb_dir = usb_dir_find();
+		if (!usb_dir) {
+			fputs ("USB device files are missing\n", stderr);
 			return -1;
 		}
 	}
 
 	/* collect and list the test devices */
-	if (ftw (usbfs_dir, find_testdev, 3) != 0) {
-		fputs ("ftw failed; is usbfs missing?\n", stderr);
+	if (ftw (usb_dir, find_testdev, 3) != 0) {
+		fputs ("ftw failed; are USB device files missing?\n", stderr);
 		return -1;
 	}
 

commit 2c449e380153b72e184dd253ce6470acaee53cb0
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Thu Dec 20 14:11:15 2012 -0500

    tools/usb: remove unneeded 'continue' and simplify condition
    
    Basically remove unneeded code. Since that 'continue' is at the end
    of the for() there's no need for it.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 68d0734b2081..643cd77fa980 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -507,10 +507,8 @@ int main (int argc, char **argv)
 			return handle_testdev (entry) != entry;
 		}
 		status = pthread_create (&entry->thread, 0, handle_testdev, entry);
-		if (status) {
+		if (status)
 			perror ("pthread_create");
-			continue;
-		}
 	}
 	if (device) {
 		struct testdev		dev;

commit 8a424bf40d772fedacc91862ecc86f10541fabb3
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 10 09:16:39 2012 +0200

    tools/usb: remove last USBFS user
    
    In commit fb28d58b ("USB: remove CONFIG_USB_DEVICEFS") USBFS got
    removed. Since it is gone we can stop using it in testusb and try udev
    nodes right away.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index b0adb2710c02..68d0734b2081 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -253,9 +253,6 @@ static int find_testdev(const char *name, const struct stat *sb, int flag)
 
 	if (flag != FTW_F)
 		return 0;
-	/* ignore /proc/bus/usb/{devices,drivers} */
-	if (strrchr(name, '/')[1] == 'd')
-		return 0;
 
 	fd = fopen(name, "rb");
 	if (!fd) {
@@ -356,28 +353,8 @@ static void *handle_testdev (void *arg)
 
 static const char *usbfs_dir_find(void)
 {
-	static char usbfs_path_0[] = "/dev/usb/devices";
-	static char usbfs_path_1[] = "/proc/bus/usb/devices";
 	static char udev_usb_path[] = "/dev/bus/usb";
 
-	static char *const usbfs_paths[] = {
-		usbfs_path_0, usbfs_path_1
-	};
-
-	static char *const *
-		end = usbfs_paths + sizeof usbfs_paths / sizeof *usbfs_paths;
-
-	char *const *it = usbfs_paths;
-	do {
-		int fd = open(*it, O_RDONLY);
-		close(fd);
-		if (fd >= 0) {
-			strrchr(*it, '/')[0] = '\0';
-			return *it;
-		}
-	} while (++it != end);
-
-	/* real device-nodes managed by udev */
 	if (access(udev_usb_path, F_OK) == 0)
 		return udev_usb_path;
 
@@ -489,7 +466,7 @@ int main (int argc, char **argv)
 		goto usage;
 	if (!all && !device) {
 		fprintf (stderr, "must specify '-a' or '-D dev', "
-			"or DEVICE=/proc/bus/usb/BBB/DDD in env\n");
+			"or DEVICE=/dev/bus/usb/BBB/DDD in env\n");
 		goto usage;
 	}
 

commit 7e54e97812ccf59e71e002f9bd6d12bf4ab448b8
Author: Du, ChangbinX <changbinx.du@intel.com>
Date:   Wed May 23 02:43:05 2012 +0000

    testusb: expose looping forever option "l" to user
    
    The testusb.c tool has support for looping forever implemented, which
    may be useful for stress test, yet it is not exposed to the user, so
    even though the code is there, it cannot be used.  This commit adds
    "l" to the set of options handled by the application which enables
    the feature.
    
    Also, I collate help information for each command line option to make
    it easier to use for novice.
    
    Signed-off-by: Du Changbin <changbinx.du@intel.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 82d7c590c026..b0adb2710c02 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -425,7 +425,7 @@ int main (int argc, char **argv)
 	/* for easy use when hotplugging */
 	device = getenv ("DEVICE");
 
-	while ((c = getopt (argc, argv, "D:aA:c:g:hns:t:v:")) != EOF)
+	while ((c = getopt (argc, argv, "D:aA:c:g:hlns:t:v:")) != EOF)
 	switch (c) {
 	case 'D':	/* device, if only one */
 		device = optarg;
@@ -468,10 +468,21 @@ int main (int argc, char **argv)
 	case 'h':
 	default:
 usage:
-		fprintf (stderr, "usage: %s [-n] [-D dev | -a | -A usbfs-dir]\n"
-			"\t[-c iterations]  [-t testnum]\n"
-			"\t[-s packetsize] [-g sglen] [-v vary]\n",
-			argv [0]);
+		fprintf (stderr,
+			"usage: %s [options]\n"
+			"Options:\n"
+			"\t-D dev		only test specific device\n"
+			"\t-A usbfs-dir\n"
+			"\t-a		test all recognized devices\n"
+			"\t-l		loop forever(for stress test)\n"
+			"\t-t testnum	only run specified case\n"
+			"\t-n		no test running, show devices to be tested\n"
+			"Case arguments:\n"
+			"\t-c iterations	default 1000\n"
+			"\t-s packetsize	default 512\n"
+			"\t-g sglen	default 32\n"
+			"\t-v vary		default 512\n",
+			argv[0]);
 		return 1;
 	}
 	if (optind != argc)

commit f6fe916ed0a383ae89b041200dae271579c053b3
Author: Du, ChangbinX <changbinx.du@intel.com>
Date:   Tue May 15 01:49:25 2012 +0000

    USB: testusb: add path /dev/bus/usb to default search paths for usbfs
    
    As real device-nodes managed by udev whose nodes lived in /dev/bus/usb
    are mostly used today, let testusb tool use that directory as one default
    path make tool be more convenient to use.
    
    Signed-off-by: Du Changbin <changbinx.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 6e0f56701e44..82d7c590c026 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -358,6 +358,7 @@ static const char *usbfs_dir_find(void)
 {
 	static char usbfs_path_0[] = "/dev/usb/devices";
 	static char usbfs_path_1[] = "/proc/bus/usb/devices";
+	static char udev_usb_path[] = "/dev/bus/usb";
 
 	static char *const usbfs_paths[] = {
 		usbfs_path_0, usbfs_path_1
@@ -376,6 +377,10 @@ static const char *usbfs_dir_find(void)
 		}
 	} while (++it != end);
 
+	/* real device-nodes managed by udev */
+	if (access(udev_usb_path, F_OK) == 0)
+		return udev_usb_path;
+
 	return NULL;
 }
 

commit 54b8360ffd4c8b2c128ca25233b8c6876fb92d30
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Fri Jan 13 15:05:16 2012 +0100

    usb: gadget: update Michal Nazarewicz's email address
    
    The m.nazarewicz@samsung.com email address is no longer valid,
    so this commit replaces it with mina86@mina86.com which is
    employer-agnostic and thus should be valid for foreseeable
    feature.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index f08e89463842..6e0f56701e44 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -3,7 +3,7 @@
 /*
  * Copyright (c) 2002 by David Brownell
  * Copyright (c) 2010 by Samsung Electronics
- * Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
+ * Author: Michal Nazarewicz <mina86@mina86.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the

commit 5bc9661cba04ff3704e704a06367d4fe96d8dd33
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Wed May 5 12:53:18 2010 +0200

    USB: testusb: testusb compatibility with FunctionFS gadget
    
    The FunctionFS gadget may provide the source/sink interface
    not as the first interface (with id == 0) but some different
    interface hence a code to find the interface number is
    required.
    
    (Note that you will still configure the gadget to report
    idProduct == 0xa4a4 (an "echo 0xa4a4
    >/sys/module/g_ffs/parameters/usb_product" should suffice) or
    configure host to handle 0x0525:0xa4ac devices using the
    usbtest driver.)
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
index 1f372983be6d..f08e89463842 100644
--- a/tools/usb/testusb.c
+++ b/tools/usb/testusb.c
@@ -1,7 +1,9 @@
-/* $(CROSS_COMPILE)cc -Wall -g -lpthread -o testusb testusb.c */
+/* $(CROSS_COMPILE)cc -Wall -Wextra -g -lpthread -o testusb testusb.c */
 
 /*
  * Copyright (c) 2002 by David Brownell
+ * Copyright (c) 2010 by Samsung Electronics
+ * Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -18,6 +20,16 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/*
+ * This program issues ioctls to perform the tests implemented by the
+ * kernel driver.  It can generate a variety of transfer patterns; you
+ * should make sure to test both regular streaming and mixes of
+ * transfer sizes (including short transfers).
+ *
+ * For more information on how this can be used and on USB testing
+ * refer to <URL:http://www.linux-usb.org/usbtest/>.
+ */
+
 #include <stdio.h>
 #include <string.h>
 #include <ftw.h>
@@ -25,6 +37,7 @@
 #include <pthread.h>
 #include <unistd.h>
 #include <errno.h>
+#include <limits.h>
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -56,6 +69,13 @@ struct usbtest_param {
 
 /* #include <linux/usb_ch9.h> */
 
+#define USB_DT_DEVICE			0x01
+#define USB_DT_INTERFACE		0x04
+
+#define USB_CLASS_PER_INTERFACE		0	/* for DeviceClass */
+#define USB_CLASS_VENDOR_SPEC		0xff
+
+
 struct usb_device_descriptor {
 	__u8  bLength;
 	__u8  bDescriptorType;
@@ -73,6 +93,19 @@ struct usb_device_descriptor {
 	__u8  bNumConfigurations;
 } __attribute__ ((packed));
 
+struct usb_interface_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bInterfaceNumber;
+	__u8  bAlternateSetting;
+	__u8  bNumEndpoints;
+	__u8  bInterfaceClass;
+	__u8  bInterfaceSubClass;
+	__u8  bInterfaceProtocol;
+	__u8  iInterface;
+} __attribute__ ((packed));
+
 enum usb_device_speed {
 	USB_SPEED_UNKNOWN = 0,			/* enumerating */
 	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
@@ -105,11 +138,42 @@ struct testdev {
 };
 static struct testdev		*testdevs;
 
-static int is_testdev (struct usb_device_descriptor *dev)
+static int testdev_ffs_ifnum(FILE *fd)
 {
+	union {
+		char buf[255];
+		struct usb_interface_descriptor intf;
+	} u;
+
+	for (;;) {
+		if (fread(u.buf, 1, 1, fd) != 1)
+			return -1;
+		if (fread(u.buf + 1, (unsigned char)u.buf[0] - 1, 1, fd) != 1)
+			return -1;
+
+		if (u.intf.bLength == sizeof u.intf
+		 && u.intf.bDescriptorType == USB_DT_INTERFACE
+		 && u.intf.bNumEndpoints == 2
+		 && u.intf.bInterfaceClass == USB_CLASS_VENDOR_SPEC
+		 && u.intf.bInterfaceSubClass == 0
+		 && u.intf.bInterfaceProtocol == 0)
+			return (unsigned char)u.intf.bInterfaceNumber;
+	}
+}
+
+static int testdev_ifnum(FILE *fd)
+{
+	struct usb_device_descriptor dev;
+
+	if (fread(&dev, sizeof dev, 1, fd) != 1)
+		return -1;
+
+	if (dev.bLength != sizeof dev || dev.bDescriptorType != USB_DT_DEVICE)
+		return -1;
+
 	/* FX2 with (tweaked) bulksrc firmware */
-	if (dev->idVendor == 0x0547 && dev->idProduct == 0x1002)
-		return 1;
+	if (dev.idVendor == 0x0547 && dev.idProduct == 0x1002)
+		return 0;
 
 	/*----------------------------------------------------*/
 
@@ -124,95 +188,108 @@ static int is_testdev (struct usb_device_descriptor *dev)
 	 */
 
 	/* generic EZ-USB FX controller */
-	if (dev->idVendor == 0x0547 && dev->idProduct == 0x2235)
-		return 1;
+	if (dev.idVendor == 0x0547 && dev.idProduct == 0x2235)
+		return 0;
 
 	/* generic EZ-USB FX2 controller */
-	if (dev->idVendor == 0x04b4 && dev->idProduct == 0x8613)
-		return 1;
+	if (dev.idVendor == 0x04b4 && dev.idProduct == 0x8613)
+		return 0;
 
 	/* CY3671 development board with EZ-USB FX */
-	if (dev->idVendor == 0x0547 && dev->idProduct == 0x0080)
-		return 1;
+	if (dev.idVendor == 0x0547 && dev.idProduct == 0x0080)
+		return 0;
 
 	/* Keyspan 19Qi uses an21xx (original EZ-USB) */
-	if (dev->idVendor == 0x06cd && dev->idProduct == 0x010b)
-		return 1;
+	if (dev.idVendor == 0x06cd && dev.idProduct == 0x010b)
+		return 0;
 
 	/*----------------------------------------------------*/
 
 	/* "gadget zero", Linux-USB test software */
-	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a0)
-		return 1;
+	if (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a0)
+		return 0;
 
 	/* user mode subset of that */
-	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a4)
-		return 1;
+	if (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a4)
+		return testdev_ffs_ifnum(fd);
+		/* return 0; */
 
 	/* iso version of usermode code */
-	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a3)
-		return 1;
+	if (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a3)
+		return 0;
 
 	/* some GPL'd test firmware uses these IDs */
 
-	if (dev->idVendor == 0xfff0 && dev->idProduct == 0xfff0)
-		return 1;
+	if (dev.idVendor == 0xfff0 && dev.idProduct == 0xfff0)
+		return 0;
 
 	/*----------------------------------------------------*/
 
 	/* iBOT2 high speed webcam */
-	if (dev->idVendor == 0x0b62 && dev->idProduct == 0x0059)
-		return 1;
+	if (dev.idVendor == 0x0b62 && dev.idProduct == 0x0059)
+		return 0;
 
-	return 0;
+	/*----------------------------------------------------*/
+
+	/* the FunctionFS gadget can have the source/sink interface
+	 * anywhere.  We look for an interface descriptor that match
+	 * what we expect.  We ignore configuratiens thou. */
+
+	if (dev.idVendor == 0x0525 && dev.idProduct == 0xa4ac
+	 && (dev.bDeviceClass == USB_CLASS_PER_INTERFACE
+	  || dev.bDeviceClass == USB_CLASS_VENDOR_SPEC))
+		return testdev_ffs_ifnum(fd);
+
+	return -1;
 }
 
-static int find_testdev (const char *name, const struct stat *sb, int flag)
+static int find_testdev(const char *name, const struct stat *sb, int flag)
 {
-	int				fd;
-	struct usb_device_descriptor	dev;
+	FILE				*fd;
+	int				ifnum;
+	struct testdev			*entry;
+
+	(void)sb; /* unused */
 
 	if (flag != FTW_F)
 		return 0;
 	/* ignore /proc/bus/usb/{devices,drivers} */
-	if (strrchr (name, '/')[1] == 'd')
+	if (strrchr(name, '/')[1] == 'd')
 		return 0;
 
-	if ((fd = open (name, O_RDONLY)) < 0) {
-		perror ("can't open dev file r/o");
+	fd = fopen(name, "rb");
+	if (!fd) {
+		perror(name);
 		return 0;
 	}
-	if (read (fd, &dev, sizeof dev) != sizeof dev)
-		fputs ("short devfile read!\n", stderr);
-	else if (is_testdev (&dev)) {
-		struct testdev		*entry;
-
-		if ((entry = calloc (1, sizeof *entry)) == 0) {
-			fputs ("no mem!\n", stderr);
-			goto done;
-		}
-		entry->name = strdup (name);
-		if (!entry->name) {
-			free (entry);
-			goto done;
-		}
 
-		// FIXME better to look at each interface and ask if it's
-		// bound to 'usbtest', rather than assume interface 0
-		entry->ifnum = 0;
-
-		// FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO
-		// so it tells about high speed etc
+	ifnum = testdev_ifnum(fd);
+	fclose(fd);
+	if (ifnum < 0)
+		return 0;
 
-		fprintf (stderr, "%s speed\t%s\n",
-				speed (entry->speed), entry->name);
+	entry = calloc(1, sizeof *entry);
+	if (!entry)
+		goto nomem;
 
-		entry->next = testdevs;
-		testdevs = entry;
+	entry->name = strdup(name);
+	if (!entry->name) {
+		free(entry);
+nomem:
+		perror("malloc");
+		return 0;
 	}
 
-done:
-	close (fd);
+	entry->ifnum = ifnum;
+
+	/* FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO so
+	 * it tells about high speed etc */
+
+	fprintf(stderr, "%s speed\t%s\t%u\n",
+		speed(entry->speed), entry->name, entry->ifnum);
+
+	entry->next = testdevs;
+	testdevs = entry;
 	return 0;
 }
 
@@ -277,11 +354,51 @@ static void *handle_testdev (void *arg)
 	return arg;
 }
 
+static const char *usbfs_dir_find(void)
+{
+	static char usbfs_path_0[] = "/dev/usb/devices";
+	static char usbfs_path_1[] = "/proc/bus/usb/devices";
+
+	static char *const usbfs_paths[] = {
+		usbfs_path_0, usbfs_path_1
+	};
+
+	static char *const *
+		end = usbfs_paths + sizeof usbfs_paths / sizeof *usbfs_paths;
+
+	char *const *it = usbfs_paths;
+	do {
+		int fd = open(*it, O_RDONLY);
+		close(fd);
+		if (fd >= 0) {
+			strrchr(*it, '/')[0] = '\0';
+			return *it;
+		}
+	} while (++it != end);
+
+	return NULL;
+}
+
+static int parse_num(unsigned *num, const char *str)
+{
+	unsigned long val;
+	char *end;
+
+	errno = 0;
+	val = strtoul(str, &end, 0);
+	if (errno || *end || val > UINT_MAX)
+		return -1;
+	*num = val;
+	return 0;
+}
+
 int main (int argc, char **argv)
 {
+
 	int			c;
 	struct testdev		*entry;
 	char			*device;
+	const char		*usbfs_dir = NULL;
 	int			all = 0, forever = 0, not = 0;
 	int			test = -1 /* all */;
 	struct usbtest_param	param;
@@ -303,23 +420,24 @@ int main (int argc, char **argv)
 	/* for easy use when hotplugging */
 	device = getenv ("DEVICE");
 
-	while ((c = getopt (argc, argv, "D:ac:g:hns:t:v:")) != EOF)
+	while ((c = getopt (argc, argv, "D:aA:c:g:hns:t:v:")) != EOF)
 	switch (c) {
 	case 'D':	/* device, if only one */
 		device = optarg;
 		continue;
+	case 'A':	/* use all devices with specified usbfs dir */
+		usbfs_dir = optarg;
+		/* FALL THROUGH */
 	case 'a':	/* use all devices */
-		device = 0;
+		device = NULL;
 		all = 1;
 		continue;
 	case 'c':	/* count iterations */
-		param.iterations = atoi (optarg);
-		if (param.iterations < 0)
+		if (parse_num(&param.iterations, optarg))
 			goto usage;
 		continue;
 	case 'g':	/* scatter/gather entries */
-		param.sglen = atoi (optarg);
-		if (param.sglen < 0)
+		if (parse_num(&param.sglen, optarg))
 			goto usage;
 		continue;
 	case 'l':	/* loop forever */
@@ -329,8 +447,7 @@ int main (int argc, char **argv)
 		not = 1;
 		continue;
 	case 's':	/* size of packet */
-		param.length = atoi (optarg);
-		if (param.length < 0)
+		if (parse_num(&param.length, optarg))
 			goto usage;
 		continue;
 	case 't':	/* run just one test */
@@ -339,15 +456,14 @@ int main (int argc, char **argv)
 			goto usage;
 		continue;
 	case 'v':	/* vary packet size by ... */
-		param.vary = atoi (optarg);
-		if (param.vary < 0)
+		if (parse_num(&param.vary, optarg))
 			goto usage;
 		continue;
 	case '?':
 	case 'h':
 	default:
 usage:
-		fprintf (stderr, "usage: %s [-an] [-D dev]\n"
+		fprintf (stderr, "usage: %s [-n] [-D dev | -a | -A usbfs-dir]\n"
 			"\t[-c iterations]  [-t testnum]\n"
 			"\t[-s packetsize] [-g sglen] [-v vary]\n",
 			argv [0]);
@@ -361,13 +477,17 @@ int main (int argc, char **argv)
 		goto usage;
 	}
 
-	if ((c = open ("/proc/bus/usb/devices", O_RDONLY)) < 0) {
-		fputs ("usbfs files are missing\n", stderr);
-		return -1;
+	/* Find usbfs mount point */
+	if (!usbfs_dir) {
+		usbfs_dir = usbfs_dir_find();
+		if (!usbfs_dir) {
+			fputs ("usbfs files are missing\n", stderr);
+			return -1;
+		}
 	}
 
 	/* collect and list the test devices */
-	if (ftw ("/proc/bus/usb", find_testdev, 3) != 0) {
+	if (ftw (usbfs_dir, find_testdev, 3) != 0) {
 		fputs ("ftw failed; is usbfs missing?\n", stderr);
 		return -1;
 	}

commit 2201d6b1620a1d9feac78e9ff12b7246227c8b17
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed May 5 12:53:17 2010 +0200

    USB: testusb: an USB testing application
    
    The testusb program just issues ioctls to perform the tests
    implemented by the kernel driver.  It can generate a variety
    of transfer patterns; you should make sure to test both regular
    streaming and mixes of  transfer sizes (including short transfers).
    
    For more information on how this can be used and on USB testing
    refer to <URL:http://www.linux-usb.org/usbtest/>.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/tools/usb/testusb.c b/tools/usb/testusb.c
new file mode 100644
index 000000000000..1f372983be6d
--- /dev/null
+++ b/tools/usb/testusb.c
@@ -0,0 +1,427 @@
+/* $(CROSS_COMPILE)cc -Wall -g -lpthread -o testusb testusb.c */
+
+/*
+ * Copyright (c) 2002 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <ftw.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <linux/usbdevice_fs.h>
+
+/*-------------------------------------------------------------------------*/
+
+#define	TEST_CASES	30
+
+// FIXME make these public somewhere; usbdevfs.h?
+
+struct usbtest_param {
+	// inputs
+	unsigned		test_num;	/* 0..(TEST_CASES-1) */
+	unsigned		iterations;
+	unsigned		length;
+	unsigned		vary;
+	unsigned		sglen;
+
+	// outputs
+	struct timeval		duration;
+};
+#define USBTEST_REQUEST	_IOWR('U', 100, struct usbtest_param)
+
+/*-------------------------------------------------------------------------*/
+
+/* #include <linux/usb_ch9.h> */
+
+struct usb_device_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__u16 idVendor;
+	__u16 idProduct;
+	__u16 bcdDevice;
+	__u8  iManufacturer;
+	__u8  iProduct;
+	__u8  iSerialNumber;
+	__u8  bNumConfigurations;
+} __attribute__ ((packed));
+
+enum usb_device_speed {
+	USB_SPEED_UNKNOWN = 0,			/* enumerating */
+	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
+	USB_SPEED_HIGH				/* usb 2.0 */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static char *speed (enum usb_device_speed s)
+{
+	switch (s) {
+	case USB_SPEED_UNKNOWN:	return "unknown";
+	case USB_SPEED_LOW:	return "low";
+	case USB_SPEED_FULL:	return "full";
+	case USB_SPEED_HIGH:	return "high";
+	default:		return "??";
+	}
+}
+
+struct testdev {
+	struct testdev		*next;
+	char			*name;
+	pthread_t		thread;
+	enum usb_device_speed	speed;
+	unsigned		ifnum : 8;
+	unsigned		forever : 1;
+	int			test;
+
+	struct usbtest_param	param;
+};
+static struct testdev		*testdevs;
+
+static int is_testdev (struct usb_device_descriptor *dev)
+{
+	/* FX2 with (tweaked) bulksrc firmware */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x1002)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* devices that start up using the EZ-USB default device and
+	 * which we can use after loading simple firmware.  hotplug
+	 * can fxload it, and then run this test driver.
+	 *
+	 * we return false positives in two cases:
+	 * - the device has a "real" driver (maybe usb-serial) that
+	 *   renumerates.  the device should vanish quickly.
+	 * - the device doesn't have the test firmware installed.
+	 */
+
+	/* generic EZ-USB FX controller */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x2235)
+		return 1;
+
+	/* generic EZ-USB FX2 controller */
+	if (dev->idVendor == 0x04b4 && dev->idProduct == 0x8613)
+		return 1;
+
+	/* CY3671 development board with EZ-USB FX */
+	if (dev->idVendor == 0x0547 && dev->idProduct == 0x0080)
+		return 1;
+
+	/* Keyspan 19Qi uses an21xx (original EZ-USB) */
+	if (dev->idVendor == 0x06cd && dev->idProduct == 0x010b)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* "gadget zero", Linux-USB test software */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a0)
+		return 1;
+
+	/* user mode subset of that */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a4)
+		return 1;
+
+	/* iso version of usermode code */
+	if (dev->idVendor == 0x0525 && dev->idProduct == 0xa4a3)
+		return 1;
+
+	/* some GPL'd test firmware uses these IDs */
+
+	if (dev->idVendor == 0xfff0 && dev->idProduct == 0xfff0)
+		return 1;
+
+	/*----------------------------------------------------*/
+
+	/* iBOT2 high speed webcam */
+	if (dev->idVendor == 0x0b62 && dev->idProduct == 0x0059)
+		return 1;
+
+	return 0;
+}
+
+static int find_testdev (const char *name, const struct stat *sb, int flag)
+{
+	int				fd;
+	struct usb_device_descriptor	dev;
+
+	if (flag != FTW_F)
+		return 0;
+	/* ignore /proc/bus/usb/{devices,drivers} */
+	if (strrchr (name, '/')[1] == 'd')
+		return 0;
+
+	if ((fd = open (name, O_RDONLY)) < 0) {
+		perror ("can't open dev file r/o");
+		return 0;
+	}
+	if (read (fd, &dev, sizeof dev) != sizeof dev)
+		fputs ("short devfile read!\n", stderr);
+	else if (is_testdev (&dev)) {
+		struct testdev		*entry;
+
+		if ((entry = calloc (1, sizeof *entry)) == 0) {
+			fputs ("no mem!\n", stderr);
+			goto done;
+		}
+		entry->name = strdup (name);
+		if (!entry->name) {
+			free (entry);
+			goto done;
+		}
+
+		// FIXME better to look at each interface and ask if it's
+		// bound to 'usbtest', rather than assume interface 0
+		entry->ifnum = 0;
+
+		// FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO
+		// so it tells about high speed etc
+
+		fprintf (stderr, "%s speed\t%s\n",
+				speed (entry->speed), entry->name);
+
+		entry->next = testdevs;
+		testdevs = entry;
+	}
+
+done:
+	close (fd);
+	return 0;
+}
+
+static int
+usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
+{
+	struct usbdevfs_ioctl	wrapper;
+
+	wrapper.ifno = ifno;
+	wrapper.ioctl_code = request;
+	wrapper.data = param;
+
+	return ioctl (fd, USBDEVFS_IOCTL, &wrapper);
+}
+
+static void *handle_testdev (void *arg)
+{
+	struct testdev		*dev = arg;
+	int			fd, i;
+	int			status;
+
+	if ((fd = open (dev->name, O_RDWR)) < 0) {
+		perror ("can't open dev file r/w");
+		return 0;
+	}
+
+restart:
+	for (i = 0; i < TEST_CASES; i++) {
+		if (dev->test != -1 && dev->test != i)
+			continue;
+		dev->param.test_num = i;
+
+		status = usbdev_ioctl (fd, dev->ifnum,
+				USBTEST_REQUEST, &dev->param);
+		if (status < 0 && errno == EOPNOTSUPP)
+			continue;
+
+		/* FIXME need a "syslog it" option for background testing */
+
+		/* NOTE: each thread emits complete lines; no fragments! */
+		if (status < 0) {
+			char	buf [80];
+			int	err = errno;
+
+			if (strerror_r (errno, buf, sizeof buf)) {
+				snprintf (buf, sizeof buf, "error %d", err);
+				errno = err;
+			}
+			printf ("%s test %d --> %d (%s)\n",
+				dev->name, i, errno, buf);
+		} else
+			printf ("%s test %d, %4d.%.06d secs\n", dev->name, i,
+				(int) dev->param.duration.tv_sec,
+				(int) dev->param.duration.tv_usec);
+
+		fflush (stdout);
+	}
+	if (dev->forever)
+		goto restart;
+
+	close (fd);
+	return arg;
+}
+
+int main (int argc, char **argv)
+{
+	int			c;
+	struct testdev		*entry;
+	char			*device;
+	int			all = 0, forever = 0, not = 0;
+	int			test = -1 /* all */;
+	struct usbtest_param	param;
+
+	/* pick defaults that works with all speeds, without short packets.
+	 *
+	 * Best per-frame data rates:
+	 *     high speed, bulk       512 * 13 * 8 = 53248
+	 *                 interrupt 1024 *  3 * 8 = 24576
+	 *     full speed, bulk/intr   64 * 19     =  1216
+	 *                 interrupt   64 *  1     =    64
+	 *      low speed, interrupt    8 *  1     =     8
+	 */
+	param.iterations = 1000;
+	param.length = 512;
+	param.vary = 512;
+	param.sglen = 32;
+
+	/* for easy use when hotplugging */
+	device = getenv ("DEVICE");
+
+	while ((c = getopt (argc, argv, "D:ac:g:hns:t:v:")) != EOF)
+	switch (c) {
+	case 'D':	/* device, if only one */
+		device = optarg;
+		continue;
+	case 'a':	/* use all devices */
+		device = 0;
+		all = 1;
+		continue;
+	case 'c':	/* count iterations */
+		param.iterations = atoi (optarg);
+		if (param.iterations < 0)
+			goto usage;
+		continue;
+	case 'g':	/* scatter/gather entries */
+		param.sglen = atoi (optarg);
+		if (param.sglen < 0)
+			goto usage;
+		continue;
+	case 'l':	/* loop forever */
+		forever = 1;
+		continue;
+	case 'n':	/* no test running! */
+		not = 1;
+		continue;
+	case 's':	/* size of packet */
+		param.length = atoi (optarg);
+		if (param.length < 0)
+			goto usage;
+		continue;
+	case 't':	/* run just one test */
+		test = atoi (optarg);
+		if (test < 0)
+			goto usage;
+		continue;
+	case 'v':	/* vary packet size by ... */
+		param.vary = atoi (optarg);
+		if (param.vary < 0)
+			goto usage;
+		continue;
+	case '?':
+	case 'h':
+	default:
+usage:
+		fprintf (stderr, "usage: %s [-an] [-D dev]\n"
+			"\t[-c iterations]  [-t testnum]\n"
+			"\t[-s packetsize] [-g sglen] [-v vary]\n",
+			argv [0]);
+		return 1;
+	}
+	if (optind != argc)
+		goto usage;
+	if (!all && !device) {
+		fprintf (stderr, "must specify '-a' or '-D dev', "
+			"or DEVICE=/proc/bus/usb/BBB/DDD in env\n");
+		goto usage;
+	}
+
+	if ((c = open ("/proc/bus/usb/devices", O_RDONLY)) < 0) {
+		fputs ("usbfs files are missing\n", stderr);
+		return -1;
+	}
+
+	/* collect and list the test devices */
+	if (ftw ("/proc/bus/usb", find_testdev, 3) != 0) {
+		fputs ("ftw failed; is usbfs missing?\n", stderr);
+		return -1;
+	}
+
+	/* quit, run single test, or create test threads */
+	if (!testdevs && !device) {
+		fputs ("no test devices recognized\n", stderr);
+		return -1;
+	}
+	if (not)
+		return 0;
+	if (testdevs && testdevs->next == 0 && !device)
+		device = testdevs->name;
+	for (entry = testdevs; entry; entry = entry->next) {
+		int	status;
+
+		entry->param = param;
+		entry->forever = forever;
+		entry->test = test;
+
+		if (device) {
+			if (strcmp (entry->name, device))
+				continue;
+			return handle_testdev (entry) != entry;
+		}
+		status = pthread_create (&entry->thread, 0, handle_testdev, entry);
+		if (status) {
+			perror ("pthread_create");
+			continue;
+		}
+	}
+	if (device) {
+		struct testdev		dev;
+
+		/* kernel can recognize test devices we don't */
+		fprintf (stderr, "%s: %s may see only control tests\n",
+				argv [0], device);
+
+		memset (&dev, 0, sizeof dev);
+		dev.name = device;
+		dev.param = param;
+		dev.forever = forever;
+		dev.test = test;
+		return handle_testdev (&dev) != &dev;
+	}
+
+	/* wait for tests to complete */
+	for (entry = testdevs; entry; entry = entry->next) {
+		void	*retval;
+
+		if (pthread_join (entry->thread, &retval))
+			perror ("pthread_join");
+		/* testing errors discarded! */
+	}
+
+	return 0;
+}
