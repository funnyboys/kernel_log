commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index ba88728483ff..b4aeb9f1f493 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -1,22 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
  *               2005-2007 Takahiro Hirofuchi
  * Copyright (C) 2015-2016 Samsung Electronics
  *               Igor Kotrasinski <i.kotrasinsk@samsung.com>
  *               Krzysztof Opasiak <k.opasiak@samsung.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <sys/stat.h>

commit ad81b15d561692df1ce2a57dce391d39633209b1
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Wed Mar 7 13:42:26 2018 -0700

    usbip: tools: change to use new error codes in server reply messages
    
    Changed usbip_network, usbip_attach, usbip_list, and usbipd to use
    and propagate the new error codes in server reply messages.
    
    usbip_net_recv_op_common() is changed to take a pointer to status
    return the status returned in the op_common.status to callers.
    
    usbip_attach and usbip_list use the common interface to print error
    messages to indicate why the request failed.
    
    With this change the messages say why a request failed:
    
    - when a client requests a device that is already exported:
    
    usbip attach -r server_name -b 3-10.2
    usbip: error: Attach Request for 3-10.2 failed - Device busy (exported)
    
    - when a client requests a device that isn't exportable,
    
    usbip attach -r server_name -b 3-10.4
    usbip: error: Attach Request for 3-10.4 failed - Device not found
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index f60738735398..ba88728483ff 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -135,6 +135,7 @@ static int query_import_device(int sockfd, char *busid)
 	struct op_import_request request;
 	struct op_import_reply   reply;
 	uint16_t code = OP_REP_IMPORT;
+	int status;
 
 	memset(&request, 0, sizeof(request));
 	memset(&reply, 0, sizeof(reply));
@@ -157,9 +158,10 @@ static int query_import_device(int sockfd, char *busid)
 	}
 
 	/* receive a reply */
-	rc = usbip_net_recv_op_common(sockfd, &code);
+	rc = usbip_net_recv_op_common(sockfd, &code, &status);
 	if (rc < 0) {
-		err("recv op_common");
+		err("Attach Request for %s failed - %s\n",
+		    busid, usbip_op_common_status_string(status));
 		return -1;
 	}
 
@@ -194,11 +196,8 @@ static int attach_device(char *host, char *busid)
 	}
 
 	rhport = query_import_device(sockfd, busid);
-	if (rhport < 0) {
-		err("Attach request for Device %s. Is this device exported?",
-		    busid);
+	if (rhport < 0)
 		return -1;
-	}
 
 	close(sockfd);
 

commit 0c60b14860fe5f7086d4d9458a7f23ea1d09fcfa
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Tue Feb 27 15:23:55 2018 -0700

    usbip: tools usbip_attach: Fix cryptic error messages
    
    Attach device error message is cryptic and useless. Fix it to be
    informative.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index 7f07b2d50f59..f60738735398 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -195,7 +195,8 @@ static int attach_device(char *host, char *busid)
 
 	rhport = query_import_device(sockfd, busid);
 	if (rhport < 0) {
-		err("query");
+		err("Attach request for Device %s. Is this device exported?",
+		    busid);
 		return -1;
 	}
 

commit a38711a88b7e3fd0c0d292a35693e0f608263759
Author: Nobuo Iwata <nobuo.iwata@fujixerox.co.jp>
Date:   Tue Aug 29 11:13:34 2017 +0900

    usbip: auto retry for concurrent attach
    
    This patch adds recovery from false busy state on concurrent attach
    operation.
    
    The procedure of attach operation is as below.
    1) Find an unused port in /sys/devices/platform/vhci_hcd/status.
    (userspace)
    2) Request attach found port to driver through
    /sys/devices/platform/vhci_hcd/attach. (userspace)
    3) Lock table, reserve requested port and unlock table. (vhci driver)
    
    Attaching more than one remote devices concurrently, same unused port
    number will be found in step-1. Then one request will succeed and
    others will fail even though there are some unused ports.
    
    With this patch, driver returns EBUSY when requested port has already
    been used. In this case, attach command retries from step-1: finding
    another unused port. If there's no unused port, the attach operation
    will fail in step-1. Otherwise it retries automatically using another
    unused port.
    
    vhci-hcd's interface (only errno) is changed as following.
    
    Current errno   New errno       Condition
    EINVAL          same as left    specified port number is in invalid
                                    range
    EAGAIN          same as left    platform_get_drvdata() failed
    EINVAL          same as left    specified socket fd is not valid
    EINVAL          EBUSY           specified port status is not free
    
    The errno EBUSY was not used in userspace
    src/usbip_attach.c:import_device(). It is needed to distinguish the
    condition to be able to retry from other unrecoverable errors.
    
    It is possible to avoid this failure by introducing userspace exclusive
    control. But it's exaggerated for this special condition. The locking
    itself has done in driver.
    As an alternate solution, userspace doesn't specify port number, driver
    searches unused port and it returns port number to the userspace. With
    this solution, the interface is much different than this patch.
    
    Signed-off-by: Nobuo Iwata <nobuo.iwata@fujixerox.co.jp>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index 6e89768ffe30..7f07b2d50f59 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -99,29 +99,34 @@ static int import_device(int sockfd, struct usbip_usb_device *udev)
 	rc = usbip_vhci_driver_open();
 	if (rc < 0) {
 		err("open vhci_driver");
-		return -1;
+		goto err_out;
 	}
 
-	port = usbip_vhci_get_free_port(speed);
-	if (port < 0) {
-		err("no free port");
-		usbip_vhci_driver_close();
-		return -1;
-	}
+	do {
+		port = usbip_vhci_get_free_port(speed);
+		if (port < 0) {
+			err("no free port");
+			goto err_driver_close;
+		}
 
-	dbg("got free port %d", port);
+		dbg("got free port %d", port);
 
-	rc = usbip_vhci_attach_device(port, sockfd, udev->busnum,
-				      udev->devnum, udev->speed);
-	if (rc < 0) {
-		err("import device");
-		usbip_vhci_driver_close();
-		return -1;
-	}
+		rc = usbip_vhci_attach_device(port, sockfd, udev->busnum,
+					      udev->devnum, udev->speed);
+		if (rc < 0 && errno != EBUSY) {
+			err("import device");
+			goto err_driver_close;
+		}
+	} while (rc < 0);
 
 	usbip_vhci_driver_close();
 
 	return port;
+
+err_driver_close:
+	usbip_vhci_driver_close();
+err_out:
+	return -1;
 }
 
 static int query_import_device(int sockfd, char *busid)

commit 1c9de5bf428612458427943b724bea51abde520a
Author: Yuyang Du <yuyang.du@intel.com>
Date:   Thu Jun 8 13:04:10 2017 +0800

    usbip: vhci-hcd: Add USB3 SuperSpeed support
    
    This patch adds a USB3 HCD to an existing USB2 HCD and provides
    the support of SuperSpeed, in case the device can only be enumerated
    with SuperSpeed.
    
    The bulk of the added code in usb3_bos_desc and hub_control to support
    SuperSpeed is borrowed from the commit 1cd8fd2887e162ad ("usb: gadget:
    dummy_hcd: add SuperSpeed support").
    
    With this patch, each vhci will have VHCI_HC_PORTS HighSpeed ports
    and VHCI_HC_PORTS SuperSpeed ports.
    
    Suggested-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Yuyang Du <yuyang.du@intel.com>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index 62a297ff647a..6e89768ffe30 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -94,6 +94,7 @@ static int import_device(int sockfd, struct usbip_usb_device *udev)
 {
 	int rc;
 	int port;
+	uint32_t speed = udev->speed;
 
 	rc = usbip_vhci_driver_open();
 	if (rc < 0) {
@@ -101,7 +102,7 @@ static int import_device(int sockfd, struct usbip_usb_device *udev)
 		return -1;
 	}
 
-	port = usbip_vhci_get_free_port();
+	port = usbip_vhci_get_free_port(speed);
 	if (port < 0) {
 		err("no free port");
 		usbip_vhci_driver_close();

commit e55dea8ede2245918c537b9a252a1269f5d7b78b
Author: Yuyang Du <yuyang.du@intel.com>
Date:   Mon May 22 18:20:18 2017 +0800

    usb: usbip tool: Fix parse_status()
    
    In parse_status(), all nports number of idev's are initiated to
    0 by memset(), it is simply wrong, because parse_status() reads
    the status sys file one by one, therefore, it can only update the
    according vhci_driver->idev's for it to parse.
    
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Yuyang Du <yuyang.du@intel.com>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index 70a6b507fb62..62a297ff647a 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -108,6 +108,8 @@ static int import_device(int sockfd, struct usbip_usb_device *udev)
 		return -1;
 	}
 
+	dbg("got free port %d", port);
+
 	rc = usbip_vhci_attach_device(port, sockfd, udev->busnum,
 				      udev->devnum, udev->speed);
 	if (rc < 0) {

commit e0546fd8b748b19d8edd1550530da8ebad6e4b31
Author: Igor Kotrasinski <i.kotrasinsk@samsung.com>
Date:   Tue Mar 8 21:49:06 2016 +0100

    usbip: tools: Start using VUDC backend in usbip tools
    
    Modify userspace tools to allow exporting and connecting to vudc.
    
    This commit is a result of cooperation between Samsung R&D Institute
    Poland and Open Operating Systems Student Society at University
    of Warsaw (O2S3@UW) consisting of:
    
       Igor Kotrasinski <ikotrasinsk@gmail.com>
       Karol Kosik <karo9@interia.eu>
       Ewelina Kosmider <3w3lfin@gmail.com>
       Dawid Lazarczyk <lazarczyk.dawid@gmail.com>
       Piotr Szulc <ps347277@students.mimuw.edu.pl>
    
    Tutor and project owner:
       Krzysztof Opasiak <k.opasiak@samsung.com>
    
    Signed-off-by: Igor Kotrasinski <i.kotrasinsk@samsung.com>
    Signed-off-by: Ewelina Kosmider <3w3lfin@gmail.com>
    [Various bug fixes and improvements]
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
index d58a14dfc094..70a6b507fb62 100644
--- a/tools/usb/usbip/src/usbip_attach.c
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -1,6 +1,9 @@
 /*
  * Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
  *               2005-2007 Takahiro Hirofuchi
+ * Copyright (C) 2015-2016 Samsung Electronics
+ *               Igor Kotrasinski <i.kotrasinsk@samsung.com>
+ *               Krzysztof Opasiak <k.opasiak@samsung.com>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -36,7 +39,8 @@
 static const char usbip_attach_usage_string[] =
 	"usbip attach <args>\n"
 	"    -r, --remote=<host>      The machine with exported USB devices\n"
-	"    -b, --busid=<busid>    Busid of the device on <host>\n";
+	"    -b, --busid=<busid>    Busid of the device on <host>\n"
+	"    -d, --device=<devid>    Id of the virtual UDC on <host>\n";
 
 void usbip_attach_usage(void)
 {
@@ -203,6 +207,7 @@ int usbip_attach(int argc, char *argv[])
 	static const struct option opts[] = {
 		{ "remote", required_argument, NULL, 'r' },
 		{ "busid",  required_argument, NULL, 'b' },
+		{ "device",  required_argument, NULL, 'd' },
 		{ NULL, 0,  NULL, 0 }
 	};
 	char *host = NULL;
@@ -211,7 +216,7 @@ int usbip_attach(int argc, char *argv[])
 	int ret = -1;
 
 	for (;;) {
-		opt = getopt_long(argc, argv, "r:b:", opts, NULL);
+		opt = getopt_long(argc, argv, "d:r:b:", opts, NULL);
 
 		if (opt == -1)
 			break;
@@ -220,6 +225,7 @@ int usbip_attach(int argc, char *argv[])
 		case 'r':
 			host = optarg;
 			break;
+		case 'd':
 		case 'b':
 			busid = optarg;
 			break;

commit 588b48caf65c4a92af567948ec0025065e749ddf
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Wed Aug 20 07:30:59 2014 +0300

    usbip: move usbip userspace code out of staging
    
    At this point, USB/IP userspace code is fully functional
    and can be moved out of staging.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/usbip/src/usbip_attach.c b/tools/usb/usbip/src/usbip_attach.c
new file mode 100644
index 000000000000..d58a14dfc094
--- /dev/null
+++ b/tools/usb/usbip/src/usbip_attach.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
+ *               2005-2007 Takahiro Hirofuchi
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/stat.h>
+
+#include <limits.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <getopt.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "vhci_driver.h"
+#include "usbip_common.h"
+#include "usbip_network.h"
+#include "usbip.h"
+
+static const char usbip_attach_usage_string[] =
+	"usbip attach <args>\n"
+	"    -r, --remote=<host>      The machine with exported USB devices\n"
+	"    -b, --busid=<busid>    Busid of the device on <host>\n";
+
+void usbip_attach_usage(void)
+{
+	printf("usage: %s", usbip_attach_usage_string);
+}
+
+#define MAX_BUFF 100
+static int record_connection(char *host, char *port, char *busid, int rhport)
+{
+	int fd;
+	char path[PATH_MAX+1];
+	char buff[MAX_BUFF+1];
+	int ret;
+
+	ret = mkdir(VHCI_STATE_PATH, 0700);
+	if (ret < 0) {
+		/* if VHCI_STATE_PATH exists, then it better be a directory */
+		if (errno == EEXIST) {
+			struct stat s;
+
+			ret = stat(VHCI_STATE_PATH, &s);
+			if (ret < 0)
+				return -1;
+			if (!(s.st_mode & S_IFDIR))
+				return -1;
+		} else
+			return -1;
+	}
+
+	snprintf(path, PATH_MAX, VHCI_STATE_PATH"/port%d", rhport);
+
+	fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);
+	if (fd < 0)
+		return -1;
+
+	snprintf(buff, MAX_BUFF, "%s %s %s\n",
+			host, port, busid);
+
+	ret = write(fd, buff, strlen(buff));
+	if (ret != (ssize_t) strlen(buff)) {
+		close(fd);
+		return -1;
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+static int import_device(int sockfd, struct usbip_usb_device *udev)
+{
+	int rc;
+	int port;
+
+	rc = usbip_vhci_driver_open();
+	if (rc < 0) {
+		err("open vhci_driver");
+		return -1;
+	}
+
+	port = usbip_vhci_get_free_port();
+	if (port < 0) {
+		err("no free port");
+		usbip_vhci_driver_close();
+		return -1;
+	}
+
+	rc = usbip_vhci_attach_device(port, sockfd, udev->busnum,
+				      udev->devnum, udev->speed);
+	if (rc < 0) {
+		err("import device");
+		usbip_vhci_driver_close();
+		return -1;
+	}
+
+	usbip_vhci_driver_close();
+
+	return port;
+}
+
+static int query_import_device(int sockfd, char *busid)
+{
+	int rc;
+	struct op_import_request request;
+	struct op_import_reply   reply;
+	uint16_t code = OP_REP_IMPORT;
+
+	memset(&request, 0, sizeof(request));
+	memset(&reply, 0, sizeof(reply));
+
+	/* send a request */
+	rc = usbip_net_send_op_common(sockfd, OP_REQ_IMPORT, 0);
+	if (rc < 0) {
+		err("send op_common");
+		return -1;
+	}
+
+	strncpy(request.busid, busid, SYSFS_BUS_ID_SIZE-1);
+
+	PACK_OP_IMPORT_REQUEST(0, &request);
+
+	rc = usbip_net_send(sockfd, (void *) &request, sizeof(request));
+	if (rc < 0) {
+		err("send op_import_request");
+		return -1;
+	}
+
+	/* receive a reply */
+	rc = usbip_net_recv_op_common(sockfd, &code);
+	if (rc < 0) {
+		err("recv op_common");
+		return -1;
+	}
+
+	rc = usbip_net_recv(sockfd, (void *) &reply, sizeof(reply));
+	if (rc < 0) {
+		err("recv op_import_reply");
+		return -1;
+	}
+
+	PACK_OP_IMPORT_REPLY(0, &reply);
+
+	/* check the reply */
+	if (strncmp(reply.udev.busid, busid, SYSFS_BUS_ID_SIZE)) {
+		err("recv different busid %s", reply.udev.busid);
+		return -1;
+	}
+
+	/* import a device */
+	return import_device(sockfd, &reply.udev);
+}
+
+static int attach_device(char *host, char *busid)
+{
+	int sockfd;
+	int rc;
+	int rhport;
+
+	sockfd = usbip_net_tcp_connect(host, usbip_port_string);
+	if (sockfd < 0) {
+		err("tcp connect");
+		return -1;
+	}
+
+	rhport = query_import_device(sockfd, busid);
+	if (rhport < 0) {
+		err("query");
+		return -1;
+	}
+
+	close(sockfd);
+
+	rc = record_connection(host, usbip_port_string, busid, rhport);
+	if (rc < 0) {
+		err("record connection");
+		return -1;
+	}
+
+	return 0;
+}
+
+int usbip_attach(int argc, char *argv[])
+{
+	static const struct option opts[] = {
+		{ "remote", required_argument, NULL, 'r' },
+		{ "busid",  required_argument, NULL, 'b' },
+		{ NULL, 0,  NULL, 0 }
+	};
+	char *host = NULL;
+	char *busid = NULL;
+	int opt;
+	int ret = -1;
+
+	for (;;) {
+		opt = getopt_long(argc, argv, "r:b:", opts, NULL);
+
+		if (opt == -1)
+			break;
+
+		switch (opt) {
+		case 'r':
+			host = optarg;
+			break;
+		case 'b':
+			busid = optarg;
+			break;
+		default:
+			goto err_out;
+		}
+	}
+
+	if (!host || !busid)
+		goto err_out;
+
+	ret = attach_device(host, busid);
+	goto out;
+
+err_out:
+	usbip_attach_usage();
+out:
+	return ret;
+}
