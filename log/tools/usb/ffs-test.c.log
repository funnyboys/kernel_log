commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 0f395dfb7774..22b938fbdfb7 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * ffs-test.c -- user mode filesystem api for usb composite function
  *
  * Copyright (C) 2010 Samsung Electronics
  *                    Author: Michal Nazarewicz <mina86@mina86.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 /* $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread */

commit a2b22dddc7bb6110ac3b5ed1a60aa9279836fadb
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Tue Jul 10 16:01:45 2018 +0200

    tools: usb: ffs-test: Fix build on big endian systems
    
    The tools/usb/ffs-test.c file defines cpu_to_le16/32 by using the C
    library htole16/32 function calls. However, cpu_to_le16/32 are used when
    initializing structures, i.e in a context where a function call is not
    allowed.
    
    It works fine on little endian systems because htole16/32 are defined by
    the C library as no-ops. But on big-endian systems, they are actually
    doing something, which might involve calling a function, causing build
    failures, such as:
    
       ffs-test.c:48:25: error: initializer element is not constant
        #define cpu_to_le32(x)  htole32(x)
                                ^~~~~~~
       ffs-test.c:128:12: note: in expansion of macro ‘cpu_to_le32’
          .magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),
                   ^~~~~~~~~~~
    
    To solve this, we code cpu_to_le16/32 in a way that allows them to be
    used when initializing structures. This fix was imported from
    meta-openembedded/android-tools/fix-big-endian-build.patch written by
    Thomas Petazzoni <thomas.petazzoni@free-electrons.com>.
    
    CC: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 95dd14648ba5..0f395dfb7774 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -44,12 +44,25 @@
 
 /******************** Little Endian Handling ********************************/
 
-#define cpu_to_le16(x)  htole16(x)
-#define cpu_to_le32(x)  htole32(x)
+/*
+ * cpu_to_le16/32 are used when initializing structures, a context where a
+ * function call is not allowed. To solve this, we code cpu_to_le16/32 in a way
+ * that allows them to be used when initializing structures.
+ */
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define cpu_to_le16(x)  (x)
+#define cpu_to_le32(x)  (x)
+#else
+#define cpu_to_le16(x)  ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8))
+#define cpu_to_le32(x)  \
+	((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >>  8) | \
+	(((x) & 0x0000ff00u) <<  8) | (((x) & 0x000000ffu) << 24))
+#endif
+
 #define le32_to_cpu(x)  le32toh(x)
 #define le16_to_cpu(x)  le16toh(x)
 
-
 /******************** Messages and Errors ***********************************/
 
 static const char argv0[] = "ffs-test";

commit 271d2d6d94dd56e2897ff989f3ce5ac8ad727323
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Tue Jan 17 15:07:19 2017 +0200

    tools: usb: ffs-test: add SS descriptors
    
    Without SS descriptors, we have no possibility of running on SS
    controllers such as DWC3.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 64fc72acc892..95dd14648ba5 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -110,16 +110,25 @@ static const struct {
 	struct usb_functionfs_descs_head_v2 header;
 	__le32 fs_count;
 	__le32 hs_count;
+	__le32 ss_count;
 	struct {
 		struct usb_interface_descriptor intf;
 		struct usb_endpoint_descriptor_no_audio sink;
 		struct usb_endpoint_descriptor_no_audio source;
 	} __attribute__((packed)) fs_descs, hs_descs;
+	struct {
+		struct usb_interface_descriptor intf;
+		struct usb_endpoint_descriptor_no_audio sink;
+		struct usb_ss_ep_comp_descriptor sink_comp;
+		struct usb_endpoint_descriptor_no_audio source;
+		struct usb_ss_ep_comp_descriptor source_comp;
+	} ss_descs;
 } __attribute__((packed)) descriptors = {
 	.header = {
 		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),
 		.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |
-				     FUNCTIONFS_HAS_HS_DESC),
+				     FUNCTIONFS_HAS_HS_DESC |
+				     FUNCTIONFS_HAS_SS_DESC),
 		.length = cpu_to_le32(sizeof descriptors),
 	},
 	.fs_count = cpu_to_le32(3),
@@ -171,6 +180,45 @@ static const struct {
 			.bInterval = 1, /* NAK every 1 uframe */
 		},
 	},
+	.ss_count = cpu_to_le32(5),
+	.ss_descs = {
+		.intf = {
+			.bLength = sizeof descriptors.fs_descs.intf,
+			.bDescriptorType = USB_DT_INTERFACE,
+			.bNumEndpoints = 2,
+			.bInterfaceClass = USB_CLASS_VENDOR_SPEC,
+			.iInterface = 1,
+		},
+		.sink = {
+			.bLength = sizeof descriptors.hs_descs.sink,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 1 | USB_DIR_IN,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			.wMaxPacketSize = cpu_to_le16(1024),
+		},
+		.sink_comp = {
+			.bLength = USB_DT_SS_EP_COMP_SIZE,
+			.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
+			.bMaxBurst = 0,
+			.bmAttributes = 0,
+			.wBytesPerInterval = 0,
+		},
+		.source = {
+			.bLength = sizeof descriptors.hs_descs.source,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 2 | USB_DIR_OUT,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			.wMaxPacketSize = cpu_to_le16(1024),
+			.bInterval = 1, /* NAK every 1 uframe */
+		},
+		.source_comp = {
+			.bLength = USB_DT_SS_EP_COMP_SIZE,
+			.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
+			.bMaxBurst = 0,
+			.bmAttributes = 0,
+			.wBytesPerInterval = 0,
+		},
+	},
 };
 
 static size_t descs_to_legacy(void **legacy, const void *descriptors_v2)

commit 5abb9b91e8e5e824aa781334f6e4945fd33fcfa8
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Tue Jan 17 15:04:07 2017 +0200

    tools: usb: ffs-test: switch to _DEFAULT_SOURCE
    
    _BSD_SOURCE is deprecated and gives a build warning. Let's use
    _DEFAULT_SOURCE instead.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 88d5e71be044..64fc72acc892 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -22,7 +22,7 @@
 /* $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread */
 
 
-#define _BSD_SOURCE /* for endian.h */
+#define _DEFAULT_SOURCE /* for endian.h */
 
 #include <endian.h>
 #include <errno.h>

commit b9a4274699c6973f62979d664cbe7c9aca4f6a9a
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Wed Aug 27 22:58:47 2014 +0200

    tools: ffs-test: add compatibility code for old kernels
    
    If ffs-test is used with a kernel prior to 3.14, which do not
    support the new descriptors format, it will fail when trying to
    write the descriptors.  Add a function that converts the new
    descriptors to the legacy ones and use it to retry writing the
    descriptors using the legacy format.
    
    Also add “-l” flag to ffs-test which will cause the tool to
    never try the new format and instead immediatelly try the
    legacy one.  This should be useful to test whether parsing
    of the old format still works on given 3.14+ kernel.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 708d317b0f37..88d5e71be044 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -29,6 +29,7 @@
 #include <fcntl.h>
 #include <pthread.h>
 #include <stdarg.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -172,6 +173,89 @@ static const struct {
 	},
 };
 
+static size_t descs_to_legacy(void **legacy, const void *descriptors_v2)
+{
+	const unsigned char *descs_end, *descs_start;
+	__u32 length, fs_count = 0, hs_count = 0, count;
+
+	/* Read v2 header */
+	{
+		const struct {
+			const struct usb_functionfs_descs_head_v2 header;
+			const __le32 counts[];
+		} __attribute__((packed)) *const in = descriptors_v2;
+		const __le32 *counts = in->counts;
+		__u32 flags;
+
+		if (le32_to_cpu(in->header.magic) !=
+		    FUNCTIONFS_DESCRIPTORS_MAGIC_V2)
+			return 0;
+		length = le32_to_cpu(in->header.length);
+		if (length <= sizeof in->header)
+			return 0;
+		length -= sizeof in->header;
+		flags = le32_to_cpu(in->header.flags);
+		if (flags & ~(FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC |
+			      FUNCTIONFS_HAS_SS_DESC))
+			return 0;
+
+#define GET_NEXT_COUNT_IF_FLAG(ret, flg) do {		\
+			if (!(flags & (flg)))		\
+				break;			\
+			if (length < 4)			\
+				return 0;		\
+			ret = le32_to_cpu(*counts);	\
+			length -= 4;			\
+			++counts;			\
+		} while (0)
+
+		GET_NEXT_COUNT_IF_FLAG(fs_count, FUNCTIONFS_HAS_FS_DESC);
+		GET_NEXT_COUNT_IF_FLAG(hs_count, FUNCTIONFS_HAS_HS_DESC);
+		GET_NEXT_COUNT_IF_FLAG(count, FUNCTIONFS_HAS_SS_DESC);
+
+		count = fs_count + hs_count;
+		if (!count)
+			return 0;
+		descs_start = (const void *)counts;
+
+#undef GET_NEXT_COUNT_IF_FLAG
+	}
+
+	/*
+	 * Find the end of FS and HS USB descriptors.  SS descriptors
+	 * are ignored since legacy format does not support them.
+	 */
+	descs_end = descs_start;
+	do {
+		if (length < *descs_end)
+			return 0;
+		length -= *descs_end;
+		descs_end += *descs_end;
+	} while (--count);
+
+	/* Allocate legacy descriptors and copy the data. */
+	{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+		struct {
+			struct usb_functionfs_descs_head header;
+			__u8 descriptors[];
+		} __attribute__((packed)) *out;
+#pragma GCC diagnostic pop
+
+		length = sizeof out->header + (descs_end - descs_start);
+		out = malloc(length);
+		out->header.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC);
+		out->header.length = cpu_to_le32(length);
+		out->header.fs_count = cpu_to_le32(fs_count);
+		out->header.hs_count = cpu_to_le32(hs_count);
+		memcpy(out->descriptors, descs_start, descs_end - descs_start);
+		*legacy = out;
+	}
+
+	return length;
+}
+
 
 #define STR_INTERFACE_ "Source/Sink"
 
@@ -491,12 +575,29 @@ ep0_consume(struct thread *ignore, const void *buf, size_t nbytes)
 	return nbytes;
 }
 
-static void ep0_init(struct thread *t)
+static void ep0_init(struct thread *t, bool legacy_descriptors)
 {
+	void *legacy;
 	ssize_t ret;
+	size_t len;
+
+	if (legacy_descriptors) {
+		info("%s: writing descriptors\n", t->filename);
+		goto legacy;
+	}
 
-	info("%s: writing descriptors\n", t->filename);
+	info("%s: writing descriptors (in v2 format)\n", t->filename);
 	ret = write(t->fd, &descriptors, sizeof descriptors);
+
+	if (ret < 0 && errno == EINVAL) {
+		warn("%s: new format rejected, trying legacy\n", t->filename);
+legacy:
+		len = descs_to_legacy(&legacy, &descriptors);
+		if (len) {
+			ret = write(t->fd, legacy, len);
+			free(legacy);
+		}
+	}
 	die_on(ret < 0, "%s: write: descriptors", t->filename);
 
 	info("%s: writing strings\n", t->filename);
@@ -507,14 +608,15 @@ static void ep0_init(struct thread *t)
 
 /******************** Main **************************************************/
 
-int main(void)
+int main(int argc, char **argv)
 {
+	bool legacy_descriptors;
 	unsigned i;
 
-	/* XXX TODO: Argument parsing missing */
+	legacy_descriptors = argc > 2 && !strcmp(argv[1], "-l");
 
 	init_thread(threads);
-	ep0_init(threads);
+	ep0_init(threads, legacy_descriptors);
 
 	for (i = 1; i < sizeof threads / sizeof *threads; ++i)
 		init_thread(threads + i);

commit 51c208c746e800dba37d1a54d3c5e601630266c4
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Wed Aug 27 22:58:46 2014 +0200

    tools: ffs-test: convert to new descriptor format
    
    Since commit [ac8dde11: “Add flags to descriptors block”] functionfs
    supports a new, more powerful and extensible, descriptor format.
    Since ffs-test is probably the first thing users of the functionfs
    interface see when they start writing functionfs user space daemons,
    convert it to use the new format thus promoting it.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index a87e99f37c52..708d317b0f37 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -1,5 +1,5 @@
 /*
- * ffs-test.c.c -- user mode filesystem api for usb composite function
+ * ffs-test.c -- user mode filesystem api for usb composite function
  *
  * Copyright (C) 2010 Samsung Electronics
  *                    Author: Michal Nazarewicz <mina86@mina86.com>
@@ -106,7 +106,9 @@ static void _msg(unsigned level, const char *fmt, ...)
 /******************** Descriptors and Strings *******************************/
 
 static const struct {
-	struct usb_functionfs_descs_head header;
+	struct usb_functionfs_descs_head_v2 header;
+	__le32 fs_count;
+	__le32 hs_count;
 	struct {
 		struct usb_interface_descriptor intf;
 		struct usb_endpoint_descriptor_no_audio sink;
@@ -114,11 +116,12 @@ static const struct {
 	} __attribute__((packed)) fs_descs, hs_descs;
 } __attribute__((packed)) descriptors = {
 	.header = {
-		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC),
+		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),
+		.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |
+				     FUNCTIONFS_HAS_HS_DESC),
 		.length = cpu_to_le32(sizeof descriptors),
-		.fs_count = cpu_to_le32(3),
-		.hs_count = cpu_to_le32(3),
 	},
+	.fs_count = cpu_to_le32(3),
 	.fs_descs = {
 		.intf = {
 			.bLength = sizeof descriptors.fs_descs.intf,
@@ -142,6 +145,7 @@ static const struct {
 			/* .wMaxPacketSize = autoconfiguration (kernel) */
 		},
 	},
+	.hs_count = cpu_to_le32(3),
 	.hs_descs = {
 		.intf = {
 			.bLength = sizeof descriptors.fs_descs.intf,

commit f35f71244da6e51db4e1f2c7e318581f498ececf
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Fri Jun 13 15:38:05 2014 +0200

    tools: ffs-test: fix header values endianess
    
    It appears that no one ever run ffs-test on a big-endian machine,
    since it used cpu-endianess for fs_count and hs_count fields which
    should be in little-endian format.  Fix by wrapping the numbers in
    cpu_to_le32.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index fe1e66b6ef40..a87e99f37c52 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -116,8 +116,8 @@ static const struct {
 	.header = {
 		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC),
 		.length = cpu_to_le32(sizeof descriptors),
-		.fs_count = 3,
-		.hs_count = 3,
+		.fs_count = cpu_to_le32(3),
+		.hs_count = cpu_to_le32(3),
 	},
 	.fs_descs = {
 		.intf = {

commit 9ad7860450ea65c6bbcbd52a9a25b54b07e35941
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Jun 27 10:41:00 2014 -0500

    Revert "tools: ffs-test: convert to new descriptor format fixing compilation error"
    
    This reverts commit f2af74123f8c5a735248547f4286a3adc28633c1.
    
    There is a better fix for this build error coming in a following
    patch.
    
    Signed-of-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 74b353d9eb50..fe1e66b6ef40 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -1,5 +1,5 @@
 /*
- * ffs-test.c -- user mode filesystem api for usb composite function
+ * ffs-test.c.c -- user mode filesystem api for usb composite function
  *
  * Copyright (C) 2010 Samsung Electronics
  *                    Author: Michal Nazarewicz <mina86@mina86.com>
@@ -21,8 +21,6 @@
 
 /* $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread */
 
-/* Uncomment to make the tool use legacy FFS descriptor headers. */
-/* #define USE_LEGACY_DESC_HEAD */
 
 #define _BSD_SOURCE /* for endian.h */
 
@@ -108,15 +106,7 @@ static void _msg(unsigned level, const char *fmt, ...)
 /******************** Descriptors and Strings *******************************/
 
 static const struct {
-	struct {
-		__le32 magic;
-		__le32 length;
-#ifndef USE_LEGACY_DESC_HEAD
-		__le32 flags;
-#endif
-		__le32 fs_count;
-		__le32 hs_count;
-	} __attribute__((packed)) header;
+	struct usb_functionfs_descs_head header;
 	struct {
 		struct usb_interface_descriptor intf;
 		struct usb_endpoint_descriptor_no_audio sink;
@@ -124,13 +114,7 @@ static const struct {
 	} __attribute__((packed)) fs_descs, hs_descs;
 } __attribute__((packed)) descriptors = {
 	.header = {
-#ifdef USE_LEGACY_DESC_HEAD
 		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC),
-#else
-		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),
-		.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |
-				     FUNCTIONFS_HAS_HS_DESC),
-#endif
 		.length = cpu_to_le32(sizeof descriptors),
 		.fs_count = 3,
 		.hs_count = 3,

commit f2af74123f8c5a735248547f4286a3adc28633c1
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Tue May 20 09:38:03 2014 -1000

    tools: ffs-test: convert to new descriptor format fixing compilation error
    
    Commit [ac8dde11: “usb: gadget: f_fs: Add flags to descriptors block”]
    which introduced a new descriptor format for FunctionFS removed the
    usb_functionfs_descs_head structure, which is still used by ffs-test.
    tool.
    
    Convert ffs-test by converting it to use the new header format.  For
    testing kernels prior to 3.14 (when the new format was introduced) and
    parsing of the legacy headers in the new kernels, provide a compilation
    flag to make the tool use the old format.
    
    Finally, include information as to when the legacy FunctionFS headers
    format has been deprecated (which is also when the new one has been
    introduced).
    
    Reported-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index fe1e66b6ef40..74b353d9eb50 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -1,5 +1,5 @@
 /*
- * ffs-test.c.c -- user mode filesystem api for usb composite function
+ * ffs-test.c -- user mode filesystem api for usb composite function
  *
  * Copyright (C) 2010 Samsung Electronics
  *                    Author: Michal Nazarewicz <mina86@mina86.com>
@@ -21,6 +21,8 @@
 
 /* $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread */
 
+/* Uncomment to make the tool use legacy FFS descriptor headers. */
+/* #define USE_LEGACY_DESC_HEAD */
 
 #define _BSD_SOURCE /* for endian.h */
 
@@ -106,7 +108,15 @@ static void _msg(unsigned level, const char *fmt, ...)
 /******************** Descriptors and Strings *******************************/
 
 static const struct {
-	struct usb_functionfs_descs_head header;
+	struct {
+		__le32 magic;
+		__le32 length;
+#ifndef USE_LEGACY_DESC_HEAD
+		__le32 flags;
+#endif
+		__le32 fs_count;
+		__le32 hs_count;
+	} __attribute__((packed)) header;
 	struct {
 		struct usb_interface_descriptor intf;
 		struct usb_endpoint_descriptor_no_audio sink;
@@ -114,7 +124,13 @@ static const struct {
 	} __attribute__((packed)) fs_descs, hs_descs;
 } __attribute__((packed)) descriptors = {
 	.header = {
+#ifdef USE_LEGACY_DESC_HEAD
 		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC),
+#else
+		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),
+		.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |
+				     FUNCTIONFS_HAS_HS_DESC),
+#endif
 		.length = cpu_to_le32(sizeof descriptors),
 		.fs_count = 3,
 		.hs_count = 3,

commit a0f11aceee531d444f58b939e6a537ee5e2b9cc5
Author: Maxin B. John <maxin.john@enea.com>
Date:   Thu Feb 21 01:57:51 2013 +0200

    tools: usb: ffs-test: Fix build failure
    
    Fixes this build failure:
    gcc -Wall -Wextra -g -lpthread -I../include -o testusb testusb.c
    gcc -Wall -Wextra -g -lpthread -I../include -o ffs-test ffs-test.c
    In file included from ffs-test.c:41:0:
    ../../include/linux/usb/functionfs.h:4:39: fatal error:
    uapi/linux/usb/functionfs.h: No such file or directory
    compilation terminated.
    make: *** [ffs-test] Error 1
    
    Signed-off-by: Maxin B. John <maxin.john@enea.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: stable <stable@vger.kernel.org>  # 3.7+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 8674b9ec14f6..fe1e66b6ef40 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -38,7 +38,7 @@
 #include <unistd.h>
 #include <tools/le_byteshift.h>
 
-#include "../../include/linux/usb/functionfs.h"
+#include "../../include/uapi/linux/usb/functionfs.h"
 
 
 /******************** Little Endian Handling ********************************/

commit eb9c5836384cd2a276254df6254ed71117983626
Author: Matthias Fend <Matthias.Fend@wolfvision.net>
Date:   Mon May 7 14:37:30 2012 +0200

    USB: ffs-test: fix length argument of out function call
    
    The out functions should only handle actual available data instead of the complete buffer.
    Otherwise for example the ep0_consume function will report ghost events since it tries to decode
    the complete buffer - which may contain partly invalid data.
    
    Signed-off-by: Matthias Fend <matthias.fend@wolfvision.net>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index 4b107b5e623f..8674b9ec14f6 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -297,7 +297,7 @@ static void *start_thread_helper(void *arg)
 
 		ret = t->in(t, t->buf, t->buf_size);
 		if (ret > 0) {
-			ret = t->out(t, t->buf, t->buf_size);
+			ret = t->out(t, t->buf, ret);
 			name = out_name;
 			op = "write";
 		} else {

commit 02c502566ef505d0469fa27567f48766c1f5f7af
Merge: f06fc0c0de0b a51f4047758d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 22 09:40:53 2012 -0700

    Merge branch 'x86-build-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86/build changes from Ingo Molnar.
    
    * 'x86-build-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, build: Fix portability issues when cross-building
      x86, tools: Remove unneeded header files from tools/build.c
      USB: ffs-test: Don't duplicate {get,put}_unaligned*() functions
      x86, efi: Fix endian issues and unaligned accesses
      x86, boot: Restrict CFLAGS for hostprogs
      x86, mkpiggy: Don't open code put_unaligned_le32()
      x86, relocs: Don't open code put_unaligned_le32()
      tools/include: Add byteshift headers for endian access

commit 24fa9a9d6d70ef7ef7087dce472a8f43a9078da5
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Feb 28 13:37:25 2012 +0000

    USB: ffs-test: Don't duplicate {get,put}_unaligned*() functions
    
    Use the header file in tools/include instead of duplicating the endian
    functions.
    
    Cc: Davidlohr Bueso <dave@gnu.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1330436245-24875-7-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index b9c798631699..384f47a5727f 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -36,6 +36,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include <tools/le_byteshift.h>
 
 #include "../../include/linux/usb/functionfs.h"
 
@@ -47,34 +48,6 @@
 #define le32_to_cpu(x)  le32toh(x)
 #define le16_to_cpu(x)  le16toh(x)
 
-static inline __u16 get_unaligned_le16(const void *_ptr)
-{
-	const __u8 *ptr = _ptr;
-	return ptr[0] | (ptr[1] << 8);
-}
-
-static inline __u32 get_unaligned_le32(const void *_ptr)
-{
-	const __u8 *ptr = _ptr;
-	return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24);
-}
-
-static inline void put_unaligned_le16(__u16 val, void *_ptr)
-{
-	__u8 *ptr = _ptr;
-	*ptr++ = val;
-	*ptr++ = val >> 8;
-}
-
-static inline void put_unaligned_le32(__u32 val, void *_ptr)
-{
-	__u8 *ptr = _ptr;
-	*ptr++ = val;
-	*ptr++ = val >>  8;
-	*ptr++ = val >> 16;
-	*ptr++ = val >> 24;
-}
-
 
 /******************** Messages and Errors ***********************************/
 

commit 54b8360ffd4c8b2c128ca25233b8c6876fb92d30
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Fri Jan 13 15:05:16 2012 +0100

    usb: gadget: update Michal Nazarewicz's email address
    
    The m.nazarewicz@samsung.com email address is no longer valid,
    so this commit replaces it with mina86@mina86.com which is
    employer-agnostic and thus should be valid for foreseeable
    feature.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index b9c798631699..53452c35d5e1 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -2,7 +2,7 @@
  * ffs-test.c.c -- user mode filesystem api for usb composite function
  *
  * Copyright (C) 2010 Samsung Electronics
- *                    Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
+ *                    Author: Michal Nazarewicz <mina86@mina86.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit d105e74eff7f8197b4d8e104e347ffbc5c3989b8
Author: Davidlohr Bueso <dave@gnu.org>
Date:   Sun Feb 27 04:58:48 2011 -0300

    USB: ffs-test: fix header path
    
    When compiling this program the functionfs.h header cannot be found, producing:
    ffs-test.c:40: fatal error: linux/usb/functionfs.h: No such file or directory
    
    This patch also fixes the following warning:
    ffs-test.c:453: warning: format ‘%4d’ expects type ‘int’, but argument 3 has type ‘size_t’
    
    Signed-off-by: Davidlohr Bueso <dave@gnu.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
index bbe2e3a2ea62..b9c798631699 100644
--- a/tools/usb/ffs-test.c
+++ b/tools/usb/ffs-test.c
@@ -37,7 +37,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#include <linux/usb/functionfs.h>
+#include "../../include/linux/usb/functionfs.h"
 
 
 /******************** Little Endian Handling ********************************/
@@ -450,7 +450,7 @@ empty_out_buf(struct thread *ignore, const void *buf, size_t nbytes)
 		    len, expected, *p);
 		for (p = buf, len = 0; len < nbytes; ++p, ++len) {
 			if (0 == (len % 32))
-				fprintf(stderr, "%4d:", len);
+				fprintf(stderr, "%4zd:", len);
 			fprintf(stderr, " %02x", *p);
 			if (31 == (len % 32))
 				fprintf(stderr, "\n");

commit 93f2aa4ddd25caac2b9a09538da54308dbda44e2
Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date:   Wed May 5 12:53:16 2010 +0200

    USB: ffs-test: FunctionFS testing program
    
    This adds an example user-space FunctionFS driver which
    implements a source/sink interface used for testing.
    
    Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/tools/usb/ffs-test.c b/tools/usb/ffs-test.c
new file mode 100644
index 000000000000..bbe2e3a2ea62
--- /dev/null
+++ b/tools/usb/ffs-test.c
@@ -0,0 +1,554 @@
+/*
+ * ffs-test.c.c -- user mode filesystem api for usb composite function
+ *
+ * Copyright (C) 2010 Samsung Electronics
+ *                    Author: Michal Nazarewicz <m.nazarewicz@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread */
+
+
+#define _BSD_SOURCE /* for endian.h */
+
+#include <endian.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <linux/usb/functionfs.h>
+
+
+/******************** Little Endian Handling ********************************/
+
+#define cpu_to_le16(x)  htole16(x)
+#define cpu_to_le32(x)  htole32(x)
+#define le32_to_cpu(x)  le32toh(x)
+#define le16_to_cpu(x)  le16toh(x)
+
+static inline __u16 get_unaligned_le16(const void *_ptr)
+{
+	const __u8 *ptr = _ptr;
+	return ptr[0] | (ptr[1] << 8);
+}
+
+static inline __u32 get_unaligned_le32(const void *_ptr)
+{
+	const __u8 *ptr = _ptr;
+	return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24);
+}
+
+static inline void put_unaligned_le16(__u16 val, void *_ptr)
+{
+	__u8 *ptr = _ptr;
+	*ptr++ = val;
+	*ptr++ = val >> 8;
+}
+
+static inline void put_unaligned_le32(__u32 val, void *_ptr)
+{
+	__u8 *ptr = _ptr;
+	*ptr++ = val;
+	*ptr++ = val >>  8;
+	*ptr++ = val >> 16;
+	*ptr++ = val >> 24;
+}
+
+
+/******************** Messages and Errors ***********************************/
+
+static const char argv0[] = "ffs-test";
+
+static unsigned verbosity = 7;
+
+static void _msg(unsigned level, const char *fmt, ...)
+{
+	if (level < 2)
+		level = 2;
+	else if (level > 7)
+		level = 7;
+
+	if (level <= verbosity) {
+		static const char levels[8][6] = {
+			[2] = "crit:",
+			[3] = "err: ",
+			[4] = "warn:",
+			[5] = "note:",
+			[6] = "info:",
+			[7] = "dbg: "
+		};
+
+		int _errno = errno;
+		va_list ap;
+
+		fprintf(stderr, "%s: %s ", argv0, levels[level]);
+		va_start(ap, fmt);
+		vfprintf(stderr, fmt, ap);
+		va_end(ap);
+
+		if (fmt[strlen(fmt) - 1] != '\n') {
+			char buffer[128];
+			strerror_r(_errno, buffer, sizeof buffer);
+			fprintf(stderr, ": (-%d) %s\n", _errno, buffer);
+		}
+
+		fflush(stderr);
+	}
+}
+
+#define die(...)  (_msg(2, __VA_ARGS__), exit(1))
+#define err(...)   _msg(3, __VA_ARGS__)
+#define warn(...)  _msg(4, __VA_ARGS__)
+#define note(...)  _msg(5, __VA_ARGS__)
+#define info(...)  _msg(6, __VA_ARGS__)
+#define debug(...) _msg(7, __VA_ARGS__)
+
+#define die_on(cond, ...) do { \
+	if (cond) \
+		die(__VA_ARGS__); \
+	} while (0)
+
+
+/******************** Descriptors and Strings *******************************/
+
+static const struct {
+	struct usb_functionfs_descs_head header;
+	struct {
+		struct usb_interface_descriptor intf;
+		struct usb_endpoint_descriptor_no_audio sink;
+		struct usb_endpoint_descriptor_no_audio source;
+	} __attribute__((packed)) fs_descs, hs_descs;
+} __attribute__((packed)) descriptors = {
+	.header = {
+		.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC),
+		.length = cpu_to_le32(sizeof descriptors),
+		.fs_count = 3,
+		.hs_count = 3,
+	},
+	.fs_descs = {
+		.intf = {
+			.bLength = sizeof descriptors.fs_descs.intf,
+			.bDescriptorType = USB_DT_INTERFACE,
+			.bNumEndpoints = 2,
+			.bInterfaceClass = USB_CLASS_VENDOR_SPEC,
+			.iInterface = 1,
+		},
+		.sink = {
+			.bLength = sizeof descriptors.fs_descs.sink,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 1 | USB_DIR_IN,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			/* .wMaxPacketSize = autoconfiguration (kernel) */
+		},
+		.source = {
+			.bLength = sizeof descriptors.fs_descs.source,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 2 | USB_DIR_OUT,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			/* .wMaxPacketSize = autoconfiguration (kernel) */
+		},
+	},
+	.hs_descs = {
+		.intf = {
+			.bLength = sizeof descriptors.fs_descs.intf,
+			.bDescriptorType = USB_DT_INTERFACE,
+			.bNumEndpoints = 2,
+			.bInterfaceClass = USB_CLASS_VENDOR_SPEC,
+			.iInterface = 1,
+		},
+		.sink = {
+			.bLength = sizeof descriptors.hs_descs.sink,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 1 | USB_DIR_IN,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			.wMaxPacketSize = cpu_to_le16(512),
+		},
+		.source = {
+			.bLength = sizeof descriptors.hs_descs.source,
+			.bDescriptorType = USB_DT_ENDPOINT,
+			.bEndpointAddress = 2 | USB_DIR_OUT,
+			.bmAttributes = USB_ENDPOINT_XFER_BULK,
+			.wMaxPacketSize = cpu_to_le16(512),
+			.bInterval = 1, /* NAK every 1 uframe */
+		},
+	},
+};
+
+
+#define STR_INTERFACE_ "Source/Sink"
+
+static const struct {
+	struct usb_functionfs_strings_head header;
+	struct {
+		__le16 code;
+		const char str1[sizeof STR_INTERFACE_];
+	} __attribute__((packed)) lang0;
+} __attribute__((packed)) strings = {
+	.header = {
+		.magic = cpu_to_le32(FUNCTIONFS_STRINGS_MAGIC),
+		.length = cpu_to_le32(sizeof strings),
+		.str_count = cpu_to_le32(1),
+		.lang_count = cpu_to_le32(1),
+	},
+	.lang0 = {
+		cpu_to_le16(0x0409), /* en-us */
+		STR_INTERFACE_,
+	},
+};
+
+#define STR_INTERFACE strings.lang0.str1
+
+
+/******************** Files and Threads Handling ****************************/
+
+struct thread;
+
+static ssize_t read_wrap(struct thread *t, void *buf, size_t nbytes);
+static ssize_t write_wrap(struct thread *t, const void *buf, size_t nbytes);
+static ssize_t ep0_consume(struct thread *t, const void *buf, size_t nbytes);
+static ssize_t fill_in_buf(struct thread *t, void *buf, size_t nbytes);
+static ssize_t empty_out_buf(struct thread *t, const void *buf, size_t nbytes);
+
+
+static struct thread {
+	const char *const filename;
+	size_t buf_size;
+
+	ssize_t (*in)(struct thread *, void *, size_t);
+	const char *const in_name;
+
+	ssize_t (*out)(struct thread *, const void *, size_t);
+	const char *const out_name;
+
+	int fd;
+	pthread_t id;
+	void *buf;
+	ssize_t status;
+} threads[] = {
+	{
+		"ep0", 4 * sizeof(struct usb_functionfs_event),
+		read_wrap, NULL,
+		ep0_consume, "<consume>",
+		0, 0, NULL, 0
+	},
+	{
+		"ep1", 8 * 1024,
+		fill_in_buf, "<in>",
+		write_wrap, NULL,
+		0, 0, NULL, 0
+	},
+	{
+		"ep2", 8 * 1024,
+		read_wrap, NULL,
+		empty_out_buf, "<out>",
+		0, 0, NULL, 0
+	},
+};
+
+
+static void init_thread(struct thread *t)
+{
+	t->buf = malloc(t->buf_size);
+	die_on(!t->buf, "malloc");
+
+	t->fd = open(t->filename, O_RDWR);
+	die_on(t->fd < 0, "%s", t->filename);
+}
+
+static void cleanup_thread(void *arg)
+{
+	struct thread *t = arg;
+	int ret, fd;
+
+	fd = t->fd;
+	if (t->fd < 0)
+		return;
+	t->fd = -1;
+
+	/* test the FIFO ioctls (non-ep0 code paths) */
+	if (t != threads) {
+		ret = ioctl(fd, FUNCTIONFS_FIFO_STATUS);
+		if (ret < 0) {
+			/* ENODEV reported after disconnect */
+			if (errno != ENODEV)
+				err("%s: get fifo status", t->filename);
+		} else if (ret) {
+			warn("%s: unclaimed = %d\n", t->filename, ret);
+			if (ioctl(fd, FUNCTIONFS_FIFO_FLUSH) < 0)
+				err("%s: fifo flush", t->filename);
+		}
+	}
+
+	if (close(fd) < 0)
+		err("%s: close", t->filename);
+
+	free(t->buf);
+	t->buf = NULL;
+}
+
+static void *start_thread_helper(void *arg)
+{
+	const char *name, *op, *in_name, *out_name;
+	struct thread *t = arg;
+	ssize_t ret;
+
+	info("%s: starts\n", t->filename);
+	in_name = t->in_name ? t->in_name : t->filename;
+	out_name = t->out_name ? t->out_name : t->filename;
+
+	pthread_cleanup_push(cleanup_thread, arg);
+
+	for (;;) {
+		pthread_testcancel();
+
+		ret = t->in(t, t->buf, t->buf_size);
+		if (ret > 0) {
+			ret = t->out(t, t->buf, t->buf_size);
+			name = out_name;
+			op = "write";
+		} else {
+			name = in_name;
+			op = "read";
+		}
+
+		if (ret > 0) {
+			/* nop */
+		} else if (!ret) {
+			debug("%s: %s: EOF", name, op);
+			break;
+		} else if (errno == EINTR || errno == EAGAIN) {
+			debug("%s: %s", name, op);
+		} else {
+			warn("%s: %s", name, op);
+			break;
+		}
+	}
+
+	pthread_cleanup_pop(1);
+
+	t->status = ret;
+	info("%s: ends\n", t->filename);
+	return NULL;
+}
+
+static void start_thread(struct thread *t)
+{
+	debug("%s: starting\n", t->filename);
+
+	die_on(pthread_create(&t->id, NULL, start_thread_helper, t) < 0,
+	       "pthread_create(%s)", t->filename);
+}
+
+static void join_thread(struct thread *t)
+{
+	int ret = pthread_join(t->id, NULL);
+
+	if (ret < 0)
+		err("%s: joining thread", t->filename);
+	else
+		debug("%s: joined\n", t->filename);
+}
+
+
+static ssize_t read_wrap(struct thread *t, void *buf, size_t nbytes)
+{
+	return read(t->fd, buf, nbytes);
+}
+
+static ssize_t write_wrap(struct thread *t, const void *buf, size_t nbytes)
+{
+	return write(t->fd, buf, nbytes);
+}
+
+
+/******************** Empty/Fill buffer routines ****************************/
+
+/* 0 -- stream of zeros, 1 -- i % 63, 2 -- pipe */
+enum pattern { PAT_ZERO, PAT_SEQ, PAT_PIPE };
+static enum pattern pattern;
+
+static ssize_t
+fill_in_buf(struct thread *ignore, void *buf, size_t nbytes)
+{
+	size_t i;
+	__u8 *p;
+
+	(void)ignore;
+
+	switch (pattern) {
+	case PAT_ZERO:
+		memset(buf, 0, nbytes);
+		break;
+
+	case PAT_SEQ:
+		for (p = buf, i = 0; i < nbytes; ++i, ++p)
+			*p = i % 63;
+		break;
+
+	case PAT_PIPE:
+		return fread(buf, 1, nbytes, stdin);
+	}
+
+	return nbytes;
+}
+
+static ssize_t
+empty_out_buf(struct thread *ignore, const void *buf, size_t nbytes)
+{
+	const __u8 *p;
+	__u8 expected;
+	ssize_t ret;
+	size_t len;
+
+	(void)ignore;
+
+	switch (pattern) {
+	case PAT_ZERO:
+		expected = 0;
+		for (p = buf, len = 0; len < nbytes; ++p, ++len)
+			if (*p)
+				goto invalid;
+		break;
+
+	case PAT_SEQ:
+		for (p = buf, len = 0; len < nbytes; ++p, ++len)
+			if (*p != len % 63) {
+				expected = len % 63;
+				goto invalid;
+			}
+		break;
+
+	case PAT_PIPE:
+		ret = fwrite(buf, nbytes, 1, stdout);
+		if (ret > 0)
+			fflush(stdout);
+		break;
+
+invalid:
+		err("bad OUT byte %zd, expected %02x got %02x\n",
+		    len, expected, *p);
+		for (p = buf, len = 0; len < nbytes; ++p, ++len) {
+			if (0 == (len % 32))
+				fprintf(stderr, "%4d:", len);
+			fprintf(stderr, " %02x", *p);
+			if (31 == (len % 32))
+				fprintf(stderr, "\n");
+		}
+		fflush(stderr);
+		errno = EILSEQ;
+		return -1;
+	}
+
+	return len;
+}
+
+
+/******************** Endpoints routines ************************************/
+
+static void handle_setup(const struct usb_ctrlrequest *setup)
+{
+	printf("bRequestType = %d\n", setup->bRequestType);
+	printf("bRequest     = %d\n", setup->bRequest);
+	printf("wValue       = %d\n", le16_to_cpu(setup->wValue));
+	printf("wIndex       = %d\n", le16_to_cpu(setup->wIndex));
+	printf("wLength      = %d\n", le16_to_cpu(setup->wLength));
+}
+
+static ssize_t
+ep0_consume(struct thread *ignore, const void *buf, size_t nbytes)
+{
+	static const char *const names[] = {
+		[FUNCTIONFS_BIND] = "BIND",
+		[FUNCTIONFS_UNBIND] = "UNBIND",
+		[FUNCTIONFS_ENABLE] = "ENABLE",
+		[FUNCTIONFS_DISABLE] = "DISABLE",
+		[FUNCTIONFS_SETUP] = "SETUP",
+		[FUNCTIONFS_SUSPEND] = "SUSPEND",
+		[FUNCTIONFS_RESUME] = "RESUME",
+	};
+
+	const struct usb_functionfs_event *event = buf;
+	size_t n;
+
+	(void)ignore;
+
+	for (n = nbytes / sizeof *event; n; --n, ++event)
+		switch (event->type) {
+		case FUNCTIONFS_BIND:
+		case FUNCTIONFS_UNBIND:
+		case FUNCTIONFS_ENABLE:
+		case FUNCTIONFS_DISABLE:
+		case FUNCTIONFS_SETUP:
+		case FUNCTIONFS_SUSPEND:
+		case FUNCTIONFS_RESUME:
+			printf("Event %s\n", names[event->type]);
+			if (event->type == FUNCTIONFS_SETUP)
+				handle_setup(&event->u.setup);
+			break;
+
+		default:
+			printf("Event %03u (unknown)\n", event->type);
+		}
+
+	return nbytes;
+}
+
+static void ep0_init(struct thread *t)
+{
+	ssize_t ret;
+
+	info("%s: writing descriptors\n", t->filename);
+	ret = write(t->fd, &descriptors, sizeof descriptors);
+	die_on(ret < 0, "%s: write: descriptors", t->filename);
+
+	info("%s: writing strings\n", t->filename);
+	ret = write(t->fd, &strings, sizeof strings);
+	die_on(ret < 0, "%s: write: strings", t->filename);
+}
+
+
+/******************** Main **************************************************/
+
+int main(void)
+{
+	unsigned i;
+
+	/* XXX TODO: Argument parsing missing */
+
+	init_thread(threads);
+	ep0_init(threads);
+
+	for (i = 1; i < sizeof threads / sizeof *threads; ++i)
+		init_thread(threads + i);
+
+	for (i = 1; i < sizeof threads / sizeof *threads; ++i)
+		start_thread(threads + i);
+
+	start_thread_helper(threads);
+
+	for (i = 1; i < sizeof threads / sizeof *threads; ++i)
+		join_thread(threads + i);
+
+	return 0;
+}
