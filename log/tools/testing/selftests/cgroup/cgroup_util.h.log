commit 9bd5910d7f3db2f65be139d2679dd9daa4a3419a
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Wed Feb 5 14:26:23 2020 +0100

    selftests/cgroup: add tests for cloning into cgroups
    
    Expand the cgroup test-suite to include tests for CLONE_INTO_CGROUP.
    This adds the following tests:
    - CLONE_INTO_CGROUP manages to clone a process directly into a correctly
      delegated cgroup
    - CLONE_INTO_CGROUP fails to clone a process into a cgroup that has been
      removed after we've opened an fd to it
    - CLONE_INTO_CGROUP fails to clone a process into an invalid domain
      cgroup
    - CLONE_INTO_CGROUP adheres to the no internal process constraint
    - CLONE_INTO_CGROUP works with the freezer feature
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: cgroups@vger.kernel.org
    Cc: linux-kselftest@vger.kernel.org
    Acked-by: Roman Gushchin <guro@fb.com>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index 49c54fbdb229..5a1305dd1f0b 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -50,3 +50,7 @@ extern int cg_wait_for_proc_count(const char *cgroup, int count);
 extern int cg_killall(const char *cgroup);
 extern ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size);
 extern int proc_read_strstr(int pid, bool thread, const char *item, const char *needle);
+extern pid_t clone_into_cgroup(int cgroup_fd);
+extern int clone_reap(pid_t pid, int options);
+extern int clone_into_cgroup_run_wait(const char *cgroup);
+extern int dirfd_open_opath(const char *dir);

commit 11318989c381d2b08b4e361a03df09d54434b26c
Author: Michal Koutný <mkoutny@suse.com>
Date:   Fri Oct 4 12:57:42 2019 +0200

    selftests: cgroup: Add task migration tests
    
    Add two new tests that verify that thread and threadgroup migrations
    work as expected.
    
    Signed-off-by: Michal Koutný <mkoutny@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index 27ff21d82af1..49c54fbdb229 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -30,6 +30,7 @@ extern int cg_read_strstr(const char *cgroup, const char *control,
 			  const char *needle);
 extern long cg_read_long(const char *cgroup, const char *control);
 long cg_read_key_long(const char *cgroup, const char *control, const char *key);
+extern long cg_read_lc(const char *cgroup, const char *control);
 extern int cg_write(const char *cgroup, const char *control, char *buf);
 extern int cg_run(const char *cgroup,
 		  int (*fn)(const char *cgroup, void *arg),
@@ -48,3 +49,4 @@ extern int set_oom_adj_score(int pid, int score);
 extern int cg_wait_for_proc_count(const char *cgroup, int count);
 extern int cg_killall(const char *cgroup);
 extern ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size);
+extern int proc_read_strstr(int pid, bool thread, const char *item, const char *needle);

commit 58c9f75b86f76895b9dd44f21dc1e37d0f477cc7
Author: Michal Koutný <mkoutny@suse.com>
Date:   Fri Oct 4 12:57:41 2019 +0200

    selftests: cgroup: Simplify task self migration
    
    Simplify task migration by being oblivious about its PID during
    migration. This allows to easily migrate individual threads as well.
    This change brings no functional change and prepares grounds for thread
    granularity migrating tests.
    
    Signed-off-by: Michal Koutný <mkoutny@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index c72f28046bfa..27ff21d82af1 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -1,4 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+#include <stdbool.h>
 #include <stdlib.h>
 
 #define PAGE_SIZE 4096
@@ -35,6 +36,7 @@ extern int cg_run(const char *cgroup,
 		  void *arg);
 extern int cg_enter(const char *cgroup, int pid);
 extern int cg_enter_current(const char *cgroup);
+extern int cg_enter_current_thread(const char *cgroup);
 extern int cg_run_nowait(const char *cgroup,
 			 int (*fn)(const char *cgroup, void *arg),
 			 void *arg);
@@ -45,4 +47,4 @@ extern int is_swap_enabled(void);
 extern int set_oom_adj_score(int pid, int score);
 extern int cg_wait_for_proc_count(const char *cgroup, int count);
 extern int cg_killall(const char *cgroup);
-extern char proc_read_text(int pid, const char *item, char *buf, size_t size);
+extern ssize_t proc_read_text(int pid, bool thread, const char *item, char *buf, size_t size);

commit 5313bfe425c8aadc582356f575100f3235a6d638
Author: Roman Gushchin <guro@fb.com>
Date:   Fri Apr 19 10:03:06 2019 -0700

    kselftests: cgroup: add freezer controller self-tests
    
    This patch implements 9 tests for the freezer controller for
    cgroup v2:
    1) a simple test, which aims to freeze and unfreeze a cgroup with 100
    processes
    2) a more complicated tree test, which creates a hierarchy of cgroups,
    puts some processes in some cgroups, and tries to freeze and unfreeze
    different parts of the subtree
    3) a forkbomb test: the test aims to freeze a forkbomb running in a
    cgroup, kill all tasks in the cgroup and remove the cgroup without
    the unfreezing.
    4) rmdir test: the test creates two nested cgroups, freezes the parent
    one, checks that the child can be successfully removed, and a new
    child can be created
    5) migration tests: the test checks migration of a task between
    frozen cgroups: from a frozen to a running, from a running to a
    frozen, and from a frozen to a frozen.
    6) ptrace test: the test checks that it's possible to attach to
    a process in a frozen cgroup, get some information and detach, and
    the cgroup will remain frozen.
    7) stopped test: the test checks that it's possible to freeze a cgroup
    with a stopped task
    8) ptraced test: the test checks that it's possible to freeze a cgroup
    with a ptraced task
    9) vfork test: the test checks that it's possible to freeze a cgroup
    with a parent process waiting for the child process in vfork()
    
    Expected output:
      $ ./test_freezer
      ok 1 test_cgfreezer_simple
      ok 2 test_cgfreezer_tree
      ok 3 test_cgfreezer_forkbomb
      ok 4 test_cgrreezer_rmdir
      ok 5 test_cgfreezer_migrate
      ok 6 test_cgfreezer_ptrace
      ok 7 test_cgfreezer_stopped
      ok 8 test_cgfreezer_ptraced
      ok 9 test_cgfreezer_vfork
    
    Signed-off-by: Roman Gushchin <guro@fb.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: kernel-team@fb.com
    Cc: linux-kselftest@vger.kernel.org

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index 9ac8b7958f83..c72f28046bfa 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -18,6 +18,7 @@ static inline int values_close(long a, long b, int err)
 extern int cg_find_unified_root(char *root, size_t len);
 extern char *cg_name(const char *root, const char *name);
 extern char *cg_name_indexed(const char *root, const char *name, int index);
+extern char *cg_control(const char *cgroup, const char *control);
 extern int cg_create(const char *cgroup);
 extern int cg_destroy(const char *cgroup);
 extern int cg_read(const char *cgroup, const char *control,
@@ -32,6 +33,7 @@ extern int cg_write(const char *cgroup, const char *control, char *buf);
 extern int cg_run(const char *cgroup,
 		  int (*fn)(const char *cgroup, void *arg),
 		  void *arg);
+extern int cg_enter(const char *cgroup, int pid);
 extern int cg_enter_current(const char *cgroup);
 extern int cg_run_nowait(const char *cgroup,
 			 int (*fn)(const char *cgroup, void *arg),
@@ -41,3 +43,6 @@ extern int alloc_pagecache(int fd, size_t size);
 extern int alloc_anon(const char *cgroup, void *arg);
 extern int is_swap_enabled(void);
 extern int set_oom_adj_score(int pid, int score);
+extern int cg_wait_for_proc_count(const char *cgroup, int count);
+extern int cg_killall(const char *cgroup);
+extern char proc_read_text(int pid, const char *item, char *buf, size_t size);

commit a987785dcd6c8ae2915460582aebd6481c81eb67
Author: Jay Kamat <jgkamat@fb.com>
Date:   Fri Sep 7 14:34:05 2018 -0700

    Add tests for memory.oom.group
    
    Add tests for memory.oom.group for the following cases:
    - Killing all processes in a leaf cgroup, but leaving the
      parent untouched
    - Killing all processes in a parent and leaf cgroup
    - Keeping processes marked by OOM_SCORE_ADJ_MIN alive when considered
      for being killed by the group oom killer.
    
    Signed-off-by: Jay Kamat <jgkamat@fb.com>
    Acked-by: Roman Gushchin <guro@fb.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index 1ff6f9f1abdc..9ac8b7958f83 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -40,3 +40,4 @@ extern int get_temp_fd(void);
 extern int alloc_pagecache(int fd, size_t size);
 extern int alloc_anon(const char *cgroup, void *arg);
 extern int is_swap_enabled(void);
+extern int set_oom_adj_score(int pid, int score);

commit d863cb03fc5f913c98a9c5d7ecb66fb4a3b29bae
Author: Claudio <claudiozumbo@gmail.com>
Date:   Wed Jul 18 19:33:58 2018 +0200

    Add cgroup core selftests
    
    This commit adds tests for some of the core functionalities
    of cgroups v2.
    
    The commit adds tests for some core principles of croup V2 API:
    
    - test_cgcore_internal_process_constraint
    
      Tests internal process constraint.
      You can't add a pid to a domain parent if a controller is enabled.
    
    - test_cgcore_top_down_constraint_enable
    
       Tests that you can't enable a controller on a child if it's not enabled
       on the parent.
    
    - test_cgcore_top_down_constraint_disable
    
      Tests that you can't disable a controller on a parent if it's
      enabled in a child.
    
    - test_cgcore_no_internal_process_constraint_on_threads
    
      Tests that there's no internal process constrain on threaded cgroups.
      You can add threads/processes on a parent with a controller enabled.
    
    - test_cgcore_parent_becomes_threaded
    
      Tests that when a child becomes threaded the parent type becomes
      domain threaded.
    
    - test_cgcore_invalid_domain
    
      In a situation like:
    
      A (domain threaded) - B (threaded) - C (domain)
    
      it tests that C can't be used until it is turned into a threaded cgroup.
      The "cgroup.type" file will report "domain (invalid)" in these cases.
      Operations which fail due to invalid topology use EOPNOTSUPP as the errno.
    
    - test_cgcore_populated
    
      In a situation like:
    
      A(0) - B(0) - C(1)
             \ D(0)
    
      It tests that A, B and C's "populated" fields would be 1 while D's 0.
      It tests that after the one process in C is moved to root, A,B and C's
      "populated" fields would flip to "0" and file modified events will
      be generated on the "cgroup.events" files of both cgroups.
    
    Signed-off-by: Claudio Zumbo <claudioz@fb.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: Roman Gushchin <guro@fb.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: kernel-team@fb.com
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Roman Gushchin <guro@fb.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index fe82a297d4e0..1ff6f9f1abdc 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -32,6 +32,7 @@ extern int cg_write(const char *cgroup, const char *control, char *buf);
 extern int cg_run(const char *cgroup,
 		  int (*fn)(const char *cgroup, void *arg),
 		  void *arg);
+extern int cg_enter_current(const char *cgroup);
 extern int cg_run_nowait(const char *cgroup,
 			 int (*fn)(const char *cgroup, void *arg),
 			 void *arg);

commit 478b27844e9ee5660f4d4fa477e85514c51fc6d8
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue May 15 19:05:53 2018 +0300

    selftests: cgroup/memcontrol: add basic test for swap controls
    
    The new test verifies that memory.swap.max and memory.swap.current behave
    as expected for simple allocation scenarios
    
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Roman Gushchin <guro@fb.com>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
index 000de075d3d8..fe82a297d4e0 100644
--- a/tools/testing/selftests/cgroup/cgroup_util.h
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -38,3 +38,4 @@ extern int cg_run_nowait(const char *cgroup,
 extern int get_temp_fd(void);
 extern int alloc_pagecache(int fd, size_t size);
 extern int alloc_anon(const char *cgroup, void *arg);
+extern int is_swap_enabled(void);

commit 84092dbcf90176fcc258d74ad6ae8bb28d7df31a
Author: Roman Gushchin <guro@fb.com>
Date:   Fri May 11 19:03:49 2018 +0100

    selftests: cgroup: add memory controller self-tests
    
    Cgroups are used for controlling the physical resource distribution
    (memory, CPU, io, etc) and often are used as basic building blocks
    for large distributed computing systems. Even small differences
    in the actual behavior may lead to significant incidents.
    
    The codebase is under the active development, which will unlikely
    stop at any time soon. Also it's scattered over different kernel
    subsystems, which makes regressions more probable.
    
    Given that, the lack of any tests is crying.
    
    This patch implements some basic tests for the memory controller,
    as well as a minimal required framework. It doesn't pretend for a
    very good coverage, but pretends to be a starting point.
    
    Hopefully, any following significant changes will include corresponding
    tests.
    
    Tests for CPU and io controllers, as well as cgroup core
    are next in the todo list.
    
    Signed-off-by: Roman Gushchin <guro@fb.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: kernel-team@fb.com
    Cc: linux-kselftest@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/testing/selftests/cgroup/cgroup_util.h b/tools/testing/selftests/cgroup/cgroup_util.h
new file mode 100644
index 000000000000..000de075d3d8
--- /dev/null
+++ b/tools/testing/selftests/cgroup/cgroup_util.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <stdlib.h>
+
+#define PAGE_SIZE 4096
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+#define MB(x) (x << 20)
+
+/*
+ * Checks if two given values differ by less than err% of their sum.
+ */
+static inline int values_close(long a, long b, int err)
+{
+	return abs(a - b) <= (a + b) / 100 * err;
+}
+
+extern int cg_find_unified_root(char *root, size_t len);
+extern char *cg_name(const char *root, const char *name);
+extern char *cg_name_indexed(const char *root, const char *name, int index);
+extern int cg_create(const char *cgroup);
+extern int cg_destroy(const char *cgroup);
+extern int cg_read(const char *cgroup, const char *control,
+		   char *buf, size_t len);
+extern int cg_read_strcmp(const char *cgroup, const char *control,
+			  const char *expected);
+extern int cg_read_strstr(const char *cgroup, const char *control,
+			  const char *needle);
+extern long cg_read_long(const char *cgroup, const char *control);
+long cg_read_key_long(const char *cgroup, const char *control, const char *key);
+extern int cg_write(const char *cgroup, const char *control, char *buf);
+extern int cg_run(const char *cgroup,
+		  int (*fn)(const char *cgroup, void *arg),
+		  void *arg);
+extern int cg_run_nowait(const char *cgroup,
+			 int (*fn)(const char *cgroup, void *arg),
+			 void *arg);
+extern int get_temp_fd(void);
+extern int alloc_pagecache(int fd, size_t size);
+extern int alloc_anon(const char *cgroup, void *arg);
