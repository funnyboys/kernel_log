commit 566fc3f5d1c641b510ec487cf274a047f8a1e849
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Tue May 19 00:45:48 2020 +0200

    bpf, testing: Add get{peer, sock}name selftests to test_progs
    
    Extend the existing connect_force_port test to assert get{peer,sock}name programs
    as well. The workflow for e.g. IPv4 is as follows: i) server binds to concrete
    port, ii) client calls getsockname() on server fd which exposes 1.2.3.4:60000 to
    client, iii) client connects to service address 1.2.3.4:60000 binds to concrete
    local address (127.0.0.1:22222) and remaps service address to a concrete backend
    address (127.0.0.1:60123), iv) client then calls getsockname() on its own fd to
    verify local address (127.0.0.1:22222) and getpeername() on its own fd which then
    publishes service address (1.2.3.4:60000) instead of actual backend. Same workflow
    is done for IPv6 just with different address/port tuples.
    
      # ./test_progs -t connect_force_port
      #14 connect_force_port:OK
      Summary: 1/0 PASSED, 0 SKIPPED, 0 FAILED
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Link: https://lore.kernel.org/bpf/3343da6ad08df81af715a95d61a84fb4a960f2bf.1589841594.git.daniel@iogearbox.net

diff --git a/tools/testing/selftests/bpf/progs/connect_force_port4.c b/tools/testing/selftests/bpf/progs/connect_force_port4.c
index 1b8eb34b2db0..7396308677a3 100644
--- a/tools/testing/selftests/bpf/progs/connect_force_port4.c
+++ b/tools/testing/selftests/bpf/progs/connect_force_port4.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <string.h>
+#include <stdbool.h>
 
 #include <linux/bpf.h>
 #include <linux/in.h>
@@ -12,17 +13,71 @@
 char _license[] SEC("license") = "GPL";
 int _version SEC("version") = 1;
 
+struct svc_addr {
+	__be32 addr;
+	__be16 port;
+};
+
+struct {
+	__uint(type, BPF_MAP_TYPE_SK_STORAGE);
+	__uint(map_flags, BPF_F_NO_PREALLOC);
+	__type(key, int);
+	__type(value, struct svc_addr);
+} service_mapping SEC(".maps");
+
 SEC("cgroup/connect4")
-int _connect4(struct bpf_sock_addr *ctx)
+int connect4(struct bpf_sock_addr *ctx)
 {
 	struct sockaddr_in sa = {};
+	struct svc_addr *orig;
 
+	/* Force local address to 127.0.0.1:22222. */
 	sa.sin_family = AF_INET;
 	sa.sin_port = bpf_htons(22222);
-	sa.sin_addr.s_addr = bpf_htonl(0x7f000001); /* 127.0.0.1 */
+	sa.sin_addr.s_addr = bpf_htonl(0x7f000001);
 
 	if (bpf_bind(ctx, (struct sockaddr *)&sa, sizeof(sa)) != 0)
 		return 0;
 
+	/* Rewire service 1.2.3.4:60000 to backend 127.0.0.1:60123. */
+	if (ctx->user_port == bpf_htons(60000)) {
+		orig = bpf_sk_storage_get(&service_mapping, ctx->sk, 0,
+					  BPF_SK_STORAGE_GET_F_CREATE);
+		if (!orig)
+			return 0;
+
+		orig->addr = ctx->user_ip4;
+		orig->port = ctx->user_port;
+
+		ctx->user_ip4 = bpf_htonl(0x7f000001);
+		ctx->user_port = bpf_htons(60123);
+	}
+	return 1;
+}
+
+SEC("cgroup/getsockname4")
+int getsockname4(struct bpf_sock_addr *ctx)
+{
+	/* Expose local server as 1.2.3.4:60000 to client. */
+	if (ctx->user_port == bpf_htons(60123)) {
+		ctx->user_ip4 = bpf_htonl(0x01020304);
+		ctx->user_port = bpf_htons(60000);
+	}
+	return 1;
+}
+
+SEC("cgroup/getpeername4")
+int getpeername4(struct bpf_sock_addr *ctx)
+{
+	struct svc_addr *orig;
+
+	/* Expose service 1.2.3.4:60000 as peer instead of backend. */
+	if (ctx->user_port == bpf_htons(60123)) {
+		orig = bpf_sk_storage_get(&service_mapping, ctx->sk, 0, 0);
+		if (orig) {
+			ctx->user_ip4 = orig->addr;
+			ctx->user_port = orig->port;
+		}
+	}
 	return 1;
 }

commit 8086fbaf49345f988deec539ec8e182b02914401
Author: Stanislav Fomichev <sdf@google.com>
Date:   Fri May 8 10:46:11 2020 -0700

    bpf: Allow any port in bpf_bind helper
    
    We want to have a tighter control on what ports we bind to in
    the BPF_CGROUP_INET{4,6}_CONNECT hooks even if it means
    connect() becomes slightly more expensive. The expensive part
    comes from the fact that we now need to call inet_csk_get_port()
    that verifies that the port is not used and allocates an entry
    in the hash table for it.
    
    Since we can't rely on "snum || !bind_address_no_port" to prevent
    us from calling POST_BIND hook anymore, let's add another bind flag
    to indicate that the call site is BPF program.
    
    v5:
    * fix wrong AF_INET (should be AF_INET6) in the bpf program for v6
    
    v3:
    * More bpf_bind documentation refinements (Martin KaFai Lau)
    * Add UDP tests as well (Martin KaFai Lau)
    * Don't start the thread, just do socket+bind+listen (Martin KaFai Lau)
    
    v2:
    * Update documentation (Andrey Ignatov)
    * Pass BIND_FORCE_ADDRESS_NO_PORT conditionally (Andrey Ignatov)
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20200508174611.228805-5-sdf@google.com

diff --git a/tools/testing/selftests/bpf/progs/connect_force_port4.c b/tools/testing/selftests/bpf/progs/connect_force_port4.c
new file mode 100644
index 000000000000..1b8eb34b2db0
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/connect_force_port4.c
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <string.h>
+
+#include <linux/bpf.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <sys/socket.h>
+
+#include <bpf/bpf_helpers.h>
+#include <bpf/bpf_endian.h>
+
+char _license[] SEC("license") = "GPL";
+int _version SEC("version") = 1;
+
+SEC("cgroup/connect4")
+int _connect4(struct bpf_sock_addr *ctx)
+{
+	struct sockaddr_in sa = {};
+
+	sa.sin_family = AF_INET;
+	sa.sin_port = bpf_htons(22222);
+	sa.sin_addr.s_addr = bpf_htonl(0x7f000001); /* 127.0.0.1 */
+
+	if (bpf_bind(ctx, (struct sockaddr *)&sa, sizeof(sa)) != 0)
+		return 0;
+
+	return 1;
+}
