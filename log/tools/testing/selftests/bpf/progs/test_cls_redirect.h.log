commit 234589012ba0e5bf448e3fdbbac0f4c265dbdd7b
Author: Lorenz Bauer <lmb@cloudflare.com>
Date:   Fri Apr 24 19:55:55 2020 +0100

    selftests/bpf: Add cls_redirect classifier
    
    cls_redirect is a TC clsact based replacement for the glb-redirect iptables
    module available at [1]. It enables what GitHub calls "second chance"
    flows [2], similarly proposed by the Beamer paper [3]. In contrast to
    glb-redirect, it also supports migrating UDP flows as long as connected
    sockets are used. cls_redirect is in production at Cloudflare, as part of
    our own L4 load balancer.
    
    We have modified the encapsulation format slightly from glb-redirect:
    glbgue_chained_routing.private_data_type has been repurposed to form a
    version field and several flags. Both have been arranged in a way that
    a private_data_type value of zero matches the current glb-redirect
    behaviour. This means that cls_redirect will understand packets in
    glb-redirect format, but not vice versa.
    
    The test suite only covers basic features. For example, cls_redirect will
    correctly forward path MTU discovery packets, but this is not exercised.
    It is also possible to switch the encapsulation format to GRE on the last
    hop, which is also not tested.
    
    There are two major distinctions from glb-redirect: first, cls_redirect
    relies on receiving encapsulated packets directly from a router. This is
    because we don't have access to the neighbour tables from BPF, yet. See
    forward_to_next_hop for details. Second, cls_redirect performs decapsulation
    instead of using separate ipip and sit tunnel devices. This
    avoids issues with the sit tunnel [4] and makes deploying the classifier
    easier: decapsulated packets appear on the same interface, so existing
    firewall rules continue to work as expected.
    
    The code base started it's life on v4.19, so there are most likely still
    hold overs from old workarounds. In no particular order:
    
    - The function buf_off is required to defeat a clang optimization
      that leads to the verifier rejecting the program due to pointer
      arithmetic in the wrong order.
    
    - The function pkt_parse_ipv6 is force inlined, because it would
      otherwise be rejected due to returning a pointer to stack memory.
    
    - The functions fill_tuple and classify_tcp contain kludges, because
      we've run out of function arguments.
    
    - The logic in general is rather nested, due to verifier restrictions.
      I think this is either because the verifier loses track of constants
      on the stack, or because it can't track enum like variables.
    
    1: https://github.com/github/glb-director/tree/master/src/glb-redirect
    2: https://github.com/github/glb-director/blob/master/docs/development/second-chance-design.md
    3: https://www.usenix.org/conference/nsdi18/presentation/olteanu
    4: https://github.com/github/glb-director/issues/64
    
    Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20200424185556.7358-2-lmb@cloudflare.com

diff --git a/tools/testing/selftests/bpf/progs/test_cls_redirect.h b/tools/testing/selftests/bpf/progs/test_cls_redirect.h
new file mode 100644
index 000000000000..76eab0aacba0
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/test_cls_redirect.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright 2019, 2020 Cloudflare */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <linux/if_ether.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/udp.h>
+
+struct gre_base_hdr {
+	uint16_t flags;
+	uint16_t protocol;
+} __attribute__((packed));
+
+struct guehdr {
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	uint8_t hlen : 5, control : 1, variant : 2;
+#else
+	uint8_t variant : 2, control : 1, hlen : 5;
+#endif
+	uint8_t proto_ctype;
+	uint16_t flags;
+};
+
+struct unigue {
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	uint8_t _r : 2, last_hop_gre : 1, forward_syn : 1, version : 4;
+#else
+	uint8_t version : 4, forward_syn : 1, last_hop_gre : 1, _r : 2;
+#endif
+	uint8_t reserved;
+	uint8_t next_hop;
+	uint8_t hop_count;
+	// Next hops go here
+} __attribute__((packed));
+
+typedef struct {
+	struct ethhdr eth;
+	struct iphdr ip;
+	struct gre_base_hdr gre;
+} __attribute__((packed)) encap_gre_t;
+
+typedef struct {
+	struct ethhdr eth;
+	struct iphdr ip;
+	struct udphdr udp;
+	struct guehdr gue;
+	struct unigue unigue;
+} __attribute__((packed)) encap_headers_t;
