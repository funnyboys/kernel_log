commit 3e689141e64df91b009a289c0559adedfe62f511
Author: Toke Høiland-Jørgensen <toke@redhat.com>
Date:   Mon Jan 20 14:06:45 2020 +0100

    selftests: Use consistent include paths for libbpf
    
    Fix all selftests to include libbpf header files with the bpf/ prefix, to
    be consistent with external users of the library. Also ensure that all
    includes of exported libbpf header files (those that are exported on 'make
    install' of the library) use bracketed includes instead of quoted.
    
    To not break the build, keep the old include path until everything has been
    changed to the new one; a subsequent patch will remove that.
    
    Fixes: 6910d7d3867a ("selftests/bpf: Ensure bpf_helper_defs.h are taken from selftests dir")
    Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Andrii Nakryiko <andriin@fb.com>
    Link: https://lore.kernel.org/bpf/157952560568.1683545.9649335788846513446.stgit@toke.dk

diff --git a/tools/testing/selftests/bpf/progs/xdping_kern.c b/tools/testing/selftests/bpf/progs/xdping_kern.c
index 112a2857f4e2..6b9ca40bd1f4 100644
--- a/tools/testing/selftests/bpf/progs/xdping_kern.c
+++ b/tools/testing/selftests/bpf/progs/xdping_kern.c
@@ -12,8 +12,8 @@
 #include <linux/if_vlan.h>
 #include <linux/ip.h>
 
-#include "bpf_helpers.h"
-#include "bpf_endian.h"
+#include <bpf/bpf_helpers.h>
+#include <bpf/bpf_endian.h>
 
 #include "xdping.h"
 

commit 1639b17c72fa7ad977ccd0ad6c673e3f7048723b
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Jul 5 08:50:12 2019 -0700

    selftests/bpf: convert legacy BPF maps to BTF-defined ones
    
    Convert selftests that were originally left out and new ones added
    recently to consistently use BTF-defined maps.
    
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/testing/selftests/bpf/progs/xdping_kern.c b/tools/testing/selftests/bpf/progs/xdping_kern.c
index 87393e7c667c..112a2857f4e2 100644
--- a/tools/testing/selftests/bpf/progs/xdping_kern.c
+++ b/tools/testing/selftests/bpf/progs/xdping_kern.c
@@ -17,12 +17,12 @@
 
 #include "xdping.h"
 
-struct bpf_map_def SEC("maps") ping_map = {
-	.type = BPF_MAP_TYPE_HASH,
-	.key_size = sizeof(__u32),
-	.value_size = sizeof(struct pinginfo),
-	.max_entries = 256,
-};
+struct {
+	__uint(type, BPF_MAP_TYPE_HASH);
+	__uint(max_entries, 256);
+	__type(key, __u32);
+	__type(value, struct pinginfo);
+} ping_map SEC(".maps");
 
 static __always_inline void swap_src_dst_mac(void *data)
 {

commit cd5385029f1d2e6879b78fff1a7b15514004af17
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Fri May 31 18:47:14 2019 +0100

    selftests/bpf: measure RTT from xdp using xdping
    
    xdping allows us to get latency estimates from XDP.  Output looks
    like this:
    
    ./xdping -I eth4 192.168.55.8
    Setting up XDP for eth4, please wait...
    XDP setup disrupts network connectivity, hit Ctrl+C to quit
    
    Normal ping RTT data
    [Ignore final RTT; it is distorted by XDP using the reply]
    PING 192.168.55.8 (192.168.55.8) from 192.168.55.7 eth4: 56(84) bytes of data.
    64 bytes from 192.168.55.8: icmp_seq=1 ttl=64 time=0.302 ms
    64 bytes from 192.168.55.8: icmp_seq=2 ttl=64 time=0.208 ms
    64 bytes from 192.168.55.8: icmp_seq=3 ttl=64 time=0.163 ms
    64 bytes from 192.168.55.8: icmp_seq=8 ttl=64 time=0.275 ms
    
    4 packets transmitted, 4 received, 0% packet loss, time 3079ms
    rtt min/avg/max/mdev = 0.163/0.237/0.302/0.054 ms
    
    XDP RTT data:
    64 bytes from 192.168.55.8: icmp_seq=5 ttl=64 time=0.02808 ms
    64 bytes from 192.168.55.8: icmp_seq=6 ttl=64 time=0.02804 ms
    64 bytes from 192.168.55.8: icmp_seq=7 ttl=64 time=0.02815 ms
    64 bytes from 192.168.55.8: icmp_seq=8 ttl=64 time=0.02805 ms
    
    The xdping program loads the associated xdping_kern.o BPF program
    and attaches it to the specified interface.  If run in client
    mode (the default), it will add a map entry keyed by the
    target IP address; this map will store RTT measurements, current
    sequence number etc.  Finally in client mode the ping command
    is executed, and the xdping BPF program will use the last ICMP
    reply, reformulate it as an ICMP request with the next sequence
    number and XDP_TX it.  After the reply to that request is received
    we can measure RTT and repeat until the desired number of
    measurements is made.  This is why the sequence numbers in the
    normal ping are 1, 2, 3 and 8.  We XDP_TX a modified version
    of ICMP reply 4 and keep doing this until we get the 4 replies
    we need; hence the networking stack only sees reply 8, where
    we have XDP_PASSed it upstream since we are done.
    
    In server mode (-s), xdping simply takes ICMP requests and replies
    to them in XDP rather than passing the request up to the networking
    stack.  No map entry is required.
    
    xdping can be run in native XDP mode (the default, or specified
    via -N) or in skb mode (-S).
    
    A test program test_xdping.sh exercises some of these options.
    
    Note that native XDP does not seem to XDP_TX for veths, hence -N
    is not tested.  Looking at the code, it looks like XDP_TX is
    supported so I'm not sure if that's expected.  Running xdping in
    native mode for ixgbe as both client and server works fine.
    
    Changes since v4
    
    - close fds on cleanup (Song Liu)
    
    Changes since v3
    
    - fixed seq to be __be16 (Song Liu)
    - fixed fd checks in xdping.c (Song Liu)
    
    Changes since v2
    
    - updated commit message to explain why seq number of last
      ICMP reply is 8 not 4 (Song Liu)
    - updated types of seq number, raddr and eliminated csum variable
      in xdpclient/xdpserver functions as it was not needed (Song Liu)
    - added XDPING_DEFAULT_COUNT definition and usage specification of
      default/max counts (Song Liu)
    
    Changes since v1
     - moved from RFC to PATCH
     - removed unused variable in ipv4_csum() (Song Liu)
     - refactored ICMP checks into icmp_check() function called by client
       and server programs and reworked client and server programs due
       to lack of shared code (Song Liu)
     - added checks to ensure that SKB and native mode are not requested
       together (Song Liu)
    
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Acked-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/testing/selftests/bpf/progs/xdping_kern.c b/tools/testing/selftests/bpf/progs/xdping_kern.c
new file mode 100644
index 000000000000..87393e7c667c
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/xdping_kern.c
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved. */
+
+#define KBUILD_MODNAME "foo"
+#include <stddef.h>
+#include <string.h>
+#include <linux/bpf.h>
+#include <linux/icmp.h>
+#include <linux/in.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+
+#include "bpf_helpers.h"
+#include "bpf_endian.h"
+
+#include "xdping.h"
+
+struct bpf_map_def SEC("maps") ping_map = {
+	.type = BPF_MAP_TYPE_HASH,
+	.key_size = sizeof(__u32),
+	.value_size = sizeof(struct pinginfo),
+	.max_entries = 256,
+};
+
+static __always_inline void swap_src_dst_mac(void *data)
+{
+	unsigned short *p = data;
+	unsigned short dst[3];
+
+	dst[0] = p[0];
+	dst[1] = p[1];
+	dst[2] = p[2];
+	p[0] = p[3];
+	p[1] = p[4];
+	p[2] = p[5];
+	p[3] = dst[0];
+	p[4] = dst[1];
+	p[5] = dst[2];
+}
+
+static __always_inline __u16 csum_fold_helper(__wsum sum)
+{
+	sum = (sum & 0xffff) + (sum >> 16);
+	return ~((sum & 0xffff) + (sum >> 16));
+}
+
+static __always_inline __u16 ipv4_csum(void *data_start, int data_size)
+{
+	__wsum sum;
+
+	sum = bpf_csum_diff(0, 0, data_start, data_size, 0);
+	return csum_fold_helper(sum);
+}
+
+#define ICMP_ECHO_LEN		64
+
+static __always_inline int icmp_check(struct xdp_md *ctx, int type)
+{
+	void *data_end = (void *)(long)ctx->data_end;
+	void *data = (void *)(long)ctx->data;
+	struct ethhdr *eth = data;
+	struct icmphdr *icmph;
+	struct iphdr *iph;
+
+	if (data + sizeof(*eth) + sizeof(*iph) + ICMP_ECHO_LEN > data_end)
+		return XDP_PASS;
+
+	if (eth->h_proto != bpf_htons(ETH_P_IP))
+		return XDP_PASS;
+
+	iph = data + sizeof(*eth);
+
+	if (iph->protocol != IPPROTO_ICMP)
+		return XDP_PASS;
+
+	if (bpf_ntohs(iph->tot_len) - sizeof(*iph) != ICMP_ECHO_LEN)
+		return XDP_PASS;
+
+	icmph = data + sizeof(*eth) + sizeof(*iph);
+
+	if (icmph->type != type)
+		return XDP_PASS;
+
+	return XDP_TX;
+}
+
+SEC("xdpclient")
+int xdping_client(struct xdp_md *ctx)
+{
+	void *data_end = (void *)(long)ctx->data_end;
+	void *data = (void *)(long)ctx->data;
+	struct pinginfo *pinginfo = NULL;
+	struct ethhdr *eth = data;
+	struct icmphdr *icmph;
+	struct iphdr *iph;
+	__u64 recvtime;
+	__be32 raddr;
+	__be16 seq;
+	int ret;
+	__u8 i;
+
+	ret = icmp_check(ctx, ICMP_ECHOREPLY);
+
+	if (ret != XDP_TX)
+		return ret;
+
+	iph = data + sizeof(*eth);
+	icmph = data + sizeof(*eth) + sizeof(*iph);
+	raddr = iph->saddr;
+
+	/* Record time reply received. */
+	recvtime = bpf_ktime_get_ns();
+	pinginfo = bpf_map_lookup_elem(&ping_map, &raddr);
+	if (!pinginfo || pinginfo->seq != icmph->un.echo.sequence)
+		return XDP_PASS;
+
+	if (pinginfo->start) {
+#pragma clang loop unroll(full)
+		for (i = 0; i < XDPING_MAX_COUNT; i++) {
+			if (pinginfo->times[i] == 0)
+				break;
+		}
+		/* verifier is fussy here... */
+		if (i < XDPING_MAX_COUNT) {
+			pinginfo->times[i] = recvtime -
+					     pinginfo->start;
+			pinginfo->start = 0;
+			i++;
+		}
+		/* No more space for values? */
+		if (i == pinginfo->count || i == XDPING_MAX_COUNT)
+			return XDP_PASS;
+	}
+
+	/* Now convert reply back into echo request. */
+	swap_src_dst_mac(data);
+	iph->saddr = iph->daddr;
+	iph->daddr = raddr;
+	icmph->type = ICMP_ECHO;
+	seq = bpf_htons(bpf_ntohs(icmph->un.echo.sequence) + 1);
+	icmph->un.echo.sequence = seq;
+	icmph->checksum = 0;
+	icmph->checksum = ipv4_csum(icmph, ICMP_ECHO_LEN);
+
+	pinginfo->seq = seq;
+	pinginfo->start = bpf_ktime_get_ns();
+
+	return XDP_TX;
+}
+
+SEC("xdpserver")
+int xdping_server(struct xdp_md *ctx)
+{
+	void *data_end = (void *)(long)ctx->data_end;
+	void *data = (void *)(long)ctx->data;
+	struct ethhdr *eth = data;
+	struct icmphdr *icmph;
+	struct iphdr *iph;
+	__be32 raddr;
+	int ret;
+
+	ret = icmp_check(ctx, ICMP_ECHO);
+
+	if (ret != XDP_TX)
+		return ret;
+
+	iph = data + sizeof(*eth);
+	icmph = data + sizeof(*eth) + sizeof(*iph);
+	raddr = iph->saddr;
+
+	/* Now convert request into echo reply. */
+	swap_src_dst_mac(data);
+	iph->saddr = iph->daddr;
+	iph->daddr = raddr;
+	icmph->type = ICMP_ECHOREPLY;
+	icmph->checksum = 0;
+	icmph->checksum = ipv4_csum(icmph, ICMP_ECHO_LEN);
+
+	return XDP_TX;
+}
+
+char _license[] SEC("license") = "GPL";
