commit c97099b0f22722be7d0f290278a26d297cc4b7ca
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri May 29 00:54:23 2020 -0700

    bpf: Add BPF ringbuf and perf buffer benchmarks
    
    Extend bench framework with ability to have benchmark-provided child argument
    parser for custom benchmark-specific parameters. This makes bench generic code
    modular and independent from any specific benchmark.
    
    Also implement a set of benchmarks for new BPF ring buffer and existing perf
    buffer. 4 benchmarks were implemented: 2 variations for each of BPF ringbuf
    and perfbuf:,
      - rb-libbpf utilizes stock libbpf ring_buffer manager for reading data;
      - rb-custom implements custom ring buffer setup and reading code, to
        eliminate overheads inherent in generic libbpf code due to callback
        functions and the need to update consumer position after each consumed
        record, instead of batching updates (due to pessimistic assumption that
        user callback might take long time and thus could unnecessarily hold ring
        buffer space for too long);
      - pb-libbpf uses stock libbpf perf_buffer code with all the default
        settings, though uses higher-performance raw event callback to minimize
        unnecessary overhead;
      - pb-custom implements its own custom consumer code to minimize any possible
        overhead of generic libbpf implementation and indirect function calls.
    
    All of the test support default, no data notification skipped, mode, as well
    as sampled mode (with --rb-sampled flag), which allows to trigger epoll
    notification less frequently and reduce overhead. As will be shown, this mode
    is especially critical for perf buffer, which suffers from high overhead of
    wakeups in kernel.
    
    Otherwise, all benchamrks implement similar way to generate a batch of records
    by using fentry/sys_getpgid BPF program, which pushes a bunch of records in
    a tight loop and records number of successful and dropped samples. Each record
    is a small 8-byte integer, to minimize the effect of memory copying with
    bpf_perf_event_output() and bpf_ringbuf_output().
    
    Benchmarks that have only one producer implement optional back-to-back mode,
    in which record production and consumption is alternating on the same CPU.
    This is the highest-throughput happy case, showing ultimate performance
    achievable with either BPF ringbuf or perfbuf.
    
    All the below scenarios are implemented in a script in
    benchs/run_bench_ringbufs.sh. Tests were performed on 28-core/56-thread
    Intel Xeon CPU E5-2680 v4 @ 2.40GHz CPU.
    
    Single-producer, parallel producer
    ==================================
    rb-libbpf            12.054 ± 0.320M/s (drops 0.000 ± 0.000M/s)
    rb-custom            8.158 ± 0.118M/s (drops 0.001 ± 0.003M/s)
    pb-libbpf            0.931 ± 0.007M/s (drops 0.000 ± 0.000M/s)
    pb-custom            0.965 ± 0.003M/s (drops 0.000 ± 0.000M/s)
    
    Single-producer, parallel producer, sampled notification
    ========================================================
    rb-libbpf            11.563 ± 0.067M/s (drops 0.000 ± 0.000M/s)
    rb-custom            15.895 ± 0.076M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf            9.889 ± 0.032M/s (drops 0.000 ± 0.000M/s)
    pb-custom            9.866 ± 0.028M/s (drops 0.000 ± 0.000M/s)
    
    Single producer on one CPU, consumer on another one, both running at full
    speed. Curiously, rb-libbpf has higher throughput than objectively faster (due
    to more lightweight consumer code path) rb-custom. It appears that faster
    consumer causes kernel to send notifications more frequently, because consumer
    appears to be caught up more frequently. Performance of perfbuf suffers from
    default "no sampling" policy and huge overhead that causes.
    
    In sampled mode, rb-custom is winning very significantly eliminating too
    frequent in-kernel wakeups, the gain appears to be more than 2x.
    
    Perf buffer achieves even more impressive wins, compared to stock perfbuf
    settings, with 10x improvements in throughput with 1:500 sampling rate. The
    trade-off is that with sampling, application might not get next X events until
    X+1st arrives, which is not always acceptable. With steady influx of events,
    though, this shouldn't be a problem.
    
    Overall, single-producer performance of ring buffers seems to be better no
    matter the sampled/non-sampled modes, but it especially beats ring buffer
    without sampling due to its adaptive notification approach.
    
    Single-producer, back-to-back mode
    ==================================
    rb-libbpf            15.507 ± 0.247M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf-sampled    14.692 ± 0.195M/s (drops 0.000 ± 0.000M/s)
    rb-custom            21.449 ± 0.157M/s (drops 0.000 ± 0.000M/s)
    rb-custom-sampled    20.024 ± 0.386M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf            1.601 ± 0.015M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf-sampled    8.545 ± 0.064M/s (drops 0.000 ± 0.000M/s)
    pb-custom            1.607 ± 0.022M/s (drops 0.000 ± 0.000M/s)
    pb-custom-sampled    8.988 ± 0.144M/s (drops 0.000 ± 0.000M/s)
    
    Here we test a back-to-back mode, which is arguably best-case scenario both
    for BPF ringbuf and perfbuf, because there is no contention and for ringbuf
    also no excessive notification, because consumer appears to be behind after
    the first record. For ringbuf, custom consumer code clearly wins with 21.5 vs
    16 million records per second exchanged between producer and consumer. Sampled
    mode actually hurts a bit due to slightly slower producer logic (it needs to
    fetch amount of data available to decide whether to skip or force notification).
    
    Perfbuf with wakeup sampling gets 5.5x throughput increase, compared to
    no-sampling version. There also doesn't seem to be noticeable overhead from
    generic libbpf handling code.
    
    Perfbuf back-to-back, effect of sample rate
    ===========================================
    pb-sampled-1         1.035 ± 0.012M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-5         3.476 ± 0.087M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-10        5.094 ± 0.136M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-25        7.118 ± 0.153M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-50        8.169 ± 0.156M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-100       8.887 ± 0.136M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-250       9.180 ± 0.209M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-500       9.353 ± 0.281M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-1000      9.411 ± 0.217M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-2000      9.464 ± 0.167M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-3000      9.575 ± 0.273M/s (drops 0.000 ± 0.000M/s)
    
    This benchmark shows the effect of event sampling for perfbuf. Back-to-back
    mode for highest throughput. Just doing every 5th record notification gives
    3.5x speed up. 250-500 appears to be the point of diminishing return, with
    almost 9x speed up. Most benchmarks use 500 as the default sampling for pb-raw
    and pb-custom.
    
    Ringbuf back-to-back, effect of sample rate
    ===========================================
    rb-sampled-1         1.106 ± 0.010M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-5         4.746 ± 0.149M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-10        7.706 ± 0.164M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-25        12.893 ± 0.273M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-50        15.961 ± 0.361M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-100       18.203 ± 0.445M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-250       19.962 ± 0.786M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-500       20.881 ± 0.551M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-1000      21.317 ± 0.532M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-2000      21.331 ± 0.535M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-3000      21.688 ± 0.392M/s (drops 0.000 ± 0.000M/s)
    
    Similar benchmark for ring buffer also shows a great advantage (in terms of
    throughput) of skipping notifications. Skipping every 5th one gives 4x boost.
    Also similar to perfbuf case, 250-500 seems to be the point of diminishing
    returns, giving roughly 20x better results.
    
    Keep in mind, for this test, notifications are controlled manually with
    BPF_RB_NO_WAKEUP and BPF_RB_FORCE_WAKEUP. As can be seen from previous
    benchmarks, adaptive notifications based on consumer's positions provides same
    (or even slightly better due to simpler load generator on BPF side) benefits in
    favorable back-to-back scenario. Over zealous and fast consumer, which is
    almost always caught up, will make thoughput numbers smaller. That's the case
    when manual notification control might prove to be extremely beneficial.
    
    Ringbuf back-to-back, reserve+commit vs output
    ==============================================
    reserve              22.819 ± 0.503M/s (drops 0.000 ± 0.000M/s)
    output               18.906 ± 0.433M/s (drops 0.000 ± 0.000M/s)
    
    Ringbuf sampled, reserve+commit vs output
    =========================================
    reserve-sampled      15.350 ± 0.132M/s (drops 0.000 ± 0.000M/s)
    output-sampled       14.195 ± 0.144M/s (drops 0.000 ± 0.000M/s)
    
    BPF ringbuf supports two sets of APIs with various usability and performance
    tradeoffs: bpf_ringbuf_reserve()+bpf_ringbuf_commit() vs bpf_ringbuf_output().
    This benchmark clearly shows superiority of reserve+commit approach, despite
    using a small 8-byte record size.
    
    Single-producer, consumer/producer competing on the same CPU, low batch count
    =============================================================================
    rb-libbpf            3.045 ± 0.020M/s (drops 3.536 ± 0.148M/s)
    rb-custom            3.055 ± 0.022M/s (drops 3.893 ± 0.066M/s)
    pb-libbpf            1.393 ± 0.024M/s (drops 0.000 ± 0.000M/s)
    pb-custom            1.407 ± 0.016M/s (drops 0.000 ± 0.000M/s)
    
    This benchmark shows one of the worst-case scenarios, in which producer and
    consumer do not coordinate *and* fight for the same CPU. No batch count and
    sampling settings were able to eliminate drops for ringbuffer, producer is
    just too fast for consumer to keep up. But ringbuf and perfbuf still able to
    pass through quite a lot of messages, which is more than enough for a lot of
    applications.
    
    Ringbuf, multi-producer contention
    ==================================
    rb-libbpf nr_prod 1  10.916 ± 0.399M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 2  4.931 ± 0.030M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 3  4.880 ± 0.006M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 4  3.926 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 8  4.011 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 12 3.967 ± 0.016M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 16 2.604 ± 0.030M/s (drops 0.001 ± 0.002M/s)
    rb-libbpf nr_prod 20 2.233 ± 0.003M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 24 2.085 ± 0.015M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 28 2.055 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 32 1.962 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 36 2.089 ± 0.005M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 40 2.118 ± 0.006M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 44 2.105 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 48 2.120 ± 0.058M/s (drops 0.000 ± 0.001M/s)
    rb-libbpf nr_prod 52 2.074 ± 0.024M/s (drops 0.007 ± 0.014M/s)
    
    Ringbuf uses a very short-duration spinlock during reservation phase, to check
    few invariants, increment producer count and set record header. This is the
    biggest point of contention for ringbuf implementation. This benchmark
    evaluates the effect of multiple competing writers on overall throughput of
    a single shared ringbuffer.
    
    Overall throughput drops almost 2x when going from single to two
    highly-contended producers, gradually dropping with additional competing
    producers.  Performance drop stabilizes at around 20 producers and hovers
    around 2mln even with 50+ fighting producers, which is a 5x drop compared to
    non-contended case. Good kernel implementation in kernel helps maintain decent
    performance here.
    
    Note, that in the intended real-world scenarios, it's not expected to get even
    close to such a high levels of contention. But if contention will become
    a problem, there is always an option of sharding few ring buffers across a set
    of CPUs.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20200529075424.3139988-5-andriin@fb.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/testing/selftests/bpf/benchs/bench_ringbufs.c b/tools/testing/selftests/bpf/benchs/bench_ringbufs.c
new file mode 100644
index 000000000000..da87c7f31891
--- /dev/null
+++ b/tools/testing/selftests/bpf/benchs/bench_ringbufs.c
@@ -0,0 +1,566 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 Facebook */
+#include <asm/barrier.h>
+#include <linux/perf_event.h>
+#include <linux/ring_buffer.h>
+#include <sys/epoll.h>
+#include <sys/mman.h>
+#include <argp.h>
+#include <stdlib.h>
+#include "bench.h"
+#include "ringbuf_bench.skel.h"
+#include "perfbuf_bench.skel.h"
+
+static struct {
+	bool back2back;
+	int batch_cnt;
+	bool sampled;
+	int sample_rate;
+	int ringbuf_sz; /* per-ringbuf, in bytes */
+	bool ringbuf_use_output; /* use slower output API */
+	int perfbuf_sz; /* per-CPU size, in pages */
+} args = {
+	.back2back = false,
+	.batch_cnt = 500,
+	.sampled = false,
+	.sample_rate = 500,
+	.ringbuf_sz = 512 * 1024,
+	.ringbuf_use_output = false,
+	.perfbuf_sz = 128,
+};
+
+enum {
+	ARG_RB_BACK2BACK = 2000,
+	ARG_RB_USE_OUTPUT = 2001,
+	ARG_RB_BATCH_CNT = 2002,
+	ARG_RB_SAMPLED = 2003,
+	ARG_RB_SAMPLE_RATE = 2004,
+};
+
+static const struct argp_option opts[] = {
+	{ "rb-b2b", ARG_RB_BACK2BACK, NULL, 0, "Back-to-back mode"},
+	{ "rb-use-output", ARG_RB_USE_OUTPUT, NULL, 0, "Use bpf_ringbuf_output() instead of bpf_ringbuf_reserve()"},
+	{ "rb-batch-cnt", ARG_RB_BATCH_CNT, "CNT", 0, "Set BPF-side record batch count"},
+	{ "rb-sampled", ARG_RB_SAMPLED, NULL, 0, "Notification sampling"},
+	{ "rb-sample-rate", ARG_RB_SAMPLE_RATE, "RATE", 0, "Notification sample rate"},
+	{},
+};
+
+static error_t parse_arg(int key, char *arg, struct argp_state *state)
+{
+	switch (key) {
+	case ARG_RB_BACK2BACK:
+		args.back2back = true;
+		break;
+	case ARG_RB_USE_OUTPUT:
+		args.ringbuf_use_output = true;
+		break;
+	case ARG_RB_BATCH_CNT:
+		args.batch_cnt = strtol(arg, NULL, 10);
+		if (args.batch_cnt < 0) {
+			fprintf(stderr, "Invalid batch count.");
+			argp_usage(state);
+		}
+		break;
+	case ARG_RB_SAMPLED:
+		args.sampled = true;
+		break;
+	case ARG_RB_SAMPLE_RATE:
+		args.sample_rate = strtol(arg, NULL, 10);
+		if (args.sample_rate < 0) {
+			fprintf(stderr, "Invalid perfbuf sample rate.");
+			argp_usage(state);
+		}
+		break;
+	default:
+		return ARGP_ERR_UNKNOWN;
+	}
+	return 0;
+}
+
+/* exported into benchmark runner */
+const struct argp bench_ringbufs_argp = {
+	.options = opts,
+	.parser = parse_arg,
+};
+
+/* RINGBUF-LIBBPF benchmark */
+
+static struct counter buf_hits;
+
+static inline void bufs_trigger_batch()
+{
+	(void)syscall(__NR_getpgid);
+}
+
+static void bufs_validate()
+{
+	if (env.consumer_cnt != 1) {
+		fprintf(stderr, "rb-libbpf benchmark doesn't support multi-consumer!\n");
+		exit(1);
+	}
+
+	if (args.back2back && env.producer_cnt > 1) {
+		fprintf(stderr, "back-to-back mode makes sense only for single-producer case!\n");
+		exit(1);
+	}
+}
+
+static void *bufs_sample_producer(void *input)
+{
+	if (args.back2back) {
+		/* initial batch to get everything started */
+		bufs_trigger_batch();
+		return NULL;
+	}
+
+	while (true)
+		bufs_trigger_batch();
+	return NULL;
+}
+
+static struct ringbuf_libbpf_ctx {
+	struct ringbuf_bench *skel;
+	struct ring_buffer *ringbuf;
+} ringbuf_libbpf_ctx;
+
+static void ringbuf_libbpf_measure(struct bench_res *res)
+{
+	struct ringbuf_libbpf_ctx *ctx = &ringbuf_libbpf_ctx;
+
+	res->hits = atomic_swap(&buf_hits.value, 0);
+	res->drops = atomic_swap(&ctx->skel->bss->dropped, 0);
+}
+
+static struct ringbuf_bench *ringbuf_setup_skeleton()
+{
+	struct ringbuf_bench *skel;
+
+	setup_libbpf();
+
+	skel = ringbuf_bench__open();
+	if (!skel) {
+		fprintf(stderr, "failed to open skeleton\n");
+		exit(1);
+	}
+
+	skel->rodata->batch_cnt = args.batch_cnt;
+	skel->rodata->use_output = args.ringbuf_use_output ? 1 : 0;
+
+	if (args.sampled)
+		/* record data + header take 16 bytes */
+		skel->rodata->wakeup_data_size = args.sample_rate * 16;
+
+	bpf_map__resize(skel->maps.ringbuf, args.ringbuf_sz);
+
+	if (ringbuf_bench__load(skel)) {
+		fprintf(stderr, "failed to load skeleton\n");
+		exit(1);
+	}
+
+	return skel;
+}
+
+static int buf_process_sample(void *ctx, void *data, size_t len)
+{
+	atomic_inc(&buf_hits.value);
+	return 0;
+}
+
+static void ringbuf_libbpf_setup()
+{
+	struct ringbuf_libbpf_ctx *ctx = &ringbuf_libbpf_ctx;
+	struct bpf_link *link;
+
+	ctx->skel = ringbuf_setup_skeleton();
+	ctx->ringbuf = ring_buffer__new(bpf_map__fd(ctx->skel->maps.ringbuf),
+					buf_process_sample, NULL, NULL);
+	if (!ctx->ringbuf) {
+		fprintf(stderr, "failed to create ringbuf\n");
+		exit(1);
+	}
+
+	link = bpf_program__attach(ctx->skel->progs.bench_ringbuf);
+	if (IS_ERR(link)) {
+		fprintf(stderr, "failed to attach program!\n");
+		exit(1);
+	}
+}
+
+static void *ringbuf_libbpf_consumer(void *input)
+{
+	struct ringbuf_libbpf_ctx *ctx = &ringbuf_libbpf_ctx;
+
+	while (ring_buffer__poll(ctx->ringbuf, -1) >= 0) {
+		if (args.back2back)
+			bufs_trigger_batch();
+	}
+	fprintf(stderr, "ringbuf polling failed!\n");
+	return NULL;
+}
+
+/* RINGBUF-CUSTOM benchmark */
+struct ringbuf_custom {
+	__u64 *consumer_pos;
+	__u64 *producer_pos;
+	__u64 mask;
+	void *data;
+	int map_fd;
+};
+
+static struct ringbuf_custom_ctx {
+	struct ringbuf_bench *skel;
+	struct ringbuf_custom ringbuf;
+	int epoll_fd;
+	struct epoll_event event;
+} ringbuf_custom_ctx;
+
+static void ringbuf_custom_measure(struct bench_res *res)
+{
+	struct ringbuf_custom_ctx *ctx = &ringbuf_custom_ctx;
+
+	res->hits = atomic_swap(&buf_hits.value, 0);
+	res->drops = atomic_swap(&ctx->skel->bss->dropped, 0);
+}
+
+static void ringbuf_custom_setup()
+{
+	struct ringbuf_custom_ctx *ctx = &ringbuf_custom_ctx;
+	const size_t page_size = getpagesize();
+	struct bpf_link *link;
+	struct ringbuf_custom *r;
+	void *tmp;
+	int err;
+
+	ctx->skel = ringbuf_setup_skeleton();
+
+	ctx->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
+	if (ctx->epoll_fd < 0) {
+		fprintf(stderr, "failed to create epoll fd: %d\n", -errno);
+		exit(1);
+	}
+
+	r = &ctx->ringbuf;
+	r->map_fd = bpf_map__fd(ctx->skel->maps.ringbuf);
+	r->mask = args.ringbuf_sz - 1;
+
+	/* Map writable consumer page */
+	tmp = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED,
+		   r->map_fd, 0);
+	if (tmp == MAP_FAILED) {
+		fprintf(stderr, "failed to mmap consumer page: %d\n", -errno);
+		exit(1);
+	}
+	r->consumer_pos = tmp;
+
+	/* Map read-only producer page and data pages. */
+	tmp = mmap(NULL, page_size + 2 * args.ringbuf_sz, PROT_READ, MAP_SHARED,
+		   r->map_fd, page_size);
+	if (tmp == MAP_FAILED) {
+		fprintf(stderr, "failed to mmap data pages: %d\n", -errno);
+		exit(1);
+	}
+	r->producer_pos = tmp;
+	r->data = tmp + page_size;
+
+	ctx->event.events = EPOLLIN;
+	err = epoll_ctl(ctx->epoll_fd, EPOLL_CTL_ADD, r->map_fd, &ctx->event);
+	if (err < 0) {
+		fprintf(stderr, "failed to epoll add ringbuf: %d\n", -errno);
+		exit(1);
+	}
+
+	link = bpf_program__attach(ctx->skel->progs.bench_ringbuf);
+	if (IS_ERR(link)) {
+		fprintf(stderr, "failed to attach program\n");
+		exit(1);
+	}
+}
+
+#define RINGBUF_BUSY_BIT (1 << 31)
+#define RINGBUF_DISCARD_BIT (1 << 30)
+#define RINGBUF_META_LEN 8
+
+static inline int roundup_len(__u32 len)
+{
+	/* clear out top 2 bits */
+	len <<= 2;
+	len >>= 2;
+	/* add length prefix */
+	len += RINGBUF_META_LEN;
+	/* round up to 8 byte alignment */
+	return (len + 7) / 8 * 8;
+}
+
+static void ringbuf_custom_process_ring(struct ringbuf_custom *r)
+{
+	unsigned long cons_pos, prod_pos;
+	int *len_ptr, len;
+	bool got_new_data;
+
+	cons_pos = smp_load_acquire(r->consumer_pos);
+	while (true) {
+		got_new_data = false;
+		prod_pos = smp_load_acquire(r->producer_pos);
+		while (cons_pos < prod_pos) {
+			len_ptr = r->data + (cons_pos & r->mask);
+			len = smp_load_acquire(len_ptr);
+
+			/* sample not committed yet, bail out for now */
+			if (len & RINGBUF_BUSY_BIT)
+				return;
+
+			got_new_data = true;
+			cons_pos += roundup_len(len);
+
+			atomic_inc(&buf_hits.value);
+		}
+		if (got_new_data)
+			smp_store_release(r->consumer_pos, cons_pos);
+		else
+			break;
+	};
+}
+
+static void *ringbuf_custom_consumer(void *input)
+{
+	struct ringbuf_custom_ctx *ctx = &ringbuf_custom_ctx;
+	int cnt;
+
+	do {
+		if (args.back2back)
+			bufs_trigger_batch();
+		cnt = epoll_wait(ctx->epoll_fd, &ctx->event, 1, -1);
+		if (cnt > 0)
+			ringbuf_custom_process_ring(&ctx->ringbuf);
+	} while (cnt >= 0);
+	fprintf(stderr, "ringbuf polling failed!\n");
+	return 0;
+}
+
+/* PERFBUF-LIBBPF benchmark */
+static struct perfbuf_libbpf_ctx {
+	struct perfbuf_bench *skel;
+	struct perf_buffer *perfbuf;
+} perfbuf_libbpf_ctx;
+
+static void perfbuf_measure(struct bench_res *res)
+{
+	struct perfbuf_libbpf_ctx *ctx = &perfbuf_libbpf_ctx;
+
+	res->hits = atomic_swap(&buf_hits.value, 0);
+	res->drops = atomic_swap(&ctx->skel->bss->dropped, 0);
+}
+
+static struct perfbuf_bench *perfbuf_setup_skeleton()
+{
+	struct perfbuf_bench *skel;
+
+	setup_libbpf();
+
+	skel = perfbuf_bench__open();
+	if (!skel) {
+		fprintf(stderr, "failed to open skeleton\n");
+		exit(1);
+	}
+
+	skel->rodata->batch_cnt = args.batch_cnt;
+
+	if (perfbuf_bench__load(skel)) {
+		fprintf(stderr, "failed to load skeleton\n");
+		exit(1);
+	}
+
+	return skel;
+}
+
+static enum bpf_perf_event_ret
+perfbuf_process_sample_raw(void *input_ctx, int cpu,
+			   struct perf_event_header *e)
+{
+	switch (e->type) {
+	case PERF_RECORD_SAMPLE:
+		atomic_inc(&buf_hits.value);
+		break;
+	case PERF_RECORD_LOST:
+		break;
+	default:
+		return LIBBPF_PERF_EVENT_ERROR;
+	}
+	return LIBBPF_PERF_EVENT_CONT;
+}
+
+static void perfbuf_libbpf_setup()
+{
+	struct perfbuf_libbpf_ctx *ctx = &perfbuf_libbpf_ctx;
+	struct perf_event_attr attr;
+	struct perf_buffer_raw_opts pb_opts = {
+		.event_cb = perfbuf_process_sample_raw,
+		.ctx = (void *)(long)0,
+		.attr = &attr,
+	};
+	struct bpf_link *link;
+
+	ctx->skel = perfbuf_setup_skeleton();
+
+	memset(&attr, 0, sizeof(attr));
+	attr.config = PERF_COUNT_SW_BPF_OUTPUT,
+	attr.type = PERF_TYPE_SOFTWARE;
+	attr.sample_type = PERF_SAMPLE_RAW;
+	/* notify only every Nth sample */
+	if (args.sampled) {
+		attr.sample_period = args.sample_rate;
+		attr.wakeup_events = args.sample_rate;
+	} else {
+		attr.sample_period = 1;
+		attr.wakeup_events = 1;
+	}
+
+	if (args.sample_rate > args.batch_cnt) {
+		fprintf(stderr, "sample rate %d is too high for given batch count %d\n",
+			args.sample_rate, args.batch_cnt);
+		exit(1);
+	}
+
+	ctx->perfbuf = perf_buffer__new_raw(bpf_map__fd(ctx->skel->maps.perfbuf),
+					    args.perfbuf_sz, &pb_opts);
+	if (!ctx->perfbuf) {
+		fprintf(stderr, "failed to create perfbuf\n");
+		exit(1);
+	}
+
+	link = bpf_program__attach(ctx->skel->progs.bench_perfbuf);
+	if (IS_ERR(link)) {
+		fprintf(stderr, "failed to attach program\n");
+		exit(1);
+	}
+}
+
+static void *perfbuf_libbpf_consumer(void *input)
+{
+	struct perfbuf_libbpf_ctx *ctx = &perfbuf_libbpf_ctx;
+
+	while (perf_buffer__poll(ctx->perfbuf, -1) >= 0) {
+		if (args.back2back)
+			bufs_trigger_batch();
+	}
+	fprintf(stderr, "perfbuf polling failed!\n");
+	return NULL;
+}
+
+/* PERFBUF-CUSTOM benchmark */
+
+/* copies of internal libbpf definitions */
+struct perf_cpu_buf {
+	struct perf_buffer *pb;
+	void *base; /* mmap()'ed memory */
+	void *buf; /* for reconstructing segmented data */
+	size_t buf_size;
+	int fd;
+	int cpu;
+	int map_key;
+};
+
+struct perf_buffer {
+	perf_buffer_event_fn event_cb;
+	perf_buffer_sample_fn sample_cb;
+	perf_buffer_lost_fn lost_cb;
+	void *ctx; /* passed into callbacks */
+
+	size_t page_size;
+	size_t mmap_size;
+	struct perf_cpu_buf **cpu_bufs;
+	struct epoll_event *events;
+	int cpu_cnt; /* number of allocated CPU buffers */
+	int epoll_fd; /* perf event FD */
+	int map_fd; /* BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF map FD */
+};
+
+static void *perfbuf_custom_consumer(void *input)
+{
+	struct perfbuf_libbpf_ctx *ctx = &perfbuf_libbpf_ctx;
+	struct perf_buffer *pb = ctx->perfbuf;
+	struct perf_cpu_buf *cpu_buf;
+	struct perf_event_mmap_page *header;
+	size_t mmap_mask = pb->mmap_size - 1;
+	struct perf_event_header *ehdr;
+	__u64 data_head, data_tail;
+	size_t ehdr_size;
+	void *base;
+	int i, cnt;
+
+	while (true) {
+		if (args.back2back)
+			bufs_trigger_batch();
+		cnt = epoll_wait(pb->epoll_fd, pb->events, pb->cpu_cnt, -1);
+		if (cnt <= 0) {
+			fprintf(stderr, "perf epoll failed: %d\n", -errno);
+			exit(1);
+		}
+
+		for (i = 0; i < cnt; ++i) {
+			cpu_buf = pb->events[i].data.ptr;
+			header = cpu_buf->base;
+			base = ((void *)header) + pb->page_size;
+
+			data_head = ring_buffer_read_head(header);
+			data_tail = header->data_tail;
+			while (data_head != data_tail) {
+				ehdr = base + (data_tail & mmap_mask);
+				ehdr_size = ehdr->size;
+
+				if (ehdr->type == PERF_RECORD_SAMPLE)
+					atomic_inc(&buf_hits.value);
+
+				data_tail += ehdr_size;
+			}
+			ring_buffer_write_tail(header, data_tail);
+		}
+	}
+	return NULL;
+}
+
+const struct bench bench_rb_libbpf = {
+	.name = "rb-libbpf",
+	.validate = bufs_validate,
+	.setup = ringbuf_libbpf_setup,
+	.producer_thread = bufs_sample_producer,
+	.consumer_thread = ringbuf_libbpf_consumer,
+	.measure = ringbuf_libbpf_measure,
+	.report_progress = hits_drops_report_progress,
+	.report_final = hits_drops_report_final,
+};
+
+const struct bench bench_rb_custom = {
+	.name = "rb-custom",
+	.validate = bufs_validate,
+	.setup = ringbuf_custom_setup,
+	.producer_thread = bufs_sample_producer,
+	.consumer_thread = ringbuf_custom_consumer,
+	.measure = ringbuf_custom_measure,
+	.report_progress = hits_drops_report_progress,
+	.report_final = hits_drops_report_final,
+};
+
+const struct bench bench_pb_libbpf = {
+	.name = "pb-libbpf",
+	.validate = bufs_validate,
+	.setup = perfbuf_libbpf_setup,
+	.producer_thread = bufs_sample_producer,
+	.consumer_thread = perfbuf_libbpf_consumer,
+	.measure = perfbuf_measure,
+	.report_progress = hits_drops_report_progress,
+	.report_final = hits_drops_report_final,
+};
+
+const struct bench bench_pb_custom = {
+	.name = "pb-custom",
+	.validate = bufs_validate,
+	.setup = perfbuf_libbpf_setup,
+	.producer_thread = bufs_sample_producer,
+	.consumer_thread = perfbuf_custom_consumer,
+	.measure = perfbuf_measure,
+	.report_progress = hits_drops_report_progress,
+	.report_final = hits_drops_report_final,
+};
+
