commit c97099b0f22722be7d0f290278a26d297cc4b7ca
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri May 29 00:54:23 2020 -0700

    bpf: Add BPF ringbuf and perf buffer benchmarks
    
    Extend bench framework with ability to have benchmark-provided child argument
    parser for custom benchmark-specific parameters. This makes bench generic code
    modular and independent from any specific benchmark.
    
    Also implement a set of benchmarks for new BPF ring buffer and existing perf
    buffer. 4 benchmarks were implemented: 2 variations for each of BPF ringbuf
    and perfbuf:,
      - rb-libbpf utilizes stock libbpf ring_buffer manager for reading data;
      - rb-custom implements custom ring buffer setup and reading code, to
        eliminate overheads inherent in generic libbpf code due to callback
        functions and the need to update consumer position after each consumed
        record, instead of batching updates (due to pessimistic assumption that
        user callback might take long time and thus could unnecessarily hold ring
        buffer space for too long);
      - pb-libbpf uses stock libbpf perf_buffer code with all the default
        settings, though uses higher-performance raw event callback to minimize
        unnecessary overhead;
      - pb-custom implements its own custom consumer code to minimize any possible
        overhead of generic libbpf implementation and indirect function calls.
    
    All of the test support default, no data notification skipped, mode, as well
    as sampled mode (with --rb-sampled flag), which allows to trigger epoll
    notification less frequently and reduce overhead. As will be shown, this mode
    is especially critical for perf buffer, which suffers from high overhead of
    wakeups in kernel.
    
    Otherwise, all benchamrks implement similar way to generate a batch of records
    by using fentry/sys_getpgid BPF program, which pushes a bunch of records in
    a tight loop and records number of successful and dropped samples. Each record
    is a small 8-byte integer, to minimize the effect of memory copying with
    bpf_perf_event_output() and bpf_ringbuf_output().
    
    Benchmarks that have only one producer implement optional back-to-back mode,
    in which record production and consumption is alternating on the same CPU.
    This is the highest-throughput happy case, showing ultimate performance
    achievable with either BPF ringbuf or perfbuf.
    
    All the below scenarios are implemented in a script in
    benchs/run_bench_ringbufs.sh. Tests were performed on 28-core/56-thread
    Intel Xeon CPU E5-2680 v4 @ 2.40GHz CPU.
    
    Single-producer, parallel producer
    ==================================
    rb-libbpf            12.054 ± 0.320M/s (drops 0.000 ± 0.000M/s)
    rb-custom            8.158 ± 0.118M/s (drops 0.001 ± 0.003M/s)
    pb-libbpf            0.931 ± 0.007M/s (drops 0.000 ± 0.000M/s)
    pb-custom            0.965 ± 0.003M/s (drops 0.000 ± 0.000M/s)
    
    Single-producer, parallel producer, sampled notification
    ========================================================
    rb-libbpf            11.563 ± 0.067M/s (drops 0.000 ± 0.000M/s)
    rb-custom            15.895 ± 0.076M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf            9.889 ± 0.032M/s (drops 0.000 ± 0.000M/s)
    pb-custom            9.866 ± 0.028M/s (drops 0.000 ± 0.000M/s)
    
    Single producer on one CPU, consumer on another one, both running at full
    speed. Curiously, rb-libbpf has higher throughput than objectively faster (due
    to more lightweight consumer code path) rb-custom. It appears that faster
    consumer causes kernel to send notifications more frequently, because consumer
    appears to be caught up more frequently. Performance of perfbuf suffers from
    default "no sampling" policy and huge overhead that causes.
    
    In sampled mode, rb-custom is winning very significantly eliminating too
    frequent in-kernel wakeups, the gain appears to be more than 2x.
    
    Perf buffer achieves even more impressive wins, compared to stock perfbuf
    settings, with 10x improvements in throughput with 1:500 sampling rate. The
    trade-off is that with sampling, application might not get next X events until
    X+1st arrives, which is not always acceptable. With steady influx of events,
    though, this shouldn't be a problem.
    
    Overall, single-producer performance of ring buffers seems to be better no
    matter the sampled/non-sampled modes, but it especially beats ring buffer
    without sampling due to its adaptive notification approach.
    
    Single-producer, back-to-back mode
    ==================================
    rb-libbpf            15.507 ± 0.247M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf-sampled    14.692 ± 0.195M/s (drops 0.000 ± 0.000M/s)
    rb-custom            21.449 ± 0.157M/s (drops 0.000 ± 0.000M/s)
    rb-custom-sampled    20.024 ± 0.386M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf            1.601 ± 0.015M/s (drops 0.000 ± 0.000M/s)
    pb-libbpf-sampled    8.545 ± 0.064M/s (drops 0.000 ± 0.000M/s)
    pb-custom            1.607 ± 0.022M/s (drops 0.000 ± 0.000M/s)
    pb-custom-sampled    8.988 ± 0.144M/s (drops 0.000 ± 0.000M/s)
    
    Here we test a back-to-back mode, which is arguably best-case scenario both
    for BPF ringbuf and perfbuf, because there is no contention and for ringbuf
    also no excessive notification, because consumer appears to be behind after
    the first record. For ringbuf, custom consumer code clearly wins with 21.5 vs
    16 million records per second exchanged between producer and consumer. Sampled
    mode actually hurts a bit due to slightly slower producer logic (it needs to
    fetch amount of data available to decide whether to skip or force notification).
    
    Perfbuf with wakeup sampling gets 5.5x throughput increase, compared to
    no-sampling version. There also doesn't seem to be noticeable overhead from
    generic libbpf handling code.
    
    Perfbuf back-to-back, effect of sample rate
    ===========================================
    pb-sampled-1         1.035 ± 0.012M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-5         3.476 ± 0.087M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-10        5.094 ± 0.136M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-25        7.118 ± 0.153M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-50        8.169 ± 0.156M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-100       8.887 ± 0.136M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-250       9.180 ± 0.209M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-500       9.353 ± 0.281M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-1000      9.411 ± 0.217M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-2000      9.464 ± 0.167M/s (drops 0.000 ± 0.000M/s)
    pb-sampled-3000      9.575 ± 0.273M/s (drops 0.000 ± 0.000M/s)
    
    This benchmark shows the effect of event sampling for perfbuf. Back-to-back
    mode for highest throughput. Just doing every 5th record notification gives
    3.5x speed up. 250-500 appears to be the point of diminishing return, with
    almost 9x speed up. Most benchmarks use 500 as the default sampling for pb-raw
    and pb-custom.
    
    Ringbuf back-to-back, effect of sample rate
    ===========================================
    rb-sampled-1         1.106 ± 0.010M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-5         4.746 ± 0.149M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-10        7.706 ± 0.164M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-25        12.893 ± 0.273M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-50        15.961 ± 0.361M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-100       18.203 ± 0.445M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-250       19.962 ± 0.786M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-500       20.881 ± 0.551M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-1000      21.317 ± 0.532M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-2000      21.331 ± 0.535M/s (drops 0.000 ± 0.000M/s)
    rb-sampled-3000      21.688 ± 0.392M/s (drops 0.000 ± 0.000M/s)
    
    Similar benchmark for ring buffer also shows a great advantage (in terms of
    throughput) of skipping notifications. Skipping every 5th one gives 4x boost.
    Also similar to perfbuf case, 250-500 seems to be the point of diminishing
    returns, giving roughly 20x better results.
    
    Keep in mind, for this test, notifications are controlled manually with
    BPF_RB_NO_WAKEUP and BPF_RB_FORCE_WAKEUP. As can be seen from previous
    benchmarks, adaptive notifications based on consumer's positions provides same
    (or even slightly better due to simpler load generator on BPF side) benefits in
    favorable back-to-back scenario. Over zealous and fast consumer, which is
    almost always caught up, will make thoughput numbers smaller. That's the case
    when manual notification control might prove to be extremely beneficial.
    
    Ringbuf back-to-back, reserve+commit vs output
    ==============================================
    reserve              22.819 ± 0.503M/s (drops 0.000 ± 0.000M/s)
    output               18.906 ± 0.433M/s (drops 0.000 ± 0.000M/s)
    
    Ringbuf sampled, reserve+commit vs output
    =========================================
    reserve-sampled      15.350 ± 0.132M/s (drops 0.000 ± 0.000M/s)
    output-sampled       14.195 ± 0.144M/s (drops 0.000 ± 0.000M/s)
    
    BPF ringbuf supports two sets of APIs with various usability and performance
    tradeoffs: bpf_ringbuf_reserve()+bpf_ringbuf_commit() vs bpf_ringbuf_output().
    This benchmark clearly shows superiority of reserve+commit approach, despite
    using a small 8-byte record size.
    
    Single-producer, consumer/producer competing on the same CPU, low batch count
    =============================================================================
    rb-libbpf            3.045 ± 0.020M/s (drops 3.536 ± 0.148M/s)
    rb-custom            3.055 ± 0.022M/s (drops 3.893 ± 0.066M/s)
    pb-libbpf            1.393 ± 0.024M/s (drops 0.000 ± 0.000M/s)
    pb-custom            1.407 ± 0.016M/s (drops 0.000 ± 0.000M/s)
    
    This benchmark shows one of the worst-case scenarios, in which producer and
    consumer do not coordinate *and* fight for the same CPU. No batch count and
    sampling settings were able to eliminate drops for ringbuffer, producer is
    just too fast for consumer to keep up. But ringbuf and perfbuf still able to
    pass through quite a lot of messages, which is more than enough for a lot of
    applications.
    
    Ringbuf, multi-producer contention
    ==================================
    rb-libbpf nr_prod 1  10.916 ± 0.399M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 2  4.931 ± 0.030M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 3  4.880 ± 0.006M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 4  3.926 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 8  4.011 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 12 3.967 ± 0.016M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 16 2.604 ± 0.030M/s (drops 0.001 ± 0.002M/s)
    rb-libbpf nr_prod 20 2.233 ± 0.003M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 24 2.085 ± 0.015M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 28 2.055 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 32 1.962 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 36 2.089 ± 0.005M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 40 2.118 ± 0.006M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 44 2.105 ± 0.004M/s (drops 0.000 ± 0.000M/s)
    rb-libbpf nr_prod 48 2.120 ± 0.058M/s (drops 0.000 ± 0.001M/s)
    rb-libbpf nr_prod 52 2.074 ± 0.024M/s (drops 0.007 ± 0.014M/s)
    
    Ringbuf uses a very short-duration spinlock during reservation phase, to check
    few invariants, increment producer count and set record header. This is the
    biggest point of contention for ringbuf implementation. This benchmark
    evaluates the effect of multiple competing writers on overall throughput of
    a single shared ringbuffer.
    
    Overall throughput drops almost 2x when going from single to two
    highly-contended producers, gradually dropping with additional competing
    producers.  Performance drop stabilizes at around 20 producers and hovers
    around 2mln even with 50+ fighting producers, which is a 5x drop compared to
    non-contended case. Good kernel implementation in kernel helps maintain decent
    performance here.
    
    Note, that in the intended real-world scenarios, it's not expected to get even
    close to such a high levels of contention. But if contention will become
    a problem, there is always an option of sharding few ring buffers across a set
    of CPUs.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Link: https://lore.kernel.org/bpf/20200529075424.3139988-5-andriin@fb.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/testing/selftests/bpf/bench.c b/tools/testing/selftests/bpf/bench.c
index 14390689ef90..944ad4721c83 100644
--- a/tools/testing/selftests/bpf/bench.c
+++ b/tools/testing/selftests/bpf/bench.c
@@ -130,6 +130,13 @@ static const struct argp_option opts[] = {
 	{},
 };
 
+extern struct argp bench_ringbufs_argp;
+
+static const struct argp_child bench_parsers[] = {
+	{ &bench_ringbufs_argp, 0, "Ring buffers benchmark", 0 },
+	{},
+};
+
 static error_t parse_arg(int key, char *arg, struct argp_state *state)
 {
 	static int pos_args;
@@ -208,6 +215,7 @@ static void parse_cmdline_args(int argc, char **argv)
 		.options = opts,
 		.parser = parse_arg,
 		.doc = argp_program_doc,
+		.children = bench_parsers,
 	};
 	if (argp_parse(&argp, argc, argv, 0, NULL, NULL))
 		exit(1);
@@ -310,6 +318,10 @@ extern const struct bench bench_trig_rawtp;
 extern const struct bench bench_trig_kprobe;
 extern const struct bench bench_trig_fentry;
 extern const struct bench bench_trig_fmodret;
+extern const struct bench bench_rb_libbpf;
+extern const struct bench bench_rb_custom;
+extern const struct bench bench_pb_libbpf;
+extern const struct bench bench_pb_custom;
 
 static const struct bench *benchs[] = {
 	&bench_count_global,
@@ -327,6 +339,10 @@ static const struct bench *benchs[] = {
 	&bench_trig_kprobe,
 	&bench_trig_fentry,
 	&bench_trig_fmodret,
+	&bench_rb_libbpf,
+	&bench_rb_custom,
+	&bench_pb_libbpf,
+	&bench_pb_custom,
 };
 
 static void setup_benchmark()

commit 5b0004d92b4511c39db0df23aa84395722f1d706
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu May 14 13:15:29 2020 +0100

    selftest/bpf: Fix spelling mistake "SIGALARM" -> "SIGALRM"
    
    There is a spelling mistake in an error message, fix it.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200514121529.259668-1-colin.king@canonical.com

diff --git a/tools/testing/selftests/bpf/bench.c b/tools/testing/selftests/bpf/bench.c
index 8c0dfbfe6088..14390689ef90 100644
--- a/tools/testing/selftests/bpf/bench.c
+++ b/tools/testing/selftests/bpf/bench.c
@@ -242,7 +242,7 @@ static void setup_timer()
 	last_time_ns = get_time_ns();
 	err = sigaction(SIGALRM, &sigalarm_action, NULL);
 	if (err < 0) {
-		fprintf(stderr, "failed to install SIGALARM handler: %d\n", -errno);
+		fprintf(stderr, "failed to install SIGALRM handler: %d\n", -errno);
 		exit(1);
 	}
 	timer_settings.it_interval.tv_sec = 1;

commit c5d420c32cb44fdd10d76f0f01bcd0b09383d0b5
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue May 12 12:24:45 2020 -0700

    selftest/bpf: Add BPF triggering benchmark
    
    It is sometimes desirable to be able to trigger BPF program from user-space
    with minimal overhead. sys_enter would seem to be a good candidate, yet in
    a lot of cases there will be a lot of noise from syscalls triggered by other
    processes on the system. So while searching for low-overhead alternative, I've
    stumbled upon getpgid() syscall, which seems to be specific enough to not
    suffer from accidental syscall by other apps.
    
    This set of benchmarks compares tp, raw_tp w/ filtering by syscall ID, kprobe,
    fentry and fmod_ret with returning error (so that syscall would not be
    executed), to determine the lowest-overhead way. Here are results on my
    machine (using benchs/run_bench_trigger.sh script):
    
      base      :    9.200 ± 0.319M/s
      tp        :    6.690 ± 0.125M/s
      rawtp     :    8.571 ± 0.214M/s
      kprobe    :    6.431 ± 0.048M/s
      fentry    :    8.955 ± 0.241M/s
      fmodret   :    8.903 ± 0.135M/s
    
    So it seems like fmodret doesn't give much benefit for such lightweight
    syscall. Raw tracepoint is pretty decent despite additional filtering logic,
    but it will be called for any other syscall in the system, which rules it out.
    Fentry, though, seems to be adding the least amoung of overhead and achieves
    97.3% of performance of baseline no-BPF-attached syscall.
    
    Using getpgid() seems to be preferable to set_task_comm() approach from
    test_overhead, as it's about 2.35x faster in a baseline performance.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200512192445.2351848-5-andriin@fb.com

diff --git a/tools/testing/selftests/bpf/bench.c b/tools/testing/selftests/bpf/bench.c
index c9e8b7dbaf66..8c0dfbfe6088 100644
--- a/tools/testing/selftests/bpf/bench.c
+++ b/tools/testing/selftests/bpf/bench.c
@@ -304,6 +304,12 @@ extern const struct bench bench_rename_rawtp;
 extern const struct bench bench_rename_fentry;
 extern const struct bench bench_rename_fexit;
 extern const struct bench bench_rename_fmodret;
+extern const struct bench bench_trig_base;
+extern const struct bench bench_trig_tp;
+extern const struct bench bench_trig_rawtp;
+extern const struct bench bench_trig_kprobe;
+extern const struct bench bench_trig_fentry;
+extern const struct bench bench_trig_fmodret;
 
 static const struct bench *benchs[] = {
 	&bench_count_global,
@@ -315,6 +321,12 @@ static const struct bench *benchs[] = {
 	&bench_rename_fentry,
 	&bench_rename_fexit,
 	&bench_rename_fmodret,
+	&bench_trig_base,
+	&bench_trig_tp,
+	&bench_trig_rawtp,
+	&bench_trig_kprobe,
+	&bench_trig_fentry,
+	&bench_trig_fmodret,
 };
 
 static void setup_benchmark()

commit 4eaf0b5c5e04c21a866431bd763ab4b1f24c4d16
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue May 12 12:24:44 2020 -0700

    selftest/bpf: Fmod_ret prog and implement test_overhead as part of bench
    
    Add fmod_ret BPF program to existing test_overhead selftest. Also re-implement
    user-space benchmarking part into benchmark runner to compare results. Results
    with ./bench are consistently somewhat lower than test_overhead's, but relative
    performance of various types of BPF programs stay consisten (e.g., kretprobe is
    noticeably slower). This slowdown seems to be coming from the fact that
    test_overhead is single-threaded, while benchmark always spins off at least
    one thread for producer. This has been confirmed by hacking multi-threaded
    test_overhead variant and also single-threaded bench variant. Resutls are
    below. run_bench_rename.sh script from benchs/ subdirectory was used to
    produce results for ./bench.
    
    Single-threaded implementations
    ===============================
    
    /* bench: single-threaded, atomics */
    base      :    4.622 ± 0.049M/s
    kprobe    :    3.673 ± 0.052M/s
    kretprobe :    2.625 ± 0.052M/s
    rawtp     :    4.369 ± 0.089M/s
    fentry    :    4.201 ± 0.558M/s
    fexit     :    4.309 ± 0.148M/s
    fmodret   :    4.314 ± 0.203M/s
    
    /* selftest: single-threaded, no atomics */
    task_rename base        4555K events per sec
    task_rename kprobe      3643K events per sec
    task_rename kretprobe   2506K events per sec
    task_rename raw_tp      4303K events per sec
    task_rename fentry      4307K events per sec
    task_rename fexit       4010K events per sec
    task_rename fmod_ret    3984K events per sec
    
    Multi-threaded implementations
    ==============================
    
    /* bench: multi-threaded w/ atomics */
    base      :    3.910 ± 0.023M/s
    kprobe    :    3.048 ± 0.037M/s
    kretprobe :    2.300 ± 0.015M/s
    rawtp     :    3.687 ± 0.034M/s
    fentry    :    3.740 ± 0.087M/s
    fexit     :    3.510 ± 0.009M/s
    fmodret   :    3.485 ± 0.050M/s
    
    /* selftest: multi-threaded w/ atomics */
    task_rename base        3872K events per sec
    task_rename kprobe      3068K events per sec
    task_rename kretprobe   2350K events per sec
    task_rename raw_tp      3731K events per sec
    task_rename fentry      3639K events per sec
    task_rename fexit       3558K events per sec
    task_rename fmod_ret    3511K events per sec
    
    /* selftest: multi-threaded, no atomics */
    task_rename base        3945K events per sec
    task_rename kprobe      3298K events per sec
    task_rename kretprobe   2451K events per sec
    task_rename raw_tp      3718K events per sec
    task_rename fentry      3782K events per sec
    task_rename fexit       3543K events per sec
    task_rename fmod_ret    3526K events per sec
    
    Note that the fact that ./bench benchmark always uses atomic increments for
    counting, while test_overhead doesn't, doesn't influence test results all that
    much.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200512192445.2351848-4-andriin@fb.com

diff --git a/tools/testing/selftests/bpf/bench.c b/tools/testing/selftests/bpf/bench.c
index 3972da8b19e8..c9e8b7dbaf66 100644
--- a/tools/testing/selftests/bpf/bench.c
+++ b/tools/testing/selftests/bpf/bench.c
@@ -297,10 +297,24 @@ const struct bench *bench = NULL;
 
 extern const struct bench bench_count_global;
 extern const struct bench bench_count_local;
+extern const struct bench bench_rename_base;
+extern const struct bench bench_rename_kprobe;
+extern const struct bench bench_rename_kretprobe;
+extern const struct bench bench_rename_rawtp;
+extern const struct bench bench_rename_fentry;
+extern const struct bench bench_rename_fexit;
+extern const struct bench bench_rename_fmodret;
 
 static const struct bench *benchs[] = {
 	&bench_count_global,
 	&bench_count_local,
+	&bench_rename_base,
+	&bench_rename_kprobe,
+	&bench_rename_kretprobe,
+	&bench_rename_rawtp,
+	&bench_rename_fentry,
+	&bench_rename_fexit,
+	&bench_rename_fmodret,
 };
 
 static void setup_benchmark()

commit 8e7c2a023ac04e04c72cd7b640329511dda92672
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Tue May 12 12:24:43 2020 -0700

    selftests/bpf: Add benchmark runner infrastructure
    
    While working on BPF ringbuf implementation, testing, and benchmarking, I've
    developed a pretty generic and modular benchmark runner, which seems to be
    generically useful, as I've already used it for one more purpose (testing
    fastest way to trigger BPF program, to minimize overhead of in-kernel code).
    
    This patch adds generic part of benchmark runner and sets up Makefile for
    extending it with more sets of benchmarks.
    
    Benchmarker itself operates by spinning up specified number of producer and
    consumer threads, setting up interval timer sending SIGALARM signal to
    application once a second. Every second, current snapshot with hits/drops
    counters are collected and stored in an array. Drops are useful for
    producer/consumer benchmarks in which producer might overwhelm consumers.
    
    Once test finishes after given amount of warm-up and testing seconds, mean and
    stddev are calculated (ignoring warm-up results) and is printed out to stdout.
    This setup seems to give consistent and accurate results.
    
    To validate behavior, I added two atomic counting tests: global and local.
    For global one, all the producer threads are atomically incrementing same
    counter as fast as possible. This, of course, leads to huge drop of
    performance once there is more than one producer thread due to CPUs fighting
    for the same memory location.
    
    Local counting, on the other hand, maintains one counter per each producer
    thread, incremented independently. Once per second, all counters are read and
    added together to form final "counting throughput" measurement. As expected,
    such setup demonstrates linear scalability with number of producers (as long
    as there are enough physical CPU cores, of course). See example output below.
    Also, this setup can nicely demonstrate disastrous effects of false sharing,
    if care is not taken to take those per-producer counters apart into
    independent cache lines.
    
    Demo output shows global counter first with 1 producer, then with 4. Both
    total and per-producer performance significantly drop. The last run is local
    counter with 4 producers, demonstrating near-perfect scalability.
    
    $ ./bench -a -w1 -d2 -p1 count-global
    Setting up benchmark 'count-global'...
    Benchmark 'count-global' started.
    Iter   0 ( 24.822us): hits  148.179M/s (148.179M/prod), drops    0.000M/s
    Iter   1 ( 37.939us): hits  149.308M/s (149.308M/prod), drops    0.000M/s
    Iter   2 (-10.774us): hits  150.717M/s (150.717M/prod), drops    0.000M/s
    Iter   3 (  3.807us): hits  151.435M/s (151.435M/prod), drops    0.000M/s
    Summary: hits  150.488 ± 1.079M/s (150.488M/prod), drops    0.000 ± 0.000M/s
    
    $ ./bench -a -w1 -d2 -p4 count-global
    Setting up benchmark 'count-global'...
    Benchmark 'count-global' started.
    Iter   0 ( 60.659us): hits   53.910M/s ( 13.477M/prod), drops    0.000M/s
    Iter   1 (-17.658us): hits   53.722M/s ( 13.431M/prod), drops    0.000M/s
    Iter   2 (  5.865us): hits   53.495M/s ( 13.374M/prod), drops    0.000M/s
    Iter   3 (  0.104us): hits   53.606M/s ( 13.402M/prod), drops    0.000M/s
    Summary: hits   53.608 ± 0.113M/s ( 13.402M/prod), drops    0.000 ± 0.000M/s
    
    $ ./bench -a -w1 -d2 -p4 count-local
    Setting up benchmark 'count-local'...
    Benchmark 'count-local' started.
    Iter   0 ( 23.388us): hits  640.450M/s (160.113M/prod), drops    0.000M/s
    Iter   1 (  2.291us): hits  605.661M/s (151.415M/prod), drops    0.000M/s
    Iter   2 ( -6.415us): hits  607.092M/s (151.773M/prod), drops    0.000M/s
    Iter   3 ( -1.361us): hits  601.796M/s (150.449M/prod), drops    0.000M/s
    Summary: hits  604.849 ± 2.739M/s (151.212M/prod), drops    0.000 ± 0.000M/s
    
    Benchmark runner supports setting thread affinity for producer and consumer
    threads. You can use -a flag for default CPU selection scheme, where first
    consumer gets CPU #0, next one gets CPU #1, and so on. Then producer threads
    pick up next CPU and increment one-by-one as well. But user can also specify
    a set of CPUs independently for producers and consumers with --prod-affinity
    1,2-10,15 and --cons-affinity <set-of-cpus>. The latter allows to force
    producers and consumers to share same set of CPUs, if necessary.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Yonghong Song <yhs@fb.com>
    Link: https://lore.kernel.org/bpf/20200512192445.2351848-3-andriin@fb.com

diff --git a/tools/testing/selftests/bpf/bench.c b/tools/testing/selftests/bpf/bench.c
new file mode 100644
index 000000000000..3972da8b19e8
--- /dev/null
+++ b/tools/testing/selftests/bpf/bench.c
@@ -0,0 +1,423 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 Facebook */
+#define _GNU_SOURCE
+#include <argp.h>
+#include <linux/compiler.h>
+#include <sys/time.h>
+#include <sched.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <sys/sysinfo.h>
+#include <sys/resource.h>
+#include <signal.h>
+#include "bench.h"
+#include "testing_helpers.h"
+
+struct env env = {
+	.warmup_sec = 1,
+	.duration_sec = 5,
+	.affinity = false,
+	.consumer_cnt = 1,
+	.producer_cnt = 1,
+};
+
+static int libbpf_print_fn(enum libbpf_print_level level,
+		    const char *format, va_list args)
+{
+	if (level == LIBBPF_DEBUG && !env.verbose)
+		return 0;
+	return vfprintf(stderr, format, args);
+}
+
+static int bump_memlock_rlimit(void)
+{
+	struct rlimit rlim_new = {
+		.rlim_cur	= RLIM_INFINITY,
+		.rlim_max	= RLIM_INFINITY,
+	};
+
+	return setrlimit(RLIMIT_MEMLOCK, &rlim_new);
+}
+
+void setup_libbpf()
+{
+	int err;
+
+	libbpf_set_print(libbpf_print_fn);
+
+	err = bump_memlock_rlimit();
+	if (err)
+		fprintf(stderr, "failed to increase RLIMIT_MEMLOCK: %d", err);
+}
+
+void hits_drops_report_progress(int iter, struct bench_res *res, long delta_ns)
+{
+	double hits_per_sec, drops_per_sec;
+	double hits_per_prod;
+
+	hits_per_sec = res->hits / 1000000.0 / (delta_ns / 1000000000.0);
+	hits_per_prod = hits_per_sec / env.producer_cnt;
+	drops_per_sec = res->drops / 1000000.0 / (delta_ns / 1000000000.0);
+
+	printf("Iter %3d (%7.3lfus): ",
+	       iter, (delta_ns - 1000000000) / 1000.0);
+
+	printf("hits %8.3lfM/s (%7.3lfM/prod), drops %8.3lfM/s\n",
+	       hits_per_sec, hits_per_prod, drops_per_sec);
+}
+
+void hits_drops_report_final(struct bench_res res[], int res_cnt)
+{
+	int i;
+	double hits_mean = 0.0, drops_mean = 0.0;
+	double hits_stddev = 0.0, drops_stddev = 0.0;
+
+	for (i = 0; i < res_cnt; i++) {
+		hits_mean += res[i].hits / 1000000.0 / (0.0 + res_cnt);
+		drops_mean += res[i].drops / 1000000.0 / (0.0 + res_cnt);
+	}
+
+	if (res_cnt > 1)  {
+		for (i = 0; i < res_cnt; i++) {
+			hits_stddev += (hits_mean - res[i].hits / 1000000.0) *
+				       (hits_mean - res[i].hits / 1000000.0) /
+				       (res_cnt - 1.0);
+			drops_stddev += (drops_mean - res[i].drops / 1000000.0) *
+					(drops_mean - res[i].drops / 1000000.0) /
+					(res_cnt - 1.0);
+		}
+		hits_stddev = sqrt(hits_stddev);
+		drops_stddev = sqrt(drops_stddev);
+	}
+	printf("Summary: hits %8.3lf \u00B1 %5.3lfM/s (%7.3lfM/prod), ",
+	       hits_mean, hits_stddev, hits_mean / env.producer_cnt);
+	printf("drops %8.3lf \u00B1 %5.3lfM/s\n",
+	       drops_mean, drops_stddev);
+}
+
+const char *argp_program_version = "benchmark";
+const char *argp_program_bug_address = "<bpf@vger.kernel.org>";
+const char argp_program_doc[] =
+"benchmark    Generic benchmarking framework.\n"
+"\n"
+"This tool runs benchmarks.\n"
+"\n"
+"USAGE: benchmark <bench-name>\n"
+"\n"
+"EXAMPLES:\n"
+"    # run 'count-local' benchmark with 1 producer and 1 consumer\n"
+"    benchmark count-local\n"
+"    # run 'count-local' with 16 producer and 8 consumer thread, pinned to CPUs\n"
+"    benchmark -p16 -c8 -a count-local\n";
+
+enum {
+	ARG_PROD_AFFINITY_SET = 1000,
+	ARG_CONS_AFFINITY_SET = 1001,
+};
+
+static const struct argp_option opts[] = {
+	{ "list", 'l', NULL, 0, "List available benchmarks"},
+	{ "duration", 'd', "SEC", 0, "Duration of benchmark, seconds"},
+	{ "warmup", 'w', "SEC", 0, "Warm-up period, seconds"},
+	{ "producers", 'p', "NUM", 0, "Number of producer threads"},
+	{ "consumers", 'c', "NUM", 0, "Number of consumer threads"},
+	{ "verbose", 'v', NULL, 0, "Verbose debug output"},
+	{ "affinity", 'a', NULL, 0, "Set consumer/producer thread affinity"},
+	{ "prod-affinity", ARG_PROD_AFFINITY_SET, "CPUSET", 0,
+	  "Set of CPUs for producer threads; implies --affinity"},
+	{ "cons-affinity", ARG_CONS_AFFINITY_SET, "CPUSET", 0,
+	  "Set of CPUs for consumer threads; implies --affinity"},
+	{},
+};
+
+static error_t parse_arg(int key, char *arg, struct argp_state *state)
+{
+	static int pos_args;
+
+	switch (key) {
+	case 'v':
+		env.verbose = true;
+		break;
+	case 'l':
+		env.list = true;
+		break;
+	case 'd':
+		env.duration_sec = strtol(arg, NULL, 10);
+		if (env.duration_sec <= 0) {
+			fprintf(stderr, "Invalid duration: %s\n", arg);
+			argp_usage(state);
+		}
+		break;
+	case 'w':
+		env.warmup_sec = strtol(arg, NULL, 10);
+		if (env.warmup_sec <= 0) {
+			fprintf(stderr, "Invalid warm-up duration: %s\n", arg);
+			argp_usage(state);
+		}
+		break;
+	case 'p':
+		env.producer_cnt = strtol(arg, NULL, 10);
+		if (env.producer_cnt <= 0) {
+			fprintf(stderr, "Invalid producer count: %s\n", arg);
+			argp_usage(state);
+		}
+		break;
+	case 'c':
+		env.consumer_cnt = strtol(arg, NULL, 10);
+		if (env.consumer_cnt <= 0) {
+			fprintf(stderr, "Invalid consumer count: %s\n", arg);
+			argp_usage(state);
+		}
+		break;
+	case 'a':
+		env.affinity = true;
+		break;
+	case ARG_PROD_AFFINITY_SET:
+		env.affinity = true;
+		if (parse_num_list(arg, &env.prod_cpus.cpus,
+				   &env.prod_cpus.cpus_len)) {
+			fprintf(stderr, "Invalid format of CPU set for producers.");
+			argp_usage(state);
+		}
+		break;
+	case ARG_CONS_AFFINITY_SET:
+		env.affinity = true;
+		if (parse_num_list(arg, &env.cons_cpus.cpus,
+				   &env.cons_cpus.cpus_len)) {
+			fprintf(stderr, "Invalid format of CPU set for consumers.");
+			argp_usage(state);
+		}
+		break;
+	case ARGP_KEY_ARG:
+		if (pos_args++) {
+			fprintf(stderr,
+				"Unrecognized positional argument: %s\n", arg);
+			argp_usage(state);
+		}
+		env.bench_name = strdup(arg);
+		break;
+	default:
+		return ARGP_ERR_UNKNOWN;
+	}
+	return 0;
+}
+
+static void parse_cmdline_args(int argc, char **argv)
+{
+	static const struct argp argp = {
+		.options = opts,
+		.parser = parse_arg,
+		.doc = argp_program_doc,
+	};
+	if (argp_parse(&argp, argc, argv, 0, NULL, NULL))
+		exit(1);
+	if (!env.list && !env.bench_name) {
+		argp_help(&argp, stderr, ARGP_HELP_DOC, "bench");
+		exit(1);
+	}
+}
+
+static void collect_measurements(long delta_ns);
+
+static __u64 last_time_ns;
+static void sigalarm_handler(int signo)
+{
+	long new_time_ns = get_time_ns();
+	long delta_ns = new_time_ns - last_time_ns;
+
+	collect_measurements(delta_ns);
+
+	last_time_ns = new_time_ns;
+}
+
+/* set up periodic 1-second timer */
+static void setup_timer()
+{
+	static struct sigaction sigalarm_action = {
+		.sa_handler = sigalarm_handler,
+	};
+	struct itimerval timer_settings = {};
+	int err;
+
+	last_time_ns = get_time_ns();
+	err = sigaction(SIGALRM, &sigalarm_action, NULL);
+	if (err < 0) {
+		fprintf(stderr, "failed to install SIGALARM handler: %d\n", -errno);
+		exit(1);
+	}
+	timer_settings.it_interval.tv_sec = 1;
+	timer_settings.it_value.tv_sec = 1;
+	err = setitimer(ITIMER_REAL, &timer_settings, NULL);
+	if (err < 0) {
+		fprintf(stderr, "failed to arm interval timer: %d\n", -errno);
+		exit(1);
+	}
+}
+
+static void set_thread_affinity(pthread_t thread, int cpu)
+{
+	cpu_set_t cpuset;
+
+	CPU_ZERO(&cpuset);
+	CPU_SET(cpu, &cpuset);
+	if (pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset)) {
+		fprintf(stderr, "setting affinity to CPU #%d failed: %d\n",
+			cpu, errno);
+		exit(1);
+	}
+}
+
+static int next_cpu(struct cpu_set *cpu_set)
+{
+	if (cpu_set->cpus) {
+		int i;
+
+		/* find next available CPU */
+		for (i = cpu_set->next_cpu; i < cpu_set->cpus_len; i++) {
+			if (cpu_set->cpus[i]) {
+				cpu_set->next_cpu = i + 1;
+				return i;
+			}
+		}
+		fprintf(stderr, "Not enough CPUs specified, need CPU #%d or higher.\n", i);
+		exit(1);
+	}
+
+	return cpu_set->next_cpu++;
+}
+
+static struct bench_state {
+	int res_cnt;
+	struct bench_res *results;
+	pthread_t *consumers;
+	pthread_t *producers;
+} state;
+
+const struct bench *bench = NULL;
+
+extern const struct bench bench_count_global;
+extern const struct bench bench_count_local;
+
+static const struct bench *benchs[] = {
+	&bench_count_global,
+	&bench_count_local,
+};
+
+static void setup_benchmark()
+{
+	int i, err;
+
+	if (!env.bench_name) {
+		fprintf(stderr, "benchmark name is not specified\n");
+		exit(1);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(benchs); i++) {
+		if (strcmp(benchs[i]->name, env.bench_name) == 0) {
+			bench = benchs[i];
+			break;
+		}
+	}
+	if (!bench) {
+		fprintf(stderr, "benchmark '%s' not found\n", env.bench_name);
+		exit(1);
+	}
+
+	printf("Setting up benchmark '%s'...\n", bench->name);
+
+	state.producers = calloc(env.producer_cnt, sizeof(*state.producers));
+	state.consumers = calloc(env.consumer_cnt, sizeof(*state.consumers));
+	state.results = calloc(env.duration_sec + env.warmup_sec + 2,
+			       sizeof(*state.results));
+	if (!state.producers || !state.consumers || !state.results)
+		exit(1);
+
+	if (bench->validate)
+		bench->validate();
+	if (bench->setup)
+		bench->setup();
+
+	for (i = 0; i < env.consumer_cnt; i++) {
+		err = pthread_create(&state.consumers[i], NULL,
+				     bench->consumer_thread, (void *)(long)i);
+		if (err) {
+			fprintf(stderr, "failed to create consumer thread #%d: %d\n",
+				i, -errno);
+			exit(1);
+		}
+		if (env.affinity)
+			set_thread_affinity(state.consumers[i],
+					    next_cpu(&env.cons_cpus));
+	}
+
+	/* unless explicit producer CPU list is specified, continue after
+	 * last consumer CPU
+	 */
+	if (!env.prod_cpus.cpus)
+		env.prod_cpus.next_cpu = env.cons_cpus.next_cpu;
+
+	for (i = 0; i < env.producer_cnt; i++) {
+		err = pthread_create(&state.producers[i], NULL,
+				     bench->producer_thread, (void *)(long)i);
+		if (err) {
+			fprintf(stderr, "failed to create producer thread #%d: %d\n",
+				i, -errno);
+			exit(1);
+		}
+		if (env.affinity)
+			set_thread_affinity(state.producers[i],
+					    next_cpu(&env.prod_cpus));
+	}
+
+	printf("Benchmark '%s' started.\n", bench->name);
+}
+
+static pthread_mutex_t bench_done_mtx = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t bench_done = PTHREAD_COND_INITIALIZER;
+
+static void collect_measurements(long delta_ns) {
+	int iter = state.res_cnt++;
+	struct bench_res *res = &state.results[iter];
+
+	bench->measure(res);
+
+	if (bench->report_progress)
+		bench->report_progress(iter, res, delta_ns);
+
+	if (iter == env.duration_sec + env.warmup_sec) {
+		pthread_mutex_lock(&bench_done_mtx);
+		pthread_cond_signal(&bench_done);
+		pthread_mutex_unlock(&bench_done_mtx);
+	}
+}
+
+int main(int argc, char **argv)
+{
+	parse_cmdline_args(argc, argv);
+
+	if (env.list) {
+		int i;
+
+		printf("Available benchmarks:\n");
+		for (i = 0; i < ARRAY_SIZE(benchs); i++) {
+			printf("- %s\n", benchs[i]->name);
+		}
+		return 0;
+	}
+
+	setup_benchmark();
+
+	setup_timer();
+
+	pthread_mutex_lock(&bench_done_mtx);
+	pthread_cond_wait(&bench_done, &bench_done_mtx);
+	pthread_mutex_unlock(&bench_done_mtx);
+
+	if (bench->report_final)
+		/* skip first sample */
+		bench->report_final(state.results + env.warmup_sec,
+				    state.res_cnt - env.warmup_sec);
+
+	return 0;
+}
+
