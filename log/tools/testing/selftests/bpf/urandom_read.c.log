commit f6827526279d75f0b1c1605b1bf560024bd7696f
Author: Ivan Vecera <ivecera@redhat.com>
Date:   Fri Mar 15 21:04:14 2019 +0100

    selftests: bpf: modify urandom_read and link it non-statically
    
    After some experiences I found that urandom_read does not need to be
    linked statically. When the 'read' syscall call is moved to separate
    non-inlined function then bpf_get_stackid() is able to find
    the executable in stack trace and extract its build_id from it.
    
    Signed-off-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/tools/testing/selftests/bpf/urandom_read.c b/tools/testing/selftests/bpf/urandom_read.c
index 9de8b7cb4e6d..db781052758d 100644
--- a/tools/testing/selftests/bpf/urandom_read.c
+++ b/tools/testing/selftests/bpf/urandom_read.c
@@ -7,11 +7,19 @@
 
 #define BUF_SIZE 256
 
+static __attribute__((noinline))
+void urandom_read(int fd, int count)
+{
+       char buf[BUF_SIZE];
+       int i;
+
+       for (i = 0; i < count; ++i)
+               read(fd, buf, BUF_SIZE);
+}
+
 int main(int argc, char *argv[])
 {
 	int fd = open("/dev/urandom", O_RDONLY);
-	int i;
-	char buf[BUF_SIZE];
 	int count = 4;
 
 	if (fd < 0)
@@ -20,8 +28,7 @@ int main(int argc, char *argv[])
 	if (argc == 2)
 		count = atoi(argv[1]);
 
-	for (i = 0; i < count; ++i)
-		read(fd, buf, BUF_SIZE);
+	urandom_read(fd, count);
 
 	close(fd);
 	return 0;

commit 13790d1cc72c22f6e7a1248e5f6d20d720797e95
Author: Song Liu <songliubraving@fb.com>
Date:   Mon May 7 10:50:49 2018 -0700

    bpf: add selftest for stackmap with build_id in NMI context
    
    This new test captures stackmap with build_id with hardware event
    PERF_COUNT_HW_CPU_CYCLES.
    
    Because we only support one ips-to-build_id lookup per cpu in NMI
    context, stack_amap will not be able to do the lookup in this test.
    Therefore, we didn't do compare_stack_ips(), as it will alwasy fail.
    
    urandom_read.c is extended to run configurable cycles so that it can be
    caught by the perf event.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/testing/selftests/bpf/urandom_read.c b/tools/testing/selftests/bpf/urandom_read.c
index 4acfdebf36fa..9de8b7cb4e6d 100644
--- a/tools/testing/selftests/bpf/urandom_read.c
+++ b/tools/testing/selftests/bpf/urandom_read.c
@@ -6,15 +6,21 @@
 #include <stdlib.h>
 
 #define BUF_SIZE 256
-int main(void)
+
+int main(int argc, char *argv[])
 {
 	int fd = open("/dev/urandom", O_RDONLY);
 	int i;
 	char buf[BUF_SIZE];
+	int count = 4;
 
 	if (fd < 0)
 		return 1;
-	for (i = 0; i < 4; ++i)
+
+	if (argc == 2)
+		count = atoi(argv[1]);
+
+	for (i = 0; i < count; ++i)
 		read(fd, buf, BUF_SIZE);
 
 	close(fd);

commit 81f77fd0deeb866d65ccc79733df8d2af5217c82
Author: Song Liu <songliubraving@fb.com>
Date:   Wed Mar 14 10:23:22 2018 -0700

    bpf: add selftest for stackmap with BPF_F_STACK_BUILD_ID
    
    test_stacktrace_build_id() is added. It accesses tracepoint urandom_read
    with "dd" and "urandom_read" and gathers stack traces. Then it reads the
    stack traces from the stackmap.
    
    urandom_read is a statically link binary that reads from /dev/urandom.
    test_stacktrace_build_id() calls readelf to read build ID of urandom_read
    and compares it with build ID from the stackmap.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/tools/testing/selftests/bpf/urandom_read.c b/tools/testing/selftests/bpf/urandom_read.c
new file mode 100644
index 000000000000..4acfdebf36fa
--- /dev/null
+++ b/tools/testing/selftests/bpf/urandom_read.c
@@ -0,0 +1,22 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+
+#define BUF_SIZE 256
+int main(void)
+{
+	int fd = open("/dev/urandom", O_RDONLY);
+	int i;
+	char buf[BUF_SIZE];
+
+	if (fd < 0)
+		return 1;
+	for (i = 0; i < 4; ++i)
+		read(fd, buf, BUF_SIZE);
+
+	close(fd);
+	return 0;
+}
