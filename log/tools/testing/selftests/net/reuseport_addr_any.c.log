commit 83a9b6f639e9f6b632337f9776de17d51d969c77
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Wed Mar 18 18:53:21 2020 +0000

    selftests/net: add definition for SOL_DCCP to fix compilation errors for old libc
    
    Many systems build/test up-to-date kernels with older libcs, and
    an older glibc (2.17) lacks the definition of SOL_DCCP in
    /usr/include/bits/socket.h (it was added in the 4.6 timeframe).
    
    Adding the definition to the test program avoids a compilation
    failure that gets in the way of building tools/testing/selftests/net.
    The test itself will work once the definition is added; either
    skipping due to DCCP not being configured in the kernel under test
    or passing, so there are no other more up-to-date glibc dependencies
    here it seems beyond that missing definition.
    
    Fixes: 11fb60d1089f ("selftests: net: reuseport_addr_any: add DCCP")
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/testing/selftests/net/reuseport_addr_any.c b/tools/testing/selftests/net/reuseport_addr_any.c
index c6233935fed1..b8475cb29be7 100644
--- a/tools/testing/selftests/net/reuseport_addr_any.c
+++ b/tools/testing/selftests/net/reuseport_addr_any.c
@@ -21,6 +21,10 @@
 #include <sys/socket.h>
 #include <unistd.h>
 
+#ifndef SOL_DCCP
+#define SOL_DCCP 269
+#endif
+
 static const char *IP4_ADDR = "127.0.0.1";
 static const char *IP6_ADDR = "::1";
 static const char *IP4_MAPPED6 = "::ffff:127.0.0.1";

commit fa2323325e8b0c61ded1e3d2c6f12f3aa43c4e30
Author: Peter Oskolkov <posk@google.com>
Date:   Thu Dec 20 16:41:52 2018 -0800

    selftests: net: reuseport_addr_any: silence clang warning
    
    Clang does not recognize that calls to error() terminate execution
    and complains about uninitialized variable use that happens after calls
    to error(). This noop patchset fixes this.
    
    Signed-off-by: Peter Oskolkov <posk@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/testing/selftests/net/reuseport_addr_any.c b/tools/testing/selftests/net/reuseport_addr_any.c
index 6f54d425dba9..c6233935fed1 100644
--- a/tools/testing/selftests/net/reuseport_addr_any.c
+++ b/tools/testing/selftests/net/reuseport_addr_any.c
@@ -60,6 +60,11 @@ static void build_rcv_fd(int family, int proto, int *rcv_fds, int count,
 		break;
 	default:
 		error(1, 0, "Unsupported family %d", family);
+		/* clang does not recognize error() above as terminating
+		 * the program, so it complains that saddr, sz are
+		 * not initialized when this code path is taken. Silence it.
+		 */
+		return;
 	}
 
 	for (i = 0; i < count; ++i) {
@@ -128,6 +133,11 @@ static int connect_and_send(int family, int proto)
 	break;
 	default:
 		error(1, 0, "Unsupported family %d", family);
+		/* clang does not recognize error() above as terminating
+		 * the program, so it complains that saddr, daddr, sz are
+		 * not initialized when this code path is taken. Silence it.
+		 */
+		return -1;
 	}
 
 	fd = socket(family, proto, 0);

commit 3f2eadb10886340f4d67fe683c2e53b4df005461
Author: Peter Oskolkov <posk@google.com>
Date:   Wed Dec 19 10:20:09 2018 -0800

    selftests: net: refactor reuseport_addr_any test
    
    This patch refactors reuseport_add_any selftest a bit:
    - makes it more modular (eliminates several copy/pasted blocks);
    - skips DCCP tests if DCCP is not supported
    
    V2: added "Signed-off-by" tag.
    
    Signed-off-by: Peter Oskolkov <posk@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/testing/selftests/net/reuseport_addr_any.c b/tools/testing/selftests/net/reuseport_addr_any.c
index 4ac3e24b7cfc..6f54d425dba9 100644
--- a/tools/testing/selftests/net/reuseport_addr_any.c
+++ b/tools/testing/selftests/net/reuseport_addr_any.c
@@ -203,7 +203,9 @@ static void test(int *rcv_fds, int count, int family, int proto, int fd)
 	close(epfd);
 }
 
-int main(void)
+
+static void run_one_test(int fam_send, int fam_rcv, int proto,
+			 const char *addr_str)
 {
 	/* Below we test that a socket listening on a specific address
 	 * is always selected in preference over a socket listening
@@ -214,95 +216,48 @@ int main(void)
 	 */
 	int rcv_fds[10], i;
 
-	fprintf(stderr, "---- UDP IPv4 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 4, 1, IP4_ADDR);
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_DGRAM, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
-
-	fprintf(stderr, "---- UDP IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 4, 1, IP6_ADDR);
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET6, SOCK_DGRAM, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
-
-	fprintf(stderr, "---- UDP IPv4 mapped to IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 4, 1, IP4_MAPPED6);
-	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_DGRAM, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
-
-	fprintf(stderr, "---- TCP IPv4 ----\n");
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 4, 1, IP4_ADDR);
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_STREAM, rcv_fds[4]);
+	build_rcv_fd(AF_INET, proto, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, proto, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(fam_rcv, proto, rcv_fds + 4, 1, addr_str);
+	build_rcv_fd(AF_INET, proto, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, proto, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, fam_send, proto, rcv_fds[4]);
 	for (i = 0; i < 9; ++i)
 		close(rcv_fds[i]);
+	fprintf(stderr, "pass\n");
+}
 
-	fprintf(stderr, "---- TCP IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 4, 1, IP6_ADDR);
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET6, SOCK_STREAM, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
+static void test_proto(int proto, const char *proto_str)
+{
+	if (proto == SOCK_DCCP) {
+		int test_fd;
+
+		test_fd = socket(AF_INET, proto, 0);
+		if (test_fd < 0) {
+			if (errno == ESOCKTNOSUPPORT) {
+				fprintf(stderr, "DCCP not supported: skipping DCCP tests\n");
+				return;
+			} else
+				error(1, errno, "failed to create a DCCP socket");
+		}
+		close(test_fd);
+	}
 
-	fprintf(stderr, "---- TCP IPv4 mapped to IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 4, 1, IP4_MAPPED6);
-	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_STREAM, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
+	fprintf(stderr, "%s IPv4 ... ", proto_str);
+	run_one_test(AF_INET, AF_INET, proto, IP4_ADDR);
 
-	fprintf(stderr, "---- DCCP IPv4 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 4, 1, IP4_ADDR);
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_DCCP, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
+	fprintf(stderr, "%s IPv6 ... ", proto_str);
+	run_one_test(AF_INET6, AF_INET6, proto, IP6_ADDR);
 
-	fprintf(stderr, "---- DCCP IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 4, 1, IP6_ADDR);
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET6, SOCK_DCCP, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
+	fprintf(stderr, "%s IPv4 mapped to IPv6 ... ", proto_str);
+	run_one_test(AF_INET, AF_INET6, proto, IP4_MAPPED6);
+}
 
-	fprintf(stderr, "---- DCCP IPv4 mapped to IPv6 ----\n");
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 4, 1, IP4_MAPPED6);
-	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
-	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
-	test(rcv_fds, 9, AF_INET, SOCK_DCCP, rcv_fds[4]);
-	for (i = 0; i < 9; ++i)
-		close(rcv_fds[i]);
+int main(void)
+{
+	test_proto(SOCK_DGRAM, "UDP");
+	test_proto(SOCK_STREAM, "TCP");
+	test_proto(SOCK_DCCP, "DCCP");
 
 	fprintf(stderr, "SUCCESS\n");
 	return 0;

commit 11fb60d1089f52dd9003d02cf2590c9b56eda840
Author: Peter Oskolkov <posk@google.com>
Date:   Sat Dec 15 14:27:24 2018 -0800

    selftests: net: reuseport_addr_any: add DCCP
    
    This patch adds coverage of DCCP to reuseport_addr_any selftest.
    
    Signed-off-by: Peter Oskolkov <posk@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/testing/selftests/net/reuseport_addr_any.c b/tools/testing/selftests/net/reuseport_addr_any.c
index f5e01d989519..4ac3e24b7cfc 100644
--- a/tools/testing/selftests/net/reuseport_addr_any.c
+++ b/tools/testing/selftests/net/reuseport_addr_any.c
@@ -9,6 +9,7 @@
 #include <arpa/inet.h>
 #include <errno.h>
 #include <error.h>
+#include <linux/dccp.h>
 #include <linux/in.h>
 #include <linux/unistd.h>
 #include <stdbool.h>
@@ -75,7 +76,16 @@ static void build_rcv_fd(int family, int proto, int *rcv_fds, int count,
 			error(1, errno, "failed to bind receive socket");
 
 		if (proto == SOCK_STREAM && listen(rcv_fds[i], 10))
-			error(1, errno, "failed to listen on receive port");
+			error(1, errno, "tcp: failed to listen on receive port");
+		else if (proto == SOCK_DCCP) {
+			if (setsockopt(rcv_fds[i], SOL_DCCP,
+					DCCP_SOCKOPT_SERVICE,
+					&(int) {htonl(42)}, sizeof(int)))
+				error(1, errno, "failed to setsockopt");
+
+			if (listen(rcv_fds[i], 10))
+				error(1, errno, "dccp: failed to listen on receive port");
+		}
 	}
 }
 
@@ -124,6 +134,11 @@ static int connect_and_send(int family, int proto)
 	if (fd < 0)
 		error(1, errno, "failed to create send socket");
 
+	if (proto == SOCK_DCCP &&
+		setsockopt(fd, SOL_DCCP, DCCP_SOCKOPT_SERVICE,
+				&(int){htonl(42)}, sizeof(int)))
+		error(1, errno, "failed to setsockopt");
+
 	if (bind(fd, saddr, sz))
 		error(1, errno, "failed to bind send socket");
 
@@ -146,7 +161,7 @@ static int receive_once(int epfd, int proto)
 	if (i < 0)
 		error(1, errno, "epoll_wait failed");
 
-	if (proto == SOCK_STREAM) {
+	if (proto == SOCK_STREAM || proto == SOCK_DCCP) {
 		fd = accept(ev.data.fd, NULL, NULL);
 		if (fd < 0)
 			error(1, errno, "failed to accept");
@@ -259,6 +274,36 @@ int main(void)
 	for (i = 0; i < 9; ++i)
 		close(rcv_fds[i]);
 
+	fprintf(stderr, "---- DCCP IPv4 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 4, 1, IP4_ADDR);
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_DCCP, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- DCCP IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 4, 1, IP6_ADDR);
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET6, SOCK_DCCP, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- DCCP IPv4 mapped to IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 4, 1, IP4_MAPPED6);
+	build_rcv_fd(AF_INET, SOCK_DCCP, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DCCP, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_DCCP, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
 	fprintf(stderr, "SUCCESS\n");
 	return 0;
 }

commit 6254e5c6a8d7c19e51e671e2648de2db06f8d504
Author: Peter Oskolkov <posk@google.com>
Date:   Wed Dec 12 13:15:37 2018 -0800

    selftests: net: test that listening sockets match on address properly
    
    This patch adds a selftest that verifies that a socket listening
    on a specific address is chosen in preference over sockets
    that listen on any address. The test covers UDP/UDP6/TCP/TCP6.
    
    It is based on, and similar to, reuseport_dualstack.c selftest.
    
    Signed-off-by: Peter Oskolkov <posk@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/tools/testing/selftests/net/reuseport_addr_any.c b/tools/testing/selftests/net/reuseport_addr_any.c
new file mode 100644
index 000000000000..f5e01d989519
--- /dev/null
+++ b/tools/testing/selftests/net/reuseport_addr_any.c
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* Test that sockets listening on a specific address are preferred
+ * over sockets listening on addr_any.
+ */
+
+#define _GNU_SOURCE
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <error.h>
+#include <linux/in.h>
+#include <linux/unistd.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/epoll.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+static const char *IP4_ADDR = "127.0.0.1";
+static const char *IP6_ADDR = "::1";
+static const char *IP4_MAPPED6 = "::ffff:127.0.0.1";
+
+static const int PORT = 8888;
+
+static void build_rcv_fd(int family, int proto, int *rcv_fds, int count,
+			 const char *addr_str)
+{
+	struct sockaddr_in  addr4 = {0};
+	struct sockaddr_in6 addr6 = {0};
+	struct sockaddr *addr;
+	int opt, i, sz;
+
+	memset(&addr, 0, sizeof(addr));
+
+	switch (family) {
+	case AF_INET:
+		addr4.sin_family = family;
+		if (!addr_str)
+			addr4.sin_addr.s_addr = htonl(INADDR_ANY);
+		else if (!inet_pton(family, addr_str, &addr4.sin_addr.s_addr))
+			error(1, errno, "inet_pton failed: %s", addr_str);
+		addr4.sin_port = htons(PORT);
+		sz = sizeof(addr4);
+		addr = (struct sockaddr *)&addr4;
+		break;
+	case AF_INET6:
+		addr6.sin6_family = AF_INET6;
+		if (!addr_str)
+			addr6.sin6_addr = in6addr_any;
+		else if (!inet_pton(family, addr_str, &addr6.sin6_addr))
+			error(1, errno, "inet_pton failed: %s", addr_str);
+		addr6.sin6_port = htons(PORT);
+		sz = sizeof(addr6);
+		addr = (struct sockaddr *)&addr6;
+		break;
+	default:
+		error(1, 0, "Unsupported family %d", family);
+	}
+
+	for (i = 0; i < count; ++i) {
+		rcv_fds[i] = socket(family, proto, 0);
+		if (rcv_fds[i] < 0)
+			error(1, errno, "failed to create receive socket");
+
+		opt = 1;
+		if (setsockopt(rcv_fds[i], SOL_SOCKET, SO_REUSEPORT, &opt,
+			       sizeof(opt)))
+			error(1, errno, "failed to set SO_REUSEPORT");
+
+		if (bind(rcv_fds[i], addr, sz))
+			error(1, errno, "failed to bind receive socket");
+
+		if (proto == SOCK_STREAM && listen(rcv_fds[i], 10))
+			error(1, errno, "failed to listen on receive port");
+	}
+}
+
+static int connect_and_send(int family, int proto)
+{
+	struct sockaddr_in  saddr4 = {0};
+	struct sockaddr_in  daddr4 = {0};
+	struct sockaddr_in6 saddr6 = {0};
+	struct sockaddr_in6 daddr6 = {0};
+	struct sockaddr *saddr, *daddr;
+	int fd, sz;
+
+	switch (family) {
+	case AF_INET:
+		saddr4.sin_family = AF_INET;
+		saddr4.sin_addr.s_addr = htonl(INADDR_ANY);
+		saddr4.sin_port = 0;
+
+		daddr4.sin_family = AF_INET;
+		if (!inet_pton(family, IP4_ADDR, &daddr4.sin_addr.s_addr))
+			error(1, errno, "inet_pton failed: %s", IP4_ADDR);
+		daddr4.sin_port = htons(PORT);
+
+		sz = sizeof(saddr4);
+		saddr = (struct sockaddr *)&saddr4;
+		daddr = (struct sockaddr *)&daddr4;
+	break;
+	case AF_INET6:
+		saddr6.sin6_family = AF_INET6;
+		saddr6.sin6_addr = in6addr_any;
+
+		daddr6.sin6_family = AF_INET6;
+		if (!inet_pton(family, IP6_ADDR, &daddr6.sin6_addr))
+			error(1, errno, "inet_pton failed: %s", IP6_ADDR);
+		daddr6.sin6_port = htons(PORT);
+
+		sz = sizeof(saddr6);
+		saddr = (struct sockaddr *)&saddr6;
+		daddr = (struct sockaddr *)&daddr6;
+	break;
+	default:
+		error(1, 0, "Unsupported family %d", family);
+	}
+
+	fd = socket(family, proto, 0);
+	if (fd < 0)
+		error(1, errno, "failed to create send socket");
+
+	if (bind(fd, saddr, sz))
+		error(1, errno, "failed to bind send socket");
+
+	if (connect(fd, daddr, sz))
+		error(1, errno, "failed to connect send socket");
+
+	if (send(fd, "a", 1, 0) < 0)
+		error(1, errno, "failed to send message");
+
+	return fd;
+}
+
+static int receive_once(int epfd, int proto)
+{
+	struct epoll_event ev;
+	int i, fd;
+	char buf[8];
+
+	i = epoll_wait(epfd, &ev, 1, 3);
+	if (i < 0)
+		error(1, errno, "epoll_wait failed");
+
+	if (proto == SOCK_STREAM) {
+		fd = accept(ev.data.fd, NULL, NULL);
+		if (fd < 0)
+			error(1, errno, "failed to accept");
+		i = recv(fd, buf, sizeof(buf), 0);
+		close(fd);
+	} else {
+		i = recv(ev.data.fd, buf, sizeof(buf), 0);
+	}
+
+	if (i < 0)
+		error(1, errno, "failed to recv");
+
+	return ev.data.fd;
+}
+
+static void test(int *rcv_fds, int count, int family, int proto, int fd)
+{
+	struct epoll_event ev;
+	int epfd, i, send_fd, recv_fd;
+
+	epfd = epoll_create(1);
+	if (epfd < 0)
+		error(1, errno, "failed to create epoll");
+
+	ev.events = EPOLLIN;
+	for (i = 0; i < count; ++i) {
+		ev.data.fd = rcv_fds[i];
+		if (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fds[i], &ev))
+			error(1, errno, "failed to register sock epoll");
+	}
+
+	send_fd = connect_and_send(family, proto);
+
+	recv_fd = receive_once(epfd, proto);
+	if (recv_fd != fd)
+		error(1, 0, "received on an unexpected socket");
+
+	close(send_fd);
+	close(epfd);
+}
+
+int main(void)
+{
+	/* Below we test that a socket listening on a specific address
+	 * is always selected in preference over a socket listening
+	 * on addr_any. Bugs where this is not the case often result
+	 * in sockets created first or last to get picked. So below
+	 * we make sure that there are always addr_any sockets created
+	 * before and after a specific socket is created.
+	 */
+	int rcv_fds[10], i;
+
+	fprintf(stderr, "---- UDP IPv4 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 4, 1, IP4_ADDR);
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_DGRAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- UDP IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 4, 1, IP6_ADDR);
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET6, SOCK_DGRAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- UDP IPv4 mapped to IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 4, 1, IP4_MAPPED6);
+	build_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_DGRAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- TCP IPv4 ----\n");
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 4, 1, IP4_ADDR);
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_STREAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- TCP IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 4, 1, IP6_ADDR);
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET6, SOCK_STREAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "---- TCP IPv4 mapped to IPv6 ----\n");
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 2, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 4, 1, IP4_MAPPED6);
+	build_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds + 5, 2, NULL);
+	build_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds + 7, 2, NULL);
+	test(rcv_fds, 9, AF_INET, SOCK_STREAM, rcv_fds[4]);
+	for (i = 0; i < 9; ++i)
+		close(rcv_fds[i]);
+
+	fprintf(stderr, "SUCCESS\n");
+	return 0;
+}
