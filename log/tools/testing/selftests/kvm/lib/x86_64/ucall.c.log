commit 90a48843a18663a25aa70c6d717d38a4443e5e29
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Sep 25 15:12:42 2019 +0200

    KVM: selftests: fix ucall on x86
    
    After commit e8bb4755eea2("KVM: selftests: Split ucall.c into architecture
    specific files") selftests which use ucall on x86 started segfaulting and
    apparently it's gcc to blame: it "optimizes" ucall() function throwing away
    va_start/va_end part because it thinks the structure is not being used.
    Previously, it couldn't do that because the there was also MMIO version and
    the decision which particular implementation to use was done at runtime.
    
    With older gccs it's possible to solve the problem by adding 'volatile'
    to 'struct ucall' but at least with gcc-8.3 this trick doesn't work.
    
    'memory' clobber seems to do the job.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/tools/testing/selftests/kvm/lib/x86_64/ucall.c b/tools/testing/selftests/kvm/lib/x86_64/ucall.c
index 4bfc9a90b1de..da4d89ad5419 100644
--- a/tools/testing/selftests/kvm/lib/x86_64/ucall.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/ucall.c
@@ -32,7 +32,7 @@ void ucall(uint64_t cmd, int nargs, ...)
 	va_end(va);
 
 	asm volatile("in %[port], %%al"
-		: : [port] "d" (UCALL_PIO_PORT), "D" (&uc) : "rax");
+		: : [port] "d" (UCALL_PIO_PORT), "D" (&uc) : "rax", "memory");
 }
 
 uint64_t get_ucall(struct kvm_vm *vm, uint32_t vcpu_id, struct ucall *uc)

commit 2040f414d12f31be3e73eb3f5048d2b1cdec48f6
Author: Thomas Huth <thuth@redhat.com>
Date:   Wed Jul 31 17:15:23 2019 +0200

    KVM: selftests: Split ucall.c into architecture specific files
    
    The way we exit from a guest to userspace is very specific to the
    architecture: On x86, we use PIO, on aarch64 we are using MMIO and on
    s390x we're going to use an instruction instead. The possibility to
    select a type via the ucall_type_t enum is currently also completely
    unused, so the code in ucall.c currently looks more complex than
    required. Let's split this up into architecture specific ucall.c
    files instead, so we can get rid of the #ifdefs and the unnecessary
    ucall_type_t handling.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Thomas Huth <thuth@redhat.com>
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Link: https://lore.kernel.org/r/20190731151525.17156-2-thuth@redhat.com
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>

diff --git a/tools/testing/selftests/kvm/lib/x86_64/ucall.c b/tools/testing/selftests/kvm/lib/x86_64/ucall.c
new file mode 100644
index 000000000000..4bfc9a90b1de
--- /dev/null
+++ b/tools/testing/selftests/kvm/lib/x86_64/ucall.c
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ucall support. A ucall is a "hypercall to userspace".
+ *
+ * Copyright (C) 2018, Red Hat, Inc.
+ */
+#include "kvm_util.h"
+
+#define UCALL_PIO_PORT ((uint16_t)0x1000)
+
+void ucall_init(struct kvm_vm *vm, void *arg)
+{
+}
+
+void ucall_uninit(struct kvm_vm *vm)
+{
+}
+
+void ucall(uint64_t cmd, int nargs, ...)
+{
+	struct ucall uc = {
+		.cmd = cmd,
+	};
+	va_list va;
+	int i;
+
+	nargs = nargs <= UCALL_MAX_ARGS ? nargs : UCALL_MAX_ARGS;
+
+	va_start(va, nargs);
+	for (i = 0; i < nargs; ++i)
+		uc.args[i] = va_arg(va, uint64_t);
+	va_end(va);
+
+	asm volatile("in %[port], %%al"
+		: : [port] "d" (UCALL_PIO_PORT), "D" (&uc) : "rax");
+}
+
+uint64_t get_ucall(struct kvm_vm *vm, uint32_t vcpu_id, struct ucall *uc)
+{
+	struct kvm_run *run = vcpu_state(vm, vcpu_id);
+	struct ucall ucall = {};
+
+	if (run->exit_reason == KVM_EXIT_IO && run->io.port == UCALL_PIO_PORT) {
+		struct kvm_regs regs;
+
+		vcpu_regs_get(vm, vcpu_id, &regs);
+		memcpy(&ucall, addr_gva2hva(vm, (vm_vaddr_t)regs.rdi),
+		       sizeof(ucall));
+
+		vcpu_run_complete_io(vm, vcpu_id);
+		if (uc)
+			memcpy(uc, &ucall, sizeof(ucall));
+	}
+
+	return ucall.cmd;
+}
