commit 9a0584f05687947d5a0b87f046bcd2592a55e67c
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Thu Feb 13 18:26:56 2020 +1100

    selftests: openat2: fix build error on newer glibc
    
    It appears that newer glibcs check that openat(O_CREAT) was provided a
    fourth argument (rather than passing garbage), resulting in the
    following build error:
    
    > In file included from /usr/include/fcntl.h:301,
    >                  from helpers.c:9:
    > In function 'openat',
    >     inlined from 'touchat' at helpers.c:49:11:
    > /usr/include/x86_64-linux-gnu/bits/fcntl2.h:126:4: error: call to
    > '__openat_missing_mode' declared with attribute error: openat with O_CREAT
    > or O_TMPFILE in third argument needs 4 arguments
    >   126 |    __openat_missing_mode ();
    >       |    ^~~~~~~~~~~~~~~~~~~~~~~~
    
    Reported-by: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/testing/selftests/openat2/helpers.c b/tools/testing/selftests/openat2/helpers.c
index e9a6557ab16f..5074681ffdc9 100644
--- a/tools/testing/selftests/openat2/helpers.c
+++ b/tools/testing/selftests/openat2/helpers.c
@@ -46,7 +46,7 @@ int sys_renameat2(int olddirfd, const char *oldpath,
 
 int touchat(int dfd, const char *path)
 {
-	int fd = openat(dfd, path, O_CREAT);
+	int fd = openat(dfd, path, O_CREAT, 0700);
 	if (fd >= 0)
 		close(fd);
 	return fd;

commit b28a10aedcd4d175470171a32f4f20b0a60a612b
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Jan 18 23:08:00 2020 +1100

    selftests: add openat2(2) selftests
    
    Test all of the various openat2(2) flags. A small stress-test of a
    symlink-rename attack is included to show that the protections against
    ".."-based attacks are sufficient.
    
    The main things these self-tests are enforcing are:
    
      * The struct+usize ABI for openat2(2) and copy_struct_from_user() to
        ensure that upgrades will be handled gracefully (in addition,
        ensuring that misaligned structures are also handled correctly).
    
      * The -EINVAL checks for openat2(2) are all correctly handled to avoid
        userspace passing unknown or conflicting flag sets (most
        importantly, ensuring that invalid flag combinations are checked).
    
      * All of the RESOLVE_* semantics (including errno values) are
        correctly handled with various combinations of paths and flags.
    
      * RESOLVE_IN_ROOT correctly protects against the symlink rename(2)
        attack that has been responsible for several CVEs (and likely will
        be responsible for several more).
    
    Cc: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/tools/testing/selftests/openat2/helpers.c b/tools/testing/selftests/openat2/helpers.c
new file mode 100644
index 000000000000..e9a6557ab16f
--- /dev/null
+++ b/tools/testing/selftests/openat2/helpers.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Author: Aleksa Sarai <cyphar@cyphar.com>
+ * Copyright (C) 2018-2019 SUSE LLC.
+ */
+
+#define _GNU_SOURCE
+#include <errno.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <string.h>
+#include <syscall.h>
+#include <limits.h>
+
+#include "helpers.h"
+
+bool needs_openat2(const struct open_how *how)
+{
+	return how->resolve != 0;
+}
+
+int raw_openat2(int dfd, const char *path, void *how, size_t size)
+{
+	int ret = syscall(__NR_openat2, dfd, path, how, size);
+	return ret >= 0 ? ret : -errno;
+}
+
+int sys_openat2(int dfd, const char *path, struct open_how *how)
+{
+	return raw_openat2(dfd, path, how, sizeof(*how));
+}
+
+int sys_openat(int dfd, const char *path, struct open_how *how)
+{
+	int ret = openat(dfd, path, how->flags, how->mode);
+	return ret >= 0 ? ret : -errno;
+}
+
+int sys_renameat2(int olddirfd, const char *oldpath,
+		  int newdirfd, const char *newpath, unsigned int flags)
+{
+	int ret = syscall(__NR_renameat2, olddirfd, oldpath,
+					  newdirfd, newpath, flags);
+	return ret >= 0 ? ret : -errno;
+}
+
+int touchat(int dfd, const char *path)
+{
+	int fd = openat(dfd, path, O_CREAT);
+	if (fd >= 0)
+		close(fd);
+	return fd;
+}
+
+char *fdreadlink(int fd)
+{
+	char *target, *tmp;
+
+	E_asprintf(&tmp, "/proc/self/fd/%d", fd);
+
+	target = malloc(PATH_MAX);
+	if (!target)
+		ksft_exit_fail_msg("fdreadlink: malloc failed\n");
+	memset(target, 0, PATH_MAX);
+
+	E_readlink(tmp, target, PATH_MAX);
+	free(tmp);
+	return target;
+}
+
+bool fdequal(int fd, int dfd, const char *path)
+{
+	char *fdpath, *dfdpath, *other;
+	bool cmp;
+
+	fdpath = fdreadlink(fd);
+	dfdpath = fdreadlink(dfd);
+
+	if (!path)
+		E_asprintf(&other, "%s", dfdpath);
+	else if (*path == '/')
+		E_asprintf(&other, "%s", path);
+	else
+		E_asprintf(&other, "%s/%s", dfdpath, path);
+
+	cmp = !strcmp(fdpath, other);
+
+	free(fdpath);
+	free(dfdpath);
+	free(other);
+	return cmp;
+}
+
+bool openat2_supported = false;
+
+void __attribute__((constructor)) init(void)
+{
+	struct open_how how = {};
+	int fd;
+
+	BUILD_BUG_ON(sizeof(struct open_how) != OPEN_HOW_SIZE_VER0);
+
+	/* Check openat2(2) support. */
+	fd = sys_openat2(AT_FDCWD, ".", &how);
+	openat2_supported = (fd >= 0);
+
+	if (fd >= 0)
+		close(fd);
+}
