commit 332e0e804d64894cf32db363e7f14c64a6ce8061
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 5 15:50:42 2019 -0800

    proc: more robust bulk read test
    
    /proc may not be mounted and test will exit successfully.
    
    Ensure proc is mounted at /proc.
    
    Link: http://lkml.kernel.org/r/20190209105613.GA10384@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/read.c b/tools/testing/selftests/proc/read.c
index b2bd8da58efe..b3ef9e14d6cc 100644
--- a/tools/testing/selftests/proc/read.c
+++ b/tools/testing/selftests/proc/read.c
@@ -26,8 +26,10 @@
 #include <dirent.h>
 #include <stdbool.h>
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
 #include <sys/stat.h>
+#include <sys/vfs.h>
 #include <fcntl.h>
 #include <unistd.h>
 
@@ -123,10 +125,22 @@ static void f(DIR *d, unsigned int level)
 int main(void)
 {
 	DIR *d;
+	struct statfs sfs;
 
 	d = opendir("/proc");
 	if (!d)
 		return 4;
+
+	/* Ensure /proc is proc. */
+	if (fstatfs(dirfd(d), &sfs) == -1) {
+		return 1;
+	}
+	if (sfs.f_type != 0x9fa0) {
+		fprintf(stderr, "error: unexpected f_type %lx\n", (long)sfs.f_type);
+		return 2;
+	}
+
 	f(d, 0);
+
 	return 0;
 }

commit 0338c838367b7993edd1c154789c563c13a3b35e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 5 15:50:18 2019 -0800

    proc: return exit code 4 for skipped tests
    
    Test harness uses 4 for SKIP, not 2.
    
    Link: http://lkml.kernel.org/r/20190108193108.GA12259@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/read.c b/tools/testing/selftests/proc/read.c
index 563e752e6eba..b2bd8da58efe 100644
--- a/tools/testing/selftests/proc/read.c
+++ b/tools/testing/selftests/proc/read.c
@@ -126,7 +126,7 @@ int main(void)
 
 	d = opendir("/proc");
 	if (!d)
-		return 2;
+		return 4;
 	f(d, 0);
 	return 0;
 }

commit b2f5de0334f03e90ae7dee72a7fc597ef555a9a8
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Jun 7 17:10:20 2018 -0700

    tools/testing/selftests/proc: test /proc/*/fd a bit (+ PF_KTHREAD is ABI!)
    
    * Test lookup in /proc/self/fd.
      "map_files" lookup story showed that lookup is not that simple.
    
    * Test that all those symlinks open the same file.
      Check with (st_dev, st_info).
    
    * Test that kernel threads do not have anything in their /proc/*/fd/
      directory.
    
    Now this is where things get interesting.
    
    First, kernel threads aren't pinned by /proc/self or equivalent,
    thus some "atomicity" is required.
    
    Second, ->comm can contain whitespace and ')'.
    No, they are not escaped.
    
    Third, the only reliable way to check if process is kernel thread
    appears to be field #9 in /proc/*/stat.
    
    This field is struct task_struct::flags in decimal!
    Check is done by testing PF_KTHREAD flags like we do in kernel.
    
            PF_KTREAD value is a part of userspace ABI !!!
    
    Other methods for determining kernel threadness are not reliable:
    * RSS can be 0 if everything is swapped, even while reading
      from /proc/self.
    
    * ->total_vm CAN BE ZERO if process is finishing
    
            munmap(NULL, whole address space);
    
    * /proc/*/maps and similar files can be empty because unmapping
      everything works. Read returning 0 can't distinguish between
      kernel thread and such suicide process.
    
    Link: http://lkml.kernel.org/r/20180505000414.GA15090@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/read.c b/tools/testing/selftests/proc/read.c
index 1e73c2232097..563e752e6eba 100644
--- a/tools/testing/selftests/proc/read.c
+++ b/tools/testing/selftests/proc/read.c
@@ -31,22 +31,7 @@
 #include <fcntl.h>
 #include <unistd.h>
 
-static inline bool streq(const char *s1, const char *s2)
-{
-	return strcmp(s1, s2) == 0;
-}
-
-static struct dirent *xreaddir(DIR *d)
-{
-	struct dirent *de;
-
-	errno = 0;
-	de = readdir(d);
-	if (!de && errno != 0) {
-		exit(1);
-	}
-	return de;
-}
+#include "proc.h"
 
 static void f_reg(DIR *d, const char *filename)
 {

commit ee9294d6ddbd418807ae49f4ab4e6441c9da2a18
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Apr 12 23:31:17 2018 +0300

    proc: fixup copyright sign
    
    Add copyright in two files before they get autorubberstamped.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/read.c b/tools/testing/selftests/proc/read.c
index 12e397f78592..1e73c2232097 100644
--- a/tools/testing/selftests/proc/read.c
+++ b/tools/testing/selftests/proc/read.c
@@ -1,5 +1,5 @@
 /*
- * Copyright _ 2018 Alexey Dobriyan <adobriyan@gmail.com>
+ * Copyright Â© 2018 Alexey Dobriyan <adobriyan@gmail.com>
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above

commit 05c3f29283af9e3da0ab7414f666cb37f530950a
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 10 16:46:19 2018 -0700

    proc: selftests: shotgun testing of read/readdir/readlink/write
    
    Perform reads with nearly everything in /proc, and some writing as well.
    
    Hopefully memleak checkers and KASAN will find something.
    
    [adobriyan@gmail.com: /proc/kmsg can and will block if read under root]
      Link: http://lkml.kernel.org/r/20180316232147.GA20146@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    [adobriyan@gmail.com: /proc/sysrq-trigger lives on the ground floor]
      Link: http://lkml.kernel.org/r/20180317164911.GA3445@avx2
    Link: http://lkml.kernel.org/r/20180315201251.GA12396@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/read.c b/tools/testing/selftests/proc/read.c
new file mode 100644
index 000000000000..12e397f78592
--- /dev/null
+++ b/tools/testing/selftests/proc/read.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright _ 2018 Alexey Dobriyan <adobriyan@gmail.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+// Test
+// 1) read of every file in /proc
+// 2) readlink of every symlink in /proc
+// 3) recursively (1) + (2) for every directory in /proc
+// 4) write to /proc/*/clear_refs and /proc/*/task/*/clear_refs
+// 5) write to /proc/sysrq-trigger
+#undef NDEBUG
+#include <assert.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+static inline bool streq(const char *s1, const char *s2)
+{
+	return strcmp(s1, s2) == 0;
+}
+
+static struct dirent *xreaddir(DIR *d)
+{
+	struct dirent *de;
+
+	errno = 0;
+	de = readdir(d);
+	if (!de && errno != 0) {
+		exit(1);
+	}
+	return de;
+}
+
+static void f_reg(DIR *d, const char *filename)
+{
+	char buf[4096];
+	int fd;
+	ssize_t rv;
+
+	/* read from /proc/kmsg can block */
+	fd = openat(dirfd(d), filename, O_RDONLY|O_NONBLOCK);
+	if (fd == -1)
+		return;
+	rv = read(fd, buf, sizeof(buf));
+	assert((0 <= rv && rv <= sizeof(buf)) || rv == -1);
+	close(fd);
+}
+
+static void f_reg_write(DIR *d, const char *filename, const char *buf, size_t len)
+{
+	int fd;
+	ssize_t rv;
+
+	fd = openat(dirfd(d), filename, O_WRONLY);
+	if (fd == -1)
+		return;
+	rv = write(fd, buf, len);
+	assert((0 <= rv && rv <= len) || rv == -1);
+	close(fd);
+}
+
+static void f_lnk(DIR *d, const char *filename)
+{
+	char buf[4096];
+	ssize_t rv;
+
+	rv = readlinkat(dirfd(d), filename, buf, sizeof(buf));
+	assert((0 <= rv && rv <= sizeof(buf)) || rv == -1);
+}
+
+static void f(DIR *d, unsigned int level)
+{
+	struct dirent *de;
+
+	de = xreaddir(d);
+	assert(de->d_type == DT_DIR);
+	assert(streq(de->d_name, "."));
+
+	de = xreaddir(d);
+	assert(de->d_type == DT_DIR);
+	assert(streq(de->d_name, ".."));
+
+	while ((de = xreaddir(d))) {
+		assert(!streq(de->d_name, "."));
+		assert(!streq(de->d_name, ".."));
+
+		switch (de->d_type) {
+			DIR *dd;
+			int fd;
+
+		case DT_REG:
+			if (level == 0 && streq(de->d_name, "sysrq-trigger")) {
+				f_reg_write(d, de->d_name, "h", 1);
+			} else if (level == 1 && streq(de->d_name, "clear_refs")) {
+				f_reg_write(d, de->d_name, "1", 1);
+			} else if (level == 3 && streq(de->d_name, "clear_refs")) {
+				f_reg_write(d, de->d_name, "1", 1);
+			} else {
+				f_reg(d, de->d_name);
+			}
+			break;
+		case DT_DIR:
+			fd = openat(dirfd(d), de->d_name, O_DIRECTORY|O_RDONLY);
+			if (fd == -1)
+				continue;
+			dd = fdopendir(fd);
+			if (!dd)
+				continue;
+			f(dd, level + 1);
+			closedir(dd);
+			break;
+		case DT_LNK:
+			f_lnk(d, de->d_name);
+			break;
+		default:
+			assert(0);
+		}
+	}
+}
+
+int main(void)
+{
+	DIR *d;
+
+	d = opendir("/proc");
+	if (!d)
+		return 2;
+	f(d, 0);
+	return 0;
+}
