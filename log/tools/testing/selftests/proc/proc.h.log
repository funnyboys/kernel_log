commit 2cd36fb329487e9525db3ccdbac1e92053b646fa
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Aug 21 21:54:20 2018 -0700

    proc: test /proc/thread-self symlink
    
    Same story: I have WIP patch to make it faster, so better have a test
    as well.
    
    Link: http://lkml.kernel.org/r/20180627195209.GC18113@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/proc.h b/tools/testing/selftests/proc/proc.h
index 31ca4b0c007f..b7d57ea40237 100644
--- a/tools/testing/selftests/proc/proc.h
+++ b/tools/testing/selftests/proc/proc.h
@@ -14,6 +14,11 @@ static inline pid_t sys_getpid(void)
 	return syscall(SYS_getpid);
 }
 
+static inline pid_t sys_gettid(void)
+{
+	return syscall(SYS_gettid);
+}
+
 static inline bool streq(const char *s1, const char *s2)
 {
 	return strcmp(s1, s2) == 0;

commit 61d47c4e71c1f080e7412315c8685bc682a8e53a
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Aug 21 21:54:16 2018 -0700

    proc: test /proc/self symlink
    
    There are plans to change how /proc/self result is calculated,
    for that a test is necessary.
    
    Use direct system call because of this whole getpid caching story.
    
    Link: http://lkml.kernel.org/r/20180627195103.GB18113@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/proc.h b/tools/testing/selftests/proc/proc.h
index 4e178166fd84..31ca4b0c007f 100644
--- a/tools/testing/selftests/proc/proc.h
+++ b/tools/testing/selftests/proc/proc.h
@@ -6,6 +6,13 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+static inline pid_t sys_getpid(void)
+{
+	return syscall(SYS_getpid);
+}
 
 static inline bool streq(const char *s1, const char *s2)
 {

commit b2f5de0334f03e90ae7dee72a7fc597ef555a9a8
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Jun 7 17:10:20 2018 -0700

    tools/testing/selftests/proc: test /proc/*/fd a bit (+ PF_KTHREAD is ABI!)
    
    * Test lookup in /proc/self/fd.
      "map_files" lookup story showed that lookup is not that simple.
    
    * Test that all those symlinks open the same file.
      Check with (st_dev, st_info).
    
    * Test that kernel threads do not have anything in their /proc/*/fd/
      directory.
    
    Now this is where things get interesting.
    
    First, kernel threads aren't pinned by /proc/self or equivalent,
    thus some "atomicity" is required.
    
    Second, ->comm can contain whitespace and ')'.
    No, they are not escaped.
    
    Third, the only reliable way to check if process is kernel thread
    appears to be field #9 in /proc/*/stat.
    
    This field is struct task_struct::flags in decimal!
    Check is done by testing PF_KTHREAD flags like we do in kernel.
    
            PF_KTREAD value is a part of userspace ABI !!!
    
    Other methods for determining kernel threadness are not reliable:
    * RSS can be 0 if everything is swapped, even while reading
      from /proc/self.
    
    * ->total_vm CAN BE ZERO if process is finishing
    
            munmap(NULL, whole address space);
    
    * /proc/*/maps and similar files can be empty because unmapping
      everything works. Read returning 0 can't distinguish between
      kernel thread and such suicide process.
    
    Link: http://lkml.kernel.org/r/20180505000414.GA15090@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/tools/testing/selftests/proc/proc.h b/tools/testing/selftests/proc/proc.h
new file mode 100644
index 000000000000..4e178166fd84
--- /dev/null
+++ b/tools/testing/selftests/proc/proc.h
@@ -0,0 +1,39 @@
+#pragma once
+#undef NDEBUG
+#include <assert.h>
+#include <dirent.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+
+static inline bool streq(const char *s1, const char *s2)
+{
+	return strcmp(s1, s2) == 0;
+}
+
+static unsigned long long xstrtoull(const char *p, char **end)
+{
+	if (*p == '0') {
+		*end = (char *)p + 1;
+		return 0;
+	} else if ('1' <= *p && *p <= '9') {
+		unsigned long long val;
+
+		errno = 0;
+		val = strtoull(p, end, 10);
+		assert(errno == 0);
+		return val;
+	} else
+		assert(0);
+}
+
+static struct dirent *xreaddir(DIR *d)
+{
+	struct dirent *de;
+
+	errno = 0;
+	de = readdir(d);
+	assert(de || errno == 0);
+	return de;
+}
