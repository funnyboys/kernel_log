commit fa10fed30f2550313a8284365b3e2398526eb42c
Author: Alexey Gladkov <gladkov.alexey@gmail.com>
Date:   Sun Apr 19 16:10:52 2020 +0200

    proc: allow to mount many instances of proc in one pid namespace
    
    This patch allows to have multiple procfs instances inside the
    same pid namespace. The aim here is lightweight sandboxes, and to allow
    that we have to modernize procfs internals.
    
    1) The main aim of this work is to have on embedded systems one
    supervisor for apps. Right now we have some lightweight sandbox support,
    however if we create pid namespacess we have to manages all the
    processes inside too, where our goal is to be able to run a bunch of
    apps each one inside its own mount namespace without being able to
    notice each other. We only want to use mount namespaces, and we want
    procfs to behave more like a real mount point.
    
    2) Linux Security Modules have multiple ptrace paths inside some
    subsystems, however inside procfs, the implementation does not guarantee
    that the ptrace() check which triggers the security_ptrace_check() hook
    will always run. We have the 'hidepid' mount option that can be used to
    force the ptrace_may_access() check inside has_pid_permissions() to run.
    The problem is that 'hidepid' is per pid namespace and not attached to
    the mount point, any remount or modification of 'hidepid' will propagate
    to all other procfs mounts.
    
    This also does not allow to support Yama LSM easily in desktop and user
    sessions. Yama ptrace scope which restricts ptrace and some other
    syscalls to be allowed only on inferiors, can be updated to have a
    per-task context, where the context will be inherited during fork(),
    clone() and preserved across execve(). If we support multiple private
    procfs instances, then we may force the ptrace_may_access() on
    /proc/<pids>/ to always run inside that new procfs instances. This will
    allow to specifiy on user sessions if we should populate procfs with
    pids that the user can ptrace or not.
    
    By using Yama ptrace scope, some restricted users will only be able to see
    inferiors inside /proc, they won't even be able to see their other
    processes. Some software like Chromium, Firefox's crash handler, Wine
    and others are already using Yama to restrict which processes can be
    ptracable. With this change this will give the possibility to restrict
    /proc/<pids>/ but more importantly this will give desktop users a
    generic and usuable way to specifiy which users should see all processes
    and which users can not.
    
    Side notes:
    * This covers the lack of seccomp where it is not able to parse
    arguments, it is easy to install a seccomp filter on direct syscalls
    that operate on pids, however /proc/<pid>/ is a Linux ABI using
    filesystem syscalls. With this change LSMs should be able to analyze
    open/read/write/close...
    
    In the new patch set version I removed the 'newinstance' option
    as suggested by Eric W. Biederman.
    
    Selftest has been added to verify new behavior.
    
    Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
    Reviewed-by: Alexey Dobriyan <adobriyan@gmail.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/tools/testing/selftests/proc/proc-multiple-procfs.c b/tools/testing/selftests/proc/proc-multiple-procfs.c
new file mode 100644
index 000000000000..ab912ad95dab
--- /dev/null
+++ b/tools/testing/selftests/proc/proc-multiple-procfs.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright Â© 2020 Alexey Gladkov <gladkov.alexey@gmail.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+int main(void)
+{
+	struct stat proc_st1, proc_st2;
+	char procbuff[] = "/tmp/proc.XXXXXX/meminfo";
+	char procdir1[] = "/tmp/proc.XXXXXX";
+	char procdir2[] = "/tmp/proc.XXXXXX";
+
+	assert(mkdtemp(procdir1) != NULL);
+	assert(mkdtemp(procdir2) != NULL);
+
+	assert(!mount("proc", procdir1, "proc", 0, "hidepid=1"));
+	assert(!mount("proc", procdir2, "proc", 0, "hidepid=2"));
+
+	snprintf(procbuff, sizeof(procbuff), "%s/meminfo", procdir1);
+	assert(!stat(procbuff, &proc_st1));
+
+	snprintf(procbuff, sizeof(procbuff), "%s/meminfo", procdir2);
+	assert(!stat(procbuff, &proc_st2));
+
+	umount(procdir1);
+	umount(procdir2);
+
+	assert(proc_st1.st_dev != proc_st2.st_dev);
+
+	return 0;
+}
