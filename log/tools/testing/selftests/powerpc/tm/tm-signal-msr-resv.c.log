commit f50a7f3d9225dd374455f28138f79ae3074a7a3d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:18 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 191
    
    Based on 1 normalized pattern(s):
    
      licensed under gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 99 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.163048684@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
index 8c54d18b3e9a..4a61e9bd12b4 100644
--- a/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
+++ b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2015, Michael Neuling, IBM Corp.
- * Licensed under GPLv2.
  *
  * Test the kernel's signal return code to ensure that it doesn't
  * crash when both the transactional and suspend MSR bits are set in

commit 501e279c231bd8d5eed4ecea5a18dcd79d51b026
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Mar 2 23:28:54 2016 +1100

    selftests/powerpc: Fix out of bounds access in TM signal test
    
    Gcc helpfully points out that we're accessing past the end of the gprs
    array:
    
      tm-signal-msr-resv.c: In function 'signal_usr1':
      tm-signal-msr-resv.c:43:37: error: array subscript is above array bounds [-Werror=array-bounds]
        ucp->uc_mcontext.regs->gpr[PT_MSR] |= (7ULL);
    
    We haven't noticed previously because -flto was hiding it somehow.
    
    The code is confused, PT_MSR isn't a gpr, instead it's in
    uc_regs->gregs, so fix it.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
index d86653f282b1..8c54d18b3e9a 100644
--- a/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
+++ b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
@@ -40,7 +40,7 @@ void signal_usr1(int signum, siginfo_t *info, void *uc)
 #ifdef __powerpc64__
 	ucp->uc_mcontext.gp_regs[PT_MSR] |= (7ULL << 32);
 #else
-	ucp->uc_mcontext.regs->gpr[PT_MSR] |= (7ULL);
+	ucp->uc_mcontext.uc_regs->gregs[PT_MSR] |= (7ULL);
 #endif
 	/* Should segv on return becuase of invalid context */
 	segv_expected = 1;

commit 25007a69e852389985ee98235e76d740d4821c6c
Author: Michael Neuling <mikey@neuling.org>
Date:   Fri Nov 20 15:15:33 2015 +1100

    selftests/powerpc: Add TM signal return test
    
    Test the kernel's signal return code to ensure that it doesn't crash
    when both the transactional and suspend MSR bits are set in the signal
    context.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Tested-by: Anshuman Khandual <khandual@linux.vnet.ibm.com>
    [mpe: Skip if we don't have TM]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
new file mode 100644
index 000000000000..d86653f282b1
--- /dev/null
+++ b/tools/testing/selftests/powerpc/tm/tm-signal-msr-resv.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2015, Michael Neuling, IBM Corp.
+ * Licensed under GPLv2.
+ *
+ * Test the kernel's signal return code to ensure that it doesn't
+ * crash when both the transactional and suspend MSR bits are set in
+ * the signal context.
+ *
+ * For this test, we send ourselves a SIGUSR1.  In the SIGUSR1 handler
+ * we modify the signal context to set both MSR TM S and T bits (which
+ * is "reserved" by the PowerISA). When we return from the signal
+ * handler (implicit sigreturn), the kernel should detect reserved MSR
+ * value and send us with a SIGSEGV.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include "utils.h"
+#include "tm.h"
+
+int segv_expected = 0;
+
+void signal_segv(int signum)
+{
+	if (segv_expected && (signum == SIGSEGV))
+		_exit(0);
+	_exit(1);
+}
+
+void signal_usr1(int signum, siginfo_t *info, void *uc)
+{
+	ucontext_t *ucp = uc;
+
+	/* Link tm checkpointed context to normal context */
+	ucp->uc_link = ucp;
+	/* Set all TM bits so that the context is now invalid */
+#ifdef __powerpc64__
+	ucp->uc_mcontext.gp_regs[PT_MSR] |= (7ULL << 32);
+#else
+	ucp->uc_mcontext.regs->gpr[PT_MSR] |= (7ULL);
+#endif
+	/* Should segv on return becuase of invalid context */
+	segv_expected = 1;
+}
+
+int tm_signal_msr_resv()
+{
+	struct sigaction act;
+
+	SKIP_IF(!have_htm());
+
+	act.sa_sigaction = signal_usr1;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = SA_SIGINFO;
+	if (sigaction(SIGUSR1, &act, NULL) < 0) {
+		perror("sigaction sigusr1");
+		exit(1);
+	}
+	if (signal(SIGSEGV, signal_segv) == SIG_ERR)
+		exit(1);
+
+	raise(SIGUSR1);
+
+	/* We shouldn't get here as we exit in the segv handler */
+	return 1;
+}
+
+int main(void)
+{
+	return test_harness(tm_signal_msr_resv, "tm_signal_msr_resv");
+}
