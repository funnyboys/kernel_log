commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index cf868b5e00f7..b3ead29c6089 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2016 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #define _GNU_SOURCE

commit 5821ba969511daf27fa917515904f7b823259cf7
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Apr 24 16:12:37 2019 -0700

    selftests: Add test plan API to kselftest.h and adjust callers
    
    The test plan for TAP needs to be declared immediately after the header.
    This adds the test plan API to kselftest.h and updates all callers to
    declare their expected test counts.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index f82dcc1f8841..cf868b5e00f7 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -173,6 +173,7 @@ int main(int argc, char **argv)
 	int opt;
 	bool do_suspend = true;
 	bool succeeded = true;
+	unsigned int tests = 0;
 	cpu_set_t available_cpus;
 	int err;
 	int cpu;
@@ -191,6 +192,13 @@ int main(int argc, char **argv)
 		}
 	}
 
+	for (cpu = 0; cpu < CPU_SETSIZE; cpu++) {
+		if (!CPU_ISSET(cpu, &available_cpus))
+			continue;
+		tests++;
+	}
+	ksft_set_plan(tests);
+
 	if (do_suspend)
 		suspend();
 

commit 423353a11e9a36885d113722168cf4343eef4dff
Author: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Date:   Wed May 2 16:37:00 2018 -0600

    selftests: breakpoints: return Kselftest Skip code for skipped tests
    
    When step_after_suspend_test is skipped because of unmet dependencies
    and/or unsupported configuration, it exits with error which is treated
    as a fail by the Kselftest framework. This leads to false negative result
    even when the test could not be run.
    
    Change it to return kselftest skip code when a test gets skipped to clearly
    report that the test could not be run.
    
    Change it to use ksft_exit_skip() when a non-root user runs the test and
    add an explicit check for root and a clear message, instead of failing
    the test when /sys/power/state file open fails.
    
    Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index 3fece06e9f64..f82dcc1f8841 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -143,10 +143,14 @@ void suspend(void)
 	int err;
 	struct itimerspec spec = {};
 
+	if (getuid() != 0)
+		ksft_exit_skip("Please run the test as root - Exiting.\n");
+
 	power_state_fd = open("/sys/power/state", O_RDWR);
 	if (power_state_fd < 0)
 		ksft_exit_fail_msg(
-			"open(\"/sys/power/state\") failed (is this test running as root?)\n");
+			"open(\"/sys/power/state\") failed %s)\n",
+			strerror(errno));
 
 	timerfd = timerfd_create(CLOCK_BOOTTIME_ALARM, 0);
 	if (timerfd < 0)

commit 3fa72f2c784b5c05f271ab8b34116d6a8e8d108d
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Jun 29 15:37:05 2017 -0600

    selftests: breakpoints: step_after_suspend_test use ksft_* var arg msg api
    
    Use ksft_* var arg msg to include strerror() info. in test output and
    simplify test_result and exit_* using var arg msg api.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index c60c2effb6bc..3fece06e9f64 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -37,17 +37,19 @@ void child(int cpu)
 	CPU_ZERO(&set);
 	CPU_SET(cpu, &set);
 	if (sched_setaffinity(0, sizeof(set), &set) != 0) {
-		perror("sched_setaffinity() failed");
+		ksft_print_msg("sched_setaffinity() failed: %s\n",
+			strerror(errno));
 		_exit(1);
 	}
 
 	if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {
-		perror("ptrace(PTRACE_TRACEME) failed");
+		ksft_print_msg("ptrace(PTRACE_TRACEME) failed: %s\n",
+			strerror(errno));
 		_exit(1);
 	}
 
 	if (raise(SIGSTOP) != 0) {
-		perror("raise(SIGSTOP) failed");
+		ksft_print_msg("raise(SIGSTOP) failed: %s\n", strerror(errno));
 		_exit(1);
 	}
 
@@ -61,7 +63,7 @@ bool run_test(int cpu)
 	pid_t wpid;
 
 	if (pid < 0) {
-		perror("fork() failed");
+		ksft_print_msg("fork() failed: %s\n", strerror(errno));
 		return false;
 	}
 	if (pid == 0)
@@ -69,57 +71,64 @@ bool run_test(int cpu)
 
 	wpid = waitpid(pid, &status, __WALL);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg("waitpid() failed: %s\n", strerror(errno));
 		return false;
 	}
 	if (!WIFSTOPPED(status)) {
-		printf("child did not stop\n");
+		ksft_print_msg("child did not stop: %s\n", strerror(errno));
 		return false;
 	}
 	if (WSTOPSIG(status) != SIGSTOP) {
-		printf("child did not stop with SIGSTOP\n");
+		ksft_print_msg("child did not stop with SIGSTOP: %s\n",
+			strerror(errno));
 		return false;
 	}
 
 	if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0) {
 		if (errno == EIO) {
-			ksft_exit_skip("ptrace(PTRACE_SINGLESTEP) "
-				"not supported on this architecture");
+			ksft_exit_skip(
+				"ptrace(PTRACE_SINGLESTEP) not supported on this architecture: %s\n",
+				strerror(errno));
 		}
-		perror("ptrace(PTRACE_SINGLESTEP) failed");
+		ksft_print_msg("ptrace(PTRACE_SINGLESTEP) failed: %s\n",
+			strerror(errno));
 		return false;
 	}
 
 	wpid = waitpid(pid, &status, __WALL);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg("waitpid() failed: $s\n", strerror(errno));
 		return false;
 	}
 	if (WIFEXITED(status)) {
-		printf("child did not single-step\n");
+		ksft_print_msg("child did not single-step: %s\n",
+			strerror(errno));
 		return false;
 	}
 	if (!WIFSTOPPED(status)) {
-		printf("child did not stop\n");
+		ksft_print_msg("child did not stop: %s\n", strerror(errno));
 		return false;
 	}
 	if (WSTOPSIG(status) != SIGTRAP) {
-		printf("child did not stop with SIGTRAP\n");
+		ksft_print_msg("child did not stop with SIGTRAP: %s\n",
+			strerror(errno));
 		return false;
 	}
 
 	if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {
-		perror("ptrace(PTRACE_CONT) failed");
+		ksft_print_msg("ptrace(PTRACE_CONT) failed: %s\n",
+			strerror(errno));
 		return false;
 	}
 
 	wpid = waitpid(pid, &status, __WALL);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg("waitpid() failed: %s\n", strerror(errno));
 		return false;
 	}
 	if (!WIFEXITED(status)) {
-		printf("child did not exit after PTRACE_CONT\n");
+		ksft_print_msg("child did not exit after PTRACE_CONT: %s\n",
+			strerror(errno));
 		return false;
 	}
 
@@ -137,19 +146,19 @@ void suspend(void)
 	power_state_fd = open("/sys/power/state", O_RDWR);
 	if (power_state_fd < 0)
 		ksft_exit_fail_msg(
-			"open(\"/sys/power/state\") failed (is this test running as root?)");
+			"open(\"/sys/power/state\") failed (is this test running as root?)\n");
 
 	timerfd = timerfd_create(CLOCK_BOOTTIME_ALARM, 0);
 	if (timerfd < 0)
-		ksft_exit_fail_msg("timerfd_create() failed");
+		ksft_exit_fail_msg("timerfd_create() failed\n");
 
 	spec.it_value.tv_sec = 5;
 	err = timerfd_settime(timerfd, 0, &spec, NULL);
 	if (err < 0)
-		ksft_exit_fail_msg("timerfd_settime() failed");
+		ksft_exit_fail_msg("timerfd_settime() failed\n");
 
 	if (write(power_state_fd, "mem", strlen("mem")) != strlen("mem"))
-		ksft_exit_fail_msg("entering suspend failed");
+		ksft_exit_fail_msg("Failed to enter Suspend state\n");
 
 	close(timerfd);
 	close(power_state_fd);
@@ -163,7 +172,6 @@ int main(int argc, char **argv)
 	cpu_set_t available_cpus;
 	int err;
 	int cpu;
-	char buf[10];
 
 	ksft_print_header();
 
@@ -184,7 +192,7 @@ int main(int argc, char **argv)
 
 	err = sched_getaffinity(0, sizeof(available_cpus), &available_cpus);
 	if (err < 0)
-		ksft_exit_fail_msg("sched_getaffinity() failed");
+		ksft_exit_fail_msg("sched_getaffinity() failed\n");
 
 	for (cpu = 0; cpu < CPU_SETSIZE; cpu++) {
 		bool test_success;
@@ -193,11 +201,10 @@ int main(int argc, char **argv)
 			continue;
 
 		test_success = run_test(cpu);
-		sprintf(buf, "CPU %d", cpu);
 		if (test_success) {
-			ksft_test_result_pass(buf);
+			ksft_test_result_pass("CPU %d\n", cpu);
 		} else {
-			ksft_test_result_fail(buf);
+			ksft_test_result_fail("CPU %d\n", cpu);
 			succeeded = false;
 		}
 	}

commit e4d1065b315b433f224920f1617bc3783230501c
Author: Paul Elder <paul.elder@pitt.edu>
Date:   Fri Jun 16 00:54:22 2017 +0900

    kselftest: make callers of ksft_exit_skip() output the reason for skipping
    
    Make the three tests that did use the old ksft_ext_skip()
    (breakpoints/breakpoint_test_arm64, breakpoints/step_after_suspend_test,
    and membarrier_test) use the new one, with an output for the
    reason for skipping all the tests.
    
    Signed-off-by: Paul Elder <paul.elder@pitt.edu>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index bf37c1087f25..c60c2effb6bc 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -83,8 +83,8 @@ bool run_test(int cpu)
 
 	if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0) {
 		if (errno == EIO) {
-			printf("ptrace(PTRACE_SINGLESTEP) not supported on this architecture\n");
-			ksft_exit_skip();
+			ksft_exit_skip("ptrace(PTRACE_SINGLESTEP) "
+				"not supported on this architecture");
 		}
 		perror("ptrace(PTRACE_SINGLESTEP) failed");
 		return false;

commit b901216441e6599063ff2828ec7f2f902b9902f0
Author: Paul Elder <paul.elder@pitt.edu>
Date:   Mon Jun 12 08:56:50 2017 +0200

    kselftest: breakpoints: convert step_after_suspend_test to TAP13 output
    
    Make the step_after_suspend test output in the TAP13 format by using the
    TAP13 output functions defined in kselftest.h
    
    Signed-off-by: Paul Elder <paul.elder@pitt.edu>
    Signed-off-by: Alice Ferrazzi <alice.ferrazzi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
index 60b8a95dac26..bf37c1087f25 100644
--- a/tools/testing/selftests/breakpoints/step_after_suspend_test.c
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -135,28 +135,21 @@ void suspend(void)
 	struct itimerspec spec = {};
 
 	power_state_fd = open("/sys/power/state", O_RDWR);
-	if (power_state_fd < 0) {
-		perror("open(\"/sys/power/state\") failed (is this test running as root?)");
-		ksft_exit_fail();
-	}
+	if (power_state_fd < 0)
+		ksft_exit_fail_msg(
+			"open(\"/sys/power/state\") failed (is this test running as root?)");
 
 	timerfd = timerfd_create(CLOCK_BOOTTIME_ALARM, 0);
-	if (timerfd < 0) {
-		perror("timerfd_create() failed");
-		ksft_exit_fail();
-	}
+	if (timerfd < 0)
+		ksft_exit_fail_msg("timerfd_create() failed");
 
 	spec.it_value.tv_sec = 5;
 	err = timerfd_settime(timerfd, 0, &spec, NULL);
-	if (err < 0) {
-		perror("timerfd_settime() failed");
-		ksft_exit_fail();
-	}
+	if (err < 0)
+		ksft_exit_fail_msg("timerfd_settime() failed");
 
-	if (write(power_state_fd, "mem", strlen("mem")) != strlen("mem")) {
-		perror("entering suspend failed");
-		ksft_exit_fail();
-	}
+	if (write(power_state_fd, "mem", strlen("mem")) != strlen("mem"))
+		ksft_exit_fail_msg("entering suspend failed");
 
 	close(timerfd);
 	close(power_state_fd);
@@ -170,6 +163,9 @@ int main(int argc, char **argv)
 	cpu_set_t available_cpus;
 	int err;
 	int cpu;
+	char buf[10];
+
+	ksft_print_header();
 
 	while ((opt = getopt(argc, argv, "n")) != -1) {
 		switch (opt) {
@@ -187,10 +183,8 @@ int main(int argc, char **argv)
 		suspend();
 
 	err = sched_getaffinity(0, sizeof(available_cpus), &available_cpus);
-	if (err < 0) {
-		perror("sched_getaffinity() failed");
-		ksft_exit_fail();
-	}
+	if (err < 0)
+		ksft_exit_fail_msg("sched_getaffinity() failed");
 
 	for (cpu = 0; cpu < CPU_SETSIZE; cpu++) {
 		bool test_success;
@@ -199,18 +193,15 @@ int main(int argc, char **argv)
 			continue;
 
 		test_success = run_test(cpu);
-		printf("CPU %d: ", cpu);
+		sprintf(buf, "CPU %d", cpu);
 		if (test_success) {
-			printf("[OK]\n");
-			ksft_inc_pass_cnt();
+			ksft_test_result_pass(buf);
 		} else {
-			printf("[FAILED]\n");
-			ksft_inc_fail_cnt();
+			ksft_test_result_fail(buf);
 			succeeded = false;
 		}
 	}
 
-	ksft_print_cnts();
 	if (succeeded)
 		ksft_exit_pass();
 	else

commit bfd092b8c272866ba1db3e63ebbe08f8ccf979cc
Author: Greg Hackmann <ghackmann@google.com>
Date:   Mon Feb 22 10:10:57 2016 -0800

    selftests: breakpoint: add step_after_suspend_test
    
    Commit e56d82a11617 ("arm64: cpu hotplug: ensure we mask out
    CPU_TASKS_FROZEN in notifiers") fixed a long-standing ARM64 bug that
    broke single-stepping after a suspend/resume cycle.  Add a kernel
    selftest to make sure this doesn't regress or affect other platforms.
    
    Signed-off-by: Greg Hackmann <ghackmann@google.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/step_after_suspend_test.c b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
new file mode 100644
index 000000000000..60b8a95dac26
--- /dev/null
+++ b/tools/testing/selftests/breakpoints/step_after_suspend_test.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sched.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ptrace.h>
+#include <sys/stat.h>
+#include <sys/timerfd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include "../kselftest.h"
+
+void child(int cpu)
+{
+	cpu_set_t set;
+
+	CPU_ZERO(&set);
+	CPU_SET(cpu, &set);
+	if (sched_setaffinity(0, sizeof(set), &set) != 0) {
+		perror("sched_setaffinity() failed");
+		_exit(1);
+	}
+
+	if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {
+		perror("ptrace(PTRACE_TRACEME) failed");
+		_exit(1);
+	}
+
+	if (raise(SIGSTOP) != 0) {
+		perror("raise(SIGSTOP) failed");
+		_exit(1);
+	}
+
+	_exit(0);
+}
+
+bool run_test(int cpu)
+{
+	int status;
+	pid_t pid = fork();
+	pid_t wpid;
+
+	if (pid < 0) {
+		perror("fork() failed");
+		return false;
+	}
+	if (pid == 0)
+		child(cpu);
+
+	wpid = waitpid(pid, &status, __WALL);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	if (!WIFSTOPPED(status)) {
+		printf("child did not stop\n");
+		return false;
+	}
+	if (WSTOPSIG(status) != SIGSTOP) {
+		printf("child did not stop with SIGSTOP\n");
+		return false;
+	}
+
+	if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0) {
+		if (errno == EIO) {
+			printf("ptrace(PTRACE_SINGLESTEP) not supported on this architecture\n");
+			ksft_exit_skip();
+		}
+		perror("ptrace(PTRACE_SINGLESTEP) failed");
+		return false;
+	}
+
+	wpid = waitpid(pid, &status, __WALL);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	if (WIFEXITED(status)) {
+		printf("child did not single-step\n");
+		return false;
+	}
+	if (!WIFSTOPPED(status)) {
+		printf("child did not stop\n");
+		return false;
+	}
+	if (WSTOPSIG(status) != SIGTRAP) {
+		printf("child did not stop with SIGTRAP\n");
+		return false;
+	}
+
+	if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {
+		perror("ptrace(PTRACE_CONT) failed");
+		return false;
+	}
+
+	wpid = waitpid(pid, &status, __WALL);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	if (!WIFEXITED(status)) {
+		printf("child did not exit after PTRACE_CONT\n");
+		return false;
+	}
+
+	return true;
+}
+
+void suspend(void)
+{
+	int power_state_fd;
+	struct sigevent event = {};
+	int timerfd;
+	int err;
+	struct itimerspec spec = {};
+
+	power_state_fd = open("/sys/power/state", O_RDWR);
+	if (power_state_fd < 0) {
+		perror("open(\"/sys/power/state\") failed (is this test running as root?)");
+		ksft_exit_fail();
+	}
+
+	timerfd = timerfd_create(CLOCK_BOOTTIME_ALARM, 0);
+	if (timerfd < 0) {
+		perror("timerfd_create() failed");
+		ksft_exit_fail();
+	}
+
+	spec.it_value.tv_sec = 5;
+	err = timerfd_settime(timerfd, 0, &spec, NULL);
+	if (err < 0) {
+		perror("timerfd_settime() failed");
+		ksft_exit_fail();
+	}
+
+	if (write(power_state_fd, "mem", strlen("mem")) != strlen("mem")) {
+		perror("entering suspend failed");
+		ksft_exit_fail();
+	}
+
+	close(timerfd);
+	close(power_state_fd);
+}
+
+int main(int argc, char **argv)
+{
+	int opt;
+	bool do_suspend = true;
+	bool succeeded = true;
+	cpu_set_t available_cpus;
+	int err;
+	int cpu;
+
+	while ((opt = getopt(argc, argv, "n")) != -1) {
+		switch (opt) {
+		case 'n':
+			do_suspend = false;
+			break;
+		default:
+			printf("Usage: %s [-n]\n", argv[0]);
+			printf("        -n: do not trigger a suspend/resume cycle before the test\n");
+			return -1;
+		}
+	}
+
+	if (do_suspend)
+		suspend();
+
+	err = sched_getaffinity(0, sizeof(available_cpus), &available_cpus);
+	if (err < 0) {
+		perror("sched_getaffinity() failed");
+		ksft_exit_fail();
+	}
+
+	for (cpu = 0; cpu < CPU_SETSIZE; cpu++) {
+		bool test_success;
+
+		if (!CPU_ISSET(cpu, &available_cpus))
+			continue;
+
+		test_success = run_test(cpu);
+		printf("CPU %d: ", cpu);
+		if (test_success) {
+			printf("[OK]\n");
+			ksft_inc_pass_cnt();
+		} else {
+			printf("[FAILED]\n");
+			ksft_inc_fail_cnt();
+			succeeded = false;
+		}
+	}
+
+	ksft_print_cnts();
+	if (succeeded)
+		ksft_exit_pass();
+	else
+		ksft_exit_fail();
+}
