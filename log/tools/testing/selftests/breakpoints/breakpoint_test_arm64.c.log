commit 5b06eeae52c02dd0d9bc8488275a1207d410870b
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu Oct 31 21:23:00 2019 +0900

    selftests: breakpoints: Fix a typo of function name
    
    Since commit 5821ba969511 ("selftests: Add test plan API to kselftest.h
    and adjust callers") accidentally introduced 'a' typo in the front of
    run_test() function, breakpoint_test_arm64.c became not able to be
    compiled.
    
    Remove the 'a' from arun_test().
    
    Fixes: 5821ba969511 ("selftests: Add test plan API to kselftest.h and adjust callers")
    Reported-by: Jun Takahashi <takahashi.jun_s@aa.socionext.com>
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index 58ed5eeab709..ad41ea69001b 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -109,7 +109,7 @@ static bool set_watchpoint(pid_t pid, int size, int wp)
 	return false;
 }
 
-static bool arun_test(int wr_size, int wp_size, int wr, int wp)
+static bool run_test(int wr_size, int wp_size, int wr, int wp)
 {
 	int status;
 	siginfo_t siginfo;

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index ab59d814341a..58ed5eeab709 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -1,20 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2016 Google, Inc.
  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Original Code by Pavel Labath <labath@google.com>
  *
  * Code modified by Pratyush Anand <panand@redhat.com>
  * for testing different byte select for each access size.
- *
  */
 
 #define _GNU_SOURCE

commit 5821ba969511daf27fa917515904f7b823259cf7
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Apr 24 16:12:37 2019 -0700

    selftests: Add test plan API to kselftest.h and adjust callers
    
    The test plan for TAP needs to be declared immediately after the header.
    This adds the test plan API to kselftest.h and updates all callers to
    declare their expected test counts.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index 2d95e5adde72..ab59d814341a 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -118,7 +118,7 @@ static bool set_watchpoint(pid_t pid, int size, int wp)
 	return false;
 }
 
-static bool run_test(int wr_size, int wp_size, int wr, int wp)
+static bool arun_test(int wr_size, int wp_size, int wr, int wp)
 {
 	int status;
 	siginfo_t siginfo;
@@ -214,6 +214,7 @@ int main(int argc, char **argv)
 	bool result;
 
 	ksft_print_header();
+	ksft_set_plan(213);
 
 	act.sa_handler = sigalrm;
 	sigemptyset(&act.sa_mask);

commit af7dc093467a917278ec3b61aea46377b4372d8c
Author: Sumit Semwal <sumit.semwal@linaro.org>
Date:   Mon Oct 23 13:12:22 2017 +0530

    selftests: breakpoints: fix compile error on breakpoint_test_arm64
    
    The current mainline breakpoints test for arm64 fails to compile with
    
    breakpoint_test_arm64.c: In function ‘set_watchpoint’:
    breakpoint_test_arm64.c:97:28: error: storage size of ‘dreg_state’ isn’t known
      struct user_hwdebug_state dreg_state;
    
    Adding a direct include for asm/ptrace.h helps it to build, and passes
    the test on mainline on hikey.
    
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index 960d02100c26..2d95e5adde72 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -19,6 +19,7 @@
 
 #define _GNU_SOURCE
 
+#include <asm/ptrace.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/ptrace.h>

commit 0732d06ee563bbcdf34ec889918baa62451b580d
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Jun 29 15:52:42 2017 -0600

    selftests: breakpoints: breakpoint_test_arm64: convert test to use TAP13
    
    Convert breakpoint_test_arm64 output to TAP13 format. Use ksft_* var arg
    msg api to include strerror() info. in the output. Change output from
    child process to use ksft_print_msg() instead of ksft_exit_* to avoid
    double counting tests and ensure parent process does the test counter
    incrementing.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index fa6d57af5217..960d02100c26 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -43,19 +43,25 @@ static void child(int size, int wr)
 	volatile uint8_t *addr = &var[32 + wr];
 
 	if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {
-		perror("ptrace(PTRACE_TRACEME) failed");
+		ksft_print_msg(
+			"ptrace(PTRACE_TRACEME) failed: %s\n",
+			strerror(errno));
 		_exit(1);
 	}
 
 	if (raise(SIGSTOP) != 0) {
-		perror("raise(SIGSTOP) failed");
+		ksft_print_msg(
+			"raise(SIGSTOP) failed: %s\n", strerror(errno));
 		_exit(1);
 	}
 
 	if ((uintptr_t) addr % size) {
-		perror("Wrong address write for the given size\n");
+		ksft_print_msg(
+			 "Wrong address write for the given size: %s\n",
+			 strerror(errno));
 		_exit(1);
 	}
+
 	switch (size) {
 	case 1:
 		*addr = 47;
@@ -100,11 +106,14 @@ static bool set_watchpoint(pid_t pid, int size, int wp)
 	if (ptrace(PTRACE_SETREGSET, pid, NT_ARM_HW_WATCH, &iov) == 0)
 		return true;
 
-	if (errno == EIO) {
-		ksft_exit_skip("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) "
-			"not supported on this hardware\n");
-	}
-	perror("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) failed");
+	if (errno == EIO)
+		ksft_print_msg(
+			"ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) not supported on this hardware: %s\n",
+			strerror(errno));
+
+	ksft_print_msg(
+		"ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) failed: %s\n",
+		strerror(errno));
 	return false;
 }
 
@@ -116,7 +125,8 @@ static bool run_test(int wr_size, int wp_size, int wr, int wp)
 	pid_t wpid;
 
 	if (pid < 0) {
-		perror("fork() failed");
+		ksft_test_result_fail(
+			"fork() failed: %s\n", strerror(errno));
 		return false;
 	}
 	if (pid == 0)
@@ -124,15 +134,17 @@ static bool run_test(int wr_size, int wp_size, int wr, int wp)
 
 	wpid = waitpid(pid, &status, __WALL);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg(
+			"waitpid() failed: %s\n", strerror(errno));
 		return false;
 	}
 	if (!WIFSTOPPED(status)) {
-		printf("child did not stop\n");
+		ksft_print_msg(
+			"child did not stop: %s\n", strerror(errno));
 		return false;
 	}
 	if (WSTOPSIG(status) != SIGSTOP) {
-		printf("child did not stop with SIGSTOP\n");
+		ksft_print_msg("child did not stop with SIGSTOP\n");
 		return false;
 	}
 
@@ -140,42 +152,49 @@ static bool run_test(int wr_size, int wp_size, int wr, int wp)
 		return false;
 
 	if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {
-		perror("ptrace(PTRACE_SINGLESTEP) failed");
+		ksft_print_msg(
+			"ptrace(PTRACE_SINGLESTEP) failed: %s\n",
+			strerror(errno));
 		return false;
 	}
 
 	alarm(3);
 	wpid = waitpid(pid, &status, __WALL);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg(
+			"waitpid() failed: %s\n", strerror(errno));
 		return false;
 	}
 	alarm(0);
 	if (WIFEXITED(status)) {
-		printf("child did not single-step\t");
+		ksft_print_msg("child did not single-step\n");
 		return false;
 	}
 	if (!WIFSTOPPED(status)) {
-		printf("child did not stop\n");
+		ksft_print_msg("child did not stop\n");
 		return false;
 	}
 	if (WSTOPSIG(status) != SIGTRAP) {
-		printf("child did not stop with SIGTRAP\n");
+		ksft_print_msg("child did not stop with SIGTRAP\n");
 		return false;
 	}
 	if (ptrace(PTRACE_GETSIGINFO, pid, NULL, &siginfo) != 0) {
-		perror("ptrace(PTRACE_GETSIGINFO)");
+		ksft_print_msg(
+			"ptrace(PTRACE_GETSIGINFO): %s\n",
+			strerror(errno));
 		return false;
 	}
 	if (siginfo.si_code != TRAP_HWBKPT) {
-		printf("Unexpected si_code %d\n", siginfo.si_code);
+		ksft_print_msg(
+			"Unexpected si_code %d\n", siginfo.si_code);
 		return false;
 	}
 
 	kill(pid, SIGKILL);
 	wpid = waitpid(pid, &status, 0);
 	if (wpid != pid) {
-		perror("waitpid() failed");
+		ksft_print_msg(
+			"waitpid() failed: %s\n", strerror(errno));
 		return false;
 	}
 	return true;
@@ -193,6 +212,8 @@ int main(int argc, char **argv)
 	int wr, wp, size;
 	bool result;
 
+	ksft_print_header();
+
 	act.sa_handler = sigalrm;
 	sigemptyset(&act.sa_mask);
 	act.sa_flags = 0;
@@ -200,14 +221,16 @@ int main(int argc, char **argv)
 	for (size = 1; size <= 32; size = size*2) {
 		for (wr = 0; wr <= 32; wr = wr + size) {
 			for (wp = wr - size; wp <= wr + size; wp = wp + size) {
-				printf("Test size = %d write offset = %d watchpoint offset = %d\t", size, wr, wp);
 				result = run_test(size, MIN(size, 8), wr, wp);
-				if ((result && wr == wp) || (!result && wr != wp)) {
-					printf("[OK]\n");
-					ksft_inc_pass_cnt();
-				} else {
-					printf("[FAILED]\n");
-					ksft_inc_fail_cnt();
+				if ((result && wr == wp) ||
+				    (!result && wr != wp))
+					ksft_test_result_pass(
+						"Test size = %d write offset = %d watchpoint offset = %d\n",
+						size, wr, wp);
+				else {
+					ksft_test_result_fail(
+						"Test size = %d write offset = %d watchpoint offset = %d\n",
+						size, wr, wp);
 					succeeded = false;
 				}
 			}
@@ -215,19 +238,18 @@ int main(int argc, char **argv)
 	}
 
 	for (size = 1; size <= 32; size = size*2) {
-		printf("Test size = %d write offset = %d watchpoint offset = -8\t", size, -size);
-
-		if (run_test(size, 8, -size, -8)) {
-			printf("[OK]\n");
-			ksft_inc_pass_cnt();
-		} else {
-			printf("[FAILED]\n");
-			ksft_inc_fail_cnt();
+		if (run_test(size, 8, -size, -8))
+			ksft_test_result_pass(
+				"Test size = %d write offset = %d watchpoint offset = -8\n",
+				size, -size);
+		else {
+			ksft_test_result_fail(
+				"Test size = %d write offset = %d watchpoint offset = -8\n",
+				size, -size);
 			succeeded = false;
 		}
 	}
 
-	ksft_print_cnts();
 	if (succeeded)
 		ksft_exit_pass();
 	else

commit e4d1065b315b433f224920f1617bc3783230501c
Author: Paul Elder <paul.elder@pitt.edu>
Date:   Fri Jun 16 00:54:22 2017 +0900

    kselftest: make callers of ksft_exit_skip() output the reason for skipping
    
    Make the three tests that did use the old ksft_ext_skip()
    (breakpoints/breakpoint_test_arm64, breakpoints/step_after_suspend_test,
    and membarrier_test) use the new one, with an output for the
    reason for skipping all the tests.
    
    Signed-off-by: Paul Elder <paul.elder@pitt.edu>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
index 3897e996541e..fa6d57af5217 100644
--- a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -101,9 +101,8 @@ static bool set_watchpoint(pid_t pid, int size, int wp)
 		return true;
 
 	if (errno == EIO) {
-		printf("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) "
+		ksft_exit_skip("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) "
 			"not supported on this hardware\n");
-		ksft_exit_skip();
 	}
 	perror("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) failed");
 	return false;

commit f43365ee17f8d22b1f887d2b26faa0837ca85138
Author: Pratyush Anand <panand@redhat.com>
Date:   Mon Nov 14 19:32:46 2016 +0530

    selftests: arm64: add test for unaligned/inexact watchpoint handling
    
    ARM64 hardware expects 64bit aligned address for watchpoint invocation.
    However, it provides byte selection method to select any number of
    consecutive byte set within the range of 1-8.
    
    This patch adds support to test all such byte selection option for
    different memory write sizes.
    
    Patch also adds a test for handling the case when the cpu does not
    report an address which exactly matches one of the regions we have
    been watching (which is a situation permitted by the spec if an
    instruction accesses both watched and unwatched regions). The test
    was failing on a MSM8996pro before this patch series and is
    passing now.
    
    Signed-off-by: Pavel Labath <labath@google.com>
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
new file mode 100644
index 000000000000..3897e996541e
--- /dev/null
+++ b/tools/testing/selftests/breakpoints/breakpoint_test_arm64.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Original Code by Pavel Labath <labath@google.com>
+ *
+ * Code modified by Pratyush Anand <panand@redhat.com>
+ * for testing different byte select for each access size.
+ *
+ */
+
+#define _GNU_SOURCE
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/ptrace.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <elf.h>
+#include <errno.h>
+#include <signal.h>
+
+#include "../kselftest.h"
+
+static volatile uint8_t var[96] __attribute__((__aligned__(32)));
+
+static void child(int size, int wr)
+{
+	volatile uint8_t *addr = &var[32 + wr];
+
+	if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {
+		perror("ptrace(PTRACE_TRACEME) failed");
+		_exit(1);
+	}
+
+	if (raise(SIGSTOP) != 0) {
+		perror("raise(SIGSTOP) failed");
+		_exit(1);
+	}
+
+	if ((uintptr_t) addr % size) {
+		perror("Wrong address write for the given size\n");
+		_exit(1);
+	}
+	switch (size) {
+	case 1:
+		*addr = 47;
+		break;
+	case 2:
+		*(uint16_t *)addr = 47;
+		break;
+	case 4:
+		*(uint32_t *)addr = 47;
+		break;
+	case 8:
+		*(uint64_t *)addr = 47;
+		break;
+	case 16:
+		__asm__ volatile ("stp x29, x30, %0" : "=m" (addr[0]));
+		break;
+	case 32:
+		__asm__ volatile ("stp q29, q30, %0" : "=m" (addr[0]));
+		break;
+	}
+
+	_exit(0);
+}
+
+static bool set_watchpoint(pid_t pid, int size, int wp)
+{
+	const volatile uint8_t *addr = &var[32 + wp];
+	const int offset = (uintptr_t)addr % 8;
+	const unsigned int byte_mask = ((1 << size) - 1) << offset;
+	const unsigned int type = 2; /* Write */
+	const unsigned int enable = 1;
+	const unsigned int control = byte_mask << 5 | type << 3 | enable;
+	struct user_hwdebug_state dreg_state;
+	struct iovec iov;
+
+	memset(&dreg_state, 0, sizeof(dreg_state));
+	dreg_state.dbg_regs[0].addr = (uintptr_t)(addr - offset);
+	dreg_state.dbg_regs[0].ctrl = control;
+	iov.iov_base = &dreg_state;
+	iov.iov_len = offsetof(struct user_hwdebug_state, dbg_regs) +
+				sizeof(dreg_state.dbg_regs[0]);
+	if (ptrace(PTRACE_SETREGSET, pid, NT_ARM_HW_WATCH, &iov) == 0)
+		return true;
+
+	if (errno == EIO) {
+		printf("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) "
+			"not supported on this hardware\n");
+		ksft_exit_skip();
+	}
+	perror("ptrace(PTRACE_SETREGSET, NT_ARM_HW_WATCH) failed");
+	return false;
+}
+
+static bool run_test(int wr_size, int wp_size, int wr, int wp)
+{
+	int status;
+	siginfo_t siginfo;
+	pid_t pid = fork();
+	pid_t wpid;
+
+	if (pid < 0) {
+		perror("fork() failed");
+		return false;
+	}
+	if (pid == 0)
+		child(wr_size, wr);
+
+	wpid = waitpid(pid, &status, __WALL);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	if (!WIFSTOPPED(status)) {
+		printf("child did not stop\n");
+		return false;
+	}
+	if (WSTOPSIG(status) != SIGSTOP) {
+		printf("child did not stop with SIGSTOP\n");
+		return false;
+	}
+
+	if (!set_watchpoint(pid, wp_size, wp))
+		return false;
+
+	if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {
+		perror("ptrace(PTRACE_SINGLESTEP) failed");
+		return false;
+	}
+
+	alarm(3);
+	wpid = waitpid(pid, &status, __WALL);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	alarm(0);
+	if (WIFEXITED(status)) {
+		printf("child did not single-step\t");
+		return false;
+	}
+	if (!WIFSTOPPED(status)) {
+		printf("child did not stop\n");
+		return false;
+	}
+	if (WSTOPSIG(status) != SIGTRAP) {
+		printf("child did not stop with SIGTRAP\n");
+		return false;
+	}
+	if (ptrace(PTRACE_GETSIGINFO, pid, NULL, &siginfo) != 0) {
+		perror("ptrace(PTRACE_GETSIGINFO)");
+		return false;
+	}
+	if (siginfo.si_code != TRAP_HWBKPT) {
+		printf("Unexpected si_code %d\n", siginfo.si_code);
+		return false;
+	}
+
+	kill(pid, SIGKILL);
+	wpid = waitpid(pid, &status, 0);
+	if (wpid != pid) {
+		perror("waitpid() failed");
+		return false;
+	}
+	return true;
+}
+
+static void sigalrm(int sig)
+{
+}
+
+int main(int argc, char **argv)
+{
+	int opt;
+	bool succeeded = true;
+	struct sigaction act;
+	int wr, wp, size;
+	bool result;
+
+	act.sa_handler = sigalrm;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = 0;
+	sigaction(SIGALRM, &act, NULL);
+	for (size = 1; size <= 32; size = size*2) {
+		for (wr = 0; wr <= 32; wr = wr + size) {
+			for (wp = wr - size; wp <= wr + size; wp = wp + size) {
+				printf("Test size = %d write offset = %d watchpoint offset = %d\t", size, wr, wp);
+				result = run_test(size, MIN(size, 8), wr, wp);
+				if ((result && wr == wp) || (!result && wr != wp)) {
+					printf("[OK]\n");
+					ksft_inc_pass_cnt();
+				} else {
+					printf("[FAILED]\n");
+					ksft_inc_fail_cnt();
+					succeeded = false;
+				}
+			}
+		}
+	}
+
+	for (size = 1; size <= 32; size = size*2) {
+		printf("Test size = %d write offset = %d watchpoint offset = -8\t", size, -size);
+
+		if (run_test(size, 8, -size, -8)) {
+			printf("[OK]\n");
+			ksft_inc_pass_cnt();
+		} else {
+			printf("[FAILED]\n");
+			ksft_inc_fail_cnt();
+			succeeded = false;
+		}
+	}
+
+	ksft_print_cnts();
+	if (succeeded)
+		ksft_exit_pass();
+	else
+		ksft_exit_fail();
+}
