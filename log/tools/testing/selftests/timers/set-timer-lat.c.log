commit eefd95e1f3d47b90dc768e9ebc77d390c4f34809
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Sep 21 13:05:18 2017 -0600

    selftests: timers: set-timer-lat: Fix hang when testing unsupported alarms
    
    When timer_create() fails on a bootime or realtime clock, setup_timer()
    returns 0 as if timer has been set. Callers wait forever for the timer
    to expire.
    
    This hang is seen on a system that doesn't have support for:
    
    CLOCK_REALTIME_ALARM   ABSTIME missing CAP_WAKE_ALARM? : [UNSUPPORTED]
    
    Test hangs waiting for a timer that hasn't been set to expire. Fix
    setup_timer() to return 1, add handling in callers to detect the
    unsupported case and return 0 without waiting to not fail the test.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index ea1af5dbc7b6..50da45437daa 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -143,7 +143,8 @@ int setup_timer(int clock_id, int flags, int interval, timer_t *tm1)
 			printf("%-22s %s missing CAP_WAKE_ALARM?    : [UNSUPPORTED]\n",
 					clockstring(clock_id),
 					flags ? "ABSTIME":"RELTIME");
-			return 0;
+			/* Indicate timer isn't set, so caller doesn't wait */
+			return 1;
 		}
 		printf("%s - timer_create() failed\n", clockstring(clock_id));
 		return -1;
@@ -213,8 +214,9 @@ int do_timer(int clock_id, int flags)
 	int err;
 
 	err = setup_timer(clock_id, flags, interval, &tm1);
+	/* Unsupported case - return 0 to not fail the test */
 	if (err)
-		return err;
+		return err == 1 ? 0 : err;
 
 	while (alarmcount < 5)
 		sleep(1);
@@ -231,8 +233,9 @@ int do_timer_oneshot(int clock_id, int flags)
 	int err;
 
 	err = setup_timer(clock_id, flags, interval, &tm1);
+	/* Unsupported case - return 0 to not fail the test */
 	if (err)
-		return err;
+		return err == 1 ? 0 : err;
 
 	memset(&timeout, 0, sizeof(timeout));
 	timeout.tv_sec = 5;

commit 01db7fbf5487505b887fbd6a03c51f2adc952196
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Sep 21 13:46:01 2017 -0600

    selftests: timers: set-timer-lat: fix hang when std out/err are redirected
    
    do_timer_oneshot() uses select() as a timer with FD_SETSIZE and readfs
    is cleared with FD_ZERO without FD_SET.
    
    When stdout and stderr are redirected, the test hangs in select forever.
    Fix the problem calling select() with readfds empty and nfds zero. This
    is sufficient for using select() for timer.
    
    With this fix "./set-timer-lat > /dev/null 2>&1" no longer hangs.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Acked-by: Greg Hackmann <ghackmann@google.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 9c92b7bd5641..ea1af5dbc7b6 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -228,7 +228,6 @@ int do_timer_oneshot(int clock_id, int flags)
 	timer_t tm1;
 	const int interval = 0;
 	struct timeval timeout;
-	fd_set fds;
 	int err;
 
 	err = setup_timer(clock_id, flags, interval, &tm1);
@@ -237,9 +236,8 @@ int do_timer_oneshot(int clock_id, int flags)
 
 	memset(&timeout, 0, sizeof(timeout));
 	timeout.tv_sec = 5;
-	FD_ZERO(&fds);
 	do {
-		err = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
+		err = select(0, NULL, NULL, NULL, &timeout);
 	} while (err == -1 && errno == EINTR);
 
 	timer_delete(tm1);

commit 6d6218976df142ba5594371f8dbd56650151c56f
Merge: 42c8e86c9c3e 369130b63178
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 8 15:11:20 2017 -0700

    Merge tag 'linux-kselftest-4.14-rc1-update' of git://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest
    
    Pull kselftest updates from Shuah Khan:
    
     - TAP13 framework API and converting tests to TAP13 continues. A few
       more tests are converted and kselftest common RUN_TESTS in lib.mk is
       enhanced to print TAP13 to cover test shell scripts that won't be
       able to use kselftest API.
    
     - Several fixes to existing tests to not fail in unsupported cases.
       This has been an ongoing work based on the feedback from stable
       release kselftest users.
    
     - A new watchdog test and much needed cleanups to the existing tests
       from Eugeniu Rosca.
    
     - Changes to kselftest common lib.mk framework to make RUN_TESTS a
       function to be called from individual test make files to run stress
       and destructive sub-tests.
    
    * tag 'linux-kselftest-4.14-rc1-update' of git://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest: (41 commits)
      selftests: Enhance kselftest_harness.h to print which assert failed
      selftests: lib.mk: change RUN_TESTS to print messages in TAP13 format
      selftests: change lib.mk RUN_TESTS to take test list as an argument
      selftests: lib.mk: suppress "cd" output from run_tests target
      selftests: kselftest framework: change skip exit code to 0
      selftests/timers: make loop consistent with array size
      selftests: timers: remove rtctest_setdate from run_destructive_tests
      selftests: timers: Fix run_destructive_tests target to handle skipped tests
      kselftests: timers: leap-a-day: Change default arguments to help test runs
      selftests: timers: drop support for !KTEST case
      rtc: rtctest: Improve support detection
      selftests/cpu-hotplug: Skip test when there is only one online cpu
      selftests/cpu-hotplug: exit with failure when test occured unexpected behaviors
      selftests: futex: convert test to use ksft TAP13 framework
      selftests: capabilities: convert error output to TAP13 ksft framework
      selftests: memfd: Align STACK_SIZE for ARM AArch64 system
      selftests: warn if failure is due to lack of executable bit
      selftests: kselftest framework: add error counter
      selftests: capabilities: convert the test to use TAP13 ksft framework
      selftests: capabilities: fix to run Non-root +ia, sgidroot => i test
      ...

commit b841065043f996e2bf7648786485f3935625592b
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Fri Aug 11 10:11:42 2017 -0600

    selftests: timers: drop support for !KTEST case
    
    There is no need to keep timers tests in sync with external timers
    repo. Drop support for !KTEST to support for building and running
    timers tests without kselftest framework.
    
    Reference: https://lkml.org/lkml/2017/8/10/952
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Acked-by: John Stultz <john.stultz@linaro.org>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 4fc98c5b0899..b343ac90b598 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -27,18 +27,7 @@
 #include <signal.h>
 #include <stdlib.h>
 #include <pthread.h>
-#ifdef KTEST
 #include "../kselftest.h"
-#else
-static inline int ksft_exit_pass(void)
-{
-	exit(0);
-}
-static inline int ksft_exit_fail(void)
-{
-	exit(1);
-}
-#endif
 
 #define CLOCK_REALTIME			0
 #define CLOCK_MONOTONIC			1

commit 28be3f8f48cfb3cf024860f042d424cd4824f5f7
Author: Greg Hackmann <ghackmann@google.com>
Date:   Tue Jul 25 14:36:26 2017 -0700

    kselftests: timers: set-timer-lat: Add one-shot timer test cases
    
    These testcases are motivated by a recent alarmtimer regression, which
    caused one-shot CLOCK_{BOOTTIME,REALTIME}_ALARM timers to become
    periodic timers.
    
    The new testcases are very similar to the existing testcases for
    repeating timers.  But rather than waiting for 5 alarms, they wait for 5
    seconds and verify that the alarm fired exactly once.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: linux-kselftest@vger.kernel.org
    Signed-off-by: Greg Hackmann <ghackmann@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 10c2e18737c0..15434da23b04 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -20,6 +20,7 @@
  */
 
 
+#include <errno.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <time.h>
@@ -122,17 +123,17 @@ void sigalarm(int signo)
 		max_latency_ns = delta_ns;
 }
 
-void describe_timer(int flags)
+void describe_timer(int flags, int interval)
 {
-	printf("%-22s %s ",
+	printf("%-22s %s %s ",
 			clockstring(clock_id),
-			flags ? "ABSTIME":"RELTIME");
+			flags ? "ABSTIME":"RELTIME",
+			interval ? "PERIODIC":"ONE-SHOT");
 }
 
-int do_timer(int clock_id, int flags)
+int setup_timer(int clock_id, int flags, int interval, timer_t *tm1)
 {
 	struct sigevent se;
-	timer_t tm1;
 	struct itimerspec its1, its2;
 	int err;
 
@@ -146,7 +147,7 @@ int do_timer(int clock_id, int flags)
 	alarmcount = 0;
 	timer_fired_early = 0;
 
-	err = timer_create(clock_id, &se, &tm1);
+	err = timer_create(clock_id, &se, tm1);
 	if (err) {
 		if ((clock_id == CLOCK_REALTIME_ALARM) ||
 		    (clock_id == CLOCK_BOOTTIME_ALARM)) {
@@ -167,19 +168,23 @@ int do_timer(int clock_id, int flags)
 		its1.it_value.tv_sec = TIMER_SECS;
 		its1.it_value.tv_nsec = 0;
 	}
-	its1.it_interval.tv_sec = TIMER_SECS;
+	its1.it_interval.tv_sec = interval;
 	its1.it_interval.tv_nsec = 0;
 
-	err = timer_settime(tm1, flags, &its1, &its2);
+	err = timer_settime(*tm1, flags, &its1, &its2);
 	if (err) {
 		printf("%s - timer_settime() failed\n", clockstring(clock_id));
 		return -1;
 	}
 
-	while (alarmcount < 5)
-		sleep(1);
+	return 0;
+}
 
-	describe_timer(flags);
+int check_timer_latency(int flags, int interval)
+{
+	int err = 0;
+
+	describe_timer(flags, interval);
 	printf("timer fired early: %7d : ", timer_fired_early);
 	if (!timer_fired_early) {
 		printf("[OK]\n");
@@ -188,10 +193,9 @@ int do_timer(int clock_id, int flags)
 		err = -1;
 	}
 
-	describe_timer(flags);
+	describe_timer(flags, interval);
 	printf("max latency: %10lld ns : ", max_latency_ns);
 
-	timer_delete(tm1);
 	if (max_latency_ns < UNRESONABLE_LATENCY) {
 		printf("[OK]\n");
 	} else {
@@ -201,6 +205,60 @@ int do_timer(int clock_id, int flags)
 	return err;
 }
 
+int check_alarmcount(int flags, int interval)
+{
+	describe_timer(flags, interval);
+	printf("count: %19d : ", alarmcount);
+	if (alarmcount == 1) {
+		printf("[OK]\n");
+		return 0;
+	}
+	printf("[FAILED]\n");
+	return -1;
+}
+
+int do_timer(int clock_id, int flags)
+{
+	timer_t tm1;
+	const int interval = TIMER_SECS;
+	int err;
+
+	err = setup_timer(clock_id, flags, interval, &tm1);
+	if (err)
+		return err;
+
+	while (alarmcount < 5)
+		sleep(1);
+
+	timer_delete(tm1);
+	return check_timer_latency(flags, interval);
+}
+
+int do_timer_oneshot(int clock_id, int flags)
+{
+	timer_t tm1;
+	const int interval = 0;
+	struct timeval timeout;
+	fd_set fds;
+	int err;
+
+	err = setup_timer(clock_id, flags, interval, &tm1);
+	if (err)
+		return err;
+
+	memset(&timeout, 0, sizeof(timeout));
+	timeout.tv_sec = 5;
+	FD_ZERO(&fds);
+	do {
+		err = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
+	} while (err == -1 && errno == EINTR);
+
+	timer_delete(tm1);
+	err = check_timer_latency(flags, interval);
+	err |= check_alarmcount(flags, interval);
+	return err;
+}
+
 int main(void)
 {
 	struct sigaction act;
@@ -226,6 +284,8 @@ int main(void)
 
 		ret |= do_timer(clock_id, TIMER_ABSTIME);
 		ret |= do_timer(clock_id, 0);
+		ret |= do_timer_oneshot(clock_id, TIMER_ABSTIME);
+		ret |= do_timer_oneshot(clock_id, 0);
 	}
 	if (ret)
 		return ksft_exit_fail();

commit a524b1184b8e86141d689fa78ad150fbf2db9b4c
Author: Greg Hackmann <ghackmann@google.com>
Date:   Tue Jul 25 14:36:25 2017 -0700

    kselftests: timers: set-timer-lat: Tweak reporting when timer fires early
    
    Rather than printing an error inside the alarm signal handler, set a
    flag that we check later.  This keeps the test from spamming the console
    every time the alarm fires early.  It also fixes the test exiting with
    error code 0 if this was the only test failure.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: linux-kselftest@vger.kernel.org
    Signed-off-by: Greg Hackmann <ghackmann@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 4fc98c5b0899..10c2e18737c0 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -63,6 +63,7 @@ int alarmcount;
 int clock_id;
 struct timespec start_time;
 long long max_latency_ns;
+int timer_fired_early;
 
 char *clockstring(int clockid)
 {
@@ -115,12 +116,19 @@ void sigalarm(int signo)
 	delta_ns -= NSEC_PER_SEC * TIMER_SECS * alarmcount;
 
 	if (delta_ns < 0)
-		printf("%s timer fired early: FAIL\n", clockstring(clock_id));
+		timer_fired_early = 1;
 
 	if (delta_ns > max_latency_ns)
 		max_latency_ns = delta_ns;
 }
 
+void describe_timer(int flags)
+{
+	printf("%-22s %s ",
+			clockstring(clock_id),
+			flags ? "ABSTIME":"RELTIME");
+}
+
 int do_timer(int clock_id, int flags)
 {
 	struct sigevent se;
@@ -136,6 +144,7 @@ int do_timer(int clock_id, int flags)
 
 	max_latency_ns = 0;
 	alarmcount = 0;
+	timer_fired_early = 0;
 
 	err = timer_create(clock_id, &se, &tm1);
 	if (err) {
@@ -170,18 +179,26 @@ int do_timer(int clock_id, int flags)
 	while (alarmcount < 5)
 		sleep(1);
 
-	printf("%-22s %s max latency: %10lld ns : ",
-			clockstring(clock_id),
-			flags ? "ABSTIME":"RELTIME",
-			max_latency_ns);
+	describe_timer(flags);
+	printf("timer fired early: %7d : ", timer_fired_early);
+	if (!timer_fired_early) {
+		printf("[OK]\n");
+	} else {
+		printf("[FAILED]\n");
+		err = -1;
+	}
+
+	describe_timer(flags);
+	printf("max latency: %10lld ns : ", max_latency_ns);
 
 	timer_delete(tm1);
 	if (max_latency_ns < UNRESONABLE_LATENCY) {
 		printf("[OK]\n");
-		return 0;
+	} else {
+		printf("[FAILED]\n");
+		err = -1;
 	}
-	printf("[FAILED]\n");
-	return -1;
+	return err;
 }
 
 int main(void)

commit 48fd77d1444a387435c3bbc773fa4e7ab6b6aca3
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 1 20:43:39 2015 -0700

    kselftests: timers: Make set-timer-lat fail more gracefully for !CAP_WAKE_ALARM
    
    The set-timer-lat test fails when testing CLOCK_BOOTTIME_ALARM
    or CLOCK_REALTIME_ALARM when the user isn't running as root or
    with CAP_WAKE_ALARM.
    
    So this patch improves the error checking so we report the
    issue more clearly and continue rather then reporting a failure.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 2ed326750ffe..4fc98c5b0899 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -139,6 +139,13 @@ int do_timer(int clock_id, int flags)
 
 	err = timer_create(clock_id, &se, &tm1);
 	if (err) {
+		if ((clock_id == CLOCK_REALTIME_ALARM) ||
+		    (clock_id == CLOCK_BOOTTIME_ALARM)) {
+			printf("%-22s %s missing CAP_WAKE_ALARM?    : [UNSUPPORTED]\n",
+					clockstring(clock_id),
+					flags ? "ABSTIME":"RELTIME");
+			return 0;
+		}
 		printf("%s - timer_create() failed\n", clockstring(clock_id));
 		return -1;
 	}

commit e48f284d63ece564f8aa19fbf5434b3458af8d3f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 25 16:44:33 2015 -0700

    kselftests: timers: Reduce default runtime on inconsistency-check and set-timer-lat
    
    For the default run_timers target, the timers tests takes the
    majority of kselftests runtime.
    
    So this patch reduces the default runtime for inconsistentcy-check
    and set-timer-lat, which reduced the runtime almost in half.
    
    Before: 11m48.629s
    After:  6m47.723s
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
index 3ea2effbcc22..2ed326750ffe 100644
--- a/tools/testing/selftests/timers/set-timer-lat.c
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -58,7 +58,7 @@ static inline int ksft_exit_fail(void)
 #define NSEC_PER_SEC 1000000000ULL
 #define UNRESONABLE_LATENCY 40000000 /* 40ms in nanosecs */
 
-#define TIMER_SECS 3
+#define TIMER_SECS 1
 int alarmcount;
 int clock_id;
 struct timespec start_time;

commit 4e40d0a22e728102bfea9543d827ee72206eecbb
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:03 2015 -0700

    selftests/timers: Add set-timer-lat test from timetest suite
    
    Add my set-timer-lat test from the timetest suite. This
    test checks the latency from set_timer and reports if
    any are unreasonable (>40ms).
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/timers/set-timer-lat.c b/tools/testing/selftests/timers/set-timer-lat.c
new file mode 100644
index 000000000000..3ea2effbcc22
--- /dev/null
+++ b/tools/testing/selftests/timers/set-timer-lat.c
@@ -0,0 +1,209 @@
+/* set_timer latency test
+ *		John Stultz (john.stultz@linaro.org)
+ *              (C) Copyright Linaro 2014
+ *              Licensed under the GPLv2
+ *
+ *   This test makes sure the set_timer api is correct
+ *
+ *  To build:
+ *	$ gcc set-timer-lat.c -o set-timer-lat -lrt
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+
+#include <stdio.h>
+#include <unistd.h>
+#include <time.h>
+#include <string.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <pthread.h>
+#ifdef KTEST
+#include "../kselftest.h"
+#else
+static inline int ksft_exit_pass(void)
+{
+	exit(0);
+}
+static inline int ksft_exit_fail(void)
+{
+	exit(1);
+}
+#endif
+
+#define CLOCK_REALTIME			0
+#define CLOCK_MONOTONIC			1
+#define CLOCK_PROCESS_CPUTIME_ID	2
+#define CLOCK_THREAD_CPUTIME_ID		3
+#define CLOCK_MONOTONIC_RAW		4
+#define CLOCK_REALTIME_COARSE		5
+#define CLOCK_MONOTONIC_COARSE		6
+#define CLOCK_BOOTTIME			7
+#define CLOCK_REALTIME_ALARM		8
+#define CLOCK_BOOTTIME_ALARM		9
+#define CLOCK_HWSPECIFIC		10
+#define CLOCK_TAI			11
+#define NR_CLOCKIDS			12
+
+
+#define NSEC_PER_SEC 1000000000ULL
+#define UNRESONABLE_LATENCY 40000000 /* 40ms in nanosecs */
+
+#define TIMER_SECS 3
+int alarmcount;
+int clock_id;
+struct timespec start_time;
+long long max_latency_ns;
+
+char *clockstring(int clockid)
+{
+	switch (clockid) {
+	case CLOCK_REALTIME:
+		return "CLOCK_REALTIME";
+	case CLOCK_MONOTONIC:
+		return "CLOCK_MONOTONIC";
+	case CLOCK_PROCESS_CPUTIME_ID:
+		return "CLOCK_PROCESS_CPUTIME_ID";
+	case CLOCK_THREAD_CPUTIME_ID:
+		return "CLOCK_THREAD_CPUTIME_ID";
+	case CLOCK_MONOTONIC_RAW:
+		return "CLOCK_MONOTONIC_RAW";
+	case CLOCK_REALTIME_COARSE:
+		return "CLOCK_REALTIME_COARSE";
+	case CLOCK_MONOTONIC_COARSE:
+		return "CLOCK_MONOTONIC_COARSE";
+	case CLOCK_BOOTTIME:
+		return "CLOCK_BOOTTIME";
+	case CLOCK_REALTIME_ALARM:
+		return "CLOCK_REALTIME_ALARM";
+	case CLOCK_BOOTTIME_ALARM:
+		return "CLOCK_BOOTTIME_ALARM";
+	case CLOCK_TAI:
+		return "CLOCK_TAI";
+	};
+	return "UNKNOWN_CLOCKID";
+}
+
+
+long long timespec_sub(struct timespec a, struct timespec b)
+{
+	long long ret = NSEC_PER_SEC * b.tv_sec + b.tv_nsec;
+
+	ret -= NSEC_PER_SEC * a.tv_sec + a.tv_nsec;
+	return ret;
+}
+
+
+void sigalarm(int signo)
+{
+	long long delta_ns;
+	struct timespec ts;
+
+	clock_gettime(clock_id, &ts);
+	alarmcount++;
+
+	delta_ns = timespec_sub(start_time, ts);
+	delta_ns -= NSEC_PER_SEC * TIMER_SECS * alarmcount;
+
+	if (delta_ns < 0)
+		printf("%s timer fired early: FAIL\n", clockstring(clock_id));
+
+	if (delta_ns > max_latency_ns)
+		max_latency_ns = delta_ns;
+}
+
+int do_timer(int clock_id, int flags)
+{
+	struct sigevent se;
+	timer_t tm1;
+	struct itimerspec its1, its2;
+	int err;
+
+	/* Set up timer: */
+	memset(&se, 0, sizeof(se));
+	se.sigev_notify = SIGEV_SIGNAL;
+	se.sigev_signo = SIGRTMAX;
+	se.sigev_value.sival_int = 0;
+
+	max_latency_ns = 0;
+	alarmcount = 0;
+
+	err = timer_create(clock_id, &se, &tm1);
+	if (err) {
+		printf("%s - timer_create() failed\n", clockstring(clock_id));
+		return -1;
+	}
+
+	clock_gettime(clock_id, &start_time);
+	if (flags) {
+		its1.it_value = start_time;
+		its1.it_value.tv_sec += TIMER_SECS;
+	} else {
+		its1.it_value.tv_sec = TIMER_SECS;
+		its1.it_value.tv_nsec = 0;
+	}
+	its1.it_interval.tv_sec = TIMER_SECS;
+	its1.it_interval.tv_nsec = 0;
+
+	err = timer_settime(tm1, flags, &its1, &its2);
+	if (err) {
+		printf("%s - timer_settime() failed\n", clockstring(clock_id));
+		return -1;
+	}
+
+	while (alarmcount < 5)
+		sleep(1);
+
+	printf("%-22s %s max latency: %10lld ns : ",
+			clockstring(clock_id),
+			flags ? "ABSTIME":"RELTIME",
+			max_latency_ns);
+
+	timer_delete(tm1);
+	if (max_latency_ns < UNRESONABLE_LATENCY) {
+		printf("[OK]\n");
+		return 0;
+	}
+	printf("[FAILED]\n");
+	return -1;
+}
+
+int main(void)
+{
+	struct sigaction act;
+	int signum = SIGRTMAX;
+	int ret = 0;
+
+	/* Set up signal handler: */
+	sigfillset(&act.sa_mask);
+	act.sa_flags = 0;
+	act.sa_handler = sigalarm;
+	sigaction(signum, &act, NULL);
+
+	printf("Setting timers for every %i seconds\n", TIMER_SECS);
+	for (clock_id = 0; clock_id < NR_CLOCKIDS; clock_id++) {
+
+		if ((clock_id == CLOCK_PROCESS_CPUTIME_ID) ||
+				(clock_id == CLOCK_THREAD_CPUTIME_ID) ||
+				(clock_id == CLOCK_MONOTONIC_RAW) ||
+				(clock_id == CLOCK_REALTIME_COARSE) ||
+				(clock_id == CLOCK_MONOTONIC_COARSE) ||
+				(clock_id == CLOCK_HWSPECIFIC))
+			continue;
+
+		ret |= do_timer(clock_id, TIMER_ABSTIME);
+		ret |= do_timer(clock_id, 0);
+	}
+	if (ret)
+		return ksft_exit_fail();
+	return ksft_exit_pass();
+}
