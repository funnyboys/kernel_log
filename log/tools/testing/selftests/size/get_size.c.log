commit 6b64a650f0b2ae3940698f401732988699eecf7a
Author: Siddhesh Poyarekar <siddhesh@gotplt.org>
Date:   Mon Jan 13 22:11:58 2020 +0530

    kselftest: Minimise dependency of get_size on C library interfaces
    
    It was observed[1] on arm64 that __builtin_strlen led to an infinite
    loop in the get_size selftest.  This is because __builtin_strlen (and
    other builtins) may sometimes result in a call to the C library
    function.  The C library implementation of strlen uses an IFUNC
    resolver to load the most efficient strlen implementation for the
    underlying machine and hence has a PLT indirection even for static
    binaries.  Because this binary avoids the C library startup routines,
    the PLT initialization never happens and hence the program gets stuck
    in an infinite loop.
    
    On x86_64 the __builtin_strlen just happens to expand inline and avoid
    the call but that is not always guaranteed.
    
    Further, while testing on x86_64 (Fedora 31), it was observed that the
    test also failed with a segfault inside write() because the generated
    code for the write function in glibc seems to access TLS before the
    syscall (probably due to the cancellation point check) and fails
    because TLS is not initialised.
    
    To mitigate these problems, this patch reduces the interface with the
    C library to just the syscall function.  The syscall function still
    sets errno on failure, which is undesirable but for now it only
    affects cases where syscalls fail.
    
    [1] https://bugs.linaro.org/show_bug.cgi?id=5479
    
    Signed-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>
    Reported-by: Masami Hiramatsu <masami.hiramatsu@linaro.org>
    Tested-by: Masami Hiramatsu <masami.hiramatsu@linaro.org>
    Reviewed-by: Tim Bird <tim.bird@sony.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/tools/testing/selftests/size/get_size.c b/tools/testing/selftests/size/get_size.c
index 2ad45b944355..2980b1a63366 100644
--- a/tools/testing/selftests/size/get_size.c
+++ b/tools/testing/selftests/size/get_size.c
@@ -11,23 +11,35 @@
  * own execution.  It also attempts to have as few dependencies
  * on kernel features as possible.
  *
- * It should be statically linked, with startup libs avoided.
- * It uses no library calls, and only the following 3 syscalls:
+ * It should be statically linked, with startup libs avoided.  It uses
+ * no library calls except the syscall() function for the following 3
+ * syscalls:
  *   sysinfo(), write(), and _exit()
  *
  * For output, it avoids printf (which in some C libraries
  * has large external dependencies) by  implementing it's own
  * number output and print routines, and using __builtin_strlen()
+ *
+ * The test may crash if any of the above syscalls fails because in some
+ * libc implementations (e.g. the GNU C Library) errno is saved in
+ * thread-local storage, which does not get initialized due to avoiding
+ * startup libs.
  */
 
 #include <sys/sysinfo.h>
 #include <unistd.h>
+#include <sys/syscall.h>
 
 #define STDOUT_FILENO 1
 
 static int print(const char *s)
 {
-	return write(STDOUT_FILENO, s, __builtin_strlen(s));
+	size_t len = 0;
+
+	while (s[len] != '\0')
+		len++;
+
+	return syscall(SYS_write, STDOUT_FILENO, s, len);
 }
 
 static inline char *num_to_str(unsigned long num, char *buf, int len)
@@ -79,12 +91,12 @@ void _start(void)
 	print("TAP version 13\n");
 	print("# Testing system size.\n");
 
-	ccode = sysinfo(&info);
+	ccode = syscall(SYS_sysinfo, &info);
 	if (ccode < 0) {
 		print("not ok 1");
 		print(test_name);
 		print(" ---\n reason: \"could not get sysinfo\"\n ...\n");
-		_exit(ccode);
+		syscall(SYS_exit, ccode);
 	}
 	print("ok 1");
 	print(test_name);
@@ -100,5 +112,5 @@ void _start(void)
 	print(" ...\n");
 	print("1..1\n");
 
-	_exit(0);
+	syscall(SYS_exit, 0);
 }

commit 4f19048fd0a0036e02443237952db5bfa5b5cdf0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:14 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 166
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 62 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.929121379@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/tools/testing/selftests/size/get_size.c b/tools/testing/selftests/size/get_size.c
index d4b59ab979a0..2ad45b944355 100644
--- a/tools/testing/selftests/size/get_size.c
+++ b/tools/testing/selftests/size/get_size.c
@@ -1,8 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2014 Sony Mobile Communications Inc.
  *
- * Licensed under the terms of the GNU GPL License version 2
- *
  * Selftest for runtime system size
  *
  * Prints the amount of RAM that the currently running system is using.

commit 48e42f91c10482992b474cc0874c0e33d76cb509
Author: Tim Bird <tbird20d@gmail.com>
Date:   Wed Jun 14 15:28:02 2017 -0700

    kselftest: convert get_size to use stricter TAP13 format
    
    1. Add the TAP13 header
    2. remove variable data from the test description line
    3. move the plan count to the end of the file, for consistency with
    other kselftests
    4. convert memory data from diagnostic (comment) format, to a YAML block
    
    Signed-off-by: Tim Bird <tim.bird@sony.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/size/get_size.c b/tools/testing/selftests/size/get_size.c
index 2d1af7cca463..d4b59ab979a0 100644
--- a/tools/testing/selftests/size/get_size.c
+++ b/tools/testing/selftests/size/get_size.c
@@ -75,26 +75,31 @@ void _start(void)
 	int ccode;
 	struct sysinfo info;
 	unsigned long used;
+	static const char *test_name = " get runtime memory use\n";
 
-	print("Testing system size.\n");
-	print("1..1\n");
+	print("TAP version 13\n");
+	print("# Testing system size.\n");
 
 	ccode = sysinfo(&info);
 	if (ccode < 0) {
-		print("not ok 1 get runtime memory use\n");
-		print("# could not get sysinfo\n");
+		print("not ok 1");
+		print(test_name);
+		print(" ---\n reason: \"could not get sysinfo\"\n ...\n");
 		_exit(ccode);
 	}
+	print("ok 1");
+	print(test_name);
+
 	/* ignore cache complexities for now */
 	used = info.totalram - info.freeram - info.bufferram;
-	print_k_value("ok 1 get runtime memory use # size = ", used,
-		info.mem_unit);
-
 	print("# System runtime memory report (units in Kilobytes):\n");
-	print_k_value("#   Total:  ", info.totalram, info.mem_unit);
-	print_k_value("#   Free:   ", info.freeram, info.mem_unit);
-	print_k_value("#   Buffer: ", info.bufferram, info.mem_unit);
-	print_k_value("#   In use: ", used, info.mem_unit);
+	print(" ---\n");
+	print_k_value(" Total:  ", info.totalram, info.mem_unit);
+	print_k_value(" Free:   ", info.freeram, info.mem_unit);
+	print_k_value(" Buffer: ", info.bufferram, info.mem_unit);
+	print_k_value(" In use: ", used, info.mem_unit);
+	print(" ...\n");
+	print("1..1\n");
 
 	_exit(0);
 }

commit 3ce51050fadd63737c03627293ca2dc4be238891
Author: Tim Bird <tim.bird@sonymobile.com>
Date:   Wed Dec 3 10:42:21 2014 -0800

    selftest: size: Add size test for Linux kernel
    
    This test shows the amount of memory used by the system.
    Note that this is dependent on the user-space that is loaded
    when this program runs.  Optimally, this program would be
    run as the init program itself.
    
    The program is optimized for size itself, to avoid conflating
    its own execution with that of the system software.
    The code is compiled statically, with no stdlibs. On my x86_64 system,
    this results in a statically linked binary of less than 5K.
    
    Signed-off-by: Tim Bird <tim.bird@sonymobile.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

diff --git a/tools/testing/selftests/size/get_size.c b/tools/testing/selftests/size/get_size.c
new file mode 100644
index 000000000000..2d1af7cca463
--- /dev/null
+++ b/tools/testing/selftests/size/get_size.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2014 Sony Mobile Communications Inc.
+ *
+ * Licensed under the terms of the GNU GPL License version 2
+ *
+ * Selftest for runtime system size
+ *
+ * Prints the amount of RAM that the currently running system is using.
+ *
+ * This program tries to be as small as possible itself, to
+ * avoid perturbing the system memory utilization with its
+ * own execution.  It also attempts to have as few dependencies
+ * on kernel features as possible.
+ *
+ * It should be statically linked, with startup libs avoided.
+ * It uses no library calls, and only the following 3 syscalls:
+ *   sysinfo(), write(), and _exit()
+ *
+ * For output, it avoids printf (which in some C libraries
+ * has large external dependencies) by  implementing it's own
+ * number output and print routines, and using __builtin_strlen()
+ */
+
+#include <sys/sysinfo.h>
+#include <unistd.h>
+
+#define STDOUT_FILENO 1
+
+static int print(const char *s)
+{
+	return write(STDOUT_FILENO, s, __builtin_strlen(s));
+}
+
+static inline char *num_to_str(unsigned long num, char *buf, int len)
+{
+	unsigned int digit;
+
+	/* put digits in buffer from back to front */
+	buf += len - 1;
+	*buf = 0;
+	do {
+		digit = num % 10;
+		*(--buf) = digit + '0';
+		num /= 10;
+	} while (num > 0);
+
+	return buf;
+}
+
+static int print_num(unsigned long num)
+{
+	char num_buf[30];
+
+	return print(num_to_str(num, num_buf, sizeof(num_buf)));
+}
+
+static int print_k_value(const char *s, unsigned long num, unsigned long units)
+{
+	unsigned long long temp;
+	int ccode;
+
+	print(s);
+
+	temp = num;
+	temp = (temp * units)/1024;
+	num = temp;
+	ccode = print_num(num);
+	print("\n");
+	return ccode;
+}
+
+/* this program has no main(), as startup libraries are not used */
+void _start(void)
+{
+	int ccode;
+	struct sysinfo info;
+	unsigned long used;
+
+	print("Testing system size.\n");
+	print("1..1\n");
+
+	ccode = sysinfo(&info);
+	if (ccode < 0) {
+		print("not ok 1 get runtime memory use\n");
+		print("# could not get sysinfo\n");
+		_exit(ccode);
+	}
+	/* ignore cache complexities for now */
+	used = info.totalram - info.freeram - info.bufferram;
+	print_k_value("ok 1 get runtime memory use # size = ", used,
+		info.mem_unit);
+
+	print("# System runtime memory report (units in Kilobytes):\n");
+	print_k_value("#   Total:  ", info.totalram, info.mem_unit);
+	print_k_value("#   Free:   ", info.freeram, info.mem_unit);
+	print_k_value("#   Buffer: ", info.bufferram, info.mem_unit);
+	print_k_value("#   In use: ", used, info.mem_unit);
+
+	_exit(0);
+}
