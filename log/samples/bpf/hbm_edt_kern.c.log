commit 71634d7f92093062e7b8b2a9efffa5569edcca8b
Author: brakmo <brakmo@fb.com>
Date:   Tue Jul 2 15:09:52 2019 -0700

    bpf: Add support for fq's EDT to HBM
    
    Adds support for fq's Earliest Departure Time to HBM (Host Bandwidth
    Manager). Includes a new BPF program supporting EDT, and also updates
    corresponding programs.
    
    It will drop packets with an EDT of more than 500us in the future
    unless the packet belongs to a flow with less than 2 packets in flight.
    This is done so each flow has at least 2 packets in flight, so they
    will not starve, and also to help prevent delayed ACK timeouts.
    
    It will also work with ECN enabled traffic, where the packets will be
    CE marked if their EDT is more than 50us in the future.
    
    The table below shows some performance numbers. The flows are back to
    back RPCS. One server sending to another, either 2 or 4 flows.
    One flow is a 10KB RPC, the rest are 1MB RPCs. When there are more
    than one flow of a given RPC size, the numbers represent averages.
    
    The rate limit applies to all flows (they are in the same cgroup).
    Tests ending with "-edt" ran with the new BPF program supporting EDT.
    Tests ending with "-hbt" ran on top HBT qdisc with the specified rate
    (i.e. no HBM). The other tests ran with the HBM BPF program included
    in the HBM patch-set.
    
    EDT has limited value when using DCTCP, but it helps in many cases when
    using Cubic. It usually achieves larger link utilization and lower
    99% latencies for the 1MB RPCs.
    HBM ends up queueing a lot of packets with its default parameter values,
    reducing the goodput of the 10KB RPCs and increasing their latency. Also,
    the RTTs seen by the flows are quite large.
    
                             Aggr              10K  10K  10K   1MB  1MB  1MB
             Limit           rate drops  RTT  rate  P90  P99  rate  P90  P99
    Test      rate  Flows    Mbps   %     us  Mbps   us   us  Mbps   ms   ms
    --------  ----  -----    ---- -----  ---  ---- ---- ----  ---- ---- ----
    cubic       1G    2       904  0.02  108   257  511  539   647 13.4 24.5
    cubic-edt   1G    2       982  0.01  156   239  656  967   743 14.0 17.2
    dctcp       1G    2       977  0.00  105   324  408  744   653 14.5 15.9
    dctcp-edt   1G    2       981  0.01  142   321  417  811   660 15.7 17.0
    cubic-htb   1G    2       919  0.00 1825    40 2822 4140   879  9.7  9.9
    
    cubic     200M    2       155  0.30  220    81  532  655    74  283  450
    cubic-edt 200M    2       188  0.02  222    87 1035 1095   101   84   85
    dctcp     200M    2       188  0.03  111    77  912  939   111   76  325
    dctcp-edt 200M    2       188  0.03  217    74 1416 1738   114   76   79
    cubic-htb 200M    2       188  0.00 5015     8 14ms 15ms   180   48   50
    
    cubic       1G    4       952  0.03  110   165  516  546   262   38  154
    cubic-edt   1G    4       973  0.01  190   111 1034 1314   287   65   79
    dctcp       1G    4       951  0.00  103   180  617  905   257   37   38
    dctcp-edt   1G    4       967  0.00  163   151  732 1126   272   43   55
    cubic-htb   1G    4       914  0.00 3249    13  7ms  8ms   300   29   34
    
    cubic       5G    4      4236  0.00  134   305  490  624  1310   10   17
    cubic-edt   5G    4      4865  0.00  156   306  425  759  1520   10   16
    dctcp       5G    4      4936  0.00  128   485  221  409  1484    7    9
    dctcp-edt   5G    4      4924  0.00  148   390  392  623  1508   11   26
    
    v1 -> v2: Incorporated Andrii's suggestions
    v2 -> v3: Incorporated Yonghong's suggestions
    v3 -> v4: Removed credit update that is not needed
    
    Signed-off-by: Lawrence Brakmo <brakmo@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/samples/bpf/hbm_edt_kern.c b/samples/bpf/hbm_edt_kern.c
new file mode 100644
index 000000000000..a65b677acdb0
--- /dev/null
+++ b/samples/bpf/hbm_edt_kern.c
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019 Facebook
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * Sample Host Bandwidth Manager (HBM) BPF program.
+ *
+ * A cgroup skb BPF egress program to limit cgroup output bandwidth.
+ * It uses a modified virtual token bucket queue to limit average
+ * egress bandwidth. The implementation uses credits instead of tokens.
+ * Negative credits imply that queueing would have happened (this is
+ * a virtual queue, so no queueing is done by it. However, queueing may
+ * occur at the actual qdisc (which is not used for rate limiting).
+ *
+ * This implementation uses 3 thresholds, one to start marking packets and
+ * the other two to drop packets:
+ *                                  CREDIT
+ *        - <--------------------------|------------------------> +
+ *              |    |          |      0
+ *              |  Large pkt    |
+ *              |  drop thresh  |
+ *   Small pkt drop             Mark threshold
+ *       thresh
+ *
+ * The effect of marking depends on the type of packet:
+ * a) If the packet is ECN enabled and it is a TCP packet, then the packet
+ *    is ECN marked.
+ * b) If the packet is a TCP packet, then we probabilistically call tcp_cwr
+ *    to reduce the congestion window. The current implementation uses a linear
+ *    distribution (0% probability at marking threshold, 100% probability
+ *    at drop threshold).
+ * c) If the packet is not a TCP packet, then it is dropped.
+ *
+ * If the credit is below the drop threshold, the packet is dropped. If it
+ * is a TCP packet, then it also calls tcp_cwr since packets dropped by
+ * by a cgroup skb BPF program do not automatically trigger a call to
+ * tcp_cwr in the current kernel code.
+ *
+ * This BPF program actually uses 2 drop thresholds, one threshold
+ * for larger packets (>= 120 bytes) and another for smaller packets. This
+ * protects smaller packets such as SYNs, ACKs, etc.
+ *
+ * The default bandwidth limit is set at 1Gbps but this can be changed by
+ * a user program through a shared BPF map. In addition, by default this BPF
+ * program does not limit connections using loopback. This behavior can be
+ * overwritten by the user program. There is also an option to calculate
+ * some statistics, such as percent of packets marked or dropped, which
+ * a user program, such as hbm, can access.
+ */
+
+#include "hbm_kern.h"
+
+SEC("cgroup_skb/egress")
+int _hbm_out_cg(struct __sk_buff *skb)
+{
+	long long delta = 0, delta_send;
+	unsigned long long curtime, sendtime;
+	struct hbm_queue_stats *qsp = NULL;
+	unsigned int queue_index = 0;
+	bool congestion_flag = false;
+	bool ecn_ce_flag = false;
+	struct hbm_pkt_info pkti = {};
+	struct hbm_vqueue *qdp;
+	bool drop_flag = false;
+	bool cwr_flag = false;
+	int len = skb->len;
+	int rv = ALLOW_PKT;
+
+	qsp = bpf_map_lookup_elem(&queue_stats, &queue_index);
+
+	// Check if we should ignore loopback traffic
+	if (qsp != NULL && !qsp->loopback && (skb->ifindex == 1))
+		return ALLOW_PKT;
+
+	hbm_get_pkt_info(skb, &pkti);
+
+	// We may want to account for the length of headers in len
+	// calculation, like ETH header + overhead, specially if it
+	// is a gso packet. But I am not doing it right now.
+
+	qdp = bpf_get_local_storage(&queue_state, 0);
+	if (!qdp)
+		return ALLOW_PKT;
+	if (qdp->lasttime == 0)
+		hbm_init_edt_vqueue(qdp, 1024);
+
+	curtime = bpf_ktime_get_ns();
+
+	// Begin critical section
+	bpf_spin_lock(&qdp->lock);
+	delta = qdp->lasttime - curtime;
+	// bound bursts to 100us
+	if (delta < -BURST_SIZE_NS) {
+		// negative delta is a credit that allows bursts
+		qdp->lasttime = curtime - BURST_SIZE_NS;
+		delta = -BURST_SIZE_NS;
+	}
+	sendtime = qdp->lasttime;
+	delta_send = BYTES_TO_NS(len, qdp->rate);
+	__sync_add_and_fetch(&(qdp->lasttime), delta_send);
+	bpf_spin_unlock(&qdp->lock);
+	// End critical section
+
+	// Set EDT of packet
+	skb->tstamp = sendtime;
+
+	// Check if we should update rate
+	if (qsp != NULL && (qsp->rate * 128) != qdp->rate)
+		qdp->rate = qsp->rate * 128;
+
+	// Set flags (drop, congestion, cwr)
+	// last packet will be sent in the future, bound latency
+	if (delta > DROP_THRESH_NS || (delta > LARGE_PKT_DROP_THRESH_NS &&
+				       len > LARGE_PKT_THRESH)) {
+		drop_flag = true;
+		if (pkti.is_tcp && pkti.ecn == 0)
+			cwr_flag = true;
+	} else if (delta > MARK_THRESH_NS) {
+		if (pkti.is_tcp)
+			congestion_flag = true;
+		else
+			drop_flag = true;
+	}
+
+	if (congestion_flag) {
+		if (bpf_skb_ecn_set_ce(skb)) {
+			ecn_ce_flag = true;
+		} else {
+			if (pkti.is_tcp) {
+				unsigned int rand = bpf_get_prandom_u32();
+
+				if (delta >= MARK_THRESH_NS +
+				    (rand % MARK_REGION_SIZE_NS)) {
+					// Do congestion control
+					cwr_flag = true;
+				}
+			} else if (len > LARGE_PKT_THRESH) {
+				// Problem if too many small packets?
+				drop_flag = true;
+				congestion_flag = false;
+			}
+		}
+	}
+
+	if (pkti.is_tcp && drop_flag && pkti.packets_out <= 1) {
+		drop_flag = false;
+		cwr_flag = true;
+		congestion_flag = false;
+	}
+
+	if (qsp != NULL && qsp->no_cn)
+			cwr_flag = false;
+
+	hbm_update_stats(qsp, len, curtime, congestion_flag, drop_flag,
+			 cwr_flag, ecn_ce_flag, &pkti, (int) delta);
+
+	if (drop_flag) {
+		__sync_add_and_fetch(&(qdp->lasttime), -delta_send);
+		rv = DROP_PKT;
+	}
+
+	if (cwr_flag)
+		rv |= CWR;
+	return rv;
+}
+char _license[] SEC("license") = "GPL";
