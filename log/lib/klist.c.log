commit 8092f73c51567470bd79472c6eb25d2e1841fac3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:45:04 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 248
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gpl v2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 3 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204655.103854853@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/klist.c b/lib/klist.c
index f6b547812fe3..332a4fbf18ff 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * klist.c - Routines for manipulating klists.
  *
  * Copyright (C) 2005 Patrick Mochel
  *
- * This file is released under the GPL v2.
- *
  * This klist interface provides a couple of structures that wrap around
  * struct list_head to provide explicit list "head" (struct klist) and list
  * "node" (struct klist_node) objects. For struct klist, a spinlock is

commit 624fa7790f80575a4ec28fbdb2034097dc18d051
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Jun 22 14:54:49 2018 -0700

    scsi: klist: Make it safe to use klists in atomic context
    
    In the scsi_transport_srp implementation it cannot be avoided to
    iterate over a klist from atomic context when using the legacy block
    layer instead of blk-mq. Hence this patch that makes it safe to use
    klists in atomic context. This patch avoids that lockdep reports the
    following:
    
    WARNING: SOFTIRQ-safe -> SOFTIRQ-unsafe lock order detected
     Possible interrupt unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&(&k->k_lock)->rlock);
                                   local_irq_disable();
                                   lock(&(&q->__queue_lock)->rlock);
                                   lock(&(&k->k_lock)->rlock);
      <Interrupt>
        lock(&(&q->__queue_lock)->rlock);
    
    stack backtrace:
    Workqueue: kblockd blk_timeout_work
    Call Trace:
     dump_stack+0xa4/0xf5
     check_usage+0x6e6/0x700
     __lock_acquire+0x185d/0x1b50
     lock_acquire+0xd2/0x260
     _raw_spin_lock+0x32/0x50
     klist_next+0x47/0x190
     device_for_each_child+0x8e/0x100
     srp_timed_out+0xaf/0x1d0 [scsi_transport_srp]
     scsi_times_out+0xd4/0x410 [scsi_mod]
     blk_rq_timed_out+0x36/0x70
     blk_timeout_work+0x1b5/0x220
     process_one_work+0x4fe/0xad0
     worker_thread+0x63/0x5a0
     kthread+0x1c1/0x1e0
     ret_from_fork+0x24/0x30
    
    See also commit c9ddf73476ff ("scsi: scsi_transport_srp: Fix shost to
    rport translation").
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: James Bottomley <jejb@linux.vnet.ibm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/lib/klist.c b/lib/klist.c
index 0507fa5d84c5..f6b547812fe3 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -336,8 +336,9 @@ struct klist_node *klist_prev(struct klist_iter *i)
 	void (*put)(struct klist_node *) = i->i_klist->put;
 	struct klist_node *last = i->i_cur;
 	struct klist_node *prev;
+	unsigned long flags;
 
-	spin_lock(&i->i_klist->k_lock);
+	spin_lock_irqsave(&i->i_klist->k_lock, flags);
 
 	if (last) {
 		prev = to_klist_node(last->n_node.prev);
@@ -356,7 +357,7 @@ struct klist_node *klist_prev(struct klist_iter *i)
 		prev = to_klist_node(prev->n_node.prev);
 	}
 
-	spin_unlock(&i->i_klist->k_lock);
+	spin_unlock_irqrestore(&i->i_klist->k_lock, flags);
 
 	if (put && last)
 		put(last);
@@ -377,8 +378,9 @@ struct klist_node *klist_next(struct klist_iter *i)
 	void (*put)(struct klist_node *) = i->i_klist->put;
 	struct klist_node *last = i->i_cur;
 	struct klist_node *next;
+	unsigned long flags;
 
-	spin_lock(&i->i_klist->k_lock);
+	spin_lock_irqsave(&i->i_klist->k_lock, flags);
 
 	if (last) {
 		next = to_klist_node(last->n_node.next);
@@ -397,7 +399,7 @@ struct klist_node *klist_next(struct klist_iter *i)
 		next = to_klist_node(next->n_node.next);
 	}
 
-	spin_unlock(&i->i_klist->k_lock);
+	spin_unlock_irqrestore(&i->i_klist->k_lock, flags);
 
 	if (put && last)
 		put(last);

commit 00cd29b799e3449f0c68b1cc77cd4a5f95b42d17
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Jan 13 08:10:31 2016 -0800

    klist: fix starting point removed bug in klist iterators
    
    The starting node for a klist iteration is often passed in from
    somewhere way above the klist infrastructure, meaning there's no
    guarantee the node is still on the list.  We've seen this in SCSI where
    we use bus_find_device() to iterate through a list of devices.  In the
    face of heavy hotplug activity, the last device returned by
    bus_find_device() can be removed before the next call.  This leads to
    
    Dec  3 13:22:02 localhost kernel: WARNING: CPU: 2 PID: 28073 at include/linux/kref.h:47 klist_iter_init_node+0x3d/0x50()
    Dec  3 13:22:02 localhost kernel: Modules linked in: scsi_debug x86_pkg_temp_thermal kvm_intel kvm irqbypass crc32c_intel joydev iTCO_wdt dcdbas ipmi_devintf acpi_power_meter iTCO_vendor_support ipmi_si imsghandler pcspkr wmi acpi_cpufreq tpm_tis tpm shpchp lpc_ich mfd_core nfsd nfs_acl lockd grace sunrpc tg3 ptp pps_core
    Dec  3 13:22:02 localhost kernel: CPU: 2 PID: 28073 Comm: cat Not tainted 4.4.0-rc1+ #2
    Dec  3 13:22:02 localhost kernel: Hardware name: Dell Inc. PowerEdge R320/08VT7V, BIOS 2.0.22 11/19/2013
    Dec  3 13:22:02 localhost kernel: ffffffff81a20e77 ffff880613acfd18 ffffffff81321eef 0000000000000000
    Dec  3 13:22:02 localhost kernel: ffff880613acfd50 ffffffff8107ca52 ffff88061176b198 0000000000000000
    Dec  3 13:22:02 localhost kernel: ffffffff814542b0 ffff880610cfb100 ffff88061176b198 ffff880613acfd60
    Dec  3 13:22:02 localhost kernel: Call Trace:
    Dec  3 13:22:02 localhost kernel: [<ffffffff81321eef>] dump_stack+0x44/0x55
    Dec  3 13:22:02 localhost kernel: [<ffffffff8107ca52>] warn_slowpath_common+0x82/0xc0
    Dec  3 13:22:02 localhost kernel: [<ffffffff814542b0>] ? proc_scsi_show+0x20/0x20
    Dec  3 13:22:02 localhost kernel: [<ffffffff8107cb4a>] warn_slowpath_null+0x1a/0x20
    Dec  3 13:22:02 localhost kernel: [<ffffffff8167225d>] klist_iter_init_node+0x3d/0x50
    Dec  3 13:22:02 localhost kernel: [<ffffffff81421d41>] bus_find_device+0x51/0xb0
    Dec  3 13:22:02 localhost kernel: [<ffffffff814545ad>] scsi_seq_next+0x2d/0x40
    [...]
    
    And an eventual crash. It can actually occur in any hotplug system
    which has a device finder and a starting device.
    
    We can fix this globally by making sure the starting node for
    klist_iter_init_node() is actually a member of the list before using it
    (and by starting from the beginning if it isn't).
    
    Reported-by: Ewan D. Milne <emilne@redhat.com>
    Tested-by: Ewan D. Milne <emilne@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/klist.c b/lib/klist.c
index d74cf7a29afd..0507fa5d84c5 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -282,9 +282,9 @@ void klist_iter_init_node(struct klist *k, struct klist_iter *i,
 			  struct klist_node *n)
 {
 	i->i_klist = k;
-	i->i_cur = n;
-	if (n)
-		kref_get(&n->n_ref);
+	i->i_cur = NULL;
+	if (n && kref_get_unless_zero(&n->n_ref))
+		i->i_cur = n;
 }
 EXPORT_SYMBOL_GPL(klist_iter_init_node);
 

commit 2e0fed7f7cdc41679e209c5636ad7537dc6210a9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 27 18:03:59 2015 +0300

    klist: implement klist_prev()
    
    klist_prev() gets the previous element in the list. It is useful to traverse
    through the list in reverse order, for example, to provide LIFO (last in first
    out) variant of access.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/lib/klist.c b/lib/klist.c
index 89b485a2a58d..d74cf7a29afd 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -323,6 +323,47 @@ static struct klist_node *to_klist_node(struct list_head *n)
 	return container_of(n, struct klist_node, n_node);
 }
 
+/**
+ * klist_prev - Ante up prev node in list.
+ * @i: Iterator structure.
+ *
+ * First grab list lock. Decrement the reference count of the previous
+ * node, if there was one. Grab the prev node, increment its reference
+ * count, drop the lock, and return that prev node.
+ */
+struct klist_node *klist_prev(struct klist_iter *i)
+{
+	void (*put)(struct klist_node *) = i->i_klist->put;
+	struct klist_node *last = i->i_cur;
+	struct klist_node *prev;
+
+	spin_lock(&i->i_klist->k_lock);
+
+	if (last) {
+		prev = to_klist_node(last->n_node.prev);
+		if (!klist_dec_and_del(last))
+			put = NULL;
+	} else
+		prev = to_klist_node(i->i_klist->k_list.prev);
+
+	i->i_cur = NULL;
+	while (prev != to_klist_node(&i->i_klist->k_list)) {
+		if (likely(!knode_dead(prev))) {
+			kref_get(&prev->n_ref);
+			i->i_cur = prev;
+			break;
+		}
+		prev = to_klist_node(prev->n_node.prev);
+	}
+
+	spin_unlock(&i->i_klist->k_lock);
+
+	if (put && last)
+		put(last);
+	return i->i_cur;
+}
+EXPORT_SYMBOL_GPL(klist_prev);
+
 /**
  * klist_next - Ante up next node in list.
  * @i: Iterator structure.

commit 0f9859ca92c9182bcb8f18c55cae1a04627cbb59
Author: Ken Helias <kenhelias@firemail.de>
Date:   Wed Aug 6 16:09:18 2014 -0700

    klist: use same naming scheme as hlist for klist_add_after()
    
    The name was modified from hlist_add_after() to hlist_add_behind() when
    adjusting the order of arguments to match the one with
    klist_add_after().  This is necessary to break old code when it would
    use it the wrong way.
    
    Make klist follow this naming scheme for consistency.
    
    Signed-off-by: Ken Helias <kenhelias@firemail.de>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/klist.c b/lib/klist.c
index 358a368a2947..89b485a2a58d 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -140,11 +140,11 @@ void klist_add_tail(struct klist_node *n, struct klist *k)
 EXPORT_SYMBOL_GPL(klist_add_tail);
 
 /**
- * klist_add_after - Init a klist_node and add it after an existing node
+ * klist_add_behind - Init a klist_node and add it after an existing node
  * @n: node we're adding.
  * @pos: node to put @n after
  */
-void klist_add_after(struct klist_node *n, struct klist_node *pos)
+void klist_add_behind(struct klist_node *n, struct klist_node *pos)
 {
 	struct klist *k = knode_klist(pos);
 
@@ -153,7 +153,7 @@ void klist_add_after(struct klist_node *n, struct klist_node *pos)
 	list_add(&n->n_node, &pos->n_node);
 	spin_unlock(&k->k_lock);
 }
-EXPORT_SYMBOL_GPL(klist_add_after);
+EXPORT_SYMBOL_GPL(klist_add_behind);
 
 /**
  * klist_add_before - Init a klist_node and add it before an existing node

commit ac5a2962b02f57dea76d314ef2521a2170b28ab6
Author: wang, biao <biao.wang@intel.com>
Date:   Thu May 16 09:50:13 2013 +0800

    klist: del waiter from klist_remove_waiters before wakeup waitting process
    
    There is a race between klist_remove and klist_release. klist_remove
    uses a local var waiter saved on stack. When klist_release calls
    wake_up_process(waiter->process) to wake up the waiter, waiter might run
    immediately and reuse the stack. Then, klist_release calls
    list_del(&waiter->list) to change previous
    wait data and cause prior waiter thread corrupt.
    
    The patch fixes it against kernel 3.9.
    
    Signed-off-by: wang, biao <biao.wang@intel.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/klist.c b/lib/klist.c
index 0874e41609a6..358a368a2947 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -193,10 +193,10 @@ static void klist_release(struct kref *kref)
 		if (waiter->node != n)
 			continue;
 
+		list_del(&waiter->list);
 		waiter->woken = 1;
 		mb();
 		wake_up_process(waiter->process);
-		list_del(&waiter->list);
 	}
 	spin_unlock(&klist_remove_lock);
 	knode_set_klist(n, NULL);

commit 8bc3bcc93a2b4e47d5d410146f6546bca6171663
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 16 21:29:17 2011 -0500

    lib: reduce the use of module.h wherever possible
    
    For files only using THIS_MODULE and/or EXPORT_SYMBOL, map
    them onto including export.h -- or if the file isn't even
    using those, then just delete the include.  Fix up any implicit
    include dependencies that were being masked by module.h along
    the way.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/lib/klist.c b/lib/klist.c
index 573d6068a42e..0874e41609a6 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -35,7 +35,7 @@
  */
 
 #include <linux/klist.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/sched.h>
 
 /*

commit 210272a28465a7a31bcd580d2f9529f924965aa5
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Oct 16 14:57:54 2008 -0600

    driver core: Remove completion from struct klist_node
    
    Removing the completion from klist_node reduces its size from 64 bytes
    to 28 on x86-64.  To maintain the semantics of klist_remove(), we add
    a single list of klist nodes which are pending deletion and scan them.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index bbdd3015c2c7..573d6068a42e 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -36,6 +36,7 @@
 
 #include <linux/klist.h>
 #include <linux/module.h>
+#include <linux/sched.h>
 
 /*
  * Use the lowest bit of n_klist to mark deleted nodes and exclude
@@ -108,7 +109,6 @@ static void add_tail(struct klist *k, struct klist_node *n)
 static void klist_node_init(struct klist *k, struct klist_node *n)
 {
 	INIT_LIST_HEAD(&n->n_node);
-	init_completion(&n->n_removed);
 	kref_init(&n->n_ref);
 	knode_set_klist(n, k);
 	if (k->get)
@@ -171,13 +171,34 @@ void klist_add_before(struct klist_node *n, struct klist_node *pos)
 }
 EXPORT_SYMBOL_GPL(klist_add_before);
 
+struct klist_waiter {
+	struct list_head list;
+	struct klist_node *node;
+	struct task_struct *process;
+	int woken;
+};
+
+static DEFINE_SPINLOCK(klist_remove_lock);
+static LIST_HEAD(klist_remove_waiters);
+
 static void klist_release(struct kref *kref)
 {
+	struct klist_waiter *waiter, *tmp;
 	struct klist_node *n = container_of(kref, struct klist_node, n_ref);
 
 	WARN_ON(!knode_dead(n));
 	list_del(&n->n_node);
-	complete(&n->n_removed);
+	spin_lock(&klist_remove_lock);
+	list_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {
+		if (waiter->node != n)
+			continue;
+
+		waiter->woken = 1;
+		mb();
+		wake_up_process(waiter->process);
+		list_del(&waiter->list);
+	}
+	spin_unlock(&klist_remove_lock);
 	knode_set_klist(n, NULL);
 }
 
@@ -217,8 +238,24 @@ EXPORT_SYMBOL_GPL(klist_del);
  */
 void klist_remove(struct klist_node *n)
 {
+	struct klist_waiter waiter;
+
+	waiter.node = n;
+	waiter.process = current;
+	waiter.woken = 0;
+	spin_lock(&klist_remove_lock);
+	list_add(&waiter.list, &klist_remove_waiters);
+	spin_unlock(&klist_remove_lock);
+
 	klist_del(n);
-	wait_for_completion(&n->n_removed);
+
+	for (;;) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		if (waiter.woken)
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
 }
 EXPORT_SYMBOL_GPL(klist_remove);
 

commit a1ed5b0cffe4b16a93a6a3390e8cee0fbef94f86
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 25 19:50:16 2008 +0200

    klist: don't iterate over deleted entries
    
    A klist entry is kept on the list till all its current iterations are
    finished; however, a new iteration after deletion also iterates over
    deleted entries as long as their reference count stays above zero.
    This causes problems for cases where there are users which iterate
    over the list while synchronized against list manipulations and
    natuarally expect already deleted entries to not show up during
    iteration.
    
    This patch implements dead flag which gets set on deletion so that
    iteration can skip already deleted entries.  The dead flag piggy backs
    on the lowest bit of knode->n_klist and only visible to klist
    implementation proper.
    
    While at it, drop klist_iter->i_head as it's redundant and doesn't
    offer anything in semantics or performance wise as klist_iter->i_klist
    is dereferenced on every iteration anyway.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/lib/klist.c b/lib/klist.c
index cca37f96faa2..bbdd3015c2c7 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -37,6 +37,37 @@
 #include <linux/klist.h>
 #include <linux/module.h>
 
+/*
+ * Use the lowest bit of n_klist to mark deleted nodes and exclude
+ * dead ones from iteration.
+ */
+#define KNODE_DEAD		1LU
+#define KNODE_KLIST_MASK	~KNODE_DEAD
+
+static struct klist *knode_klist(struct klist_node *knode)
+{
+	return (struct klist *)
+		((unsigned long)knode->n_klist & KNODE_KLIST_MASK);
+}
+
+static bool knode_dead(struct klist_node *knode)
+{
+	return (unsigned long)knode->n_klist & KNODE_DEAD;
+}
+
+static void knode_set_klist(struct klist_node *knode, struct klist *klist)
+{
+	knode->n_klist = klist;
+	/* no knode deserves to start its life dead */
+	WARN_ON(knode_dead(knode));
+}
+
+static void knode_kill(struct klist_node *knode)
+{
+	/* and no knode should die twice ever either, see we're very humane */
+	WARN_ON(knode_dead(knode));
+	*(unsigned long *)&knode->n_klist |= KNODE_DEAD;
+}
 
 /**
  * klist_init - Initialize a klist structure.
@@ -79,7 +110,7 @@ static void klist_node_init(struct klist *k, struct klist_node *n)
 	INIT_LIST_HEAD(&n->n_node);
 	init_completion(&n->n_removed);
 	kref_init(&n->n_ref);
-	n->n_klist = k;
+	knode_set_klist(n, k);
 	if (k->get)
 		k->get(n);
 }
@@ -115,7 +146,7 @@ EXPORT_SYMBOL_GPL(klist_add_tail);
  */
 void klist_add_after(struct klist_node *n, struct klist_node *pos)
 {
-	struct klist *k = pos->n_klist;
+	struct klist *k = knode_klist(pos);
 
 	klist_node_init(k, n);
 	spin_lock(&k->k_lock);
@@ -131,7 +162,7 @@ EXPORT_SYMBOL_GPL(klist_add_after);
  */
 void klist_add_before(struct klist_node *n, struct klist_node *pos)
 {
-	struct klist *k = pos->n_klist;
+	struct klist *k = knode_klist(pos);
 
 	klist_node_init(k, n);
 	spin_lock(&k->k_lock);
@@ -144,9 +175,10 @@ static void klist_release(struct kref *kref)
 {
 	struct klist_node *n = container_of(kref, struct klist_node, n_ref);
 
+	WARN_ON(!knode_dead(n));
 	list_del(&n->n_node);
 	complete(&n->n_removed);
-	n->n_klist = NULL;
+	knode_set_klist(n, NULL);
 }
 
 static int klist_dec_and_del(struct klist_node *n)
@@ -154,22 +186,29 @@ static int klist_dec_and_del(struct klist_node *n)
 	return kref_put(&n->n_ref, klist_release);
 }
 
-/**
- * klist_del - Decrement the reference count of node and try to remove.
- * @n: node we're deleting.
- */
-void klist_del(struct klist_node *n)
+static void klist_put(struct klist_node *n, bool kill)
 {
-	struct klist *k = n->n_klist;
+	struct klist *k = knode_klist(n);
 	void (*put)(struct klist_node *) = k->put;
 
 	spin_lock(&k->k_lock);
+	if (kill)
+		knode_kill(n);
 	if (!klist_dec_and_del(n))
 		put = NULL;
 	spin_unlock(&k->k_lock);
 	if (put)
 		put(n);
 }
+
+/**
+ * klist_del - Decrement the reference count of node and try to remove.
+ * @n: node we're deleting.
+ */
+void klist_del(struct klist_node *n)
+{
+	klist_put(n, true);
+}
 EXPORT_SYMBOL_GPL(klist_del);
 
 /**
@@ -206,7 +245,6 @@ void klist_iter_init_node(struct klist *k, struct klist_iter *i,
 			  struct klist_node *n)
 {
 	i->i_klist = k;
-	i->i_head = &k->k_list;
 	i->i_cur = n;
 	if (n)
 		kref_get(&n->n_ref);
@@ -237,7 +275,7 @@ EXPORT_SYMBOL_GPL(klist_iter_init);
 void klist_iter_exit(struct klist_iter *i)
 {
 	if (i->i_cur) {
-		klist_del(i->i_cur);
+		klist_put(i->i_cur, false);
 		i->i_cur = NULL;
 	}
 }
@@ -258,27 +296,33 @@ static struct klist_node *to_klist_node(struct list_head *n)
  */
 struct klist_node *klist_next(struct klist_iter *i)
 {
-	struct list_head *next;
-	struct klist_node *lnode = i->i_cur;
-	struct klist_node *knode = NULL;
 	void (*put)(struct klist_node *) = i->i_klist->put;
+	struct klist_node *last = i->i_cur;
+	struct klist_node *next;
 
 	spin_lock(&i->i_klist->k_lock);
-	if (lnode) {
-		next = lnode->n_node.next;
-		if (!klist_dec_and_del(lnode))
+
+	if (last) {
+		next = to_klist_node(last->n_node.next);
+		if (!klist_dec_and_del(last))
 			put = NULL;
 	} else
-		next = i->i_head->next;
+		next = to_klist_node(i->i_klist->k_list.next);
 
-	if (next != i->i_head) {
-		knode = to_klist_node(next);
-		kref_get(&knode->n_ref);
+	i->i_cur = NULL;
+	while (next != to_klist_node(&i->i_klist->k_list)) {
+		if (likely(!knode_dead(next))) {
+			kref_get(&next->n_ref);
+			i->i_cur = next;
+			break;
+		}
+		next = to_klist_node(next->n_node.next);
 	}
-	i->i_cur = knode;
+
 	spin_unlock(&i->i_klist->k_lock);
-	if (put && lnode)
-		put(lnode);
-	return knode;
+
+	if (put && last)
+		put(last);
+	return i->i_cur;
 }
 EXPORT_SYMBOL_GPL(klist_next);

commit c3bb7fadaf52de3637b834002dac27f6250b4b49
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 30 16:43:45 2008 -0700

    klist: fix coding style errors in klist.h and klist.c
    
    Finally clean up the odd spacing in these files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index ebba9488046e..cca37f96faa2 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -1,38 +1,37 @@
 /*
- *	klist.c - Routines for manipulating klists.
+ * klist.c - Routines for manipulating klists.
  *
+ * Copyright (C) 2005 Patrick Mochel
  *
- *	This klist interface provides a couple of structures that wrap around 
- *	struct list_head to provide explicit list "head" (struct klist) and 
- *	list "node" (struct klist_node) objects. For struct klist, a spinlock
- *	is included that protects access to the actual list itself. struct 
- *	klist_node provides a pointer to the klist that owns it and a kref
- *	reference count that indicates the number of current users of that node
- *	in the list.
+ * This file is released under the GPL v2.
  *
- *	The entire point is to provide an interface for iterating over a list
- *	that is safe and allows for modification of the list during the
- *	iteration (e.g. insertion and removal), including modification of the
- *	current node on the list.
+ * This klist interface provides a couple of structures that wrap around
+ * struct list_head to provide explicit list "head" (struct klist) and list
+ * "node" (struct klist_node) objects. For struct klist, a spinlock is
+ * included that protects access to the actual list itself. struct
+ * klist_node provides a pointer to the klist that owns it and a kref
+ * reference count that indicates the number of current users of that node
+ * in the list.
  *
- *	It works using a 3rd object type - struct klist_iter - that is declared
- *	and initialized before an iteration. klist_next() is used to acquire the
- *	next element in the list. It returns NULL if there are no more items.
- *	Internally, that routine takes the klist's lock, decrements the reference
- *	count of the previous klist_node and increments the count of the next
- *	klist_node. It then drops the lock and returns.
+ * The entire point is to provide an interface for iterating over a list
+ * that is safe and allows for modification of the list during the
+ * iteration (e.g. insertion and removal), including modification of the
+ * current node on the list.
  *
- *	There are primitives for adding and removing nodes to/from a klist. 
- *	When deleting, klist_del() will simply decrement the reference count. 
- *	Only when the count goes to 0 is the node removed from the list. 
- *	klist_remove() will try to delete the node from the list and block
- *	until it is actually removed. This is useful for objects (like devices)
- *	that have been removed from the system and must be freed (but must wait
- *	until all accessors have finished).
+ * It works using a 3rd object type - struct klist_iter - that is declared
+ * and initialized before an iteration. klist_next() is used to acquire the
+ * next element in the list. It returns NULL if there are no more items.
+ * Internally, that routine takes the klist's lock, decrements the
+ * reference count of the previous klist_node and increments the count of
+ * the next klist_node. It then drops the lock and returns.
  *
- *	Copyright (C) 2005 Patrick Mochel
- *
- *	This file is released under the GPL v2.
+ * There are primitives for adding and removing nodes to/from a klist.
+ * When deleting, klist_del() will simply decrement the reference count.
+ * Only when the count goes to 0 is the node removed from the list.
+ * klist_remove() will try to delete the node from the list and block until
+ * it is actually removed. This is useful for objects (like devices) that
+ * have been removed from the system and must be freed (but must wait until
+ * all accessors have finished).
  */
 
 #include <linux/klist.h>
@@ -40,10 +39,10 @@
 
 
 /**
- *	klist_init - Initialize a klist structure. 
- *	@k:	The klist we're initializing.
- *	@get:	The get function for the embedding object (NULL if none)
- *	@put:	The put function for the embedding object (NULL if none)
+ * klist_init - Initialize a klist structure.
+ * @k: The klist we're initializing.
+ * @get: The get function for the embedding object (NULL if none)
+ * @put: The put function for the embedding object (NULL if none)
  *
  * Initialises the klist structure.  If the klist_node structures are
  * going to be embedded in refcounted objects (necessary for safe
@@ -51,8 +50,7 @@
  * functions that take and release references on the embedding
  * objects.
  */
-
-void klist_init(struct klist * k, void (*get)(struct klist_node *),
+void klist_init(struct klist *k, void (*get)(struct klist_node *),
 		void (*put)(struct klist_node *))
 {
 	INIT_LIST_HEAD(&k->k_list);
@@ -60,26 +58,23 @@ void klist_init(struct klist * k, void (*get)(struct klist_node *),
 	k->get = get;
 	k->put = put;
 }
-
 EXPORT_SYMBOL_GPL(klist_init);
 
-
-static void add_head(struct klist * k, struct klist_node * n)
+static void add_head(struct klist *k, struct klist_node *n)
 {
 	spin_lock(&k->k_lock);
 	list_add(&n->n_node, &k->k_list);
 	spin_unlock(&k->k_lock);
 }
 
-static void add_tail(struct klist * k, struct klist_node * n)
+static void add_tail(struct klist *k, struct klist_node *n)
 {
 	spin_lock(&k->k_lock);
 	list_add_tail(&n->n_node, &k->k_list);
 	spin_unlock(&k->k_lock);
 }
 
-
-static void klist_node_init(struct klist * k, struct klist_node * n)
+static void klist_node_init(struct klist *k, struct klist_node *n)
 {
 	INIT_LIST_HEAD(&n->n_node);
 	init_completion(&n->n_removed);
@@ -89,37 +84,30 @@ static void klist_node_init(struct klist * k, struct klist_node * n)
 		k->get(n);
 }
 
-
 /**
- *	klist_add_head - Initialize a klist_node and add it to front.
- *	@n:	node we're adding.
- *	@k:	klist it's going on.
+ * klist_add_head - Initialize a klist_node and add it to front.
+ * @n: node we're adding.
+ * @k: klist it's going on.
  */
-
-void klist_add_head(struct klist_node * n, struct klist * k)
+void klist_add_head(struct klist_node *n, struct klist *k)
 {
 	klist_node_init(k, n);
 	add_head(k, n);
 }
-
 EXPORT_SYMBOL_GPL(klist_add_head);
 
-
 /**
- *	klist_add_tail - Initialize a klist_node and add it to back.
- *	@n:	node we're adding.
- *	@k:	klist it's going on.
+ * klist_add_tail - Initialize a klist_node and add it to back.
+ * @n: node we're adding.
+ * @k: klist it's going on.
  */
-
-void klist_add_tail(struct klist_node * n, struct klist * k)
+void klist_add_tail(struct klist_node *n, struct klist *k)
 {
 	klist_node_init(k, n);
 	add_tail(k, n);
 }
-
 EXPORT_SYMBOL_GPL(klist_add_tail);
 
-
 /**
  * klist_add_after - Init a klist_node and add it after an existing node
  * @n: node we're adding.
@@ -152,30 +140,27 @@ void klist_add_before(struct klist_node *n, struct klist_node *pos)
 }
 EXPORT_SYMBOL_GPL(klist_add_before);
 
-
-static void klist_release(struct kref * kref)
+static void klist_release(struct kref *kref)
 {
-	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
+	struct klist_node *n = container_of(kref, struct klist_node, n_ref);
 
 	list_del(&n->n_node);
 	complete(&n->n_removed);
 	n->n_klist = NULL;
 }
 
-static int klist_dec_and_del(struct klist_node * n)
+static int klist_dec_and_del(struct klist_node *n)
 {
 	return kref_put(&n->n_ref, klist_release);
 }
 
-
 /**
- *	klist_del - Decrement the reference count of node and try to remove.
- *	@n:	node we're deleting.
+ * klist_del - Decrement the reference count of node and try to remove.
+ * @n: node we're deleting.
  */
-
-void klist_del(struct klist_node * n)
+void klist_del(struct klist_node *n)
 {
-	struct klist * k = n->n_klist;
+	struct klist *k = n->n_klist;
 	void (*put)(struct klist_node *) = k->put;
 
 	spin_lock(&k->k_lock);
@@ -185,48 +170,40 @@ void klist_del(struct klist_node * n)
 	if (put)
 		put(n);
 }
-
 EXPORT_SYMBOL_GPL(klist_del);
 
-
 /**
- *	klist_remove - Decrement the refcount of node and wait for it to go away.
- *	@n:	node we're removing.
+ * klist_remove - Decrement the refcount of node and wait for it to go away.
+ * @n: node we're removing.
  */
-
-void klist_remove(struct klist_node * n)
+void klist_remove(struct klist_node *n)
 {
 	klist_del(n);
 	wait_for_completion(&n->n_removed);
 }
-
 EXPORT_SYMBOL_GPL(klist_remove);
 
-
 /**
- *	klist_node_attached - Say whether a node is bound to a list or not.
- *	@n:	Node that we're testing.
+ * klist_node_attached - Say whether a node is bound to a list or not.
+ * @n: Node that we're testing.
  */
-
-int klist_node_attached(struct klist_node * n)
+int klist_node_attached(struct klist_node *n)
 {
 	return (n->n_klist != NULL);
 }
-
 EXPORT_SYMBOL_GPL(klist_node_attached);
 
-
 /**
- *	klist_iter_init_node - Initialize a klist_iter structure.
- *	@k:	klist we're iterating.
- *	@i:	klist_iter we're filling.
- *	@n:	node to start with.
+ * klist_iter_init_node - Initialize a klist_iter structure.
+ * @k: klist we're iterating.
+ * @i: klist_iter we're filling.
+ * @n: node to start with.
  *
- *	Similar to klist_iter_init(), but starts the action off with @n, 
- *	instead of with the list head.
+ * Similar to klist_iter_init(), but starts the action off with @n,
+ * instead of with the list head.
  */
-
-void klist_iter_init_node(struct klist * k, struct klist_iter * i, struct klist_node * n)
+void klist_iter_init_node(struct klist *k, struct klist_iter *i,
+			  struct klist_node *n)
 {
 	i->i_klist = k;
 	i->i_head = &k->k_list;
@@ -234,66 +211,56 @@ void klist_iter_init_node(struct klist * k, struct klist_iter * i, struct klist_
 	if (n)
 		kref_get(&n->n_ref);
 }
-
 EXPORT_SYMBOL_GPL(klist_iter_init_node);
 
-
 /**
- *	klist_iter_init - Iniitalize a klist_iter structure.
- *	@k:	klist we're iterating.
- *	@i:	klist_iter structure we're filling.
+ * klist_iter_init - Iniitalize a klist_iter structure.
+ * @k: klist we're iterating.
+ * @i: klist_iter structure we're filling.
  *
- *	Similar to klist_iter_init_node(), but start with the list head.
+ * Similar to klist_iter_init_node(), but start with the list head.
  */
-
-void klist_iter_init(struct klist * k, struct klist_iter * i)
+void klist_iter_init(struct klist *k, struct klist_iter *i)
 {
 	klist_iter_init_node(k, i, NULL);
 }
-
 EXPORT_SYMBOL_GPL(klist_iter_init);
 
-
 /**
- *	klist_iter_exit - Finish a list iteration.
- *	@i:	Iterator structure.
+ * klist_iter_exit - Finish a list iteration.
+ * @i: Iterator structure.
  *
- *	Must be called when done iterating over list, as it decrements the 
- *	refcount of the current node. Necessary in case iteration exited before
- *	the end of the list was reached, and always good form.
+ * Must be called when done iterating over list, as it decrements the
+ * refcount of the current node. Necessary in case iteration exited before
+ * the end of the list was reached, and always good form.
  */
-
-void klist_iter_exit(struct klist_iter * i)
+void klist_iter_exit(struct klist_iter *i)
 {
 	if (i->i_cur) {
 		klist_del(i->i_cur);
 		i->i_cur = NULL;
 	}
 }
-
 EXPORT_SYMBOL_GPL(klist_iter_exit);
 
-
-static struct klist_node * to_klist_node(struct list_head * n)
+static struct klist_node *to_klist_node(struct list_head *n)
 {
 	return container_of(n, struct klist_node, n_node);
 }
 
-
 /**
- *	klist_next - Ante up next node in list.
- *	@i:	Iterator structure.
+ * klist_next - Ante up next node in list.
+ * @i: Iterator structure.
  *
- *	First grab list lock. Decrement the reference count of the previous
- *	node, if there was one. Grab the next node, increment its reference 
- *	count, drop the lock, and return that next node.
+ * First grab list lock. Decrement the reference count of the previous
+ * node, if there was one. Grab the next node, increment its reference
+ * count, drop the lock, and return that next node.
  */
-
-struct klist_node * klist_next(struct klist_iter * i)
+struct klist_node *klist_next(struct klist_iter *i)
 {
-	struct list_head * next;
-	struct klist_node * lnode = i->i_cur;
-	struct klist_node * knode = NULL;
+	struct list_head *next;
+	struct klist_node *lnode = i->i_cur;
+	struct klist_node *knode = NULL;
 	void (*put)(struct klist_node *) = i->i_klist->put;
 
 	spin_lock(&i->i_klist->k_lock);
@@ -314,7 +281,4 @@ struct klist_node * klist_next(struct klist_iter * i)
 		put(lnode);
 	return knode;
 }
-
 EXPORT_SYMBOL_GPL(klist_next);
-
-

commit 93dd40013f4f7f4b18d19d0d77855f025bcc57c3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 22 18:58:46 2008 +0900

    klist: implement klist_add_{after|before}()
    
    Add klist_add_after() and klist_add_before() which puts a new node
    after and before an existing node, respectively.  This is useful for
    callers which need to keep klist ordered.  Note that synchronizing
    between simultaneous additions for ordering is the caller's
    responsibility.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index 120bd175aa78..ebba9488046e 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -120,6 +120,39 @@ void klist_add_tail(struct klist_node * n, struct klist * k)
 EXPORT_SYMBOL_GPL(klist_add_tail);
 
 
+/**
+ * klist_add_after - Init a klist_node and add it after an existing node
+ * @n: node we're adding.
+ * @pos: node to put @n after
+ */
+void klist_add_after(struct klist_node *n, struct klist_node *pos)
+{
+	struct klist *k = pos->n_klist;
+
+	klist_node_init(k, n);
+	spin_lock(&k->k_lock);
+	list_add(&n->n_node, &pos->n_node);
+	spin_unlock(&k->k_lock);
+}
+EXPORT_SYMBOL_GPL(klist_add_after);
+
+/**
+ * klist_add_before - Init a klist_node and add it before an existing node
+ * @n: node we're adding.
+ * @pos: node to put @n after
+ */
+void klist_add_before(struct klist_node *n, struct klist_node *pos)
+{
+	struct klist *k = pos->n_klist;
+
+	klist_node_init(k, n);
+	spin_lock(&k->k_lock);
+	list_add_tail(&n->n_node, &pos->n_node);
+	spin_unlock(&k->k_lock);
+}
+EXPORT_SYMBOL_GPL(klist_add_before);
+
+
 static void klist_release(struct kref * kref)
 {
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);

commit 7e9f4b2d3e21e87c26025810413ef1592834e63b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 18 16:28:06 2006 -0400

    Driver core: Don't call put methods while holding a spinlock
    
    The klist utility routines currently call _put methods while holding a
    spinlock.  This is of course illegal; a put routine could try to
    unregister a device and hence need to sleep.
    
    No problems have arisen until now because in many cases klist removals
    were done synchronously, so the _put methods were never actually used.
    In other cases we may simply have been lucky.
    
    This patch (as784) reworks the klist routines so that _put methods are
    called only _after_ the klist's spinlock has been released.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index 9c94f0b163a1..120bd175aa78 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -123,12 +123,10 @@ EXPORT_SYMBOL_GPL(klist_add_tail);
 static void klist_release(struct kref * kref)
 {
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
-	void (*put)(struct klist_node *) = n->n_klist->put;
+
 	list_del(&n->n_node);
 	complete(&n->n_removed);
 	n->n_klist = NULL;
-	if (put)
-		put(n);
 }
 
 static int klist_dec_and_del(struct klist_node * n)
@@ -145,10 +143,14 @@ static int klist_dec_and_del(struct klist_node * n)
 void klist_del(struct klist_node * n)
 {
 	struct klist * k = n->n_klist;
+	void (*put)(struct klist_node *) = k->put;
 
 	spin_lock(&k->k_lock);
-	klist_dec_and_del(n);
+	if (!klist_dec_and_del(n))
+		put = NULL;
 	spin_unlock(&k->k_lock);
+	if (put)
+		put(n);
 }
 
 EXPORT_SYMBOL_GPL(klist_del);
@@ -161,10 +163,7 @@ EXPORT_SYMBOL_GPL(klist_del);
 
 void klist_remove(struct klist_node * n)
 {
-	struct klist * k = n->n_klist;
-	spin_lock(&k->k_lock);
-	klist_dec_and_del(n);
-	spin_unlock(&k->k_lock);
+	klist_del(n);
 	wait_for_completion(&n->n_removed);
 }
 
@@ -260,12 +259,15 @@ static struct klist_node * to_klist_node(struct list_head * n)
 struct klist_node * klist_next(struct klist_iter * i)
 {
 	struct list_head * next;
+	struct klist_node * lnode = i->i_cur;
 	struct klist_node * knode = NULL;
+	void (*put)(struct klist_node *) = i->i_klist->put;
 
 	spin_lock(&i->i_klist->k_lock);
-	if (i->i_cur) {
-		next = i->i_cur->n_node.next;
-		klist_dec_and_del(i->i_cur);
+	if (lnode) {
+		next = lnode->n_node.next;
+		if (!klist_dec_and_del(lnode))
+			put = NULL;
 	} else
 		next = i->i_head->next;
 
@@ -275,6 +277,8 @@ struct klist_node * klist_next(struct klist_iter * i)
 	}
 	i->i_cur = knode;
 	spin_unlock(&i->i_klist->k_lock);
+	if (put && lnode)
+		put(lnode);
 	return knode;
 }
 

commit e22dafbcd7a579c29a424d5203b5b33b131948a7
Author: Frank Pavlic <pavlic@de.ibm.com>
Date:   Sat Nov 26 20:48:40 2005 -0800

    [PATCH] klist: Fix broken kref counting in find functions
    
    The klist reference counting in the find functions that use
    klist_iter_init_node is broken.  If the function (for example
    driver_find_device) is called with a NULL start object then everything is
    fine, the first call to next_device()/klist_next increases the ref-count of
    the first node on the list and does nothing for the start object which is
    NULL.
    
    If they are called with a valid start object then klist_next will decrement
    the ref-count for the start object but nobody has incremented it.  Logical
    place to fix this would be klist_iter_init_node because the function puts a
    reference of the object into the klist_iter struct.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Frank Pavlic <pavlic@de.ibm.com>
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index bb2f3551d50a..9c94f0b163a1 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -199,6 +199,8 @@ void klist_iter_init_node(struct klist * k, struct klist_iter * i, struct klist_
 	i->i_klist = k;
 	i->i_head = &k->k_list;
 	i->i_cur = n;
+	if (n)
+		kref_get(&n->n_ref);
 }
 
 EXPORT_SYMBOL_GPL(klist_iter_init_node);

commit 34bb61f9ddabd7a7f909cbfb05592eb775f6662a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Sep 6 16:56:51 2005 -0700

    [PATCH] fix klist semantics for lists which have elements removed on traversal
    
    The problem is that klists claim to provide semantics for safe traversal of
    lists which are being modified.  The failure case is when traversal of a
    list causes element removal (a fairly common case).  The issue is that
    although the list node is refcounted, if it is embedded in an object (which
    is universally the case), then the object will be freed regardless of the
    klist refcount leading to slab corruption because the klist iterator refers
    to the prior element to get the next.
    
    The solution is to make the klist take and release references to the
    embedding object meaning that the embedding object won't be released until
    the list relinquishes the reference to it.
    
    (akpm: fast-track this because it's needed for the 2.6.13 scsi merge)
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/klist.c b/lib/klist.c
index a70c836c5c4c..bb2f3551d50a 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -42,12 +42,23 @@
 /**
  *	klist_init - Initialize a klist structure. 
  *	@k:	The klist we're initializing.
+ *	@get:	The get function for the embedding object (NULL if none)
+ *	@put:	The put function for the embedding object (NULL if none)
+ *
+ * Initialises the klist structure.  If the klist_node structures are
+ * going to be embedded in refcounted objects (necessary for safe
+ * deletion) then the get/put arguments are used to initialise
+ * functions that take and release references on the embedding
+ * objects.
  */
 
-void klist_init(struct klist * k)
+void klist_init(struct klist * k, void (*get)(struct klist_node *),
+		void (*put)(struct klist_node *))
 {
 	INIT_LIST_HEAD(&k->k_list);
 	spin_lock_init(&k->k_lock);
+	k->get = get;
+	k->put = put;
 }
 
 EXPORT_SYMBOL_GPL(klist_init);
@@ -74,6 +85,8 @@ static void klist_node_init(struct klist * k, struct klist_node * n)
 	init_completion(&n->n_removed);
 	kref_init(&n->n_ref);
 	n->n_klist = k;
+	if (k->get)
+		k->get(n);
 }
 
 
@@ -110,9 +123,12 @@ EXPORT_SYMBOL_GPL(klist_add_tail);
 static void klist_release(struct kref * kref)
 {
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
+	void (*put)(struct klist_node *) = n->n_klist->put;
 	list_del(&n->n_node);
 	complete(&n->n_removed);
 	n->n_klist = NULL;
+	if (put)
+		put(n);
 }
 
 static int klist_dec_and_del(struct klist_node * n)

commit d856f1e337782326c638c70c0b4df2b909350dec
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Fri Aug 19 09:14:01 2005 -0400

    [PATCH] klist: fix klist to have the same klist_add semantics as list_head
    
    at the moment, the list_head semantics are
    
    list_add(node, head)
    
    whereas current klist semantics are
    
    klist_add(head, node)
    
    This is bound to cause confusion, and since klist is the newcomer, it
    should follow the list_head semantics.
    
    I also added missing include guards to klist.h
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/klist.c b/lib/klist.c
index 738ab810160a..a70c836c5c4c 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -79,11 +79,11 @@ static void klist_node_init(struct klist * k, struct klist_node * n)
 
 /**
  *	klist_add_head - Initialize a klist_node and add it to front.
- *	@k:	klist it's going on.
  *	@n:	node we're adding.
+ *	@k:	klist it's going on.
  */
 
-void klist_add_head(struct klist * k, struct klist_node * n)
+void klist_add_head(struct klist_node * n, struct klist * k)
 {
 	klist_node_init(k, n);
 	add_head(k, n);
@@ -94,11 +94,11 @@ EXPORT_SYMBOL_GPL(klist_add_head);
 
 /**
  *	klist_add_tail - Initialize a klist_node and add it to back.
- *	@k:	klist it's going on.
  *	@n:	node we're adding.
+ *	@k:	klist it's going on.
  */
 
-void klist_add_tail(struct klist * k, struct klist_node * n)
+void klist_add_tail(struct klist_node * n, struct klist * k)
 {
 	klist_node_init(k, n);
 	add_tail(k, n);

commit 0293a509405dccecc30783a5d729d615b68d6a77
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 18:59:59 2005 -0800

    [PATCH] Don't reference NULL klist pointer in klist_remove().
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/lib/klist.c b/lib/klist.c

diff --git a/lib/klist.c b/lib/klist.c
index 02177d72dc89..738ab810160a 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -145,9 +145,10 @@ EXPORT_SYMBOL_GPL(klist_del);
 
 void klist_remove(struct klist_node * n)
 {
-	spin_lock(&n->n_klist->k_lock);
+	struct klist * k = n->n_klist;
+	spin_lock(&k->k_lock);
 	klist_dec_and_del(n);
-	spin_unlock(&n->n_klist->k_lock);
+	spin_unlock(&k->k_lock);
 	wait_for_completion(&n->n_removed);
 }
 

commit 8b0c250be489dcbf1a3a33bb4ec4c7f33735a365
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 12:58:57 2005 -0800

    [PATCH] add klist_node_attached() to determine if a node is on a list or not.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/include/linux/klist.h b/include/linux/klist.h

diff --git a/lib/klist.c b/lib/klist.c
index 6f760424648b..02177d72dc89 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -112,6 +112,7 @@ static void klist_release(struct kref * kref)
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
 	list_del(&n->n_node);
 	complete(&n->n_removed);
+	n->n_klist = NULL;
 }
 
 static int klist_dec_and_del(struct klist_node * n)
@@ -153,6 +154,19 @@ void klist_remove(struct klist_node * n)
 EXPORT_SYMBOL_GPL(klist_remove);
 
 
+/**
+ *	klist_node_attached - Say whether a node is bound to a list or not.
+ *	@n:	Node that we're testing.
+ */
+
+int klist_node_attached(struct klist_node * n)
+{
+	return (n->n_klist != NULL);
+}
+
+EXPORT_SYMBOL_GPL(klist_node_attached);
+
+
 /**
  *	klist_iter_init_node - Initialize a klist_iter structure.
  *	@k:	klist we're iterating.
@@ -246,3 +260,5 @@ struct klist_node * klist_next(struct klist_iter * i)
 }
 
 EXPORT_SYMBOL_GPL(klist_next);
+
+

commit 9a19fea43616066561e221359596ce532e631395
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 11:45:16 2005 -0800

    [PATCH] Add initial implementation of klist helpers.
    
    This klist interface provides a couple of structures that wrap around
    struct list_head to provide explicit list "head" (struct klist) and
    list "node" (struct klist_node) objects. For struct klist, a spinlock
    is included that protects access to the actual list itself. struct
    klist_node provides a pointer to the klist that owns it and a kref
    reference count that indicates the number of current users of that node
    in the list.
    
    The entire point is to provide an interface for iterating over a list
    that is safe and allows for modification of the list during the
    iteration (e.g. insertion and removal), including modification of the
    current node on the list.
    
    It works using a 3rd object type - struct klist_iter - that is declared
    and initialized before an iteration. klist_next() is used to acquire the
    next element in the list. It returns NULL if there are no more items.
    This klist interface provides a couple of structures that wrap around
    struct list_head to provide explicit list "head" (struct klist) and
    list "node" (struct klist_node) objects. For struct klist, a spinlock
    is included that protects access to the actual list itself. struct
    klist_node provides a pointer to the klist that owns it and a kref
    reference count that indicates the number of current users of that node
    in the list.
    
    The entire point is to provide an interface for iterating over a list
    that is safe and allows for modification of the list during the
    iteration (e.g. insertion and removal), including modification of the
    current node on the list.
    
    It works using a 3rd object type - struct klist_iter - that is declared
    and initialized before an iteration. klist_next() is used to acquire the
    next element in the list. It returns NULL if there are no more items.
    Internally, that routine takes the klist's lock, decrements the reference
    count of the previous klist_node and increments the count of the next
    klist_node. It then drops the lock and returns.
    
    There are primitives for adding and removing nodes to/from a klist.
    When deleting, klist_del() will simply decrement the reference count.
    Only when the count goes to 0 is the node removed from the list.
    klist_remove() will try to delete the node from the list and block
    until it is actually removed. This is useful for objects (like devices)
    that have been removed from the system and must be freed (but must wait
    until all accessors have finished).
    
    Internally, that routine takes the klist's lock, decrements the reference
    count of the previous klist_node and increments the count of the next
    klist_node. It then drops the lock and returns.
    
    There are primitives for adding and removing nodes to/from a klist.
    When deleting, klist_del() will simply decrement the reference count.
    Only when the count goes to 0 is the node removed from the list.
    klist_remove() will try to delete the node from the list and block
    until it is actually removed. This is useful for objects (like devices)
    that have been removed from the system and must be freed (but must wait
    until all accessors have finished).
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/include/linux/klist.h b/include/linux/klist.h

diff --git a/lib/klist.c b/lib/klist.c
new file mode 100644
index 000000000000..6f760424648b
--- /dev/null
+++ b/lib/klist.c
@@ -0,0 +1,248 @@
+/*
+ *	klist.c - Routines for manipulating klists.
+ *
+ *
+ *	This klist interface provides a couple of structures that wrap around 
+ *	struct list_head to provide explicit list "head" (struct klist) and 
+ *	list "node" (struct klist_node) objects. For struct klist, a spinlock
+ *	is included that protects access to the actual list itself. struct 
+ *	klist_node provides a pointer to the klist that owns it and a kref
+ *	reference count that indicates the number of current users of that node
+ *	in the list.
+ *
+ *	The entire point is to provide an interface for iterating over a list
+ *	that is safe and allows for modification of the list during the
+ *	iteration (e.g. insertion and removal), including modification of the
+ *	current node on the list.
+ *
+ *	It works using a 3rd object type - struct klist_iter - that is declared
+ *	and initialized before an iteration. klist_next() is used to acquire the
+ *	next element in the list. It returns NULL if there are no more items.
+ *	Internally, that routine takes the klist's lock, decrements the reference
+ *	count of the previous klist_node and increments the count of the next
+ *	klist_node. It then drops the lock and returns.
+ *
+ *	There are primitives for adding and removing nodes to/from a klist. 
+ *	When deleting, klist_del() will simply decrement the reference count. 
+ *	Only when the count goes to 0 is the node removed from the list. 
+ *	klist_remove() will try to delete the node from the list and block
+ *	until it is actually removed. This is useful for objects (like devices)
+ *	that have been removed from the system and must be freed (but must wait
+ *	until all accessors have finished).
+ *
+ *	Copyright (C) 2005 Patrick Mochel
+ *
+ *	This file is released under the GPL v2.
+ */
+
+#include <linux/klist.h>
+#include <linux/module.h>
+
+
+/**
+ *	klist_init - Initialize a klist structure. 
+ *	@k:	The klist we're initializing.
+ */
+
+void klist_init(struct klist * k)
+{
+	INIT_LIST_HEAD(&k->k_list);
+	spin_lock_init(&k->k_lock);
+}
+
+EXPORT_SYMBOL_GPL(klist_init);
+
+
+static void add_head(struct klist * k, struct klist_node * n)
+{
+	spin_lock(&k->k_lock);
+	list_add(&n->n_node, &k->k_list);
+	spin_unlock(&k->k_lock);
+}
+
+static void add_tail(struct klist * k, struct klist_node * n)
+{
+	spin_lock(&k->k_lock);
+	list_add_tail(&n->n_node, &k->k_list);
+	spin_unlock(&k->k_lock);
+}
+
+
+static void klist_node_init(struct klist * k, struct klist_node * n)
+{
+	INIT_LIST_HEAD(&n->n_node);
+	init_completion(&n->n_removed);
+	kref_init(&n->n_ref);
+	n->n_klist = k;
+}
+
+
+/**
+ *	klist_add_head - Initialize a klist_node and add it to front.
+ *	@k:	klist it's going on.
+ *	@n:	node we're adding.
+ */
+
+void klist_add_head(struct klist * k, struct klist_node * n)
+{
+	klist_node_init(k, n);
+	add_head(k, n);
+}
+
+EXPORT_SYMBOL_GPL(klist_add_head);
+
+
+/**
+ *	klist_add_tail - Initialize a klist_node and add it to back.
+ *	@k:	klist it's going on.
+ *	@n:	node we're adding.
+ */
+
+void klist_add_tail(struct klist * k, struct klist_node * n)
+{
+	klist_node_init(k, n);
+	add_tail(k, n);
+}
+
+EXPORT_SYMBOL_GPL(klist_add_tail);
+
+
+static void klist_release(struct kref * kref)
+{
+	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
+	list_del(&n->n_node);
+	complete(&n->n_removed);
+}
+
+static int klist_dec_and_del(struct klist_node * n)
+{
+	return kref_put(&n->n_ref, klist_release);
+}
+
+
+/**
+ *	klist_del - Decrement the reference count of node and try to remove.
+ *	@n:	node we're deleting.
+ */
+
+void klist_del(struct klist_node * n)
+{
+	struct klist * k = n->n_klist;
+
+	spin_lock(&k->k_lock);
+	klist_dec_and_del(n);
+	spin_unlock(&k->k_lock);
+}
+
+EXPORT_SYMBOL_GPL(klist_del);
+
+
+/**
+ *	klist_remove - Decrement the refcount of node and wait for it to go away.
+ *	@n:	node we're removing.
+ */
+
+void klist_remove(struct klist_node * n)
+{
+	spin_lock(&n->n_klist->k_lock);
+	klist_dec_and_del(n);
+	spin_unlock(&n->n_klist->k_lock);
+	wait_for_completion(&n->n_removed);
+}
+
+EXPORT_SYMBOL_GPL(klist_remove);
+
+
+/**
+ *	klist_iter_init_node - Initialize a klist_iter structure.
+ *	@k:	klist we're iterating.
+ *	@i:	klist_iter we're filling.
+ *	@n:	node to start with.
+ *
+ *	Similar to klist_iter_init(), but starts the action off with @n, 
+ *	instead of with the list head.
+ */
+
+void klist_iter_init_node(struct klist * k, struct klist_iter * i, struct klist_node * n)
+{
+	i->i_klist = k;
+	i->i_head = &k->k_list;
+	i->i_cur = n;
+}
+
+EXPORT_SYMBOL_GPL(klist_iter_init_node);
+
+
+/**
+ *	klist_iter_init - Iniitalize a klist_iter structure.
+ *	@k:	klist we're iterating.
+ *	@i:	klist_iter structure we're filling.
+ *
+ *	Similar to klist_iter_init_node(), but start with the list head.
+ */
+
+void klist_iter_init(struct klist * k, struct klist_iter * i)
+{
+	klist_iter_init_node(k, i, NULL);
+}
+
+EXPORT_SYMBOL_GPL(klist_iter_init);
+
+
+/**
+ *	klist_iter_exit - Finish a list iteration.
+ *	@i:	Iterator structure.
+ *
+ *	Must be called when done iterating over list, as it decrements the 
+ *	refcount of the current node. Necessary in case iteration exited before
+ *	the end of the list was reached, and always good form.
+ */
+
+void klist_iter_exit(struct klist_iter * i)
+{
+	if (i->i_cur) {
+		klist_del(i->i_cur);
+		i->i_cur = NULL;
+	}
+}
+
+EXPORT_SYMBOL_GPL(klist_iter_exit);
+
+
+static struct klist_node * to_klist_node(struct list_head * n)
+{
+	return container_of(n, struct klist_node, n_node);
+}
+
+
+/**
+ *	klist_next - Ante up next node in list.
+ *	@i:	Iterator structure.
+ *
+ *	First grab list lock. Decrement the reference count of the previous
+ *	node, if there was one. Grab the next node, increment its reference 
+ *	count, drop the lock, and return that next node.
+ */
+
+struct klist_node * klist_next(struct klist_iter * i)
+{
+	struct list_head * next;
+	struct klist_node * knode = NULL;
+
+	spin_lock(&i->i_klist->k_lock);
+	if (i->i_cur) {
+		next = i->i_cur->n_node.next;
+		klist_dec_and_del(i->i_cur);
+	} else
+		next = i->i_head->next;
+
+	if (next != i->i_head) {
+		knode = to_klist_node(next);
+		kref_get(&knode->n_ref);
+	}
+	i->i_cur = knode;
+	spin_unlock(&i->i_klist->k_lock);
+	return knode;
+}
+
+EXPORT_SYMBOL_GPL(klist_next);
