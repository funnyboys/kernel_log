commit f558b8364e19f9222e7976c64e9367f66bab02cc
Merge: 80ef846e9909 8c3e315d4296
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 7 10:53:36 2020 -0700

    Merge tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core patches for 5.8-rc1.
    
      Not all that huge this release, just a number of small fixes and
      updates:
    
       - software node fixes
    
       - kobject now sends KOBJ_REMOVE when it is removed from sysfs, not
         when it is removed from memory (which could come much later)
    
       - device link additions and fixes based on testing on more devices
    
       - firmware core cleanups
    
       - other minor changes, full details in the shortlog
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: Update device link status correctly for SYNC_STATE_ONLY links
      firmware_loader: change enum fw_opt to u32
      software node: implement software_node_unregister()
      kobject: send KOBJ_REMOVE uevent when the object is removed from sysfs
      driver core: Remove unnecessary is_fwnode_dev variable in device_add()
      drivers property: When no children in primary, try secondary
      driver core: platform: Fix spelling errors in platform.c
      driver core: Remove check in driver_deferred_probe_force_trigger()
      of: platform: Batch fwnode parsing when adding all top level devices
      driver core: fw_devlink: Add support for batching fwnode parsing
      driver core: Look for waiting consumers only for a fwnode's primary device
      driver core: Move code to the right part of the file
      Revert "Revert "driver core: Set fw_devlink to "permissive" behavior by default""
      drivers: base: Fix NULL pointer exception in __platform_driver_probe() if a driver developer is foolish
      firmware_loader: move fw_fallback_config to a private kernel symbol namespace
      driver core: Add missing '\n' in log messages
      driver/base/soc: Use kobj_to_dev() API
      Add documentation on meaning of -EPROBE_DEFER
      driver core: platform: remove redundant assignment to variable ret
      debugfs: Use the correct style for SPDX License Identifier
      ...

commit 0e5596c54aa2fbfd22842096d3ebb6753b2a220a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun May 24 17:30:41 2020 +0200

    kobject: send KOBJ_REMOVE uevent when the object is removed from sysfs
    
    It is possible for a KOBJ_REMOVE uevent to be sent to userspace way
    after the files are actually gone from sysfs, due to how reference
    counting for kobjects work.  This should not be a problem, but it would
    be good to properly send the information when things are going away, not
    at some later point in time in the future.
    
    Before this move, if a kobject's parent was torn down before the child,
    when the call to kobject_uevent() happened, the parent walk to try to
    reconstruct the full path of the kobject could be a total mess and cause
    crashes.  It's not good to try to tear down a kobject tree from top
    down, but let's at least try to not to crash if a user does so.
    
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20200524153041.2361-2-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 83198cb37d8d..2509e22ad74a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -620,6 +620,13 @@ void kobject_del(struct kobject *kobj)
 	if (ktype)
 		sysfs_remove_groups(kobj, ktype->default_groups);
 
+	/* send "remove" if the caller did not do it but sent "add" */
+	if (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {
+		pr_debug("kobject: '%s' (%p): auto cleanup 'remove' event\n",
+			 kobject_name(kobj), kobj);
+		kobject_uevent(kobj, KOBJ_REMOVE);
+	}
+
 	sysfs_remove_dir(kobj);
 	sysfs_put(sd);
 
@@ -673,13 +680,6 @@ static void kobject_cleanup(struct kobject *kobj)
 		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n",
 			 kobject_name(kobj), kobj);
 
-	/* send "remove" if the caller did not do it but sent "add" */
-	if (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {
-		pr_debug("kobject: '%s' (%p): auto cleanup 'remove' event\n",
-			 kobject_name(kobj), kobj);
-		kobject_uevent(kobj, KOBJ_REMOVE);
-	}
-
 	/* remove from sysfs if the caller did not do it */
 	if (kobj->state_in_sysfs) {
 		pr_debug("kobject: '%s' (%p): auto cleanup kobject_del\n",

commit 0c1bc6b84525b96aa9fb8f6fbe8c5cb26a5c0ead
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Tue Apr 14 18:48:37 2020 +0200

    docs: filesystems: fix renamed references
    
    Some filesystem references got broken by a previous patch
    series I submitted. Address those.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Acked-by: David Sterba <dsterba@suse.com> # fs/affs/Kconfig
    Link: https://lore.kernel.org/r/57318c53008dbda7f6f4a5a9e5787f4d37e8565a.1586881715.git.mchehab+huawei@kernel.org
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/lib/kobject.c b/lib/kobject.c
index 83198cb37d8d..65fa7bf70c57 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -6,7 +6,7 @@
  * Copyright (c) 2006-2007 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (c) 2006-2007 Novell Inc.
  *
- * Please see the file Documentation/kobject.txt for critical information
+ * Please see the file Documentation/core-api/kobject.rst for critical information
  * about using the kobject interface.
  */
 
@@ -670,7 +670,7 @@ static void kobject_cleanup(struct kobject *kobj)
 		 kobject_name(kobj), kobj, __func__, kobj->parent);
 
 	if (t && !t->release)
-		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n",
+		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\n",
 			 kobject_name(kobj), kobj);
 
 	/* send "remove" if the caller did not do it but sent "add" */

commit 122f8ec7b78e2d0f2dc6c966bef96b47c955ca36
Author: Lin Yi <teroincn@163.com>
Date:   Mon Jun 3 16:08:10 2019 +0800

    lib : kobject: fix refcount imblance on kobject_rename
    
    the kobj refcount increased by kobject_get should be released before
    error return, otherwise lead to a memory leak.
    
    Signed-off-by: Lin Yi <teroincn@163.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index f2ccdbac8ed9..83198cb37d8d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -498,8 +498,10 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 	kobj = kobject_get(kobj);
 	if (!kobj)
 		return -EINVAL;
-	if (!kobj->parent)
+	if (!kobj->parent) {
+		kobject_put(kobj);
 		return -EINVAL;
+	}
 
 	devpath = kobject_get_path(kobj, GFP_KERNEL);
 	if (!devpath) {

commit 70e16a620e075cb916644e06012766639b58b2fb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu May 2 12:22:24 2019 +0200

    kobject: clean up the kobject add documentation a bit more
    
    Commit 1fd7c3b438a2 ("kobject: Improve doc clarity kobject_init_and_add()")
    tried to provide more clarity, but the reference to kobject_del() was
    incorrect.  Fix that up by removing that line, and hopefully be more explicit
    as to exactly what needs to happen here once you register a kobject with the
    kobject core.
    
    Acked-by: Tobin C. Harding <tobin@kernel.org>
    Fixes: 1fd7c3b438a2 ("kobject: Improve doc clarity kobject_init_and_add()")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3f4b7e95b0c2..f2ccdbac8ed9 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -416,8 +416,12 @@ static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
  *         to this function be directly freed with a call to kfree(),
  *         that can leak memory.
  *
- *         If this call returns successfully and you later need to unwind
- *         kobject_add() for the error path you should call kobject_del().
+ *         If this function returns success, kobject_put() must also be called
+ *         in order to properly clean up the memory associated with the object.
+ *
+ *         In short, once this function is called, kobject_put() MUST be called
+ *         when the use of the object is finished in order to properly free
+ *         everything.
  */
 int kobject_add(struct kobject *kobj, struct kobject *parent,
 		const char *fmt, ...)

commit ed856349dc0886a97e91fd4ce6ba5ff5312fc0f1
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Thu May 2 12:31:40 2019 +1000

    kobject: Fix kernel-doc comment first line
    
    kernel-doc comments have a prescribed format.  This includes parenthesis
    on the function name.  To be _particularly_ correct we should also
    capitalise the brief description and terminate it with a period.
    
    In preparation for adding/updating kernel-doc function comments clean up
    the ones currently present.
    
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 09e3ac329e92..3f4b7e95b0c2 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -18,7 +18,7 @@
 #include <linux/random.h>
 
 /**
- * kobject_namespace - return @kobj's namespace tag
+ * kobject_namespace() - Return @kobj's namespace tag.
  * @kobj: kobject in question
  *
  * Returns namespace tag of @kobj if its parent has namespace ops enabled
@@ -36,7 +36,7 @@ const void *kobject_namespace(struct kobject *kobj)
 }
 
 /**
- * kobject_get_ownership - get sysfs ownership data for @kobj
+ * kobject_get_ownership() - Get sysfs ownership data for @kobj.
  * @kobj: kobject in question
  * @uid: kernel user ID for sysfs objects
  * @gid: kernel group ID for sysfs objects
@@ -273,7 +273,7 @@ static int kobject_add_internal(struct kobject *kobj)
 }
 
 /**
- * kobject_set_name_vargs - Set the name of an kobject
+ * kobject_set_name_vargs() - Set the name of a kobject.
  * @kobj: struct kobject to set the name of
  * @fmt: format string used to build the name
  * @vargs: vargs to format the string.
@@ -313,7 +313,7 @@ int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 }
 
 /**
- * kobject_set_name - Set the name of a kobject
+ * kobject_set_name() - Set the name of a kobject.
  * @kobj: struct kobject to set the name of
  * @fmt: format string used to build the name
  *
@@ -335,7 +335,7 @@ int kobject_set_name(struct kobject *kobj, const char *fmt, ...)
 EXPORT_SYMBOL(kobject_set_name);
 
 /**
- * kobject_init - initialize a kobject structure
+ * kobject_init() - Initialize a kobject structure.
  * @kobj: pointer to the kobject to initialize
  * @ktype: pointer to the ktype for this kobject.
  *
@@ -391,7 +391,7 @@ static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
 }
 
 /**
- * kobject_add - the main kobject add function
+ * kobject_add() - The main kobject add function.
  * @kobj: the kobject to add
  * @parent: pointer to the parent of the kobject.
  * @fmt: format to name the kobject with.
@@ -443,7 +443,8 @@ int kobject_add(struct kobject *kobj, struct kobject *parent,
 EXPORT_SYMBOL(kobject_add);
 
 /**
- * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy
+ * kobject_init_and_add() - Initialize a kobject structure and add it to
+ *                          the kobject hierarchy.
  * @kobj: pointer to the kobject to initialize
  * @ktype: pointer to the ktype for this kobject.
  * @parent: pointer to the parent of this kobject.
@@ -473,7 +474,7 @@ int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
 EXPORT_SYMBOL_GPL(kobject_init_and_add);
 
 /**
- * kobject_rename - change the name of an object
+ * kobject_rename() - Change the name of an object.
  * @kobj: object in question.
  * @new_name: object's new name
  *
@@ -540,7 +541,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 EXPORT_SYMBOL_GPL(kobject_rename);
 
 /**
- * kobject_move - move object to another parent
+ * kobject_move() - Move object to another parent.
  * @kobj: object in question.
  * @new_parent: object's new parent (can be NULL)
  */
@@ -593,7 +594,7 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 EXPORT_SYMBOL_GPL(kobject_move);
 
 /**
- * kobject_del - unlink kobject from hierarchy.
+ * kobject_del() - Unlink kobject from hierarchy.
  * @kobj: object.
  *
  * This is the function that should be called to delete an object
@@ -624,7 +625,7 @@ void kobject_del(struct kobject *kobj)
 EXPORT_SYMBOL(kobject_del);
 
 /**
- * kobject_get - increment refcount for object.
+ * kobject_get() - Increment refcount for object.
  * @kobj: object.
  */
 struct kobject *kobject_get(struct kobject *kobj)
@@ -717,7 +718,7 @@ static void kobject_release(struct kref *kref)
 }
 
 /**
- * kobject_put - decrement refcount for object.
+ * kobject_put() - Decrement refcount for object.
  * @kobj: object.
  *
  * Decrement the refcount, and if 0, call kobject_cleanup().
@@ -746,7 +747,7 @@ static struct kobj_type dynamic_kobj_ktype = {
 };
 
 /**
- * kobject_create - create a struct kobject dynamically
+ * kobject_create() - Create a struct kobject dynamically.
  *
  * This function creates a kobject structure dynamically and sets it up
  * to be a "dynamic" kobject with a default release function set up.
@@ -769,8 +770,8 @@ struct kobject *kobject_create(void)
 }
 
 /**
- * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs
- *
+ * kobject_create_and_add() - Create a struct kobject dynamically and
+ *                            register it with sysfs.
  * @name: the name for the kobject
  * @parent: the parent kobject of this kobject, if any.
  *
@@ -801,7 +802,7 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 EXPORT_SYMBOL_GPL(kobject_create_and_add);
 
 /**
- * kset_init - initialize a kset for use
+ * kset_init() - Initialize a kset for use.
  * @k: kset
  */
 void kset_init(struct kset *k)
@@ -843,7 +844,7 @@ const struct sysfs_ops kobj_sysfs_ops = {
 EXPORT_SYMBOL_GPL(kobj_sysfs_ops);
 
 /**
- * kset_register - initialize and add a kset.
+ * kset_register() - Initialize and add a kset.
  * @k: kset.
  */
 int kset_register(struct kset *k)
@@ -863,7 +864,7 @@ int kset_register(struct kset *k)
 EXPORT_SYMBOL(kset_register);
 
 /**
- * kset_unregister - remove a kset.
+ * kset_unregister() - Remove a kset.
  * @k: kset.
  */
 void kset_unregister(struct kset *k)
@@ -876,7 +877,7 @@ void kset_unregister(struct kset *k)
 EXPORT_SYMBOL(kset_unregister);
 
 /**
- * kset_find_obj - search for object in kset.
+ * kset_find_obj() - Search for object in kset.
  * @kset: kset we're looking in.
  * @name: object's name.
  *
@@ -924,7 +925,7 @@ static struct kobj_type kset_ktype = {
 };
 
 /**
- * kset_create - create a struct kset dynamically
+ * kset_create() - Create a struct kset dynamically.
  *
  * @name: the name for the kset
  * @uevent_ops: a struct kset_uevent_ops for the kset
@@ -968,7 +969,7 @@ static struct kset *kset_create(const char *name,
 }
 
 /**
- * kset_create_and_add - create a struct kset dynamically and add it to sysfs
+ * kset_create_and_add() - Create a struct kset dynamically and add it to sysfs.
  *
  * @name: the name for the kset
  * @uevent_ops: a struct kset_uevent_ops for the kset

commit 8fd7c302b37099670b5d793375da10a40da7edf5
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Thu May 2 12:31:39 2019 +1000

    kobject: Remove docstring reference to kset
    
    Currently the docstring for kobject_get_path() mentions 'kset'.  The
    kset is not used in the function callchain starting from this function.
    
    Remove docstring reference to kset from the function kobject_get_path().
    
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 095bcb55c2ba..09e3ac329e92 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -162,12 +162,11 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 }
 
 /**
- * kobject_get_path - generate and return the path associated with a given kobj and kset pair.
- *
+ * kobject_get_path() - Allocate memory and fill in the path for @kobj.
  * @kobj:	kobject in question, with which to build the path
  * @gfp_mask:	the allocation type used to allocate the path
  *
- * The result must be freed by the caller with kfree().
+ * Return: The newly allocated memory, caller must free with kfree().
  */
 char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 {

commit 3d378dc713f3ff4951d9a50c6a815f011e59da10
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed May 1 13:43:17 2019 +0100

    kobject: fix dereference before null check on kobj
    
    The kobj pointer is being null-checked so potentially it could be null,
    however, the ktype declaration before the null check is dereferencing kobj
    hence we have a potential null pointer deference. Fix this by moving the
    assignment of ktype after kobj has been null checked.
    
    Addresses-Coverity: ("Dereference before null check")
    Fixes: aa30f47cf666 ("kobject: Add support for default attribute groups to kobj_type")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index a30ee0467942..095bcb55c2ba 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -603,12 +603,13 @@ EXPORT_SYMBOL_GPL(kobject_move);
 void kobject_del(struct kobject *kobj)
 {
 	struct kernfs_node *sd;
-	const struct kobj_type *ktype = get_ktype(kobj);
+	const struct kobj_type *ktype;
 
 	if (!kobj)
 		return;
 
 	sd = kobj->sd;
+	ktype = get_ktype(kobj);
 
 	if (ktype)
 		sysfs_remove_groups(kobj, ktype->default_groups);

commit 1fd7c3b438a2e4741435ed4d45546c03abf045b2
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Sun Apr 28 09:56:52 2019 +1000

    kobject: Improve doc clarity kobject_init_and_add()
    
    Function kobject_init_and_add() is currently misused in a number of
    places in the kernel.  On error return kobject_put() must be called but
    is at times not.
    
    Make the function documentation more explicit about calling
    kobject_put() in the error path.
    
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index c97b5729f94d..a30ee0467942 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -450,9 +450,12 @@ EXPORT_SYMBOL(kobject_add);
  * @parent: pointer to the parent of this kobject.
  * @fmt: the name of the kobject.
  *
- * This function combines the call to kobject_init() and
- * kobject_add().  The same type of error handling after a call to
- * kobject_add() and kobject lifetime rules are the same here.
+ * This function combines the call to kobject_init() and kobject_add().
+ *
+ * If this function returns an error, kobject_put() must be called to
+ * properly clean up the memory associated with the object.  This is the
+ * same type of error handling after a call to kobject_add() and kobject
+ * lifetime rules are the same here.
  */
 int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
 			 struct kobject *parent, const char *fmt, ...)

commit 92067f843854be0eef1e41ff00cb465247a83c42
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Sun Apr 28 10:48:10 2019 +1000

    kobject: Improve docs for kobject_add/del
    
    There is currently some confusion on how to wind back
    kobject_init_and_add() during the error paths in code that uses this
    function.
    
    Add documentation to kobject_add() and kobject_del() to help clarify the
    usage.
    
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index ede40005db28..c97b5729f94d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -406,15 +406,19 @@ static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
  * is assigned to the kobject, then the kobject will be located in the
  * root of the sysfs tree.
  *
- * If this function returns an error, kobject_put() must be called to
- * properly clean up the memory associated with the object.
- * Under no instance should the kobject that is passed to this function
- * be directly freed with a call to kfree(), that can leak memory.
- *
  * Note, no "add" uevent will be created with this call, the caller should set
  * up all of the necessary sysfs files for the object and then call
  * kobject_uevent() with the UEVENT_ADD parameter to ensure that
  * userspace is properly notified of this kobject's creation.
+ *
+ * Return: If this function returns an error, kobject_put() must be
+ *         called to properly clean up the memory associated with the
+ *         object.  Under no instance should the kobject that is passed
+ *         to this function be directly freed with a call to kfree(),
+ *         that can leak memory.
+ *
+ *         If this call returns successfully and you later need to unwind
+ *         kobject_add() for the error path you should call kobject_del().
  */
 int kobject_add(struct kobject *kobj, struct kobject *parent,
 		const char *fmt, ...)
@@ -589,6 +593,9 @@ EXPORT_SYMBOL_GPL(kobject_move);
 /**
  * kobject_del - unlink kobject from hierarchy.
  * @kobj: object.
+ *
+ * This is the function that should be called to delete an object
+ * successfully added via kobject_add().
  */
 void kobject_del(struct kobject *kobj)
 {

commit aa30f47cf666111f6bbfd15f290a27e8a7b9d854
Author: Kimberly Brown <kimbrownkd@gmail.com>
Date:   Mon Apr 1 22:51:18 2019 -0400

    kobject: Add support for default attribute groups to kobj_type
    
    kobj_type currently uses a list of individual attributes to store
    default attributes. Attribute groups are more flexible than a list of
    attributes because groups provide support for attribute visibility. So,
    add support for default attribute groups to kobj_type.
    
    In future patches, the existing uses of kobj_type’s attribute list will
    be converted to attribute groups. When that is complete, kobj_type’s
    attribute list, “default_attrs”, will be removed.
    
    Signed-off-by: Kimberly Brown <kimbrownkd@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index aa89edcd2b63..ede40005db28 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -82,6 +82,7 @@ static int populate_dir(struct kobject *kobj)
 
 static int create_dir(struct kobject *kobj)
 {
+	const struct kobj_type *ktype = get_ktype(kobj);
 	const struct kobj_ns_type_operations *ops;
 	int error;
 
@@ -95,6 +96,14 @@ static int create_dir(struct kobject *kobj)
 		return error;
 	}
 
+	if (ktype) {
+		error = sysfs_create_groups(kobj, ktype->default_groups);
+		if (error) {
+			sysfs_remove_dir(kobj);
+			return error;
+		}
+	}
+
 	/*
 	 * @kobj->sd may be deleted by an ancestor going away.  Hold an
 	 * extra reference so that it stays until @kobj is gone.
@@ -584,11 +593,16 @@ EXPORT_SYMBOL_GPL(kobject_move);
 void kobject_del(struct kobject *kobj)
 {
 	struct kernfs_node *sd;
+	const struct kobj_type *ktype = get_ktype(kobj);
 
 	if (!kobj)
 		return;
 
 	sd = kobj->sd;
+
+	if (ktype)
+		sysfs_remove_groups(kobj, ktype->default_groups);
+
 	sysfs_remove_dir(kobj);
 	sysfs_put(sd);
 

commit 7ab35a14de257d5fdac9c7e44c4a1a69967f9fa2
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Jan 8 23:36:14 2019 -0800

    kobject: make kset_get_ownership() 'static'
    
    kset_get_ownership() is only used in lib/kobject.c, so make it 'static'.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index b72e00fd7d09..aa89edcd2b63 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -887,7 +887,7 @@ static void kset_release(struct kobject *kobj)
 	kfree(kset);
 }
 
-void kset_get_ownership(struct kobject *kobj, kuid_t *uid, kgid_t *gid)
+static void kset_get_ownership(struct kobject *kobj, kuid_t *uid, kgid_t *gid)
 {
 	if (kobj->parent)
 		kobject_get_ownership(kobj->parent, uid, gid);

commit 186bddb28ff9f61250d1b33554321d0bf5d085f6
Author: Ezequiel Garcia <ezequiel@collabora.com>
Date:   Mon Dec 3 13:44:35 2018 -0300

    kref/kobject: Improve documentation
    
    The current kref and kobject documentation may be
    insufficient to understand these common pitfalls regarding
    object lifetime and object releasing.
    
    Add a bit more documentation and improve the warnings
    seen by the user, pointing to the right piece of documentation.
    
    Also, it's important to understand that making fun of people
    publicly is not at all helpful, doesn't provide any value,
    and it's not a healthy way of encouraging developers to do better.
    
    "Mocking mercilessly" will, if anything, make developers feel bad
    and go away. This kind of behavior should not be encouraged or justified.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@collabora.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Matthias Brugger <mbrugger@suse.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 97d86dc17c42..b72e00fd7d09 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -639,7 +639,7 @@ static void kobject_cleanup(struct kobject *kobj)
 		 kobject_name(kobj), kobj, __func__, kobj->parent);
 
 	if (t && !t->release)
-		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed.\n",
+		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed. See Documentation/kobject.txt.\n",
 			 kobject_name(kobj), kobj);
 
 	/* send "remove" if the caller did not do it but sent "add" */

commit a18d783fedfe6f9b720afe901db9501ce116ed81
Merge: d5acba26bfa0 d2fc88a61b4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 18 11:44:53 2018 -0700

    Merge tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here are all of the driver core and related patches for 4.19-rc1.
    
      Nothing huge here, just a number of small cleanups and the ability to
      now stop the deferred probing after init happens.
    
      All of these have been in linux-next for a while with only a merge
      issue reported"
    
    * tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (21 commits)
      base: core: Remove WARN_ON from link dependencies check
      drivers/base: stop new probing during shutdown
      drivers: core: Remove glue dirs from sysfs earlier
      driver core: remove unnecessary function extern declare
      sysfs.h: fix non-kernel-doc comment
      PM / Domains: Stop deferring probe at the end of initcall
      iommu: Remove IOMMU_OF_DECLARE
      iommu: Stop deferring probe at end of initcalls
      pinctrl: Support stopping deferred probe after initcalls
      dt-bindings: pinctrl: add a 'pinctrl-use-default' property
      driver core: allow stopping deferred probe after init
      driver core: add a debugfs entry to show deferred devices
      sysfs: Fix internal_create_group() for named group updates
      base: fix order of OF initialization
      linux/device.h: fix kernel-doc notation warning
      Documentation: update firmware loader fallback reference
      kobject: Replace strncpy with memcpy
      drivers: base: cacheinfo: use OF property_read_u32 instead of get_property,read_number
      kernfs: Replace strncpy with memcpy
      device: Add #define dev_fmt similar to #define pr_fmt
      ...

commit d028b6f703209dbe96201b2714ff46625877128e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:49 2018 +0000

    kobject: kset_create_and_add() - fetch ownership info from parent
    
    This change implements get_ownership() for ksets created with
    kset_create_and_add() call by fetching ownership data from parent kobject.
    This is done mostly for benefit of "queues" attribute of net devices so
    that corresponding directory belongs to container's root instead of global
    root for network devices in a container.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/lib/kobject.c b/lib/kobject.c
index f2dc1f756007..389829d3a1d1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -887,9 +887,16 @@ static void kset_release(struct kobject *kobj)
 	kfree(kset);
 }
 
+void kset_get_ownership(struct kobject *kobj, kuid_t *uid, kgid_t *gid)
+{
+	if (kobj->parent)
+		kobject_get_ownership(kobj->parent, uid, gid);
+}
+
 static struct kobj_type kset_ktype = {
 	.sysfs_ops	= &kobj_sysfs_ops,
-	.release = kset_release,
+	.release	= kset_release,
+	.get_ownership	= kset_get_ownership,
 };
 
 /**

commit 5f81880d5204ee2388fd9a75bb850ccd526885b7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:48 2018 +0000

    sysfs, kobject: allow creating kobject belonging to arbitrary users
    
    Normally kobjects and their sysfs representation belong to global root,
    however it is not necessarily the case for objects in separate namespaces.
    For example, objects in separate network namespace logically belong to the
    container's root and not global root.
    
    This change lays groundwork for allowing network namespace objects
    ownership to be transferred to container's root user by defining
    get_ownership() callback in ktype structure and using it in sysfs code to
    retrieve desired uid/gid when creating sysfs objects for given kobject.
    
    Co-Developed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/lib/kobject.c b/lib/kobject.c
index 18989b5b3b56..f2dc1f756007 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -35,6 +35,25 @@ const void *kobject_namespace(struct kobject *kobj)
 	return kobj->ktype->namespace(kobj);
 }
 
+/**
+ * kobject_get_ownership - get sysfs ownership data for @kobj
+ * @kobj: kobject in question
+ * @uid: kernel user ID for sysfs objects
+ * @gid: kernel group ID for sysfs objects
+ *
+ * Returns initial uid/gid pair that should be used when creating sysfs
+ * representation of given kobject. Normally used to adjust ownership of
+ * objects in a container.
+ */
+void kobject_get_ownership(struct kobject *kobj, kuid_t *uid, kgid_t *gid)
+{
+	*uid = GLOBAL_ROOT_UID;
+	*gid = GLOBAL_ROOT_GID;
+
+	if (kobj->ktype->get_ownership)
+		kobj->ktype->get_ownership(kobj, uid, gid);
+}
+
 /*
  * populate_dir - populate directory with attributes.
  * @kobj: object we're working on.

commit 77d2a24b6107bd9b3bf2403a65c1428a9da83dd0
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jul 1 13:57:16 2018 -0700

    kobject: Replace strncpy with memcpy
    
    gcc 8.1.0 complains:
    
    lib/kobject.c:128:3: warning:
            'strncpy' output truncated before terminating nul copying as many
            bytes from a string as its length [-Wstringop-truncation]
    lib/kobject.c: In function 'kobject_get_path':
    lib/kobject.c:125:13: note: length computed here
    
    Using strncpy() is indeed less than perfect since the length of data to
    be copied has already been determined with strlen(). Replace strncpy()
    with memcpy() to address the warning and optimize the code a little.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 18989b5b3b56..e876957743c8 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -125,7 +125,7 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 		int cur = strlen(kobject_name(parent));
 		/* back up enough to print this name with '/' */
 		length -= cur;
-		strncpy(path + length, kobject_name(parent), cur);
+		memcpy(path + length, kobject_name(parent), cur);
 		*(path + --length) = '/';
 	}
 

commit 3e14c6abbfb5c94506edda9d8e2c145d79375798
Author: Dmitry Vyukov <dvyukov@google.com>
Date:   Wed Apr 11 17:22:43 2018 +0200

    kobject: don't use WARN for registration failures
    
    This WARNING proved to be noisy. The function still returns an error
    and callers should handle it. That's how most of kernel code works.
    Downgrade the WARNING to pr_err() and leave WARNINGs for kernel bugs.
    
    Signed-off-by: Dmitry Vyukov <dvyukov@google.com>
    Reported-by: syzbot+209c0f67f99fec8eb14b@syzkaller.appspotmail.com
    Reported-by: syzbot+7fb6d9525a4528104e05@syzkaller.appspotmail.com
    Reported-by: syzbot+2e63711063e2d8f9ea27@syzkaller.appspotmail.com
    Reported-by: syzbot+de73361ee4971b6e6f75@syzkaller.appspotmail.com
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index e1d1f290bf35..18989b5b3b56 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -233,13 +233,12 @@ static int kobject_add_internal(struct kobject *kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			WARN(1,
-			     "%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\n",
-			     __func__, kobject_name(kobj));
+			pr_err("%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\n",
+			       __func__, kobject_name(kobj));
 		else
-			WARN(1, "%s failed for %s (error: %d parent: %s)\n",
-			     __func__, kobject_name(kobj), error,
-			     parent ? kobject_name(parent) : "'none'");
+			pr_err("%s failed for %s (error: %d parent: %s)\n",
+			       __func__, kobject_name(kobj), error,
+			       parent ? kobject_name(parent) : "'none'");
 	} else
 		kobj->state_in_sysfs = 1;
 

commit 82d1f1178a8578599fb52e697ee8ce8b68f1efd0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 15 15:23:43 2018 +0200

    lib/kobject: Join string literals back
    
    There is no need to split string literals. Moreover, it would be simpler
    to grep for an actual code line, when debugging, by using almost any
    part of the string literal in question.
    
    While here, replace printk(LEVEL) by pr_lvl() macros.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index afd5a3fc6123..e1d1f290bf35 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -204,8 +204,9 @@ static int kobject_add_internal(struct kobject *kobj)
 		return -ENOENT;
 
 	if (!kobj->name || !kobj->name[0]) {
-		WARN(1, "kobject: (%p): attempted to be registered with empty "
-			 "name!\n", kobj);
+		WARN(1,
+		     "kobject: (%p): attempted to be registered with empty name!\n",
+		     kobj);
 		return -EINVAL;
 	}
 
@@ -232,9 +233,8 @@ static int kobject_add_internal(struct kobject *kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			WARN(1, "%s failed for %s with "
-			     "-EEXIST, don't try to register things with "
-			     "the same name in the same directory.\n",
+			WARN(1,
+			     "%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\n",
 			     __func__, kobject_name(kobj));
 		else
 			WARN(1, "%s failed for %s (error: %d parent: %s)\n",
@@ -334,8 +334,8 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 	}
 	if (kobj->state_initialized) {
 		/* do not error out as sometimes we can recover */
-		printk(KERN_ERR "kobject (%p): tried to init an initialized "
-		       "object, something is seriously wrong.\n", kobj);
+		pr_err("kobject (%p): tried to init an initialized object, something is seriously wrong.\n",
+		       kobj);
 		dump_stack();
 	}
 
@@ -344,7 +344,7 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 	return;
 
 error:
-	printk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);
+	pr_err("kobject (%p): %s\n", kobj, err_str);
 	dump_stack();
 }
 EXPORT_SYMBOL(kobject_init);
@@ -357,7 +357,7 @@ static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
 
 	retval = kobject_set_name_vargs(kobj, fmt, vargs);
 	if (retval) {
-		printk(KERN_ERR "kobject: can not set name properly!\n");
+		pr_err("kobject: can not set name properly!\n");
 		return retval;
 	}
 	kobj->parent = parent;
@@ -399,8 +399,7 @@ int kobject_add(struct kobject *kobj, struct kobject *parent,
 		return -EINVAL;
 
 	if (!kobj->state_initialized) {
-		printk(KERN_ERR "kobject '%s' (%p): tried to add an "
-		       "uninitialized object, something is seriously wrong.\n",
+		pr_err("kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\n",
 		       kobject_name(kobj), kobj);
 		dump_stack();
 		return -EINVAL;
@@ -590,9 +589,9 @@ struct kobject *kobject_get(struct kobject *kobj)
 {
 	if (kobj) {
 		if (!kobj->state_initialized)
-			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
-			       "initialized, yet kobject_get() is being "
-			       "called.\n", kobject_name(kobj), kobj);
+			WARN(1, KERN_WARNING
+				"kobject: '%s' (%p): is not initialized, yet kobject_get() is being called.\n",
+			     kobject_name(kobj), kobj);
 		kref_get(&kobj->kref);
 	}
 	return kobj;
@@ -622,8 +621,7 @@ static void kobject_cleanup(struct kobject *kobj)
 		 kobject_name(kobj), kobj, __func__, kobj->parent);
 
 	if (t && !t->release)
-		pr_debug("kobject: '%s' (%p): does not have a release() "
-			 "function, it is broken and must be fixed.\n",
+		pr_debug("kobject: '%s' (%p): does not have a release() function, it is broken and must be fixed.\n",
 			 kobject_name(kobj), kobj);
 
 	/* send "remove" if the caller did not do it but sent "add" */
@@ -686,9 +684,9 @@ void kobject_put(struct kobject *kobj)
 {
 	if (kobj) {
 		if (!kobj->state_initialized)
-			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
-			       "initialized, yet kobject_put() is being "
-			       "called.\n", kobject_name(kobj), kobj);
+			WARN(1, KERN_WARNING
+				"kobject: '%s' (%p): is not initialized, yet kobject_put() is being called.\n",
+			     kobject_name(kobj), kobj);
 		kref_put(&kobj->kref, kobject_release);
 	}
 }
@@ -752,8 +750,7 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 
 	retval = kobject_add(kobj, parent, "%s", name);
 	if (retval) {
-		printk(KERN_WARNING "%s: kobject_add error: %d\n",
-		       __func__, retval);
+		pr_warn("%s: kobject_add error: %d\n", __func__, retval);
 		kobject_put(kobj);
 		kobj = NULL;
 	}

commit 47fcc0360cfb3fe82e4daddacad3c1cd80b0b75d
Merge: 5d8515bc2321 c505cbd45f6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 10:00:28 2018 -0800

    Merge tag 'driver-core-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of "big" driver core patches for 4.16-rc1.
    
      The majority of the work here is in the firmware subsystem, with
      reworks to try to attempt to make the code easier to handle in the
      long run, but no functional change. There's also some tree-wide sysfs
      attribute fixups with lots of acks from the various subsystem
      maintainers, as well as a handful of other normal fixes and changes.
    
      And finally, some license cleanups for the driver core and sysfs code.
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (48 commits)
      device property: Define type of PROPERTY_ENRTY_*() macros
      device property: Reuse property_entry_free_data()
      device property: Move property_entry_free_data() upper
      firmware: Fix up docs referring to FIRMWARE_IN_KERNEL
      firmware: Drop FIRMWARE_IN_KERNEL Kconfig option
      USB: serial: keyspan: Drop firmware Kconfig options
      sysfs: remove DEBUG defines
      sysfs: use SPDX identifiers
      drivers: base: add coredump driver ops
      sysfs: add attribute specification for /sysfs/devices/.../coredump
      test_firmware: fix missing unlock on error in config_num_requests_store()
      test_firmware: make local symbol test_fw_config static
      sysfs: turn WARN() into pr_warn()
      firmware: Fix a typo in fallback-mechanisms.rst
      treewide: Use DEVICE_ATTR_WO
      treewide: Use DEVICE_ATTR_RO
      treewide: Use DEVICE_ATTR_RW
      sysfs.h: Use octal permissions
      component: add debugfs support
      bus: simple-pm-bus: convert bool SIMPLE_PM_BUS to tristate
      ...

commit 172856eac7cfaaeabad6a282d3c79d687ad69fc0
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Jan 22 14:27:11 2018 -0800

    kobject: Export kobj_ns_grab_current() and kobj_ns_drop()
    
    Make it possible to call these two functions from a kernel module.
    Note: despite their name, these two functions can be used meaningfully
    independent of kobjects. A later patch will add calls to these
    functions from the SRP driver because this patch series modifies the
    SRP driver such that it can hold a reference to a namespace that can
    last longer than the lifetime of the process through which the
    namespace reference was obtained.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/lib/kobject.c b/lib/kobject.c
index 763d70a18941..06b849eee0ca 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -1039,6 +1039,7 @@ void *kobj_ns_grab_current(enum kobj_ns_type type)
 
 	return ns;
 }
+EXPORT_SYMBOL_GPL(kobj_ns_grab_current);
 
 const void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk)
 {
@@ -1074,3 +1075,4 @@ void kobj_ns_drop(enum kobj_ns_type type, void *ns)
 		kobj_ns_ops_tbl[type]->drop_ns(ns);
 	spin_unlock(&kobj_ns_type_lock);
 }
+EXPORT_SYMBOL_GPL(kobj_ns_drop);

commit 045c5f75b77177ad19fe747e33aae2249a12e827
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:06 2017 +0100

    kobject: Remove redundant license text
    
    Now that the SPDX tag is in all kobject files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 450e771d0ac7..fad12300d264 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -6,9 +6,6 @@
  * Copyright (c) 2006-2007 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (c) 2006-2007 Novell Inc.
  *
- * This file is released under the GPLv2.
- *
- *
  * Please see the file Documentation/kobject.txt for critical information
  * about using the kobject interface.
  */

commit d9d16e16a3f82e88fec99222c9c7e26563b05688
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:05 2017 +0100

    kobject: add SPDX identifiers to all kobject files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the kobject files files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 763d70a18941..450e771d0ac7 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * kobject.c - library routines for handling generic kernel objects
  *

commit c70c176ff8c3ff0ac6ef9a831cd591ea9a66bd1a
Author: Jan Kara <jack@suse.cz>
Date:   Thu Mar 23 01:37:01 2017 +0100

    kobject: Export kobject_get_unless_zero()
    
    Make the function available for outside use and fortify it against NULL
    kobject.
    
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/lib/kobject.c b/lib/kobject.c
index 445dcaeb0f56..763d70a18941 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -601,12 +601,15 @@ struct kobject *kobject_get(struct kobject *kobj)
 }
 EXPORT_SYMBOL(kobject_get);
 
-static struct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)
+struct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)
 {
+	if (!kobj)
+		return NULL;
 	if (!kref_get_unless_zero(&kobj->kref))
 		kobj = NULL;
 	return kobj;
 }
+EXPORT_SYMBOL(kobject_get_unless_zero);
 
 /*
  * kobject_cleanup - free kobject resources.

commit 2fe829aca9d7bed5fd6b49c6a1452e5e486b6cc3
Author: Gabriel Somlo <somlo@cmu.edu>
Date:   Thu Jan 28 09:23:12 2016 -0500

    kobject: export kset_find_obj() for module use
    
    Signed-off-by: Gabriel Somlo <somlo@cmu.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7cbccd2b4c72..445dcaeb0f56 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -861,6 +861,7 @@ struct kobject *kset_find_obj(struct kset *kset, const char *name)
 	spin_unlock(&kset->list_lock);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(kset_find_obj);
 
 static void kset_release(struct kobject *kobj)
 {

commit f773f32d71a4ed9a645634da107cd249e09e1180
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Nov 6 16:31:23 2015 -0800

    lib/kobject.c: use kvasprintf_const for formatting ->name
    
    Sometimes kobject_set_name_vargs is called with a format string conaining
    no %, or a format string of precisely "%s", where the single vararg
    happens to point to .rodata.  kvasprintf_const detects these cases for us
    and returns a copy of that pointer instead of duplicating the string, thus
    saving some run-time memory.  Otherwise, it falls back to kvasprintf.  We
    just need to always deallocate ->name using kfree_const.
    
    Unfortunately, the dance we need to do to perform the '/' -> '!'
    sanitization makes the resulting code rather ugly.
    
    I instrumented kstrdup_const to provide some statistics on the memory
    saved, and for me this gave an additional ~14KB after boot (306KB was
    already saved; this patch bumped that to 320KB).  I have
    KMALLOC_SHIFT_LOW==3, and since 80% of the kvasprintf_const hits were
    satisfied by an 8-byte allocation, the 14K would roughly be quadrupled
    when KMALLOC_SHIFT_LOW==5.  Whether these numbers are sufficient to
    justify the ugliness I'll leave to others to decide.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 055407746266..7cbccd2b4c72 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -257,18 +257,32 @@ static int kobject_add_internal(struct kobject *kobj)
 int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 				  va_list vargs)
 {
-	char *s;
+	const char *s;
 
 	if (kobj->name && !fmt)
 		return 0;
 
-	s = kvasprintf(GFP_KERNEL, fmt, vargs);
+	s = kvasprintf_const(GFP_KERNEL, fmt, vargs);
 	if (!s)
 		return -ENOMEM;
 
-	/* ewww... some of these buggers have '/' in the name ... */
-	strreplace(s, '/', '!');
-	kfree(kobj->name);
+	/*
+	 * ewww... some of these buggers have '/' in the name ... If
+	 * that's the case, we need to make sure we have an actual
+	 * allocated copy to modify, since kvasprintf_const may have
+	 * returned something from .rodata.
+	 */
+	if (strchr(s, '/')) {
+		char *t;
+
+		t = kstrdup(s, GFP_KERNEL);
+		kfree_const(s);
+		if (!t)
+			return -ENOMEM;
+		strreplace(t, '/', '!');
+		s = t;
+	}
+	kfree_const(kobj->name);
 	kobj->name = s;
 
 	return 0;
@@ -466,7 +480,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 	envp[0] = devpath_string;
 	envp[1] = NULL;
 
-	name = dup_name = kstrdup(new_name, GFP_KERNEL);
+	name = dup_name = kstrdup_const(new_name, GFP_KERNEL);
 	if (!name) {
 		error = -ENOMEM;
 		goto out;
@@ -486,7 +500,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 	kobject_uevent_env(kobj, KOBJ_MOVE, envp);
 
 out:
-	kfree(dup_name);
+	kfree_const(dup_name);
 	kfree(devpath_string);
 	kfree(devpath);
 	kobject_put(kobj);
@@ -634,7 +648,7 @@ static void kobject_cleanup(struct kobject *kobj)
 	/* free name if we allocated it */
 	if (name) {
 		pr_debug("kobject: '%s': free name\n", name);
-		kfree(name);
+		kfree_const(name);
 	}
 }
 

commit fa40ae34441286b2cb595468ef781e24573e9e7d
Author: Gabriel Somlo <somlo@cmu.edu>
Date:   Mon Aug 10 15:51:43 2015 -0400

    kobject: move EXPORT_SYMBOL() macros next to corresponding definitions
    
    Move EXPORT_SYMBOL() macros in kobject.c from the end of the file
    next to the function definitions to which they belong.
    
    Signed-off-by: Gabriel Somlo <somlo@cmu.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3e3a5c3cb330..055407746266 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -568,6 +568,7 @@ void kobject_del(struct kobject *kobj)
 	kobject_put(kobj->parent);
 	kobj->parent = NULL;
 }
+EXPORT_SYMBOL(kobject_del);
 
 /**
  * kobject_get - increment refcount for object.
@@ -584,6 +585,7 @@ struct kobject *kobject_get(struct kobject *kobj)
 	}
 	return kobj;
 }
+EXPORT_SYMBOL(kobject_get);
 
 static struct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)
 {
@@ -675,6 +677,7 @@ void kobject_put(struct kobject *kobj)
 		kref_put(&kobj->kref, kobject_release);
 	}
 }
+EXPORT_SYMBOL(kobject_put);
 
 static void dynamic_kobj_release(struct kobject *kobj)
 {
@@ -803,6 +806,7 @@ int kset_register(struct kset *k)
 	kobject_uevent(&k->kobj, KOBJ_ADD);
 	return 0;
 }
+EXPORT_SYMBOL(kset_register);
 
 /**
  * kset_unregister - remove a kset.
@@ -815,6 +819,7 @@ void kset_unregister(struct kset *k)
 	kobject_del(&k->kobj);
 	kobject_put(&k->kobj);
 }
+EXPORT_SYMBOL(kset_unregister);
 
 /**
  * kset_find_obj - search for object in kset.
@@ -1051,10 +1056,3 @@ void kobj_ns_drop(enum kobj_ns_type type, void *ns)
 		kobj_ns_ops_tbl[type]->drop_ns(ns);
 	spin_unlock(&kobj_ns_type_lock);
 }
-
-EXPORT_SYMBOL(kobject_get);
-EXPORT_SYMBOL(kobject_put);
-EXPORT_SYMBOL(kobject_del);
-
-EXPORT_SYMBOL(kset_register);
-EXPORT_SYMBOL(kset_unregister);

commit 8db1486065141e619e4855b84e350ef32064f7e1
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Fri Jul 17 16:23:42 2015 -0700

    include, lib: add __printf attributes to several function prototypes
    
    Using __printf attributes helps to detect several format string issues
    at compile time (even though -Wformat-security is currently disabled in
    Makefile).  For example it can detect when formatting a pointer as a
    number, like the issue fixed in commit a3fa71c40f18 ("wl18xx: show
    rx_frames_per_rates as an array as it really is"), or when the arguments
    do not match the format string, c.f.  for example commit 5ce1aca81435
    ("reiserfs: fix __RASSERT format string").
    
    To prevent similar bugs in the future, add a __printf attribute to every
    function prototype which needs one in include/linux/ and lib/.  These
    functions were mostly found by using gcc's -Wsuggest-attribute=format
    flag.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2e3bd01964a9..3e3a5c3cb330 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -337,8 +337,9 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 }
 EXPORT_SYMBOL(kobject_init);
 
-static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
-			    const char *fmt, va_list vargs)
+static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
+					   struct kobject *parent,
+					   const char *fmt, va_list vargs)
 {
 	int retval;
 

commit 043cd04950431f206f784d1ed9b3fcc5993045f2
Merge: 43baed34bc6b 5a5003df98d5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 30 20:07:45 2015 -0700

    Merge branch 'for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "Outside of our usual batch of fixes, this integrates the subvolume
      quota updates that Qu Wenruo from Fujitsu has been working on for a
      few releases now.  He gets an extra gold star for making btrfs smaller
      this time, and fixing a number of quota corners in the process.
    
      Dave Sterba tested and integrated Anand Jain's sysfs improvements.
      Outside of exporting a symbol (ack'd by Greg) these are all internal
      to btrfs and it's mostly cleanups and fixes.  Anand also attached some
      of our sysfs objects to our internal device management structs instead
      of an object off the super block.  It will make device management
      easier overall and it's a better fit for how the sysfs files are used.
      None of the existing sysfs files are moved around.
    
      Thanks for all the fixes everyone"
    
    * 'for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (87 commits)
      btrfs: delayed-ref: double free in btrfs_add_delayed_tree_ref()
      Btrfs: Check if kobject is initialized before put
      lib: export symbol kobject_move()
      Btrfs: sysfs: add support to show replacing target in the sysfs
      Btrfs: free the stale device
      Btrfs: use received_uuid of parent during send
      Btrfs: fix use-after-free in btrfs_replay_log
      btrfs: wait for delayed iputs on no space
      btrfs: qgroup: Make snapshot accounting work with new extent-oriented qgroup.
      btrfs: qgroup: Add the ability to skip given qgroup for old/new_roots.
      btrfs: ulist: Add ulist_del() function.
      btrfs: qgroup: Cleanup the old ref_node-oriented mechanism.
      btrfs: qgroup: Switch self test to extent-oriented qgroup mechanism.
      btrfs: qgroup: Switch to new extent-oriented qgroup mechanism.
      btrfs: qgroup: Switch rescan to new mechanism.
      btrfs: qgroup: Add new qgroup calculation function btrfs_qgroup_account_extents().
      btrfs: backref: Add special time_seq == (u64)-1 case for btrfs_find_all_roots().
      btrfs: qgroup: Add new function to record old_roots.
      btrfs: qgroup: Record possible quota-related extent for qgroup.
      btrfs: qgroup: Add function qgroup_update_counters().
      ...

commit 2abf114fc841550a3e0c63afcd31c9781116fe42
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Jun 25 15:02:30 2015 -0700

    lib/kobject.c: use strreplace()
    
    There's probably not many slashes in the name, but starting over when
    we see one feels wrong.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3b841b97fccd..75ee63834fd1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -257,23 +257,20 @@ static int kobject_add_internal(struct kobject *kobj)
 int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 				  va_list vargs)
 {
-	const char *old_name = kobj->name;
 	char *s;
 
 	if (kobj->name && !fmt)
 		return 0;
 
-	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
-	if (!kobj->name) {
-		kobj->name = old_name;
+	s = kvasprintf(GFP_KERNEL, fmt, vargs);
+	if (!s)
 		return -ENOMEM;
-	}
 
 	/* ewww... some of these buggers have '/' in the name ... */
-	while ((s = strchr(kobj->name, '/')))
-		s[0] = '!';
+	strreplace(s, '/', '!');
+	kfree(kobj->name);
+	kobj->name = s;
 
-	kfree(old_name);
 	return 0;
 }
 

commit 24199d206a739a77edc3ff6c429b68b7bd6b2ef8
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Feb 12 07:03:37 2015 +0800

    lib: export symbol kobject_move()
    
    drivers/cpufreq/cpufreq.c is already using this function. And now btrfs
    needs it as well. Export symbol kobject_move().
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3b841b97fccd..53bfc853cd8c 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -548,6 +548,7 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 	kfree(devpath);
 	return error;
 }
+EXPORT_SYMBOL_GPL(kobject_move);
 
 /**
  * kobject_del - unlink kobject from hierarchy.

commit d82d54af7b14092dc5934a8ce09170789c9ddb57
Author: Ethan Zhao <ethan.zhao@oracle.com>
Date:   Thu Mar 12 13:04:16 2015 +0900

    kobject: WARN as tip when call kobject_get() to a kobject not initialized
    
    call kobject_get() to kojbect that is not initalized or released will only
    leave following like call trace to us:
    
    -----------[ cut here ]------------
    [   54.545816] WARNING: CPU: 0 PID: 213 at include/linux/kref.h:47
    kobject_get+0x41/0x50()
    [   54.642595] Modules linked in: i2c_i801(+) mfd_core shpchp(+)
    acpi_cpufreq(+) edac_core ioatdma(+) xfs libcrc32c ast syscopyarea ixgbe
    sysfillrect sysimgblt sr_mod sd_mod drm_kms_helper igb mdio cdrom e1000e ahci
    dca ttm libahci uas drm i2c_algo_bit ptp megaraid_sas libata usb_storage
    i2c_core pps_core dm_mirror dm_region_hash dm_log dm_mod
    [   55.007264] CPU: 0 PID: 213 Comm: kworker/0:2 Not tainted
    3.18.5
    [   55.099970] Hardware name: Oracle Corporation SUN FIRE X4170 M2 SERVER
       /ASSY,MOTHERBOARD,X4170, BIOS 08120104 05/08/2012
    [   55.239736] Workqueue: kacpi_notify acpi_os_execute_deferred
    [   55.308598]  0000000000000000 00000000bd730b61 ffff88046742baf8
    ffffffff816b7edb
    [   55.398305]  0000000000000000 0000000000000000 ffff88046742bb38
    ffffffff81078ae1
    [   55.488040]  ffff88046742bbd8 ffff8806706b3000 0000000000000292
    0000000000000000
    [   55.577776] Call Trace:
    [   55.608228]  [<ffffffff816b7edb>] dump_stack+0x46/0x58
    [   55.670895]  [<ffffffff81078ae1>] warn_slowpath_common+0x81/0xa0
    [   55.743952]  [<ffffffff81078bfa>] warn_slowpath_null+0x1a/0x20
    [   55.814929]  [<ffffffff8130d0d1>] kobject_get+0x41/0x50
    [   55.878654]  [<ffffffff8153e955>] cpufreq_cpu_get+0x75/0xc0
    [   55.946528]  [<ffffffff8153f37e>] cpufreq_update_policy+0x2e/0x1f0
    
    The above issue was casued by a race condition, if there is a WARN in
    kobject_get() of the kobject is not initialized, that would save us much
    time to debug it.
    
    Signed-off-by: Ethan Zhao <ethan.zhao@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 03d4ab349fa7..3b841b97fccd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -576,8 +576,13 @@ void kobject_del(struct kobject *kobj)
  */
 struct kobject *kobject_get(struct kobject *kobj)
 {
-	if (kobj)
+	if (kobj) {
+		if (!kobj->state_initialized)
+			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
+			       "initialized, yet kobject_get() is being "
+			       "called.\n", kobject_name(kobj), kobj);
 		kref_get(&kobj->kref);
+	}
 	return kobj;
 }
 

commit 41fb96a4b619afd2272acb6e981a7581efa8e118
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Wed Sep 24 16:25:54 2014 +0530

    kobject: fix NULL pointer derefernce in kobj_child_ns_ops
    
    We will hit NULL pointer dereference if we call
    platform_device_register_simple or platform_device_add at very early
    stage. I have observed following crash when called platform_device_add
    from "init_irq" hook of machine_desc. This patch fixes this issue and
    let system handle this case gracefully instead of kernel panic.
    
    [0.000000] Unable to handle kernel NULL pointer dereference at
    virtual address 0000000c
    [0.000000] pgd = c0004000
    [0.000000] [0000000c] *pgd=00000000
    [0.000000] Internal error: Oops: 5 [#1] PREEMPT ARM
    [0.000000] Modules linked in:
    [0.000000] CPU: 0 PID: 0 Comm: swapper Tainted: G        W 3.17.0-rc6-00198-ga1603f1-dirty #319
    [0.000000] task: c05b23f0 ti: c05a8000 task.ti: c05a8000
    [0.000000] PC is at kobject_namespace+0x18/0x58
    [0.000000] LR is at kobject_add_internal+0x90/0x2ec
    [snip]
    [0.000000] [<c01b1df0>] (kobject_namespace) from [<c01b2338>] (kobject_add_internal+0x90/0x2ec)
    [0.000000] [<c01b2338>] (kobject_add_internal) from [<c01b2728>] (kobject_add+0x4c/0x98)
    [0.000000] [<c01b2728>] (kobject_add) from [<c0226274>] (device_add+0xe8/0x51c)
    [0.000000] [<c0226274>] (device_add) from [<c0229c70>] (platform_device_add+0xb4/0x214)
    [0.000000] [<c0229c70>] (platform_device_add) from [<c022a338>] (platform_device_register_full+0xb8/0xdc)
    [0.000000] [<c022a338>] (platform_device_register_full) from [<c0570214>] (exynos_init_irq+0x90/0x9c)
    [0.000000] [<c0570214>] (exynos_init_irq) from [<c056c18c>] (init_IRQ+0x2c/0x78)
    [0.000000] [<c056c18c>] (init_IRQ) from [<c0569a54>] (start_kernel+0x22c/0x378)
    [0.000000] [<c0569a54>] (start_kernel) from [<40008070>] (0x40008070)
    [0.000000] Code: e590000c e3500000 0a00000e e5903014 (e593300c)
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 58751bb80a7c..03d4ab349fa7 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -976,7 +976,7 @@ const struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent)
 {
 	const struct kobj_ns_type_operations *ops = NULL;
 
-	if (parent && parent->ktype->child_ns_type)
+	if (parent && parent->ktype && parent->ktype->child_ns_type)
 		ops = parent->ktype->child_ns_type(parent);
 
 	return ops;

commit fa4cd451cceb77e97432b91fcf50a7e4a7361e29
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 7 13:32:07 2014 -0500

    sysfs, kobject: add sysfs wrapper for kernfs_enable_ns()
    
    Currently, kobject is invoking kernfs_enable_ns() directly.  This is
    fine now as sysfs and kernfs are enabled and disabled together.  If
    sysfs is disabled, kernfs_enable_ns() is switched to dummy
    implementation too and everything is fine; however, kernfs will soon
    have its own config option CONFIG_KERNFS and !SYSFS && KERNFS will be
    possible, which can make kobject call into non-dummy
    kernfs_enable_ns() with NULL kernfs_node pointers leading to an oops.
    
    Introduce sysfs_enable_ns() which is a wrapper around
    kernfs_enable_ns() so that it can be made a noop depending only on
    CONFIG_SYSFS regardless of the planned CONFIG_KERNFS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index cb14aeac4cca..58751bb80a7c 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -94,7 +94,7 @@ static int create_dir(struct kobject *kobj)
 		BUG_ON(ops->type >= KOBJ_NS_TYPES);
 		BUG_ON(!kobj_ns_type_registered(ops->type));
 
-		kernfs_enable_ns(kobj->sd);
+		sysfs_enable_ns(kobj->sd);
 	}
 
 	return 0;

commit e7651b819e90da924991d727d3c007200a18670d
Merge: 060e8e3b6f8f cf93da7bcf45
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 30 20:08:20 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This is a pretty big pull, and most of these changes have been
      floating in btrfs-next for a long time.  Filipe's properties work is a
      cool building block for inheriting attributes like compression down on
      a per inode basis.
    
      Jeff Mahoney kicked in code to export filesystem info into sysfs.
    
      Otherwise, lots of performance improvements, cleanups and bug fixes.
    
      Looks like there are still a few other small pending incrementals, but
      I wanted to get the bulk of this in first"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (149 commits)
      Btrfs: fix spin_unlock in check_ref_cleanup
      Btrfs: setup inode location during btrfs_init_inode_locked
      Btrfs: don't use ram_bytes for uncompressed inline items
      Btrfs: fix btrfs_search_slot_for_read backwards iteration
      Btrfs: do not export ulist functions
      Btrfs: rework ulist with list+rb_tree
      Btrfs: fix memory leaks on walking backrefs failure
      Btrfs: fix send file hole detection leading to data corruption
      Btrfs: add a reschedule point in btrfs_find_all_roots()
      Btrfs: make send's file extent item search more efficient
      Btrfs: fix to catch all errors when resolving indirect ref
      Btrfs: fix protection between walking backrefs and root deletion
      btrfs: fix warning while merging two adjacent extents
      Btrfs: fix infinite path build loops in incremental send
      btrfs: undo sysfs when open_ctree() fails
      Btrfs: fix snprintf usage by send's gen_unique_name
      btrfs: fix defrag 32-bit integer overflow
      btrfs: sysfs: list the NO_HOLES feature
      btrfs: sysfs: don't show reserved incompat feature
      btrfs: call permission checks earlier in ioctls and return EPERM
      ...

commit 29dfe2dc0e8f85c5656d13bb4c78a5ffca54c452
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Nov 1 13:06:56 2013 -0400

    kobject: export kobj_sysfs_ops
    
    struct kobj_attribute implements the baseline attribute functionality
    that can be used all over the place. We should export the ops associated
    with it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/lib/kobject.c b/lib/kobject.c
index 5b4b8886435e..03512a40a3ef 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -758,6 +758,7 @@ const struct sysfs_ops kobj_sysfs_ops = {
 	.show	= kobj_attr_show,
 	.store	= kobj_attr_store,
 };
+EXPORT_SYMBOL_GPL(kobj_sysfs_ops);
 
 /**
  * kobj_completion_init - initialize a kobj_completion object.

commit 9705710e40b9e5acaf003f90d6ed883ba193b314
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Jan 4 14:20:04 2014 +0100

    kobject: Fix source code comment spelling
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index f7f69cbe4f6e..b0b26665c611 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -365,7 +365,7 @@ static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
  *
  * If @parent is set, then the parent of the @kobj will be set to it.
  * If @parent is NULL, then the parent of the @kobj will be set to the
- * kobject associted with the kset assigned to this kobject.  If no kset
+ * kobject associated with the kset assigned to this kobject.  If no kset
  * is assigned to the kobject, then the kobject will be located in the
  * root of the sysfs tree.
  *

commit eb4c69033fd1dda8b60e48af3accdd578c2e59ed
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jan 4 19:56:40 2014 -0800

    Revert "kobject: introduce kobj_completion"
    
    This reverts commit eee031649707db3c9920d9498f8d03819b74fc23.
    
    Jeff writes:
            I have no objections to reverting it. There were concerns from
            Al Viro that it'd be tough to get right by callers and I had
            assumed it got dropped after that. I had planned on using it in
            my btrfs sysfs exports patchset but came up with a better way.
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 064451f2a6c3..f7f69cbe4f6e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -13,7 +13,6 @@
  */
 
 #include <linux/kobject.h>
-#include <linux/kobj_completion.h>
 #include <linux/string.h>
 #include <linux/export.h>
 #include <linux/stat.h>
@@ -781,55 +780,6 @@ const struct sysfs_ops kobj_sysfs_ops = {
 	.store	= kobj_attr_store,
 };
 
-/**
- * kobj_completion_init - initialize a kobj_completion object.
- * @kc: kobj_completion
- * @ktype: type of kobject to initialize
- *
- * kobj_completion structures can be embedded within structures with different
- * lifetime rules.  During the release of the enclosing object, we can
- * wait on the release of the kobject so that we don't free it while it's
- * still busy.
- */
-void kobj_completion_init(struct kobj_completion *kc, struct kobj_type *ktype)
-{
-	init_completion(&kc->kc_unregister);
-	kobject_init(&kc->kc_kobj, ktype);
-}
-EXPORT_SYMBOL_GPL(kobj_completion_init);
-
-/**
- * kobj_completion_release - release a kobj_completion object
- * @kobj: kobject embedded in kobj_completion
- *
- * Used with kobject_release to notify waiters that the kobject has been
- * released.
- */
-void kobj_completion_release(struct kobject *kobj)
-{
-	struct kobj_completion *kc = kobj_to_kobj_completion(kobj);
-	complete(&kc->kc_unregister);
-}
-EXPORT_SYMBOL_GPL(kobj_completion_release);
-
-/**
- * kobj_completion_del_and_wait - release the kobject and wait for it
- * @kc: kobj_completion object to release
- *
- * Delete the kobject from sysfs and drop the reference count.  Then wait
- * until any other outstanding references are also dropped.  This routine
- * is only necessary once other references may have been taken on the
- * kobject.  Typically this happens when the kobject has been published
- * to sysfs via kobject_add.
- */
-void kobj_completion_del_and_wait(struct kobj_completion *kc)
-{
-	kobject_del(&kc->kc_kobj);
-	kobject_put(&kc->kc_kobj);
-	wait_for_completion(&kc->kc_unregister);
-}
-EXPORT_SYMBOL_GPL(kobj_completion_del_and_wait);
-
 /**
  * kset_register - initialize and add a kset.
  * @k: kset.

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 94b321f4ac67..064451f2a6c3 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -556,7 +556,7 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
  */
 void kobject_del(struct kobject *kobj)
 {
-	struct sysfs_dirent *sd;
+	struct kernfs_node *sd;
 
 	if (!kobj)
 		return;

commit 020d30f17f196dcbf0c2c68a874345e8885a3149
Author: Maurizio Lombardi <mlombard@redhat.com>
Date:   Fri Nov 8 15:28:25 2013 +0100

    kobject: fix memory leak in kobject_set_name_vargs
    
    If the call to kvasprintf fails then the old name of the object will be leaked,
    this patch fixes the bug by restoring the old name before returning ENOMEM.
    
    Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 98b45bb33c8d..94b321f4ac67 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -265,8 +265,10 @@ int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 		return 0;
 
 	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
-	if (!kobj->name)
+	if (!kobj->name) {
+		kobj->name = old_name;
 		return -ENOMEM;
+	}
 
 	/* ewww... some of these buggers have '/' in the name ... */
 	while ((s = strchr(kobj->name, '/')))

commit 35a5fe695b07ae899510ad76fdf0aeaef85fe951
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 5 17:38:00 2013 -0700

    kobject: remove kset from sysfs immediately in kset_unregister()
    
    There's no "unlink from sysfs" interface for ksets, so I think callers of
    kset_unregister() expect the kset to be removed from sysfs immediately,
    without waiting for the last reference to be released.
    
    This patch makes the sysfs removal happen immediately, so the caller may
    create a new kset with the same name as soon as kset_unregister() returns.
    Without this, every caller has to call "kobject_del(&kset->kobj)" first
    unless it knows it will never create a new kset with the same name.
    
    This sometimes shows up on module unload and reload, where the reload fails
    because it tries to create a kobject with the same name as one from the
    original load that still exists.  CONFIG_DEBUG_KOBJECT_RELEASE=y makes this
    problem easier to hit.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1d110dc95db5..98b45bb33c8d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -855,6 +855,7 @@ void kset_unregister(struct kset *k)
 {
 	if (!k)
 		return;
+	kobject_del(&k->kobj);
 	kobject_put(&k->kobj);
 }
 

commit 89c86a64cd056e283323710c9ddf6f7090a450c8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 5 17:37:51 2013 -0700

    kobject: delay kobject release for random time
    
    When CONFIG_DEBUG_KOBJECT_RELEASE=y, delay kobject release functions for a
    random time between 1 and 8 seconds, which effectively changes the order in
    which they're called.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index b8d848fb1377..1d110dc95db5 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -18,6 +18,7 @@
 #include <linux/export.h>
 #include <linux/stat.h>
 #include <linux/slab.h>
+#include <linux/random.h>
 
 /**
  * kobject_namespace - return @kobj's namespace tag
@@ -642,10 +643,12 @@ static void kobject_release(struct kref *kref)
 {
 	struct kobject *kobj = container_of(kref, struct kobject, kref);
 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
-	pr_info("kobject: '%s' (%p): %s, parent %p (delayed)\n",
-		 kobject_name(kobj), kobj, __func__, kobj->parent);
+	unsigned long delay = HZ + HZ * (get_random_int() & 0x3);
+	pr_info("kobject: '%s' (%p): %s, parent %p (delayed %ld)\n",
+		 kobject_name(kobj), kobj, __func__, kobj->parent, delay);
 	INIT_DELAYED_WORK(&kobj->release, kobject_delayed_cleanup);
-	schedule_delayed_work(&kobj->release, HZ);
+
+	schedule_delayed_work(&kobj->release, delay);
 #else
 	kobject_cleanup(kobj);
 #endif

commit 93b2b8e4aa4317e3fe6414d117deb5f3c362e8bb
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:15 2013 -0500

    sysfs, kernfs: introduce kernfs_create_dir[_ns]()
    
    Introduce kernfs interface to manipulate a directory which takes and
    returns sysfs_dirents.
    
    create_dir() is renamed to kernfs_create_dir_ns() and its argumantes
    and return value are updated.  create_dir() usages are replaced with
    kernfs_create_dir_ns() and sysfs_create_subdir() usages are replaced
    with kernfs_create_dir().  Dup warnings are handled explicitly by
    sysfs users of the kernfs interface.
    
    sysfs_enable_ns() is renamed to kernfs_enable_ns().
    
    This patch doesn't introduce any behavior changes.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    v3: kernfs_enable_ns() added.
    
    v4: Refreshed on top of "sysfs: drop kobj_ns_type handling, take #2"
        so that this patch removes sysfs_enable_ns().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 16e9335b32d3..b8d848fb1377 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -94,7 +94,7 @@ static int create_dir(struct kobject *kobj)
 		BUG_ON(ops->type >= KOBJ_NS_TYPES);
 		BUG_ON(!kobj_ns_type_registered(ops->type));
 
-		sysfs_enable_ns(kobj->sd);
+		kernfs_enable_ns(kobj->sd);
 	}
 
 	return 0;

commit c84a3b27798dfce928b867fa1c9f3c3fd66f0a31
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 18:01:46 2013 -0500

    sysfs: drop kobj_ns_type handling, take #2
    
    The way namespace tags are implemented in sysfs is more complicated
    than necessary.  As each tag is a pointer value and required to be
    non-NULL under a namespace enabled parent, there's no need to record
    separately what type each tag is.  If multiple namespace types are
    needed, which currently aren't, we can simply compare the tag to a set
    of allowed tags in the superblock assuming that the tags, being
    pointers, won't have the same value across multiple types.
    
    This patch rips out kobj_ns_type handling from sysfs.  sysfs now has
    an enable switch to turn on namespace under a node.  If enabled, all
    children are required to have non-NULL namespace tags and filtered
    against the super_block's tag.
    
    kobject namespace determination is now performed in
    lib/kobject.c::create_dir() making sysfs_read_ns_type() unnecessary.
    The sanity checks are also moved.  create_dir() is restructured to
    ease such addition.  This removes most kobject namespace knowledge
    from sysfs proper which will enable proper separation and layering of
    sysfs.
    
    This is the second try.  The first one was cb26a311578e ("sysfs: drop
    kobj_ns_type handling") which tried to automatically enable namespace
    if there are children with non-NULL namespace tags; however, it was
    broken for symlinks as they should inherit the target's tag iff
    namespace is enabled in the parent.  This led to namespace filtering
    enabled incorrectly for wireless net class devices through phy80211
    symlinks and thus network configuration failure.  a1212d278c05
    ("Revert "sysfs: drop kobj_ns_type handling"") reverted the commit.
    
    This shouldn't introduce any behavior changes, for real.
    
    v2: Dummy implementation of sysfs_enable_ns() for !CONFIG_SYSFS was
        missing and caused build failure.  Reported by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 5b4b8886435e..16e9335b32d3 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -65,13 +65,17 @@ static int populate_dir(struct kobject *kobj)
 
 static int create_dir(struct kobject *kobj)
 {
+	const struct kobj_ns_type_operations *ops;
 	int error;
 
 	error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));
-	if (!error) {
-		error = populate_dir(kobj);
-		if (error)
-			sysfs_remove_dir(kobj);
+	if (error)
+		return error;
+
+	error = populate_dir(kobj);
+	if (error) {
+		sysfs_remove_dir(kobj);
+		return error;
 	}
 
 	/*
@@ -80,7 +84,20 @@ static int create_dir(struct kobject *kobj)
 	 */
 	sysfs_get(kobj->sd);
 
-	return error;
+	/*
+	 * If @kobj has ns_ops, its children need to be filtered based on
+	 * their namespace tags.  Enable namespace support on @kobj->sd.
+	 */
+	ops = kobj_child_ns_ops(kobj);
+	if (ops) {
+		BUG_ON(ops->type <= KOBJ_NS_TYPE_NONE);
+		BUG_ON(ops->type >= KOBJ_NS_TYPES);
+		BUG_ON(!kobj_ns_type_registered(ops->type));
+
+		sysfs_enable_ns(kobj->sd);
+	}
+
+	return 0;
 }
 
 static int get_kobj_path_length(struct kobject *kobj)

commit a1212d278c05ca0a38f5cbd7ae90ac2e367228a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 7 20:47:28 2013 +0900

    Revert "sysfs: drop kobj_ns_type handling"
    
    This reverts commit cb26a311578e67769e92a39a0a63476533cb7e12.
    
    It mysteriously causes NetworkManager to not find the wireless device
    for me.  As far as I can tell, Tejun *meant* for this commit to not make
    any semantic changes, but there clearly are some.  So revert it, taking
    into account some of the calling convention changes that happened in
    this area in subsequent commits.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7a1c203083eb..5b4b8886435e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -30,14 +30,11 @@
 const void *kobject_namespace(struct kobject *kobj)
 {
 	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);
-	const void *ns;
 
 	if (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)
 		return NULL;
 
-	ns = kobj->ktype->namespace(kobj);
-	WARN_ON(!ns);	/* @kobj in a namespace is required to have !NULL tag */
-	return ns;
+	return kobj->ktype->namespace(kobj);
 }
 
 /*

commit 1461c5be7becc6e65dba5cadb31fb5f4339609f5
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Wed Oct 9 09:26:21 2013 +0800

    kobject: show debug info on delayed kobject release
    
    Useful for locating buggy drivers on kernel oops.
    
    It may add dozens of new lines to boot dmesg. DEBUG_KOBJECT_RELEASE is
    hopefully only enabled in debug kernels (like maybe the Fedora rawhide
    one, or at developers), so being a bit more verbose is likely ok.
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2fdf7fa9e9bd..7a1c203083eb 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -628,7 +628,7 @@ static void kobject_release(struct kref *kref)
 {
 	struct kobject *kobj = container_of(kref, struct kobject, kref);
 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
-	pr_debug("kobject: '%s' (%p): %s, parent %p (delayed)\n",
+	pr_info("kobject: '%s' (%p): %s, parent %p (delayed)\n",
 		 kobject_name(kobj), kobj, __func__, kobj->parent);
 	INIT_DELAYED_WORK(&kobj->release, kobject_delayed_cleanup);
 	schedule_delayed_work(&kobj->release, HZ);

commit 26ea12dec0c84133add937455be76d44fe253d85
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 18 17:15:36 2013 -0400

    kobject: grab an extra reference on kobject->sd to allow duplicate deletes
    
    sysfs currently has a rather weird behavior regarding removals.  A
    directory removal would delete all files directly under it but
    wouldn't recurse into subdirectories, which, while a bit inconsistent,
    seems to make sense at the first glance as each directory is
    supposedly associated with a kobject and each kobject can take care of
    the directory deletion; however, this doesn't really hold as we have
    groups which can be directories without a kobject associated with it
    and require explicit deletions.
    
    We're in the process of separating out sysfs from kboject / driver
    core and want a consistent behavior.  A removal should delete either
    only the specified node or everything under it.  I think it is helpful
    to support recursive atomic removal and later patches will implement
    it.
    
    Such change means that a sysfs_dirent associated with kobject may be
    deleted before the kobject itself is removed if one of its ancestor
    gets removed before it.  As sysfs_remove_dir() puts the base ref, we
    may end up with dangling pointer on descendants.  This can be solved
    by holding an extra reference on the sd from kobject.
    
    Acquire an extra reference on the associated sysfs_dirent on directory
    creation and put it after removal.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 151089788c21..2fdf7fa9e9bd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -76,6 +76,13 @@ static int create_dir(struct kobject *kobj)
 		if (error)
 			sysfs_remove_dir(kobj);
 	}
+
+	/*
+	 * @kobj->sd may be deleted by an ancestor going away.  Hold an
+	 * extra reference so that it stays until @kobj is gone.
+	 */
+	sysfs_get(kobj->sd);
+
 	return error;
 }
 
@@ -532,10 +539,15 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
  */
 void kobject_del(struct kobject *kobj)
 {
+	struct sysfs_dirent *sd;
+
 	if (!kobj)
 		return;
 
+	sd = kobj->sd;
 	sysfs_remove_dir(kobj);
+	sysfs_put(sd);
+
 	kobj->state_in_sysfs = 0;
 	kobj_kset_leave(kobj);
 	kobject_put(kobj->parent);

commit 88502b9c0a5dcc884c0dbfb6ddf964ff5da5d8d3
Merge: e18945b159a1 15c03dd4859a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 29 18:29:23 2013 -0700

    Merge 3.12-rc3 into driver-core-next
    
    We want the driver core and sysfs fixes in here to make merges and
    development easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 730d7d339884f20da28b59bf6f0a16af6400a113
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Sep 23 14:41:17 2013 -0700

    sysfs: Allow mounting without CONFIG_NET
    
    In kobj_ns_current_may_mount the default should be to allow the mount.
    The test is only for a single kobj_ns_type at a time, and unless there
    is a reason to prevent it the mounting sysfs should be allowed.
    Subsystems that are not registered can't have are not involved so can't
    have a reason to prevent mounting sysfs.
    
    This is a bug-fix to commit 7dc5dbc879bd ("sysfs: Restrict mounting
    sysfs") that came in via the userns tree during the 3.12 merge window.
    
    Reported-and-tested-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 962175134702..669bf190d4fb 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -933,10 +933,7 @@ const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)
 
 bool kobj_ns_current_may_mount(enum kobj_ns_type type)
 {
-	bool may_mount = false;
-
-	if (type == KOBJ_NS_TYPE_NONE)
-		return true;
+	bool may_mount = true;
 
 	spin_lock(&kobj_ns_type_lock);
 	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&

commit eee031649707db3c9920d9498f8d03819b74fc23
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Sep 11 13:00:30 2013 -0400

    kobject: introduce kobj_completion
    
    A common way to handle kobject lifetimes in embedded in objects with
    different lifetime rules is to pair the kobject with a struct completion.
    
    This introduces a kobj_completion structure that can be used in place
    of the pairing, along with several convenience functions for
    initialization, release, and put-and-wait.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index e769ee3c2fb9..a5a9b13b0648 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/kobject.h>
+#include <linux/kobj_completion.h>
 #include <linux/string.h>
 #include <linux/export.h>
 #include <linux/stat.h>
@@ -749,6 +750,55 @@ const struct sysfs_ops kobj_sysfs_ops = {
 	.store	= kobj_attr_store,
 };
 
+/**
+ * kobj_completion_init - initialize a kobj_completion object.
+ * @kc: kobj_completion
+ * @ktype: type of kobject to initialize
+ *
+ * kobj_completion structures can be embedded within structures with different
+ * lifetime rules.  During the release of the enclosing object, we can
+ * wait on the release of the kobject so that we don't free it while it's
+ * still busy.
+ */
+void kobj_completion_init(struct kobj_completion *kc, struct kobj_type *ktype)
+{
+	init_completion(&kc->kc_unregister);
+	kobject_init(&kc->kc_kobj, ktype);
+}
+EXPORT_SYMBOL_GPL(kobj_completion_init);
+
+/**
+ * kobj_completion_release - release a kobj_completion object
+ * @kobj: kobject embedded in kobj_completion
+ *
+ * Used with kobject_release to notify waiters that the kobject has been
+ * released.
+ */
+void kobj_completion_release(struct kobject *kobj)
+{
+	struct kobj_completion *kc = kobj_to_kobj_completion(kobj);
+	complete(&kc->kc_unregister);
+}
+EXPORT_SYMBOL_GPL(kobj_completion_release);
+
+/**
+ * kobj_completion_del_and_wait - release the kobject and wait for it
+ * @kc: kobj_completion object to release
+ *
+ * Delete the kobject from sysfs and drop the reference count.  Then wait
+ * until any other outstanding references are also dropped.  This routine
+ * is only necessary once other references may have been taken on the
+ * kobject.  Typically this happens when the kobject has been published
+ * to sysfs via kobject_add.
+ */
+void kobj_completion_del_and_wait(struct kobj_completion *kc)
+{
+	kobject_del(&kc->kc_kobj);
+	kobject_put(&kc->kc_kobj);
+	wait_for_completion(&kc->kc_unregister);
+}
+EXPORT_SYMBOL_GPL(kobj_completion_del_and_wait);
+
 /**
  * kset_register - initialize and add a kset.
  * @k: kset.

commit cb26a311578e67769e92a39a0a63476533cb7e12
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 22:29:07 2013 -0400

    sysfs: drop kobj_ns_type handling
    
    The way namespace tags are implemented in sysfs is more complicated
    than necessary.  As each tag is a pointer value and required to be
    non-NULL under a namespace enabled parent, there's no need to record
    separately what type each tag is or where namespace is enabled.
    
    If multiple namespace types are needed, which currently aren't, we can
    simply compare the tag to a set of allowed tags in the superblock
    assuming that the tags, being pointers, won't have the same value
    across multiple types.  Also, whether to filter by namespace tag or
    not can be trivially determined by whether the node has any tagged
    children or not.
    
    This patch rips out kobj_ns_type handling from sysfs.  sysfs no longer
    cares whether specific type of namespace is enabled or not.  If a
    sysfs_dirent has a non-NULL tag, the parent is marked as needing
    namespace filtering and the value is tested against the allowed set of
    tags for the superblock (currently only one but increasing this number
    isn't difficult) and the sysfs_dirent is ignored if it doesn't match.
    
    This removes most kobject namespace knowledge from sysfs proper which
    will enable proper separation and layering of sysfs.  The namespace
    sanity checks in fs/sysfs/dir.c are replaced by the new sanity check
    in kobject_namespace().  As this is the only place ktype->namespace()
    is called for sysfs, this doesn't weaken the sanity check
    significantly.  I omitted converting the sanity check in
    sysfs_do_create_link_sd().  While the check can be shifted to upper
    layer, mistakes there are well contained and should be easily visible
    anyway.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 85fb3a161b21..e769ee3c2fb9 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -29,11 +29,14 @@
 const void *kobject_namespace(struct kobject *kobj)
 {
 	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);
+	const void *ns;
 
 	if (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)
 		return NULL;
 
-	return kobj->ktype->namespace(kobj);
+	ns = kobj->ktype->namespace(kobj);
+	WARN_ON(!ns);	/* @kobj in a namespace is required to have !NULL tag */
+	return ns;
 }
 
 /*

commit e34ff4906199d2ebd248ae897ae34f52bea151c9
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 22:29:05 2013 -0400

    sysfs: remove ktype->namespace() invocations in directory code
    
    For some unrecognizable reason, namespace information is communicated
    to sysfs through ktype->namespace() callback when there's *nothing*
    which needs the use of a callback.  The whole sequence of operations
    is completely synchronous and sysfs operations simply end up calling
    back into the layer which just invoked it in order to find out the
    namespace information, which is completely backwards, obfuscates
    what's going on and unnecessarily tangles two separate layers.
    
    This patch doesn't remove ktype->namespace() but shifts its handling
    to kobject layer.  We probably want to get rid of the callback in the
    long term.
    
    This patch adds an explicit param to sysfs_{create|rename|move}_dir()
    and renames them to sysfs_{create|rename|move}_dir_ns(), respectively.
    ktype->namespace() invocations are moved to the calling sites of the
    above functions.  A new helper kboject_namespace() is introduced which
    directly tests kobj_ns_type_operations->type which should give the
    same result as testing sysfs_fs_type(parent_sd) and returns @kobj's
    namespace tag as necessary.  kobject_namespace() is extern as it will
    be used from another file in the following patches.
    
    This patch should be an equivalent conversion without any functional
    difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 962175134702..85fb3a161b21 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -18,6 +18,24 @@
 #include <linux/stat.h>
 #include <linux/slab.h>
 
+/**
+ * kobject_namespace - return @kobj's namespace tag
+ * @kobj: kobject in question
+ *
+ * Returns namespace tag of @kobj if its parent has namespace ops enabled
+ * and thus @kobj should have a namespace tag associated with it.  Returns
+ * %NULL otherwise.
+ */
+const void *kobject_namespace(struct kobject *kobj)
+{
+	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);
+
+	if (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)
+		return NULL;
+
+	return kobj->ktype->namespace(kobj);
+}
+
 /*
  * populate_dir - populate directory with attributes.
  * @kobj: object we're working on.
@@ -46,8 +64,9 @@ static int populate_dir(struct kobject *kobj)
 
 static int create_dir(struct kobject *kobj)
 {
-	int error = 0;
-	error = sysfs_create_dir(kobj);
+	int error;
+
+	error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));
 	if (!error) {
 		error = populate_dir(kobj);
 		if (error)
@@ -428,7 +447,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 		goto out;
 	}
 
-	error = sysfs_rename_dir(kobj, new_name);
+	error = sysfs_rename_dir_ns(kobj, new_name, kobject_namespace(kobj));
 	if (error)
 		goto out;
 
@@ -472,6 +491,7 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 		if (kobj->kset)
 			new_parent = kobject_get(&kobj->kset->kobj);
 	}
+
 	/* old object path */
 	devpath = kobject_get_path(kobj, GFP_KERNEL);
 	if (!devpath) {
@@ -486,7 +506,7 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 	sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);
 	envp[0] = devpath_string;
 	envp[1] = NULL;
-	error = sysfs_move_dir(kobj, new_parent);
+	error = sysfs_move_dir_ns(kobj, new_parent, kobject_namespace(kobj));
 	if (error)
 		goto out;
 	old_parent = kobj->parent;

commit c7c4591db64dbd1e504bc4e2806d7ef290a3c81b
Merge: 11c7b03d42a8 c7b96acf1456
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 7 14:35:32 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace changes from Eric Biederman:
     "This is an assorted mishmash of small cleanups, enhancements and bug
      fixes.
    
      The major theme is user namespace mount restrictions.  nsown_capable
      is killed as it encourages not thinking about details that need to be
      considered.  A very hard to hit pid namespace exiting bug was finally
      tracked and fixed.  A couple of cleanups to the basic namespace
      infrastructure.
    
      Finally there is an enhancement that makes per user namespace
      capabilities usable as capabilities, and an enhancement that allows
      the per userns root to nice other processes in the user namespace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      userns:  Kill nsown_capable it makes the wrong thing easy
      capabilities: allow nice if we are privileged
      pidns: Don't have unshare(CLONE_NEWPID) imply CLONE_THREAD
      userns: Allow PR_CAPBSET_DROP in a user namespace.
      namespaces: Simplify copy_namespaces so it is clear what is going on.
      pidns: Fix hang in zap_pid_ns_processes by sending a potentially extra wakeup
      sysfs: Restrict mounting sysfs
      userns: Better restrictions on when proc and sysfs can be mounted
      vfs: Don't copy mount bind mounts of /proc/<pid>/ns/mnt between namespaces
      kernel/nsproxy.c: Improving a snippet of code.
      proc: Restrict mounting the proc filesystem
      vfs: Lock in place mounts from more privileged users

commit 7dc5dbc879bd0779924b5132a48b731a0bc04a1e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Mar 25 20:07:01 2013 -0700

    sysfs: Restrict mounting sysfs
    
    Don't allow mounting sysfs unless the caller has CAP_SYS_ADMIN rights
    over the net namespace.  The principle here is if you create or have
    capabilities over it you can mount it, otherwise you get to live with
    what other people have mounted.
    
    Instead of testing this with a straight forward ns_capable call,
    perform this check the long and torturous way with kobject helpers,
    this keeps direct knowledge of namespaces out of sysfs, and preserves
    the existing sysfs abstractions.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4a1f33d43548..3bbde222c90f 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -915,6 +915,21 @@ const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)
 	return kobj_child_ns_ops(kobj->parent);
 }
 
+bool kobj_ns_current_may_mount(enum kobj_ns_type type)
+{
+	bool may_mount = false;
+
+	if (type == KOBJ_NS_TYPE_NONE)
+		return true;
+
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
+	    kobj_ns_ops_tbl[type])
+		may_mount = kobj_ns_ops_tbl[type]->current_may_mount();
+	spin_unlock(&kobj_ns_type_lock);
+
+	return may_mount;
+}
 
 void *kobj_ns_grab_current(enum kobj_ns_type type)
 {

commit c817a67ecba7c3c2aaa104796d78f160af60920d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 27 15:06:14 2013 +0100

    kobject: delayed kobject release: help find buggy drivers
    
    Implement debugging for kobject release functions.  kobjects are
    reference counted, so the drop of the last reference to them is not
    predictable. However, the common case is for the last reference to be
    the kobject's removal from a subsystem, which results in the release
    function being immediately called.
    
    This can hide subtle bugs, which can occur when another thread holds a
    reference to the kobject at the same time that a kobject is removed.
    This results in the release method being delayed.
    
    In order to make these kinds of problems more visible, the following
    patch implements a delayed release; this has the effect that the
    release function will be out of order with respect to the removal of
    the kobject in the same manner that it would be if a reference was
    being held.
    
    This provides us with an easy way to allow driver writers to debug
    their drivers and fix otherwise hidden problems.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4a1f33d43548..1d46c151a4ae 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -545,8 +545,8 @@ static void kobject_cleanup(struct kobject *kobj)
 	struct kobj_type *t = get_ktype(kobj);
 	const char *name = kobj->name;
 
-	pr_debug("kobject: '%s' (%p): %s\n",
-		 kobject_name(kobj), kobj, __func__);
+	pr_debug("kobject: '%s' (%p): %s, parent %p\n",
+		 kobject_name(kobj), kobj, __func__, kobj->parent);
 
 	if (t && !t->release)
 		pr_debug("kobject: '%s' (%p): does not have a release() "
@@ -580,9 +580,25 @@ static void kobject_cleanup(struct kobject *kobj)
 	}
 }
 
+#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
+static void kobject_delayed_cleanup(struct work_struct *work)
+{
+	kobject_cleanup(container_of(to_delayed_work(work),
+				     struct kobject, release));
+}
+#endif
+
 static void kobject_release(struct kref *kref)
 {
-	kobject_cleanup(container_of(kref, struct kobject, kref));
+	struct kobject *kobj = container_of(kref, struct kobject, kref);
+#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
+	pr_debug("kobject: '%s' (%p): %s, parent %p (delayed)\n",
+		 kobject_name(kobj), kobj, __func__, kobj->parent);
+	INIT_DELAYED_WORK(&kobj->release, kobject_delayed_cleanup);
+	schedule_delayed_work(&kobj->release, HZ);
+#else
+	kobject_cleanup(kobj);
+#endif
 }
 
 /**

commit b7165ebbf0898bad9aaeddfa22b918e94ed90e07
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jun 6 13:52:19 2013 -0700

    kobject: sanitize argument for format string
    
    Unlike kobject_set_name(), the kset_create_and_add() interface does not
    provide a way to use format strings, so make sure that the interface
    cannot be abused accidentally. It looks like all current callers use
    static strings, so there's no existing flaw.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index b7e29a6056d3..4a1f33d43548 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -805,7 +805,7 @@ static struct kset *kset_create(const char *name,
 	kset = kzalloc(sizeof(*kset), GFP_KERNEL);
 	if (!kset)
 		return NULL;
-	retval = kobject_set_name(&kset->kobj, name);
+	retval = kobject_set_name(&kset->kobj, "%s", name);
 	if (retval) {
 		kfree(kset);
 		return NULL;

commit 2d864e41710f1d2ba406fb62018ab0487152e6f2
Author: Anatol Pomozov <anatol.pomozov@gmail.com>
Date:   Tue May 7 15:37:48 2013 -0700

    kref: minor cleanup
    
     - make warning smp-safe
     - result of atomic _unless_zero functions should be checked by caller
       to avoid use-after-free error
     - trivial whitespace fix.
    
    Link: https://lkml.org/lkml/2013/4/12/391
    
    Tested: compile x86, boot machine and run xfstests
    Signed-off-by: Anatol Pomozov <anatol.pomozov@gmail.com>
    [ Removed line-break, changed to use WARN_ON_ONCE()  - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index a65486613d79..b7e29a6056d3 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -529,7 +529,7 @@ struct kobject *kobject_get(struct kobject *kobj)
 	return kobj;
 }
 
-static struct kobject *kobject_get_unless_zero(struct kobject *kobj)
+static struct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)
 {
 	if (!kref_get_unless_zero(&kobj->kref))
 		kobj = NULL;

commit a49b7e82cab0f9b41f483359be83f44fbb6b4979
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 13 15:15:30 2013 -0700

    kobject: fix kset_find_obj() race with concurrent last kobject_put()
    
    Anatol Pomozov identified a race condition that hits module unloading
    and re-loading.  To quote Anatol:
    
     "This is a race codition that exists between kset_find_obj() and
      kobject_put().  kset_find_obj() might return kobject that has refcount
      equal to 0 if this kobject is freeing by kobject_put() in other
      thread.
    
      Here is timeline for the crash in case if kset_find_obj() searches for
      an object tht nobody holds and other thread is doing kobject_put() on
      the same kobject:
    
        THREAD A (calls kset_find_obj())     THREAD B (calls kobject_put())
        splin_lock()
                                             atomic_dec_return(kobj->kref), counter gets zero here
                                             ... starts kobject cleanup ....
                                             spin_lock() // WAIT thread A in kobj_kset_leave()
        iterate over kset->list
        atomic_inc(kobj->kref) (counter becomes 1)
        spin_unlock()
                                             spin_lock() // taken
                                             // it does not know that thread A increased counter so it
                                             remove obj from list
                                             spin_unlock()
                                             vfree(module) // frees module object with containing kobj
    
        // kobj points to freed memory area!!
        kobject_put(kobj) // OOPS!!!!
    
      The race above happens because module.c tries to use kset_find_obj()
      when somebody unloads module.  The module.c code was introduced in
      commit 6494a93d55fa"
    
    Anatol supplied a patch specific for module.c that worked around the
    problem by simply not using kset_find_obj() at all, but rather than make
    a local band-aid, this just fixes kset_find_obj() to be thread-safe
    using the proper model of refusing the get a new reference if the
    refcount has already dropped to zero.
    
    See examples of this proper refcount handling not only in the kref
    documentation, but in various other equivalent uses of this pattern by
    grepping for atomic_inc_not_zero().
    
    [ Side note: the module race does indicate that module loading and
      unloading is not properly serialized wrt sysfs information using the
      module mutex.  That may require further thought, but this is the
      correct fix at the kobject layer regardless. ]
    
    Reported-analyzed-and-tested-by: Anatol Pomozov <anatol.pomozov@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index e07ee1fcd6f1..a65486613d79 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -529,6 +529,13 @@ struct kobject *kobject_get(struct kobject *kobj)
 	return kobj;
 }
 
+static struct kobject *kobject_get_unless_zero(struct kobject *kobj)
+{
+	if (!kref_get_unless_zero(&kobj->kref))
+		kobj = NULL;
+	return kobj;
+}
+
 /*
  * kobject_cleanup - free kobject resources.
  * @kobj: object to cleanup
@@ -751,7 +758,7 @@ struct kobject *kset_find_obj(struct kset *kset, const char *name)
 
 	list_for_each_entry(k, &kset->list, entry) {
 		if (kobject_name(k) && !strcmp(kobject_name(k), name)) {
-			ret = kobject_get(k);
+			ret = kobject_get_unless_zero(k);
 			break;
 		}
 	}

commit 9ff1f838e9c019b16b720dca9b04565f1a6e0316
Author: Zhi Yong Wu <wuzhy@linux.vnet.ibm.com>
Date:   Mon May 7 10:48:25 2012 +0800

    kobject: fix the uncorrect comment
    
    Signed-off-by: Zhi Yong Wu <wuzhy@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 38fcc60e661b..e07ee1fcd6f1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -632,7 +632,7 @@ struct kobject *kobject_create(void)
 /**
  * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs
  *
- * @name: the name for the kset
+ * @name: the name for the kobject
  * @parent: the parent kobject of this kobject, if any.
  *
  * This function creates a kobject structure dynamically and registers it

commit eb1574270a6de8fb8d31ffc3b021e30df0afcda3
Merge: aac10aaa8cc6 69964ea4c7b6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed May 2 14:33:37 2012 -0700

    Merge 3.4-rc5 into driver-core-next
    
    This was done to resolve a merge issue with the init/main.c file.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6b9606106ba58d2bd80610f97e06fea58206b47c
Author: yan <clouds.yan@gmail.com>
Date:   Fri Apr 20 21:25:53 2012 +0800

    lib/kobject.c : Remove redundant check in create_dir
    
    create_dir is a static function used only in kobject_add_internal.
    There's no need to do check here, for kobject_add_internal will
    reject kobject with invalid name.
    
    Signed-off-by: Yan Hong <clouds.yan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 21dee7c19afd..bbffa2110d43 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -47,13 +47,11 @@ static int populate_dir(struct kobject *kobj)
 static int create_dir(struct kobject *kobj)
 {
 	int error = 0;
-	if (kobject_name(kobj)) {
-		error = sysfs_create_dir(kobj);
-		if (!error) {
-			error = populate_dir(kobj);
-			if (error)
-				sysfs_remove_dir(kobj);
-		}
+	error = sysfs_create_dir(kobj);
+	if (!error) {
+		error = populate_dir(kobj);
+		if (error)
+			sysfs_remove_dir(kobj);
 	}
 	return error;
 }

commit 282029c005e65ffdce3aa9f8220f88a8bbbc4dae
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 6 13:41:15 2012 -0700

    kobject: provide more diagnostic info for kobject_add_internal() failures
    
    1/ convert open-coded KERN_ERR+dump_stack() to WARN(), so that automated
       tools pick up this warning.
    
    2/ include the 'child' and 'parent' kobject names.  This information was
       useful for tracking down the case where scsi invoked device_del() on a
       parent object and subsequently invoked device_add() on a child.  Now the
       warning looks like:
    
         kobject_add_internal failed for target8:0:16 (error: -2 parent: end_device-8:0:24)
         Pid: 2942, comm: scsi_scan_8 Not tainted 3.3.0-rc7-isci+ #2
         Call Trace:
          [<ffffffff8125e551>] kobject_add_internal+0x1c1/0x1f3
          [<ffffffff81075149>] ? trace_hardirqs_on+0xd/0xf
          [<ffffffff8125e659>] kobject_add_varg+0x41/0x50
          [<ffffffff8125e723>] kobject_add+0x64/0x66
          [<ffffffff8131124b>] device_add+0x12d/0x63a
          [<ffffffff8125e0ef>] ? kobject_put+0x4c/0x50
          [<ffffffff8132f370>] scsi_sysfs_add_sdev+0x4e/0x28a
          [<ffffffff8132dce3>] do_scan_async+0x9c/0x145
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: James Bottomley <JBottomley@parallels.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 21dee7c19afd..aeefa8bc8b1c 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -192,14 +192,14 @@ static int kobject_add_internal(struct kobject *kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			printk(KERN_ERR "%s failed for %s with "
-			       "-EEXIST, don't try to register things with "
-			       "the same name in the same directory.\n",
-			       __func__, kobject_name(kobj));
+			WARN(1, "%s failed for %s with "
+			     "-EEXIST, don't try to register things with "
+			     "the same name in the same directory.\n",
+			     __func__, kobject_name(kobj));
 		else
-			printk(KERN_ERR "%s failed for %s (%d)\n",
-			       __func__, kobject_name(kobj), error);
-		dump_stack();
+			WARN(1, "%s failed for %s (error: %d parent: %s)\n",
+			     __func__, kobject_name(kobj), error,
+			     parent ? kobject_name(parent) : "'none'");
 	} else
 		kobj->state_in_sysfs = 1;
 

commit 8bc3bcc93a2b4e47d5d410146f6546bca6171663
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 16 21:29:17 2011 -0500

    lib: reduce the use of module.h wherever possible
    
    For files only using THIS_MODULE and/or EXPORT_SYMBOL, map
    them onto including export.h -- or if the file isn't even
    using those, then just delete the include.  Fix up any implicit
    include dependencies that were being masked by module.h along
    the way.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/lib/kobject.c b/lib/kobject.c
index c33d7a18d635..21dee7c19afd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -14,7 +14,7 @@
 
 #include <linux/kobject.h>
 #include <linux/string.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/stat.h>
 #include <linux/slab.h>
 

commit b3e8d7b2478401b2f25f4566a90faad54f7d6d07
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 15:13:54 2011 -0800

    kobject: remove kset_find_obj_hinted()
    
    Now that there are no in-kernel users of this function, remove it as it
    is no longer needed.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 640bd98a4c8a..c33d7a18d635 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -745,44 +745,12 @@ void kset_unregister(struct kset *k)
  * take a reference and return the object.
  */
 struct kobject *kset_find_obj(struct kset *kset, const char *name)
-{
-	return kset_find_obj_hinted(kset, name, NULL);
-}
-
-/**
- * kset_find_obj_hinted - search for object in kset given a predecessor hint.
- * @kset: kset we're looking in.
- * @name: object's name.
- * @hint: hint to possible object's predecessor.
- *
- * Check the hint's next object and if it is a match return it directly,
- * otherwise, fall back to the behavior of kset_find_obj().  Either way
- * a reference for the returned object is held and the reference on the
- * hinted object is released.
- */
-struct kobject *kset_find_obj_hinted(struct kset *kset, const char *name,
-				     struct kobject *hint)
 {
 	struct kobject *k;
 	struct kobject *ret = NULL;
 
 	spin_lock(&kset->list_lock);
 
-	if (!hint)
-		goto slow_search;
-
-	/* end of list detection */
-	if (hint->entry.next == kset->list.next)
-		goto slow_search;
-
-	k = container_of(hint->entry.next, struct kobject, entry);
-	if (!kobject_name(k) || strcmp(kobject_name(k), name))
-		goto slow_search;
-
-	ret = kobject_get(k);
-	goto unlock_exit;
-
-slow_search:
 	list_for_each_entry(k, &kset->list, entry) {
 		if (kobject_name(k) && !strcmp(kobject_name(k), name)) {
 			ret = kobject_get(k);
@@ -790,12 +758,7 @@ struct kobject *kset_find_obj_hinted(struct kset *kset, const char *name,
 		}
 	}
 
-unlock_exit:
 	spin_unlock(&kset->list_lock);
-
-	if (hint)
-		kobject_put(hint);
-
 	return ret;
 }
 

commit a685e08987d1edf1995b76511d4c98ea0e905377
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 8 21:13:01 2011 -0400

    Delay struct net freeing while there's a sysfs instance refering to it
    
            * new refcount in struct net, controlling actual freeing of the memory
            * new method in kobj_ns_type_operations (->drop_ns())
            * ->current_ns() semantics change - it's supposed to be followed by
    corresponding ->drop_ns().  For struct net in case of CONFIG_NET_NS it bumps
    the new refcount; net_drop_ns() decrements it and calls net_free() if the
    last reference has been dropped.  Method renamed to ->grab_current_ns().
            * old net_free() callers call net_drop_ns() instead.
            * sysfs_exit_ns() is gone, along with a large part of callchain
    leading to it; now that the references stored in ->ns[...] stay valid we
    do not need to hunt them down and replace them with NULL.  That fixes
    problems in sysfs_lookup() and sysfs_readdir(), along with getting rid
    of sb->s_instances abuse.
    
            Note that struct net *shutdown* logics has not changed - net_cleanup()
    is called exactly when it used to be called.  The only thing postponed by
    having a sysfs instance refering to that struct net is actual freeing of
    memory occupied by struct net.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/lib/kobject.c b/lib/kobject.c
index 82dc34c095c2..640bd98a4c8a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -948,14 +948,14 @@ const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)
 }
 
 
-const void *kobj_ns_current(enum kobj_ns_type type)
+void *kobj_ns_grab_current(enum kobj_ns_type type)
 {
-	const void *ns = NULL;
+	void *ns = NULL;
 
 	spin_lock(&kobj_ns_type_lock);
 	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
 	    kobj_ns_ops_tbl[type])
-		ns = kobj_ns_ops_tbl[type]->current_ns();
+		ns = kobj_ns_ops_tbl[type]->grab_current_ns();
 	spin_unlock(&kobj_ns_type_lock);
 
 	return ns;
@@ -987,23 +987,15 @@ const void *kobj_ns_initial(enum kobj_ns_type type)
 	return ns;
 }
 
-/*
- * kobj_ns_exit - invalidate a namespace tag
- *
- * @type: the namespace type (i.e. KOBJ_NS_TYPE_NET)
- * @ns: the actual namespace being invalidated
- *
- * This is called when a tag is no longer valid.  For instance,
- * when a network namespace exits, it uses this helper to
- * make sure no sb's sysfs_info points to the now-invalidated
- * netns.
- */
-void kobj_ns_exit(enum kobj_ns_type type, const void *ns)
+void kobj_ns_drop(enum kobj_ns_type type, void *ns)
 {
-	sysfs_exit_ns(type, ns);
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
+	    kobj_ns_ops_tbl[type] && kobj_ns_ops_tbl[type]->drop_ns)
+		kobj_ns_ops_tbl[type]->drop_ns(ns);
+	spin_unlock(&kobj_ns_type_lock);
 }
 
-
 EXPORT_SYMBOL(kobject_get);
 EXPORT_SYMBOL(kobject_put);
 EXPORT_SYMBOL(kobject_del);

commit c25d1dfbd403209025df41a737f82ce8f43d93f5
Author: Robin Holt <holt@sgi.com>
Date:   Wed Sep 29 14:00:54 2010 -0500

    kobject: Introduce kset_find_obj_hinted.
    
    One call chain getting to kset_find_obj is:
      link_mem_sections()
        find_mem_section()
          kset_find_obj()
    
    This is done during boot.  The memory sections were added in a linearly
    increasing order and link_mem_sections tends to utilize them in that
    same linear order.
    
    Introduce a kset_find_obj_hinted which is passed the result of the
    previous kset_find_obj which it uses for a quick "is the next object
    our desired object" check before falling back to the old behavior.
    
    Signed-off-by: Robin Holt <holt@sgi.com>
    To: Robert P. J. Day <rpjday@crashcourse.ca>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index f07c57252e82..82dc34c095c2 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -745,18 +745,57 @@ void kset_unregister(struct kset *k)
  * take a reference and return the object.
  */
 struct kobject *kset_find_obj(struct kset *kset, const char *name)
+{
+	return kset_find_obj_hinted(kset, name, NULL);
+}
+
+/**
+ * kset_find_obj_hinted - search for object in kset given a predecessor hint.
+ * @kset: kset we're looking in.
+ * @name: object's name.
+ * @hint: hint to possible object's predecessor.
+ *
+ * Check the hint's next object and if it is a match return it directly,
+ * otherwise, fall back to the behavior of kset_find_obj().  Either way
+ * a reference for the returned object is held and the reference on the
+ * hinted object is released.
+ */
+struct kobject *kset_find_obj_hinted(struct kset *kset, const char *name,
+				     struct kobject *hint)
 {
 	struct kobject *k;
 	struct kobject *ret = NULL;
 
 	spin_lock(&kset->list_lock);
+
+	if (!hint)
+		goto slow_search;
+
+	/* end of list detection */
+	if (hint->entry.next == kset->list.next)
+		goto slow_search;
+
+	k = container_of(hint->entry.next, struct kobject, entry);
+	if (!kobject_name(k) || strcmp(kobject_name(k), name))
+		goto slow_search;
+
+	ret = kobject_get(k);
+	goto unlock_exit;
+
+slow_search:
 	list_for_each_entry(k, &kset->list, entry) {
 		if (kobject_name(k) && !strcmp(kobject_name(k), name)) {
 			ret = kobject_get(k);
 			break;
 		}
 	}
+
+unlock_exit:
 	spin_unlock(&kset->list_lock);
+
+	if (hint)
+		kobject_put(hint);
+
 	return ret;
 }
 

commit be867b194a3ae3c680c29521287ae49b4d44d420
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon May 3 16:23:15 2010 -0500

    sysfs: Comment sysfs directory tagging logic
    
    Add some in-line comments to explain the new infrastructure, which
    was introduced to support sysfs directory tagging with namespaces.
    I think an overall description someplace might be good too, but it
    didn't really seem to fit into Documentation/filesystems/sysfs.txt,
    which appears more geared toward users, rather than maintainers, of
    sysfs.
    
    (Tejun, please let me know if I can make anything clearer or failed
    altogether to comment something that should be commented.)
    
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index b2c6d1f56e65..f07c57252e82 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -948,6 +948,17 @@ const void *kobj_ns_initial(enum kobj_ns_type type)
 	return ns;
 }
 
+/*
+ * kobj_ns_exit - invalidate a namespace tag
+ *
+ * @type: the namespace type (i.e. KOBJ_NS_TYPE_NET)
+ * @ns: the actual namespace being invalidated
+ *
+ * This is called when a tag is no longer valid.  For instance,
+ * when a network namespace exits, it uses this helper to
+ * make sure no sb's sysfs_info points to the now-invalidated
+ * netns.
+ */
 void kobj_ns_exit(enum kobj_ns_type type, const void *ns)
 {
 	sysfs_exit_ns(type, ns);

commit 3ff195b011d7decf501a4d55aeed312731094796
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 11:31:26 2010 -0700

    sysfs: Implement sysfs tagged directory support.
    
    The problem.  When implementing a network namespace I need to be able
    to have multiple network devices with the same name.  Currently this
    is a problem for /sys/class/net/*, /sys/devices/virtual/net/*, and
    potentially a few other directories of the form /sys/ ... /net/*.
    
    What this patch does is to add an additional tag field to the
    sysfs dirent structure.  For directories that should show different
    contents depending on the context such as /sys/class/net/, and
    /sys/devices/virtual/net/ this tag field is used to specify the
    context in which those directories should be visible.  Effectively
    this is the same as creating multiple distinct directories with
    the same name but internally to sysfs the result is nicer.
    
    I am calling the concept of a single directory that looks like multiple
    directories all at the same path in the filesystem tagged directories.
    
    For the networking namespace the set of directories whose contents I need
    to filter with tags can depend on the presence or absence of hotplug
    hardware or which modules are currently loaded.  Which means I need
    a simple race free way to setup those directories as tagged.
    
    To achieve a reace free design all tagged directories are created
    and managed by sysfs itself.
    
    Users of this interface:
    - define a type in the sysfs_tag_type enumeration.
    - call sysfs_register_ns_types with the type and it's operations
    - sysfs_exit_ns when an individual tag is no longer valid
    
    - Implement mount_ns() which returns the ns of the calling process
      so we can attach it to a sysfs superblock.
    - Implement ktype.namespace() which returns the ns of a syfs kobject.
    
    Everything else is left up to sysfs and the driver layer.
    
    For the network namespace mount_ns and namespace() are essentially
    one line functions, and look to remain that.
    
    Tags are currently represented a const void * pointers as that is
    both generic, prevides enough information for equality comparisons,
    and is trivial to create for current users, as it is just the
    existing namespace pointer.
    
    The work needed in sysfs is more extensive.  At each directory
    or symlink creating I need to check if the directory it is being
    created in is a tagged directory and if so generate the appropriate
    tag to place on the sysfs_dirent.  Likewise at each symlink or
    directory removal I need to check if the sysfs directory it is
    being removed from is a tagged directory and if so figure out
    which tag goes along with the name I am deleting.
    
    Currently only directories which hold kobjects, and
    symlinks are supported.  There is not enough information
    in the current file attribute interfaces to give us anything
    to discriminate on which makes it useless, and there are
    no potential users which makes it an uninteresting problem
    to solve.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index bbb2bb40ee1f..b2c6d1f56e65 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -950,6 +950,7 @@ const void *kobj_ns_initial(enum kobj_ns_type type)
 
 void kobj_ns_exit(enum kobj_ns_type type, const void *ns)
 {
+	sysfs_exit_ns(type, ns);
 }
 
 

commit bc451f2058238013e1cdf4acd443c01734d332f0
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 11:31:25 2010 -0700

    kobj: Add basic infrastructure for dealing with namespaces.
    
    Move complete knowledge of namespaces into the kobject layer
    so we can use that information when reporting kobjects to
    userspace.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 8115eb1bbf4d..bbb2bb40ee1f 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -850,6 +850,109 @@ struct kset *kset_create_and_add(const char *name,
 }
 EXPORT_SYMBOL_GPL(kset_create_and_add);
 
+
+static DEFINE_SPINLOCK(kobj_ns_type_lock);
+static const struct kobj_ns_type_operations *kobj_ns_ops_tbl[KOBJ_NS_TYPES];
+
+int kobj_ns_type_register(const struct kobj_ns_type_operations *ops)
+{
+	enum kobj_ns_type type = ops->type;
+	int error;
+
+	spin_lock(&kobj_ns_type_lock);
+
+	error = -EINVAL;
+	if (type >= KOBJ_NS_TYPES)
+		goto out;
+
+	error = -EINVAL;
+	if (type <= KOBJ_NS_TYPE_NONE)
+		goto out;
+
+	error = -EBUSY;
+	if (kobj_ns_ops_tbl[type])
+		goto out;
+
+	error = 0;
+	kobj_ns_ops_tbl[type] = ops;
+
+out:
+	spin_unlock(&kobj_ns_type_lock);
+	return error;
+}
+
+int kobj_ns_type_registered(enum kobj_ns_type type)
+{
+	int registered = 0;
+
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES))
+		registered = kobj_ns_ops_tbl[type] != NULL;
+	spin_unlock(&kobj_ns_type_lock);
+
+	return registered;
+}
+
+const struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent)
+{
+	const struct kobj_ns_type_operations *ops = NULL;
+
+	if (parent && parent->ktype->child_ns_type)
+		ops = parent->ktype->child_ns_type(parent);
+
+	return ops;
+}
+
+const struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)
+{
+	return kobj_child_ns_ops(kobj->parent);
+}
+
+
+const void *kobj_ns_current(enum kobj_ns_type type)
+{
+	const void *ns = NULL;
+
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
+	    kobj_ns_ops_tbl[type])
+		ns = kobj_ns_ops_tbl[type]->current_ns();
+	spin_unlock(&kobj_ns_type_lock);
+
+	return ns;
+}
+
+const void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk)
+{
+	const void *ns = NULL;
+
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
+	    kobj_ns_ops_tbl[type])
+		ns = kobj_ns_ops_tbl[type]->netlink_ns(sk);
+	spin_unlock(&kobj_ns_type_lock);
+
+	return ns;
+}
+
+const void *kobj_ns_initial(enum kobj_ns_type type)
+{
+	const void *ns = NULL;
+
+	spin_lock(&kobj_ns_type_lock);
+	if ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&
+	    kobj_ns_ops_tbl[type])
+		ns = kobj_ns_ops_tbl[type]->initial_ns();
+	spin_unlock(&kobj_ns_type_lock);
+
+	return ns;
+}
+
+void kobj_ns_exit(enum kobj_ns_type type, const void *ns)
+{
+}
+
+
 EXPORT_SYMBOL(kobject_get);
 EXPORT_SYMBOL(kobject_put);
 EXPORT_SYMBOL(kobject_del);

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index cecf5a0ef6e1..8115eb1bbf4d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -700,7 +700,7 @@ static ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,
 	return ret;
 }
 
-struct sysfs_ops kobj_sysfs_ops = {
+const struct sysfs_ops kobj_sysfs_ops = {
 	.show	= kobj_attr_show,
 	.store	= kobj_attr_store,
 };

commit 9cd43611ccfb46632bfa7d19f688924ea93f1613
Author: Emese Revfy <re.emese@gmail.com>
Date:   Thu Dec 31 14:52:51 2009 +0100

    kobject: Constify struct kset_uevent_ops
    
    Constify struct kset_uevent_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index b512b746d2af..cecf5a0ef6e1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -789,7 +789,7 @@ static struct kobj_type kset_ktype = {
  * If the kset was not able to be created, NULL will be returned.
  */
 static struct kset *kset_create(const char *name,
-				struct kset_uevent_ops *uevent_ops,
+				const struct kset_uevent_ops *uevent_ops,
 				struct kobject *parent_kobj)
 {
 	struct kset *kset;
@@ -832,7 +832,7 @@ static struct kset *kset_create(const char *name,
  * If the kset was not able to be created, NULL will be returned.
  */
 struct kset *kset_create_and_add(const char *name,
-				 struct kset_uevent_ops *uevent_ops,
+				 const struct kset_uevent_ops *uevent_ops,
 				 struct kobject *parent_kobj)
 {
 	struct kset *kset;

commit d9cd8f37855b012757818f31390e8f84db251c89
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Mon May 11 14:17:45 2009 +0800

    kobject: make kset_create check kobject_set_name return value
    
    kset_create should check the kobject_set_name return value.
    
    Add the return value checking code.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index bacf6fe4f7a0..b512b746d2af 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -793,11 +793,16 @@ static struct kset *kset_create(const char *name,
 				struct kobject *parent_kobj)
 {
 	struct kset *kset;
+	int retval;
 
 	kset = kzalloc(sizeof(*kset), GFP_KERNEL);
 	if (!kset)
 		return NULL;
-	kobject_set_name(&kset->kobj, name);
+	retval = kobject_set_name(&kset->kobj, name);
+	if (retval) {
+		kfree(kset);
+		return NULL;
+	}
 	kset->uevent_ops = uevent_ops;
 	kset->kobj.parent = parent_kobj;
 

commit 8a577ffc75d9194fe8cdb7479236f2081c26ca1f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Apr 18 15:05:45 2009 -0700

    driver: dont update dev_name via device_add path
    
    notice one system /proc/iomem some entries missed the name for pci_devices
    
    it turns that dev->dev.kobj name is changed after device_add.
    
    for pci code: via acpi_pci_root_driver.ops.add (aka acpi_pci_root_add)
    ==> pci_acpi_scan_root is used to scan pci bus/device, and at the same
    time we read the resource for pci_dev in the pci_read_bases, we have
    res->name = pci_name(pci_dev); pci_name is calling dev_name.
    
    later via acpi_pci_root_driver.ops.start (aka acpi_pci_root_start) ==>
    pci_bus_add_device to add all pci_dev in kobj tree.  pci_bus_add_device
    will call device_add.
    
    actually in device_add
    
            /* first, register with generic layer. */
            error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
            if (error)
                    goto Error;
    
    will get one new name for that kobj, old name is freed.
    
    [Impact: fix corrupted names in /proc/iomem ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index a6dec32f2ddd..bacf6fe4f7a0 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -218,6 +218,9 @@ int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 	const char *old_name = kobj->name;
 	char *s;
 
+	if (kobj->name && !fmt)
+		return 0;
+
 	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
 	if (!kobj->name)
 		return -ENOMEM;

commit 1fa5ae857bb14f6046205171d98506d8112dd74e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jan 25 15:17:37 2009 +0100

    driver core: get rid of struct device's bus_id string array
    
    Now that all users of bus_id is gone, we can remove it from struct
    device.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 0487d1f64806..a6dec32f2ddd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -212,7 +212,7 @@ static int kobject_add_internal(struct kobject *kobj)
  * @fmt: format string used to build the name
  * @vargs: vargs to format the string.
  */
-static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
+int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 				  va_list vargs)
 {
 	const char *old_name = kobj->name;

commit 0b4a4fea253e1296222603ccc55430ed7cd9413a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 3 18:05:28 2008 -0700

    kobject: Cleanup kobject_rename and !CONFIG_SYSFS
    
    It finally dawned on me what the clean fix to sysfs_rename_dir
    calling kobject_set_name is.  Move the work into kobject_rename
    where it belongs.  The callers serialize us anyway so this is
    safe.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index ae6bb900bfb6..0487d1f64806 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -397,6 +397,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 {
 	int error = 0;
 	const char *devpath = NULL;
+	const char *dup_name = NULL, *name;
 	char *devpath_string = NULL;
 	char *envp[2];
 
@@ -420,15 +421,27 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 	envp[0] = devpath_string;
 	envp[1] = NULL;
 
+	name = dup_name = kstrdup(new_name, GFP_KERNEL);
+	if (!name) {
+		error = -ENOMEM;
+		goto out;
+	}
+
 	error = sysfs_rename_dir(kobj, new_name);
+	if (error)
+		goto out;
+
+	/* Install the new kobject name */
+	dup_name = kobj->name;
+	kobj->name = name;
 
 	/* This function is mostly/only used for network interface.
 	 * Some hotplug package track interfaces by their name and
 	 * therefore want to know when the name is changed by the user. */
-	if (!error)
-		kobject_uevent_env(kobj, KOBJ_MOVE, envp);
+	kobject_uevent_env(kobj, KOBJ_MOVE, envp);
 
 out:
+	kfree(dup_name);
 	kfree(devpath_string);
 	kfree(devpath);
 	kobject_put(kobj);

commit 030c1d2bfcc2187650fb975456ca0b61a5bb77f4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 8 14:41:00 2008 -0700

    kobject: Fix kobject_rename and !CONFIG_SYSFS
    
    When looking at kobject_rename I found two bugs with
    that exist when sysfs support is disabled in the kernel.
    
    kobject_rename does not change the name on the kobject when
    sysfs support is not compiled in.
    
    kobject_rename without locking attempts to check the
    validity of a rename operation, which the kobject layer
    simply does not have the infrastructure to do.
    
    This patch documents the previously unstated requirement of
    kobject_rename that is the responsibility of the caller to
    provide mutual exclusion and to be certain that the new_name
    for the kobject is valid.
    
    This patch modifies sysfs_rename_dir in !CONFIG_SYSFS case
    to call kobject_set_name to actually change the kobject_name.
    
    This patch removes the bogus and misleading check in kobject_rename
    that attempts to see if a rename is valid.  The check is bogus
    because we do not have the proper locking.  The check is misleading
    because it looks like we can and do perform checking at the kobject
    level that we don't.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index fbf0ae282376..ae6bb900bfb6 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -387,6 +387,11 @@ EXPORT_SYMBOL_GPL(kobject_init_and_add);
  * kobject_rename - change the name of an object
  * @kobj: object in question.
  * @new_name: object's new name
+ *
+ * It is the responsibility of the caller to provide mutual
+ * exclusion between two different calls of kobject_rename
+ * on the same kobject and to ensure that new_name is valid and
+ * won't conflict with other kobjects.
  */
 int kobject_rename(struct kobject *kobj, const char *new_name)
 {
@@ -401,19 +406,6 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 	if (!kobj->parent)
 		return -EINVAL;
 
-	/* see if this name is already in use */
-	if (kobj->kset) {
-		struct kobject *temp_kobj;
-		temp_kobj = kset_find_obj(kobj->kset, new_name);
-		if (temp_kobj) {
-			printk(KERN_WARNING "kobject '%s' cannot be renamed "
-			       "to '%s' as '%s' is already in existence.\n",
-			       kobject_name(kobj), new_name, new_name);
-			kobject_put(temp_kobj);
-			return -EINVAL;
-		}
-	}
-
 	devpath = kobject_get_path(kobj, GFP_KERNEL);
 	if (!devpath) {
 		error = -ENOMEM;

commit 25fdeb3f4468595ab2885687b13515fa848731c2
Author: Ingo Oeser <ioe-lkml@rameria.de>
Date:   Wed Jul 23 01:25:01 2008 +0200

    kobject: Replace ALL occurrences of '/' with '!' instead of only the first one.
    
    A recent patch from Kay Sievers <kay.sievers@vrfy.org>
    replaced the first occurrence of '/' with '!' as needed for block devices.
    
    Now do some cheap defensive coding and replace all of them to avoid future
    issues in this area.
    
    Signed-off-by: Ingo Oeser <ioe-lkml@rameria.de>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index bd732ffebc85..fbf0ae282376 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -223,8 +223,7 @@ static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 		return -ENOMEM;
 
 	/* ewww... some of these buggers have '/' in the name ... */
-	s = strchr(kobj->name, '/');
-	if (s)
+	while ((s = strchr(kobj->name, '/')))
 		s[0] = '!';
 
 	kfree(old_name);

commit d955c78ac4699ac9c3fe07be62982cda13d13267
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Jul 25 01:45:55 2008 -0700

    Example use of WARN()
    
    Now that WARN() exists, we can fold some of the printk's into it.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 744401571ed7..bd732ffebc85 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -164,9 +164,8 @@ static int kobject_add_internal(struct kobject *kobj)
 		return -ENOENT;
 
 	if (!kobj->name || !kobj->name[0]) {
-		pr_debug("kobject: (%p): attempted to be registered with empty "
+		WARN(1, "kobject: (%p): attempted to be registered with empty "
 			 "name!\n", kobj);
-		WARN_ON(1);
 		return -EINVAL;
 	}
 
@@ -583,12 +582,10 @@ static void kobject_release(struct kref *kref)
 void kobject_put(struct kobject *kobj)
 {
 	if (kobj) {
-		if (!kobj->state_initialized) {
-			printk(KERN_WARNING "kobject: '%s' (%p): is not "
+		if (!kobj->state_initialized)
+			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
 			       "initialized, yet kobject_put() is being "
 			       "called.\n", kobject_name(kobj), kobj);
-			WARN_ON(1);
-		}
 		kref_put(&kobj->kref, kobject_release);
 	}
 }

commit 9f255651fb41c111ee35a2ae632df8ce9bd61def
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue May 6 22:24:04 2008 +0200

    kobject: replace '/' with '!' in name
    
    Some (block) devices have a '/' in the name, and need special
    handling. Let's have that rule to the core, so we can remove it
    from the block class.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index dcade0543bd2..744401571ed7 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -216,13 +216,19 @@ static int kobject_add_internal(struct kobject *kobj)
 static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 				  va_list vargs)
 {
-	/* Free the old name, if necessary. */
-	kfree(kobj->name);
+	const char *old_name = kobj->name;
+	char *s;
 
 	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
 	if (!kobj->name)
 		return -ENOMEM;
 
+	/* ewww... some of these buggers have '/' in the name ... */
+	s = strchr(kobj->name, '/');
+	if (s)
+		s[0] = '!';
+
+	kfree(old_name);
 	return 0;
 }
 

commit 8344b568f5bdc7ee1bba909de3294c6348c36056
Author: Alex Chiang <achiang@hp.com>
Date:   Tue Jun 10 15:30:42 2008 -0600

    PCI: ACPI PCI slot detection driver
    
    Detect all physical PCI slots as described by ACPI, and create entries in
    /sys/bus/pci/slots/.
    
    Not all physical slots are hotpluggable, and the acpiphp module does not
    detect them.  Now we know the physical PCI geography of our system, without
    caring about hotplug.
    
    [kaneshige.kenji@jp.fujitsu.com: export-kobject_rename-for-pci_hotplug_core]
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Greg KH <greg@kroah.com>
    [akpm@linux-foundation.org: build fix]
    [akpm@linux-foundation.org: fix build with CONFIG_DMI=n]
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 718e5101c263..dcade0543bd2 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -439,6 +439,7 @@ int kobject_rename(struct kobject *kobj, const char *new_name)
 
 	return error;
 }
+EXPORT_SYMBOL_GPL(kobject_rename);
 
 /**
  * kobject_move - move object to another parent

commit a4ca6617421188f50774780cdc91c3782b7d08fe
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Apr 30 02:06:29 2008 +0200

    kobject: do not copy vargs, just pass them around
    
    This prevents a few unneeded copies.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index fd7874032163..718e5101c263 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -216,21 +216,12 @@ static int kobject_add_internal(struct kobject *kobj)
 static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 				  va_list vargs)
 {
-	va_list aq;
-	char *name;
-
-	va_copy(aq, vargs);
-	name = kvasprintf(GFP_KERNEL, fmt, vargs);
-	va_end(aq);
-
-	if (!name)
-		return -ENOMEM;
-
 	/* Free the old name, if necessary. */
 	kfree(kobj->name);
 
-	/* Now, set the new name */
-	kobj->name = name;
+	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
+	if (!kobj->name)
+		return -ENOMEM;
 
 	return 0;
 }
@@ -246,12 +237,12 @@ static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
  */
 int kobject_set_name(struct kobject *kobj, const char *fmt, ...)
 {
-	va_list args;
+	va_list vargs;
 	int retval;
 
-	va_start(args, fmt);
-	retval = kobject_set_name_vargs(kobj, fmt, args);
-	va_end(args);
+	va_start(vargs, fmt);
+	retval = kobject_set_name_vargs(kobj, fmt, vargs);
+	va_end(vargs);
 
 	return retval;
 }
@@ -301,12 +292,9 @@ EXPORT_SYMBOL(kobject_init);
 static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
 			    const char *fmt, va_list vargs)
 {
-	va_list aq;
 	int retval;
 
-	va_copy(aq, vargs);
-	retval = kobject_set_name_vargs(kobj, fmt, aq);
-	va_end(aq);
+	retval = kobject_set_name_vargs(kobj, fmt, vargs);
 	if (retval) {
 		printk(KERN_ERR "kobject: can not set name properly!\n");
 		return retval;

commit 810304db75b0ca4e6ef071f86aa3e85fdaddee5e
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Apr 30 00:55:08 2008 -0700

    lib: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2c6490370922..fd7874032163 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -90,7 +90,7 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 	}
 
 	pr_debug("kobject: '%s' (%p): %s: path = '%s'\n", kobject_name(kobj),
-		 kobj, __FUNCTION__, path);
+		 kobj, __func__, path);
 }
 
 /**
@@ -181,7 +181,7 @@ static int kobject_add_internal(struct kobject *kobj)
 	}
 
 	pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
-		 kobject_name(kobj), kobj, __FUNCTION__,
+		 kobject_name(kobj), kobj, __func__,
 		 parent ? kobject_name(parent) : "<NULL>",
 		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>");
 
@@ -196,10 +196,10 @@ static int kobject_add_internal(struct kobject *kobj)
 			printk(KERN_ERR "%s failed for %s with "
 			       "-EEXIST, don't try to register things with "
 			       "the same name in the same directory.\n",
-			       __FUNCTION__, kobject_name(kobj));
+			       __func__, kobject_name(kobj));
 		else
 			printk(KERN_ERR "%s failed for %s (%d)\n",
-			       __FUNCTION__, kobject_name(kobj), error);
+			       __func__, kobject_name(kobj), error);
 		dump_stack();
 	} else
 		kobj->state_in_sysfs = 1;
@@ -540,7 +540,7 @@ static void kobject_cleanup(struct kobject *kobj)
 	const char *name = kobj->name;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
-		 kobject_name(kobj), kobj, __FUNCTION__);
+		 kobject_name(kobj), kobj, __func__);
 
 	if (t && !t->release)
 		pr_debug("kobject: '%s' (%p): does not have a release() "
@@ -600,7 +600,7 @@ void kobject_put(struct kobject *kobj)
 
 static void dynamic_kobj_release(struct kobject *kobj)
 {
-	pr_debug("kobject: (%p): %s\n", kobj, __FUNCTION__);
+	pr_debug("kobject: (%p): %s\n", kobj, __func__);
 	kfree(kobj);
 }
 
@@ -657,7 +657,7 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 	retval = kobject_add(kobj, parent, "%s", name);
 	if (retval) {
 		printk(KERN_WARNING "%s: kobject_add error: %d\n",
-		       __FUNCTION__, retval);
+		       __func__, retval);
 		kobject_put(kobj);
 		kobj = NULL;
 	}
@@ -765,7 +765,7 @@ static void kset_release(struct kobject *kobj)
 {
 	struct kset *kset = container_of(kobj, struct kset, kobj);
 	pr_debug("kobject: '%s' (%p): %s\n",
-		 kobject_name(kobj), kobj, __FUNCTION__);
+		 kobject_name(kobj), kobj, __func__);
 	kfree(kset);
 }
 

commit c6a2a3dc26da72e431c293d02549593f9c041f63
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu Mar 27 01:13:34 2008 -0400

    Kobject: Replace list_for_each() with list_for_each_entry().
    
    Use the more concise list_for_each_entry(), which allows for the
    deletion of the to_kobj() routine at the same time.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 60ae9e817663..2c6490370922 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -58,11 +58,6 @@ static int create_dir(struct kobject *kobj)
 	return error;
 }
 
-static inline struct kobject *to_kobj(struct list_head *entry)
-{
-	return container_of(entry, struct kobject, entry);
-}
-
 static int get_kobj_path_length(struct kobject *kobj)
 {
 	int length = 1;
@@ -752,12 +747,11 @@ void kset_unregister(struct kset *k)
  */
 struct kobject *kset_find_obj(struct kset *kset, const char *name)
 {
-	struct list_head *entry;
+	struct kobject *k;
 	struct kobject *ret = NULL;
 
 	spin_lock(&kset->list_lock);
-	list_for_each(entry, &kset->list) {
-		struct kobject *k = to_kobj(entry);
+	list_for_each_entry(k, &kset->list, entry) {
 		if (kobject_name(k) && !strcmp(kobject_name(k), name)) {
 			ret = kobject_get(k);
 			break;

commit c1ebdae514a356c71c09035f5141d94aab5e8fe4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Feb 26 09:36:38 2008 -0800

    kobject: catch kobjects that are not initialized
    
    Add warnings to kobject_put() to catch kobjects that are cleaned up but
    were never initialized to begin with.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 0d03252f87a8..60ae9e817663 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -592,8 +592,15 @@ static void kobject_release(struct kref *kref)
  */
 void kobject_put(struct kobject *kobj)
 {
-	if (kobj)
+	if (kobj) {
+		if (!kobj->state_initialized) {
+			printk(KERN_WARNING "kobject: '%s' (%p): is not "
+			       "initialized, yet kobject_put() is being "
+			       "called.\n", kobject_name(kobj), kobj);
+			WARN_ON(1);
+		}
 		kref_put(&kobj->kref, kobject_release);
+	}
 }
 
 static void dynamic_kobj_release(struct kobject *kobj)

commit a4573c488dd531c6e2d308ce8a7413c4a2646207
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Feb 26 09:36:38 2008 -0800

    kobject: properly initialize ksets
    
    kset_initialize was calling kobject_init_internal() which didn't
    initialize the kobject as well as kobject_init() was.  So have
    kobject_init() call kobject_init_internal() and move the logic to
    initalize the kobject there.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index d784daeb8571..0d03252f87a8 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -153,6 +153,10 @@ static void kobject_init_internal(struct kobject *kobj)
 		return;
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
+	kobj->state_in_sysfs = 0;
+	kobj->state_add_uevent_sent = 0;
+	kobj->state_remove_uevent_sent = 0;
+	kobj->state_initialized = 1;
 }
 
 
@@ -289,13 +293,8 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 		dump_stack();
 	}
 
-	kref_init(&kobj->kref);
-	INIT_LIST_HEAD(&kobj->entry);
+	kobject_init_internal(kobj);
 	kobj->ktype = ktype;
-	kobj->state_in_sysfs = 0;
-	kobj->state_add_uevent_sent = 0;
-	kobj->state_remove_uevent_sent = 0;
-	kobj->state_initialized = 1;
 	return;
 
 error:

commit f70701a34e217fd5f4f180f7bf4bb5c137d76e8a
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Mon Jan 28 16:58:00 2008 +0800

    kobject: kerneldoc comment fix
    
    Fix kerneldoc comment of kobject_create.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1d63ead1815e..d784daeb8571 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -637,7 +637,7 @@ struct kobject *kobject_create(void)
  * @name: the name for the kset
  * @parent: the parent kobject of this kobject, if any.
  *
- * This function creates a kset structure dynamically and registers it
+ * This function creates a kobject structure dynamically and registers it
  * with sysfs.  When you are finished with this structure, call
  * kobject_put() and the structure will be dynamically freed when
  * it is no longer being used.

commit e374a2bfebf359f846216336de91670be40499da
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 24 21:59:04 2008 -0800

    Kobject: fix coding style issues in kobject c files
    
    Clean up the kobject.c and kobject_uevent.c files to follow the
    proper coding style rules.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 8dc32454661d..1d63ead1815e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -18,58 +18,57 @@
 #include <linux/stat.h>
 #include <linux/slab.h>
 
-/**
- *	populate_dir - populate directory with attributes.
- *	@kobj:	object we're working on.
- *
- *	Most subsystems have a set of default attributes that 
- *	are associated with an object that registers with them.
- *	This is a helper called during object registration that 
- *	loops through the default attributes of the subsystem 
- *	and creates attributes files for them in sysfs.
+/*
+ * populate_dir - populate directory with attributes.
+ * @kobj: object we're working on.
  *
+ * Most subsystems have a set of default attributes that are associated
+ * with an object that registers with them.  This is a helper called during
+ * object registration that loops through the default attributes of the
+ * subsystem and creates attributes files for them in sysfs.
  */
-
-static int populate_dir(struct kobject * kobj)
+static int populate_dir(struct kobject *kobj)
 {
-	struct kobj_type * t = get_ktype(kobj);
-	struct attribute * attr;
+	struct kobj_type *t = get_ktype(kobj);
+	struct attribute *attr;
 	int error = 0;
 	int i;
-	
+
 	if (t && t->default_attrs) {
 		for (i = 0; (attr = t->default_attrs[i]) != NULL; i++) {
-			if ((error = sysfs_create_file(kobj,attr)))
+			error = sysfs_create_file(kobj, attr);
+			if (error)
 				break;
 		}
 	}
 	return error;
 }
 
-static int create_dir(struct kobject * kobj)
+static int create_dir(struct kobject *kobj)
 {
 	int error = 0;
 	if (kobject_name(kobj)) {
 		error = sysfs_create_dir(kobj);
 		if (!error) {
-			if ((error = populate_dir(kobj)))
+			error = populate_dir(kobj);
+			if (error)
 				sysfs_remove_dir(kobj);
 		}
 	}
 	return error;
 }
 
-static inline struct kobject * to_kobj(struct list_head * entry)
+static inline struct kobject *to_kobj(struct list_head *entry)
 {
-	return container_of(entry,struct kobject,entry);
+	return container_of(entry, struct kobject, entry);
 }
 
 static int get_kobj_path_length(struct kobject *kobj)
 {
 	int length = 1;
-	struct kobject * parent = kobj;
+	struct kobject *parent = kobj;
 
-	/* walk up the ancestors until we hit the one pointing to the 
+	/* walk up the ancestors until we hit the one pointing to the
 	 * root.
 	 * Add 1 to strlen for leading '/' of each level.
 	 */
@@ -84,19 +83,19 @@ static int get_kobj_path_length(struct kobject *kobj)
 
 static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 {
-	struct kobject * parent;
+	struct kobject *parent;
 
 	--length;
 	for (parent = kobj; parent; parent = parent->parent) {
 		int cur = strlen(kobject_name(parent));
 		/* back up enough to print this name with '/' */
 		length -= cur;
-		strncpy (path + length, kobject_name(parent), cur);
+		strncpy(path + length, kobject_name(parent), cur);
 		*(path + --length) = '/';
 	}
 
 	pr_debug("kobject: '%s' (%p): %s: path = '%s'\n", kobject_name(kobj),
-		 kobj, __FUNCTION__,path);
+		 kobj, __FUNCTION__, path);
 }
 
 /**
@@ -148,7 +147,7 @@ static void kobj_kset_leave(struct kobject *kobj)
 	kset_put(kobj->kset);
 }
 
-static void kobject_init_internal(struct kobject * kobj)
+static void kobject_init_internal(struct kobject *kobj)
 {
 	if (!kobj)
 		return;
@@ -160,7 +159,7 @@ static void kobject_init_internal(struct kobject * kobj)
 static int kobject_add_internal(struct kobject *kobj)
 {
 	int error = 0;
-	struct kobject * parent;
+	struct kobject *parent;
 
 	if (!kobj)
 		return -ENOENT;
@@ -185,7 +184,7 @@ static int kobject_add_internal(struct kobject *kobj)
 	pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
 		 kobject_name(kobj), kobj, __FUNCTION__,
 		 parent ? kobject_name(parent) : "<NULL>",
-		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
+		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>");
 
 	error = create_dir(kobj);
 	if (error) {
@@ -399,12 +398,11 @@ int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
 EXPORT_SYMBOL_GPL(kobject_init_and_add);
 
 /**
- *	kobject_rename - change the name of an object
- *	@kobj:	object in question.
- *	@new_name: object's new name
+ * kobject_rename - change the name of an object
+ * @kobj: object in question.
+ * @new_name: object's new name
  */
-
-int kobject_rename(struct kobject * kobj, const char *new_name)
+int kobject_rename(struct kobject *kobj, const char *new_name)
 {
 	int error = 0;
 	const char *devpath = NULL;
@@ -461,11 +459,10 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 }
 
 /**
- *	kobject_move - move object to another parent
- *	@kobj:	object in question.
- *	@new_parent: object's new parent (can be NULL)
+ * kobject_move - move object to another parent
+ * @kobj: object in question.
+ * @new_parent: object's new parent (can be NULL)
  */
-
 int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 {
 	int error;
@@ -513,11 +510,10 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 }
 
 /**
- *	kobject_del - unlink kobject from hierarchy.
- * 	@kobj:	object.
+ * kobject_del - unlink kobject from hierarchy.
+ * @kobj: object.
  */
-
-void kobject_del(struct kobject * kobj)
+void kobject_del(struct kobject *kobj)
 {
 	if (!kobj)
 		return;
@@ -530,11 +526,10 @@ void kobject_del(struct kobject * kobj)
 }
 
 /**
- *	kobject_get - increment refcount for object.
- *	@kobj:	object.
+ * kobject_get - increment refcount for object.
+ * @kobj: object.
  */
-
-struct kobject * kobject_get(struct kobject * kobj)
+struct kobject *kobject_get(struct kobject *kobj)
 {
 	if (kobj)
 		kref_get(&kobj->kref);
@@ -591,12 +586,12 @@ static void kobject_release(struct kref *kref)
 }
 
 /**
- *	kobject_put - decrement refcount for object.
- *	@kobj:	object.
+ * kobject_put - decrement refcount for object.
+ * @kobj: object.
  *
- *	Decrement the refcount, and if 0, call kobject_cleanup().
+ * Decrement the refcount, and if 0, call kobject_cleanup().
  */
-void kobject_put(struct kobject * kobj)
+void kobject_put(struct kobject *kobj)
 {
 	if (kobj)
 		kref_put(&kobj->kref, kobject_release);
@@ -670,11 +665,10 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 EXPORT_SYMBOL_GPL(kobject_create_and_add);
 
 /**
- *	kset_init - initialize a kset for use
- *	@k:	kset 
+ * kset_init - initialize a kset for use
+ * @k: kset
  */
-
-void kset_init(struct kset * k)
+void kset_init(struct kset *k)
 {
 	kobject_init_internal(&k->kobj);
 	INIT_LIST_HEAD(&k->list);
@@ -712,11 +706,10 @@ struct sysfs_ops kobj_sysfs_ops = {
 };
 
 /**
- *	kset_register - initialize and add a kset.
- *	@k:	kset.
+ * kset_register - initialize and add a kset.
+ * @k: kset.
  */
-
-int kset_register(struct kset * k)
+int kset_register(struct kset *k)
 {
 	int err;
 
@@ -731,39 +724,35 @@ int kset_register(struct kset * k)
 	return 0;
 }
 
-
 /**
- *	kset_unregister - remove a kset.
- *	@k:	kset.
+ * kset_unregister - remove a kset.
+ * @k: kset.
  */
-
-void kset_unregister(struct kset * k)
+void kset_unregister(struct kset *k)
 {
 	if (!k)
 		return;
 	kobject_put(&k->kobj);
 }
 
-
 /**
- *	kset_find_obj - search for object in kset.
- *	@kset:	kset we're looking in.
- *	@name:	object's name.
+ * kset_find_obj - search for object in kset.
+ * @kset: kset we're looking in.
+ * @name: object's name.
  *
- *	Lock kset via @kset->subsys, and iterate over @kset->list,
- *	looking for a matching kobject. If matching object is found
- *	take a reference and return the object.
+ * Lock kset via @kset->subsys, and iterate over @kset->list,
+ * looking for a matching kobject. If matching object is found
+ * take a reference and return the object.
  */
-
-struct kobject * kset_find_obj(struct kset * kset, const char * name)
+struct kobject *kset_find_obj(struct kset *kset, const char *name)
 {
-	struct list_head * entry;
-	struct kobject * ret = NULL;
+	struct list_head *entry;
+	struct kobject *ret = NULL;
 
 	spin_lock(&kset->list_lock);
-	list_for_each(entry,&kset->list) {
-		struct kobject * k = to_kobj(entry);
-		if (kobject_name(k) && !strcmp(kobject_name(k),name)) {
+	list_for_each(entry, &kset->list) {
+		struct kobject *k = to_kobj(entry);
+		if (kobject_name(k) && !strcmp(kobject_name(k), name)) {
 			ret = kobject_get(k);
 			break;
 		}

commit af5ca3f4ec5cc4432a42a73b050dd8898ce8fd00
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Dec 20 02:09:39 2007 +0100

    Driver core: change sysdev classes to use dynamic kobject names
    
    All kobjects require a dynamically allocated name now. We no longer
    need to keep track if the name is statically assigned, we can just
    unconditionally free() all kobject names on cleanup.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index a0773734545c..8dc32454661d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -165,7 +165,7 @@ static int kobject_add_internal(struct kobject *kobj)
 	if (!kobj)
 		return -ENOENT;
 
-	if (!kobj->k_name || !kobj->k_name[0]) {
+	if (!kobj->name || !kobj->name[0]) {
 		pr_debug("kobject: (%p): attempted to be registered with empty "
 			 "name!\n", kobj);
 		WARN_ON(1);
@@ -228,13 +228,11 @@ static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 	if (!name)
 		return -ENOMEM;
 
-
 	/* Free the old name, if necessary. */
-	kfree(kobj->k_name);
+	kfree(kobj->name);
 
 	/* Now, set the new name */
-	kobj->k_name = name;
-	kobj->state_name_set = 1;
+	kobj->name = name;
 
 	return 0;
 }
@@ -295,7 +293,6 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->ktype = ktype;
-	kobj->state_name_set = 0;
 	kobj->state_in_sysfs = 0;
 	kobj->state_add_uevent_sent = 0;
 	kobj->state_remove_uevent_sent = 0;
@@ -551,8 +548,7 @@ struct kobject * kobject_get(struct kobject * kobj)
 static void kobject_cleanup(struct kobject *kobj)
 {
 	struct kobj_type *t = get_ktype(kobj);
-	const char *name = kobj->k_name;
-	int name_set = kobj->state_name_set;
+	const char *name = kobj->name;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
 		 kobject_name(kobj), kobj, __FUNCTION__);
@@ -583,7 +579,7 @@ static void kobject_cleanup(struct kobject *kobj)
 	}
 
 	/* free name if we allocated it */
-	if (name_set && name) {
+	if (name) {
 		pr_debug("kobject: '%s': free name\n", name);
 		kfree(name);
 	}

commit 528a4bf1d5ffed310d26fc1d82d45c02949f71cf
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 20 08:13:05 2007 -0800

    Kobject: remove kobject_unregister() as no one uses it anymore
    
    There are no in-kernel users of kobject_unregister() so it should be
    removed.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 462946ee3e64..a0773734545c 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -532,22 +532,6 @@ void kobject_del(struct kobject * kobj)
 	kobj->parent = NULL;
 }
 
-/**
- *	kobject_unregister - remove object from hierarchy and decrement refcount.
- *	@kobj:	object going away.
- */
-
-void kobject_unregister(struct kobject * kobj)
-{
-	if (!kobj)
-		return;
-	pr_debug("kobject: '%s' (%p): %s\n",
-		 kobject_name(kobj), kobj, __FUNCTION__);
-	kobject_uevent(kobj, KOBJ_REMOVE);
-	kobject_del(kobj);
-	kobject_put(kobj);
-}
-
 /**
  *	kobject_get - increment refcount for object.
  *	@kobj:	object.
@@ -877,7 +861,6 @@ struct kset *kset_create_and_add(const char *name,
 }
 EXPORT_SYMBOL_GPL(kset_create_and_add);
 
-EXPORT_SYMBOL(kobject_unregister);
 EXPORT_SYMBOL(kobject_get);
 EXPORT_SYMBOL(kobject_put);
 EXPORT_SYMBOL(kobject_del);

commit 78a2d906b40fe530ea800c1e873bfe8f02326f1e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 20 08:13:05 2007 -0800

    Kobject: convert remaining kobject_unregister() to kobject_put()
    
    There is no need for kobject_unregister() anymore, thanks to Kay's
    kobject cleanup changes, so replace all instances of it with
    kobject_put().
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4fce5ca42c2e..462946ee3e64 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -664,7 +664,7 @@ struct kobject *kobject_create(void)
  *
  * This function creates a kset structure dynamically and registers it
  * with sysfs.  When you are finished with this structure, call
- * kobject_unregister() and the structure will be dynamically freed when
+ * kobject_put() and the structure will be dynamically freed when
  * it is no longer being used.
  *
  * If the kobject was not able to be created, NULL will be returned.
@@ -761,7 +761,7 @@ void kset_unregister(struct kset * k)
 {
 	if (!k)
 		return;
-	kobject_unregister(&k->kobj);
+	kobject_put(&k->kobj);
 }
 
 

commit 0f4dafc0563c6c49e17fe14b3f5f356e4c4b8806
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 19 01:40:42 2007 +0100

    Kobject: auto-cleanup on final unref
    
    We save the current state in the object itself, so we can do proper
    cleanup when the last reference is dropped.
    
    If the initial reference is dropped, the object will be removed from
    sysfs if needed, if an "add" event was sent, "remove" will be send, and
    the allocated resources are released.
    
    This allows us to clean up some driver core usage as well as allowing us
    to do other such changes to the rest of the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index c321f1910cc2..4fce5ca42c2e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -124,85 +124,74 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 }
 EXPORT_SYMBOL_GPL(kobject_get_path);
 
-static void kobject_init_internal(struct kobject * kobj)
+/* add the kobject to its kset's list */
+static void kobj_kset_join(struct kobject *kobj)
 {
-	if (!kobj)
+	if (!kobj->kset)
 		return;
-	kref_init(&kobj->kref);
-	INIT_LIST_HEAD(&kobj->entry);
+
+	kset_get(kobj->kset);
+	spin_lock(&kobj->kset->list_lock);
+	list_add_tail(&kobj->entry, &kobj->kset->list);
+	spin_unlock(&kobj->kset->list_lock);
 }
 
+/* remove the kobject from its kset's list */
+static void kobj_kset_leave(struct kobject *kobj)
+{
+	if (!kobj->kset)
+		return;
 
-/**
- *	unlink - remove kobject from kset list.
- *	@kobj:	kobject.
- *
- *	Remove the kobject from the kset list and decrement
- *	its parent's refcount.
- *	This is separated out, so we can use it in both 
- *	kobject_del() and kobject_add_internal() on error.
- */
+	spin_lock(&kobj->kset->list_lock);
+	list_del_init(&kobj->entry);
+	spin_unlock(&kobj->kset->list_lock);
+	kset_put(kobj->kset);
+}
 
-static void unlink(struct kobject * kobj)
+static void kobject_init_internal(struct kobject * kobj)
 {
-	struct kobject *parent = kobj->parent;
-
-	if (kobj->kset) {
-		spin_lock(&kobj->kset->list_lock);
-		list_del_init(&kobj->entry);
-		spin_unlock(&kobj->kset->list_lock);
-	}
-	kobj->parent = NULL;
-	kobject_put(kobj);
-	kobject_put(parent);
+	if (!kobj)
+		return;
+	kref_init(&kobj->kref);
+	INIT_LIST_HEAD(&kobj->entry);
 }
 
+
 static int kobject_add_internal(struct kobject *kobj)
 {
 	int error = 0;
 	struct kobject * parent;
 
-	if (!(kobj = kobject_get(kobj)))
+	if (!kobj)
 		return -ENOENT;
-	if (!kobj->k_name)
-		kobject_set_name(kobj, "NO_NAME");
-	if (!*kobj->k_name) {
-		pr_debug("kobject (%p) attempted to be registered with no "
+
+	if (!kobj->k_name || !kobj->k_name[0]) {
+		pr_debug("kobject: (%p): attempted to be registered with empty "
 			 "name!\n", kobj);
 		WARN_ON(1);
-		kobject_put(kobj);
 		return -EINVAL;
 	}
-	parent = kobject_get(kobj->parent);
 
-	pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
-		 kobject_name(kobj), kobj, __FUNCTION__,
-		 parent ? kobject_name(parent) : "<NULL>",
-		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
+	parent = kobject_get(kobj->parent);
 
+	/* join kset if set, use it as parent if we do not already have one */
 	if (kobj->kset) {
-		kobj->kset = kset_get(kobj->kset);
-
-		if (!parent) {
+		if (!parent)
 			parent = kobject_get(&kobj->kset->kobj);
-			/*
-			 * If the kset is our parent, get a second
-			 * reference, we drop both the kset and the
-			 * parent ref on cleanup
-			 */
-			kobject_get(parent);
-		}
-
-		spin_lock(&kobj->kset->list_lock);
-		list_add_tail(&kobj->entry, &kobj->kset->list);
-		spin_unlock(&kobj->kset->list_lock);
+		kobj_kset_join(kobj);
 		kobj->parent = parent;
 	}
 
+	pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
+		 kobject_name(kobj), kobj, __FUNCTION__,
+		 parent ? kobject_name(parent) : "<NULL>",
+		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
+
 	error = create_dir(kobj);
 	if (error) {
-		/* unlink does the kobject_put() for us */
-		unlink(kobj);
+		kobj_kset_leave(kobj);
+		kobject_put(parent);
+		kobj->parent = NULL;
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
@@ -214,7 +203,8 @@ static int kobject_add_internal(struct kobject *kobj)
 			printk(KERN_ERR "%s failed for %s (%d)\n",
 			       __FUNCTION__, kobject_name(kobj), error);
 		dump_stack();
-	}
+	} else
+		kobj->state_in_sysfs = 1;
 
 	return error;
 }
@@ -238,11 +228,13 @@ static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 	if (!name)
 		return -ENOMEM;
 
+
 	/* Free the old name, if necessary. */
 	kfree(kobj->k_name);
 
 	/* Now, set the new name */
 	kobj->k_name = name;
+	kobj->state_name_set = 1;
 
 	return 0;
 }
@@ -293,20 +285,25 @@ void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 		err_str = "must have a ktype to be initialized properly!\n";
 		goto error;
 	}
-	if (atomic_read(&kobj->kref.refcount)) {
+	if (kobj->state_initialized) {
 		/* do not error out as sometimes we can recover */
-		printk(KERN_ERR "kobject: reference count is already set, "
-		       "something is seriously wrong.\n");
+		printk(KERN_ERR "kobject (%p): tried to init an initialized "
+		       "object, something is seriously wrong.\n", kobj);
 		dump_stack();
 	}
 
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->ktype = ktype;
+	kobj->state_name_set = 0;
+	kobj->state_in_sysfs = 0;
+	kobj->state_add_uevent_sent = 0;
+	kobj->state_remove_uevent_sent = 0;
+	kobj->state_initialized = 1;
 	return;
 
 error:
-	printk(KERN_ERR "kobject: %s\n", err_str);
+	printk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);
 	dump_stack();
 }
 EXPORT_SYMBOL(kobject_init);
@@ -345,17 +342,10 @@ static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
  *
  * If this function returns an error, kobject_put() must be called to
  * properly clean up the memory associated with the object.
- *
- * If the function is successful, the only way to properly clean up the
- * memory is with a call to kobject_del(), in which case, a call to
- * kobject_put() is not necessary (kobject_del() does the final
- * kobject_put() to call the release function in the ktype's release
- * pointer.)
- *
  * Under no instance should the kobject that is passed to this function
  * be directly freed with a call to kfree(), that can leak memory.
  *
- * Note, no uevent will be created with this call, the caller should set
+ * Note, no "add" uevent will be created with this call, the caller should set
  * up all of the necessary sysfs files for the object and then call
  * kobject_uevent() with the UEVENT_ADD parameter to ensure that
  * userspace is properly notified of this kobject's creation.
@@ -369,6 +359,13 @@ int kobject_add(struct kobject *kobj, struct kobject *parent,
 	if (!kobj)
 		return -EINVAL;
 
+	if (!kobj->state_initialized) {
+		printk(KERN_ERR "kobject '%s' (%p): tried to add an "
+		       "uninitialized object, something is seriously wrong.\n",
+		       kobject_name(kobj), kobj);
+		dump_stack();
+		return -EINVAL;
+	}
 	va_start(args, fmt);
 	retval = kobject_add_varg(kobj, parent, fmt, args);
 	va_end(args);
@@ -527,8 +524,12 @@ void kobject_del(struct kobject * kobj)
 {
 	if (!kobj)
 		return;
+
 	sysfs_remove_dir(kobj);
-	unlink(kobj);
+	kobj->state_in_sysfs = 0;
+	kobj_kset_leave(kobj);
+	kobject_put(kobj->parent);
+	kobj->parent = NULL;
 }
 
 /**
@@ -565,21 +566,43 @@ struct kobject * kobject_get(struct kobject * kobj)
  */
 static void kobject_cleanup(struct kobject *kobj)
 {
-	struct kobj_type * t = get_ktype(kobj);
-	struct kset * s = kobj->kset;
+	struct kobj_type *t = get_ktype(kobj);
 	const char *name = kobj->k_name;
+	int name_set = kobj->state_name_set;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
 		 kobject_name(kobj), kobj, __FUNCTION__);
+
+	if (t && !t->release)
+		pr_debug("kobject: '%s' (%p): does not have a release() "
+			 "function, it is broken and must be fixed.\n",
+			 kobject_name(kobj), kobj);
+
+	/* send "remove" if the caller did not do it but sent "add" */
+	if (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {
+		pr_debug("kobject: '%s' (%p): auto cleanup 'remove' event\n",
+			 kobject_name(kobj), kobj);
+		kobject_uevent(kobj, KOBJ_REMOVE);
+	}
+
+	/* remove from sysfs if the caller did not do it */
+	if (kobj->state_in_sysfs) {
+		pr_debug("kobject: '%s' (%p): auto cleanup kobject_del\n",
+			 kobject_name(kobj), kobj);
+		kobject_del(kobj);
+	}
+
 	if (t && t->release) {
+		pr_debug("kobject: '%s' (%p): calling ktype release\n",
+			 kobject_name(kobj), kobj);
 		t->release(kobj);
-		/* If we have a release function, we can guess that this was
-		 * not a statically allocated kobject, so we should be safe to
-		 * free the name */
+	}
+
+	/* free name if we allocated it */
+	if (name_set && name) {
+		pr_debug("kobject: '%s': free name\n", name);
 		kfree(name);
 	}
-	if (s)
-		kset_put(s);
 }
 
 static void kobject_release(struct kref *kref)
@@ -601,8 +624,7 @@ void kobject_put(struct kobject * kobj)
 
 static void dynamic_kobj_release(struct kobject *kobj)
 {
-	pr_debug("kobject: '%s' (%p): %s\n",
-		 kobject_name(kobj), kobj, __FUNCTION__);
+	pr_debug("kobject: (%p): %s\n", kobj, __FUNCTION__);
 	kfree(kobj);
 }
 

commit 12e339ac6e31a34fe42396aec8fb1c0b43caf61e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Apr 9 12:14:34 2002 -0700

    Kset: remove kset_add function
    
    No one is calling this anymore, so just remove it and hard-code the one
    internal-use of it.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3326281c96b6..c321f1910cc2 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -709,17 +709,6 @@ struct sysfs_ops kobj_sysfs_ops = {
 	.store	= kobj_attr_store,
 };
 
-/**
- *	kset_add - add a kset object to the hierarchy.
- *	@k:	kset.
- */
-
-int kset_add(struct kset * k)
-{
-	return kobject_add_internal(&k->kobj);
-}
-
-
 /**
  *	kset_register - initialize and add a kset.
  *	@k:	kset.
@@ -733,7 +722,7 @@ int kset_register(struct kset * k)
 		return -EINVAL;
 
 	kset_init(k);
-	err = kset_add(k);
+	err = kobject_add_internal(&k->kobj);
 	if (err)
 		return err;
 	kobject_uevent(&k->kobj, KOBJ_ADD);

commit 6d06adfaf82d154023141ddc0c9de18b6a49090b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Dec 19 11:26:50 2007 -0800

    Kobject: remove kobject_register()
    
    The function is no longer used by anyone in the kernel, and it prevents
    the proper sending of the kobject uevent after the needed files are set
    up by the caller.  kobject_init_and_add() can be used in its place.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4cc231c86225..3326281c96b6 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -219,23 +219,6 @@ static int kobject_add_internal(struct kobject *kobj)
 	return error;
 }
 
-/**
- *	kobject_register - initialize and add an object.
- *	@kobj:	object in question.
- */
-
-int kobject_register(struct kobject * kobj)
-{
-	int error = -EINVAL;
-	if (kobj) {
-		kobject_init_internal(kobj);
-		error = kobject_add(kobj);
-		if (!error)
-			kobject_uevent(kobj, KOBJ_ADD);
-	}
-	return error;
-}
-
 /**
  * kobject_set_name_vargs - Set the name of an kobject
  * @kobj: struct kobject to set the name of
@@ -883,7 +866,6 @@ struct kset *kset_create_and_add(const char *name,
 }
 EXPORT_SYMBOL_GPL(kset_create_and_add);
 
-EXPORT_SYMBOL(kobject_register);
 EXPORT_SYMBOL(kobject_unregister);
 EXPORT_SYMBOL(kobject_get);
 EXPORT_SYMBOL(kobject_put);

commit f9cb074bff8e762ef24c44678a5a7d907f82fbeb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: rename kobject_init_ng() to kobject_init()
    
    Now that the old kobject_init() function is gone, rename
    kobject_init_ng() to kobject_init() to clean up the namespace.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 10d977b6e69d..4cc231c86225 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -287,7 +287,7 @@ int kobject_set_name(struct kobject *kobj, const char *fmt, ...)
 EXPORT_SYMBOL(kobject_set_name);
 
 /**
- * kobject_init_ng - initialize a kobject structure
+ * kobject_init - initialize a kobject structure
  * @kobj: pointer to the kobject to initialize
  * @ktype: pointer to the ktype for this kobject.
  *
@@ -298,7 +298,7 @@ EXPORT_SYMBOL(kobject_set_name);
  * to kobject_put(), not by a call to kfree directly to ensure that all of
  * the memory is cleaned up properly.
  */
-void kobject_init_ng(struct kobject *kobj, struct kobj_type *ktype)
+void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
 {
 	char *err_str;
 
@@ -326,7 +326,7 @@ void kobject_init_ng(struct kobject *kobj, struct kobj_type *ktype)
 	printk(KERN_ERR "kobject: %s\n", err_str);
 	dump_stack();
 }
-EXPORT_SYMBOL(kobject_init_ng);
+EXPORT_SYMBOL(kobject_init);
 
 static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
 			    const char *fmt, va_list vargs)
@@ -401,7 +401,7 @@ EXPORT_SYMBOL(kobject_add);
  * @parent: pointer to the parent of this kobject.
  * @fmt: the name of the kobject.
  *
- * This function combines the call to kobject_init_ng() and
+ * This function combines the call to kobject_init() and
  * kobject_add().  The same type of error handling after a call to
  * kobject_add() and kobject lifetime rules are the same here.
  */
@@ -411,7 +411,7 @@ int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
 	va_list args;
 	int retval;
 
-	kobject_init_ng(kobj, ktype);
+	kobject_init(kobj, ktype);
 
 	va_start(args, fmt);
 	retval = kobject_add_varg(kobj, parent, fmt, args);
@@ -636,7 +636,7 @@ static struct kobj_type dynamic_kobj_ktype = {
  *
  * If the kobject was not able to be created, NULL will be returned.
  * The kobject structure returned from here must be cleaned up with a
- * call to kobject_put() and not kfree(), as kobject_init_ng() has
+ * call to kobject_put() and not kfree(), as kobject_init() has
  * already been called on this structure.
  */
 struct kobject *kobject_create(void)
@@ -647,7 +647,7 @@ struct kobject *kobject_create(void)
 	if (!kobj)
 		return NULL;
 
-	kobject_init_ng(kobj, &dynamic_kobj_ktype);
+	kobject_init(kobj, &dynamic_kobj_ktype);
 	return kobj;
 }
 

commit e1543ddf739b22a8c4218716ad50c26b3e147403
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: remove kobject_init() as no one uses it anymore
    
    The old kobject_init() function is on longer in use, so let us remove it
    from the public scope (kset mess in the kobject.c file still uses it,
    but that can be cleaned up later very simply.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 359e114790cb..10d977b6e69d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -124,11 +124,7 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 }
 EXPORT_SYMBOL_GPL(kobject_get_path);
 
-/**
- *	kobject_init - initialize object.
- *	@kobj:	object in question.
- */
-void kobject_init(struct kobject * kobj)
+static void kobject_init_internal(struct kobject * kobj)
 {
 	if (!kobj)
 		return;
@@ -232,7 +228,7 @@ int kobject_register(struct kobject * kobj)
 {
 	int error = -EINVAL;
 	if (kobj) {
-		kobject_init(kobj);
+		kobject_init_internal(kobj);
 		error = kobject_add(kobj);
 		if (!error)
 			kobject_uevent(kobj, KOBJ_ADD);
@@ -695,7 +691,7 @@ EXPORT_SYMBOL_GPL(kobject_create_and_add);
 
 void kset_init(struct kset * k)
 {
-	kobject_init(&k->kobj);
+	kobject_init_internal(&k->kobj);
 	INIT_LIST_HEAD(&k->list);
 	spin_lock_init(&k->list_lock);
 }
@@ -887,7 +883,6 @@ struct kset *kset_create_and_add(const char *name,
 }
 EXPORT_SYMBOL_GPL(kset_create_and_add);
 
-EXPORT_SYMBOL(kobject_init);
 EXPORT_SYMBOL(kobject_register);
 EXPORT_SYMBOL(kobject_unregister);
 EXPORT_SYMBOL(kobject_get);

commit b2d6db5878a0832659ed58476357eea2db915550
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: rename kobject_add_ng() to kobject_add()
    
    Now that the old kobject_add() function is gone, rename kobject_add_ng()
    to kobject_add() to clean up the namespace.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index d04789fa4da9..359e114790cb 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -350,7 +350,7 @@ static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
 }
 
 /**
- * kobject_add_ng - the main kobject add function
+ * kobject_add - the main kobject add function
  * @kobj: the kobject to add
  * @parent: pointer to the parent of the kobject.
  * @fmt: format to name the kobject with.
@@ -381,8 +381,8 @@ static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
  * kobject_uevent() with the UEVENT_ADD parameter to ensure that
  * userspace is properly notified of this kobject's creation.
  */
-int kobject_add_ng(struct kobject *kobj, struct kobject *parent,
-		   const char *fmt, ...)
+int kobject_add(struct kobject *kobj, struct kobject *parent,
+		const char *fmt, ...)
 {
 	va_list args;
 	int retval;
@@ -396,7 +396,7 @@ int kobject_add_ng(struct kobject *kobj, struct kobject *parent,
 
 	return retval;
 }
-EXPORT_SYMBOL(kobject_add_ng);
+EXPORT_SYMBOL(kobject_add);
 
 /**
  * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy
@@ -406,8 +406,8 @@ EXPORT_SYMBOL(kobject_add_ng);
  * @fmt: the name of the kobject.
  *
  * This function combines the call to kobject_init_ng() and
- * kobject_add_ng().  The same type of error handling after a call to
- * kobject_add_ng() and kobject lifetime rules are the same here.
+ * kobject_add().  The same type of error handling after a call to
+ * kobject_add() and kobject lifetime rules are the same here.
  */
 int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
 			 struct kobject *parent, const char *fmt, ...)
@@ -677,7 +677,7 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 	if (!kobj)
 		return NULL;
 
-	retval = kobject_add_ng(kobj, parent, "%s", name);
+	retval = kobject_add(kobj, parent, "%s", name);
 	if (retval) {
 		printk(KERN_WARNING "%s: kobject_add error: %d\n",
 		       __FUNCTION__, retval);

commit 9e7bbccd0290e720e0874443932869c55f63d5a8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 23:05:35 2007 -0700

    Kobject: remove kobject_add() as no one uses it anymore
    
    The old kobject_add() function is on longer in use, so let us remove it
    from the public scope (kset mess in the kobject.c file still uses it,
    but that can be cleaned up later very simply.)
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 493e991abb1b..d04789fa4da9 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -144,7 +144,7 @@ void kobject_init(struct kobject * kobj)
  *	Remove the kobject from the kset list and decrement
  *	its parent's refcount.
  *	This is separated out, so we can use it in both 
- *	kobject_del() and kobject_add() on error.
+ *	kobject_del() and kobject_add_internal() on error.
  */
 
 static void unlink(struct kobject * kobj)
@@ -161,12 +161,7 @@ static void unlink(struct kobject * kobj)
 	kobject_put(parent);
 }
 
-/**
- *	kobject_add - add an object to the hierarchy.
- *	@kobj:	object.
- */
-
-int kobject_add(struct kobject * kobj)
+static int kobject_add_internal(struct kobject *kobj)
 {
 	int error = 0;
 	struct kobject * parent;
@@ -215,13 +210,13 @@ int kobject_add(struct kobject * kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			printk(KERN_ERR "kobject_add failed for %s with "
+			printk(KERN_ERR "%s failed for %s with "
 			       "-EEXIST, don't try to register things with "
 			       "the same name in the same directory.\n",
-			       kobject_name(kobj));
+			       __FUNCTION__, kobject_name(kobj));
 		else
-			printk(KERN_ERR "kobject_add failed for %s (%d)\n",
-			       kobject_name(kobj), error);
+			printk(KERN_ERR "%s failed for %s (%d)\n",
+			       __FUNCTION__, kobject_name(kobj), error);
 		dump_stack();
 	}
 
@@ -351,7 +346,7 @@ static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
 		return retval;
 	}
 	kobj->parent = parent;
-	return kobject_add(kobj);
+	return kobject_add_internal(kobj);
 }
 
 /**
@@ -742,7 +737,7 @@ struct sysfs_ops kobj_sysfs_ops = {
 
 int kset_add(struct kset * k)
 {
-	return kobject_add(&k->kobj);
+	return kobject_add_internal(&k->kobj);
 }
 
 
@@ -897,7 +892,6 @@ EXPORT_SYMBOL(kobject_register);
 EXPORT_SYMBOL(kobject_unregister);
 EXPORT_SYMBOL(kobject_get);
 EXPORT_SYMBOL(kobject_put);
-EXPORT_SYMBOL(kobject_add);
 EXPORT_SYMBOL(kobject_del);
 
 EXPORT_SYMBOL(kset_register);

commit 09f82ea92822a7bbb7e816508abbda47ed54a77f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 19 10:53:40 2007 -0500

    Kobject: drop child->parent ref at unregistration
    
    This patch (as1015) reverts changes that were made to the driver core
    about four years ago.  The intent back then was to avoid certain kinds
    of invalid memory accesses by leaving kernel objects allocated as long
    as any of their children were still allocated.  The original and
    correct approach was to wait only as long as any children were still
    _registered_; that's what this patch reinstates.
    
    This fixes a problem in the SCSI core made visible by the class_device
    to regular device conversion: A reference loop (scsi_device holds
    reference to request_queue, which is the child of a gendisk, which is
    the child of the scsi_device) prevents the data structures from being
    released, even though they are deregistered okay.
    
    It's possible that this change will cause a few bugs to surface,
    things that have been hidden for several years.  They can be fixed
    easily enough by having the child device take an explicit reference to
    the parent whenever needed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1015f74212d0..493e991abb1b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -149,12 +149,16 @@ void kobject_init(struct kobject * kobj)
 
 static void unlink(struct kobject * kobj)
 {
+	struct kobject *parent = kobj->parent;
+
 	if (kobj->kset) {
 		spin_lock(&kobj->kset->list_lock);
 		list_del_init(&kobj->entry);
 		spin_unlock(&kobj->kset->list_lock);
 	}
+	kobj->parent = NULL;
 	kobject_put(kobj);
+	kobject_put(parent);
 }
 
 /**
@@ -208,7 +212,6 @@ int kobject_add(struct kobject * kobj)
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
-		kobject_put(parent);
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
@@ -590,7 +593,6 @@ static void kobject_cleanup(struct kobject *kobj)
 {
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj->kset;
-	struct kobject * parent = kobj->parent;
 	const char *name = kobj->k_name;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
@@ -604,7 +606,6 @@ static void kobject_cleanup(struct kobject *kobj)
 	}
 	if (s)
 		kset_put(s);
-	kobject_put(parent);
 }
 
 static void kobject_release(struct kref *kref)

commit 9f66fa2a4690a16da0dbaae2f44ddfc313802504
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 23:49:41 2007 -0800

    kobject: clean up debugging messages
    
    The kobject debugging messages are a mess.  This provides a unified
    message that makes them actually useful.
    
    The format for new kobject debug messages should be:
            kobject: 'KOBJECT_NAME' (ADDRESS): FUNCTION_NAME: message.\n
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4d52b6f534bc..1015f74212d0 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -95,7 +95,8 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 		*(path + --length) = '/';
 	}
 
-	pr_debug("%s: path = '%s'\n",__FUNCTION__,path);
+	pr_debug("kobject: '%s' (%p): %s: path = '%s'\n", kobject_name(kobj),
+		 kobj, __FUNCTION__,path);
 }
 
 /**
@@ -171,15 +172,17 @@ int kobject_add(struct kobject * kobj)
 	if (!kobj->k_name)
 		kobject_set_name(kobj, "NO_NAME");
 	if (!*kobj->k_name) {
-		pr_debug("kobject attempted to be registered with no name!\n");
+		pr_debug("kobject (%p) attempted to be registered with no "
+			 "name!\n", kobj);
 		WARN_ON(1);
 		kobject_put(kobj);
 		return -EINVAL;
 	}
 	parent = kobject_get(kobj->parent);
 
-	pr_debug("kobject %s: registering. parent: %s, set: %s\n",
-		 kobject_name(kobj), parent ? kobject_name(parent) : "<NULL>", 
+	pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
+		 kobject_name(kobj), kobj, __FUNCTION__,
+		 parent ? kobject_name(parent) : "<NULL>",
 		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
 
 	if (kobj->kset) {
@@ -560,7 +563,8 @@ void kobject_unregister(struct kobject * kobj)
 {
 	if (!kobj)
 		return;
-	pr_debug("kobject %s: unregistering\n",kobject_name(kobj));
+	pr_debug("kobject: '%s' (%p): %s\n",
+		 kobject_name(kobj), kobj, __FUNCTION__);
 	kobject_uevent(kobj, KOBJ_REMOVE);
 	kobject_del(kobj);
 	kobject_put(kobj);
@@ -589,7 +593,8 @@ static void kobject_cleanup(struct kobject *kobj)
 	struct kobject * parent = kobj->parent;
 	const char *name = kobj->k_name;
 
-	pr_debug("kobject %s: cleaning up\n",kobject_name(kobj));
+	pr_debug("kobject: '%s' (%p): %s\n",
+		 kobject_name(kobj), kobj, __FUNCTION__);
 	if (t && t->release) {
 		t->release(kobj);
 		/* If we have a release function, we can guess that this was
@@ -621,7 +626,8 @@ void kobject_put(struct kobject * kobj)
 
 static void dynamic_kobj_release(struct kobject *kobj)
 {
-	pr_debug("%s: freeing %s\n", __FUNCTION__, kobject_name(kobj));
+	pr_debug("kobject: '%s' (%p): %s\n",
+		 kobject_name(kobj), kobj, __FUNCTION__);
 	kfree(kobj);
 }
 
@@ -803,7 +809,8 @@ struct kobject * kset_find_obj(struct kset * kset, const char * name)
 static void kset_release(struct kobject *kobj)
 {
 	struct kset *kset = container_of(kobj, struct kset, kobj);
-	pr_debug("kset %s: now freed\n", kobject_name(kobj));
+	pr_debug("kobject: '%s' (%p): %s\n",
+		 kobject_name(kobj), kobj, __FUNCTION__);
 	kfree(kset);
 }
 

commit cfb36fff45e3997b8044c81045fc4869ba5f281a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 28 10:46:22 2007 -0800

    kobject: grab the kset reference in kobject_add, not kobject_init
    
    kobject_init should not be grabing any references, but only initializing
    the object.  This patch fixes this, and makes the lock hold-time shorter
    for when a kset is present in the kobject.
    
    The current kernel tree has been audited to verify that this change
    should be safe.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7919c32a3a15..4d52b6f534bc 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -133,7 +133,6 @@ void kobject_init(struct kobject * kobj)
 		return;
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
-	kobj->kset = kset_get(kobj->kset);
 }
 
 
@@ -184,7 +183,7 @@ int kobject_add(struct kobject * kobj)
 		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
 
 	if (kobj->kset) {
-		spin_lock(&kobj->kset->list_lock);
+		kobj->kset = kset_get(kobj->kset);
 
 		if (!parent) {
 			parent = kobject_get(&kobj->kset->kobj);
@@ -196,7 +195,8 @@ int kobject_add(struct kobject * kobj)
 			kobject_get(parent);
 		}
 
-		list_add_tail(&kobj->entry,&kobj->kset->list);
+		spin_lock(&kobj->kset->list_lock);
+		list_add_tail(&kobj->entry, &kobj->kset->list);
 		spin_unlock(&kobj->kset->list_lock);
 		kobj->parent = parent;
 	}

commit 2fb9113b974c3c7c43e76647bd5077238e274e1c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 6 15:03:30 2007 -0800

    kobject: remove subsystem_(un)register functions
    
    These functions are no longer used and are the last remants of the old
    subsystem crap.  So delete them for good.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index c742ac25228a..7919c32a3a15 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -800,16 +800,6 @@ struct kobject * kset_find_obj(struct kset * kset, const char * name)
 	return ret;
 }
 
-int subsystem_register(struct kset *s)
-{
-	return kset_register(s);
-}
-
-void subsystem_unregister(struct kset *s)
-{
-	kset_unregister(s);
-}
-
 static void kset_release(struct kobject *kobj)
 {
 	struct kset *kset = container_of(kobj, struct kset, kobj);
@@ -904,6 +894,3 @@ EXPORT_SYMBOL(kobject_del);
 
 EXPORT_SYMBOL(kset_register);
 EXPORT_SYMBOL(kset_unregister);
-
-EXPORT_SYMBOL(subsystem_register);
-EXPORT_SYMBOL(subsystem_unregister);

commit 000f2a4d8cfc1e1cbc0aa98136015e7ae7719b46
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 2 13:47:53 2007 +0100

    Driver Core: kill subsys_attribute and default sysfs ops
    
    Remove the no longer needed subsys_attributes, they are all converted to
    the more sensical kobj_attributes.
    
    There is no longer a magic fallback in sysfs attribute operations, all
    kobjects which create simple attributes need explicitely a ktype
    assigned, which tells the core what was intended here.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 99f6354a5751..c742ac25228a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -810,26 +810,6 @@ void subsystem_unregister(struct kset *s)
 	kset_unregister(s);
 }
 
-/**
- *	subsystem_create_file - export sysfs attribute file.
- *	@s:	subsystem.
- *	@a:	subsystem attribute descriptor.
- */
-
-int subsys_create_file(struct kset *s, struct subsys_attribute *a)
-{
-	int error = 0;
-
-	if (!s || !a)
-		return -EINVAL;
-
-	if (kset_get(s)) {
-		error = sysfs_create_file(&s->kobj, &a->attr);
-		kset_put(s);
-	}
-	return error;
-}
-
 static void kset_release(struct kobject *kobj)
 {
 	struct kset *kset = container_of(kobj, struct kset, kobj);
@@ -927,4 +907,3 @@ EXPORT_SYMBOL(kset_unregister);
 
 EXPORT_SYMBOL(subsystem_register);
 EXPORT_SYMBOL(subsystem_unregister);
-EXPORT_SYMBOL(subsys_create_file);

commit 386f275f5d097758f867bc99ddeaeb7a03b6b190
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 2 13:47:53 2007 +0100

    Driver Core: switch all dynamic ksets to kobj_sysfs_ops
    
    Switch all dynamically created ksets, that export simple attributes,
    to kobj_attribute from subsys_attribute. Struct subsys_attribute will
    be removed.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mike Halcrow <mhalcrow@us.ibm.com>
    Cc: Phillip Hellewell <phillip@hellewell.homeip.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1c343fe4ba63..99f6354a5751 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -626,7 +626,8 @@ static void dynamic_kobj_release(struct kobject *kobj)
 }
 
 static struct kobj_type dynamic_kobj_ktype = {
-	.release = dynamic_kobj_release,
+	.release	= dynamic_kobj_release,
+	.sysfs_ops	= &kobj_sysfs_ops,
 };
 
 /**
@@ -836,7 +837,8 @@ static void kset_release(struct kobject *kobj)
 	kfree(kset);
 }
 
-static struct kobj_type kset_type = {
+static struct kobj_type kset_ktype = {
+	.sysfs_ops	= &kobj_sysfs_ops,
 	.release = kset_release,
 };
 
@@ -869,11 +871,11 @@ static struct kset *kset_create(const char *name,
 	kset->kobj.parent = parent_kobj;
 
 	/*
-	 * The kobject of this kset will have a type of kset_type and belong to
+	 * The kobject of this kset will have a type of kset_ktype and belong to
 	 * no kset itself.  That way we can properly free it when it is
 	 * finished being used.
 	 */
-	kset->kobj.ktype = &kset_type;
+	kset->kobj.ktype = &kset_ktype;
 	kset->kobj.kset = NULL;
 
 	return kset;

commit 23b5212cc7422f475b82124334b64277b5b43013
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 2 13:47:53 2007 +0100

    Driver Core: add kobj_attribute handling
    
    Add kobj_sysfs_ops to replace subsys_sysfs_ops. There is no
    need for special kset operations, we want to be able to use
    simple attribute operations at any kobject, not only ksets.
    
    The whole concept of any default sysfs attribute operations
    will go away with the upcoming removal of subsys_sysfs_ops.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 67c3d38d48f0..1c343fe4ba63 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -697,6 +697,35 @@ void kset_init(struct kset * k)
 	spin_lock_init(&k->list_lock);
 }
 
+/* default kobject attribute operations */
+static ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,
+			      char *buf)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->show)
+		ret = kattr->show(kobj, kattr, buf);
+	return ret;
+}
+
+static ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->store)
+		ret = kattr->store(kobj, kattr, buf, count);
+	return ret;
+}
+
+struct sysfs_ops kobj_sysfs_ops = {
+	.show	= kobj_attr_show,
+	.store	= kobj_attr_store,
+};
 
 /**
  *	kset_add - add a kset object to the hierarchy.

commit 43968d2f1648f4dc92437dc0363a3e88377445b3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 22:24:43 2007 -0800

    kobject: get rid of kobject_kset_add_dir
    
    kobject_kset_add_dir is only called in one place so remove it and use
    kobject_create() instead.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 96b61d9a9284..67c3d38d48f0 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -629,15 +629,18 @@ static struct kobj_type dynamic_kobj_ktype = {
 	.release = dynamic_kobj_release,
 };
 
-/*
+/**
  * kobject_create - create a struct kobject dynamically
  *
  * This function creates a kobject structure dynamically and sets it up
  * to be a "dynamic" kobject with a default release function set up.
  *
  * If the kobject was not able to be created, NULL will be returned.
+ * The kobject structure returned from here must be cleaned up with a
+ * call to kobject_put() and not kfree(), as kobject_init_ng() has
+ * already been called on this structure.
  */
-static struct kobject *kobject_create(void)
+struct kobject *kobject_create(void)
 {
 	struct kobject *kobj;
 
@@ -682,36 +685,6 @@ struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
 }
 EXPORT_SYMBOL_GPL(kobject_create_and_add);
 
-/**
- *	kobject_kset_add_dir - add sub directory of object.
- *	@kset:		kset the directory is belongs to.
- *	@parent:	object in which a directory is created.
- *	@name:	directory name.
- *
- *	Add a plain directory object as child of given object.
- */
-struct kobject *kobject_kset_add_dir(struct kset *kset,
-				     struct kobject *parent, const char *name)
-{
-	struct kobject *k;
-	int ret;
-
-	k = kobject_create();
-	if (!k)
-		return NULL;
-
-	k->kset = kset;
-	ret = kobject_add_ng(k, parent, "%s", name);
-	if (ret < 0) {
-		printk(KERN_WARNING "%s: kobject_add error: %d\n",
-			__func__, ret);
-		kobject_put(k);
-		k = NULL;
-	}
-
-	return k;
-}
-
 /**
  *	kset_init - initialize a kset for use
  *	@k:	kset 

commit 4ff6abff832fbc6cb1d769f6106c841bc2b09f63
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 22:24:43 2007 -0800

    kobject: get rid of kobject_add_dir
    
    kobject_create_and_add is the same as kobject_add_dir, so drop
    kobject_add_dir.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 98422a3eeffc..96b61d9a9284 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -712,18 +712,6 @@ struct kobject *kobject_kset_add_dir(struct kset *kset,
 	return k;
 }
 
-/**
- *	kobject_add_dir - add sub directory of object.
- *	@parent:	object in which a directory is created.
- *	@name:	directory name.
- *
- *	Add a plain directory object as child of given object.
- */
-struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
-{
-	return kobject_create_and_add(name, parent);
-}
-
 /**
  *	kset_init - initialize a kset for use
  *	@k:	kset 

commit 3f9e3ee9dc3605e5c593b5d708494571fb0d3970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 13:16:15 2007 -0800

    kobject: add kobject_create_and_add function
    
    This lets users create dynamic kobjects much easier.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4fb27ba28807..98422a3eeffc 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -619,18 +619,69 @@ void kobject_put(struct kobject * kobj)
 		kref_put(&kobj->kref, kobject_release);
 }
 
-
-static void dir_release(struct kobject *kobj)
+static void dynamic_kobj_release(struct kobject *kobj)
 {
+	pr_debug("%s: freeing %s\n", __FUNCTION__, kobject_name(kobj));
 	kfree(kobj);
 }
 
-static struct kobj_type dir_ktype = {
-	.release	= dir_release,
-	.sysfs_ops	= NULL,
-	.default_attrs	= NULL,
+static struct kobj_type dynamic_kobj_ktype = {
+	.release = dynamic_kobj_release,
 };
 
+/*
+ * kobject_create - create a struct kobject dynamically
+ *
+ * This function creates a kobject structure dynamically and sets it up
+ * to be a "dynamic" kobject with a default release function set up.
+ *
+ * If the kobject was not able to be created, NULL will be returned.
+ */
+static struct kobject *kobject_create(void)
+{
+	struct kobject *kobj;
+
+	kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);
+	if (!kobj)
+		return NULL;
+
+	kobject_init_ng(kobj, &dynamic_kobj_ktype);
+	return kobj;
+}
+
+/**
+ * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs
+ *
+ * @name: the name for the kset
+ * @parent: the parent kobject of this kobject, if any.
+ *
+ * This function creates a kset structure dynamically and registers it
+ * with sysfs.  When you are finished with this structure, call
+ * kobject_unregister() and the structure will be dynamically freed when
+ * it is no longer being used.
+ *
+ * If the kobject was not able to be created, NULL will be returned.
+ */
+struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
+{
+	struct kobject *kobj;
+	int retval;
+
+	kobj = kobject_create();
+	if (!kobj)
+		return NULL;
+
+	retval = kobject_add_ng(kobj, parent, "%s", name);
+	if (retval) {
+		printk(KERN_WARNING "%s: kobject_add error: %d\n",
+		       __FUNCTION__, retval);
+		kobject_put(kobj);
+		kobj = NULL;
+	}
+	return kobj;
+}
+EXPORT_SYMBOL_GPL(kobject_create_and_add);
+
 /**
  *	kobject_kset_add_dir - add sub directory of object.
  *	@kset:		kset the directory is belongs to.
@@ -645,23 +696,17 @@ struct kobject *kobject_kset_add_dir(struct kset *kset,
 	struct kobject *k;
 	int ret;
 
-	if (!parent)
-		return NULL;
-
-	k = kzalloc(sizeof(*k), GFP_KERNEL);
+	k = kobject_create();
 	if (!k)
 		return NULL;
 
 	k->kset = kset;
-	k->parent = parent;
-	k->ktype = &dir_ktype;
-	kobject_set_name(k, name);
-	ret = kobject_register(k);
+	ret = kobject_add_ng(k, parent, "%s", name);
 	if (ret < 0) {
-		printk(KERN_WARNING "%s: kobject_register error: %d\n",
+		printk(KERN_WARNING "%s: kobject_add error: %d\n",
 			__func__, ret);
-		kobject_del(k);
-		return NULL;
+		kobject_put(k);
+		k = NULL;
 	}
 
 	return k;
@@ -676,7 +721,7 @@ struct kobject *kobject_kset_add_dir(struct kset *kset,
  */
 struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 {
-	return kobject_kset_add_dir(NULL, parent, name);
+	return kobject_create_and_add(name, parent);
 }
 
 /**

commit b727c702896f88d2ff6c3e03bd011d7c3dffe3e1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 27 14:48:53 2007 -0700

    kset: add kset_create_and_add function
    
    Now ksets can be dynamically created on the fly, no static definitions
    are required.  Thanks to Miklos for hints on how to make this work
    better for the callers.
    
    And thanks to Kay for finding some stupid bugs in my original version
    and pointing out that we need to handle the fact that kobject's can have
    a kset as a parent and to handle that properly in kobject_add().
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 8f249408b2ec..4fb27ba28807 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -186,8 +186,15 @@ int kobject_add(struct kobject * kobj)
 	if (kobj->kset) {
 		spin_lock(&kobj->kset->list_lock);
 
-		if (!parent)
+		if (!parent) {
 			parent = kobject_get(&kobj->kset->kobj);
+			/*
+			 * If the kset is our parent, get a second
+			 * reference, we drop both the kset and the
+			 * parent ref on cleanup
+			 */
+			kobject_get(parent);
+		}
 
 		list_add_tail(&kobj->entry,&kobj->kset->list);
 		spin_unlock(&kobj->kset->list_lock);
@@ -787,6 +794,89 @@ int subsys_create_file(struct kset *s, struct subsys_attribute *a)
 	return error;
 }
 
+static void kset_release(struct kobject *kobj)
+{
+	struct kset *kset = container_of(kobj, struct kset, kobj);
+	pr_debug("kset %s: now freed\n", kobject_name(kobj));
+	kfree(kset);
+}
+
+static struct kobj_type kset_type = {
+	.release = kset_release,
+};
+
+/**
+ * kset_create - create a struct kset dynamically
+ *
+ * @name: the name for the kset
+ * @uevent_ops: a struct kset_uevent_ops for the kset
+ * @parent_kobj: the parent kobject of this kset, if any.
+ *
+ * This function creates a kset structure dynamically.  This structure can
+ * then be registered with the system and show up in sysfs with a call to
+ * kset_register().  When you are finished with this structure, if
+ * kset_register() has been called, call kset_unregister() and the
+ * structure will be dynamically freed when it is no longer being used.
+ *
+ * If the kset was not able to be created, NULL will be returned.
+ */
+static struct kset *kset_create(const char *name,
+				struct kset_uevent_ops *uevent_ops,
+				struct kobject *parent_kobj)
+{
+	struct kset *kset;
+
+	kset = kzalloc(sizeof(*kset), GFP_KERNEL);
+	if (!kset)
+		return NULL;
+	kobject_set_name(&kset->kobj, name);
+	kset->uevent_ops = uevent_ops;
+	kset->kobj.parent = parent_kobj;
+
+	/*
+	 * The kobject of this kset will have a type of kset_type and belong to
+	 * no kset itself.  That way we can properly free it when it is
+	 * finished being used.
+	 */
+	kset->kobj.ktype = &kset_type;
+	kset->kobj.kset = NULL;
+
+	return kset;
+}
+
+/**
+ * kset_create_and_add - create a struct kset dynamically and add it to sysfs
+ *
+ * @name: the name for the kset
+ * @uevent_ops: a struct kset_uevent_ops for the kset
+ * @parent_kobj: the parent kobject of this kset, if any.
+ *
+ * This function creates a kset structure dynamically and registers it
+ * with sysfs.  When you are finished with this structure, call
+ * kset_unregister() and the structure will be dynamically freed when it
+ * is no longer being used.
+ *
+ * If the kset was not able to be created, NULL will be returned.
+ */
+struct kset *kset_create_and_add(const char *name,
+				 struct kset_uevent_ops *uevent_ops,
+				 struct kobject *parent_kobj)
+{
+	struct kset *kset;
+	int error;
+
+	kset = kset_create(name, uevent_ops, parent_kobj);
+	if (!kset)
+		return NULL;
+	error = kset_register(kset);
+	if (error) {
+		kfree(kset);
+		return NULL;
+	}
+	return kset;
+}
+EXPORT_SYMBOL_GPL(kset_create_and_add);
+
 EXPORT_SYMBOL(kobject_init);
 EXPORT_SYMBOL(kobject_register);
 EXPORT_SYMBOL(kobject_unregister);

commit c11c4154e7ff4cebfadad849b1e22689d759c3f4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 3 21:31:08 2007 -0800

    kobject: add kobject_init_and_add function
    
    Also add a kobject_init_and_add function which bundles up what a lot of
    the current callers want to do all at once, and it properly handles the
    memory usages, unlike kobject_register();
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 329fd1126b3f..8f249408b2ec 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -390,6 +390,33 @@ int kobject_add_ng(struct kobject *kobj, struct kobject *parent,
 }
 EXPORT_SYMBOL(kobject_add_ng);
 
+/**
+ * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy
+ * @kobj: pointer to the kobject to initialize
+ * @ktype: pointer to the ktype for this kobject.
+ * @parent: pointer to the parent of this kobject.
+ * @fmt: the name of the kobject.
+ *
+ * This function combines the call to kobject_init_ng() and
+ * kobject_add_ng().  The same type of error handling after a call to
+ * kobject_add_ng() and kobject lifetime rules are the same here.
+ */
+int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
+			 struct kobject *parent, const char *fmt, ...)
+{
+	va_list args;
+	int retval;
+
+	kobject_init_ng(kobj, ktype);
+
+	va_start(args, fmt);
+	retval = kobject_add_varg(kobj, parent, fmt, args);
+	va_end(args);
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(kobject_init_and_add);
+
 /**
  *	kobject_rename - change the name of an object
  *	@kobj:	object in question.

commit 244f6cee9a928103132a722292bfa0eb84114b07
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 3 21:31:08 2007 -0800

    kobject: add kobject_add_ng function
    
    This is what the kobject_add function is going to become.
    
    Add this to the kernel and then we can convert the tree over to use it.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 60586bcc7a71..329fd1126b3f 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -324,6 +324,72 @@ void kobject_init_ng(struct kobject *kobj, struct kobj_type *ktype)
 }
 EXPORT_SYMBOL(kobject_init_ng);
 
+static int kobject_add_varg(struct kobject *kobj, struct kobject *parent,
+			    const char *fmt, va_list vargs)
+{
+	va_list aq;
+	int retval;
+
+	va_copy(aq, vargs);
+	retval = kobject_set_name_vargs(kobj, fmt, aq);
+	va_end(aq);
+	if (retval) {
+		printk(KERN_ERR "kobject: can not set name properly!\n");
+		return retval;
+	}
+	kobj->parent = parent;
+	return kobject_add(kobj);
+}
+
+/**
+ * kobject_add_ng - the main kobject add function
+ * @kobj: the kobject to add
+ * @parent: pointer to the parent of the kobject.
+ * @fmt: format to name the kobject with.
+ *
+ * The kobject name is set and added to the kobject hierarchy in this
+ * function.
+ *
+ * If @parent is set, then the parent of the @kobj will be set to it.
+ * If @parent is NULL, then the parent of the @kobj will be set to the
+ * kobject associted with the kset assigned to this kobject.  If no kset
+ * is assigned to the kobject, then the kobject will be located in the
+ * root of the sysfs tree.
+ *
+ * If this function returns an error, kobject_put() must be called to
+ * properly clean up the memory associated with the object.
+ *
+ * If the function is successful, the only way to properly clean up the
+ * memory is with a call to kobject_del(), in which case, a call to
+ * kobject_put() is not necessary (kobject_del() does the final
+ * kobject_put() to call the release function in the ktype's release
+ * pointer.)
+ *
+ * Under no instance should the kobject that is passed to this function
+ * be directly freed with a call to kfree(), that can leak memory.
+ *
+ * Note, no uevent will be created with this call, the caller should set
+ * up all of the necessary sysfs files for the object and then call
+ * kobject_uevent() with the UEVENT_ADD parameter to ensure that
+ * userspace is properly notified of this kobject's creation.
+ */
+int kobject_add_ng(struct kobject *kobj, struct kobject *parent,
+		   const char *fmt, ...)
+{
+	va_list args;
+	int retval;
+
+	if (!kobj)
+		return -EINVAL;
+
+	va_start(args, fmt);
+	retval = kobject_add_varg(kobj, parent, fmt, args);
+	va_end(args);
+
+	return retval;
+}
+EXPORT_SYMBOL(kobject_add_ng);
+
 /**
  *	kobject_rename - change the name of an object
  *	@kobj:	object in question.

commit e86000d042d23904bbb609af2f8618a541cf129b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 3 21:31:08 2007 -0800

    kobject: add kobject_init_ng function
    
    This is what the kobject_init function is going to become.
    
    Add this to the kernel and then we can convert the tree over to use it.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index a152036db006..60586bcc7a71 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -282,6 +282,48 @@ int kobject_set_name(struct kobject *kobj, const char *fmt, ...)
 }
 EXPORT_SYMBOL(kobject_set_name);
 
+/**
+ * kobject_init_ng - initialize a kobject structure
+ * @kobj: pointer to the kobject to initialize
+ * @ktype: pointer to the ktype for this kobject.
+ *
+ * This function will properly initialize a kobject such that it can then
+ * be passed to the kobject_add() call.
+ *
+ * After this function is called, the kobject MUST be cleaned up by a call
+ * to kobject_put(), not by a call to kfree directly to ensure that all of
+ * the memory is cleaned up properly.
+ */
+void kobject_init_ng(struct kobject *kobj, struct kobj_type *ktype)
+{
+	char *err_str;
+
+	if (!kobj) {
+		err_str = "invalid kobject pointer!";
+		goto error;
+	}
+	if (!ktype) {
+		err_str = "must have a ktype to be initialized properly!\n";
+		goto error;
+	}
+	if (atomic_read(&kobj->kref.refcount)) {
+		/* do not error out as sometimes we can recover */
+		printk(KERN_ERR "kobject: reference count is already set, "
+		       "something is seriously wrong.\n");
+		dump_stack();
+	}
+
+	kref_init(&kobj->kref);
+	INIT_LIST_HEAD(&kobj->entry);
+	kobj->ktype = ktype;
+	return;
+
+error:
+	printk(KERN_ERR "kobject: %s\n", err_str);
+	dump_stack();
+}
+EXPORT_SYMBOL(kobject_init_ng);
+
 /**
  *	kobject_rename - change the name of an object
  *	@kobj:	object in question.

commit 18041f4775688af073d9b3ab0ffc262c1847e60b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 3 21:31:08 2007 -0800

    kobject: make kobject_cleanup be static
    
    No one except the kobject core calls it so make the function static.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4a310e55a886..a152036db006 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -436,12 +436,11 @@ struct kobject * kobject_get(struct kobject * kobj)
 	return kobj;
 }
 
-/**
- *	kobject_cleanup - free kobject resources. 
- *	@kobj:	object.
+/*
+ * kobject_cleanup - free kobject resources.
+ * @kobj: object to cleanup
  */
-
-void kobject_cleanup(struct kobject * kobj)
+static void kobject_cleanup(struct kobject *kobj)
 {
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj->kset;

commit 663a47430b361f863b515752a97166a7a4b92d35
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 29 18:32:47 2007 -0500

    kobject: fix up kobject_set_name to use kvasprintf
    
    Kay pointed out that kobject_set_name was being very stupid, doing two
    allocations for every call, when it should just be using the kernel
    function kvasprintf() instead.
    
    This change adds the internal kobject_set_name_vargs() function, which
    other follow-on patches will be using.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 9500339ae024..4a310e55a886 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -232,60 +232,53 @@ int kobject_register(struct kobject * kobj)
 	return error;
 }
 
+/**
+ * kobject_set_name_vargs - Set the name of an kobject
+ * @kobj: struct kobject to set the name of
+ * @fmt: format string used to build the name
+ * @vargs: vargs to format the string.
+ */
+static int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
+				  va_list vargs)
+{
+	va_list aq;
+	char *name;
+
+	va_copy(aq, vargs);
+	name = kvasprintf(GFP_KERNEL, fmt, vargs);
+	va_end(aq);
+
+	if (!name)
+		return -ENOMEM;
+
+	/* Free the old name, if necessary. */
+	kfree(kobj->k_name);
+
+	/* Now, set the new name */
+	kobj->k_name = name;
+
+	return 0;
+}
 
 /**
  * kobject_set_name - Set the name of a kobject
- * @kobj: kobject to name
+ * @kobj: struct kobject to set the name of
  * @fmt: format string used to build the name
  *
  * This sets the name of the kobject.  If you have already added the
  * kobject to the system, you must call kobject_rename() in order to
  * change the name of the kobject.
  */
-int kobject_set_name(struct kobject * kobj, const char * fmt, ...)
+int kobject_set_name(struct kobject *kobj, const char *fmt, ...)
 {
-	int error = 0;
-	int limit;
-	int need;
 	va_list args;
-	char *name;
+	int retval;
 
-	/* find out how big a buffer we need */
-	name = kmalloc(1024, GFP_KERNEL);
-	if (!name) {
-		error = -ENOMEM;
-		goto done;
-	}
 	va_start(args, fmt);
-	need = vsnprintf(name, 1024, fmt, args);
+	retval = kobject_set_name_vargs(kobj, fmt, args);
 	va_end(args);
-	kfree(name);
 
-	/* Allocate the new space and copy the string in */
-	limit = need + 1;
-	name = kmalloc(limit, GFP_KERNEL);
-	if (!name) {
-		error = -ENOMEM;
-		goto done;
-	}
-	va_start(args, fmt);
-	need = vsnprintf(name, limit, fmt, args);
-	va_end(args);
-
-	/* something wrong with the string we copied? */
-	if (need >= limit) {
-		kfree(name);
-		error = -EFAULT;
-		goto done;
-	}
-
-	/* Free the old name, if necessary. */
-	kfree(kobj->k_name);
-
-	/* Now, set the new name */
-	kobj->k_name = name;
-done:
-	return error;
+	return retval;
 }
 EXPORT_SYMBOL(kobject_set_name);
 

commit 7a83d456a86d559a6347115d206d23774bc152d9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Oct 24 21:52:56 2007 -0700

    kobject: remove incorrect comment in kobject_rename
    
    As pointed out by Kay.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 3590f022a609..9500339ae024 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -334,8 +334,6 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);
 	envp[0] = devpath_string;
 	envp[1] = NULL;
-	/* Note : if we want to send the new name alone, not the full path,
-	 * we could probably use kobject_name(kobj); */
 
 	error = sysfs_rename_dir(kobj, new_name);
 

commit 8c4606b1a4f6eb09344294b7f11641f36cd402af
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 4 14:45:47 2007 +0800

    kobject: fix the documentation of how kobject_set_name works
    
    Thanks to Dave Young <hidave.darkstar@gmail.com> for pointing out that I
    forgot to update the comment when I rewrote kobject_set_name.
    
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index b52e9f4ef371..3590f022a609 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -234,13 +234,13 @@ int kobject_register(struct kobject * kobj)
 
 
 /**
- *	kobject_set_name - Set the name of an object
- *	@kobj:	object.
- *	@fmt:	format string used to build the name
+ * kobject_set_name - Set the name of a kobject
+ * @kobj: kobject to name
+ * @fmt: format string used to build the name
  *
- *	If strlen(name) >= KOBJ_NAME_LEN, then use a dynamically allocated
- *	string that @kobj->k_name points to. Otherwise, use the static 
- *	@kobj->name array.
+ * This sets the name of the kobject.  If you have already added the
+ * kobject to the system, you must call kobject_rename() in order to
+ * change the name of the kobject.
  */
 int kobject_set_name(struct kobject * kobj, const char * fmt, ...)
 {

commit 71409a498e96a421bdc20e7275ebc4fab8b14cdc
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Nov 5 13:59:11 2007 +0100

    kobject: two typo fixes
    
    This fixes two typos from commit
    34358c26a2c96b2a068dc44e0ac602106a466bce.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index a7e3bf4d3c70..b52e9f4ef371 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -313,8 +313,8 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 		struct kobject *temp_kobj;
 		temp_kobj = kset_find_obj(kobj->kset, new_name);
 		if (temp_kobj) {
-			printk(KERN_WARNING "kobject '%s' can not be renamed "
-			       "to '%s' as '%s' is already in existance.\n",
+			printk(KERN_WARNING "kobject '%s' cannot be renamed "
+			       "to '%s' as '%s' is already in existence.\n",
 			       kobject_name(kobj), new_name, new_name);
 			kobject_put(temp_kobj);
 			return -EINVAL;

commit 34358c26a2c96b2a068dc44e0ac602106a466bce
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Oct 24 16:52:31 2007 -0700

    kobject: check for duplicate names in kobject_rename
    
    This should catch any duplicate names before we try to tell sysfs to
    rename the object.  This happens a lot with older versions of udev and
    the network rename scripts.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 03d40360ff1b..a7e3bf4d3c70 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -308,6 +308,19 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	if (!kobj->parent)
 		return -EINVAL;
 
+	/* see if this name is already in use */
+	if (kobj->kset) {
+		struct kobject *temp_kobj;
+		temp_kobj = kset_find_obj(kobj->kset, new_name);
+		if (temp_kobj) {
+			printk(KERN_WARNING "kobject '%s' can not be renamed "
+			       "to '%s' as '%s' is already in existance.\n",
+			       kobject_name(kobj), new_name, new_name);
+			kobject_put(temp_kobj);
+			return -EINVAL;
+		}
+	}
+
 	devpath = kobject_get_path(kobj, GFP_KERNEL);
 	if (!devpath) {
 		error = -ENOMEM;

commit f0e7e1bd77d450ebfa12153b90f93ad46616ab4a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Sep 27 14:48:53 2007 -0700

    kobject: update the copyrights
    
    I've been hacking on these files for a while now, might as well make it
    official...
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index b7e0646f7977..03d40360ff1b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -2,6 +2,8 @@
  * kobject.c - library routines for handling generic kernel objects
  *
  * Copyright (c) 2002-2003 Patrick Mochel <mochel@osdl.org>
+ * Copyright (c) 2006-2007 Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (c) 2006-2007 Novell Inc.
  *
  * This file is released under the GPLv2.
  *

commit e4bc16621d82ee1fd3685dcbf889a7c49891847b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 26 11:12:00 2007 -0700

    driver core: remove subsystem_init()
    
    There is only one user of it, and it is only a wrapper for kset_init().
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index fc6db6b4bfc5..b7e0646f7977 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -617,11 +617,6 @@ struct kobject * kset_find_obj(struct kset * kset, const char * name)
 	return ret;
 }
 
-void subsystem_init(struct kset *s)
-{
-	kset_init(s);
-}
-
 int subsystem_register(struct kset *s)
 {
 	return kset_register(s);

commit a4e8b912541d5372ae049a3b7c1979968e52c40b
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Sep 20 16:05:12 2007 +0900

    sysfs: move sysfs file poll implementation to sysfs_open_dirent
    
    Sysfs file poll implementation is scattered over sysfs and kobject.
    Event numbering is done in sysfs_dirent but wait itself is done on
    kobject.  This not only unecessarily bloats both kobject and
    sysfs_dirent but is also buggy - if a sysfs_dirent is removed while
    there still are pollers, the associaton betwen the kobject and
    sysfs_dirent breaks and kobject may be freed with the pollers still
    sleeping on it.
    
    This patch moves whole poll implementation into sysfs_open_dirent.
    Each time a sysfs_open_dirent is created, event number restarts from 1
    and pollers sleep on sysfs_open_dirent.  As event sequence number is
    meaningless without any open file and pollers should have open file
    and thus sysfs_open_dirent, this ephemeral event counting works and is
    a saner implementation.
    
    This patch fixes the dnagling sleepers bug and reduces the sizes of
    kobject and sysfs_dirent by one pointer.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index e8181d3cec34..fc6db6b4bfc5 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -131,7 +131,6 @@ void kobject_init(struct kobject * kobj)
 		return;
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
-	init_waitqueue_head(&kobj->poll);
 	kobj->kset = kset_get(kobj->kset);
 }
 

commit 90bc61359de0148f8627073d68a22edc7ed9893d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Jul 31 19:15:08 2007 +0900

    sysfs: Remove first pass at shadow directory support
    
    While shadow directories appear to be a good idea, the current scheme
    of controlling their creation and destruction outside of sysfs appears
    to be a locking and maintenance nightmare in the face of sysfs
    directories dynamically coming and going.  Which can now occur for
    directories containing network devices when CONFIG_SYSFS_DEPRECATED is
    not set.
    
    This patch removes everything from the initial shadow directory support
    that allowed the shadow directory creation to be controlled at a higher
    level.  So except for a few bits of sysfs_rename_dir everything from
    commit b592fcfe7f06c15ec11774b5be7ce0de3aa86e73 is now gone.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 10ae2ebeaf96..e8181d3cec34 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -44,11 +44,11 @@ static int populate_dir(struct kobject * kobj)
 	return error;
 }
 
-static int create_dir(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
+static int create_dir(struct kobject * kobj)
 {
 	int error = 0;
 	if (kobject_name(kobj)) {
-		error = sysfs_create_dir(kobj, shadow_parent);
+		error = sysfs_create_dir(kobj);
 		if (!error) {
 			if ((error = populate_dir(kobj)))
 				sysfs_remove_dir(kobj);
@@ -157,12 +157,11 @@ static void unlink(struct kobject * kobj)
 }
 
 /**
- *	kobject_shadow_add - add an object to the hierarchy.
+ *	kobject_add - add an object to the hierarchy.
  *	@kobj:	object.
- *	@shadow_parent: sysfs directory to add to.
  */
 
-int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
+int kobject_add(struct kobject * kobj)
 {
 	int error = 0;
 	struct kobject * parent;
@@ -194,7 +193,7 @@ int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 		kobj->parent = parent;
 	}
 
-	error = create_dir(kobj, shadow_parent);
+	error = create_dir(kobj);
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
@@ -215,16 +214,6 @@ int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 	return error;
 }
 
-/**
- *	kobject_add - add an object to the hierarchy.
- *	@kobj:	object.
- */
-int kobject_add(struct kobject * kobj)
-{
-	return kobject_shadow_add(kobj, NULL);
-}
-
-
 /**
  *	kobject_register - initialize and add an object.
  *	@kobj:	object in question.
@@ -334,7 +323,7 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	/* Note : if we want to send the new name alone, not the full path,
 	 * we could probably use kobject_name(kobj); */
 
-	error = sysfs_rename_dir(kobj, kobj->parent->sd, new_name);
+	error = sysfs_rename_dir(kobj, new_name);
 
 	/* This function is mostly/only used for network interface.
 	 * Some hotplug package track interfaces by their name and
@@ -350,27 +339,6 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	return error;
 }
 
-/**
- *	kobject_rename - change the name of an object
- *	@kobj:	object in question.
- *	@new_parent: object's new parent
- *	@new_name: object's new name
- */
-
-int kobject_shadow_rename(struct kobject *kobj,
-			  struct sysfs_dirent *new_parent, const char *new_name)
-{
-	int error = 0;
-
-	kobj = kobject_get(kobj);
-	if (!kobj)
-		return -EINVAL;
-	error = sysfs_rename_dir(kobj, new_parent, new_name);
-	kobject_put(kobj);
-
-	return error;
-}
-
 /**
  *	kobject_move - move object to another parent
  *	@kobj:	object in question.

commit ce2c9cb0259acd2aed184499ebe41ab00da13b25
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 12 15:06:57 2007 -0700

    kobject: remove the static array for the name
    
    Due to historical reasons, struct kobject contained a static array for
    the name, and a dynamic pointer in case the name got bigger than the
    array.  That's just dumb, as people didn't always know which variable to
    reference, even with the accessor for the kobject name.
    
    This patch removes the static array, potentially saving a lot of memory
    as the majority of kobjects do not have a very long name.
    
    Thanks to Kay for the idea to do this.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1326041213dd..10ae2ebeaf96 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -170,7 +170,7 @@ int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 	if (!(kobj = kobject_get(kobj)))
 		return -ENOENT;
 	if (!kobj->k_name)
-		kobj->k_name = kobj->name;
+		kobject_set_name(kobj, "NO_NAME");
 	if (!*kobj->k_name) {
 		pr_debug("kobject attempted to be registered with no name!\n");
 		WARN_ON(1);
@@ -181,7 +181,7 @@ int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 
 	pr_debug("kobject %s: registering. parent: %s, set: %s\n",
 		 kobject_name(kobj), parent ? kobject_name(parent) : "<NULL>", 
-		 kobj->kset ? kobj->kset->kobj.name : "<NULL>" );
+		 kobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>" );
 
 	if (kobj->kset) {
 		spin_lock(&kobj->kset->list_lock);
@@ -255,54 +255,50 @@ int kobject_register(struct kobject * kobj)
 int kobject_set_name(struct kobject * kobj, const char * fmt, ...)
 {
 	int error = 0;
-	int limit = KOBJ_NAME_LEN;
+	int limit;
 	int need;
 	va_list args;
-	char * name;
+	char *name;
 
-	/* 
-	 * First, try the static array 
-	 */
-	va_start(args,fmt);
-	need = vsnprintf(kobj->name,limit,fmt,args);
+	/* find out how big a buffer we need */
+	name = kmalloc(1024, GFP_KERNEL);
+	if (!name) {
+		error = -ENOMEM;
+		goto done;
+	}
+	va_start(args, fmt);
+	need = vsnprintf(name, 1024, fmt, args);
 	va_end(args);
-	if (need < limit) 
-		name = kobj->name;
-	else {
-		/* 
-		 * Need more space? Allocate it and try again 
-		 */
-		limit = need + 1;
-		name = kmalloc(limit,GFP_KERNEL);
-		if (!name) {
-			error = -ENOMEM;
-			goto Done;
-		}
-		va_start(args,fmt);
-		need = vsnprintf(name,limit,fmt,args);
-		va_end(args);
-
-		/* Still? Give up. */
-		if (need >= limit) {
-			kfree(name);
-			error = -EFAULT;
-			goto Done;
-		}
+	kfree(name);
+
+	/* Allocate the new space and copy the string in */
+	limit = need + 1;
+	name = kmalloc(limit, GFP_KERNEL);
+	if (!name) {
+		error = -ENOMEM;
+		goto done;
+	}
+	va_start(args, fmt);
+	need = vsnprintf(name, limit, fmt, args);
+	va_end(args);
+
+	/* something wrong with the string we copied? */
+	if (need >= limit) {
+		kfree(name);
+		error = -EFAULT;
+		goto done;
 	}
 
 	/* Free the old name, if necessary. */
-	if (kobj->k_name && kobj->k_name != kobj->name)
-		kfree(kobj->k_name);
+	kfree(kobj->k_name);
 
 	/* Now, set the new name */
 	kobj->k_name = name;
- Done:
+done:
 	return error;
 }
-
 EXPORT_SYMBOL(kobject_set_name);
 
-
 /**
  *	kobject_rename - change the name of an object
  *	@kobj:	object in question.
@@ -477,13 +473,16 @@ void kobject_cleanup(struct kobject * kobj)
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj->kset;
 	struct kobject * parent = kobj->parent;
+	const char *name = kobj->k_name;
 
 	pr_debug("kobject %s: cleaning up\n",kobject_name(kobj));
-	if (kobj->k_name != kobj->name)
-		kfree(kobj->k_name);
-	kobj->k_name = NULL;
-	if (t && t->release)
+	if (t && t->release) {
 		t->release(kobj);
+		/* If we have a release function, we can guess that this was
+		 * not a statically allocated kobject, so we should be safe to
+		 * free the name */
+		kfree(name);
+	}
 	if (s)
 		kset_put(s);
 	kobject_put(parent);

commit 1ef4cfac01fb5e98900f5bdb2a722aac1daff11b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 12 15:06:57 2007 -0700

    Driver core: remove subsys_get()
    
    There are no more subsystems, it's a kset now so remove the function and
    the only two users, which are in the driver core.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 0aa4e906916a..1326041213dd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -679,7 +679,7 @@ int subsys_create_file(struct kset *s, struct subsys_attribute *a)
 	if (!s || !a)
 		return -EINVAL;
 
-	if (subsys_get(s)) {
+	if (kset_get(s)) {
 		error = sysfs_create_file(&s->kobj, &a->attr);
 		kset_put(s);
 	}

commit 6e9d930d167f8957a12a80515f3c417a98296378
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 12 15:06:57 2007 -0700

    Driver core: remove subsys_put()
    
    There are no more subsystems, it's a kset now so remove the function and
    the only two users, which are in the driver core.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 4b08e0ff95c8..0aa4e906916a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -681,7 +681,7 @@ int subsys_create_file(struct kset *s, struct subsys_attribute *a)
 
 	if (subsys_get(s)) {
 		error = sysfs_create_file(&s->kobj, &a->attr);
-		subsys_put(s);
+		kset_put(s);
 	}
 	return error;
 }

commit 608e266a2d4e62c1b98c1c573064b6afe8c06a58
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 04:27:22 2007 +0900

    sysfs: make kobj point to sysfs_dirent instead of dentry
    
    As kobj sysfs dentries and inodes are gonna be made reclaimable,
    dentry can't be used as naming token for sysfs file/directory, replace
    kobj->dentry with kobj->sd.  The only external interface change is
    shadow directory handling.  All other changes are contained in kobj
    and sysfs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index b4ebd7631700..4b08e0ff95c8 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -44,7 +44,7 @@ static int populate_dir(struct kobject * kobj)
 	return error;
 }
 
-static int create_dir(struct kobject * kobj, struct dentry *shadow_parent)
+static int create_dir(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 {
 	int error = 0;
 	if (kobject_name(kobj)) {
@@ -162,7 +162,7 @@ static void unlink(struct kobject * kobj)
  *	@shadow_parent: sysfs directory to add to.
  */
 
-int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
+int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
 {
 	int error = 0;
 	struct kobject * parent;
@@ -338,7 +338,7 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	/* Note : if we want to send the new name alone, not the full path,
 	 * we could probably use kobject_name(kobj); */
 
-	error = sysfs_rename_dir(kobj, kobj->parent->dentry, new_name);
+	error = sysfs_rename_dir(kobj, kobj->parent->sd, new_name);
 
 	/* This function is mostly/only used for network interface.
 	 * Some hotplug package track interfaces by their name and
@@ -361,8 +361,8 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
  *	@new_name: object's new name
  */
 
-int kobject_shadow_rename(struct kobject * kobj, struct dentry *new_parent,
-			  const char *new_name)
+int kobject_shadow_rename(struct kobject *kobj,
+			  struct sysfs_dirent *new_parent, const char *new_name)
 {
 	int error = 0;
 

commit 80f03e349f06a261a8e980bf6005c61811a0d66a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat May 26 11:21:36 2007 +0200

    Driver core: add missing kset uevent
    
    We get uevents for a bus/class going away, but not one registering.
    Add the missing uevent in kset_register(), which will send an
    event for a new bus/class. Suppress all unwanted uevents for bus
    subdirectories like /bus/*/devices/, /bus/*/drivers/.
    
    Now we get for module usbcore:
      add      /module/usbcore (module)
      add      /bus/usb (bus)
      add      /class/usb_host (class)
      add      /bus/usb/drivers/hub (drivers)
      add      /bus/usb/drivers/usb (drivers)
      remove   /bus/usb/drivers/usb (drivers)
      remove   /bus/usb/drivers/hub (drivers)
      remove   /class/usb_host (class)
      remove   /bus/usb (bus)
      remove   /module/usbcore (module)
    
    instead of:
      add      /module/usbcore (module)
      add      /bus/usb/drivers/hub (drivers)
      add      /bus/usb/drivers/usb (drivers)
      remove   /bus/usb/drivers/usb (drivers)
      remove   /bus/usb/drivers/hub (drivers)
      remove   /class/usb_host (class)
      remove   /bus/usb/drivers (bus)
      remove   /bus/usb/devices (bus)
      remove   /bus/usb (bus)
      remove   /module/usbcore (module)
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index ac1520651b9b..b4ebd7631700 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -597,10 +597,17 @@ int kset_add(struct kset * k)
 
 int kset_register(struct kset * k)
 {
+	int err;
+
 	if (!k)
 		return -EINVAL;
+
 	kset_init(k);
-	return kset_add(k);
+	err = kset_add(k);
+	if (err)
+		return err;
+	kobject_uevent(&k->kobj, KOBJ_ADD);
+	return 0;
 }
 
 

commit 5c73a3fba6dd2b410de378f648bc9851ffa7201a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 7 15:05:15 2007 -0700

    kobject: use the proper printk level for kobject error
    
    Thanks to Jean Delvare <khali@linux-fr.org> for pointing it out to me.
    
    Cc: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index fc5f3f6e7329..ac1520651b9b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -202,14 +202,14 @@ int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			printk("kobject_add failed for %s with -EEXIST, "
-			       "don't try to register things with the "
-			       "same name in the same directory.\n",
+			printk(KERN_ERR "kobject_add failed for %s with "
+			       "-EEXIST, don't try to register things with "
+			       "the same name in the same directory.\n",
 			       kobject_name(kobj));
 		else
-			printk("kobject_add failed for %s (%d)\n",
+			printk(KERN_ERR "kobject_add failed for %s (%d)\n",
 			       kobject_name(kobj), error);
-		 dump_stack();
+		dump_stack();
 	}
 
 	return error;

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index cecf2fbede3e..fc5f3f6e7329 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -582,22 +582,10 @@ void kset_init(struct kset * k)
 /**
  *	kset_add - add a kset object to the hierarchy.
  *	@k:	kset.
- *
- *	Simply, this adds the kset's embedded kobject to the 
- *	hierarchy. 
- *	We also try to make sure that the kset's embedded kobject
- *	has a parent before it is added. We only care if the embedded
- *	kobject is not part of a kset itself, since kobject_add()
- *	assigns a parent in that case. 
- *	If that is the case, and the kset has a controlling subsystem,
- *	then we set the kset's parent to be said subsystem. 
  */
 
 int kset_add(struct kset * k)
 {
-	if (!k->kobj.parent && !k->kobj.kset && k->subsys)
-		k->kobj.parent = &k->subsys->kset.kobj;
-
 	return kobject_add(&k->kobj);
 }
 
@@ -656,53 +644,28 @@ struct kobject * kset_find_obj(struct kset * kset, const char * name)
 	return ret;
 }
 
-
-void subsystem_init(struct subsystem * s)
+void subsystem_init(struct kset *s)
 {
-	kset_init(&s->kset);
+	kset_init(s);
 }
 
-/**
- *	subsystem_register - register a subsystem.
- *	@s:	the subsystem we're registering.
- *
- *	Once we register the subsystem, we want to make sure that 
- *	the kset points back to this subsystem.
- */
-
-int subsystem_register(struct subsystem * s)
+int subsystem_register(struct kset *s)
 {
-	int error;
-
-	if (!s)
-		return -EINVAL;
-
-	subsystem_init(s);
-	pr_debug("subsystem %s: registering\n",s->kset.kobj.name);
-
-	if (!(error = kset_add(&s->kset))) {
-		if (!s->kset.subsys)
-			s->kset.subsys = s;
-	}
-	return error;
+	return kset_register(s);
 }
 
-void subsystem_unregister(struct subsystem * s)
+void subsystem_unregister(struct kset *s)
 {
-	if (!s)
-		return;
-	pr_debug("subsystem %s: unregistering\n",s->kset.kobj.name);
-	kset_unregister(&s->kset);
+	kset_unregister(s);
 }
 
-
 /**
  *	subsystem_create_file - export sysfs attribute file.
  *	@s:	subsystem.
  *	@a:	subsystem attribute descriptor.
  */
 
-int subsys_create_file(struct subsystem * s, struct subsys_attribute * a)
+int subsys_create_file(struct kset *s, struct subsys_attribute *a)
 {
 	int error = 0;
 
@@ -710,28 +673,12 @@ int subsys_create_file(struct subsystem * s, struct subsys_attribute * a)
 		return -EINVAL;
 
 	if (subsys_get(s)) {
-		error = sysfs_create_file(&s->kset.kobj,&a->attr);
+		error = sysfs_create_file(&s->kobj, &a->attr);
 		subsys_put(s);
 	}
 	return error;
 }
 
-
-/**
- *	subsystem_remove_file - remove sysfs attribute file.
- *	@s:	subsystem.
- *	@a:	attribute desciptor.
- */
-#if 0
-void subsys_remove_file(struct subsystem * s, struct subsys_attribute * a)
-{
-	if (subsys_get(s)) {
-		sysfs_remove_file(&s->kset.kobj,&a->attr);
-		subsys_put(s);
-	}
-}
-#endif  /*  0  */
-
 EXPORT_SYMBOL(kobject_init);
 EXPORT_SYMBOL(kobject_register);
 EXPORT_SYMBOL(kobject_unregister);

commit 2753133eb3321feb81dcb9c88141dd2aa5973ee1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Apr 6 10:47:11 2007 -0600

    kobject: Comment and warning fixes to kobject.c
    
    This dots some i's and crosses some t's after left over from when
    kobject_kset_add_dir was built from kobject_add_dir.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2882aff6f3d1..cecf2fbede3e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -519,7 +519,7 @@ static struct kobj_type dir_ktype = {
 };
 
 /**
- *	kobject__kset_add_dir - add sub directory of object.
+ *	kobject_kset_add_dir - add sub directory of object.
  *	@kset:		kset the directory is belongs to.
  *	@parent:	object in which a directory is created.
  *	@name:	directory name.
@@ -545,8 +545,8 @@ struct kobject *kobject_kset_add_dir(struct kset *kset,
 	kobject_set_name(k, name);
 	ret = kobject_register(k);
 	if (ret < 0) {
-		printk(KERN_WARNING "kobject_add_dir: "
-			"kobject_register error: %d\n", ret);
+		printk(KERN_WARNING "%s: kobject_register error: %d\n",
+			__func__, ret);
 		kobject_del(k);
 		return NULL;
 	}
@@ -554,6 +554,13 @@ struct kobject *kobject_kset_add_dir(struct kset *kset,
 	return k;
 }
 
+/**
+ *	kobject_add_dir - add sub directory of object.
+ *	@parent:	object in which a directory is created.
+ *	@name:	directory name.
+ *
+ *	Add a plain directory object as child of given object.
+ */
 struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 {
 	return kobject_kset_add_dir(NULL, parent, name);

commit 4628803062d93dadc6ba8e801fd075526904a38c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 9 11:52:31 2007 -0400

    kobject core: remove rwsem from struct subsystem
    
    It isn't used at all by the driver core anymore, and the few usages of
    it within the kernel have now all been fixed as most of them were using
    it incorrectly.  So remove it.
    
    Now the whole struct subsys can be removed from the system, but that's
    for a later patch...
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index eb251aae78dd..2882aff6f3d1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -652,7 +652,6 @@ struct kobject * kset_find_obj(struct kset * kset, const char * name)
 
 void subsystem_init(struct subsystem * s)
 {
-	init_rwsem(&s->rwsem);
 	kset_init(&s->kset);
 }
 
@@ -661,8 +660,7 @@ void subsystem_init(struct subsystem * s)
  *	@s:	the subsystem we're registering.
  *
  *	Once we register the subsystem, we want to make sure that 
- *	the kset points back to this subsystem for correct usage of 
- *	the rwsem. 
+ *	the kset points back to this subsystem.
  */
 
 int subsystem_register(struct subsystem * s)

commit 88db4721d47bc59b92d46de04e21c7975ea983f2
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Tue Apr 10 14:35:27 2007 +0200

    kobject: kobject_add() reference leak
    
    We leak a reference if we attempt to add a kobject with no name.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index db1d23707eb1..eb251aae78dd 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -174,6 +174,7 @@ int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
 	if (!*kobj->k_name) {
 		pr_debug("kobject attempted to be registered with no name!\n");
 		WARN_ON(1);
+		kobject_put(kobj);
 		return -EINVAL;
 	}
 	parent = kobject_get(kobj->parent);

commit ca2f37dbc5324c7278577731033a358f1f86050a
Author: Jean Tourrilhes <jt@hpl.hp.com>
Date:   Wed Mar 7 10:49:30 2007 -0800

    Driver core: notify userspace of network device renames
    
    Provide rename event for when we rename network devices.
    
    Signed-off-by: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index bbbfab4145e6..db1d23707eb1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -311,13 +311,43 @@ EXPORT_SYMBOL(kobject_set_name);
 int kobject_rename(struct kobject * kobj, const char *new_name)
 {
 	int error = 0;
+	const char *devpath = NULL;
+	char *devpath_string = NULL;
+	char *envp[2];
 
 	kobj = kobject_get(kobj);
 	if (!kobj)
 		return -EINVAL;
 	if (!kobj->parent)
 		return -EINVAL;
+
+	devpath = kobject_get_path(kobj, GFP_KERNEL);
+	if (!devpath) {
+		error = -ENOMEM;
+		goto out;
+	}
+	devpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);
+	if (!devpath_string) {
+		error = -ENOMEM;
+		goto out;
+	}
+	sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);
+	envp[0] = devpath_string;
+	envp[1] = NULL;
+	/* Note : if we want to send the new name alone, not the full path,
+	 * we could probably use kobject_name(kobj); */
+
 	error = sysfs_rename_dir(kobj, kobj->parent->dentry, new_name);
+
+	/* This function is mostly/only used for network interface.
+	 * Some hotplug package track interfaces by their name and
+	 * therefore want to know when the name is changed by the user. */
+	if (!error)
+		kobject_uevent_env(kobj, KOBJ_MOVE, envp);
+
+out:
+	kfree(devpath_string);
+	kfree(devpath);
 	kobject_put(kobj);
 
 	return error;

commit 460f7e9a1bde2c74f060f7ce0a308dab4be6a56b
Author: Dmitriy Monakhov <dmonakhov@openvz.org>
Date:   Sat Mar 10 14:00:10 2007 +0300

    kobject: kobject_shadow_add cleanup
    
     - correct function name in comments
     - parrent assignment does metter only inside "if" block,
       so move it inside this block.
    
    Signed-off-by: Monakhov Dmitriy <dmonakhov@openvz.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index f66455155606..bbbfab4145e6 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -157,7 +157,7 @@ static void unlink(struct kobject * kobj)
 }
 
 /**
- *	kobject_add - add an object to the hierarchy.
+ *	kobject_shadow_add - add an object to the hierarchy.
  *	@kobj:	object.
  *	@shadow_parent: sysfs directory to add to.
  */
@@ -190,8 +190,8 @@ int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
 
 		list_add_tail(&kobj->entry,&kobj->kset->list);
 		spin_unlock(&kobj->kset->list_lock);
+		kobj->parent = parent;
 	}
-	kobj->parent = parent;
 
 	error = create_dir(kobj, shadow_parent);
 	if (error) {

commit 864062457a2e444227bd368ca5f2a2b740de604f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Mar 14 03:25:56 2007 +0100

    driver core: fix namespace issue with devices assigned to classes
    
      - uses a kset in "struct class" to keep track of all directories
        belonging to this class
      - merges with the /sys/devices/virtual logic.
      - removes the namespace-dir if the last member of that class
        leaves the directory.
    
    There may be locking or refcounting fixes left, I stopped when it seemed
    to work with network and sound modules. :)
    
    From: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 057921c5945a..f66455155606 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -488,13 +488,15 @@ static struct kobj_type dir_ktype = {
 };
 
 /**
- *	kobject_add_dir - add sub directory of object.
+ *	kobject__kset_add_dir - add sub directory of object.
+ *	@kset:		kset the directory is belongs to.
  *	@parent:	object in which a directory is created.
  *	@name:	directory name.
  *
  *	Add a plain directory object as child of given object.
  */
-struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
+struct kobject *kobject_kset_add_dir(struct kset *kset,
+				     struct kobject *parent, const char *name)
 {
 	struct kobject *k;
 	int ret;
@@ -506,6 +508,7 @@ struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 	if (!k)
 		return NULL;
 
+	k->kset = kset;
 	k->parent = parent;
 	k->ktype = &dir_ktype;
 	kobject_set_name(k, name);
@@ -520,6 +523,11 @@ struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 	return k;
 }
 
+struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
+{
+	return kobject_kset_add_dir(NULL, parent, name);
+}
+
 /**
  *	kset_init - initialize a kset for use
  *	@k:	kset 

commit 9e993efb0da827634778554070f3c3ec4bdade33
Author: Dmitriy Monakhov <dmonakhov@sw.ru>
Date:   Sat Mar 3 16:11:21 2007 +0300

    kobject: new_device->kref wasn't putted after error in kobject_move()
    
    If error happen we jump to "out" label, in this case new_device not yet
    became the parent but it wasn't putted.
    
    Signed-off-by: Monakhov Dmitriy <dmonakhov@openvz.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index f4f6176dcd12..057921c5945a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -385,9 +385,11 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 		goto out;
 	old_parent = kobj->parent;
 	kobj->parent = new_parent;
+	new_parent = NULL;
 	kobject_put(old_parent);
 	kobject_uevent_env(kobj, KOBJ_MOVE, envp);
 out:
+	kobject_put(new_parent);
 	kobject_put(kobj);
 	kfree(devpath_string);
 	kfree(devpath);

commit 733abe4fff3afa13e301bc8bc5bee9aac4b59fdc
Merge: 5fe8252fc3a2 81bb0e198b46
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 19 12:59:55 2007 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6:
      PCI: Make PCI device numa-node attribute visible in sysfs
      PCI: add systems for automatic breadth-first device sorting
      PCI: PCI devices get assigned redundant IRQs
      PCI: Make CARDBUS_MEM_SIZE and CARDBUS_IO_SIZE boot options
      PCI: pci.txt fix __devexit() usage
      PCI/sysfs/kobject kernel-doc fixes

commit f95d882d81ee731be2a4a3b34f86810e29b68836
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Feb 10 14:41:56 2007 -0800

    PCI/sysfs/kobject kernel-doc fixes
    
    Fix kernel-doc warnings in PCI, sysfs, and kobject files.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2782f49e906e..4572809d1b95 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -326,6 +326,7 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 /**
  *	kobject_rename - change the name of an object
  *	@kobj:	object in question.
+ *	@new_parent: object's new parent
  *	@new_name: object's new name
  */
 

commit 1350770112bd9bd5696cb52deb712370012d80e0
Author: Martin Stoilov <mstoilov@odesys.com>
Date:   Mon Feb 5 16:15:23 2007 -0800

    kobject: kobj->k_name verification fix
    
    The function 'kobject_add' tries to verify the name of
    a new kobject instance is properly set before continuing.
        if (!kobj->k_name)
            kobj->k_name = kobj->name;
        if (!kobj->k_name) {
            pr_debug("kobject attempted to be registered with no name!\n");
            WARN_ON(1);
            return -EINVAL;
        }
    The statement:
        if (!kobj->k_name) {
            pr_debug("kobject attempted to be registered with no name!\n");
            WARN_ON(1);
            return -EINVAL;
        }
    is useless the way it is right now, because it can never be true. I
    think the
    code was intended to be:
        if (!kobj->k_name)
            kobj->k_name = kobj->name;
        if (!*kobj->k_name) {
            pr_debug("kobject attempted to be registered with no name!\n");
            WARN_ON(1);
            return -EINVAL;
        }
    because this would make sure the kobj->name buffer has something in it.
    So the missing '*' is just a typo. Although, I would much prefer
    expression like:
        if (*kobj->k_name == '\0') {
            pr_debug("kobject attempted to be registered with no name!\n");
            WARN_ON(1);
            return -EINVAL;
        }
    
    because this would've made the intention clear, in this patch I just restore
    the missing '*' without changing the coding style of the function.
    
    Signed-off-by: Martin Stoilov <mstoilov@odesys.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 2782f49e906e..93685f43bb9b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -171,7 +171,7 @@ int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
 		return -ENOENT;
 	if (!kobj->k_name)
 		kobj->k_name = kobj->name;
-	if (!kobj->k_name) {
+	if (!*kobj->k_name) {
 		pr_debug("kobject attempted to be registered with no name!\n");
 		WARN_ON(1);
 		return -EINVAL;

commit 72fd4a35a824331d7a0f4168d7576502d95d34b3
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sat Feb 10 01:45:59 2007 -0800

    [PATCH] Numerous fixes to kernel-doc info in source files.
    
    A variety of (mostly) innocuous fixes to the embedded kernel-doc content in
    source files, including:
    
      * make multi-line initial descriptions single line
      * denote some function names, constants and structs as such
      * change erroneous opening '/*' to '/**' in a few places
      * reword some text for clarity
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index c2917ffe8bf1..2782f49e906e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -97,11 +97,12 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
 }
 
 /**
- * kobject_get_path - generate and return the path associated with a given kobj
- * and kset pair.  The result must be freed by the caller with kfree().
+ * kobject_get_path - generate and return the path associated with a given kobj and kset pair.
  *
  * @kobj:	kobject in question, with which to build the path
  * @gfp_mask:	the allocation type used to allocate the path
+ *
+ * The result must be freed by the caller with kfree().
  */
 char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 {

commit b592fcfe7f06c15ec11774b5be7ce0de3aa86e73
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 24 12:35:52 2007 -0700

    sysfs: Shadow directory support
    
    The problem.  When implementing a network namespace I need to be able
    to have multiple network devices with the same name.  Currently this
    is a problem for /sys/class/net/*.
    
    What I want is a separate /sys/class/net directory in sysfs for each
    network namespace, and I want to name each of them /sys/class/net.
    
    I looked and the VFS actually allows that.  All that is needed is
    for /sys/class/net to implement a follow link method to redirect
    lookups to the real directory you want.
    
    Implementing a follow link method that is sensitive to the current
    network namespace turns out to be 3 lines of code so it looks like a
    clean approach.  Modifying sysfs so it doesn't get in my was is a bit
    trickier.
    
    I am calling the concept of multiple directories all at the same path
    in the filesystem shadow directories.  With the directory entry really
    at that location the shadow master.
    
    The following patch modifies sysfs so it can handle a directory
    structure slightly different from the kobject tree so I can implement
    the shadow directories for handling /sys/class/net/.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Maneesh Soni <maneesh@in.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 74b8dbca150e..c2917ffe8bf1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -44,11 +44,11 @@ static int populate_dir(struct kobject * kobj)
 	return error;
 }
 
-static int create_dir(struct kobject * kobj)
+static int create_dir(struct kobject * kobj, struct dentry *shadow_parent)
 {
 	int error = 0;
 	if (kobject_name(kobj)) {
-		error = sysfs_create_dir(kobj);
+		error = sysfs_create_dir(kobj, shadow_parent);
 		if (!error) {
 			if ((error = populate_dir(kobj)))
 				sysfs_remove_dir(kobj);
@@ -158,9 +158,10 @@ static void unlink(struct kobject * kobj)
 /**
  *	kobject_add - add an object to the hierarchy.
  *	@kobj:	object.
+ *	@shadow_parent: sysfs directory to add to.
  */
 
-int kobject_add(struct kobject * kobj)
+int kobject_shadow_add(struct kobject * kobj, struct dentry *shadow_parent)
 {
 	int error = 0;
 	struct kobject * parent;
@@ -191,7 +192,7 @@ int kobject_add(struct kobject * kobj)
 	}
 	kobj->parent = parent;
 
-	error = create_dir(kobj);
+	error = create_dir(kobj, shadow_parent);
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
@@ -212,6 +213,15 @@ int kobject_add(struct kobject * kobj)
 	return error;
 }
 
+/**
+ *	kobject_add - add an object to the hierarchy.
+ *	@kobj:	object.
+ */
+int kobject_add(struct kobject * kobj)
+{
+	return kobject_shadow_add(kobj, NULL);
+}
+
 
 /**
  *	kobject_register - initialize and add an object.
@@ -304,7 +314,29 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	kobj = kobject_get(kobj);
 	if (!kobj)
 		return -EINVAL;
-	error = sysfs_rename_dir(kobj, new_name);
+	if (!kobj->parent)
+		return -EINVAL;
+	error = sysfs_rename_dir(kobj, kobj->parent->dentry, new_name);
+	kobject_put(kobj);
+
+	return error;
+}
+
+/**
+ *	kobject_rename - change the name of an object
+ *	@kobj:	object in question.
+ *	@new_name: object's new name
+ */
+
+int kobject_shadow_rename(struct kobject * kobj, struct dentry *new_parent,
+			  const char *new_name)
+{
+	int error = 0;
+
+	kobj = kobject_get(kobj);
+	if (!kobj)
+		return -EINVAL;
+	error = sysfs_rename_dir(kobj, new_parent, new_name);
 	kobject_put(kobj);
 
 	return error;

commit b067db49e1f4013ef02ef68845701b600e88a722
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Jan 2 13:44:44 2007 +0100

    kobject: kobject_put cleanup
    
    This patch removes redundant argument checks for kobject_put().
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index c033dc8fa9af..74b8dbca150e 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -195,8 +195,7 @@ int kobject_add(struct kobject * kobj)
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
-		if (parent)
-			kobject_put(parent);
+		kobject_put(parent);
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
@@ -420,8 +419,7 @@ void kobject_cleanup(struct kobject * kobj)
 		t->release(kobj);
 	if (s)
 		kset_put(s);
-	if (parent) 
-		kobject_put(parent);
+	kobject_put(parent);
 }
 
 static void kobject_release(struct kref *kref)

commit c744aeae9d173a953b771a7ad5c872f91fa99dec
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Jan 8 20:16:44 2007 +0100

    driver core: Allow device_move(dev, NULL).
    
    If we allow NULL as the new parent in device_move(), we need to make sure
    that the device is placed into the same place as it would if it was
    newly registered:
    
    - Consider the device virtual tree. In order to be able to reuse code,
      setup_parent() has been tweaked a bit.
    - kobject_move() can fall back to the kset's kobject.
    - sysfs_move_dir() uses the sysfs root dir as fallback.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 9aed594bfcac..c033dc8fa9af 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -314,7 +314,7 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 /**
  *	kobject_move - move object to another parent
  *	@kobj:	object in question.
- *	@new_parent: object's new parent
+ *	@new_parent: object's new parent (can be NULL)
  */
 
 int kobject_move(struct kobject *kobj, struct kobject *new_parent)
@@ -330,8 +330,8 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 		return -EINVAL;
 	new_parent = kobject_get(new_parent);
 	if (!new_parent) {
-		error = -EINVAL;
-		goto out;
+		if (kobj->kset)
+			new_parent = kobject_get(&kobj->kset->kobj);
 	}
 	/* old object path */
 	devpath = kobject_get_path(kobj, GFP_KERNEL);

commit 31b9025aa0f89b392077db3f87458fd46bcc4f58
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 18 12:23:51 2007 -0800

    Kobject: make kobject apis more robust in handling NULL pointers
    
    It should be ok to pass in NULL for some kobject functions, so add error
    checking for all exported kobject functions to be more robust.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7ce6dc138e90..9aed594bfcac 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -126,6 +126,8 @@ EXPORT_SYMBOL_GPL(kobject_get_path);
  */
 void kobject_init(struct kobject * kobj)
 {
+	if (!kobj)
+		return;
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	init_waitqueue_head(&kobj->poll);
@@ -366,6 +368,8 @@ int kobject_move(struct kobject *kobj, struct kobject *new_parent)
 
 void kobject_del(struct kobject * kobj)
 {
+	if (!kobj)
+		return;
 	sysfs_remove_dir(kobj);
 	unlink(kobj);
 }
@@ -377,6 +381,8 @@ void kobject_del(struct kobject * kobj)
 
 void kobject_unregister(struct kobject * kobj)
 {
+	if (!kobj)
+		return;
 	pr_debug("kobject %s: unregistering\n",kobject_name(kobj));
 	kobject_uevent(kobj, KOBJ_REMOVE);
 	kobject_del(kobj);
@@ -523,6 +529,8 @@ int kset_add(struct kset * k)
 
 int kset_register(struct kset * k)
 {
+	if (!k)
+		return -EINVAL;
 	kset_init(k);
 	return kset_add(k);
 }
@@ -535,6 +543,8 @@ int kset_register(struct kset * k)
 
 void kset_unregister(struct kset * k)
 {
+	if (!k)
+		return;
 	kobject_unregister(&k->kobj);
 }
 
@@ -586,6 +596,9 @@ int subsystem_register(struct subsystem * s)
 {
 	int error;
 
+	if (!s)
+		return -EINVAL;
+
 	subsystem_init(s);
 	pr_debug("subsystem %s: registering\n",s->kset.kobj.name);
 
@@ -598,6 +611,8 @@ int subsystem_register(struct subsystem * s)
 
 void subsystem_unregister(struct subsystem * s)
 {
+	if (!s)
+		return;
 	pr_debug("subsystem %s: unregistering\n",s->kset.kobj.name);
 	kset_unregister(&s->kset);
 }
@@ -612,6 +627,10 @@ void subsystem_unregister(struct subsystem * s)
 int subsys_create_file(struct subsystem * s, struct subsys_attribute * a)
 {
 	int error = 0;
+
+	if (!s || !a)
+		return -EINVAL;
+
 	if (subsys_get(s)) {
 		error = sysfs_create_file(&s->kset.kobj,&a->attr);
 		subsys_put(s);

commit 4668edc334ee90cf50c382c3e423cfc510b5a126
Author: Burman Yan <yan_952@hotmail.com>
Date:   Wed Dec 6 20:38:51 2006 -0800

    [PATCH] kernel core: replace kmalloc+memset with kzalloc
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 744a4b102c7f..7ce6dc138e90 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -111,10 +111,9 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 	len = get_kobj_path_length(kobj);
 	if (len == 0)
 		return NULL;
-	path = kmalloc(len, gfp_mask);
+	path = kzalloc(len, gfp_mask);
 	if (!path)
 		return NULL;
-	memset(path, 0x00, len);
 	fill_kobj_path(kobj, path, len);
 
 	return path;

commit 8a82472f86bf693b8e91ed56c9ca4f62fbbdcfa3
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Mon Nov 20 17:07:51 2006 +0100

    driver core: Introduce device_move(): move a device to a new parent.
    
    Provide a function device_move() to move a device to a new parent device. Add
    auxilliary functions kobject_move() and sysfs_move_dir().
    kobject_move() generates a new uevent of type KOBJ_MOVE, containing the
    previous path (DEVPATH_OLD) in addition to the usual values. For this, a new
    interface kobject_uevent_env() is created that allows to add further
    environmental data to the uevent at the kobject layer.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7dd5c0e9d996..744a4b102c7f 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -310,6 +310,56 @@ int kobject_rename(struct kobject * kobj, const char *new_name)
 	return error;
 }
 
+/**
+ *	kobject_move - move object to another parent
+ *	@kobj:	object in question.
+ *	@new_parent: object's new parent
+ */
+
+int kobject_move(struct kobject *kobj, struct kobject *new_parent)
+{
+	int error;
+	struct kobject *old_parent;
+	const char *devpath = NULL;
+	char *devpath_string = NULL;
+	char *envp[2];
+
+	kobj = kobject_get(kobj);
+	if (!kobj)
+		return -EINVAL;
+	new_parent = kobject_get(new_parent);
+	if (!new_parent) {
+		error = -EINVAL;
+		goto out;
+	}
+	/* old object path */
+	devpath = kobject_get_path(kobj, GFP_KERNEL);
+	if (!devpath) {
+		error = -ENOMEM;
+		goto out;
+	}
+	devpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);
+	if (!devpath_string) {
+		error = -ENOMEM;
+		goto out;
+	}
+	sprintf(devpath_string, "DEVPATH_OLD=%s", devpath);
+	envp[0] = devpath_string;
+	envp[1] = NULL;
+	error = sysfs_move_dir(kobj, new_parent);
+	if (error)
+		goto out;
+	old_parent = kobj->parent;
+	kobj->parent = new_parent;
+	kobject_put(old_parent);
+	kobject_uevent_env(kobj, KOBJ_MOVE, envp);
+out:
+	kobject_put(kobj);
+	kfree(devpath_string);
+	kfree(devpath);
+	return error;
+}
+
 /**
  *	kobject_del - unlink kobject from hierarchy.
  * 	@kobj:	object.

commit 80fc9f532d8c05d4cb12d55660624ce53a378349
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Wed Oct 11 01:43:58 2006 -0400

    Input: add missing exports to fix modular build
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/lib/kobject.c b/lib/kobject.c
index 1699eb9161f3..7dd5c0e9d996 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -119,6 +119,7 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 
 	return path;
 }
+EXPORT_SYMBOL_GPL(kobject_get_path);
 
 /**
  *	kobject_init - initialize object.

commit 10188012daa586ae7fcbef272e4db4f404741adf
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Jul 11 20:49:41 2006 -0700

    kobject: must_check fixes
    
    Check all __must_check warnings in lib/kobject.c
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 8e7c71993487..1699eb9161f3 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -407,6 +407,7 @@ static struct kobj_type dir_ktype = {
 struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 {
 	struct kobject *k;
+	int ret;
 
 	if (!parent)
 		return NULL;
@@ -418,7 +419,13 @@ struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 	k->parent = parent;
 	k->ktype = &dir_ktype;
 	kobject_set_name(k, name);
-	kobject_register(k);
+	ret = kobject_register(k);
+	if (ret < 0) {
+		printk(KERN_WARNING "kobject_add_dir: "
+			"kobject_register error: %d\n", ret);
+		kobject_del(k);
+		return NULL;
+	}
 
 	return k;
 }

commit 183bd5b3da82b80920c30c4772222df8027fc364
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu May 18 10:39:21 2006 -0700

    [PATCH] kobject: make people pay attention to kobject_add errors
    
    These really need to be fixed, shout it out to the world.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 687ab418d292..8e7c71993487 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -198,14 +198,14 @@ int kobject_add(struct kobject * kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			pr_debug("kobject_add failed for %s with -EEXIST, "
+			printk("kobject_add failed for %s with -EEXIST, "
 			       "don't try to register things with the "
 			       "same name in the same directory.\n",
 			       kobject_name(kobj));
 		else
-			pr_debug("kobject_add failed for %s (%d)\n",
+			printk("kobject_add failed for %s (%d)\n",
 			       kobject_name(kobj), error);
-		/* dump_stack(); */
+		 dump_stack();
 	}
 
 	return error;

commit ae57a856429dd932c547530df1b234eb7e642297
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat May 20 15:00:30 2006 -0700

    [PATCH] kobject: quiet errors in kobject_add
    
    People don't like released kernels yelling at them, no matter how real the
    error might be.  So only report it if CONFIG_KOBJECT_DEBUG is enabled.
    
    Sent on request of Andrew Morton.
    
    (akpm: should bring this back post-2.6.17)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index b46350c27837..687ab418d292 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -198,14 +198,14 @@ int kobject_add(struct kobject * kobj)
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
-			printk("kobject_add failed for %s with -EEXIST, "
+			pr_debug("kobject_add failed for %s with -EEXIST, "
 			       "don't try to register things with the "
 			       "same name in the same directory.\n",
 			       kobject_name(kobj));
 		else
-			printk("kobject_add failed for %s (%d)\n",
+			pr_debug("kobject_add failed for %s (%d)\n",
 			       kobject_name(kobj), error);
-		dump_stack();
+		/* dump_stack(); */
 	}
 
 	return error;

commit 5b3ef14e3e9d745a512d65fcb4ef9be541226d80
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Apr 22 12:14:44 2006 +0200

    [PATCH] Kobject: possible cleanups
    
    This patch contains the following possible cleanups:
    - #if 0 the following unused global function:
      - subsys_remove_file()
    - remove the following unused EXPORT_SYMBOL's:
      - kset_find_obj
      - subsystem_init
    - remove the following unused EXPORT_SYMBOL_GPL:
      - kobject_add_dir
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 01d957513940..b46350c27837 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -422,7 +422,6 @@ struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
 
 	return k;
 }
-EXPORT_SYMBOL_GPL(kobject_add_dir);
 
 /**
  *	kset_init - initialize a kset for use
@@ -569,7 +568,7 @@ int subsys_create_file(struct subsystem * s, struct subsys_attribute * a)
  *	@s:	subsystem.
  *	@a:	attribute desciptor.
  */
-
+#if 0
 void subsys_remove_file(struct subsystem * s, struct subsys_attribute * a)
 {
 	if (subsys_get(s)) {
@@ -577,6 +576,7 @@ void subsys_remove_file(struct subsystem * s, struct subsys_attribute * a)
 		subsys_put(s);
 	}
 }
+#endif  /*  0  */
 
 EXPORT_SYMBOL(kobject_init);
 EXPORT_SYMBOL(kobject_register);
@@ -588,10 +588,7 @@ EXPORT_SYMBOL(kobject_del);
 
 EXPORT_SYMBOL(kset_register);
 EXPORT_SYMBOL(kset_unregister);
-EXPORT_SYMBOL(kset_find_obj);
 
-EXPORT_SYMBOL(subsystem_init);
 EXPORT_SYMBOL(subsystem_register);
 EXPORT_SYMBOL(subsystem_unregister);
 EXPORT_SYMBOL(subsys_create_file);
-EXPORT_SYMBOL(subsys_remove_file);

commit 4508a7a734b111b8b7e39986237d84acb1168dd0
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 20 17:53:53 2006 +1100

    [PATCH] sysfs: Allow sysfs attribute files to be pollable
    
    It works like this:
      Open the file
      Read all the contents.
      Call poll requesting POLLERR or POLLPRI (so select/exceptfds works)
      When poll returns,
         close the file and go to top of loop.
       or lseek to start of file and go back to the 'read'.
    
    Events are signaled by an object manager calling
       sysfs_notify(kobj, dir, attr);
    
    If the dir is non-NULL, it is used to find a subdirectory which
    contains the attribute (presumably created by sysfs_create_group).
    
    This has a cost of one int  per attribute, one wait_queuehead per kobject,
    one int per open file.
    
    The name "sysfs_notify" may be confused with the inotify
    functionality.  Maybe it would be nice to support inotify for sysfs
    attributes as well?
    
    This patch also uses sysfs_notify to allow /sys/block/md*/md/sync_action
    to be pollable
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 25204a41a9b0..01d957513940 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -128,6 +128,7 @@ void kobject_init(struct kobject * kobj)
 {
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
+	init_waitqueue_head(&kobj->poll);
 	kobj->kset = kset_get(kobj->kset);
 }
 

commit 7423172a50968de1905a61413c52bb070a62f5ce
Author: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
Date:   Mon Mar 13 17:14:25 2006 -0500

    [PATCH] kobject_add_dir
    
    Adding kobject_add_dir() function which creates a subdirectory
    for a given kobject.
    
    Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 36668c8c3ea1..25204a41a9b0 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -385,6 +385,44 @@ void kobject_put(struct kobject * kobj)
 }
 
 
+static void dir_release(struct kobject *kobj)
+{
+	kfree(kobj);
+}
+
+static struct kobj_type dir_ktype = {
+	.release	= dir_release,
+	.sysfs_ops	= NULL,
+	.default_attrs	= NULL,
+};
+
+/**
+ *	kobject_add_dir - add sub directory of object.
+ *	@parent:	object in which a directory is created.
+ *	@name:	directory name.
+ *
+ *	Add a plain directory object as child of given object.
+ */
+struct kobject *kobject_add_dir(struct kobject *parent, const char *name)
+{
+	struct kobject *k;
+
+	if (!parent)
+		return NULL;
+
+	k = kzalloc(sizeof(*k), GFP_KERNEL);
+	if (!k)
+		return NULL;
+
+	k->parent = parent;
+	k->ktype = &dir_ktype;
+	kobject_set_name(k, name);
+	kobject_register(k);
+
+	return k;
+}
+EXPORT_SYMBOL_GPL(kobject_add_dir);
+
 /**
  *	kset_init - initialize a kset for use
  *	@k:	kset 

commit dcd0da002122a70fe1c625c0ca9f58c95aa33ebe
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Mar 20 13:17:13 2006 -0800

    [PATCH] Kobject: provide better warning messages when people do stupid things
    
    Now that kobject_add() is used more than kobject_register() the kernel
    wasn't always letting people know that they were doing something wrong.
    This change fixes this.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index efe67fa96a71..36668c8c3ea1 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -194,6 +194,17 @@ int kobject_add(struct kobject * kobj)
 		unlink(kobj);
 		if (parent)
 			kobject_put(parent);
+
+		/* be noisy on error issues */
+		if (error == -EEXIST)
+			printk("kobject_add failed for %s with -EEXIST, "
+			       "don't try to register things with the "
+			       "same name in the same directory.\n",
+			       kobject_name(kobj));
+		else
+			printk("kobject_add failed for %s (%d)\n",
+			       kobject_name(kobj), error);
+		dump_stack();
 	}
 
 	return error;
@@ -207,18 +218,13 @@ int kobject_add(struct kobject * kobj)
 
 int kobject_register(struct kobject * kobj)
 {
-	int error = 0;
+	int error = -EINVAL;
 	if (kobj) {
 		kobject_init(kobj);
 		error = kobject_add(kobj);
-		if (error) {
-			printk("kobject_register failed for %s (%d)\n",
-			       kobject_name(kobj),error);
-			dump_stack();
-		} else
+		if (!error)
 			kobject_uevent(kobj, KOBJ_ADD);
-	} else
-		error = -EINVAL;
+	}
 	return error;
 }
 

commit b365b3daf2a9e2a8b002ea9fef877af1c71513fd
Author: Chuck Ebbert <76306.1226@compuserve.com>
Date:   Thu Jan 12 20:02:00 2006 -0500

    [PATCH] kobject: don't oops on null kobject.name
    
    kobject_get_path() will oops if one of the component names is
    NULL.  Fix that by returning NULL instead of oopsing.
    
    Signed-off-by: Chuck Ebbert <76306.1226@compuserve.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index fe4ae36ce960..efe67fa96a71 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -72,6 +72,8 @@ static int get_kobj_path_length(struct kobject *kobj)
 	 * Add 1 to strlen for leading '/' of each level.
 	 */
 	do {
+		if (kobject_name(parent) == NULL)
+			return 0;
 		length += strlen(kobject_name(parent)) + 1;
 		parent = parent->parent;
 	} while (parent);
@@ -107,6 +109,8 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 	int len;
 
 	len = get_kobj_path_length(kobj);
+	if (len == 0)
+		return NULL;
 	path = kmalloc(len, gfp_mask);
 	if (!path)
 		return NULL;

commit c171fef5c8566cf5f57877e7832fa696ecdf5228
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 20 14:08:59 2006 -0800

    [PATCH] kobject_add() must have a valid name in order to succeed.
    
    So we might as well check to verify this, and let the user know that
    something is wrong if they didn't do it correctly, instead of oopsing
    later on in kobject_get_name() or somewhere else.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 7a0e6809490d..fe4ae36ce960 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -162,6 +162,11 @@ int kobject_add(struct kobject * kobj)
 		return -ENOENT;
 	if (!kobj->k_name)
 		kobj->k_name = kobj->name;
+	if (!kobj->k_name) {
+		pr_debug("kobject attempted to be registered with no name!\n");
+		WARN_ON(1);
+		return -EINVAL;
+	}
 	parent = kobject_get(kobj->parent);
 
 	pr_debug("kobject %s: registering. parent: %s, set: %s\n",

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index a181abed89f6..7a0e6809490d 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -207,7 +207,7 @@ int kobject_register(struct kobject * kobj)
 			       kobject_name(kobj),error);
 			dump_stack();
 		} else
-			kobject_hotplug(kobj, KOBJ_ADD);
+			kobject_uevent(kobj, KOBJ_ADD);
 	} else
 		error = -EINVAL;
 	return error;
@@ -312,7 +312,7 @@ void kobject_del(struct kobject * kobj)
 void kobject_unregister(struct kobject * kobj)
 {
 	pr_debug("kobject %s: unregistering\n",kobject_name(kobj));
-	kobject_hotplug(kobj, KOBJ_REMOVE);
+	kobject_uevent(kobj, KOBJ_REMOVE);
 	kobject_del(kobj);
 	kobject_put(kobj);
 }

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 253d3004ace9..a181abed89f6 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -14,6 +14,7 @@
 #include <linux/string.h>
 #include <linux/module.h>
 #include <linux/stat.h>
+#include <linux/slab.h>
 
 /**
  *	populate_dir - populate directory with attributes.

commit fd4f2df24bc23e6b8fc069765b425c7dacf52347
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:18:50 2005 -0400

    [PATCH] gfp_t: lib/*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index dd0917dd9fa9..253d3004ace9 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -100,7 +100,7 @@ static void fill_kobj_path(struct kobject *kobj, char *path, int length)
  * @kobj:	kobject in question, with which to build the path
  * @gfp_mask:	the allocation type used to allocate the path
  */
-char *kobject_get_path(struct kobject *kobj, int gfp_mask)
+char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)
 {
 	char *path;
 	int len;

commit f3b4f3c6dec04c6c8261fe22645f07b39976595a
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Tue Apr 26 02:32:00 2005 -0500

    [PATCH] Make kobject's name be const char *
    
    kobject: make kobject's name const char * since users should not
             attempt to change it (except by calling kobject_rename).
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index 94048826624c..dd0917dd9fa9 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -279,7 +279,7 @@ EXPORT_SYMBOL(kobject_set_name);
  *	@new_name: object's new name
  */
 
-int kobject_rename(struct kobject * kobj, char *new_name)
+int kobject_rename(struct kobject * kobj, const char *new_name)
 {
 	int error = 0;
 

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/kobject.c b/lib/kobject.c
index 5df8441c44e7..94048826624c 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -216,13 +216,12 @@ int kobject_register(struct kobject * kobj)
 /**
  *	kobject_set_name - Set the name of an object
  *	@kobj:	object.
- *	@name:	name. 
+ *	@fmt:	format string used to build the name
  *
  *	If strlen(name) >= KOBJ_NAME_LEN, then use a dynamically allocated
  *	string that @kobj->k_name points to. Otherwise, use the static 
  *	@kobj->name array.
  */
-
 int kobject_set_name(struct kobject * kobj, const char * fmt, ...)
 {
 	int error = 0;

commit 18c3d5271b472c096adfc856e107c79f6fd30d7d
Author: kay.sievers@vrfy.org <kay.sievers@vrfy.org>
Date:   Mon Apr 18 21:57:34 2005 -0700

    [PATCH] kobject/hotplug split - kobject add/remove
    
    kobject_add() and kobject_del() don't emit hotplug events anymore.
    The user should do it itself if it has finished populating the device
    directory.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/lib/kobject.c b/lib/kobject.c
index ff9491986b38..5df8441c44e7 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -184,8 +184,6 @@ int kobject_add(struct kobject * kobj)
 		unlink(kobj);
 		if (parent)
 			kobject_put(parent);
-	} else {
-		kobject_hotplug(kobj, KOBJ_ADD);
 	}
 
 	return error;
@@ -207,7 +205,8 @@ int kobject_register(struct kobject * kobj)
 			printk("kobject_register failed for %s (%d)\n",
 			       kobject_name(kobj),error);
 			dump_stack();
-		}
+		} else
+			kobject_hotplug(kobj, KOBJ_ADD);
 	} else
 		error = -EINVAL;
 	return error;
@@ -301,7 +300,6 @@ int kobject_rename(struct kobject * kobj, char *new_name)
 
 void kobject_del(struct kobject * kobj)
 {
-	kobject_hotplug(kobj, KOBJ_REMOVE);
 	sysfs_remove_dir(kobj);
 	unlink(kobj);
 }
@@ -314,6 +312,7 @@ void kobject_del(struct kobject * kobj)
 void kobject_unregister(struct kobject * kobj)
 {
 	pr_debug("kobject %s: unregistering\n",kobject_name(kobj));
+	kobject_hotplug(kobj, KOBJ_REMOVE);
 	kobject_del(kobj);
 	kobject_put(kobj);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/lib/kobject.c b/lib/kobject.c
new file mode 100644
index 000000000000..ff9491986b38
--- /dev/null
+++ b/lib/kobject.c
@@ -0,0 +1,544 @@
+/*
+ * kobject.c - library routines for handling generic kernel objects
+ *
+ * Copyright (c) 2002-2003 Patrick Mochel <mochel@osdl.org>
+ *
+ * This file is released under the GPLv2.
+ *
+ *
+ * Please see the file Documentation/kobject.txt for critical information
+ * about using the kobject interface.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+
+/**
+ *	populate_dir - populate directory with attributes.
+ *	@kobj:	object we're working on.
+ *
+ *	Most subsystems have a set of default attributes that 
+ *	are associated with an object that registers with them.
+ *	This is a helper called during object registration that 
+ *	loops through the default attributes of the subsystem 
+ *	and creates attributes files for them in sysfs.
+ *
+ */
+
+static int populate_dir(struct kobject * kobj)
+{
+	struct kobj_type * t = get_ktype(kobj);
+	struct attribute * attr;
+	int error = 0;
+	int i;
+	
+	if (t && t->default_attrs) {
+		for (i = 0; (attr = t->default_attrs[i]) != NULL; i++) {
+			if ((error = sysfs_create_file(kobj,attr)))
+				break;
+		}
+	}
+	return error;
+}
+
+static int create_dir(struct kobject * kobj)
+{
+	int error = 0;
+	if (kobject_name(kobj)) {
+		error = sysfs_create_dir(kobj);
+		if (!error) {
+			if ((error = populate_dir(kobj)))
+				sysfs_remove_dir(kobj);
+		}
+	}
+	return error;
+}
+
+static inline struct kobject * to_kobj(struct list_head * entry)
+{
+	return container_of(entry,struct kobject,entry);
+}
+
+static int get_kobj_path_length(struct kobject *kobj)
+{
+	int length = 1;
+	struct kobject * parent = kobj;
+
+	/* walk up the ancestors until we hit the one pointing to the 
+	 * root.
+	 * Add 1 to strlen for leading '/' of each level.
+	 */
+	do {
+		length += strlen(kobject_name(parent)) + 1;
+		parent = parent->parent;
+	} while (parent);
+	return length;
+}
+
+static void fill_kobj_path(struct kobject *kobj, char *path, int length)
+{
+	struct kobject * parent;
+
+	--length;
+	for (parent = kobj; parent; parent = parent->parent) {
+		int cur = strlen(kobject_name(parent));
+		/* back up enough to print this name with '/' */
+		length -= cur;
+		strncpy (path + length, kobject_name(parent), cur);
+		*(path + --length) = '/';
+	}
+
+	pr_debug("%s: path = '%s'\n",__FUNCTION__,path);
+}
+
+/**
+ * kobject_get_path - generate and return the path associated with a given kobj
+ * and kset pair.  The result must be freed by the caller with kfree().
+ *
+ * @kobj:	kobject in question, with which to build the path
+ * @gfp_mask:	the allocation type used to allocate the path
+ */
+char *kobject_get_path(struct kobject *kobj, int gfp_mask)
+{
+	char *path;
+	int len;
+
+	len = get_kobj_path_length(kobj);
+	path = kmalloc(len, gfp_mask);
+	if (!path)
+		return NULL;
+	memset(path, 0x00, len);
+	fill_kobj_path(kobj, path, len);
+
+	return path;
+}
+
+/**
+ *	kobject_init - initialize object.
+ *	@kobj:	object in question.
+ */
+void kobject_init(struct kobject * kobj)
+{
+	kref_init(&kobj->kref);
+	INIT_LIST_HEAD(&kobj->entry);
+	kobj->kset = kset_get(kobj->kset);
+}
+
+
+/**
+ *	unlink - remove kobject from kset list.
+ *	@kobj:	kobject.
+ *
+ *	Remove the kobject from the kset list and decrement
+ *	its parent's refcount.
+ *	This is separated out, so we can use it in both 
+ *	kobject_del() and kobject_add() on error.
+ */
+
+static void unlink(struct kobject * kobj)
+{
+	if (kobj->kset) {
+		spin_lock(&kobj->kset->list_lock);
+		list_del_init(&kobj->entry);
+		spin_unlock(&kobj->kset->list_lock);
+	}
+	kobject_put(kobj);
+}
+
+/**
+ *	kobject_add - add an object to the hierarchy.
+ *	@kobj:	object.
+ */
+
+int kobject_add(struct kobject * kobj)
+{
+	int error = 0;
+	struct kobject * parent;
+
+	if (!(kobj = kobject_get(kobj)))
+		return -ENOENT;
+	if (!kobj->k_name)
+		kobj->k_name = kobj->name;
+	parent = kobject_get(kobj->parent);
+
+	pr_debug("kobject %s: registering. parent: %s, set: %s\n",
+		 kobject_name(kobj), parent ? kobject_name(parent) : "<NULL>", 
+		 kobj->kset ? kobj->kset->kobj.name : "<NULL>" );
+
+	if (kobj->kset) {
+		spin_lock(&kobj->kset->list_lock);
+
+		if (!parent)
+			parent = kobject_get(&kobj->kset->kobj);
+
+		list_add_tail(&kobj->entry,&kobj->kset->list);
+		spin_unlock(&kobj->kset->list_lock);
+	}
+	kobj->parent = parent;
+
+	error = create_dir(kobj);
+	if (error) {
+		/* unlink does the kobject_put() for us */
+		unlink(kobj);
+		if (parent)
+			kobject_put(parent);
+	} else {
+		kobject_hotplug(kobj, KOBJ_ADD);
+	}
+
+	return error;
+}
+
+
+/**
+ *	kobject_register - initialize and add an object.
+ *	@kobj:	object in question.
+ */
+
+int kobject_register(struct kobject * kobj)
+{
+	int error = 0;
+	if (kobj) {
+		kobject_init(kobj);
+		error = kobject_add(kobj);
+		if (error) {
+			printk("kobject_register failed for %s (%d)\n",
+			       kobject_name(kobj),error);
+			dump_stack();
+		}
+	} else
+		error = -EINVAL;
+	return error;
+}
+
+
+/**
+ *	kobject_set_name - Set the name of an object
+ *	@kobj:	object.
+ *	@name:	name. 
+ *
+ *	If strlen(name) >= KOBJ_NAME_LEN, then use a dynamically allocated
+ *	string that @kobj->k_name points to. Otherwise, use the static 
+ *	@kobj->name array.
+ */
+
+int kobject_set_name(struct kobject * kobj, const char * fmt, ...)
+{
+	int error = 0;
+	int limit = KOBJ_NAME_LEN;
+	int need;
+	va_list args;
+	char * name;
+
+	/* 
+	 * First, try the static array 
+	 */
+	va_start(args,fmt);
+	need = vsnprintf(kobj->name,limit,fmt,args);
+	va_end(args);
+	if (need < limit) 
+		name = kobj->name;
+	else {
+		/* 
+		 * Need more space? Allocate it and try again 
+		 */
+		limit = need + 1;
+		name = kmalloc(limit,GFP_KERNEL);
+		if (!name) {
+			error = -ENOMEM;
+			goto Done;
+		}
+		va_start(args,fmt);
+		need = vsnprintf(name,limit,fmt,args);
+		va_end(args);
+
+		/* Still? Give up. */
+		if (need >= limit) {
+			kfree(name);
+			error = -EFAULT;
+			goto Done;
+		}
+	}
+
+	/* Free the old name, if necessary. */
+	if (kobj->k_name && kobj->k_name != kobj->name)
+		kfree(kobj->k_name);
+
+	/* Now, set the new name */
+	kobj->k_name = name;
+ Done:
+	return error;
+}
+
+EXPORT_SYMBOL(kobject_set_name);
+
+
+/**
+ *	kobject_rename - change the name of an object
+ *	@kobj:	object in question.
+ *	@new_name: object's new name
+ */
+
+int kobject_rename(struct kobject * kobj, char *new_name)
+{
+	int error = 0;
+
+	kobj = kobject_get(kobj);
+	if (!kobj)
+		return -EINVAL;
+	error = sysfs_rename_dir(kobj, new_name);
+	kobject_put(kobj);
+
+	return error;
+}
+
+/**
+ *	kobject_del - unlink kobject from hierarchy.
+ * 	@kobj:	object.
+ */
+
+void kobject_del(struct kobject * kobj)
+{
+	kobject_hotplug(kobj, KOBJ_REMOVE);
+	sysfs_remove_dir(kobj);
+	unlink(kobj);
+}
+
+/**
+ *	kobject_unregister - remove object from hierarchy and decrement refcount.
+ *	@kobj:	object going away.
+ */
+
+void kobject_unregister(struct kobject * kobj)
+{
+	pr_debug("kobject %s: unregistering\n",kobject_name(kobj));
+	kobject_del(kobj);
+	kobject_put(kobj);
+}
+
+/**
+ *	kobject_get - increment refcount for object.
+ *	@kobj:	object.
+ */
+
+struct kobject * kobject_get(struct kobject * kobj)
+{
+	if (kobj)
+		kref_get(&kobj->kref);
+	return kobj;
+}
+
+/**
+ *	kobject_cleanup - free kobject resources. 
+ *	@kobj:	object.
+ */
+
+void kobject_cleanup(struct kobject * kobj)
+{
+	struct kobj_type * t = get_ktype(kobj);
+	struct kset * s = kobj->kset;
+	struct kobject * parent = kobj->parent;
+
+	pr_debug("kobject %s: cleaning up\n",kobject_name(kobj));
+	if (kobj->k_name != kobj->name)
+		kfree(kobj->k_name);
+	kobj->k_name = NULL;
+	if (t && t->release)
+		t->release(kobj);
+	if (s)
+		kset_put(s);
+	if (parent) 
+		kobject_put(parent);
+}
+
+static void kobject_release(struct kref *kref)
+{
+	kobject_cleanup(container_of(kref, struct kobject, kref));
+}
+
+/**
+ *	kobject_put - decrement refcount for object.
+ *	@kobj:	object.
+ *
+ *	Decrement the refcount, and if 0, call kobject_cleanup().
+ */
+void kobject_put(struct kobject * kobj)
+{
+	if (kobj)
+		kref_put(&kobj->kref, kobject_release);
+}
+
+
+/**
+ *	kset_init - initialize a kset for use
+ *	@k:	kset 
+ */
+
+void kset_init(struct kset * k)
+{
+	kobject_init(&k->kobj);
+	INIT_LIST_HEAD(&k->list);
+	spin_lock_init(&k->list_lock);
+}
+
+
+/**
+ *	kset_add - add a kset object to the hierarchy.
+ *	@k:	kset.
+ *
+ *	Simply, this adds the kset's embedded kobject to the 
+ *	hierarchy. 
+ *	We also try to make sure that the kset's embedded kobject
+ *	has a parent before it is added. We only care if the embedded
+ *	kobject is not part of a kset itself, since kobject_add()
+ *	assigns a parent in that case. 
+ *	If that is the case, and the kset has a controlling subsystem,
+ *	then we set the kset's parent to be said subsystem. 
+ */
+
+int kset_add(struct kset * k)
+{
+	if (!k->kobj.parent && !k->kobj.kset && k->subsys)
+		k->kobj.parent = &k->subsys->kset.kobj;
+
+	return kobject_add(&k->kobj);
+}
+
+
+/**
+ *	kset_register - initialize and add a kset.
+ *	@k:	kset.
+ */
+
+int kset_register(struct kset * k)
+{
+	kset_init(k);
+	return kset_add(k);
+}
+
+
+/**
+ *	kset_unregister - remove a kset.
+ *	@k:	kset.
+ */
+
+void kset_unregister(struct kset * k)
+{
+	kobject_unregister(&k->kobj);
+}
+
+
+/**
+ *	kset_find_obj - search for object in kset.
+ *	@kset:	kset we're looking in.
+ *	@name:	object's name.
+ *
+ *	Lock kset via @kset->subsys, and iterate over @kset->list,
+ *	looking for a matching kobject. If matching object is found
+ *	take a reference and return the object.
+ */
+
+struct kobject * kset_find_obj(struct kset * kset, const char * name)
+{
+	struct list_head * entry;
+	struct kobject * ret = NULL;
+
+	spin_lock(&kset->list_lock);
+	list_for_each(entry,&kset->list) {
+		struct kobject * k = to_kobj(entry);
+		if (kobject_name(k) && !strcmp(kobject_name(k),name)) {
+			ret = kobject_get(k);
+			break;
+		}
+	}
+	spin_unlock(&kset->list_lock);
+	return ret;
+}
+
+
+void subsystem_init(struct subsystem * s)
+{
+	init_rwsem(&s->rwsem);
+	kset_init(&s->kset);
+}
+
+/**
+ *	subsystem_register - register a subsystem.
+ *	@s:	the subsystem we're registering.
+ *
+ *	Once we register the subsystem, we want to make sure that 
+ *	the kset points back to this subsystem for correct usage of 
+ *	the rwsem. 
+ */
+
+int subsystem_register(struct subsystem * s)
+{
+	int error;
+
+	subsystem_init(s);
+	pr_debug("subsystem %s: registering\n",s->kset.kobj.name);
+
+	if (!(error = kset_add(&s->kset))) {
+		if (!s->kset.subsys)
+			s->kset.subsys = s;
+	}
+	return error;
+}
+
+void subsystem_unregister(struct subsystem * s)
+{
+	pr_debug("subsystem %s: unregistering\n",s->kset.kobj.name);
+	kset_unregister(&s->kset);
+}
+
+
+/**
+ *	subsystem_create_file - export sysfs attribute file.
+ *	@s:	subsystem.
+ *	@a:	subsystem attribute descriptor.
+ */
+
+int subsys_create_file(struct subsystem * s, struct subsys_attribute * a)
+{
+	int error = 0;
+	if (subsys_get(s)) {
+		error = sysfs_create_file(&s->kset.kobj,&a->attr);
+		subsys_put(s);
+	}
+	return error;
+}
+
+
+/**
+ *	subsystem_remove_file - remove sysfs attribute file.
+ *	@s:	subsystem.
+ *	@a:	attribute desciptor.
+ */
+
+void subsys_remove_file(struct subsystem * s, struct subsys_attribute * a)
+{
+	if (subsys_get(s)) {
+		sysfs_remove_file(&s->kset.kobj,&a->attr);
+		subsys_put(s);
+	}
+}
+
+EXPORT_SYMBOL(kobject_init);
+EXPORT_SYMBOL(kobject_register);
+EXPORT_SYMBOL(kobject_unregister);
+EXPORT_SYMBOL(kobject_get);
+EXPORT_SYMBOL(kobject_put);
+EXPORT_SYMBOL(kobject_add);
+EXPORT_SYMBOL(kobject_del);
+
+EXPORT_SYMBOL(kset_register);
+EXPORT_SYMBOL(kset_unregister);
+EXPORT_SYMBOL(kset_find_obj);
+
+EXPORT_SYMBOL(subsystem_init);
+EXPORT_SYMBOL(subsystem_register);
+EXPORT_SYMBOL(subsystem_unregister);
+EXPORT_SYMBOL(subsys_create_file);
+EXPORT_SYMBOL(subsys_remove_file);
