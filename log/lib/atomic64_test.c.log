commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 62ab629f51ca..d9d170238165 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Testsuite for atomic64_t functions
  *
  * Copyright Â© 2010  Luca Barbieri
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit ffba19ccae8d98beb0a17345a0b1ee9e415b23b8
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Fri Jul 14 14:49:41 2017 -0700

    lib/atomic64_test.c: add a test that atomic64_inc_not_zero() returns an int
    
    atomic64_inc_not_zero() returns a "truth value" which in C is
    traditionally an int.  That means callers are likely to expect the
    result will fit in an int.
    
    If an implementation returns a "true" value which does not fit in an
    int, then there's a possibility that callers will truncate it when they
    store it in an int.
    
    In fact this happened in practice, see commit 966d2b04e070
    ("percpu-refcount: fix reference leak during percpu-atomic transition").
    
    So add a test that the result fits in an int, even when the input
    doesn't.  This catches the case where an implementation just passes the
    non-zero input value out as the result.
    
    Link: http://lkml.kernel.org/r/1499775133-1231-1-git-send-email-mpe@ellerman.id.au
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Douglas Miller <dougmill@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index fd70c0e0e673..62ab629f51ca 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -153,8 +153,10 @@ static __init void test_atomic64(void)
 	long long v0 = 0xaaa31337c001d00dLL;
 	long long v1 = 0xdeadbeefdeafcafeLL;
 	long long v2 = 0xfaceabadf00df001LL;
+	long long v3 = 0x8000000000000000LL;
 	long long onestwos = 0x1111111122222222LL;
 	long long one = 1LL;
+	int r_int;
 
 	atomic64_t v = ATOMIC64_INIT(v0);
 	long long r = v0;
@@ -240,6 +242,11 @@ static __init void test_atomic64(void)
 	BUG_ON(!atomic64_inc_not_zero(&v));
 	r += one;
 	BUG_ON(v.counter != r);
+
+	/* Confirm the return value fits in an int, even if the value doesn't */
+	INIT(v3);
+	r_int = atomic64_inc_not_zero(&v);
+	BUG_ON(!r_int);
 }
 
 static __init int test_atomics_init(void)

commit 55ded9551f9a64f2872df77a954d4c30f8958e82
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Feb 24 15:00:55 2017 -0800

    lib: add module support to atomic64 tests
    
    Allow to compile the atomic64 test code either to a loadable module, or
    builtin into the kernel.
    
    Link: http://lkml.kernel.org/r/1483470276-10517-3-git-send-email-geert@linux-m68k.org
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 46042901130f..fd70c0e0e673 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -15,6 +15,7 @@
 #include <linux/bug.h>
 #include <linux/kernel.h>
 #include <linux/atomic.h>
+#include <linux/module.h>
 
 #ifdef CONFIG_X86
 #include <asm/cpufeature.h>	/* for boot_cpu_has below */
@@ -241,7 +242,7 @@ static __init void test_atomic64(void)
 	BUG_ON(v.counter != r);
 }
 
-static __init int test_atomics(void)
+static __init int test_atomics_init(void)
 {
 	test_atomic();
 	test_atomic64();
@@ -264,4 +265,9 @@ static __init int test_atomics(void)
 	return 0;
 }
 
-core_initcall(test_atomics);
+static __exit void test_atomics_exit(void) {}
+
+module_init(test_atomics_init);
+module_exit(test_atomics_exit);
+
+MODULE_LICENSE("GPL");

commit 51a021244b9d579be6b4f8c15c493a76deb2a79e
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Fri Oct 7 17:02:10 2016 -0700

    atomic64: no need for CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
    
    This came to light when implementing native 64-bit atomics for ARCv2.
    
    The atomic64 self-test code uses CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
    to check whether atomic64_dec_if_positive() is available.  It seems it
    was needed when not every arch defined it.  However as of current code
    the Kconfig option seems needless
    
     - for CONFIG_GENERIC_ATOMIC64 it is auto-enabled in lib/Kconfig and a
       generic definition of API is present lib/atomic64.c
     - arches with native 64-bit atomics select it in arch/*/Kconfig and
       define the API in their headers
    
    So I see no point in keeping the Kconfig option
    
    Compile tested for:
     - blackfin (CONFIG_GENERIC_ATOMIC64)
     - x86 (!CONFIG_GENERIC_ATOMIC64)
     - ia64
    
    Link: http://lkml.kernel.org/r/1473703083-8625-3-git-send-email-vgupta@synopsys.com
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Zhaoxiu Zeng <zhaoxiu.zeng@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Ming Lin <ming.l@ssi.samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Boqun Feng <boqun.feng@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index dbb369145dda..46042901130f 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -213,7 +213,6 @@ static __init void test_atomic64(void)
 	r += one;
 	BUG_ON(v.counter != r);
 
-#ifdef CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;
@@ -226,9 +225,6 @@ static __init void test_atomic64(void)
 	INIT(-one);
 	BUG_ON(atomic64_dec_if_positive(&v) != (-one - one));
 	BUG_ON(v.counter != r);
-#else
-#warning Please implement atomic64_dec_if_positive for your architecture and select the above Kconfig symbol
-#endif
 
 	INIT(onestwos);
 	BUG_ON(!atomic64_inc_not_zero(&v));

commit 28aa2bda2211f4327d83b44a4f917b4a061b1c56
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Apr 18 00:54:38 2016 +0200

    locking/atomic: Implement atomic{,64,_long}_fetch_{add,sub,and,andnot,or,xor}{,_relaxed,_acquire,_release}()
    
    Now that all the architectures have implemented support for these new
    atomic primitives add on the generic infrastructure to expose and use
    it.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Boqun Feng <boqun.feng@gmail.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 123481814320..dbb369145dda 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -53,11 +53,25 @@ do {								\
 	BUG_ON(atomic##bit##_read(&v) != r);			\
 } while (0)
 
+#define TEST_FETCH(bit, op, c_op, val)				\
+do {								\
+	atomic##bit##_set(&v, v0);				\
+	r = v0;							\
+	r c_op val;						\
+	BUG_ON(atomic##bit##_##op(val, &v) != v0);		\
+	BUG_ON(atomic##bit##_read(&v) != r);			\
+} while (0)
+
 #define RETURN_FAMILY_TEST(bit, op, c_op, val)			\
 do {								\
 	FAMILY_TEST(TEST_RETURN, bit, op, c_op, val);		\
 } while (0)
 
+#define FETCH_FAMILY_TEST(bit, op, c_op, val)			\
+do {								\
+	FAMILY_TEST(TEST_FETCH, bit, op, c_op, val);		\
+} while (0)
+
 #define TEST_ARGS(bit, op, init, ret, expect, args...)		\
 do {								\
 	atomic##bit##_set(&v, init);				\
@@ -114,6 +128,16 @@ static __init void test_atomic(void)
 	RETURN_FAMILY_TEST(, sub_return, -=, onestwos);
 	RETURN_FAMILY_TEST(, sub_return, -=, -one);
 
+	FETCH_FAMILY_TEST(, fetch_add, +=, onestwos);
+	FETCH_FAMILY_TEST(, fetch_add, +=, -one);
+	FETCH_FAMILY_TEST(, fetch_sub, -=, onestwos);
+	FETCH_FAMILY_TEST(, fetch_sub, -=, -one);
+
+	FETCH_FAMILY_TEST(, fetch_or,  |=, v1);
+	FETCH_FAMILY_TEST(, fetch_and, &=, v1);
+	FETCH_FAMILY_TEST(, fetch_andnot, &= ~, v1);
+	FETCH_FAMILY_TEST(, fetch_xor, ^=, v1);
+
 	INC_RETURN_FAMILY_TEST(, v0);
 	DEC_RETURN_FAMILY_TEST(, v0);
 
@@ -154,6 +178,16 @@ static __init void test_atomic64(void)
 	RETURN_FAMILY_TEST(64, sub_return, -=, onestwos);
 	RETURN_FAMILY_TEST(64, sub_return, -=, -one);
 
+	FETCH_FAMILY_TEST(64, fetch_add, +=, onestwos);
+	FETCH_FAMILY_TEST(64, fetch_add, +=, -one);
+	FETCH_FAMILY_TEST(64, fetch_sub, -=, onestwos);
+	FETCH_FAMILY_TEST(64, fetch_sub, -=, -one);
+
+	FETCH_FAMILY_TEST(64, fetch_or,  |=, v1);
+	FETCH_FAMILY_TEST(64, fetch_and, &=, v1);
+	FETCH_FAMILY_TEST(64, fetch_andnot, &= ~, v1);
+	FETCH_FAMILY_TEST(64, fetch_xor, ^=, v1);
+
 	INIT(v0);
 	atomic64_inc(&v);
 	r += one;

commit cd4d09ec6f6c12a2cc3db5b7d8876a325a53545b
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Jan 26 22:12:04 2016 +0100

    x86/cpufeature: Carve out X86_FEATURE_*
    
    Move them to a separate header and have the following
    dependency:
    
      x86/cpufeatures.h <- x86/processor.h <- x86/cpufeature.h
    
    This makes it easier to use the header in asm code and not
    include the whole cpufeature.h and add guards for asm.
    
    Suggested-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1453842730-28463-5-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index d62de8bf022d..123481814320 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -17,7 +17,7 @@
 #include <linux/atomic.h>
 
 #ifdef CONFIG_X86
-#include <asm/processor.h>	/* for boot_cpu_has below */
+#include <asm/cpufeature.h>	/* for boot_cpu_has below */
 #endif
 
 #define TEST(bit, op, c_op, val)				\

commit 5cb52b5e1654f3f1ed9c32e34456d98559c85aa0
Merge: 24af98c4cf5f 3eb9ede23bdd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 14:39:17 2016 -0800

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "Kernel side changes:
    
       - Intel Knights Landing support.  (Harish Chegondi)
    
       - Intel Broadwell-EP uncore PMU support.  (Kan Liang)
    
       - Core code improvements.  (Peter Zijlstra.)
    
       - Event filter, LBR and PEBS fixes.  (Stephane Eranian)
    
       - Enable cycles:pp on Intel Atom.  (Stephane Eranian)
    
       - Add cycles:ppp support for Skylake.  (Andi Kleen)
    
       - Various x86 NMI overhead optimizations.  (Andi Kleen)
    
       - Intel PT enhancements.  (Takao Indoh)
    
       - AMD cache events fix.  (Vince Weaver)
    
      Tons of tooling changes:
    
       - Show random perf tool tips in the 'perf report' bottom line
         (Namhyung Kim)
    
       - perf report now defaults to --group if the perf.data file has
         grouped events, try it with:
    
          # perf record -e '{cycles,instructions}' -a sleep 1
          [ perf record: Woken up 1 times to write data ]
          [ perf record: Captured and wrote 1.093 MB perf.data (1247 samples) ]
          # perf report
          # Samples: 1K of event 'anon group { cycles, instructions }'
          # Event count (approx.): 1955219195
          #
          #       Overhead  Command     Shared Object      Symbol
    
             2.86%   0.22%  swapper     [kernel.kallsyms]  [k] intel_idle
             1.05%   0.33%  firefox     libxul.so          [.] js::SetObjectElement
             1.05%   0.00%  kworker/0:3 [kernel.kallsyms]  [k] gen6_ring_get_seqno
             0.88%   0.17%  chrome      chrome             [.] 0x0000000000ee27ab
             0.65%   0.86%  firefox     libxul.so          [.] js::ValueToId<(js::AllowGC)1>
             0.64%   0.23%  JS Helper   libxul.so          [.] js::SplayTree<js::jit::LiveRange*, js::jit::LiveRange>::splay
             0.62%   1.27%  firefox     libxul.so          [.] js::GetIterator
             0.61%   1.74%  firefox     libxul.so          [.] js::NativeSetProperty
             0.61%   0.31%  firefox     libxul.so          [.] js::SetPropertyByDefining
    
       - Introduce the 'perf stat record/report' workflow:
    
         Generate perf.data files from 'perf stat', to tap into the
         scripting capabilities perf has instead of defining a 'perf stat'
         specific scripting support to calculate event ratios, etc.
    
         Simple example:
    
            $ perf stat record -e cycles usleep 1
    
             Performance counter stats for 'usleep 1':
    
                   1,134,996      cycles
    
                 0.000670644 seconds time elapsed
    
            $ perf stat report
    
             Performance counter stats for '/home/acme/bin/perf stat record -e cycles usleep 1':
    
                   1,134,996      cycles
    
                 0.000670644 seconds time elapsed
    
            $
    
         It generates PERF_RECORD_ userspace records to store the details:
    
            $ perf report -D | grep PERF_RECORD
            0xf0 [0x28]: PERF_RECORD_THREAD_MAP nr: 1 thread: 27637
            0x118 [0x12]: PERF_RECORD_CPU_MAP nr: 1 cpu: 65535
            0x12a [0x40]: PERF_RECORD_STAT_CONFIG
            0x16a [0x30]: PERF_RECORD_STAT
            -1 -1 0x19a [0x40]: PERF_RECORD_MMAP -1/0: [0xffffffff81000000(0x1f000000) @ 0xffffffff81000000]: x [kernel.kallsyms]_text
            0x1da [0x18]: PERF_RECORD_STAT_ROUND
            [acme@ssdandy linux]$
    
         An effort was made to make perf.data files generated like this to
         not generate cryptic messages when processed by older tools.
    
         The 'perf script' bits need rebasing, will go up later.
    
       - Make command line options always available, even when they depend
         on some feature being enabled, warning the user about use of such
         options (Wang Nan)
    
       - Support hw breakpoint events (mem:0xAddress) in the default output
         mode in 'perf script' (Wang Nan)
    
       - Fixes and improvements for supporting annotating ARM binaries,
         support ARM call and jump instructions, more work needed to have
         arch specific stuff separated into tools/perf/arch/*/annotate/
         (Russell King)
    
       - Add initial 'perf config' command, for now just with a --list
         command to the contents of the configuration file in use and a
         basic man page describing its format, commands for doing edits and
         detailed documentation are being reviewed and proof-read.  (Taeung
         Song)
    
       - Allows BPF scriptlets specify arguments to be fetched using DWARF
         info, using a prologue generated at compile/build time (He Kuang,
         Wang Nan)
    
       - Allow attaching BPF scriptlets to module symbols (Wang Nan)
    
       - Allow attaching BPF scriptlets to userspace code using uprobe (Wang
         Nan)
    
       - BPF programs now can specify 'perf probe' tunables via its section
         name, separating key=val values using semicolons (Wang Nan)
    
         Testing some of these new BPF features:
    
            Use case: get callchains when receiving SSL packets, filter then in the
                      kernel, at arbitrary place.
    
            # cat ssl.bpf.c
            #define SEC(NAME) __attribute__((section(NAME), used))
    
            struct pt_regs;
    
            SEC("func=__inet_lookup_established hnum")
            int func(struct pt_regs *ctx, int err, unsigned short port)
            {
                    return err == 0 && port == 443;
            }
    
            char _license[] SEC("license") = "GPL";
            int  _version   SEC("version") = LINUX_VERSION_CODE;
            #
            # perf record -a -g -e ssl.bpf.c
            ^C[ perf record: Woken up 1 times to write data ]
            [ perf record: Captured and wrote 0.787 MB perf.data (3 samples) ]
            # perf script | head -30
            swapper     0 [000] 58783.268118: perf_bpf_probe:func: (ffffffff816a0f60) hnum=0x1bb
               8a0f61 __inet_lookup_established (/lib/modules/4.3.0+/build/vmlinux)
               896def ip_rcv_finish (/lib/modules/4.3.0+/build/vmlinux)
               8976c2 ip_rcv (/lib/modules/4.3.0+/build/vmlinux)
               855eba __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
               8572a8 process_backlog (/lib/modules/4.3.0+/build/vmlinux)
               856b11 net_rx_action (/lib/modules/4.3.0+/build/vmlinux)
               2a284b __do_softirq (/lib/modules/4.3.0+/build/vmlinux)
               2a2ba3 irq_exit (/lib/modules/4.3.0+/build/vmlinux)
               96b7a4 do_IRQ (/lib/modules/4.3.0+/build/vmlinux)
               969807 ret_from_intr (/lib/modules/4.3.0+/build/vmlinux)
               2dede5 cpu_startup_entry (/lib/modules/4.3.0+/build/vmlinux)
               95d5bc rest_init (/lib/modules/4.3.0+/build/vmlinux)
              1163ffa start_kernel ([kernel.vmlinux].init.text)
              11634d7 x86_64_start_reservations ([kernel.vmlinux].init.text)
              1163623 x86_64_start_kernel ([kernel.vmlinux].init.text)
    
            qemu-system-x86  9178 [003] 58785.792417: perf_bpf_probe:func: (ffffffff816a0f60) hnum=0x1bb
               8a0f61 __inet_lookup_established (/lib/modules/4.3.0+/build/vmlinux)
               896def ip_rcv_finish (/lib/modules/4.3.0+/build/vmlinux)
               8976c2 ip_rcv (/lib/modules/4.3.0+/build/vmlinux)
               855eba __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
               856660 netif_receive_skb_internal (/lib/modules/4.3.0+/build/vmlinux)
               8566ec netif_receive_skb_sk (/lib/modules/4.3.0+/build/vmlinux)
                 430a br_handle_frame_finish ([bridge])
                 48bc br_handle_frame ([bridge])
               855f44 __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
            #
    
       - Use 'perf probe' various options to list functions, see what
         variables can be collected at any given point, experiment first
         collecting without a filter, then filter, use it together with
         'perf trace', 'perf top', with or without callchains, if it
         explodes, please tell us!
    
       - Introduce a new callchain mode: "folded", that will list per line
         representations of all callchains for a give histogram entry,
         facilitating 'perf report' output processing by other tools, such
         as Brendan Gregg's flamegraph tools (Namhyung Kim)
    
         E.g:
    
            # perf report | grep -v ^# | head
               18.37%     0.00%  swapper  [kernel.kallsyms]   [k] cpu_startup_entry
                               |
                               ---cpu_startup_entry
                                  |
                                  |--12.07%--start_secondary
                                  |
                                   --6.30%--rest_init
                                             start_kernel
                                             x86_64_start_reservations
                                             x86_64_start_kernel
             #
    
         Becomes, in "folded" mode:
    
            # perf report -g folded | grep -v ^# | head -5
                18.37%     0.00%  swapper [kernel.kallsyms]   [k] cpu_startup_entry
              12.07% cpu_startup_entry;start_secondary
               6.30% cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                16.90%     0.00%  swapper [kernel.kallsyms]   [k] call_cpuidle
              11.23% call_cpuidle;cpu_startup_entry;start_secondary
               5.67% call_cpuidle;cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                16.90%     0.00%  swapper [kernel.kallsyms]   [k] cpuidle_enter
              11.23% cpuidle_enter;call_cpuidle;cpu_startup_entry;start_secondary
               5.67% cpuidle_enter;call_cpuidle;cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                15.12%     0.00%  swapper [kernel.kallsyms]   [k] cpuidle_enter_state
             #
    
         The user can also select one of "count", "period" or "percent" as
         the first column.
    
      ... and lots of infrastructure enhancements, plus fixes and other
      changes, features I failed to list - see the shortlog and the git log
      for details"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (271 commits)
      perf evlist: Add --trace-fields option to show trace fields
      perf record: Store data mmaps for dwarf unwind
      perf libdw: Check for mmaps also in MAP__VARIABLE tree
      perf unwind: Check for mmaps also in MAP__VARIABLE tree
      perf unwind: Use find_map function in access_dso_mem
      perf evlist: Remove perf_evlist__(enable|disable)_event functions
      perf evlist: Make perf_evlist__open() open evsels with their cpus and threads (like perf record does)
      perf report: Show random usage tip on the help line
      perf hists: Export a couple of hist functions
      perf diff: Use perf_hpp__register_sort_field interface
      perf tools: Add overhead/overhead_children keys defaults via string
      perf tools: Remove list entry from struct sort_entry
      perf tools: Include all tools/lib directory for tags/cscope/TAGS targets
      perf script: Align event name properly
      perf tools: Add missing headers in perf's MANIFEST
      perf tools: Do not show trace command if it's not compiled in
      perf report: Change default to use event group view
      perf top: Decay periods in callchains
      tools lib: Move bitmap.[ch] from tools/perf/ to tools/{lib,include}/
      tools lib: Sync tools/lib/find_bit.c with the kernel
      ...

commit 153a4334c439cfb62e1d31cee0c790ba4157813d
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Dec 1 17:00:57 2015 -0800

    x86/headers: Don't include asm/processor.h in asm/atomic.h
    
    asm/atomic.h doesn't really need asm/processor.h anymore. Everything
    it uses has moved to other header files. So remove that include.
    
    processor.h is a nasty header that includes lots of
    other headers and makes it prone to include loops. Removing the
    include here makes asm/atomic.h a "leaf" header that can
    be safely included in most other headers.
    
    The only fallout is in the lib/atomic tester which relied on
    this implicit include. Give it an explicit include.
    (the include is in ifdef because the user is also in ifdef)
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Cc: rostedt@goodmis.org
    Link: http://lkml.kernel.org/r/1449018060-1742-1-git-send-email-andi@firstfloor.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 83c33a5bcffb..d51e25aa5f1d 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -16,6 +16,10 @@
 #include <linux/kernel.h>
 #include <linux/atomic.h>
 
+#ifdef CONFIG_X86
+#include <asm/processor.h>	/* for boot_cpu_has below */
+#endif
+
 #define TEST(bit, op, c_op, val)				\
 do {								\
 	atomic##bit##_set(&v, v0);				\

commit 978e5a3692c3b674b4c7c412e96835fd996c2ff4
Author: Boqun Feng <boqun.feng@gmail.com>
Date:   Wed Nov 4 18:52:45 2015 +0800

    atomics: Add test for atomic operations with _relaxed variants
    
    Some atomic operations now have _relaxed/acquire/release variants, this
    patch adds some trivial tests for two purposes:
    
      1. test the behavior of these new operations in single-CPU
         environment.
    
      2. make their code generated before we actually use them somewhere,
         so that we can examine their assembly code.
    
    Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <waiman.long@hp.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Link: http://lkml.kernel.org/r/1446634365-25176-1-git-send-email-boqun.feng@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 83c33a5bcffb..18e422b259cf 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -27,6 +27,65 @@ do {								\
 		(unsigned long long)r);				\
 } while (0)
 
+/*
+ * Test for a atomic operation family,
+ * @test should be a macro accepting parameters (bit, op, ...)
+ */
+
+#define FAMILY_TEST(test, bit, op, args...)	\
+do {						\
+	test(bit, op, ##args);		\
+	test(bit, op##_acquire, ##args);	\
+	test(bit, op##_release, ##args);	\
+	test(bit, op##_relaxed, ##args);	\
+} while (0)
+
+#define TEST_RETURN(bit, op, c_op, val)				\
+do {								\
+	atomic##bit##_set(&v, v0);				\
+	r = v0;							\
+	r c_op val;						\
+	BUG_ON(atomic##bit##_##op(val, &v) != r);		\
+	BUG_ON(atomic##bit##_read(&v) != r);			\
+} while (0)
+
+#define RETURN_FAMILY_TEST(bit, op, c_op, val)			\
+do {								\
+	FAMILY_TEST(TEST_RETURN, bit, op, c_op, val);		\
+} while (0)
+
+#define TEST_ARGS(bit, op, init, ret, expect, args...)		\
+do {								\
+	atomic##bit##_set(&v, init);				\
+	BUG_ON(atomic##bit##_##op(&v, ##args) != ret);		\
+	BUG_ON(atomic##bit##_read(&v) != expect);		\
+} while (0)
+
+#define XCHG_FAMILY_TEST(bit, init, new)				\
+do {									\
+	FAMILY_TEST(TEST_ARGS, bit, xchg, init, init, new, new);	\
+} while (0)
+
+#define CMPXCHG_FAMILY_TEST(bit, init, new, wrong)			\
+do {									\
+	FAMILY_TEST(TEST_ARGS, bit, cmpxchg, 				\
+			init, init, new, init, new);			\
+	FAMILY_TEST(TEST_ARGS, bit, cmpxchg,				\
+			init, init, init, wrong, new);			\
+} while (0)
+
+#define INC_RETURN_FAMILY_TEST(bit, i)			\
+do {							\
+	FAMILY_TEST(TEST_ARGS, bit, inc_return,		\
+			i, (i) + one, (i) + one);	\
+} while (0)
+
+#define DEC_RETURN_FAMILY_TEST(bit, i)			\
+do {							\
+	FAMILY_TEST(TEST_ARGS, bit, dec_return,		\
+			i, (i) - one, (i) - one);	\
+} while (0)
+
 static __init void test_atomic(void)
 {
 	int v0 = 0xaaa31337;
@@ -45,6 +104,18 @@ static __init void test_atomic(void)
 	TEST(, and, &=, v1);
 	TEST(, xor, ^=, v1);
 	TEST(, andnot, &= ~, v1);
+
+	RETURN_FAMILY_TEST(, add_return, +=, onestwos);
+	RETURN_FAMILY_TEST(, add_return, +=, -one);
+	RETURN_FAMILY_TEST(, sub_return, -=, onestwos);
+	RETURN_FAMILY_TEST(, sub_return, -=, -one);
+
+	INC_RETURN_FAMILY_TEST(, v0);
+	DEC_RETURN_FAMILY_TEST(, v0);
+
+	XCHG_FAMILY_TEST(, v0, v1);
+	CMPXCHG_FAMILY_TEST(, v0, v1, onestwos);
+
 }
 
 #define INIT(c) do { atomic64_set(&v, c); r = c; } while (0)
@@ -74,59 +145,26 @@ static __init void test_atomic64(void)
 	TEST(64, xor, ^=, v1);
 	TEST(64, andnot, &= ~, v1);
 
-	INIT(v0);
-	r += onestwos;
-	BUG_ON(atomic64_add_return(onestwos, &v) != r);
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	r += -one;
-	BUG_ON(atomic64_add_return(-one, &v) != r);
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	r -= onestwos;
-	BUG_ON(atomic64_sub_return(onestwos, &v) != r);
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	r -= -one;
-	BUG_ON(atomic64_sub_return(-one, &v) != r);
-	BUG_ON(v.counter != r);
+	RETURN_FAMILY_TEST(64, add_return, +=, onestwos);
+	RETURN_FAMILY_TEST(64, add_return, +=, -one);
+	RETURN_FAMILY_TEST(64, sub_return, -=, onestwos);
+	RETURN_FAMILY_TEST(64, sub_return, -=, -one);
 
 	INIT(v0);
 	atomic64_inc(&v);
 	r += one;
 	BUG_ON(v.counter != r);
 
-	INIT(v0);
-	r += one;
-	BUG_ON(atomic64_inc_return(&v) != r);
-	BUG_ON(v.counter != r);
-
 	INIT(v0);
 	atomic64_dec(&v);
 	r -= one;
 	BUG_ON(v.counter != r);
 
-	INIT(v0);
-	r -= one;
-	BUG_ON(atomic64_dec_return(&v) != r);
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	BUG_ON(atomic64_xchg(&v, v1) != v0);
-	r = v1;
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	BUG_ON(atomic64_cmpxchg(&v, v0, v1) != v0);
-	r = v1;
-	BUG_ON(v.counter != r);
+	INC_RETURN_FAMILY_TEST(64, v0);
+	DEC_RETURN_FAMILY_TEST(64, v0);
 
-	INIT(v0);
-	BUG_ON(atomic64_cmpxchg(&v, v2, v1) != v0);
-	BUG_ON(v.counter != r);
+	XCHG_FAMILY_TEST(64, v0, v1);
+	CMPXCHG_FAMILY_TEST(64, v0, v1, v2);
 
 	INIT(v0);
 	BUG_ON(atomic64_add_unless(&v, one, v0));

commit 41b9e9fcc1c44b84a785115058ce9c703e3fca6e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Jul 13 12:55:58 2015 +0200

    atomic: Add simple atomic_t tests
    
    Add a few atomic_t tests, gets some compile coverage for the new
    operations.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 0211d30d8c39..83c33a5bcffb 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -16,8 +16,39 @@
 #include <linux/kernel.h>
 #include <linux/atomic.h>
 
+#define TEST(bit, op, c_op, val)				\
+do {								\
+	atomic##bit##_set(&v, v0);				\
+	r = v0;							\
+	atomic##bit##_##op(val, &v);				\
+	r c_op val;						\
+	WARN(atomic##bit##_read(&v) != r, "%Lx != %Lx\n",	\
+		(unsigned long long)atomic##bit##_read(&v),	\
+		(unsigned long long)r);				\
+} while (0)
+
+static __init void test_atomic(void)
+{
+	int v0 = 0xaaa31337;
+	int v1 = 0xdeadbeef;
+	int onestwos = 0x11112222;
+	int one = 1;
+
+	atomic_t v;
+	int r;
+
+	TEST(, add, +=, onestwos);
+	TEST(, add, +=, -one);
+	TEST(, sub, -=, onestwos);
+	TEST(, sub, -=, -one);
+	TEST(, or, |=, v1);
+	TEST(, and, &=, v1);
+	TEST(, xor, ^=, v1);
+	TEST(, andnot, &= ~, v1);
+}
+
 #define INIT(c) do { atomic64_set(&v, c); r = c; } while (0)
-static __init int test_atomic64(void)
+static __init void test_atomic64(void)
 {
 	long long v0 = 0xaaa31337c001d00dLL;
 	long long v1 = 0xdeadbeefdeafcafeLL;
@@ -34,15 +65,14 @@ static __init int test_atomic64(void)
 	BUG_ON(v.counter != r);
 	BUG_ON(atomic64_read(&v) != r);
 
-	INIT(v0);
-	atomic64_add(onestwos, &v);
-	r += onestwos;
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	atomic64_add(-one, &v);
-	r += -one;
-	BUG_ON(v.counter != r);
+	TEST(64, add, +=, onestwos);
+	TEST(64, add, +=, -one);
+	TEST(64, sub, -=, onestwos);
+	TEST(64, sub, -=, -one);
+	TEST(64, or, |=, v1);
+	TEST(64, and, &=, v1);
+	TEST(64, xor, ^=, v1);
+	TEST(64, andnot, &= ~, v1);
 
 	INIT(v0);
 	r += onestwos;
@@ -54,16 +84,6 @@ static __init int test_atomic64(void)
 	BUG_ON(atomic64_add_return(-one, &v) != r);
 	BUG_ON(v.counter != r);
 
-	INIT(v0);
-	atomic64_sub(onestwos, &v);
-	r -= onestwos;
-	BUG_ON(v.counter != r);
-
-	INIT(v0);
-	atomic64_sub(-one, &v);
-	r -= -one;
-	BUG_ON(v.counter != r);
-
 	INIT(v0);
 	r -= onestwos;
 	BUG_ON(atomic64_sub_return(onestwos, &v) != r);
@@ -147,6 +167,12 @@ static __init int test_atomic64(void)
 	BUG_ON(!atomic64_inc_not_zero(&v));
 	r += one;
 	BUG_ON(v.counter != r);
+}
+
+static __init int test_atomics(void)
+{
+	test_atomic();
+	test_atomic64();
 
 #ifdef CONFIG_X86
 	pr_info("passed for %s platform %s CX8 and %s SSE\n",
@@ -166,4 +192,4 @@ static __init int test_atomic64(void)
 	return 0;
 }
 
-core_initcall(test_atomic64);
+core_initcall(test_atomics);

commit b3b16d284a4121a9eb294ec0012928591993b37c
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 4 16:12:00 2014 -0700

    lib/atomic64_test.c: convert printk(KERN_INFO to pr_info
    
    Convert printk to current pr_foo() logging functions.
    
    Also add pr_fmt based on KBUILD_MODNAME to avoid repeating prefix.  Prefix
    is now "atomic64_test: "
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Luca Barbieri <luca@luca-barbieri.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 00bca223d1e1..0211d30d8c39 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -8,6 +8,9 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/init.h>
 #include <linux/bug.h>
 #include <linux/kernel.h>
@@ -146,18 +149,18 @@ static __init int test_atomic64(void)
 	BUG_ON(v.counter != r);
 
 #ifdef CONFIG_X86
-	printk(KERN_INFO "atomic64 test passed for %s platform %s CX8 and %s SSE\n",
+	pr_info("passed for %s platform %s CX8 and %s SSE\n",
 #ifdef CONFIG_X86_64
-	       "x86-64",
+		"x86-64",
 #elif defined(CONFIG_X86_CMPXCHG64)
-	       "i586+",
+		"i586+",
 #else
-	       "i386+",
+		"i386+",
 #endif
 	       boot_cpu_has(X86_FEATURE_CX8) ? "with" : "without",
 	       boot_cpu_has(X86_FEATURE_XMM) ? "with" : "without");
 #else
-	printk(KERN_INFO "atomic64 test passed\n");
+	pr_info("passed\n");
 #endif
 
 	return 0;

commit 7463449b8287162454d7e00bf7fd2c64f72c1dc8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jul 30 14:41:09 2012 -0700

    atomic64_test: simplify the #ifdef for atomic64_dec_if_positive() test
    
    Introduce CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE and use this instead
    of the multitude of #if defined() checks in atomic64_test.c
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index cb99b91c3a1d..00bca223d1e1 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -114,8 +114,7 @@ static __init int test_atomic64(void)
 	r += one;
 	BUG_ON(v.counter != r);
 
-#if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \
-    defined(CONFIG_S390) || defined(_ASM_GENERIC_ATOMIC64_H) || defined(CONFIG_ARM)
+#ifdef CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;
@@ -129,7 +128,7 @@ static __init int test_atomic64(void)
 	BUG_ON(atomic64_dec_if_positive(&v) != (-one - one));
 	BUG_ON(v.counter != r);
 #else
-#warning Please implement atomic64_dec_if_positive for your architecture, and add it to the IF above
+#warning Please implement atomic64_dec_if_positive for your architecture and select the above Kconfig symbol
 #endif
 
 	INIT(onestwos);

commit 50af5ead3b44ccf8bd2b4d2a50c1b610f557c480
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jan 20 18:35:53 2012 -0500

    bug.h: add include of it to various implicit C users
    
    With bug.h currently living right in linux/kernel.h there
    are files that use BUG_ON and friends but are not including
    the header explicitly.  Fix them up so we can remove the
    presence in kernel.h file.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 0c33cde2a1e6..cb99b91c3a1d 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -9,6 +9,7 @@
  * (at your option) any later version.
  */
 #include <linux/init.h>
+#include <linux/bug.h>
 #include <linux/kernel.h>
 #include <linux/atomic.h>
 

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 44524cc8c32a..0c33cde2a1e6 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -10,7 +10,7 @@
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 #define INIT(c) do { atomic64_set(&v, c); r = c; } while (0)
 static __init int test_atomic64(void)

commit c58bbd39f876955be6e072748fdfe2b671f9d939
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Jul 8 10:59:59 2010 +0100

    ARM: 6213/1: atomic64_test: add ARM as supported architecture
    
    ARM has support for the atomic64_dec_if_positive operation
    so ensure that it is tested by the atomic64_test routine.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 250ed11d3ed2..44524cc8c32a 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -114,7 +114,7 @@ static __init int test_atomic64(void)
 	BUG_ON(v.counter != r);
 
 #if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \
-    defined(CONFIG_S390) || defined(_ASM_GENERIC_ATOMIC64_H)
+    defined(CONFIG_S390) || defined(_ASM_GENERIC_ATOMIC64_H) || defined(CONFIG_ARM)
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;

commit 007d08678eb87478b65b3f229960c81dd7c7b8f3
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Fri Jun 4 14:15:02 2010 -0700

    lib: add s390 to atomic64_dec_if_positive archs
    
    Add s390 to list of architectures that have atomic64_dec_if_positive
    implemented so we get rid of this warning:
    
    lib/atomic64_test.c:129:2: warning: #warning Please implement
    atomic64_dec_if_positive for your architecture, and add it to the IF above
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Luca Barbieri <luca@luca-barbieri.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 9087d71537dd..250ed11d3ed2 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -113,7 +113,8 @@ static __init int test_atomic64(void)
 	r += one;
 	BUG_ON(v.counter != r);
 
-#if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(_ASM_GENERIC_ATOMIC64_H)
+#if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \
+    defined(CONFIG_S390) || defined(_ASM_GENERIC_ATOMIC64_H)
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;

commit 0dbdd1bfe0b83798763540111118b78b70792f00
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon May 24 12:13:20 2010 -0700

    lib/atomic64_test: fix missing include of linux/kernel.h
    
    Fix a build-failure
    (http://kisskb.ellerman.id.au/kisskb/buildresult/2601239/) by adding the
    missing include file (linux/kernel.h) for printk and KERN_INFO.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    LKML-Reference: <201005241913.o4OJDKdf010884@imap1.linux-foundation.org>
    Cc: Luca Barbieri <luca@luca-barbieri.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 65e482caf5e9..9087d71537dd 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -9,6 +9,7 @@
  * (at your option) any later version.
  */
 #include <linux/init.h>
+#include <linux/kernel.h>
 #include <asm/atomic.h>
 
 #define INIT(c) do { atomic64_set(&v, c); r = c; } while (0)

commit a5c9161f27c3e1ae6c0094d262f03a7e98262181
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Mon Mar 1 11:49:23 2010 -0800

    x86, atomic64: In selftest, distinguish x86-64 from 586+
    
    The x86-64 implementation of the atomics is totally different from the
    i586+ implementation, which makes it quite confusing to call it
    "586+".  Also fix indentation, and add "i" for "i386" and "i586" as
    used elsewhere in the kernel.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267005265-27958-4-git-send-email-luca@luca-barbieri.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index f7bb706c9c3a..65e482caf5e9 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -144,14 +144,16 @@ static __init int test_atomic64(void)
 	BUG_ON(v.counter != r);
 
 #ifdef CONFIG_X86
-	printk(KERN_INFO "atomic64 test passed for %s+ platform %s CX8 and %s SSE\n",
-#ifdef CONFIG_X86_CMPXCHG64
-			"586",
+	printk(KERN_INFO "atomic64 test passed for %s platform %s CX8 and %s SSE\n",
+#ifdef CONFIG_X86_64
+	       "x86-64",
+#elif defined(CONFIG_X86_CMPXCHG64)
+	       "i586+",
 #else
-			"386",
+	       "i386+",
 #endif
-			boot_cpu_has(X86_FEATURE_CX8) ? "with" : "without",
-			boot_cpu_has(X86_FEATURE_XMM) ? "with" : "without");
+	       boot_cpu_has(X86_FEATURE_CX8) ? "with" : "without",
+	       boot_cpu_has(X86_FEATURE_XMM) ? "with" : "without");
 #else
 	printk(KERN_INFO "atomic64 test passed\n");
 #endif

commit 25a304f277ad70166eeae25a4958d2049005c33a
Author: Luca Barbieri <luca@luca-barbieri.com>
Date:   Mon Mar 1 19:55:48 2010 +0100

    lib: Fix atomic64_inc_not_zero test
    
    atomic64_inc_not_zero must return 1 if it perfomed the add and 0 otherwise.
    The test assumed the opposite convention.
    
    Signed-off-by: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267469749-11878-5-git-send-email-luca@luca-barbieri.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index ee8e6de8b413..f7bb706c9c3a 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -130,16 +130,16 @@ static __init int test_atomic64(void)
 #endif
 
 	INIT(onestwos);
-	BUG_ON(atomic64_inc_not_zero(&v));
+	BUG_ON(!atomic64_inc_not_zero(&v));
 	r += one;
 	BUG_ON(v.counter != r);
 
 	INIT(0);
-	BUG_ON(!atomic64_inc_not_zero(&v));
+	BUG_ON(atomic64_inc_not_zero(&v));
 	BUG_ON(v.counter != r);
 
 	INIT(-one);
-	BUG_ON(atomic64_inc_not_zero(&v));
+	BUG_ON(!atomic64_inc_not_zero(&v));
 	r += one;
 	BUG_ON(v.counter != r);
 

commit 9efbcd590243045111670c171a951923b877b57d
Author: Luca Barbieri <luca@luca-barbieri.com>
Date:   Mon Mar 1 19:55:45 2010 +0100

    lib: Fix atomic64_add_unless test
    
    atomic64_add_unless must return 1 if it perfomed the add and 0 otherwise.
    The test assumed the opposite convention.
    
    Reported-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267469749-11878-2-git-send-email-luca@luca-barbieri.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 58efdabb3845..ee8e6de8b413 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -104,11 +104,11 @@ static __init int test_atomic64(void)
 	BUG_ON(v.counter != r);
 
 	INIT(v0);
-	BUG_ON(!atomic64_add_unless(&v, one, v0));
+	BUG_ON(atomic64_add_unless(&v, one, v0));
 	BUG_ON(v.counter != r);
 
 	INIT(v0);
-	BUG_ON(atomic64_add_unless(&v, one, v1));
+	BUG_ON(!atomic64_add_unless(&v, one, v1));
 	r += one;
 	BUG_ON(v.counter != r);
 

commit d7f6de1e9c4a12e11ba7186c70f0f40caa76f590
Author: Luca Barbieri <luca@luca-barbieri.com>
Date:   Fri Feb 26 12:22:41 2010 +0100

    x86: Implement atomic[64]_dec_if_positive()
    
    Add support for atomic_dec_if_positive(), and
    atomic64_dec_if_positive() for x86-64.
    
    atomic64_dec_if_positive() for x86-32 was already implemented in a previous patch.
    
    Signed-off-by: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267183361-20775-2-git-send-email-luca@luca-barbieri.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 0effcacbebda..58efdabb3845 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -112,7 +112,7 @@ static __init int test_atomic64(void)
 	r += one;
 	BUG_ON(v.counter != r);
 
-#if defined(CONFIG_X86_32) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(_ASM_GENERIC_ATOMIC64_H)
+#if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(_ASM_GENERIC_ATOMIC64_H)
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;

commit 8f4f202b335144bf5be5c9e5b1bc9477ecdae958
Author: Luca Barbieri <luca@luca-barbieri.com>
Date:   Fri Feb 26 12:22:40 2010 +0100

    lib: Only test atomic64_dec_if_positive on archs having it
    
    Currently atomic64_dec_if_positive() is only supported by PowerPC,
    MIPS and x86-32.
    
    Signed-off-by: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267183361-20775-1-git-send-email-luca@luca-barbieri.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
index 4ff649e46bad..0effcacbebda 100644
--- a/lib/atomic64_test.c
+++ b/lib/atomic64_test.c
@@ -112,6 +112,7 @@ static __init int test_atomic64(void)
 	r += one;
 	BUG_ON(v.counter != r);
 
+#if defined(CONFIG_X86_32) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(_ASM_GENERIC_ATOMIC64_H)
 	INIT(onestwos);
 	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
 	r -= one;
@@ -124,6 +125,9 @@ static __init int test_atomic64(void)
 	INIT(-one);
 	BUG_ON(atomic64_dec_if_positive(&v) != (-one - one));
 	BUG_ON(v.counter != r);
+#else
+#warning Please implement atomic64_dec_if_positive for your architecture, and add it to the IF above
+#endif
 
 	INIT(onestwos);
 	BUG_ON(atomic64_inc_not_zero(&v));

commit 86a8938078a8bb518c5376de493e348c7490d506
Author: Luca Barbieri <luca@luca-barbieri.com>
Date:   Wed Feb 24 10:54:24 2010 +0100

    lib: Add self-test for atomic64_t
    
    This patch adds self-test on boot code for atomic64_t.
    
    This has been used to test the later changes in this patchset.
    
    Signed-off-by: Luca Barbieri <luca@luca-barbieri.com>
    LKML-Reference: <1267005265-27958-4-git-send-email-luca@luca-barbieri.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/lib/atomic64_test.c b/lib/atomic64_test.c
new file mode 100644
index 000000000000..4ff649e46bad
--- /dev/null
+++ b/lib/atomic64_test.c
@@ -0,0 +1,158 @@
+/*
+ * Testsuite for atomic64_t functions
+ *
+ * Copyright Â© 2010  Luca Barbieri
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/init.h>
+#include <asm/atomic.h>
+
+#define INIT(c) do { atomic64_set(&v, c); r = c; } while (0)
+static __init int test_atomic64(void)
+{
+	long long v0 = 0xaaa31337c001d00dLL;
+	long long v1 = 0xdeadbeefdeafcafeLL;
+	long long v2 = 0xfaceabadf00df001LL;
+	long long onestwos = 0x1111111122222222LL;
+	long long one = 1LL;
+
+	atomic64_t v = ATOMIC64_INIT(v0);
+	long long r = v0;
+	BUG_ON(v.counter != r);
+
+	atomic64_set(&v, v1);
+	r = v1;
+	BUG_ON(v.counter != r);
+	BUG_ON(atomic64_read(&v) != r);
+
+	INIT(v0);
+	atomic64_add(onestwos, &v);
+	r += onestwos;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	atomic64_add(-one, &v);
+	r += -one;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r += onestwos;
+	BUG_ON(atomic64_add_return(onestwos, &v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r += -one;
+	BUG_ON(atomic64_add_return(-one, &v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	atomic64_sub(onestwos, &v);
+	r -= onestwos;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	atomic64_sub(-one, &v);
+	r -= -one;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r -= onestwos;
+	BUG_ON(atomic64_sub_return(onestwos, &v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r -= -one;
+	BUG_ON(atomic64_sub_return(-one, &v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	atomic64_inc(&v);
+	r += one;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r += one;
+	BUG_ON(atomic64_inc_return(&v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	atomic64_dec(&v);
+	r -= one;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	r -= one;
+	BUG_ON(atomic64_dec_return(&v) != r);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	BUG_ON(atomic64_xchg(&v, v1) != v0);
+	r = v1;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	BUG_ON(atomic64_cmpxchg(&v, v0, v1) != v0);
+	r = v1;
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	BUG_ON(atomic64_cmpxchg(&v, v2, v1) != v0);
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	BUG_ON(!atomic64_add_unless(&v, one, v0));
+	BUG_ON(v.counter != r);
+
+	INIT(v0);
+	BUG_ON(atomic64_add_unless(&v, one, v1));
+	r += one;
+	BUG_ON(v.counter != r);
+
+	INIT(onestwos);
+	BUG_ON(atomic64_dec_if_positive(&v) != (onestwos - 1));
+	r -= one;
+	BUG_ON(v.counter != r);
+
+	INIT(0);
+	BUG_ON(atomic64_dec_if_positive(&v) != -one);
+	BUG_ON(v.counter != r);
+
+	INIT(-one);
+	BUG_ON(atomic64_dec_if_positive(&v) != (-one - one));
+	BUG_ON(v.counter != r);
+
+	INIT(onestwos);
+	BUG_ON(atomic64_inc_not_zero(&v));
+	r += one;
+	BUG_ON(v.counter != r);
+
+	INIT(0);
+	BUG_ON(!atomic64_inc_not_zero(&v));
+	BUG_ON(v.counter != r);
+
+	INIT(-one);
+	BUG_ON(atomic64_inc_not_zero(&v));
+	r += one;
+	BUG_ON(v.counter != r);
+
+#ifdef CONFIG_X86
+	printk(KERN_INFO "atomic64 test passed for %s+ platform %s CX8 and %s SSE\n",
+#ifdef CONFIG_X86_CMPXCHG64
+			"586",
+#else
+			"386",
+#endif
+			boot_cpu_has(X86_FEATURE_CX8) ? "with" : "without",
+			boot_cpu_has(X86_FEATURE_XMM) ? "with" : "without");
+#else
+	printk(KERN_INFO "atomic64 test passed\n");
+#endif
+
+	return 0;
+}
+
+core_initcall(test_atomic64);
