commit f558b8364e19f9222e7976c64e9367f66bab02cc
Merge: 80ef846e9909 8c3e315d4296
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 7 10:53:36 2020 -0700

    Merge tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of driver core patches for 5.8-rc1.
    
      Not all that huge this release, just a number of small fixes and
      updates:
    
       - software node fixes
    
       - kobject now sends KOBJ_REMOVE when it is removed from sysfs, not
         when it is removed from memory (which could come much later)
    
       - device link additions and fixes based on testing on more devices
    
       - firmware core cleanups
    
       - other minor changes, full details in the shortlog
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (23 commits)
      driver core: Update device link status correctly for SYNC_STATE_ONLY links
      firmware_loader: change enum fw_opt to u32
      software node: implement software_node_unregister()
      kobject: send KOBJ_REMOVE uevent when the object is removed from sysfs
      driver core: Remove unnecessary is_fwnode_dev variable in device_add()
      drivers property: When no children in primary, try secondary
      driver core: platform: Fix spelling errors in platform.c
      driver core: Remove check in driver_deferred_probe_force_trigger()
      of: platform: Batch fwnode parsing when adding all top level devices
      driver core: fw_devlink: Add support for batching fwnode parsing
      driver core: Look for waiting consumers only for a fwnode's primary device
      driver core: Move code to the right part of the file
      Revert "Revert "driver core: Set fw_devlink to "permissive" behavior by default""
      drivers: base: Fix NULL pointer exception in __platform_driver_probe() if a driver developer is foolish
      firmware_loader: move fw_fallback_config to a private kernel symbol namespace
      driver core: Add missing '\n' in log messages
      driver/base/soc: Use kobj_to_dev() API
      Add documentation on meaning of -EPROBE_DEFER
      driver core: platform: remove redundant assignment to variable ret
      debugfs: Use the correct style for SPDX License Identifier
      ...

commit ca1f5df23f28228c46aa45d934abad38c6b6ff2e
Merge: 4d67829e1186 8b390ab725fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 1 12:13:30 2020 -0700

    Merge tag 'printk-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux
    
    Pull printk updates from Petr Mladek:
    
     - Benjamin Herrenschmidt solved a problem with non-matched console
       aliases by first checking consoles defined on the command line. It is
       a more conservative approach than the previous attempts.
    
     - Benjamin also made sure that the console accessible via /dev/console
       always has CON_CONSDEV flag.
    
     - Andy Shevchenko added the %ptT modifier for printing struct time64_t.
       It extends the existing %ptR handling for struct rtc_time.
    
     - Bruno Meneguele fixed /dev/kmsg error value returned by unsupported
       SEEK_CUR.
    
     - Tetsuo Handa removed unused pr_cont_once().
    
    ... and a few small fixes.
    
    * tag 'printk-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/printk/linux:
      printk: Remove pr_cont_once()
      printk: handle blank console arguments passed in.
      kernel/printk: add kmsg SEEK_CUR handling
      printk: Fix a typo in comment "interator"->"iterator"
      usb: pulse8-cec: Switch to use %ptT
      ARM: bcm2835: Switch to use %ptT
      lib/vsprintf: Print time64_t in human readable format
      lib/vsprintf: update comment about simple_strto<foo>() functions
      printk: Correctly set CON_CONSDEV even when preferred console was not registered
      printk: Fix preferred console selection with multiple matches
      printk: Move console matching logic into a separate function
      printk: Convert a use of sprintf to snprintf in console_unlock

commit 46d26819a5056f4831649c5887ad5c71a16d86f7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun May 24 17:30:40 2020 +0200

    software node: implement software_node_unregister()
    
    Sometimes it is better to unregister individual nodes instead of trying
    to do them all at once with software_node_unregister_nodes(), so create
    software_node_unregister() so that you can unregister them one at a
    time.
    
    This is especially important when creating nodes in a hierarchy, with
    parent -> children representations.  Children always need to be removed
    before a parent is, as the swnode logic assumes this is going to be the
    case.
    
    Fix up the lib/test_printf.c fwnode_pointer() test which to use this new
    function as it had the problem of tearing things down in the backwards
    order.
    
    Fixes: f1ce39df508d ("lib/test_printf: Add tests for %pfw printk modifier")
    Cc: stable <stable@vger.kernel.org>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Brendan Higgins <brendanhiggins@google.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Reported-by: Naresh Kamboju <naresh.kamboju@linaro.org>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Tested-by: Petr Mladek <pmladek@suse.com>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Link: https://lore.kernel.org/r/20200524153041.2361-1-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 6b1622f4d7c2..fc63b8959d42 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -637,7 +637,9 @@ static void __init fwnode_pointer(void)
 	test(second_name, "%pfwP", software_node_fwnode(&softnodes[1]));
 	test(third_name, "%pfwP", software_node_fwnode(&softnodes[2]));
 
-	software_node_unregister_nodes(softnodes);
+	software_node_unregister(&softnodes[2]);
+	software_node_unregister(&softnodes[1]);
+	software_node_unregister(&softnodes[0]);
 }
 
 static void __init

commit 7daac5b2fdf88e3c3e84cf0d577f524beb0244ab
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 15 20:00:44 2020 +0300

    lib/vsprintf: Print time64_t in human readable format
    
    There are users which print time and date represented by content of
    time64_t type in human readable format.
    
    Instead of open coding that each time introduce %ptT[dt][r] specifier.
    
    Few test cases for %ptT specifier has been added as well.
    
    Link: https://lore.kernel.org/r/20200415170046.33374-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Rewieved-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 2d9f520d2f27..6dc0a6c33b8c 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -478,7 +478,7 @@ struct_va_format(void)
 }
 
 static void __init
-struct_rtc_time(void)
+time_and_date(void)
 {
 	/* 1543210543 */
 	const struct rtc_time tm = {
@@ -489,14 +489,21 @@ struct_rtc_time(void)
 		.tm_mon = 10,
 		.tm_year = 118,
 	};
+	/* 2019-01-04T15:32:23 */
+	time64_t t = 1546615943;
 
-	test("(%ptR?)", "%pt", &tm);
+	test("(%pt?)", "%pt", &tm);
 	test("2018-11-26T05:35:43", "%ptR", &tm);
 	test("0118-10-26T05:35:43", "%ptRr", &tm);
 	test("05:35:43|2018-11-26", "%ptRt|%ptRd", &tm, &tm);
 	test("05:35:43|0118-10-26", "%ptRtr|%ptRdr", &tm, &tm);
 	test("05:35:43|2018-11-26", "%ptRttr|%ptRdtr", &tm, &tm);
 	test("05:35:43 tr|2018-11-26 tr", "%ptRt tr|%ptRd tr", &tm, &tm);
+
+	test("2019-01-04T15:32:23", "%ptT", &t);
+	test("0119-00-04T15:32:23", "%ptTr", &t);
+	test("15:32:23|2019-01-04", "%ptTt|%ptTd", &t, &t);
+	test("15:32:23|0119-00-04", "%ptTtr|%ptTdr", &t, &t);
 }
 
 static void __init
@@ -661,7 +668,7 @@ test_pointer(void)
 	uuid();
 	dentry();
 	struct_va_format();
-	struct_rtc_time();
+	time_and_date();
 	struct_clk();
 	bitmap();
 	netdev_features();

commit 7bd57fbc4a4ddedc664cad0bbced1b469e24e921
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue May 19 13:26:57 2020 +0200

    vsprintf: don't obfuscate NULL and error pointers
    
    I don't see what security concern is addressed by obfuscating NULL
    and IS_ERR() error pointers, printed with %p/%pK.  Given the number
    of sites where %p is used (over 10000) and the fact that NULL pointers
    aren't uncommon, it probably wouldn't take long for an attacker to
    find the hash that corresponds to 0.  Although harder, the same goes
    for most common error values, such as -1, -2, -11, -14, etc.
    
    The NULL part actually fixes a regression: NULL pointers weren't
    obfuscated until commit 3e5903eb9cff ("vsprintf: Prevent crash when
    dereferencing invalid pointers") which went into 5.2.  I'm tacking
    the IS_ERR() part on here because error pointers won't leak kernel
    addresses and printing them as pointers shouldn't be any different
    from e.g. %d with PTR_ERR_OR_ZERO().  Obfuscating them just makes
    debugging based on existing pr_debug and friends excruciating.
    
    Note that the "always print 0's for %pK when kptr_restrict == 2"
    behaviour which goes way back is left as is.
    
    Example output with the patch applied:
    
                                 ptr         error-ptr              NULL
     %p:            0000000001f8cc5b  fffffffffffffff2  0000000000000000
     %pK, kptr = 0: 0000000001f8cc5b  fffffffffffffff2  0000000000000000
     %px:           ffff888048c04020  fffffffffffffff2  0000000000000000
     %pK, kptr = 1: ffff888048c04020  fffffffffffffff2  0000000000000000
     %pK, kptr = 2: 0000000000000000  0000000000000000  0000000000000000
    
    Fixes: 3e5903eb9cff ("vsprintf: Prevent crash when dereferencing invalid pointers")
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 2d9f520d2f27..6b1622f4d7c2 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -214,6 +214,7 @@ test_string(void)
 #define PTR_STR "ffff0123456789ab"
 #define PTR_VAL_NO_CRNG "(____ptrval____)"
 #define ZEROS "00000000"	/* hex 32 zero bits */
+#define ONES "ffffffff"		/* hex 32 one bits */
 
 static int __init
 plain_format(void)
@@ -245,6 +246,7 @@ plain_format(void)
 #define PTR_STR "456789ab"
 #define PTR_VAL_NO_CRNG "(ptrval)"
 #define ZEROS ""
+#define ONES ""
 
 static int __init
 plain_format(void)
@@ -330,14 +332,28 @@ test_hashed(const char *fmt, const void *p)
 	test(buf, fmt, p);
 }
 
+/*
+ * NULL pointers aren't hashed.
+ */
 static void __init
 null_pointer(void)
 {
-	test_hashed("%p", NULL);
+	test(ZEROS "00000000", "%p", NULL);
 	test(ZEROS "00000000", "%px", NULL);
 	test("(null)", "%pE", NULL);
 }
 
+/*
+ * Error pointers aren't hashed.
+ */
+static void __init
+error_pointer(void)
+{
+	test(ONES "fffffff5", "%p", ERR_PTR(-11));
+	test(ONES "fffffff5", "%px", ERR_PTR(-11));
+	test("(efault)", "%pE", ERR_PTR(-11));
+}
+
 #define PTR_INVALID ((void *)0x000000ab)
 
 static void __init
@@ -649,6 +665,7 @@ test_pointer(void)
 {
 	plain();
 	null_pointer();
+	error_pointer();
 	invalid_pointer();
 	symbol_ptr();
 	kernel_ptr();

commit 361b0d286afea0d867537536977a695b5557d133
Merge: 6e9f879684b4 1afc14032e54
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 26 19:45:12 2019 -0800

    Merge tag 'devprop-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "Add support for printing fwnode names using a new conversion specifier
      "%pfw" (Sakari Ailus), clean up the software node and
      efi/apple-properties code in preparation for improved software node
      reference properties handling (Dmitry Torokhov) and fix the struct
      fwnode_operations description (Heikki Krogerus)"
    
    * tag 'devprop-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (22 commits)
      software node: simplify property_entry_read_string_array()
      software node: unify PROPERTY_ENTRY_XXX macros
      software node: remove property_entry_read_uNN_array functions
      software node: get rid of property_set_pointer()
      software node: clean up property_copy_string_array()
      software node: mark internal macros with double underscores
      efi/apple-properties: use PROPERTY_ENTRY_U8_ARRAY_LEN
      software node: introduce PROPERTY_ENTRY_XXX_ARRAY_LEN()
      software node: remove DEV_PROP_MAX
      device property: Fix the description of struct fwnode_operations
      lib/test_printf: Add tests for %pfw printk modifier
      lib/vsprintf: Add %pfw conversion specifier for printing fwnode names
      lib/vsprintf: OF nodes are first and foremost, struct device_nodes
      lib/vsprintf: Make use of fwnode API to obtain node names and separators
      lib/vsprintf: Add a note on re-using %pf or %pF
      lib/vsprintf: Remove support for %pF and %pf in favour of %pS and %ps
      device property: Add a function to obtain a node's prefix
      device property: Add fwnode_get_name for returning the name of a node
      device property: Add functions for accessing node's parents
      device property: Move fwnode_get_parent() up
      ...

commit 57f5677e535ba24b8926a7125be2ef8d7f09323c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue Oct 15 21:07:05 2019 +0200

    printf: add support for printing symbolic error names
    
    It has been suggested several times to extend vsnprintf() to be able
    to convert the numeric value of ENOSPC to print "ENOSPC". This
    implements that as a %p extension: With %pe, one can do
    
      if (IS_ERR(foo)) {
        pr_err("Sorry, can't do that: %pe\n", foo);
        return PTR_ERR(foo);
      }
    
    instead of what is seen in quite a few places in the kernel:
    
      if (IS_ERR(foo)) {
        pr_err("Sorry, can't do that: %ld\n", PTR_ERR(foo));
        return PTR_ERR(foo);
      }
    
    If the value passed to %pe is an ERR_PTR, but the library function
    errname() added here doesn't know about the value, the value is simply
    printed in decimal. If the value passed to %pe is not an ERR_PTR, we
    treat it as an ordinary %p and thus print the hashed value (passing
    non-ERR_PTR values to %pe indicates a bug in the caller, but we can't
    do much about that).
    
    With my embedded hat on, and because it's not very invasive to do,
    I've made it possible to remove this. The errname() function and
    associated lookup tables take up about 3K. For most, that's probably
    quite acceptable and a price worth paying for more readable
    dmesg (once this starts getting used), while for those that disable
    printk() it's of very little use - I don't see a
    procfs/sysfs/seq_printf() file reasonably making use of this - and
    they clearly want to squeeze vmlinux as much as possible. Hence the
    default y if PRINTK.
    
    The symbols to include have been found by massaging the output of
    
      find arch include -iname 'errno*.h' | xargs grep -E 'define\s*E'
    
    In the cases where some common aliasing exists
    (e.g. EAGAIN=EWOULDBLOCK on all platforms, EDEADLOCK=EDEADLK on most),
    I've moved the more popular one (in terms of 'git grep -w Efoo | wc)
    to the bottom so that one takes precedence.
    
    Link: http://lkml.kernel.org/r/20191015190706.15989-1-linux@rasmusvillemoes.dk
    To: "Jonathan Corbet" <corbet@lwn.net>
    To: linux-kernel@vger.kernel.org
    Cc: "Andy Shevchenko" <andy.shevchenko@gmail.com>
    Cc: "Andrew Morton" <akpm@linux-foundation.org>
    Cc: "Joe Perches" <joe@perches.com>
    Cc: linux-doc@vger.kernel.org
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Uwe Kleine-König <uwe@kleine-koenig.org>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    [andy.shevchenko@gmail.com: use abs()]
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 5d94cbff2120..030daeb4fe21 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -593,6 +593,26 @@ flags(void)
 	kfree(cmp_buffer);
 }
 
+static void __init
+errptr(void)
+{
+	test("-1234", "%pe", ERR_PTR(-1234));
+
+	/* Check that %pe with a non-ERR_PTR gets treated as ordinary %p. */
+	BUILD_BUG_ON(IS_ERR(PTR));
+	test_hashed("%pe", PTR);
+
+#ifdef CONFIG_SYMBOLIC_ERRNAME
+	test("(-ENOTSOCK)", "(%pe)", ERR_PTR(-ENOTSOCK));
+	test("(-EAGAIN)", "(%pe)", ERR_PTR(-EAGAIN));
+	BUILD_BUG_ON(EAGAIN != EWOULDBLOCK);
+	test("(-EAGAIN)", "(%pe)", ERR_PTR(-EWOULDBLOCK));
+	test("[-EIO    ]", "[%-8pe]", ERR_PTR(-EIO));
+	test("[    -EIO]", "[%8pe]", ERR_PTR(-EIO));
+	test("-EPROBE_DEFER", "%pe", ERR_PTR(-EPROBE_DEFER));
+#endif
+}
+
 static void __init
 test_pointer(void)
 {
@@ -615,6 +635,7 @@ test_pointer(void)
 	bitmap();
 	netdev_features();
 	flags();
+	errptr();
 }
 
 static void __init selftest(void)

commit f1ce39df508de4a4abd83daa3e589ccea46b1480
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Oct 3 15:32:19 2019 +0300

    lib/test_printf: Add tests for %pfw printk modifier
    
    Add a test for the %pfw printk modifier using software nodes.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 5d94cbff2120..422b847db424 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -22,6 +22,8 @@
 #include <linux/gfp.h>
 #include <linux/mm.h>
 
+#include <linux/property.h>
+
 #include "../tools/testing/selftests/kselftest_module.h"
 
 #define BUF_SIZE 256
@@ -593,6 +595,35 @@ flags(void)
 	kfree(cmp_buffer);
 }
 
+static void __init fwnode_pointer(void)
+{
+	const struct software_node softnodes[] = {
+		{ .name = "first", },
+		{ .name = "second", .parent = &softnodes[0], },
+		{ .name = "third", .parent = &softnodes[1], },
+		{ NULL /* Guardian */ }
+	};
+	const char * const full_name = "first/second/third";
+	const char * const full_name_second = "first/second";
+	const char * const second_name = "second";
+	const char * const third_name = "third";
+	int rval;
+
+	rval = software_node_register_nodes(softnodes);
+	if (rval) {
+		pr_warn("cannot register softnodes; rval %d\n", rval);
+		return;
+	}
+
+	test(full_name_second, "%pfw", software_node_fwnode(&softnodes[1]));
+	test(full_name, "%pfw", software_node_fwnode(&softnodes[2]));
+	test(full_name, "%pfwf", software_node_fwnode(&softnodes[2]));
+	test(second_name, "%pfwP", software_node_fwnode(&softnodes[1]));
+	test(third_name, "%pfwP", software_node_fwnode(&softnodes[2]));
+
+	software_node_unregister_nodes(softnodes);
+}
+
 static void __init
 test_pointer(void)
 {
@@ -615,6 +646,7 @@ test_pointer(void)
 	bitmap();
 	netdev_features();
 	flags();
+	fwnode_pointer();
 }
 
 static void __init selftest(void)

commit 8ebea6ea1a7ed5d67ecbb2a493c716a2a89c0be2
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Aug 15 17:01:33 2019 +0200

    lib/test_printf: Remove obvious comments from %pd and %pD tests
    
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index befedffeb476..5d94cbff2120 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -455,10 +455,8 @@ dentry(void)
 	test("foo", "%pd", &test_dentry[0]);
 	test("foo", "%pd2", &test_dentry[0]);
 
-	/* test the null/invalid pointer case for dentry */
 	test("(null)", "%pd", NULL);
 	test("(efault)", "%pd", PTR_INVALID);
-	/* test the null/invalid pointer case for file */
 	test("(null)", "%pD", NULL);
 	test("(efault)", "%pD", PTR_INVALID);
 

commit cf6b7921fc19e537cd5ae88460195c8599eb5d9d
Author: Jia He <justin.he@arm.com>
Date:   Fri Aug 9 09:24:57 2019 +0800

    lib/test_printf: Add test of null/invalid pointer dereference for dentry
    
    This add some additional test cases of null/invalid pointer dereference
    for dentry and file (%pd and %pD)
    
    Link: http://lkml.kernel.org/r/20190809012457.56685-2-justin.he@arm.com
    To: Geert Uytterhoeven <geert+renesas@glider.be>
    To: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    To: Thomas Gleixner <tglx@linutronix.de>
    To: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    To: Petr Mladek <pmladek@suse.com>
    To: linux-kernel@vger.kernel.org
    Cc: Kees Cook <keescook@chromium.org>
    Cc: "Steven Rostedt (VMware)" <rostedt@goodmis.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: "Tobin C. Harding" <tobin@kernel.org>
    Signed-off-by: Jia He <justin.he@arm.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 944eb50f3862..befedffeb476 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -455,6 +455,13 @@ dentry(void)
 	test("foo", "%pd", &test_dentry[0]);
 	test("foo", "%pd2", &test_dentry[0]);
 
+	/* test the null/invalid pointer case for dentry */
+	test("(null)", "%pd", NULL);
+	test("(efault)", "%pd", PTR_INVALID);
+	/* test the null/invalid pointer case for file */
+	test("(null)", "%pD", NULL);
+	test("(efault)", "%pD", PTR_INVALID);
+
 	test("romeo", "%pd", &test_dentry[3]);
 	test("alfa/romeo", "%pd2", &test_dentry[3]);
 	test("bravo/alfa/romeo", "%pd3", &test_dentry[3]);

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 93da0a5000ec..944eb50f3862 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Test cases for printf facility.
  */

commit 0968621917add2e0d60c8fbc4e24c670cb14319c
Merge: 573de2a6e844 0f46c78391e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 09:18:12 2019 -0700

    Merge tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow state reset of printk_once() calls.
    
     - Prevent crashes when dereferencing invalid pointers in vsprintf().
       Only the first byte is checked for simplicity.
    
     - Make vsprintf warnings consistent and inlined.
    
     - Treewide conversion of obsolete %pf, %pF to %ps, %pF printf
       modifiers.
    
     - Some clean up of vsprintf and test_printf code.
    
    * tag 'printk-for-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk:
      lib/vsprintf: Make function pointer_string static
      vsprintf: Limit the length of inlined error messages
      vsprintf: Avoid confusion between invalid address and value
      vsprintf: Prevent crash when dereferencing invalid pointers
      vsprintf: Consolidate handling of unknown pointer specifiers
      vsprintf: Factor out %pO handler as kobject_string()
      vsprintf: Factor out %pV handler as va_format()
      vsprintf: Factor out %p[iI] handler as ip_addr_string()
      vsprintf: Do not check address of well-known strings
      vsprintf: Consistent %pK handling for kptr_restrict == 0
      vsprintf: Shuffle restricted_pointer()
      printk: Tie printk_once / printk_deferred_once into .data.once for reset
      treewide: Switch printk users from %pf and %pF to %ps and %pS, respectively
      lib/test_printf: Switch to bitmap_zalloc()

commit 35e1547511fcb035437b4527184458adfb0e8f43
Merge: 3ec25826ae33 ce9d3eceb7ff
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon May 6 10:32:45 2019 +0200

    Merge branch 'for-5.2-vsprintf-hardening' into for-linus

commit 3e5903eb9cff707301712498aed9e34b3e2ee883
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Apr 17 13:53:48 2019 +0200

    vsprintf: Prevent crash when dereferencing invalid pointers
    
    We already prevent crash when dereferencing some obviously broken
    pointers. But the handling is not consistent. Sometimes we print "(null)"
    only for pure NULL pointer, sometimes for pointers in the first
    page and sometimes also for pointers in the last page (error codes).
    
    Note that printk() call this code under logbuf_lock. Any recursive
    printks are redirected to the printk_safe implementation and the messages
    are stored into per-CPU buffers. These buffers might be eventually flushed
    in printk_safe_flush_on_panic() but it is not guaranteed.
    
    This patch adds a check using probe_kernel_read(). It is not a full-proof
    test. But it should help to see the error message in 99% situations where
    the kernel would silently crash otherwise.
    
    Also it makes the error handling unified for "%s" and the many %p*
    specifiers that need to read the data from a given address. We print:
    
       + (null)   when accessing data on pure pure NULL address
       + (efault) when accessing data on an invalid address
    
    It does not affect the %p* specifiers that just print the given address
    in some form, namely %pF, %pf, %pS, %ps, %pB, %pK, %px, and plain %p.
    
    Note that we print (efault) from security reasons. In fact, the real
    address can be seen only by %px or eventually %pK.
    
    Link: http://lkml.kernel.org/r/20190417115350.20479-9-pmladek@suse.com
    To: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "Tobin C . Harding" <me@tobin.cc>
    Cc: Joe Perches <joe@perches.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 250ee864b8b8..359ae4fb1ece 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -239,6 +239,7 @@ plain_format(void)
 #define PTR ((void *)0x456789ab)
 #define PTR_STR "456789ab"
 #define PTR_VAL_NO_CRNG "(ptrval)"
+#define ZEROS ""
 
 static int __init
 plain_format(void)
@@ -268,7 +269,6 @@ plain_hash_to_buffer(const void *p, char *buf, size_t len)
 	return 0;
 }
 
-
 static int __init
 plain_hash(void)
 {
@@ -325,6 +325,24 @@ test_hashed(const char *fmt, const void *p)
 	test(buf, fmt, p);
 }
 
+static void __init
+null_pointer(void)
+{
+	test_hashed("%p", NULL);
+	test(ZEROS "00000000", "%px", NULL);
+	test("(null)", "%pE", NULL);
+}
+
+#define PTR_INVALID ((void *)0x000000ab)
+
+static void __init
+invalid_pointer(void)
+{
+	test_hashed("%p", PTR_INVALID);
+	test(ZEROS "000000ab", "%px", PTR_INVALID);
+	test("(efault)", "%pE", PTR_INVALID);
+}
+
 static void __init
 symbol_ptr(void)
 {
@@ -571,6 +589,8 @@ static void __init
 test_pointer(void)
 {
 	plain();
+	null_pointer();
+	invalid_pointer();
 	symbol_ptr();
 	kernel_ptr();
 	struct_resource();

commit 0b74d4d763fd4ee9daa53889324300587c015338
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Apr 17 13:53:47 2019 +0200

    vsprintf: Consolidate handling of unknown pointer specifiers
    
    There are few printk formats that make sense only with two or more
    specifiers. Also some specifiers make sense only when a kernel feature
    is enabled.
    
    The handling of unknown specifiers is inconsistent and not helpful.
    Using WARN() looks like an overkill for this type of error. pr_warn()
    is not good either. It would by handled via printk_safe buffer and
    it might be hard to match it with the problematic string.
    
    A reasonable compromise seems to be writing the unknown format specifier
    into the original string with a question mark, for example (%pC?).
    It should be self-explaining enough. Note that it is in brackets
    to follow the (null) style.
    
    Note that it introduces a warning about that test_hashed() function
    is unused. It is going to be used again by a later patch.
    
    Link: http://lkml.kernel.org/r/20190417115350.20479-8-pmladek@suse.com
    To: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "Tobin C . Harding" <me@tobin.cc>
    Cc: Joe Perches <joe@perches.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 659b6cc0d483..250ee864b8b8 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -462,8 +462,7 @@ struct_rtc_time(void)
 		.tm_year = 118,
 	};
 
-	test_hashed("%pt", &tm);
-
+	test("(%ptR?)", "%pt", &tm);
 	test("2018-11-26T05:35:43", "%ptR", &tm);
 	test("0118-10-26T05:35:43", "%ptRr", &tm);
 	test("05:35:43|2018-11-26", "%ptRt|%ptRd", &tm, &tm);

commit 6b1a4d5b1a26ae830d50e08d7b3ca0e8b3e6b453
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Fri Apr 5 12:58:57 2019 +1100

    lib: Use new kselftest header
    
    We just added a new C header file for use with test modules that are
    intended to be run with kselftest.  We can reduce code duplication by
    using this header.
    
    Use new kselftest header to reduce code duplication in test_printf and
    test_bitmap test modules.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Shuah Khan <shuah@kernel.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 601e8519319a..f4fcc1c43739 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -21,6 +21,8 @@
 #include <linux/gfp.h>
 #include <linux/mm.h>
 
+#include "../tools/testing/selftests/kselftest_module.h"
+
 #define BUF_SIZE 256
 #define PAD_SIZE 16
 #define FILL_CHAR '$'
@@ -590,12 +592,11 @@ test_pointer(void)
 	flags();
 }
 
-static int __init
-test_printf_init(void)
+static void __init selftest(void)
 {
 	alloced_buffer = kmalloc(BUF_SIZE + 2*PAD_SIZE, GFP_KERNEL);
 	if (!alloced_buffer)
-		return -ENOMEM;
+		return;
 	test_buffer = alloced_buffer + PAD_SIZE;
 
 	test_basic();
@@ -604,22 +605,8 @@ test_printf_init(void)
 	test_pointer();
 
 	kfree(alloced_buffer);
-
-	if (failed_tests == 0)
-		pr_info("all %u tests passed\n", total_tests);
-	else
-		pr_warn("failed %u out of %u tests\n", failed_tests, total_tests);
-
-	return failed_tests ? -EINVAL : 0;
 }
 
-module_init(test_printf_init);
-
-static void __exit test_printf_exit(void)
-{
-}
-
-module_exit(test_printf_exit);
-
+KSTM_MODULE_LOADERS(test_printf);
 MODULE_AUTHOR("Rasmus Villemoes <linux@rasmusvillemoes.dk>");
 MODULE_LICENSE("GPL");

commit 6989808ee7636188cc091224bc76ab8e1696088a
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Fri Apr 5 12:58:54 2019 +1100

    lib/test_printf: Add empty module_exit function
    
    Currently the test_printf module does not have an exit function, this
    prevents the module from being unloaded.  If we cannot unload the
    module we cannot run the tests a second time.
    
    Add an empty exit function.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Shuah Khan <shuah@kernel.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 659b6cc0d483..601e8519319a 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -615,5 +615,11 @@ test_printf_init(void)
 
 module_init(test_printf_init);
 
+static void __exit test_printf_exit(void)
+{
+}
+
+module_exit(test_printf_exit);
+
 MODULE_AUTHOR("Rasmus Villemoes <linux@rasmusvillemoes.dk>");
 MODULE_LICENSE("GPL");

commit 2821fd0c2be0c4e513b1622d86df9170ef62a6d4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 4 12:00:09 2019 +0200

    lib/test_printf: Switch to bitmap_zalloc()
    
    Switch to bitmap_zalloc() to show clearly what we are allocating.
    Besides that it returns pointer of bitmap type instead of opaque void *.
    
    Link: http://lkml.kernel.org/r/20190304100009.65147-1-andriy.shevchenko@linux.intel.com
    To: linux-kernel@vger.kernel.org
    To: Andrew Morton <akpm@linux-foundation.org>
    To: linux@rasmusvillemoes.dk
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 659b6cc0d483..e8206d8d2d08 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -481,14 +481,14 @@ static void __init
 large_bitmap(void)
 {
 	const int nbits = 1 << 16;
-	unsigned long *bits = kcalloc(BITS_TO_LONGS(nbits), sizeof(long), GFP_KERNEL);
+	unsigned long *bits = bitmap_zalloc(nbits, GFP_KERNEL);
 	if (!bits)
 		return;
 
 	bitmap_set(bits, 1, 20);
 	bitmap_set(bits, 60000, 15);
 	test("1-20,60000-60014", "%*pbl", nbits, bits);
-	kfree(bits);
+	bitmap_free(bits);
 }
 
 static void __init

commit 4d42c44727a062e233e446c6c86da1c84d762d79
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Dec 4 23:23:11 2018 +0200

    lib/vsprintf: Print time and date in human readable format via %pt
    
    There are users which print time and date represented by content of
    struct rtc_time in human readable format.
    
    Instead of open coding that each time introduce %ptR[dt][r] specifier.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 53527ea822b5..659b6cc0d483 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/printk.h>
 #include <linux/random.h>
+#include <linux/rtc.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 
@@ -249,12 +250,11 @@ plain_format(void)
 #endif	/* BITS_PER_LONG == 64 */
 
 static int __init
-plain_hash(void)
+plain_hash_to_buffer(const void *p, char *buf, size_t len)
 {
-	char buf[PLAIN_BUF_SIZE];
 	int nchars;
 
-	nchars = snprintf(buf, PLAIN_BUF_SIZE, "%p", PTR);
+	nchars = snprintf(buf, len, "%p", p);
 
 	if (nchars != PTR_WIDTH)
 		return -1;
@@ -265,6 +265,20 @@ plain_hash(void)
 		return 0;
 	}
 
+	return 0;
+}
+
+
+static int __init
+plain_hash(void)
+{
+	char buf[PLAIN_BUF_SIZE];
+	int ret;
+
+	ret = plain_hash_to_buffer(PTR, buf, PLAIN_BUF_SIZE);
+	if (ret)
+		return ret;
+
 	if (strncmp(buf, PTR_STR, PTR_WIDTH) == 0)
 		return -1;
 
@@ -294,6 +308,23 @@ plain(void)
 	}
 }
 
+static void __init
+test_hashed(const char *fmt, const void *p)
+{
+	char buf[PLAIN_BUF_SIZE];
+	int ret;
+
+	/*
+	 * No need to increase failed test counter since this is assumed
+	 * to be called after plain().
+	 */
+	ret = plain_hash_to_buffer(p, buf, PLAIN_BUF_SIZE);
+	if (ret)
+		return;
+
+	test(buf, fmt, p);
+}
+
 static void __init
 symbol_ptr(void)
 {
@@ -418,6 +449,29 @@ struct_va_format(void)
 {
 }
 
+static void __init
+struct_rtc_time(void)
+{
+	/* 1543210543 */
+	const struct rtc_time tm = {
+		.tm_sec = 43,
+		.tm_min = 35,
+		.tm_hour = 5,
+		.tm_mday = 26,
+		.tm_mon = 10,
+		.tm_year = 118,
+	};
+
+	test_hashed("%pt", &tm);
+
+	test("2018-11-26T05:35:43", "%ptR", &tm);
+	test("0118-10-26T05:35:43", "%ptRr", &tm);
+	test("05:35:43|2018-11-26", "%ptRt|%ptRd", &tm, &tm);
+	test("05:35:43|0118-10-26", "%ptRtr|%ptRdr", &tm, &tm);
+	test("05:35:43|2018-11-26", "%ptRttr|%ptRdtr", &tm, &tm);
+	test("05:35:43 tr|2018-11-26 tr", "%ptRt tr|%ptRd tr", &tm, &tm);
+}
+
 static void __init
 struct_clk(void)
 {
@@ -529,6 +583,7 @@ test_pointer(void)
 	uuid();
 	dentry();
 	struct_va_format();
+	struct_rtc_time();
 	struct_clk();
 	bitmap();
 	netdev_features();

commit ce041c43f22298485122bab15c14d062383fbc67
Author: Thierry Escande <thierry.escande@linaro.org>
Date:   Wed Jun 13 19:18:40 2018 +0200

    lib/test_printf.c: accept "ptrval" as valid result for plain 'p' tests
    
    If the test_printf module is loaded before the crng is initialized, the
    plain 'p' tests will fail because the printed address will not be hashed
    and the buffer will contain "(____ptrval____)" or "(ptrval)" instead
    (64-bit vs 32-bit).
    Since we cannot wait for the crng to be initialized for an undefined
    time, both plain 'p' tests now accept the strings "(____ptrval____)" or
    "(ptrval)" as a valid result and print a warning message.
    
    Link: http://lkml.kernel.org/r/20180613171840.29827-1-thierry.escande@linaro.org
    Fixes: ad67b74d2469d9b82 ("printk: hash addresses printed with %p")
    To: Andrew Morton <akpm@linux-foundation.org>
    To: David Miller <davem@davemloft.net>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: "Tobin C . Harding" <me@tobin.cc>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Thierry Escande <thierry.escande@linaro.org>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index cea592f402ed..53527ea822b5 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -206,6 +206,7 @@ test_string(void)
 #define PTR_WIDTH 16
 #define PTR ((void *)0xffff0123456789abUL)
 #define PTR_STR "ffff0123456789ab"
+#define PTR_VAL_NO_CRNG "(____ptrval____)"
 #define ZEROS "00000000"	/* hex 32 zero bits */
 
 static int __init
@@ -216,7 +217,16 @@ plain_format(void)
 
 	nchars = snprintf(buf, PLAIN_BUF_SIZE, "%p", PTR);
 
-	if (nchars != PTR_WIDTH || strncmp(buf, ZEROS, strlen(ZEROS)) != 0)
+	if (nchars != PTR_WIDTH)
+		return -1;
+
+	if (strncmp(buf, PTR_VAL_NO_CRNG, PTR_WIDTH) == 0) {
+		pr_warn("crng possibly not yet initialized. plain 'p' buffer contains \"%s\"",
+			PTR_VAL_NO_CRNG);
+		return 0;
+	}
+
+	if (strncmp(buf, ZEROS, strlen(ZEROS)) != 0)
 		return -1;
 
 	return 0;
@@ -227,6 +237,7 @@ plain_format(void)
 #define PTR_WIDTH 8
 #define PTR ((void *)0x456789ab)
 #define PTR_STR "456789ab"
+#define PTR_VAL_NO_CRNG "(ptrval)"
 
 static int __init
 plain_format(void)
@@ -245,7 +256,16 @@ plain_hash(void)
 
 	nchars = snprintf(buf, PLAIN_BUF_SIZE, "%p", PTR);
 
-	if (nchars != PTR_WIDTH || strncmp(buf, PTR_STR, PTR_WIDTH) == 0)
+	if (nchars != PTR_WIDTH)
+		return -1;
+
+	if (strncmp(buf, PTR_VAL_NO_CRNG, PTR_WIDTH) == 0) {
+		pr_warn("crng possibly not yet initialized. plain 'p' buffer contains \"%s\"",
+			PTR_VAL_NO_CRNG);
+		return 0;
+	}
+
+	if (strncmp(buf, PTR_STR, PTR_WIDTH) == 0)
 		return -1;
 
 	return 0;

commit c604b40728c28ba4d831832c7f03805aba11a8e2
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 16 23:07:03 2018 +0200

    lib/test_printf: Mark big constant with UL
    
    Sparse complains that constant is so big for unsigned long on 64-bit
    architecture.
    
    lib/test_printf.c:217:54: warning: constant 0xffff0123456789ab is so big it is unsigned long
    lib/test_printf.c:246:54: warning: constant 0xffff0123456789ab is so big it is unsigned long
    
    To satisfy everyone, mark the constant with UL.
    
    Link: http://lkml.kernel.org/r/20180216210711.79901-1-andriy.shevchenko@linux.intel.com
    To: "Tobin C . Harding" <me@tobin.cc>
    To: linux@rasmusvillemoes.dk
    To: Joe Perches <joe@perches.com>
    To: linux-kernel@vger.kernel.org
    To: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [pmladek@suse.com: Changed from ULL to UL as suggested by Luc Van Oostenryck <luc.vanoostenryck@gmail.com>]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 71ebfa43ad05..cea592f402ed 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -204,7 +204,7 @@ test_string(void)
 #if BITS_PER_LONG == 64
 
 #define PTR_WIDTH 16
-#define PTR ((void *)0xffff0123456789ab)
+#define PTR ((void *)0xffff0123456789abUL)
 #define PTR_STR "ffff0123456789ab"
 #define ZEROS "00000000"	/* hex 32 zero bits */
 

commit ad67b74d2469d9b82aaa572d76474c95bc484d57
Author: Tobin C. Harding <me@tobin.cc>
Date:   Wed Nov 1 15:32:23 2017 +1100

    printk: hash addresses printed with %p
    
    Currently there exist approximately 14 000 places in the kernel where
    addresses are being printed using an unadorned %p. This potentially
    leaks sensitive information regarding the Kernel layout in memory. Many
    of these calls are stale, instead of fixing every call lets hash the
    address by default before printing. This will of course break some
    users, forcing code printing needed addresses to be updated.
    
    Code that _really_ needs the address will soon be able to use the new
    printk specifier %px to print the address.
    
    For what it's worth, usage of unadorned %p can be broken down as
    follows (thanks to Joe Perches).
    
    $ git grep -E '%p[^A-Za-z0-9]' | cut -f1 -d"/" | sort | uniq -c
       1084 arch
         20 block
         10 crypto
         32 Documentation
       8121 drivers
       1221 fs
        143 include
        101 kernel
         69 lib
        100 mm
       1510 net
         40 samples
          7 scripts
         11 security
        166 sound
        152 tools
          2 virt
    
    Add function ptr_to_id() to map an address to a 32 bit unique
    identifier. Hash any unadorned usage of specifier %p and any malformed
    specifiers.
    
    Signed-off-by: Tobin C. Harding <me@tobin.cc>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 563f10e6876a..71ebfa43ad05 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -24,24 +24,6 @@
 #define PAD_SIZE 16
 #define FILL_CHAR '$'
 
-#define PTR1 ((void*)0x01234567)
-#define PTR2 ((void*)(long)(int)0xfedcba98)
-
-#if BITS_PER_LONG == 64
-#define PTR1_ZEROES "000000000"
-#define PTR1_SPACES "         "
-#define PTR1_STR "1234567"
-#define PTR2_STR "fffffffffedcba98"
-#define PTR_WIDTH 16
-#else
-#define PTR1_ZEROES "0"
-#define PTR1_SPACES " "
-#define PTR1_STR "1234567"
-#define PTR2_STR "fedcba98"
-#define PTR_WIDTH 8
-#endif
-#define PTR_WIDTH_STR stringify(PTR_WIDTH)
-
 static unsigned total_tests __initdata;
 static unsigned failed_tests __initdata;
 static char *test_buffer __initdata;
@@ -217,30 +199,79 @@ test_string(void)
 	test("a  |   |   ", "%-3.s|%-3.0s|%-3.*s", "a", "b", 0, "c");
 }
 
+#define PLAIN_BUF_SIZE 64	/* leave some space so we don't oops */
+
+#if BITS_PER_LONG == 64
+
+#define PTR_WIDTH 16
+#define PTR ((void *)0xffff0123456789ab)
+#define PTR_STR "ffff0123456789ab"
+#define ZEROS "00000000"	/* hex 32 zero bits */
+
+static int __init
+plain_format(void)
+{
+	char buf[PLAIN_BUF_SIZE];
+	int nchars;
+
+	nchars = snprintf(buf, PLAIN_BUF_SIZE, "%p", PTR);
+
+	if (nchars != PTR_WIDTH || strncmp(buf, ZEROS, strlen(ZEROS)) != 0)
+		return -1;
+
+	return 0;
+}
+
+#else
+
+#define PTR_WIDTH 8
+#define PTR ((void *)0x456789ab)
+#define PTR_STR "456789ab"
+
+static int __init
+plain_format(void)
+{
+	/* Format is implicitly tested for 32 bit machines by plain_hash() */
+	return 0;
+}
+
+#endif	/* BITS_PER_LONG == 64 */
+
+static int __init
+plain_hash(void)
+{
+	char buf[PLAIN_BUF_SIZE];
+	int nchars;
+
+	nchars = snprintf(buf, PLAIN_BUF_SIZE, "%p", PTR);
+
+	if (nchars != PTR_WIDTH || strncmp(buf, PTR_STR, PTR_WIDTH) == 0)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * We can't use test() to test %p because we don't know what output to expect
+ * after an address is hashed.
+ */
 static void __init
 plain(void)
 {
-	test(PTR1_ZEROES PTR1_STR " " PTR2_STR, "%p %p", PTR1, PTR2);
-	/*
-	 * The field width is overloaded for some %p extensions to
-	 * pass another piece of information. For plain pointers, the
-	 * behaviour is slightly odd: One cannot pass either the 0
-	 * flag nor a precision to %p without gcc complaining, and if
-	 * one explicitly gives a field width, the number is no longer
-	 * zero-padded.
-	 */
-	test("|" PTR1_STR PTR1_SPACES "  |  " PTR1_SPACES PTR1_STR "|",
-	     "|%-*p|%*p|", PTR_WIDTH+2, PTR1, PTR_WIDTH+2, PTR1);
-	test("|" PTR2_STR "  |  " PTR2_STR "|",
-	     "|%-*p|%*p|", PTR_WIDTH+2, PTR2, PTR_WIDTH+2, PTR2);
+	int err;
 
-	/*
-	 * Unrecognized %p extensions are treated as plain %p, but the
-	 * alphanumeric suffix is ignored (that is, does not occur in
-	 * the output.)
-	 */
-	test("|"PTR1_ZEROES PTR1_STR"|", "|%p0y|", PTR1);
-	test("|"PTR2_STR"|", "|%p0y|", PTR2);
+	err = plain_hash();
+	if (err) {
+		pr_warn("plain 'p' does not appear to be hashed\n");
+		failed_tests++;
+		return;
+	}
+
+	err = plain_format();
+	if (err) {
+		pr_warn("hashing plain 'p' has unexpected format\n");
+		failed_tests++;
+	}
 }
 
 static void __init
@@ -251,6 +282,7 @@ symbol_ptr(void)
 static void __init
 kernel_ptr(void)
 {
+	/* We can't test this without access to kptr_restrict. */
 }
 
 static void __init

commit edf14cdbf9a0e5ab52698ca66d07a76ade0d5c46
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Tue Mar 15 14:55:56 2016 -0700

    mm, printk: introduce new format string for flags
    
    In mm we use several kinds of flags bitfields that are sometimes printed
    for debugging purposes, or exported to userspace via sysfs.  To make
    them easier to interpret independently on kernel version and config, we
    want to dump also the symbolic flag names.  So far this has been done
    with repeated calls to pr_cont(), which is unreliable on SMP, and not
    usable for e.g.  sysfs export.
    
    To get a more reliable and universal solution, this patch extends
    printk() format string for pointers to handle the page flags (%pGp),
    gfp_flags (%pGg) and vma flags (%pGv).  Existing users of
    dump_flag_names() are converted and simplified.
    
    It would be possible to pass flags by value instead of pointer, but the
    %p format string for pointers already has extensions for various kernel
    structures, so it's a good fit, and the extra indirection in a
    non-critical path is negligible.
    
    [linux@rasmusvillemoes.dk: lots of good implementation suggestions]
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 4f6ae60433bc..563f10e6876a 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -17,6 +17,9 @@
 #include <linux/socket.h>
 #include <linux/in.h>
 
+#include <linux/gfp.h>
+#include <linux/mm.h>
+
 #define BUF_SIZE 256
 #define PAD_SIZE 16
 #define FILL_CHAR '$'
@@ -410,6 +413,55 @@ netdev_features(void)
 {
 }
 
+static void __init
+flags(void)
+{
+	unsigned long flags;
+	gfp_t gfp;
+	char *cmp_buffer;
+
+	flags = 0;
+	test("", "%pGp", &flags);
+
+	/* Page flags should filter the zone id */
+	flags = 1UL << NR_PAGEFLAGS;
+	test("", "%pGp", &flags);
+
+	flags |= 1UL << PG_uptodate | 1UL << PG_dirty | 1UL << PG_lru
+		| 1UL << PG_active | 1UL << PG_swapbacked;
+	test("uptodate|dirty|lru|active|swapbacked", "%pGp", &flags);
+
+
+	flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC
+			| VM_DENYWRITE;
+	test("read|exec|mayread|maywrite|mayexec|denywrite", "%pGv", &flags);
+
+	gfp = GFP_TRANSHUGE;
+	test("GFP_TRANSHUGE", "%pGg", &gfp);
+
+	gfp = GFP_ATOMIC|__GFP_DMA;
+	test("GFP_ATOMIC|GFP_DMA", "%pGg", &gfp);
+
+	gfp = __GFP_ATOMIC;
+	test("__GFP_ATOMIC", "%pGg", &gfp);
+
+	cmp_buffer = kmalloc(BUF_SIZE, GFP_KERNEL);
+	if (!cmp_buffer)
+		return;
+
+	/* Any flags not translated by the table should remain numeric */
+	gfp = ~__GFP_BITS_MASK;
+	snprintf(cmp_buffer, BUF_SIZE, "%#lx", (unsigned long) gfp);
+	test(cmp_buffer, "%pGg", &gfp);
+
+	snprintf(cmp_buffer, BUF_SIZE, "__GFP_ATOMIC|%#lx",
+							(unsigned long) gfp);
+	gfp |= __GFP_ATOMIC;
+	test(cmp_buffer, "%pGg", &gfp);
+
+	kfree(cmp_buffer);
+}
+
 static void __init
 test_pointer(void)
 {
@@ -428,6 +480,7 @@ test_pointer(void)
 	struct_clk();
 	bitmap();
 	netdev_features();
+	flags();
 }
 
 static int __init

commit 251c72345579b82df59eddfa184af53d6830959c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:59:09 2016 -0800

    lib/test_printf.c: test dentry printing
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 60740c10c3e8..4f6ae60433bc 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -13,6 +13,7 @@
 #include <linux/string.h>
 
 #include <linux/bitmap.h>
+#include <linux/dcache.h>
 #include <linux/socket.h>
 #include <linux/in.h>
 
@@ -326,9 +327,35 @@ uuid(void)
 	test("03020100-0504-0706-0809-0A0B0C0D0E0F", "%pUL", uuid);
 }
 
+static struct dentry test_dentry[4] __initdata = {
+	{ .d_parent = &test_dentry[0],
+	  .d_name = QSTR_INIT(test_dentry[0].d_iname, 3),
+	  .d_iname = "foo" },
+	{ .d_parent = &test_dentry[0],
+	  .d_name = QSTR_INIT(test_dentry[1].d_iname, 5),
+	  .d_iname = "bravo" },
+	{ .d_parent = &test_dentry[1],
+	  .d_name = QSTR_INIT(test_dentry[2].d_iname, 4),
+	  .d_iname = "alfa" },
+	{ .d_parent = &test_dentry[2],
+	  .d_name = QSTR_INIT(test_dentry[3].d_iname, 5),
+	  .d_iname = "romeo" },
+};
+
 static void __init
 dentry(void)
 {
+	test("foo", "%pd", &test_dentry[0]);
+	test("foo", "%pd2", &test_dentry[0]);
+
+	test("romeo", "%pd", &test_dentry[3]);
+	test("alfa/romeo", "%pd2", &test_dentry[3]);
+	test("bravo/alfa/romeo", "%pd3", &test_dentry[3]);
+	test("/bravo/alfa/romeo", "%pd4", &test_dentry[3]);
+	test("/bravo/alfa", "%pd4", &test_dentry[2]);
+
+	test("bravo/alfa  |bravo/alfa  ", "%-12pd2|%*pd2", &test_dentry[2], -12, &test_dentry[2]);
+	test("  bravo/alfa|  bravo/alfa", "%12pd2|%*pd2", &test_dentry[2], 12, &test_dentry[2]);
 }
 
 static void __init

commit 857cca4d565d85857597ccf0b6f72cf0f06e046c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:59:06 2016 -0800

    lib/test_printf.c: add test for large bitmaps
    
    Following "lib/vsprintf.c: expand field_width to 24 bits", let's add a
    test to see that we now actually support bitmaps with 65536 bits.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 3e21170d327d..60740c10c3e8 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -12,6 +12,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 
+#include <linux/bitmap.h>
 #include <linux/socket.h>
 #include <linux/in.h>
 
@@ -340,6 +341,20 @@ struct_clk(void)
 {
 }
 
+static void __init
+large_bitmap(void)
+{
+	const int nbits = 1 << 16;
+	unsigned long *bits = kcalloc(BITS_TO_LONGS(nbits), sizeof(long), GFP_KERNEL);
+	if (!bits)
+		return;
+
+	bitmap_set(bits, 1, 20);
+	bitmap_set(bits, 60000, 15);
+	test("1-20,60000-60014", "%*pbl", nbits, bits);
+	kfree(bits);
+}
+
 static void __init
 bitmap(void)
 {
@@ -359,6 +374,8 @@ bitmap(void)
 	bitmap_fill(bits, 20);
 	test("fffff|fffff", "%20pb|%*pb", bits, 20, bits);
 	test("0-19|0-19", "%20pbl|%*pbl", bits, 20, bits);
+
+	large_bitmap();
 }
 
 static void __init

commit b79a7db37d560c9e4b6fdb5314cb8b226a2d6567
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:59:02 2016 -0800

    lib/test_printf.c: account for kvasprintf tests
    
    These should also count as performed tests.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index b23ce824766f..3e21170d327d 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -127,6 +127,7 @@ __test(const char *expect, int elen, const char *fmt, ...)
 
 	p = kvasprintf(GFP_KERNEL, fmt, ap);
 	if (p) {
+		total_tests++;
 		if (memcmp(p, expect, elen+1)) {
 			pr_warn("kvasprintf(..., \"%s\", ...) returned '%s', expected '%s'\n",
 				fmt, p, expect);

commit 1ca8e8ebe991ff628d7e03ad4b5a11817a9655d5
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:58:59 2016 -0800

    lib/test_printf.c: add a few number() tests
    
    This adds a few tests to test_number, one of which serves to document
    another deviation from POSIX/C99 (printing 0 with an explicit precision
    of 0).
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 3393d667c6b8..b23ce824766f 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -158,6 +158,30 @@ test_number(void)
 	test("0x1234abcd  ", "%#-12x", 0x1234abcd);
 	test("  0x1234abcd", "%#12x", 0x1234abcd);
 	test("0|001| 12|+123| 1234|-123|-1234", "%d|%03d|%3d|%+d|% d|%+d|% d", 0, 1, 12, 123, 1234, -123, -1234);
+	test("0|1|1|128|255", "%hhu|%hhu|%hhu|%hhu|%hhu", 0, 1, 257, 128, -1);
+	test("0|1|1|-128|-1", "%hhd|%hhd|%hhd|%hhd|%hhd", 0, 1, 257, 128, -1);
+	test("2015122420151225", "%ho%ho%#ho", 1037, 5282, -11627);
+	/*
+	 * POSIX/C99: »The result of converting zero with an explicit
+	 * precision of zero shall be no characters.« Hence the output
+	 * from the below test should really be "00|0||| ". However,
+	 * the kernel's printf also produces a single 0 in that
+	 * case. This test case simply documents the current
+	 * behaviour.
+	 */
+	test("00|0|0|0|0", "%.2d|%.1d|%.0d|%.*d|%1.0d", 0, 0, 0, 0, 0, 0);
+#ifndef __CHAR_UNSIGNED__
+	{
+		/*
+		 * Passing a 'char' to a %02x specifier doesn't do
+		 * what was presumably the intention when char is
+		 * signed and the value is negative. One must either &
+		 * with 0xff or cast to u8.
+		 */
+		char val = -16;
+		test("0xfffffff0|0xf0|0xf0", "%#02x|%#02x|%#02x", val, val & 0xff, (u8)val);
+	}
+#endif
 }
 
 static void __init

commit f176eb4ce9d433184178d37a598ffdfe1cee1463
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:58:56 2016 -0800

    lib/test_printf.c: test precision quirks
    
    The kernel's printf doesn't follow the standards in a few corner cases
    (which are probably mostly irrelevant).  Add tests that document the
    current behaviour.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 1ce1a1dd8faf..3393d667c6b8 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -166,14 +166,23 @@ test_string(void)
 	test("", "%s%.0s", "", "123");
 	test("ABCD|abc|123", "%s|%.3s|%.*s", "ABCD", "abcdef", 3, "123456");
 	test("1  |  2|3  |  4|5  ", "%-3s|%3s|%-*s|%*s|%*s", "1", "2", 3, "3", 3, "4", -3, "5");
+	test("1234      ", "%-10.4s", "123456");
+	test("      1234", "%10.4s", "123456");
 	/*
-	 * POSIX and C99 say that a missing precision should be
-	 * treated as a precision of 0. However, the kernel's printf
-	 * implementation treats this case as if the . wasn't
-	 * present. Let's add a test case documenting the current
-	 * behaviour; should anyone ever feel the need to follow the
-	 * standards more closely, this can be revisited.
+	 * POSIX and C99 say that a negative precision (which is only
+	 * possible to pass via a * argument) should be treated as if
+	 * the precision wasn't present, and that if the precision is
+	 * omitted (as in %.s), the precision should be taken to be
+	 * 0. However, the kernel's printf behave exactly opposite,
+	 * treating a negative precision as 0 and treating an omitted
+	 * precision specifier as if no precision was given.
+	 *
+	 * These test cases document the current behaviour; should
+	 * anyone ever feel the need to follow the standards more
+	 * closely, this can be revisited.
 	 */
+	test("    ", "%4.*s", -5, "123456");
+	test("123456", "%.s", "123456");
 	test("a||", "%.s|%.0s|%.*s", "a", "b", 0, "c");
 	test("a  |   |   ", "%-3.s|%-3.0s|%-3.*s", "a", "b", 0, "c");
 }

commit 331e4deb6dfdac50d3f9c4ccbc41b1427335e212
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:58:53 2016 -0800

    lib/test_printf.c: check for out-of-bound writes
    
    Add a few padding bytes on either side of the test buffer, and check
    that these (and the part of the buffer not used) are untouched by
    vsnprintf.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index 9232a2add28c..1ce1a1dd8faf 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -16,6 +16,7 @@
 #include <linux/in.h>
 
 #define BUF_SIZE 256
+#define PAD_SIZE 16
 #define FILL_CHAR '$'
 
 #define PTR1 ((void*)0x01234567)
@@ -39,6 +40,7 @@
 static unsigned total_tests __initdata;
 static unsigned failed_tests __initdata;
 static char *test_buffer __initdata;
+static char *alloced_buffer __initdata;
 
 static int __printf(4, 0) __init
 do_test(int bufsize, const char *expect, int elen,
@@ -49,7 +51,7 @@ do_test(int bufsize, const char *expect, int elen,
 
 	total_tests++;
 
-	memset(test_buffer, FILL_CHAR, BUF_SIZE);
+	memset(alloced_buffer, FILL_CHAR, BUF_SIZE + 2*PAD_SIZE);
 	va_copy(aq, ap);
 	ret = vsnprintf(test_buffer, bufsize, fmt, aq);
 	va_end(aq);
@@ -60,8 +62,13 @@ do_test(int bufsize, const char *expect, int elen,
 		return 1;
 	}
 
+	if (memchr_inv(alloced_buffer, FILL_CHAR, PAD_SIZE)) {
+		pr_warn("vsnprintf(buf, %d, \"%s\", ...) wrote before buffer\n", bufsize, fmt);
+		return 1;
+	}
+
 	if (!bufsize) {
-		if (memchr_inv(test_buffer, FILL_CHAR, BUF_SIZE)) {
+		if (memchr_inv(test_buffer, FILL_CHAR, BUF_SIZE + PAD_SIZE)) {
 			pr_warn("vsnprintf(buf, 0, \"%s\", ...) wrote to buffer\n",
 				fmt);
 			return 1;
@@ -76,6 +83,12 @@ do_test(int bufsize, const char *expect, int elen,
 		return 1;
 	}
 
+	if (memchr_inv(test_buffer + written + 1, FILL_CHAR, BUF_SIZE + PAD_SIZE - (written + 1))) {
+		pr_warn("vsnprintf(buf, %d, \"%s\", ...) wrote beyond the nul-terminator\n",
+			bufsize, fmt);
+		return 1;
+	}
+
 	if (memcmp(test_buffer, expect, written)) {
 		pr_warn("vsnprintf(buf, %d, \"%s\", ...) wrote '%s', expected '%.*s'\n",
 			bufsize, fmt, test_buffer, written, expect);
@@ -342,16 +355,17 @@ test_pointer(void)
 static int __init
 test_printf_init(void)
 {
-	test_buffer = kmalloc(BUF_SIZE, GFP_KERNEL);
-	if (!test_buffer)
+	alloced_buffer = kmalloc(BUF_SIZE + 2*PAD_SIZE, GFP_KERNEL);
+	if (!alloced_buffer)
 		return -ENOMEM;
+	test_buffer = alloced_buffer + PAD_SIZE;
 
 	test_basic();
 	test_number();
 	test_string();
 	test_pointer();
 
-	kfree(test_buffer);
+	kfree(alloced_buffer);
 
 	if (failed_tests == 0)
 		pr_info("all %u tests passed\n", total_tests);

commit fd0515d50ff33865d0f8cdd74510e8bd1aee88ac
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Jan 15 16:58:50 2016 -0800

    lib/test_printf.c: don't BUG
    
    BUG is a completely unnecessarily big hammer, and we're more likely to
    get the internal bug reported if we just pr_err() and ensure the test
    suite fails.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
index c5a666af9ba5..9232a2add28c 100644
--- a/lib/test_printf.c
+++ b/lib/test_printf.c
@@ -91,7 +91,12 @@ __test(const char *expect, int elen, const char *fmt, ...)
 	int rand;
 	char *p;
 
-	BUG_ON(elen >= BUF_SIZE);
+	if (elen >= BUF_SIZE) {
+		pr_err("error in test suite: expected output length %d too long. Format was '%s'.\n",
+		       elen, fmt);
+		failed_tests++;
+		return;
+	}
 
 	va_start(ap, fmt);
 

commit 707cc7280f452a162c52bc240eae62568b9753c2
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Nov 6 16:30:29 2015 -0800

    test_printf: test printf family at runtime
    
    This adds a simple module for testing the kernel's printf facilities.
    Previously, some %p extensions have caused a wrong return value in case
    the entire output didn't fit and/or been unusable in kasprintf().  This
    should help catch such issues.  Also, it should help ensure that changes
    to the formatting algorithms don't break anything.
    
    I'm not sure if we have a struct dentry or struct file lying around at
    boot time or if we can fake one, but most %p extensions should be
    testable, as should the ordinary number and string formatting.
    
    The nature of vararg functions means we can't use a more conventional
    table-driven approach.
    
    For now, this is mostly a skeleton; contributions are very
    welcome. Some tests are/will be slightly annoying to write, since the
    expected output depends on stuff like CONFIG_*, sizeof(long), runtime
    values etc.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Martin Kletzander <mkletzan@redhat.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_printf.c b/lib/test_printf.c
new file mode 100644
index 000000000000..c5a666af9ba5
--- /dev/null
+++ b/lib/test_printf.c
@@ -0,0 +1,362 @@
+/*
+ * Test cases for printf facility.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/random.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include <linux/socket.h>
+#include <linux/in.h>
+
+#define BUF_SIZE 256
+#define FILL_CHAR '$'
+
+#define PTR1 ((void*)0x01234567)
+#define PTR2 ((void*)(long)(int)0xfedcba98)
+
+#if BITS_PER_LONG == 64
+#define PTR1_ZEROES "000000000"
+#define PTR1_SPACES "         "
+#define PTR1_STR "1234567"
+#define PTR2_STR "fffffffffedcba98"
+#define PTR_WIDTH 16
+#else
+#define PTR1_ZEROES "0"
+#define PTR1_SPACES " "
+#define PTR1_STR "1234567"
+#define PTR2_STR "fedcba98"
+#define PTR_WIDTH 8
+#endif
+#define PTR_WIDTH_STR stringify(PTR_WIDTH)
+
+static unsigned total_tests __initdata;
+static unsigned failed_tests __initdata;
+static char *test_buffer __initdata;
+
+static int __printf(4, 0) __init
+do_test(int bufsize, const char *expect, int elen,
+	const char *fmt, va_list ap)
+{
+	va_list aq;
+	int ret, written;
+
+	total_tests++;
+
+	memset(test_buffer, FILL_CHAR, BUF_SIZE);
+	va_copy(aq, ap);
+	ret = vsnprintf(test_buffer, bufsize, fmt, aq);
+	va_end(aq);
+
+	if (ret != elen) {
+		pr_warn("vsnprintf(buf, %d, \"%s\", ...) returned %d, expected %d\n",
+			bufsize, fmt, ret, elen);
+		return 1;
+	}
+
+	if (!bufsize) {
+		if (memchr_inv(test_buffer, FILL_CHAR, BUF_SIZE)) {
+			pr_warn("vsnprintf(buf, 0, \"%s\", ...) wrote to buffer\n",
+				fmt);
+			return 1;
+		}
+		return 0;
+	}
+
+	written = min(bufsize-1, elen);
+	if (test_buffer[written]) {
+		pr_warn("vsnprintf(buf, %d, \"%s\", ...) did not nul-terminate buffer\n",
+			bufsize, fmt);
+		return 1;
+	}
+
+	if (memcmp(test_buffer, expect, written)) {
+		pr_warn("vsnprintf(buf, %d, \"%s\", ...) wrote '%s', expected '%.*s'\n",
+			bufsize, fmt, test_buffer, written, expect);
+		return 1;
+	}
+	return 0;
+}
+
+static void __printf(3, 4) __init
+__test(const char *expect, int elen, const char *fmt, ...)
+{
+	va_list ap;
+	int rand;
+	char *p;
+
+	BUG_ON(elen >= BUF_SIZE);
+
+	va_start(ap, fmt);
+
+	/*
+	 * Every fmt+args is subjected to four tests: Three where we
+	 * tell vsnprintf varying buffer sizes (plenty, not quite
+	 * enough and 0), and then we also test that kvasprintf would
+	 * be able to print it as expected.
+	 */
+	failed_tests += do_test(BUF_SIZE, expect, elen, fmt, ap);
+	rand = 1 + prandom_u32_max(elen+1);
+	/* Since elen < BUF_SIZE, we have 1 <= rand <= BUF_SIZE. */
+	failed_tests += do_test(rand, expect, elen, fmt, ap);
+	failed_tests += do_test(0, expect, elen, fmt, ap);
+
+	p = kvasprintf(GFP_KERNEL, fmt, ap);
+	if (p) {
+		if (memcmp(p, expect, elen+1)) {
+			pr_warn("kvasprintf(..., \"%s\", ...) returned '%s', expected '%s'\n",
+				fmt, p, expect);
+			failed_tests++;
+		}
+		kfree(p);
+	}
+	va_end(ap);
+}
+
+#define test(expect, fmt, ...)					\
+	__test(expect, strlen(expect), fmt, ##__VA_ARGS__)
+
+static void __init
+test_basic(void)
+{
+	/* Work around annoying "warning: zero-length gnu_printf format string". */
+	char nul = '\0';
+
+	test("", &nul);
+	test("100%", "100%%");
+	test("xxx%yyy", "xxx%cyyy", '%');
+	__test("xxx\0yyy", 7, "xxx%cyyy", '\0');
+}
+
+static void __init
+test_number(void)
+{
+	test("0x1234abcd  ", "%#-12x", 0x1234abcd);
+	test("  0x1234abcd", "%#12x", 0x1234abcd);
+	test("0|001| 12|+123| 1234|-123|-1234", "%d|%03d|%3d|%+d|% d|%+d|% d", 0, 1, 12, 123, 1234, -123, -1234);
+}
+
+static void __init
+test_string(void)
+{
+	test("", "%s%.0s", "", "123");
+	test("ABCD|abc|123", "%s|%.3s|%.*s", "ABCD", "abcdef", 3, "123456");
+	test("1  |  2|3  |  4|5  ", "%-3s|%3s|%-*s|%*s|%*s", "1", "2", 3, "3", 3, "4", -3, "5");
+	/*
+	 * POSIX and C99 say that a missing precision should be
+	 * treated as a precision of 0. However, the kernel's printf
+	 * implementation treats this case as if the . wasn't
+	 * present. Let's add a test case documenting the current
+	 * behaviour; should anyone ever feel the need to follow the
+	 * standards more closely, this can be revisited.
+	 */
+	test("a||", "%.s|%.0s|%.*s", "a", "b", 0, "c");
+	test("a  |   |   ", "%-3.s|%-3.0s|%-3.*s", "a", "b", 0, "c");
+}
+
+static void __init
+plain(void)
+{
+	test(PTR1_ZEROES PTR1_STR " " PTR2_STR, "%p %p", PTR1, PTR2);
+	/*
+	 * The field width is overloaded for some %p extensions to
+	 * pass another piece of information. For plain pointers, the
+	 * behaviour is slightly odd: One cannot pass either the 0
+	 * flag nor a precision to %p without gcc complaining, and if
+	 * one explicitly gives a field width, the number is no longer
+	 * zero-padded.
+	 */
+	test("|" PTR1_STR PTR1_SPACES "  |  " PTR1_SPACES PTR1_STR "|",
+	     "|%-*p|%*p|", PTR_WIDTH+2, PTR1, PTR_WIDTH+2, PTR1);
+	test("|" PTR2_STR "  |  " PTR2_STR "|",
+	     "|%-*p|%*p|", PTR_WIDTH+2, PTR2, PTR_WIDTH+2, PTR2);
+
+	/*
+	 * Unrecognized %p extensions are treated as plain %p, but the
+	 * alphanumeric suffix is ignored (that is, does not occur in
+	 * the output.)
+	 */
+	test("|"PTR1_ZEROES PTR1_STR"|", "|%p0y|", PTR1);
+	test("|"PTR2_STR"|", "|%p0y|", PTR2);
+}
+
+static void __init
+symbol_ptr(void)
+{
+}
+
+static void __init
+kernel_ptr(void)
+{
+}
+
+static void __init
+struct_resource(void)
+{
+}
+
+static void __init
+addr(void)
+{
+}
+
+static void __init
+escaped_str(void)
+{
+}
+
+static void __init
+hex_string(void)
+{
+	const char buf[3] = {0xc0, 0xff, 0xee};
+
+	test("c0 ff ee|c0:ff:ee|c0-ff-ee|c0ffee",
+	     "%3ph|%3phC|%3phD|%3phN", buf, buf, buf, buf);
+	test("c0 ff ee|c0:ff:ee|c0-ff-ee|c0ffee",
+	     "%*ph|%*phC|%*phD|%*phN", 3, buf, 3, buf, 3, buf, 3, buf);
+}
+
+static void __init
+mac(void)
+{
+	const u8 addr[6] = {0x2d, 0x48, 0xd6, 0xfc, 0x7a, 0x05};
+
+	test("2d:48:d6:fc:7a:05", "%pM", addr);
+	test("05:7a:fc:d6:48:2d", "%pMR", addr);
+	test("2d-48-d6-fc-7a-05", "%pMF", addr);
+	test("2d48d6fc7a05", "%pm", addr);
+	test("057afcd6482d", "%pmR", addr);
+}
+
+static void __init
+ip4(void)
+{
+	struct sockaddr_in sa;
+
+	sa.sin_family = AF_INET;
+	sa.sin_port = cpu_to_be16(12345);
+	sa.sin_addr.s_addr = cpu_to_be32(0x7f000001);
+
+	test("127.000.000.001|127.0.0.1", "%pi4|%pI4", &sa.sin_addr, &sa.sin_addr);
+	test("127.000.000.001|127.0.0.1", "%piS|%pIS", &sa, &sa);
+	sa.sin_addr.s_addr = cpu_to_be32(0x01020304);
+	test("001.002.003.004:12345|1.2.3.4:12345", "%piSp|%pISp", &sa, &sa);
+}
+
+static void __init
+ip6(void)
+{
+}
+
+static void __init
+ip(void)
+{
+	ip4();
+	ip6();
+}
+
+static void __init
+uuid(void)
+{
+	const char uuid[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
+			       0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
+
+	test("00010203-0405-0607-0809-0a0b0c0d0e0f", "%pUb", uuid);
+	test("00010203-0405-0607-0809-0A0B0C0D0E0F", "%pUB", uuid);
+	test("03020100-0504-0706-0809-0a0b0c0d0e0f", "%pUl", uuid);
+	test("03020100-0504-0706-0809-0A0B0C0D0E0F", "%pUL", uuid);
+}
+
+static void __init
+dentry(void)
+{
+}
+
+static void __init
+struct_va_format(void)
+{
+}
+
+static void __init
+struct_clk(void)
+{
+}
+
+static void __init
+bitmap(void)
+{
+	DECLARE_BITMAP(bits, 20);
+	const int primes[] = {2,3,5,7,11,13,17,19};
+	int i;
+
+	bitmap_zero(bits, 20);
+	test("00000|00000", "%20pb|%*pb", bits, 20, bits);
+	test("|", "%20pbl|%*pbl", bits, 20, bits);
+
+	for (i = 0; i < ARRAY_SIZE(primes); ++i)
+		set_bit(primes[i], bits);
+	test("a28ac|a28ac", "%20pb|%*pb", bits, 20, bits);
+	test("2-3,5,7,11,13,17,19|2-3,5,7,11,13,17,19", "%20pbl|%*pbl", bits, 20, bits);
+
+	bitmap_fill(bits, 20);
+	test("fffff|fffff", "%20pb|%*pb", bits, 20, bits);
+	test("0-19|0-19", "%20pbl|%*pbl", bits, 20, bits);
+}
+
+static void __init
+netdev_features(void)
+{
+}
+
+static void __init
+test_pointer(void)
+{
+	plain();
+	symbol_ptr();
+	kernel_ptr();
+	struct_resource();
+	addr();
+	escaped_str();
+	hex_string();
+	mac();
+	ip();
+	uuid();
+	dentry();
+	struct_va_format();
+	struct_clk();
+	bitmap();
+	netdev_features();
+}
+
+static int __init
+test_printf_init(void)
+{
+	test_buffer = kmalloc(BUF_SIZE, GFP_KERNEL);
+	if (!test_buffer)
+		return -ENOMEM;
+
+	test_basic();
+	test_number();
+	test_string();
+	test_pointer();
+
+	kfree(test_buffer);
+
+	if (failed_tests == 0)
+		pr_info("all %u tests passed\n", total_tests);
+	else
+		pr_warn("failed %u out of %u tests\n", failed_tests, total_tests);
+
+	return failed_tests ? -EINVAL : 0;
+}
+
+module_init(test_printf_init);
+
+MODULE_AUTHOR("Rasmus Villemoes <linux@rasmusvillemoes.dk>");
+MODULE_LICENSE("GPL");
