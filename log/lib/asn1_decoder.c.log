commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 8f3d207d2b00..58f72b25f8e9 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* Decoder for ASN.1 BER/DER/CER encoded bytestream
  *
  * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #include <linux/export.h>

commit afb33e40d54e365457a4fb5eada6df55cd11a9cf
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Jan 25 14:46:46 2019 -0600

    ASN.1: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch
    cases where we are expecting to fall through.
    
    This patch fixes the following warnings:
    
    lib/asn1_decoder.c:386:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    lib/asn1_decoder.c:449:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    This patch is part of the ongoing efforts to enabling
    -Wimplicit-fallthrough.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index dc14beae2c9a..8f3d207d2b00 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -385,6 +385,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	case ASN1_OP_END_SET_ACT:
 		if (unlikely(!(flags & FLAG_MATCHED)))
 			goto tag_mismatch;
+		/* fall through */
+
 	case ASN1_OP_END_SEQ:
 	case ASN1_OP_END_SET_OF:
 	case ASN1_OP_END_SEQ_OF:
@@ -450,6 +452,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 			pc += asn1_op_lengths[op];
 			goto next_op;
 		}
+		/* fall through */
+
 	case ASN1_OP_ACT:
 		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
 		if (ret < 0)

commit 81a7be2cd69b412ab6aeacfe5ebf1bb6e5bce955
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Dec 8 15:13:27 2017 +0000

    ASN.1: check for error from ASN1_OP_END__ACT actions
    
    asn1_ber_decoder() was ignoring errors from actions associated with the
    opcodes ASN1_OP_END_SEQ_ACT, ASN1_OP_END_SET_ACT,
    ASN1_OP_END_SEQ_OF_ACT, and ASN1_OP_END_SET_OF_ACT.  In practice, this
    meant the pkcs7_note_signed_info() action (since that was the only user
    of those opcodes).  Fix it by checking for the error, just like the
    decoder does for actions associated with the other opcodes.
    
    This bug allowed users to leak slab memory by repeatedly trying to add a
    specially crafted "pkcs7_test" key (requires CONFIG_PKCS7_TEST_KEY).
    
    In theory, this bug could also be used to bypass module signature
    verification, by providing a PKCS#7 message that is misparsed such that
    a signature's ->authattrs do not contain its ->msgdigest.  But it
    doesn't seem practical in normal cases, due to restrictions on the
    format of the ->authattrs.
    
    Fixes: 42d5ec27f873 ("X.509: Add an ASN.1 decoder")
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index d77cdfc4b554..dc14beae2c9a 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -439,6 +439,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 			else
 				act = machine[pc + 1];
 			ret = actions[act](context, hdr, 0, data + tdp, len);
+			if (ret < 0)
+				return ret;
 		}
 		pc += asn1_op_lengths[op];
 		goto next_op;

commit e0058f3a874ebb48b25be7ff79bc3b4e59929f90
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Dec 8 15:13:27 2017 +0000

    ASN.1: fix out-of-bounds read when parsing indefinite length item
    
    In asn1_ber_decoder(), indefinitely-sized ASN.1 items were being passed
    to the action functions before their lengths had been computed, using
    the bogus length of 0x80 (ASN1_INDEFINITE_LENGTH).  This resulted in
    reading data past the end of the input buffer, when given a specially
    crafted message.
    
    Fix it by rearranging the code so that the indefinite length is resolved
    before the action is called.
    
    This bug was originally found by fuzzing the X.509 parser in userspace
    using libFuzzer from the LLVM project.
    
    KASAN report (cleaned up slightly):
    
        BUG: KASAN: slab-out-of-bounds in memcpy ./include/linux/string.h:341 [inline]
        BUG: KASAN: slab-out-of-bounds in x509_fabricate_name.constprop.1+0x1a4/0x940 crypto/asymmetric_keys/x509_cert_parser.c:366
        Read of size 128 at addr ffff880035dd9eaf by task keyctl/195
    
        CPU: 1 PID: 195 Comm: keyctl Not tainted 4.14.0-09238-g1d3b78bbc6e9 #26
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-20171110_100015-anatol 04/01/2014
        Call Trace:
         __dump_stack lib/dump_stack.c:17 [inline]
         dump_stack+0xd1/0x175 lib/dump_stack.c:53
         print_address_description+0x78/0x260 mm/kasan/report.c:252
         kasan_report_error mm/kasan/report.c:351 [inline]
         kasan_report+0x23f/0x350 mm/kasan/report.c:409
         memcpy+0x1f/0x50 mm/kasan/kasan.c:302
         memcpy ./include/linux/string.h:341 [inline]
         x509_fabricate_name.constprop.1+0x1a4/0x940 crypto/asymmetric_keys/x509_cert_parser.c:366
         asn1_ber_decoder+0xb4a/0x1fd0 lib/asn1_decoder.c:447
         x509_cert_parse+0x1c7/0x620 crypto/asymmetric_keys/x509_cert_parser.c:89
         x509_key_preparse+0x61/0x750 crypto/asymmetric_keys/x509_public_key.c:174
         asymmetric_key_preparse+0xa4/0x150 crypto/asymmetric_keys/asymmetric_type.c:388
         key_create_or_update+0x4d4/0x10a0 security/keys/key.c:850
         SYSC_add_key security/keys/keyctl.c:122 [inline]
         SyS_add_key+0xe8/0x290 security/keys/keyctl.c:62
         entry_SYSCALL_64_fastpath+0x1f/0x96
    
        Allocated by task 195:
         __do_kmalloc_node mm/slab.c:3675 [inline]
         __kmalloc_node+0x47/0x60 mm/slab.c:3682
         kvmalloc ./include/linux/mm.h:540 [inline]
         SYSC_add_key security/keys/keyctl.c:104 [inline]
         SyS_add_key+0x19e/0x290 security/keys/keyctl.c:62
         entry_SYSCALL_64_fastpath+0x1f/0x96
    
    Fixes: 42d5ec27f873 ("X.509: Add an ASN.1 decoder")
    Reported-by: Alexander Potapenko <glider@google.com>
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 1ef0cec38d78..d77cdfc4b554 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -313,42 +313,47 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 
 	/* Decide how to handle the operation */
 	switch (op) {
-	case ASN1_OP_MATCH_ANY_ACT:
-	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:
-	case ASN1_OP_COND_MATCH_ANY_ACT:
-	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:
-		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
-		if (ret < 0)
-			return ret;
-		goto skip_data;
-
-	case ASN1_OP_MATCH_ACT:
-	case ASN1_OP_MATCH_ACT_OR_SKIP:
-	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
-		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
-		if (ret < 0)
-			return ret;
-		goto skip_data;
-
 	case ASN1_OP_MATCH:
 	case ASN1_OP_MATCH_OR_SKIP:
+	case ASN1_OP_MATCH_ACT:
+	case ASN1_OP_MATCH_ACT_OR_SKIP:
 	case ASN1_OP_MATCH_ANY:
 	case ASN1_OP_MATCH_ANY_OR_SKIP:
+	case ASN1_OP_MATCH_ANY_ACT:
+	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:
 	case ASN1_OP_COND_MATCH_OR_SKIP:
+	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
 	case ASN1_OP_COND_MATCH_ANY:
 	case ASN1_OP_COND_MATCH_ANY_OR_SKIP:
-	skip_data:
+	case ASN1_OP_COND_MATCH_ANY_ACT:
+	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:
+
 		if (!(flags & FLAG_CONS)) {
 			if (flags & FLAG_INDEFINITE_LENGTH) {
+				size_t tmp = dp;
+
 				ret = asn1_find_indefinite_length(
-					data, datalen, &dp, &len, &errmsg);
+					data, datalen, &tmp, &len, &errmsg);
 				if (ret < 0)
 					goto error;
-			} else {
-				dp += len;
 			}
 			pr_debug("- LEAF: %zu\n", len);
 		}
+
+		if (op & ASN1_OP_MATCH__ACT) {
+			unsigned char act;
+
+			if (op & ASN1_OP_MATCH__ANY)
+				act = machine[pc + 1];
+			else
+				act = machine[pc + 2];
+			ret = actions[act](context, hdr, tag, data + dp, len);
+			if (ret < 0)
+				return ret;
+		}
+
+		if (!(flags & FLAG_CONS))
+			dp += len;
 		pc += asn1_op_lengths[op];
 		goto next_op;
 

commit 624f5ab8720b3371367327a822c267699c1823b8
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Nov 7 22:29:02 2017 +0000

    KEYS: fix NULL pointer dereference during ASN.1 parsing [ver #2]
    
    syzkaller reported a NULL pointer dereference in asn1_ber_decoder().  It
    can be reproduced by the following command, assuming
    CONFIG_PKCS7_TEST_KEY=y:
    
            keyctl add pkcs7_test desc '' @s
    
    The bug is that if the data buffer is empty, an integer underflow occurs
    in the following check:
    
            if (unlikely(dp >= datalen - 1))
                    goto data_overrun_error;
    
    This results in the NULL data pointer being dereferenced.
    
    Fix it by checking for 'datalen - dp < 2' instead.
    
    Also fix the similar check for 'dp >= datalen - n' later in the same
    function.  That one possibly could result in a buffer overread.
    
    The NULL pointer dereference was reproducible using the "pkcs7_test" key
    type but not the "asymmetric" key type because the "asymmetric" key type
    checks for a 0-length payload before calling into the ASN.1 decoder but
    the "pkcs7_test" key type does not.
    
    The bug report was:
    
        BUG: unable to handle kernel NULL pointer dereference at           (null)
        IP: asn1_ber_decoder+0x17f/0xe60 lib/asn1_decoder.c:233
        PGD 7b708067 P4D 7b708067 PUD 7b6ee067 PMD 0
        Oops: 0000 [#1] SMP
        Modules linked in:
        CPU: 0 PID: 522 Comm: syz-executor1 Not tainted 4.14.0-rc8 #7
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.3-20171021_125229-anatol 04/01/2014
        task: ffff9b6b3798c040 task.stack: ffff9b6b37970000
        RIP: 0010:asn1_ber_decoder+0x17f/0xe60 lib/asn1_decoder.c:233
        RSP: 0018:ffff9b6b37973c78 EFLAGS: 00010216
        RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000000000021c
        RDX: ffffffff814a04ed RSI: ffffb1524066e000 RDI: ffffffff910759e0
        RBP: ffff9b6b37973d60 R08: 0000000000000001 R09: ffff9b6b3caa4180
        R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000002
        R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
        FS:  00007f10ed1f2700(0000) GS:ffff9b6b3ea00000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: 0000000000000000 CR3: 000000007b6f3000 CR4: 00000000000006f0
        Call Trace:
         pkcs7_parse_message+0xee/0x240 crypto/asymmetric_keys/pkcs7_parser.c:139
         verify_pkcs7_signature+0x33/0x180 certs/system_keyring.c:216
         pkcs7_preparse+0x41/0x70 crypto/asymmetric_keys/pkcs7_key_type.c:63
         key_create_or_update+0x180/0x530 security/keys/key.c:855
         SYSC_add_key security/keys/keyctl.c:122 [inline]
         SyS_add_key+0xbf/0x250 security/keys/keyctl.c:62
         entry_SYSCALL_64_fastpath+0x1f/0xbe
        RIP: 0033:0x4585c9
        RSP: 002b:00007f10ed1f1bd8 EFLAGS: 00000216 ORIG_RAX: 00000000000000f8
        RAX: ffffffffffffffda RBX: 00007f10ed1f2700 RCX: 00000000004585c9
        RDX: 0000000020000000 RSI: 0000000020008ffb RDI: 0000000020008000
        RBP: 0000000000000000 R08: ffffffffffffffff R09: 0000000000000000
        R10: 0000000000000000 R11: 0000000000000216 R12: 00007fff1b2260ae
        R13: 00007fff1b2260af R14: 00007f10ed1f2700 R15: 0000000000000000
        Code: dd ca ff 48 8b 45 88 48 83 e8 01 4c 39 f0 0f 86 a8 07 00 00 e8 53 dd ca ff 49 8d 46 01 48 89 85 58 ff ff ff 48 8b 85 60 ff ff ff <42> 0f b6 0c 30 89 c8 88 8d 75 ff ff ff 83 e0 1f 89 8d 28 ff ff
        RIP: asn1_ber_decoder+0x17f/0xe60 lib/asn1_decoder.c:233 RSP: ffff9b6b37973c78
        CR2: 0000000000000000
    
    Fixes: 42d5ec27f873 ("X.509: Add an ASN.1 decoder")
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index fef5d2e114be..1ef0cec38d78 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -228,7 +228,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		hdr = 2;
 
 		/* Extract a tag from the data */
-		if (unlikely(dp >= datalen - 1))
+		if (unlikely(datalen - dp < 2))
 			goto data_overrun_error;
 		tag = data[dp++];
 		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
@@ -274,7 +274,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 				int n = len - 0x80;
 				if (unlikely(n > 2))
 					goto length_too_long;
-				if (unlikely(dp >= datalen - n))
+				if (unlikely(n > datalen - dp))
 					goto data_overrun_error;
 				hdr += n;
 				for (len = 0; n > 0; n--) {

commit 2eb9eabf1e868fda15808954fb29b0f105ed65f1
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Nov 2 00:47:19 2017 +0000

    KEYS: fix out-of-bounds read during ASN.1 parsing
    
    syzkaller with KASAN reported an out-of-bounds read in
    asn1_ber_decoder().  It can be reproduced by the following command,
    assuming CONFIG_X509_CERTIFICATE_PARSER=y and CONFIG_KASAN=y:
    
        keyctl add asymmetric desc $'\x30\x30' @s
    
    The bug is that the length of an ASN.1 data value isn't validated in the
    case where it is encoded using the short form, causing the decoder to
    read past the end of the input buffer.  Fix it by validating the length.
    
    The bug report was:
    
        BUG: KASAN: slab-out-of-bounds in asn1_ber_decoder+0x10cb/0x1730 lib/asn1_decoder.c:233
        Read of size 1 at addr ffff88003cccfa02 by task syz-executor0/6818
    
        CPU: 1 PID: 6818 Comm: syz-executor0 Not tainted 4.14.0-rc7-00008-g5f479447d983 #2
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
        Call Trace:
         __dump_stack lib/dump_stack.c:16 [inline]
         dump_stack+0xb3/0x10b lib/dump_stack.c:52
         print_address_description+0x79/0x2a0 mm/kasan/report.c:252
         kasan_report_error mm/kasan/report.c:351 [inline]
         kasan_report+0x236/0x340 mm/kasan/report.c:409
         __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:427
         asn1_ber_decoder+0x10cb/0x1730 lib/asn1_decoder.c:233
         x509_cert_parse+0x1db/0x650 crypto/asymmetric_keys/x509_cert_parser.c:89
         x509_key_preparse+0x64/0x7a0 crypto/asymmetric_keys/x509_public_key.c:174
         asymmetric_key_preparse+0xcb/0x1a0 crypto/asymmetric_keys/asymmetric_type.c:388
         key_create_or_update+0x347/0xb20 security/keys/key.c:855
         SYSC_add_key security/keys/keyctl.c:122 [inline]
         SyS_add_key+0x1cd/0x340 security/keys/keyctl.c:62
         entry_SYSCALL_64_fastpath+0x1f/0xbe
        RIP: 0033:0x447c89
        RSP: 002b:00007fca7a5d3bd8 EFLAGS: 00000246 ORIG_RAX: 00000000000000f8
        RAX: ffffffffffffffda RBX: 00007fca7a5d46cc RCX: 0000000000447c89
        RDX: 0000000020006f4a RSI: 0000000020006000 RDI: 0000000020001ff5
        RBP: 0000000000000046 R08: fffffffffffffffd R09: 0000000000000000
        R10: 0000000000000002 R11: 0000000000000246 R12: 0000000000000000
        R13: 0000000000000000 R14: 00007fca7a5d49c0 R15: 00007fca7a5d4700
    
    Fixes: 42d5ec27f873 ("X.509: Add an ASN.1 decoder")
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 0bd8a611eb83..fef5d2e114be 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -284,6 +284,9 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 				if (unlikely(len > datalen - dp))
 					goto data_overrun_error;
 			}
+		} else {
+			if (unlikely(len > datalen - dp))
+				goto data_overrun_error;
 		}
 
 		if (flags & FLAG_CONS) {

commit 9a07a7968407e20fe87ed6b5eb6a6000e4819492
Merge: 16490980e396 256b1cfb9a34
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 09:33:39 2016 -0700

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto update from Herbert Xu:
     "API:
    
       - Crypto self tests can now be disabled at boot/run time.
       - Add async support to algif_aead.
    
      Algorithms:
    
       - A large number of fixes to MPI from Nicolai Stange.
       - Performance improvement for HMAC DRBG.
    
      Drivers:
    
       - Use generic crypto engine in omap-des.
       - Merge ppc4xx-rng and crypto4xx drivers.
       - Fix lockups in sun4i-ss driver by disabling IRQs.
       - Add DMA engine support to ccp.
       - Reenable talitos hash algorithms.
       - Add support for Hisilicon SoC RNG.
       - Add basic crypto driver for the MXC SCC.
    
      Others:
    
       - Do not allocate crypto hash tfm in NORECLAIM context in ecryptfs"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (77 commits)
      crypto: qat - change the adf_ctl_stop_devices to void
      crypto: caam - fix caam_jr_alloc() ret code
      crypto: vmx - comply with ABIs that specify vrsave as reserved.
      crypto: testmgr - Add a flag allowing the self-tests to be disabled at runtime.
      crypto: ccp - constify ccp_actions structure
      crypto: marvell/cesa - Use dma_pool_zalloc
      crypto: qat - make adf_vf_isr.c dependant on IOV config
      crypto: qat - Fix typo in comments
      lib: asn1_decoder - add MODULE_LICENSE("GPL")
      crypto: omap-sham - Use dma_request_chan() for requesting DMA channel
      crypto: omap-des - Use dma_request_chan() for requesting DMA channel
      crypto: omap-aes - Use dma_request_chan() for requesting DMA channel
      crypto: omap-des - Integrate with the crypto engine framework
      crypto: s5p-sss - fix incorrect usage of scatterlists api
      crypto: s5p-sss - Fix missed interrupts when working with 8 kB blocks
      crypto: s5p-sss - Use common BIT macro
      crypto: mxc-scc - fix unwinding in mxc_scc_crypto_register()
      crypto: mxc-scc - signedness bugs in mxc_scc_ablkcipher_req_init()
      crypto: talitos - fix ahash algorithms registration
      crypto: ccp - Ensure all dependencies are specified
      ...

commit 23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa
Author: David Howells <dhowells@redhat.com>
Date:   Tue Feb 23 11:03:12 2016 +0000

    KEYS: Fix ASN.1 indefinite length object parsing
    
    This fixes CVE-2016-0758.
    
    In the ASN.1 decoder, when the length field of an ASN.1 value is extracted,
    it isn't validated against the remaining amount of data before being added
    to the cursor.  With a sufficiently large size indicated, the check:
    
            datalen - dp < 2
    
    may then fail due to integer overflow.
    
    Fix this by checking the length indicated against the amount of remaining
    data in both places a definite length is determined.
    
    Whilst we're at it, make the following changes:
    
     (1) Check the maximum size of extended length does not exceed the capacity
         of the variable it's being stored in (len) rather than the type that
         variable is assumed to be (size_t).
    
     (2) Compare the EOC tag to the symbolic constant ASN1_EOC rather than the
         integer 0.
    
     (3) To reduce confusion, move the initialisation of len outside of:
    
            for (len = 0; n > 0; n--) {
    
         since it doesn't have anything to do with the loop counter n.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Peter Jones <pjones@redhat.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 2b3f46c049d4..554522934c44 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -74,7 +74,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 
 	/* Extract a tag from the data */
 	tag = data[dp++];
-	if (tag == 0) {
+	if (tag == ASN1_EOC) {
 		/* It appears to be an EOC. */
 		if (data[dp++] != 0)
 			goto invalid_eoc;
@@ -96,10 +96,8 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 
 	/* Extract the length */
 	len = data[dp++];
-	if (len <= 0x7f) {
-		dp += len;
-		goto next_tag;
-	}
+	if (len <= 0x7f)
+		goto check_length;
 
 	if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
 		/* Indefinite length */
@@ -110,14 +108,18 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 	}
 
 	n = len - 0x80;
-	if (unlikely(n > sizeof(size_t) - 1))
+	if (unlikely(n > sizeof(len) - 1))
 		goto length_too_long;
 	if (unlikely(n > datalen - dp))
 		goto data_overrun_error;
-	for (len = 0; n > 0; n--) {
+	len = 0;
+	for (; n > 0; n--) {
 		len <<= 8;
 		len |= data[dp++];
 	}
+check_length:
+	if (len > datalen - dp)
+		goto data_overrun_error;
 	dp += len;
 	goto next_tag;
 

commit ccab6058daa4933def4194b8ff6a4bb33c7f2a97
Author: Tudor Ambarus <tudor-dan.ambarus@nxp.com>
Date:   Fri Apr 29 17:48:08 2016 +0300

    lib: asn1_decoder - add MODULE_LICENSE("GPL")
    
    A kernel taint results when loading the rsa_generic module:
    
    root@(none):~# modprobe rsa_generic
    asn1_decoder: module license 'unspecified' taints kernel.
    Disabling lock debugging due to kernel taint
    
    "Tainting" of the kernel is (usually) a way of indicating that
    a proprietary module has been inserted, which is not the case here.
    
    Signed-off-by: Tudor Ambarus <tudor-dan.ambarus@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 2b3f46c049d4..b1ffcab7211a 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -12,6 +12,7 @@
 #include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
+#include <linux/module.h>
 #include <linux/asn1_decoder.h>
 #include <linux/asn1_ber_bytecode.h>
 
@@ -504,3 +505,5 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	return -EBADMSG;
 }
 EXPORT_SYMBOL_GPL(asn1_ber_decoder);
+
+MODULE_LICENSE("GPL");

commit 233ce79db4b23a174bcf30bde5d6ad913d5f46d3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Handle 'ANY OPTIONAL' in grammar
    
    An ANY object in an ASN.1 grammar that is marked OPTIONAL should be skipped
    if there is no more data to be had.
    
    This can be tested by editing X.509 certificates or PKCS#7 messages to
    remove the NULL from subobjects that look like the following:
    
            SEQUENCE {
              OBJECT(2a864886f70d01010b);
              NULL();
            }
    
    This is an algorithm identifier plus an optional parameter.
    
    The modified DER can be passed to one of:
    
            keyctl padd asymmetric "" @s </tmp/modified.x509
            keyctl padd pkcs7_test foo @s </tmp/modified.pkcs7
    
    It should work okay with the patch and produce EBADMSG without.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 3f74dd3e2910..2b3f46c049d4 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -24,12 +24,16 @@ static const unsigned char asn1_op_lengths[ASN1_OP__NR] = {
 	[ASN1_OP_MATCH_JUMP]			= 1 + 1 + 1,
 	[ASN1_OP_MATCH_JUMP_OR_SKIP]		= 1 + 1 + 1,
 	[ASN1_OP_MATCH_ANY]			= 1,
+	[ASN1_OP_MATCH_ANY_OR_SKIP]		= 1,
 	[ASN1_OP_MATCH_ANY_ACT]			= 1         + 1,
+	[ASN1_OP_MATCH_ANY_ACT_OR_SKIP]		= 1         + 1,
 	[ASN1_OP_COND_MATCH_OR_SKIP]		= 1 + 1,
 	[ASN1_OP_COND_MATCH_ACT_OR_SKIP]	= 1 + 1     + 1,
 	[ASN1_OP_COND_MATCH_JUMP_OR_SKIP]	= 1 + 1 + 1,
 	[ASN1_OP_COND_MATCH_ANY]		= 1,
+	[ASN1_OP_COND_MATCH_ANY_OR_SKIP]	= 1,
 	[ASN1_OP_COND_MATCH_ANY_ACT]		= 1         + 1,
+	[ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP]	= 1         + 1,
 	[ASN1_OP_COND_FAIL]			= 1,
 	[ASN1_OP_COMPLETE]			= 1,
 	[ASN1_OP_ACT]				= 1         + 1,
@@ -304,7 +308,9 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	/* Decide how to handle the operation */
 	switch (op) {
 	case ASN1_OP_MATCH_ANY_ACT:
+	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:
 	case ASN1_OP_COND_MATCH_ANY_ACT:
+	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:
 		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
 		if (ret < 0)
 			return ret;
@@ -321,8 +327,10 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	case ASN1_OP_MATCH:
 	case ASN1_OP_MATCH_OR_SKIP:
 	case ASN1_OP_MATCH_ANY:
+	case ASN1_OP_MATCH_ANY_OR_SKIP:
 	case ASN1_OP_COND_MATCH_OR_SKIP:
 	case ASN1_OP_COND_MATCH_ANY:
+	case ASN1_OP_COND_MATCH_ANY_OR_SKIP:
 	skip_data:
 		if (!(flags & FLAG_CONS)) {
 			if (flags & FLAG_INDEFINITE_LENGTH) {

commit 0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Fix non-match detection failure on data overrun
    
    If the ASN.1 decoder is asked to parse a sequence of objects, non-optional
    matches get skipped if there's no more data to be had rather than a
    data-overrun error being reported.
    
    This is due to the code segment that decides whether to skip optional
    matches (ie. matches that could get ignored because an element is marked
    OPTIONAL in the grammar) due to a lack of data also skips non-optional
    elements if the data pointer has reached the end of the buffer.
    
    This can be tested with the data decoder for the new RSA akcipher algorithm
    that takes three non-optional integers.  Currently, it skips the last
    integer if there is insufficient data.
    
    Without the fix, #defining DEBUG in asn1_decoder.c will show something
    like:
    
            next_op: pc=0/13 dp=0/270 C=0 J=0
            - match? 30 30 00
            - TAG: 30 266 CONS
            next_op: pc=2/13 dp=4/270 C=1 J=0
            - match? 02 02 00
            - TAG: 02 257
            - LEAF: 257
            next_op: pc=5/13 dp=265/270 C=1 J=0
            - match? 02 02 00
            - TAG: 02 3
            - LEAF: 3
            next_op: pc=8/13 dp=270/270 C=1 J=0
            next_op: pc=11/13 dp=270/270 C=1 J=0
            - end cons t=4 dp=270 l=270/270
    
    The next_op line for pc=8/13 should be followed by a match line.
    
    This is not exploitable for X.509 certificates by means of shortening the
    message and fixing up the ASN.1 CONS tags because:
    
     (1) The relevant records being built up are cleared before use.
    
     (2) If the message is shortened sufficiently to remove the public key, the
         ASN.1 parse of the RSA key will fail quickly due to a lack of data.
    
     (3) Extracted signature data is either turned into MPIs (which cope with a
         0 length) or is simpler integers specifying algoritms and suchlike
         (which can validly be 0); and
    
     (4) The AKID and SKID extensions are optional and their removal is handled
         without risking passing a NULL to asymmetric_key_generate_id().
    
     (5) If the certificate is truncated sufficiently to remove the subject,
         issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons
         stack underflow' return.
    
    This is not exploitable for PKCS#7 messages by means of removal of elements
    from such a message from the tail end of a sequence:
    
     (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable
         as detailed above.
    
     (2) The message digest content isn't used if it shows a NULL pointer,
         similarly, the authattrs aren't used if that shows a NULL pointer.
    
     (3) A missing signature results in a NULL MPI - which the MPI routines deal
         with.
    
     (4) If data is NULL, it is expected that the message has detached content and
         that is handled appropriately.
    
     (5) If the serialNumber is excised, the unconditional action associated
         with it will pick up the containing SEQUENCE instead, so no NULL
         pointer will be seen here.
    
         If both the issuer and the serialNumber are excised, the ASN.1 decode
         will fail with an 'Unexpected tag' return.
    
         In either case, there's no way to get to asymmetric_key_generate_id()
         with a NULL pointer.
    
     (6) Other fields are decoded to simple integers.  Shortening the message
         to omit an algorithm ID field will cause checks on this to fail early
         in the verification process.
    
    
    This can also be tested by snipping objects off of the end of the ASN.1 stream
    such that mandatory tags are removed - or even from the end of internal
    SEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be
    produced.  Without this patch ERANGE or ENOPKG might be produced or the parse
    may apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced
    later, depending on what gets snipped.
    
    Just snipping off the final BIT_STRING or OCTET_STRING from either sample
    should be a start since both are mandatory and neither will cause an EBADMSG
    without the patches
    
    Reported-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 55980d7e1ac0..3f74dd3e2910 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -210,9 +210,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
-		if ((op & ASN1_OP_MATCH__COND &&
-		     flags & FLAG_MATCHED) ||
-		    dp == datalen) {
+		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
+		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;

commit 3f3af97d8225a58ecdcde7217c030b17e5198226
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Fix actions on CHOICE elements with IMPLICIT tags
    
    In an ASN.1 description where there is a CHOICE construct that contains
    elements with IMPLICIT tags that refer to constructed types, actions to be
    taken on those elements should be conditional on the corresponding element
    actually being matched.  Currently, however, such actions are performed
    unconditionally in the middle of processing the CHOICE.
    
    For example, look at elements 'b' and 'e' here:
    
            A ::= SEQUENCE {
                            CHOICE {
                            b [0] IMPLICIT B ({ do_XXXXXXXXXXXX_b }),
                            c [1] EXPLICIT C ({ do_XXXXXXXXXXXX_c }),
                            d [2] EXPLICIT B ({ do_XXXXXXXXXXXX_d }),
                            e [3] IMPLICIT C ({ do_XXXXXXXXXXXX_e }),
                            f [4] IMPLICIT INTEGER ({ do_XXXXXXXXXXXX_f })
                            }
                    } ({ do_XXXXXXXXXXXX_A })
    
            B ::= SET OF OBJECT IDENTIFIER ({ do_XXXXXXXXXXXX_oid })
    
            C ::= SET OF INTEGER ({ do_XXXXXXXXXXXX_int })
    
    They each have an action (do_XXXXXXXXXXXX_b and do_XXXXXXXXXXXX_e) that
    should only be processed if that element is matched.
    
    The problem is that there's no easy place to hang the action off in the
    subclause (type B for element 'b' and type C for element 'e') because
    subclause opcode sequences can be shared.
    
    To fix this, introduce a conditional action opcode(ASN1_OP_MAYBE_ACT) that
    the decoder only processes if the preceding match was successful.  This can
    be seen in an excerpt from the output of the fixed ASN.1 compiler for the
    above ASN.1 description:
    
            [  13] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,              // e
            [  14] =  _tagn(CONT, CONS,  3),
            [  15] =  _jump_target(45),             // --> C
            [  16] =  ASN1_OP_MAYBE_ACT,
            [  17] =  _action(ACT_do_XXXXXXXXXXXX_e),
    
    In this, if the op at [13] is matched (ie. element 'e' above) then the
    action at [16] will be performed.  However, if the op at [13] doesn't match
    or is skipped because it is conditional and some previous op matched, then
    the action at [16] will be ignored.
    
    Note that to make this work in the decoder, the ASN1_OP_RETURN op must set
    the flag to indicate that a match happened.  This is necessary because the
    _jump_target() seen above introduces a subclause (in this case an object of
    type 'C') which is likely to alter the flag.  Setting the flag here is okay
    because to process a subclause, a match must have happened and caused a
    jump.
    
    This cannot be tested with the code as it stands, but rather affects future
    code.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 1a000bb050f9..55980d7e1ac0 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -33,6 +33,7 @@ static const unsigned char asn1_op_lengths[ASN1_OP__NR] = {
 	[ASN1_OP_COND_FAIL]			= 1,
 	[ASN1_OP_COMPLETE]			= 1,
 	[ASN1_OP_ACT]				= 1         + 1,
+	[ASN1_OP_MAYBE_ACT]			= 1         + 1,
 	[ASN1_OP_RETURN]			= 1,
 	[ASN1_OP_END_SEQ]			= 1,
 	[ASN1_OP_END_SEQ_OF]			= 1     + 1,
@@ -177,6 +178,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	unsigned char flags = 0;
 #define FLAG_INDEFINITE_LENGTH	0x01
 #define FLAG_MATCHED		0x02
+#define FLAG_LAST_MATCHED	0x04 /* Last tag matched */
 #define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
 				      * - ie. whether or not we are going to parse
 				      *   a compound type.
@@ -211,6 +213,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		if ((op & ASN1_OP_MATCH__COND &&
 		     flags & FLAG_MATCHED) ||
 		    dp == datalen) {
+			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;
 		}
@@ -422,8 +425,15 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		pc += asn1_op_lengths[op];
 		goto next_op;
 
+	case ASN1_OP_MAYBE_ACT:
+		if (!(flags & FLAG_LAST_MATCHED)) {
+			pc += asn1_op_lengths[op];
+			goto next_op;
+		}
 	case ASN1_OP_ACT:
 		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
+		if (ret < 0)
+			return ret;
 		pc += asn1_op_lengths[op];
 		goto next_op;
 
@@ -431,6 +441,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		if (unlikely(jsp <= 0))
 			goto jump_stack_underflow;
 		pc = jump_stack[--jsp];
+		flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
 		goto next_op;
 
 	default:
@@ -438,7 +449,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	}
 
 	/* Shouldn't reach here */
-	pr_err("ASN.1 decoder error: Found reserved opcode (%u)\n", op);
+	pr_err("ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n",
+	       op, pc);
 	return -EBADMSG;
 
 data_overrun_error:

commit 548bbff9818c7ddd325b47face1c9bf9a53ad0c7
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 4 16:12:01 2014 -0700

    lib/asn1_decoder.c: kernel-doc warning fix
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 11b9b01fda6b..1a000bb050f9 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -140,7 +140,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
  * @decoder: The decoder definition (produced by asn1_compiler)
  * @context: The caller's context (to be passed to the action functions)
  * @data: The encoded data
- * @datasize: The size of the encoded data
+ * @datalen: The size of the encoded data
  *
  * Decode BER/DER/CER encoded ASN.1 data according to a bytecode pattern
  * produced by asn1_compiler.  Action functions are called on marked tags to

commit 7a684c452e2589f3ddd7e2d466b4f747d3715ad9
Merge: 7f2de8171ddf e10e1774efbd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 19 07:55:08 2012 -0800

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module update from Rusty Russell:
     "Nothing all that exciting; a new module-from-fd syscall for those who
      want to verify the source of the module (ChromeOS) and/or use standard
      IMA on it or other security hooks."
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      MODSIGN: Fix kbuild output when using default extra_certificates
      MODSIGN: Avoid using .incbin in C source
      modules: don't hand 0 to vmalloc.
      module: Remove a extra null character at the top of module->strtab.
      ASN.1: Use the ASN1_LONG_TAG and ASN1_INDEFINITE_LENGTH constants
      ASN.1: Define indefinite length marker constant
      moduleparam: use __UNIQUE_ID()
      __UNIQUE_ID()
      MODSIGN: Add modules_sign make target
      powerpc: add finit_module syscall.
      ima: support new kernel module syscall
      add finit_module syscall to asm-generic
      ARM: add finit_module syscall to ARM
      security: introduce kernel_module_from_file hook
      module: add flags arg to sys_finit_module()
      module: add syscall to load module from fd

commit 99cca91e370ab9224755365dda98b78eb5a5417f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Dec 5 11:55:30 2012 +1030

    ASN.1: Use the ASN1_LONG_TAG and ASN1_INDEFINITE_LENGTH constants
    
    Use the ASN1_LONG_TAG and ASN1_INDEFINITE_LENGTH constants in the ASN.1
    general decoder instead of the equivalent numbers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index de2c8b5a715b..7bd2188ed939 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -81,7 +81,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 		goto next_tag;
 	}
 
-	if (unlikely((tag & 0x1f) == 0x1f)) {
+	if (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {
 		do {
 			if (unlikely(datalen - dp < 2))
 				goto data_overrun_error;
@@ -96,7 +96,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 		goto next_tag;
 	}
 
-	if (unlikely(len == 0x80)) {
+	if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
 		/* Indefinite length */
 		if (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))
 			goto indefinite_len_primitive;
@@ -222,7 +222,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		if (unlikely(dp >= datalen - 1))
 			goto data_overrun_error;
 		tag = data[dp++];
-		if (unlikely((tag & 0x1f) == 0x1f))
+		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
 			goto long_tag_not_supported;
 
 		if (op & ASN1_OP_MATCH__ANY) {
@@ -254,7 +254,7 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 
 		len = data[dp++];
 		if (len > 0x7f) {
-			if (unlikely(len == 0x80)) {
+			if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
 				/* Indefinite length */
 				if (unlikely(!(tag & ASN1_CONS_BIT)))
 					goto indefinite_len_primitive;

commit f3537f91f9be2ce5fcbaa1aa6d787ad0436daec6
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 22 15:05:55 2012 +0100

    ASN.1: Fix an indefinite length skip error
    
    Fix an error in asn1_find_indefinite_length() whereby small definite length
    elements of size 0x7f are incorrecly classified as non-small.  Without this
    fix, an error will be given as the length of the length will be perceived as
    being very much greater than the maximum supported size.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index de2c8b5a715b..5293d2433029 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -91,7 +91,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 
 	/* Extract the length */
 	len = data[dp++];
-	if (len < 0x7f) {
+	if (len <= 0x7f) {
 		dp += len;
 		goto next_tag;
 	}

commit dbadc17683e6c673a69b236c0f041b931cc55c42
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 4 14:21:23 2012 +0100

    X.509: Fix indefinite length element skip error handling
    
    asn1_find_indefinite_length() returns an error indicator of -1, which the
    caller asn1_ber_decoder() places in a size_t (which is usually unsigned) and
    then checks to see whether it is less than 0 (which it can't be).  This can
    lead to the following warning:
    
            lib/asn1_decoder.c:320 asn1_ber_decoder()
                    warn: unsigned 'len' is never less than zero.
    
    Instead, asn1_find_indefinite_length() update the caller's idea of the data
    cursor and length separately from returning the error code.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
index 2e4196ddf06f..de2c8b5a715b 100644
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@ -46,12 +46,18 @@ static const unsigned char asn1_op_lengths[ASN1_OP__NR] = {
 
 /*
  * Find the length of an indefinite length object
+ * @data: The data buffer
+ * @datalen: The end of the innermost containing element in the buffer
+ * @_dp: The data parse cursor (updated before returning)
+ * @_len: Where to return the size of the element.
+ * @_errmsg: Where to return a pointer to an error message on error
  */
 static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,
-				       const char **_errmsg, size_t *_err_dp)
+				       size_t *_dp, size_t *_len,
+				       const char **_errmsg)
 {
 	unsigned char tag, tmp;
-	size_t dp = 0, len, n;
+	size_t dp = *_dp, len, n;
 	int indef_level = 1;
 
 next_tag:
@@ -67,8 +73,11 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 		/* It appears to be an EOC. */
 		if (data[dp++] != 0)
 			goto invalid_eoc;
-		if (--indef_level <= 0)
-			return dp;
+		if (--indef_level <= 0) {
+			*_len = dp - *_dp;
+			*_dp = dp;
+			return 0;
+		}
 		goto next_tag;
 	}
 
@@ -122,7 +131,7 @@ static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 missing_eoc:
 	*_errmsg = "Missing EOC in indefinite len cons";
 error:
-	*_err_dp = dp;
+	*_dp = dp;
 	return -1;
 }
 
@@ -315,13 +324,14 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 	skip_data:
 		if (!(flags & FLAG_CONS)) {
 			if (flags & FLAG_INDEFINITE_LENGTH) {
-				len = asn1_find_indefinite_length(
-					data + dp, datalen - dp, &errmsg, &dp);
-				if (len < 0)
+				ret = asn1_find_indefinite_length(
+					data, datalen, &dp, &len, &errmsg);
+				if (ret < 0)
 					goto error;
+			} else {
+				dp += len;
 			}
 			pr_debug("- LEAF: %zu\n", len);
-			dp += len;
 		}
 		pc += asn1_op_lengths[op];
 		goto next_op;

commit 42d5ec27f873c654a68f7f865dcd7737513e9508
Author: David Howells <dhowells@redhat.com>
Date:   Mon Sep 24 17:11:16 2012 +0100

    X.509: Add an ASN.1 decoder
    
    Add an ASN.1 BER/DER/CER decoder.  This uses the bytecode from the ASN.1
    compiler in the previous patch to inform it as to what to expect to find in the
    encoded byte stream.  The output from the compiler also tells it what functions
    to call on what tags, thus allowing the caller to retrieve information.
    
    The decoder is called as follows:
    
            int asn1_decoder(const struct asn1_decoder *decoder,
                             void *context,
                             const unsigned char *data,
                             size_t datalen);
    
    The decoder argument points to the bytecode from the ASN.1 compiler.  context
    is the caller's context and is passed to the action functions.  data and
    datalen define the byte stream to be decoded.
    
    Note that the decoder is currently limited to datalen being less than 64K.
    This reduces the amount of stack space used by the decoder because ASN.1 is a
    nested construct.  Similarly, the decoder is limited to a maximum of 10 levels
    of constructed data outside of a leaf node also in an effort to keep stack
    usage down.
    
    These restrictions can be raised if necessary.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c
new file mode 100644
index 000000000000..2e4196ddf06f
--- /dev/null
+++ b/lib/asn1_decoder.c
@@ -0,0 +1,477 @@
+/* Decoder for ASN.1 BER/DER/CER encoded bytestream
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/asn1_decoder.h>
+#include <linux/asn1_ber_bytecode.h>
+
+static const unsigned char asn1_op_lengths[ASN1_OP__NR] = {
+	/*					OPC TAG JMP ACT */
+	[ASN1_OP_MATCH]				= 1 + 1,
+	[ASN1_OP_MATCH_OR_SKIP]			= 1 + 1,
+	[ASN1_OP_MATCH_ACT]			= 1 + 1     + 1,
+	[ASN1_OP_MATCH_ACT_OR_SKIP]		= 1 + 1     + 1,
+	[ASN1_OP_MATCH_JUMP]			= 1 + 1 + 1,
+	[ASN1_OP_MATCH_JUMP_OR_SKIP]		= 1 + 1 + 1,
+	[ASN1_OP_MATCH_ANY]			= 1,
+	[ASN1_OP_MATCH_ANY_ACT]			= 1         + 1,
+	[ASN1_OP_COND_MATCH_OR_SKIP]		= 1 + 1,
+	[ASN1_OP_COND_MATCH_ACT_OR_SKIP]	= 1 + 1     + 1,
+	[ASN1_OP_COND_MATCH_JUMP_OR_SKIP]	= 1 + 1 + 1,
+	[ASN1_OP_COND_MATCH_ANY]		= 1,
+	[ASN1_OP_COND_MATCH_ANY_ACT]		= 1         + 1,
+	[ASN1_OP_COND_FAIL]			= 1,
+	[ASN1_OP_COMPLETE]			= 1,
+	[ASN1_OP_ACT]				= 1         + 1,
+	[ASN1_OP_RETURN]			= 1,
+	[ASN1_OP_END_SEQ]			= 1,
+	[ASN1_OP_END_SEQ_OF]			= 1     + 1,
+	[ASN1_OP_END_SET]			= 1,
+	[ASN1_OP_END_SET_OF]			= 1     + 1,
+	[ASN1_OP_END_SEQ_ACT]			= 1         + 1,
+	[ASN1_OP_END_SEQ_OF_ACT]		= 1     + 1 + 1,
+	[ASN1_OP_END_SET_ACT]			= 1         + 1,
+	[ASN1_OP_END_SET_OF_ACT]		= 1     + 1 + 1,
+};
+
+/*
+ * Find the length of an indefinite length object
+ */
+static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,
+				       const char **_errmsg, size_t *_err_dp)
+{
+	unsigned char tag, tmp;
+	size_t dp = 0, len, n;
+	int indef_level = 1;
+
+next_tag:
+	if (unlikely(datalen - dp < 2)) {
+		if (datalen == dp)
+			goto missing_eoc;
+		goto data_overrun_error;
+	}
+
+	/* Extract a tag from the data */
+	tag = data[dp++];
+	if (tag == 0) {
+		/* It appears to be an EOC. */
+		if (data[dp++] != 0)
+			goto invalid_eoc;
+		if (--indef_level <= 0)
+			return dp;
+		goto next_tag;
+	}
+
+	if (unlikely((tag & 0x1f) == 0x1f)) {
+		do {
+			if (unlikely(datalen - dp < 2))
+				goto data_overrun_error;
+			tmp = data[dp++];
+		} while (tmp & 0x80);
+	}
+
+	/* Extract the length */
+	len = data[dp++];
+	if (len < 0x7f) {
+		dp += len;
+		goto next_tag;
+	}
+
+	if (unlikely(len == 0x80)) {
+		/* Indefinite length */
+		if (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))
+			goto indefinite_len_primitive;
+		indef_level++;
+		goto next_tag;
+	}
+
+	n = len - 0x80;
+	if (unlikely(n > sizeof(size_t) - 1))
+		goto length_too_long;
+	if (unlikely(n > datalen - dp))
+		goto data_overrun_error;
+	for (len = 0; n > 0; n--) {
+		len <<= 8;
+		len |= data[dp++];
+	}
+	dp += len;
+	goto next_tag;
+
+length_too_long:
+	*_errmsg = "Unsupported length";
+	goto error;
+indefinite_len_primitive:
+	*_errmsg = "Indefinite len primitive not permitted";
+	goto error;
+invalid_eoc:
+	*_errmsg = "Invalid length EOC";
+	goto error;
+data_overrun_error:
+	*_errmsg = "Data overrun error";
+	goto error;
+missing_eoc:
+	*_errmsg = "Missing EOC in indefinite len cons";
+error:
+	*_err_dp = dp;
+	return -1;
+}
+
+/**
+ * asn1_ber_decoder - Decoder BER/DER/CER ASN.1 according to pattern
+ * @decoder: The decoder definition (produced by asn1_compiler)
+ * @context: The caller's context (to be passed to the action functions)
+ * @data: The encoded data
+ * @datasize: The size of the encoded data
+ *
+ * Decode BER/DER/CER encoded ASN.1 data according to a bytecode pattern
+ * produced by asn1_compiler.  Action functions are called on marked tags to
+ * allow the caller to retrieve significant data.
+ *
+ * LIMITATIONS:
+ *
+ * To keep down the amount of stack used by this function, the following limits
+ * have been imposed:
+ *
+ *  (1) This won't handle datalen > 65535 without increasing the size of the
+ *	cons stack elements and length_too_long checking.
+ *
+ *  (2) The stack of constructed types is 10 deep.  If the depth of non-leaf
+ *	constructed types exceeds this, the decode will fail.
+ *
+ *  (3) The SET type (not the SET OF type) isn't really supported as tracking
+ *	what members of the set have been seen is a pain.
+ */
+int asn1_ber_decoder(const struct asn1_decoder *decoder,
+		     void *context,
+		     const unsigned char *data,
+		     size_t datalen)
+{
+	const unsigned char *machine = decoder->machine;
+	const asn1_action_t *actions = decoder->actions;
+	size_t machlen = decoder->machlen;
+	enum asn1_opcode op;
+	unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
+	const char *errmsg;
+	size_t pc = 0, dp = 0, tdp = 0, len = 0;
+	int ret;
+
+	unsigned char flags = 0;
+#define FLAG_INDEFINITE_LENGTH	0x01
+#define FLAG_MATCHED		0x02
+#define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
+				      * - ie. whether or not we are going to parse
+				      *   a compound type.
+				      */
+
+#define NR_CONS_STACK 10
+	unsigned short cons_dp_stack[NR_CONS_STACK];
+	unsigned short cons_datalen_stack[NR_CONS_STACK];
+	unsigned char cons_hdrlen_stack[NR_CONS_STACK];
+#define NR_JUMP_STACK 10
+	unsigned char jump_stack[NR_JUMP_STACK];
+
+	if (datalen > 65535)
+		return -EMSGSIZE;
+
+next_op:
+	pr_debug("next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n",
+		 pc, machlen, dp, datalen, csp, jsp);
+	if (unlikely(pc >= machlen))
+		goto machine_overrun_error;
+	op = machine[pc];
+	if (unlikely(pc + asn1_op_lengths[op] > machlen))
+		goto machine_overrun_error;
+
+	/* If this command is meant to match a tag, then do that before
+	 * evaluating the command.
+	 */
+	if (op <= ASN1_OP__MATCHES_TAG) {
+		unsigned char tmp;
+
+		/* Skip conditional matches if possible */
+		if ((op & ASN1_OP_MATCH__COND &&
+		     flags & FLAG_MATCHED) ||
+		    dp == datalen) {
+			pc += asn1_op_lengths[op];
+			goto next_op;
+		}
+
+		flags = 0;
+		hdr = 2;
+
+		/* Extract a tag from the data */
+		if (unlikely(dp >= datalen - 1))
+			goto data_overrun_error;
+		tag = data[dp++];
+		if (unlikely((tag & 0x1f) == 0x1f))
+			goto long_tag_not_supported;
+
+		if (op & ASN1_OP_MATCH__ANY) {
+			pr_debug("- any %02x\n", tag);
+		} else {
+			/* Extract the tag from the machine
+			 * - Either CONS or PRIM are permitted in the data if
+			 *   CONS is not set in the op stream, otherwise CONS
+			 *   is mandatory.
+			 */
+			optag = machine[pc + 1];
+			flags |= optag & FLAG_CONS;
+
+			/* Determine whether the tag matched */
+			tmp = optag ^ tag;
+			tmp &= ~(optag & ASN1_CONS_BIT);
+			pr_debug("- match? %02x %02x %02x\n", tag, optag, tmp);
+			if (tmp != 0) {
+				/* All odd-numbered tags are MATCH_OR_SKIP. */
+				if (op & ASN1_OP_MATCH__SKIP) {
+					pc += asn1_op_lengths[op];
+					dp--;
+					goto next_op;
+				}
+				goto tag_mismatch;
+			}
+		}
+		flags |= FLAG_MATCHED;
+
+		len = data[dp++];
+		if (len > 0x7f) {
+			if (unlikely(len == 0x80)) {
+				/* Indefinite length */
+				if (unlikely(!(tag & ASN1_CONS_BIT)))
+					goto indefinite_len_primitive;
+				flags |= FLAG_INDEFINITE_LENGTH;
+				if (unlikely(2 > datalen - dp))
+					goto data_overrun_error;
+			} else {
+				int n = len - 0x80;
+				if (unlikely(n > 2))
+					goto length_too_long;
+				if (unlikely(dp >= datalen - n))
+					goto data_overrun_error;
+				hdr += n;
+				for (len = 0; n > 0; n--) {
+					len <<= 8;
+					len |= data[dp++];
+				}
+				if (unlikely(len > datalen - dp))
+					goto data_overrun_error;
+			}
+		}
+
+		if (flags & FLAG_CONS) {
+			/* For expected compound forms, we stack the positions
+			 * of the start and end of the data.
+			 */
+			if (unlikely(csp >= NR_CONS_STACK))
+				goto cons_stack_overflow;
+			cons_dp_stack[csp] = dp;
+			cons_hdrlen_stack[csp] = hdr;
+			if (!(flags & FLAG_INDEFINITE_LENGTH)) {
+				cons_datalen_stack[csp] = datalen;
+				datalen = dp + len;
+			} else {
+				cons_datalen_stack[csp] = 0;
+			}
+			csp++;
+		}
+
+		pr_debug("- TAG: %02x %zu%s\n",
+			 tag, len, flags & FLAG_CONS ? " CONS" : "");
+		tdp = dp;
+	}
+
+	/* Decide how to handle the operation */
+	switch (op) {
+	case ASN1_OP_MATCH_ANY_ACT:
+	case ASN1_OP_COND_MATCH_ANY_ACT:
+		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
+		if (ret < 0)
+			return ret;
+		goto skip_data;
+
+	case ASN1_OP_MATCH_ACT:
+	case ASN1_OP_MATCH_ACT_OR_SKIP:
+	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
+		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
+		if (ret < 0)
+			return ret;
+		goto skip_data;
+
+	case ASN1_OP_MATCH:
+	case ASN1_OP_MATCH_OR_SKIP:
+	case ASN1_OP_MATCH_ANY:
+	case ASN1_OP_COND_MATCH_OR_SKIP:
+	case ASN1_OP_COND_MATCH_ANY:
+	skip_data:
+		if (!(flags & FLAG_CONS)) {
+			if (flags & FLAG_INDEFINITE_LENGTH) {
+				len = asn1_find_indefinite_length(
+					data + dp, datalen - dp, &errmsg, &dp);
+				if (len < 0)
+					goto error;
+			}
+			pr_debug("- LEAF: %zu\n", len);
+			dp += len;
+		}
+		pc += asn1_op_lengths[op];
+		goto next_op;
+
+	case ASN1_OP_MATCH_JUMP:
+	case ASN1_OP_MATCH_JUMP_OR_SKIP:
+	case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
+		pr_debug("- MATCH_JUMP\n");
+		if (unlikely(jsp == NR_JUMP_STACK))
+			goto jump_stack_overflow;
+		jump_stack[jsp++] = pc + asn1_op_lengths[op];
+		pc = machine[pc + 2];
+		goto next_op;
+
+	case ASN1_OP_COND_FAIL:
+		if (unlikely(!(flags & FLAG_MATCHED)))
+			goto tag_mismatch;
+		pc += asn1_op_lengths[op];
+		goto next_op;
+
+	case ASN1_OP_COMPLETE:
+		if (unlikely(jsp != 0 || csp != 0)) {
+			pr_err("ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n",
+			       jsp, csp);
+			return -EBADMSG;
+		}
+		return 0;
+
+	case ASN1_OP_END_SET:
+	case ASN1_OP_END_SET_ACT:
+		if (unlikely(!(flags & FLAG_MATCHED)))
+			goto tag_mismatch;
+	case ASN1_OP_END_SEQ:
+	case ASN1_OP_END_SET_OF:
+	case ASN1_OP_END_SEQ_OF:
+	case ASN1_OP_END_SEQ_ACT:
+	case ASN1_OP_END_SET_OF_ACT:
+	case ASN1_OP_END_SEQ_OF_ACT:
+		if (unlikely(csp <= 0))
+			goto cons_stack_underflow;
+		csp--;
+		tdp = cons_dp_stack[csp];
+		hdr = cons_hdrlen_stack[csp];
+		len = datalen;
+		datalen = cons_datalen_stack[csp];
+		pr_debug("- end cons t=%zu dp=%zu l=%zu/%zu\n",
+			 tdp, dp, len, datalen);
+		if (datalen == 0) {
+			/* Indefinite length - check for the EOC. */
+			datalen = len;
+			if (unlikely(datalen - dp < 2))
+				goto data_overrun_error;
+			if (data[dp++] != 0) {
+				if (op & ASN1_OP_END__OF) {
+					dp--;
+					csp++;
+					pc = machine[pc + 1];
+					pr_debug("- continue\n");
+					goto next_op;
+				}
+				goto missing_eoc;
+			}
+			if (data[dp++] != 0)
+				goto invalid_eoc;
+			len = dp - tdp - 2;
+		} else {
+			if (dp < len && (op & ASN1_OP_END__OF)) {
+				datalen = len;
+				csp++;
+				pc = machine[pc + 1];
+				pr_debug("- continue\n");
+				goto next_op;
+			}
+			if (dp != len)
+				goto cons_length_error;
+			len -= tdp;
+			pr_debug("- cons len l=%zu d=%zu\n", len, dp - tdp);
+		}
+
+		if (op & ASN1_OP_END__ACT) {
+			unsigned char act;
+			if (op & ASN1_OP_END__OF)
+				act = machine[pc + 2];
+			else
+				act = machine[pc + 1];
+			ret = actions[act](context, hdr, 0, data + tdp, len);
+		}
+		pc += asn1_op_lengths[op];
+		goto next_op;
+
+	case ASN1_OP_ACT:
+		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
+		pc += asn1_op_lengths[op];
+		goto next_op;
+
+	case ASN1_OP_RETURN:
+		if (unlikely(jsp <= 0))
+			goto jump_stack_underflow;
+		pc = jump_stack[--jsp];
+		goto next_op;
+
+	default:
+		break;
+	}
+
+	/* Shouldn't reach here */
+	pr_err("ASN.1 decoder error: Found reserved opcode (%u)\n", op);
+	return -EBADMSG;
+
+data_overrun_error:
+	errmsg = "Data overrun error";
+	goto error;
+machine_overrun_error:
+	errmsg = "Machine overrun error";
+	goto error;
+jump_stack_underflow:
+	errmsg = "Jump stack underflow";
+	goto error;
+jump_stack_overflow:
+	errmsg = "Jump stack overflow";
+	goto error;
+cons_stack_underflow:
+	errmsg = "Cons stack underflow";
+	goto error;
+cons_stack_overflow:
+	errmsg = "Cons stack overflow";
+	goto error;
+cons_length_error:
+	errmsg = "Cons length error";
+	goto error;
+missing_eoc:
+	errmsg = "Missing EOC in indefinite len cons";
+	goto error;
+invalid_eoc:
+	errmsg = "Invalid length EOC";
+	goto error;
+length_too_long:
+	errmsg = "Unsupported length";
+	goto error;
+indefinite_len_primitive:
+	errmsg = "Indefinite len primitive not permitted";
+	goto error;
+tag_mismatch:
+	errmsg = "Unexpected tag";
+	goto error;
+long_tag_not_supported:
+	errmsg = "Long tag not supported";
+error:
+	pr_debug("\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n",
+		 errmsg, pc, dp, optag, tag, len);
+	return -EBADMSG;
+}
+EXPORT_SYMBOL_GPL(asn1_ber_decoder);
