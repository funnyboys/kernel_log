commit 89b74cac7834734d6b2733204c639917d3826083
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Tue Mar 3 20:24:50 2020 +0900

    tools/bootconfig: Show line and column in parse error
    
    Show line and column when we got a parse error in bootconfig tool.
    Current lib/bootconfig shows the parse error with byte offset, but
    that is not human readable.
    This makes xbc_init() not showing error message itself but able to
    pass the error message and position to caller, so that the caller
    can decode it and show the error message with line number and columns.
    
    With this patch, bootconfig tool shows an error with line:column as
    below.
    
      $ cat samples/bad-dotword.bconf
      # do not start keyword with .
      key {
        .word = 1
      }
      $ ./bootconfig -a samples/bad-dotword.bconf initrd
      Parse Error: Invalid keyword at 3:3
    
    Link: http://lkml.kernel.org/r/158323469002.10560.4023923847704522760.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index ec3ce7fd299f..912ef4921398 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -29,12 +29,14 @@ static int xbc_node_num __initdata;
 static char *xbc_data __initdata;
 static size_t xbc_data_size __initdata;
 static struct xbc_node *last_parent __initdata;
+static const char *xbc_err_msg __initdata;
+static int xbc_err_pos __initdata;
 
 static int __init xbc_parse_error(const char *msg, const char *p)
 {
-	int pos = p - xbc_data;
+	xbc_err_msg = msg;
+	xbc_err_pos = (int)(p - xbc_data);
 
-	pr_err("Parse error at pos %d: %s\n", pos, msg);
 	return -EINVAL;
 }
 
@@ -738,33 +740,44 @@ void __init xbc_destroy_all(void)
 /**
  * xbc_init() - Parse given XBC file and build XBC internal tree
  * @buf: boot config text
+ * @emsg: A pointer of const char * to store the error message
+ * @epos: A pointer of int to store the error position
  *
  * This parses the boot config text in @buf. @buf must be a
  * null terminated string and smaller than XBC_DATA_MAX.
  * Return the number of stored nodes (>0) if succeeded, or -errno
  * if there is any error.
+ * In error cases, @emsg will be updated with an error message and
+ * @epos will be updated with the error position which is the byte offset
+ * of @buf. If the error is not a parser error, @epos will be -1.
  */
-int __init xbc_init(char *buf)
+int __init xbc_init(char *buf, const char **emsg, int *epos)
 {
 	char *p, *q;
 	int ret, c;
 
+	if (epos)
+		*epos = -1;
+
 	if (xbc_data) {
-		pr_err("Error: bootconfig is already initialized.\n");
+		if (emsg)
+			*emsg = "Bootconfig is already initialized";
 		return -EBUSY;
 	}
 
 	ret = strlen(buf);
 	if (ret > XBC_DATA_MAX - 1 || ret == 0) {
-		pr_err("Error: Config data is %s.\n",
-			ret ? "too big" : "empty");
+		if (emsg)
+			*emsg = ret ? "Config data is too big" :
+				"Config data is empty";
 		return -ERANGE;
 	}
 
 	xbc_nodes = memblock_alloc(sizeof(struct xbc_node) * XBC_NODE_MAX,
 				   SMP_CACHE_BYTES);
 	if (!xbc_nodes) {
-		pr_err("Failed to allocate memory for bootconfig nodes.\n");
+		if (emsg)
+			*emsg = "Failed to allocate bootconfig nodes";
 		return -ENOMEM;
 	}
 	memset(xbc_nodes, 0, sizeof(struct xbc_node) * XBC_NODE_MAX);
@@ -814,9 +827,13 @@ int __init xbc_init(char *buf)
 	if (!ret)
 		ret = xbc_verify_tree();
 
-	if (ret < 0)
+	if (ret < 0) {
+		if (epos)
+			*epos = xbc_err_pos;
+		if (emsg)
+			*emsg = xbc_err_msg;
 		xbc_destroy_all();
-	else
+	} else
 		ret = xbc_node_num;
 
 	return ret;

commit 5f811c57c99205e048926293bb812c750a6ea562
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Fri Feb 21 17:13:52 2020 +0900

    bootconfig: Add append value operator support
    
    Add append value operator "+=" support to bootconfig syntax.
    With this operator, user can add new value to the key as
    an entry of array instead of overwriting.
    For example,
    
      foo = bar
      ...
      foo += baz
    
    Then the key "foo" has "bar" and "baz" values as an array.
    
    Link: http://lkml.kernel.org/r/158227283195.12842.8310503105963275584.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index 2ef304db31f2..ec3ce7fd299f 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -578,7 +578,7 @@ static int __init __xbc_parse_keys(char *k)
 	return __xbc_add_key(k);
 }
 
-static int __init xbc_parse_kv(char **k, char *v)
+static int __init xbc_parse_kv(char **k, char *v, int op)
 {
 	struct xbc_node *prev_parent = last_parent;
 	struct xbc_node *child;
@@ -593,7 +593,7 @@ static int __init xbc_parse_kv(char **k, char *v)
 	if (child) {
 		if (xbc_node_is_key(child))
 			return xbc_parse_error("Value is mixed with subkey", v);
-		else
+		else if (op == '=')
 			return xbc_parse_error("Value is redefined", v);
 	}
 
@@ -774,7 +774,7 @@ int __init xbc_init(char *buf)
 
 	p = buf;
 	do {
-		q = strpbrk(p, "{}=;\n#");
+		q = strpbrk(p, "{}=+;\n#");
 		if (!q) {
 			p = skip_spaces(p);
 			if (*p != '\0')
@@ -785,8 +785,15 @@ int __init xbc_init(char *buf)
 		c = *q;
 		*q++ = '\0';
 		switch (c) {
+		case '+':
+			if (*q++ != '=') {
+				ret = xbc_parse_error("Wrong '+' operator",
+							q - 2);
+				break;
+			}
+			/* Fall through */
 		case '=':
-			ret = xbc_parse_kv(&p, q);
+			ret = xbc_parse_kv(&p, q, c);
 			break;
 		case '{':
 			ret = xbc_open_brace(&p, q);

commit 4e4694d8729f7cd6381f6691e8f83e378fce3160
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Fri Feb 21 17:13:42 2020 +0900

    bootconfig: Prohibit re-defining value on same key
    
    Currently, bootconfig adds a new value on the existing key to the tail of an
    array. But this looks a bit confusing because an admin can easily rewrite
    the original value in the same config file.
    
    This rejects the following value re-definition.
    
      key = value1
      ...
      key = value2
    
    You should rewrite value1 to value2 in this case.
    
    Link: http://lkml.kernel.org/r/158227282199.12842.10110929876059658601.stgit@devnote2
    
    Suggested-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    [ Fixed spelling of arraies to arrays ]
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index 54ac623ca781..2ef304db31f2 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -581,7 +581,7 @@ static int __init __xbc_parse_keys(char *k)
 static int __init xbc_parse_kv(char **k, char *v)
 {
 	struct xbc_node *prev_parent = last_parent;
-	struct xbc_node *node, *child;
+	struct xbc_node *child;
 	char *next;
 	int c, ret;
 
@@ -590,15 +590,18 @@ static int __init xbc_parse_kv(char **k, char *v)
 		return ret;
 
 	child = xbc_node_get_child(last_parent);
-	if (child && xbc_node_is_key(child))
-		return xbc_parse_error("Value is mixed with subkey", v);
+	if (child) {
+		if (xbc_node_is_key(child))
+			return xbc_parse_error("Value is mixed with subkey", v);
+		else
+			return xbc_parse_error("Value is redefined", v);
+	}
 
 	c = __xbc_parse_value(&v, &next);
 	if (c < 0)
 		return c;
 
-	node = xbc_add_sibling(v, XBC_VALUE);
-	if (!node)
+	if (!xbc_add_sibling(v, XBC_VALUE))
 		return -ENOMEM;
 
 	if (c == ',') {	/* Array */

commit a24d286f36104ed45108a5a36f3868938434772f
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu Feb 20 21:19:12 2020 +0900

    bootconfig: Reject subkey and value on same parent key
    
    Reject if a value node is mixed with subkey node on same
    parent key node.
    
    A value node can not co-exist with subkey node under some key
    node, e.g.
    
    key = value
    key.subkey = another-value
    
    This is not be allowed because bootconfig API is not designed
    to handle such case.
    
    Link: http://lkml.kernel.org/r/158220115232.26565.7792340045009731803.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index 3ea601a2eba5..54ac623ca781 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -533,7 +533,7 @@ struct xbc_node *find_match_node(struct xbc_node *node, char *k)
 
 static int __init __xbc_add_key(char *k)
 {
-	struct xbc_node *node;
+	struct xbc_node *node, *child;
 
 	if (!xbc_valid_keyword(k))
 		return xbc_parse_error("Invalid keyword", k);
@@ -543,8 +543,12 @@ static int __init __xbc_add_key(char *k)
 
 	if (!last_parent)	/* the first level */
 		node = find_match_node(xbc_nodes, k);
-	else
-		node = find_match_node(xbc_node_get_child(last_parent), k);
+	else {
+		child = xbc_node_get_child(last_parent);
+		if (child && xbc_node_is_value(child))
+			return xbc_parse_error("Subkey is mixed with value", k);
+		node = find_match_node(child, k);
+	}
 
 	if (node)
 		last_parent = node;
@@ -577,7 +581,7 @@ static int __init __xbc_parse_keys(char *k)
 static int __init xbc_parse_kv(char **k, char *v)
 {
 	struct xbc_node *prev_parent = last_parent;
-	struct xbc_node *node;
+	struct xbc_node *node, *child;
 	char *next;
 	int c, ret;
 
@@ -585,6 +589,10 @@ static int __init xbc_parse_kv(char **k, char *v)
 	if (ret)
 		return ret;
 
+	child = xbc_node_get_child(last_parent);
+	if (child && xbc_node_is_key(child))
+		return xbc_parse_error("Value is mixed with subkey", v);
+
 	c = __xbc_parse_value(&v, &next);
 	if (c < 0)
 		return c;

commit a91e4f12ffc42fa019b5a66eaa8702f5e0f08a6a
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Fri Feb 7 23:28:17 2020 +0900

    bootconfig: Allocate xbc_nodes array dynamically
    
    To reduce the large static array from kernel data, allocate
    xbc_nodes array dynamically only if the kernel loads a
    bootconfig.
    
    Note that this also add dummy memblock.h for user-spacae
    bootconfig tool.
    
    Link: http://lkml.kernel.org/r/158108569699.3187.6512834527603883707.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index afb2e767e6fe..3ea601a2eba5 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -6,12 +6,13 @@
 
 #define pr_fmt(fmt)    "bootconfig: " fmt
 
+#include <linux/bootconfig.h>
 #include <linux/bug.h>
 #include <linux/ctype.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
+#include <linux/memblock.h>
 #include <linux/printk.h>
-#include <linux/bootconfig.h>
 #include <linux/string.h>
 
 /*
@@ -23,7 +24,7 @@
  * node (for array).
  */
 
-static struct xbc_node xbc_nodes[XBC_NODE_MAX] __initdata;
+static struct xbc_node *xbc_nodes __initdata;
 static int xbc_node_num __initdata;
 static char *xbc_data __initdata;
 static size_t xbc_data_size __initdata;
@@ -719,7 +720,8 @@ void __init xbc_destroy_all(void)
 	xbc_data = NULL;
 	xbc_data_size = 0;
 	xbc_node_num = 0;
-	memset(xbc_nodes, 0, sizeof(xbc_nodes));
+	memblock_free(__pa(xbc_nodes), sizeof(struct xbc_node) * XBC_NODE_MAX);
+	xbc_nodes = NULL;
 }
 
 /**
@@ -748,6 +750,13 @@ int __init xbc_init(char *buf)
 		return -ERANGE;
 	}
 
+	xbc_nodes = memblock_alloc(sizeof(struct xbc_node) * XBC_NODE_MAX,
+				   SMP_CACHE_BYTES);
+	if (!xbc_nodes) {
+		pr_err("Failed to allocate memory for bootconfig nodes.\n");
+		return -ENOMEM;
+	}
+	memset(xbc_nodes, 0, sizeof(struct xbc_node) * XBC_NODE_MAX);
 	xbc_data = buf;
 	xbc_data_size = ret + 1;
 	last_parent = NULL;

commit 0f0d0a77ccbdc6bfe51c0d184f92d99ebcc2e809
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Wed Feb 5 22:50:13 2020 +0900

    tools/bootconfig: Show the number of bootconfig nodes
    
    Show the number of bootconfig nodes when applying new bootconfig to
    initrd.
    
    Since there are limitations of bootconfig not only in its filesize,
    but also the number of nodes, the number should be shown when applying
    so that user can get the feeling of scale of current bootconfig.
    
    Link: http://lkml.kernel.org/r/158091061337.27924.10886706631693823982.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index a98ae136529c..afb2e767e6fe 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -728,7 +728,8 @@ void __init xbc_destroy_all(void)
  *
  * This parses the boot config text in @buf. @buf must be a
  * null terminated string and smaller than XBC_DATA_MAX.
- * Return 0 if succeeded, or -errno if there is any error.
+ * Return the number of stored nodes (>0) if succeeded, or -errno
+ * if there is any error.
  */
 int __init xbc_init(char *buf)
 {
@@ -788,6 +789,8 @@ int __init xbc_init(char *buf)
 
 	if (ret < 0)
 		xbc_destroy_all();
+	else
+		ret = xbc_node_num;
 
 	return ret;
 }

commit 597c0e3b4540972580ab36bcc8aa34394bd88cfb
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Wed Feb 5 22:50:04 2020 +0900

    bootconfig: Add more parse error messages
    
    Add more error messages for following cases.
     - Exceeding max number of nodes
     - Config tree data is empty (e.g. comment only)
     - Config data is empty or exceeding max size
     - bootconfig is already initialized
    
    Link: http://lkml.kernel.org/r/158091060401.27924.9024818742827122764.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index 055014e233a5..a98ae136529c 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -373,7 +373,8 @@ static struct xbc_node * __init xbc_add_sibling(char *data, u32 flag)
 				sib->next = xbc_node_index(node);
 			}
 		}
-	}
+	} else
+		xbc_parse_error("Too many nodes", data);
 
 	return node;
 }
@@ -657,8 +658,10 @@ static int __init xbc_verify_tree(void)
 	struct xbc_node *n, *m;
 
 	/* Empty tree */
-	if (xbc_node_num == 0)
+	if (xbc_node_num == 0) {
+		xbc_parse_error("Empty config", xbc_data);
 		return -ENOENT;
+	}
 
 	for (i = 0; i < xbc_node_num; i++) {
 		if (xbc_nodes[i].next > xbc_node_num) {
@@ -732,12 +735,17 @@ int __init xbc_init(char *buf)
 	char *p, *q;
 	int ret, c;
 
-	if (xbc_data)
+	if (xbc_data) {
+		pr_err("Error: bootconfig is already initialized.\n");
 		return -EBUSY;
+	}
 
 	ret = strlen(buf);
-	if (ret > XBC_DATA_MAX - 1 || ret == 0)
+	if (ret > XBC_DATA_MAX - 1 || ret == 0) {
+		pr_err("Error: Config data is %s.\n",
+			ret ? "too big" : "empty");
 		return -ERANGE;
+	}
 
 	xbc_data = buf;
 	xbc_data_size = ret + 1;

commit 76db5a27a827c2c89e5120a3d486472da847863b
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Sat Jan 11 01:03:32 2020 +0900

    bootconfig: Add Extra Boot Config support
    
    Extra Boot Config (XBC) allows admin to pass a tree-structured
    boot configuration file when boot up the kernel. This extends
    the kernel command line in an efficient way.
    
    Boot config will contain some key-value commands, e.g.
    
    key.word = value1
    another.key.word = value2
    
    It can fold same keys with braces, also you can write array
    data. For example,
    
    key {
       word1 {
          setting1 = data
          setting2
       }
       word2.array = "val1", "val2"
    }
    
    User can access these key-value pair and tree structure via
    SKC APIs.
    
    Link: http://lkml.kernel.org/r/157867221257.17873.1775090991929862549.stgit@devnote2
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/bootconfig.c b/lib/bootconfig.c
new file mode 100644
index 000000000000..055014e233a5
--- /dev/null
+++ b/lib/bootconfig.c
@@ -0,0 +1,803 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Extra Boot Config
+ * Masami Hiramatsu <mhiramat@kernel.org>
+ */
+
+#define pr_fmt(fmt)    "bootconfig: " fmt
+
+#include <linux/bug.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/bootconfig.h>
+#include <linux/string.h>
+
+/*
+ * Extra Boot Config (XBC) is given as tree-structured ascii text of
+ * key-value pairs on memory.
+ * xbc_parse() parses the text to build a simple tree. Each tree node is
+ * simply a key word or a value. A key node may have a next key node or/and
+ * a child node (both key and value). A value node may have a next value
+ * node (for array).
+ */
+
+static struct xbc_node xbc_nodes[XBC_NODE_MAX] __initdata;
+static int xbc_node_num __initdata;
+static char *xbc_data __initdata;
+static size_t xbc_data_size __initdata;
+static struct xbc_node *last_parent __initdata;
+
+static int __init xbc_parse_error(const char *msg, const char *p)
+{
+	int pos = p - xbc_data;
+
+	pr_err("Parse error at pos %d: %s\n", pos, msg);
+	return -EINVAL;
+}
+
+/**
+ * xbc_root_node() - Get the root node of extended boot config
+ *
+ * Return the address of root node of extended boot config. If the
+ * extended boot config is not initiized, return NULL.
+ */
+struct xbc_node * __init xbc_root_node(void)
+{
+	if (unlikely(!xbc_data))
+		return NULL;
+
+	return xbc_nodes;
+}
+
+/**
+ * xbc_node_index() - Get the index of XBC node
+ * @node: A target node of getting index.
+ *
+ * Return the index number of @node in XBC node list.
+ */
+int __init xbc_node_index(struct xbc_node *node)
+{
+	return node - &xbc_nodes[0];
+}
+
+/**
+ * xbc_node_get_parent() - Get the parent XBC node
+ * @node: An XBC node.
+ *
+ * Return the parent node of @node. If the node is top node of the tree,
+ * return NULL.
+ */
+struct xbc_node * __init xbc_node_get_parent(struct xbc_node *node)
+{
+	return node->parent == XBC_NODE_MAX ? NULL : &xbc_nodes[node->parent];
+}
+
+/**
+ * xbc_node_get_child() - Get the child XBC node
+ * @node: An XBC node.
+ *
+ * Return the first child node of @node. If the node has no child, return
+ * NULL.
+ */
+struct xbc_node * __init xbc_node_get_child(struct xbc_node *node)
+{
+	return node->child ? &xbc_nodes[node->child] : NULL;
+}
+
+/**
+ * xbc_node_get_next() - Get the next sibling XBC node
+ * @node: An XBC node.
+ *
+ * Return the NEXT sibling node of @node. If the node has no next sibling,
+ * return NULL. Note that even if this returns NULL, it doesn't mean @node
+ * has no siblings. (You also has to check whether the parent's child node
+ * is @node or not.)
+ */
+struct xbc_node * __init xbc_node_get_next(struct xbc_node *node)
+{
+	return node->next ? &xbc_nodes[node->next] : NULL;
+}
+
+/**
+ * xbc_node_get_data() - Get the data of XBC node
+ * @node: An XBC node.
+ *
+ * Return the data (which is always a null terminated string) of @node.
+ * If the node has invalid data, warn and return NULL.
+ */
+const char * __init xbc_node_get_data(struct xbc_node *node)
+{
+	int offset = node->data & ~XBC_VALUE;
+
+	if (WARN_ON(offset >= xbc_data_size))
+		return NULL;
+
+	return xbc_data + offset;
+}
+
+static bool __init
+xbc_node_match_prefix(struct xbc_node *node, const char **prefix)
+{
+	const char *p = xbc_node_get_data(node);
+	int len = strlen(p);
+
+	if (strncmp(*prefix, p, len))
+		return false;
+
+	p = *prefix + len;
+	if (*p == '.')
+		p++;
+	else if (*p != '\0')
+		return false;
+	*prefix = p;
+
+	return true;
+}
+
+/**
+ * xbc_node_find_child() - Find a child node which matches given key
+ * @parent: An XBC node.
+ * @key: A key string.
+ *
+ * Search a node under @parent which matches @key. The @key can contain
+ * several words jointed with '.'. If @parent is NULL, this searches the
+ * node from whole tree. Return NULL if no node is matched.
+ */
+struct xbc_node * __init
+xbc_node_find_child(struct xbc_node *parent, const char *key)
+{
+	struct xbc_node *node;
+
+	if (parent)
+		node = xbc_node_get_child(parent);
+	else
+		node = xbc_root_node();
+
+	while (node && xbc_node_is_key(node)) {
+		if (!xbc_node_match_prefix(node, &key))
+			node = xbc_node_get_next(node);
+		else if (*key != '\0')
+			node = xbc_node_get_child(node);
+		else
+			break;
+	}
+
+	return node;
+}
+
+/**
+ * xbc_node_find_value() - Find a value node which matches given key
+ * @parent: An XBC node.
+ * @key: A key string.
+ * @vnode: A container pointer of found XBC node.
+ *
+ * Search a value node under @parent whose (parent) key node matches @key,
+ * store it in *@vnode, and returns the value string.
+ * The @key can contain several words jointed with '.'. If @parent is NULL,
+ * this searches the node from whole tree. Return the value string if a
+ * matched key found, return NULL if no node is matched.
+ * Note that this returns 0-length string and stores NULL in *@vnode if the
+ * key has no value. And also it will return the value of the first entry if
+ * the value is an array.
+ */
+const char * __init
+xbc_node_find_value(struct xbc_node *parent, const char *key,
+		    struct xbc_node **vnode)
+{
+	struct xbc_node *node = xbc_node_find_child(parent, key);
+
+	if (!node || !xbc_node_is_key(node))
+		return NULL;
+
+	node = xbc_node_get_child(node);
+	if (node && !xbc_node_is_value(node))
+		return NULL;
+
+	if (vnode)
+		*vnode = node;
+
+	return node ? xbc_node_get_data(node) : "";
+}
+
+/**
+ * xbc_node_compose_key_after() - Compose partial key string of the XBC node
+ * @root: Root XBC node
+ * @node: Target XBC node.
+ * @buf: A buffer to store the key.
+ * @size: The size of the @buf.
+ *
+ * Compose the partial key of the @node into @buf, which is starting right
+ * after @root (@root is not included.) If @root is NULL, this returns full
+ * key words of @node.
+ * Returns the total length of the key stored in @buf. Returns -EINVAL
+ * if @node is NULL or @root is not the ancestor of @node or @root is @node,
+ * or returns -ERANGE if the key depth is deeper than max depth.
+ * This is expected to be used with xbc_find_node() to list up all (child)
+ * keys under given key.
+ */
+int __init xbc_node_compose_key_after(struct xbc_node *root,
+				      struct xbc_node *node,
+				      char *buf, size_t size)
+{
+	u16 keys[XBC_DEPTH_MAX];
+	int depth = 0, ret = 0, total = 0;
+
+	if (!node || node == root)
+		return -EINVAL;
+
+	if (xbc_node_is_value(node))
+		node = xbc_node_get_parent(node);
+
+	while (node && node != root) {
+		keys[depth++] = xbc_node_index(node);
+		if (depth == XBC_DEPTH_MAX)
+			return -ERANGE;
+		node = xbc_node_get_parent(node);
+	}
+	if (!node && root)
+		return -EINVAL;
+
+	while (--depth >= 0) {
+		node = xbc_nodes + keys[depth];
+		ret = snprintf(buf, size, "%s%s", xbc_node_get_data(node),
+			       depth ? "." : "");
+		if (ret < 0)
+			return ret;
+		if (ret > size) {
+			size = 0;
+		} else {
+			size -= ret;
+			buf += ret;
+		}
+		total += ret;
+	}
+
+	return total;
+}
+
+/**
+ * xbc_node_find_next_leaf() - Find the next leaf node under given node
+ * @root: An XBC root node
+ * @node: An XBC node which starts from.
+ *
+ * Search the next leaf node (which means the terminal key node) of @node
+ * under @root node (including @root node itself).
+ * Return the next node or NULL if next leaf node is not found.
+ */
+struct xbc_node * __init xbc_node_find_next_leaf(struct xbc_node *root,
+						 struct xbc_node *node)
+{
+	if (unlikely(!xbc_data))
+		return NULL;
+
+	if (!node) {	/* First try */
+		node = root;
+		if (!node)
+			node = xbc_nodes;
+	} else {
+		if (node == root)	/* @root was a leaf, no child node. */
+			return NULL;
+
+		while (!node->next) {
+			node = xbc_node_get_parent(node);
+			if (node == root)
+				return NULL;
+			/* User passed a node which is not uder parent */
+			if (WARN_ON(!node))
+				return NULL;
+		}
+		node = xbc_node_get_next(node);
+	}
+
+	while (node && !xbc_node_is_leaf(node))
+		node = xbc_node_get_child(node);
+
+	return node;
+}
+
+/**
+ * xbc_node_find_next_key_value() - Find the next key-value pair nodes
+ * @root: An XBC root node
+ * @leaf: A container pointer of XBC node which starts from.
+ *
+ * Search the next leaf node (which means the terminal key node) of *@leaf
+ * under @root node. Returns the value and update *@leaf if next leaf node
+ * is found, or NULL if no next leaf node is found.
+ * Note that this returns 0-length string if the key has no value, or
+ * the value of the first entry if the value is an array.
+ */
+const char * __init xbc_node_find_next_key_value(struct xbc_node *root,
+						 struct xbc_node **leaf)
+{
+	/* tip must be passed */
+	if (WARN_ON(!leaf))
+		return NULL;
+
+	*leaf = xbc_node_find_next_leaf(root, *leaf);
+	if (!*leaf)
+		return NULL;
+	if ((*leaf)->child)
+		return xbc_node_get_data(xbc_node_get_child(*leaf));
+	else
+		return "";	/* No value key */
+}
+
+/* XBC parse and tree build */
+
+static struct xbc_node * __init xbc_add_node(char *data, u32 flag)
+{
+	struct xbc_node *node;
+	unsigned long offset;
+
+	if (xbc_node_num == XBC_NODE_MAX)
+		return NULL;
+
+	node = &xbc_nodes[xbc_node_num++];
+	offset = data - xbc_data;
+	node->data = (u16)offset;
+	if (WARN_ON(offset >= XBC_DATA_MAX))
+		return NULL;
+	node->data |= flag;
+	node->child = 0;
+	node->next = 0;
+
+	return node;
+}
+
+static inline __init struct xbc_node *xbc_last_sibling(struct xbc_node *node)
+{
+	while (node->next)
+		node = xbc_node_get_next(node);
+
+	return node;
+}
+
+static struct xbc_node * __init xbc_add_sibling(char *data, u32 flag)
+{
+	struct xbc_node *sib, *node = xbc_add_node(data, flag);
+
+	if (node) {
+		if (!last_parent) {
+			node->parent = XBC_NODE_MAX;
+			sib = xbc_last_sibling(xbc_nodes);
+			sib->next = xbc_node_index(node);
+		} else {
+			node->parent = xbc_node_index(last_parent);
+			if (!last_parent->child) {
+				last_parent->child = xbc_node_index(node);
+			} else {
+				sib = xbc_node_get_child(last_parent);
+				sib = xbc_last_sibling(sib);
+				sib->next = xbc_node_index(node);
+			}
+		}
+	}
+
+	return node;
+}
+
+static inline __init struct xbc_node *xbc_add_child(char *data, u32 flag)
+{
+	struct xbc_node *node = xbc_add_sibling(data, flag);
+
+	if (node)
+		last_parent = node;
+
+	return node;
+}
+
+static inline __init bool xbc_valid_keyword(char *key)
+{
+	if (key[0] == '\0')
+		return false;
+
+	while (isalnum(*key) || *key == '-' || *key == '_')
+		key++;
+
+	return *key == '\0';
+}
+
+static char *skip_comment(char *p)
+{
+	char *ret;
+
+	ret = strchr(p, '\n');
+	if (!ret)
+		ret = p + strlen(p);
+	else
+		ret++;
+
+	return ret;
+}
+
+static char *skip_spaces_until_newline(char *p)
+{
+	while (isspace(*p) && *p != '\n')
+		p++;
+	return p;
+}
+
+static int __init __xbc_open_brace(void)
+{
+	/* Mark the last key as open brace */
+	last_parent->next = XBC_NODE_MAX;
+
+	return 0;
+}
+
+static int __init __xbc_close_brace(char *p)
+{
+	struct xbc_node *node;
+
+	if (!last_parent || last_parent->next != XBC_NODE_MAX)
+		return xbc_parse_error("Unexpected closing brace", p);
+
+	node = last_parent;
+	node->next = 0;
+	do {
+		node = xbc_node_get_parent(node);
+	} while (node && node->next != XBC_NODE_MAX);
+	last_parent = node;
+
+	return 0;
+}
+
+/*
+ * Return delimiter or error, no node added. As same as lib/cmdline.c,
+ * you can use " around spaces, but can't escape " for value.
+ */
+static int __init __xbc_parse_value(char **__v, char **__n)
+{
+	char *p, *v = *__v;
+	int c, quotes = 0;
+
+	v = skip_spaces(v);
+	while (*v == '#') {
+		v = skip_comment(v);
+		v = skip_spaces(v);
+	}
+	if (*v == '"' || *v == '\'') {
+		quotes = *v;
+		v++;
+	}
+	p = v - 1;
+	while ((c = *++p)) {
+		if (!isprint(c) && !isspace(c))
+			return xbc_parse_error("Non printable value", p);
+		if (quotes) {
+			if (c != quotes)
+				continue;
+			quotes = 0;
+			*p++ = '\0';
+			p = skip_spaces_until_newline(p);
+			c = *p;
+			if (c && !strchr(",;\n#}", c))
+				return xbc_parse_error("No value delimiter", p);
+			if (*p)
+				p++;
+			break;
+		}
+		if (strchr(",;\n#}", c)) {
+			v = strim(v);
+			*p++ = '\0';
+			break;
+		}
+	}
+	if (quotes)
+		return xbc_parse_error("No closing quotes", p);
+	if (c == '#') {
+		p = skip_comment(p);
+		c = '\n';	/* A comment must be treated as a newline */
+	}
+	*__n = p;
+	*__v = v;
+
+	return c;
+}
+
+static int __init xbc_parse_array(char **__v)
+{
+	struct xbc_node *node;
+	char *next;
+	int c = 0;
+
+	do {
+		c = __xbc_parse_value(__v, &next);
+		if (c < 0)
+			return c;
+
+		node = xbc_add_sibling(*__v, XBC_VALUE);
+		if (!node)
+			return -ENOMEM;
+		*__v = next;
+	} while (c == ',');
+	node->next = 0;
+
+	return c;
+}
+
+static inline __init
+struct xbc_node *find_match_node(struct xbc_node *node, char *k)
+{
+	while (node) {
+		if (!strcmp(xbc_node_get_data(node), k))
+			break;
+		node = xbc_node_get_next(node);
+	}
+	return node;
+}
+
+static int __init __xbc_add_key(char *k)
+{
+	struct xbc_node *node;
+
+	if (!xbc_valid_keyword(k))
+		return xbc_parse_error("Invalid keyword", k);
+
+	if (unlikely(xbc_node_num == 0))
+		goto add_node;
+
+	if (!last_parent)	/* the first level */
+		node = find_match_node(xbc_nodes, k);
+	else
+		node = find_match_node(xbc_node_get_child(last_parent), k);
+
+	if (node)
+		last_parent = node;
+	else {
+add_node:
+		node = xbc_add_child(k, XBC_KEY);
+		if (!node)
+			return -ENOMEM;
+	}
+	return 0;
+}
+
+static int __init __xbc_parse_keys(char *k)
+{
+	char *p;
+	int ret;
+
+	k = strim(k);
+	while ((p = strchr(k, '.'))) {
+		*p++ = '\0';
+		ret = __xbc_add_key(k);
+		if (ret)
+			return ret;
+		k = p;
+	}
+
+	return __xbc_add_key(k);
+}
+
+static int __init xbc_parse_kv(char **k, char *v)
+{
+	struct xbc_node *prev_parent = last_parent;
+	struct xbc_node *node;
+	char *next;
+	int c, ret;
+
+	ret = __xbc_parse_keys(*k);
+	if (ret)
+		return ret;
+
+	c = __xbc_parse_value(&v, &next);
+	if (c < 0)
+		return c;
+
+	node = xbc_add_sibling(v, XBC_VALUE);
+	if (!node)
+		return -ENOMEM;
+
+	if (c == ',') {	/* Array */
+		c = xbc_parse_array(&next);
+		if (c < 0)
+			return c;
+	}
+
+	last_parent = prev_parent;
+
+	if (c == '}') {
+		ret = __xbc_close_brace(next - 1);
+		if (ret < 0)
+			return ret;
+	}
+
+	*k = next;
+
+	return 0;
+}
+
+static int __init xbc_parse_key(char **k, char *n)
+{
+	struct xbc_node *prev_parent = last_parent;
+	int ret;
+
+	*k = strim(*k);
+	if (**k != '\0') {
+		ret = __xbc_parse_keys(*k);
+		if (ret)
+			return ret;
+		last_parent = prev_parent;
+	}
+	*k = n;
+
+	return 0;
+}
+
+static int __init xbc_open_brace(char **k, char *n)
+{
+	int ret;
+
+	ret = __xbc_parse_keys(*k);
+	if (ret)
+		return ret;
+	*k = n;
+
+	return __xbc_open_brace();
+}
+
+static int __init xbc_close_brace(char **k, char *n)
+{
+	int ret;
+
+	ret = xbc_parse_key(k, n);
+	if (ret)
+		return ret;
+	/* k is updated in xbc_parse_key() */
+
+	return __xbc_close_brace(n - 1);
+}
+
+static int __init xbc_verify_tree(void)
+{
+	int i, depth, len, wlen;
+	struct xbc_node *n, *m;
+
+	/* Empty tree */
+	if (xbc_node_num == 0)
+		return -ENOENT;
+
+	for (i = 0; i < xbc_node_num; i++) {
+		if (xbc_nodes[i].next > xbc_node_num) {
+			return xbc_parse_error("No closing brace",
+				xbc_node_get_data(xbc_nodes + i));
+		}
+	}
+
+	/* Key tree limitation check */
+	n = &xbc_nodes[0];
+	depth = 1;
+	len = 0;
+
+	while (n) {
+		wlen = strlen(xbc_node_get_data(n)) + 1;
+		len += wlen;
+		if (len > XBC_KEYLEN_MAX)
+			return xbc_parse_error("Too long key length",
+				xbc_node_get_data(n));
+
+		m = xbc_node_get_child(n);
+		if (m && xbc_node_is_key(m)) {
+			n = m;
+			depth++;
+			if (depth > XBC_DEPTH_MAX)
+				return xbc_parse_error("Too many key words",
+						xbc_node_get_data(n));
+			continue;
+		}
+		len -= wlen;
+		m = xbc_node_get_next(n);
+		while (!m) {
+			n = xbc_node_get_parent(n);
+			if (!n)
+				break;
+			len -= strlen(xbc_node_get_data(n)) + 1;
+			depth--;
+			m = xbc_node_get_next(n);
+		}
+		n = m;
+	}
+
+	return 0;
+}
+
+/**
+ * xbc_destroy_all() - Clean up all parsed bootconfig
+ *
+ * This clears all data structures of parsed bootconfig on memory.
+ * If you need to reuse xbc_init() with new boot config, you can
+ * use this.
+ */
+void __init xbc_destroy_all(void)
+{
+	xbc_data = NULL;
+	xbc_data_size = 0;
+	xbc_node_num = 0;
+	memset(xbc_nodes, 0, sizeof(xbc_nodes));
+}
+
+/**
+ * xbc_init() - Parse given XBC file and build XBC internal tree
+ * @buf: boot config text
+ *
+ * This parses the boot config text in @buf. @buf must be a
+ * null terminated string and smaller than XBC_DATA_MAX.
+ * Return 0 if succeeded, or -errno if there is any error.
+ */
+int __init xbc_init(char *buf)
+{
+	char *p, *q;
+	int ret, c;
+
+	if (xbc_data)
+		return -EBUSY;
+
+	ret = strlen(buf);
+	if (ret > XBC_DATA_MAX - 1 || ret == 0)
+		return -ERANGE;
+
+	xbc_data = buf;
+	xbc_data_size = ret + 1;
+	last_parent = NULL;
+
+	p = buf;
+	do {
+		q = strpbrk(p, "{}=;\n#");
+		if (!q) {
+			p = skip_spaces(p);
+			if (*p != '\0')
+				ret = xbc_parse_error("No delimiter", p);
+			break;
+		}
+
+		c = *q;
+		*q++ = '\0';
+		switch (c) {
+		case '=':
+			ret = xbc_parse_kv(&p, q);
+			break;
+		case '{':
+			ret = xbc_open_brace(&p, q);
+			break;
+		case '#':
+			q = skip_comment(q);
+			/* fall through */
+		case ';':
+		case '\n':
+			ret = xbc_parse_key(&p, q);
+			break;
+		case '}':
+			ret = xbc_close_brace(&p, q);
+			break;
+		}
+	} while (!ret);
+
+	if (!ret)
+		ret = xbc_verify_tree();
+
+	if (ret < 0)
+		xbc_destroy_all();
+
+	return ret;
+}
+
+/**
+ * xbc_debug_dump() - Dump current XBC node list
+ *
+ * Dump the current XBC node list on printk buffer for debug.
+ */
+void __init xbc_debug_dump(void)
+{
+	int i;
+
+	for (i = 0; i < xbc_node_num; i++) {
+		pr_debug("[%d] %s (%s) .next=%d, .child=%d .parent=%d\n", i,
+			xbc_node_get_data(xbc_nodes + i),
+			xbc_node_is_value(xbc_nodes + i) ? "value" : "key",
+			xbc_nodes[i].next, xbc_nodes[i].child,
+			xbc_nodes[i].parent);
+	}
+}
