commit 93048c0944150b316a15f92c41a4d626c8df37fd
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Tue Oct 16 14:13:40 2018 +0300

    lib: Fix ia64 bootloader linkage
    
    kbuild robot reports that since commit ce76d938dd98 ("lib: Add memcat_p():
    paste 2 pointer arrays together") the ia64/hp/sim/boot fails to link:
    
    > LD      arch/ia64/hp/sim/boot/bootloader
    > lib/string.o: In function `__memcat_p':
    > string.c:(.text+0x1f22): undefined reference to `__kmalloc'
    > string.c:(.text+0x1ff2): undefined reference to `__kmalloc'
    > make[1]: *** [arch/ia64/hp/sim/boot/Makefile:37: arch/ia64/hp/sim/boot/bootloader] Error 1
    
    The reason is, the above commit, via __memcat_p(), adds a call to
    __kmalloc to string.o, which happens to be used in the bootloader, but
    there's no kmalloc or slab or anything.
    
    Since the linker would only pull in objects that contain referenced
    symbols, moving __memcat_p() to a different compilation unit solves the
    problem.
    
    Fixes: ce76d938dd98 ("lib: Add memcat_p(): paste 2 pointer arrays together")
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/test_memcat_p.c b/lib/test_memcat_p.c
index 2b163a749ecb..849c477d49d0 100644
--- a/lib/test_memcat_p.c
+++ b/lib/test_memcat_p.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Test cases for memcat_p() in lib/string.c
+ * Test cases for memcat_p() in lib/memcat_p.c
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit ce76d938dd98817f998c905e01fbb99b072c0bf6
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri Oct 5 15:43:05 2018 +0300

    lib: Add memcat_p(): paste 2 pointer arrays together
    
    This adds a helper to paste 2 pointer arrays together, useful for merging
    various types of attribute arrays. There are a few places in the kernel
    tree where this is open coded, and I just added one more in the STM class.
    
    The naming is inspired by memset_p() and memcat(), and partial credit for
    it goes to Andy Shevchenko.
    
    This patch adds the function wrapped in a type-enforcing macro and a test
    module.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/test_memcat_p.c b/lib/test_memcat_p.c
new file mode 100644
index 000000000000..2b163a749ecb
--- /dev/null
+++ b/lib/test_memcat_p.c
@@ -0,0 +1,115 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Test cases for memcat_p() in lib/string.c
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+struct test_struct {
+	int		num;
+	unsigned int	magic;
+};
+
+#define MAGIC		0xf00ff00f
+/* Size of each of the NULL-terminated input arrays */
+#define INPUT_MAX	128
+/* Expected number of non-NULL elements in the output array */
+#define EXPECT		(INPUT_MAX * 2 - 2)
+
+static int __init test_memcat_p_init(void)
+{
+	struct test_struct **in0, **in1, **out, **p;
+	int err = -ENOMEM, i, r, total = 0;
+
+	in0 = kcalloc(INPUT_MAX, sizeof(*in0), GFP_KERNEL);
+	if (!in0)
+		return err;
+
+	in1 = kcalloc(INPUT_MAX, sizeof(*in1), GFP_KERNEL);
+	if (!in1)
+		goto err_free_in0;
+
+	for (i = 0, r = 1; i < INPUT_MAX - 1; i++) {
+		in0[i] = kmalloc(sizeof(**in0), GFP_KERNEL);
+		if (!in0[i])
+			goto err_free_elements;
+
+		in1[i] = kmalloc(sizeof(**in1), GFP_KERNEL);
+		if (!in1[i]) {
+			kfree(in0[i]);
+			goto err_free_elements;
+		}
+
+		/* lifted from test_sort.c */
+		r = (r * 725861) % 6599;
+		in0[i]->num = r;
+		in1[i]->num = -r;
+		in0[i]->magic = MAGIC;
+		in1[i]->magic = MAGIC;
+	}
+
+	in0[i] = in1[i] = NULL;
+
+	out = memcat_p(in0, in1);
+	if (!out)
+		goto err_free_all_elements;
+
+	err = -EINVAL;
+	for (i = 0, p = out; *p && (i < INPUT_MAX * 2 - 1); p++, i++) {
+		total += (*p)->num;
+
+		if ((*p)->magic != MAGIC) {
+			pr_err("test failed: wrong magic at %d: %u\n", i,
+			       (*p)->magic);
+			goto err_free_out;
+		}
+	}
+
+	if (total) {
+		pr_err("test failed: expected zero total, got %d\n", total);
+		goto err_free_out;
+	}
+
+	if (i != EXPECT) {
+		pr_err("test failed: expected output size %d, got %d\n",
+		       EXPECT, i);
+		goto err_free_out;
+	}
+
+	for (i = 0; i < INPUT_MAX - 1; i++)
+		if (out[i] != in0[i] || out[i + INPUT_MAX - 1] != in1[i]) {
+			pr_err("test failed: wrong element order at %d\n", i);
+			goto err_free_out;
+		}
+
+	err = 0;
+	pr_info("test passed\n");
+
+err_free_out:
+	kfree(out);
+err_free_all_elements:
+	i = INPUT_MAX;
+err_free_elements:
+	for (i--; i >= 0; i--) {
+		kfree(in1[i]);
+		kfree(in0[i]);
+	}
+
+	kfree(in1);
+err_free_in0:
+	kfree(in0);
+
+	return err;
+}
+
+static void __exit test_memcat_p_exit(void)
+{
+}
+
+module_init(test_memcat_p_init);
+module_exit(test_memcat_p_exit);
+
+MODULE_LICENSE("GPL");
