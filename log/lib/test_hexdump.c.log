commit b1286ed7158e9b62787508066283ab0b8850b518
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 30 12:13:15 2018 -0800

    test_hexdump: use memcpy instead of strncpy
    
    New versions of gcc reasonably warn about the odd pattern of
    
            strncpy(p, q, strlen(q));
    
    which really doesn't make sense: the strncpy() ends up being just a slow
    and odd way to write memcpy() in this case.
    
    Apparently there was a patch for this floating around earlier, but it
    got lost.
    
    Acked-again-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 626f580b4ff7..5144899d3c6b 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -99,7 +99,7 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 		const char *q = *result++;
 		size_t amount = strlen(q);
 
-		strncpy(p, q, amount);
+		memcpy(p, q, amount);
 		p += amount;
 
 		*p++ = ' ';

commit de9df3993cfffde468c1c226382f24cec7e9fedc
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Tue Aug 21 21:57:22 2018 -0700

    lib/test_hexdump.c: fix failure on big endian cpu
    
    On a big endian cpu, test_hexdump fails as follows.  The logs show that
    bytes are expected in reversed order.
    
      [...]
      test_hexdump: Len: 24 buflen: 130 strlen: 97
      test_hexdump: Result: 97 'be32db7b 0a1893b2 70bac424 7d83349b a69c31ad 9c0face9                    .2.{....p..$}.4...1.....'
      test_hexdump: Expect: 97 '7bdb32be b293180a 24c4ba70 9b34837d ad319ca6 e9ac0f9c                    .2.{....p..$}.4...1.....'
      test_hexdump: Len: 8 buflen: 130 strlen: 77
      test_hexdump: Result: 77 'be32db7b0a1893b2                                                     .2.{....'
      test_hexdump: Expect: 77 'b293180a7bdb32be                                                     .2.{....'
      test_hexdump: Len: 6 buflen: 131 strlen: 87
      test_hexdump: Result: 87 'be32 db7b 0a18                                                                   .2.{..'
      test_hexdump: Expect: 87 '32be 7bdb 180a                                                                   .2.{..'
      test_hexdump: Len: 24 buflen: 131 strlen: 97
      test_hexdump: Result: 97 'be32db7b 0a1893b2 70bac424 7d83349b a69c31ad 9c0face9                    .2.{....p..$}.4...1.....'
      test_hexdump: Expect: 97 '7bdb32be b293180a 24c4ba70 9b34837d ad319ca6 e9ac0f9c                    .2.{....p..$}.4...1.....'
      test_hexdump: Len: 32 buflen: 131 strlen: 101
      test_hexdump: Result: 101 'be32db7b0a1893b2 70bac4247d83349b a69c31ad9c0face9 4cd1199943b1af0c  .2.{....p..$}.4...1.....L...C...'
      test_hexdump: Expect: 101 'b293180a7bdb32be 9b34837d24c4ba70 e9ac0f9cad319ca6 0cafb1439919d14c  .2.{....p..$}.4...1.....L...C...'
      test_hexdump: failed 801 out of 1184 tests
    
    This patch fixes it.
    
    Link: http://lkml.kernel.org/r/f3112437f62c2f48300535510918e8be1dceacfb.1533610877.git.christophe.leroy@c-s.fr
    Fixes: 64d1d77a44697 ("hexdump: introduce test suite")
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: rashmica <rashmicy@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 3f415d8101f3..626f580b4ff7 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -18,7 +18,7 @@ static const unsigned char data_b[] = {
 
 static const unsigned char data_a[] = ".2.{....p..$}.4...1.....L...C...";
 
-static const char * const test_data_1_le[] __initconst = {
+static const char * const test_data_1[] __initconst = {
 	"be", "32", "db", "7b", "0a", "18", "93", "b2",
 	"70", "ba", "c4", "24", "7d", "83", "34", "9b",
 	"a6", "9c", "31", "ad", "9c", "0f", "ac", "e9",
@@ -32,16 +32,33 @@ static const char * const test_data_2_le[] __initconst = {
 	"d14c", "9919", "b143", "0caf",
 };
 
+static const char * const test_data_2_be[] __initconst = {
+	"be32", "db7b", "0a18", "93b2",
+	"70ba", "c424", "7d83", "349b",
+	"a69c", "31ad", "9c0f", "ace9",
+	"4cd1", "1999", "43b1", "af0c",
+};
+
 static const char * const test_data_4_le[] __initconst = {
 	"7bdb32be", "b293180a", "24c4ba70", "9b34837d",
 	"ad319ca6", "e9ac0f9c", "9919d14c", "0cafb143",
 };
 
+static const char * const test_data_4_be[] __initconst = {
+	"be32db7b", "0a1893b2", "70bac424", "7d83349b",
+	"a69c31ad", "9c0face9", "4cd11999", "43b1af0c",
+};
+
 static const char * const test_data_8_le[] __initconst = {
 	"b293180a7bdb32be", "9b34837d24c4ba70",
 	"e9ac0f9cad319ca6", "0cafb1439919d14c",
 };
 
+static const char * const test_data_8_be[] __initconst = {
+	"be32db7b0a1893b2", "70bac4247d83349b",
+	"a69c31ad9c0face9", "4cd1199943b1af0c",
+};
+
 #define FILL_CHAR	'#'
 
 static unsigned total_tests __initdata;
@@ -56,6 +73,7 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 	size_t l = len;
 	int gs = groupsize, rs = rowsize;
 	unsigned int i;
+	const bool is_be = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN);
 
 	if (rs != 16 && rs != 32)
 		rs = 16;
@@ -67,13 +85,13 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 		gs = 1;
 
 	if (gs == 8)
-		result = test_data_8_le;
+		result = is_be ? test_data_8_be : test_data_8_le;
 	else if (gs == 4)
-		result = test_data_4_le;
+		result = is_be ? test_data_4_be : test_data_4_le;
 	else if (gs == 2)
-		result = test_data_2_le;
+		result = is_be ? test_data_2_be : test_data_2_le;
 	else
-		result = test_data_1_le;
+		result = test_data_1;
 
 	/* hex dump */
 	p = test;

commit 7aaf4c3e1235cca77dcc1c5a0848687e7d26a42f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:59:07 2016 -0800

    test_hexdump: print statistics at the end
    
    Like others test are doing print the gathered statistics after test module
    is finished.  Return from the module based on the result.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 11d45f510d6c..3f415d8101f3 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -44,6 +44,9 @@ static const char * const test_data_8_le[] __initconst = {
 
 #define FILL_CHAR	'#'
 
+static unsigned total_tests __initdata;
+static unsigned failed_tests __initdata;
+
 static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 					     int groupsize, char *test,
 					     size_t testlen, bool ascii)
@@ -107,6 +110,8 @@ static void __init test_hexdump(size_t len, int rowsize, int groupsize,
 	char test[TEST_HEXDUMP_BUF_SIZE];
 	char real[TEST_HEXDUMP_BUF_SIZE];
 
+	total_tests++;
+
 	memset(real, FILL_CHAR, sizeof(real));
 	hex_dump_to_buffer(data_b, len, rowsize, groupsize, real, sizeof(real),
 			   ascii);
@@ -119,6 +124,7 @@ static void __init test_hexdump(size_t len, int rowsize, int groupsize,
 		pr_err("Len: %zu row: %d group: %d\n", len, rowsize, groupsize);
 		pr_err("Result: '%s'\n", real);
 		pr_err("Expect: '%s'\n", test);
+		failed_tests++;
 	}
 }
 
@@ -143,6 +149,8 @@ static void __init test_hexdump_overflow(size_t buflen, size_t len,
 	int ae, he, e, f, r;
 	bool a;
 
+	total_tests++;
+
 	memset(buf, FILL_CHAR, sizeof(buf));
 
 	r = hex_dump_to_buffer(data_b, len, rs, gs, buf, buflen, ascii);
@@ -175,6 +183,7 @@ static void __init test_hexdump_overflow(size_t buflen, size_t len,
 			len, buflen, strnlen(buf, sizeof(buf)));
 		pr_err("Result: %d '%s'\n", r, buf);
 		pr_err("Expect: %d '%s'\n", e, test);
+		failed_tests++;
 	}
 }
 
@@ -196,8 +205,6 @@ static int __init test_hexdump_init(void)
 	unsigned int i;
 	int rowsize;
 
-	pr_info("Running tests...\n");
-
 	rowsize = (get_random_int() % 2 + 1) * 16;
 	for (i = 0; i < 16; i++)
 		test_hexdump_set(rowsize, false);
@@ -212,7 +219,20 @@ static int __init test_hexdump_init(void)
 	for (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)
 		test_hexdump_overflow_set(i, true);
 
-	return -EINVAL;
+	if (failed_tests == 0)
+		pr_info("all %u tests passed\n", total_tests);
+	else
+		pr_err("failed %u out of %u tests\n", failed_tests, total_tests);
+
+	return failed_tests ? -EINVAL : 0;
 }
 module_init(test_hexdump_init);
+
+static void __exit test_hexdump_exit(void)
+{
+	/* do nothing */
+}
+module_exit(test_hexdump_exit);
+
+MODULE_AUTHOR("Andy Shevchenko <andriy.shevchenko@linux.intel.com>");
 MODULE_LICENSE("Dual BSD/GPL");

commit 1dacd9ddd359eed63b210bd9b5000c2cfae287ff
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:59:04 2016 -0800

    test_hexdump: test all possible group sizes for overflow
    
    Currently the only one combination is tested for overflow, i.e.  rowsize =
    16, groupsize = 1, len = 1.  Do various test to go through all possible
    branches.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 16a759374730..11d45f510d6c 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -133,7 +133,9 @@ static void __init test_hexdump_set(int rowsize, bool ascii)
 	test_hexdump(len, rowsize, 1, ascii);
 }
 
-static void __init test_hexdump_overflow(size_t buflen, bool ascii)
+static void __init test_hexdump_overflow(size_t buflen, size_t len,
+					 int rowsize, int groupsize,
+					 bool ascii)
 {
 	char test[TEST_HEXDUMP_BUF_SIZE];
 	char buf[TEST_HEXDUMP_BUF_SIZE];
@@ -176,6 +178,19 @@ static void __init test_hexdump_overflow(size_t buflen, bool ascii)
 	}
 }
 
+static void __init test_hexdump_overflow_set(size_t buflen, bool ascii)
+{
+	unsigned int i = 0;
+	int rs = (get_random_int() % 2 + 1) * 16;
+
+	do {
+		int gs = 1 << i;
+		size_t len = get_random_int() % rs + gs;
+
+		test_hexdump_overflow(buflen, rounddown(len, gs), rs, gs, ascii);
+	} while (i++ < 3);
+}
+
 static int __init test_hexdump_init(void)
 {
 	unsigned int i;
@@ -192,10 +207,10 @@ static int __init test_hexdump_init(void)
 		test_hexdump_set(rowsize, true);
 
 	for (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)
-		test_hexdump_overflow(i, false);
+		test_hexdump_overflow_set(i, false);
 
 	for (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)
-		test_hexdump_overflow(i, true);
+		test_hexdump_overflow_set(i, true);
 
 	return -EINVAL;
 }

commit cc77a719a5cfd419d057277fd0fdfca568bcfdd2
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:59:01 2016 -0800

    test_hexdump: check all bytes in real buffer
    
    After processing by hex_dump_to_buffer() check all the parts to be expected.
    
    Part 1. The actual expected hex dump with or without ASCII part.
    
    Part 2. Check if the buffer is dirty beyond needed.
    
    Part 3. Return code should be as expected.
    
    This is done by using comparison of the return code and memcmp() against
    the test buffer.  We fill the buffer by FILL_CHAR ('#') characters, so, we
    expect to have a tail of the buffer will be left untouched.  The
    terminating NUL is also checked by memcmp().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 4b949aac6f08..16a759374730 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -135,11 +135,10 @@ static void __init test_hexdump_set(int rowsize, bool ascii)
 
 static void __init test_hexdump_overflow(size_t buflen, bool ascii)
 {
+	char test[TEST_HEXDUMP_BUF_SIZE];
 	char buf[TEST_HEXDUMP_BUF_SIZE];
-	const char *t = test_data_1_le[0];
-	size_t len = 1;
-	int rs = 16, gs = 1;
-	int ae, he, e, r;
+	int rs = rowsize, gs = groupsize;
+	int ae, he, e, f, r;
 	bool a;
 
 	memset(buf, FILL_CHAR, sizeof(buf));
@@ -157,26 +156,23 @@ static void __init test_hexdump_overflow(size_t buflen, bool ascii)
 		e = ae;
 	else
 		e = he;
-	buf[e + 2] = '\0';
-
-	if (!buflen) {
-		a = r == e && buf[0] == FILL_CHAR;
-	} else if (buflen < 3) {
-		a = r == e && buf[0] == '\0';
-	} else if (buflen < 4) {
-		a = r == e && !strcmp(buf, t);
-	} else if (ascii) {
-		if (buflen < 51)
-			a = r == e && buf[buflen - 1] == '\0' && buf[buflen - 2] == FILL_CHAR;
-		else
-			a = r == e && buf[50] == '\0' && buf[49] == '.';
-	} else {
-		a = r == e && buf[e] == '\0';
+
+	f = min_t(int, e + 1, buflen);
+	if (buflen) {
+		test_hexdump_prepare_test(len, rs, gs, test, sizeof(test), ascii);
+		test[f - 1] = '\0';
 	}
+	memset(test + f, FILL_CHAR, sizeof(test) - f);
+
+	a = r == e && !memcmp(test, buf, TEST_HEXDUMP_BUF_SIZE);
+
+	buf[sizeof(buf) - 1] = '\0';
 
 	if (!a) {
-		pr_err("Len: %zu rc: %u strlen: %zu\n", buflen, r, strlen(buf));
-		pr_err("Result: '%s'\n", buf);
+		pr_err("Len: %zu buflen: %zu strlen: %zu\n",
+			len, buflen, strnlen(buf, sizeof(buf)));
+		pr_err("Result: %d '%s'\n", r, buf);
+		pr_err("Expect: %d '%s'\n", e, test);
 	}
 }
 

commit 7047d813718c8e40929b7267a8d20cbf212f8565
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:58 2016 -0800

    test_hexdump: switch to memcmp()
    
    Better to use memcmp() against entire buffer to check that nothing is
    happened to the data in the tail.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 141d031e6a13..4b949aac6f08 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -72,8 +72,6 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 	else
 		result = test_data_1_le;
 
-	memset(test, FILL_CHAR, testlen);
-
 	/* hex dump */
 	p = test;
 	for (i = 0; i < l / gs; i++) {
@@ -109,13 +107,15 @@ static void __init test_hexdump(size_t len, int rowsize, int groupsize,
 	char test[TEST_HEXDUMP_BUF_SIZE];
 	char real[TEST_HEXDUMP_BUF_SIZE];
 
+	memset(real, FILL_CHAR, sizeof(real));
 	hex_dump_to_buffer(data_b, len, rowsize, groupsize, real, sizeof(real),
 			   ascii);
 
+	memset(test, FILL_CHAR, sizeof(test));
 	test_hexdump_prepare_test(len, rowsize, groupsize, test, sizeof(test),
 				  ascii);
 
-	if (strcmp(test, real)) {
+	if (memcmp(test, real, TEST_HEXDUMP_BUF_SIZE)) {
 		pr_err("Len: %zu row: %d group: %d\n", len, rowsize, groupsize);
 		pr_err("Result: '%s'\n", real);
 		pr_err("Expect: '%s'\n", test);

commit ad27a7559a85309a4775389d012f3728c92f5eb0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:56 2016 -0800

    test_hexdump: replace magic numbers by their meaning
    
    The magic numbers of the length are converted to their actual meaning,
    such as end of the buffer with and without ASCII part.
    
    We don't touch the rest of the magic constants that will be removed in the
    following commits.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 940b1d318831..141d031e6a13 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -137,17 +137,26 @@ static void __init test_hexdump_overflow(size_t buflen, bool ascii)
 {
 	char buf[TEST_HEXDUMP_BUF_SIZE];
 	const char *t = test_data_1_le[0];
+	size_t len = 1;
+	int rs = 16, gs = 1;
+	int ae, he, e, r;
 	bool a;
-	int e, r;
 
 	memset(buf, FILL_CHAR, sizeof(buf));
 
-	r = hex_dump_to_buffer(data_b, 1, 16, 1, buf, buflen, ascii);
+	r = hex_dump_to_buffer(data_b, len, rs, gs, buf, buflen, ascii);
+
+	/*
+	 * Caller must provide the data length multiple of groupsize. The
+	 * calculations below are made with that assumption in mind.
+	 */
+	ae = rs * 2 /* hex */ + rs / gs /* spaces */ + 1 /* space */ + len /* ascii */;
+	he = (gs * 2 /* hex */ + 1 /* space */) * len / gs - 1 /* no trailing space */;
 
 	if (ascii)
-		e = 50;
+		e = ae;
 	else
-		e = 2;
+		e = he;
 	buf[e + 2] = '\0';
 
 	if (!buflen) {

commit a3d601fcc2f94fd1583053a1b1aea5de66ffc79c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:53 2016 -0800

    test_hexdump: go through all possible lengths of buffer
    
    When test for overflow do iterate the buffer length in a range 0 ..
    BUF_SIZE.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 1ecdb97b370c..940b1d318831 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -133,17 +133,16 @@ static void __init test_hexdump_set(int rowsize, bool ascii)
 	test_hexdump(len, rowsize, 1, ascii);
 }
 
-static void __init test_hexdump_overflow(bool ascii)
+static void __init test_hexdump_overflow(size_t buflen, bool ascii)
 {
-	char buf[56];
+	char buf[TEST_HEXDUMP_BUF_SIZE];
 	const char *t = test_data_1_le[0];
-	size_t l = get_random_int() % sizeof(buf);
 	bool a;
 	int e, r;
 
 	memset(buf, FILL_CHAR, sizeof(buf));
 
-	r = hex_dump_to_buffer(data_b, 1, 16, 1, buf, l, ascii);
+	r = hex_dump_to_buffer(data_b, 1, 16, 1, buf, buflen, ascii);
 
 	if (ascii)
 		e = 50;
@@ -151,15 +150,15 @@ static void __init test_hexdump_overflow(bool ascii)
 		e = 2;
 	buf[e + 2] = '\0';
 
-	if (!l) {
+	if (!buflen) {
 		a = r == e && buf[0] == FILL_CHAR;
-	} else if (l < 3) {
+	} else if (buflen < 3) {
 		a = r == e && buf[0] == '\0';
-	} else if (l < 4) {
+	} else if (buflen < 4) {
 		a = r == e && !strcmp(buf, t);
 	} else if (ascii) {
-		if (l < 51)
-			a = r == e && buf[l - 1] == '\0' && buf[l - 2] == FILL_CHAR;
+		if (buflen < 51)
+			a = r == e && buf[buflen - 1] == '\0' && buf[buflen - 2] == FILL_CHAR;
 		else
 			a = r == e && buf[50] == '\0' && buf[49] == '.';
 	} else {
@@ -167,7 +166,7 @@ static void __init test_hexdump_overflow(bool ascii)
 	}
 
 	if (!a) {
-		pr_err("Len: %zu rc: %u strlen: %zu\n", l, r, strlen(buf));
+		pr_err("Len: %zu rc: %u strlen: %zu\n", buflen, r, strlen(buf));
 		pr_err("Result: '%s'\n", buf);
 	}
 }
@@ -187,11 +186,11 @@ static int __init test_hexdump_init(void)
 	for (i = 0; i < 16; i++)
 		test_hexdump_set(rowsize, true);
 
-	for (i = 0; i < 16; i++)
-		test_hexdump_overflow(false);
+	for (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)
+		test_hexdump_overflow(i, false);
 
-	for (i = 0; i < 16; i++)
-		test_hexdump_overflow(true);
+	for (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)
+		test_hexdump_overflow(i, true);
 
 	return -EINVAL;
 }

commit 3db4a987180acfba3bc117575bfedb81e055778c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:50 2016 -0800

    test_hexdump: define FILL_CHAR constant
    
    Define a character to fill the test buffers.  Though the character should
    be printable since it's used when errors are reported.  It should neither
    be from hex digit [a-fA-F0-9] dictionary nor space.  It is recommended not
    to use one which is present in ASCII part of the test data.  Later on we
    might switch to unprintable character to make test case more robust.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index ed7c6a704f34..1ecdb97b370c 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -42,6 +42,8 @@ static const char * const test_data_8_le[] __initconst = {
 	"e9ac0f9cad319ca6", "0cafb1439919d14c",
 };
 
+#define FILL_CHAR	'#'
+
 static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 					     int groupsize, char *test,
 					     size_t testlen, bool ascii)
@@ -70,7 +72,7 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 	else
 		result = test_data_1_le;
 
-	memset(test, ' ', testlen);
+	memset(test, FILL_CHAR, testlen);
 
 	/* hex dump */
 	p = test;
@@ -79,14 +81,19 @@ static void __init test_hexdump_prepare_test(size_t len, int rowsize,
 		size_t amount = strlen(q);
 
 		strncpy(p, q, amount);
-		p += amount + 1;
+		p += amount;
+
+		*p++ = ' ';
 	}
 	if (i)
 		p--;
 
 	/* ASCII part */
 	if (ascii) {
-		p = test + rs * 2 + rs / gs + 1;
+		do {
+			*p++ = ' ';
+		} while (p < test + rs * 2 + rs / gs + 1);
+
 		strncpy(p, data_a, l);
 		p += l;
 	}
@@ -134,7 +141,7 @@ static void __init test_hexdump_overflow(bool ascii)
 	bool a;
 	int e, r;
 
-	memset(buf, ' ', sizeof(buf));
+	memset(buf, FILL_CHAR, sizeof(buf));
 
 	r = hex_dump_to_buffer(data_b, 1, 16, 1, buf, l, ascii);
 
@@ -145,14 +152,14 @@ static void __init test_hexdump_overflow(bool ascii)
 	buf[e + 2] = '\0';
 
 	if (!l) {
-		a = r == e && buf[0] == ' ';
+		a = r == e && buf[0] == FILL_CHAR;
 	} else if (l < 3) {
 		a = r == e && buf[0] == '\0';
 	} else if (l < 4) {
 		a = r == e && !strcmp(buf, t);
 	} else if (ascii) {
 		if (l < 51)
-			a = r == e && buf[l - 1] == '\0' && buf[l - 2] == ' ';
+			a = r == e && buf[l - 1] == '\0' && buf[l - 2] == FILL_CHAR;
 		else
 			a = r == e && buf[50] == '\0' && buf[49] == '.';
 	} else {

commit 87977ca6bcd051b8bd20adff0a023548ff25902c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:47 2016 -0800

    test_hexdump: introduce test_hexdump_prepare_test() helper
    
    The function prepares the expected result in the provided buffer.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
index 5241df36eedf..ed7c6a704f34 100644
--- a/lib/test_hexdump.c
+++ b/lib/test_hexdump.c
@@ -42,19 +42,16 @@ static const char * const test_data_8_le[] __initconst = {
 	"e9ac0f9cad319ca6", "0cafb1439919d14c",
 };
 
-static void __init test_hexdump(size_t len, int rowsize, int groupsize,
-				bool ascii)
+static void __init test_hexdump_prepare_test(size_t len, int rowsize,
+					     int groupsize, char *test,
+					     size_t testlen, bool ascii)
 {
-	char test[32 * 3 + 2 + 32 + 1];
-	char real[32 * 3 + 2 + 32 + 1];
 	char *p;
 	const char * const *result;
 	size_t l = len;
 	int gs = groupsize, rs = rowsize;
 	unsigned int i;
 
-	hex_dump_to_buffer(data_b, l, rs, gs, real, sizeof(real), ascii);
-
 	if (rs != 16 && rs != 32)
 		rs = 16;
 
@@ -73,7 +70,7 @@ static void __init test_hexdump(size_t len, int rowsize, int groupsize,
 	else
 		result = test_data_1_le;
 
-	memset(test, ' ', sizeof(test));
+	memset(test, ' ', testlen);
 
 	/* hex dump */
 	p = test;
@@ -95,6 +92,21 @@ static void __init test_hexdump(size_t len, int rowsize, int groupsize,
 	}
 
 	*p = '\0';
+}
+
+#define TEST_HEXDUMP_BUF_SIZE		(32 * 3 + 2 + 32 + 1)
+
+static void __init test_hexdump(size_t len, int rowsize, int groupsize,
+				bool ascii)
+{
+	char test[TEST_HEXDUMP_BUF_SIZE];
+	char real[TEST_HEXDUMP_BUF_SIZE];
+
+	hex_dump_to_buffer(data_b, len, rowsize, groupsize, real, sizeof(real),
+			   ascii);
+
+	test_hexdump_prepare_test(len, rowsize, groupsize, test, sizeof(test),
+				  ascii);
 
 	if (strcmp(test, real)) {
 		pr_err("Len: %zu row: %d group: %d\n", len, rowsize, groupsize);

commit 60b2e8f4f71a21b96306a8a3ea4dd345ea3bfb46
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 20 14:58:44 2016 -0800

    test_hexdump: rename to test_hexdump
    
    The test suite currently doesn't cover many corner cases when
    hex_dump_to_buffer() runs into overflow.  Refactor and amend test suite
    to cover most of the cases.
    
    This patch (of 9):
    
    Just to follow the scheme that most of the test modules are using.
    
    There is no fuctional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_hexdump.c b/lib/test_hexdump.c
new file mode 100644
index 000000000000..5241df36eedf
--- /dev/null
+++ b/lib/test_hexdump.c
@@ -0,0 +1,180 @@
+/*
+ * Test cases for lib/hexdump.c module.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/string.h>
+
+static const unsigned char data_b[] = {
+	'\xbe', '\x32', '\xdb', '\x7b', '\x0a', '\x18', '\x93', '\xb2',	/* 00 - 07 */
+	'\x70', '\xba', '\xc4', '\x24', '\x7d', '\x83', '\x34', '\x9b',	/* 08 - 0f */
+	'\xa6', '\x9c', '\x31', '\xad', '\x9c', '\x0f', '\xac', '\xe9',	/* 10 - 17 */
+	'\x4c', '\xd1', '\x19', '\x99', '\x43', '\xb1', '\xaf', '\x0c',	/* 18 - 1f */
+};
+
+static const unsigned char data_a[] = ".2.{....p..$}.4...1.....L...C...";
+
+static const char * const test_data_1_le[] __initconst = {
+	"be", "32", "db", "7b", "0a", "18", "93", "b2",
+	"70", "ba", "c4", "24", "7d", "83", "34", "9b",
+	"a6", "9c", "31", "ad", "9c", "0f", "ac", "e9",
+	"4c", "d1", "19", "99", "43", "b1", "af", "0c",
+};
+
+static const char * const test_data_2_le[] __initconst = {
+	"32be", "7bdb", "180a", "b293",
+	"ba70", "24c4", "837d", "9b34",
+	"9ca6", "ad31", "0f9c", "e9ac",
+	"d14c", "9919", "b143", "0caf",
+};
+
+static const char * const test_data_4_le[] __initconst = {
+	"7bdb32be", "b293180a", "24c4ba70", "9b34837d",
+	"ad319ca6", "e9ac0f9c", "9919d14c", "0cafb143",
+};
+
+static const char * const test_data_8_le[] __initconst = {
+	"b293180a7bdb32be", "9b34837d24c4ba70",
+	"e9ac0f9cad319ca6", "0cafb1439919d14c",
+};
+
+static void __init test_hexdump(size_t len, int rowsize, int groupsize,
+				bool ascii)
+{
+	char test[32 * 3 + 2 + 32 + 1];
+	char real[32 * 3 + 2 + 32 + 1];
+	char *p;
+	const char * const *result;
+	size_t l = len;
+	int gs = groupsize, rs = rowsize;
+	unsigned int i;
+
+	hex_dump_to_buffer(data_b, l, rs, gs, real, sizeof(real), ascii);
+
+	if (rs != 16 && rs != 32)
+		rs = 16;
+
+	if (l > rs)
+		l = rs;
+
+	if (!is_power_of_2(gs) || gs > 8 || (len % gs != 0))
+		gs = 1;
+
+	if (gs == 8)
+		result = test_data_8_le;
+	else if (gs == 4)
+		result = test_data_4_le;
+	else if (gs == 2)
+		result = test_data_2_le;
+	else
+		result = test_data_1_le;
+
+	memset(test, ' ', sizeof(test));
+
+	/* hex dump */
+	p = test;
+	for (i = 0; i < l / gs; i++) {
+		const char *q = *result++;
+		size_t amount = strlen(q);
+
+		strncpy(p, q, amount);
+		p += amount + 1;
+	}
+	if (i)
+		p--;
+
+	/* ASCII part */
+	if (ascii) {
+		p = test + rs * 2 + rs / gs + 1;
+		strncpy(p, data_a, l);
+		p += l;
+	}
+
+	*p = '\0';
+
+	if (strcmp(test, real)) {
+		pr_err("Len: %zu row: %d group: %d\n", len, rowsize, groupsize);
+		pr_err("Result: '%s'\n", real);
+		pr_err("Expect: '%s'\n", test);
+	}
+}
+
+static void __init test_hexdump_set(int rowsize, bool ascii)
+{
+	size_t d = min_t(size_t, sizeof(data_b), rowsize);
+	size_t len = get_random_int() % d + 1;
+
+	test_hexdump(len, rowsize, 4, ascii);
+	test_hexdump(len, rowsize, 2, ascii);
+	test_hexdump(len, rowsize, 8, ascii);
+	test_hexdump(len, rowsize, 1, ascii);
+}
+
+static void __init test_hexdump_overflow(bool ascii)
+{
+	char buf[56];
+	const char *t = test_data_1_le[0];
+	size_t l = get_random_int() % sizeof(buf);
+	bool a;
+	int e, r;
+
+	memset(buf, ' ', sizeof(buf));
+
+	r = hex_dump_to_buffer(data_b, 1, 16, 1, buf, l, ascii);
+
+	if (ascii)
+		e = 50;
+	else
+		e = 2;
+	buf[e + 2] = '\0';
+
+	if (!l) {
+		a = r == e && buf[0] == ' ';
+	} else if (l < 3) {
+		a = r == e && buf[0] == '\0';
+	} else if (l < 4) {
+		a = r == e && !strcmp(buf, t);
+	} else if (ascii) {
+		if (l < 51)
+			a = r == e && buf[l - 1] == '\0' && buf[l - 2] == ' ';
+		else
+			a = r == e && buf[50] == '\0' && buf[49] == '.';
+	} else {
+		a = r == e && buf[e] == '\0';
+	}
+
+	if (!a) {
+		pr_err("Len: %zu rc: %u strlen: %zu\n", l, r, strlen(buf));
+		pr_err("Result: '%s'\n", buf);
+	}
+}
+
+static int __init test_hexdump_init(void)
+{
+	unsigned int i;
+	int rowsize;
+
+	pr_info("Running tests...\n");
+
+	rowsize = (get_random_int() % 2 + 1) * 16;
+	for (i = 0; i < 16; i++)
+		test_hexdump_set(rowsize, false);
+
+	rowsize = (get_random_int() % 2 + 1) * 16;
+	for (i = 0; i < 16; i++)
+		test_hexdump_set(rowsize, true);
+
+	for (i = 0; i < 16; i++)
+		test_hexdump_overflow(false);
+
+	for (i = 0; i < 16; i++)
+		test_hexdump_overflow(true);
+
+	return -EINVAL;
+}
+module_init(test_hexdump_init);
+MODULE_LICENSE("Dual BSD/GPL");
