commit 45a46873f0143703b65ee6646564345d82c7935e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 22 09:51:41 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 95
    
    Based on 1 normalized pattern(s):
    
      library are free software you can redistribute them and or modify
      them under the terms of the gnu general public license as published
      by the free software foundation either version 2 of the license or
      at your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program see the file copying if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520075212.429390570@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index f4c158e3a022..1f439a622076 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * LZO decompressor for the Linux kernel. Code borrowed from the lzo
  * implementation by Markus Franz Xaver Johannes Oberhumer.
@@ -10,21 +11,6 @@
  * Copyright (C) 1996-2005 Markus Franz Xaver Johannes Oberhumer
  * All Rights Reserved.
  *
- * lzop and the LZO library are free software; you can redistribute them
- * and/or modify them under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.
- * If not, write to the Free Software Foundation, Inc.,
- * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Markus F.X.J. Oberhumer
  * <markus@oberhumer.com>
  * http://www.oberhumer.com/opensource/lzop/

commit 2d3862d26e67a59340ba1cf1748196c76c5787de
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Sep 9 15:39:12 2015 -0700

    lib/decompressors: use real out buf size for gunzip with kernel
    
    When loading x86 64bit kernel above 4GiB with patched grub2, got kernel
    gunzip error.
    
    | early console in decompress_kernel
    | decompress_kernel:
    |       input: [0x807f2143b4-0x807ff61aee]
    |      output: [0x807cc00000-0x807f3ea29b] 0x027ea29c: output_len
    | boot via startup_64
    | KASLR using RDTSC...
    |  new output: [0x46fe000000-0x470138cfff] 0x0338d000: output_run_size
    |  decompress: [0x46fe000000-0x47007ea29b] <=== [0x807f2143b4-0x807ff61aee]
    |
    | Decompressing Linux... gz...
    |
    | uncompression error
    |
    | -- System halted
    
    the new buffer is at 0x46fe000000ULL, decompressor_gzip is using
    0xffffffb901ffffff as out_len.  gunzip in lib/zlib_inflate/inflate.c cap
    that len to 0x01ffffff and decompress fails later.
    
    We could hit this problem with crashkernel booting that uses kexec loading
    kernel above 4GiB.
    
    We have decompress_* support:
        1. inbuf[]/outbuf[] for kernel preboot.
        2. inbuf[]/flush() for initramfs
        3. fill()/flush() for initrd.
    This bug only affect kernel preboot path that use outbuf[].
    
    Add __decompress and take real out_buf_len for gunzip instead of guessing
    wrong buf size.
    
    Fixes: 1431574a1c4 (lib/decompressors: fix "no limit" output buffer length)
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Alexandre Courbot <acourbot@nvidia.com>
    Cc: Jon Medhurst <tixy@linaro.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index b94a31bdd87d..f4c158e3a022 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -31,6 +31,7 @@
  */
 
 #ifdef STATIC
+#define PREBOOT
 #include "lzo/lzo1x_decompress_safe.c"
 #else
 #include <linux/decompress/unlzo.h>
@@ -287,4 +288,14 @@ STATIC int INIT unlzo(u8 *input, long in_len,
 	return ret;
 }
 
-#define decompress unlzo
+#ifdef PREBOOT
+STATIC int INIT __decompress(unsigned char *buf, long len,
+			   long (*fill)(void*, unsigned long),
+			   long (*flush)(void*, unsigned long),
+			   unsigned char *out_buf, long olen,
+			   long *pos,
+			   void (*error)(char *x))
+{
+	return unlzo(buf, len, fill, flush, out_buf, pos, error);
+}
+#endif

commit d97b07c54f34e88352ebe676beb798c8f59ac588
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Aug 8 14:23:14 2014 -0700

    initramfs: support initramfs that is bigger than 2GiB
    
    Now with 64bit bzImage and kexec tools, we support ramdisk that size is
    bigger than 2g, as we could put it above 4G.
    
    Found compressed initramfs image could not be decompressed properly.  It
    turns out that image length is int during decompress detection, and it
    will become < 0 when length is more than 2G.  Furthermore, during
    decompressing len as int is used for inbuf count, that has problem too.
    
    Change len to long, that should be ok as on 32 bit platform long is
    32bits.
    
    Tested with following compressed initramfs image as root with kexec.
            gzip, bzip2, xz, lzma, lzop, lz4.
    run time for populate_rootfs():
       size        name       Nehalem-EX  Westmere-EX  Ivybridge-EX
     9034400256 root_img     :   26s           24s          30s
     3561095057 root_img.lz4 :   28s           27s          27s
     3459554629 root_img.lzo :   29s           29s          28s
     3219399480 root_img.gz  :   64s           62s          49s
     2251594592 root_img.xz  :  262s          260s         183s
     2226366598 root_img.lzma:  386s          376s         277s
     2901482513 root_img.bz2 :  635s          599s
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Rashika Kheria <rashika.kheria@gmail.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Kyungsik Lee <kyungsik.lee@lge.com>
    Cc: P J P <ppandit@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: "Daniel M. Weeks" <dan@danweeks.net>
    Cc: Alexandre Courbot <acourbot@nvidia.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 960183d4258f..b94a31bdd87d 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -51,7 +51,7 @@ static const unsigned char lzop_magic[] = {
 #define HEADER_SIZE_MIN       (9 + 7     + 4 + 8     + 1       + 4)
 #define HEADER_SIZE_MAX       (9 + 7 + 1 + 8 + 8 + 4 + 1 + 255 + 4)
 
-STATIC inline int INIT parse_header(u8 *input, int *skip, int in_len)
+STATIC inline long INIT parse_header(u8 *input, long *skip, long in_len)
 {
 	int l;
 	u8 *parse = input;
@@ -108,14 +108,14 @@ STATIC inline int INIT parse_header(u8 *input, int *skip, int in_len)
 	return 1;
 }
 
-STATIC inline int INIT unlzo(u8 *input, int in_len,
-				int (*fill) (void *, unsigned int),
-				int (*flush) (void *, unsigned int),
-				u8 *output, int *posp,
+STATIC int INIT unlzo(u8 *input, long in_len,
+				long (*fill)(void *, unsigned long),
+				long (*flush)(void *, unsigned long),
+				u8 *output, long *posp,
 				void (*error) (char *x))
 {
 	u8 r = 0;
-	int skip = 0;
+	long skip = 0;
 	u32 src_len, dst_len;
 	size_t tmp;
 	u8 *in_buf, *in_buf_save, *out_buf;

commit b6bec26cea948148a9420e7a0ac337f925de49e7
Author: Markus F.X.J. Oberhumer <markus@oberhumer.com>
Date:   Mon Aug 13 17:24:24 2012 +0200

    lib/lzo: Rename lzo1x_decompress.c to lzo1x_decompress_safe.c
    
    Rename the source file to match the function name and thereby
    also make room for a possible future even slightly faster
    "non-safe" decompressor version.
    
    Signed-off-by: Markus F.X.J. Oberhumer <markus@oberhumer.com>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 4531294fa62f..960183d4258f 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -31,7 +31,7 @@
  */
 
 #ifdef STATIC
-#include "lzo/lzo1x_decompress.c"
+#include "lzo/lzo1x_decompress_safe.c"
 #else
 #include <linux/decompress/unlzo.h>
 #endif

commit 35f1526845a9d804206883e19bd257d3dcef758f
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Jan 12 17:21:01 2012 -0800

    unlzo: fix input buffer free
    
    unlzo modifies the pointer to in_buf, so we have to free the original
    buffer, not the modified pointer.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Lasse Collin <lasse.collin@tukaani.org>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 5a7a2adf4c4c..4531294fa62f 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -279,7 +279,7 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	ret = 0;
 exit_2:
 	if (!input)
-		free(in_buf);
+		free(in_buf_save);
 exit_1:
 	if (!output)
 		free(out_buf);

commit fb7fa589fd3ecc212fabd7867a4ecc3b175260c1
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:21 2011 -0800

    Decompressors: fix callback-to-callback mode in decompress_unlzo.c
    
    Callback-to-callback decompression mode is used for initrd (not
    initramfs).  The LZO wrapper is broken for this use case for two reasons:
    
      - The argument validation is needlessly too strict by
        requiring that "posp" is non-NULL when "fill" is non-NULL.
    
      - The buffer handling code didn't work at all for this
        use case.
    
    I tested with LZO-compressed kernel, initramfs, initrd, and corrupt
    (truncated) initramfs and initrd images.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 7eb3b80bf022..5a7a2adf4c4c 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -139,8 +139,8 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 		goto exit_1;
 	} else if (input) {
 		in_buf = input;
-	} else if (!fill || !posp) {
-		error("NULL input pointer and missing position pointer or fill function");
+	} else if (!fill) {
+		error("NULL input pointer and missing fill function");
 		goto exit_1;
 	} else {
 		in_buf = malloc(lzo1x_worst_compress(LZO_BLOCK_SIZE));
@@ -154,21 +154,40 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	if (posp)
 		*posp = 0;
 
-	if (fill)
-		fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
+	if (fill) {
+		/*
+		 * Start from in_buf + HEADER_SIZE_MAX to make it possible
+		 * to use memcpy() to copy the unused data to the beginning
+		 * of the buffer. This way memmove() isn't needed which
+		 * is missing from pre-boot environments of most archs.
+		 */
+		in_buf += HEADER_SIZE_MAX;
+		in_len = fill(in_buf, HEADER_SIZE_MAX);
+	}
 
-	if (!parse_header(input, &skip, in_len)) {
+	if (!parse_header(in_buf, &skip, in_len)) {
 		error("invalid header");
 		goto exit_2;
 	}
 	in_buf += skip;
 	in_len -= skip;
 
+	if (fill) {
+		/* Move the unused data to the beginning of the buffer. */
+		memcpy(in_buf_save, in_buf, in_len);
+		in_buf = in_buf_save;
+	}
+
 	if (posp)
 		*posp = skip;
 
 	for (;;) {
 		/* read uncompressed block size */
+		if (fill && in_len < 4) {
+			skip = fill(in_buf + in_len, 4 - in_len);
+			if (skip > 0)
+				in_len += skip;
+		}
 		if (in_len < 4) {
 			error("file corrupted");
 			goto exit_2;
@@ -190,6 +209,11 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 		}
 
 		/* read compressed block size, and skip block checksum info */
+		if (fill && in_len < 8) {
+			skip = fill(in_buf + in_len, 8 - in_len);
+			if (skip > 0)
+				in_len += skip;
+		}
 		if (in_len < 8) {
 			error("file corrupted");
 			goto exit_2;
@@ -198,12 +222,21 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 		in_buf += 8;
 		in_len -= 8;
 
-		if (src_len <= 0 || src_len > dst_len || src_len > in_len) {
+		if (src_len <= 0 || src_len > dst_len) {
 			error("file corrupted");
 			goto exit_2;
 		}
 
 		/* decompress */
+		if (fill && in_len < src_len) {
+			skip = fill(in_buf + in_len, src_len - in_len);
+			if (skip > 0)
+				in_len += skip;
+		}
+		if (in_len < src_len) {
+			error("file corrupted");
+			goto exit_2;
+		}
 		tmp = dst_len;
 
 		/* When the input data is not compressed at all,
@@ -227,12 +260,19 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 			out_buf += dst_len;
 		if (posp)
 			*posp += src_len + 12;
+
+		in_buf += src_len;
+		in_len -= src_len;
 		if (fill) {
+			/*
+			 * If there happens to still be unused data left in
+			 * in_buf, move it to the beginning of the buffer.
+			 * Use a loop to avoid memmove() dependency.
+			 */
+			if (in_len > 0)
+				for (skip = 0; skip < in_len; ++skip)
+					in_buf_save[skip] = in_buf[skip];
 			in_buf = in_buf_save;
-			fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
-		} else {
-			in_buf += src_len;
-			in_len -= src_len;
 		}
 	}
 

commit 5a3f81a7029daff5f08aad146f4c4510e790da49
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:21 2011 -0800

    Decompressors: check input size in decompress_unlzo.c
    
    The code assumes that the input is valid and not truncated.  Add checks to
    avoid reading past the end of the input buffer.  Change the type of "skip"
    from u8 to int to fix a possible integer overflow.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 855d9d30ec45..7eb3b80bf022 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -48,14 +48,25 @@ static const unsigned char lzop_magic[] = {
 
 #define LZO_BLOCK_SIZE        (256*1024l)
 #define HEADER_HAS_FILTER      0x00000800L
+#define HEADER_SIZE_MIN       (9 + 7     + 4 + 8     + 1       + 4)
+#define HEADER_SIZE_MAX       (9 + 7 + 1 + 8 + 8 + 4 + 1 + 255 + 4)
 
-STATIC inline int INIT parse_header(u8 *input, u8 *skip)
+STATIC inline int INIT parse_header(u8 *input, int *skip, int in_len)
 {
 	int l;
 	u8 *parse = input;
+	u8 *end = input + in_len;
 	u8 level = 0;
 	u16 version;
 
+	/*
+	 * Check that there's enough input to possibly have a valid header.
+	 * Then it is possible to parse several fields until the minimum
+	 * size may have been used.
+	 */
+	if (in_len < HEADER_SIZE_MIN)
+		return 0;
+
 	/* read magic: 9 first bits */
 	for (l = 0; l < 9; l++) {
 		if (*parse++ != lzop_magic[l])
@@ -73,6 +84,15 @@ STATIC inline int INIT parse_header(u8 *input, u8 *skip)
 	else
 		parse += 4; /* flags */
 
+	/*
+	 * At least mode, mtime_low, filename length, and checksum must
+	 * be left to be parsed. If also mtime_high is present, it's OK
+	 * because the next input buffer check is after reading the
+	 * filename length.
+	 */
+	if (end - parse < 8 + 1 + 4)
+		return 0;
+
 	/* skip mode and mtime_low */
 	parse += 8;
 	if (version >= 0x0940)
@@ -80,6 +100,8 @@ STATIC inline int INIT parse_header(u8 *input, u8 *skip)
 
 	l = *parse++;
 	/* don't care about the file name, and skip checksum */
+	if (end - parse < l + 4)
+		return 0;
 	parse += l + 4;
 
 	*skip = parse - input;
@@ -92,7 +114,8 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 				u8 *output, int *posp,
 				void (*error) (char *x))
 {
-	u8 skip = 0, r = 0;
+	u8 r = 0;
+	int skip = 0;
 	u32 src_len, dst_len;
 	size_t tmp;
 	u8 *in_buf, *in_buf_save, *out_buf;
@@ -134,19 +157,25 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	if (fill)
 		fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
 
-	if (!parse_header(input, &skip)) {
+	if (!parse_header(input, &skip, in_len)) {
 		error("invalid header");
 		goto exit_2;
 	}
 	in_buf += skip;
+	in_len -= skip;
 
 	if (posp)
 		*posp = skip;
 
 	for (;;) {
 		/* read uncompressed block size */
+		if (in_len < 4) {
+			error("file corrupted");
+			goto exit_2;
+		}
 		dst_len = get_unaligned_be32(in_buf);
 		in_buf += 4;
+		in_len -= 4;
 
 		/* exit if last block */
 		if (dst_len == 0) {
@@ -161,10 +190,15 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 		}
 
 		/* read compressed block size, and skip block checksum info */
+		if (in_len < 8) {
+			error("file corrupted");
+			goto exit_2;
+		}
 		src_len = get_unaligned_be32(in_buf);
 		in_buf += 8;
+		in_len -= 8;
 
-		if (src_len <= 0 || src_len > dst_len) {
+		if (src_len <= 0 || src_len > dst_len || src_len > in_len) {
 			error("file corrupted");
 			goto exit_2;
 		}
@@ -196,8 +230,10 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 		if (fill) {
 			in_buf = in_buf_save;
 			fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
-		} else
+		} else {
 			in_buf += src_len;
+			in_len -= src_len;
+		}
 	}
 
 	ret = 0;

commit 8f9b54a35a70b604ebd2b2f2e7e04eabd0ff8a54
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:20 2011 -0800

    Decompressors: check for write errors in decompress_unlzo.c
    
    The return value of flush() is not checked in unlzo().  This means that
    the decompressor won't stop even if the caller doesn't want more data.
    This can happen e.g.  with a corrupt LZO-compressed initramfs image.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index 6e56d547ba32..855d9d30ec45 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -187,8 +187,8 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 			}
 		}
 
-		if (flush)
-			flush(out_buf, dst_len);
+		if (flush && flush(out_buf, dst_len) != dst_len)
+			goto exit_2;
 		if (output)
 			out_buf += dst_len;
 		if (posp)

commit 2b6b5caa6d05579bd1501006e34feec1b2aef8c4
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:15 2011 -0800

    Decompressors: include <linux/slab.h> in <linux/decompress/mm.h>
    
    Currently users of mm.h need to include <linux/slab.h> to use the macros
    malloc() and free() provided by mm.h.  This fixes it.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index df3e98f945a6..6e56d547ba32 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -33,7 +33,6 @@
 #ifdef STATIC
 #include "lzo/lzo1x_decompress.c"
 #else
-#include <linux/slab.h>
 #include <linux/decompress/unlzo.h>
 #endif
 

commit 93685ad247ef65b7d6f90ffe97b44f5cfeaf40d3
Author: Lasse Collin <lasse.collin@tukaani.org>
Date:   Wed Jan 12 17:01:14 2011 -0800

    Decompressors: get rid of set_error_fn() macro
    
    set_error_fn() has become a useless complication after c1e7c3ae59
    ("bzip2/lzma/gzip: pre-boot malloc doesn't return NULL on failure") fixed
    the use of error() in malloc().  Only decompress_unlzma.c had some use for
    it and that was easy to change too.
    
    This also gets rid of the static function pointer "error", which
    should have been marked as __initdata.
    
    Signed-off-by: Lasse Collin <lasse.collin@tukaani.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alain Knaff <alain@knaff.lu>
    Cc: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index bcb3a4bd68ff..df3e98f945a6 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -91,7 +91,7 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 				int (*fill) (void *, unsigned int),
 				int (*flush) (void *, unsigned int),
 				u8 *output, int *posp,
-				void (*error_fn) (char *x))
+				void (*error) (char *x))
 {
 	u8 skip = 0, r = 0;
 	u32 src_len, dst_len;
@@ -99,8 +99,6 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	u8 *in_buf, *in_buf_save, *out_buf;
 	int ret = -1;
 
-	set_error_fn(error_fn);
-
 	if (output) {
 		out_buf = output;
 	} else if (!flush) {

commit ccdb40048b2972f10bdc944913c0e0ee26b5d1f2
Author: Albin Tonnerre <albin.tonnerre@free-electrons.com>
Date:   Fri Apr 23 13:17:58 2010 -0400

    lib: fix the use of LZO to decompress initramfs images
    
    This patch fixes 2 issues with the LZO decompressor:
    
    - It doesn't handle the case where a block isn't compressed at all.  In
      this case, calling lzo1x_decompress_safe will fail, so we need to just
      use memcpy() instead (the upstream LZO code does something similar)
    
    - Since commit 54291362d2a5738e1b0495df2abcb9e6b0563a3f ("initramfs: add
      missing decompressor error check") , the decompressor return code is
      checked in the init/initramfs.c The LZO decompressor didn't return the
      expected value, causing the initramfs code to falsely believe a
      decompression error occured
    
    Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Tested-by: bert schulze <spambemyguest@googlemail.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
index db521f45626e..bcb3a4bd68ff 100644
--- a/lib/decompress_unlzo.c
+++ b/lib/decompress_unlzo.c
@@ -97,7 +97,7 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	u32 src_len, dst_len;
 	size_t tmp;
 	u8 *in_buf, *in_buf_save, *out_buf;
-	int obytes_processed = 0;
+	int ret = -1;
 
 	set_error_fn(error_fn);
 
@@ -174,15 +174,22 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 
 		/* decompress */
 		tmp = dst_len;
-		r = lzo1x_decompress_safe((u8 *) in_buf, src_len,
+
+		/* When the input data is not compressed at all,
+		 * lzo1x_decompress_safe will fail, so call memcpy()
+		 * instead */
+		if (unlikely(dst_len == src_len))
+			memcpy(out_buf, in_buf, src_len);
+		else {
+			r = lzo1x_decompress_safe((u8 *) in_buf, src_len,
 						out_buf, &tmp);
 
-		if (r != LZO_E_OK || dst_len != tmp) {
-			error("Compressed data violation");
-			goto exit_2;
+			if (r != LZO_E_OK || dst_len != tmp) {
+				error("Compressed data violation");
+				goto exit_2;
+			}
 		}
 
-		obytes_processed += dst_len;
 		if (flush)
 			flush(out_buf, dst_len);
 		if (output)
@@ -196,6 +203,7 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 			in_buf += src_len;
 	}
 
+	ret = 0;
 exit_2:
 	if (!input)
 		free(in_buf);
@@ -203,7 +211,7 @@ STATIC inline int INIT unlzo(u8 *input, int in_len,
 	if (!output)
 		free(out_buf);
 exit:
-	return obytes_processed;
+	return ret;
 }
 
 #define decompress unlzo

commit 7dd65feb6c603e13eba501c34c662259ab38e70e
Author: Albin Tonnerre <albin.tonnerre@free-electrons.com>
Date:   Fri Jan 8 14:42:42 2010 -0800

    lib: add support for LZO-compressed kernels
    
    This patch series adds generic support for creating and extracting
    LZO-compressed kernel images, as well as support for using such images on
    the x86 and ARM architectures, and support for creating and using
    LZO-compressed initrd and initramfs images.
    
    Russell King said:
    
    : Testing on a Cortex A9 model:
    : - lzo decompressor is 65% of the time gzip takes to decompress a kernel
    : - lzo kernel is 9% larger than a gzip kernel
    :
    : which I'm happy to say confirms your figures when comparing the two.
    :
    : However, when comparing your new gzip code to the old gzip code:
    : - new is 99% of the size of the old code
    : - new takes 42% of the time to decompress than the old code
    :
    : What this means is that for a proper comparison, the results get even better:
    : - lzo is 7.5% larger than the old gzip'd kernel image
    : - lzo takes 28% of the time that the old gzip code took
    :
    : So the expense seems definitely worth the effort.  The only reason I
    : can think of ever using gzip would be if you needed the additional
    : compression (eg, because you have limited flash to store the image.)
    :
    : I would argue that the default for ARM should therefore be LZO.
    
    This patch:
    
    The lzo compressor is worse than gzip at compression, but faster at
    extraction.  Here are some figures for an ARM board I'm working on:
    
    Uncompressed size: 3.24Mo
    gzip  1.61Mo 0.72s
    lzo   1.75Mo 0.48s
    
    So for a compression ratio that is still relatively close to gzip, it's
    much faster to extract, at least in that case.
    
    This part contains:
     - Makefile routine to support lzo compression
     - Fixes to the existing lzo compressor so that it can be used in
       compressed kernels
     - wrapper around the existing lzo1x_decompress, as it only extracts one
       block at a time, while we need to extract a whole file here
     - config dialog for kernel compression
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Tested-by: Wu Zhangjin <wuzhangjin@gmail.com>
    Acked-by: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Russell King <rmk@arm.linux.org.uk>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c
new file mode 100644
index 000000000000..db521f45626e
--- /dev/null
+++ b/lib/decompress_unlzo.c
@@ -0,0 +1,209 @@
+/*
+ * LZO decompressor for the Linux kernel. Code borrowed from the lzo
+ * implementation by Markus Franz Xaver Johannes Oberhumer.
+ *
+ * Linux kernel adaptation:
+ * Copyright (C) 2009
+ * Albin Tonnerre, Free Electrons <albin.tonnerre@free-electrons.com>
+ *
+ * Original code:
+ * Copyright (C) 1996-2005 Markus Franz Xaver Johannes Oberhumer
+ * All Rights Reserved.
+ *
+ * lzop and the LZO library are free software; you can redistribute them
+ * and/or modify them under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Markus F.X.J. Oberhumer
+ * <markus@oberhumer.com>
+ * http://www.oberhumer.com/opensource/lzop/
+ */
+
+#ifdef STATIC
+#include "lzo/lzo1x_decompress.c"
+#else
+#include <linux/slab.h>
+#include <linux/decompress/unlzo.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/lzo.h>
+#include <linux/decompress/mm.h>
+
+#include <linux/compiler.h>
+#include <asm/unaligned.h>
+
+static const unsigned char lzop_magic[] = {
+	0x89, 0x4c, 0x5a, 0x4f, 0x00, 0x0d, 0x0a, 0x1a, 0x0a };
+
+#define LZO_BLOCK_SIZE        (256*1024l)
+#define HEADER_HAS_FILTER      0x00000800L
+
+STATIC inline int INIT parse_header(u8 *input, u8 *skip)
+{
+	int l;
+	u8 *parse = input;
+	u8 level = 0;
+	u16 version;
+
+	/* read magic: 9 first bits */
+	for (l = 0; l < 9; l++) {
+		if (*parse++ != lzop_magic[l])
+			return 0;
+	}
+	/* get version (2bytes), skip library version (2),
+	 * 'need to be extracted' version (2) and
+	 * method (1) */
+	version = get_unaligned_be16(parse);
+	parse += 7;
+	if (version >= 0x0940)
+		level = *parse++;
+	if (get_unaligned_be32(parse) & HEADER_HAS_FILTER)
+		parse += 8; /* flags + filter info */
+	else
+		parse += 4; /* flags */
+
+	/* skip mode and mtime_low */
+	parse += 8;
+	if (version >= 0x0940)
+		parse += 4;	/* skip mtime_high */
+
+	l = *parse++;
+	/* don't care about the file name, and skip checksum */
+	parse += l + 4;
+
+	*skip = parse - input;
+	return 1;
+}
+
+STATIC inline int INIT unlzo(u8 *input, int in_len,
+				int (*fill) (void *, unsigned int),
+				int (*flush) (void *, unsigned int),
+				u8 *output, int *posp,
+				void (*error_fn) (char *x))
+{
+	u8 skip = 0, r = 0;
+	u32 src_len, dst_len;
+	size_t tmp;
+	u8 *in_buf, *in_buf_save, *out_buf;
+	int obytes_processed = 0;
+
+	set_error_fn(error_fn);
+
+	if (output) {
+		out_buf = output;
+	} else if (!flush) {
+		error("NULL output pointer and no flush function provided");
+		goto exit;
+	} else {
+		out_buf = malloc(LZO_BLOCK_SIZE);
+		if (!out_buf) {
+			error("Could not allocate output buffer");
+			goto exit;
+		}
+	}
+
+	if (input && fill) {
+		error("Both input pointer and fill function provided, don't know what to do");
+		goto exit_1;
+	} else if (input) {
+		in_buf = input;
+	} else if (!fill || !posp) {
+		error("NULL input pointer and missing position pointer or fill function");
+		goto exit_1;
+	} else {
+		in_buf = malloc(lzo1x_worst_compress(LZO_BLOCK_SIZE));
+		if (!in_buf) {
+			error("Could not allocate input buffer");
+			goto exit_1;
+		}
+	}
+	in_buf_save = in_buf;
+
+	if (posp)
+		*posp = 0;
+
+	if (fill)
+		fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
+
+	if (!parse_header(input, &skip)) {
+		error("invalid header");
+		goto exit_2;
+	}
+	in_buf += skip;
+
+	if (posp)
+		*posp = skip;
+
+	for (;;) {
+		/* read uncompressed block size */
+		dst_len = get_unaligned_be32(in_buf);
+		in_buf += 4;
+
+		/* exit if last block */
+		if (dst_len == 0) {
+			if (posp)
+				*posp += 4;
+			break;
+		}
+
+		if (dst_len > LZO_BLOCK_SIZE) {
+			error("dest len longer than block size");
+			goto exit_2;
+		}
+
+		/* read compressed block size, and skip block checksum info */
+		src_len = get_unaligned_be32(in_buf);
+		in_buf += 8;
+
+		if (src_len <= 0 || src_len > dst_len) {
+			error("file corrupted");
+			goto exit_2;
+		}
+
+		/* decompress */
+		tmp = dst_len;
+		r = lzo1x_decompress_safe((u8 *) in_buf, src_len,
+						out_buf, &tmp);
+
+		if (r != LZO_E_OK || dst_len != tmp) {
+			error("Compressed data violation");
+			goto exit_2;
+		}
+
+		obytes_processed += dst_len;
+		if (flush)
+			flush(out_buf, dst_len);
+		if (output)
+			out_buf += dst_len;
+		if (posp)
+			*posp += src_len + 12;
+		if (fill) {
+			in_buf = in_buf_save;
+			fill(in_buf, lzo1x_worst_compress(LZO_BLOCK_SIZE));
+		} else
+			in_buf += src_len;
+	}
+
+exit_2:
+	if (!input)
+		free(in_buf);
+exit_1:
+	if (!output)
+		free(out_buf);
+exit:
+	return obytes_processed;
+}
+
+#define decompress unlzo
