commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index d01f47135239..e01a93f46f83 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * ratelimit.c - Do something with rate limit.
  *
@@ -5,8 +6,6 @@
  *
  * 2008-05-01 rewrite the function and use a ratelimit_state data struct as
  * parameter. Now every user can use their own standalone ratelimit_state.
- *
- * This file is released under the GPLv2.
  */
 
 #include <linux/ratelimit.h>

commit 656d61ce9666209c4c4a13c71902d3ee70d1ff6f
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Tue Oct 3 16:16:45 2017 -0700

    lib/ratelimit.c: use deferred printk() version
    
    printk_ratelimit() invokes ___ratelimit() which may invoke a normal
    printk() (pr_warn() in this particular case) to warn about suppressed
    output.  Given that printk_ratelimit() may be called from anywhere, that
    pr_warn() is dangerous - it may end up deadlocking the system.  Fix
    ___ratelimit() by using deferred printk().
    
    Sasha reported the following lockdep error:
    
     : Unregister pv shared memory for cpu 8
     : select_fallback_rq: 3 callbacks suppressed
     : process 8583 (trinity-c78) no longer affine to cpu8
     :
     : ======================================================
     : WARNING: possible circular locking dependency detected
     : 4.14.0-rc2-next-20170927+ #252 Not tainted
     : ------------------------------------------------------
     : migration/8/62 is trying to acquire lock:
     : (&port_lock_key){-.-.}, at: serial8250_console_write()
     :
     : but task is already holding lock:
     : (&rq->lock){-.-.}, at: sched_cpu_dying()
     :
     : which lock already depends on the new lock.
     :
     :
     : the existing dependency chain (in reverse order) is:
     :
     : -> #3 (&rq->lock){-.-.}:
     : __lock_acquire()
     : lock_acquire()
     : _raw_spin_lock()
     : task_fork_fair()
     : sched_fork()
     : copy_process.part.31()
     : _do_fork()
     : kernel_thread()
     : rest_init()
     : start_kernel()
     : x86_64_start_reservations()
     : x86_64_start_kernel()
     : verify_cpu()
     :
     : -> #2 (&p->pi_lock){-.-.}:
     : __lock_acquire()
     : lock_acquire()
     : _raw_spin_lock_irqsave()
     : try_to_wake_up()
     : default_wake_function()
     : woken_wake_function()
     : __wake_up_common()
     : __wake_up_common_lock()
     : __wake_up()
     : tty_wakeup()
     : tty_port_default_wakeup()
     : tty_port_tty_wakeup()
     : uart_write_wakeup()
     : serial8250_tx_chars()
     : serial8250_handle_irq.part.25()
     : serial8250_default_handle_irq()
     : serial8250_interrupt()
     : __handle_irq_event_percpu()
     : handle_irq_event_percpu()
     : handle_irq_event()
     : handle_level_irq()
     : handle_irq()
     : do_IRQ()
     : ret_from_intr()
     : native_safe_halt()
     : default_idle()
     : arch_cpu_idle()
     : default_idle_call()
     : do_idle()
     : cpu_startup_entry()
     : rest_init()
     : start_kernel()
     : x86_64_start_reservations()
     : x86_64_start_kernel()
     : verify_cpu()
     :
     : -> #1 (&tty->write_wait){-.-.}:
     : __lock_acquire()
     : lock_acquire()
     : _raw_spin_lock_irqsave()
     : __wake_up_common_lock()
     : __wake_up()
     : tty_wakeup()
     : tty_port_default_wakeup()
     : tty_port_tty_wakeup()
     : uart_write_wakeup()
     : serial8250_tx_chars()
     : serial8250_handle_irq.part.25()
     : serial8250_default_handle_irq()
     : serial8250_interrupt()
     : __handle_irq_event_percpu()
     : handle_irq_event_percpu()
     : handle_irq_event()
     : handle_level_irq()
     : handle_irq()
     : do_IRQ()
     : ret_from_intr()
     : native_safe_halt()
     : default_idle()
     : arch_cpu_idle()
     : default_idle_call()
     : do_idle()
     : cpu_startup_entry()
     : rest_init()
     : start_kernel()
     : x86_64_start_reservations()
     : x86_64_start_kernel()
     : verify_cpu()
     :
     : -> #0 (&port_lock_key){-.-.}:
     : check_prev_add()
     : __lock_acquire()
     : lock_acquire()
     : _raw_spin_lock_irqsave()
     : serial8250_console_write()
     : univ8250_console_write()
     : console_unlock()
     : vprintk_emit()
     : vprintk_default()
     : vprintk_func()
     : printk()
     : ___ratelimit()
     : __printk_ratelimit()
     : select_fallback_rq()
     : sched_cpu_dying()
     : cpuhp_invoke_callback()
     : take_cpu_down()
     : multi_cpu_stop()
     : cpu_stopper_thread()
     : smpboot_thread_fn()
     : kthread()
     : ret_from_fork()
     :
     : other info that might help us debug this:
     :
     : Chain exists of:
     :   &port_lock_key --> &p->pi_lock --> &rq->lock
     :
     :  Possible unsafe locking scenario:
     :
     :        CPU0                    CPU1
     :        ----                    ----
     :   lock(&rq->lock);
     :                                lock(&p->pi_lock);
     :                                lock(&rq->lock);
     :   lock(&port_lock_key);
     :
     :  *** DEADLOCK ***
     :
     : 4 locks held by migration/8/62:
     : #0: (&p->pi_lock){-.-.}, at: sched_cpu_dying()
     : #1: (&rq->lock){-.-.}, at: sched_cpu_dying()
     : #2: (printk_ratelimit_state.lock){....}, at: ___ratelimit()
     : #3: (console_lock){+.+.}, at: vprintk_emit()
     :
     : stack backtrace:
     : CPU: 8 PID: 62 Comm: migration/8 Not tainted 4.14.0-rc2-next-20170927+ #252
     : Call Trace:
     : dump_stack()
     : print_circular_bug()
     : check_prev_add()
     : ? add_lock_to_list.isra.26()
     : ? check_usage()
     : ? kvm_clock_read()
     : ? kvm_sched_clock_read()
     : ? sched_clock()
     : ? check_preemption_disabled()
     : __lock_acquire()
     : ? __lock_acquire()
     : ? add_lock_to_list.isra.26()
     : ? debug_check_no_locks_freed()
     : ? memcpy()
     : lock_acquire()
     : ? serial8250_console_write()
     : _raw_spin_lock_irqsave()
     : ? serial8250_console_write()
     : serial8250_console_write()
     : ? serial8250_start_tx()
     : ? lock_acquire()
     : ? memcpy()
     : univ8250_console_write()
     : console_unlock()
     : ? __down_trylock_console_sem()
     : vprintk_emit()
     : vprintk_default()
     : vprintk_func()
     : printk()
     : ? show_regs_print_info()
     : ? lock_acquire()
     : ___ratelimit()
     : __printk_ratelimit()
     : select_fallback_rq()
     : sched_cpu_dying()
     : ? sched_cpu_starting()
     : ? rcutree_dying_cpu()
     : ? sched_cpu_starting()
     : cpuhp_invoke_callback()
     : ? cpu_disable_common()
     : take_cpu_down()
     : ? trace_hardirqs_off_caller()
     : ? cpuhp_invoke_callback()
     : multi_cpu_stop()
     : ? __this_cpu_preempt_check()
     : ? cpu_stop_queue_work()
     : cpu_stopper_thread()
     : ? cpu_stop_create()
     : smpboot_thread_fn()
     : ? sort_range()
     : ? schedule()
     : ? __kthread_parkme()
     : kthread()
     : ? sort_range()
     : ? kthread_create_on_node()
     : ret_from_fork()
     : process 9121 (trinity-c78) no longer affine to cpu8
     : smpboot: CPU 8 is now offline
    
    Link: http://lkml.kernel.org/r/20170928120405.18273-1-sergey.senozhatsky@gmail.com
    Fixes: 6b1d174b0c27b ("ratelimit: extend to print suppressed messages on release")
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 08f8043cac61..d01f47135239 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -48,7 +48,9 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 	if (time_is_before_jiffies(rs->begin + rs->interval)) {
 		if (rs->missed) {
 			if (!(rs->flags & RATELIMIT_MSG_ON_RELEASE)) {
-				pr_warn("%s: %d callbacks suppressed\n", func, rs->missed);
+				printk_deferred(KERN_WARNING
+						"%s: %d callbacks suppressed\n",
+						func, rs->missed);
 				rs->missed = 0;
 			}
 		}

commit 6b1d174b0c27b5de421eda55c2731f32b6bd9852
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Aug 2 14:04:04 2016 -0700

    ratelimit: extend to print suppressed messages on release
    
    Extend the ratelimiting facility to print the amount of suppressed lines
    when it is being released.
    
    This use case is aimed at short-termed, burst-like users for which we
    want to output the suppressed lines stats only once, after it has been
    disposed of.  For an example, see /dev/kmsg usage in a follow-on patch.
    
    Also, change the printk() line we issue on release to not use
    "callbacks" as it is misleading: we're not suppressing callbacks but
    printk() calls.
    
    This has been separated from a previous patch by Linus.
    
    Link: http://lkml.kernel.org/r/20160716061745.15795-2-bp@alien8.de
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Franck Bui <fbui@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 2c5de86460c5..08f8043cac61 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -46,12 +46,14 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 		rs->begin = jiffies;
 
 	if (time_is_before_jiffies(rs->begin + rs->interval)) {
-		if (rs->missed)
-			printk(KERN_WARNING "%s: %d callbacks suppressed\n",
-				func, rs->missed);
+		if (rs->missed) {
+			if (!(rs->flags & RATELIMIT_MSG_ON_RELEASE)) {
+				pr_warn("%s: %d callbacks suppressed\n", func, rs->missed);
+				rs->missed = 0;
+			}
+		}
 		rs->begin   = jiffies;
 		rs->printed = 0;
-		rs->missed  = 0;
 	}
 	if (rs->burst && rs->burst > rs->printed) {
 		rs->printed++;

commit c2594bc37f4464bc74f2c119eb3269a643400aa0
Author: Jaewon Kim <jaewon31.kim@samsung.com>
Date:   Thu Jan 21 16:55:07 2016 -0800

    ratelimit: fix bug in time interval by resetting right begin time
    
    rs->begin in ratelimit is set in two cases.
     1) when rs->begin was not initialized
     2) when rs->interval was passed
    
    For case #2, current ratelimit sets the begin to 0.  This incurrs
    improper suppression.  The begin value will be set in the next ratelimit
    call by 1).  Then the time interval check will be always false, and
    rs->printed will not be initialized.  Although enough time passed,
    ratelimit may return 0 if rs->printed is not less than rs->burst.  To
    reset interval properly, begin should be jiffies rather than 0.
    
    For an example code below:
    
        static DEFINE_RATELIMIT_STATE(mylimit, 1, 1);
        for (i = 1; i <= 10; i++) {
            if (__ratelimit(&mylimit))
                printk("ratelimit test count %d\n", i);
            msleep(3000);
        }
    
    test result in the current code shows suppression even there is 3 seconds sleep.
    
      [  78.391148] ratelimit test count 1
      [  81.295988] ratelimit test count 2
      [  87.315981] ratelimit test count 4
      [  93.336267] ratelimit test count 6
      [  99.356031] ratelimit test count 8
      [ 105.376367] ratelimit test count 10
    
    Signed-off-by: Jaewon Kim <jaewon31.kim@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 40e03ea2a967..2c5de86460c5 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -49,7 +49,7 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 		if (rs->missed)
 			printk(KERN_WARNING "%s: %d callbacks suppressed\n",
 				func, rs->missed);
-		rs->begin   = 0;
+		rs->begin   = jiffies;
 		rs->printed = 0;
 		rs->missed  = 0;
 	}

commit 8bc3bcc93a2b4e47d5d410146f6546bca6171663
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 16 21:29:17 2011 -0500

    lib: reduce the use of module.h wherever possible
    
    For files only using THIS_MODULE and/or EXPORT_SYMBOL, map
    them onto including export.h -- or if the file isn't even
    using those, then just delete the include.  Fix up any implicit
    include dependencies that were being masked by module.h along
    the way.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index c96d500577de..40e03ea2a967 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -11,7 +11,7 @@
 
 #include <linux/ratelimit.h>
 #include <linux/jiffies.h>
-#include <linux/module.h>
+#include <linux/export.h>
 
 /*
  * __ratelimit - rate limiting

commit 07354eb1a74d1e1ece29f8bafe0b46e8c77a95ef
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 25 17:50:36 2009 +0200

    locking, printk: Annotate logbuf_lock as raw
    
    The logbuf_lock lock can be taken in atomic context and therefore
    cannot be preempted on -rt - annotate it.
    
    In mainline this change documents the low level nature of
    the lock - otherwise there's no functional difference. Lockdep
    and Sparse checking will work as usual.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ merged and fixed it ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 027a03f4c56d..c96d500577de 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -39,7 +39,7 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 	 * in addition to the one that will be printed by
 	 * the entity that is holding the lock already:
 	 */
-	if (!spin_trylock_irqsave(&rs->lock, flags))
+	if (!raw_spin_trylock_irqsave(&rs->lock, flags))
 		return 0;
 
 	if (!rs->begin)
@@ -60,7 +60,7 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 		rs->missed++;
 		ret = 0;
 	}
-	spin_unlock_irqrestore(&rs->lock, flags);
+	raw_spin_unlock_irqrestore(&rs->lock, flags);
 
 	return ret;
 }

commit 57119c34e53bbb8d244c3ff1335ef5145768538f
Author: Yong Zhang <yong.zhang@windriver.com>
Date:   Tue Apr 6 14:35:03 2010 -0700

    ratelimit: fix the return value when __ratelimit() fails to acquire the lock
    
    The log of commit edaac8e3167501cda336231d00611bf59c164346 ("ratelimit:
    Fix/allow use in atomic contexts"), indicates that we want to suppress the
    callback when the trylock fails.
    
    Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index b4cd24ff9b29..027a03f4c56d 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -40,7 +40,7 @@ int ___ratelimit(struct ratelimit_state *rs, const char *func)
 	 * the entity that is holding the lock already:
 	 */
 	if (!spin_trylock_irqsave(&rs->lock, flags))
-		return 1;
+		return 0;
 
 	if (!rs->begin)
 		rs->begin = jiffies;

commit 2a7268abc48c8009b284bd88605d14fcb65772ec
Author: Yong Zhang <yong.zhang@windriver.com>
Date:   Tue Apr 6 14:35:01 2010 -0700

    ratelimit: annotate ___ratelimit()
    
    To prevent from wrongly using the return value.
    
    [akpm@linux-foundation.org: fix spello]
    Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 09f5ce1810dc..b4cd24ff9b29 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -16,9 +16,14 @@
 /*
  * __ratelimit - rate limiting
  * @rs: ratelimit_state data
+ * @func: name of calling function
  *
- * This enforces a rate limit: not more than @rs->ratelimit_burst callbacks
- * in every @rs->ratelimit_jiffies
+ * This enforces a rate limit: not more than @rs->burst callbacks
+ * in every @rs->interval
+ *
+ * RETURNS:
+ * 0 means callbacks will be suppressed.
+ * 1 means go ahead and do it.
  */
 int ___ratelimit(struct ratelimit_state *rs, const char *func)
 {

commit 5c828713358cb9df8aa174371edcbbb62203a490
Author: Christian Borntraeger <borntraeger@de.ibm.com>
Date:   Fri Oct 23 14:58:11 2009 +0200

    ratelimit: Make suppressed output messages more useful
    
    Today I got:
    
      [39648.224782] Registered led device: iwl-phy0::TX
      [40676.545099] __ratelimit: 246 callbacks suppressed
      [40676.545103] abcdef[23675]: segfault at 0 ...
    
    as you can see the ratelimit message contains a function prefix.
    Since this is always __ratelimit, this wont help much.
    
    This patch changes __ratelimit and printk_ratelimit to print the
    function name that calls ratelimit.
    
    This will pinpoint the responsible function, as long as not several
    different places call ratelimit with the same ratelimit state at
    the same time. In that case we catch only one random function that
    calls ratelimit after the wait period.
    
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    CC: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <200910231458.11832.borntraeger@de.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 5551731ae1d4..09f5ce1810dc 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -20,7 +20,7 @@
  * This enforces a rate limit: not more than @rs->ratelimit_burst callbacks
  * in every @rs->ratelimit_jiffies
  */
-int __ratelimit(struct ratelimit_state *rs)
+int ___ratelimit(struct ratelimit_state *rs, const char *func)
 {
 	unsigned long flags;
 	int ret;
@@ -43,7 +43,7 @@ int __ratelimit(struct ratelimit_state *rs)
 	if (time_is_before_jiffies(rs->begin + rs->interval)) {
 		if (rs->missed)
 			printk(KERN_WARNING "%s: %d callbacks suppressed\n",
-				__func__, rs->missed);
+				func, rs->missed);
 		rs->begin   = 0;
 		rs->printed = 0;
 		rs->missed  = 0;
@@ -59,4 +59,4 @@ int __ratelimit(struct ratelimit_state *rs)
 
 	return ret;
 }
-EXPORT_SYMBOL(__ratelimit);
+EXPORT_SYMBOL(___ratelimit);

commit 3fff4c42bd0a89869a0eb1e7874cc06ffa4aa0f5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Sep 22 16:18:09 2009 +0200

    printk: Remove ratelimit.h from kernel.h
    
    Decouple kernel.h from ratelimit.h: the global declaration of
    printk's ratelimit_state is not needed, and it leads to messy
    circular dependencies due to ratelimit.h's (new) adding of a
    spinlock_types.h include.
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: David S. Miller <davem@davemloft.net>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 69bfcacda16d..5551731ae1d4 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -9,7 +9,7 @@
  * This file is released under the GPLv2.
  */
 
-#include <linux/kernel.h>
+#include <linux/ratelimit.h>
 #include <linux/jiffies.h>
 #include <linux/module.h>
 

commit edaac8e3167501cda336231d00611bf59c164346
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Sep 22 14:44:11 2009 +0200

    ratelimit: Fix/allow use in atomic contexts
    
    I'd like to use printk_ratelimit() in NMI context, but it's not
    robust right now due to spinlock usage in lib/ratelimit.c. If an
    NMI is unlucky enough to hit just that spot we might lock up trying
    to take the spinlock again.
    
    Fix that by using a trylock variant. If we contend on that lock we
    can genuinely skip the message because the state is just being
    accessed by another CPU (or by this CPU).
    
    ( We could use atomics for the suppressed messages field, but
      i doubt it matters in practice and it makes the code heavier. )
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: David S. Miller <davem@davemloft.net>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 0e2c28e8a0ca..69bfcacda16d 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -28,7 +28,15 @@ int __ratelimit(struct ratelimit_state *rs)
 	if (!rs->interval)
 		return 1;
 
-	spin_lock_irqsave(&rs->lock, flags);
+	/*
+	 * If we contend on this state's lock then almost
+	 * by definition we are too busy to print a message,
+	 * in addition to the one that will be printed by
+	 * the entity that is holding the lock already:
+	 */
+	if (!spin_trylock_irqsave(&rs->lock, flags))
+		return 1;
+
 	if (!rs->begin)
 		rs->begin = jiffies;
 

commit 979f693def9084a452846365dfde5dcb28366333
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Sep 22 14:44:11 2009 +0200

    ratelimit: Use per ratelimit context locking
    
    I'd like to use printk_ratelimit() in atomic context, but that's
    not possible right now due to the spinlock usage this commit
    introduced more than a year ago:
    
      717115e: printk ratelimiting rewrite
    
    As a first step push the lock into the ratelimit state structure.
    This allows us to deal with locking failures to be considered as an
    event related to that state being too busy.
    
    Also clean up the code a bit (without changing functionality):
    
     - tidy up the definitions
    
     - clean up the code flow
    
    This also shrinks the code a tiny bit:
    
       text    data     bss     dec     hex filename
        264       0       4     268     10c ratelimit.o.before
        255       0       0     255      ff ratelimit.o.after
    
    ( Whole-kernel data size got a bit larger, because we have
      two ratelimit-state data structures right now. )
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: David S. Miller <davem@davemloft.net>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 26187edcc7ea..0e2c28e8a0ca 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -7,15 +7,12 @@
  * parameter. Now every user can use their own standalone ratelimit_state.
  *
  * This file is released under the GPLv2.
- *
  */
 
 #include <linux/kernel.h>
 #include <linux/jiffies.h>
 #include <linux/module.h>
 
-static DEFINE_SPINLOCK(ratelimit_lock);
-
 /*
  * __ratelimit - rate limiting
  * @rs: ratelimit_state data
@@ -26,11 +23,12 @@ static DEFINE_SPINLOCK(ratelimit_lock);
 int __ratelimit(struct ratelimit_state *rs)
 {
 	unsigned long flags;
+	int ret;
 
 	if (!rs->interval)
 		return 1;
 
-	spin_lock_irqsave(&ratelimit_lock, flags);
+	spin_lock_irqsave(&rs->lock, flags);
 	if (!rs->begin)
 		rs->begin = jiffies;
 
@@ -38,20 +36,19 @@ int __ratelimit(struct ratelimit_state *rs)
 		if (rs->missed)
 			printk(KERN_WARNING "%s: %d callbacks suppressed\n",
 				__func__, rs->missed);
-		rs->begin = 0;
+		rs->begin   = 0;
 		rs->printed = 0;
-		rs->missed = 0;
+		rs->missed  = 0;
 	}
-	if (rs->burst && rs->burst > rs->printed)
-		goto print;
-
-	rs->missed++;
-	spin_unlock_irqrestore(&ratelimit_lock, flags);
-	return 0;
+	if (rs->burst && rs->burst > rs->printed) {
+		rs->printed++;
+		ret = 1;
+	} else {
+		rs->missed++;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&rs->lock, flags);
 
-print:
-	rs->printed++;
-	spin_unlock_irqrestore(&ratelimit_lock, flags);
-	return 1;
+	return ret;
 }
 EXPORT_SYMBOL(__ratelimit);

commit 4d9c377c81d37740b25cacf025f95c084eafabbb
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jul 28 15:46:21 2008 -0700

    __ratelimit() cpu flags can't be static
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 35136671b215..26187edcc7ea 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -15,7 +15,6 @@
 #include <linux/module.h>
 
 static DEFINE_SPINLOCK(ratelimit_lock);
-static unsigned long flags;
 
 /*
  * __ratelimit - rate limiting
@@ -26,6 +25,8 @@ static unsigned long flags;
  */
 int __ratelimit(struct ratelimit_state *rs)
 {
+	unsigned long flags;
+
 	if (!rs->interval)
 		return 1;
 

commit 717115e1a5856b57af0f71e1df7149108294fc10
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Fri Jul 25 01:45:58 2008 -0700

    printk ratelimiting rewrite
    
    All ratelimit user use same jiffies and burst params, so some messages
    (callbacks) will be lost.
    
    For example:
    a call printk_ratelimit(5 * HZ, 1)
    b call printk_ratelimit(5 * HZ, 1) before the 5*HZ timeout of a, then b will
    will be supressed.
    
    - rewrite __ratelimit, and use a ratelimit_state as parameter.  Thanks for
      hints from andrew.
    
    - Add WARN_ON_RATELIMIT, update rcupreempt.h
    
    - remove __printk_ratelimit
    
    - use __ratelimit in net_ratelimit
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
index 485e3040dcd4..35136671b215 100644
--- a/lib/ratelimit.c
+++ b/lib/ratelimit.c
@@ -3,6 +3,9 @@
  *
  * Isolated from kernel/printk.c by Dave Young <hidave.darkstar@gmail.com>
  *
+ * 2008-05-01 rewrite the function and use a ratelimit_state data struct as
+ * parameter. Now every user can use their own standalone ratelimit_state.
+ *
  * This file is released under the GPLv2.
  *
  */
@@ -11,41 +14,43 @@
 #include <linux/jiffies.h>
 #include <linux/module.h>
 
+static DEFINE_SPINLOCK(ratelimit_lock);
+static unsigned long flags;
+
 /*
  * __ratelimit - rate limiting
- * @ratelimit_jiffies: minimum time in jiffies between two callbacks
- * @ratelimit_burst: number of callbacks we do before ratelimiting
+ * @rs: ratelimit_state data
  *
- * This enforces a rate limit: not more than @ratelimit_burst callbacks
- * in every ratelimit_jiffies
+ * This enforces a rate limit: not more than @rs->ratelimit_burst callbacks
+ * in every @rs->ratelimit_jiffies
  */
-int __ratelimit(int ratelimit_jiffies, int ratelimit_burst)
+int __ratelimit(struct ratelimit_state *rs)
 {
-	static DEFINE_SPINLOCK(ratelimit_lock);
-	static unsigned toks = 10 * 5 * HZ;
-	static unsigned long last_msg;
-	static int missed;
-	unsigned long flags;
-	unsigned long now = jiffies;
+	if (!rs->interval)
+		return 1;
 
 	spin_lock_irqsave(&ratelimit_lock, flags);
-	toks += now - last_msg;
-	last_msg = now;
-	if (toks > (ratelimit_burst * ratelimit_jiffies))
-		toks = ratelimit_burst * ratelimit_jiffies;
-	if (toks >= ratelimit_jiffies) {
-		int lost = missed;
+	if (!rs->begin)
+		rs->begin = jiffies;
 
-		missed = 0;
-		toks -= ratelimit_jiffies;
-		spin_unlock_irqrestore(&ratelimit_lock, flags);
-		if (lost)
-			printk(KERN_WARNING "%s: %d messages suppressed\n",
-				__func__, lost);
-		return 1;
+	if (time_is_before_jiffies(rs->begin + rs->interval)) {
+		if (rs->missed)
+			printk(KERN_WARNING "%s: %d callbacks suppressed\n",
+				__func__, rs->missed);
+		rs->begin = 0;
+		rs->printed = 0;
+		rs->missed = 0;
 	}
-	missed++;
+	if (rs->burst && rs->burst > rs->printed)
+		goto print;
+
+	rs->missed++;
 	spin_unlock_irqrestore(&ratelimit_lock, flags);
 	return 0;
+
+print:
+	rs->printed++;
+	spin_unlock_irqrestore(&ratelimit_lock, flags);
+	return 1;
 }
 EXPORT_SYMBOL(__ratelimit);

commit 5f97a5a8799b8d7d0afdb9d68a50a4e0e8298a05
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Tue Apr 29 00:59:43 2008 -0700

    isolate ratelimit from printk.c for other use
    
    Due to the rcupreempt.h WARN_ON trigged, I got 2G syslog file.  For some
    serious complaining of kernel, we need repeat the warnings, so here I isolate
    the ratelimit part of printk.c to a standalone file.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/ratelimit.c b/lib/ratelimit.c
new file mode 100644
index 000000000000..485e3040dcd4
--- /dev/null
+++ b/lib/ratelimit.c
@@ -0,0 +1,51 @@
+/*
+ * ratelimit.c - Do something with rate limit.
+ *
+ * Isolated from kernel/printk.c by Dave Young <hidave.darkstar@gmail.com>
+ *
+ * This file is released under the GPLv2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+
+/*
+ * __ratelimit - rate limiting
+ * @ratelimit_jiffies: minimum time in jiffies between two callbacks
+ * @ratelimit_burst: number of callbacks we do before ratelimiting
+ *
+ * This enforces a rate limit: not more than @ratelimit_burst callbacks
+ * in every ratelimit_jiffies
+ */
+int __ratelimit(int ratelimit_jiffies, int ratelimit_burst)
+{
+	static DEFINE_SPINLOCK(ratelimit_lock);
+	static unsigned toks = 10 * 5 * HZ;
+	static unsigned long last_msg;
+	static int missed;
+	unsigned long flags;
+	unsigned long now = jiffies;
+
+	spin_lock_irqsave(&ratelimit_lock, flags);
+	toks += now - last_msg;
+	last_msg = now;
+	if (toks > (ratelimit_burst * ratelimit_jiffies))
+		toks = ratelimit_burst * ratelimit_jiffies;
+	if (toks >= ratelimit_jiffies) {
+		int lost = missed;
+
+		missed = 0;
+		toks -= ratelimit_jiffies;
+		spin_unlock_irqrestore(&ratelimit_lock, flags);
+		if (lost)
+			printk(KERN_WARNING "%s: %d messages suppressed\n",
+				__func__, lost);
+		return 1;
+	}
+	missed++;
+	spin_unlock_irqrestore(&ratelimit_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(__ratelimit);
