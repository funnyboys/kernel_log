commit 991305dee585dd9e3107b2e253778ed02ee3fbd1
Author: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
Date:   Thu Jun 20 17:10:39 2019 +0300

    rslib: Fix remaining decoder flaws
    
    The decoder is flawed in the following ways:
    
    - The decoder sometimes fails silently, i.e. it announces success but
      returns a word that is not a codeword.
    
    - The return value of the decoder is incoherent with respect to how
      fixed erasures are counted. If the word to be decoded is a codeword,
      then the decoder always returns zero even if some erasures are given.
      On the other hand, if the word to be decoded contains errors, then the
      number of erasures is always included in the count of corrected
      symbols. So the decoder handles erasures without symbol corruption
      inconsistently. This inconsistency probably doesn't affect anyone
      using the decoder, but it is inconsistent with the documentation.
    
    - The error positions returned in eras_pos include all erasures, but the
      corrections are only set in the correction buffer if there actually is
      a symbol error. So if there are erasures without symbol corruption,
      then the correction buffer will contain errors (unless initialized to
      zero before calling the decoder) or some values will be unset (if the
      correction buffer is uninitialized).
    
    - When correcting data in-place the decoder does not correct errors in
      the parity. On the other hand, when returning the errors in correction
      buffers, errors in the parity are included.
    
    The respective fixed are:
    
    - The syndrome of a codeword is always zero, and the syndrome is linear,
      .i.e, S(x+e) = S(x) + S(e). So compute the syndrome for the error and
      check whether it equals the syndrome of the received word. If it does,
      then we have decoded to a valid codeword, otherwise we know that we
      have an uncorrectable error. Fortunately, some unrecoverable error
      conditions can be detected earlier in the decoding, which saves some
      processing power.
    
    - Simply count and return the number of symbols actually corrected.
    
    - Make sure to only return positions where symbols were corrected.
    
    - Also fix errors in parity when correcting in-place. Another option
      would be to completely disregard errors in the parity, but then the
      interface makes it impossible to write tests that test for silent
      failures.
    
    Other changes:
    
    - Only fill the correction buffer and error position buffer if both of
      them are provided. Otherwise correct in place. Previously the error
      position buffer was always populated with the positions of the
      corrected errors, irrespective of whether a correction buffer was
      supplied or not. The rationale for this change is that there seems to
      be two use cases for the decoder; correct in-place or use the
      correction buffers. The caller does not need the positions of the
      corrected errors when in-place correction is used. If in-place
      correction is not used, then both the correction buffer and error
      position buffer need to be populated.
    
    Signed-off-by: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190620141039.9874-8-ferdinand.blomqvist@gmail.com

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index b7264a712d46..805de84ae83d 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -22,6 +22,7 @@
 	uint16_t *index_of = rs->index_of;
 	uint16_t u, q, tmp, num1, num2, den, discr_r, syn_error;
 	int count = 0;
+	int num_corrected;
 	uint16_t msk = (uint16_t) rs->nn;
 
 	/*
@@ -184,6 +185,15 @@
 		if (lambda[i] != nn)
 			deg_lambda = i;
 	}
+
+	if (deg_lambda == 0) {
+		/*
+		 * deg(lambda) is zero even though the syndrome is non-zero
+		 * => uncorrectable error detected
+		 */
+		return -EBADMSG;
+	}
+
 	/* Find roots of error+erasure locator polynomial by Chien search */
 	memcpy(&reg[1], &lambda[1], nroots * sizeof(reg[0]));
 	count = 0;		/* Number of roots of lambda(x) */
@@ -197,6 +207,12 @@
 		}
 		if (q != 0)
 			continue;	/* Not a root */
+
+		if (k < pad) {
+			/* Impossible error location. Uncorrectable error. */
+			return -EBADMSG;
+		}
+
 		/* store root (index-form) and error location number */
 		root[count] = i;
 		loc[count] = k;
@@ -231,7 +247,9 @@
 	/*
 	 * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
 	 * inv(X(l))**(fcr-1) and den = lambda_pr(inv(X(l))) all in poly-form
+	 * Note: we reuse the buffer for b to store the correction pattern
 	 */
+	num_corrected = 0;
 	for (j = count - 1; j >= 0; j--) {
 		num1 = 0;
 		for (i = deg_omega; i >= 0; i--) {
@@ -239,6 +257,13 @@
 				num1 ^= alpha_to[rs_modnn(rs, omega[i] +
 							i * root[j])];
 		}
+
+		if (num1 == 0) {
+			/* Nothing to correct at this position */
+			b[j] = 0;
+			continue;
+		}
+
 		num2 = alpha_to[rs_modnn(rs, root[j] * (fcr - 1) + nn)];
 		den = 0;
 
@@ -250,29 +275,52 @@
 						       i * root[j])];
 			}
 		}
-		/* Apply error to data */
-		if (num1 != 0 && loc[j] >= pad) {
-			uint16_t cor = alpha_to[rs_modnn(rs,index_of[num1] +
-						       index_of[num2] +
-						       nn - index_of[den])];
-			/* Store the error correction pattern, if a
-			 * correction buffer is available */
-			if (corr) {
-				corr[j] = cor;
-			} else {
-				/* If a data buffer is given and the
-				 * error is inside the message,
-				 * correct it */
-				if (data && (loc[j] < (nn - nroots)))
-					data[loc[j] - pad] ^= cor;
-			}
+
+		b[j] = alpha_to[rs_modnn(rs, index_of[num1] +
+					       index_of[num2] +
+					       nn - index_of[den])];
+		num_corrected++;
+	}
+
+	/*
+	 * We compute the syndrome of the 'error' and check that it matches
+	 * the syndrome of the received word
+	 */
+	for (i = 0; i < nroots; i++) {
+		tmp = 0;
+		for (j = 0; j < count; j++) {
+			if (b[j] == 0)
+				continue;
+
+			k = (fcr + i) * prim * (nn-loc[j]-1);
+			tmp ^= alpha_to[rs_modnn(rs, index_of[b[j]] + k)];
 		}
+
+		if (tmp != alpha_to[s[i]])
+			return -EBADMSG;
 	}
 
-	if (eras_pos != NULL) {
-		for (i = 0; i < count; i++)
-			eras_pos[i] = loc[i] - pad;
+	/*
+	 * Store the error correction pattern, if a
+	 * correction buffer is available
+	 */
+	if (corr && eras_pos) {
+		j = 0;
+		for (i = 0; i < count; i++) {
+			if (b[i]) {
+				corr[j] = b[i];
+				eras_pos[j++] = loc[i] - pad;
+			}
+		}
+	} else if (data && par) {
+		/* Apply error to data and parity */
+		for (i = 0; i < count; i++) {
+			if (loc[i] < (nn - nroots))
+				data[loc[i] - pad] ^= b[i];
+			else
+				par[loc[i] - pad - len] ^= b[i];
+		}
 	}
-	return count;
 
+	return  num_corrected;
 }

commit ef4d6a8556b637ad27c8c2a2cff1dda3da38e9a9
Author: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
Date:   Thu Jun 20 17:10:37 2019 +0300

    rslib: Fix handling of of caller provided syndrome
    
    Check if the syndrome provided by the caller is zero, and act
    accordingly.
    
    Signed-off-by: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190620141039.9874-6-ferdinand.blomqvist@gmail.com

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 78629bbe6590..b7264a712d46 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -42,8 +42,18 @@
 	BUG_ON(pad < 0 || pad >= nn - nroots);
 
 	/* Does the caller provide the syndrome ? */
-	if (s != NULL)
-		goto decode;
+	if (s != NULL) {
+		for (i = 0; i < nroots; i++) {
+			/* The syndrome is in index form,
+			 * so nn represents zero
+			 */
+			if (s[i] != nn)
+				goto decode;
+		}
+
+		/* syndrome is zero, no errors to correct  */
+		return 0;
+	}
 
 	/* form the syndromes; i.e., evaluate data(x) at roots of
 	 * g(x) */

commit 647cc9ece63fdba573a31bdafa54fb2d388c3c83
Author: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
Date:   Thu Jun 20 17:10:36 2019 +0300

    rslib: decode_rs: Code cleanup
    
    Nothing useful was done after the finish label when count is negative so
    return directly instead of jumping to finish.
    
    Signed-off-by: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190620141039.9874-5-ferdinand.blomqvist@gmail.com

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 22006eaa41e6..78629bbe6590 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -88,8 +88,7 @@
 		/* if syndrome is zero, data[] is a codeword and there are no
 		 * errors to correct. So return data[] unmodified
 		 */
-		count = 0;
-		goto finish;
+		return 0;
 	}
 
  decode:
@@ -202,8 +201,7 @@
 		 * deg(lambda) unequal to number of roots => uncorrectable
 		 * error detected
 		 */
-		count = -EBADMSG;
-		goto finish;
+		return -EBADMSG;
 	}
 	/*
 	 * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
@@ -261,7 +259,6 @@
 		}
 	}
 
-finish:
 	if (eras_pos != NULL) {
 		for (i = 0; i < count; i++)
 			eras_pos[i] = loc[i] - pad;

commit a343536f8f482be6932803a023f46d0fa723ae56
Author: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
Date:   Thu Jun 20 17:10:35 2019 +0300

    rslib: decode_rs: Fix length parameter check
    
    The length of the data load must be at least one. Or in other words,
    there must be room for at least 1 data and nroots parity symbols after
    shortening the RS code.
    
    Signed-off-by: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190620141039.9874-4-ferdinand.blomqvist@gmail.com

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 3313bf944ff1..22006eaa41e6 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -39,7 +39,7 @@
 
 	/* Check length parameter for validity */
 	pad = nn - nroots - len;
-	BUG_ON(pad < 0 || pad >= nn);
+	BUG_ON(pad < 0 || pad >= nn - nroots);
 
 	/* Does the caller provide the syndrome ? */
 	if (s != NULL)

commit 2034a42d1747fc1e1eeef2c6f1789c4d0762cb9c
Author: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
Date:   Thu Jun 20 17:10:34 2019 +0300

    rslib: Fix decoding of shortened codes
    
    The decoding of shortenend codes is broken. It only works as expected if
    there are no erasures.
    
    When decoding with erasures, Lambda (the error and erasure locator
    polynomial) is initialized from the given erasure positions. The pad
    parameter is not accounted for by the initialisation code, and hence
    Lambda is initialized from incorrect erasure positions.
    
    The fix is to adjust the erasure positions by the supplied pad.
    
    Signed-off-by: Ferdinand Blomqvist <ferdinand.blomqvist@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190620141039.9874-3-ferdinand.blomqvist@gmail.com

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 1db74eb098d0..3313bf944ff1 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -99,9 +99,9 @@
 	if (no_eras > 0) {
 		/* Init lambda to be the erasure locator polynomial */
 		lambda[1] = alpha_to[rs_modnn(rs,
-					      prim * (nn - 1 - eras_pos[0]))];
+					prim * (nn - 1 - (eras_pos[0] + pad)))];
 		for (i = 1; i < no_eras; i++) {
-			u = rs_modnn(rs, prim * (nn - 1 - eras_pos[i]));
+			u = rs_modnn(rs, prim * (nn - 1 - (eras_pos[i] + pad)));
 			for (j = i + 1; j > 0; j--) {
 				tmp = index_of[lambda[j - 1]];
 				if (tmp != nn) {

commit 45888b40d2a6221d46bb69959e2600ddba71cc1f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Apr 22 18:23:55 2018 +0200

    rslib: Allocate decoder buffers to avoid VLAs
    
    To get rid of the variable length arrays on stack in the RS decoder it's
    necessary to allocate the decoder buffers per control structure instance.
    
    All usage sites have been checked for potential parallel decoder usage and
    fixed where necessary. Kees confirmed that the pstore decoding is strictly
    single threaded so there should be no surprises.
    
    Allocate them in the rs control structure sized depending on the number of
    roots for the chosen codec and adapt the decoder code to make use of them.
    
    Document the fact that decode operations based on a particular rs control
    instance cannot run in parallel and the caller has to ensure that as it's
    not possible to provide a proper locking construct which fits all use
    cases.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Kernel Hardening <kernel-hardening@lists.openwall.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Andrew Morton <akpm@linuxfoundation.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 794cced31c75..1db74eb098d0 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -21,16 +21,22 @@
 	uint16_t *alpha_to = rs->alpha_to;
 	uint16_t *index_of = rs->index_of;
 	uint16_t u, q, tmp, num1, num2, den, discr_r, syn_error;
-	/* Err+Eras Locator poly and syndrome poly The maximum value
-	 * of nroots is 8. So the necessary stack size will be about
-	 * 220 bytes max.
-	 */
-	uint16_t lambda[nroots + 1], syn[nroots];
-	uint16_t b[nroots + 1], t[nroots + 1], omega[nroots + 1];
-	uint16_t root[nroots], reg[nroots + 1], loc[nroots];
 	int count = 0;
 	uint16_t msk = (uint16_t) rs->nn;
 
+	/*
+	 * The decoder buffers are in the rs control struct. They are
+	 * arrays sized [nroots + 1]
+	 */
+	uint16_t *lambda = rsc->buffers + RS_DECODE_LAMBDA * (nroots + 1);
+	uint16_t *syn = rsc->buffers + RS_DECODE_SYN * (nroots + 1);
+	uint16_t *b = rsc->buffers + RS_DECODE_B * (nroots + 1);
+	uint16_t *t = rsc->buffers + RS_DECODE_T * (nroots + 1);
+	uint16_t *omega = rsc->buffers + RS_DECODE_OMEGA * (nroots + 1);
+	uint16_t *root = rsc->buffers + RS_DECODE_ROOT * (nroots + 1);
+	uint16_t *reg = rsc->buffers + RS_DECODE_REG * (nroots + 1);
+	uint16_t *loc = rsc->buffers + RS_DECODE_LOC * (nroots + 1);
+
 	/* Check length parameter for validity */
 	pad = nn - nroots - len;
 	BUG_ON(pad < 0 || pad >= nn);

commit 2163398192f6a53e84765cfe3e5a2088437c3d2d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Apr 22 18:23:53 2018 +0200

    rslib: Split rs control struct
    
    The decoder library uses variable length arrays on stack. To get rid of
    them it would be simple to allocate fixed length arrays on stack, but those
    might become rather large. The other solution is to allocate the buffers in
    the rs control structure, but this cannot be done as long as the structure
    can be shared by several users. Sharing is desired because the RS polynom
    tables are large and initialization is time consuming.
    
    To solve this split the codec information out of the control structure and
    have a pointer to a shared codec in it. Instantiate the control structure
    for each user, create a new codec if no shareable is avaiable yet.  Adjust
    all affected usage sites to the new scheme.
    
    This allows to add per instance decoder buffers to the control structure
    later on.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Kernel Hardening <kernel-hardening@lists.openwall.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Andrew Morton <akpm@linuxfoundation.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index d61007ade4a0..794cced31c75 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -10,6 +10,7 @@
  * Generic data width independent code which is included by the wrappers.
  */
 {
+	struct rs_codec *rs = rsc->codec;
 	int deg_lambda, el, deg_omega;
 	int i, j, r, k, pad;
 	int nn = rs->nn;

commit dc8f923eaee24061c557cb3221abeea3b95072c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Apr 22 18:23:50 2018 +0200

    rslib: Add SPDX identifiers
    
    The Reed-Solomon library is based on code from Phil Karn who granted
    permission to import it into the kernel under the GPL V2.
    
    See commit 15b5423757a7 ("Shared Reed-Solomon ECC library") in the history
    git tree at: git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git
    
      ...
      The encoder/decoder code is lifted from the GPL'd userspace RS-library
      written by Phil Karn. I modified/wrapped it to provide the different
      functions which we need in the MTD/NAND code.
      ...
      Signed-Off-By: Thomas Gleixner <tglx@linutronix.de>
      Signed-Off-By: David Woodhouse <dwmw2@infradead.org>
      "No objections at all. Just keep the authorship notices." -- Phil Karn
    
    Add the proper SPDX identifiers according to
    Documentation/process/license-rules.rst.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Kernel Hardening <kernel-hardening@lists.openwall.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Andrew Morton <akpm@linuxfoundation.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index c1ef9917bc85..d61007ade4a0 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Generic Reed Solomon encoder / decoder library
  *

commit 3413e1891d443b9e936b4b6fb0ba4cdc38ff71b6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Apr 22 18:23:49 2018 +0200

    rslib: Cleanup top level comments
    
    File references and stale CVS ids are really not useful.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Kernel Hardening <kernel-hardening@lists.openwall.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Andrew Morton <akpm@linuxfoundation.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 0ec3f257ffdf..c1ef9917bc85 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -1,20 +1,12 @@
 /*
- * lib/reed_solomon/decode_rs.c
- *
- * Overview:
- *   Generic Reed Solomon encoder / decoder library
+ * Generic Reed Solomon encoder / decoder library
  *
  * Copyright 2002, Phil Karn, KA9Q
  * May be used under the terms of the GNU General Public License (GPL)
  *
  * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: decode_rs.c,v 1.7 2005/11/07 11:14:59 gleixner Exp $
- *
- */
-
-/* Generic data width independent code which is included by the
- * wrappers.
+ * Generic data width independent code which is included by the wrappers.
  */
 {
 	int deg_lambda, el, deg_omega;

commit eb684507159de2162cd6fc62f2b3a671afd5a61d
Author: Jörn Engel <joern@logfs.org>
Date:   Sat Oct 20 23:16:32 2007 +0200

    [MTD] [NAND] Replace -1 with -EBADMSG in nand error correction code
    
    Magic numerical values are just bad style.  Particularly so when
    undocumented.
    
    Signed-off-by: Jörn Engel <joern@logfs.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 65bc718f0dc0..0ec3f257ffdf 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -202,7 +202,7 @@
 		 * deg(lambda) unequal to number of roots => uncorrectable
 		 * error detected
 		 */
-		count = -1;
+		count = -EBADMSG;
 		goto finish;
 	}
 	/*

commit 1dd7fdb163645f453f5ae55686511b6fcc2314cd
Author: Jörn Engel <joern@logfs.org>
Date:   Sat Oct 20 23:14:42 2007 +0200

    [RSLIB] BUG() when passing illegal parameters to decode_rs8() or decode_rs16()
    
    Returning -ERANGE should never happen.
    
    Signed-off-by: Jörn Engel <joern@logfs.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index a58df56f09b6..65bc718f0dc0 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -39,8 +39,7 @@
 
 	/* Check length parameter for validity */
 	pad = nn - nroots - len;
-	if (pad < 0 || pad >= nn)
-		return -ERANGE;
+	BUG_ON(pad < 0 || pad >= nn);
 
 	/* Does the caller provide the syndrome ? */
 	if (s != NULL)

commit 03ead8427d65f6986a8bf5fd3f29a879348780ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:37 2005 +0000

    [LIB] reed_solomon: Clean up trailing white spaces

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index d401decd6289..a58df56f09b6 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -1,22 +1,22 @@
-/* 
+/*
  * lib/reed_solomon/decode_rs.c
  *
  * Overview:
  *   Generic Reed Solomon encoder / decoder library
- *   
+ *
  * Copyright 2002, Phil Karn, KA9Q
  * May be used under the terms of the GNU General Public License (GPL)
  *
  * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: decode_rs.c,v 1.6 2004/10/22 15:41:47 gleixner Exp $
+ * $Id: decode_rs.c,v 1.7 2005/11/07 11:14:59 gleixner Exp $
  *
  */
 
-/* Generic data width independent code which is included by the 
+/* Generic data width independent code which is included by the
  * wrappers.
  */
-{ 
+{
 	int deg_lambda, el, deg_omega;
 	int i, j, r, k, pad;
 	int nn = rs->nn;
@@ -41,9 +41,9 @@
 	pad = nn - nroots - len;
 	if (pad < 0 || pad >= nn)
 		return -ERANGE;
-		
+
 	/* Does the caller provide the syndrome ? */
-	if (s != NULL) 
+	if (s != NULL)
 		goto decode;
 
 	/* form the syndromes; i.e., evaluate data(x) at roots of
@@ -54,11 +54,11 @@
 	for (j = 1; j < len; j++) {
 		for (i = 0; i < nroots; i++) {
 			if (syn[i] == 0) {
-				syn[i] = (((uint16_t) data[j]) ^ 
+				syn[i] = (((uint16_t) data[j]) ^
 					  invmsk) & msk;
 			} else {
 				syn[i] = ((((uint16_t) data[j]) ^
-					   invmsk) & msk) ^ 
+					   invmsk) & msk) ^
 					alpha_to[rs_modnn(rs, index_of[syn[i]] +
 						       (fcr + i) * prim)];
 			}
@@ -70,7 +70,7 @@
 			if (syn[i] == 0) {
 				syn[i] = ((uint16_t) par[j]) & msk;
 			} else {
-				syn[i] = (((uint16_t) par[j]) & msk) ^ 
+				syn[i] = (((uint16_t) par[j]) & msk) ^
 					alpha_to[rs_modnn(rs, index_of[syn[i]] +
 						       (fcr+i)*prim)];
 			}
@@ -99,14 +99,14 @@
 
 	if (no_eras > 0) {
 		/* Init lambda to be the erasure locator polynomial */
-		lambda[1] = alpha_to[rs_modnn(rs, 
+		lambda[1] = alpha_to[rs_modnn(rs,
 					      prim * (nn - 1 - eras_pos[0]))];
 		for (i = 1; i < no_eras; i++) {
 			u = rs_modnn(rs, prim * (nn - 1 - eras_pos[i]));
 			for (j = i + 1; j > 0; j--) {
 				tmp = index_of[lambda[j - 1]];
 				if (tmp != nn) {
-					lambda[j] ^= 
+					lambda[j] ^=
 						alpha_to[rs_modnn(rs, u + tmp)];
 				}
 			}
@@ -127,8 +127,8 @@
 		discr_r = 0;
 		for (i = 0; i < r; i++) {
 			if ((lambda[i] != 0) && (s[r - i - 1] != nn)) {
-				discr_r ^= 
-					alpha_to[rs_modnn(rs, 
+				discr_r ^=
+					alpha_to[rs_modnn(rs,
 							  index_of[lambda[i]] +
 							  s[r - i - 1])];
 			}
@@ -143,7 +143,7 @@
 			t[0] = lambda[0];
 			for (i = 0; i < nroots; i++) {
 				if (b[i] != nn) {
-					t[i + 1] = lambda[i + 1] ^ 
+					t[i + 1] = lambda[i + 1] ^
 						alpha_to[rs_modnn(rs, discr_r +
 								  b[i])];
 				} else
@@ -229,7 +229,7 @@
 		num1 = 0;
 		for (i = deg_omega; i >= 0; i--) {
 			if (omega[i] != nn)
-				num1 ^= alpha_to[rs_modnn(rs, omega[i] + 
+				num1 ^= alpha_to[rs_modnn(rs, omega[i] +
 							i * root[j])];
 		}
 		num2 = alpha_to[rs_modnn(rs, root[j] * (fcr - 1) + nn)];
@@ -239,13 +239,13 @@
 		 * lambda_pr of lambda[i] */
 		for (i = min(deg_lambda, nroots - 1) & ~1; i >= 0; i -= 2) {
 			if (lambda[i + 1] != nn) {
-				den ^= alpha_to[rs_modnn(rs, lambda[i + 1] + 
+				den ^= alpha_to[rs_modnn(rs, lambda[i + 1] +
 						       i * root[j])];
 			}
 		}
 		/* Apply error to data */
 		if (num1 != 0 && loc[j] >= pad) {
-			uint16_t cor = alpha_to[rs_modnn(rs,index_of[num1] + 
+			uint16_t cor = alpha_to[rs_modnn(rs,index_of[num1] +
 						       index_of[num2] +
 						       nn - index_of[den])];
 			/* Store the error correction pattern, if a

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
new file mode 100644
index 000000000000..d401decd6289
--- /dev/null
+++ b/lib/reed_solomon/decode_rs.c
@@ -0,0 +1,272 @@
+/* 
+ * lib/reed_solomon/decode_rs.c
+ *
+ * Overview:
+ *   Generic Reed Solomon encoder / decoder library
+ *   
+ * Copyright 2002, Phil Karn, KA9Q
+ * May be used under the terms of the GNU General Public License (GPL)
+ *
+ * Adaption to the kernel by Thomas Gleixner (tglx@linutronix.de)
+ *
+ * $Id: decode_rs.c,v 1.6 2004/10/22 15:41:47 gleixner Exp $
+ *
+ */
+
+/* Generic data width independent code which is included by the 
+ * wrappers.
+ */
+{ 
+	int deg_lambda, el, deg_omega;
+	int i, j, r, k, pad;
+	int nn = rs->nn;
+	int nroots = rs->nroots;
+	int fcr = rs->fcr;
+	int prim = rs->prim;
+	int iprim = rs->iprim;
+	uint16_t *alpha_to = rs->alpha_to;
+	uint16_t *index_of = rs->index_of;
+	uint16_t u, q, tmp, num1, num2, den, discr_r, syn_error;
+	/* Err+Eras Locator poly and syndrome poly The maximum value
+	 * of nroots is 8. So the necessary stack size will be about
+	 * 220 bytes max.
+	 */
+	uint16_t lambda[nroots + 1], syn[nroots];
+	uint16_t b[nroots + 1], t[nroots + 1], omega[nroots + 1];
+	uint16_t root[nroots], reg[nroots + 1], loc[nroots];
+	int count = 0;
+	uint16_t msk = (uint16_t) rs->nn;
+
+	/* Check length parameter for validity */
+	pad = nn - nroots - len;
+	if (pad < 0 || pad >= nn)
+		return -ERANGE;
+		
+	/* Does the caller provide the syndrome ? */
+	if (s != NULL) 
+		goto decode;
+
+	/* form the syndromes; i.e., evaluate data(x) at roots of
+	 * g(x) */
+	for (i = 0; i < nroots; i++)
+		syn[i] = (((uint16_t) data[0]) ^ invmsk) & msk;
+
+	for (j = 1; j < len; j++) {
+		for (i = 0; i < nroots; i++) {
+			if (syn[i] == 0) {
+				syn[i] = (((uint16_t) data[j]) ^ 
+					  invmsk) & msk;
+			} else {
+				syn[i] = ((((uint16_t) data[j]) ^
+					   invmsk) & msk) ^ 
+					alpha_to[rs_modnn(rs, index_of[syn[i]] +
+						       (fcr + i) * prim)];
+			}
+		}
+	}
+
+	for (j = 0; j < nroots; j++) {
+		for (i = 0; i < nroots; i++) {
+			if (syn[i] == 0) {
+				syn[i] = ((uint16_t) par[j]) & msk;
+			} else {
+				syn[i] = (((uint16_t) par[j]) & msk) ^ 
+					alpha_to[rs_modnn(rs, index_of[syn[i]] +
+						       (fcr+i)*prim)];
+			}
+		}
+	}
+	s = syn;
+
+	/* Convert syndromes to index form, checking for nonzero condition */
+	syn_error = 0;
+	for (i = 0; i < nroots; i++) {
+		syn_error |= s[i];
+		s[i] = index_of[s[i]];
+	}
+
+	if (!syn_error) {
+		/* if syndrome is zero, data[] is a codeword and there are no
+		 * errors to correct. So return data[] unmodified
+		 */
+		count = 0;
+		goto finish;
+	}
+
+ decode:
+	memset(&lambda[1], 0, nroots * sizeof(lambda[0]));
+	lambda[0] = 1;
+
+	if (no_eras > 0) {
+		/* Init lambda to be the erasure locator polynomial */
+		lambda[1] = alpha_to[rs_modnn(rs, 
+					      prim * (nn - 1 - eras_pos[0]))];
+		for (i = 1; i < no_eras; i++) {
+			u = rs_modnn(rs, prim * (nn - 1 - eras_pos[i]));
+			for (j = i + 1; j > 0; j--) {
+				tmp = index_of[lambda[j - 1]];
+				if (tmp != nn) {
+					lambda[j] ^= 
+						alpha_to[rs_modnn(rs, u + tmp)];
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < nroots + 1; i++)
+		b[i] = index_of[lambda[i]];
+
+	/*
+	 * Begin Berlekamp-Massey algorithm to determine error+erasure
+	 * locator polynomial
+	 */
+	r = no_eras;
+	el = no_eras;
+	while (++r <= nroots) {	/* r is the step number */
+		/* Compute discrepancy at the r-th step in poly-form */
+		discr_r = 0;
+		for (i = 0; i < r; i++) {
+			if ((lambda[i] != 0) && (s[r - i - 1] != nn)) {
+				discr_r ^= 
+					alpha_to[rs_modnn(rs, 
+							  index_of[lambda[i]] +
+							  s[r - i - 1])];
+			}
+		}
+		discr_r = index_of[discr_r];	/* Index form */
+		if (discr_r == nn) {
+			/* 2 lines below: B(x) <-- x*B(x) */
+			memmove (&b[1], b, nroots * sizeof (b[0]));
+			b[0] = nn;
+		} else {
+			/* 7 lines below: T(x) <-- lambda(x)-discr_r*x*b(x) */
+			t[0] = lambda[0];
+			for (i = 0; i < nroots; i++) {
+				if (b[i] != nn) {
+					t[i + 1] = lambda[i + 1] ^ 
+						alpha_to[rs_modnn(rs, discr_r +
+								  b[i])];
+				} else
+					t[i + 1] = lambda[i + 1];
+			}
+			if (2 * el <= r + no_eras - 1) {
+				el = r + no_eras - el;
+				/*
+				 * 2 lines below: B(x) <-- inv(discr_r) *
+				 * lambda(x)
+				 */
+				for (i = 0; i <= nroots; i++) {
+					b[i] = (lambda[i] == 0) ? nn :
+						rs_modnn(rs, index_of[lambda[i]]
+							 - discr_r + nn);
+				}
+			} else {
+				/* 2 lines below: B(x) <-- x*B(x) */
+				memmove(&b[1], b, nroots * sizeof(b[0]));
+				b[0] = nn;
+			}
+			memcpy(lambda, t, (nroots + 1) * sizeof(t[0]));
+		}
+	}
+
+	/* Convert lambda to index form and compute deg(lambda(x)) */
+	deg_lambda = 0;
+	for (i = 0; i < nroots + 1; i++) {
+		lambda[i] = index_of[lambda[i]];
+		if (lambda[i] != nn)
+			deg_lambda = i;
+	}
+	/* Find roots of error+erasure locator polynomial by Chien search */
+	memcpy(&reg[1], &lambda[1], nroots * sizeof(reg[0]));
+	count = 0;		/* Number of roots of lambda(x) */
+	for (i = 1, k = iprim - 1; i <= nn; i++, k = rs_modnn(rs, k + iprim)) {
+		q = 1;		/* lambda[0] is always 0 */
+		for (j = deg_lambda; j > 0; j--) {
+			if (reg[j] != nn) {
+				reg[j] = rs_modnn(rs, reg[j] + j);
+				q ^= alpha_to[reg[j]];
+			}
+		}
+		if (q != 0)
+			continue;	/* Not a root */
+		/* store root (index-form) and error location number */
+		root[count] = i;
+		loc[count] = k;
+		/* If we've already found max possible roots,
+		 * abort the search to save time
+		 */
+		if (++count == deg_lambda)
+			break;
+	}
+	if (deg_lambda != count) {
+		/*
+		 * deg(lambda) unequal to number of roots => uncorrectable
+		 * error detected
+		 */
+		count = -1;
+		goto finish;
+	}
+	/*
+	 * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
+	 * x**nroots). in index form. Also find deg(omega).
+	 */
+	deg_omega = deg_lambda - 1;
+	for (i = 0; i <= deg_omega; i++) {
+		tmp = 0;
+		for (j = i; j >= 0; j--) {
+			if ((s[i - j] != nn) && (lambda[j] != nn))
+				tmp ^=
+				    alpha_to[rs_modnn(rs, s[i - j] + lambda[j])];
+		}
+		omega[i] = index_of[tmp];
+	}
+
+	/*
+	 * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
+	 * inv(X(l))**(fcr-1) and den = lambda_pr(inv(X(l))) all in poly-form
+	 */
+	for (j = count - 1; j >= 0; j--) {
+		num1 = 0;
+		for (i = deg_omega; i >= 0; i--) {
+			if (omega[i] != nn)
+				num1 ^= alpha_to[rs_modnn(rs, omega[i] + 
+							i * root[j])];
+		}
+		num2 = alpha_to[rs_modnn(rs, root[j] * (fcr - 1) + nn)];
+		den = 0;
+
+		/* lambda[i+1] for i even is the formal derivative
+		 * lambda_pr of lambda[i] */
+		for (i = min(deg_lambda, nroots - 1) & ~1; i >= 0; i -= 2) {
+			if (lambda[i + 1] != nn) {
+				den ^= alpha_to[rs_modnn(rs, lambda[i + 1] + 
+						       i * root[j])];
+			}
+		}
+		/* Apply error to data */
+		if (num1 != 0 && loc[j] >= pad) {
+			uint16_t cor = alpha_to[rs_modnn(rs,index_of[num1] + 
+						       index_of[num2] +
+						       nn - index_of[den])];
+			/* Store the error correction pattern, if a
+			 * correction buffer is available */
+			if (corr) {
+				corr[j] = cor;
+			} else {
+				/* If a data buffer is given and the
+				 * error is inside the message,
+				 * correct it */
+				if (data && (loc[j] < (nn - nroots)))
+					data[loc[j] - pad] ^= cor;
+			}
+		}
+	}
+
+finish:
+	if (eras_pos != NULL) {
+		for (i = 0; i < count; i++)
+			eras_pos[i] = loc[i] - pad;
+	}
+	return count;
+
+}
