commit f418dddffc8007945fd5962380ebde770a240cf5
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Oct 16 23:27:32 2019 +1100

    usercopy: Avoid soft lockups in test_check_nonzero_user()
    
    On a machine with a 64K PAGE_SIZE, the nested for loops in
    test_check_nonzero_user() can lead to soft lockups, eg:
    
      watchdog: BUG: soft lockup - CPU#4 stuck for 22s! [modprobe:611]
      Modules linked in: test_user_copy(+) vmx_crypto gf128mul crc32c_vpmsum virtio_balloon ip_tables x_tables autofs4
      CPU: 4 PID: 611 Comm: modprobe Tainted: G             L    5.4.0-rc1-gcc-8.2.0-00001-gf5a1a536fa14-dirty #1151
      ...
      NIP __might_sleep+0x20/0xc0
      LR  __might_fault+0x40/0x60
      Call Trace:
        check_zeroed_user+0x12c/0x200
        test_user_copy_init+0x67c/0x1210 [test_user_copy]
        do_one_initcall+0x60/0x340
        do_init_module+0x7c/0x2f0
        load_module+0x2d94/0x30e0
        __do_sys_finit_module+0xc8/0x150
        system_call+0x5c/0x68
    
    Even with a 4K PAGE_SIZE the test takes multiple seconds. Instead
    tweak it to only scan a 1024 byte region, but make it cross the
    page boundary.
    
    Fixes: f5a1a536fa14 ("lib: introduce copy_struct_from_user() helper")
    Suggested-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Aleksa Sarai <cyphar@cyphar.com>
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/r/20191016122732.13467-1-mpe@ellerman.id.au
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index ad2372727b1b..5ff04d8fe971 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -47,9 +47,25 @@ static bool is_zeroed(void *from, size_t size)
 static int test_check_nonzero_user(char *kmem, char __user *umem, size_t size)
 {
 	int ret = 0;
-	size_t start, end, i;
-	size_t zero_start = size / 4;
-	size_t zero_end = size - zero_start;
+	size_t start, end, i, zero_start, zero_end;
+
+	if (test(size < 2 * PAGE_SIZE, "buffer too small"))
+		return -EINVAL;
+
+	/*
+	 * We want to cross a page boundary to exercise the code more
+	 * effectively. We also don't want to make the size we scan too large,
+	 * otherwise the test can take a long time and cause soft lockups. So
+	 * scan a 1024 byte region across the page boundary.
+	 */
+	size = 1024;
+	start = PAGE_SIZE - (size / 2);
+
+	kmem += start;
+	umem += start;
+
+	zero_start = size / 4;
+	zero_end = size - zero_start;
 
 	/*
 	 * We conduct a series of check_nonzero_user() tests on a block of

commit c90012ac85c24547e5c3468ef00aabf44aa7332d
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sun Oct 6 10:30:28 2019 +1100

    lib: test_user_copy: style cleanup
    
    While writing the tests for copy_struct_from_user(), I used a construct
    that Linus doesn't appear to be too fond of:
    
    On 2019-10-04, Linus Torvalds <torvalds@linux-foundation.org> wrote:
    > Hmm. That code is ugly, both before and after the fix.
    >
    > This just doesn't make sense for so many reasons:
    >
    >         if ((ret |= test(umem_src == NULL, "kmalloc failed")))
    >
    > where the insanity comes from
    >
    >  - why "|=" when you know that "ret" was zero before (and it had to
    >    be, for the test to make sense)
    >
    >  - why do this as a single line anyway?
    >
    >  - don't do the stupid "double parenthesis" to hide a warning. Make it
    >    use an actual comparison if you add a layer of parentheses.
    
    So instead, use a bog-standard check that isn't nearly as ugly.
    
    Fixes: 341115822f88 ("usercopy: Add parentheses around assignment in test_copy_struct_from_user")
    Fixes: f5a1a536fa14 ("lib: introduce copy_struct_from_user() helper")
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/r/20191005233028.18566-1-cyphar@cyphar.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index e365ace06538..ad2372727b1b 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -52,13 +52,14 @@ static int test_check_nonzero_user(char *kmem, char __user *umem, size_t size)
 	size_t zero_end = size - zero_start;
 
 	/*
-	 * We conduct a series of check_nonzero_user() tests on a block of memory
-	 * with the following byte-pattern (trying every possible [start,end]
-	 * pair):
+	 * We conduct a series of check_nonzero_user() tests on a block of
+	 * memory with the following byte-pattern (trying every possible
+	 * [start,end] pair):
 	 *
 	 *   [ 00 ff 00 ff ... 00 00 00 00 ... ff 00 ff 00 ]
 	 *
-	 * And we verify that check_nonzero_user() acts identically to memchr_inv().
+	 * And we verify that check_nonzero_user() acts identically to
+	 * memchr_inv().
 	 */
 
 	memset(kmem, 0x0, size);
@@ -93,11 +94,13 @@ static int test_copy_struct_from_user(char *kmem, char __user *umem,
 	size_t ksize, usize;
 
 	umem_src = kmalloc(size, GFP_KERNEL);
-	if ((ret |= test(umem_src == NULL, "kmalloc failed")))
+	ret = test(umem_src == NULL, "kmalloc failed");
+	if (ret)
 		goto out_free;
 
 	expected = kmalloc(size, GFP_KERNEL);
-	if ((ret |= test(expected == NULL, "kmalloc failed")))
+	ret = test(expected == NULL, "kmalloc failed");
+	if (ret)
 		goto out_free;
 
 	/* Fill umem with a fixed byte pattern. */

commit 341115822f8832f0c2d8af2f7e151c4c9a77bcd1
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Oct 3 10:11:21 2019 -0700

    usercopy: Add parentheses around assignment in test_copy_struct_from_user
    
    Clang warns:
    
    lib/test_user_copy.c:96:10: warning: using the result of an assignment
    as a condition without parentheses [-Wparentheses]
            if (ret |= test(umem_src == NULL, "kmalloc failed"))
                ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    lib/test_user_copy.c:96:10: note: place parentheses around the
    assignment to silence this warning
            if (ret |= test(umem_src == NULL, "kmalloc failed"))
                    ^
                (                                              )
    lib/test_user_copy.c:96:10: note: use '!=' to turn this compound
    assignment into an inequality comparison
            if (ret |= test(umem_src == NULL, "kmalloc failed"))
                    ^~
                    !=
    
    Add the parentheses as it suggests because this is intentional.
    
    Fixes: f5a1a536fa14 ("lib: introduce copy_struct_from_user() helper")
    Link: https://github.com/ClangBuiltLinux/linux/issues/731
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Aleksa Sarai <cyphar@cyphar.com>
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/r/20191003171121.2723619-1-natechancellor@gmail.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 950ee88cd6ac..e365ace06538 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -93,11 +93,11 @@ static int test_copy_struct_from_user(char *kmem, char __user *umem,
 	size_t ksize, usize;
 
 	umem_src = kmalloc(size, GFP_KERNEL);
-	if (ret |= test(umem_src == NULL, "kmalloc failed"))
+	if ((ret |= test(umem_src == NULL, "kmalloc failed")))
 		goto out_free;
 
 	expected = kmalloc(size, GFP_KERNEL);
-	if (ret |= test(expected == NULL, "kmalloc failed"))
+	if ((ret |= test(expected == NULL, "kmalloc failed")))
 		goto out_free;
 
 	/* Fill umem with a fixed byte pattern. */

commit f5a1a536fa14895ccff4e94e6a5af90901ce86aa
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Tue Oct 1 11:10:52 2019 +1000

    lib: introduce copy_struct_from_user() helper
    
    A common pattern for syscall extensions is increasing the size of a
    struct passed from userspace, such that the zero-value of the new fields
    result in the old kernel behaviour (allowing for a mix of userspace and
    kernel vintages to operate on one another in most cases).
    
    While this interface exists for communication in both directions, only
    one interface is straightforward to have reasonable semantics for
    (userspace passing a struct to the kernel). For kernel returns to
    userspace, what the correct semantics are (whether there should be an
    error if userspace is unaware of a new extension) is very
    syscall-dependent and thus probably cannot be unified between syscalls
    (a good example of this problem is [1]).
    
    Previously there was no common lib/ function that implemented
    the necessary extension-checking semantics (and different syscalls
    implemented them slightly differently or incompletely[2]). Future
    patches replace common uses of this pattern to make use of
    copy_struct_from_user().
    
    Some in-kernel selftests that insure that the handling of alignment and
    various byte patterns are all handled identically to memchr_inv() usage.
    
    [1]: commit 1251201c0d34 ("sched/core: Fix uclamp ABI bug, clean up and
         robustify sched_read_attr() ABI logic and code")
    
    [2]: For instance {sched_setattr,perf_event_open,clone3}(2) all do do
         similar checks to copy_struct_from_user() while rt_sigprocmask(2)
         always rejects differently-sized struct arguments.
    
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/r/20191001011055.19283-2-cyphar@cyphar.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 67bcd5dfd847..950ee88cd6ac 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -31,14 +31,133 @@
 # define TEST_U64
 #endif
 
-#define test(condition, msg)		\
-({					\
-	int cond = (condition);		\
-	if (cond)			\
-		pr_warn("%s\n", msg);	\
-	cond;				\
+#define test(condition, msg, ...)					\
+({									\
+	int cond = (condition);						\
+	if (cond)							\
+		pr_warn("[%d] " msg "\n", __LINE__, ##__VA_ARGS__);	\
+	cond;								\
 })
 
+static bool is_zeroed(void *from, size_t size)
+{
+	return memchr_inv(from, 0x0, size) == NULL;
+}
+
+static int test_check_nonzero_user(char *kmem, char __user *umem, size_t size)
+{
+	int ret = 0;
+	size_t start, end, i;
+	size_t zero_start = size / 4;
+	size_t zero_end = size - zero_start;
+
+	/*
+	 * We conduct a series of check_nonzero_user() tests on a block of memory
+	 * with the following byte-pattern (trying every possible [start,end]
+	 * pair):
+	 *
+	 *   [ 00 ff 00 ff ... 00 00 00 00 ... ff 00 ff 00 ]
+	 *
+	 * And we verify that check_nonzero_user() acts identically to memchr_inv().
+	 */
+
+	memset(kmem, 0x0, size);
+	for (i = 1; i < zero_start; i += 2)
+		kmem[i] = 0xff;
+	for (i = zero_end; i < size; i += 2)
+		kmem[i] = 0xff;
+
+	ret |= test(copy_to_user(umem, kmem, size),
+		    "legitimate copy_to_user failed");
+
+	for (start = 0; start <= size; start++) {
+		for (end = start; end <= size; end++) {
+			size_t len = end - start;
+			int retval = check_zeroed_user(umem + start, len);
+			int expected = is_zeroed(kmem + start, len);
+
+			ret |= test(retval != expected,
+				    "check_nonzero_user(=%d) != memchr_inv(=%d) mismatch (start=%zu, end=%zu)",
+				    retval, expected, start, end);
+		}
+	}
+
+	return ret;
+}
+
+static int test_copy_struct_from_user(char *kmem, char __user *umem,
+				      size_t size)
+{
+	int ret = 0;
+	char *umem_src = NULL, *expected = NULL;
+	size_t ksize, usize;
+
+	umem_src = kmalloc(size, GFP_KERNEL);
+	if (ret |= test(umem_src == NULL, "kmalloc failed"))
+		goto out_free;
+
+	expected = kmalloc(size, GFP_KERNEL);
+	if (ret |= test(expected == NULL, "kmalloc failed"))
+		goto out_free;
+
+	/* Fill umem with a fixed byte pattern. */
+	memset(umem_src, 0x3e, size);
+	ret |= test(copy_to_user(umem, umem_src, size),
+		    "legitimate copy_to_user failed");
+
+	/* Check basic case -- (usize == ksize). */
+	ksize = size;
+	usize = size;
+
+	memcpy(expected, umem_src, ksize);
+
+	memset(kmem, 0x0, size);
+	ret |= test(copy_struct_from_user(kmem, ksize, umem, usize),
+		    "copy_struct_from_user(usize == ksize) failed");
+	ret |= test(memcmp(kmem, expected, ksize),
+		    "copy_struct_from_user(usize == ksize) gives unexpected copy");
+
+	/* Old userspace case -- (usize < ksize). */
+	ksize = size;
+	usize = size / 2;
+
+	memcpy(expected, umem_src, usize);
+	memset(expected + usize, 0x0, ksize - usize);
+
+	memset(kmem, 0x0, size);
+	ret |= test(copy_struct_from_user(kmem, ksize, umem, usize),
+		    "copy_struct_from_user(usize < ksize) failed");
+	ret |= test(memcmp(kmem, expected, ksize),
+		    "copy_struct_from_user(usize < ksize) gives unexpected copy");
+
+	/* New userspace (-E2BIG) case -- (usize > ksize). */
+	ksize = size / 2;
+	usize = size;
+
+	memset(kmem, 0x0, size);
+	ret |= test(copy_struct_from_user(kmem, ksize, umem, usize) != -E2BIG,
+		    "copy_struct_from_user(usize > ksize) didn't give E2BIG");
+
+	/* New userspace (success) case -- (usize > ksize). */
+	ksize = size / 2;
+	usize = size;
+
+	memcpy(expected, umem_src, ksize);
+	ret |= test(clear_user(umem + ksize, usize - ksize),
+		    "legitimate clear_user failed");
+
+	memset(kmem, 0x0, size);
+	ret |= test(copy_struct_from_user(kmem, ksize, umem, usize),
+		    "copy_struct_from_user(usize > ksize) failed");
+	ret |= test(memcmp(kmem, expected, ksize),
+		    "copy_struct_from_user(usize > ksize) gives unexpected copy");
+
+out_free:
+	kfree(expected);
+	kfree(umem_src);
+	return ret;
+}
+
 static int __init test_user_copy_init(void)
 {
 	int ret = 0;
@@ -106,6 +225,11 @@ static int __init test_user_copy_init(void)
 #endif
 #undef test_legit
 
+	/* Test usage of check_nonzero_user(). */
+	ret |= test_check_nonzero_user(kmem, usermem, 2 * PAGE_SIZE);
+	/* Test usage of copy_struct_from_user(). */
+	ret |= test_copy_struct_from_user(kmem, usermem, 2 * PAGE_SIZE);
+
 	/*
 	 * Invalid usage: none of these copies should succeed.
 	 */

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index e161f0498f42..67bcd5dfd847 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Kernel module for testing copy_to/from_user infrastructure.
  *
@@ -5,15 +6,6 @@
  *
  * Authors:
  *      Kees Cook       <keescook@chromium.org>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit a687a5337063af99ebd0eebaa6f4b4cf2e07c21b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 7 23:30:54 2018 +0100

    treewide: simplify Kconfig dependencies for removed archs
    
    A lot of Kconfig symbols have architecture specific dependencies.
    In those cases that depend on architectures we have already removed,
    they can be omitted.
    
    Acked-by: Kalle Valo <kvalo@codeaurora.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index a6556f3364d1..e161f0498f42 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -31,8 +31,6 @@
  * their capability at compile-time, we just have to opt-out certain archs.
  */
 #if BITS_PER_LONG == 64 || (!(defined(CONFIG_ARM) && !defined(MMU)) && \
-			    !defined(CONFIG_BLACKFIN) &&	\
-			    !defined(CONFIG_M32R) &&		\
 			    !defined(CONFIG_M68K) &&		\
 			    !defined(CONFIG_MICROBLAZE) &&	\
 			    !defined(CONFIG_NIOS2) &&		\

commit 739d875dd6982618020d30f58f8acf10f6076e6d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 8 09:48:46 2018 +0000

    mn10300: Remove the architecture
    
    Remove the MN10300 arch as the hardware is defunct.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    cc: linux-am33-list@redhat.com
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 4621db801b23..a6556f3364d1 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -35,7 +35,6 @@
 			    !defined(CONFIG_M32R) &&		\
 			    !defined(CONFIG_M68K) &&		\
 			    !defined(CONFIG_MICROBLAZE) &&	\
-			    !defined(CONFIG_MN10300) &&		\
 			    !defined(CONFIG_NIOS2) &&		\
 			    !defined(CONFIG_PPC32) &&		\
 			    !defined(CONFIG_SUPERH))

commit cddbfbd448344dbfa0581307b0c4705e940b0743
Author: Hans-Christian Noren Egtvedt <egtvedt@samfundet.no>
Date:   Mon May 1 09:33:20 2017 +0200

    lib: remove check for AVR32 arch in test_user_copy
    
    The AVR32 architecture support has been removed from the Linux kernel,
    hence remove all the check for this architecture in test_user_copy.c.
    
    Signed-off-by: Hans-Christian Noren Egtvedt <egtvedt@samfundet.no>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 1a8d71a68531..4621db801b23 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -31,7 +31,6 @@
  * their capability at compile-time, we just have to opt-out certain archs.
  */
 #if BITS_PER_LONG == 64 || (!(defined(CONFIG_ARM) && !defined(MMU)) && \
-			    !defined(CONFIG_AVR32) &&		\
 			    !defined(CONFIG_BLACKFIN) &&	\
 			    !defined(CONFIG_M32R) &&		\
 			    !defined(CONFIG_M68K) &&		\

commit 4deaa6fd00be2bf408dd06cdf0c40a1b59237879
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Feb 22 11:21:22 2017 -0800

    usercopy: ARM NOMMU has no 64-bit get_user
    
    On a NOMMU ARM kernel, we get this link error:
    
    ERROR: "__get_user_bad" [lib/test_user_copy.ko] undefined!
    
    The problem is that the extended get_user/put_user definitions
    were only added for the normal (MMU based) case.
    
    We could add it for NOMMU as well, but it seems easier to just not
    call it, since no other code needs it.
    
    Fixes: 4c5d7bc63775 ("usercopy: Add tests for all get_user() sizes")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 6f335a3d4ae2..1a8d71a68531 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -30,7 +30,8 @@
  * As there doesn't appear to be anything that can safely determine
  * their capability at compile-time, we just have to opt-out certain archs.
  */
-#if BITS_PER_LONG == 64 || (!defined(CONFIG_AVR32)  &&		\
+#if BITS_PER_LONG == 64 || (!(defined(CONFIG_ARM) && !defined(MMU)) && \
+			    !defined(CONFIG_AVR32) &&		\
 			    !defined(CONFIG_BLACKFIN) &&	\
 			    !defined(CONFIG_M32R) &&		\
 			    !defined(CONFIG_M68K) &&		\

commit 4c5d7bc63775b40631b75f6c59a3a3005455262d
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Feb 14 12:38:07 2017 -0800

    usercopy: Add tests for all get_user() sizes
    
    The existing test was only exercising native unsigned long size
    get_user(). For completeness, we should check all sizes. But we
    must skip some 32-bit architectures that don't implement a 64-bit
    get_user().
    
    These new tests actually uncovered a bug in ARM's 64-bit get_user()
    zeroing.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 73ff7a628e3a..6f335a3d4ae2 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -25,6 +25,23 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 
+/*
+ * Several 32-bit architectures support 64-bit {get,put}_user() calls.
+ * As there doesn't appear to be anything that can safely determine
+ * their capability at compile-time, we just have to opt-out certain archs.
+ */
+#if BITS_PER_LONG == 64 || (!defined(CONFIG_AVR32)  &&		\
+			    !defined(CONFIG_BLACKFIN) &&	\
+			    !defined(CONFIG_M32R) &&		\
+			    !defined(CONFIG_M68K) &&		\
+			    !defined(CONFIG_MICROBLAZE) &&	\
+			    !defined(CONFIG_MN10300) &&		\
+			    !defined(CONFIG_NIOS2) &&		\
+			    !defined(CONFIG_PPC32) &&		\
+			    !defined(CONFIG_SUPERH))
+# define TEST_U64
+#endif
+
 #define test(condition, msg)		\
 ({					\
 	int cond = (condition);		\
@@ -40,7 +57,12 @@ static int __init test_user_copy_init(void)
 	char __user *usermem;
 	char *bad_usermem;
 	unsigned long user_addr;
-	unsigned long value = 0x5A;
+	u8 val_u8;
+	u16 val_u16;
+	u32 val_u32;
+#ifdef TEST_U64
+	u64 val_u64;
+#endif
 
 	kmem = kmalloc(PAGE_SIZE * 2, GFP_KERNEL);
 	if (!kmem)
@@ -61,14 +83,39 @@ static int __init test_user_copy_init(void)
 	/*
 	 * Legitimate usage: none of these copies should fail.
 	 */
-	ret |= test(copy_from_user(kmem, usermem, PAGE_SIZE),
-		    "legitimate copy_from_user failed");
+	memset(kmem, 0x3a, PAGE_SIZE * 2);
 	ret |= test(copy_to_user(usermem, kmem, PAGE_SIZE),
 		    "legitimate copy_to_user failed");
-	ret |= test(get_user(value, (unsigned long __user *)usermem),
-		    "legitimate get_user failed");
-	ret |= test(put_user(value, (unsigned long __user *)usermem),
-		    "legitimate put_user failed");
+	memset(kmem, 0x0, PAGE_SIZE);
+	ret |= test(copy_from_user(kmem, usermem, PAGE_SIZE),
+		    "legitimate copy_from_user failed");
+	ret |= test(memcmp(kmem, kmem + PAGE_SIZE, PAGE_SIZE),
+		    "legitimate usercopy failed to copy data");
+
+#define test_legit(size, check)						  \
+	do {								  \
+		val_##size = check;					  \
+		ret |= test(put_user(val_##size, (size __user *)usermem), \
+		    "legitimate put_user (" #size ") failed");		  \
+		val_##size = 0;						  \
+		ret |= test(get_user(val_##size, (size __user *)usermem), \
+		    "legitimate get_user (" #size ") failed");		  \
+		ret |= test(val_##size != check,			  \
+		    "legitimate get_user (" #size ") failed to do copy"); \
+		if (val_##size != check) {				  \
+			pr_info("0x%llx != 0x%llx\n",			  \
+				(unsigned long long)val_##size,		  \
+				(unsigned long long)check);		  \
+		}							  \
+	} while (0)
+
+	test_legit(u8,  0x5a);
+	test_legit(u16, 0x5a5b);
+	test_legit(u32, 0x5a5b5c5d);
+#ifdef TEST_U64
+	test_legit(u64, 0x5a5b5c5d6a6b6c6d);
+#endif
+#undef test_legit
 
 	/*
 	 * Invalid usage: none of these copies should succeed.
@@ -105,12 +152,28 @@ static int __init test_user_copy_init(void)
 				  PAGE_SIZE),
 		    "illegal reversed copy_to_user passed");
 
-	value = 0x5a;
-	ret |= test(!get_user(value, (unsigned long __user *)kmem),
-		    "illegal get_user passed");
-	ret |= test(value != 0, "zeroing failure for illegal get_user");
-	ret |= test(!put_user(value, (unsigned long __user *)kmem),
-		    "illegal put_user passed");
+#define test_illegal(size, check)					    \
+	do {								    \
+		val_##size = (check);					    \
+		ret |= test(!get_user(val_##size, (size __user *)kmem),	    \
+		    "illegal get_user (" #size ") passed");		    \
+		ret |= test(val_##size != (size)0,			    \
+		    "zeroing failure for illegal get_user (" #size ")");    \
+		if (val_##size != (size)0) {				    \
+			pr_info("0x%llx != 0\n",			    \
+				(unsigned long long)val_##size);	    \
+		}							    \
+		ret |= test(!put_user(val_##size, (size __user *)kmem),	    \
+		    "illegal put_user (" #size ") passed");		    \
+	} while (0)
+
+	test_illegal(u8,  0x5a);
+	test_illegal(u16, 0x5a5b);
+	test_illegal(u32, 0x5a5b5c5d);
+#ifdef TEST_U64
+	test_illegal(u64, 0x5a5b5c5d6a6b6c6d);
+#endif
+#undef test_illegal
 
 	vm_munmap(user_addr, PAGE_SIZE * 2);
 	kfree(kmem);

commit f5f893c57e37ca730808cb2eee3820abd05e7507
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Feb 13 11:25:26 2017 -0800

    usercopy: Adjust tests to deal with SMAP/PAN
    
    Under SMAP/PAN/etc, we cannot write directly to userspace memory, so
    this rearranges the test bytes to get written through copy_to_user().
    Additionally drops the bad copy_from_user() test that would trigger a
    memcpy() against userspace on failure.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 0f86c67d87db..73ff7a628e3a 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -58,7 +58,9 @@ static int __init test_user_copy_init(void)
 	usermem = (char __user *)user_addr;
 	bad_usermem = (char *)user_addr;
 
-	/* Legitimate usage: none of these should fail. */
+	/*
+	 * Legitimate usage: none of these copies should fail.
+	 */
 	ret |= test(copy_from_user(kmem, usermem, PAGE_SIZE),
 		    "legitimate copy_from_user failed");
 	ret |= test(copy_to_user(usermem, kmem, PAGE_SIZE),
@@ -68,31 +70,45 @@ static int __init test_user_copy_init(void)
 	ret |= test(put_user(value, (unsigned long __user *)usermem),
 		    "legitimate put_user failed");
 
-	/* Invalid usage: none of these should succeed. */
+	/*
+	 * Invalid usage: none of these copies should succeed.
+	 */
+
+	/* Prepare kernel memory with check values. */
 	memset(kmem, 0x5a, PAGE_SIZE);
 	memset(kmem + PAGE_SIZE, 0, PAGE_SIZE);
+
+	/* Reject kernel-to-kernel copies through copy_from_user(). */
 	ret |= test(!copy_from_user(kmem, (char __user *)(kmem + PAGE_SIZE),
 				    PAGE_SIZE),
 		    "illegal all-kernel copy_from_user passed");
+
+	/* Destination half of buffer should have been zeroed. */
 	ret |= test(memcmp(kmem + PAGE_SIZE, kmem, PAGE_SIZE),
 		    "zeroing failure for illegal all-kernel copy_from_user");
-	memset(bad_usermem, 0x5A, PAGE_SIZE);
+
+#if 0
+	/*
+	 * When running with SMAP/PAN/etc, this will Oops the kernel
+	 * due to the zeroing of userspace memory on failure. This needs
+	 * to be tested in LKDTM instead, since this test module does not
+	 * expect to explode.
+	 */
 	ret |= test(!copy_from_user(bad_usermem, (char __user *)kmem,
 				    PAGE_SIZE),
 		    "illegal reversed copy_from_user passed");
-	ret |= test(memcmp(kmem + PAGE_SIZE, bad_usermem, PAGE_SIZE),
-		    "zeroing failure for illegal reversed copy_from_user");
+#endif
 	ret |= test(!copy_to_user((char __user *)kmem, kmem + PAGE_SIZE,
 				  PAGE_SIZE),
 		    "illegal all-kernel copy_to_user passed");
 	ret |= test(!copy_to_user((char __user *)kmem, bad_usermem,
 				  PAGE_SIZE),
 		    "illegal reversed copy_to_user passed");
-	memset(kmem, 0x5a, PAGE_SIZE);
+
+	value = 0x5a;
 	ret |= test(!get_user(value, (unsigned long __user *)kmem),
 		    "illegal get_user passed");
-	ret |= test(memcmp(kmem + PAGE_SIZE, kmem, sizeof(value)),
-		    "zeroing failure for illegal get_user");
+	ret |= test(value != 0, "zeroing failure for illegal get_user");
 	ret |= test(!put_user(value, (unsigned long __user *)kmem),
 		    "illegal put_user passed");
 

commit 4fbfeb8bd684d564bddeff1e3723d3d9f99aa5de
Author: Hoeun Ryu <hoeun.ryu@gmail.com>
Date:   Sun Feb 12 15:13:33 2017 +0900

    usercopy: add testcases to check zeroing on failure
    
    During usercopy the destination buffer will be zeroed if copy_from_user()
    or get_user() fails. This patch adds testcases for it. The destination
    buffer is set with non-zero value before illegal copy_from_user() or
    get_user() is executed and the buffer is compared to zero after usercopy
    is done.
    
    Signed-off-by: Hoeun Ryu <hoeun.ryu@gmail.com>
    [kees: clarified commit log, dropped second kmalloc]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 0ecef3e4690e..0f86c67d87db 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -69,20 +69,30 @@ static int __init test_user_copy_init(void)
 		    "legitimate put_user failed");
 
 	/* Invalid usage: none of these should succeed. */
+	memset(kmem, 0x5a, PAGE_SIZE);
+	memset(kmem + PAGE_SIZE, 0, PAGE_SIZE);
 	ret |= test(!copy_from_user(kmem, (char __user *)(kmem + PAGE_SIZE),
 				    PAGE_SIZE),
 		    "illegal all-kernel copy_from_user passed");
+	ret |= test(memcmp(kmem + PAGE_SIZE, kmem, PAGE_SIZE),
+		    "zeroing failure for illegal all-kernel copy_from_user");
+	memset(bad_usermem, 0x5A, PAGE_SIZE);
 	ret |= test(!copy_from_user(bad_usermem, (char __user *)kmem,
 				    PAGE_SIZE),
 		    "illegal reversed copy_from_user passed");
+	ret |= test(memcmp(kmem + PAGE_SIZE, bad_usermem, PAGE_SIZE),
+		    "zeroing failure for illegal reversed copy_from_user");
 	ret |= test(!copy_to_user((char __user *)kmem, kmem + PAGE_SIZE,
 				  PAGE_SIZE),
 		    "illegal all-kernel copy_to_user passed");
 	ret |= test(!copy_to_user((char __user *)kmem, bad_usermem,
 				  PAGE_SIZE),
 		    "illegal reversed copy_to_user passed");
+	memset(kmem, 0x5a, PAGE_SIZE);
 	ret |= test(!get_user(value, (unsigned long __user *)kmem),
 		    "illegal get_user passed");
+	ret |= test(memcmp(kmem + PAGE_SIZE, kmem, sizeof(value)),
+		    "zeroing failure for illegal get_user");
 	ret |= test(!put_user(value, (unsigned long __user *)kmem),
 		    "illegal put_user passed");
 

commit 3e2a4c183ace8708c69f589505fb82bb63010ade
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jan 23 15:54:38 2014 -0800

    test: check copy_to/from_user boundary validation
    
    To help avoid an architecture failing to correctly check kernel/user
    boundaries when handling copy_to_user, copy_from_user, put_user, or
    get_user, perform some simple tests and fail to load if any of them
    behave unexpectedly.
    
    Specifically, this is to make sure there is a way to notice if things
    like what was fixed in commit 8404663f81d2 ("ARM: 7527/1: uaccess:
    explicitly check __user pointer when !CPU_USE_DOMAINS") ever regresses
    again, for any architecture.
    
    Additionally, adds new "user" selftest target, which loads this module.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
new file mode 100644
index 000000000000..0ecef3e4690e
--- /dev/null
+++ b/lib/test_user_copy.c
@@ -0,0 +1,110 @@
+/*
+ * Kernel module for testing copy_to/from_user infrastructure.
+ *
+ * Copyright 2013 Google Inc. All Rights Reserved
+ *
+ * Authors:
+ *      Kees Cook       <keescook@chromium.org>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#define test(condition, msg)		\
+({					\
+	int cond = (condition);		\
+	if (cond)			\
+		pr_warn("%s\n", msg);	\
+	cond;				\
+})
+
+static int __init test_user_copy_init(void)
+{
+	int ret = 0;
+	char *kmem;
+	char __user *usermem;
+	char *bad_usermem;
+	unsigned long user_addr;
+	unsigned long value = 0x5A;
+
+	kmem = kmalloc(PAGE_SIZE * 2, GFP_KERNEL);
+	if (!kmem)
+		return -ENOMEM;
+
+	user_addr = vm_mmap(NULL, 0, PAGE_SIZE * 2,
+			    PROT_READ | PROT_WRITE | PROT_EXEC,
+			    MAP_ANONYMOUS | MAP_PRIVATE, 0);
+	if (user_addr >= (unsigned long)(TASK_SIZE)) {
+		pr_warn("Failed to allocate user memory\n");
+		kfree(kmem);
+		return -ENOMEM;
+	}
+
+	usermem = (char __user *)user_addr;
+	bad_usermem = (char *)user_addr;
+
+	/* Legitimate usage: none of these should fail. */
+	ret |= test(copy_from_user(kmem, usermem, PAGE_SIZE),
+		    "legitimate copy_from_user failed");
+	ret |= test(copy_to_user(usermem, kmem, PAGE_SIZE),
+		    "legitimate copy_to_user failed");
+	ret |= test(get_user(value, (unsigned long __user *)usermem),
+		    "legitimate get_user failed");
+	ret |= test(put_user(value, (unsigned long __user *)usermem),
+		    "legitimate put_user failed");
+
+	/* Invalid usage: none of these should succeed. */
+	ret |= test(!copy_from_user(kmem, (char __user *)(kmem + PAGE_SIZE),
+				    PAGE_SIZE),
+		    "illegal all-kernel copy_from_user passed");
+	ret |= test(!copy_from_user(bad_usermem, (char __user *)kmem,
+				    PAGE_SIZE),
+		    "illegal reversed copy_from_user passed");
+	ret |= test(!copy_to_user((char __user *)kmem, kmem + PAGE_SIZE,
+				  PAGE_SIZE),
+		    "illegal all-kernel copy_to_user passed");
+	ret |= test(!copy_to_user((char __user *)kmem, bad_usermem,
+				  PAGE_SIZE),
+		    "illegal reversed copy_to_user passed");
+	ret |= test(!get_user(value, (unsigned long __user *)kmem),
+		    "illegal get_user passed");
+	ret |= test(!put_user(value, (unsigned long __user *)kmem),
+		    "illegal put_user passed");
+
+	vm_munmap(user_addr, PAGE_SIZE * 2);
+	kfree(kmem);
+
+	if (ret == 0) {
+		pr_info("tests passed.\n");
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+module_init(test_user_copy_init);
+
+static void __exit test_user_copy_exit(void)
+{
+	pr_info("unloaded.\n");
+}
+
+module_exit(test_user_copy_exit);
+
+MODULE_AUTHOR("Kees Cook <keescook@chromium.org>");
+MODULE_LICENSE("GPL");
