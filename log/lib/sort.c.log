commit 52ae533b8a18e7ca868e7ac5953ad7258210f320
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Oct 7 16:56:54 2019 +0300

    lib/sort: Move swap, cmp and cmp_r function types for wider use
    
    The function types for swap, cmp and cmp_r functions are already
    being in use by modules.
    
    Move them to types.h that everybody in kernel will be able to use
    generic types instead of custom ones.
    
    This adds more sense to the comment in bsearch() later on.
    
    Link: http://lkml.kernel.org/r/20191007135656.37734-1-andriy.shevchenko@linux.intel.com
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/lib/sort.c b/lib/sort.c
index d54cf97e9548..3ad454411997 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -117,8 +117,6 @@ static void swap_bytes(void *a, void *b, size_t n)
 	} while (n);
 }
 
-typedef void (*swap_func_t)(void *a, void *b, int size);
-
 /*
  * The values are arbitrary as long as they can't be confused with
  * a pointer, but small integers make for the smallest compare
@@ -144,12 +142,9 @@ static void do_swap(void *a, void *b, size_t size, swap_func_t swap_func)
 		swap_func(a, b, (int)size);
 }
 
-typedef int (*cmp_func_t)(const void *, const void *);
-typedef int (*cmp_r_func_t)(const void *, const void *, const void *);
 #define _CMP_WRAPPER ((cmp_r_func_t)0L)
 
-static int do_cmp(const void *a, const void *b,
-		  cmp_r_func_t cmp, const void *priv)
+static int do_cmp(const void *a, const void *b, cmp_r_func_t cmp, const void *priv)
 {
 	if (cmp == _CMP_WRAPPER)
 		return ((cmp_func_t)(priv))(a, b);
@@ -202,8 +197,8 @@ static size_t parent(size_t i, unsigned int lsbit, size_t size)
  * it less suitable for kernel use.
  */
 void sort_r(void *base, size_t num, size_t size,
-	    int (*cmp_func)(const void *, const void *, const void *),
-	    void (*swap_func)(void *, void *, int size),
+	    cmp_r_func_t cmp_func,
+	    swap_func_t swap_func,
 	    const void *priv)
 {
 	/* pre-scale counters for performance */
@@ -269,8 +264,8 @@ void sort_r(void *base, size_t num, size_t size,
 EXPORT_SYMBOL(sort_r);
 
 void sort(void *base, size_t num, size_t size,
-	  int (*cmp_func)(const void *, const void *),
-	  void (*swap_func)(void *, void *, int size))
+	  cmp_func_t cmp_func,
+	  swap_func_t swap_func)
 {
 	return sort_r(base, num, size, _CMP_WRAPPER, swap_func, cmp_func);
 }

commit 4333fb96ca1086d1cec0f93f78c453aa2dee8a5c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Aug 16 13:01:22 2019 -0300

    media: lib/sort.c: implement sort() variant taking context argument
    
    Our list_sort() utility has always supported a context argument that
    is passed through to the comparison routine. Now there's a use case
    for the similar thing for sort().
    
    This implements sort_r by simply extending the existing sort function
    in the obvious way. To avoid code duplication, we want to implement
    sort() in terms of sort_r(). The naive way to do that is
    
    static int cmp_wrapper(const void *a, const void *b, const void *ctx)
    {
      int (*real_cmp)(const void*, const void*) = ctx;
      return real_cmp(a, b);
    }
    
    sort(..., cmp) { sort_r(..., cmp_wrapper, cmp) }
    
    but this would do two indirect calls for each comparison. Instead, do
    as is done for the default swap functions - that only adds a cost of a
    single easily predicted branch to each comparison call.
    
    Aside from introducing support for the context argument, this also
    serves as preparation for patches that will eliminate the indirect
    comparison calls in common cases.
    
    Requested-by: Boris Brezillon <boris.brezillon@collabora.com>
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Acked-by: Andrew Morton <akpm@linux-foundation.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/lib/sort.c b/lib/sort.c
index cf408aec3733..d54cf97e9548 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -144,6 +144,18 @@ static void do_swap(void *a, void *b, size_t size, swap_func_t swap_func)
 		swap_func(a, b, (int)size);
 }
 
+typedef int (*cmp_func_t)(const void *, const void *);
+typedef int (*cmp_r_func_t)(const void *, const void *, const void *);
+#define _CMP_WRAPPER ((cmp_r_func_t)0L)
+
+static int do_cmp(const void *a, const void *b,
+		  cmp_r_func_t cmp, const void *priv)
+{
+	if (cmp == _CMP_WRAPPER)
+		return ((cmp_func_t)(priv))(a, b);
+	return cmp(a, b, priv);
+}
+
 /**
  * parent - given the offset of the child, find the offset of the parent.
  * @i: the offset of the heap element whose parent is sought.  Non-zero.
@@ -171,12 +183,13 @@ static size_t parent(size_t i, unsigned int lsbit, size_t size)
 }
 
 /**
- * sort - sort an array of elements
+ * sort_r - sort an array of elements
  * @base: pointer to data to sort
  * @num: number of elements
  * @size: size of each element
  * @cmp_func: pointer to comparison function
  * @swap_func: pointer to swap function or NULL
+ * @priv: third argument passed to comparison function
  *
  * This function does a heapsort on the given array.  You may provide
  * a swap_func function if you need to do something more than a memory
@@ -188,9 +201,10 @@ static size_t parent(size_t i, unsigned int lsbit, size_t size)
  * O(n*n) worst-case behavior and extra memory requirements that make
  * it less suitable for kernel use.
  */
-void sort(void *base, size_t num, size_t size,
-	  int (*cmp_func)(const void *, const void *),
-	  void (*swap_func)(void *, void *, int size))
+void sort_r(void *base, size_t num, size_t size,
+	    int (*cmp_func)(const void *, const void *, const void *),
+	    void (*swap_func)(void *, void *, int size),
+	    const void *priv)
 {
 	/* pre-scale counters for performance */
 	size_t n = num * size, a = (num/2) * size;
@@ -238,12 +252,12 @@ void sort(void *base, size_t num, size_t size,
 		 * average, 3/4 worst-case.)
 		 */
 		for (b = a; c = 2*b + size, (d = c + size) < n;)
-			b = cmp_func(base + c, base + d) >= 0 ? c : d;
+			b = do_cmp(base + c, base + d, cmp_func, priv) >= 0 ? c : d;
 		if (d == n)	/* Special case last leaf with no sibling */
 			b = c;
 
 		/* Now backtrack from "b" to the correct location for "a" */
-		while (b != a && cmp_func(base + a, base + b) >= 0)
+		while (b != a && do_cmp(base + a, base + b, cmp_func, priv) >= 0)
 			b = parent(b, lsbit, size);
 		c = b;			/* Where "a" belongs */
 		while (b != a) {	/* Shift it into place */
@@ -252,4 +266,12 @@ void sort(void *base, size_t num, size_t size,
 		}
 	}
 }
+EXPORT_SYMBOL(sort_r);
+
+void sort(void *base, size_t num, size_t size,
+	  int (*cmp_func)(const void *, const void *),
+	  void (*swap_func)(void *, void *, int size))
+{
+	return sort_r(base, num, size, _CMP_WRAPPER, swap_func, cmp_func);
+}
 EXPORT_SYMBOL(sort);

commit aa52619ccbe056999d7c7231c8a1a11cedfccc6a
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri May 31 22:30:00 2019 -0700

    lib/sort.c: fix kernel-doc notation warnings
    
    Fix kernel-doc notation in lib/sort.c by using correct function parameter
    names.
    
      lib/sort.c:59: warning: Excess function parameter 'size' description in 'swap_words_32'
      lib/sort.c:83: warning: Excess function parameter 'size' description in 'swap_words_64'
      lib/sort.c:110: warning: Excess function parameter 'size' description in 'swap_bytes'
    
    Link: http://lkml.kernel.org/r/60e25d3d-68d1-bde2-3b39-e4baa0b14907@infradead.org
    Fixes: 37d0ec34d111a ("lib/sort: make swap functions more generic")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: George Spelvin <lkml@sdf.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 50855ea8c262..cf408aec3733 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -43,8 +43,9 @@ static bool is_aligned(const void *base, size_t size, unsigned char align)
 
 /**
  * swap_words_32 - swap two elements in 32-bit chunks
- * @a, @b: pointers to the elements
- * @size: element size (must be a multiple of 4)
+ * @a: pointer to the first element to swap
+ * @b: pointer to the second element to swap
+ * @n: element size (must be a multiple of 4)
  *
  * Exchange the two objects in memory.  This exploits base+index addressing,
  * which basically all CPUs have, to minimize loop overhead computations.
@@ -65,8 +66,9 @@ static void swap_words_32(void *a, void *b, size_t n)
 
 /**
  * swap_words_64 - swap two elements in 64-bit chunks
- * @a, @b: pointers to the elements
- * @size: element size (must be a multiple of 8)
+ * @a: pointer to the first element to swap
+ * @b: pointer to the second element to swap
+ * @n: element size (must be a multiple of 8)
  *
  * Exchange the two objects in memory.  This exploits base+index
  * addressing, which basically all CPUs have, to minimize loop overhead
@@ -100,8 +102,9 @@ static void swap_words_64(void *a, void *b, size_t n)
 
 /**
  * swap_bytes - swap two elements a byte at a time
- * @a, @b: pointers to the elements
- * @size: element size
+ * @a: pointer to the first element to swap
+ * @b: pointer to the second element to swap
+ * @n: element size
  *
  * This is the fallback if alignment doesn't allow using larger chunks.
  */

commit 8fb583c4258d08f0aff105aa2ae5157b7d414ea2
Author: George Spelvin <lkml@sdf.org>
Date:   Tue May 14 15:42:55 2019 -0700

    lib/sort: avoid indirect calls to built-in swap
    
    Similar to what's being done in the net code, this takes advantage of
    the fact that most invocations use only a few common swap functions, and
    replaces indirect calls to them with (highly predictable) conditional
    branches.  (The downside, of course, is that if you *do* use a custom
    swap function, there are a few extra predicted branches on the code
    path.)
    
    This actually *shrinks* the x86-64 code, because it inlines the various
    swap functions inside do_swap, eliding function prologues & epilogues.
    
    x86-64 code size 767 -> 703 bytes (-64)
    
    Link: http://lkml.kernel.org/r/d10c5d4b393a1847f32f5b26f4bbaa2857140e1e.1552704200.git.lkml@sdf.org
    Signed-off-by: George Spelvin <lkml@sdf.org>
    Acked-by: Andrey Abramov <st5pub@yandex.ru>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Daniel Wagner <daniel.wagner@siemens.com>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: Don Mullis <don.mullis@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 0d24d0c5c0fc..50855ea8c262 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -54,10 +54,8 @@ static bool is_aligned(const void *base, size_t size, unsigned char align)
  * subtract (since the intervening mov instructions don't alter the flags).
  * Gcc 8.1.0 doesn't have that problem.
  */
-static void swap_words_32(void *a, void *b, int size)
+static void swap_words_32(void *a, void *b, size_t n)
 {
-	size_t n = (unsigned int)size;
-
 	do {
 		u32 t = *(u32 *)(a + (n -= 4));
 		*(u32 *)(a + n) = *(u32 *)(b + n);
@@ -80,10 +78,8 @@ static void swap_words_32(void *a, void *b, int size)
  * but it's possible to have 64-bit loads without 64-bit pointers (e.g.
  * x32 ABI).  Are there any cases the kernel needs to worry about?
  */
-static void swap_words_64(void *a, void *b, int size)
+static void swap_words_64(void *a, void *b, size_t n)
 {
-	size_t n = (unsigned int)size;
-
 	do {
 #ifdef CONFIG_64BIT
 		u64 t = *(u64 *)(a + (n -= 8));
@@ -109,10 +105,8 @@ static void swap_words_64(void *a, void *b, int size)
  *
  * This is the fallback if alignment doesn't allow using larger chunks.
  */
-static void swap_bytes(void *a, void *b, int size)
+static void swap_bytes(void *a, void *b, size_t n)
 {
-	size_t n = (unsigned int)size;
-
 	do {
 		char t = ((char *)a)[--n];
 		((char *)a)[n] = ((char *)b)[n];
@@ -120,6 +114,33 @@ static void swap_bytes(void *a, void *b, int size)
 	} while (n);
 }
 
+typedef void (*swap_func_t)(void *a, void *b, int size);
+
+/*
+ * The values are arbitrary as long as they can't be confused with
+ * a pointer, but small integers make for the smallest compare
+ * instructions.
+ */
+#define SWAP_WORDS_64 (swap_func_t)0
+#define SWAP_WORDS_32 (swap_func_t)1
+#define SWAP_BYTES    (swap_func_t)2
+
+/*
+ * The function pointer is last to make tail calls most efficient if the
+ * compiler decides not to inline this function.
+ */
+static void do_swap(void *a, void *b, size_t size, swap_func_t swap_func)
+{
+	if (swap_func == SWAP_WORDS_64)
+		swap_words_64(a, b, size);
+	else if (swap_func == SWAP_WORDS_32)
+		swap_words_32(a, b, size);
+	else if (swap_func == SWAP_BYTES)
+		swap_bytes(a, b, size);
+	else
+		swap_func(a, b, (int)size);
+}
+
 /**
  * parent - given the offset of the child, find the offset of the parent.
  * @i: the offset of the heap element whose parent is sought.  Non-zero.
@@ -157,7 +178,7 @@ static size_t parent(size_t i, unsigned int lsbit, size_t size)
  * This function does a heapsort on the given array.  You may provide
  * a swap_func function if you need to do something more than a memory
  * copy (e.g. fix up pointers or auxiliary data), but the built-in swap
- * isn't usually a bottleneck.
+ * avoids a slow retpoline and so is significantly faster.
  *
  * Sorting time is O(n log n) both on average and worst-case. While
  * quicksort is slightly faster on average, it suffers from exploitable
@@ -177,11 +198,11 @@ void sort(void *base, size_t num, size_t size,
 
 	if (!swap_func) {
 		if (is_aligned(base, size, 8))
-			swap_func = swap_words_64;
+			swap_func = SWAP_WORDS_64;
 		else if (is_aligned(base, size, 4))
-			swap_func = swap_words_32;
+			swap_func = SWAP_WORDS_32;
 		else
-			swap_func = swap_bytes;
+			swap_func = SWAP_BYTES;
 	}
 
 	/*
@@ -197,7 +218,7 @@ void sort(void *base, size_t num, size_t size,
 		if (a)			/* Building heap: sift down --a */
 			a -= size;
 		else if (n -= size)	/* Sorting: Extract root to --n */
-			swap_func(base, base + n, size);
+			do_swap(base, base + n, size, swap_func);
 		else			/* Sort complete */
 			break;
 
@@ -224,7 +245,7 @@ void sort(void *base, size_t num, size_t size,
 		c = b;			/* Where "a" belongs */
 		while (b != a) {	/* Shift it into place */
 			b = parent(b, lsbit, size);
-			swap_func(base + b, base + c, size);
+			do_swap(base + b, base + c, size, swap_func);
 		}
 	}
 }

commit 22a241ccb2c19962a0fb02c98154aa93d3fc1862
Author: George Spelvin <lkml@sdf.org>
Date:   Tue May 14 15:42:52 2019 -0700

    lib/sort: use more efficient bottom-up heapsort variant
    
    This uses fewer comparisons than the previous code (approaching half as
    many for large random inputs), but produces identical results; it
    actually performs the exact same series of swap operations.
    
    Specifically, it reduces the average number of compares from
      2*n*log2(n) - 3*n + o(n)
    to
        n*log2(n) + 0.37*n + o(n).
    
    This is still 1.63*n worse than glibc qsort() which manages n*log2(n) -
    1.26*n, but at least the leading coefficient is correct.
    
    Standard heapsort, when sifting down, performs two comparisons per
    level: one to find the greater child, and a second to see if the current
    node should be exchanged with that child.
    
    Bottom-up heapsort observes that it's better to postpone the second
    comparison and search for the leaf where -infinity would be sent to,
    then search back *up* for the current node's destination.
    
    Since sifting down usually proceeds to the leaf level (that's where half
    the nodes are), this does O(1) second comparisons rather than log2(n).
    That saves a lot of (expensive since Spectre) indirect function calls.
    
    The one time it's worse than the previous code is if there are large
    numbers of duplicate keys, when the top-down algorithm is O(n) and
    bottom-up is O(n log n).  For distinct keys, it's provably always
    better, doing 1.5*n*log2(n) + O(n) in the worst case.
    
    (The code is not significantly more complex.  This patch also merges the
    heap-building and -extracting sift-down loops, resulting in a net code
    size savings.)
    
    x86-64 code size 885 -> 767 bytes (-118)
    
    (I see the checkpatch complaint about "else if (n -= size)".  The
    alternative is significantly uglier.)
    
    Link: http://lkml.kernel.org/r/2de8348635a1a421a72620677898c7fd5bd4b19d.1552704200.git.lkml@sdf.org
    Signed-off-by: George Spelvin <lkml@sdf.org>
    Acked-by: Andrey Abramov <st5pub@yandex.ru>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Daniel Wagner <daniel.wagner@siemens.com>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: Don Mullis <don.mullis@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index ec79eac85e21..0d24d0c5c0fc 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -1,8 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * A fast, small, non-recursive O(nlog n) sort for the Linux kernel
+ * A fast, small, non-recursive O(n log n) sort for the Linux kernel
  *
- * Jan 23 2005  Matt Mackall <mpm@selenic.com>
+ * This performs n*log2(n) + 0.37*n + o(n) comparisons on average,
+ * and 1.5*n*log2(n) + O(n) in the (very contrived) worst case.
+ *
+ * Glibc qsort() manages n*log2(n) - 1.26*n for random inputs (1.63*n
+ * better) at the expense of stack usage and much larger code to avoid
+ * quicksort's O(n^2) worst case.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -15,7 +20,7 @@
  * is_aligned - is this pointer & size okay for word-wide copying?
  * @base: pointer to data
  * @size: size of each element
- * @align: required aignment (typically 4 or 8)
+ * @align: required alignment (typically 4 or 8)
  *
  * Returns true if elements can be copied using word loads and stores.
  * The size must be a multiple of the alignment, and the base address must
@@ -115,6 +120,32 @@ static void swap_bytes(void *a, void *b, int size)
 	} while (n);
 }
 
+/**
+ * parent - given the offset of the child, find the offset of the parent.
+ * @i: the offset of the heap element whose parent is sought.  Non-zero.
+ * @lsbit: a precomputed 1-bit mask, equal to "size & -size"
+ * @size: size of each element
+ *
+ * In terms of array indexes, the parent of element j = @i/@size is simply
+ * (j-1)/2.  But when working in byte offsets, we can't use implicit
+ * truncation of integer divides.
+ *
+ * Fortunately, we only need one bit of the quotient, not the full divide.
+ * @size has a least significant bit.  That bit will be clear if @i is
+ * an even multiple of @size, and set if it's an odd multiple.
+ *
+ * Logically, we're doing "if (i & lsbit) i -= size;", but since the
+ * branch is unpredictable, it's done with a bit of clever branch-free
+ * code instead.
+ */
+__attribute_const__ __always_inline
+static size_t parent(size_t i, unsigned int lsbit, size_t size)
+{
+	i -= size;
+	i -= size & -(i & lsbit);
+	return i / 2;
+}
+
 /**
  * sort - sort an array of elements
  * @base: pointer to data to sort
@@ -129,17 +160,20 @@ static void swap_bytes(void *a, void *b, int size)
  * isn't usually a bottleneck.
  *
  * Sorting time is O(n log n) both on average and worst-case. While
- * qsort is about 20% faster on average, it suffers from exploitable
+ * quicksort is slightly faster on average, it suffers from exploitable
  * O(n*n) worst-case behavior and extra memory requirements that make
  * it less suitable for kernel use.
  */
-
 void sort(void *base, size_t num, size_t size,
 	  int (*cmp_func)(const void *, const void *),
 	  void (*swap_func)(void *, void *, int size))
 {
 	/* pre-scale counters for performance */
-	int i = (num/2 - 1) * size, n = num * size, c, r;
+	size_t n = num * size, a = (num/2) * size;
+	const unsigned int lsbit = size & -size;  /* Used to find parent */
+
+	if (!a)		/* num < 2 || size == 0 */
+		return;
 
 	if (!swap_func) {
 		if (is_aligned(base, size, 8))
@@ -150,32 +184,48 @@ void sort(void *base, size_t num, size_t size,
 			swap_func = swap_bytes;
 	}
 
-	/* heapify */
-	for ( ; i >= 0; i -= size) {
-		for (r = i; r * 2 + size < n; r  = c) {
-			c = r * 2 + size;
-			if (c < n - size &&
-					cmp_func(base + c, base + c + size) < 0)
-				c += size;
-			if (cmp_func(base + r, base + c) >= 0)
-				break;
-			swap_func(base + r, base + c, size);
-		}
-	}
-
-	/* sort */
-	for (i = n - size; i > 0; i -= size) {
-		swap_func(base, base + i, size);
-		for (r = 0; r * 2 + size < i; r = c) {
-			c = r * 2 + size;
-			if (c < i - size &&
-					cmp_func(base + c, base + c + size) < 0)
-				c += size;
-			if (cmp_func(base + r, base + c) >= 0)
-				break;
-			swap_func(base + r, base + c, size);
+	/*
+	 * Loop invariants:
+	 * 1. elements [a,n) satisfy the heap property (compare greater than
+	 *    all of their children),
+	 * 2. elements [n,num*size) are sorted, and
+	 * 3. a <= b <= c <= d <= n (whenever they are valid).
+	 */
+	for (;;) {
+		size_t b, c, d;
+
+		if (a)			/* Building heap: sift down --a */
+			a -= size;
+		else if (n -= size)	/* Sorting: Extract root to --n */
+			swap_func(base, base + n, size);
+		else			/* Sort complete */
+			break;
+
+		/*
+		 * Sift element at "a" down into heap.  This is the
+		 * "bottom-up" variant, which significantly reduces
+		 * calls to cmp_func(): we find the sift-down path all
+		 * the way to the leaves (one compare per level), then
+		 * backtrack to find where to insert the target element.
+		 *
+		 * Because elements tend to sift down close to the leaves,
+		 * this uses fewer compares than doing two per level
+		 * on the way down.  (A bit more than half as many on
+		 * average, 3/4 worst-case.)
+		 */
+		for (b = a; c = 2*b + size, (d = c + size) < n;)
+			b = cmp_func(base + c, base + d) >= 0 ? c : d;
+		if (d == n)	/* Special case last leaf with no sibling */
+			b = c;
+
+		/* Now backtrack from "b" to the correct location for "a" */
+		while (b != a && cmp_func(base + a, base + b) >= 0)
+			b = parent(b, lsbit, size);
+		c = b;			/* Where "a" belongs */
+		while (b != a) {	/* Shift it into place */
+			b = parent(b, lsbit, size);
+			swap_func(base + b, base + c, size);
 		}
 	}
 }
-
 EXPORT_SYMBOL(sort);

commit 37d0ec34d111acfdb82b24e3de00d926c0aece4d
Author: George Spelvin <lkml@sdf.org>
Date:   Tue May 14 15:42:49 2019 -0700

    lib/sort: make swap functions more generic
    
    Patch series "lib/sort & lib/list_sort: faster and smaller", v2.
    
    Because CONFIG_RETPOLINE has made indirect calls much more expensive, I
    thought I'd try to reduce the number made by the library sort functions.
    
    The first three patches apply to lib/sort.c.
    
    Patch #1 is a simple optimization.  The built-in swap has special cases
    for aligned 4- and 8-byte objects.  But those are almost never used;
    most calls to sort() work on larger structures, which fall back to the
    byte-at-a-time loop.  This generalizes them to aligned *multiples* of 4
    and 8 bytes.  (If nothing else, it saves an awful lot of energy by not
    thrashing the store buffers as much.)
    
    Patch #2 grabs a juicy piece of low-hanging fruit.  I agree that nice
    simple solid heapsort is preferable to more complex algorithms (sorry,
    Andrey), but it's possible to implement heapsort with far fewer
    comparisons (50% asymptotically, 25-40% reduction for realistic sizes)
    than the way it's been done up to now.  And with some care, the code
    ends up smaller, as well.  This is the "big win" patch.
    
    Patch #3 adds the same sort of indirect call bypass that has been added
    to the net code of late.  The great majority of the callers use the
    builtin swap functions, so replace the indirect call to sort_func with a
    (highly preditable) series of if() statements.  Rather surprisingly,
    this decreased code size, as the swap functions were inlined and their
    prologue & epilogue code eliminated.
    
    lib/list_sort.c is a bit trickier, as merge sort is already close to
    optimal, and we don't want to introduce triumphs of theory over
    practicality like the Ford-Johnson merge-insertion sort.
    
    Patch #4, without changing the algorithm, chops 32% off the code size
    and removes the part[MAX_LIST_LENGTH+1] pointer array (and the
    corresponding upper limit on efficiently sortable input size).
    
    Patch #5 improves the algorithm.  The previous code is already optimal
    for power-of-two (or slightly smaller) size inputs, but when the input
    size is just over a power of 2, there's a very unbalanced final merge.
    
    There are, in the literature, several algorithms which solve this, but
    they all depend on the "breadth-first" merge order which was replaced by
    commit 835cc0c8477f with a more cache-friendly "depth-first" order.
    Some hard thinking came up with a depth-first algorithm which defers
    merges as little as possible while avoiding bad merges.  This saves
    0.2*n compares, averaged over all sizes.
    
    The code size increase is minimal (64 bytes on x86-64, reducing the net
    savings to 26%), but the comments expanded significantly to document the
    clever algorithm.
    
    TESTING NOTES: I have some ugly user-space benchmarking code which I
    used for testing before moving this code into the kernel.  Shout if you
    want a copy.
    
    I'm running this code right now, with CONFIG_TEST_SORT and
    CONFIG_TEST_LIST_SORT, but I confess I haven't rebooted since the last
    round of minor edits to quell checkpatch.  I figure there will be at
    least one round of comments and final testing.
    
    This patch (of 5):
    
    Rather than having special-case swap functions for 4- and 8-byte
    objects, special-case aligned multiples of 4 or 8 bytes.  This speeds up
    most users of sort() by avoiding fallback to the byte copy loop.
    
    Despite what ca96ab859ab4 ("lib/sort: Add 64 bit swap function") claims,
    very few users of sort() sort pointers (or pointer-sized objects); most
    sort structures containing at least two words.  (E.g.
    drivers/acpi/fan.c:acpi_fan_get_fps() sorts an array of 40-byte struct
    acpi_fan_fps.)
    
    The functions also got renamed to reflect the fact that they support
    multiple words.  In the great tradition of bikeshedding, the names were
    by far the most contentious issue during review of this patch series.
    
    x86-64 code size 872 -> 886 bytes (+14)
    
    With feedback from Andy Shevchenko, Rasmus Villemoes and Geert
    Uytterhoeven.
    
    Link: http://lkml.kernel.org/r/f24f932df3a7fa1973c1084154f1cea596bcf341.1552704200.git.lkml@sdf.org
    Signed-off-by: George Spelvin <lkml@sdf.org>
    Acked-by: Andrey Abramov <st5pub@yandex.ru>
    Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Daniel Wagner <daniel.wagner@siemens.com>
    Cc: Don Mullis <don.mullis@gmail.com>
    Cc: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index d6b7a202b0b6..ec79eac85e21 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -11,35 +11,108 @@
 #include <linux/export.h>
 #include <linux/sort.h>
 
-static int alignment_ok(const void *base, int align)
+/**
+ * is_aligned - is this pointer & size okay for word-wide copying?
+ * @base: pointer to data
+ * @size: size of each element
+ * @align: required aignment (typically 4 or 8)
+ *
+ * Returns true if elements can be copied using word loads and stores.
+ * The size must be a multiple of the alignment, and the base address must
+ * be if we do not have CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS.
+ *
+ * For some reason, gcc doesn't know to optimize "if (a & mask || b & mask)"
+ * to "if ((a | b) & mask)", so we do that by hand.
+ */
+__attribute_const__ __always_inline
+static bool is_aligned(const void *base, size_t size, unsigned char align)
 {
-	return IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ||
-		((unsigned long)base & (align - 1)) == 0;
+	unsigned char lsbits = (unsigned char)size;
+
+	(void)base;
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+	lsbits |= (unsigned char)(uintptr_t)base;
+#endif
+	return (lsbits & (align - 1)) == 0;
 }
 
-static void u32_swap(void *a, void *b, int size)
+/**
+ * swap_words_32 - swap two elements in 32-bit chunks
+ * @a, @b: pointers to the elements
+ * @size: element size (must be a multiple of 4)
+ *
+ * Exchange the two objects in memory.  This exploits base+index addressing,
+ * which basically all CPUs have, to minimize loop overhead computations.
+ *
+ * For some reason, on x86 gcc 7.3.0 adds a redundant test of n at the
+ * bottom of the loop, even though the zero flag is stil valid from the
+ * subtract (since the intervening mov instructions don't alter the flags).
+ * Gcc 8.1.0 doesn't have that problem.
+ */
+static void swap_words_32(void *a, void *b, int size)
 {
-	u32 t = *(u32 *)a;
-	*(u32 *)a = *(u32 *)b;
-	*(u32 *)b = t;
+	size_t n = (unsigned int)size;
+
+	do {
+		u32 t = *(u32 *)(a + (n -= 4));
+		*(u32 *)(a + n) = *(u32 *)(b + n);
+		*(u32 *)(b + n) = t;
+	} while (n);
 }
 
-static void u64_swap(void *a, void *b, int size)
+/**
+ * swap_words_64 - swap two elements in 64-bit chunks
+ * @a, @b: pointers to the elements
+ * @size: element size (must be a multiple of 8)
+ *
+ * Exchange the two objects in memory.  This exploits base+index
+ * addressing, which basically all CPUs have, to minimize loop overhead
+ * computations.
+ *
+ * We'd like to use 64-bit loads if possible.  If they're not, emulating
+ * one requires base+index+4 addressing which x86 has but most other
+ * processors do not.  If CONFIG_64BIT, we definitely have 64-bit loads,
+ * but it's possible to have 64-bit loads without 64-bit pointers (e.g.
+ * x32 ABI).  Are there any cases the kernel needs to worry about?
+ */
+static void swap_words_64(void *a, void *b, int size)
 {
-	u64 t = *(u64 *)a;
-	*(u64 *)a = *(u64 *)b;
-	*(u64 *)b = t;
+	size_t n = (unsigned int)size;
+
+	do {
+#ifdef CONFIG_64BIT
+		u64 t = *(u64 *)(a + (n -= 8));
+		*(u64 *)(a + n) = *(u64 *)(b + n);
+		*(u64 *)(b + n) = t;
+#else
+		/* Use two 32-bit transfers to avoid base+index+4 addressing */
+		u32 t = *(u32 *)(a + (n -= 4));
+		*(u32 *)(a + n) = *(u32 *)(b + n);
+		*(u32 *)(b + n) = t;
+
+		t = *(u32 *)(a + (n -= 4));
+		*(u32 *)(a + n) = *(u32 *)(b + n);
+		*(u32 *)(b + n) = t;
+#endif
+	} while (n);
 }
 
-static void generic_swap(void *a, void *b, int size)
+/**
+ * swap_bytes - swap two elements a byte at a time
+ * @a, @b: pointers to the elements
+ * @size: element size
+ *
+ * This is the fallback if alignment doesn't allow using larger chunks.
+ */
+static void swap_bytes(void *a, void *b, int size)
 {
-	char t;
+	size_t n = (unsigned int)size;
 
 	do {
-		t = *(char *)a;
-		*(char *)a++ = *(char *)b;
-		*(char *)b++ = t;
-	} while (--size > 0);
+		char t = ((char *)a)[--n];
+		((char *)a)[n] = ((char *)b)[n];
+		((char *)b)[n] = t;
+	} while (n);
 }
 
 /**
@@ -50,8 +123,10 @@ static void generic_swap(void *a, void *b, int size)
  * @cmp_func: pointer to comparison function
  * @swap_func: pointer to swap function or NULL
  *
- * This function does a heapsort on the given array. You may provide a
- * swap_func function optimized to your element type.
+ * This function does a heapsort on the given array.  You may provide
+ * a swap_func function if you need to do something more than a memory
+ * copy (e.g. fix up pointers or auxiliary data), but the built-in swap
+ * isn't usually a bottleneck.
  *
  * Sorting time is O(n log n) both on average and worst-case. While
  * qsort is about 20% faster on average, it suffers from exploitable
@@ -67,12 +142,12 @@ void sort(void *base, size_t num, size_t size,
 	int i = (num/2 - 1) * size, n = num * size, c, r;
 
 	if (!swap_func) {
-		if (size == 4 && alignment_ok(base, 4))
-			swap_func = u32_swap;
-		else if (size == 8 && alignment_ok(base, 8))
-			swap_func = u64_swap;
+		if (is_aligned(base, size, 8))
+			swap_func = swap_words_64;
+		else if (is_aligned(base, size, 4))
+			swap_func = swap_words_32;
 		else
-			swap_func = generic_swap;
+			swap_func = swap_bytes;
 	}
 
 	/* heapify */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 975c6ef6fec7..d6b7a202b0b6 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * A fast, small, non-recursive O(nlog n) sort for the Linux kernel
  *

commit c5adae9583ef6985875532904160c6bf9f07b453
Author: Kostenzer Felix <fkostenzer@live.at>
Date:   Fri Feb 24 15:01:07 2017 -0800

    lib: add CONFIG_TEST_SORT to enable self-test of sort()
    
    Along with the addition made to Kconfig.debug, the prior existing but
    permanently disabled test function has been slightly refactored.
    
    Patch has been tested using QEMU 2.1.2 with a .config obtained through
    'make defconfig' (x86_64) and manually enabling the option.
    
    [arnd@arndb.de: move sort self-test into a separate file]
      Link: http://lkml.kernel.org/r/20170112110657.3123790-1-arnd@arndb.de
    Link: http://lkml.kernel.org/r/HE1PR09MB0394B0418D504DCD27167D4FD49B0@HE1PR09MB0394.eurprd09.prod.outlook.com
    Signed-off-by: Kostenzer Felix <fkostenzer@live.at>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index fc20df42aa6f..975c6ef6fec7 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -4,6 +4,8 @@
  * Jan 23 2005  Matt Mackall <mpm@selenic.com>
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/types.h>
 #include <linux/export.h>
 #include <linux/sort.h>
@@ -101,42 +103,3 @@ void sort(void *base, size_t num, size_t size,
 }
 
 EXPORT_SYMBOL(sort);
-
-#if 0
-#include <linux/slab.h>
-/* a simple boot-time regression test */
-
-int cmpint(const void *a, const void *b)
-{
-	return *(int *)a - *(int *)b;
-}
-
-static int sort_test(void)
-{
-	int *a, i, r = 1;
-
-	a = kmalloc(1000 * sizeof(int), GFP_KERNEL);
-	BUG_ON(!a);
-
-	printk("testing sort()\n");
-
-	for (i = 0; i < 1000; i++) {
-		r = (r * 725861) % 6599;
-		a[i] = r;
-	}
-
-	sort(a, 1000, sizeof(int), cmpint, NULL);
-
-	for (i = 0; i < 999; i++)
-		if (a[i] > a[i+1]) {
-			printk("sort() failed!\n");
-			break;
-		}
-
-	kfree(a);
-
-	return 0;
-}
-
-module_init(sort_test);
-#endif

commit ca96ab859ab4b5dad1709a6a22613920d19bfbbb
Author: Daniel Wagner <daniel.wagner@bmw-carit.de>
Date:   Thu Jun 25 15:02:14 2015 -0700

    lib/sort: Add 64 bit swap function
    
    In case the call side is not providing a swap function, we either use a
    32 bit or a generic swap function.  When swapping around pointers on 64
    bit architectures falling back to use the generic swap function seems
    like an unnecessary waste.
    
    There at least 9 users ('sort' is of difficult to grep for) of sort()
    and all of them use the sort function without a customized swap
    function.  Furthermore, they are all using pointers to swap around:
    
    arch/x86/kernel/e820.c:sanitize_e820_map()
    arch/x86/mm/extable.c:sort_extable()
    drivers/acpi/fan.c:acpi_fan_get_fps()
    fs/btrfs/super.c:btrfs_descending_sort_devices()
    fs/xfs/libxfs/xfs_dir2_block.c:xfs_dir2_sf_to_block()
    kernel/range.c:clean_sort_range()
    mm/memcontrol.c:__mem_cgroup_usage_register_event()
    sound/pci/hda/hda_auto_parser.c:snd_hda_parse_pin_defcfg()
    sound/pci/hda/hda_auto_parser.c:sort_pins_by_sequence()
    
    Obviously, we could improve the swap for other sizes as well
    but this is overkill at this point.
    
    A simple test shows sorting a 400 element array (try to stay in one
    page) with either with u32_swap() or u64_swap() show that the theory
    actually works. This test was done on a x86_64 (Intel Xeon E5-4610)
    machine.
    
    - swap_32:
    
    NumSamples = 100; Min = 48.00; Max = 49.00
    Mean = 48.320000; Variance = 0.217600; SD = 0.466476; Median 48.000000
    each * represents a count of 1
       48.0000 -    48.1000 [    68]: ********************************************************************
       48.1000 -    48.2000 [     0]:
       48.2000 -    48.3000 [     0]:
       48.3000 -    48.4000 [     0]:
       48.4000 -    48.5000 [     0]:
       48.5000 -    48.6000 [     0]:
       48.6000 -    48.7000 [     0]:
       48.7000 -    48.8000 [     0]:
       48.8000 -    48.9000 [     0]:
       48.9000 -    49.0000 [    32]: ********************************
    
    - swap_64:
    
    NumSamples = 100; Min = 44.00; Max = 63.00
    Mean = 48.250000; Variance = 18.687500; SD = 4.322904; Median 47.000000
    each * represents a count of 1
       44.0000 -    45.9000 [    15]: ***************
       45.9000 -    47.8000 [    37]: *************************************
       47.8000 -    49.7000 [    39]: ***************************************
       49.7000 -    51.6000 [     0]:
       51.6000 -    53.5000 [     0]:
       53.5000 -    55.4000 [     0]:
       55.4000 -    57.3000 [     0]:
       57.3000 -    59.2000 [     1]: *
       59.2000 -    61.1000 [     3]: ***
       61.1000 -    63.0000 [     5]: *****
    
    - swap_72:
    
    NumSamples = 100; Min = 53.00; Max = 71.00
    Mean = 55.070000; Variance = 21.565100; SD = 4.643824; Median 53.000000
    each * represents a count of 1
       53.0000 -    54.8000 [    73]: *************************************************************************
       54.8000 -    56.6000 [     9]: *********
       56.6000 -    58.4000 [     9]: *********
       58.4000 -    60.2000 [     0]:
       60.2000 -    62.0000 [     0]:
       62.0000 -    63.8000 [     0]:
       63.8000 -    65.6000 [     0]:
       65.6000 -    67.4000 [     1]: *
       67.4000 -    69.2000 [     4]: ****
       69.2000 -    71.0000 [     4]: ****
    
    - test program:
    
    static int cmp_32(const void *a, const void *b)
    {
            u32 l = *(u32 *)a;
            u32 r = *(u32 *)b;
    
            if (l < r)
                    return -1;
            if (l > r)
                    return 1;
            return 0;
    }
    
    static int cmp_64(const void *a, const void *b)
    {
            u64 l = *(u64 *)a;
            u64 r = *(u64 *)b;
    
            if (l < r)
                    return -1;
            if (l > r)
                    return 1;
            return 0;
    }
    
    static int cmp_72(const void *a, const void *b)
    {
            u32 l = get_unaligned((u32 *) a);
            u32 r = get_unaligned((u32 *) b);
    
            if (l < r)
                    return -1;
            if (l > r)
                    return 1;
            return 0;
    }
    
    static void init_array32(void *array)
    {
            u32 *a = array;
            int i;
    
            a[0] = 3821;
            for (i = 1; i < ARRAY_ELEMENTS; i++)
                    a[i] = next_pseudo_random32(a[i-1]);
    }
    
    static void init_array64(void *array)
    {
            u64 *a = array;
            int i;
    
            a[0] = 3821;
            for (i = 1; i < ARRAY_ELEMENTS; i++)
                    a[i] = next_pseudo_random32(a[i-1]);
    }
    
    static void init_array72(void *array)
    {
            char *p;
            u32 v;
            int i;
    
            v = 3821;
            for (i = 0; i < ARRAY_ELEMENTS; i++) {
                    p = (char *)array + (i * 9);
                    put_unaligned(v, (u32*) p);
                    v = next_pseudo_random32(v);
            }
    }
    
    static void sort_test(void (*init)(void *array),
                          int (*cmp) (const void *, const void *),
                          void *array, size_t size)
    {
            ktime_t start, stop;
            int i;
    
            for (i = 0; i < 10000; i++) {
                    init(array);
    
                    local_irq_disable();
                    start = ktime_get();
    
                    sort(array, ARRAY_ELEMENTS, size, cmp, NULL);
    
                    stop = ktime_get();
                    local_irq_enable();
    
                    if (i > 10000 - 101)
                      pr_info("%lld\n",  ktime_to_us(ktime_sub(stop, start)));
            }
    }
    
    static void *create_array(size_t size)
    {
            void *array;
    
            array = kmalloc(ARRAY_ELEMENTS * size, GFP_KERNEL);
            if (!array)
                    return NULL;
    
            return array;
    }
    
    static int perform_test(size_t size)
    {
            void *array;
    
            array = create_array(size);
            if (!array)
                    return -ENOMEM;
    
            pr_info("test element size %d bytes\n", (int)size);
            switch (size) {
            case 4:
                    sort_test(init_array32, cmp_32, array, size);
                    break;
            case 8:
                    sort_test(init_array64, cmp_64, array, size);
                    break;
            case 9:
                    sort_test(init_array72, cmp_72, array, size);
                    break;
            }
            kfree(array);
    
            return 0;
    }
    
    static int __init sort_tests_init(void)
    {
            int err;
    
            err = perform_test(sizeof(u32));
            if (err)
                    return err;
    
            err = perform_test(sizeof(u64));
            if (err)
                    return err;
    
            err = perform_test(sizeof(u64)+1);
            if (err)
                    return err;
    
            return 0;
    }
    
    static void __exit sort_tests_exit(void)
    {
    }
    
    module_init(sort_tests_init);
    module_exit(sort_tests_exit);
    
    MODULE_LICENSE("GPL v2");
    MODULE_AUTHOR("Daniel Wagner");
    MODULE_DESCRIPTION("sort perfomance tests");
    
    Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 43c9fe73ae2e..fc20df42aa6f 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -8,6 +8,12 @@
 #include <linux/export.h>
 #include <linux/sort.h>
 
+static int alignment_ok(const void *base, int align)
+{
+	return IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ||
+		((unsigned long)base & (align - 1)) == 0;
+}
+
 static void u32_swap(void *a, void *b, int size)
 {
 	u32 t = *(u32 *)a;
@@ -15,6 +21,13 @@ static void u32_swap(void *a, void *b, int size)
 	*(u32 *)b = t;
 }
 
+static void u64_swap(void *a, void *b, int size)
+{
+	u64 t = *(u64 *)a;
+	*(u64 *)a = *(u64 *)b;
+	*(u64 *)b = t;
+}
+
 static void generic_swap(void *a, void *b, int size)
 {
 	char t;
@@ -50,8 +63,14 @@ void sort(void *base, size_t num, size_t size,
 	/* pre-scale counters for performance */
 	int i = (num/2 - 1) * size, n = num * size, c, r;
 
-	if (!swap_func)
-		swap_func = (size == 4 ? u32_swap : generic_swap);
+	if (!swap_func) {
+		if (size == 4 && alignment_ok(base, 4))
+			swap_func = u32_swap;
+		else if (size == 8 && alignment_ok(base, 8))
+			swap_func = u64_swap;
+		else
+			swap_func = generic_swap;
+	}
 
 	/* heapify */
 	for ( ; i >= 0; i -= size) {

commit 2ddae683bf36d50b960402a94a55047ab0c73e2c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Feb 12 15:03:10 2015 -0800

    lib/sort.c: move include inside #if 0
    
    The sort function and its helpers don't do memory allocation, so the
    slab.h include is redundant.  Move it inside the #if 0 protecting the
    self-test, similar to how it is done in lib/list_sort.c.  This removes
    over 450 lines from the generated dependency file.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 14fc1dfadb3f..43c9fe73ae2e 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -7,7 +7,6 @@
 #include <linux/types.h>
 #include <linux/export.h>
 #include <linux/sort.h>
-#include <linux/slab.h>
 
 static void u32_swap(void *a, void *b, int size)
 {
@@ -85,6 +84,7 @@ void sort(void *base, size_t num, size_t size,
 EXPORT_SYMBOL(sort);
 
 #if 0
+#include <linux/slab.h>
 /* a simple boot-time regression test */
 
 int cmpint(const void *a, const void *b)

commit 42cf809654e4ea2fa16dd73608e153f1c6f7c2ed
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Feb 12 15:02:35 2015 -0800

    lib/sort.c: use simpler includes
    
    sort.c doesn't use facilities from kernel.h, but does use some types
    defined in linux/types.h.  Include the latter directly instead of relying
    on some other header doing it.  Similarly, include linux/export.h directly
    instead of through module.h.  This removes 80 lines from the dependency
    file .sort.o.cmd.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 926d00429ed2..14fc1dfadb3f 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -4,8 +4,8 @@
  * Jan 23 2005  Matt Mackall <mpm@selenic.com>
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/export.h>
 #include <linux/sort.h>
 #include <linux/slab.h>
 

commit b53907c0100a353a7ac53bed260e735e5ccbbbcc
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Wed Jan 7 18:09:11 2009 -0800

    generic swap(): lib/sort.c: rename swap to swap_func
    
    This is to avoid name clashes for the introduction of a global swap()
    macro.
    
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 6abbaf3d5858..926d00429ed2 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -32,11 +32,11 @@ static void generic_swap(void *a, void *b, int size)
  * @base: pointer to data to sort
  * @num: number of elements
  * @size: size of each element
- * @cmp: pointer to comparison function
- * @swap: pointer to swap function or NULL
+ * @cmp_func: pointer to comparison function
+ * @swap_func: pointer to swap function or NULL
  *
  * This function does a heapsort on the given array. You may provide a
- * swap function optimized to your element type.
+ * swap_func function optimized to your element type.
  *
  * Sorting time is O(n log n) both on average and worst-case. While
  * qsort is about 20% faster on average, it suffers from exploitable
@@ -45,37 +45,39 @@ static void generic_swap(void *a, void *b, int size)
  */
 
 void sort(void *base, size_t num, size_t size,
-	  int (*cmp)(const void *, const void *),
-	  void (*swap)(void *, void *, int size))
+	  int (*cmp_func)(const void *, const void *),
+	  void (*swap_func)(void *, void *, int size))
 {
 	/* pre-scale counters for performance */
 	int i = (num/2 - 1) * size, n = num * size, c, r;
 
-	if (!swap)
-		swap = (size == 4 ? u32_swap : generic_swap);
+	if (!swap_func)
+		swap_func = (size == 4 ? u32_swap : generic_swap);
 
 	/* heapify */
 	for ( ; i >= 0; i -= size) {
 		for (r = i; r * 2 + size < n; r  = c) {
 			c = r * 2 + size;
-			if (c < n - size && cmp(base + c, base + c + size) < 0)
+			if (c < n - size &&
+					cmp_func(base + c, base + c + size) < 0)
 				c += size;
-			if (cmp(base + r, base + c) >= 0)
+			if (cmp_func(base + r, base + c) >= 0)
 				break;
-			swap(base + r, base + c, size);
+			swap_func(base + r, base + c, size);
 		}
 	}
 
 	/* sort */
 	for (i = n - size; i > 0; i -= size) {
-		swap(base, base + i, size);
+		swap_func(base, base + i, size);
 		for (r = 0; r * 2 + size < i; r = c) {
 			c = r * 2 + size;
-			if (c < i - size && cmp(base + c, base + c + size) < 0)
+			if (c < i - size &&
+					cmp_func(base + c, base + c + size) < 0)
 				c += size;
-			if (cmp(base + r, base + c) >= 0)
+			if (cmp_func(base + r, base + c) >= 0)
 				break;
-			swap(base + r, base + c, size);
+			swap_func(base + r, base + c, size);
 		}
 	}
 }

commit 995e4286a047b32aebf8ce540908edb7fbd93f76
Author: Subbaiah Venkata <kvsnaidu@sapnaidu.net>
Date:   Tue Oct 16 23:27:06 2007 -0700

    lib/sort.c optimization
    
    Hello, I fixed and tested a small bug in lib/sort.c file, heap sort
    function.
    
    The fix avoids unnecessary swap of contents when i is 0 (saves few loads
    and stores), which happens every time sort function is called.  I felt the
    fix is worth bringing it to your attention given the importance and
    frequent use of the sort function.
    
    Acked-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 961567894d16..6abbaf3d5858 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -67,7 +67,7 @@ void sort(void *base, size_t num, size_t size,
 	}
 
 	/* sort */
-	for (i = n - size; i >= 0; i -= size) {
+	for (i = n - size; i > 0; i -= size) {
 		swap(base, base + i, size);
 		for (r = 0; r * 2 + size < i; r = c) {
 			c = r * 2 + size;

commit 72fd4a35a824331d7a0f4168d7576502d95d34b3
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sat Feb 10 01:45:59 2007 -0800

    [PATCH] Numerous fixes to kernel-doc info in source files.
    
    A variety of (mostly) innocuous fixes to the embedded kernel-doc content in
    source files, including:
    
      * make multi-line initial descriptions single line
      * denote some function names, constants and structs as such
      * change erroneous opening '/*' to '/**' in a few places
      * reword some text for clarity
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/sort.c b/lib/sort.c
index 488788b341cb..961567894d16 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -27,7 +27,7 @@ static void generic_swap(void *a, void *b, int size)
 	} while (--size > 0);
 }
 
-/*
+/**
  * sort - sort an array of elements
  * @base: pointer to data to sort
  * @num: number of elements

commit d3717bdf8f08a0e1039158c8bab2c24d20f492b6
Author: keios <keios.cn@gmail.com>
Date:   Tue Oct 3 01:13:49 2006 -0700

    [PATCH] low performance of lib/sort.c
    
    It is a non-standard heap-sort algorithm implementation because the index
    of child node is wrong .  The sort function still outputs right result, but
    the performance is O( n * ( log(n) + 1 ) ) , about 10% ~ 20% worse than
    standard algorithm.
    
    Signed-off-by: keios <keios.cn@gmail.com>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Acked-by: Zou Nan hai <nanhai.zou@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/sort.c b/lib/sort.c
index 5f3b51ffa1dc..488788b341cb 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -49,15 +49,15 @@ void sort(void *base, size_t num, size_t size,
 	  void (*swap)(void *, void *, int size))
 {
 	/* pre-scale counters for performance */
-	int i = (num/2) * size, n = num * size, c, r;
+	int i = (num/2 - 1) * size, n = num * size, c, r;
 
 	if (!swap)
 		swap = (size == 4 ? u32_swap : generic_swap);
 
 	/* heapify */
 	for ( ; i >= 0; i -= size) {
-		for (r = i; r * 2 < n; r  = c) {
-			c = r * 2;
+		for (r = i; r * 2 + size < n; r  = c) {
+			c = r * 2 + size;
 			if (c < n - size && cmp(base + c, base + c + size) < 0)
 				c += size;
 			if (cmp(base + r, base + c) >= 0)
@@ -69,8 +69,8 @@ void sort(void *base, size_t num, size_t size,
 	/* sort */
 	for (i = n - size; i >= 0; i -= size) {
 		swap(base, base + i, size);
-		for (r = 0; r * 2 < i; r = c) {
-			c = r * 2;
+		for (r = 0; r * 2 + size < i; r = c) {
+			c = r * 2 + size;
 			if (c < i - size && cmp(base + c, base + c + size) < 0)
 				c += size;
 			if (cmp(base + r, base + c) >= 0)

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/sort.c b/lib/sort.c
index ddc4d35df289..5f3b51ffa1dc 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -7,6 +7,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/sort.h>
+#include <linux/slab.h>
 
 static void u32_swap(void *a, void *b, int size)
 {

commit ecec4cb7a9df5f61fe00710d2f2c69ce9a3b1d40
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Sep 10 00:26:59 2005 -0700

    [PATCH] lib/sort.c: small cleanups
    
    This patch contains the following small cleanups:
    - make two needlessly global functions static
    - every file should #include the header files containing the prototypes
      of it's global functions
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/sort.c b/lib/sort.c
index b73dbb0e7c83..ddc4d35df289 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -6,15 +6,16 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/sort.h>
 
-void u32_swap(void *a, void *b, int size)
+static void u32_swap(void *a, void *b, int size)
 {
 	u32 t = *(u32 *)a;
 	*(u32 *)a = *(u32 *)b;
 	*(u32 *)b = t;
 }
 
-void generic_swap(void *a, void *b, int size)
+static void generic_swap(void *a, void *b, int size)
 {
 	char t;
 

commit d28c2bc8d192f606a4eb831978722107b20a9405
Author: Domen Puncer <domen@coderock.org>
Date:   Thu May 5 16:16:19 2005 -0700

    [PATCH] fix lib/sort regression test
    
    The regression test in lib/sort.c is currently worthless because the array
    that is generated for sorting will be all zeros.  This patch fixes things
    so that the array that is generated will contain unsorted integers (that
    are not all identical) as was probably intended.
    
    Signed-off-by Daniel Dickman <didickman@yahoo.com>
    Signed-off-by: Domen Puncer <domen@coderock.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/lib/sort.c b/lib/sort.c
index ea3caedeabdb..b73dbb0e7c83 100644
--- a/lib/sort.c
+++ b/lib/sort.c
@@ -90,7 +90,7 @@ int cmpint(const void *a, const void *b)
 
 static int sort_test(void)
 {
-	int *a, i, r = 0;
+	int *a, i, r = 1;
 
 	a = kmalloc(1000 * sizeof(int), GFP_KERNEL);
 	BUG_ON(!a);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/lib/sort.c b/lib/sort.c
new file mode 100644
index 000000000000..ea3caedeabdb
--- /dev/null
+++ b/lib/sort.c
@@ -0,0 +1,119 @@
+/*
+ * A fast, small, non-recursive O(nlog n) sort for the Linux kernel
+ *
+ * Jan 23 2005  Matt Mackall <mpm@selenic.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+void u32_swap(void *a, void *b, int size)
+{
+	u32 t = *(u32 *)a;
+	*(u32 *)a = *(u32 *)b;
+	*(u32 *)b = t;
+}
+
+void generic_swap(void *a, void *b, int size)
+{
+	char t;
+
+	do {
+		t = *(char *)a;
+		*(char *)a++ = *(char *)b;
+		*(char *)b++ = t;
+	} while (--size > 0);
+}
+
+/*
+ * sort - sort an array of elements
+ * @base: pointer to data to sort
+ * @num: number of elements
+ * @size: size of each element
+ * @cmp: pointer to comparison function
+ * @swap: pointer to swap function or NULL
+ *
+ * This function does a heapsort on the given array. You may provide a
+ * swap function optimized to your element type.
+ *
+ * Sorting time is O(n log n) both on average and worst-case. While
+ * qsort is about 20% faster on average, it suffers from exploitable
+ * O(n*n) worst-case behavior and extra memory requirements that make
+ * it less suitable for kernel use.
+ */
+
+void sort(void *base, size_t num, size_t size,
+	  int (*cmp)(const void *, const void *),
+	  void (*swap)(void *, void *, int size))
+{
+	/* pre-scale counters for performance */
+	int i = (num/2) * size, n = num * size, c, r;
+
+	if (!swap)
+		swap = (size == 4 ? u32_swap : generic_swap);
+
+	/* heapify */
+	for ( ; i >= 0; i -= size) {
+		for (r = i; r * 2 < n; r  = c) {
+			c = r * 2;
+			if (c < n - size && cmp(base + c, base + c + size) < 0)
+				c += size;
+			if (cmp(base + r, base + c) >= 0)
+				break;
+			swap(base + r, base + c, size);
+		}
+	}
+
+	/* sort */
+	for (i = n - size; i >= 0; i -= size) {
+		swap(base, base + i, size);
+		for (r = 0; r * 2 < i; r = c) {
+			c = r * 2;
+			if (c < i - size && cmp(base + c, base + c + size) < 0)
+				c += size;
+			if (cmp(base + r, base + c) >= 0)
+				break;
+			swap(base + r, base + c, size);
+		}
+	}
+}
+
+EXPORT_SYMBOL(sort);
+
+#if 0
+/* a simple boot-time regression test */
+
+int cmpint(const void *a, const void *b)
+{
+	return *(int *)a - *(int *)b;
+}
+
+static int sort_test(void)
+{
+	int *a, i, r = 0;
+
+	a = kmalloc(1000 * sizeof(int), GFP_KERNEL);
+	BUG_ON(!a);
+
+	printk("testing sort()\n");
+
+	for (i = 0; i < 1000; i++) {
+		r = (r * 725861) % 6599;
+		a[i] = r;
+	}
+
+	sort(a, 1000, sizeof(int), cmpint, NULL);
+
+	for (i = 0; i < 999; i++)
+		if (a[i] > a[i+1]) {
+			printk("sort() failed!\n");
+			break;
+		}
+
+	kfree(a);
+
+	return 0;
+}
+
+module_init(sort_test);
+#endif
