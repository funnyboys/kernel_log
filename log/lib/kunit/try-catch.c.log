commit 1c024d45151b51c8f8d4749e65958b0bcf3e7c52
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Mon Jan 6 22:28:21 2020 +0000

    kunit: remove timeout dependence on sysctl_hung_task_timeout_seconds
    
    In discussion of how to handle timeouts, it was noted that if
    sysctl_hung_task_timeout_seconds is exceeded for a kunit test,
    the test task will be killed and an oops generated.  This should
    suffice as a means of debugging such timeout issues for now.
    
    Hence remove use of sysctl_hung_task_timeout_secs, which has the
    added benefit of avoiding the need to export that symbol from
    the core kernel.
    
    Co-developed-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Acked-by: Brendan Higgins <brendanhiggins@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/lib/kunit/try-catch.c b/lib/kunit/try-catch.c
index 0247a281431a..0dd434e40487 100644
--- a/lib/kunit/try-catch.c
+++ b/lib/kunit/try-catch.c
@@ -11,7 +11,6 @@
 #include <linux/completion.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
-#include <linux/sched/sysctl.h>
 
 #include "try-catch-impl.h"
 
@@ -33,8 +32,6 @@ static int kunit_generic_run_threadfn_adapter(void *data)
 
 static unsigned long kunit_test_timeout(void)
 {
-	unsigned long timeout_msecs;
-
 	/*
 	 * TODO(brendanhiggins@google.com): We should probably have some type of
 	 * variable timeout here. The only question is what that timeout value
@@ -51,22 +48,11 @@ static unsigned long kunit_test_timeout(void)
 	 *
 	 * For more background on this topic, see:
 	 * https://mike-bland.com/2011/11/01/small-medium-large.html
+	 *
+	 * If tests timeout due to exceeding sysctl_hung_task_timeout_secs,
+	 * the task will be killed and an oops generated.
 	 */
-	if (sysctl_hung_task_timeout_secs) {
-		/*
-		 * If sysctl_hung_task is active, just set the timeout to some
-		 * value less than that.
-		 *
-		 * In regards to the above TODO, if we decide on variable
-		 * timeouts, this logic will likely need to change.
-		 */
-		timeout_msecs = (sysctl_hung_task_timeout_secs - 1) *
-				MSEC_PER_SEC;
-	} else {
-		timeout_msecs = 300 * MSEC_PER_SEC; /* 5 min */
-	}
-
-	return timeout_msecs;
+	return 300 * MSEC_PER_SEC; /* 5 min */
 }
 
 void kunit_try_catch_run(struct kunit_try_catch *try_catch, void *context)

commit c475c77d5b56398303e726969e81208196b3aab3
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Mon Jan 6 22:28:20 2020 +0000

    kunit: allow kunit tests to be loaded as a module
    
    As tests are added to kunit, it will become less feasible to execute
    all built tests together.  By supporting modular tests we provide
    a simple way to do selective execution on a running system; specifying
    
    CONFIG_KUNIT=y
    CONFIG_KUNIT_EXAMPLE_TEST=m
    
    ...means we can simply "insmod example-test.ko" to run the tests.
    
    To achieve this we need to do the following:
    
    o export the required symbols in kunit
    o string-stream tests utilize non-exported symbols so for now we skip
      building them when CONFIG_KUNIT_TEST=m.
    o drivers/base/power/qos-test.c contains a few unexported interface
      references, namely freq_qos_read_value() and freq_constraints_init().
      Both of these could be potentially defined as static inline functions
      in include/linux/pm_qos.h, but for now we simply avoid supporting
      module build for that test suite.
    o support a new way of declaring test suites.  Because a module cannot
      do multiple late_initcall()s, we provide a kunit_test_suites() macro
      to declare multiple suites within the same module at once.
    o some test module names would have been too general ("test-test"
      and "example-test" for kunit tests, "inode-test" for ext4 tests);
      rename these as appropriate ("kunit-test", "kunit-example-test"
      and "ext4-inode-test" respectively).
    
    Also define kunit_test_suite() via kunit_test_suites()
    as callers in other trees may need the old definition.
    
    Co-developed-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-by: Theodore Ts'o <tytso@mit.edu> # for ext4 bits
    Acked-by: David Gow <davidgow@google.com> # For list-test
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/lib/kunit/try-catch.c b/lib/kunit/try-catch.c
index 4a66d1684b46..0247a281431a 100644
--- a/lib/kunit/try-catch.c
+++ b/lib/kunit/try-catch.c
@@ -20,6 +20,7 @@ void __noreturn kunit_try_catch_throw(struct kunit_try_catch *try_catch)
 	try_catch->try_result = -EFAULT;
 	complete_and_exit(try_catch->try_completion, -EFAULT);
 }
+EXPORT_SYMBOL_GPL(kunit_try_catch_throw);
 
 static int kunit_generic_run_threadfn_adapter(void *data)
 {
@@ -107,3 +108,4 @@ void kunit_try_catch_run(struct kunit_try_catch *try_catch, void *context)
 
 	try_catch->catch(try_catch->context);
 }
+EXPORT_SYMBOL_GPL(kunit_try_catch_run);

commit 9bbb11c6be4623e38fdef8af0178c174acded9a6
Author: Alan Maguire <alan.maguire@oracle.com>
Date:   Mon Jan 6 22:28:19 2020 +0000

    kunit: hide unexported try-catch interface in try-catch-impl.h
    
    Define function as static inline in try-catch-impl.h to allow it to
    be used in kunit itself and tests.  Also remove unused
    kunit_generic_try_catch
    
    Co-developed-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Knut Omang <knut.omang@oracle.com>
    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Tested-by: Brendan Higgins <brendanhiggins@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/lib/kunit/try-catch.c b/lib/kunit/try-catch.c
index 55686839eb61..4a66d1684b46 100644
--- a/lib/kunit/try-catch.c
+++ b/lib/kunit/try-catch.c
@@ -8,12 +8,13 @@
  */
 
 #include <kunit/test.h>
-#include <kunit/try-catch.h>
 #include <linux/completion.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
 #include <linux/sched/sysctl.h>
 
+#include "try-catch-impl.h"
+
 void __noreturn kunit_try_catch_throw(struct kunit_try_catch *try_catch)
 {
 	try_catch->try_result = -EFAULT;
@@ -106,13 +107,3 @@ void kunit_try_catch_run(struct kunit_try_catch *try_catch, void *context)
 
 	try_catch->catch(try_catch->context);
 }
-
-void kunit_try_catch_init(struct kunit_try_catch *try_catch,
-			  struct kunit *test,
-			  kunit_try_catch_func_t try,
-			  kunit_try_catch_func_t catch)
-{
-	try_catch->test = test;
-	try_catch->try = try;
-	try_catch->catch = catch;
-}

commit 5f3e06208920ee78b68cf3527f40ffbff83cb3bc
Author: Brendan Higgins <brendanhiggins@google.com>
Date:   Mon Sep 23 02:02:39 2019 -0700

    kunit: test: add support for test abort
    
    Add support for aborting/bailing out of test cases, which is needed for
    implementing assertions.
    
    An assertion is like an expectation, but bails out of the test case
    early if the assertion is not met. The idea with assertions is that you
    use them to state all the preconditions for your test. Logically
    speaking, these are the premises of the test case, so if a premise isn't
    true, there is no point in continuing the test case because there are no
    conclusions that can be drawn without the premises. Whereas, the
    expectation is the thing you are trying to prove.
    
    Signed-off-by: Brendan Higgins <brendanhiggins@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Logan Gunthorpe <logang@deltatee.com>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

diff --git a/lib/kunit/try-catch.c b/lib/kunit/try-catch.c
new file mode 100644
index 000000000000..55686839eb61
--- /dev/null
+++ b/lib/kunit/try-catch.c
@@ -0,0 +1,118 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * An API to allow a function, that may fail, to be executed, and recover in a
+ * controlled manner.
+ *
+ * Copyright (C) 2019, Google LLC.
+ * Author: Brendan Higgins <brendanhiggins@google.com>
+ */
+
+#include <kunit/test.h>
+#include <kunit/try-catch.h>
+#include <linux/completion.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/sched/sysctl.h>
+
+void __noreturn kunit_try_catch_throw(struct kunit_try_catch *try_catch)
+{
+	try_catch->try_result = -EFAULT;
+	complete_and_exit(try_catch->try_completion, -EFAULT);
+}
+
+static int kunit_generic_run_threadfn_adapter(void *data)
+{
+	struct kunit_try_catch *try_catch = data;
+
+	try_catch->try(try_catch->context);
+
+	complete_and_exit(try_catch->try_completion, 0);
+}
+
+static unsigned long kunit_test_timeout(void)
+{
+	unsigned long timeout_msecs;
+
+	/*
+	 * TODO(brendanhiggins@google.com): We should probably have some type of
+	 * variable timeout here. The only question is what that timeout value
+	 * should be.
+	 *
+	 * The intention has always been, at some point, to be able to label
+	 * tests with some type of size bucket (unit/small, integration/medium,
+	 * large/system/end-to-end, etc), where each size bucket would get a
+	 * default timeout value kind of like what Bazel does:
+	 * https://docs.bazel.build/versions/master/be/common-definitions.html#test.size
+	 * There is still some debate to be had on exactly how we do this. (For
+	 * one, we probably want to have some sort of test runner level
+	 * timeout.)
+	 *
+	 * For more background on this topic, see:
+	 * https://mike-bland.com/2011/11/01/small-medium-large.html
+	 */
+	if (sysctl_hung_task_timeout_secs) {
+		/*
+		 * If sysctl_hung_task is active, just set the timeout to some
+		 * value less than that.
+		 *
+		 * In regards to the above TODO, if we decide on variable
+		 * timeouts, this logic will likely need to change.
+		 */
+		timeout_msecs = (sysctl_hung_task_timeout_secs - 1) *
+				MSEC_PER_SEC;
+	} else {
+		timeout_msecs = 300 * MSEC_PER_SEC; /* 5 min */
+	}
+
+	return timeout_msecs;
+}
+
+void kunit_try_catch_run(struct kunit_try_catch *try_catch, void *context)
+{
+	DECLARE_COMPLETION_ONSTACK(try_completion);
+	struct kunit *test = try_catch->test;
+	struct task_struct *task_struct;
+	int exit_code, time_remaining;
+
+	try_catch->context = context;
+	try_catch->try_completion = &try_completion;
+	try_catch->try_result = 0;
+	task_struct = kthread_run(kunit_generic_run_threadfn_adapter,
+				  try_catch,
+				  "kunit_try_catch_thread");
+	if (IS_ERR(task_struct)) {
+		try_catch->catch(try_catch->context);
+		return;
+	}
+
+	time_remaining = wait_for_completion_timeout(&try_completion,
+						     kunit_test_timeout());
+	if (time_remaining == 0) {
+		kunit_err(test, "try timed out\n");
+		try_catch->try_result = -ETIMEDOUT;
+	}
+
+	exit_code = try_catch->try_result;
+
+	if (!exit_code)
+		return;
+
+	if (exit_code == -EFAULT)
+		try_catch->try_result = 0;
+	else if (exit_code == -EINTR)
+		kunit_err(test, "wake_up_process() was never called\n");
+	else if (exit_code)
+		kunit_err(test, "Unknown error: %d\n", exit_code);
+
+	try_catch->catch(try_catch->context);
+}
+
+void kunit_try_catch_init(struct kunit_try_catch *try_catch,
+			  struct kunit *test,
+			  kunit_try_catch_func_t try,
+			  kunit_try_catch_func_t catch)
+{
+	try_catch->test = test;
+	try_catch->try = try;
+	try_catch->catch = catch;
+}
