commit 752beb5ec4413d40434957e427c6c48d5043f805
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Wed May 15 14:40:52 2019 +0300

    net: bpfilter: fallback to netfilter if failed to load bpfilter kernel module
    
    If bpfilter is not available return ENOPROTOOPT to fallback to netfilter.
    
    Function request_module() returns both errors and userspace exit codes.
    Just ignore them. Rechecking bpfilter_ops is enough.
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index 15427163a041..0480918bfc7c 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -30,13 +30,11 @@ static int bpfilter_mbox_request(struct sock *sk, int optname,
 	mutex_lock(&bpfilter_ops.lock);
 	if (!bpfilter_ops.sockopt) {
 		mutex_unlock(&bpfilter_ops.lock);
-		err = request_module("bpfilter");
+		request_module("bpfilter");
 		mutex_lock(&bpfilter_ops.lock);
 
-		if (err)
-			goto out;
 		if (!bpfilter_ops.sockopt) {
-			err = -ECHILD;
+			err = -ENOPROTOOPT;
 			goto out;
 		}
 	}

commit 3557b3fdeefacdd111469f90db1a0602902c9698
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Apr 20 23:29:47 2019 -0400

    net: bpfilter: dont use module_init in non-modular code
    
    The Kconfig controlling this code is:
    
    bpfilter/Kconfig:menuconfig BPFILTER
    bpfilter/Kconfig:   bool "BPF based packet filtering framework (BPFILTER)"
    
    Since it isn't a module, we shouldn't use module_init().  Instead we
    use device_initcall() - which is exactly what module_init() defaults
    to for non-modular code/builds.
    
    We don't remove <linux/module.h> from the includes since this file does
    a request_module() and hence is a valid user of that header file, even
    though it is not modular itself.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index 1e976bb93d99..15427163a041 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -77,5 +77,4 @@ static int __init bpfilter_sockopt_init(void)
 
 	return 0;
 }
-
-module_init(bpfilter_sockopt_init);
+device_initcall(bpfilter_sockopt_init);

commit 71a8508402b570127d6500c1ad456bbd33ccf187
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:25:10 2019 +0900

    net: bpfilter: disallow to remove bpfilter module while being used
    
    The bpfilter.ko module can be removed while functions of the bpfilter.ko
    are executing. so panic can occurred. in order to protect that, locks can
    be used. a bpfilter_lock protects routines in the
    __bpfilter_process_sockopt() but it's not enough because __exit routine
    can be executed concurrently.
    
    Now, the bpfilter_umh can not run in parallel.
    So, the module do not removed while it's being used and it do not
    double-create UMH process.
    The members of the umh_info and the bpfilter_umh_ops are protected by
    the bpfilter_umh_ops.lock.
    
    test commands:
       while :
       do
            iptables -I FORWARD -m string --string ap --algo kmp &
            modprobe -rv bpfilter &
       done
    
    splat looks like:
    [  298.623435] BUG: unable to handle kernel paging request at fffffbfff807440b
    [  298.628512] #PF error: [normal kernel read fault]
    [  298.633018] PGD 124327067 P4D 124327067 PUD 11c1a3067 PMD 119eb2067 PTE 0
    [  298.638859] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  298.638859] CPU: 0 PID: 2997 Comm: iptables Not tainted 4.20.0+ #154
    [  298.638859] RIP: 0010:__mutex_lock+0x6b9/0x16a0
    [  298.638859] Code: c0 00 00 e8 89 82 ff ff 80 bd 8f fc ff ff 00 0f 85 d9 05 00 00 48 8b 85 80 fc ff ff 48 bf 00 00 00 00 00 fc ff df 48 c1 e8 03 <80> 3c 38 00 0f 85 1d 0e 00 00 48 8b 85 c8 fc ff ff 49 39 47 58 c6
    [  298.638859] RSP: 0018:ffff88810e7777a0 EFLAGS: 00010202
    [  298.638859] RAX: 1ffffffff807440b RBX: ffff888111bd4d80 RCX: 0000000000000000
    [  298.638859] RDX: 1ffff110235ff806 RSI: ffff888111bd5538 RDI: dffffc0000000000
    [  298.638859] RBP: ffff88810e777b30 R08: 0000000080000002 R09: 0000000000000000
    [  298.638859] R10: 0000000000000000 R11: 0000000000000000 R12: fffffbfff168a42c
    [  298.638859] R13: ffff888111bd4d80 R14: ffff8881040e9a05 R15: ffffffffc03a2000
    [  298.638859] FS:  00007f39e3758700(0000) GS:ffff88811ae00000(0000) knlGS:0000000000000000
    [  298.638859] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  298.638859] CR2: fffffbfff807440b CR3: 000000011243e000 CR4: 00000000001006f0
    [  298.638859] Call Trace:
    [  298.638859]  ? mutex_lock_io_nested+0x1560/0x1560
    [  298.638859]  ? kasan_kmalloc+0xa0/0xd0
    [  298.638859]  ? kmem_cache_alloc+0x1c2/0x260
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? alloc_empty_file+0x43/0x120
    [  298.638859]  ? alloc_file_pseudo+0x220/0x330
    [  298.638859]  ? sock_alloc_file+0x39/0x160
    [  298.638859]  ? __sys_socket+0x113/0x1d0
    [  298.638859]  ? __x64_sys_socket+0x6f/0xb0
    [  298.638859]  ? do_syscall_64+0x138/0x560
    [  298.638859]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? init_object+0x6b/0x80
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? hlock_class+0x140/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? check_flags.part.37+0x440/0x440
    [  298.638859]  ? __lock_acquire+0x4f90/0x4f90
    [  298.638859]  ? set_rq_offline.part.89+0x140/0x140
    [ ... ]
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index de84ede4e765..1e976bb93d99 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -14,10 +14,12 @@ EXPORT_SYMBOL_GPL(bpfilter_ops);
 
 static void bpfilter_umh_cleanup(struct umh_info *info)
 {
+	mutex_lock(&bpfilter_ops.lock);
 	bpfilter_ops.stop = true;
 	fput(info->pipe_to_umh);
 	fput(info->pipe_from_umh);
 	info->pid = 0;
+	mutex_unlock(&bpfilter_ops.lock);
 }
 
 static int bpfilter_mbox_request(struct sock *sk, int optname,
@@ -25,21 +27,28 @@ static int bpfilter_mbox_request(struct sock *sk, int optname,
 				 unsigned int optlen, bool is_set)
 {
 	int err;
-
+	mutex_lock(&bpfilter_ops.lock);
 	if (!bpfilter_ops.sockopt) {
+		mutex_unlock(&bpfilter_ops.lock);
 		err = request_module("bpfilter");
+		mutex_lock(&bpfilter_ops.lock);
 
 		if (err)
-			return err;
-		if (!bpfilter_ops.sockopt)
-			return -ECHILD;
+			goto out;
+		if (!bpfilter_ops.sockopt) {
+			err = -ECHILD;
+			goto out;
+		}
 	}
 	if (bpfilter_ops.stop) {
 		err = bpfilter_ops.start();
 		if (err)
-			return err;
+			goto out;
 	}
-	return bpfilter_ops.sockopt(sk, optname, optval, optlen, is_set);
+	err = bpfilter_ops.sockopt(sk, optname, optval, optlen, is_set);
+out:
+	mutex_unlock(&bpfilter_ops.lock);
+	return err;
 }
 
 int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char __user *optval,
@@ -61,6 +70,7 @@ int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
 
 static int __init bpfilter_sockopt_init(void)
 {
+	mutex_init(&bpfilter_ops.lock);
 	bpfilter_ops.stop = true;
 	bpfilter_ops.info.cmdline = "bpfilter_umh";
 	bpfilter_ops.info.cleanup = &bpfilter_umh_cleanup;

commit 61fbf5933d42b02f552123af5a87a06335a3b4db
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:53 2019 +0900

    net: bpfilter: restart bpfilter_umh when error occurred
    
    The bpfilter_umh will be stopped via __stop_umh() when the bpfilter
    error occurred.
    The bpfilter_umh() couldn't start again because there is no restart
    routine.
    
    The section of the bpfilter_umh_{start/end} is no longer .init.rodata
    because these area should be reused in the restart routine. hence
    the section name is changed to .bpfilter_umh.
    
    The bpfilter_ops->start() is restart callback. it will be called when
    bpfilter_umh is stopped.
    The stop bit means bpfilter_umh is stopped. this bit is set by both
    start and stop routine.
    
    Before this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       [  480.045136] bpfilter: write fail -32
       $ iptables -vnL
    
    All iptables commands will fail.
    
    After this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       $ iptables -vnL
    
    Now, all iptables commands will work.
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index c326cfbc0f62..de84ede4e765 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -14,6 +14,7 @@ EXPORT_SYMBOL_GPL(bpfilter_ops);
 
 static void bpfilter_umh_cleanup(struct umh_info *info)
 {
+	bpfilter_ops.stop = true;
 	fput(info->pipe_to_umh);
 	fput(info->pipe_from_umh);
 	info->pid = 0;
@@ -23,14 +24,21 @@ static int bpfilter_mbox_request(struct sock *sk, int optname,
 				 char __user *optval,
 				 unsigned int optlen, bool is_set)
 {
+	int err;
+
 	if (!bpfilter_ops.sockopt) {
-		int err = request_module("bpfilter");
+		err = request_module("bpfilter");
 
 		if (err)
 			return err;
 		if (!bpfilter_ops.sockopt)
 			return -ECHILD;
 	}
+	if (bpfilter_ops.stop) {
+		err = bpfilter_ops.start();
+		if (err)
+			return err;
+	}
 	return bpfilter_ops.sockopt(sk, optname, optval, optlen, is_set);
 }
 
@@ -53,6 +61,7 @@ int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
 
 static int __init bpfilter_sockopt_init(void)
 {
+	bpfilter_ops.stop = true;
 	bpfilter_ops.info.cmdline = "bpfilter_umh";
 	bpfilter_ops.info.cleanup = &bpfilter_umh_cleanup;
 

commit 5b4cb650e569db2e6a09d2fa0ef8eb789a0ac5d8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:34 2019 +0900

    net: bpfilter: use cleanup callback to release umh_info
    
    Now, UMH process is killed, do_exit() calls the umh_info->cleanup callback
    to release members of the umh_info.
    This patch makes bpfilter_umh's cleanup routine to use the
    umh_info->cleanup callback.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index 5e04ed25bc0e..c326cfbc0f62 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -1,28 +1,37 @@
 // SPDX-License-Identifier: GPL-2.0
+#include <linux/init.h>
+#include <linux/module.h>
 #include <linux/uaccess.h>
 #include <linux/bpfilter.h>
 #include <uapi/linux/bpf.h>
 #include <linux/wait.h>
 #include <linux/kmod.h>
+#include <linux/fs.h>
+#include <linux/file.h>
 
-int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
-				char __user *optval,
-				unsigned int optlen, bool is_set);
-EXPORT_SYMBOL_GPL(bpfilter_process_sockopt);
+struct bpfilter_umh_ops bpfilter_ops;
+EXPORT_SYMBOL_GPL(bpfilter_ops);
+
+static void bpfilter_umh_cleanup(struct umh_info *info)
+{
+	fput(info->pipe_to_umh);
+	fput(info->pipe_from_umh);
+	info->pid = 0;
+}
 
 static int bpfilter_mbox_request(struct sock *sk, int optname,
 				 char __user *optval,
 				 unsigned int optlen, bool is_set)
 {
-	if (!bpfilter_process_sockopt) {
+	if (!bpfilter_ops.sockopt) {
 		int err = request_module("bpfilter");
 
 		if (err)
 			return err;
-		if (!bpfilter_process_sockopt)
+		if (!bpfilter_ops.sockopt)
 			return -ECHILD;
 	}
-	return bpfilter_process_sockopt(sk, optname, optval, optlen, is_set);
+	return bpfilter_ops.sockopt(sk, optname, optval, optlen, is_set);
 }
 
 int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char __user *optval,
@@ -41,3 +50,13 @@ int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
 
 	return bpfilter_mbox_request(sk, optname, optval, len, false);
 }
+
+static int __init bpfilter_sockopt_init(void)
+{
+	bpfilter_ops.info.cmdline = "bpfilter_umh";
+	bpfilter_ops.info.cleanup = &bpfilter_umh_cleanup;
+
+	return 0;
+}
+
+module_init(bpfilter_sockopt_init);

commit 77ab8d5d2950cd0e18ba943336c1172b46e9f53e
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Sat May 26 09:47:26 2018 +0000

    net: bpfilter: make function bpfilter_mbox_request() static
    
    Fixes the following sparse warnings:
    
    net/ipv4/bpfilter/sockopt.c:13:5: warning:
     symbol 'bpfilter_mbox_request' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
index 42a96d2d8d05..5e04ed25bc0e 100644
--- a/net/ipv4/bpfilter/sockopt.c
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -10,8 +10,9 @@ int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
 				unsigned int optlen, bool is_set);
 EXPORT_SYMBOL_GPL(bpfilter_process_sockopt);
 
-int bpfilter_mbox_request(struct sock *sk, int optname, char __user *optval,
-			  unsigned int optlen, bool is_set)
+static int bpfilter_mbox_request(struct sock *sk, int optname,
+				 char __user *optval,
+				 unsigned int optlen, bool is_set)
 {
 	if (!bpfilter_process_sockopt) {
 		int err = request_module("bpfilter");

commit d2ba09c17a0647f899d6c20a11bab9e6d3382f07
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Mon May 21 19:22:30 2018 -0700

    net: add skeleton of bpfilter kernel module
    
    bpfilter.ko consists of bpfilter_kern.c (normal kernel module code)
    and user mode helper code that is embedded into bpfilter.ko
    
    The steps to build bpfilter.ko are the following:
    - main.c is compiled by HOSTCC into the bpfilter_umh elf executable file
    - with quite a bit of objcopy and Makefile magic the bpfilter_umh elf file
      is converted into bpfilter_umh.o object file
      with _binary_net_bpfilter_bpfilter_umh_start and _end symbols
      Example:
      $ nm ./bld_x64/net/bpfilter/bpfilter_umh.o
      0000000000004cf8 T _binary_net_bpfilter_bpfilter_umh_end
      0000000000004cf8 A _binary_net_bpfilter_bpfilter_umh_size
      0000000000000000 T _binary_net_bpfilter_bpfilter_umh_start
    - bpfilter_umh.o and bpfilter_kern.o are linked together into bpfilter.ko
    
    bpfilter_kern.c is a normal kernel module code that calls
    the fork_usermode_blob() helper to execute part of its own data
    as a user mode process.
    
    Notice that _binary_net_bpfilter_bpfilter_umh_start - end
    is placed into .init.rodata section, so it's freed as soon as __init
    function of bpfilter.ko is finished.
    As part of __init the bpfilter.ko does first request/reply action
    via two unix pipe provided by fork_usermode_blob() helper to
    make sure that umh is healthy. If not it will kill it via pid.
    
    Later bpfilter_process_sockopt() will be called from bpfilter hooks
    in get/setsockopt() to pass iptable commands into umh via bpfilter.ko
    
    If admin does 'rmmod bpfilter' the __exit code bpfilter.ko will
    kill umh as well.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/bpfilter/sockopt.c b/net/ipv4/bpfilter/sockopt.c
new file mode 100644
index 000000000000..42a96d2d8d05
--- /dev/null
+++ b/net/ipv4/bpfilter/sockopt.c
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/uaccess.h>
+#include <linux/bpfilter.h>
+#include <uapi/linux/bpf.h>
+#include <linux/wait.h>
+#include <linux/kmod.h>
+
+int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
+				char __user *optval,
+				unsigned int optlen, bool is_set);
+EXPORT_SYMBOL_GPL(bpfilter_process_sockopt);
+
+int bpfilter_mbox_request(struct sock *sk, int optname, char __user *optval,
+			  unsigned int optlen, bool is_set)
+{
+	if (!bpfilter_process_sockopt) {
+		int err = request_module("bpfilter");
+
+		if (err)
+			return err;
+		if (!bpfilter_process_sockopt)
+			return -ECHILD;
+	}
+	return bpfilter_process_sockopt(sk, optname, optval, optlen, is_set);
+}
+
+int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char __user *optval,
+			    unsigned int optlen)
+{
+	return bpfilter_mbox_request(sk, optname, optval, optlen, true);
+}
+
+int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
+			    int __user *optlen)
+{
+	int len;
+
+	if (get_user(len, optlen))
+		return -EFAULT;
+
+	return bpfilter_mbox_request(sk, optname, optval, len, false);
+}
