commit 67c20de35a3cc2e2cd940f95ebd85ed0a765315a
Author: Rob Gill <rrobgill@protonmail.com>
Date:   Sat Jun 20 02:08:25 2020 +0000

    net: Add MODULE_DESCRIPTION entries to network modules
    
    The user tool modinfo is used to get information on kernel modules, including a
    description where it is available.
    
    This patch adds a brief MODULE_DESCRIPTION to the following modules:
    
    9p
    drop_monitor
    esp4_offload
    esp6_offload
    fou
    fou6
    ila
    sch_fq
    sch_fq_codel
    sch_hhf
    
    Signed-off-by: Rob Gill <rrobgill@protonmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 091f94184dc1..430518ae26fa 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -224,3 +224,4 @@ module_init(fou6_init);
 module_exit(fou6_fini);
 MODULE_AUTHOR("Tom Herbert <therbert@google.com>");
 MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Foo over UDP (IPv6)");

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index ec4e2ed95f36..091f94184dc1 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/socket.h>

commit 5355ed6388e23b69a00d48398a68d022135e6486
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Mar 6 10:41:00 2019 -0800

    fou, fou6: avoid uninit-value in gue_err() and gue6_err()
    
    My prior commit missed the fact that these functions
    were using udp_hdr() (aka skb_transport_header())
    to get access to GUE header.
    
    Since pskb_transport_may_pull() does not exist yet, we have to add
    transport_offset to our pskb_may_pull() calls.
    
    BUG: KMSAN: uninit-value in gue_err+0x514/0xfa0 net/ipv4/fou.c:1032
    CPU: 1 PID: 10648 Comm: syz-executor.1 Not tainted 5.0.0+ #11
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x173/0x1d0 lib/dump_stack.c:113
     kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600
     __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313
     gue_err+0x514/0xfa0 net/ipv4/fou.c:1032
     __udp4_lib_err_encap_no_sk net/ipv4/udp.c:571 [inline]
     __udp4_lib_err_encap net/ipv4/udp.c:626 [inline]
     __udp4_lib_err+0x12e6/0x1d40 net/ipv4/udp.c:665
     udp_err+0x74/0x90 net/ipv4/udp.c:737
     icmp_socket_deliver net/ipv4/icmp.c:767 [inline]
     icmp_unreach+0xb65/0x1070 net/ipv4/icmp.c:884
     icmp_rcv+0x11a1/0x1950 net/ipv4/icmp.c:1066
     ip_protocol_deliver_rcu+0x584/0xbb0 net/ipv4/ip_input.c:208
     ip_local_deliver_finish net/ipv4/ip_input.c:234 [inline]
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ip_local_deliver+0x624/0x7b0 net/ipv4/ip_input.c:255
     dst_input include/net/dst.h:450 [inline]
     ip_rcv_finish net/ipv4/ip_input.c:414 [inline]
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ip_rcv+0x6bd/0x740 net/ipv4/ip_input.c:524
     __netif_receive_skb_one_core net/core/dev.c:4973 [inline]
     __netif_receive_skb net/core/dev.c:5083 [inline]
     process_backlog+0x756/0x10e0 net/core/dev.c:5923
     napi_poll net/core/dev.c:6346 [inline]
     net_rx_action+0x78b/0x1a60 net/core/dev.c:6412
     __do_softirq+0x53f/0x93a kernel/softirq.c:293
     invoke_softirq kernel/softirq.c:375 [inline]
     irq_exit+0x214/0x250 kernel/softirq.c:416
     exiting_irq+0xe/0x10 arch/x86/include/asm/apic.h:536
     smp_apic_timer_interrupt+0x48/0x70 arch/x86/kernel/apic/apic.c:1064
     apic_timer_interrupt+0x2e/0x40 arch/x86/entry/entry_64.S:814
     </IRQ>
    RIP: 0010:finish_lock_switch+0x2b/0x40 kernel/sched/core.c:2597
    Code: 48 89 e5 53 48 89 fb e8 63 e7 95 00 8b b8 88 0c 00 00 48 8b 00 48 85 c0 75 12 48 89 df e8 dd db 95 00 c6 00 00 c6 03 00 fb 5b <5d> c3 e8 4e e6 95 00 eb e7 66 90 66 2e 0f 1f 84 00 00 00 00 00 55
    RSP: 0018:ffff888081a0fc80 EFLAGS: 00000296 ORIG_RAX: ffffffffffffff13
    RAX: ffff88821fd6bd80 RBX: ffff888027898000 RCX: ccccccccccccd000
    RDX: ffff88821fca8d80 RSI: ffff888000000000 RDI: 00000000000004a0
    RBP: ffff888081a0fc80 R08: 0000000000000002 R09: ffff888081a0fb08
    R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000001
    R13: ffff88811130e388 R14: ffff88811130da00 R15: ffff88812fdb7d80
     finish_task_switch+0xfc/0x2d0 kernel/sched/core.c:2698
     context_switch kernel/sched/core.c:2851 [inline]
     __schedule+0x6cc/0x800 kernel/sched/core.c:3491
     schedule+0x15b/0x240 kernel/sched/core.c:3535
     freezable_schedule include/linux/freezer.h:172 [inline]
     do_nanosleep+0x2ba/0x980 kernel/time/hrtimer.c:1679
     hrtimer_nanosleep kernel/time/hrtimer.c:1733 [inline]
     __do_sys_nanosleep kernel/time/hrtimer.c:1767 [inline]
     __se_sys_nanosleep+0x746/0x960 kernel/time/hrtimer.c:1754
     __x64_sys_nanosleep+0x3e/0x60 kernel/time/hrtimer.c:1754
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    RIP: 0033:0x4855a0
    Code: 00 00 48 c7 c0 d4 ff ff ff 64 c7 00 16 00 00 00 31 c0 eb be 66 0f 1f 44 00 00 83 3d b1 11 5d 00 00 75 14 b8 23 00 00 00 0f 05 <48> 3d 01 f0 ff ff 0f 83 04 e2 f8 ff c3 48 83 ec 08 e8 3a 55 fd ff
    RSP: 002b:0000000000a4fd58 EFLAGS: 00000246 ORIG_RAX: 0000000000000023
    RAX: ffffffffffffffda RBX: 0000000000085780 RCX: 00000000004855a0
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000a4fd60
    RBP: 00000000000007ec R08: 0000000000000001 R09: 0000000000ceb940
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000008
    R13: 0000000000a4fdb0 R14: 0000000000085711 R15: 0000000000a4fdc0
    
    Uninit was created at:
     kmsan_save_stack_with_flags mm/kmsan/kmsan.c:205 [inline]
     kmsan_internal_poison_shadow+0x92/0x150 mm/kmsan/kmsan.c:159
     kmsan_kmalloc+0xa6/0x130 mm/kmsan/kmsan_hooks.c:176
     kmsan_slab_alloc+0xe/0x10 mm/kmsan/kmsan_hooks.c:185
     slab_post_alloc_hook mm/slab.h:445 [inline]
     slab_alloc_node mm/slub.c:2773 [inline]
     __kmalloc_node_track_caller+0xe9e/0xff0 mm/slub.c:4398
     __kmalloc_reserve net/core/skbuff.c:140 [inline]
     __alloc_skb+0x309/0xa20 net/core/skbuff.c:208
     alloc_skb include/linux/skbuff.h:1012 [inline]
     alloc_skb_with_frags+0x186/0xa60 net/core/skbuff.c:5287
     sock_alloc_send_pskb+0xafd/0x10a0 net/core/sock.c:2091
     sock_alloc_send_skb+0xca/0xe0 net/core/sock.c:2108
     __ip_append_data+0x34cd/0x5000 net/ipv4/ip_output.c:998
     ip_append_data+0x324/0x480 net/ipv4/ip_output.c:1220
     icmp_push_reply+0x23d/0x7e0 net/ipv4/icmp.c:375
     __icmp_send+0x2ea3/0x30f0 net/ipv4/icmp.c:737
     icmp_send include/net/icmp.h:47 [inline]
     ipv4_link_failure+0x6d/0x230 net/ipv4/route.c:1190
     dst_link_failure include/net/dst.h:427 [inline]
     arp_error_report+0x106/0x1a0 net/ipv4/arp.c:297
     neigh_invalidate+0x359/0x8e0 net/core/neighbour.c:992
     neigh_timer_handler+0xdf2/0x1280 net/core/neighbour.c:1078
     call_timer_fn+0x285/0x600 kernel/time/timer.c:1325
     expire_timers kernel/time/timer.c:1362 [inline]
     __run_timers+0xdb4/0x11d0 kernel/time/timer.c:1681
     run_timer_softirq+0x2e/0x50 kernel/time/timer.c:1694
     __do_softirq+0x53f/0x93a kernel/softirq.c:293
    
    Fixes: 26fc181e6cac ("fou, fou6: do not assume linear skbs")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Stefano Brivio <sbrivio@redhat.com>
    Cc: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 867474abe269..ec4e2ed95f36 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -94,7 +94,7 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	int ret;
 
 	len = sizeof(struct udphdr) + sizeof(struct guehdr);
-	if (!pskb_may_pull(skb, len))
+	if (!pskb_may_pull(skb, transport_offset + len))
 		return -EINVAL;
 
 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
@@ -129,7 +129,7 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 
 	optlen = guehdr->hlen << 2;
 
-	if (!pskb_may_pull(skb, len + optlen))
+	if (!pskb_may_pull(skb, transport_offset + len + optlen))
 		return -EINVAL;
 
 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];

commit 5de362df44d71fc8f6b153ae4eaa2a1284c84490
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Thu Feb 21 17:43:58 2019 +0100

    fou6: fix proto error handler argument type
    
    Last argument of gue6_err_proto_handler() has a wrong type annotation,
    fix it and make sparse happy again.
    
    Fixes: b8a51b38e4d4 ("fou, fou6: ICMP error handlers for FoU and GUE")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index b858bd5280bf..867474abe269 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -72,7 +72,7 @@ static int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
 
 static int gue6_err_proto_handler(int proto, struct sk_buff *skb,
 				  struct inet6_skb_parm *opt,
-				  u8 type, u8 code, int offset, u32 info)
+				  u8 type, u8 code, int offset, __be32 info)
 {
 	const struct inet6_protocol *ipprot;
 

commit 26fc181e6cacacd4837da7ffe0c871134a421600
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Jan 11 06:27:35 2019 -0800

    fou, fou6: do not assume linear skbs
    
    Both gue_err() and gue6_err() incorrectly assume
    linear skbs. Fix them to use pskb_may_pull().
    
    BUG: KMSAN: uninit-value in gue6_err+0x475/0xc40 net/ipv6/fou6.c:101
    CPU: 0 PID: 18083 Comm: syz-executor1 Not tainted 5.0.0-rc1+ #7
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x173/0x1d0 lib/dump_stack.c:113
     kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600
     __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313
     gue6_err+0x475/0xc40 net/ipv6/fou6.c:101
     __udp6_lib_err_encap_no_sk net/ipv6/udp.c:434 [inline]
     __udp6_lib_err_encap net/ipv6/udp.c:491 [inline]
     __udp6_lib_err+0x18d0/0x2590 net/ipv6/udp.c:522
     udplitev6_err+0x118/0x130 net/ipv6/udplite.c:27
     icmpv6_notify+0x462/0x9f0 net/ipv6/icmp.c:784
     icmpv6_rcv+0x18ac/0x3fa0 net/ipv6/icmp.c:872
     ip6_protocol_deliver_rcu+0xb5a/0x23a0 net/ipv6/ip6_input.c:394
     ip6_input_finish net/ipv6/ip6_input.c:434 [inline]
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ip6_input+0x2b6/0x350 net/ipv6/ip6_input.c:443
     dst_input include/net/dst.h:450 [inline]
     ip6_rcv_finish+0x4e7/0x6d0 net/ipv6/ip6_input.c:76
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ipv6_rcv+0x34b/0x3f0 net/ipv6/ip6_input.c:272
     __netif_receive_skb_one_core net/core/dev.c:4973 [inline]
     __netif_receive_skb net/core/dev.c:5083 [inline]
     process_backlog+0x756/0x10e0 net/core/dev.c:5923
     napi_poll net/core/dev.c:6346 [inline]
     net_rx_action+0x78b/0x1a60 net/core/dev.c:6412
     __do_softirq+0x53f/0x93a kernel/softirq.c:293
     do_softirq_own_stack+0x49/0x80 arch/x86/entry/entry_64.S:1039
     </IRQ>
     do_softirq kernel/softirq.c:338 [inline]
     __local_bh_enable_ip+0x16f/0x1a0 kernel/softirq.c:190
     local_bh_enable+0x36/0x40 include/linux/bottom_half.h:32
     rcu_read_unlock_bh include/linux/rcupdate.h:696 [inline]
     ip6_finish_output2+0x1d64/0x25f0 net/ipv6/ip6_output.c:121
     ip6_finish_output+0xae4/0xbc0 net/ipv6/ip6_output.c:154
     NF_HOOK_COND include/linux/netfilter.h:278 [inline]
     ip6_output+0x5ca/0x710 net/ipv6/ip6_output.c:171
     dst_output include/net/dst.h:444 [inline]
     ip6_local_out+0x164/0x1d0 net/ipv6/output_core.c:176
     ip6_send_skb+0xfa/0x390 net/ipv6/ip6_output.c:1727
     udp_v6_send_skb+0x1733/0x1d20 net/ipv6/udp.c:1169
     udpv6_sendmsg+0x424e/0x45d0 net/ipv6/udp.c:1466
     inet_sendmsg+0x54a/0x720 net/ipv4/af_inet.c:798
     sock_sendmsg_nosec net/socket.c:621 [inline]
     sock_sendmsg net/socket.c:631 [inline]
     ___sys_sendmsg+0xdb9/0x11b0 net/socket.c:2116
     __sys_sendmmsg+0x580/0xad0 net/socket.c:2211
     __do_sys_sendmmsg net/socket.c:2240 [inline]
     __se_sys_sendmmsg+0xbd/0xe0 net/socket.c:2237
     __x64_sys_sendmmsg+0x56/0x70 net/socket.c:2237
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    RIP: 0033:0x457ec9
    Code: 6d b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 3b b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f4a5204fc78 EFLAGS: 00000246 ORIG_RAX: 0000000000000133
    RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 0000000000457ec9
    RDX: 00000000040001ab RSI: 0000000020000240 RDI: 0000000000000003
    RBP: 000000000073bf00 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007f4a520506d4
    R13: 00000000004c4ce5 R14: 00000000004d85d8 R15: 00000000ffffffff
    
    Uninit was created at:
     kmsan_save_stack_with_flags mm/kmsan/kmsan.c:205 [inline]
     kmsan_internal_poison_shadow+0x92/0x150 mm/kmsan/kmsan.c:159
     kmsan_kmalloc+0xa6/0x130 mm/kmsan/kmsan_hooks.c:176
     kmsan_slab_alloc+0xe/0x10 mm/kmsan/kmsan_hooks.c:185
     slab_post_alloc_hook mm/slab.h:446 [inline]
     slab_alloc_node mm/slub.c:2754 [inline]
     __kmalloc_node_track_caller+0xe9e/0xff0 mm/slub.c:4377
     __kmalloc_reserve net/core/skbuff.c:140 [inline]
     __alloc_skb+0x309/0xa20 net/core/skbuff.c:208
     alloc_skb include/linux/skbuff.h:1012 [inline]
     alloc_skb_with_frags+0x1c7/0xac0 net/core/skbuff.c:5288
     sock_alloc_send_pskb+0xafd/0x10a0 net/core/sock.c:2091
     sock_alloc_send_skb+0xca/0xe0 net/core/sock.c:2108
     __ip6_append_data+0x42ed/0x5dc0 net/ipv6/ip6_output.c:1443
     ip6_append_data+0x3c2/0x650 net/ipv6/ip6_output.c:1619
     icmp6_send+0x2f5c/0x3c40 net/ipv6/icmp.c:574
     icmpv6_send+0xe5/0x110 net/ipv6/ip6_icmp.c:43
     ip6_link_failure+0x5c/0x2c0 net/ipv6/route.c:2231
     dst_link_failure include/net/dst.h:427 [inline]
     vti_xmit net/ipv4/ip_vti.c:229 [inline]
     vti_tunnel_xmit+0xf3b/0x1ea0 net/ipv4/ip_vti.c:265
     __netdev_start_xmit include/linux/netdevice.h:4382 [inline]
     netdev_start_xmit include/linux/netdevice.h:4391 [inline]
     xmit_one net/core/dev.c:3278 [inline]
     dev_hard_start_xmit+0x604/0xc40 net/core/dev.c:3294
     __dev_queue_xmit+0x2e48/0x3b80 net/core/dev.c:3864
     dev_queue_xmit+0x4b/0x60 net/core/dev.c:3897
     neigh_direct_output+0x42/0x50 net/core/neighbour.c:1511
     neigh_output include/net/neighbour.h:508 [inline]
     ip6_finish_output2+0x1d4e/0x25f0 net/ipv6/ip6_output.c:120
     ip6_finish_output+0xae4/0xbc0 net/ipv6/ip6_output.c:154
     NF_HOOK_COND include/linux/netfilter.h:278 [inline]
     ip6_output+0x5ca/0x710 net/ipv6/ip6_output.c:171
     dst_output include/net/dst.h:444 [inline]
     ip6_local_out+0x164/0x1d0 net/ipv6/output_core.c:176
     ip6_send_skb+0xfa/0x390 net/ipv6/ip6_output.c:1727
     udp_v6_send_skb+0x1733/0x1d20 net/ipv6/udp.c:1169
     udpv6_sendmsg+0x424e/0x45d0 net/ipv6/udp.c:1466
     inet_sendmsg+0x54a/0x720 net/ipv4/af_inet.c:798
     sock_sendmsg_nosec net/socket.c:621 [inline]
     sock_sendmsg net/socket.c:631 [inline]
     ___sys_sendmsg+0xdb9/0x11b0 net/socket.c:2116
     __sys_sendmmsg+0x580/0xad0 net/socket.c:2211
     __do_sys_sendmmsg net/socket.c:2240 [inline]
     __se_sys_sendmmsg+0xbd/0xe0 net/socket.c:2237
     __x64_sys_sendmmsg+0x56/0x70 net/socket.c:2237
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    
    Fixes: b8a51b38e4d4 ("fou, fou6: ICMP error handlers for FoU and GUE")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Stefano Brivio <sbrivio@redhat.com>
    Cc: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 7da7bf3b7fe3..b858bd5280bf 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -90,10 +90,11 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 {
 	int transport_offset = skb_transport_offset(skb);
 	struct guehdr *guehdr;
-	size_t optlen;
+	size_t len, optlen;
 	int ret;
 
-	if (skb->len < sizeof(struct udphdr) + sizeof(struct guehdr))
+	len = sizeof(struct udphdr) + sizeof(struct guehdr);
+	if (!pskb_may_pull(skb, len))
 		return -EINVAL;
 
 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
@@ -128,6 +129,10 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 
 	optlen = guehdr->hlen << 2;
 
+	if (!pskb_may_pull(skb, len + optlen))
+		return -EINVAL;
+
+	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
 	if (validate_gue_flags(guehdr, optlen))
 		return -EINVAL;
 

commit 44039e00171b0fe930c07ff7b43e6023eaf1ed31
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Thu Jan 3 21:43:35 2019 +0100

    fou6: Prevent unbounded recursion in GUE error handler
    
    I forgot to deal with IPv6 in commit 11789039da53 ("fou: Prevent unbounded
    recursion in GUE error handler").
    
    Now syzbot reported what might be the same type of issue, caused by
    gue6_err(), that is, handling exceptions for direct UDP encapsulation in
    GUE (UDP-in-UDP) leads to unbounded recursion in the GUE exception
    handler.
    
    As it probably doesn't make sense to set up GUE this way, and it's
    currently not even possible to configure this, skip exception handling for
    UDP (or UDP-Lite) packets encapsulated in UDP (or UDP-Lite) packets with
    GUE on IPv6.
    
    Reported-by: syzbot+4ad25edc7a33e4ab91e0@syzkaller.appspotmail.com
    Reported-by: Willem de Bruijn <willemdebruijn.kernel@gmail.com>
    Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: b8a51b38e4d4 ("fou, fou6: ICMP error handlers for FoU and GUE")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index bd675c61deb1..7da7bf3b7fe3 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -131,6 +131,14 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	if (validate_gue_flags(guehdr, optlen))
 		return -EINVAL;
 
+	/* Handling exceptions for direct UDP encapsulation in GUE would lead to
+	 * recursion. Besides, this kind of encapsulation can't even be
+	 * configured currently. Discard this.
+	 */
+	if (guehdr->proto_ctype == IPPROTO_UDP ||
+	    guehdr->proto_ctype == IPPROTO_UDPLITE)
+		return -EOPNOTSUPP;
+
 	skb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));
 	ret = gue6_err_proto_handler(guehdr->proto_ctype, skb,
 				     opt, type, code, offset, info);

commit b8a51b38e4d4dec3e379d52c0fe1a66827f7cf1e
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Thu Nov 8 12:19:23 2018 +0100

    fou, fou6: ICMP error handlers for FoU and GUE
    
    As the destination port in FoU and GUE receiving sockets doesn't
    necessarily match the remote destination port, we can't associate errors
    to the encapsulating tunnels with a socket lookup -- we need to blindly
    try them instead. This means we don't even know if we are handling errors
    for FoU or GUE without digging into the packets.
    
    Hence, implement a single handler for both, one for IPv4 and one for IPv6,
    that will check whether the packet that generated the ICMP error used a
    direct IP encapsulation or if it had a GUE header, and send the error to
    the matching protocol handler, if any.
    
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 6de3c04b0f30..bd675c61deb1 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -4,6 +4,7 @@
 #include <linux/skbuff.h>
 #include <linux/ip.h>
 #include <linux/udp.h>
+#include <linux/icmpv6.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <net/fou.h>
@@ -69,14 +70,87 @@ static int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
 	return 0;
 }
 
+static int gue6_err_proto_handler(int proto, struct sk_buff *skb,
+				  struct inet6_skb_parm *opt,
+				  u8 type, u8 code, int offset, u32 info)
+{
+	const struct inet6_protocol *ipprot;
+
+	ipprot = rcu_dereference(inet6_protos[proto]);
+	if (ipprot && ipprot->err_handler) {
+		if (!ipprot->err_handler(skb, opt, type, code, offset, info))
+			return 0;
+	}
+
+	return -ENOENT;
+}
+
+static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+		    u8 type, u8 code, int offset, __be32 info)
+{
+	int transport_offset = skb_transport_offset(skb);
+	struct guehdr *guehdr;
+	size_t optlen;
+	int ret;
+
+	if (skb->len < sizeof(struct udphdr) + sizeof(struct guehdr))
+		return -EINVAL;
+
+	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
+
+	switch (guehdr->version) {
+	case 0: /* Full GUE header present */
+		break;
+	case 1: {
+		/* Direct encasulation of IPv4 or IPv6 */
+		skb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));
+
+		switch (((struct iphdr *)guehdr)->version) {
+		case 4:
+			ret = gue6_err_proto_handler(IPPROTO_IPIP, skb, opt,
+						     type, code, offset, info);
+			goto out;
+		case 6:
+			ret = gue6_err_proto_handler(IPPROTO_IPV6, skb, opt,
+						     type, code, offset, info);
+			goto out;
+		default:
+			ret = -EOPNOTSUPP;
+			goto out;
+		}
+	}
+	default: /* Undefined version */
+		return -EOPNOTSUPP;
+	}
+
+	if (guehdr->control)
+		return -ENOENT;
+
+	optlen = guehdr->hlen << 2;
+
+	if (validate_gue_flags(guehdr, optlen))
+		return -EINVAL;
+
+	skb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));
+	ret = gue6_err_proto_handler(guehdr->proto_ctype, skb,
+				     opt, type, code, offset, info);
+
+out:
+	skb_set_transport_header(skb, transport_offset);
+	return ret;
+}
+
+
 static const struct ip6_tnl_encap_ops fou_ip6tun_ops = {
 	.encap_hlen = fou_encap_hlen,
 	.build_header = fou6_build_header,
+	.err_handler = gue6_err,
 };
 
 static const struct ip6_tnl_encap_ops gue_ip6tun_ops = {
 	.encap_hlen = gue_encap_hlen,
 	.build_header = gue6_build_header,
+	.err_handler = gue6_err,
 };
 
 static int ip6_tnl_encap_add_fou_ops(void)

commit 9dc621afa8d673d4bdaab2d850699cd98a50b14a
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Fri May 19 09:55:54 2017 -0700

    fou: make local function static
    
    The build header functions are not used by any other code.
    
    net/ipv6/fou6.c:36:5: warning: no previous prototype for ‘fou6_build_header’ [-Wmissing-prototypes]
    net/ipv6/fou6.c:54:5: warning: no previous prototype for ‘gue6_build_header’ [-Wmissing-prototypes]
    
    Need to do some code rearranging to satisfy different Kconfig possiblities.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 9ea249b9451e..6de3c04b0f30 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -14,6 +14,8 @@
 #include <net/udp.h>
 #include <net/udp_tunnel.h>
 
+#if IS_ENABLED(CONFIG_IPV6_FOU_TUNNEL)
+
 static void fou6_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,
 			   struct flowi6 *fl6, u8 *protocol, __be16 sport)
 {
@@ -33,8 +35,8 @@ static void fou6_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,
 	*protocol = IPPROTO_UDP;
 }
 
-int fou6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
-		      u8 *protocol, struct flowi6 *fl6)
+static int fou6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+			     u8 *protocol, struct flowi6 *fl6)
 {
 	__be16 sport;
 	int err;
@@ -49,10 +51,9 @@ int fou6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
 
 	return 0;
 }
-EXPORT_SYMBOL(fou6_build_header);
 
-int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
-		      u8 *protocol, struct flowi6 *fl6)
+static int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+			     u8 *protocol, struct flowi6 *fl6)
 {
 	__be16 sport;
 	int err;
@@ -67,9 +68,6 @@ int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
 
 	return 0;
 }
-EXPORT_SYMBOL(gue6_build_header);
-
-#if IS_ENABLED(CONFIG_IPV6_FOU_TUNNEL)
 
 static const struct ip6_tnl_encap_ops fou_ip6tun_ops = {
 	.encap_hlen = fou_encap_hlen,

commit fabb13db448efc23c47851550867fc46519de97e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed May 25 16:50:46 2016 +0200

    fou: add Kconfig options for IPv6 support
    
    A previous patch added the fou6.ko module, but that failed to link
    in a couple of configurations:
    
    net/built-in.o: In function `ip6_tnl_encap_add_fou_ops':
    net/ipv6/fou6.c:88: undefined reference to `ip6_tnl_encap_add_ops'
    net/ipv6/fou6.c:94: undefined reference to `ip6_tnl_encap_add_ops'
    net/ipv6/fou6.c:97: undefined reference to `ip6_tnl_encap_del_ops'
    net/built-in.o: In function `ip6_tnl_encap_del_fou_ops':
    net/ipv6/fou6.c:106: undefined reference to `ip6_tnl_encap_del_ops'
    net/ipv6/fou6.c:107: undefined reference to `ip6_tnl_encap_del_ops'
    
    If CONFIG_IPV6=m, ip6_tnl_encap_add_ops/ip6_tnl_encap_del_ops
    are in a module, but fou6.c can still be built-in, and that
    obviously fails to link.
    
    Also, if CONFIG_IPV6=y, but CONFIG_IPV6_TUNNEL=m or
    CONFIG_IPV6_TUNNEL=n, the same problem happens for a different
    reason.
    
    This adds two new silent Kconfig symbols to work around both
    problems:
    
    - CONFIG_IPV6_FOU is now always set to 'm' if either CONFIG_NET_FOU=m
      or CONFIG_IPV6=m
    - CONFIG_IPV6_FOU_TUNNEL is set implicitly when IPV6_FOU is enabled
      and NET_FOU_IP_TUNNELS is also turned out, and it will ensure
      that CONFIG_IPV6_TUNNEL is also available.
    
    The options could be made user-visible as well, to give additional
    room for configuration, but it seems easier not to bother users
    with more choice here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: aa3463d65e7b ("fou: Add encap ops for IPv6 tunnels")
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index c972d0b52579..9ea249b9451e 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -69,7 +69,7 @@ int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
 }
 EXPORT_SYMBOL(gue6_build_header);
 
-#ifdef CONFIG_NET_FOU_IP_TUNNELS
+#if IS_ENABLED(CONFIG_IPV6_FOU_TUNNEL)
 
 static const struct ip6_tnl_encap_ops fou_ip6tun_ops = {
 	.encap_hlen = fou_encap_hlen,

commit aa3463d65e7b9f5ae322db4a12214c2cb041bc8e
Author: Tom Herbert <tom@herbertland.com>
Date:   Wed May 18 09:06:18 2016 -0700

    fou: Add encap ops for IPv6 tunnels
    
    This patch add a new fou6 module that provides encapsulation
    operations for IPv6.
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
new file mode 100644
index 000000000000..c972d0b52579
--- /dev/null
+++ b/net/ipv6/fou6.c
@@ -0,0 +1,140 @@
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <net/fou.h>
+#include <net/ip.h>
+#include <net/ip6_tunnel.h>
+#include <net/ip6_checksum.h>
+#include <net/protocol.h>
+#include <net/udp.h>
+#include <net/udp_tunnel.h>
+
+static void fou6_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,
+			   struct flowi6 *fl6, u8 *protocol, __be16 sport)
+{
+	struct udphdr *uh;
+
+	skb_push(skb, sizeof(struct udphdr));
+	skb_reset_transport_header(skb);
+
+	uh = udp_hdr(skb);
+
+	uh->dest = e->dport;
+	uh->source = sport;
+	uh->len = htons(skb->len);
+	udp6_set_csum(!(e->flags & TUNNEL_ENCAP_FLAG_CSUM6), skb,
+		      &fl6->saddr, &fl6->daddr, skb->len);
+
+	*protocol = IPPROTO_UDP;
+}
+
+int fou6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+		      u8 *protocol, struct flowi6 *fl6)
+{
+	__be16 sport;
+	int err;
+	int type = e->flags & TUNNEL_ENCAP_FLAG_CSUM6 ?
+		SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+
+	err = __fou_build_header(skb, e, protocol, &sport, type);
+	if (err)
+		return err;
+
+	fou6_build_udp(skb, e, fl6, protocol, sport);
+
+	return 0;
+}
+EXPORT_SYMBOL(fou6_build_header);
+
+int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+		      u8 *protocol, struct flowi6 *fl6)
+{
+	__be16 sport;
+	int err;
+	int type = e->flags & TUNNEL_ENCAP_FLAG_CSUM6 ?
+		SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+
+	err = __gue_build_header(skb, e, protocol, &sport, type);
+	if (err)
+		return err;
+
+	fou6_build_udp(skb, e, fl6, protocol, sport);
+
+	return 0;
+}
+EXPORT_SYMBOL(gue6_build_header);
+
+#ifdef CONFIG_NET_FOU_IP_TUNNELS
+
+static const struct ip6_tnl_encap_ops fou_ip6tun_ops = {
+	.encap_hlen = fou_encap_hlen,
+	.build_header = fou6_build_header,
+};
+
+static const struct ip6_tnl_encap_ops gue_ip6tun_ops = {
+	.encap_hlen = gue_encap_hlen,
+	.build_header = gue6_build_header,
+};
+
+static int ip6_tnl_encap_add_fou_ops(void)
+{
+	int ret;
+
+	ret = ip6_tnl_encap_add_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);
+	if (ret < 0) {
+		pr_err("can't add fou6 ops\n");
+		return ret;
+	}
+
+	ret = ip6_tnl_encap_add_ops(&gue_ip6tun_ops, TUNNEL_ENCAP_GUE);
+	if (ret < 0) {
+		pr_err("can't add gue6 ops\n");
+		ip6_tnl_encap_del_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ip6_tnl_encap_del_fou_ops(void)
+{
+	ip6_tnl_encap_del_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);
+	ip6_tnl_encap_del_ops(&gue_ip6tun_ops, TUNNEL_ENCAP_GUE);
+}
+
+#else
+
+static int ip6_tnl_encap_add_fou_ops(void)
+{
+	return 0;
+}
+
+static void ip6_tnl_encap_del_fou_ops(void)
+{
+}
+
+#endif
+
+static int __init fou6_init(void)
+{
+	int ret;
+
+	ret = ip6_tnl_encap_add_fou_ops();
+
+	return ret;
+}
+
+static void __exit fou6_fini(void)
+{
+	ip6_tnl_encap_del_fou_ops();
+}
+
+module_init(fou6_init);
+module_exit(fou6_fini);
+MODULE_AUTHOR("Tom Herbert <therbert@google.com>");
+MODULE_LICENSE("GPL");
