commit e1b185491f739983b596804953586346e50351c9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Oct 24 17:23:23 2019 +0200

    net: Fix various misspellings of "connect"
    
    Fix misspellings of "disconnect", "disconnecting", "connections", and
    "disconnected".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Kalle Valo <kvalo@codeaurora.org>
    Acked-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index dc8f689bd469..f9e83031a40a 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -114,7 +114,7 @@ void regulatory_hint_country_ie(struct wiphy *wiphy,
 			 u8 country_ie_len);
 
 /**
- * regulatory_hint_disconnect - informs all devices have been disconneted
+ * regulatory_hint_disconnect - informs all devices have been disconnected
  *
  * Regulotory rules can be enhanced further upon scanning and upon
  * connection to an AP. These rules become stale if we disconnect

commit dc0c18ed229cdcca283dd78fefa38273ec37a42c
Author: Aaron Komisar <aaron.komisar@tandemg.com>
Date:   Wed Oct 2 13:59:07 2019 +0000

    mac80211: fix scan when operating on DFS channels in ETSI domains
    
    In non-ETSI regulatory domains scan is blocked when operating channel
    is a DFS channel. For ETSI, however, once DFS channel is marked as
    available after the CAC, this channel will remain available (for some
    time) even after leaving this channel.
    
    Therefore a scan can be done without any impact on the availability
    of the DFS channel as no new CAC is required after the scan.
    
    Enable scan in mac80211 in these cases.
    
    Signed-off-by: Aaron Komisar <aaron.komisar@tandemg.com>
    Link: https://lore.kernel.org/r/1570024728-17284-1-git-send-email-aaron.komisar@tandemg.com
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 504133d76de4..dc8f689bd469 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -155,14 +155,6 @@ bool regulatory_indoor_allowed(void);
  */
 #define REG_PRE_CAC_EXPIRY_GRACE_MS 2000
 
-/**
- * regulatory_pre_cac_allowed - if pre-CAC allowed in the current dfs domain
- * @wiphy: wiphy for which pre-CAC capability is checked.
-
- * Pre-CAC is allowed only in ETSI domain.
- */
-bool regulatory_pre_cac_allowed(struct wiphy *wiphy);
-
 /**
  * regulatory_propagate_dfs_state - Propagate DFS channel state to other wiphys
  * @wiphy - wiphy on which radar is detected and the event will be propagated

commit e646a0257b64dbef9d168e0f90daafa3fc1a83af
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Feb 5 21:08:29 2019 +0100

    cfg80211: restore regulatory without calling userspace
    
    Jouni reports that in some cases it is possible that getting
    disconnected (or stopping AP, after previous patches) results
    in further operations hitting the window within the regulatory
    core restoring the regdomain to the defaults. The reason for
    this is that we have to call out to CRDA or otherwise do some
    asynchronous work, and thus can't do the restore atomically.
    
    However, we've previously seen all the data we need to do the
    restore, so we can hang on to that data and use it later for
    the restore. This makes the whole thing happen within a single
    locked section and thus atomic.
    
    However, we can't *always* do this - there are unfortunately
    cases where the restore needs to re-request, because this is
    also used (abused?) as an error recovery process, so make the
    new behaviour optional and only use it when doing a regular
    restore as described above.
    
    Reported-by: Jouni Malinen <j@w1.fi>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 9ceeb5f3a7cb..504133d76de4 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -5,6 +5,7 @@
 
 /*
  * Copyright 2008-2011	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
+ * Copyright (C) 2019 Intel Corporation
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -22,6 +23,7 @@
 enum ieee80211_regd_source {
 	REGD_SOURCE_INTERNAL_DB,
 	REGD_SOURCE_CRDA,
+	REGD_SOURCE_CACHED,
 };
 
 extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;

commit 90a53e4432b12288316efaa5f308adafb8d304b0
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Sep 13 22:21:08 2017 +0200

    cfg80211: implement regdb signature checking
    
    Currently CRDA implements the signature checking, and the previous
    commits added the ability to load the whole regulatory database
    into the kernel.
    
    However, we really can't lose the signature checking, so implement
    it in the kernel by loading a detached signature (regulatory.db.p7s)
    and check it against built-in keys.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 9529c522611a..9ceeb5f3a7cb 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -1,5 +1,8 @@
 #ifndef __NET_WIRELESS_REG_H
 #define __NET_WIRELESS_REG_H
+
+#include <net/cfg80211.h>
+
 /*
  * Copyright 2008-2011	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
  *
@@ -185,4 +188,9 @@ bool reg_dfs_domain_same(struct wiphy *wiphy1, struct wiphy *wiphy2);
  */
 int reg_reload_regdb(void);
 
+extern const u8 shipped_regdb_certs[];
+extern unsigned int shipped_regdb_certs_len;
+extern const u8 extra_regdb_certs[];
+extern unsigned int extra_regdb_certs_len;
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 1ea4ff3e9f0b8d53e680a2bb9e8e644bf03aeb4d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Sep 13 16:07:22 2017 +0200

    cfg80211: support reloading regulatory database
    
    If the regulatory database is loaded, and then updated, it may
    be necessary to reload it. Add an nl80211 command to do this.
    
    Note that this just reloads the database, it doesn't re-apply
    the rules from it immediately.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index ca7fedf2e7a1..9529c522611a 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -179,4 +179,10 @@ void regulatory_propagate_dfs_state(struct wiphy *wiphy,
  * @wiphy2 - wiphy it's dfs_region to be checked against that of wiphy1
  */
 bool reg_dfs_domain_same(struct wiphy *wiphy1, struct wiphy *wiphy2);
+
+/**
+ * reg_reload_regdb - reload the regulatory.db firmware file
+ */
+int reg_reload_regdb(void);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 8976672736d6089ae011fda3482e30e4380276f8
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Mon Feb 27 17:04:35 2017 +0530

    cfg80211: Share Channel DFS state across wiphys of same DFS domain
    
    Sharing DFS channel state across multiple wiphys (radios) could
    be useful with multiple radios on the system. When one radio
    completes CAC and markes the channel available another radio
    can use this information and start beaconing without really doing
    CAC.
    
    Whenever there is a state change in dfs channel associated to
    a particular wiphy the the same state change is propagated to
    other wiphys having the same DFS reg domain configuration.
    Also when a new wiphy is created the dfs channel state of
    other existing wiphys of same DFS domain is copied.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index ff078f093989..ca7fedf2e7a1 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -157,4 +157,26 @@ bool regulatory_indoor_allowed(void);
  * Pre-CAC is allowed only in ETSI domain.
  */
 bool regulatory_pre_cac_allowed(struct wiphy *wiphy);
+
+/**
+ * regulatory_propagate_dfs_state - Propagate DFS channel state to other wiphys
+ * @wiphy - wiphy on which radar is detected and the event will be propagated
+ *	to other available wiphys having the same DFS domain
+ * @chandef - Channel definition of radar detected channel
+ * @dfs_state - DFS channel state to be set
+ * @event - Type of radar event which triggered this DFS state change
+ *
+ * This function should be called with rtnl lock held.
+ */
+void regulatory_propagate_dfs_state(struct wiphy *wiphy,
+				    struct cfg80211_chan_def *chandef,
+				    enum nl80211_dfs_state dfs_state,
+				    enum nl80211_radar_event event);
+
+/**
+ * reg_dfs_domain_same - Checks if both wiphy have same DFS domain configured
+ * @wiphy1 - wiphy it's dfs_region to be checked against that of wiphy2
+ * @wiphy2 - wiphy it's dfs_region to be checked against that of wiphy1
+ */
+bool reg_dfs_domain_same(struct wiphy *wiphy1, struct wiphy *wiphy2);
 #endif  /* __NET_WIRELESS_REG_H */

commit b35a51c7dd25a823767969e3089542d7478777e9
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Mon Feb 27 17:04:33 2017 +0530

    cfg80211: Make pre-CAC results valid only for ETSI domain
    
    DFS requirement for ETSI domain (section 4.7.1.4 in
    ETSI EN 301 893 V1.8.1) is the only one which explicitly
    states that once DFS channel is marked as available afer
    the CAC, this channel will remain in available state even
    moving to a different operating channel. But the same is
    not explicitly stated in FCC DFS requirement. Also, Pre-CAC
    requriements are not explicitly mentioned in FCC requirement.
    Current implementation in keeping DFS channel in available
    state is same as described in ETSI domain.
    
    For non-ETSI DFS domain, this patch gives a grace period of 2 seconds
    since the completion of successful CAC before moving the channel's
    DFS state to 'usable' from 'available' state. The same grace period
    is checked against the channel's dfs_state_entered timestamp while
    deciding if a DFS channel is available for operation. There is a new
    radar event, NL80211_RADAR_PRE_CAC_EXPIRED, reported when DFS channel
    is moved from available to usable state after the grace period. Also
    make sure the DFS channel state is reset to usable once the beaconing
    operation on that channel is brought down (like stop_ap, leave_ibss
    and leave_mesh) in non-ETSI domain.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index f6ced316b5a4..ff078f093989 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -143,4 +143,18 @@ int cfg80211_get_unii(int freq);
  */
 bool regulatory_indoor_allowed(void);
 
+/*
+ * Grace period to timeout pre-CAC results on the dfs channels. This timeout
+ * value is used for Non-ETSI domain.
+ * TODO: May be make this timeout available through regdb?
+ */
+#define REG_PRE_CAC_EXPIRY_GRACE_MS 2000
+
+/**
+ * regulatory_pre_cac_allowed - if pre-CAC allowed in the current dfs domain
+ * @wiphy: wiphy for which pre-CAC capability is checked.
+
+ * Pre-CAC is allowed only in ETSI domain.
+ */
+bool regulatory_pre_cac_allowed(struct wiphy *wiphy);
 #endif  /* __NET_WIRELESS_REG_H */

commit 57fbcce37be7c1d2622b56587c10ade00e96afa3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 12 15:56:15 2016 +0200

    cfg80211: remove enum ieee80211_band
    
    This enum is already perfectly aliased to enum nl80211_band, and
    the only reason for it is that we get IEEE80211_NUM_BANDS out of
    it. There's no really good reason to not declare the number of
    bands in nl80211 though, so do that and remove the cfg80211 one.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 9f495d76eca0..f6ced316b5a4 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -104,7 +104,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
  * information for a band the BSS is not present in it will be ignored.
  */
 void regulatory_hint_country_ie(struct wiphy *wiphy,
-			 enum ieee80211_band band,
+			 enum nl80211_band band,
 			 const u8 *country_ie,
 			 u8 country_ie_len);
 

commit c37722bd1972118142ee54c0e1a727142d944068
Author: Ilan peer <ilan.peer@intel.com>
Date:   Mon Mar 30 15:15:49 2015 +0300

    cfg80211: Stop calling crda if it is not responsive
    
    Patch eeca9fce1d71a4955855ceb0c3b13c1eb9db27c1 (cfg80211: Schedule
    timeout for all CRDA call) introduced a regression, where in case
    that crda is not installed (or not configured properly etc.), the
    regulatory core will needlessly continue to call it, polluting the
    log with the following log:
    
    "cfg80211: Calling CRDA to update world regulatory domain"
    
    Fix this by limiting the number of continuous CRDA request failures.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index a2c4e16459da..9f495d76eca0 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -16,6 +16,11 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+enum ieee80211_regd_source {
+	REGD_SOURCE_INTERNAL_DB,
+	REGD_SOURCE_CRDA,
+};
+
 extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
 bool reg_is_valid_request(const char *alpha2);
@@ -46,7 +51,9 @@ void wiphy_regulatory_deregister(struct wiphy *wiphy);
 int __init regulatory_init(void);
 void regulatory_exit(void);
 
-int set_regdom(const struct ieee80211_regdomain *rd);
+int set_regdom(const struct ieee80211_regdomain *rd,
+	       enum ieee80211_regd_source regd_src);
+
 unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
 				   const struct ieee80211_reg_rule *rule);
 

commit 05050753602626ed4c46271c689929b625f409e7
Author: Ilan peer <ilan.peer@intel.com>
Date:   Wed Mar 4 00:32:06 2015 -0500

    cfg80211: Add API to change the indoor regulatory setting
    
    Previously, the indoor setting configuration assumed that as
    long as a station interface is connected, the indoor environment
    setting does not change. However, this assumption is problematic
    as:
    
    - It is possible that a station interface is connected to a mobile
      AP, e.g., softAP or a P2P GO, where it is possible that both the
      station and the mobile AP move out of the indoor environment making
      the indoor setting invalid. In such a case, user space has no way to
      invalidate the setting.
    - A station interface disconnection does not necessarily imply that
      the device is no longer operating in an indoor environment, e.g.,
      it is possible that the station interface is roaming but is still
      stays indoor.
    
    To handle the above, extend the indoor configuration API to allow
    user space to indicate a change of indoor settings, and allow it to
    indicate weather it controls the indoor setting, such that:
    
    1. If the user space process explicitly indicates that it is going
       to control the indoor setting, do not clear the indoor setting
       internally, unless the socket is released. The user space process
       should use the NL80211_ATTR_SOCKET_OWNER attribute in the command
       to state that it is going to control the indoor setting.
    2. Reset the indoor setting when restoring the regulatory settings in
       case it is not owned by a user space process.
    
    Based on the above, a user space tool that continuously monitors the
    indoor settings, i.e., tracking power setting, location etc., can
    indicate environment changes to the regulatory core.
    
    It should be noted that currently user space is the only provided mechanism
    used to hint to the regulatory core over the indoor/outdoor environment --
    while the country IEs do have an environment setting this has been completely
    ignored by the regulatory core by design for a while now since country IEs
    typically can contain bogus data.
    
    Acked-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: ArikX Nemtsov <arik@wizery.com>
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 4b45d6e61d24..a2c4e16459da 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -25,7 +25,20 @@ enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy);
 
 int regulatory_hint_user(const char *alpha2,
 			 enum nl80211_user_reg_hint_type user_reg_hint_type);
-int regulatory_hint_indoor_user(void);
+
+/**
+ * regulatory_hint_indoor - hint operation in indoor env. or not
+ * @is_indoor: if true indicates that user space thinks that the
+ * device is operating in an indoor environment.
+ * @portid: the netlink port ID on which the hint was given.
+ */
+int regulatory_hint_indoor(bool is_indoor, u32 portid);
+
+/**
+ * regulatory_netlink_notify - notify on released netlink socket
+ * @portid: the netlink socket port ID
+ */
+void regulatory_netlink_notify(u32 portid);
 
 void wiphy_regulatory_register(struct wiphy *wiphy);
 void wiphy_regulatory_deregister(struct wiphy *wiphy);

commit ad30ca2c03cecfb1b0749874bdceead269542de6
Author: Arik Nemtsov <arik@wizery.com>
Date:   Mon Dec 15 19:25:59 2014 +0200

    cfg80211: allow usermode to query wiphy specific regdom
    
    If a wiphy-idx is specified, the kernel will return the wiphy specific
    regdomain, if such exists. Otherwise return the global regdom.
    
    When no wiphy-idx is specified, return the global regdomain as well as
    all wiphy-specific regulatory domains in the system, via a new nested
    list of attributes.
    
    Add a new attribute for each wiphy-specific regdomain, for usermode to
    identify it as such.
    
    Signed-off-by: Arik Nemtsov <arikx.nemtsov@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 5e48031ccb9a..4b45d6e61d24 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -38,6 +38,7 @@ unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
 				   const struct ieee80211_reg_rule *rule);
 
 bool reg_last_request_cell_base(void);
+const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy);
 
 /**
  * regulatory_hint_found_beacon - hints a beacon was found on a channel

commit c8866e55a94fb02b83b13f289e5e470fc928703a
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Sun Feb 23 09:13:03 2014 +0200

    cfg80211: Enable GO operation on indoor channels
    
    Allow GO operation on a channel marked with IEEE80211_CHAN_INDOOR_ONLY
    iff there is a user hint indicating that the platform is operating in
    an indoor environment, i.e., the platform is a printer or media center
    device.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 2a3842828f6d..5e48031ccb9a 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -117,4 +117,9 @@ void regulatory_hint_disconnect(void);
  */
 int cfg80211_get_unii(int freq);
 
+/**
+ * regulatory_indoor_allowed - is indoor operation allowed
+ */
+bool regulatory_indoor_allowed(void);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 52616f2b446eaad8eb2cd78bbd052f0066069757
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Tue Feb 25 16:26:00 2014 +0200

    cfg80211: Add an option to hint indoor operation
    
    Add the option to hint the wireless core that it is operating in an indoor
    environment.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 334a53af0fc8..2a3842828f6d 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -25,6 +25,7 @@ enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy);
 
 int regulatory_hint_user(const char *alpha2,
 			 enum nl80211_user_reg_hint_type user_reg_hint_type);
+int regulatory_hint_indoor_user(void);
 
 void wiphy_regulatory_register(struct wiphy *wiphy);
 void wiphy_regulatory_deregister(struct wiphy *wiphy);

commit 174e0cd28af0fe3c6c634c3e4d9e042c683bd7f7
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Sun Feb 23 09:13:01 2014 +0200

    cfg80211: Enable GO operation on additional channels
    
    Allow GO operation on a channel marked with IEEE80211_CHAN_GO_CONCURRENT
    iff there is an active station interface that is associated to
    an AP operating on the same channel in the 2 GHz band or the same UNII band
    (in the 5 GHz band). This relaxation is not allowed if the channel is
    marked with IEEE80211_CHAN_RADAR.
    
    Note that this is a permissive approach to the FCC definitions,
    that require a clear assessment that the device operating the AP is
    an authorized master, i.e., with radar detection and DFS capabilities.
    
    It is assumed that such restrictions are enforced by user space.
    Furthermore, it is assumed, that if the conditions that allowed for
    the operation of the GO on such a channel change, i.e., the station
    interface disconnected from the AP, it is the responsibility of user
    space to evacuate the GO from the channel.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 37c180df34b7..334a53af0fc8 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -104,4 +104,16 @@ void regulatory_hint_country_ie(struct wiphy *wiphy,
  */
 void regulatory_hint_disconnect(void);
 
+/**
+ * cfg80211_get_unii - get the U-NII band for the frequency
+ * @freq: the frequency for which we want to get the UNII band.
+
+ * Get a value specifying the U-NII band frequency belongs to.
+ * U-NII bands are defined by the FCC in C.F.R 47 part 15.
+ *
+ * Returns -EINVAL if freq is invalid, 0 for UNII-1, 1 for UNII-2A,
+ * 2 for UNII-2B, 3 for UNII-2C and 4 for UNII-3.
+ */
+int cfg80211_get_unii(int freq);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 1226d2587065f98dae54c79e14dd329879b896f7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Feb 25 15:43:36 2014 +0100

    cfg80211: regulatory: simplify uevent sending
    
    There's no need for the struct device_type with the uevent function
    etc., just fill the country alpha2 when sending the event.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 18524617ab62..37c180df34b7 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -26,7 +26,6 @@ enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy);
 int regulatory_hint_user(const char *alpha2,
 			 enum nl80211_user_reg_hint_type user_reg_hint_type);
 
-int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env);
 void wiphy_regulatory_register(struct wiphy *wiphy);
 void wiphy_regulatory_deregister(struct wiphy *wiphy);
 

commit 9752482083066af7ac18a5ca376ff35d72418b29
Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
Date:   Thu Jan 30 09:52:20 2014 +0100

    cfg80211: regulatory introduce maximum bandwidth calculation
    
    In case we will get regulatory request with rule
    where max_bandwidth_khz is set to 0 handle this
    case as a special one.
    
    If max_bandwidth_khz == 0 we should calculate maximum
    available bandwidth base on all frequency contiguous rules.
    In case we need auto calculation we just have to set:
    
    country PL: DFS-ETSI
            (2402 - 2482 @ 40), (N/A, 20)
            (5170 - 5250 @ AUTO), (N/A, 20)
            (5250 - 5330 @ AUTO), (N/A, 20), DFS
            (5490 - 5710 @ 80), (N/A, 27), DFS
    
    This mean we will calculate maximum bw for rules where
    AUTO (N/A) were set, 160MHz (5330 - 5170) in example above.
    So we will get:
            (5170 - 5250 @ 160), (N/A, 20)
            (5250 - 5330 @ 160), (N/A, 20), DFS
    
    In other case:
    country FR: DFS-ETSI
            (2402 - 2482 @ 40), (N/A, 20)
            (5170 - 5250 @ AUTO), (N/A, 20)
            (5250 - 5330 @ 80), (N/A, 20), DFS
            (5490 - 5710 @ 80), (N/A, 27), DFS
    
    We will get 80MHz (5250 - 5170):
            (5170 - 5250 @ 80), (N/A, 20)
            (5250 - 5330 @ 80), (N/A, 20), DFS
    
    Base on this calculations we will set correct channel
    bandwidth flags (eg. IEEE80211_CHAN_NO_80MHZ).
    
    We don't need any changes in CRDA or internal regulatory.
    
    Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
    [extend nl80211 description a bit, fix typo]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 02bd8f4b0921..18524617ab62 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -34,6 +34,8 @@ int __init regulatory_init(void);
 void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
+unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
+				   const struct ieee80211_reg_rule *rule);
 
 bool reg_last_request_cell_base(void);
 

commit 6c474799dccc91c9cf03cd18ec32f97929549e9f
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 25 20:56:09 2013 +0100

    cfg80211: add reg_get_dfs_region()
    
    This can be used outside of the regulatory context for any checks
    on the DFS region. The central cfg80211 dfs_region is always used
    and if it does not match with the wiphy a debug print is issued.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index cc4c2c0a6723..02bd8f4b0921 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -21,6 +21,7 @@ extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 bool reg_is_valid_request(const char *alpha2);
 bool is_world_regdom(const char *alpha2);
 bool reg_supported_dfs_region(enum nl80211_dfs_regions dfs_region);
+enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy);
 
 int regulatory_hint_user(const char *alpha2,
 			 enum nl80211_user_reg_hint_type user_reg_hint_type);

commit 4c7d3982a6e37831382b9ef90aa0dbadc0bf3a22
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Wed Nov 13 18:54:02 2013 +0100

    cfg80211: use enum nl80211_dfs_regions for dfs_region everywhere
    
    u8 was used in some other places, just stick to the enum,
    this forces us to express the values that are expected.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index b4076babaf47..cc4c2c0a6723 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -20,7 +20,7 @@ extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
 bool reg_is_valid_request(const char *alpha2);
 bool is_world_regdom(const char *alpha2);
-bool reg_supported_dfs_region(u8 dfs_region);
+bool reg_supported_dfs_region(enum nl80211_dfs_regions dfs_region);
 
 int regulatory_hint_user(const char *alpha2,
 			 enum nl80211_user_reg_hint_type user_reg_hint_type);

commit e438768ff9b22c83a968e14b79e8c83128e8bfe4
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Tue Nov 5 09:18:01 2013 -0800

    cfg80211: check regulatory request alpha2 early
    
    Currently nl80211 allows userspace to send the kernel
    a bogus regulatory domain with at most 32 rules set
    and it won't reject it until after its allocated
    memory. Let's be smart about it and take advantage
    that the last_request is now available under RTNL
    and check if the alpha2 matches an expected request
    and reject any bogus userspace requests prior to
    hitting the memory allocator.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 9677e3c13da9..b4076babaf47 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -18,6 +18,7 @@
 
 extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
+bool reg_is_valid_request(const char *alpha2);
 bool is_world_regdom(const char *alpha2);
 bool reg_supported_dfs_region(u8 dfs_region);
 

commit 789fd03331aa1ec45cb58168e2d82525c97c7351
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Fri Oct 4 18:07:24 2013 -0700

    cfg80211: rename regulatory_hint_11d() to regulatory_hint_country_ie()
    
    It is incorrect to refer to this as 11d as 802.11d was just a
    proposed amendment, 802.11d was merged to the standard so
    use proper terminology.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index af2d5f8a5d82..9677e3c13da9 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -58,7 +58,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
 				 gfp_t gfp);
 
 /**
- * regulatory_hint_11d - hints a country IE as a regulatory domain
+ * regulatory_hint_country_ie - hints a country IE as a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
  * @band: the band on which the country IE was received on. This determines
@@ -78,7 +78,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
  * not observed. For this reason if a triplet is seen with channel
  * information for a band the BSS is not present in it will be ignored.
  */
-void regulatory_hint_11d(struct wiphy *wiphy,
+void regulatory_hint_country_ie(struct wiphy *wiphy,
 			 enum ieee80211_band band,
 			 const u8 *country_ie,
 			 u8 country_ie_len);

commit 458f4f9e960b9a3b674c4b87d996eef186b1fe83
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 6 15:47:38 2012 +0100

    regulatory: use RCU to protect global and wiphy regdomains
    
    To simplify the locking and not require cfg80211_mutex
    (which nl80211 uses to access the global regdomain) and
    also to make it possible for drivers to access their
    wiphy->regd safely, use RCU to protect these pointers.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index d391b50d2829..af2d5f8a5d82 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -16,7 +16,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-extern const struct ieee80211_regdomain *cfg80211_regdomain;
+extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
 bool is_world_regdom(const char *alpha2);
 bool reg_supported_dfs_region(u8 dfs_region);

commit 6913b49a5071064f49f7a74b432286fa735f7612
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Dec 4 00:48:59 2012 +0100

    regulatory: fix reg_is_valid_request handling
    
    There's a bug with the world regulatory domain, it
    can be updated any time which is different from all
    other regdomains that can only be updated once after
    a request for them. Fix this by adding a check for
    "processed" to the reg_is_valid_request() function
    and clear that when doing a request.
    
    While looking at this I also found another locking
    bug, last_request is protected by the reg_mutex not
    the cfg80211_mutex so the code in nl80211 is racy.
    Remove that code as it only tries to prevent an
    allocation in an error case, which isn't necessary.
    Then the function can also become static and locking
    in nl80211 can have a smaller scope.
    
    Also change __set_regdom() to do the checks earlier
    and not different for world/other regdomains.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 37891e813a74..d391b50d2829 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -19,7 +19,6 @@
 extern const struct ieee80211_regdomain *cfg80211_regdomain;
 
 bool is_world_regdom(const char *alpha2);
-bool reg_is_valid_request(const char *alpha2);
 bool reg_supported_dfs_region(u8 dfs_region);
 
 int regulatory_hint_user(const char *alpha2,

commit 1a9193185f462a51815fe48491f8a6fb6b942551
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Dec 3 17:21:11 2012 +0100

    regulatory: code cleanup
    
    Clean up various things like indentation, extra
    parentheses, too many/few line breaks, etc.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 4c0a32ffd530..37891e813a74 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -55,8 +55,8 @@ bool reg_last_request_cell_base(void);
  * set the wiphy->disable_beacon_hints to true.
  */
 int regulatory_hint_found_beacon(struct wiphy *wiphy,
-					struct ieee80211_channel *beacon_chan,
-					gfp_t gfp);
+				 struct ieee80211_channel *beacon_chan,
+				 gfp_t gfp);
 
 /**
  * regulatory_hint_11d - hints a country IE as a regulatory domain

commit 9caf03640279e64d0ba36539b42daa1b43a49486
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 29 01:25:20 2012 +0100

    cfg80211: fix BSS struct IE access races
    
    When a BSS struct is updated, the IEs are currently
    overwritten or freed. This can lead to races if some
    other CPU is accessing the BSS struct and using the
    IEs concurrently.
    
    Fix this by always allocating the IEs in a new struct
    that holds the data and length and protecting access
    to this new struct with RCU.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index f023c8a31c60..4c0a32ffd530 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -81,7 +81,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
  */
 void regulatory_hint_11d(struct wiphy *wiphy,
 			 enum ieee80211_band band,
-			 u8 *country_ie,
+			 const u8 *country_ie,
 			 u8 country_ie_len);
 
 /**

commit f8a1c774570ab50f1657083c990b968d5f7f22cb
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Thu Jul 12 11:49:20 2012 -0700

    cfg80211: make regulatory_update() static
    
    Now that we have wiphy_regulatory_register() we can
    tuck away the core's regulatory_update() call there
    and make it static.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index f36b15fb4592..f023c8a31c60 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -34,7 +34,6 @@ void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
-void regulatory_update(struct wiphy *wiphy, enum nl80211_reg_initiator setby);
 bool reg_last_request_cell_base(void);
 
 /**

commit bfead0808c3b1fff3b94daceef0a0a48e73c42a9
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Thu Jul 12 11:49:19 2012 -0700

    cfg80211: rename reg_device_remove() to wiphy_regulatory_deregister()
    
    This makes it clearer what we're doing. This now makes a bit
    more sense given that regardless of the wiphy if the cell
    base station hint feature is supported we will be modifying the
    way the regulatory core behaves.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 519492fdda3c..f36b15fb4592 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -27,7 +27,7 @@ int regulatory_hint_user(const char *alpha2,
 
 int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env);
 void wiphy_regulatory_register(struct wiphy *wiphy);
-void reg_device_remove(struct wiphy *wiphy);
+void wiphy_regulatory_deregister(struct wiphy *wiphy);
 
 int __init regulatory_init(void);
 void regulatory_exit(void);

commit 57b5ce072e7361218a8e2ea1d62960cbb71d9cff
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Thu Jul 12 11:49:18 2012 -0700

    cfg80211: add cellular base station regulatory hint support
    
    Cellular base stations can provide hints to cfg80211 about
    where they think we are. This can be done for example on
    a cell phone. To enable these hints we simply allow them
    through as user regulatory hints but we allow userspace
    to clasify the hint as either coming directly from the
    user or coming from a cellular base station. This option
    is only available when you enable
    CONFIG_CFG80211_CERTIFICATION_ONUS.
    
    The base station hints themselves will not be processed
    by the core unless at least one device on the system
    supports this feature.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index e2aaaf525a22..519492fdda3c 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -22,9 +22,11 @@ bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
 bool reg_supported_dfs_region(u8 dfs_region);
 
-int regulatory_hint_user(const char *alpha2);
+int regulatory_hint_user(const char *alpha2,
+			 enum nl80211_user_reg_hint_type user_reg_hint_type);
 
 int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env);
+void wiphy_regulatory_register(struct wiphy *wiphy);
 void reg_device_remove(struct wiphy *wiphy);
 
 int __init regulatory_init(void);
@@ -33,6 +35,7 @@ void regulatory_exit(void);
 int set_regdom(const struct ieee80211_regdomain *rd);
 
 void regulatory_update(struct wiphy *wiphy, enum nl80211_reg_initiator setby);
+bool reg_last_request_cell_base(void);
 
 /**
  * regulatory_hint_found_beacon - hints a beacon was found on a channel

commit 3b77d5ec0c86b8a9594217ff9024b00e4d1c5795
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Tue Dec 20 12:23:38 2011 -0800

    cfg80211: relicense reg.c reg.h and genregdb.awk to ISC
    
    Following the tradition we have had with ath5k, ath9k, CRDA,
    wireless-regdb I'd like to license this code under the permissive ISC
    license for the code sharing purposes with other OSes, it'd sure be nice
    to help the landscape in this area. Although I am %82.89 owner of the
    regulatory code I have asked every contributor to the regulatory code
    and have receieved positive Acked-bys from everyone except two deceased
    entities:
    
     o Frans Pop RIP 2010 [0]
            - Frans Pop <elendil@planet.nl>
            - Frans Pop <fjp@debian.org>
     o Nokia     RIP February, 11, 2011 [1], [2]
            - ext-yuri.ershov@nokia.com
            - kalle.valo@nokia.com
    
    Frans Pop's contribution was a simple patch 55f98938, titled,
    "wireless: remove trailing space in messages" which just add a \n
    to some printk lines. I'm going to treat these additions as
    uncopyrightable.
    
    As for the contributions made by employees on behalf of Nokia
    my contact point was Petri Karhula <petri.karhula@nokia.com> but
    after one month he noted he had not been able to get traction from the
    legal department on this request, as such it I proceeded by replacing
    their contributions in previous patches.
    
    The end goal is to help a clean rewrite that starts in userspace
    that is shared under ISC license which currently is taking place with
    the regulatory simulator [3].
    
    [0] http://lists.debian.org/debian-devel/2011/12/msg00263.html
    [1] http://press.nokia.com/2011/02/11/nokia-outlines-new-strategy-introduces-new-leadership-operational-structure/
    [2] http://NokiaPlanB.com
    [3] git://github.com/mcgrof/regsim.git
    
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
    Acked-by: Dan Carpenter <error27@gmail.com>
    Acked-by: Mihai Moldovan <ionic@ionic.de>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Sven Neumann <s.neumann@raumfeld.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Tony Vroon <tony@linx.net>
    Acked-by: Pavel Roskin <proski@gnu.org>
    Acked-by: Bob Copeland <me@bobcopeland.com>
    Acked-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Acked-by: Pat Erley <pat-lkml@erley.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: John W. Linville <linville@tuxdriver.com>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Acked-by: Joe Perches <joe@perches.com>
    Acked-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: John Gordon <john@devicescape.com>
    Acked-by: Simon Barber <protocolmagic@gmail.com>
    Acked-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Acked-by: Jiri Benc <jbenc@upir.cz>
    Acked-by: Bruno Randolf <br1@einfach.org>
    Acked-by: Scott James Remnant <keybuk@google.com>
    Acked-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 786e414afd91..e2aaaf525a22 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -1,5 +1,20 @@
 #ifndef __NET_WIRELESS_REG_H
 #define __NET_WIRELESS_REG_H
+/*
+ * Copyright 2008-2011	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
 
 extern const struct ieee80211_regdomain *cfg80211_regdomain;
 

commit 8b60b07805d557542160d852874fa6a1b969184e
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Tue Oct 11 10:59:02 2011 -0700

    cfg80211: process regulatory DFS region for countries
    
    The wireless-regdb now has support for mapping a country to
    one DFS region. CRDA sends this to us now so process it
    so we can provide that hint to drivers. This will later be
    used by code for processing DFS in a way that meets the
    criteria for the DFS region the country belongs to.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 4a56799d868d..786e414afd91 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -5,6 +5,7 @@ extern const struct ieee80211_regdomain *cfg80211_regdomain;
 
 bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
+bool reg_supported_dfs_region(u8 dfs_region);
 
 int regulatory_hint_user(const char *alpha2);
 

commit eac03e381957a05f3842ceb8de987a1025966ecf
Author: Sven Neumann <s.neumann@raumfeld.com>
Date:   Tue Aug 30 23:38:53 2011 +0200

    cfg80211: hold reg_mutex when updating regulatory
    
    The function wiphy_update_regulatory() uses the static variable
    last_request and thus needs to be called with reg_mutex held.
    This is the case for all users in reg.c, but the function was
    exported for use by wiphy_register(), from where it is called
    without the lock being held.
    
    Fix this by making wiphy_update_regulatory() private and introducing
    regulatory_update() as a wrapper that acquires and holds the lock.
    
    Signed-off-by: Sven Neumann <s.neumann@raumfeld.com>
    Cc: John W. Linville <linville@tuxdriver.com>
    Cc: Luis R. Rodriguez <mcgrof@gmail.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: linux-wireless@vger.kernel.org
    Acked-by:  Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index b67d1c3a2fb9..4a56799d868d 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -16,6 +16,8 @@ void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
+void regulatory_update(struct wiphy *wiphy, enum nl80211_reg_initiator setby);
+
 /**
  * regulatory_hint_found_beacon - hints a beacon was found on a channel
  * @wiphy: the wireless device where the beacon was found on

commit 4d9d88d121fdd01dd859717909ea3c90173f143a
Author: Scott James Remnant <keybuk@google.com>
Date:   Tue Mar 8 10:45:30 2011 -0800

    net/wireless: add COUNTRY to to regulatory device uevent
    
    Regulatory devices issue change uevents to inform userspace of a need
    to call the crda tool; however these can often be sent before udevd is
    running, and were not previously included in the results of
    udevadm trigger (which requests a new change event using the /uevent
    attribute of the sysfs object).
    
    Add a uevent function to the device type which includes the COUNTRY
    information from the last request if it has yet to be processed, the
    case of multiple requests is already handled in the code by checking
    whether an unprocessed one is queued in the same manner and refusing
    to queue a new one.
    
    The existing udev rule continues to work as before.
    
    Signed-off-by: Scott James Remnant <keybuk@google.com>
    Acked-By: Kay Sievers <kay.sievers@vrfy.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index c4695d07af23..b67d1c3a2fb9 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -8,6 +8,7 @@ bool reg_is_valid_request(const char *alpha2);
 
 int regulatory_hint_user(const char *alpha2);
 
+int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env);
 void reg_device_remove(struct wiphy *wiphy);
 
 int __init regulatory_init(void);

commit 2fcc9f731b598a6c70dca277776c66c9cf9d7a3b
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 18 09:38:55 2010 +0200

    wireless: move regulatory_init to .init.text
    
    regulatory_init is only called by cfg80211_init which is in .init.text,
    too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index b26224a9f3bc..c4695d07af23 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -10,7 +10,7 @@ int regulatory_hint_user(const char *alpha2);
 
 void reg_device_remove(struct wiphy *wiphy);
 
-int regulatory_init(void);
+int __init regulatory_init(void);
 void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);

commit 09d989d179d0c679043556dda77c51b41a2dae7e
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Fri Jan 29 19:58:57 2010 -0500

    cfg80211: add regulatory hint disconnect support
    
    This adds a new regulatory hint to be used when we know all
    devices have been disconnected and idle. This can happen
    when we suspend, for instance. When we disconnect we can
    no longer assume the same regulatory rules learned from
    a country IE or beacon hints are applicable so restore
    regulatory settings to an initial state.
    
    Since driver hints are cached on the wiphy that called
    the hint, those hints are not reproduced onto cfg80211
    as the wiphy will respect its own wiphy->regd regardless.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 3018508226ab..b26224a9f3bc 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -63,4 +63,22 @@ void regulatory_hint_11d(struct wiphy *wiphy,
 			 u8 *country_ie,
 			 u8 country_ie_len);
 
+/**
+ * regulatory_hint_disconnect - informs all devices have been disconneted
+ *
+ * Regulotory rules can be enhanced further upon scanning and upon
+ * connection to an AP. These rules become stale if we disconnect
+ * and go to another country, whether or not we suspend and resume.
+ * If we suspend, go to another country and resume we'll automatically
+ * get disconnected shortly after resuming and things will be reset as well.
+ * This routine is a helper to restore regulatory settings to how they were
+ * prior to our first connect attempt. This includes ignoring country IE and
+ * beacon regulatory hints. The ieee80211_regdom module parameter will always
+ * be respected but if a user had set the regulatory domain that will take
+ * precedence.
+ *
+ * Must be called from process context.
+ */
+void regulatory_hint_disconnect(void);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 84920e3e47f654a22b540606fb8c1ab90b870942
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Thu Jan 14 20:08:20 2010 -0500

    cfg80211: make regulatory_hint_11d() band specific
    
    In practice APs do not send country IE channel triplets for channels
    the AP is not operating on and if they were to do so they would have
    to use the regulatory extension which we currently do not process.
    No AP has been seen in practice that does this though so just drop
    those country IEs.
    
    Additionally it has been noted the first series of country IE
    channels triplets are specific to the band the AP sends. Propagate
    the band on which the country IE was found on reject the country
    IE then if the triplets are ever oustide of the band.
    
    Although we now won't process country IE information with multiple
    band information we leave the intersection work as is as it is
    technically possible for someone to want to eventually process these
    type of country IEs with regulatory extensions.
    
    Cc: Jouni Malinen <jouni.malinen@atheros.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 3362c7c069b2..3018508226ab 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -41,14 +41,25 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
  * regulatory_hint_11d - hints a country IE as a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
+ * @band: the band on which the country IE was received on. This determines
+ *	the band we'll process the country IE channel triplets for.
  * @country_ie: pointer to the country IE
  * @country_ie_len: length of the country IE
  *
  * We will intersect the rd with the what CRDA tells us should apply
  * for the alpha2 this country IE belongs to, this prevents APs from
  * sending us incorrect or outdated information against a country.
+ *
+ * The AP is expected to provide Country IE channel triplets for the
+ * band it is on. It is technically possible for APs to send channel
+ * country IE triplets even for channels outside of the band they are
+ * in but for that they would have to use the regulatory extension
+ * in combination with a triplet but this behaviour is currently
+ * not observed. For this reason if a triplet is seen with channel
+ * information for a band the BSS is not present in it will be ignored.
  */
 void regulatory_hint_11d(struct wiphy *wiphy,
+			 enum ieee80211_band band,
 			 u8 *country_ie,
 			 u8 country_ie_len);
 

commit aa11d958d1a6572eda08214d7c6a735804fe48a5
Merge: 07f6642ee941 9799218ae369
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 12 17:44:53 2009 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            arch/microblaze/include/asm/socket.h

commit 8b19e6ca3bac7e04e93fb73f561d670e77c5fae6
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Thu Jul 30 17:38:09 2009 -0700

    cfg80211: enable country IE support to all cfg80211 drivers
    
    Since the bss is always set now once we are connected, if the
    bss has its own information element we refer to it and pass that
    instead of relying on mac80211's parsing.
    
    Now all cfg80211 drivers get country IE support, automatically and
    we reduce the call overhead that we had on mac80211 which called this
    upon every beacon and instead now call this only upon a successfull
    connection by a STA on cfg80211.
    
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index e37829a49dc4..662a9dad76d5 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -36,4 +36,19 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
 					struct ieee80211_channel *beacon_chan,
 					gfp_t gfp);
 
+/**
+ * regulatory_hint_11d - hints a country IE as a regulatory domain
+ * @wiphy: the wireless device giving the hint (used only for reporting
+ *	conflicts)
+ * @country_ie: pointer to the country IE
+ * @country_ie_len: length of the country IE
+ *
+ * We will intersect the rd with the what CRDA tells us should apply
+ * for the alpha2 this country IE belongs to, this prevents APs from
+ * sending us incorrect or outdated information against a country.
+ */
+void regulatory_hint_11d(struct wiphy *wiphy,
+			 u8 *country_ie,
+			 u8 country_ie_len);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit 371842448c05b42d11a4be1c8e4e81d62ecc7534
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Thu Jul 30 17:43:48 2009 -0700

    cfg80211: fix regression on beacon world roaming feature
    
    A regression was added through patch a4ed90d6:
    
    "cfg80211: respect API on orig_flags on channel for beacon hint"
    
    We did indeed respect _orig flags but the intention was not clearly
    stated in the commit log. This patch fixes firmware issues picked
    up by iwlwifi when we lift passive scan of beaconing restrictions
    on channels its EEPROM has been configured to always enable.
    
    By doing so though we also disallowed beacon hints on devices
    registering their wiphy with custom world regulatory domains
    enabled, this happens to be currently ath5k, ath9k and ar9170.
    The passive scan and beacon restrictions on those devices would
    never be lifted even if we did find a beacon and the hardware did
    support such enhancements when world roaming.
    
    Since Johannes indicates iwlwifi firmware cannot be changed to
    allow beacon hinting we set up a flag now to specifically allow
    drivers to disable beacon hints for devices which cannot use them.
    
    We enable the flag on iwlwifi to disable beacon hints and by default
    enable it for all other drivers. It should be noted beacon hints lift
    passive scan flags and beacon restrictions when we receive a beacon from
    an AP on any 5 GHz non-DFS channels, and channels 12-14 on the 2.4 GHz
    band. We don't bother with channels 1-11 as those channels are allowed
    world wide.
    
    This should fix world roaming for ath5k, ath9k and ar9170, thereby
    improving scan time when we receive the first beacon from any AP,
    and also enabling beaconing operation (AP/IBSS/Mesh) on cards which
    would otherwise not be allowed to do so. Drivers not using custom
    regulatory stuff (wiphy_apply_custom_regulatory()) were not affected
    by this as the orig_flags for the channels would have been cleared
    upon wiphy registration.
    
    I tested this with a world roaming ath5k card.
    
    Cc: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index e37829a49dc4..4e167a8e11be 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -30,7 +30,8 @@ int set_regdom(const struct ieee80211_regdomain *rd);
  * non-radar 5 GHz channels.
  *
  * Drivers do not need to call this, cfg80211 will do it for after a scan
- * on a newly found BSS.
+ * on a newly found BSS. If you cannot make use of this feature you can
+ * set the wiphy->disable_beacon_hints to true.
  */
 int regulatory_hint_found_beacon(struct wiphy *wiphy,
 					struct ieee80211_channel *beacon_chan,

commit d1c96a9a29a5f34fa50133889b6110dca6cc3d43
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:24:13 2009 -0500

    cfg80211: make __regulatory_hint() static
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 65bfd0558ce1..e37829a49dc4 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -15,29 +15,6 @@ void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
-/**
- * __regulatory_hint - hint to the wireless core a regulatory domain
- * @wiphy: if the hint comes from country information from an AP, this
- *	is required to be set to the wiphy that received the information
- * @alpha2: the ISO/IEC 3166 alpha2 being claimed the regulatory domain
- *	should be in.
- * @country_ie_checksum: checksum of processed country IE, set this to 0
- * 	if the hint did not come from a country IE
- * @country_ie_env: the environment the IE told us we are in, %ENVIRON_*
- *
- * The Wireless subsystem can use this function to hint to the wireless core
- * what it believes should be the current regulatory domain by giving it an
- * ISO/IEC 3166 alpha2 country code it knows its regulatory domain should be
- * in.
- *
- * Returns zero if all went fine, %-EALREADY if a regulatory domain had
- * already been set or other standard error codes.
- *
- */
-extern int __regulatory_hint(struct wiphy *wiphy, enum reg_set_by set_by,
-			     const char *alpha2, u32 country_ie_checksum,
-			     enum environment_cap country_ie_env);
-
 /**
  * regulatory_hint_found_beacon - hints a beacon was found on a channel
  * @wiphy: the wireless device where the beacon was found on

commit e38f8a7a8bebbab9d97f204e2cf05ef58b048a1d
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:20:39 2009 -0500

    cfg80211: Add AP beacon regulatory hints
    
    When devices are world roaming they cannot beacon or do active scan
    on 5 GHz or on channels 12, 13 and 14 on the 2 GHz band. Although
    we have a good regulatory API some cards may _always_ world roam, this
    is also true when a system does not have CRDA present. Devices doing world
    roaming can still passive scan, if they find a beacon from an AP on
    one of the world roaming frequencies we make the assumption we can do
    the same and we also remove the passive scan requirement.
    
    This adds support for providing beacon regulatory hints based on scans.
    This works for devices that do either hardware or software scanning.
    If a channel has not yet been marked as having had a beacon present
    on it we queue the beacon hint processing into the workqueue.
    
    All wireless devices will benefit from beacon regulatory hints from
    any wireless device on a system including new devices connected to
    the system at a later time.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 4730def5a69d..65bfd0558ce1 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -38,4 +38,25 @@ extern int __regulatory_hint(struct wiphy *wiphy, enum reg_set_by set_by,
 			     const char *alpha2, u32 country_ie_checksum,
 			     enum environment_cap country_ie_env);
 
+/**
+ * regulatory_hint_found_beacon - hints a beacon was found on a channel
+ * @wiphy: the wireless device where the beacon was found on
+ * @beacon_chan: the channel on which the beacon was found on
+ * @gfp: context flags
+ *
+ * This informs the wireless core that a beacon from an AP was found on
+ * the channel provided. This allows the wireless core to make educated
+ * guesses on regulatory to help with world roaming. This is only used for
+ * world roaming -- when we do not know our current location. This is
+ * only useful on channels 12, 13 and 14 on the 2 GHz band as channels
+ * 1-11 are already enabled by the world regulatory domain; and on
+ * non-radar 5 GHz channels.
+ *
+ * Drivers do not need to call this, cfg80211 will do it for after a scan
+ * on a newly found BSS.
+ */
+int regulatory_hint_found_beacon(struct wiphy *wiphy,
+					struct ieee80211_channel *beacon_chan,
+					gfp_t gfp);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit fe33eb390854886e1fd5d4835d833b80d145aafb
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:30 2009 -0500

    cfg80211: move all regulatory hints to workqueue
    
    All regulatory hints (core, driver, userspace and 11d) are now processed in
    a workqueue.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index fe8c83f34fb7..4730def5a69d 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -6,6 +6,8 @@ extern const struct ieee80211_regdomain *cfg80211_regdomain;
 bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
 
+int regulatory_hint_user(const char *alpha2);
+
 void reg_device_remove(struct wiphy *wiphy);
 
 int regulatory_init(void);

commit f130347c2dd8e7ce0757cd3cf80bedbc6ed63c4c
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Fri Jan 30 09:26:42 2009 -0800

    cfg80211: add get reg command
    
    This lets userspace request to get the currently set
    regulatory domain.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index eb1dd5bc9b27..fe8c83f34fb7 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -1,6 +1,8 @@
 #ifndef __NET_WIRELESS_REG_H
 #define __NET_WIRELESS_REG_H
 
+extern const struct ieee80211_regdomain *cfg80211_regdomain;
+
 bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
 

commit 716f9392e2b84cacc18cc11f7427cb98adeb1c3d
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Thu Jan 22 15:05:51 2009 -0800

    cfg80211: pass more detailed regulatory request information on reg_notifier()
    
    Drivers may need more information than just who set the last regulatory domain,
    as such lets just pass the last regulatory_request receipt. To do this we need
    to move out to headers struct regulatory_request, and enum environment_cap. While
    at it lets add documentation for enum environment_cap.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index a76ea3ff7cd6..eb1dd5bc9b27 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -11,13 +11,6 @@ void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
-enum environment_cap {
-	ENVIRON_ANY,
-	ENVIRON_INDOOR,
-	ENVIRON_OUTDOOR,
-};
-
-
 /**
  * __regulatory_hint - hint to the wireless core a regulatory domain
  * @wiphy: if the hint comes from country information from an AP, this

commit 3f2355cb9111ac04e7ae06a4d7044da2ae813863
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Wed Nov 12 14:22:02 2008 -0800

    cfg80211/mac80211: Add 802.11d support
    
    This adds country IE parsing to mac80211 and enables its usage
    within the new regulatory infrastructure in cfg80211. We parse
    the country IEs only on management beacons for the BSSID you are
    associated to and disregard the IEs when the country and environment
    (indoor, outdoor, any) matches the already processed country IE.
    
    To avoid following misinformed or outdated APs we build and use
    a regulatory domain out of the intersection between what the AP
    provides us on the country IE and what CRDA is aware is allowed
    on the same country.
    
    A secondary device is allowed to follow only the same country IE
    as it make no sense for two devices on a system to be in two
    different countries.
    
    In the case the AP is using country IEs for an incorrect country
    the user may help compliance further by setting the regulatory
    domain before or after the IE is parsed and in that case another
    intersection will be performed.
    
    CONFIG_WIRELESS_OLD_REGULATORY is supported but requires CRDA
    present.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index c9b6b6358bbe..a76ea3ff7cd6 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -4,28 +4,41 @@
 bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
 
+void reg_device_remove(struct wiphy *wiphy);
+
 int regulatory_init(void);
 void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
+enum environment_cap {
+	ENVIRON_ANY,
+	ENVIRON_INDOOR,
+	ENVIRON_OUTDOOR,
+};
+
+
 /**
  * __regulatory_hint - hint to the wireless core a regulatory domain
  * @wiphy: if the hint comes from country information from an AP, this
  *	is required to be set to the wiphy that received the information
  * @alpha2: the ISO/IEC 3166 alpha2 being claimed the regulatory domain
  *	should be in.
+ * @country_ie_checksum: checksum of processed country IE, set this to 0
+ * 	if the hint did not come from a country IE
+ * @country_ie_env: the environment the IE told us we are in, %ENVIRON_*
  *
  * The Wireless subsystem can use this function to hint to the wireless core
- * what it believes should be the current regulatory domain by
- * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
- * domain should be in.
+ * what it believes should be the current regulatory domain by giving it an
+ * ISO/IEC 3166 alpha2 country code it knows its regulatory domain should be
+ * in.
  *
  * Returns zero if all went fine, %-EALREADY if a regulatory domain had
  * already been set or other standard error codes.
  *
  */
 extern int __regulatory_hint(struct wiphy *wiphy, enum reg_set_by set_by,
-			     const char *alpha2);
+			     const char *alpha2, u32 country_ie_checksum,
+			     enum environment_cap country_ie_env);
 
 #endif  /* __NET_WIRELESS_REG_H */

commit be3d48106c1e5d075784e5e67928a6b5ffc0f3b6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Oct 24 20:32:21 2008 +0200

    wireless: remove struct regdom hinting
    
    The code needs to be split out and cleaned up, so as a
    first step remove the capability, to add it back in a
    subsequent patch as a separate function. Also remove the
    publically facing return value of the function and the
    wiphy argument. A number of internal functions go from
    being generic helpers to just being used for alpha2
    setting.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index 0c1572b92fef..c9b6b6358bbe 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -11,30 +11,21 @@ int set_regdom(const struct ieee80211_regdomain *rd);
 
 /**
  * __regulatory_hint - hint to the wireless core a regulatory domain
- * @wiphy: if a driver is providing the hint this is the driver's very
- * 	own &struct wiphy
+ * @wiphy: if the hint comes from country information from an AP, this
+ *	is required to be set to the wiphy that received the information
  * @alpha2: the ISO/IEC 3166 alpha2 being claimed the regulatory domain
- * 	should be in. If @rd is set this should be NULL
- * @rd: a complete regulatory domain, if passed the caller need not worry
- * 	about freeing it
+ *	should be in.
  *
  * The Wireless subsystem can use this function to hint to the wireless core
  * what it believes should be the current regulatory domain by
  * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
- * domain should be in or by providing a completely build regulatory domain.
+ * domain should be in.
  *
- * Returns -EALREADY if *a regulatory domain* has already been set. Note that
- * this could be by another driver. It is safe for drivers to continue if
- * -EALREADY is returned, if drivers are not capable of world roaming they
- * should not register more channels than they support. Right now we only
- * support listening to the first driver hint. If the driver is capable
- * of world roaming but wants to respect its own EEPROM mappings for
- * specific regulatory domains it should register the @reg_notifier callback
- * on the &struct wiphy. Returns 0 if the hint went through fine or through an
- * intersection operation. Otherwise a standard error code is returned.
+ * Returns zero if all went fine, %-EALREADY if a regulatory domain had
+ * already been set or other standard error codes.
  *
  */
 extern int __regulatory_hint(struct wiphy *wiphy, enum reg_set_by set_by,
-		const char *alpha2, struct ieee80211_regdomain *rd);
+			     const char *alpha2);
 
 #endif  /* __NET_WIRELESS_REG_H */

commit f3b407fba52e1b86ca286ee7c218a4fb00bd29e0
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 21 09:57:41 2008 +0200

    wireless: remove cfg80211_reg_mutex
    
    This mutex is wrong, we use cfg80211_drv_mutex (which should
    possibly be renamed to just cfg80211_mutex) everywhere except
    in one place, fix that and get rid of the extra mutex.
    
    Also get rid of a spurious regulatory_requests list definition.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index a4845b140a84..0c1572b92fef 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -1,7 +1,6 @@
 #ifndef __NET_WIRELESS_REG_H
 #define __NET_WIRELESS_REG_H
 
-extern struct mutex cfg80211_reg_mutex;
 bool is_world_regdom(const char *alpha2);
 bool reg_is_valid_request(const char *alpha2);
 

commit cf03268e6ed6cfacaa5e32db41ea832c4d10438b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 21 09:42:38 2008 +0200

    wireless: don't publish __regulatory_hint
    
    This function requires an internal lock to be held, so it cannot
    be published to other modules in the kernel.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index a33362872f3c..a4845b140a84 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -10,4 +10,32 @@ void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
 
+/**
+ * __regulatory_hint - hint to the wireless core a regulatory domain
+ * @wiphy: if a driver is providing the hint this is the driver's very
+ * 	own &struct wiphy
+ * @alpha2: the ISO/IEC 3166 alpha2 being claimed the regulatory domain
+ * 	should be in. If @rd is set this should be NULL
+ * @rd: a complete regulatory domain, if passed the caller need not worry
+ * 	about freeing it
+ *
+ * The Wireless subsystem can use this function to hint to the wireless core
+ * what it believes should be the current regulatory domain by
+ * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
+ * domain should be in or by providing a completely build regulatory domain.
+ *
+ * Returns -EALREADY if *a regulatory domain* has already been set. Note that
+ * this could be by another driver. It is safe for drivers to continue if
+ * -EALREADY is returned, if drivers are not capable of world roaming they
+ * should not register more channels than they support. Right now we only
+ * support listening to the first driver hint. If the driver is capable
+ * of world roaming but wants to respect its own EEPROM mappings for
+ * specific regulatory domains it should register the @reg_notifier callback
+ * on the &struct wiphy. Returns 0 if the hint went through fine or through an
+ * intersection operation. Otherwise a standard error code is returned.
+ *
+ */
+extern int __regulatory_hint(struct wiphy *wiphy, enum reg_set_by set_by,
+		const char *alpha2, struct ieee80211_regdomain *rd);
+
 #endif  /* __NET_WIRELESS_REG_H */

commit a3d2eaf0dcad6dfdf44f3093aef688dfca714b6c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Sep 15 11:10:52 2008 +0200

    cfg80211: fix regulatory code const
    
    A few pointers and structures in the regulatory code are const,
    but because it wasn't done properly a whole bunch of bogus
    casts were needed to compile without warning. Mark everything
    const properly to avoid that kind of junk code.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index b169815987f4..a33362872f3c 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -2,12 +2,12 @@
 #define __NET_WIRELESS_REG_H
 
 extern struct mutex cfg80211_reg_mutex;
-bool is_world_regdom(char *alpha2);
-bool reg_is_valid_request(char *alpha2);
+bool is_world_regdom(const char *alpha2);
+bool reg_is_valid_request(const char *alpha2);
 
 int regulatory_init(void);
 void regulatory_exit(void);
 
-int set_regdom(struct ieee80211_regdomain *rd);
+int set_regdom(const struct ieee80211_regdomain *rd);
 
 #endif  /* __NET_WIRELESS_REG_H */

commit 734366deaee05b1a5842d977960b4cc574d7551d
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Sep 15 10:56:48 2008 +0200

    cfg80211: clean up regulatory mess
    
    The recent code from Luis is an #ifdef hell and contains lots of
    code that's stuffed into the wrong file making a whole bunch of
    things needlessly non-static, and besides, what is it doing in
    core.c??
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index d75fd0232972..b169815987f4 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -1,44 +1,13 @@
 #ifndef __NET_WIRELESS_REG_H
 #define __NET_WIRELESS_REG_H
 
-extern const struct ieee80211_regdomain world_regdom;
-#ifdef CONFIG_WIRELESS_OLD_REGULATORY
-extern const struct ieee80211_regdomain us_regdom;
-extern const struct ieee80211_regdomain jp_regdom;
-extern const struct ieee80211_regdomain eu_regdom;
-#endif
-
-extern struct ieee80211_regdomain *cfg80211_regdomain;
-extern struct ieee80211_regdomain *cfg80211_world_regdom;
-extern struct list_head regulatory_requests;
-
-struct regdom_last_setby {
-	struct wiphy *wiphy;
-	u8 initiator;
-};
-
-/* wiphy is set if this request's initiator is REGDOM_SET_BY_DRIVER */
-struct regulatory_request {
-	struct list_head list;
-	struct wiphy *wiphy;
-	int granted;
-	enum reg_set_by initiator;
-	char alpha2[2];
-};
-
+extern struct mutex cfg80211_reg_mutex;
 bool is_world_regdom(char *alpha2);
 bool reg_is_valid_request(char *alpha2);
 
-int set_regdom(struct ieee80211_regdomain *rd);
-int __regulatory_hint_alpha2(struct wiphy *wiphy, enum reg_set_by set_by,
-		      const char *alpha2);
-
 int regulatory_init(void);
 void regulatory_exit(void);
 
-void print_regdomain_info(struct ieee80211_regdomain *);
-
-/* If a char is A-Z */
-#define IS_ALPHA(letter) (letter >= 65 && letter <= 90)
+int set_regdom(struct ieee80211_regdomain *rd);
 
 #endif  /* __NET_WIRELESS_REG_H */

commit b2e1b30290539b344cbaff0d9da38012e03aa347
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Tue Sep 9 23:19:48 2008 -0700

    cfg80211: Add new wireless regulatory infrastructure
    
    This adds the new wireless regulatory infrastructure. The
    main motiviation behind this was to centralize regulatory
    code as each driver was implementing their own regulatory solution,
    and to replace the initial centralized code we have where:
    
    * only 3 regulatory domains are supported: US, JP and EU
    * regulatory domains can only be changed through module parameter
    * all rules were built statically in the kernel
    
    We now have support for regulatory domains for many countries
    and regulatory domains are now queried through a userspace agent
    through udev allowing distributions to update regulatory rules
    without updating the kernel.
    
    Each driver can regulatory_hint() a regulatory domain
    based on either their EEPROM mapped regulatory domain value to a
    respective ISO/IEC 3166-1 country code or pass an internally built
    regulatory domain. We also add support to let the user set the
    regulatory domain through userspace in case of faulty EEPROMs to
    further help compliance.
    
    Support for world roaming will be added soon for cards capable of
    this.
    
    For more information see:
    
    http://wireless.kernel.org/en/developers/Regulatory/CRDA
    
    For now we leave an option to enable the old module parameter,
    ieee80211_regdom, and to build the 3 old regdomains statically
    (US, JP and EU). This option is CONFIG_WIRELESS_OLD_REGULATORY.
    These old static definitions and the module parameter is being
    scheduled for removal for 2.6.29. Note that if you use this
    you won't make use of a world regulatory domain as its pointless.
    If you leave this option enabled and if CRDA is present and you
    use US or JP we will try to ask CRDA to update us a regulatory
    domain for us.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/reg.h b/net/wireless/reg.h
new file mode 100644
index 000000000000..d75fd0232972
--- /dev/null
+++ b/net/wireless/reg.h
@@ -0,0 +1,44 @@
+#ifndef __NET_WIRELESS_REG_H
+#define __NET_WIRELESS_REG_H
+
+extern const struct ieee80211_regdomain world_regdom;
+#ifdef CONFIG_WIRELESS_OLD_REGULATORY
+extern const struct ieee80211_regdomain us_regdom;
+extern const struct ieee80211_regdomain jp_regdom;
+extern const struct ieee80211_regdomain eu_regdom;
+#endif
+
+extern struct ieee80211_regdomain *cfg80211_regdomain;
+extern struct ieee80211_regdomain *cfg80211_world_regdom;
+extern struct list_head regulatory_requests;
+
+struct regdom_last_setby {
+	struct wiphy *wiphy;
+	u8 initiator;
+};
+
+/* wiphy is set if this request's initiator is REGDOM_SET_BY_DRIVER */
+struct regulatory_request {
+	struct list_head list;
+	struct wiphy *wiphy;
+	int granted;
+	enum reg_set_by initiator;
+	char alpha2[2];
+};
+
+bool is_world_regdom(char *alpha2);
+bool reg_is_valid_request(char *alpha2);
+
+int set_regdom(struct ieee80211_regdomain *rd);
+int __regulatory_hint_alpha2(struct wiphy *wiphy, enum reg_set_by set_by,
+		      const char *alpha2);
+
+int regulatory_init(void);
+void regulatory_exit(void);
+
+void print_regdomain_info(struct ieee80211_regdomain *);
+
+/* If a char is A-Z */
+#define IS_ALPHA(letter) (letter >= 65 && letter <= 90)
+
+#endif  /* __NET_WIRELESS_REG_H */
