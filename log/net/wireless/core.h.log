commit 79ea1e12c0b8540100e89b32afb9f0e6503fad35
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jun 4 12:04:20 2020 +0200

    cfg80211: fix management registrations deadlock
    
    Lockdep reports that we may deadlock because we take the RTNL on
    the work struct, but flush it under RTNL. Clearly, it's correct.
    In practice, this can happen when doing rfkill on an active device.
    
    Fix this by moving the work struct to the wiphy (registered dev)
    layer, and iterate over all the wdevs inside there. This then
    means we need to track which one of them has work to do, so we
    don't update to the driver for all wdevs all the time.
    
    Also fix a locking bug I noticed while working on this - the
    registrations list is iterated as if it was an RCU list, but it
    isn't handle that way - and we need to lock now for the update
    flag anyway, so remove the RCU.
    
    Fixes: 6cd536fe62ef ("cfg80211: change internal management frame registration API")
    Reported-by: Markus Theil <markus.theil@tu-ilmenau.de>
    Reported-and-tested-by: Kenneth R. Crudup <kenny@panix.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Link: https://lore.kernel.org/r/20200604120420.b1dc540a7e26.I55dcca56bb5bdc5d7ad66a36a0b42afd7034d8be@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e0e5b3ee9699..67b0389fca4d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -99,6 +99,8 @@ struct cfg80211_registered_device {
 	struct cfg80211_chan_def cac_done_chandef;
 	struct work_struct propagate_cac_done_wk;
 
+	struct work_struct mgmt_registrations_update_wk;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);

commit 396fba0a59f3c94d6fd6443fbeabd8bd9e3956eb
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:39:09 2020 -0500

    cfg80211: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Link: https://lore.kernel.org/r/20200507183909.GA12993@embeddedor
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 639d41896573..e0e5b3ee9699 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -286,7 +286,7 @@ struct cfg80211_cqm_config {
 	u32 rssi_hyst;
 	s32 last_rssi_event_value;
 	int n_rssi_thresholds;
-	s32 rssi_thresholds[0];
+	s32 rssi_thresholds[];
 };
 
 void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev);

commit 9dba48a6ece79da064655736dc7347a5fcadedef
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Apr 17 12:40:15 2020 +0200

    cfg80211: support multicast RX registration
    
    For DPP, there's a need to receive multicast action frames,
    but many drivers need a special filter configuration for this.
    
    Support announcing from userspace in the management registration
    that multicast RX is required, with an extended feature flag if
    the driver handles this.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Reviewed-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Link: https://lore.kernel.org/r/20200417124013.c46238801048.Ib041d437ce0bff28a0c6d5dc915f68f1d8591002@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 30fb2c35ae43..639d41896573 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -381,7 +381,8 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 				u16 frame_type, const u8 *match_data,
-				int match_len, struct netlink_ext_ack *extack);
+				int match_len, bool multicast_rx,
+				struct netlink_ext_ack *extack);
 void cfg80211_mgmt_registrations_update_wk(struct work_struct *wk);
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);

commit 6cd536fe62ef58d7c4eac2da07ab0ed7fd19010d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Apr 17 12:43:01 2020 +0200

    cfg80211: change internal management frame registration API
    
    Almost all drivers below cfg80211 get the API wrong (except for
    cfg80211) and are unable to cope with multiple registrations for
    the same frame type, which is valid due to the match filter.
    This seems to indicate the API is wrong, and we should maintain
    the full information in cfg80211 instead of the drivers.
    
    Change the API to no longer inform the driver about individual
    registrations and unregistrations, but rather every time about
    the entire state of the entire wiphy and single wdev, whenever
    it may have changed. This also simplifies the code in cfg80211
    as it no longer has to track exactly what was unregistered and
    can free things immediately.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Reviewed-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Link: https://lore.kernel.org/r/20200417124300.f47f3828afc8.I7f81ef59c2c5a340d7075fb3c6d0e08e8aeffe07@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bb897a803ffe..30fb2c35ae43 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -60,10 +60,6 @@ struct cfg80211_registered_device {
 	struct list_head beacon_registrations;
 	spinlock_t beacon_registrations_lock;
 
-	struct list_head mlme_unreg;
-	spinlock_t mlme_unreg_lock;
-	struct work_struct mlme_unreg_wk;
-
 	/* protected by RTNL only */
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
@@ -386,7 +382,7 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 				u16 frame_type, const u8 *match_data,
 				int match_len, struct netlink_ext_ack *extack);
-void cfg80211_mlme_unreg_wk(struct work_struct *wk);
+void cfg80211_mgmt_registrations_update_wk(struct work_struct *wk);
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,

commit ff74c51e8f4c543ed2bd3bf1c2f3287b098660df
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Fri Jan 31 13:45:29 2020 +0200

    cfg80211/mac80211: Allow user space to register for station Rx authentication
    
    To support Pre Association Security Negotiation (PASN) while already
    associated to one AP, allow user space to register to Rx
    authentication frames, so that the user space logic would be able to
    receive/handle authentication frames from a different AP as part of
    PASN.
    
    Note that it is expected that user space would intelligently register
    for Rx authentication frames, i.e., only when PASN is used and
    configure a match filter only for PASN authentication algorithm, as
    otherwise the MLME functionality of mac80211 would be broken.
    
    Additionally, since some versions of the user space daemons wrongly
    register to all types of authentication frames (which might result in
    unexpected behavior) allow such registration if the request is for a
    specific authentication algorithm number.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Link: https://lore.kernel.org/r/20200131114529.894206-1-luca@coelho.fi
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ed487e324571..bb897a803ffe 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -385,7 +385,7 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 				u16 frame_type, const u8 *match_data,
-				int match_len);
+				int match_len, struct netlink_ext_ack *extack);
 void cfg80211_mlme_unreg_wk(struct work_struct *wk);
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);

commit 3cfe91c4c3c080c6af95611a87f8cf32d1913896
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Aug 30 14:24:44 2019 +0300

    cfg80211: always shut down on HW rfkill
    
    When the RFKILL subsystem isn't available, then rfkill_blocked()
    always returns false. In the case of hardware rfkill this will
    be wrong though, as if the hardware reported being killed then
    it cannot operate any longer.
    
    Since we only ever call the rfkill_sync work in this case, just
    rename it to rfkill_block and always pass "true" for the blocked
    parameter, rather than passing rfkill_blocked().
    
    We rely on the underlying driver to still reject any new attempt
    to bring up the device by itself.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Link: https://lore.kernel.org/r/20190830112451.21655-2-luca@coelho.fi
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 77556c58d9ac..ed487e324571 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -28,7 +28,7 @@ struct cfg80211_registered_device {
 	/* rfkill support */
 	struct rfkill_ops rfkill_ops;
 	struct rfkill *rfkill;
-	struct work_struct rfkill_sync;
+	struct work_struct rfkill_block;
 
 	/* ISO / IEC 3166 alpha2 for which this device is receiving
 	 * country IEs on, this can help disregard country IEs from APs

commit 0afd425b1b64251f19b5d8d8b49bf56fefbc643f
Author: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
Date:   Fri Jul 26 16:39:34 2019 +0000

    cfg80211: fix duplicated scan entries after channel switch
    
    When associated BSS completes channel switch procedure, its channel
    record needs to be updated. The existing mac80211 solution was
    extended to cfg80211 in commit 5dc8cdce1d72 ("mac80211/cfg80211:
    update bss channel on channel switch").
    
    However that solution still appears to be incomplete as it may lead
    to duplicated scan entries for associated BSS after channel switch.
    The root cause of the problem is as follows. Each BSS entry is
    included into the following data structures:
    - bss list rdev->bss_list
    - bss search tree rdev->bss_tree
    Updating BSS channel record without rebuilding bss_tree may break
    tree search since cmp_bss considers all of the following: channel,
    bssid, ssid. When BSS channel is updated, but its location in bss_tree
    is not updated, then subsequent search operations may fail to locate
    this BSS since they will be traversing bss_tree in wrong direction.
    As a result, for scan performed after associated BSS channel switch,
    cfg80211_bss_update may add the second entry for the same BSS to both
    bss_list and bss_tree, rather then update the existing one.
    
    To summarize, if BSS channel needs to be updated, then bss_tree should
    be rebuilt in order to put updated BSS entry into a proper location.
    
    This commit suggests the following straightforward solution:
    - if new entry has been already created for BSS after channel switch,
      then use its IEs to update known BSS entry and then remove new
      entry completely
    - use rb_erase/rb_insert_bss reinstall updated BSS in bss_tree
    - for nontransmit BSS entry, the whole transmit BSS hierarchy
      is updated
    
    Signed-off-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Link: https://lore.kernel.org/r/20190726163922.27509-3-sergey.matyukevich.os@quantenna.com
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ee8388fe4a92..77556c58d9ac 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -306,6 +306,8 @@ void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 void cfg80211_bss_expire(struct cfg80211_registered_device *rdev);
 void cfg80211_bss_age(struct cfg80211_registered_device *rdev,
                       unsigned long age_secs);
+void cfg80211_update_assoc_bss_entry(struct wireless_dev *wdev,
+				     struct ieee80211_channel *channel);
 
 /* IBSS */
 int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,

commit a3ce17d1495b65d62fceb2c7a704bb97133c5de9
Author: Chaitanya Tata <chaitanya.tata@bluwireless.co.uk>
Date:   Wed May 1 18:25:24 2019 +0530

    cfg80211: Handle bss expiry during connection
    
    If the BSS is expired during connection, the connect result will
    trigger a kernel warning. Ideally cfg80211 should hold the BSS
    before the connection is attempted, but as the BSSID is not known
    in case of auth/assoc MLME offload (connect op) it doesn't.
    
    For those drivers without the connect op cfg80211 holds down the
    reference so it wil not be removed from list.
    
    Fix this by removing the warning and silently adding the BSS back to
    the bss list which is return by the driver (with proper BSSID set) or
    in case the BSS is already added use that.
    
    The requirements for drivers are documented in the API's.
    
    Signed-off-by: Chaitanya Tata <chaitanya.tata@bluwireless.co.uk>
    [formatting fixes, keep old timestamp]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 84d36ca7a7ab..ee8388fe4a92 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -531,6 +531,10 @@ void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
 void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
 		       struct wireless_dev *wdev);
 
+struct cfg80211_internal_bss *
+cfg80211_bss_update(struct cfg80211_registered_device *rdev,
+		    struct cfg80211_internal_bss *tmp,
+		    bool signal_valid, unsigned long ts);
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit b7b14ec1ebef35d22f3f4087816468f22c987f75
Merge: 77ff2c6b4984 7a25c6c0aac8
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 22 13:48:13 2019 +0100

    Merge remote-tracking branch 'net-next/master' into mac80211-next
    
    Merge net-next to resolve a conflict and to get the mac80211
    rhashtable fixes so further patches can be applied on top.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit 7011ba583f425780ab1ee52f41161a0171197365
Author: Sara Sharon <sara.sharon@intel.com>
Date:   Mon Jan 21 12:25:59 2019 +0200

    cfg80211: Move Multiple BSS info to struct cfg80211_bss to be visible
    
    Previously the transmitted BSS and the non-trasmitted BSS list were
    defined in struct cfg80211_internal_bss. Move them to struct cfg80211_bss
    since mac80211 needs this info.
    
    Signed-off-by: Sara Sharon <sara.sharon@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c20c75df60f5..f257a2b32ba4 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -152,8 +152,6 @@ extern int cfg80211_rdev_list_generation;
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct list_head hidden_list;
-	struct list_head nontrans_list;
-	struct cfg80211_bss *transmitted_bss;
 	struct rb_node rbn;
 	u64 ts_boottime;
 	unsigned long ts;
@@ -184,8 +182,8 @@ static inline struct cfg80211_internal_bss *bss_from_pub(struct cfg80211_bss *pu
 static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 {
 	atomic_inc(&bss->hold);
-	if (bss->transmitted_bss) {
-		bss = container_of(bss->transmitted_bss,
+	if (bss->pub.transmitted_bss) {
+		bss = container_of(bss->pub.transmitted_bss,
 				   struct cfg80211_internal_bss, pub);
 		atomic_inc(&bss->hold);
 	}
@@ -195,8 +193,8 @@ static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 {
 	int r = atomic_dec_return(&bss->hold);
 	WARN_ON(r < 0);
-	if (bss->transmitted_bss) {
-		bss = container_of(bss->transmitted_bss,
+	if (bss->pub.transmitted_bss) {
+		bss = container_of(bss->pub.transmitted_bss,
 				   struct cfg80211_internal_bss, pub);
 		r = atomic_dec_return(&bss->hold);
 		WARN_ON(r < 0);

commit a3584f56de1c808d4383a275b4a74467b19e5645
Author: Sara Sharon <sara.sharon@intel.com>
Date:   Mon Jan 21 12:22:21 2019 +0200

    cfg80211: Properly track transmitting and non-transmitting BSS
    
    When holding data of the non-transmitting BSS, we need to keep the
    transmitting BSS data on. Otherwise it will be released, and release
    the non-transmitting BSS with it.
    
    Signed-off-by: Sara Sharon <sara.sharon@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a50b92ac77a1..c20c75df60f5 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -153,6 +153,7 @@ struct cfg80211_internal_bss {
 	struct list_head list;
 	struct list_head hidden_list;
 	struct list_head nontrans_list;
+	struct cfg80211_bss *transmitted_bss;
 	struct rb_node rbn;
 	u64 ts_boottime;
 	unsigned long ts;
@@ -183,12 +184,23 @@ static inline struct cfg80211_internal_bss *bss_from_pub(struct cfg80211_bss *pu
 static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 {
 	atomic_inc(&bss->hold);
+	if (bss->transmitted_bss) {
+		bss = container_of(bss->transmitted_bss,
+				   struct cfg80211_internal_bss, pub);
+		atomic_inc(&bss->hold);
+	}
 }
 
 static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 {
 	int r = atomic_dec_return(&bss->hold);
 	WARN_ON(r < 0);
+	if (bss->transmitted_bss) {
+		bss = container_of(bss->transmitted_bss,
+				   struct cfg80211_internal_bss, pub);
+		r = atomic_dec_return(&bss->hold);
+		WARN_ON(r < 0);
+	}
 }
 
 

commit 0b8fb8235be8be99a197e8d948fc0a2df8dc261a
Author: Peng Xu <pxu@codeaurora.org>
Date:   Mon Jan 21 12:14:57 2019 +0200

    cfg80211: Parsing of Multiple BSSID information in scanning
    
    This extends cfg80211 BSS table processing to be able to parse Multiple
    BSSID element from Beacon and Probe Response frames and to update the
    BSS profiles in internal database for non-transmitted BSSs.
    
    Signed-off-by: Peng Xu <pxu@codeaurora.org>
    Signed-off-by: Sara Sharon <sara.sharon@intel.com>
    Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c5d6f3418601..a50b92ac77a1 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -3,7 +3,7 @@
  * Wireless configuration interface internals.
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
- * Copyright (C) 2018 Intel Corporation
+ * Copyright (C) 2018-2019 Intel Corporation
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
@@ -152,6 +152,7 @@ extern int cfg80211_rdev_list_generation;
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct list_head hidden_list;
+	struct list_head nontrans_list;
 	struct rb_node rbn;
 	u64 ts_boottime;
 	unsigned long ts;

commit e005bd7ddea06784c1eb91ac5bb6b171a94f3b05
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 1 11:09:54 2019 +0100

    cfg80211: call disconnect_wk when AP stops
    
    Since we now prevent regulatory restore during STA disconnect
    if concurrent AP interfaces are active, we need to reschedule
    this check when the AP state changes. This fixes never doing
    a restore when an AP is the last interface to stop. Or to put
    it another way: we need to re-check after anything we check
    here changes.
    
    Cc: stable@vger.kernel.org
    Fixes: 113f3aaa81bd ("cfg80211: Prevent regulatory restore during STA disconnect in concurrent interfaces")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c5d6f3418601..f6b40563dc63 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -445,6 +445,8 @@ void cfg80211_process_wdev_events(struct wireless_dev *wdev);
 bool cfg80211_does_bw_fit_range(const struct ieee80211_freq_range *freq_range,
 				u32 center_freq_khz, u32 bw_khz);
 
+extern struct work_struct cfg80211_disconnect_work;
+
 /**
  * cfg80211_chandef_dfs_usable - checks if chandef is DFS usable
  * @wiphy: the wiphy to validate against

commit 9bb7e0f24e7e7d00daa1219b14539e2e602649b2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Sep 10 13:29:12 2018 +0200

    cfg80211: add peer measurement with FTM initiator API
    
    Add a new "peer measurement" API, that can be used to measure
    certain things related to a peer. Right now, only implement
    FTM (flight time measurement) over it, but the idea is that
    it'll be extensible to also support measuring the necessary
    things to calculate e.g. angle-of-arrival for WiGig.
    
    The API is structured to have a generic list of peers and
    channels to measure with/on, and then for each of those a
    set of measurements (again, only FTM right now) to perform.
    
    Results are sent to the requesting socket, including a final
    complete message.
    
    Closing the controlling netlink socket will abort a running
    measurement.
    
    v3:
     - add a bit to report "final" for partial results
     - remove list keeping etc. and just unicast out the results
       to the requester (big code reduction ...)
     - also send complete message unicast, and as a result
       remove the multicast group
     - separate out struct cfg80211_pmsr_ftm_request_peer
       from struct cfg80211_pmsr_request_peer
     - document timeout == 0 if no timeout
     - disallow setting timeout nl80211 attribute to 0,
       must not include attribute for no timeout
     - make MAC address randomization optional
     - change num bursts exponent default to 0 (1 burst, rather
       rather than the old default of 15==don't care)
    
    v4:
     - clarify NL80211_ATTR_TIMEOUT documentation
    
    v5:
     - remove unnecessary nl80211 multicast/family changes
     - remove partial results bit/flag, final is sufficient
     - add max_bursts_exponent, max_ftms_per_burst to capability
     - rename "frames per burst" -> "FTMs per burst"
    
    v6:
     - rename cfg80211_pmsr_free_wdev() to cfg80211_pmsr_wdev_down()
       and call it in leave, so the device can't go down with any
       pending measurements
    
    v7:
     - wording fixes (Lior)
     - fix ftm.max_bursts_exponent to allow having the limit of 0 (Lior)
    
    v8:
     - copyright statements
     - minor coding style fixes
     - fix error path leak
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c61dbba8bf47..c5d6f3418601 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -3,6 +3,7 @@
  * Wireless configuration interface internals.
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ * Copyright (C) 2018 Intel Corporation
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
@@ -530,4 +531,8 @@ void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
 
 void cfg80211_cqm_config_free(struct wireless_dev *wdev);
 
+void cfg80211_release_pmsr(struct wireless_dev *wdev, u32 portid);
+void cfg80211_pmsr_wdev_down(struct wireless_dev *wdev);
+void cfg80211_pmsr_free_wk(struct work_struct *work);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit b60ad3485106b5845113e7a2745abb7e64b15d6d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Oct 1 11:52:07 2018 +0200

    cfg80211: move cookie_counter out of wiphy
    
    There's no reason for drivers to be able to access the
    cfg80211 internal cookie counter; move it out of the
    wiphy into the rdev structure.
    
    While at it, also make it never assign 0 as a cookie
    (we consider that invalid in some places), and warn if
    we manage to do that for some reason (wrapping is not
    likely to happen with a u64.)
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 45fd4e21dbda..c61dbba8bf47 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -66,6 +66,7 @@ struct cfg80211_registered_device {
 	/* protected by RTNL only */
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
+	u64 cookie_counter;
 
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
@@ -133,6 +134,16 @@ cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 #endif
 }
 
+static inline u64 cfg80211_assign_cookie(struct cfg80211_registered_device *rdev)
+{
+	u64 r = ++rdev->cookie_counter;
+
+	if (WARN_ON(r == 0))
+		r = ++rdev->cookie_counter;
+
+	return r;
+}
+
 extern struct workqueue_struct *cfg80211_wq;
 extern struct list_head cfg80211_rdev_list;
 extern int cfg80211_rdev_list_generation;

commit e4d4216e91ea31049ba0cde0799ece244410a9f7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Sep 13 14:12:03 2018 +0200

    cfg80211: combine duplicate wdev init code
    
    There's a bit of duplicated code to initialize a wdev, pull it out
    into a separate function to call from both places.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 7f52ef569320..45fd4e21dbda 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -187,6 +187,9 @@ struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 			  struct net *net);
 
+void cfg80211_init_wdev(struct cfg80211_registered_device *rdev,
+			struct wireless_dev *wdev);
+
 static inline void wdev_lock(struct wireless_dev *wdev)
 	__acquires(wdev)
 {

commit fe0984d38938249f3f11fc558a8845fc6f8a0105
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 17:11:14 2018 +0200

    cfg80211: track time using boottime
    
    The cfg80211 layer uses get_seconds() to read the current time
    in its supend handling. This function is deprecated because of the 32-bit
    time_t overflow, and it can cause unexpected behavior when the time
    changes due to settimeofday() calls or leap second updates.
    
    In many cases, we want to use monotonic time instead, however cfg80211
    explicitly tracks the time spent in suspend, so this changes the
    driver over to use ktime_get_boottime_seconds(), which is slightly
    slower, but not used in a fastpath here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 63eb1b5fdd04..7f52ef569320 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -76,7 +76,7 @@ struct cfg80211_registered_device {
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
 	struct list_head sched_scan_req_list;
-	unsigned long suspend_at;
+	time64_t suspend_at;
 	struct work_struct scan_done_wk;
 
 	struct genl_info *cur_cmd_info;

commit 188c1b3c04d69e842122daf201f07a34fcfad039
Author: Denis Kenzior <denkenz@gmail.com>
Date:   Mon Mar 26 12:52:46 2018 -0500

    nl80211: Add SOCKET_OWNER support to JOIN_MESH
    
    Signed-off-by: Denis Kenzior <denkenz@gmail.com>
    [johannes: fix race with wdev lock/unlock by just acquiring once]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b5cf3ea8d4df..63eb1b5fdd04 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -303,10 +303,6 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
 			 struct mesh_setup *setup,
 			 const struct mesh_config *conf);
-int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
-		       struct net_device *dev,
-		       struct mesh_setup *setup,
-		       const struct mesh_config *conf);
 int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,

commit f8d16d3edb4dbae080df04318423c360de3c594d
Author: Denis Kenzior <denkenz@gmail.com>
Date:   Mon Mar 26 12:52:45 2018 -0500

    nl80211: Add SOCKET_OWNER support to JOIN_IBSS
    
    Signed-off-by: Denis Kenzior <denkenz@gmail.com>
    [johannes: fix race with wdev lock/unlock by just acquiring once]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index eaff636169c2..b5cf3ea8d4df 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -282,10 +282,10 @@ void cfg80211_bss_age(struct cfg80211_registered_device *rdev,
                       unsigned long age_secs);
 
 /* IBSS */
-int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
-		       struct net_device *dev,
-		       struct cfg80211_ibss_params *params,
-		       struct cfg80211_cached_keys *connkeys);
+int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 struct cfg80211_ibss_params *params,
+			 struct cfg80211_cached_keys *connkeys);
 void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, bool nowext);

commit 51a1aaa631c90223888d8beac4d649dc11d2ca55
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jan 15 09:32:36 2018 +0100

    mac80211_hwsim: validate number of different channels
    
    When creating a new radio on the fly, hwsim allows this
    to be done with an arbitrary number of channels, but
    cfg80211 only supports a limited number of simultaneous
    channels, leading to a warning.
    
    Fix this by validating the number - this requires moving
    the define for the maximum out to a visible header file.
    
    Reported-by: syzbot+8dd9051ff19940290931@syzkaller.appspotmail.com
    Fixes: b59ec8dd4394 ("mac80211_hwsim: fix number of channels in interface combinations")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d2f7e8b8a097..eaff636169c2 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -507,8 +507,6 @@ void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
 void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
 		       struct wireless_dev *wdev);
 
-#define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
-
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit 2a171788ba7bb61995e98e8163204fc7880f63b2
Merge: bf5345882bd1 d4c2e9fca5b7
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 4 09:26:51 2017 +0900

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Files removed in 'net-next' had their license header updated
    in 'net'.  We take the remove from 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6e809325af3b..705835047f98 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Wireless configuration interface internals.
  *

commit 503c1fb98ba3859c13863957c7c65c92371a9e50
Author: Avraham Stern <avraham.stern@intel.com>
Date:   Fri Sep 29 14:21:49 2017 +0200

    cfg80211/nl80211: add a port authorized event
    
    Add an event that indicates that a connection is authorized
    (i.e. the 4 way handshake was performed by the driver). This event
    should be sent by the driver after sending a connect/roamed event.
    
    This is useful for networks that require 802.1X authentication.
    In cases that the driver supports 4 way handshake offload, but the
    802.1X authentication is managed by user space, the driver needs to
    inform user space right after the 802.11 association was completed
    so user space can initialize its 802.1X state machine etc.
    However, it is also possible that the AP will choose to skip the
    802.1X authentication (e.g. when PMKSA caching is used) and proceed
    with the 4 way handshake immediately. In this case the driver needs
    to inform user space that 802.1X authentication is no longer required
    (e.g. to prevent user space from disconnecting since it did not get
    any EAPOLs from the AP).
    
    This is also useful for roaming, in which case it is possible that
    the driver used the Fast Transition protocol so 802.1X is not
    required.
    
    Since there will now be a dedicated notification indicating that the
    connection is authorized, the authorized flag can be removed from the
    roamed event. Drivers can send the new port authorized event right
    after sending the roamed event to indicate the new AP is already
    authorized. This therefore reserves the old PORT_AUTHORIZED attribute.
    
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6e809325af3b..35165f42c2a8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -216,6 +216,7 @@ enum cfg80211_event_type {
 	EVENT_DISCONNECTED,
 	EVENT_IBSS_JOINED,
 	EVENT_STOPPED,
+	EVENT_PORT_AUTHORIZED,
 };
 
 struct cfg80211_event {
@@ -235,6 +236,9 @@ struct cfg80211_event {
 			u8 bssid[ETH_ALEN];
 			struct ieee80211_channel *channel;
 		} ij;
+		struct {
+			u8 bssid[ETH_ALEN];
+		} pa;
 	};
 };
 
@@ -385,6 +389,7 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			bool wextev);
 void __cfg80211_roamed(struct wireless_dev *wdev,
 		       struct cfg80211_roam_info *info);
+void __cfg80211_port_authorized(struct wireless_dev *wdev, const u8 *bssid);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 void cfg80211_autodisconnect_wk(struct work_struct *work);

commit b34939b9836950d261610132853311054b507247
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Fri Apr 28 13:40:28 2017 +0100

    cfg80211: add request id to cfg80211_sched_scan_*() api
    
    Have proper request id filled in the SCHED_SCAN_RESULTS and
    SCHED_SCAN_STOPPED notifications toward user-space by having the
    driver provide it through the api.
    
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 96baffab5e5b..6e809325af3b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -77,7 +77,6 @@ struct cfg80211_registered_device {
 	struct list_head sched_scan_req_list;
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
-	struct work_struct sched_scan_results_wk;
 
 	struct genl_info *cur_cmd_info;
 
@@ -93,6 +92,7 @@ struct cfg80211_registered_device {
 
 	struct work_struct destroy_work;
 	struct work_struct sched_scan_stop_wk;
+	struct work_struct sched_scan_res_wk;
 
 	struct cfg80211_chan_def radar_chandef;
 	struct work_struct propagate_radar_detect_wk;
@@ -412,7 +412,7 @@ void cfg80211_add_sched_scan_req(struct cfg80211_registered_device *rdev,
 				 struct cfg80211_sched_scan_request *req);
 int cfg80211_sched_scan_req_possible(struct cfg80211_registered_device *rdev,
 				     bool want_multi);
-void __cfg80211_sched_scan_results(struct work_struct *wk);
+void cfg80211_sched_scan_results_wk(struct work_struct *work);
 int cfg80211_stop_sched_scan_req(struct cfg80211_registered_device *rdev,
 				 struct cfg80211_sched_scan_request *req,
 				 bool driver_initiated);

commit 29ce6ecbb83c9185d76e3a7c340c9702d2a54961
Author: Avraham Stern <avraham.stern@intel.com>
Date:   Wed Apr 26 10:58:49 2017 +0300

    cfg80211: unify cfg80211_roamed() and cfg80211_roamed_bss()
    
    cfg80211_roamed() and cfg80211_roamed_bss() take the same arguments
    except that cfg80211_roamed() requires the BSSID and
    cfg80211_roamed_bss() requires the bss entry.
    
    Unify the two functions by using a struct for driver initiated
    roaming information so that either the BSSID or the bss entry can be
    passed as an argument to the unified function.
    
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    [modified the ath6k, brcm80211, rndis and wlan-ng drivers accordingly]
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    [modify brcmfmac to remove the useless cast, spotted by Arend]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 06eaf96053a8..96baffab5e5b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -224,13 +224,7 @@ struct cfg80211_event {
 
 	union {
 		struct cfg80211_connect_resp_params cr;
-		struct {
-			const u8 *req_ie;
-			const u8 *resp_ie;
-			size_t req_ie_len;
-			size_t resp_ie_len;
-			struct cfg80211_bss *bss;
-		} rm;
+		struct cfg80211_roam_info rm;
 		struct {
 			const u8 *ie;
 			size_t ie_len;
@@ -390,9 +384,7 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
 void __cfg80211_roamed(struct wireless_dev *wdev,
-		       struct cfg80211_bss *bss,
-		       const u8 *req_ie, size_t req_ie_len,
-		       const u8 *resp_ie, size_t resp_ie_len);
+		       struct cfg80211_roam_info *info);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 void cfg80211_autodisconnect_wk(struct work_struct *work);

commit ca986ad9bcd3893c8b0b4cc2cafcc8cf1554409c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Fri Apr 21 13:05:00 2017 +0100

    nl80211: allow multiple active scheduled scan requests
    
    This patch implements the idea to have multiple scheduled scan requests
    running concurrently. It mainly illustrates how to deal with the incoming
    request from user-space in terms of backward compatibility. In order to
    use multiple scheduled scans user-space needs to provide a flag attribute
    NL80211_ATTR_SCHED_SCAN_MULTI to indicate support. If not the request is
    treated as a legacy scan.
    
    Drivers currently supporting scheduled scan are now indicating they support
    a single scheduled scan request. This obsoletes WIPHY_FLAG_SUPPORTS_SCHED_SCAN.
    
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    [clean up netlink destroy path to avoid allocations, code cleanups]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f9b748e3425a..06eaf96053a8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -74,7 +74,7 @@ struct cfg80211_registered_device {
 	u32 bss_entries;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
-	struct cfg80211_sched_scan_request __rcu *sched_scan_req;
+	struct list_head sched_scan_req_list;
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;
@@ -416,9 +416,16 @@ int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 void __cfg80211_scan_done(struct work_struct *wk);
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
 			   bool send_message);
+void cfg80211_add_sched_scan_req(struct cfg80211_registered_device *rdev,
+				 struct cfg80211_sched_scan_request *req);
+int cfg80211_sched_scan_req_possible(struct cfg80211_registered_device *rdev,
+				     bool want_multi);
 void __cfg80211_sched_scan_results(struct work_struct *wk);
+int cfg80211_stop_sched_scan_req(struct cfg80211_registered_device *rdev,
+				 struct cfg80211_sched_scan_request *req,
+				 bool driver_initiated);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
-			       bool driver_initiated);
+			       u64 reqid, bool driver_initiated);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, enum nl80211_iftype ntype,

commit ab81007a7b519d72f3c26d753a9fe1ffd27edc20
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 26 07:43:41 2017 +0200

    cfg80211: simplify netlink socket owner interface deletion
    
    There's no need to allocate a portid structure and then, for
    each of those, walk the interfaces - we can just add a flag
    to each interface and walk those directly. Due to padding in
    the struct, we can even do it without any memory cost, and
    it even simplifies the code.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5d27eca57d3b..f9b748e3425a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -91,10 +91,7 @@ struct cfg80211_registered_device {
 
 	struct cfg80211_coalesce *coalesce;
 
-	spinlock_t destroy_list_lock;
-	struct list_head destroy_list;
 	struct work_struct destroy_work;
-
 	struct work_struct sched_scan_stop_wk;
 
 	struct cfg80211_chan_def radar_chandef;
@@ -264,11 +261,6 @@ struct cfg80211_beacon_registration {
 	u32 nlportid;
 };
 
-struct cfg80211_iface_destroy {
-	struct list_head list;
-	u32 nlportid;
-};
-
 struct cfg80211_cqm_config {
 	u32 rssi_hyst;
 	s32 last_rssi_event_value;

commit 818a986e4ebacea2020622e48c8bc04b7f500d89
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 12 11:23:28 2017 +0200

    cfg80211: move add/change interface monitor flags into params
    
    Instead passing both flags, which can be NULL, and vif_params,
    which are never NULL, move the flags into the vif_params and
    use BIT(0), which is invalid from userspace, to indicate that
    the flags were changed.
    
    While updating all drivers, fix a small bug in wil6210 where
    it was setting the flags to 0 instead of leaving them unchanged.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d614efb41726..5d27eca57d3b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -430,7 +430,7 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, enum nl80211_iftype ntype,
-			  u32 *flags, struct vif_params *params);
+			  struct vif_params *params);
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 void cfg80211_process_wdev_events(struct wireless_dev *wdev);
 

commit 5349a0f7bfbdd7d81b8418c707dcd1439c714647
Author: Vidyullatha Kanchanapally <vkanchan@qti.qualcomm.com>
Date:   Fri Mar 31 00:22:33 2017 +0300

    cfg80211: Use a structure to pass connect response params
    
    Currently the connect event from driver takes all the connection
    response parameters as arguments. With support for new features these
    response parameters can grow. Use a structure to pass these parameters
    rather than passing them as function arguments.
    
    Signed-off-by: Vidyullatha Kanchanapally <vkanchan@qti.qualcomm.com>
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    [add to documentation]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a2fe8fc93283..d614efb41726 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -226,16 +226,7 @@ struct cfg80211_event {
 	enum cfg80211_event_type type;
 
 	union {
-		struct {
-			u8 bssid[ETH_ALEN];
-			const u8 *req_ie;
-			const u8 *resp_ie;
-			size_t req_ie_len;
-			size_t resp_ie_len;
-			struct cfg80211_bss *bss;
-			int status; /* -1 = failed; 0..65535 = status code */
-			enum nl80211_timeout_reason timeout_reason;
-		} cr;
+		struct cfg80211_connect_resp_params cr;
 		struct {
 			const u8 *req_ie;
 			const u8 *resp_ie;
@@ -398,12 +389,9 @@ int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct cfg80211_connect_params *connect,
 		     struct cfg80211_cached_keys *connkeys,
 		     const u8 *prev_bssid);
-void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
-			       const u8 *req_ie, size_t req_ie_len,
-			       const u8 *resp_ie, size_t resp_ie_len,
-			       int status, bool wextev,
-			       struct cfg80211_bss *bss,
-			       enum nl80211_timeout_reason timeout_reason);
+void __cfg80211_connect_result(struct net_device *dev,
+			       struct cfg80211_connect_resp_params *params,
+			       bool wextev);
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,

commit 8976672736d6089ae011fda3482e30e4380276f8
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Mon Feb 27 17:04:35 2017 +0530

    cfg80211: Share Channel DFS state across wiphys of same DFS domain
    
    Sharing DFS channel state across multiple wiphys (radios) could
    be useful with multiple radios on the system. When one radio
    completes CAC and markes the channel available another radio
    can use this information and start beaconing without really doing
    CAC.
    
    Whenever there is a state change in dfs channel associated to
    a particular wiphy the the same state change is propagated to
    other wiphys having the same DFS reg domain configuration.
    Also when a new wiphy is created the dfs channel state of
    other existing wiphys of same DFS domain is copied.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 519a29ebde5b..a2fe8fc93283 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -97,6 +97,12 @@ struct cfg80211_registered_device {
 
 	struct work_struct sched_scan_stop_wk;
 
+	struct cfg80211_chan_def radar_chandef;
+	struct work_struct propagate_radar_detect_wk;
+
+	struct cfg80211_chan_def cac_done_chandef;
+	struct work_struct propagate_cac_done_wk;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);

commit b35a51c7dd25a823767969e3089542d7478777e9
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Mon Feb 27 17:04:33 2017 +0530

    cfg80211: Make pre-CAC results valid only for ETSI domain
    
    DFS requirement for ETSI domain (section 4.7.1.4 in
    ETSI EN 301 893 V1.8.1) is the only one which explicitly
    states that once DFS channel is marked as available afer
    the CAC, this channel will remain in available state even
    moving to a different operating channel. But the same is
    not explicitly stated in FCC DFS requirement. Also, Pre-CAC
    requriements are not explicitly mentioned in FCC requirement.
    Current implementation in keeping DFS channel in available
    state is same as described in ETSI domain.
    
    For non-ETSI DFS domain, this patch gives a grace period of 2 seconds
    since the completion of successful CAC before moving the channel's
    DFS state to 'usable' from 'available' state. The same grace period
    is checked against the channel's dfs_state_entered timestamp while
    deciding if a DFS channel is available for operation. There is a new
    radar event, NL80211_RADAR_PRE_CAC_EXPIRED, reported when DFS channel
    is moved from available to usable state after the grace period. Also
    make sure the DFS channel state is reset to usable once the beaconing
    operation on that channel is brought down (like stop_ap, leave_ibss
    and leave_mesh) in non-ETSI domain.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index efa690a7ef8d..519a29ebde5b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -466,6 +466,16 @@ unsigned int
 cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
 			      const struct cfg80211_chan_def *chandef);
 
+void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
+
+bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+				  struct ieee80211_channel *chan);
+
+bool cfg80211_beaconing_iface_active(struct wireless_dev *wdev);
+
+bool cfg80211_is_sub_chan(struct cfg80211_chan_def *chandef,
+			  struct ieee80211_channel *chan);
+
 static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 {
 	unsigned long end = jiffies;

commit 4a4b8169501b18c3450ac735a7e277b24886a651
Author: Andrew Zaborowski <andrew.zaborowski@intel.com>
Date:   Fri Feb 10 10:02:31 2017 +0100

    cfg80211: Accept multiple RSSI thresholds for CQM
    
    Change the SET CQM command's RSSI threshold attribute to accept any
    number of thresholds as a sorted array.  The API should be backwards
    compatible so that if one s32 threshold value is passed, the old
    mechanism is enabled.  The netlink event generated is the same in both
    cases.
    
    cfg80211 handles an arbitrary number of RSSI thresholds but drivers have
    to provide a method (set_cqm_rssi_range_config) that configures a range
    set by a high and a low value.  Drivers have to call back when the RSSI
    goes out of that range and there's no additional event for each time the
    range is reconfigured as there was with the current one-threshold API.
    
    This method doesn't have a hysteresis parameter because there's no
    benefit to the cfg80211 code from having the hysteresis be handled by
    hardware/driver in terms of the number of wakeups.  At the same time
    it would likely be less consistent between drivers if offloaded or
    done in the drivers.
    
    Signed-off-by: Andrew Zaborowski <andrew.zaborowski@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 58ca206982fe..efa690a7ef8d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -272,6 +272,13 @@ struct cfg80211_iface_destroy {
 	u32 nlportid;
 };
 
+struct cfg80211_cqm_config {
+	u32 rssi_hyst;
+	s32 last_rssi_event_value;
+	int n_rssi_thresholds;
+	s32 rssi_thresholds[0];
+};
+
 void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev);
 
 /* free object */
@@ -512,4 +519,6 @@ void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
 #define CFG80211_DEV_WARN_ON(cond)	({bool __r = (cond); __r; })
 #endif
 
+void cfg80211_cqm_config_free(struct wireless_dev *wdev);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 3093ebbeabcdddc9a982950052f2151df43c7aa2
Author: Purushottam Kushwaha <pkushwah@qti.qualcomm.com>
Date:   Fri Jan 13 01:12:21 2017 +0200

    cfg80211: Specify the reason for connect timeout
    
    This enhances the connect timeout API to also carry the reason for the
    timeout. These reason codes for the connect time out are represented by
    enum nl80211_timeout_reason and are passed to user space through a new
    attribute NL80211_ATTR_TIMEOUT_REASON (u32).
    
    Signed-off-by: Purushottam Kushwaha <pkushwah@qti.qualcomm.com>
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    [keep gfp_t argument last]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ba42055a036d..58ca206982fe 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -228,6 +228,7 @@ struct cfg80211_event {
 			size_t resp_ie_len;
 			struct cfg80211_bss *bss;
 			int status; /* -1 = failed; 0..65535 = status code */
+			enum nl80211_timeout_reason timeout_reason;
 		} cr;
 		struct {
 			const u8 *req_ie;
@@ -388,7 +389,8 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 			       const u8 *req_ie, size_t req_ie_len,
 			       const u8 *resp_ie, size_t resp_ie_len,
 			       int status, bool wextev,
-			       struct cfg80211_bss *bss);
+			       struct cfg80211_bss *bss,
+			       enum nl80211_timeout_reason timeout_reason);
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,

commit bd2522b168847106c1885f0319a2833bdf88bf9a
Author: Andrzej Zaborowski <andrew.zaborowski@intel.com>
Date:   Fri Jan 6 16:33:43 2017 -0500

    cfg80211: NL80211_ATTR_SOCKET_OWNER support for CMD_CONNECT
    
    Disconnect or deauthenticate when the owning socket is closed if this
    flag is supplied to CMD_CONNECT or CMD_ASSOCIATE.  This may be used
    to ensure userspace daemon doesn't leave an unmanaged connection behind.
    
    In some situations it would be possible to account for that, to some
    degree, in the deamon restart code or in the up/down scripts without
    the use of this attribute.  But there will be systems where the daemon
    can go away for varying periods without a warning due to local resource
    management.
    
    Signed-off-by: Andrew Zaborowski <andrew.zaborowski@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bc8ba6e57519..ba42055a036d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -400,6 +400,7 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
 		       const u8 *resp_ie, size_t resp_ie_len);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
+void cfg80211_autodisconnect_wk(struct work_struct *work);
 
 /* SME implementation */
 void cfg80211_conn_work(struct work_struct *work);

commit 4787cfa08476d4193c35d958f564f643bb6ae234
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Wed Jan 4 18:58:30 2017 +0100

    cfg80211: move function checking range fit to util.c
    
    It is needed for another cfg80211 helper that will be out of reg.c so
    move it to common util.c file and make it non-static.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index af6e023020b1..bc8ba6e57519 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -430,6 +430,9 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 void cfg80211_process_wdev_events(struct wireless_dev *wdev);
 
+bool cfg80211_does_bw_fit_range(const struct ieee80211_freq_range *freq_range,
+				u32 center_freq_khz, u32 bw_khz);
+
 /**
  * cfg80211_chandef_dfs_usable - checks if chandef is DFS usable
  * @wiphy: the wiphy to validate against

commit 5ac9efbe1c825d624eb557e633683c07ee03465b
Merge: 524a64c7268f e6f462df9acd
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Dec 9 22:59:05 2016 -0500

    Merge tag 'mac80211-next-for-davem-2016-12-09' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next
    
    Johannes Berg says:
    
    ====================
    Three fixes:
     * fix a logic bug introduced by a previous cleanup
     * fix nl80211 attribute confusing (trying to use
       a single attribute for two purposes)
     * fix a long-standing BSS leak that happens when an
       association attempt is abandoned
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e6f462df9acd2a3295e5d34eb29e2823220cf129
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 8 17:22:09 2016 +0100

    cfg80211/mac80211: fix BSS leaks when abandoning assoc attempts
    
    When mac80211 abandons an association attempt, it may free
    all the data structures, but inform cfg80211 and userspace
    about it only by sending the deauth frame it received, in
    which case cfg80211 has no link to the BSS struct that was
    used and will not cfg80211_unhold_bss() it.
    
    Fix this by providing a way to inform cfg80211 of this with
    the BSS entry passed, so that it can clean up properly, and
    use this ability in the appropriate places in mac80211.
    
    This isn't ideal: some code is more or less duplicated and
    tracing is missing. However, it's a fairly small change and
    it's thus easier to backport - cleanups can come later.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fb2fcd5581fe..9820fa251daa 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -409,6 +409,7 @@ void cfg80211_sme_disassoc(struct wireless_dev *wdev);
 void cfg80211_sme_deauth(struct wireless_dev *wdev);
 void cfg80211_sme_auth_timeout(struct wireless_dev *wdev);
 void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev);
+void cfg80211_sme_abandon_assoc(struct wireless_dev *wdev);
 
 /* internal helpers */
 bool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher);

commit f9aa9dc7d2d00e6eb02168ffc64ef614b89d7998
Merge: 06b37b650cf8 3b404a519815
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Nov 22 11:29:28 2016 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    All conflicts were simple overlapping changes except perhaps
    for the Thunder driver.
    
    That driver has a change_mtu method explicitly for sending
    a message to the hardware.  If that fails it returns an
    error.
    
    Normally a driver doesn't need an ndo_change_mtu method becuase those
    are usually just range changes, which are now handled generically.
    But since this extra operation is needed in the Thunder driver, it has
    to stay.
    
    However, if the message send fails we have to restore the original
    MTU before the change because the entire call chain expects that if
    an error is thrown by ndo_change_mtu then the MTU did not change.
    Therefore code is added to nicvf_change_mtu to remember the original
    MTU, and to restore it upon nicvf_update_hw_max_frs() failue.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9853a55ef1bb66d7411136046060bbfb69c714fa
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Nov 15 12:05:11 2016 +0100

    cfg80211: limit scan results cache size
    
    It's possible to make scanning consume almost arbitrary amounts
    of memory, e.g. by sending beacon frames with random BSSIDs at
    high rates while somebody is scanning.
    
    Limit the number of BSS table entries we're willing to cache to
    1000, limiting maximum memory usage to maybe 4-5MB, but lower
    in practice - that would be the case for having both full-sized
    beacon and probe response frames for each entry; this seems not
    possible in practice, so a limit of 1000 entries will likely be
    closer to 0.5 MB.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 08d2e948c9ad..f0c0c8a48c92 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -71,6 +71,7 @@ struct cfg80211_registered_device {
 	struct list_head bss_list;
 	struct rb_root bss_tree;
 	u32 bss_generation;
+	u32 bss_entries;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
 	struct cfg80211_sched_scan_request __rcu *sched_scan_req;

commit 11b6b5a4ced2f2c76073b97ee08ca0eab8358fde
Author: Jouni Malinen <jouni@qca.qualcomm.com>
Date:   Thu Oct 27 00:41:58 2016 +0300

    cfg80211: Rename SAE_DATA to more generic AUTH_DATA
    
    This adds defines and nl80211 extensions to allow FILS Authentication to
    be implemented similarly to SAE. FILS does not need the special rules
    for the Authentication transaction number and Status code fields, but it
    does need to add non-IE fields. The previously used
    NL80211_ATTR_SAE_DATA can be reused for this to avoid having to
    duplicate that implementation. Rename that attribute to more generic
    NL80211_ATTR_AUTH_DATA (with backwards compatibility define for
    NL80211_SAE_DATA).
    
    Also document the special rules related to the Authentication
    transaction number and Status code fiels.
    
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 21e31888cfa9..fb2fcd5581fe 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -345,7 +345,7 @@ int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len,
 		       const u8 *key, int key_len, int key_idx,
-		       const u8 *sae_data, int sae_data_len);
+		       const u8 *auth_data, int auth_data_len);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev,
 			struct ieee80211_channel *chan,

commit 0c317a02ca982ca093e71bf07cb562265ba40032
Author: Purushottam Kushwaha <pkushwah@qti.qualcomm.com>
Date:   Wed Oct 12 18:26:51 2016 +0530

    cfg80211: support virtual interfaces with different beacon intervals
    
    This commit provides a mechanism for the host drivers to advertise the
    support for different beacon intervals among the respective interface
    combinations in a group, through NL80211_IFACE_COMB_BI_MIN_GCD (u32).
    
    This value will be compared against GCD of all beaconing interfaces of
    matching combinations.
    
    If the driver doesn't advertise this value, the old behaviour where
    all beacon intervals must be identical is retained.
    
    If it is specified, then any beacon interval for an interface in the
    interface combination as well as the GCD of all active beacon intervals
    in the combination must be greater or equal to this value.
    
    Signed-off-by: Purushottam Kushwaha <pkushwah@qti.qualcomm.com>
    [change commit message, some variable names, small other things]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 08d2e948c9ad..21e31888cfa9 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -475,7 +475,7 @@ int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
 			   u32 *mask);
 
 int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
-				 u32 beacon_int);
+				 enum nl80211_iftype iftype, u32 beacon_int);
 
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);

commit cb3b7d87652aeb37cfb5295a6157a3280dae10cb
Author: Ayala Beker <ayala.beker@intel.com>
Date:   Tue Sep 20 17:31:13 2016 +0300

    cfg80211: add start / stop NAN commands
    
    This allows user space to start/stop NAN interface.
    A NAN interface is like P2P device in a few aspects: it
    doesn't have a netdev associated to it.
    Add the new interface type and prevent operations that
    can't be executed on NAN interface like scan.
    
    Define several attributes that may be configured by user space
    when starting NAN functionality (master preference and dual
    band operation)
    
    Signed-off-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 554f87d0f991..08d2e948c9ad 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -488,6 +488,9 @@ void cfg80211_leave(struct cfg80211_registered_device *rdev,
 void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 
+void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
+		       struct wireless_dev *wdev);
+
 #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
 
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS

commit b8676221f00dd5b6018f0fd88cd278f93e11143a
Author: David Spinadel <david.spinadel@intel.com>
Date:   Thu Sep 22 23:16:50 2016 +0300

    cfg80211: Add support for static WEP in the driver
    
    Add support for drivers that implement static WEP internally, i.e.
    expose connection keys to the driver in connect flow and don't
    upload the keys after the connection.
    
    Signed-off-by: David Spinadel <david.spinadel@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5555e3c13ae9..554f87d0f991 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -249,8 +249,8 @@ struct cfg80211_event {
 };
 
 struct cfg80211_cached_keys {
-	struct key_params params[4];
-	u8 data[4][WLAN_KEY_LEN_WEP104];
+	struct key_params params[CFG80211_MAX_WEP_KEYS];
+	u8 data[CFG80211_MAX_WEP_KEYS][WLAN_KEY_LEN_WEP104];
 	int def;
 };
 

commit 89b706fb28e431fa7639348536c284fb375eb3c0
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Sep 13 16:39:38 2016 +0200

    cfg80211: reduce connect key caching struct size
    
    After the previous patches, connect keys can only (correctly)
    be used for storing static WEP keys. Therefore, remove all the
    data for dealing with key index 4/5 and reduce the size of the
    key material to the maximum for WEP keys.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index eee91443924d..5555e3c13ae9 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -249,9 +249,9 @@ struct cfg80211_event {
 };
 
 struct cfg80211_cached_keys {
-	struct key_params params[6];
-	u8 data[6][WLAN_MAX_KEY_LEN];
-	int def, defmgmt;
+	struct key_params params[4];
+	u8 data[4][WLAN_KEY_LEN_WEP104];
+	int def;
 };
 
 enum cfg80211_chan_mode {

commit 1d76250bd34af86c6498fc51e50cab3bfbbeceaa
Author: Avraham Stern <avraham.stern@intel.com>
Date:   Tue Jul 5 17:10:13 2016 +0300

    nl80211: support beacon report scanning
    
    Beacon report radio measurement requires reporting observed BSSs
    on the channels specified in the beacon request. If the measurement
    mode is set to passive or active, it requires actually performing a
    scan (passive or active, accordingly), and reporting the time that
    the scan was started and the time each beacon/probe was received
    (both in terms of TSF of the BSS of the requesting AP). If the
    request mode is table, this information is optional.
    In addition, the radio measurement request specifies the channel
    dwell time for the measurement.
    
    In order to use scan for beacon report when the mode is active or
    passive, add a parameter to scan request that specifies the
    channel dwell time, and add scan start time and beacon received time
    to scan results information.
    
    Supporting beacon report is required for Multi Band Operation (MBO).
    
    Signed-off-by: Assaf Krauss <assaf.krauss@intel.com>
    Signed-off-by: David Spinadel <david.spinadel@intel.com>
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a4d547f99f8d..eee91443924d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -141,6 +141,18 @@ struct cfg80211_internal_bss {
 	unsigned long refcount;
 	atomic_t hold;
 
+	/* time at the start of the reception of the first octet of the
+	 * timestamp field of the last beacon/probe received for this BSS.
+	 * The time is the TSF of the BSS specified by %parent_bssid.
+	 */
+	u64 parent_tsf;
+
+	/* the BSS according to which %parent_tsf is set. This is set to
+	 * the BSS that the interface that requested the scan was connected to
+	 * when the beacon/probe was received.
+	 */
+	u8 parent_bssid[ETH_ALEN] __aligned(2);
+
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;
 };

commit bf1ecd210541ef5f3a110e88e8ca5d33b4aa5c23
Author: Jouni Malinen <jouni@qca.qualcomm.com>
Date:   Tue May 31 00:16:50 2016 +0300

    cfg80211: Allow cfg80211_connect_result() errors to be distinguished
    
    Previously, the status parameter to cfg80211_connect_result() was
    documented as using WLAN_STATUS_UNSPECIFIED_FAILURE (1) when the real
    status code for the failure is not known. This value can be used by an
    AP (and often is) and as such, user space cannot distinguish between
    explicitly rejected authentication/association and not being able to
    even try to associate or not receiving a response from the AP.
    
    Add a new inline function, cfg80211_connect_timeout(), to be used when
    the driver knows that the connection attempt failed due to a reason
    where connection could not be attempt or no response was received from
    the AP. The internal functions now allow a negative status value (-1) to
    be used as an indication of this special case. This results in the
    NL80211_ATTR_TIMED_OUT to be added to the NL80211_CMD_CONNECT event to
    allow user space to determine this case was hit. For backwards
    compatibility, NL80211_STATUS_CODE with the value
    WLAN_STATUS_UNSPECIFIED_FAILURE is still indicated in the event in such
    a case.
    
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    [johannes: fix cfg80211_connect_bss() prototype to use int for status,
     add cfg80211_connect_timeout() to docbook, fix docbook]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 025b7a5d508b..a4d547f99f8d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -214,7 +214,7 @@ struct cfg80211_event {
 			size_t req_ie_len;
 			size_t resp_ie_len;
 			struct cfg80211_bss *bss;
-			u16 status;
+			int status; /* -1 = failed; 0..65535 = status code */
 		} cr;
 		struct {
 			const u8 *req_ie;
@@ -374,7 +374,7 @@ int cfg80211_connect(struct cfg80211_registered_device *rdev,
 void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 			       const u8 *req_ie, size_t req_ie_len,
 			       const u8 *resp_ie, size_t resp_ie_len,
-			       u16 status, bool wextev,
+			       int status, bool wextev,
 			       struct cfg80211_bss *bss);
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);

commit 53873f134d285191ef6435882d55837093a36c53
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue May 3 16:52:04 2016 +0300

    cfg80211: make wdev_list accessible to drivers
    
    There's no harm in having drivers read the list, since they can
    use RCU protection or RTNL locking; allow this to not require
    each and every driver to also implement its own bookkeeping.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f75d7605bc38..025b7a5d508b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -50,8 +50,7 @@ struct cfg80211_registered_device {
 	/* wiphy index, internal only */
 	int wiphy_idx;
 
-	/* associated wireless interfaces, protected by rtnl or RCU */
-	struct list_head wdev_list;
+	/* protected by RTNL */
 	int devlist_generation, wdev_id;
 	int opencount;
 	wait_queue_head_t dev_wait;

commit 8b9b2f06998f33bdd1774a9860ec60e945977384
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue May 3 16:26:40 2016 +0300

    cfg80211: remove erroneous comment
    
    The devlist_mtx mutex was removed about two years ago, in favour of just
    using RTNL/RCU protection. Remove the comment still referencing it.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ac44e77ac2f2..f75d7605bc38 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -53,7 +53,7 @@ struct cfg80211_registered_device {
 	/* associated wireless interfaces, protected by rtnl or RCU */
 	struct list_head wdev_list;
 	int devlist_generation, wdev_id;
-	int opencount; /* also protected by devlist_mtx */
+	int opencount;
 	wait_queue_head_t dev_wait;
 
 	struct list_head beacon_registrations;

commit e705498945ad3a3b945771c5d683df064bb9819c
Author: Kanchanapally, Vidyullatha <vkanchan@qti.qualcomm.com>
Date:   Mon Apr 11 15:16:01 2016 +0530

    cfg80211: Add option to report the bss entry in connect result
    
    Since cfg80211 maintains separate BSS table entries for APs if the same
    BSSID, SSID pair is seen on multiple channels, it is possible that it
    can map the current_bss to a BSS entry on the wrong channel. This
    current_bss will not get flushed unless disconnected and cfg80211
    reports a wrong channel as the associated channel.
    
    Fix this by introducing a new cfg80211_connect_bss() function which is
    similar to cfg80211_connect_result(), but it includes an additional
    parameter: the bss the STA is connected to. This allows drivers to
    provide the exact bss entry that matches the BSS to which the connection
    was completed.
    
    Reviewed-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Vidyullatha Kanchanapally <vkanchan@qti.qualcomm.com>
    Signed-off-by: Sunil Dutt <usdutt@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 022ccad06cbe..ac44e77ac2f2 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -214,6 +214,7 @@ struct cfg80211_event {
 			const u8 *resp_ie;
 			size_t req_ie_len;
 			size_t resp_ie_len;
+			struct cfg80211_bss *bss;
 			u16 status;
 		} cr;
 		struct {

commit c781944b71f87aa4d30eaaafb4e7573ce94bdcfd
Author: Michal Sojka <sojkam1@fel.cvut.cz>
Date:   Mon Nov 23 19:27:15 2015 +0100

    cfg80211: Remove unused cfg80211_can_use_iftype_chan()
    
    Last caller of this function was removed in 3.17 in commit
    97dc94f1d933c9df2c0b327066ea130c0e92083f.
    
    Signed-off-by: Michal Sojka <sojkam1@fel.cvut.cz>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a618b4b86fa4..022ccad06cbe 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -416,13 +416,6 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 void cfg80211_process_wdev_events(struct wireless_dev *wdev);
 
-int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
-				 struct wireless_dev *wdev,
-				 enum nl80211_iftype iftype,
-				 struct ieee80211_channel *chan,
-				 enum cfg80211_chan_mode chanmode,
-				 u8 radar_detect);
-
 /**
  * cfg80211_chandef_dfs_usable - checks if chandef is DFS usable
  * @wiphy: the wiphy to validate against

commit 6e19bc4b7091ffd26586100eee78232b44427ec7
Author: Dmitry Shmidt <dimitrysh@google.com>
Date:   Wed Oct 7 11:32:53 2015 +0200

    nl80211: allow BSS data to include CLOCK_BOOTTIME timestamp
    
    For location and connectivity services, userspace would often like
    to know the time when the BSS was last seen. The current "last seen"
    value is calculated in a way that makes it less useful, especially
    if the system suspended in the meantime.
    
    Add the ability for the driver to report a real CLOCK_BOOTTIME stamp
    that can then be reported to userspace (if present).
    
    Drivers wishing to use this must be converted to the new API to call
    cfg80211_inform_bss_data() or cfg80211_inform_bss_frame_data(). They
    need to ensure the reported value is accurate enough even when the
    frame might have been buffered in the device (e.g. firmware.)
    
    Signed-off-by: Dmitry Shmidt <dimitrysh@google.com>
    [modified to use struct, inlines]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b9d5bc8c148d..a618b4b86fa4 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -137,6 +137,7 @@ struct cfg80211_internal_bss {
 	struct list_head list;
 	struct list_head hidden_list;
 	struct rb_node rbn;
+	u64 ts_boottime;
 	unsigned long ts;
 	unsigned long refcount;
 	atomic_t hold;

commit 33d8783c58427683b533664f67f8c4378ed64495
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jun 23 17:47:05 2015 +0200

    cfg80211: allow mgmt_frame_register callback to sleep
    
    This callback is currently not allowed to sleep, which makes it more
    difficult to implement proper driver methods in mac80211 than it has
    to be. Instead of doing asynchronous work here in mac80211, make it
    possible for the callback to sleep by doing some asynchronous work
    in cfg80211. This also enables improvements to other drivers, like
    ath6kl, that would like to sleep in this callback.
    
    While at it, also fix the code to call the driver on the implicit
    unregistration when an interface is removed, and do that also when
    a P2P-Device wdev is destroyed (otherwise we leak the structs.)
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 311eef26bf88..b9d5bc8c148d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -59,6 +59,10 @@ struct cfg80211_registered_device {
 	struct list_head beacon_registrations;
 	spinlock_t beacon_registrations_lock;
 
+	struct list_head mlme_unreg;
+	spinlock_t mlme_unreg_lock;
+	struct work_struct mlme_unreg_wk;
+
 	/* protected by RTNL only */
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
@@ -348,6 +352,7 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 				u16 frame_type, const u8 *match_data,
 				int match_len);
+void cfg80211_mlme_unreg_wk(struct work_struct *wk);
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,

commit 80279fb7ba5b71981a60988b0307afa43f78f6b1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri May 22 16:22:20 2015 +0200

    cfg80211: properly send NL80211_ATTR_DISCONNECTED_BY_AP in disconnect
    
    When we disconnect from the AP, drivers call cfg80211_disconnect().
    This doesn't know whether the disconnection was initiated locally
    or by the AP though, which can cause problems with the supplicant,
    for example with WPS. This issue obviously doesn't show up with any
    mac80211 based driver since mac80211 doesn't call this function.
    
    Fix this by requiring drivers to indicate whether the disconnect is
    locally generated or not. I've tried to update the drivers, but may
    not have gotten the values correct, and some drivers may currently
    not be able to report correct values. In case of doubt I left it at
    false, which is the current behaviour.
    
    For libertas, make adjustments as indicated by Dan Williams.
    
    Reported-by: Matthieu Mauger <matthieux.mauger@intel.com>
    Tested-by: Matthieu Mauger <matthieux.mauger@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 801cd49c5a0c..311eef26bf88 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -222,6 +222,7 @@ struct cfg80211_event {
 			const u8 *ie;
 			size_t ie_len;
 			u16 reason;
+			bool locally_generated;
 		} dc;
 		struct {
 			u8 bssid[ETH_ALEN];

commit 93a1e86ce10e4898f9ca9cd09d659a8a7780ee5e
Author: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date:   Mon Dec 15 13:25:39 2014 +0200

    nl80211: Stop scheduled scan if netlink client disappears
    
    An attribute NL80211_ATTR_SOCKET_OWNER can be set by the scan initiator.
    If present, the attribute will cause the scan to be stopped if the client
    dies.
    
    Signed-off-by: Jukka Rissanen <jukka.rissanen@linux.intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e82030c32311..801cd49c5a0c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -91,6 +91,8 @@ struct cfg80211_registered_device {
 	struct list_head destroy_list;
 	struct work_struct destroy_work;
 
+	struct work_struct sched_scan_stop_wk;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);

commit 31a60ed1e95ab8afbadb65599bef12b195080a0c
Author: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date:   Mon Dec 15 13:25:38 2014 +0200

    nl80211: Convert sched_scan_req pointer to RCU pointer
    
    Because of possible races when accessing sched_scan_req pointer in
    rdev, the sched_scan_req is converted to RCU pointer.
    
    Signed-off-by: Jukka Rissanen <jukka.rissanen@linux.intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e87cae57a83b..e82030c32311 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -70,7 +70,7 @@ struct cfg80211_registered_device {
 	u32 bss_generation;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
-	struct cfg80211_sched_scan_request *sched_scan_req;
+	struct cfg80211_sched_scan_request __rcu *sched_scan_req;
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;

commit b0d7aa59592b4270531de5ce65dcf18338a2d98c
Author: Jonathan Doron <jond@wizery.com>
Date:   Mon Dec 15 19:26:00 2014 +0200

    cfg80211: allow wiphy specific regdomain management
    
    Add a new regulatory flag that allows a driver to manage regdomain
    changes/updates for its own wiphy.
    A self-managed wiphys only employs regulatory information obtained from
    the FW and driver and does not use other cfg80211 sources like
    beacon-hints, country-code IEs and hints from other devices on the same
    system. Conversely, a self-managed wiphy does not share its regulatory
    hints with other devices in the system. If a system contains several
    devices, one or more of which are self-managed, there might be
    contradictory regulatory settings between them. Usage of flag is
    generally discouraged. Only use it if the FW/driver is incompatible
    with non-locally originated hints.
    
    A new API lets the driver send a complete regdomain, to be applied on
    its wiphy only.
    
    After a wiphy-specific regdomain change takes place, usermode will get
    a new type of change notification. The regulatory core also takes care
    enforce regulatory restrictions, in case some interfaces are on
    forbidden channels.
    
    Signed-off-by: Jonathan Doron <jonathanx.doron@intel.com>
    Signed-off-by: Arik Nemtsov <arikx.nemtsov@intel.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index faa5b1609aae..e87cae57a83b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -36,6 +36,13 @@ struct cfg80211_registered_device {
 	 * the country on the country IE changed. */
 	char country_ie_alpha2[2];
 
+	/*
+	 * the driver requests the regulatory core to set this regulatory
+	 * domain as the wiphy's. Only used for %REGULATORY_WIPHY_SELF_MANAGED
+	 * devices using the regulatory_set_wiphy_regd() API
+	 */
+	const struct ieee80211_regdomain *requested_regd;
+
 	/* If a Country IE has been received this tells us the environment
 	 * which its telling us its in. This defaults to ENVIRON_ANY */
 	enum environment_cap env;

commit 8cd4d4563ef0a518002c4a8f47dd950afe386ea8
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Wed Sep 17 11:55:28 2014 +0300

    cfg80211: add wowlan net-detect support
    
    Add a new WoWLAN API to enable net-detect as a wake up trigger.
    Net-detect allows the device to scan in the background while the
    host is asleep to wake up the host system when a matching network
    is found.
    
    Reuse the scheduled scan attributes to specify how the scan is
    performed while suspended and the matches that will trigger a
    wake event.
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 61ee664cf2bd..faa5b1609aae 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -111,6 +111,7 @@ cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 	    rdev->wiphy.wowlan_config->tcp->sock)
 		sock_release(rdev->wiphy.wowlan_config->tcp->sock);
 	kfree(rdev->wiphy.wowlan_config->tcp);
+	kfree(rdev->wiphy.wowlan_config->nd_config);
 	kfree(rdev->wiphy.wowlan_config);
 #endif
 }

commit 6e0bd6c35b021dc73a81ebd1ef79761233c48b50
Author: Rostislav Lisovy <lisovy@gmail.com>
Date:   Mon Nov 3 10:33:18 2014 +0100

    cfg80211: 802.11p OCB mode handling
    
    This patch adds new iface type (NL80211_IFTYPE_OCB) representing
    the OCB (Outside the Context of a BSS) mode.
    When establishing a connection to the network a cfg80211_join_ocb
    function is called (particular nl80211_command is added as well).
    A mandatory parameters during the ocb_join operation are 'center
    frequency' and 'channel width (5/10 MHz)'.
    
    Changes done in mac80211 are minimal possible required to avoid
    many warnings (warning: enumeration value 'NL80211_IFTYPE_OCB'
    not handled in switch) during compilation. Full functionality
    (where needed) is added in the following patch.
    
    Signed-off-by: Rostislav Lisovy <rostislav.lisovy@fel.cvut.cz>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 7e3a3cef7df9..61ee664cf2bd 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -290,6 +290,18 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev,
 			      struct cfg80211_chan_def *chandef);
 
+/* OCB */
+int __cfg80211_join_ocb(struct cfg80211_registered_device *rdev,
+			struct net_device *dev,
+			struct ocb_setup *setup);
+int cfg80211_join_ocb(struct cfg80211_registered_device *rdev,
+		      struct net_device *dev,
+		      struct ocb_setup *setup);
+int __cfg80211_leave_ocb(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev);
+int cfg80211_leave_ocb(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev);
+
 /* AP */
 int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, bool notify);

commit 0ce12026d6ea4a24d52ddcde36b9643f2e26d560
Author: Eliad Peller <eliad@wizery.com>
Date:   Tue Jun 17 13:07:02 2014 +0300

    cfg80211: fix elapsed_jiffies calculation
    
    MAX_JIFFY_OFFSET has no meaning when calculating the
    elapsed jiffies, as jiffies run out until ULONG_MAX.
    
    This miscalculation results in erroneous values
    in case of a wrap-around.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e9afbf10e756..7e3a3cef7df9 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -424,7 +424,7 @@ static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 	if (end >= start)
 		return jiffies_to_msecs(end - start);
 
-	return jiffies_to_msecs(end + (MAX_JIFFY_OFFSET - start) + 1);
+	return jiffies_to_msecs(end + (ULONG_MAX - start) + 1);
 }
 
 void

commit f04c22033c25f71617ac62bcfe75698baa17a0b8
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed Apr 9 15:11:01 2014 +0200

    cfg80211: export interface stopping function
    
    This exports a new cfg80211_stop_iface() function.
    
    This is intended for driver internal interface
    combination management and channel switching.
    
    Due to locking issues (it re-enters driver) the
    call is asynchronous and uses cfg80211 event
    list/worker.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 681b8fa4355b..e9afbf10e756 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -185,6 +185,7 @@ enum cfg80211_event_type {
 	EVENT_ROAMED,
 	EVENT_DISCONNECTED,
 	EVENT_IBSS_JOINED,
+	EVENT_STOPPED,
 };
 
 struct cfg80211_event {
@@ -281,6 +282,8 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
 		       struct mesh_setup *setup,
 		       const struct mesh_config *conf);
+int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
 int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
@@ -288,6 +291,8 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 			      struct cfg80211_chan_def *chandef);
 
 /* AP */
+int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev, bool notify);
 int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev, bool notify);
 
@@ -441,6 +446,8 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
+void __cfg80211_leave(struct cfg80211_registered_device *rdev,
+		      struct wireless_dev *wdev);
 void cfg80211_leave(struct cfg80211_registered_device *rdev,
 		    struct wireless_dev *wdev);
 

commit f26cbf401be935eec13da6fca7088b50d797d78b
Author: Zhao, Gang <gamerh2o@gmail.com>
Date:   Mon Apr 21 12:53:03 2014 +0800

    cfg80211: change wiphy_to_dev function name
    
    Name wiphy_to_rdev is more accurate to describe what the function
    does, i.e., return a pointer pointing to struct
    cfg80211_registered_device.
    
    Signed-off-by: Zhao, Gang <gamerh2o@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c65f4a92710c..681b8fa4355b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -90,7 +90,7 @@ struct cfg80211_registered_device {
 };
 
 static inline
-struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
+struct cfg80211_registered_device *wiphy_to_rdev(struct wiphy *wiphy)
 {
 	BUG_ON(!wiphy);
 	return container_of(wiphy, struct cfg80211_registered_device, wiphy);

commit 1b8ec87aa077c527c9e3525e16098ca7efbc853d
Author: Zhao, Gang <gamerh2o@gmail.com>
Date:   Mon Apr 21 12:53:02 2014 +0800

    cfg80211: change registered device pointer name
    
    Name "dev" is too common and ambiguous, let all the pointer name
    pointing to struct cfg80211_registered_device be "rdev". This can
    improve code readability and consistency(since other places have
    already called it rdev).
    
    Signed-off-by: Zhao, Gang <gamerh2o@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5bee6cc94b21..c65f4a92710c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -251,8 +251,8 @@ int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 
-void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
-void cfg80211_bss_age(struct cfg80211_registered_device *dev,
+void cfg80211_bss_expire(struct cfg80211_registered_device *rdev);
+void cfg80211_bss_age(struct cfg80211_registered_device *rdev,
                       unsigned long age_secs);
 
 /* IBSS */

commit b6a550156bc08a472c9d2515631649e229fcfcef
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Thu Feb 27 11:07:21 2014 +0200

    cfg80211/mac80211: move more combination checks to mac80211
    
    Get rid of the cfg80211_can_add_interface() and
    cfg80211_can_change_interface() functions by moving that functionality
    to mac80211.  With this patch all interface combination checks are now
    out of cfg80211 (except for the channel switch case which will be
    addressed in a future commit).
    
    Additionally, modify the ieee80211_check_combinations() function so
    that an undefined chandef can be passed, in order to use it before a
    channel is defined.
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6684c5d965d8..5bee6cc94b21 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -412,28 +412,6 @@ unsigned int
 cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
 			      const struct cfg80211_chan_def *chandef);
 
-static inline int
-cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
-			      struct wireless_dev *wdev,
-			      enum nl80211_iftype iftype)
-{
-	/* TODO: For this function, we'll probably need to keep some
-	 * kind of interface combination check in cfg80211...
-	 */
-	return cfg80211_can_use_iftype_chan(rdev, wdev, iftype, NULL,
-					    CHAN_MODE_UNDEFINED, 0);
-}
-
-static inline int
-cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
-			   enum nl80211_iftype iftype)
-{
-	if (rfkill_blocked(rdev->rfkill))
-		return -ERFKILL;
-
-	return cfg80211_can_change_interface(rdev, NULL, iftype);
-}
-
 static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 {
 	unsigned long end = jiffies;

commit 73de86a38962b18edad3205c2358599dd9c83e9f
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Thu Feb 13 11:31:59 2014 +0200

    cfg80211/mac80211: move interface counting for combination check to mac80211
    
    Move the counting part of the interface combination check from
    cfg80211 to mac80211.
    
    This is needed to simplify locking when the driver has to perform a
    combination check by itself (eg. with channel-switch).
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6f6f75609852..6684c5d965d8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -417,6 +417,9 @@ cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev,
 			      enum nl80211_iftype iftype)
 {
+	/* TODO: For this function, we'll probably need to keep some
+	 * kind of interface combination check in cfg80211...
+	 */
 	return cfg80211_can_use_iftype_chan(rdev, wdev, iftype, NULL,
 					    CHAN_MODE_UNDEFINED, 0);
 }
@@ -431,16 +434,6 @@ cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
 	return cfg80211_can_change_interface(rdev, NULL, iftype);
 }
 
-static inline int
-cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
-		      struct wireless_dev *wdev,
-		      struct ieee80211_channel *chan,
-		      enum cfg80211_chan_mode chanmode)
-{
-	return cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-					    chan, chanmode, 0);
-}
-
 static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 {
 	unsigned long end = jiffies;

commit 78f22b6a3a9254460d23060530b48ae02a9394e3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Mar 24 17:57:27 2014 +0100

    cfg80211: allow userspace to take ownership of interfaces
    
    When dynamically creating interfaces from userspace, e.g. for P2P usage,
    such interfaces are usually owned by the process that created them, i.e.
    wpa_supplicant. Should wpa_supplicant crash, such interfaces will often
    cease operating properly and cause problems on restarting the process.
    
    To avoid this problem, introduce an ownership concept for interfaces. If
    an interface is owned by a netlink socket, then it will be destroyed if
    the netlink socket is closed for any reason, including if the process it
    belongs to crashed. This gives us a race-free way to get rid of any such
    interfaces.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5b1fdcadd469..6f6f75609852 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -80,6 +80,10 @@ struct cfg80211_registered_device {
 
 	struct cfg80211_coalesce *coalesce;
 
+	spinlock_t destroy_list_lock;
+	struct list_head destroy_list;
+	struct work_struct destroy_work;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);
@@ -232,6 +236,13 @@ struct cfg80211_beacon_registration {
 	u32 nlportid;
 };
 
+struct cfg80211_iface_destroy {
+	struct list_head list;
+	u32 nlportid;
+};
+
+void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev);
+
 /* free object */
 void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
 

commit 73fb08e24ae840bc518facc2c605dd6bb3751fec
Author: Zhao, Gang <gamerh2o@gmail.com>
Date:   Wed Mar 19 17:04:36 2014 +0800

    cfg80211: remove macro ASSERT_RDEV_LOCK(rdev)
    
    Macro ASSERT_RDEV_LOCK(rdev) is equal to ASSERT_RTNL(), so replace it
    with ASSERT_RTNL() and remove it.
    
    Signed-off-by: Zhao, Gang <gamerh2o@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 579149d0ea34..5b1fdcadd469 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -166,7 +166,6 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
 	mutex_unlock(&wdev->mtx);
 }
 
-#define ASSERT_RDEV_LOCK(rdev) ASSERT_RTNL()
 #define ASSERT_WDEV_LOCK(wdev) lockdep_assert_held(&(wdev)->mtx)
 
 static inline bool cfg80211_has_monitors_only(struct cfg80211_registered_device *rdev)

commit 2316d7b0544c4601cc852c801c93d1f451378740
Author: Zhao, Gang <gamerh2o@gmail.com>
Date:   Sat Mar 8 11:01:24 2014 +0800

    cfg80211: make __cfg80211_join_ibss() static
    
    Function __cfg80211_join_ibss() is only used in net/wireless/ibss.c,
    so make it static.
    
    Signed-off-by: Zhao, Gang <gamerh2o@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3975ffa8feb2..579149d0ea34 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -246,10 +246,6 @@ void cfg80211_bss_age(struct cfg80211_registered_device *dev,
                       unsigned long age_secs);
 
 /* IBSS */
-int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
-			 struct net_device *dev,
-			 struct cfg80211_ibss_params *params,
-			 struct cfg80211_cached_keys *connkeys);
 int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
 		       struct cfg80211_ibss_params *params,

commit 7c8d5e03acc680eb433b0d5dbacbb6cc9db663a1
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Tue Feb 25 15:33:38 2014 +0200

    cfg80211: send stop AP event only due to internal reason
    
    Commit "nl80211: send event when AP operation is stopped" added an
    event to notify user space that an AP interface has been stopped, to
    handle cases such as suspend etc. The event is sent regardless
    if the stop AP flow was triggered by user space or due to internal state
    change.
    
    This might cause issues with wpa_supplicant/hostapd flows that consider
    stop AP flow as a synchronous one, e.g., AP/GO channel change in the
    absence of CSA support. In such cases, the flow will restart the AP
    immediately after the stop AP flow is done, and only handle the stop
    AP event after the current flow is done, and as a result stop the AP
    again.
    
    Change the current implementation to only send the event in case the
    stop AP was triggered due to an internal reason.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 64fde38c1a7e..3975ffa8feb2 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -283,7 +283,7 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 
 /* AP */
 int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
-		     struct net_device *dev);
+		     struct net_device *dev, bool notify);
 
 /* MLME */
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,

commit 31559f35c5724976fd975e5d7e90cdb693b8dd27
Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
Date:   Fri Feb 21 19:46:13 2014 +0100

    cfg80211: DFS get CAC time from regulatory database
    
    Send Channel Availability Check time as a parameter
    of start_radar_detection() callback.
    Get CAC time from regulatory database.
    
    Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 40683004d523..64fde38c1a7e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -402,6 +402,9 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
 
+unsigned int
+cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
+			      const struct cfg80211_chan_def *chandef);
 
 static inline int
 cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,

commit 0e028ab0fb2da47fd235dafd4159859892e73d08
Merge: e57f1734d87a 348f7d4adee9
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Feb 13 14:43:02 2014 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless

commit f9d15d162b3acf28f85b3ac05c4883e5ed588d28
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jan 22 11:14:19 2014 +0200

    cfg80211: send scan results from work queue
    
    Due to the previous commit, when a scan finishes, it is in theory
    possible to hit the following sequence:
     1. interface starts being removed
     2. scan is cancelled by driver and cfg80211 is notified
     3. scan done work is scheduled
     4. interface is removed completely, rdev->scan_req is freed,
        event sent to userspace but scan done work remains pending
     5. new scan is requested on another virtual interface
     6. scan done work runs, freeing the still-running scan
    
    To fix this situation, hang on to the scan done message and block
    new scans while that is the case, and only send the message from
    the work function, regardless of whether the scan_req is already
    freed from interface removal. This makes step 5 above impossible
    and changes step 6 to be
     5. scan done work runs, sending the scan done message
    
    As this can't work for wext, so we send the message immediately,
    but this shouldn't be an issue since we still return -EBUSY.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 37ec16d7bb1a..f1d193b557b6 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -62,6 +62,7 @@ struct cfg80211_registered_device {
 	struct rb_root bss_tree;
 	u32 bss_generation;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
+	struct sk_buff *scan_msg;
 	struct cfg80211_sched_scan_request *sched_scan_req;
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
@@ -361,7 +362,8 @@ int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
 				   bool pairwise, const u8 *mac_addr);
 void __cfg80211_scan_done(struct work_struct *wk);
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev);
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
+			   bool send_message);
 void __cfg80211_sched_scan_results(struct work_struct *wk);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 			       bool driver_initiated);

commit 9e0e29615a2077be852b1245b57c5b00fa609522
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed Jan 29 14:22:27 2014 +0100

    cfg80211: consider existing DFS interfaces
    
    It was possible to break interface combinations in
    the following way:
    
     combo 1: iftype = AP, num_ifaces = 2, num_chans = 2,
     combo 2: iftype = AP, num_ifaces = 1, num_chans = 1, radar = HT20
    
    With the above interface combinations it was
    possible to:
    
     step 1. start AP on DFS channel by matching combo 2
     step 2. start AP on non-DFS channel by matching combo 1
    
    This was possible beacuse (step 2) did not consider
    if other interfaces require radar detection.
    
    The patch changes how cfg80211 tracks channels -
    instead of channel itself now a complete chandef
    is stored.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 8a820f9c4a76..9895ab16c051 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -443,7 +443,8 @@ static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 void
 cfg80211_get_chan_state(struct wireless_dev *wdev,
 		        struct ieee80211_channel **chan,
-		        enum cfg80211_chan_mode *chanmode);
+		        enum cfg80211_chan_mode *chanmode,
+		        u8 *radar_detect);
 
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
 				 struct cfg80211_chan_def *chandef);

commit fe94f3a4ffaa20c7470038c69ffc8e545ef5f90a
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Wed Jan 29 17:53:43 2014 +0100

    cfg80211: fix channel configuration in IBSS join
    
    When receiving an IBSS_JOINED event select the BSS object
    based on the {bssid, channel} couple rather than the bssid
    only.
    With the current approach if another cell having the same
    BSSID (but using a different channel) exists then cfg80211
    picks up the wrong BSS object.
    The result is a mismatching channel configuration between
    cfg80211 and the driver, that can lead to any sort of
    problem.
    
    The issue can be triggered by having an IBSS sitting on
    given channel and then asking the driver to create a new
    cell using the same BSSID but with a different frequency.
    By passing the channel to cfg80211_get_bss() we can solve
    this ambiguity and retrieve/create the correct BSS object.
    All the users of cfg80211_ibss_joined() have been changed
    accordingly.
    
    Moreover WARN when cfg80211_ibss_joined() gets a NULL
    channel as argument and remove a bogus call of the same
    function in ath6kl (it does not make sense to call
    cfg80211_ibss_joined() with a zero BSSID on ibss-leave).
    
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Arend van Spriel <arend@broadcom.com>
    Cc: Bing Zhao <bzhao@marvell.com>
    Cc: Jussi Kivilinna <jussi.kivilinna@iki.fi>
    Cc: libertas-dev@lists.infradead.org
    Acked-by: Kalle Valo <kvalo@qca.qualcomm.com>
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    [minor code cleanup in ath6kl]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 37ec16d7bb1a..8a820f9c4a76 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -210,6 +210,7 @@ struct cfg80211_event {
 		} dc;
 		struct {
 			u8 bssid[ETH_ALEN];
+			struct ieee80211_channel *channel;
 		} ij;
 	};
 };
@@ -257,7 +258,8 @@ int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
-void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+			    struct ieee80211_channel *channel);
 int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 			    struct wireless_dev *wdev);
 

commit c4de673b775e4db48cd2db6277e0c6714332ca0c
Merge: bafdc614a1f4 55957fb7a0b6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Dec 16 11:23:45 2013 +0100

    Merge remote-tracking branch 'wireless-next/master' into mac80211-next

commit 4a58e7c38443154fce1b47910e1a9184f65c5d72
Author: Eliad Peller <eliad@wizery.com>
Date:   Thu Dec 5 18:30:17 2013 +0200

    cfg80211: don't "leak" uncompleted scans
    
    ___cfg80211_scan_done() can be called in some cases
    (e.g. on NETDEV_DOWN) before the low level driver
    notified scan completion (which is indicated by
    passing leak=true).
    
    Clearing rdev->scan_req in this case is buggy, as
    scan_done_wk might have already being queued/running
    (and can't be flushed as it takes rtnl()).
    
    If a new scan will be requested at this stage, the
    scan_done_wk will try freeing it (instead of the
    previous scan), and this will later result in
    a use after free.
    
    Simply remove the "leak" option, and replace it with
    a standard WARN_ON.
    
    An example backtrace after such crash:
    Unable to handle kernel paging request at virtual address fffffee5
    pgd = c0004000
    [fffffee5] *pgd=9fdf6821, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] SMP ARM
    PC is at cfg80211_scan_done+0x28/0xc4 [cfg80211]
    LR is at __ieee80211_scan_completed+0xe4/0x2dc [mac80211]
    [<bf0077b0>] (cfg80211_scan_done+0x28/0xc4 [cfg80211])
    [<bf0973d4>] (__ieee80211_scan_completed+0xe4/0x2dc [mac80211])
    [<bf0982cc>] (ieee80211_scan_work+0x94/0x4f0 [mac80211])
    [<c005fd10>] (process_one_work+0x1b0/0x4a8)
    [<c0060404>] (worker_thread+0x138/0x37c)
    [<c0066d70>] (kthread+0xa4/0xb0)
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ac77644cf894..453c6ed880f1 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -361,7 +361,7 @@ int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
 				   bool pairwise, const u8 *mac_addr);
 void __cfg80211_scan_done(struct work_struct *wk);
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev);
 void __cfg80211_sched_scan_results(struct work_struct *wk);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 			       bool driver_initiated);

commit ad7e718c9b4f717823fd920a0103f7b0fb06183f
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Nov 13 13:37:47 2013 +0100

    nl80211: vendor command support
    
    Add support for vendor-specific commands to nl80211. This is
    intended to be used for really vendor-specific functionality
    that can't be implemented in a generic fashion for any reason.
    It's *NOT* intended to be used for any normal/generic feature
    or any optimisations that could be implemented across drivers.
    
    Currently, only vendor commands (with replies) are supported,
    no dump operations or vendor-specific notifications.
    
    Also add a function wdev_to_ieee80211_vif() to mac80211 which
    is needed for mac80211-based drivers wanting to implement any
    vendor commands.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6716c5c3f748..ac77644cf894 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -67,9 +67,7 @@ struct cfg80211_registered_device {
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;
 
-#ifdef CONFIG_NL80211_TESTMODE
-	struct genl_info *testmode_info;
-#endif
+	struct genl_info *cur_cmd_info;
 
 	struct work_struct conn_work;
 	struct work_struct event_work;

commit 4b074b07625f603d40d4d04937f8874a00415dc4
Merge: 7d68849f40cd ddcc347b70f2
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Dec 2 14:25:38 2013 -0500

    Merge branch 'for-john' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next

commit b176e629402f41f2b984d3aa842ddae23ed5562e
Author: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
Date:   Mon Nov 18 19:06:49 2013 +0200

    cfg80211: aggregate mgmt_tx parameters into a struct
    
    Change cfg80211 and mac80211 to use cfg80211_mgmt_tx_params
    struct to aggregate parameters for mgmt_tx functions.
    This makes the functions' signatures less clumsy and allows
    less painful parameters extension.
    
    Signed-off-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
    [fix all other drivers]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2888867ee7c5..6716c5c3f748 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -317,9 +317,8 @@ void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  struct wireless_dev *wdev,
-			  struct ieee80211_channel *chan, bool offchan,
-			  unsigned int wait, const u8 *buf, size_t len,
-			  bool no_cck, bool dont_wait_for_ack, u64 *cookie);
+			  struct cfg80211_mgmt_tx_params *params,
+			  u64 *cookie);
 void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
 			       const struct ieee80211_ht_cap *ht_capa_mask);
 void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,

commit fe7c3a1f20a419d86d3f90316d8efc2d04f3f0ed
Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
Date:   Tue Nov 5 14:48:48 2013 +0100

    cfg80211: DFS check chandef usable before CAC
    
    Check chandef we get in CAC request is usable for CAC.
    All channels have to be DFS channels. Allow DFS_USABLE
    and DFS_AVAILABLE channels mix. At least one channel
    has to be DFS_USABLE (require CAC).
    
    Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index eb0f7a3a25a9..2888867ee7c5 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -382,6 +382,19 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 enum cfg80211_chan_mode chanmode,
 				 u8 radar_detect);
 
+/**
+ * cfg80211_chandef_dfs_usable - checks if chandef is DFS usable
+ * @wiphy: the wiphy to validate against
+ * @chandef: the channel definition to check
+ *
+ * Checks if chandef is usable and we can/need start CAC on such channel.
+ *
+ * Return: Return true if all channels available and at least
+ *	   one channel require CAC (NL80211_DFS_USABLE)
+ */
+bool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,
+				 const struct cfg80211_chan_def *chandef);
+
 void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    const struct cfg80211_chan_def *chandef,
 			    enum nl80211_dfs_state dfs_state);

commit 01925efdf7e03b4b803b5c9f985163d687f7f017
Merge: a1b13b9ad375 8ce9beac4661
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Nov 4 14:45:14 2013 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless
    
    Conflicts:
            drivers/net/wireless/iwlwifi/pcie/drv.c

commit c3fa32b9764dc45dcf8a2231b1c110abc4a63e0b
Merge: 34d92d5315b6 320437af954c
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Oct 23 16:28:39 2013 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/usb/qmi_wwan.c
            include/net/dst.h
    
    Trivial merge conflicts, both were overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c1b1203d65955c179fec617ff17a21273f33a414
Author: Joe Perches <joe@perches.com>
Date:   Fri Oct 18 13:48:25 2013 -0700

    net: misc: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b43efac4efca..74beff1e926f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -234,10 +234,10 @@ struct cfg80211_beacon_registration {
 };
 
 /* free object */
-extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
+void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
 
-extern int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
-			       char *newname);
+int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
+			char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 

commit f38dd58ccca0d612e62509f75e99952dcf316cb2
Author: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
Date:   Tue Sep 17 15:20:13 2013 +0300

    cfg80211: don't add p2p device while in RFKILL
    
    Since P2P device doesn't have a netdev associated to it,
    we cannot prevent the user to start it when in RFKILL.
    So refuse to even add it when in RFKILL.
    
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 9ad43c619c54..3159e9c284c5 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -411,6 +411,9 @@ static inline int
 cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
 			   enum nl80211_iftype iftype)
 {
+	if (rfkill_blocked(rdev->rfkill))
+		return -ERFKILL;
+
 	return cfg80211_can_change_interface(rdev, NULL, iftype);
 }
 

commit 774f073461dbee0decee7524d9b930a98a3dc30c
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Wed Aug 28 13:41:28 2013 +0200

    cfg80211: export cfg80211_chandef_dfs_required
    
    It will be used later by the IBSS CSA implementation of mac80211.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Mathias Kretschmer <mathias.kretschmer@fokus.fraunhofer.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 9ad43c619c54..b43efac4efca 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -382,15 +382,6 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 enum cfg80211_chan_mode chanmode,
 				 u8 radar_detect);
 
-/**
- * cfg80211_chandef_dfs_required - checks if radar detection is required
- * @wiphy: the wiphy to validate against
- * @chandef: the channel definition to check
- * Return: 1 if radar detection is required, 0 if it is not, < 0 on error
- */
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
-				  const struct cfg80211_chan_def *c);
-
 void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    const struct cfg80211_chan_def *chandef,
 			    enum nl80211_dfs_state dfs_state);

commit be29b99a9b51b0338eea3c66a58de53bbd01de24
Author: Amitkumar Karwar <akarwar@marvell.com>
Date:   Fri Jun 28 11:51:26 2013 -0700

    cfg80211/nl80211: Add packet coalesce support
    
    In most cases, host that receives IPv4 and IPv6 multicast/broadcast
    packets does not do anything with these packets. Therefore the
    reception of these unwanted packets causes unnecessary processing
    and power consumption.
    
    Packet coalesce feature helps to reduce number of received
    interrupts to host by buffering these packets in firmware/hardware
    for some predefined time. Received interrupt will be generated when
    one of the following events occur.
    a) Expiration of hardware timer whose expiration time is set to
    maximum coalescing delay of matching coalesce rule.
    b) Coalescing buffer in hardware reaches it's limit.
    c) Packet doesn't match any of the configured coalesce rules.
    
    This patch adds set/get configuration support for packet coalesce.
    User needs to configure following parameters for creating a coalesce
    rule.
    a) Maximum coalescing delay
    b) List of packet patterns which needs to be matched
    c) Condition for coalescence. pattern 'match' or 'no match'
    Multiple such rules can be created.
    
    This feature needs to be advertised during driver initialization.
    Drivers are supposed to do required firmware/hardware settings based
    on user configuration.
    
    Signed-off-by: Amitkumar Karwar <akarwar@marvell.com>
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    [fix kernel-doc, change free function, fix copy/paste error]
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a6b45bf00f33..9ad43c619c54 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -79,6 +79,8 @@ struct cfg80211_registered_device {
 	/* netlink port which started critical protocol (0 means not started) */
 	u32 crit_proto_nlportid;
 
+	struct cfg80211_coalesce *coalesce;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);

commit ceca7b7121795ef81bd598a240d53a925662d0c1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu May 16 00:55:45 2013 +0200

    cfg80211: separate internal SME implementation
    
    The current internal SME implementation in cfg80211 is
    very mixed up with the MLME handling, which has been
    causing issues for a long time. There are three things
    that the implementation has to provide:
     * a basic SME implementation for nl80211's connect()
       call (for drivers implementing auth/assoc, which is
       really just mac80211) and wireless extensions
     * MLME events for the userspace SME
     * SME events (connected, disconnected etc.) for all
       different SME implementation possibilities (driver,
       cfg80211 and userspace)
    
    To achieve these goals it isn't necessary to track the
    software SME's connection status outside of it's state
    (which is the part that caused many issues.) Instead,
    track it only in the SME data (wdev->conn) and in the
    general case only track whether the wdev is connected
    or not (via wdev->current_bss.)
    
    Also separate the internal implementation to not have
    callbacks from the SME events, but rather call it from
    the API functions that the driver (or rather mac80211)
    calls. This separates the code better.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a65eaf8a84c1..a6b45bf00f33 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -308,11 +308,6 @@ int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 			   bool local_state_change);
 void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
-void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
-			       const u8 *req_ie, size_t req_ie_len,
-			       const u8 *resp_ie, size_t resp_ie_len,
-			       u16 status, bool wextev,
-			       struct cfg80211_bss *bss);
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 				u16 frame_type, const u8 *match_data,
 				int match_len);
@@ -328,12 +323,19 @@ void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
 void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,
 				const struct ieee80211_vht_cap *vht_capa_mask);
 
-/* SME */
+/* SME events */
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
 		     struct cfg80211_connect_params *connect,
 		     struct cfg80211_cached_keys *connkeys,
 		     const u8 *prev_bssid);
+void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+			       const u8 *req_ie, size_t req_ie_len,
+			       const u8 *resp_ie, size_t resp_ie_len,
+			       u16 status, bool wextev,
+			       struct cfg80211_bss *bss);
+void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
+			     size_t ie_len, u16 reason, bool from_ap);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
@@ -344,21 +346,21 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 
+/* SME implementation */
 void cfg80211_conn_work(struct work_struct *work);
-void cfg80211_sme_failed_assoc(struct wireless_dev *wdev);
-bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
+void cfg80211_sme_scan_done(struct net_device *dev);
+bool cfg80211_sme_rx_assoc_resp(struct wireless_dev *wdev, u16 status);
+void cfg80211_sme_rx_auth(struct wireless_dev *wdev, const u8 *buf, size_t len);
+void cfg80211_sme_disassoc(struct wireless_dev *wdev);
+void cfg80211_sme_deauth(struct wireless_dev *wdev);
+void cfg80211_sme_auth_timeout(struct wireless_dev *wdev);
+void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev);
 
 /* internal helpers */
 bool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher);
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
 				   bool pairwise, const u8 *mac_addr);
-void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
-			     size_t ie_len, u16 reason, bool from_ap);
-void cfg80211_sme_scan_done(struct net_device *dev);
-void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
-void cfg80211_sme_disassoc(struct net_device *dev,
-			   struct cfg80211_internal_bss *bss);
 void __cfg80211_scan_done(struct work_struct *wk);
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
 void __cfg80211_sched_scan_results(struct work_struct *wk);

commit 6abb9cb99f33b20c2f32f18a3ae9cc7543e46edb
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 15 09:30:07 2013 +0200

    cfg80211: make WoWLAN configuration available to drivers
    
    Make the current WoWLAN configuration available to drivers
    at runtime. This isn't really useful for the normal WoWLAN
    behaviour and accessing it can also be racy, but drivers
    may use it for testing the WoWLAN device behaviour while
    the host stays up & running to observe the device.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b4b4a566626b..a65eaf8a84c1 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -74,8 +74,6 @@ struct cfg80211_registered_device {
 	struct work_struct conn_work;
 	struct work_struct event_work;
 
-	struct cfg80211_wowlan *wowlan;
-
 	struct delayed_work dfs_update_channels_wk;
 
 	/* netlink port which started critical protocol (0 means not started) */
@@ -96,17 +94,20 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 static inline void
 cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 {
+#ifdef CONFIG_PM
 	int i;
 
-	if (!rdev->wowlan)
+	if (!rdev->wiphy.wowlan_config)
 		return;
-	for (i = 0; i < rdev->wowlan->n_patterns; i++)
-		kfree(rdev->wowlan->patterns[i].mask);
-	kfree(rdev->wowlan->patterns);
-	if (rdev->wowlan->tcp && rdev->wowlan->tcp->sock)
-		sock_release(rdev->wowlan->tcp->sock);
-	kfree(rdev->wowlan->tcp);
-	kfree(rdev->wowlan);
+	for (i = 0; i < rdev->wiphy.wowlan_config->n_patterns; i++)
+		kfree(rdev->wiphy.wowlan_config->patterns[i].mask);
+	kfree(rdev->wiphy.wowlan_config->patterns);
+	if (rdev->wiphy.wowlan_config->tcp &&
+	    rdev->wiphy.wowlan_config->tcp->sock)
+		sock_release(rdev->wiphy.wowlan_config->tcp->sock);
+	kfree(rdev->wiphy.wowlan_config->tcp);
+	kfree(rdev->wiphy.wowlan_config);
+#endif
 }
 
 extern struct workqueue_struct *cfg80211_wq;

commit 83739b03de97049181d711c95200b94a14d3f693
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 15 17:44:01 2013 +0200

    cfg80211: remove some locked wrappers from sme API
    
    By making all the API functions require wdev locking we
    can clean up the API a bit, getting rid of the locking
    version of each function. This also decreases the size
    of cfg80211 by a small amount.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c8f87dfd50d3..b4b4a566626b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -328,18 +328,11 @@ void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,
 				const struct ieee80211_vht_cap *vht_capa_mask);
 
 /* SME */
-int __cfg80211_connect(struct cfg80211_registered_device *rdev,
-		       struct net_device *dev,
-		       struct cfg80211_connect_params *connect,
-		       struct cfg80211_cached_keys *connkeys,
-		       const u8 *prev_bssid);
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
 		     struct cfg80211_connect_params *connect,
-		     struct cfg80211_cached_keys *connkeys);
-int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
-			  struct net_device *dev, u16 reason,
-			  bool wextev);
+		     struct cfg80211_cached_keys *connkeys,
+		     const u8 *prev_bssid);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);

commit 91bf9b26fc95c505846bc2f744a73b51f2aaee1d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 15 17:44:01 2013 +0200

    cfg80211: remove some locked wrappers from mlme API
    
    By making all the API functions require wdev locking we
    can clean up the API a bit, getting rid of the locking
    version of each function. This also decreases the size
    of cfg80211 by a small amount.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d21a0fc01401..c8f87dfd50d3 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -282,38 +282,21 @@ int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev);
 
 /* MLME */
-int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-			 struct net_device *dev,
-			 struct ieee80211_channel *chan,
-			 enum nl80211_auth_type auth_type,
-			 const u8 *bssid,
-			 const u8 *ssid, int ssid_len,
-			 const u8 *ie, int ie_len,
-			 const u8 *key, int key_len, int key_idx,
-			 const u8 *sae_data, int sae_data_len);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-		       struct net_device *dev, struct ieee80211_channel *chan,
-		       enum nl80211_auth_type auth_type, const u8 *bssid,
+		       struct net_device *dev,
+		       struct ieee80211_channel *chan,
+		       enum nl80211_auth_type auth_type,
+		       const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len,
 		       const u8 *key, int key_len, int key_idx,
 		       const u8 *sae_data, int sae_data_len);
-int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
-			  struct net_device *dev,
-			  struct ieee80211_channel *chan,
-			  const u8 *bssid,
-			  const u8 *ssid, int ssid_len,
-			  struct cfg80211_assoc_request *req);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev,
 			struct ieee80211_channel *chan,
 			const u8 *bssid,
 			const u8 *ssid, int ssid_len,
 			struct cfg80211_assoc_request *req);
-int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
-			   struct net_device *dev, const u8 *bssid,
-			   const u8 *ie, int ie_len, u16 reason,
-			   bool local_state_change);
 int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev, const u8 *bssid,
 			 const u8 *ie, int ie_len, u16 reason,

commit 5fe231e873729fa2f57cdc417d5c1f80871e2d7d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 8 21:45:15 2013 +0200

    cfg80211: vastly simplify locking
    
    Virtually all code paths in cfg80211 already (need to) hold
    the RTNL. As such, there's little point in having another
    four mutexes for various parts of the code, they just cause
    lock ordering issues (and much of the time, the RTNL and a
    few of the others need thus be held.)
    
    Simplify all this by getting rid of the extra four mutexes
    and just use the RTNL throughout. Only a few code changes
    were needed to do this and we can get rid of a work struct
    for bonus points.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 95b29075a9c8..d21a0fc01401 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -5,7 +5,6 @@
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
-#include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
 #include <linux/rbtree.h>
@@ -23,11 +22,6 @@
 struct cfg80211_registered_device {
 	const struct cfg80211_ops *ops;
 	struct list_head list;
-	/* we hold this mutex during any call so that
-	 * we cannot do multiple calls at once, and also
-	 * to avoid the deregister call to proceed while
-	 * any call is in progress */
-	struct mutex mtx;
 
 	/* rfkill support */
 	struct rfkill_ops rfkill_ops;
@@ -49,9 +43,7 @@ struct cfg80211_registered_device {
 	/* wiphy index, internal only */
 	int wiphy_idx;
 
-	/* associated wireless interfaces */
-	struct mutex devlist_mtx;
-	/* protected by devlist_mtx or RCU */
+	/* associated wireless interfaces, protected by rtnl or RCU */
 	struct list_head wdev_list;
 	int devlist_generation, wdev_id;
 	int opencount; /* also protected by devlist_mtx */
@@ -75,8 +67,6 @@ struct cfg80211_registered_device {
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;
 
-	struct mutex sched_scan_mtx;
-
 #ifdef CONFIG_NL80211_TESTMODE
 	struct genl_info *testmode_info;
 #endif
@@ -120,15 +110,9 @@ cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 }
 
 extern struct workqueue_struct *cfg80211_wq;
-extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_rdev_list;
 extern int cfg80211_rdev_list_generation;
 
-static inline void assert_cfg80211_lock(void)
-{
-	lockdep_assert_held(&cfg80211_mutex);
-}
-
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct list_head hidden_list;
@@ -161,23 +145,11 @@ static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
-/* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 
 int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 			  struct net *net);
 
-static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *rdev)
-{
-	mutex_lock(&rdev->mtx);
-}
-
-static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *rdev)
-{
-	BUG_ON(IS_ERR(rdev) || !rdev);
-	mutex_unlock(&rdev->mtx);
-}
-
 static inline void wdev_lock(struct wireless_dev *wdev)
 	__acquires(wdev)
 {
@@ -192,7 +164,7 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
 	mutex_unlock(&wdev->mtx);
 }
 
-#define ASSERT_RDEV_LOCK(rdev) lockdep_assert_held(&(rdev)->mtx)
+#define ASSERT_RDEV_LOCK(rdev) ASSERT_RTNL()
 #define ASSERT_WDEV_LOCK(wdev) lockdep_assert_held(&(wdev)->mtx)
 
 static inline bool cfg80211_has_monitors_only(struct cfg80211_registered_device *rdev)

commit 9f419f3851041e0c8170629f0639813dbfc79d5e
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 8 21:34:22 2013 +0200

    cfg80211: move cfg80211_get_dev_from_ifindex under wext
    
    The function is only used and needed by the wext code
    for scanning, so move it there.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fd35dae547c4..95b29075a9c8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -164,10 +164,6 @@ int get_wiphy_idx(struct wiphy *wiphy);
 /* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 
-/* identical to cfg80211_get_dev_from_info but only operate on ifindex */
-extern struct cfg80211_registered_device *
-cfg80211_get_dev_from_ifindex(struct net *net, int ifindex);
-
 int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 			  struct net *net);
 

commit 5de17984898c5758fc6ebe08eccea9f4b6548914
Author: Arend van Spriel <arend@broadcom.com>
Date:   Thu Apr 18 15:49:00 2013 +0200

    cfg80211: introduce critical protocol indication from user-space
    
    Some protocols need a more reliable connection to complete
    successful in reasonable time. This patch adds a user-space
    API to indicate the wireless driver that a critical protocol
    is about to commence and when it is done, using nl80211 primitives
    NL80211_CMD_CRIT_PROTOCOL_START and NL80211_CRIT_PROTOCOL_STOP.
    
    There can be only on critical protocol session started per
    registered cfg80211 device.
    
    The driver can support this by implementing the cfg80211 callbacks
    .crit_proto_start() and .crit_proto_stop(). Examples of protocols
    that can benefit from this are DHCP, EAPOL, APIPA. Exactly how the
    link can/should be made more reliable is up to the driver. Things
    to consider are avoid scanning, no multi-channel operations, and
    alter coexistence schemes.
    
    Reviewed-by: Pieter-Paul Giesberts <pieterpg@broadcom.com>
    Reviewed-by: Franky (Zhenhui) Lin <frankyl@broadcom.com>
    Signed-off-by: Arend van Spriel <arend@broadcom.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 124e5e773fbc..fd35dae547c4 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -88,6 +88,9 @@ struct cfg80211_registered_device {
 
 	struct delayed_work dfs_update_channels_wk;
 
+	/* netlink port which started critical protocol (0 means not started) */
+	u32 crit_proto_nlportid;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);

commit 9a574cd67a447059f9c14bbef47873315d7f7b35
Merge: 689b66cb53fb 2e1253d640eb
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Mar 29 16:41:36 2013 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless
    
    Conflicts:
            net/mac80211/sta_info.c
            net/wireless/core.h

commit f9f475292dbb0e7035fb6661d1524761ea0888d9
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Mar 19 15:04:07 2013 +0100

    cfg80211: always check for scan end on P2P device
    
    If a P2P device wdev is removed while it has a scan, then the
    scan completion might crash later as it is already freed by
    that time. To avoid the crash always check the scan completion
    when the P2P device is being removed for some reason. If the
    driver already canceled it, don't want and free it, otherwise
    warn and leak it to avoid later crashes.
    
    In order to do this, locking needs to be changed away from the
    rdev mutex (which can't always be guaranteed). For now, use
    the sched_scan_mtx instead, I'll rename it to just scan_mtx in
    a later patch.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3aec0e429d8a..5845c2b37aa8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -503,6 +503,9 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
+void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev);
+
 #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
 
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS

commit 8125696991194aacb1173b6e8196d19098b44e17
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Thu Feb 28 10:55:25 2013 +0100

    cfg80211/mac80211: disconnect on suspend
    
    If possible that after suspend, cfg80211 will receive request to
    disconnect what require action on interface that was removed during
    suspend.
    
    Problem can manifest itself by various warnings similar to below one:
    
    WARNING: at net/mac80211/driver-ops.h:12 ieee80211_bss_info_change_notify+0x2f9/0x300 [mac80211]()
    wlan0:  Failed check-sdata-in-driver check, flags: 0x4
    Call Trace:
     [<c043e0b3>] warn_slowpath_fmt+0x33/0x40
     [<f83707c9>] ieee80211_bss_info_change_notify+0x2f9/0x300 [mac80211]
     [<f83a660a>] ieee80211_recalc_ps_vif+0x2a/0x30 [mac80211]
     [<f83a6706>] ieee80211_set_disassoc+0xf6/0x500 [mac80211]
     [<f83a9441>] ieee80211_mgd_deauth+0x1f1/0x280 [mac80211]
     [<f8381b36>] ieee80211_deauth+0x16/0x20 [mac80211]
     [<f8261e70>] cfg80211_mlme_down+0x70/0xc0 [cfg80211]
     [<f8264de1>] __cfg80211_disconnect+0x1b1/0x1d0 [cfg80211]
    
    To fix the problem disconnect from any associated network before
    suspend. User space is responsible to establish connection again
    after resume. This basically need to be done by user space anyway,
    because associated stations can go away during suspend (for example
    NetworkManager disconnects on suspend and connect on resume by default).
    
    Patch also handle situation when driver refuse to suspend with wowlan
    configured and try to suspend again without it.
    
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 9a2be8ddac5f..d5d06fdea961 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -500,6 +500,9 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
+void cfg80211_leave(struct cfg80211_registered_device *rdev,
+		    struct wireless_dev *wdev);
+
 #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
 
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS

commit f62fab735e99af2190eba03f565adaca5c002882
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 21 20:09:09 2013 +0100

    cfg80211: refactor association parameters
    
    cfg80211_mlme_assoc() has grown far too many arguments,
    make the caller build almost all of the driver struct
    and pass that to the function instead.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c2f94f22bb22..9a2be8ddac5f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -330,24 +330,15 @@ int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
 			  struct ieee80211_channel *chan,
-			  const u8 *bssid, const u8 *prev_bssid,
+			  const u8 *bssid,
 			  const u8 *ssid, int ssid_len,
-			  const u8 *ie, int ie_len, bool use_mfp,
-			  struct cfg80211_crypto_settings *crypt,
-			  u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
-			  struct ieee80211_ht_cap *ht_capa_mask,
-			  struct ieee80211_vht_cap *vht_capa,
-			  struct ieee80211_vht_cap *vht_capa_mask);
+			  struct cfg80211_assoc_request *req);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
-			struct net_device *dev, struct ieee80211_channel *chan,
-			const u8 *bssid, const u8 *prev_bssid,
+			struct net_device *dev,
+			struct ieee80211_channel *chan,
+			const u8 *bssid,
 			const u8 *ssid, int ssid_len,
-			const u8 *ie, int ie_len, bool use_mfp,
-			struct cfg80211_crypto_settings *crypt,
-			u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
-			struct ieee80211_ht_cap *ht_capa_mask,
-			struct ieee80211_vht_cap *vht_capa,
-			struct ieee80211_vht_cap *vht_capa_mask);
+			struct cfg80211_assoc_request *req);
 int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			   struct net_device *dev, const u8 *bssid,
 			   const u8 *ie, int ie_len, u16 reason,

commit ee2aca343c9aa64d277a75a5df043299dc84cfd9
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 21 17:36:01 2013 +0100

    cfg80211: add ability to override VHT capabilities
    
    For testing it's sometimes useful to be able to
    override certain VHT capability advertisement,
    add the ability to do that in cfg80211.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3aec0e429d8a..c2f94f22bb22 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -335,7 +335,9 @@ int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  const u8 *ie, int ie_len, bool use_mfp,
 			  struct cfg80211_crypto_settings *crypt,
 			  u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
-			  struct ieee80211_ht_cap *ht_capa_mask);
+			  struct ieee80211_ht_cap *ht_capa_mask,
+			  struct ieee80211_vht_cap *vht_capa,
+			  struct ieee80211_vht_cap *vht_capa_mask);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, struct ieee80211_channel *chan,
 			const u8 *bssid, const u8 *prev_bssid,
@@ -343,7 +345,9 @@ int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			const u8 *ie, int ie_len, bool use_mfp,
 			struct cfg80211_crypto_settings *crypt,
 			u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
-			struct ieee80211_ht_cap *ht_capa_mask);
+			struct ieee80211_ht_cap *ht_capa_mask,
+			struct ieee80211_vht_cap *vht_capa,
+			struct ieee80211_vht_cap *vht_capa_mask);
 int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			   struct net_device *dev, const u8 *bssid,
 			   const u8 *ie, int ie_len, u16 reason,
@@ -375,6 +379,8 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  bool no_cck, bool dont_wait_for_ack, u64 *cookie);
 void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
 			       const struct ieee80211_ht_cap *ht_capa_mask);
+void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,
+				const struct ieee80211_vht_cap *vht_capa_mask);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 04f39047af2a6df64b763ea5a271db24879d0391
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Fri Feb 8 18:16:19 2013 +0100

    nl80211/cfg80211: add radar detection command/event
    
    Add new NL80211_CMD_RADAR_DETECT, which starts the Channel
    Availability Check (CAC). This command will also notify the
    usermode about events (CAC finished, CAC aborted, radar
    detected, NOP finished).
    Once radar detection has started it should continuously
    monitor for radars as long as the channel is active.
    
    This patch enables DFS for AP mode in nl80211/cfg80211.
    
    Based on original patch by Victor Goldenshtein <victorg@ti.com>
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    [remove WIPHY_FLAG_HAS_RADAR_DETECT again -- my mistake]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 949c9573d8d7..3aec0e429d8a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -86,6 +86,8 @@ struct cfg80211_registered_device {
 
 	struct cfg80211_wowlan *wowlan;
 
+	struct delayed_work dfs_update_channels_wk;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);
@@ -431,6 +433,22 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 enum cfg80211_chan_mode chanmode,
 				 u8 radar_detect);
 
+/**
+ * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * @wiphy: the wiphy to validate against
+ * @chandef: the channel definition to check
+ * Return: 1 if radar detection is required, 0 if it is not, < 0 on error
+ */
+int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+				  const struct cfg80211_chan_def *c);
+
+void cfg80211_set_dfs_state(struct wiphy *wiphy,
+			    const struct cfg80211_chan_def *chandef,
+			    enum nl80211_dfs_state dfs_state);
+
+void cfg80211_dfs_channels_update_work(struct work_struct *work);
+
+
 static inline int
 cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev,
@@ -457,6 +475,16 @@ cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
 					    chan, chanmode, 0);
 }
 
+static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
+{
+	unsigned long end = jiffies;
+
+	if (end >= start)
+		return jiffies_to_msecs(end - start);
+
+	return jiffies_to_msecs(end + (MAX_JIFFY_OFFSET - start) + 1);
+}
+
 void
 cfg80211_get_chan_state(struct wireless_dev *wdev,
 		        struct ieee80211_channel **chan,

commit 2a0e047ed62f20664005881b8e7f9328f910316a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jan 23 22:57:40 2013 +0100

    cfg80211: configuration for WoWLAN over TCP
    
    Intel Wireless devices are able to make a TCP connection
    after suspending, sending some data and waking up when
    the connection receives wakeup data (or breaks). Add the
    WoWLAN configuration and feature advertising API for it.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 37d70dc2fe82..949c9573d8d7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -108,6 +108,9 @@ cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 	for (i = 0; i < rdev->wowlan->n_patterns; i++)
 		kfree(rdev->wowlan->patterns[i].mask);
 	kfree(rdev->wowlan->patterns);
+	if (rdev->wowlan->tcp && rdev->wowlan->tcp->sock)
+		sock_release(rdev->wowlan->tcp->sock);
+	kfree(rdev->wowlan->tcp);
 	kfree(rdev->wowlan);
 }
 

commit 776b3580178f2065838fa0db0eb7a41b57495c0a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 1 02:06:18 2013 +0100

    cfg80211: track hidden SSID networks properly
    
    Currently, cfg80211 will copy beacon IEs from a previously
    received hidden SSID beacon to a probe response entry, if
    that entry is created after the beacon entry. However, if
    it is the other way around, or if the beacon is updated,
    such changes aren't propagated.
    
    Fix this by tracking the relation between the probe
    response and beacon BSS structs in this case.
    
    In case drivers have private data stored in a BSS struct
    and need access to such data from a beacon entry, cfg80211
    now provides the hidden_beacon_bss pointer from the probe
    response entry to the beacon entry.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 8396f7671c8d..37d70dc2fe82 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -8,7 +8,6 @@
 #include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
-#include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <linux/debugfs.h>
 #include <linux/rfkill.h>
@@ -124,9 +123,10 @@ static inline void assert_cfg80211_lock(void)
 
 struct cfg80211_internal_bss {
 	struct list_head list;
+	struct list_head hidden_list;
 	struct rb_node rbn;
 	unsigned long ts;
-	struct kref ref;
+	unsigned long refcount;
 	atomic_t hold;
 
 	/* must be last because of priv member */

commit 11c4a075db2f8774d37544342c8cb9752b4db9e1
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Tue Jan 8 14:04:07 2013 +0100

    cfg80211: check radar interface combinations
    
    To ease further DFS development regarding interface combinations, use
    the interface combinations structure to test for radar capabilities.
    Drivers can specify which channel widths they support, and in which
    modes. Right now only a single AP interface is allowed, but as the
    DFS code evolves other combinations can be enabled.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f342267e3620..8396f7671c8d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -425,7 +425,8 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 struct wireless_dev *wdev,
 				 enum nl80211_iftype iftype,
 				 struct ieee80211_channel *chan,
-				 enum cfg80211_chan_mode chanmode);
+				 enum cfg80211_chan_mode chanmode,
+				 u8 radar_detect);
 
 static inline int
 cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
@@ -433,7 +434,7 @@ cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
 			      enum nl80211_iftype iftype)
 {
 	return cfg80211_can_use_iftype_chan(rdev, wdev, iftype, NULL,
-					    CHAN_MODE_UNDEFINED);
+					    CHAN_MODE_UNDEFINED, 0);
 }
 
 static inline int
@@ -450,7 +451,7 @@ cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
 		      enum cfg80211_chan_mode chanmode)
 {
 	return cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-					    chan, chanmode);
+					    chan, chanmode, 0);
 }
 
 void

commit 1c06ef9831c78648f719a174e4598ae2600b0cf7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Dec 28 12:22:02 2012 +0100

    wireless: use __aligned
    
    Use __aligned(...) instead of __attribute__((aligned(...)))
    in mac80211 and cfg80211.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b8f4630c6ada..f342267e3620 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -89,7 +89,7 @@ struct cfg80211_registered_device {
 
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
-	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));
+	struct wiphy wiphy __aligned(NETDEV_ALIGN);
 };
 
 static inline

commit f41737669d2f4c07c09e90767498243e142171f9
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Dec 3 18:23:37 2012 +0100

    cfg80211: remove wiphy_idx_valid
    
    This is pretty much useless since get_wiphy_idx()
    always returns true since it's always called with
    a valid wiphy pointer.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3563097169cb..b8f4630c6ada 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -18,6 +18,9 @@
 #include <net/cfg80211.h>
 #include "reg.h"
 
+
+#define WIPHY_IDX_INVALID	-1
+
 struct cfg80211_registered_device {
 	const struct cfg80211_ops *ops;
 	struct list_head list;
@@ -96,13 +99,6 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 	return container_of(wiphy, struct cfg80211_registered_device, wiphy);
 }
 
-/* Note 0 is valid, hence phy0 */
-static inline
-bool wiphy_idx_valid(int wiphy_idx)
-{
-	return wiphy_idx >= 0;
-}
-
 static inline void
 cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 {
@@ -126,12 +122,6 @@ static inline void assert_cfg80211_lock(void)
 	lockdep_assert_held(&cfg80211_mutex);
 }
 
-/*
- * You can use this to mark a wiphy_idx as not having an associated wiphy.
- * It guarantees cfg80211_rdev_by_wiphy_idx(wiphy_idx) will return NULL
- */
-#define WIPHY_IDX_STALE -1
-
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct rb_node rbn;

commit 9caf03640279e64d0ba36539b42daa1b43a49486
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 29 01:25:20 2012 +0100

    cfg80211: fix BSS struct IE access races
    
    When a BSS struct is updated, the IEs are currently
    overwritten or freed. This can lead to races if some
    other CPU is accessing the BSS struct and using the
    IEs concurrently.
    
    Fix this by always allocating the IEs in a new struct
    that holds the data and length and protecting access
    to this new struct with RCU.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6183a0d25b8b..3563097169cb 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -138,8 +138,6 @@ struct cfg80211_internal_bss {
 	unsigned long ts;
 	struct kref ref;
 	atomic_t hold;
-	bool beacon_ies_allocated;
-	bool proberesp_ies_allocated;
 
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;

commit 9f5e8f6efc7c2601136b27d9c7325c245f8fd19a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 22 16:59:45 2012 +0100

    cfg80211: rework chandef checking and export it
    
    Some of the chandef checking that we do in cfg80211
    to check if a channel is supported or not is also
    needed in mac80211, so rework that a bit and export
    the functions that are needed.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a0c8decf6a47..6183a0d25b8b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -483,12 +483,6 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
-bool cfg80211_chan_def_valid(const struct cfg80211_chan_def *chandef);
-
-bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,
-				 u32 center_freq, u32 bandwidth,
-				 u32 prohibited_flags);
-
 #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
 
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS

commit 3d9d1d6656a73ea8407734cfb00b81d14ef62d4b
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 8 23:14:50 2012 +0100

    nl80211/cfg80211: support VHT channel configuration
    
    Change nl80211 to support specifying a VHT (or HT)
    using the control channel frequency (as before) and
    new attributes for the channel width and first and
    second center frequency. The old channel type is of
    course still supported for HT.
    
    Also change the cfg80211 channel definition struct
    to support these by adding the relevant fields to
    it (and removing the _type field.)
    
    This also adds new helper functions:
     - cfg80211_chandef_create to create a channel def
       struct given the control channel and channel type,
     - cfg80211_chandef_identical to check if two channel
       definitions are identical
     - cfg80211_chandef_compatible to check if the given
       channel definitions are compatible, and return the
       wider of the two
    
    This isn't entirely complete, but that doesn't matter
    until we have a driver using it. In particular, it's
    missing
     - regulatory checks on the usable bandwidth (if that
       even makes sense)
     - regulatory TX power (database can't deal with it)
     - a proper channel compatibility calculation for the
       new channel types
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6183a0d25b8b..a0c8decf6a47 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -483,6 +483,12 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
+bool cfg80211_chan_def_valid(const struct cfg80211_chan_def *chandef);
+
+bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,
+				 u32 center_freq, u32 bandwidth,
+				 u32 prohibited_flags);
+
 #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
 
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS

commit 683b6d3b31a51956ea540df00abb0b78894924c1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 8 21:25:48 2012 +0100

    cfg80211: pass a channel definition struct
    
    Instead of passing a channel pointer and channel type
    to all functions and driver methods, pass a new channel
    definition struct. Right now, this struct contains just
    the control channel and channel type, but for VHT this
    will change.
    
    Also, add a small inline cfg80211_get_chandef_type() so
    that drivers don't need to use the _type field of the
    new structure all the time, which will change.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b0a09cf56e06..6183a0d25b8b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -309,9 +309,9 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       const struct mesh_config *conf);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
-int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
-			   struct wireless_dev *wdev, int freq,
-			   enum nl80211_channel_type channel_type);
+int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev,
+			      struct cfg80211_chan_def *chandef);
 
 /* AP */
 int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
@@ -470,11 +470,8 @@ cfg80211_get_chan_state(struct wireless_dev *wdev,
 		        struct ieee80211_channel **chan,
 		        enum cfg80211_chan_mode *chanmode);
 
-struct ieee80211_channel *
-rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
-		  int freq, enum nl80211_channel_type channel_type);
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
-				 int freq, enum nl80211_channel_type chantype);
+				 struct cfg80211_chan_def *chandef);
 
 int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
 			   const u8 *rates, unsigned int n_rates,

commit 42d97a599eb6b2aab3a401b3e5799a399d6c7652
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 8 18:31:02 2012 +0100

    cfg80211: remove remain-on-channel channel type
    
    As mwifiex (and mac80211 in the software case) are the
    only drivers actually implementing remain-on-channel
    with channel type, userspace can't be relying on it.
    This is the case, as it's used only for P2P operations
    right now.
    
    Rather than adding a flag to tell userspace whether or
    not it can actually rely on it, simplify all the code
    by removing the ability to use different channel types.
    Leave only the validation of the attribute, so that if
    we extend it again later (with the needed capability
    flag), it can't break userspace sending invalid data.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e53831c876bb..b0a09cf56e06 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -378,10 +378,8 @@ void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  struct wireless_dev *wdev,
 			  struct ieee80211_channel *chan, bool offchan,
-			  enum nl80211_channel_type channel_type,
-			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, bool no_cck,
-			  bool dont_wait_for_ack, u64 *cookie);
+			  unsigned int wait, const u8 *buf, size_t len,
+			  bool no_cck, bool dont_wait_for_ack, u64 *cookie);
 void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
 			       const struct ieee80211_ht_cap *ht_capa_mask);
 

commit 37c73b5f323c973c1db6857494a6685260440be1
Author: Ben Greear <greearb@candelatech.com>
Date:   Fri Oct 26 14:49:25 2012 -0700

    cfg80211: allow registering more than one beacon listener
    
    The commit:
    
    commit 5e760230e42cf759bd923457ca2753aacf2e656e
    Author: Johannes Berg <johannes.berg@intel.com>
    Date:   Fri Nov 4 11:18:17 2011 +0100
    
        cfg80211: allow registering to beacons
    
    allowed only a single process to register for beacon events
    per wiphy.  This breaks cases where a user may want two or
    more VIFs on a wiphy and run a seperate hostapd process on
    each vif.
    
    This patch allows multiple beacon listeners, fixing the
    regression.
    
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b8eb743fe7da..e53831c876bb 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -55,7 +55,8 @@ struct cfg80211_registered_device {
 	int opencount; /* also protected by devlist_mtx */
 	wait_queue_head_t dev_wait;
 
-	u32 ap_beacons_nlportid;
+	struct list_head beacon_registrations;
+	spinlock_t beacon_registrations_lock;
 
 	/* protected by RTNL only */
 	int num_running_ifaces;
@@ -260,6 +261,10 @@ enum cfg80211_chan_mode {
 	CHAN_MODE_EXCLUSIVE,
 };
 
+struct cfg80211_beacon_registration {
+	struct list_head list;
+	u32 nlportid;
+};
 
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);

commit e39e5b5e7206767a0f1be0e5cb7acbd0db87ae60
Author: Jouni Malinen <j@w1.fi>
Date:   Sun Sep 30 19:29:39 2012 +0300

    cfg80211: Allow user space to specify non-IEs to SAE Authentication
    
    SAE extends Authentication frames with fields that are not information
    elements. NL80211_ATTR_IE is not suitable for these, so introduce a new
    attribute that can be used to specify the fields needed for SAE in
    station mode.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    [change to verify that SAE is only used with authenticate command]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a343be4a52bd..b8eb743fe7da 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -320,13 +320,15 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 const u8 *bssid,
 			 const u8 *ssid, int ssid_len,
 			 const u8 *ie, int ie_len,
-			 const u8 *key, int key_len, int key_idx);
+			 const u8 *key, int key_len, int key_idx,
+			 const u8 *sae_data, int sae_data_len);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, struct ieee80211_channel *chan,
 		       enum nl80211_auth_type auth_type, const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len,
-		       const u8 *key, int key_len, int key_idx);
+		       const u8 *key, int key_len, int key_idx,
+		       const u8 *sae_data, int sae_data_len);
 int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
 			  struct ieee80211_channel *chan,

commit 15e473046cb6e5d18a4d0057e61d76315230382b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Sep 7 20:12:54 2012 +0000

    netlink: Rename pid to portid to avoid confusion
    
    It is a frequent mistake to confuse the netlink port identifier with a
    process identifier.  Try to reduce this confusion by renaming fields
    that hold port identifiers portid instead of pid.
    
    I have carefully avoided changing the structures exported to
    userspace to avoid changing the userspace API.
    
    I have successfully built an allyesconfig kernel with this change.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bc7430b54771..a343be4a52bd 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -55,7 +55,7 @@ struct cfg80211_registered_device {
 	int opencount; /* also protected by devlist_mtx */
 	wait_queue_head_t dev_wait;
 
-	u32 ap_beacons_nlpid;
+	u32 ap_beacons_nlportid;
 
 	/* protected by RTNL only */
 	int num_running_ifaces;

commit 1f6fc43e621167492ed4b7f3b4269c584c3d6ccc
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu Aug 2 18:41:48 2012 +0100

    cfg80211: process pending events when unregistering net device
    
    libertas currently calls cfg80211_disconnected() when it is being
    brought down. This causes an event to be allocated, but since the
    wdev is already removed from the rdev by the time that the event
    processing work executes, the event is never processed or freed.
    http://article.gmane.org/gmane.linux.kernel.wireless.general/95666
    
    Fix this leak, and other possible situations, by processing the event
    queue when a device is being unregistered. Thanks to Johannes Berg for
    the suggestion.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Cc: stable@vger.kernel.org
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5206c6844fd7..bc7430b54771 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -426,6 +426,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, enum nl80211_iftype ntype,
 			  u32 *flags, struct vif_params *params);
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
+void cfg80211_process_wdev_events(struct wireless_dev *wdev);
 
 int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 struct wireless_dev *wdev,

commit 4290cb4bf212112e3d6f860e25f000ca8a1ca6a4
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jul 12 22:19:48 2012 +0200

    cfg80211: reduce monitor interface tracking
    
    Revert commit b78e8ceac23655e1e06b30aa95ab11742d1ac7c0
    ("cfg80211: track monitor channel") and remove the
    set_monitor_enabled() callback.
    
    Due to the tracking happening in NETDEV_PRE_UP, it had
    introduced bugs because the monitor interface callback
    would be called before the device was started. It looks
    like there's no way to fix this, and using NETDEV_PRE_UP
    is broken anyway (since there's no NETDEV_UP_FAIL), so
    remove all that code, track interfaces in NETDEV_UP and
    also stop tracking the monitor channel in cfg80211.
    
    This mostly reverts to before the tracking, except that
    we keep the interface count tracking so that setting the
    monitor channel can be rejected properly.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bac97da751df..5206c6844fd7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -61,9 +61,6 @@ struct cfg80211_registered_device {
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
 
-	struct ieee80211_channel *monitor_channel;
-	enum nl80211_channel_type monitor_channel_type;
-
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
 	struct list_head bss_list;

commit 8e95ea49c94908cb10e698c5637d57f0fbdc796d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jul 10 19:39:02 2012 +0200

    cfg80211: fix locking and lockdep complaints
    
    To call cfg80211_get_chan_state() we need to lock
    the wdev, so we need to lock the wdev_iter mutex
    in cfg80211_can_use_iftype_chan(). This needs to
    use nested locking for lockdep.
    
    Also, cfg80211_get_chan_state() doesn't actually
    use the rdev, so remove that completely including
    the lock assertion that isn't needed.
    
    Reported-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index eae5a25a1691..bac97da751df 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -463,8 +463,7 @@ cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
 }
 
 void
-cfg80211_get_chan_state(struct cfg80211_registered_device *rdev,
-		        struct wireless_dev *wdev,
+cfg80211_get_chan_state(struct wireless_dev *wdev,
 		        struct ieee80211_channel **chan,
 		        enum cfg80211_chan_mode *chanmode);
 

commit 71bbc9943883cffaf5d7a7728a4e4c50b3ac44d3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 15 15:30:18 2012 +0200

    cfg80211: use wdev in mgmt-tx/ROC APIs
    
    The management frame and remain-on-channel APIs will be
    needed in the P2P device abstraction, so move them over
    to the new wdev-based APIs. Userspace can still use both
    the interface index and wdev identifier for them so it's
    backward compatible, but for the P2P Device wdev it will
    be able to use the wdev identifier only.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6b0170a5f05f..eae5a25a1691 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -372,7 +372,7 @@ int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
-			  struct net_device *dev,
+			  struct wireless_dev *wdev,
 			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,

commit 89a54e48b9cbb44aed1bf6cd712e087b96b6ae65
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 15 14:33:17 2012 +0200

    nl80211: prepare for non-netdev wireless devs
    
    In order to support a P2P device abstraction and
    Bluetooth high-speed AMPs, we need to have a way
    to identify virtual interfaces that don't have a
    netdev associated.
    
    Do this by adding a NL80211_ATTR_WDEV attribute
    to identify a wdev which may or may not also be
    a netdev.
    
    To simplify things, use a 64-bit value with the
    high 32 bits being the wiphy index for this new
    wdev identifier in the nl80211 API.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 377dc394f48c..6b0170a5f05f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -47,11 +47,11 @@ struct cfg80211_registered_device {
 	/* wiphy index, internal only */
 	int wiphy_idx;
 
-	/* associate netdev list */
+	/* associated wireless interfaces */
 	struct mutex devlist_mtx;
 	/* protected by devlist_mtx or RCU */
-	struct list_head netdev_list;
-	int devlist_generation;
+	struct list_head wdev_list;
+	int devlist_generation, wdev_id;
 	int opencount; /* also protected by devlist_mtx */
 	wait_queue_head_t dev_wait;
 

commit c5a7e582490c423f0685e42ee5cfb7c6de81adb0
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jul 4 13:28:18 2012 +0200

    cfg80211: fix locking regression in monitor channel tracking
    
    Michal's monitor channel tracking introduce a locking problem
    as it locked the rdev lock inside the netdev notifier which
    isn't allowed as we might already hold it if we get there by
    removing an interface that is up.
    
    Fix this by relying only on the RTNL to protect the interface
    counters, the RTNL is always held in these code paths anyway.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 81fef3ddb5a8..377dc394f48c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -13,6 +13,7 @@
 #include <linux/debugfs.h>
 #include <linux/rfkill.h>
 #include <linux/workqueue.h>
+#include <linux/rtnetlink.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
 #include "reg.h"
@@ -56,6 +57,7 @@ struct cfg80211_registered_device {
 
 	u32 ap_beacons_nlpid;
 
+	/* protected by RTNL only */
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
 
@@ -205,7 +207,7 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
 
 static inline bool cfg80211_has_monitors_only(struct cfg80211_registered_device *rdev)
 {
-	ASSERT_RDEV_LOCK(rdev);
+	ASSERT_RTNL();
 
 	return rdev->num_running_ifaces == rdev->num_running_monitor_ifaces &&
 	       rdev->num_running_ifaces > 0;

commit d4e50c5917e110451ced8f8de594cea858791f37
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:47:07 2012 +0200

    cfg80211: add channel checking for iface combinations
    
    .connect cannot be handled since the driver scans
    and connects on its own. It is up to the driver
    then to refuse a connection (with -EBUSY for
    example).
    
    Non-fixed channel IBSSes always take a single
    channel resource. For example two non-fixed
    channel IBSSes always take up 2
    num_different_channels, even if they operate on
    the same channel at a given point of time.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d5efe1b0a8f7..81fef3ddb5a8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -428,9 +428,20 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  u32 *flags, struct vif_params *params);
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 
-int cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
-				  struct wireless_dev *wdev,
-				  enum nl80211_iftype iftype);
+int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
+				 struct wireless_dev *wdev,
+				 enum nl80211_iftype iftype,
+				 struct ieee80211_channel *chan,
+				 enum cfg80211_chan_mode chanmode);
+
+static inline int
+cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev,
+			      enum nl80211_iftype iftype)
+{
+	return cfg80211_can_use_iftype_chan(rdev, wdev, iftype, NULL,
+					    CHAN_MODE_UNDEFINED);
+}
 
 static inline int
 cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
@@ -439,6 +450,16 @@ cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
 	return cfg80211_can_change_interface(rdev, NULL, iftype);
 }
 
+static inline int
+cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
+		      struct wireless_dev *wdev,
+		      struct ieee80211_channel *chan,
+		      enum cfg80211_chan_mode chanmode)
+{
+	return cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
+					    chan, chanmode);
+}
+
 void
 cfg80211_get_chan_state(struct cfg80211_registered_device *rdev,
 		        struct wireless_dev *wdev,
@@ -461,6 +482,8 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype, int num);
 
+#define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
+
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit b78e8ceac23655e1e06b30aa95ab11742d1ac7c0
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:47:04 2012 +0200

    cfg80211: track monitor channel
    
    Make it even more obvious we support single
    monitor channel. This will allow us to remove
    .get_channel.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 99acd51343b1..d5efe1b0a8f7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -59,6 +59,9 @@ struct cfg80211_registered_device {
 	int num_running_ifaces;
 	int num_running_monitor_ifaces;
 
+	struct ieee80211_channel *monitor_channel;
+	enum nl80211_channel_type monitor_channel_type;
+
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
 	struct list_head bss_list;

commit dbbae26afa81320b3315fb4ad755b20f1ff256b4
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:47:01 2012 +0200

    cfg80211: track monitor interfaces count
    
    Implements .set_monitor_enabled(wiphy, enabled).
    
    Notifies driver upon change of interface layout.
    
    If only monitor interfaces become present it is
    called with 2nd argument being true. If
    non-monitor interface appears then 2nd argument
    is false. Driver is notified only upon change.
    
    This makes it more obvious about the fact that
    cfg80211 supports single monitor channel. Once we
    implement multi-channel we don't want to allow
    setting monitor channel while other interface
    types are running. Otherwise it would be ambiguous
    once we start considering num_different_channels.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 56f18c2eb919..99acd51343b1 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -56,6 +56,9 @@ struct cfg80211_registered_device {
 
 	u32 ap_beacons_nlpid;
 
+	int num_running_ifaces;
+	int num_running_monitor_ifaces;
+
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
 	struct list_head bss_list;
@@ -197,6 +200,14 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
 #define ASSERT_RDEV_LOCK(rdev) lockdep_assert_held(&(rdev)->mtx)
 #define ASSERT_WDEV_LOCK(wdev) lockdep_assert_held(&(wdev)->mtx)
 
+static inline bool cfg80211_has_monitors_only(struct cfg80211_registered_device *rdev)
+{
+	ASSERT_RDEV_LOCK(rdev);
+
+	return rdev->num_running_ifaces == rdev->num_running_monitor_ifaces &&
+	       rdev->num_running_ifaces > 0;
+}
+
 enum cfg80211_event_type {
 	EVENT_CONNECT_RESULT,
 	EVENT_ROAMED,
@@ -444,6 +455,9 @@ int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
 int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 				 u32 beacon_int);
 
+void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
+			       enum nl80211_iftype iftype, int num);
+
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit 26ab9a0c589db9ba2710f042c4959da25fd3297b
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:47:00 2012 +0200

    cfg80211: introduce cfg80211_get_chan_state
    
    Helper function for finding out which channel is
    used by a given interface.
    
    An exclusive channel can be used only by a single
    interface. This is mainly for non-fixed channel
    IBSS handling.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fef476d2117e..56f18c2eb919 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -241,6 +241,12 @@ struct cfg80211_cached_keys {
 	int def, defmgmt;
 };
 
+enum cfg80211_chan_mode {
+	CHAN_MODE_UNDEFINED,
+	CHAN_MODE_SHARED,
+	CHAN_MODE_EXCLUSIVE,
+};
+
 
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
@@ -419,6 +425,12 @@ cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
 	return cfg80211_can_change_interface(rdev, NULL, iftype);
 }
 
+void
+cfg80211_get_chan_state(struct cfg80211_registered_device *rdev,
+		        struct wireless_dev *wdev,
+		        struct ieee80211_channel **chan,
+		        enum cfg80211_chan_mode *chanmode);
+
 struct ieee80211_channel *
 rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
 		  int freq, enum nl80211_channel_type channel_type);

commit 60771780c27cbc93d0b78da0c7fd7a8a540b029e
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:46:56 2012 +0200

    cfg80211: introduce cfg80211_stop_ap
    
    This functionality will be reused when interface
    is going down. Avoids code duplication. Also adds
    missing wdev locking.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 609a579255ac..fef476d2117e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -289,6 +289,10 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 			   struct wireless_dev *wdev, int freq,
 			   enum nl80211_channel_type channel_type);
 
+/* AP */
+int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
+		     struct net_device *dev);
+
 /* MLME */
 int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,

commit a9455408b09395ecf4008bd998516ce2e9551bbc
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 15 13:32:49 2012 +0200

    cfg80211: make some functions static
    
    Some of the functions to retrieve a device can
    be static as they're used only in nl80211.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 9348a47562a4..609a579255ac 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -159,32 +159,6 @@ static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
-struct cfg80211_registered_device *
-__cfg80211_rdev_from_info(struct genl_info *info);
-
-/*
- * This function returns a pointer to the driver
- * that the genl_info item that is passed refers to.
- * If successful, it returns non-NULL and also locks
- * the driver's mutex!
- *
- * This means that you need to call cfg80211_unlock_rdev()
- * before being allowed to acquire &cfg80211_mutex!
- *
- * This is necessary because we need to lock the global
- * mutex to get an item off the list safely, and then
- * we lock the rdev mutex so it doesn't go away under us.
- *
- * We don't want to keep cfg80211_mutex locked
- * for all the time in order to allow requests on
- * other interfaces to go through at the same time.
- *
- * The result of this can be a PTR_ERR and hence must
- * be checked with IS_ERR() for errors.
- */
-extern struct cfg80211_registered_device *
-cfg80211_get_dev_from_info(struct genl_info *info);
-
 /* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 

commit e8c9bd5b8d807cfe6c923265969a523b1ba1e6c2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jun 6 08:18:22 2012 +0200

    cfg80211: clarify set_channel APIs
    
    Now that we've removed all uses of the set_channel
    API except for the monitor channel and in libertas,
    clarify this. Split the libertas mesh use into a
    new libertas_set_mesh_channel() operation, just to
    keep backward compatibility, and rename the normal
    set_channel() to set_monitor_channel().
    
    Also describe the desired set_monitor_channel()
    semantics more clearly.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 1d3d24126946..9348a47562a4 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -444,9 +444,8 @@ cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
 struct ieee80211_channel *
 rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
 		  int freq, enum nl80211_channel_type channel_type);
-int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
-		      struct wireless_dev *wdev, int freq,
-		      enum nl80211_channel_type channel_type);
+int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
+				 int freq, enum nl80211_channel_type chantype);
 
 int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
 			   const u8 *rates, unsigned int n_rates,

commit cc1d2806bf06ab92268343d26eb3d8d8f00f8bc9
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 16 23:50:20 2012 +0200

    cfg80211: provide channel to join_mesh function
    
    Just like the AP mode patch, instead of setting
    the channel and then joining the mesh network,
    provide the channel to join the network on to
    the join_mesh() function.
    
    Like in AP mode, you can also give the channel
    to the join-mesh nl80211 command now.
    
    Unlike AP mode, it picks a default channel if
    none was given.
    
    As libertas uses mesh mode interfaces but has
    no join_mesh callback and we can't simply break
    it, keep some compatibility code for that case
    and configure the channel directly for it.
    
    In the non-libertas case, where we store the
    channel until join, allow setting it while the
    interface is down.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 8523f3878677..1d3d24126946 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -303,14 +303,17 @@ extern const struct mesh_config default_mesh_config;
 extern const struct mesh_setup default_mesh_setup;
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
-			 const struct mesh_setup *setup,
+			 struct mesh_setup *setup,
 			 const struct mesh_config *conf);
 int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       const struct mesh_setup *setup,
+		       struct mesh_setup *setup,
 		       const struct mesh_config *conf);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
+int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
+			   struct wireless_dev *wdev, int freq,
+			   enum nl80211_channel_type channel_type);
 
 /* MLME */
 int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,

commit 4472037be86a9d7d1cab37e0c4cb310997a140ae
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue May 8 21:23:54 2012 +0200

    cfg80211: remove double prototype
    
    cfg80211_calculate_bitrate() is defined in the external
    header file cfg80211.h now, so no need to keep it in
    the internal one as well.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3ac2dd00d714..8523f3878677 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -445,8 +445,6 @@ int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 		      struct wireless_dev *wdev, int freq,
 		      enum nl80211_channel_type channel_type);
 
-u16 cfg80211_calculate_bitrate(struct rate_info *rate);
-
 int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
 			   const u8 *rates, unsigned int n_rates,
 			   u32 *mask);

commit 4c0c0b75e0c35ddb8f61c06bcbffede63ab4f4a2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 20 13:55:26 2012 +0100

    cfg80211: export cfg80211_ref_bss
    
    This is needed by mac80211 to keep a reference
    to a BSS alive for the auth process. Remove the
    old version of cfg80211_ref_bss() since it's
    not actually used.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2b454caf4395..3ac2dd00d714 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -144,11 +144,6 @@ static inline struct cfg80211_internal_bss *bss_from_pub(struct cfg80211_bss *pu
 	return container_of(pub, struct cfg80211_internal_bss, pub);
 }
 
-static inline void cfg80211_ref_bss(struct cfg80211_internal_bss *bss)
-{
-	kref_get(&bss->ref);
-}
-
 static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 {
 	atomic_inc(&bss->hold);

commit 95de817b9034d50860319f6033ec85d25024694c
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 20 13:55:25 2012 +0100

    cfg80211: stop tracking authenticated state
    
    To track authenticated state seems to have been
    a design mistake in cfg80211. It is possible to
    have out of band authentication (FT), tracking
    multiple authentications caused more problems
    than it ever helped, and the implementation in
    mac80211 is too complex.
    
    Remove all this complexity, and let userspace
    do whatever it wants to, mac80211 can deal with
    that just fine. Association is still tracked of
    course, but authentication no longer is. Local
    auth state changes are thus no longer of value,
    so ignore them completely.
    
    This will also help implement SAE -- asking the
    driver to do an authentication is now almost
    equivalent to sending an authentication frame,
    with the exception of shared key authentication
    which is still handled completely.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 43ad9c81efcf..2b454caf4395 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -325,15 +325,13 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 const u8 *bssid,
 			 const u8 *ssid, int ssid_len,
 			 const u8 *ie, int ie_len,
-			 const u8 *key, int key_len, int key_idx,
-			 bool local_state_change);
+			 const u8 *key, int key_len, int key_idx);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, struct ieee80211_channel *chan,
 		       enum nl80211_auth_type auth_type, const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len,
-		       const u8 *key, int key_len, int key_idx,
-		       bool local_state_change);
+		       const u8 *key, int key_len, int key_idx);
 int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
 			  struct ieee80211_channel *chan,
@@ -421,7 +419,8 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
-void cfg80211_sme_disassoc(struct net_device *dev, int idx);
+void cfg80211_sme_disassoc(struct net_device *dev,
+			   struct cfg80211_internal_bss *bss);
 void __cfg80211_scan_done(struct work_struct *wk);
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
 void __cfg80211_sched_scan_results(struct work_struct *wk);

commit adbde344dc12514d68620afae8d34035e72544b1
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Thu Dec 8 14:28:47 2011 +0530

    cfg80211: Fix race in bss timeout
    
    It is quite possible to run into a race in bss timeout where
    the drivers see the bss entry just before notifying cfg80211
    of a roaming event but it got timed out by the time rdev->event_work
    got scehduled from cfg80211_wq. This would result in the following
    WARN-ON() along with the failure to notify the user space of
    the roaming. The other situation which is happening with ath6kl
    that runs into issue is when the driver reports roam to same AP
    event where the AP bss entry already got expired. To fix this,
    move cfg80211_get_bss() from __cfg80211_roamed() to cfg80211_roamed().
    
    [158645.538384] WARNING: at net/wireless/sme.c:586
    __cfg80211_roamed+0xc2/0x1b1()
    [158645.538810] Call Trace:
    [158645.538838]  [<c1033527>] warn_slowpath_common+0x65/0x7a
    [158645.538917]  [<c14cfacf>] ? __cfg80211_roamed+0xc2/0x1b1
    [158645.538946]  [<c103354b>] warn_slowpath_null+0xf/0x13
    [158645.539055]  [<c14cfacf>] __cfg80211_roamed+0xc2/0x1b1
    [158645.539086]  [<c14beb5b>] cfg80211_process_rdev_events+0x153/0x1cc
    [158645.539166]  [<c14bd57b>] cfg80211_event_work+0x26/0x36
    [158645.539195]  [<c10482ae>] process_one_work+0x219/0x38b
    [158645.539273]  [<c14bd555>] ? wiphy_new+0x419/0x419
    [158645.539301]  [<c10486cb>] worker_thread+0xf6/0x1bf
    [158645.539379]  [<c10485d5>] ? rescuer_thread+0x1b5/0x1b5
    [158645.539407]  [<c104b3e2>] kthread+0x62/0x67
    [158645.539484]  [<c104b380>] ? __init_kthread_worker+0x42/0x42
    [158645.539514]  [<c151309a>] kernel_thread_helper+0x6/0xd
    
    Reported-by: Kalle Valo <kvalo@qca.qualcomm.com>
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fb08c28fc90a..43ad9c81efcf 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -249,12 +249,11 @@ struct cfg80211_event {
 			u16 status;
 		} cr;
 		struct {
-			struct ieee80211_channel *channel;
-			u8 bssid[ETH_ALEN];
 			const u8 *req_ie;
 			const u8 *resp_ie;
 			size_t req_ie_len;
 			size_t resp_ie_len;
+			struct cfg80211_bss *bss;
 		} rm;
 		struct {
 			const u8 *ie;
@@ -403,8 +402,7 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
 void __cfg80211_roamed(struct wireless_dev *wdev,
-		       struct ieee80211_channel *channel,
-		       const u8 *bssid,
+		       struct cfg80211_bss *bss,
 		       const u8 *req_ie, size_t req_ie_len,
 		       const u8 *resp_ie, size_t resp_ie_len);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,

commit 7e7c8926b2f4e3453b8aeb39cd814d2af3fec24f
Author: Ben Greear <greearb@candelatech.com>
Date:   Fri Nov 18 11:31:59 2011 -0800

    wireless: Support ht-capabilities over-rides.
    
    This allows users to disable features such as HT, HT40,
    and to modify the MCS, AMPDU, and AMSDU settings for
    drivers that support it.
    
    The MCS, AMPDU, and AMSDU features that may be disabled are
    are reported in the phy-info netlink message as a mask.
    
    Attemping to disable features that are not supported will
    take no affect, but will not return errors.  This is to aid
    backwards compatibility in user-space apps that may not be
    clever enough to deal with parsing the the capabilities mask.
    
    This patch only enables the infrastructure.  An additional
    patch will enable the feature in mac80211.
    
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 1c7d4df5418c..fb08c28fc90a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -341,13 +341,17 @@ int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  const u8 *bssid, const u8 *prev_bssid,
 			  const u8 *ssid, int ssid_len,
 			  const u8 *ie, int ie_len, bool use_mfp,
-			  struct cfg80211_crypto_settings *crypt);
+			  struct cfg80211_crypto_settings *crypt,
+			  u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
+			  struct ieee80211_ht_cap *ht_capa_mask);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, struct ieee80211_channel *chan,
 			const u8 *bssid, const u8 *prev_bssid,
 			const u8 *ssid, int ssid_len,
 			const u8 *ie, int ie_len, bool use_mfp,
-			struct cfg80211_crypto_settings *crypt);
+			struct cfg80211_crypto_settings *crypt,
+			u32 assoc_flags, struct ieee80211_ht_cap *ht_capa,
+			struct ieee80211_ht_cap *ht_capa_mask);
 int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			   struct net_device *dev, const u8 *bssid,
 			   const u8 *ie, int ie_len, u16 reason,
@@ -379,6 +383,8 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  bool channel_type_valid, unsigned int wait,
 			  const u8 *buf, size_t len, bool no_cck,
 			  bool dont_wait_for_ack, u64 *cookie);
+void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
+			       const struct ieee80211_ht_cap *ht_capa_mask);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit e247bd9068e3e86c3571147c128883596ace9d05
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Nov 4 11:18:21 2011 +0100

    cfg80211/mac80211: allow management TX to not wait for ACK
    
    For probe responses it can be useful to not wait for ACK to
    avoid retransmissions if the station that sent the probe is
    already on the next channel, so allow userspace to request
    not caring about the ACK with a new nl80211 flag.
    
    Since mac80211 needs to be updated for the new function
    prototype anyway implement it right away -- it's just a
    few lines of code.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 4c6ff4024356..1c7d4df5418c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -378,7 +378,7 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,
 			  const u8 *buf, size_t len, bool no_cck,
-			  u64 *cookie);
+			  bool dont_wait_for_ack, u64 *cookie);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 5e760230e42cf759bd923457ca2753aacf2e656e
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Nov 4 11:18:17 2011 +0100

    cfg80211: allow registering to beacons
    
    Add the ability to register to received beacon frames
    to allow implementing OLBC logic in userspace. The
    registration is per wiphy since there's no point in
    receiving the same frame multiple times.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b9ec3061ed72..4c6ff4024356 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -54,6 +54,8 @@ struct cfg80211_registered_device {
 	int opencount; /* also protected by devlist_mtx */
 	wait_queue_head_t dev_wait;
 
+	u32 ap_beacons_nlpid;
+
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
 	struct list_head bss_list;

commit e9f935e3e8dc0bddd0df6d148165d95925422502
Author: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
Date:   Sun Sep 25 14:53:30 2011 +0530

    nl80211/cfg80211: Add support to disable CCK rate for management frame
    
    Add a new nl80211 attribute to specify whether to send the management
    frames in CCK rate or not. As of now the wpa_supplicant is disabling
    CCK rate at P2P init itself. So this patch helps to send P2P probe
    request/probe response/action frames being sent at non CCK rate in 2GHz
    without disabling 11b rates.
    
    This attribute is used with NL80211_CMD_TRIGGER_SCAN and
    NL80211_CMD_FRAME commands to disable CCK rate for management frame
    transmission.
    
    Cc: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index cb87b8bbceb7..b9ec3061ed72 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -375,7 +375,8 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, u64 *cookie);
+			  const u8 *buf, size_t len, bool no_cck,
+			  u64 *cookie);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 38ba3c57af1c737966fb58bcbeecdc71f5f4fa90
Author: Jouni Malinen <jouni@qca.qualcomm.com>
Date:   Wed Sep 21 18:14:56 2011 +0300

    cfg80211: Validate cipher suite against supported ciphers
    
    Instead of using a hardcoded list of cipher suites in nl80211.c, use a
    shared function in util.c to verify that the driver advertises support
    for the specified cipher. This provides more accurate validation of the
    values and allows vendor-specific cipher suites to be added in drivers.
    
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 796a4bdf8b0d..cb87b8bbceb7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -406,6 +406,7 @@ void cfg80211_sme_failed_assoc(struct wireless_dev *wdev);
 bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
 
 /* internal helpers */
+bool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher);
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
 				   bool pairwise, const u8 *mac_addr);

commit eac03e381957a05f3842ceb8de987a1025966ecf
Author: Sven Neumann <s.neumann@raumfeld.com>
Date:   Tue Aug 30 23:38:53 2011 +0200

    cfg80211: hold reg_mutex when updating regulatory
    
    The function wiphy_update_regulatory() uses the static variable
    last_request and thus needs to be called with reg_mutex held.
    This is the case for all users in reg.c, but the function was
    exported for use by wiphy_register(), from where it is called
    without the lock being held.
    
    Fix this by making wiphy_update_regulatory() private and introducing
    regulatory_update() as a wrapper that acquires and holds the lock.
    
    Signed-off-by: Sven Neumann <s.neumann@raumfeld.com>
    Cc: John W. Linville <linville@tuxdriver.com>
    Cc: Luis R. Rodriguez <mcgrof@gmail.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: linux-wireless@vger.kernel.org
    Acked-by:  Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 8672e028022f..796a4bdf8b0d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -279,8 +279,6 @@ extern int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
 			       char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
-void wiphy_update_regulatory(struct wiphy *wiphy,
-			     enum nl80211_reg_initiator setby);
 
 void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
 void cfg80211_bss_age(struct cfg80211_registered_device *dev,

commit 34850ab25d74ab4eead62c3b4a9e8036a25cc669
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jul 18 18:08:35 2011 +0200

    cfg80211: allow userspace to control supported rates in scan
    
    Some P2P scans are not allowed to advertise
    11b rates, but that is a rather special case
    so instead of having that, allow userspace
    to request the rate sets (per band) that are
    advertised in scan probe request frames.
    
    Since it's needed in two places now, factor
    out some common code parsing a rate array.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a570ff9214ec..8672e028022f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -447,6 +447,10 @@ int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 
 u16 cfg80211_calculate_bitrate(struct rate_info *rate);
 
+int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
+			   const u8 *rates, unsigned int n_rates,
+			   u32 *mask);
+
 int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 				 u32 beacon_int);
 

commit c10841ca722a0bc960dc541c51582773f9a24f98
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu Jun 30 08:32:41 2011 +0300

    cfg80211: fix deadlock with rfkill/sched_scan by adding new mutex
    
    There was a deadlock when rfkill-blocking a wireless interface,
    because we were locking the rdev mutex on NETDEV_GOING_DOWN to stop
    sched_scans that were eventually running.  The rfkill block code was
    already holding a mutex under rdev:
    
    kernel: =======================================================
    kernel: [ INFO: possible circular locking dependency detected ]
    kernel: 3.0.0-rc1-00049-g1fa7b6a #57
    kernel: -------------------------------------------------------
    kernel: kworker/0:1/4525 is trying to acquire lock:
    kernel: (&rdev->mtx){+.+.+.}, at: [<ffffffff8164c831>] cfg80211_netdev_notifier_call+0x131/0x5b0
    kernel:
    kernel: but task is already holding lock:
    kernel: (&rdev->devlist_mtx){+.+.+.}, at: [<ffffffff8164dcef>] cfg80211_rfkill_set_block+0x4f/0xa0
    kernel:
    kernel: which lock already depends on the new lock.
    
    To fix this, add a new mutex specifically for sched_scan, to protect
    the sched_scan_req element in the rdev struct, instead of using the
    global rdev mutex.
    
    Reported-by: Duane Griffin <duaneg@dghda.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3dce1f167eba..a570ff9214ec 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -65,6 +65,8 @@ struct cfg80211_registered_device {
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;
 
+	struct mutex sched_scan_mtx;
+
 #ifdef CONFIG_NL80211_TESTMODE
 	struct genl_info *testmode_info;
 #endif

commit ed9d01026f156db2d638cbb045231c7a8fde877d
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Mon May 16 19:40:15 2011 +0300

    cfg80211: Use consistent BSS matching between scan and sme
    
    cfg80211 scan code adds separate BSS entries if the same BSS shows up
    on multiple channels. However, sme implementation does not use the
    frequency when fetching the BSS entry. Fix this by adding channel
    information to cfg80211_roamed() and include it in cfg80211_get_bss()
    calls.
    
    Please note that drivers using cfg80211_roamed() need to be modified to
    fully implement this fix. This commit includes only minimal changes to
    avoid compilation issues; it maintains the old (broken) behavior for
    most drivers. ath6kl was the only one that I could test, so I updated
    it to provide the operating frequency in the roamed event.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bf0fb40e3c8b..3dce1f167eba 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -245,6 +245,7 @@ struct cfg80211_event {
 			u16 status;
 		} cr;
 		struct {
+			struct ieee80211_channel *channel;
 			u8 bssid[ETH_ALEN];
 			const u8 *req_ie;
 			const u8 *resp_ie;
@@ -392,7 +393,9 @@ int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
-void __cfg80211_roamed(struct wireless_dev *wdev, const u8 *bssid,
+void __cfg80211_roamed(struct wireless_dev *wdev,
+		       struct ieee80211_channel *channel,
+		       const u8 *bssid,
 		       const u8 *req_ie, size_t req_ie_len,
 		       const u8 *resp_ie, size_t resp_ie_len);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,

commit 7527a782e187d1214a5b3dc2897ce441033bb4ef
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri May 13 10:58:57 2011 +0200

    cfg80211: advertise possible interface combinations
    
    Add the ability to advertise interface combinations in nl80211.
    This allows the driver to indicate what the combinations are
    that it supports. "Combinations" of just a single interface are
    implicit, as previously. Note that cfg80211 will enforce that
    the restrictions are met, but not for all drivers yet (once all
    drivers are updated, we can remove the flag and enforce for all).
    
    When no combinations are actually supported, an empty list will
    be exported so that userspace can know if the kernel exported
    this info or not (although it isn't clear to me what tools using
    the info should do if the kernel didn't export it).
    
    Since some interface types are purely virtual/software and don't
    fit the restrictions, those are exposed in a new list of pure SW
    types, not subject to restrictions. This mainly exists to handle
    AP-VLAN and monitor interfaces in mac80211.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d4b8f4c0bbbb..bf0fb40e3c8b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -422,6 +422,17 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  u32 *flags, struct vif_params *params);
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 
+int cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
+				  struct wireless_dev *wdev,
+				  enum nl80211_iftype iftype);
+
+static inline int
+cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
+			   enum nl80211_iftype iftype)
+{
+	return cfg80211_can_change_interface(rdev, NULL, iftype);
+}
+
 struct ieee80211_channel *
 rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
 		  int freq, enum nl80211_channel_type channel_type);

commit 85a9994a0a6cba1a6cc6af4bd3ebd85f778be0fe
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu May 12 16:28:29 2011 +0300

    cfg80211/mac80211: avoid bounce back mac->cfg->mac on sched_scan_stopped
    
    When sched_scan_stopped was called by the driver, mac80211 calls
    cfg80211, which in turn was calling mac80211 back with a flag
    "driver_initiated".  This flag was used so that mac80211 would do the
    necessary cleanup but would not call the driver.  This was enough to
    prevent the bounce back between the driver and mac80211, but not
    between mac80211 and cfg80211.
    
    To fix this, we now do the cleanup in mac80211 before calling
    cfg80211.  To help with locking issues, the workqueue was moved from
    cfg80211 to mac80211.
    
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fd9135f9b5be..d4b8f4c0bbbb 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -64,7 +64,6 @@ struct cfg80211_registered_device {
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
 	struct work_struct sched_scan_results_wk;
-	struct work_struct sched_scan_stopped_wk;
 
 #ifdef CONFIG_NL80211_TESTMODE
 	struct genl_info *testmode_info;
@@ -417,7 +416,6 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
 void __cfg80211_sched_scan_results(struct work_struct *wk);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 			       bool driver_initiated);
-void __cfg80211_sched_scan_stopped(struct work_struct *wk);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, enum nl80211_iftype ntype,

commit 56d1893d94bc06d0b1aa3a53f924ed02f9e207bf
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon May 9 18:41:15 2011 +0200

    cfg80211: restrict AP beacon intervals
    
    Multiple virtual AP interfaces can currently try
    to use different beacon intervals, but that just
    leads to problems since it won't actually be done
    that way by drivers. Return an error in this case
    to make sure it won't be done wrong.
    
    Also, ignore attempts to change the DTIM period
    or beacon interval during the lifetime of the BSS.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e3f7b1d995cd..fd9135f9b5be 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -433,6 +433,9 @@ int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 
 u16 cfg80211_calculate_bitrate(struct rate_info *rate);
 
+int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
+				 u32 beacon_int);
+
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit 807f8a8c300435d5483e8d78df9dcdbc27333166
Author: Luciano Coelho <coelho@ti.com>
Date:   Wed May 11 17:09:35 2011 +0300

    cfg80211/nl80211: add support for scheduled scans
    
    Implement new functionality for scheduled scan offload.  With this feature we
    can scan automatically at certain intervals.
    
    The idea is that the hardware can perform scan automatically and filter on
    desired results without waking up the host unnecessarily.
    
    Add NL80211_CMD_START_SCHED_SCAN and NL80211_CMD_STOP_SCHED_SCAN
    commands to the nl80211 interface.  When results are available they are
    reported by NL80211_CMD_SCHED_SCAN_RESULTS events.  The userspace is
    informed when the scheduled scan has stopped with a
    NL80211_CMD_SCHED_SCAN_STOPPED event, which can be triggered either by
    the driver or by a call to NL80211_CMD_STOP_SCHED_SCAN.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 7a18c10a7fb6..e3f7b1d995cd 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -60,8 +60,11 @@ struct cfg80211_registered_device {
 	struct rb_root bss_tree;
 	u32 bss_generation;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
+	struct cfg80211_sched_scan_request *sched_scan_req;
 	unsigned long suspend_at;
 	struct work_struct scan_done_wk;
+	struct work_struct sched_scan_results_wk;
+	struct work_struct sched_scan_stopped_wk;
 
 #ifdef CONFIG_NL80211_TESTMODE
 	struct genl_info *testmode_info;
@@ -411,6 +414,10 @@ void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
+void __cfg80211_sched_scan_results(struct work_struct *wk);
+int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
+			       bool driver_initiated);
+void __cfg80211_sched_scan_stopped(struct work_struct *wk);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, enum nl80211_iftype ntype,

commit ff1b6e69ad4f31fb3c9c6da2665655f2e798dd70
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 4 15:37:28 2011 +0200

    nl80211/cfg80211: WoWLAN support
    
    This is based on (but now quite far from) the
    original work from Luis and Eliad. Add support
    for configuring WoWLAN triggers, and getting
    the configuration out again. Changes from the
    original patchset are too numerous to list,
    but one important change needs highlighting:
    the suspend() callback is passed NULL for the
    trigger configuration if userspace has not
    configured WoWLAN at all.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 26a0a084e16b..7a18c10a7fb6 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -70,6 +70,8 @@ struct cfg80211_registered_device {
 	struct work_struct conn_work;
 	struct work_struct event_work;
 
+	struct cfg80211_wowlan *wowlan;
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));
@@ -89,6 +91,18 @@ bool wiphy_idx_valid(int wiphy_idx)
 	return wiphy_idx >= 0;
 }
 
+static inline void
+cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
+{
+	int i;
+
+	if (!rdev->wowlan)
+		return;
+	for (i = 0; i < rdev->wowlan->n_patterns; i++)
+		kfree(rdev->wowlan->patterns[i].mask);
+	kfree(rdev->wowlan->patterns);
+	kfree(rdev->wowlan);
+}
 
 extern struct workqueue_struct *cfg80211_wq;
 extern struct mutex cfg80211_mutex;

commit c80d545da3f7c0e534ccd4a780f322f80a92cff1
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Dec 16 17:37:49 2010 -0800

    mac80211: Let userspace enable and configure vendor specific path selection.
    
    Userspace will now be allowed to toggle between the default path
    selection algorithm (HWMP, implemented in the kernel), and a vendor
    specific alternative.  Also in the same patch, allow userspace to add
    information elements to mesh beacons.  This is accordance with the
    Extensible Path Selection Framework specified in version 7.0 of the
    802.11s draft.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 743203bb61ac..26a0a084e16b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -287,13 +287,14 @@ int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 
 /* mesh */
 extern const struct mesh_config default_mesh_config;
+extern const struct mesh_setup default_mesh_setup;
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
-			 const u8 *mesh_id, u8 mesh_id_len,
+			 const struct mesh_setup *setup,
 			 const struct mesh_config *conf);
 int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       const u8 *mesh_id, u8 mesh_id_len,
+		       const struct mesh_setup *setup,
 		       const struct mesh_config *conf);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);

commit 29cbe68c516a48a9a88b3226878570c6cbd83c02
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Dec 3 09:20:44 2010 +0100

    cfg80211/mac80211: add mesh join/leave commands
    
    Instead of tying mesh activity to interface up,
    add join and leave commands for mesh. Since we
    must be backward compatible, let cfg80211 handle
    joining a mesh if a mesh ID was pre-configured
    when the device goes up.
    
    Note that this therefore must modify mac80211 as
    well since mac80211 needs to lose the logic to
    start the mesh on interface up.
    
    We now allow querying mesh parameters before the
    mesh is connected, which simply returns defaults.
    Setting them (internally renamed to "update") is
    only allowed while connected. Specify them with
    the new mesh join command instead where needed.
    
    In mac80211, beaconing must now also follow the
    mesh enabled/not enabled state, which is done
    by testing the mesh ID.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ee80ad8dc655..743203bb61ac 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -285,6 +285,19 @@ void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
 int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 			    struct wireless_dev *wdev);
 
+/* mesh */
+extern const struct mesh_config default_mesh_config;
+int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 const u8 *mesh_id, u8 mesh_id_len,
+			 const struct mesh_config *conf);
+int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev,
+		       const u8 *mesh_id, u8 mesh_id_len,
+		       const struct mesh_config *conf);
+int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+			struct net_device *dev);
+
 /* MLME */
 int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,

commit f7ca38dfe58c20cb1aa2ed9643187e8b194b5bae
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 25 10:02:29 2010 +0100

    nl80211/cfg80211: extend mgmt-tx API for off-channel
    
    With p2p, it is sometimes necessary to transmit
    a frame (typically an action frame) on another
    channel than the current channel. Enable this
    through the CMD_FRAME API, and allow it to wait
    for a response. A new command allows that wait
    to be aborted.
    
    However, allow userspace to specify whether or
    not it wants to allow off-channel TX, it may
    actually want to use the same channel only.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6583cca0e2ee..ee80ad8dc655 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -341,9 +341,9 @@ void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
-			  struct ieee80211_channel *chan,
+			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
-			  bool channel_type_valid,
+			  bool channel_type_valid, unsigned int wait,
 			  const u8 *buf, size_t len, u64 *cookie);
 
 /* SME */

commit e9a68707d736f4f73d7e209885d7b4c5c452b1dc
Merge: dd53df265b1e 15a6321d1c0f
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Oct 8 15:39:28 2010 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/wireless/ipw2x00/ipw2200.c

commit e31b82136d1adc7a599b6e99d3321e5831841f5a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Oct 5 19:39:30 2010 +0200

    cfg80211/mac80211: allow per-station GTKs
    
    This adds API to allow adding per-station GTKs,
    updates mac80211 to support it, and also allows
    drivers to remove a key from hwaccel again when
    this may be necessary due to multiple GTKs.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 37580e090a3d..2d1d4c70113c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -375,7 +375,7 @@ bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
 /* internal helpers */
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
-				   const u8 *mac_addr);
+				   bool pairwise, const u8 *mac_addr);
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 void cfg80211_sme_scan_done(struct net_device *dev);

commit a02cec2155fbea457eca8881870fd2de1a4c4c76
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 20:43:57 2010 +0000

    net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 37580e090a3d..5d89310b3587 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -86,7 +86,7 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 static inline
 bool wiphy_idx_valid(int wiphy_idx)
 {
-	return (wiphy_idx >= 0);
+	return wiphy_idx >= 0;
 }
 
 

commit 46a5ebaf02d69e26ee0f47a0b8d2d9bc619240d4
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Sep 15 13:28:15 2010 +0200

    cfg80211/mac80211: use lockdep_assert_held
    
    Instead of using a WARN_ON(!mutex_is_locked())
    use lockdep_assert_held() which compiles away
    completely when lockdep isn't enabled, and
    also is a more accurate assertion since it
    checks that the current thread is holding the
    mutex.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 58ab2c791d28..37580e090a3d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -95,7 +95,10 @@ extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_rdev_list;
 extern int cfg80211_rdev_list_generation;
 
-#define assert_cfg80211_lock() WARN_ON(!mutex_is_locked(&cfg80211_mutex))
+static inline void assert_cfg80211_lock(void)
+{
+	lockdep_assert_held(&cfg80211_mutex);
+}
 
 /*
  * You can use this to mark a wiphy_idx as not having an associated wiphy.
@@ -202,8 +205,8 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
 	mutex_unlock(&wdev->mtx);
 }
 
-#define ASSERT_RDEV_LOCK(rdev) WARN_ON(!mutex_is_locked(&(rdev)->mtx));
-#define ASSERT_WDEV_LOCK(wdev) WARN_ON(!mutex_is_locked(&(wdev)->mtx));
+#define ASSERT_RDEV_LOCK(rdev) lockdep_assert_held(&(rdev)->mtx)
+#define ASSERT_WDEV_LOCK(wdev) lockdep_assert_held(&(wdev)->mtx)
 
 enum cfg80211_event_type {
 	EVENT_CONNECT_RESULT,

commit 2e161f78e5f63a7f9fd25a766bb7f816a01eb14a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Aug 12 15:38:38 2010 +0200

    cfg80211/mac80211: extensible frame processing
    
    Allow userspace to register for more than just
    action frames by giving the frame subtype, and
    make it possible to use this in various modes
    as well.
    
    With some tweaks and some added functionality
    this will, in the future, also be usable in AP
    mode and be able to replace the cooked monitor
    interface currently used in that case.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 63d57ae399c3..58ab2c791d28 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -331,16 +331,17 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 			       const u8 *resp_ie, size_t resp_ie_len,
 			       u16 status, bool wextev,
 			       struct cfg80211_bss *bss);
-int cfg80211_mlme_register_action(struct wireless_dev *wdev, u32 snd_pid,
-				  const u8 *match_data, int match_len);
-void cfg80211_mlme_unregister_actions(struct wireless_dev *wdev, u32 nlpid);
-void cfg80211_mlme_purge_actions(struct wireless_dev *wdev);
-int cfg80211_mlme_action(struct cfg80211_registered_device *rdev,
-			 struct net_device *dev,
-			 struct ieee80211_channel *chan,
-			 enum nl80211_channel_type channel_type,
-			 bool channel_type_valid,
-			 const u8 *buf, size_t len, u64 *cookie);
+int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
+				u16 frame_type, const u8 *match_data,
+				int match_len);
+void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
+void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
+int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev,
+			  struct ieee80211_channel *chan,
+			  enum nl80211_channel_type channel_type,
+			  bool channel_type_valid,
+			  const u8 *buf, size_t len, u64 *cookie);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 252aa631f88080920a7083ac5a5844ffc5463629
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed May 19 12:17:12 2010 +0200

    cfg80211: make action channel type optional
    
    When sending action frames, we want to verify
    that we do that on the correct channel. However,
    checking the channel type in addition can get in
    the way, since the channel type could change on
    the fly during an association, and it's not
    useful to have the channel type anyway since it
    has no effect on the transmission. Therefore,
    make it optional to specify so that if wanted,
    it can still be checked, but is not required.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ae930acf75e9..63d57ae399c3 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -339,6 +339,7 @@ int cfg80211_mlme_action(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
 			 struct ieee80211_channel *chan,
 			 enum nl80211_channel_type channel_type,
+			 bool channel_type_valid,
 			 const u8 *buf, size_t len, u64 *cookie);
 
 /* SME */

commit f444de05d20e27cdd960c13fcbcfca3099f03143
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed May 5 15:25:02 2010 +0200

    cfg80211/mac80211: better channel handling
    
    Currently (all tested with hwsim) you can do stupid
    things like setting up an AP on a certain channel,
    then adding another virtual interface and making
    that associate on another channel -- this will make
    the beaconing to move channel but obviously without
    the necessary IEs data update.
    
    In order to improve this situation, first make the
    configuration APIs (cfg80211 and nl80211) aware of
    multi-channel operation -- we'll eventually need
    that in the future anyway. There's one userland API
    change and one API addition. The API change is that
    now SET_WIPHY must be called with virtual interface
    index rather than only wiphy index in order to take
    effect for that interface -- luckily all current
    users (hostapd) do that. For monitor interfaces, the
    old setting is preserved, but monitors are always
    slaved to other devices anyway so no guarantees.
    
    The second userland API change is the introduction
    of a per virtual interface SET_CHANNEL command, that
    hostapd should use going forward to make it easier
    to understand what's going on (it can automatically
    detect a kernel with this command).
    
    Other than mac80211, no existing cfg80211 drivers
    are affected by this change because they only allow
    a single virtual interface.
    
    mac80211, however, now needs to be aware that the
    channel settings are per interface now, and needs
    to disallow (for now) real multi-channel operation,
    which is another important part of this patch.
    
    One of the immediate benefits is that you can now
    start hostapd to operate on a hardware that already
    has a connection on another virtual interface, as
    long as you specify the same channel.
    
    Note that two things are left unhandled (this is an
    improvement -- not a complete fix):
    
     * different HT/no-HT modes
    
       currently you could start an HT AP and then
       connect to a non-HT network on the same channel
       which would configure the hardware for no HT;
       that can be fixed fairly easily
    
     * CSA
    
       An AP we're connected to on a virtual interface
       might indicate switching channels, and in that
       case we would follow it, regardless of how many
       other interfaces are operating; this requires
       more effort to fix but is pretty rare after all
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index b2234b436ead..ae930acf75e9 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -70,9 +70,6 @@ struct cfg80211_registered_device {
 	struct work_struct conn_work;
 	struct work_struct event_work;
 
-	/* current channel */
-	struct ieee80211_channel *channel;
-
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));
@@ -387,15 +384,12 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			  u32 *flags, struct vif_params *params);
 void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 
-struct ieee80211_channel *
-rdev_fixed_channel(struct cfg80211_registered_device *rdev,
-		   struct wireless_dev *for_wdev);
 struct ieee80211_channel *
 rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
 		  int freq, enum nl80211_channel_type channel_type);
-int rdev_set_freq(struct cfg80211_registered_device *rdev,
-		  struct wireless_dev *for_wdev,
-		  int freq, enum nl80211_channel_type channel_type);
+int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
+		      struct wireless_dev *wdev, int freq,
+		      enum nl80211_channel_type channel_type);
 
 u16 cfg80211_calculate_bitrate(struct rate_info *rate);
 

commit d5cdfacb35ed886271d1ccfffbded98d3447da17
Author: Jouni Malinen <j@w1.fi>
Date:   Sun Apr 4 09:37:19 2010 +0300

    cfg80211: Add local-state-change-only auth/deauth/disassoc
    
    cfg80211 is quite strict on allowing authentication and association
    commands only in certain states. In order to meet these requirements,
    user space applications may need to clear authentication or
    association state in some cases. Currently, this can be done with
    deauth/disassoc command, but that ends up sending out Deauthentication
    or Disassociation frame unnecessarily. Add a new nl80211 attribute to
    allow this sending of the frame be skipped, but with all other
    deauth/disassoc operations being completed.
    
    Similar state change is also needed for IEEE 802.11r FT protocol in
    the FT-over-DS case which does not use Authentication frame exchange
    in a transition to another BSS. For this to work with cfg80211, an
    authentication entry needs to be created for the target BSS without
    sending out an Authentication frame. The nl80211 authentication
    command can be used for this purpose, too, with the new attribute to
    indicate that the command is only for changing local state. This
    enables wpa_supplicant to complete FT-over-DS transition successfully.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d52da913145a..b2234b436ead 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -293,13 +293,15 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 const u8 *bssid,
 			 const u8 *ssid, int ssid_len,
 			 const u8 *ie, int ie_len,
-			 const u8 *key, int key_len, int key_idx);
+			 const u8 *key, int key_len, int key_idx,
+			 bool local_state_change);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, struct ieee80211_channel *chan,
 		       enum nl80211_auth_type auth_type, const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len,
-		       const u8 *key, int key_len, int key_idx);
+		       const u8 *key, int key_len, int key_idx,
+		       bool local_state_change);
 int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
 			  struct ieee80211_channel *chan,
@@ -315,13 +317,16 @@ int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct cfg80211_crypto_settings *crypt);
 int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			   struct net_device *dev, const u8 *bssid,
-			   const u8 *ie, int ie_len, u16 reason);
+			   const u8 *ie, int ie_len, u16 reason,
+			   bool local_state_change);
 int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev, const u8 *bssid,
-			 const u8 *ie, int ie_len, u16 reason);
+			 const u8 *ie, int ie_len, u16 reason,
+			 bool local_state_change);
 int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 			   struct net_device *dev, const u8 *bssid,
-			   const u8 *ie, int ie_len, u16 reason);
+			   const u8 *ie, int ie_len, u16 reason,
+			   bool local_state_change);
 void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
 void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,

commit 026331c4d9b526561ea96f95fac4bfc52b69e316
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Mon Feb 15 12:53:10 2010 +0200

    cfg80211/mac80211: allow registering for and sending action frames
    
    This implements a new command to register for action frames
    that userspace wants to handle instead of the in-kernel
    rejection. It is then responsible for rejecting ones that
    it decided not to handle. There is no unregistration, but
    the socket can be closed for that.
    
    Frames that are not registered for will not be forwarded
    to userspace and will be rejected by the kernel, the
    cfg80211 API helps implementing that.
    
    Additionally, this patch adds a new command that allows
    doing action frame transmission from userspace. It can be
    used either to exchange action frames on the current
    operational channel (e.g., with the AP with which we are
    currently associated) or to exchange off-channel Public
    Action frames with the remain-on-channel command.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c326a667022a..d52da913145a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -329,6 +329,15 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 			       const u8 *resp_ie, size_t resp_ie_len,
 			       u16 status, bool wextev,
 			       struct cfg80211_bss *bss);
+int cfg80211_mlme_register_action(struct wireless_dev *wdev, u32 snd_pid,
+				  const u8 *match_data, int match_len);
+void cfg80211_mlme_unregister_actions(struct wireless_dev *wdev, u32 nlpid);
+void cfg80211_mlme_purge_actions(struct wireless_dev *wdev);
+int cfg80211_mlme_action(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 struct ieee80211_channel *chan,
+			 enum nl80211_channel_type channel_type,
+			 const u8 *buf, size_t len, u64 *cookie);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 5f2aa25e0e5b221a176ab3d1c51d51da265cb4a7
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun Jan 17 15:49:02 2010 +0100

    cfg80211: rcu-ify rdev and wdev
    
    Future code will need to look up rdev and wdev
    within atomic sections, but currently we need
    to lock a mutex for such lookups. Change the
    list handling for both to be RCU-safe so that
    we can look them up in rcu sections instead in
    the future.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2d6a6b9c0c43..c326a667022a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -1,7 +1,7 @@
 /*
  * Wireless configuration interface internals.
  *
- * Copyright 2006-2009	Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
@@ -48,6 +48,7 @@ struct cfg80211_registered_device {
 
 	/* associate netdev list */
 	struct mutex devlist_mtx;
+	/* protected by devlist_mtx or RCU */
 	struct list_head netdev_list;
 	int devlist_generation;
 	int opencount; /* also protected by devlist_mtx */

commit 34a6eddbabd704b3c7dae9362234552267573be2
Author: Jouni Malinen <j@w1.fi>
Date:   Wed Jan 6 16:19:24 2010 +0200

    cfg80211: Store IEs from both Beacon and Probe Response frames
    
    Store information elements from Beacon and Probe Response frames in
    separate buffers to allow both sets to be made available through
    nl80211. This allows user space applications to get access to IEs from
    Beacon frames even if we have received Probe Response frames from the
    BSS. Previously, the IEs from Probe Response frames would have
    overridden the IEs from Beacon frames.
    
    This feature is of somewhat limited use since most protocols include
    the same (or extended) information in Probe Response frames. However,
    there are couple of exceptions where the IEs from Beacon frames could
    be of some use: TIM IE is only included in Beacon frames (and it would
    be needed to figure out the DTIM period used in the BSS) and at least
    some implementations of Wireless Provisioning Services seem to include
    the full IE only in Beacon frames).
    
    The new BSS attribute for scan results is added to allow both the IE
    sets to be delivered. This is done in a way that maintains the
    previously used behavior for applications that are not aware of the
    new NL80211_BSS_BEACON_IES attribute.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 30ec95f05b52..2d6a6b9c0c43 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -111,7 +111,8 @@ struct cfg80211_internal_bss {
 	unsigned long ts;
 	struct kref ref;
 	atomic_t hold;
-	bool ies_allocated;
+	bool beacon_ies_allocated;
+	bool proberesp_ies_allocated;
 
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;

commit 9588bbd5529461a3dacd435bf239c84c3508f569
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Wed Dec 23 13:15:41 2009 +0100

    cfg80211: add remain-on-channel command
    
    Add new commands for requesting the driver to remain awake
    on a specified channel for the specified amount of time
    (and another command to cancel such an operation). This
    can be used to implement userspace-controlled off-channel
    operations, like Public Action frame exchange on another
    channel than the operation channel.
    
    The off-channel operation should behave similarly to scan,
    i.e. the local station (if associated) moves into power
    save mode to request the AP to buffer frames for it and
    then moves to the other channel to allow the off-channel
    operation to be completed. The duration parameter can be
    used to request enough time to receive a response from
    the target station.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 35b712127143..30ec95f05b52 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -374,6 +374,9 @@ void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 struct ieee80211_channel *
 rdev_fixed_channel(struct cfg80211_registered_device *rdev,
 		   struct wireless_dev *for_wdev);
+struct ieee80211_channel *
+rdev_freq_to_chan(struct cfg80211_registered_device *rdev,
+		  int freq, enum nl80211_channel_type channel_type);
 int rdev_set_freq(struct cfg80211_registered_device *rdev,
 		  struct wireless_dev *for_wdev,
 		  int freq, enum nl80211_channel_type channel_type);

commit 254416aae70ab2e6b57fd79782c8a67196234d02
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Dec 9 16:43:52 2009 -0500

    wireless: report reasonable bitrate for MCS rates through wext
    
    Previously, cfg80211 had reported "0" for MCS (i.e. 802.11n) bitrates
    through the wireless extensions interface.  However, nl80211 was
    converting MCS rates into a reasonable bitrate number.  This patch moves
    the nl80211 code to cfg80211 where it is now shared between both the
    nl80211 interface and the wireless extensions interface.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 4ef3efc94106..35b712127143 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -378,6 +378,8 @@ int rdev_set_freq(struct cfg80211_registered_device *rdev,
 		  struct wireless_dev *for_wdev,
 		  int freq, enum nl80211_channel_type channel_type);
 
+u16 cfg80211_calculate_bitrate(struct rate_info *rate);
+
 #ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
 #define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
 #else

commit e60d7443e00a72a2c056950cdaab79c7b077f3d4
Author: Alban Browaeys <prahal@yahoo.com>
Date:   Wed Nov 25 15:13:00 2009 +0100

    wireless : use a dedicated workqueue for cfg80211.
    
    This patch moves the works cleanup, scan and events to a cfg80211
    dedicated workqueue.
    
    Platform driver like eeepc-laptop ought to use works to rfkill (as
    new rfkill does lock in rfkill_unregister and the platform driver is
    called from rfkill_switch_all which also lock the same mutex).
    This raise a new issue in itself that the work scheduled by the platform
    driver to the global worqueue calls wiphy_unregister which flush_work
    scan and event works (which thus flush works on the global workqueue inside
    a work on the global workqueue) and also put on hold the  wdev_cleanup_work
     (which prevents the dev_put on netdev thus indefinite Usage count error on
    wifi device).
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Alban Browaeys <prahal@yahoo.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index a9db9e6255bb..4ef3efc94106 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -91,6 +91,8 @@ bool wiphy_idx_valid(int wiphy_idx)
 	return (wiphy_idx >= 0);
 }
 
+
+extern struct workqueue_struct *cfg80211_wq;
 extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_rdev_list;
 extern int cfg80211_rdev_list_generation;

commit 98d3a7ca9232a436c067888936a0133e64ea126a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Nov 18 13:03:43 2009 +0100

    cfg80211: re-join IBSS when privacy changes
    
    When going from/to a WEP protected IBSS, we need to
    leave this one and join a new one to take care of
    the changed capability.
    
    Cc: Hong Zhang <henryzhang62@yahoo.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5aeebb9085f8..a9db9e6255bb 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -273,6 +273,8 @@ int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 		       struct cfg80211_ibss_params *params,
 		       struct cfg80211_cached_keys *connkeys);
 void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
+int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
 void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);

commit 7bcfaf2f431c09c51fe776fc06638b25d3b421c5
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 27 12:59:03 2009 +0100

    cfg80211/mac80211: use debugfs_remove_recursive
    
    We can save a lot of code and pointers in the structs
    by using debugfs_remove_recursive().
    
    First, change cfg80211 to use debugfs_remove_recursive()
    so that drivers do not need to clean up any files they
    added to the per-wiphy debugfs (if and only if they are
    ok to be accessed until after wiphy_unregister!).
    
    Then also make mac80211 use debugfs_remove_recursive()
    where necessary -- it need not remove per-wiphy files
    as cfg80211 now removes those, but netdev etc. files
    still need to be handled but can now be removed without
    needing struct dentry pointers to all of them.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 68b321997d4c..5aeebb9085f8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -72,17 +72,6 @@ struct cfg80211_registered_device {
 	/* current channel */
 	struct ieee80211_channel *channel;
 
-#ifdef CONFIG_CFG80211_DEBUGFS
-	/* Debugfs entries */
-	struct wiphy_debugfsdentries {
-		struct dentry *rts_threshold;
-		struct dentry *fragmentation_threshold;
-		struct dentry *short_retry_limit;
-		struct dentry *long_retry_limit;
-		struct dentry *ht40allow_map;
-	} debugfs;
-#endif
-
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));

commit 7d930bc33653d5592dc386a76a38f39c2e962344
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 20 15:08:53 2009 +0900

    cfg80211: sme: deauthenticate on assoc failure
    
    When the in-kernel SME gets an association failure from
    the AP we don't deauthenticate, and thus get into a very
    confused state which will lead to warnings later on. Fix
    this by actually deauthenticating when the AP indicates
    an association failure.
    
    (Brought to you by the hacking session at Kernel Summit 2009 in Tokyo,
    Japan. -- JWL)
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2a33d8bc886b..68b321997d4c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -358,6 +358,7 @@ int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 
 void cfg80211_conn_work(struct work_struct *work);
+void cfg80211_sme_failed_assoc(struct wireless_dev *wdev);
 bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
 
 /* internal helpers */

commit 3d54d25515838543e56889aa7e48f40d00719368
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Aug 21 14:51:05 2009 +0200

    cfg80211: clean up properly on interface type change
    
    When the interface type changes while connected, and the
    driver does not require the interface to be down for a
    type change, it is currently possible to get very strange
    results unless the driver takes special care, which it
    shouldn't have to.
    
    To fix this, take care to disconnect/leave IBSS when
    changing the interface type -- even if the driver may fail
    the call. Also process all events that may be pending to
    avoid running into a situation where an event is reported
    but only processed after the type has already changed,
    which would lead to missing events and warnings.
    
    A side effect of this is that you will have disconnected
    or left the IBSS even if the mode change ultimately fails,
    but since the intention was to change it and thus leave or
    disconnect, this is not a problem.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d262d42cbd5e..2a33d8bc886b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -372,6 +372,10 @@ void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
+int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev, enum nl80211_iftype ntype,
+			  u32 *flags, struct vif_params *params);
+void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev);
 
 struct ieee80211_channel *
 rdev_fixed_channel(struct cfg80211_registered_device *rdev,

commit f7969969f416e593bcc7dc24abf3f9fd6c27136d
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Aug 21 12:23:49 2009 +0200

    cfg80211: make spurious warnings less likely, configurable
    
    Bob reported that he got warnings in IBSS mode about
    the ssid_len being zero on a joined event, but only
    when kmemcheck was enabled. This appears to be due
    to a race condition between drivers and userspace,
    when the driver reports joined but the user in the
    meantime decided to leave the IBSS again, the warning
    would trigger. This was made more likely by kmemcheck
    delaying the code that does the check and sends the
    event.
    
    So first, make the warning trigger closer to the
    driver, which means it's not locked, but since only
    the warning depends on it that's ok.
    
    And secondly, users will not want to have spurious
    warnings at all, so make those that are known to be
    racy in such a way configurable.
    
    Reported-by: Bob Copeland <me@bobcopeland.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 68eaf340d613..d262d42cbd5e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -380,4 +380,15 @@ int rdev_set_freq(struct cfg80211_registered_device *rdev,
 		  struct wireless_dev *for_wdev,
 		  int freq, enum nl80211_channel_type channel_type);
 
+#ifdef CONFIG_CFG80211_DEVELOPER_WARNINGS
+#define CFG80211_DEV_WARN_ON(cond)	WARN_ON(cond)
+#else
+/*
+ * Trick to enable using it as a condition,
+ * and also not give a warning when it's
+ * not used that way.
+ */
+#define CFG80211_DEV_WARN_ON(cond)	({bool __r = (cond); __r; })
+#endif
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 01a0ac417ce9b4f1216a266f2fd454cffefc5aee
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Aug 20 21:36:16 2009 +0200

    cfg80211: check lost scans later, fix bug
    
    When we lose a scan, cfg80211 tries to clean up after
    the driver. However, it currently does this too early,
    it does this in GOING_DOWN already instead of DOWN, so
    it may happen with mac80211. Besides fixing this, also
    make it more robust by leaking the scan request so if
    the driver later actually finishes the scan, it won't
    crash. Also check in ___cfg80211_scan_done whether a
    scan request is still pending and exit if not.
    
    Reported-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Tested-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f565432ae22f..68eaf340d613 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -370,7 +370,7 @@ void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev);
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 
 struct ieee80211_channel *

commit ad002395fd230528281083f4be71855ed7e35b04
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Aug 18 19:51:57 2009 +0200

    cfg80211: fix dangling scan request checking
    
    My patch "cfg80211: fix deadlock" broke the code it
    was supposed to fix, the scan request checking. But
    it's not trivial to put it back the way it was, since
    the original patch had a deadlock.
    
    Now do it in a completely new way: queue the check
    off to a work struct, where we can freely lock. But
    that has some more complications, like needing to
    wait for it to be done before the wiphy/rdev can be
    destroyed, so some code is required to handle that.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index c603f5286326..f565432ae22f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -50,6 +50,8 @@ struct cfg80211_registered_device {
 	struct mutex devlist_mtx;
 	struct list_head netdev_list;
 	int devlist_generation;
+	int opencount; /* also protected by devlist_mtx */
+	wait_queue_head_t dev_wait;
 
 	/* BSSes/scanning */
 	spinlock_t bss_lock;

commit 36e6fea84905512ea776707e82b5b435220efc17
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Aug 12 22:21:21 2009 +0200

    cfg80211: check for and abort dangling scan requests
    
    If you trigger a scan request on an interface and then
    take it down, or rmmod the module or unplug the device
    the driver might "forget" to cancel the scan request.
    That is a bug in the driver, but the current behaviour
    is that we just hang endlessly waiting for the netdev
    refcount to become 0 which it never will. To improve
    robustness, check for this situation in cfg80211, warn
    about it and clean up behind the driver. I don't just
    clean up silently because it's likely that the driver
    also has some internal state it has now leaked.
    
    Additionally, this fixes a locking bug, clearing the
    scan_req pointer should be done under the rdev lock.
    
    Finally, we also need to _wait_ for the scan work and
    not just abort it since it might be pending and wanting
    to do a cleanup.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f7be3a9b427e..c603f5286326 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -368,6 +368,7 @@ void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 
 struct ieee80211_channel *

commit 4b181144e6c1c25aaba9b9fc7cc70c95495ecb92
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sat Aug 8 11:03:58 2009 +0200

    cfg80211: fix locking for SIWFREQ
    
    "cfg80211: validate channel settings across interfaces"
    contained a locking bug -- in the managed-mode SIWFREQ
    call it would end up running into a lock recursion.
    
    This fixes it by not checking that particular interface
    for a channel that it needs to stay on, which is as it
    should be as that's the interface we're setting the
    channel for.
    
    Reported-by: Reinette Chatre <reinette.chatre@intel.com>
    Reported-by: Kalle Valo <kalle.valo@iki.fi>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Tested-by: Kalle Valo <kalle.valo@iki.fi>
    Tested-by: Reinette Chatre <reinette.chatre@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 639db52eeff7..f7be3a9b427e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -374,6 +374,7 @@ struct ieee80211_channel *
 rdev_fixed_channel(struct cfg80211_registered_device *rdev,
 		   struct wireless_dev *for_wdev);
 int rdev_set_freq(struct cfg80211_registered_device *rdev,
+		  struct wireless_dev *for_wdev,
 		  int freq, enum nl80211_channel_type channel_type);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit f5ea9120be2e5d5c846243416cfdce01d02f5836
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Aug 7 16:17:38 2009 +0200

    nl80211: add generation number to all dumps
    
    In order for userspace to be able to figure out whether
    it obtained a consistent snapshot of data or not when
    using netlink dumps, we need to have a generation number
    in each dump message that indicates whether the list has
    changed or not -- its value is arbitrary.
    
    This patch adds such a number to all dumps, this needs
    some mac80211 involvement to keep track of a generation
    number to start with when adding/removing mesh paths or
    stations.
    
    The wiphy and netdev lists can be fully handled within
    cfg80211, of course, but generation numbers need to be
    stored there as well.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 92e0492b0e4d..639db52eeff7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -49,6 +49,7 @@ struct cfg80211_registered_device {
 	/* associate netdev list */
 	struct mutex devlist_mtx;
 	struct list_head netdev_list;
+	int devlist_generation;
 
 	/* BSSes/scanning */
 	spinlock_t bss_lock;
@@ -101,6 +102,7 @@ bool wiphy_idx_valid(int wiphy_idx)
 
 extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_rdev_list;
+extern int cfg80211_rdev_list_generation;
 
 #define assert_cfg80211_lock() WARN_ON(!mutex_is_locked(&cfg80211_mutex))
 

commit f401a6f7ede753e56b84025e7d2db0d5ef560ce6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Aug 7 14:51:05 2009 +0200

    cfg80211: use reassociation when possible
    
    With the move of everything related to the SME from
    mac80211 to cfg80211, we lost the ability to send
    reassociation frames. This adds them back, but only
    for wireless extensions. With the userspace SME, it
    shall control assoc vs. reassoc (it already can do
    so with the nl80211 interface).
    
    I haven't touched the connect() implementation, so
    it is not possible to reassociate with the nl80211
    connect primitive. I think that should be done with
    the NL80211_CMD_ROAM command, but we'll have to see
    how that can be handled in the future, especially
    with fullmac chips.
    
    This patch addresses only the immediate regression
    we had in mac80211, which previously sent reassoc.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5696b95af9be..92e0492b0e4d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -335,7 +335,8 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
 		       struct cfg80211_connect_params *connect,
-		       struct cfg80211_cached_keys *connkeys);
+		       struct cfg80211_cached_keys *connkeys,
+		       const u8 *prev_bssid);
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
 		     struct cfg80211_connect_params *connect,
@@ -353,6 +354,7 @@ int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 
 void cfg80211_conn_work(struct work_struct *work);
+bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
 
 /* internal helpers */
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,

commit 59bbb6f7574bc693ed8313b98eac641116c95b94
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Aug 7 17:22:35 2009 +0200

    cfg80211: validate channel settings across interfaces
    
    Currently, there's a problem that affects regulatory
    enforcement and connection stability, in that it is
    possible to switch the channel while connected to a
    network or joined to an IBSS.
    
    The problem comes from the fact that we only validate
    the channel against the current interface's type, not
    against any other interface. Thus, you have any type
    of interface up, additionally bring up a monitor mode
    interface and switch the channel on the monitor. This
    will obviously also switch the channel on the other
    interface.
    
    The problem now is that if you do that while sending
    beacons for IBSS mode, you can switch to a disabled
    channel or a channel that doesn't allow beaconing.
    Combined with a managed mode interface connected to
    an AP instead of an IBSS interface, you can easily
    break the connection that way.
    
    To fix this, this patch validates any channel change
    with all available interfaces, and disallows such
    changes on secondary interfaces if another interface
    is connected to an AP or joined to an IBSS.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 325c17e6198c..5696b95af9be 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -366,4 +366,10 @@ void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 
+struct ieee80211_channel *
+rdev_fixed_channel(struct cfg80211_registered_device *rdev,
+		   struct wireless_dev *for_wdev);
+int rdev_set_freq(struct cfg80211_registered_device *rdev,
+		  int freq, enum nl80211_channel_type channel_type);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit df7fc0f9735085bb617fff774bfd71465edb448c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 29 11:23:49 2009 +0200

    cfg80211: keep track of current_bss for userspace SME
    
    When a userspace SME is active, we're currently not
    keeping track of the BSS properly for reporting the
    current link and for internal use. Additionally, it
    looks like there is a possible BSS leak in that the
    BSS never gets removed from auth_bsses[]. To fix it,
    pass the BSS struct to __cfg80211_connect_result in
    this case.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6d903c1d721d..325c17e6198c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -127,6 +127,11 @@ static inline struct cfg80211_internal_bss *bss_from_pub(struct cfg80211_bss *pu
 	return container_of(pub, struct cfg80211_internal_bss, pub);
 }
 
+static inline void cfg80211_ref_bss(struct cfg80211_internal_bss *bss)
+{
+	kref_get(&bss->ref);
+}
+
 static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 {
 	atomic_inc(&bss->hold);
@@ -323,7 +328,8 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 			       const u8 *req_ie, size_t req_ie_len,
 			       const u8 *resp_ie, size_t resp_ie_len,
-			       u16 status, bool wextev);
+			       u16 status, bool wextev,
+			       struct cfg80211_bss *bss);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,

commit 0e82ffe3b90bcad72cfe80e4379946b8fb0691ca
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Jul 27 12:01:50 2009 +0200

    cfg80211: combine iwfreq implementations
    
    Until now we implemented iwfreq for managed mode, we
    needed to keep the implementations separate, but now
    that we have all versions implemented we can combine
    them and export just one handler.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 4276b70cd975..6d903c1d721d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -66,6 +66,9 @@ struct cfg80211_registered_device {
 	struct work_struct conn_work;
 	struct work_struct event_work;
 
+	/* current channel */
+	struct ieee80211_channel *channel;
+
 #ifdef CONFIG_CFG80211_DEBUGFS
 	/* Debugfs entries */
 	struct wiphy_debugfsdentries {

commit 463d018323851a608eef52a9427b0585005c647f
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jul 14 00:33:35 2009 +0200

    cfg80211: make aware of net namespaces
    
    In order to make cfg80211/nl80211 aware of network namespaces,
    we have to do the following things:
    
     * del_virtual_intf method takes an interface index rather
       than a netdev pointer - simply change this
    
     * nl80211 uses init_net a lot, it changes to use the sender's
       network namespace
    
     * scan requests use the interface index, hold a netdev pointer
       and reference instead
    
     * we want a wiphy and its associated virtual interfaces to be
       in one netns together, so
        - we need to be able to change ns for a given interface, so
          export dev_change_net_namespace()
        - for each virtual interface set the NETIF_F_NETNS_LOCAL
          flag, and clear that flag only when the wiphy changes ns,
          to disallow breaking this invariant
    
     * when a network namespace goes away, we need to reparent the
       wiphy to init_net
    
     * cfg80211 users that support creating virtual interfaces must
       create them in the wiphy's namespace, currently this affects
       only mac80211
    
    The end result is that you can now switch an entire wiphy into
    a different network namespace with the new command
            iw phy#<idx> set netns <pid>
    and all virtual interfaces will follow (or the operation fails).
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2ec8ddbe57de..4276b70cd975 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -170,7 +170,10 @@ struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 
 /* identical to cfg80211_get_dev_from_info but only operate on ifindex */
 extern struct cfg80211_registered_device *
-cfg80211_get_dev_from_ifindex(int ifindex);
+cfg80211_get_dev_from_ifindex(struct net *net, int ifindex);
+
+int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
+			  struct net *net);
 
 static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *rdev)
 {

commit fffd0934b9390f34bec45762192b7edd3b12b4b5
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 8 14:22:54 2009 +0200

    cfg80211: rework key operation
    
    This reworks the key operation in cfg80211, and now only
    allows, from userspace, configuring keys (via nl80211)
    after the connection has been established (in managed
    mode), the IBSS been joined (in IBSS mode), at any time
    (in AP[_VLAN] modes) or never for all the other modes.
    
    In order to do shared key authentication correctly, it
    is now possible to give a WEP key to the AUTH command.
    To configure static WEP keys, these are given to the
    CONNECT or IBSS_JOIN command directly, for a userspace
    SME it is assumed it will configure it properly after
    the connection has been established.
    
    Since mac80211 used to check the default key in IBSS
    mode to see whether or not the network is protected,
    it needs an update in that area, as well as an update
    to make use of the WEP key passed to auth() for shared
    key authentication.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e46cd6eb61d7..2ec8ddbe57de 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -238,6 +238,12 @@ struct cfg80211_event {
 	};
 };
 
+struct cfg80211_cached_keys {
+	struct key_params params[6];
+	u8 data[6][WLAN_MAX_KEY_LEN];
+	int def, defmgmt;
+};
+
 
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
@@ -256,14 +262,18 @@ void cfg80211_bss_age(struct cfg80211_registered_device *dev,
 /* IBSS */
 int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
-			 struct cfg80211_ibss_params *params);
+			 struct cfg80211_ibss_params *params,
+			 struct cfg80211_cached_keys *connkeys);
 int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       struct cfg80211_ibss_params *params);
+		       struct cfg80211_ibss_params *params,
+		       struct cfg80211_cached_keys *connkeys);
 void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
 void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
+int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
+			    struct wireless_dev *wdev);
 
 /* MLME */
 int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
@@ -272,12 +282,14 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			 enum nl80211_auth_type auth_type,
 			 const u8 *bssid,
 			 const u8 *ssid, int ssid_len,
-			 const u8 *ie, int ie_len);
+			 const u8 *ie, int ie_len,
+			 const u8 *key, int key_len, int key_idx);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, struct ieee80211_channel *chan,
 		       enum nl80211_auth_type auth_type, const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
-		       const u8 *ie, int ie_len);
+		       const u8 *ie, int ie_len,
+		       const u8 *key, int key_len, int key_idx);
 int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev,
 			  struct ieee80211_channel *chan,
@@ -310,10 +322,12 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       struct cfg80211_connect_params *connect);
+		       struct cfg80211_connect_params *connect,
+		       struct cfg80211_cached_keys *connkeys);
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
-		     struct cfg80211_connect_params *connect);
+		     struct cfg80211_connect_params *connect,
+		     struct cfg80211_cached_keys *connkeys);
 int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			  struct net_device *dev, u16 reason,
 			  bool wextev);
@@ -323,11 +337,14 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 void __cfg80211_roamed(struct wireless_dev *wdev, const u8 *bssid,
 		       const u8 *req_ie, size_t req_ie_len,
 		       const u8 *resp_ie, size_t resp_ie_len);
+int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev);
 
 void cfg80211_conn_work(struct work_struct *work);
 
 /* internal helpers */
-int cfg80211_validate_key_settings(struct key_params *params, int key_idx,
+int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
+				   struct key_params *params, int key_idx,
 				   const u8 *mac_addr);
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
@@ -335,5 +352,6 @@ void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 void __cfg80211_scan_done(struct work_struct *wk);
+void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit 79c97e97aed7f760d2826c7daf2d42d8eefe9838
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jul 7 03:56:12 2009 +0200

    cfg80211: clean up naming once and for all
    
    We've named the registered devices 'drv' sometimes,
    thinking of "driver", which is not what it is, it's
    the internal representation of a wiphy, i.e. a
    device. Let's clean up the naming once and and use
    'rdev' aka 'registered device' everywhere.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5ccd642e183b..e46cd6eb61d7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -97,13 +97,13 @@ bool wiphy_idx_valid(int wiphy_idx)
 }
 
 extern struct mutex cfg80211_mutex;
-extern struct list_head cfg80211_drv_list;
+extern struct list_head cfg80211_rdev_list;
 
 #define assert_cfg80211_lock() WARN_ON(!mutex_is_locked(&cfg80211_mutex))
 
 /*
  * You can use this to mark a wiphy_idx as not having an associated wiphy.
- * It guarantees cfg80211_drv_by_wiphy_idx(wiphy_idx) will return NULL
+ * It guarantees cfg80211_rdev_by_wiphy_idx(wiphy_idx) will return NULL
  */
 #define WIPHY_IDX_STALE -1
 
@@ -136,11 +136,11 @@ static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 }
 
 
-struct cfg80211_registered_device *cfg80211_drv_by_wiphy_idx(int wiphy_idx);
+struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
 struct cfg80211_registered_device *
-__cfg80211_drv_from_info(struct genl_info *info);
+__cfg80211_rdev_from_info(struct genl_info *info);
 
 /*
  * This function returns a pointer to the driver
@@ -153,7 +153,7 @@ __cfg80211_drv_from_info(struct genl_info *info);
  *
  * This is necessary because we need to lock the global
  * mutex to get an item off the list safely, and then
- * we lock the drv mutex so it doesn't go away under us.
+ * we lock the rdev mutex so it doesn't go away under us.
  *
  * We don't want to keep cfg80211_mutex locked
  * for all the time in order to allow requests on
@@ -165,22 +165,22 @@ __cfg80211_drv_from_info(struct genl_info *info);
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_info(struct genl_info *info);
 
-/* requires cfg80211_drv_mutex to be held! */
+/* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 
 /* identical to cfg80211_get_dev_from_info but only operate on ifindex */
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_ifindex(int ifindex);
 
-static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *drv)
+static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *rdev)
 {
-	mutex_lock(&drv->mtx);
+	mutex_lock(&rdev->mtx);
 }
 
-static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *drv)
+static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *rdev)
 {
-	BUG_ON(IS_ERR(drv) || !drv);
-	mutex_unlock(&drv->mtx);
+	BUG_ON(IS_ERR(rdev) || !rdev);
+	mutex_unlock(&rdev->mtx);
 }
 
 static inline void wdev_lock(struct wireless_dev *wdev)
@@ -240,9 +240,9 @@ struct cfg80211_event {
 
 
 /* free object */
-extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);
+extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
 
-extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
+extern int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
 			       char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);

commit 667503ddcb96f3b10211f997fe55907fa7509841
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jul 7 03:56:11 2009 +0200

    cfg80211: fix locking
    
    Over time, a lot of locking issues have crept into
    the smarts of cfg80211, so e.g. scan completion can
    race against a new scan, IBSS join can race against
    leaving an IBSS, etc.
    
    Introduce a new per-interface lock that protects
    most of the per-interface data that we need to keep
    track of, and sprinkle assertions about that lock
    everywhere. Some things now need to be offloaded to
    work structs so that we don't require being able to
    sleep in functions the drivers call. The exception
    to that are the MLME callbacks (rx_auth etc.) that
    currently only mac80211 calls because it was easier
    to do that there instead of in cfg80211, and future
    drivers implementing those calls will, if they ever
    exist, probably need to use a similar scheme like
    mac80211 anyway...
    
    In order to be able to handle _deauth and _disassoc
    properly, introduce a cookie passed to it that will
    determine locking requirements.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 92da612b3f9e..5ccd642e183b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -57,12 +57,14 @@ struct cfg80211_registered_device {
 	u32 bss_generation;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	unsigned long suspend_at;
+	struct work_struct scan_done_wk;
 
 #ifdef CONFIG_NL80211_TESTMODE
 	struct genl_info *testmode_info;
 #endif
 
 	struct work_struct conn_work;
+	struct work_struct event_work;
 
 #ifdef CONFIG_CFG80211_DEBUGFS
 	/* Debugfs entries */
@@ -170,12 +172,73 @@ struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_ifindex(int ifindex);
 
+static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *drv)
+{
+	mutex_lock(&drv->mtx);
+}
+
 static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *drv)
 {
 	BUG_ON(IS_ERR(drv) || !drv);
 	mutex_unlock(&drv->mtx);
 }
 
+static inline void wdev_lock(struct wireless_dev *wdev)
+	__acquires(wdev)
+{
+	mutex_lock(&wdev->mtx);
+	__acquire(wdev->mtx);
+}
+
+static inline void wdev_unlock(struct wireless_dev *wdev)
+	__releases(wdev)
+{
+	__release(wdev->mtx);
+	mutex_unlock(&wdev->mtx);
+}
+
+#define ASSERT_RDEV_LOCK(rdev) WARN_ON(!mutex_is_locked(&(rdev)->mtx));
+#define ASSERT_WDEV_LOCK(wdev) WARN_ON(!mutex_is_locked(&(wdev)->mtx));
+
+enum cfg80211_event_type {
+	EVENT_CONNECT_RESULT,
+	EVENT_ROAMED,
+	EVENT_DISCONNECTED,
+	EVENT_IBSS_JOINED,
+};
+
+struct cfg80211_event {
+	struct list_head list;
+	enum cfg80211_event_type type;
+
+	union {
+		struct {
+			u8 bssid[ETH_ALEN];
+			const u8 *req_ie;
+			const u8 *resp_ie;
+			size_t req_ie_len;
+			size_t resp_ie_len;
+			u16 status;
+		} cr;
+		struct {
+			u8 bssid[ETH_ALEN];
+			const u8 *req_ie;
+			const u8 *resp_ie;
+			size_t req_ie_len;
+			size_t resp_ie_len;
+		} rm;
+		struct {
+			const u8 *ie;
+			size_t ie_len;
+			u16 reason;
+		} dc;
+		struct {
+			u8 bssid[ETH_ALEN];
+		} ij;
+	};
+};
+
+
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);
 
@@ -191,25 +254,46 @@ void cfg80211_bss_age(struct cfg80211_registered_device *dev,
                       unsigned long age_secs);
 
 /* IBSS */
+int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 struct cfg80211_ibss_params *params);
 int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
 		       struct cfg80211_ibss_params *params);
 void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
 
 /* MLME */
+int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 struct ieee80211_channel *chan,
+			 enum nl80211_auth_type auth_type,
+			 const u8 *bssid,
+			 const u8 *ssid, int ssid_len,
+			 const u8 *ie, int ie_len);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev, struct ieee80211_channel *chan,
 		       enum nl80211_auth_type auth_type, const u8 *bssid,
 		       const u8 *ssid, int ssid_len,
 		       const u8 *ie, int ie_len);
+int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev,
+			  struct ieee80211_channel *chan,
+			  const u8 *bssid, const u8 *prev_bssid,
+			  const u8 *ssid, int ssid_len,
+			  const u8 *ie, int ie_len, bool use_mfp,
+			  struct cfg80211_crypto_settings *crypt);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, struct ieee80211_channel *chan,
 			const u8 *bssid, const u8 *prev_bssid,
 			const u8 *ssid, int ssid_len,
 			const u8 *ie, int ie_len, bool use_mfp,
 			struct cfg80211_crypto_settings *crypt);
+int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
+			   struct net_device *dev, const u8 *bssid,
+			   const u8 *ie, int ie_len, u16 reason);
 int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev, const u8 *bssid,
 			 const u8 *ie, int ie_len, u16 reason);
@@ -218,24 +302,38 @@ int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 			   const u8 *ie, int ie_len, u16 reason);
 void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 			struct net_device *dev);
+void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+			       const u8 *req_ie, size_t req_ie_len,
+			       const u8 *resp_ie, size_t resp_ie_len,
+			       u16 status, bool wextev);
 
 /* SME */
+int __cfg80211_connect(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev,
+		       struct cfg80211_connect_params *connect);
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
 		     struct cfg80211_connect_params *connect);
+int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev, u16 reason,
+			  bool wextev);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
+void __cfg80211_roamed(struct wireless_dev *wdev, const u8 *bssid,
+		       const u8 *req_ie, size_t req_ie_len,
+		       const u8 *resp_ie, size_t resp_ie_len);
 
 void cfg80211_conn_work(struct work_struct *work);
 
 /* internal helpers */
 int cfg80211_validate_key_settings(struct key_params *params, int key_idx,
 				   const u8 *mac_addr);
-void __cfg80211_disconnected(struct net_device *dev, gfp_t gfp, u8 *ie,
+void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 void cfg80211_sme_disassoc(struct net_device *dev, int idx);
+void __cfg80211_scan_done(struct work_struct *wk);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit 4d0c8aead32ecdbe1310ad473b3637991f560865
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jul 7 03:56:09 2009 +0200

    cfg80211: properly name driver locking
    
    Currently we call that cfg80211_put_dev(), but that is
    misleading. With the new convention of using 'rdev' for
    registered_device variables, also call that function
    cfg80211_unlock_rdev().
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 4554453c116a..92da612b3f9e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -146,7 +146,7 @@ __cfg80211_drv_from_info(struct genl_info *info);
  * If successful, it returns non-NULL and also locks
  * the driver's mutex!
  *
- * This means that you need to call cfg80211_put_dev()
+ * This means that you need to call cfg80211_unlock_rdev()
  * before being allowed to acquire &cfg80211_mutex!
  *
  * This is necessary because we need to lock the global
@@ -170,7 +170,11 @@ struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_ifindex(int ifindex);
 
-extern void cfg80211_put_dev(struct cfg80211_registered_device *drv);
+static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *drv)
+{
+	BUG_ON(IS_ERR(drv) || !drv);
+	mutex_unlock(&drv->mtx);
+}
 
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);

commit 3e5d7649a64e558e4146ddfad4dfcf13fc65dd47
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jul 7 14:37:26 2009 +0200

    cfg80211: let SME control reassociation vs. association
    
    Since we don't really know that well in the kernel,
    let's let the SME control whether it wants to use
    reassociation or not, by allowing it to give the
    previous BSSID in the associate() parameters.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 82918f5896a5..4554453c116a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -202,7 +202,8 @@ int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 		       const u8 *ie, int ie_len);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, struct ieee80211_channel *chan,
-			const u8 *bssid, const u8 *ssid, int ssid_len,
+			const u8 *bssid, const u8 *prev_bssid,
+			const u8 *ssid, int ssid_len,
 			const u8 *ie, int ie_len, bool use_mfp,
 			struct cfg80211_crypto_settings *crypt);
 int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,

commit 19957bb399e2722719c0e20c9ae91cf8b6aaff04
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Jul 2 17:20:43 2009 +0200

    cfg80211: keep track of BSSes
    
    In order to avoid problems with BSS structs going away
    while they're in use, I've long wanted to make cfg80211
    keep track of them. Without the SME, that wasn't doable
    but now that we have the SME we can do this too. It can
    keep track of up to four separate authentications and
    one association, regardless of whether it's controlled
    by the cfg80211 SME or the userspace SME.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5209acb0ff7e..82918f5896a5 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -110,12 +110,30 @@ struct cfg80211_internal_bss {
 	struct rb_node rbn;
 	unsigned long ts;
 	struct kref ref;
-	bool hold, ies_allocated;
+	atomic_t hold;
+	bool ies_allocated;
 
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;
 };
 
+static inline struct cfg80211_internal_bss *bss_from_pub(struct cfg80211_bss *pub)
+{
+	return container_of(pub, struct cfg80211_internal_bss, pub);
+}
+
+static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
+{
+	atomic_inc(&bss->hold);
+}
+
+static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
+{
+	int r = atomic_dec_return(&bss->hold);
+	WARN_ON(r < 0);
+}
+
+
 struct cfg80211_registered_device *cfg80211_drv_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
@@ -176,6 +194,26 @@ void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
 
+/* MLME */
+int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev, struct ieee80211_channel *chan,
+		       enum nl80211_auth_type auth_type, const u8 *bssid,
+		       const u8 *ssid, int ssid_len,
+		       const u8 *ie, int ie_len);
+int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
+			struct net_device *dev, struct ieee80211_channel *chan,
+			const u8 *bssid, const u8 *ssid, int ssid_len,
+			const u8 *ie, int ie_len, bool use_mfp,
+			struct cfg80211_crypto_settings *crypt);
+int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev, const u8 *bssid,
+			 const u8 *ie, int ie_len, u16 reason);
+int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
+			   struct net_device *dev, const u8 *bssid,
+			   const u8 *ie, int ie_len, u16 reason);
+void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
+			struct net_device *dev);
+
 /* SME */
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
@@ -193,5 +231,6 @@ void __cfg80211_disconnected(struct net_device *dev, gfp_t gfp, u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 void cfg80211_sme_scan_done(struct net_device *dev);
 void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_sme_disassoc(struct net_device *dev, int idx);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit f21293549f60f88c74fcb9944737f11048896dc4
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 1 21:26:56 2009 +0200

    cfg80211: managed mode wext compatibility
    
    This adds code to make it possible to use the cfg80211
    connect() API with wireless extensions, and because the
    previous patch added emulation of that API with auth()
    and assoc(), by extension also supports wext on that.
    At the same time, removes code from mac80211 for wext,
    but doesn't yet clean up mac80211's mlme code more.
    
    Signed-off-by: Samuel Ortiz <samuel.ortiz@intel.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2c0f64252f3d..5209acb0ff7e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -181,7 +181,8 @@ int cfg80211_connect(struct cfg80211_registered_device *rdev,
 		     struct net_device *dev,
 		     struct cfg80211_connect_params *connect);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
-			struct net_device *dev, u16 reason);
+			struct net_device *dev, u16 reason,
+			bool wextev);
 
 void cfg80211_conn_work(struct work_struct *work);
 

commit 6829c878ecd24ff0ae41b4668c7e9d0f11b66942
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Jul 2 09:13:27 2009 +0200

    cfg80211: emulate connect with auth/assoc
    
    This adds code to cfg80211 so that drivers (mac80211 right
    now) that don't implement connect but rather auth/assoc can
    still be used with the nl80211 connect command. This will
    also be necessary for the wext compat code.
    
    Signed-off-by: Samuel Ortiz <samuel.ortiz@intel.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f93f96f85d2b..2c0f64252f3d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -62,6 +62,8 @@ struct cfg80211_registered_device {
 	struct genl_info *testmode_info;
 #endif
 
+	struct work_struct conn_work;
+
 #ifdef CONFIG_CFG80211_DEBUGFS
 	/* Debugfs entries */
 	struct wiphy_debugfsdentries {
@@ -181,8 +183,14 @@ int cfg80211_connect(struct cfg80211_registered_device *rdev,
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason);
 
+void cfg80211_conn_work(struct work_struct *work);
+
 /* internal helpers */
 int cfg80211_validate_key_settings(struct key_params *params, int key_idx,
 				   const u8 *mac_addr);
+void __cfg80211_disconnected(struct net_device *dev, gfp_t gfp, u8 *ie,
+			     size_t ie_len, u16 reason, bool from_ap);
+void cfg80211_sme_scan_done(struct net_device *dev);
+void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit b23aa676ab9d54469cda9f7151f51a2851c6f36e
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Jul 1 21:26:54 2009 +0200

    cfg80211: connect/disconnect API
    
    This patch introduces the cfg80211 connect/disconnect API.
    The goal here is to run the AUTH and ASSOC steps in one call.
    This is needed for some fullmac cards that run both steps
    directly from the target, after the host driver sends a
    connect command.
    
    Additionally, all the new crypto parameters for connect()
    are now also valid for associate() -- although associate
    requires the IEs to be used, the information can be useful
    for drivers and should be given.
    
    Signed-off-by: Samuel Ortiz <samuel.ortiz@intel.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bc084b68865c..f93f96f85d2b 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -174,6 +174,13 @@ void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
 
+/* SME */
+int cfg80211_connect(struct cfg80211_registered_device *rdev,
+		     struct net_device *dev,
+		     struct cfg80211_connect_params *connect);
+int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
+			struct net_device *dev, u16 reason);
+
 /* internal helpers */
 int cfg80211_validate_key_settings(struct key_params *params, int key_idx,
 				   const u8 *mac_addr);

commit aff89a9b9084931e51b89d8f3ee3c547bea6c422
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 1 21:26:51 2009 +0200

    cfg80211: introduce nl80211 testmode command
    
    This introduces a new NL80211_CMD_TESTMODE for testing
    and calibration use with nl80211. There's no multiplexing
    like like iwpriv had, and the command is not available by
    default, it needs to be explicitly enabled in Kconfig and
    shouldn't be enabled in most kernels.
    
    The command requires a wiphy index or interface index to
    identify the device to operate on, and the new TESTDATA
    attribute. There also is API for sending replies to the
    command, and testmode multicast messages (on a testmode
    multicast group).
    
    I've also updated mac80211 to be able to pass through the
    command to the driver, since it itself doesn't implement
    the testmode command.
    
    Additionally, to give people an idea of how to use the
    command, I've added a little code to hwsim that makes use
    of the new command to set the powersave mode, this is
    currently done via debugfs and should remain there, and
    the testmode command only serves as an example of how to
    use this best -- with nested netlink attributes in the
    TESTDATA attribute. A hwsim testmode tool can be found at
    http://git.sipsolutions.net/hwsim.git/. This tool is BSD
    licensed so people can easily use it as a basis for their
    own internal fabrication and validation tools.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index bfa340c7abb5..bc084b68865c 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -58,6 +58,10 @@ struct cfg80211_registered_device {
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	unsigned long suspend_at;
 
+#ifdef CONFIG_NL80211_TESTMODE
+	struct genl_info *testmode_info;
+#endif
+
 #ifdef CONFIG_CFG80211_DEBUGFS
 	/* Debugfs entries */
 	struct wiphy_debugfsdentries {

commit 1f87f7d3a3b42b20f34cb03f0fd1a41c3d0e27f3
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jun 2 13:01:41 2009 +0200

    cfg80211: add rfkill support
    
    To be easier on drivers and users, have cfg80211 register an
    rfkill structure that drivers can access. When soft-killed,
    simply take down all interfaces; when hard-killed the driver
    needs to notify us and we will take down the interfaces
    after the fact. While rfkilled, interfaces cannot be set UP.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index ab512bcd8153..bfa340c7abb5 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -11,6 +11,8 @@
 #include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <linux/debugfs.h>
+#include <linux/rfkill.h>
+#include <linux/workqueue.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
 #include "reg.h"
@@ -24,6 +26,11 @@ struct cfg80211_registered_device {
 	 * any call is in progress */
 	struct mutex mtx;
 
+	/* rfkill support */
+	struct rfkill_ops rfkill_ops;
+	struct rfkill *rfkill;
+	struct work_struct rfkill_sync;
+
 	/* ISO / IEC 3166 alpha2 for which this device is receiving
 	 * country IEs on, this can help disregard country IEs from APs
 	 * on the same alpha2 quickly. The alpha2 may differ from

commit e43e820c9cc5cc37ca8fc07d1f18cb29f13a2ce8
Author: Pavel Roskin <proski@gnu.org>
Date:   Mon May 18 21:43:52 2009 -0400

    cfg80211: fix compile error with CONFIG_CFG80211_DEBUGFS
    
    If CONFIG_CFG80211_DEBUGFS is enabled and CONFIG_MAC80211_DEBUGFS is
    not, compilation fails in net/wireless/debugfs.c:
    
    net/wireless/debugfs.c: In function 'cfg80211_debugfs_drv_add':
    net/wireless/debugfs.c:117: error: 'struct cfg80211_registered_device'
    has no member named 'debugfs'
    
    The debugfs filed is needed if and only if CONFIG_CFG80211_DEBUGFS is
    enabled, so use that instead of CONFIG_MAC80211_DEBUGFS.
    
    Signed-off-by: Pavel Roskin <proski@gnu.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 9511c2be83d8..ab512bcd8153 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -51,7 +51,7 @@ struct cfg80211_registered_device {
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	unsigned long suspend_at;
 
-#ifdef CONFIG_MAC80211_DEBUGFS
+#ifdef CONFIG_CFG80211_DEBUGFS
 	/* Debugfs entries */
 	struct wiphy_debugfsdentries {
 		struct dentry *rts_threshold;

commit 3dcf670baf3d3a9bfc752e59d0b1a8d886230750
Author: David Kilroy <kilroyd@googlemail.com>
Date:   Sat May 16 23:13:46 2009 +0100

    cfg80211: mark ops as pointer to const
    
    This allows drivers to mark their cfg80211_ops tables const.
    
    Signed-off-by: David Kilroy <kilroyd@googlemail.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 88f234c8f6b3..9511c2be83d8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -16,7 +16,7 @@
 #include "reg.h"
 
 struct cfg80211_registered_device {
-	struct cfg80211_ops *ops;
+	const struct cfg80211_ops *ops;
 	struct list_head list;
 	/* we hold this mutex during any call so that
 	 * we cannot do multiple calls at once, and also

commit 80a3511d70e8fc7ed3fe4417d7b0bf6c3f642f64
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat May 2 00:39:30 2009 -0400

    cfg80211: add debugfs HT40 allow map
    
    Here's a screenshot of what this looks like with ath9k:
    
    mcgrof@pogo /debug/ieee80211/phy0 $ cat ht40allow_map
    2412 HT40  +
    2417 HT40  +
    2422 HT40  +
    2427 HT40  +
    2432 HT40 -+
    2437 HT40 -+
    2442 HT40 -+
    2447 HT40 -
    2452 HT40 -
    2457 HT40 -
    2462 HT40 -
    2467 Disabled
    2472 Disabled
    2484 Disabled
    5180 HT40  +
    5200 HT40 -+
    5220 HT40 -+
    5240 HT40 -+
    5260 HT40 -+
    5280 HT40 -+
    5300 HT40 -+
    5320 HT40 -
    5500 HT40  +
    5520 HT40 -+
    5540 HT40 -+
    5560 HT40 -+
    5580 HT40 -+
    5600 HT40 -+
    5620 HT40 -+
    5640 HT40 -+
    5660 HT40 -+
    5680 HT40 -+
    5700 HT40 -
    5745 HT40  +
    5765 HT40 -+
    5785 HT40 -+
    5805 HT40 -+
    5825 HT40 -
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 930a80124dbf..88f234c8f6b3 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -58,6 +58,7 @@ struct cfg80211_registered_device {
 		struct dentry *fragmentation_threshold;
 		struct dentry *short_retry_limit;
 		struct dentry *long_retry_limit;
+		struct dentry *ht40allow_map;
 	} debugfs;
 #endif
 

commit 1ac61302dcd18880e28c29e5728cd4d0efeb5366
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat May 2 00:37:21 2009 -0400

    mac80211/cfg80211: move wiphy specific debugfs entries to cfg80211
    
    This moves the cfg80211 specific stuff to new cfg80211 debugfs
    entries. Non-mac80211 will also get these entries now. There were
    only 4 which we take:
    
    rts_threshold
    fragmentation_threshold
    short_retry_limit
    long_retry_limit
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f14b6c5f4221..930a80124dbf 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -10,6 +10,7 @@
 #include <linux/netdevice.h>
 #include <linux/kref.h>
 #include <linux/rbtree.h>
+#include <linux/debugfs.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
 #include "reg.h"
@@ -50,6 +51,16 @@ struct cfg80211_registered_device {
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	unsigned long suspend_at;
 
+#ifdef CONFIG_MAC80211_DEBUGFS
+	/* Debugfs entries */
+	struct wiphy_debugfsdentries {
+		struct dentry *rts_threshold;
+		struct dentry *fragmentation_threshold;
+		struct dentry *short_retry_limit;
+		struct dentry *long_retry_limit;
+	} debugfs;
+#endif
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));

commit 08645126dd24872c2e27014f93968f7312e29176
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon May 11 13:54:58 2009 +0200

    cfg80211: implement wext key handling
    
    Move key handling wireless extension ioctls from mac80211 to cfg80211
    so that all drivers that implement the cfg80211 operations get wext
    compatibility.
    
    Note that this drops the SIOCGIWENCODE ioctl support for getting
    IW_ENCODE_RESTRICTED/IW_ENCODE_OPEN. This means that iwconfig will
    no longer report "Security mode:open" or "Security mode:restricted"
    for mac80211. However, what we displayed there (the authentication
    algo used) was actually wrong -- linux/wireless.h states that this
    setting is meant to differentiate between "Refuse non-encoded packets"
    and "Accept non-encoded packets".
    
    (Combined with "cfg80211: fix a couple of bugs with key ioctls". -- JWL)
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 3e49d3399311..f14b6c5f4221 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -1,7 +1,7 @@
 /*
  * Wireless configuration interface internals.
  *
- * Copyright 2006, 2007 Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2006-2009	Johannes Berg <johannes@sipsolutions.net>
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
@@ -151,4 +151,8 @@ void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
 
+/* internal helpers */
+int cfg80211_validate_key_settings(struct key_params *params, int key_idx,
+				   const u8 *mac_addr);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 9d308429a9fd0fa644f0b748f6241631f74a6cda
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 20 18:43:46 2009 +0200

    cfg80211: clear WEXT SSID when clearing IBSS
    
    When we leave an IBSS, we should clear the SSID and not just the
    BSSID, but since WEXT allows configuring while the interface is
    down we must not clear it when leaving due to taking the iface
    down, so some complications are needed.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 89a8159ef0b1..3e49d3399311 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -147,8 +147,8 @@ void cfg80211_bss_age(struct cfg80211_registered_device *dev,
 int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
 		       struct cfg80211_ibss_params *params);
-void cfg80211_clear_ibss(struct net_device *dev);
+void cfg80211_clear_ibss(struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
-			struct net_device *dev);
+			struct net_device *dev, bool nowext);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit d323655372590c533c275b1d798f9d1221efb5c6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 20 14:31:42 2009 +0200

    cfg80211: clean up includes
    
    Trying to separate header files into net/wireless.h and
    net/cfg80211.h has been a source of confusion. Remove
    net/wireless.h (because there also is the linux/wireless.h)
    and subsume everything into net/cfg80211.h -- except the
    definitions for regulatory structures which get moved to
    a new header net/regulatory.h.
    
    The "new" net/cfg80211.h is now divided into sections.
    
    There are no real changes in this patch but code shuffling
    and some very minor documentation fixes.
    
    I have also, to make things reflect reality, put in a
    copyright line for Luis to net/regulatory.h since that
    is probably exclusively written by him but was formerly
    in a file that only had my copyright line.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2ef3595fd6e0..89a8159ef0b1 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -11,7 +11,6 @@
 #include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <net/genetlink.h>
-#include <net/wireless.h>
 #include <net/cfg80211.h>
 #include "reg.h"
 

commit 04a773ade0680d862b479d7219973df60f7a3834
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun Apr 19 21:24:32 2009 +0200

    cfg80211/nl80211: add IBSS API
    
    This adds IBSS API along with (preliminary) wext handlers.
    The wext handlers can only do IBSS so you need to call them
    from your own wext handlers if the mode is IBSS.
    
    The nl80211 API requires
     * an SSID
     * a channel (frequency) for the case that a new IBSS
       has to be created
    
    It optionally supports
     * a flag to fix the channel
     * a fixed BSSID
    
    The cfg80211 code also takes care to leave the IBSS before
    the netdev is set down. If wireless extensions are used, it
    also caches values when the interface is down and instructs
    the driver to join when the interface is set up.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 02668b02e331..2ef3595fd6e0 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -144,4 +144,12 @@ void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
 void cfg80211_bss_age(struct cfg80211_registered_device *dev,
                       unsigned long age_secs);
 
+/* IBSS */
+int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev,
+		       struct cfg80211_ibss_params *params);
+void cfg80211_clear_ibss(struct net_device *dev);
+int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
+			struct net_device *dev);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 7edfab7adef45a09b459cb7f5957f476108f5e77
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sat Apr 11 13:32:46 2009 +0200

    cfg80211: convert mutex assert to macro
    
    That will make the various cases where the WARN_ON
    can happen distinguishable.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index fcee83a0c9bb..02668b02e331 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -73,10 +73,7 @@ bool wiphy_idx_valid(int wiphy_idx)
 extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_drv_list;
 
-static inline void assert_cfg80211_lock(void)
-{
-	WARN_ON(!mutex_is_locked(&cfg80211_mutex));
-}
+#define assert_cfg80211_lock() WARN_ON(!mutex_is_locked(&cfg80211_mutex))
 
 /*
  * You can use this to mark a wiphy_idx as not having an associated wiphy.

commit c0ed418977edf60f1df9933e1ccd48920a28eb66
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Fri Mar 27 22:21:36 2009 +0800

    nl80211: remove duplicated #include
    
    Remove duplicated #include in net/wireless/core.h.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 0a592e4295f0..fcee83a0c9bb 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -10,7 +10,6 @@
 #include <linux/netdevice.h>
 #include <linux/kref.h>
 #include <linux/rbtree.h>
-#include <linux/mutex.h>
 #include <net/genetlink.h>
 #include <net/wireless.h>
 #include <net/cfg80211.h>

commit cd1658f592a60d028dd2e48d86724b737a82cab0
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Apr 16 15:00:58 2009 +0200

    cfg80211: do not replace BSS structs
    
    Instead, allocate extra IE memory if necessary. Normally,
    this isn't even necessary since there's enough space.
    
    This is a better way of correcting the "held BSS can
    disappear" issue, but also a lot more code. It is also
    necessary for proper auth/assoc BSS handling in the
    future.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index d43daa236ef9..0a592e4295f0 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -90,7 +90,7 @@ struct cfg80211_internal_bss {
 	struct rb_node rbn;
 	unsigned long ts;
 	struct kref ref;
-	bool hold;
+	bool hold, ies_allocated;
 
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;

commit 4bbf4d56583dd52c429d88f43cb614bdbe5deea6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Mar 24 09:35:46 2009 +0100

    cfg80211: fix locking in nl80211_set_wiphy
    
    Luis reports that there's a circular locking dependency;
    this is because cfg80211_dev_rename() will acquire the
    cfg80211_mutex while the device mutex is held, while
    this normally is done the other way around. The solution
    is to open-code the device-getting in nl80211_set_wiphy
    and require holding the mutex around cfg80211_dev_rename
    rather than acquiring it within.
    
    Also fix a bug -- rtnl locking is expected by drivers so
    we need to provide it.
    
    Reported-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 97a6fd8b2b03..d43daa236ef9 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -99,6 +99,9 @@ struct cfg80211_internal_bss {
 struct cfg80211_registered_device *cfg80211_drv_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
+struct cfg80211_registered_device *
+__cfg80211_drv_from_info(struct genl_info *info);
+
 /*
  * This function returns a pointer to the driver
  * that the genl_info item that is passed refers to.

commit a08c1c1ac0c26229ca1ca45d554b209a56edc8be
Author: Kalle Valo <kalle.valo@nokia.com>
Date:   Sun Mar 22 21:57:28 2009 +0200

    cfg80211: add feature to hold bss
    
    In beacon filtering there needs to be a way to not expire the BSS even
    when no beacons are received. Add an interface to cfg80211 to hold
    BSS and make sure that it's not expired.
    
    Signed-off-by: Kalle Valo <kalle.valo@nokia.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6acd483a61f8..97a6fd8b2b03 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -90,6 +90,8 @@ struct cfg80211_internal_bss {
 	struct rb_node rbn;
 	unsigned long ts;
 	struct kref ref;
+	bool hold;
+
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;
 };

commit 7db90f4a25bd4184f3d36dfa4f512f53b0448da7
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Mon Mar 9 22:07:41 2009 -0400

    cfg80211: move enum reg_set_by to nl80211.h
    
    We do this so we can later inform userspace who set the
    regulatory domain and provide details of the request.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f6c53f5807f4..6acd483a61f8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -136,7 +136,8 @@ extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
 			       char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
-void wiphy_update_regulatory(struct wiphy *wiphy, enum reg_set_by setby);
+void wiphy_update_regulatory(struct wiphy *wiphy,
+			     enum nl80211_reg_initiator setby);
 
 void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
 void cfg80211_bss_age(struct cfg80211_registered_device *dev,

commit 0bfbce18b9c11201ebf1cfbc0deeab7bdbfe32a5
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Tue Feb 24 16:49:58 2009 +0200

    nl80211: Avoid AP mode BUG_ON hang with invalid lock assert
    
    "cfg80211: add assert_cfg80211_lock() to ensure proper protection"
    added assert_cfg80211_lock() calls into various places. At least
    one of them, nl80211_send_wiphy(), should not have been there. That
    triggers the BUG_ON in assert_cfg80211_lock() and pretty much kills
    the kernel whenever someone runs hostapd.. Remove that call and make
    assert_cfg80211_lock() use WARN_ON instead of BUG_ON to be a bit more
    friendly to users.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index cd8e6e3ef116..f6c53f5807f4 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -76,7 +76,7 @@ extern struct list_head cfg80211_drv_list;
 
 static inline void assert_cfg80211_lock(void)
 {
-	BUG_ON(!mutex_is_locked(&cfg80211_mutex));
+	WARN_ON(!mutex_is_locked(&cfg80211_mutex));
 }
 
 /*

commit 806a9e39670be4f1f861c346ec102a79e81b90c3
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:26 2009 -0500

    cfg80211: make regulatory_request use wiphy_idx instead of wiphy
    
    We do this so later on we can move the pending requests onto a
    workqueue. By using the wiphy_idx instead of the wiphy we can
    later easily check if the wiphy has disappeared or not.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 982cc6be3484..cd8e6e3ef116 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -79,6 +79,12 @@ static inline void assert_cfg80211_lock(void)
 	BUG_ON(!mutex_is_locked(&cfg80211_mutex));
 }
 
+/*
+ * You can use this to mark a wiphy_idx as not having an associated wiphy.
+ * It guarantees cfg80211_drv_by_wiphy_idx(wiphy_idx) will return NULL
+ */
+#define WIPHY_IDX_STALE -1
+
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct rb_node rbn;
@@ -88,6 +94,9 @@ struct cfg80211_internal_bss {
 	struct cfg80211_bss pub;
 };
 
+struct cfg80211_registered_device *cfg80211_drv_by_wiphy_idx(int wiphy_idx);
+int get_wiphy_idx(struct wiphy *wiphy);
+
 /*
  * This function returns a pointer to the driver
  * that the genl_info item that is passed refers to.
@@ -111,6 +120,9 @@ struct cfg80211_internal_bss {
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_info(struct genl_info *info);
 
+/* requires cfg80211_drv_mutex to be held! */
+struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
+
 /* identical to cfg80211_get_dev_from_info but only operate on ifindex */
 extern struct cfg80211_registered_device *
 cfg80211_get_dev_from_ifindex(int ifindex);

commit 761cf7ecffc4bc079679e65c3b1ab107c1c1fb56
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:25 2009 -0500

    cfg80211: add assert_cfg80211_lock() to ensure proper protection
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f3ab00cbf766..982cc6be3484 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -10,6 +10,7 @@
 #include <linux/netdevice.h>
 #include <linux/kref.h>
 #include <linux/rbtree.h>
+#include <linux/mutex.h>
 #include <net/genetlink.h>
 #include <net/wireless.h>
 #include <net/cfg80211.h>
@@ -73,6 +74,11 @@ bool wiphy_idx_valid(int wiphy_idx)
 extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_drv_list;
 
+static inline void assert_cfg80211_lock(void)
+{
+	BUG_ON(!mutex_is_locked(&cfg80211_mutex));
+}
+
 struct cfg80211_internal_bss {
 	struct list_head list;
 	struct rb_node rbn;

commit a1794390f1afc3631ac056e0f1677b7ab6f7ee74
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:21 2009 -0500

    cfg80211: rename cfg80211_drv_mutex to cfg80211_mutex
    
    cfg80211_drv_mutex is protecting more than the driver list,
    this renames it and documents what its currently supposed to
    protect.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 4f2e0fe38ce3..f3ab00cbf766 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -70,7 +70,7 @@ bool wiphy_idx_valid(int wiphy_idx)
 	return (wiphy_idx >= 0);
 }
 
-extern struct mutex cfg80211_drv_mutex;
+extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_drv_list;
 
 struct cfg80211_internal_bss {
@@ -89,13 +89,13 @@ struct cfg80211_internal_bss {
  * the driver's mutex!
  *
  * This means that you need to call cfg80211_put_dev()
- * before being allowed to acquire &cfg80211_drv_mutex!
+ * before being allowed to acquire &cfg80211_mutex!
  *
  * This is necessary because we need to lock the global
  * mutex to get an item off the list safely, and then
  * we lock the drv mutex so it doesn't go away under us.
  *
- * We don't want to keep cfg80211_drv_mutex locked
+ * We don't want to keep cfg80211_mutex locked
  * for all the time in order to allow requests on
  * other interfaces to go through at the same time.
  *

commit 85fd129a721e6e892dbaaf05203baf819730f699
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:20 2009 -0500

    cfg80211: add wiphy_idx_valid to check for wiphy_idx sanity
    
    This will later be used by others, for now make use of it in
    cfg80211_drv_by_wiphy_idx() to return early if an invalid
    wiphy_idx has been provided.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 178378124800..4f2e0fe38ce3 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -63,6 +63,13 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 	return container_of(wiphy, struct cfg80211_registered_device, wiphy);
 }
 
+/* Note 0 is valid, hence phy0 */
+static inline
+bool wiphy_idx_valid(int wiphy_idx)
+{
+	return (wiphy_idx >= 0);
+}
+
 extern struct mutex cfg80211_drv_mutex;
 extern struct list_head cfg80211_drv_list;
 

commit b5850a7a4fd5bcab4f6a2c49e5b4ab9ebb1d5d44
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Feb 21 00:04:19 2009 -0500

    cfg80211: rename cfg80211_registered_device's idx to wiphy_idx
    
    Makes it clearer to read when comparing to ifidx
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 5d0c682d737a..178378124800 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -37,7 +37,7 @@ struct cfg80211_registered_device {
 	enum environment_cap env;
 
 	/* wiphy index, internal only */
-	int idx;
+	int wiphy_idx;
 
 	/* associate netdev list */
 	struct mutex devlist_mtx;

commit cb3a8eec0e66edfe8db7d3b3bf19d25745bae3c3
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Feb 11 17:14:43 2009 -0500

    cfg80211: age scan results on resume
    
    Scanned BSS entries are timestamped with jiffies, which doesn't
    increment across suspend and hibernate.  On resume, every BSS in the
    scan list looks like it was scanned within the last 10 seconds,
    irregardless of how long the machine was actually asleep.  Age scan
    results on resume with the time spent during sleep so userspace has a
    clue how old they really are.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index e29ad4cd464f..5d0c682d737a 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -49,6 +49,7 @@ struct cfg80211_registered_device {
 	struct rb_root bss_tree;
 	u32 bss_generation;
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
+	unsigned long suspend_at;
 
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
@@ -113,5 +114,7 @@ void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 void wiphy_update_regulatory(struct wiphy *wiphy, enum reg_set_by setby);
 
 void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
+void cfg80211_bss_age(struct cfg80211_registered_device *dev,
+                      unsigned long age_secs);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit 2a5193119269062608582418deba7af82844159a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Feb 10 21:25:55 2009 +0100

    cfg80211/nl80211: scanning (and mac80211 update to use it)
    
    This patch adds basic scan capability to cfg80211/nl80211 and
    changes mac80211 to use it. The BSS list that cfg80211 maintains
    is made driver-accessible with a private area in each BSS struct,
    but mac80211 doesn't yet use it. That's another large project.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index f7fb9f413028..e29ad4cd464f 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -8,6 +8,8 @@
 #include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
+#include <linux/kref.h>
+#include <linux/rbtree.h>
 #include <net/genetlink.h>
 #include <net/wireless.h>
 #include <net/cfg80211.h>
@@ -41,6 +43,13 @@ struct cfg80211_registered_device {
 	struct mutex devlist_mtx;
 	struct list_head netdev_list;
 
+	/* BSSes/scanning */
+	spinlock_t bss_lock;
+	struct list_head bss_list;
+	struct rb_root bss_tree;
+	u32 bss_generation;
+	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
+
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));
@@ -56,6 +65,15 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 extern struct mutex cfg80211_drv_mutex;
 extern struct list_head cfg80211_drv_list;
 
+struct cfg80211_internal_bss {
+	struct list_head list;
+	struct rb_node rbn;
+	unsigned long ts;
+	struct kref ref;
+	/* must be last because of priv member */
+	struct cfg80211_bss pub;
+};
+
 /*
  * This function returns a pointer to the driver
  * that the genl_info item that is passed refers to.
@@ -94,4 +112,6 @@ extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 void wiphy_update_regulatory(struct wiphy *wiphy, enum reg_set_by setby);
 
+void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 3f2355cb9111ac04e7ae06a4d7044da2ae813863
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Wed Nov 12 14:22:02 2008 -0800

    cfg80211/mac80211: Add 802.11d support
    
    This adds country IE parsing to mac80211 and enables its usage
    within the new regulatory infrastructure in cfg80211. We parse
    the country IEs only on management beacons for the BSSID you are
    associated to and disregard the IEs when the country and environment
    (indoor, outdoor, any) matches the already processed country IE.
    
    To avoid following misinformed or outdated APs we build and use
    a regulatory domain out of the intersection between what the AP
    provides us on the country IE and what CRDA is aware is allowed
    on the same country.
    
    A secondary device is allowed to follow only the same country IE
    as it make no sense for two devices on a system to be in two
    different countries.
    
    In the case the AP is using country IEs for an incorrect country
    the user may help compliance further by setting the regulatory
    domain before or after the IE is parsed and in that case another
    intersection will be performed.
    
    CONFIG_WIRELESS_OLD_REGULATORY is supported but requires CRDA
    present.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 771cc5cc7658..f7fb9f413028 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -11,6 +11,7 @@
 #include <net/genetlink.h>
 #include <net/wireless.h>
 #include <net/cfg80211.h>
+#include "reg.h"
 
 struct cfg80211_registered_device {
 	struct cfg80211_ops *ops;
@@ -21,6 +22,18 @@ struct cfg80211_registered_device {
 	 * any call is in progress */
 	struct mutex mtx;
 
+	/* ISO / IEC 3166 alpha2 for which this device is receiving
+	 * country IEs on, this can help disregard country IEs from APs
+	 * on the same alpha2 quickly. The alpha2 may differ from
+	 * cfg80211_regdomain's alpha2 when an intersection has occurred.
+	 * If the AP is reconfigured this can also be used to tell us if
+	 * the country on the country IE changed. */
+	char country_ie_alpha2[2];
+
+	/* If a Country IE has been received this tells us the environment
+	 * which its telling us its in. This defaults to ENVIRON_ANY */
+	enum environment_cap env;
+
 	/* wiphy index, internal only */
 	int idx;
 

commit b2e1b30290539b344cbaff0d9da38012e03aa347
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Tue Sep 9 23:19:48 2008 -0700

    cfg80211: Add new wireless regulatory infrastructure
    
    This adds the new wireless regulatory infrastructure. The
    main motiviation behind this was to centralize regulatory
    code as each driver was implementing their own regulatory solution,
    and to replace the initial centralized code we have where:
    
    * only 3 regulatory domains are supported: US, JP and EU
    * regulatory domains can only be changed through module parameter
    * all rules were built statically in the kernel
    
    We now have support for regulatory domains for many countries
    and regulatory domains are now queried through a userspace agent
    through udev allowing distributions to update regulatory rules
    without updating the kernel.
    
    Each driver can regulatory_hint() a regulatory domain
    based on either their EEPROM mapped regulatory domain value to a
    respective ISO/IEC 3166-1 country code or pass an internally built
    regulatory domain. We also add support to let the user set the
    regulatory domain through userspace in case of faulty EEPROMs to
    further help compliance.
    
    Support for world roaming will be added soon for cards capable of
    this.
    
    For more information see:
    
    http://wireless.kernel.org/en/developers/Regulatory/CRDA
    
    For now we leave an option to enable the old module parameter,
    ieee80211_regdom, and to build the 3 old regdomains statically
    (US, JP and EU). This option is CONFIG_WIRELESS_OLD_REGULATORY.
    These old static definitions and the module parameter is being
    scheduled for removal for 2.6.29. Note that if you use this
    you won't make use of a world regulatory domain as its pointless.
    If you leave this option enabled and if CRDA is present and you
    use US or JP we will try to ask CRDA to update us a regulatory
    domain for us.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 7a02c356d63d..771cc5cc7658 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -79,6 +79,6 @@ extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
 			       char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
-void wiphy_update_regulatory(struct wiphy *wiphy);
+void wiphy_update_regulatory(struct wiphy *wiphy, enum reg_set_by setby);
 
 #endif /* __NET_WIRELESS_CORE_H */

commit 8318d78a44d49ac1edf2bdec7299de3617c4232e
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Jan 24 19:38:38 2008 +0100

    cfg80211 API for channels/bitrates, mac80211 and driver conversion
    
    This patch creates new cfg80211 wiphy API for channel and bitrate
    registration and converts mac80211 and drivers to the new API. The
    old mac80211 API is completely ripped out. All drivers (except ath5k)
    are updated to the new API, in many cases I expect that optimisations
    can be done.
    
    Along with the regulatory code I've also ripped out the
    IEEE80211_HW_DEFAULT_REG_DOMAIN_CONFIGURED flag, I believe it to be
    unnecessary if the hardware simply gives us whatever channels it wants
    to support and we then enable/disable them as required, which is pretty
    much required for travelling.
    
    Additionally, the patch adds proper "basic" rate handling for STA
    mode interface, AP mode interface will have to have new API added
    to allow userspace to set the basic rate set, currently it'll be
    empty... However, the basic rate handling will need to be moved to
    the BSS conf stuff.
    
    I do expect there to be bugs in this, especially wrt. transmit
    power handling where I'm basically clueless about how it should work.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index eb0f846b40df..7a02c356d63d 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -78,4 +78,7 @@ extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);
 extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
 			       char *newname);
 
+void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
+void wiphy_update_regulatory(struct wiphy *wiphy);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 556829657397b9b05baec6691ead4e22ee8d1567
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Sep 20 13:09:35 2007 -0400

    [NL80211]: add netlink interface to cfg80211
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 158db1edb92a..eb0f846b40df 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -43,7 +43,39 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 extern struct mutex cfg80211_drv_mutex;
 extern struct list_head cfg80211_drv_list;
 
+/*
+ * This function returns a pointer to the driver
+ * that the genl_info item that is passed refers to.
+ * If successful, it returns non-NULL and also locks
+ * the driver's mutex!
+ *
+ * This means that you need to call cfg80211_put_dev()
+ * before being allowed to acquire &cfg80211_drv_mutex!
+ *
+ * This is necessary because we need to lock the global
+ * mutex to get an item off the list safely, and then
+ * we lock the drv mutex so it doesn't go away under us.
+ *
+ * We don't want to keep cfg80211_drv_mutex locked
+ * for all the time in order to allow requests on
+ * other interfaces to go through at the same time.
+ *
+ * The result of this can be a PTR_ERR and hence must
+ * be checked with IS_ERR() for errors.
+ */
+extern struct cfg80211_registered_device *
+cfg80211_get_dev_from_info(struct genl_info *info);
+
+/* identical to cfg80211_get_dev_from_info but only operate on ifindex */
+extern struct cfg80211_registered_device *
+cfg80211_get_dev_from_ifindex(int ifindex);
+
+extern void cfg80211_put_dev(struct cfg80211_registered_device *drv);
+
 /* free object */
 extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);
 
+extern int cfg80211_dev_rename(struct cfg80211_registered_device *drv,
+			       char *newname);
+
 #endif /* __NET_WIRELESS_CORE_H */

commit 704232c2718c9d4b3375ec15a14fc0397970c449
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 23 12:20:05 2007 -0700

    [WIRELESS] cfg80211: New wireless config infrastructure.
    
    This patch creates the core cfg80211 code along with some sysfs bits.
    This is a stripped down version to allow mac80211 to function, but
    doesn't include any configuration yet except for creating and removing
    virtual interfaces.
    
    This patch includes the nl80211 header file but it only contains the
    interface types which the cfg80211 interface for creating virtual
    interfaces relies on.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/wireless/core.h b/net/wireless/core.h
new file mode 100644
index 000000000000..158db1edb92a
--- /dev/null
+++ b/net/wireless/core.h
@@ -0,0 +1,49 @@
+/*
+ * Wireless configuration interface internals.
+ *
+ * Copyright 2006, 2007 Johannes Berg <johannes@sipsolutions.net>
+ */
+#ifndef __NET_WIRELESS_CORE_H
+#define __NET_WIRELESS_CORE_H
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <net/genetlink.h>
+#include <net/wireless.h>
+#include <net/cfg80211.h>
+
+struct cfg80211_registered_device {
+	struct cfg80211_ops *ops;
+	struct list_head list;
+	/* we hold this mutex during any call so that
+	 * we cannot do multiple calls at once, and also
+	 * to avoid the deregister call to proceed while
+	 * any call is in progress */
+	struct mutex mtx;
+
+	/* wiphy index, internal only */
+	int idx;
+
+	/* associate netdev list */
+	struct mutex devlist_mtx;
+	struct list_head netdev_list;
+
+	/* must be last because of the way we do wiphy_priv(),
+	 * and it should at least be aligned to NETDEV_ALIGN */
+	struct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));
+};
+
+static inline
+struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
+{
+	BUG_ON(!wiphy);
+	return container_of(wiphy, struct cfg80211_registered_device, wiphy);
+}
+
+extern struct mutex cfg80211_drv_mutex;
+extern struct list_head cfg80211_drv_list;
+
+/* free object */
+extern void cfg80211_dev_free(struct cfg80211_registered_device *drv);
+
+#endif /* __NET_WIRELESS_CORE_H */
