commit 188c1b3c04d69e842122daf201f07a34fcfad039
Author: Denis Kenzior <denkenz@gmail.com>
Date:   Mon Mar 26 12:52:46 2018 -0500

    nl80211: Add SOCKET_OWNER support to JOIN_MESH
    
    Signed-off-by: Denis Kenzior <denkenz@gmail.com>
    [johannes: fix race with wdev lock/unlock by just acquiring once]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index b12da6ef3c12..eac5aa1419fc 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -217,21 +217,6 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	return err;
 }
 
-int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
-		       struct net_device *dev,
-		       struct mesh_setup *setup,
-		       const struct mesh_config *conf)
-{
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	int err;
-
-	wdev_lock(wdev);
-	err = __cfg80211_join_mesh(rdev, dev, setup, conf);
-	wdev_unlock(wdev);
-
-	return err;
-}
-
 int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev,
 			      struct cfg80211_chan_def *chandef)
@@ -286,6 +271,7 @@ int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 
 	err = rdev_leave_mesh(rdev, dev);
 	if (!err) {
+		wdev->conn_owner_nlportid = 0;
 		wdev->mesh_id_len = 0;
 		wdev->beacon_interval = 0;
 		memset(&wdev->chandef, 0, sizeof(wdev->chandef));

commit c028c6309a9f9b385ba8c0c984eb2b6c3f368650
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jan 30 13:17:38 2018 +0100

    cfg80211: use only 1Mbps for basic rates in mesh
    
    Mesh used to use the mandatory rates as basic rates, but we got
    the calculation of mandatory rates wrong until some time ago.
    Fix this this broke interoperability with older versions since
    now more basic rates are required, and thus the MBSS isn't the
    same and the network stops working.
    
    Fix this by simply using only 1Mbps as the basic rate in 2.4GHz.
    Since the changed mandatory rates only affected 2.4GHz, this is
    all we need to make it work again.
    
    Reported-and-tested-by: Matthias Schiffer <mschiffer@universe-factory.net>
    Fixes: 1bd773c077de ("wireless: set correct mandatory rate flags")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 51aa55618ef7..b12da6ef3c12 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -170,9 +170,28 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		enum nl80211_bss_scan_width scan_width;
 		struct ieee80211_supported_band *sband =
 				rdev->wiphy.bands[setup->chandef.chan->band];
-		scan_width = cfg80211_chandef_to_scan_width(&setup->chandef);
-		setup->basic_rates = ieee80211_mandatory_rates(sband,
-							       scan_width);
+
+		if (setup->chandef.chan->band == NL80211_BAND_2GHZ) {
+			int i;
+
+			/*
+			 * Older versions selected the mandatory rates for
+			 * 2.4 GHz as well, but were broken in that only
+			 * 1 Mbps was regarded as a mandatory rate. Keep
+			 * using just 1 Mbps as the default basic rate for
+			 * mesh to be interoperable with older versions.
+			 */
+			for (i = 0; i < sband->n_bitrates; i++) {
+				if (sband->bitrates[i].bitrate == 10) {
+					setup->basic_rates = BIT(i);
+					break;
+				}
+			}
+		} else {
+			scan_width = cfg80211_chandef_to_scan_width(&setup->chandef);
+			setup->basic_rates = ieee80211_mandatory_rates(sband,
+								       scan_width);
+		}
 	}
 
 	err = cfg80211_chandef_dfs_required(&rdev->wiphy,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 421a6b80ec62..51aa55618ef7 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/ieee80211.h>
 #include <linux/export.h>
 #include <net/cfg80211.h>

commit d37d49c2f18fb53c6315b2b0fd7f1fb3d8be57ac
Author: Benjamin Berg <benjamin@sipsolutions.net>
Date:   Tue May 16 11:23:11 2017 +0200

    wireless: Only join DFS channels in mesh mode if userspace flags support
    
    When joining a mesh network it is not guaranteed that userspace has a
    daemon listening for radar events. This is however required for channels
    requiring DFS. To flag that userspace will handle radar events, it needs
    to set NL80211_ATTR_HANDLE_DFS.
    
    This matches the current mechanism used for IBSS mode.
    
    Signed-off-by: Benjamin Berg <benjamin@sipsolutions.net>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index ec0b1c20ac99..421a6b80ec62 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -174,6 +174,14 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 							       scan_width);
 	}
 
+	err = cfg80211_chandef_dfs_required(&rdev->wiphy,
+					    &setup->chandef,
+					    NL80211_IFTYPE_MESH_POINT);
+	if (err < 0)
+		return err;
+	if (err > 0 && !setup->userspace_handles_dfs)
+		return -EINVAL;
+
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef,
 				     NL80211_IFTYPE_MESH_POINT))
 		return -EINVAL;

commit b35a51c7dd25a823767969e3089542d7478777e9
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Mon Feb 27 17:04:33 2017 +0530

    cfg80211: Make pre-CAC results valid only for ETSI domain
    
    DFS requirement for ETSI domain (section 4.7.1.4 in
    ETSI EN 301 893 V1.8.1) is the only one which explicitly
    states that once DFS channel is marked as available afer
    the CAC, this channel will remain in available state even
    moving to a different operating channel. But the same is
    not explicitly stated in FCC DFS requirement. Also, Pre-CAC
    requriements are not explicitly mentioned in FCC requirement.
    Current implementation in keeping DFS channel in available
    state is same as described in ETSI domain.
    
    For non-ETSI DFS domain, this patch gives a grace period of 2 seconds
    since the completion of successful CAC before moving the channel's
    DFS state to 'usable' from 'available' state. The same grace period
    is checked against the channel's dfs_state_entered timestamp while
    deciding if a DFS channel is available for operation. There is a new
    radar event, NL80211_RADAR_PRE_CAC_EXPIRED, reported when DFS channel
    is moved from available to usable state after the grace period. Also
    make sure the DFS channel state is reset to usable once the beaconing
    operation on that channel is brought down (like stop_ap, leave_ibss
    and leave_mesh) in non-ETSI domain.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 2d8518a37eab..ec0b1c20ac99 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -262,6 +262,7 @@ int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 		wdev->beacon_interval = 0;
 		memset(&wdev->chandef, 0, sizeof(wdev->chandef));
 		rdev_set_qos_map(rdev, dev, NULL);
+		cfg80211_sched_dfs_chan_update(rdev);
 	}
 
 	return err;

commit 275fcf62c289d52f0fc14d774ab176c0d6196171
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Oct 21 14:25:11 2016 +0200

    cfg80211: mesh: track (and thus validate) beacon interval
    
    This is needed for beacon interval validation; if we don't
    store it, then new interfaces added won't validate that the
    beacon interval is the same as existing ones. Fix this.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index fa2066b56f36..2d8518a37eab 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -183,6 +183,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
 		wdev->mesh_id_len = setup->mesh_id_len;
 		wdev->chandef = setup->chandef;
+		wdev->beacon_interval = setup->beacon_interval;
 	}
 
 	return err;
@@ -258,6 +259,7 @@ int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	err = rdev_leave_mesh(rdev, dev);
 	if (!err) {
 		wdev->mesh_id_len = 0;
+		wdev->beacon_interval = 0;
 		memset(&wdev->chandef, 0, sizeof(wdev->chandef));
 		rdev_set_qos_map(rdev, dev, NULL);
 	}

commit 57fbcce37be7c1d2622b56587c10ade00e96afa3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 12 15:56:15 2016 +0200

    cfg80211: remove enum ieee80211_band
    
    This enum is already perfectly aliased to enum nl80211_band, and
    the only reason for it is that we get IEEE80211_NUM_BANDS out of
    it. There's no really good reason to not declare the number of
    bands in nl80211 though, so do that and remove the cfg80211 one.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 092300b30c37..fa2066b56f36 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -128,9 +128,9 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 	if (!setup->chandef.chan) {
 		/* if we don't have that either, use the first usable channel */
-		enum ieee80211_band band;
+		enum nl80211_band band;
 
-		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+		for (band = 0; band < NUM_NL80211_BANDS; band++) {
 			struct ieee80211_supported_band *sband;
 			struct ieee80211_channel *chan;
 			int i;

commit f04c22033c25f71617ac62bcfe75698baa17a0b8
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed Apr 9 15:11:01 2014 +0200

    cfg80211: export interface stopping function
    
    This exports a new cfg80211_stop_iface() function.
    
    This is intended for driver internal interface
    combination management and channel switching.
    
    Due to locking issues (it re-enters driver) the
    call is asynchronous and uses cfg80211 event
    list/worker.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 3ddfb7cd335e..092300b30c37 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -238,8 +238,8 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 	return 0;
 }
 
-static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
-				 struct net_device *dev)
+int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+			  struct net_device *dev)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;

commit 73de86a38962b18edad3205c2358599dd9c83e9f
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Thu Feb 13 11:31:59 2014 +0200

    cfg80211/mac80211: move interface counting for combination check to mac80211
    
    Move the counting part of the interface combination check from
    cfg80211 to mac80211.
    
    This is needed to simplify locking when the driver has to perform a
    combination check by itself (eg. with channel-switch).
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 6ebe883653a4..3ddfb7cd335e 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -99,7 +99,6 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	u8 radar_detect_width = 0;
 	int err;
 
 	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
@@ -179,22 +178,6 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 				     NL80211_IFTYPE_MESH_POINT))
 		return -EINVAL;
 
-	err = cfg80211_chandef_dfs_required(wdev->wiphy,
-					    &setup->chandef,
-					    NL80211_IFTYPE_MESH_POINT);
-	if (err < 0)
-		return err;
-
-	if (err > 0)
-		radar_detect_width = BIT(setup->chandef.width);
-
-	err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-					   setup->chandef.chan,
-					   CHAN_MODE_SHARED,
-					   radar_detect_width);
-	if (err)
-		return err;
-
 	err = rdev_join_mesh(rdev, dev, conf, setup);
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
@@ -240,17 +223,6 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
 
-		/* cfg80211_can_use_chan() calls
-		 * cfg80211_can_use_iftype_chan() with no radar
-		 * detection, so if we're trying to use a radar
-		 * channel here, something is wrong.
-		 */
-		WARN_ON_ONCE(chandef->chan->flags & IEEE80211_CHAN_RADAR);
-		err = cfg80211_can_use_chan(rdev, wdev, chandef->chan,
-					    CHAN_MODE_SHARED);
-		if (err)
-			return err;
-
 		err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
 						     chandef->chan);
 		if (!err)

commit 2beb6dab2d799ee8934cb0801845e551ad8c70f2
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Tue Feb 18 11:40:36 2014 +0200

    cfg80211/mac80211: refactor cfg80211_chandef_dfs_required()
    
    Some interface types don't require DFS (such as STATION, P2P_CLIENT
    etc).  In order to centralize these decisions, make
    cfg80211_chandef_dfs_required() take the iftype into consideration.
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 7031ee0afad8..6ebe883653a4 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -179,10 +179,13 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 				     NL80211_IFTYPE_MESH_POINT))
 		return -EINVAL;
 
-	err = cfg80211_chandef_dfs_required(wdev->wiphy, &setup->chandef);
+	err = cfg80211_chandef_dfs_required(wdev->wiphy,
+					    &setup->chandef,
+					    NL80211_IFTYPE_MESH_POINT);
 	if (err < 0)
 		return err;
-	if (err)
+
+	if (err > 0)
 		radar_detect_width = BIT(setup->chandef.width);
 
 	err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,

commit 174e0cd28af0fe3c6c634c3e4d9e042c683bd7f7
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Sun Feb 23 09:13:01 2014 +0200

    cfg80211: Enable GO operation on additional channels
    
    Allow GO operation on a channel marked with IEEE80211_CHAN_GO_CONCURRENT
    iff there is an active station interface that is associated to
    an AP operating on the same channel in the 2 GHz band or the same UNII band
    (in the 5 GHz band). This relaxation is not allowed if the channel is
    marked with IEEE80211_CHAN_RADAR.
    
    Note that this is a permissive approach to the FCC definitions,
    that require a clear assessment that the device operating the AP is
    an authorized master, i.e., with radar detection and DFS capabilities.
    
    It is assumed that such restrictions are enforced by user space.
    Furthermore, it is assumed, that if the conditions that allowed for
    the operation of the GO on such a channel change, i.e., the station
    interface disconnected from the AP, it is the responsibility of user
    space to evacuate the GO from the channel.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 5af5cc6b2c4c..7031ee0afad8 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -175,7 +175,8 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 							       scan_width);
 	}
 
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
+	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef,
+				     NL80211_IFTYPE_MESH_POINT))
 		return -EINVAL;
 
 	err = cfg80211_chandef_dfs_required(wdev->wiphy, &setup->chandef);

commit 7b2106aea2638948806df248215b14efd84c5ffc
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Thu Feb 20 16:36:21 2014 +0200

    cfg80211: remove radar requirements check from cfg80211_can_use_iftype_chan()
    
    We don't have to double check whether the parameters passed to
    cfg80211_can_use_iftype_chan() are correct.  We should just make sure
    they *are* when we call this function.
    
    Remove the radar_detect argument check in
    cfg80211_can_use_iftype_chan() to simplify the code.
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    [keep braces around a long comment + single statement]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index d42a3fcb2f67..5af5cc6b2c4c 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -236,6 +236,12 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
 
+		/* cfg80211_can_use_chan() calls
+		 * cfg80211_can_use_iftype_chan() with no radar
+		 * detection, so if we're trying to use a radar
+		 * channel here, something is wrong.
+		 */
+		WARN_ON_ONCE(chandef->chan->flags & IEEE80211_CHAN_RADAR);
 		err = cfg80211_can_use_chan(rdev, wdev, chandef->chan,
 					    CHAN_MODE_SHARED);
 		if (err)

commit 9e0e29615a2077be852b1245b57c5b00fa609522
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed Jan 29 14:22:27 2014 +0100

    cfg80211: consider existing DFS interfaces
    
    It was possible to break interface combinations in
    the following way:
    
     combo 1: iftype = AP, num_ifaces = 2, num_chans = 2,
     combo 2: iftype = AP, num_ifaces = 1, num_chans = 1, radar = HT20
    
    With the above interface combinations it was
    possible to:
    
     step 1. start AP on DFS channel by matching combo 2
     step 2. start AP on non-DFS channel by matching combo 1
    
    This was possible beacuse (step 2) did not consider
    if other interfaces require radar detection.
    
    The patch changes how cfg80211 tracks channels -
    instead of channel itself now a complete chandef
    is stored.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 885862447b63..d42a3fcb2f67 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -195,7 +195,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
 		wdev->mesh_id_len = setup->mesh_id_len;
-		wdev->channel = setup->chandef.chan;
+		wdev->chandef = setup->chandef;
 	}
 
 	return err;
@@ -244,7 +244,7 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 		err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
 						     chandef->chan);
 		if (!err)
-			wdev->channel = chandef->chan;
+			wdev->chandef = *chandef;
 
 		return err;
 	}
@@ -276,7 +276,7 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	err = rdev_leave_mesh(rdev, dev);
 	if (!err) {
 		wdev->mesh_id_len = 0;
-		wdev->channel = NULL;
+		memset(&wdev->chandef, 0, sizeof(wdev->chandef));
 		rdev_set_qos_map(rdev, dev, NULL);
 	}
 

commit fa9ffc745610f31c6bc136d5a6a1782e00870e72
Author: Kyeyoon Park <kyeyoonp@qca.qualcomm.com>
Date:   Mon Dec 16 23:01:30 2013 -0800

    cfg80211: Add support for QoS mapping
    
    This allows QoS mapping from external networks to be implemented as
    defined in IEEE Std 802.11-2012, 10.24.9. APs can use this to advertise
    DSCP ranges and exceptions for mapping frames to a specific UP over
    Wi-Fi.
    
    The payload of the QoS Map Set element (IEEE Std 802.11-2012, 8.4.2.97)
    is sent to the driver through the new NL80211_ATTR_QOS_MAP attribute to
    configure the local behavior either on the AP (based on local
    configuration) or on a station (based on information received from the
    AP).
    
    Signed-off-by: Kyeyoon Park <kyeyoonp@qca.qualcomm.com>
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 9c7a11ae7936..885862447b63 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -277,6 +277,7 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	if (!err) {
 		wdev->mesh_id_len = 0;
 		wdev->channel = NULL;
+		rdev_set_qos_map(rdev, dev, NULL);
 	}
 
 	return err;

commit 33dde2bfe8ca97bdd8253bc0496482b048fa0b32
Author: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
Date:   Mon Dec 2 16:05:49 2013 +0800

    nl80211: allow the use of DFS channel in mesh
    
    This permits the use of DFS channel once the CAC is conducted and
    no radar is detected.
    
    Signed-off-by: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index b0e1869de7de..9c7a11ae7936 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -99,6 +99,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	u8 radar_detect_width = 0;
 	int err;
 
 	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
@@ -177,8 +178,16 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
 		return -EINVAL;
 
-	err = cfg80211_can_use_chan(rdev, wdev, setup->chandef.chan,
-				    CHAN_MODE_SHARED);
+	err = cfg80211_chandef_dfs_required(wdev->wiphy, &setup->chandef);
+	if (err < 0)
+		return err;
+	if (err)
+		radar_detect_width = BIT(setup->chandef.width);
+
+	err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
+					   setup->chandef.chan,
+					   CHAN_MODE_SHARED,
+					   radar_detect_width);
 	if (err)
 		return err;
 

commit 8fe02e167efa8ed4a4503a5eedc0f49fcb7e3eb9
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:22:25 2013 +0200

    cfg80211: consolidate passive-scan and no-ibss flags
    
    These two flags are used for the same purpose, just
    combine them into a no-ir flag to annotate no initiating
    radiation is allowed.
    
    Old userspace sending either flag will have it treated as
    the no-ir flag. To be considerate to older userspace we
    also send both the no-ir flag and the old no-ibss flags.
    Newer userspace will have to be aware of older kernels.
    
    Update all places in the tree using these flags with the
    following semantic patch:
    
    @@
    @@
    -NL80211_RRF_PASSIVE_SCAN
    +NL80211_RRF_NO_IR
    @@
    @@
    -NL80211_RRF_NO_IBSS
    +NL80211_RRF_NO_IR
    @@
    @@
    -IEEE80211_CHAN_PASSIVE_SCAN
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -IEEE80211_CHAN_NO_IBSS
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -NL80211_RRF_NO_IR | NL80211_RRF_NO_IR
    +NL80211_RRF_NO_IR
    @@
    @@
    -IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_IR
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -(NL80211_RRF_NO_IR)
    +NL80211_RRF_NO_IR
    @@
    @@
    -(IEEE80211_CHAN_NO_IR)
    +IEEE80211_CHAN_NO_IR
    
    Along with some hand-optimisations in documentation, to
    remove duplicates and to fix some indentation.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [do all the driver updates in one go]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0553fd4d85ae..b0e1869de7de 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -141,8 +141,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 			for (i = 0; i < sband->n_channels; i++) {
 				chan = &sband->channels[i];
-				if (chan->flags & (IEEE80211_CHAN_NO_IBSS |
-						   IEEE80211_CHAN_PASSIVE_SCAN |
+				if (chan->flags & (IEEE80211_CHAN_NO_IR |
 						   IEEE80211_CHAN_DISABLED |
 						   IEEE80211_CHAN_RADAR))
 					continue;

commit 74608aca4d82e2855b1a6a2cd60331d1a98f2d6a
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Mon Jul 8 16:55:54 2013 +0200

    cfg80211/mac80211: get mandatory rates based on scan width
    
    Mandatory rates for 5 and 10 MHz are different from the rates used for
    20 MHz in 2.4 GHz mode, as they use OFDM only.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Mathias Kretschmer <mathias.kretschmer@fokus.fraunhofer.de>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 30c49202ee4d..0553fd4d85ae 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -167,9 +167,12 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	 * basic rates
 	 */
 	if (!setup->basic_rates) {
+		enum nl80211_bss_scan_width scan_width;
 		struct ieee80211_supported_band *sband =
 				rdev->wiphy.bands[setup->chandef.chan->band];
-		setup->basic_rates = ieee80211_mandatory_rates(sband);
+		scan_width = cfg80211_chandef_to_scan_width(&setup->chandef);
+		setup->basic_rates = ieee80211_mandatory_rates(sband,
+							       scan_width);
 	}
 
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))

commit ffb3cf3000aa12facdccbdfcb10bfebda7199209
Author: Ashok Nagarajan <ashok@cozybit.com>
Date:   Mon Jun 3 10:33:36 2013 -0700

    {nl,mac,cfg}80211: Allow user to configure basic rates for mesh
    
    Currently mesh uses mandatory rates as the default basic rates. Allow basic
    rates to be configured during mesh join. Basic rates are applied only if
    channel is also provided with mesh join command.
    
    Signed-off-by: Ashok Nagarajan <ashok@cozybit.com>
    [some whitespace fixes, refuse basic rates w/o channel]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0daaf72e1b81..30c49202ee4d 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -162,6 +162,16 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		setup->chandef.center_freq1 = setup->chandef.chan->center_freq;
 	}
 
+	/*
+	 * check if basic rates are available otherwise use mandatory rates as
+	 * basic rates
+	 */
+	if (!setup->basic_rates) {
+		struct ieee80211_supported_band *sband =
+				rdev->wiphy.bands[setup->chandef.chan->band];
+		setup->basic_rates = ieee80211_mandatory_rates(sband);
+	}
+
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
 		return -EINVAL;
 

commit 8e7c053853b7d299e8a2b8733659b0df8eee51f7
Author: Colleen Twitty <colleen@cozybit.com>
Date:   Mon Jun 3 09:53:39 2013 -0700

    {nl,cfg}80211: make peer link expiration time configurable
    
    If a STA has a peer that it hasn't seen any tx activity
    from for a certain length of time, the peer link is
    expired. This means the inactive STA is removed from the
    list of peers and that STA is not considered a peer again
    unless it re-peers.  Previously, this inactivity time was
    always 30 minutes.  Now, add it to the mesh configuration
    and allow it to be configured.  Retain 30 minutes as a
    default value.
    
    Signed-off-by: Colleen Twitty <colleen@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 5dfb289ab761..0daaf72e1b81 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -18,6 +18,7 @@
 #define MESH_PATH_TO_ROOT_TIMEOUT      6000
 #define MESH_ROOT_INTERVAL     5000
 #define MESH_ROOT_CONFIRMATION_INTERVAL 2000
+#define MESH_DEFAULT_PLINK_TIMEOUT	1800 /* timeout in seconds */
 
 /*
  * Minimum interval between two consecutive PREQs originated by the same
@@ -75,6 +76,7 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshHWMPconfirmationInterval = MESH_ROOT_CONFIRMATION_INTERVAL,
 	.power_mode = NL80211_MESH_POWER_ACTIVE,
 	.dot11MeshAwakeWindowDuration = MESH_DEFAULT_AWAKE_WINDOW,
+	.plink_timeout = MESH_DEFAULT_PLINK_TIMEOUT,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit 5fe231e873729fa2f57cdc417d5c1f80871e2d7d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 8 21:45:15 2013 +0200

    cfg80211: vastly simplify locking
    
    Virtually all code paths in cfg80211 already (need to) hold
    the RTNL. As such, there's little point in having another
    four mutexes for various parts of the code, they just cause
    lock ordering issues (and much of the time, the RTNL and a
    few of the others need thus be held.)
    
    Simplify all this by getting rid of the extra four mutexes
    and just use the RTNL throughout. Only a few code changes
    were needed to do this and we can get rid of a work struct
    for bonus points.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 9546ad210550..5dfb289ab761 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -186,11 +186,9 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	mutex_lock(&rdev->devlist_mtx);
 	wdev_lock(wdev);
 	err = __cfg80211_join_mesh(rdev, dev, setup, conf);
 	wdev_unlock(wdev);
-	mutex_unlock(&rdev->devlist_mtx);
 
 	return err;
 }

commit 6e16d90b5218307db805e6b3e0b06d3946eb8c4c
Author: Colleen Twitty <colleen@cozybit.com>
Date:   Wed May 8 11:45:59 2013 -0700

    cfg80211: Userspace may inform kernel of mesh auth method.
    
    Authentication takes place in userspace, but the beacon is
    generated in the kernel.  Allow userspace to inform the
    kernel of the authentication method so the appropriate
    mesh config IE can be set prior to beacon generation when
    joining the MBSS.
    
    Signed-off-by: Colleen Twitty <colleen@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0bb93f3061a4..9546ad210550 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -82,6 +82,7 @@ const struct mesh_setup default_mesh_setup = {
 	.sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
 	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
+	.auth_id = 0, /* open */
 	.ie = NULL,
 	.ie_len = 0,
 	.is_secure = false,

commit bb2798d45fc0575f5d08c0bb7baf4d5d5e8cc0c3
Author: Thomas Pedersen <thomas@cozybit.com>
Date:   Mon Mar 4 13:06:10 2013 -0800

    nl80211: explicit userspace MPM
    
    Secure mesh had the implicit requirement that the Mesh
    Peering Management entity be in userspace.  However
    userspace might want to implement an open MPM as well, so
    specify a mesh setup parameter to indicate this.
    
    Signed-off-by: Thomas Pedersen <thomas@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 9688b249a805..0bb93f3061a4 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -85,6 +85,7 @@ const struct mesh_setup default_mesh_setup = {
 	.ie = NULL,
 	.ie_len = 0,
 	.is_secure = false,
+	.user_mpm = false,
 	.beacon_interval = MESH_DEFAULT_BEACON_INTERVAL,
 	.dtim_period = MESH_DEFAULT_DTIM_PERIOD,
 };

commit 947add36ca2dcd61c5b07347f029a5bafb9efb4e
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 22 22:05:20 2013 +0100

    cfg80211: move exported event functions into nl80211
    
    This is the sort of thing gcc's LTO could do, but since
    we don't have that yet we can also do it manually. The
    advantage is reduced code, both source and binary, e.g.
    on x86-64
    
       text    data     bss     dec     hex filename
     442825   56230     776  499831   7a077 cfg80211.ko (before)
     441585   56230     776  498591   79b9f cfg80211.ko (after)
    
    a reduction of ~1k.
    
    But in order to not complicate the code move only those
    functions that are simple wrappers, not those that have
    functionality of their own.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 55957a284f6c..9688b249a805 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -233,20 +233,6 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 	return 0;
 }
 
-void cfg80211_notify_new_peer_candidate(struct net_device *dev,
-		const u8 *macaddr, const u8* ie, u8 ie_len, gfp_t gfp)
-{
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
-
-	trace_cfg80211_notify_new_peer_candidate(dev, macaddr);
-	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))
-		return;
-
-	nl80211_send_new_peer_candidate(wiphy_to_dev(wdev->wiphy), dev,
-			macaddr, ie, ie_len, gfp);
-}
-EXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);
-
 static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 				 struct net_device *dev)
 {

commit 3b1c5a5307fb5277f395efdcf330c064d79df07d
Author: Marco Porsch <marco@cozybit.com>
Date:   Mon Jan 7 16:04:52 2013 +0100

    {cfg,nl}80211: mesh power mode primitives and userspace access
    
    Add the nl80211_mesh_power_mode enumeration which holds possible
    values for the mesh power mode. These modes are unknown, active,
    light sleep and deep sleep.
    
    Add power_mode entry to the mesh config structure to hold the
    user-configured default mesh power mode. This value will be used
    for new peer links.
    
    Add the dot11MeshAwakeWindowDuration value to the mesh config.
    The awake window is a duration in TU describing how long the STA
    will stay awake after transmitting its beacon in PS mode.
    
    Add access routines to:
     - get/set local link-specific power mode (STA)
     - get remote STA's link-specific power mode (STA)
     - get remote STA's non-peer power mode (STA)
     - get/set default mesh power mode (mesh config)
     - get/set mesh awake window duration (mesh config)
    
    All config changes may be done at mesh runtime and take effect
    immediately.
    
    Signed-off-by: Marco Porsch <marco@cozybit.com>
    Signed-off-by: Ivan Bezyazychnyy <ivan.bezyazychnyy@gmail.com>
    Signed-off-by: Mike Krinkin <krinkin.m.u@gmail.com>
    [fix commit message line length, error handling in set station]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0fe8ceb5444e..55957a284f6c 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -46,6 +46,7 @@
 
 #define MESH_DEFAULT_BEACON_INTERVAL	1000	/* in 1024 us units (=TUs) */
 #define MESH_DEFAULT_DTIM_PERIOD	2
+#define MESH_DEFAULT_AWAKE_WINDOW	10	/* in 1024 us units (=TUs) */
 
 const struct mesh_config default_mesh_config = {
 	.dot11MeshRetryTimeout = MESH_RET_T,
@@ -72,6 +73,8 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshHWMPactivePathToRootTimeout = MESH_PATH_TO_ROOT_TIMEOUT,
 	.dot11MeshHWMProotInterval = MESH_ROOT_INTERVAL,
 	.dot11MeshHWMPconfirmationInterval = MESH_ROOT_CONFIRMATION_INTERVAL,
+	.power_mode = NL80211_MESH_POWER_ACTIVE,
+	.dot11MeshAwakeWindowDuration = MESH_DEFAULT_AWAKE_WINDOW,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit 9bdbf04db099c11bbbaea9dcea7465c508531fb8
Author: Marco Porsch <marco@cozybit.com>
Date:   Mon Jan 7 16:04:51 2013 +0100

    {cfg,nl,mac}80211: set beacon interval and DTIM period on mesh join
    
    Move the default mesh beacon interval and DTIM period to cfg80211
    and make them accessible to nl80211. This enables setting both
    values when joining an MBSS.
    
    Previously the DTIM parameter was not set by mac80211 so the
    driver's default value was used.
    
    Signed-off-by: Marco Porsch <marco@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index f9d6ce5cfabb..0fe8ceb5444e 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -44,6 +44,9 @@
 
 #define MESH_SYNC_NEIGHBOR_OFFSET_MAX 50
 
+#define MESH_DEFAULT_BEACON_INTERVAL	1000	/* in 1024 us units (=TUs) */
+#define MESH_DEFAULT_DTIM_PERIOD	2
+
 const struct mesh_config default_mesh_config = {
 	.dot11MeshRetryTimeout = MESH_RET_T,
 	.dot11MeshConfirmTimeout = MESH_CONF_T,
@@ -79,6 +82,8 @@ const struct mesh_setup default_mesh_setup = {
 	.ie = NULL,
 	.ie_len = 0,
 	.is_secure = false,
+	.beacon_interval = MESH_DEFAULT_BEACON_INTERVAL,
+	.dtim_period = MESH_DEFAULT_DTIM_PERIOD,
 };
 
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,

commit da29d2a5780d80857773d7776b7603a449b0b6e0
Author: Marco Porsch <marco.porsch@etit.tu-chemnitz.de>
Date:   Mon Dec 3 11:23:37 2012 +0100

    cfg80211: fix channel error on mesh join
    
    Fix an error on mesh join when no channel has been
    explicitly set beforehand.
    
    Also remove a double semicolon.
    
    Signed-off-by: Marco Porsch <marco.porsch@etit.tu-chemnitz.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 3ee5a7282283..f9d6ce5cfabb 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -146,7 +146,8 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		if (!setup->chandef.chan)
 			return -EINVAL;
 
-		setup->chandef.width = NL80211_CHAN_WIDTH_20_NOHT;;
+		setup->chandef.width = NL80211_CHAN_WIDTH_20_NOHT;
+		setup->chandef.center_freq1 = setup->chandef.chan->center_freq;
 	}
 
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))

commit 3d9d1d6656a73ea8407734cfb00b81d14ef62d4b
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 8 23:14:50 2012 +0100

    nl80211/cfg80211: support VHT channel configuration
    
    Change nl80211 to support specifying a VHT (or HT)
    using the control channel frequency (as before) and
    new attributes for the channel width and first and
    second center frequency. The old channel type is of
    course still supported for HT.
    
    Also change the cfg80211 channel definition struct
    to support these by adding the relevant fields to
    it (and removing the _type field.)
    
    This also adds new helper functions:
     - cfg80211_chandef_create to create a channel def
       struct given the control channel and channel type,
     - cfg80211_chandef_identical to check if two channel
       definitions are identical
     - cfg80211_chandef_compatible to check if the given
       channel definitions are compatible, and return the
       wider of the two
    
    This isn't entirely complete, but that doesn't matter
    until we have a driver using it. In particular, it's
    missing
     - regulatory checks on the usable bandwidth (if that
       even makes sense)
     - regulatory TX power (database can't deal with it)
     - a proper channel compatibility calculation for the
       new channel types
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 12b5a570a306..3ee5a7282283 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -146,7 +146,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		if (!setup->chandef.chan)
 			return -EINVAL;
 
-		setup->chandef._type = NL80211_CHAN_NO_HT;
+		setup->chandef.width = NL80211_CHAN_WIDTH_20_NOHT;;
 	}
 
 	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
@@ -198,7 +198,7 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
 	 * compatible with 802.11 mesh.
 	 */
 	if (rdev->ops->libertas_set_mesh_channel) {
-		if (chandef->_type != NL80211_CHAN_NO_HT)
+		if (chandef->width != NL80211_CHAN_WIDTH_20_NOHT)
 			return -EINVAL;
 
 		if (!netif_running(wdev->netdev))

commit 683b6d3b31a51956ea540df00abb0b78894924c1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Nov 8 21:25:48 2012 +0100

    cfg80211: pass a channel definition struct
    
    Instead of passing a channel pointer and channel type
    to all functions and driver methods, pass a new channel
    definition struct. Right now, this struct contains just
    the control channel and channel type, but for VHT this
    will change.
    
    Also, add a small inline cfg80211_get_chandef_type() so
    that drivers don't need to use the _type field of the
    new structure all the time, which will change.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 966cfc4cd79d..12b5a570a306 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -73,8 +73,6 @@ const struct mesh_config default_mesh_config = {
 
 const struct mesh_setup default_mesh_setup = {
 	/* cfg80211_join_mesh() will pick a channel if needed */
-	.channel = NULL,
-	.channel_type = NL80211_CHAN_NO_HT,
 	.sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
 	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
@@ -111,13 +109,12 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!rdev->ops->join_mesh)
 		return -EOPNOTSUPP;
 
-	if (!setup->channel) {
+	if (!setup->chandef.chan) {
 		/* if no channel explicitly given, use preset channel */
-		setup->channel = wdev->preset_chan;
-		setup->channel_type = wdev->preset_chantype;
+		setup->chandef = wdev->preset_chandef;
 	}
 
-	if (!setup->channel) {
+	if (!setup->chandef.chan) {
 		/* if we don't have that either, use the first usable channel */
 		enum ieee80211_band band;
 
@@ -137,26 +134,25 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 						   IEEE80211_CHAN_DISABLED |
 						   IEEE80211_CHAN_RADAR))
 					continue;
-				setup->channel = chan;
+				setup->chandef.chan = chan;
 				break;
 			}
 
-			if (setup->channel)
+			if (setup->chandef.chan)
 				break;
 		}
 
 		/* no usable channel ... */
-		if (!setup->channel)
+		if (!setup->chandef.chan)
 			return -EINVAL;
 
-		setup->channel_type = NL80211_CHAN_NO_HT;
+		setup->chandef._type = NL80211_CHAN_NO_HT;
 	}
 
-	if (!cfg80211_can_beacon_sec_chan(&rdev->wiphy, setup->channel,
-					  setup->channel_type))
+	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
 		return -EINVAL;
 
-	err = cfg80211_can_use_chan(rdev, wdev, setup->channel,
+	err = cfg80211_can_use_chan(rdev, wdev, setup->chandef.chan,
 				    CHAN_MODE_SHARED);
 	if (err)
 		return err;
@@ -165,7 +161,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
 		wdev->mesh_id_len = setup->mesh_id_len;
-		wdev->channel = setup->channel;
+		wdev->channel = setup->chandef.chan;
 	}
 
 	return err;
@@ -188,20 +184,12 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	return err;
 }
 
-int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
-			   struct wireless_dev *wdev, int freq,
-			   enum nl80211_channel_type channel_type)
+int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev,
+			      struct cfg80211_chan_def *chandef)
 {
-	struct ieee80211_channel *channel;
 	int err;
 
-	channel = rdev_freq_to_chan(rdev, freq, channel_type);
-	if (!channel || !cfg80211_can_beacon_sec_chan(&rdev->wiphy,
-						      channel,
-						      channel_type)) {
-		return -EINVAL;
-	}
-
 	/*
 	 * Workaround for libertas (only!), it puts the interface
 	 * into mesh mode but doesn't implement join_mesh. Instead,
@@ -210,21 +198,21 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 	 * compatible with 802.11 mesh.
 	 */
 	if (rdev->ops->libertas_set_mesh_channel) {
-		if (channel_type != NL80211_CHAN_NO_HT)
+		if (chandef->_type != NL80211_CHAN_NO_HT)
 			return -EINVAL;
 
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
 
-		err = cfg80211_can_use_chan(rdev, wdev, channel,
+		err = cfg80211_can_use_chan(rdev, wdev, chandef->chan,
 					    CHAN_MODE_SHARED);
 		if (err)
 			return err;
 
 		err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
-						     channel);
+						     chandef->chan);
 		if (!err)
-			wdev->channel = channel;
+			wdev->channel = chandef->chan;
 
 		return err;
 	}
@@ -232,8 +220,7 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 	if (wdev->mesh_id_len)
 		return -EBUSY;
 
-	wdev->preset_chan = channel;
-	wdev->preset_chantype = channel_type;
+	wdev->preset_chandef = *chandef;
 	return 0;
 }
 

commit 4ee3e063f10acf6fd17c0ee6f1d0a95726e74cb2
Author: Beni Lev <beni.lev@intel.com>
Date:   Mon Aug 27 12:49:39 2012 +0300

    cfg80211: add cfg80211 exported function tracing
    
    Also add tracing to the API functions that drivers
    (and mac80211) can call in cfg80211.
    
    Signed-off-by: Beni Lev <beni.lev@intel.com>
    Reviewed-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Reviewed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index a18bb3417be5..966cfc4cd79d 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -242,6 +242,7 @@ void cfg80211_notify_new_peer_candidate(struct net_device *dev,
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 
+	trace_cfg80211_notify_new_peer_candidate(dev, macaddr);
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))
 		return;
 

commit e35e4d28b687d4e849573419fdcf90f1cce2a14c
Author: Hila Gonen <hila.gonen@intel.com>
Date:   Wed Jun 27 17:19:42 2012 +0300

    cfg80211: add wrappers for registered_device_ops
    
    This will allow adding central tracing like in mac80211.
    
    Signed-off-by: Hila Gonen <hila.gonen@intel.com>
    Reviewed-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Reviewed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index c384e77ff77a..a18bb3417be5 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -3,6 +3,7 @@
 #include <net/cfg80211.h>
 #include "nl80211.h"
 #include "core.h"
+#include "rdev-ops.h"
 
 /* Default values, timeouts in ms */
 #define MESH_TTL 		31
@@ -160,7 +161,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (err)
 		return err;
 
-	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, setup);
+	err = rdev_join_mesh(rdev, dev, conf, setup);
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
 		wdev->mesh_id_len = setup->mesh_id_len;
@@ -220,9 +221,8 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 		if (err)
 			return err;
 
-		err = rdev->ops->libertas_set_mesh_channel(&rdev->wiphy,
-							   wdev->netdev,
-							   channel);
+		err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
+						     channel);
 		if (!err)
 			wdev->channel = channel;
 
@@ -267,7 +267,7 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	if (!wdev->mesh_id_len)
 		return -ENOTCONN;
 
-	err = rdev->ops->leave_mesh(&rdev->wiphy, dev);
+	err = rdev_leave_mesh(rdev, dev);
 	if (!err) {
 		wdev->mesh_id_len = 0;
 		wdev->channel = NULL;

commit e4e32459c2daea59516da59999706b357e6eb480
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:47:08 2012 +0200

    cfg80211: respect iface combinations when starting operation
    
    devlist_mtx locking is changed to accomodate changes.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index bab381344723..c384e77ff77a 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -155,6 +155,11 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 					  setup->channel_type))
 		return -EINVAL;
 
+	err = cfg80211_can_use_chan(rdev, wdev, setup->channel,
+				    CHAN_MODE_SHARED);
+	if (err)
+		return err;
+
 	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, setup);
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
@@ -173,9 +178,11 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
+	mutex_lock(&rdev->devlist_mtx);
 	wdev_lock(wdev);
 	err = __cfg80211_join_mesh(rdev, dev, setup, conf);
 	wdev_unlock(wdev);
+	mutex_unlock(&rdev->devlist_mtx);
 
 	return err;
 }
@@ -208,6 +215,11 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
 
+		err = cfg80211_can_use_chan(rdev, wdev, channel,
+					    CHAN_MODE_SHARED);
+		if (err)
+			return err;
+
 		err = rdev->ops->libertas_set_mesh_channel(&rdev->wiphy,
 							   wdev->netdev,
 							   channel);

commit f4489ebeffa436c8427a20e2f05004e783708cde
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Jun 29 12:46:58 2012 +0200

    cfg80211: add channel tracking for AP and mesh
    
    We need to know which channel is used by a running
    AP and mesh for channel context accounting and
    finding matching/active interface combination.
    
    STA/IBSS have current_bss already which allows us
    to check which channel a vif is tuned to.
    Non-fixed channel IBSS can be handled with
    additional changes.
    
    Monitor mode is going to be handled differently.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 3b73b07486cf..bab381344723 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -159,6 +159,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
 		wdev->mesh_id_len = setup->mesh_id_len;
+		wdev->channel = setup->channel;
 	}
 
 	return err;
@@ -184,6 +185,7 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 			   enum nl80211_channel_type channel_type)
 {
 	struct ieee80211_channel *channel;
+	int err;
 
 	channel = rdev_freq_to_chan(rdev, freq, channel_type);
 	if (!channel || !cfg80211_can_beacon_sec_chan(&rdev->wiphy,
@@ -205,9 +207,14 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
-		return rdev->ops->libertas_set_mesh_channel(&rdev->wiphy,
-							    wdev->netdev,
-							    channel);
+
+		err = rdev->ops->libertas_set_mesh_channel(&rdev->wiphy,
+							   wdev->netdev,
+							   channel);
+		if (!err)
+			wdev->channel = channel;
+
+		return err;
 	}
 
 	if (wdev->mesh_id_len)
@@ -249,8 +256,11 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 		return -ENOTCONN;
 
 	err = rdev->ops->leave_mesh(&rdev->wiphy, dev);
-	if (!err)
+	if (!err) {
 		wdev->mesh_id_len = 0;
+		wdev->channel = NULL;
+	}
+
 	return err;
 }
 

commit 728b19e5fb9bbebbd580784a092b786fe379ed8e
Author: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
Date:   Thu Jun 14 02:06:10 2012 +0800

    {nl,cfg,mac}80211: implement dot11MeshHWMPconfirmationInterval
    
    As defined in section 13.10.9.3 Case D (802.11-2012), this
    control variable is used to limit the mesh STA to send only
    one PREQ to a root mesh STA within this interval of time
    (in TUs). The default value for this variable is set to
    2000 TUs. However, for current implementation, the maximum
    configurable of dot11MeshHWMPconfirmationInterval is
    restricted by dot11MeshHWMPactivePathTimeout.
    
    Signed-off-by: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
    [line-break commit log]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 2f141cfd581e..3b73b07486cf 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -16,6 +16,7 @@
 #define MESH_RANN_INTERVAL      5000
 #define MESH_PATH_TO_ROOT_TIMEOUT      6000
 #define MESH_ROOT_INTERVAL     5000
+#define MESH_ROOT_CONFIRMATION_INTERVAL 2000
 
 /*
  * Minimum interval between two consecutive PREQs originated by the same
@@ -66,6 +67,7 @@ const struct mesh_config default_mesh_config = {
 	.ht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED,
 	.dot11MeshHWMPactivePathToRootTimeout = MESH_PATH_TO_ROOT_TIMEOUT,
 	.dot11MeshHWMProotInterval = MESH_ROOT_INTERVAL,
+	.dot11MeshHWMPconfirmationInterval = MESH_ROOT_CONFIRMATION_INTERVAL,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit ac1073a61d73b6277794d2efc872eb7e1b706b5c
Author: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
Date:   Thu Jun 14 02:06:06 2012 +0800

    {nl,cfg,mac}80211: implement dot11MeshHWMProotInterval and dot11MeshHWMPactivePathToRootTimeout
    
    Add the mesh configuration parameters dot11MeshHWMProotInterval
    and dot11MeshHWMPactivePathToRootTimeout to be used by
    proactive PREQ mechanism.
    
    Signed-off-by: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
    [line-break commit log]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index b44c736bf9cf..2f141cfd581e 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -14,6 +14,8 @@
 
 #define MESH_PATH_TIMEOUT	5000
 #define MESH_RANN_INTERVAL      5000
+#define MESH_PATH_TO_ROOT_TIMEOUT      6000
+#define MESH_ROOT_INTERVAL     5000
 
 /*
  * Minimum interval between two consecutive PREQs originated by the same
@@ -62,6 +64,8 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshForwarding = true,
 	.rssi_threshold = MESH_RSSI_THRESHOLD,
 	.ht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED,
+	.dot11MeshHWMPactivePathToRootTimeout = MESH_PATH_TO_ROOT_TIMEOUT,
+	.dot11MeshHWMProotInterval = MESH_ROOT_INTERVAL,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit e8c9bd5b8d807cfe6c923265969a523b1ba1e6c2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jun 6 08:18:22 2012 +0200

    cfg80211: clarify set_channel APIs
    
    Now that we've removed all uses of the set_channel
    API except for the monitor channel and in libertas,
    clarify this. Split the libertas mesh use into a
    new libertas_set_mesh_channel() operation, just to
    keep backward compatibility, and rename the normal
    set_channel() to set_monitor_channel().
    
    Also describe the desired set_monitor_channel()
    semantics more clearly.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 2e3b700eba32..b44c736bf9cf 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -179,6 +179,13 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 {
 	struct ieee80211_channel *channel;
 
+	channel = rdev_freq_to_chan(rdev, freq, channel_type);
+	if (!channel || !cfg80211_can_beacon_sec_chan(&rdev->wiphy,
+						      channel,
+						      channel_type)) {
+		return -EINVAL;
+	}
+
 	/*
 	 * Workaround for libertas (only!), it puts the interface
 	 * into mesh mode but doesn't implement join_mesh. Instead,
@@ -186,27 +193,20 @@ int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
 	 * you set the channel. Note that the libertas mesh isn't
 	 * compatible with 802.11 mesh.
 	 */
-	if (!rdev->ops->join_mesh) {
-		int err;
+	if (rdev->ops->libertas_set_mesh_channel) {
+		if (channel_type != NL80211_CHAN_NO_HT)
+			return -EINVAL;
 
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
-		wdev_lock(wdev);
-		err = cfg80211_set_freq(rdev, wdev, freq, channel_type);
-		wdev_unlock(wdev);
-
-		return err;
+		return rdev->ops->libertas_set_mesh_channel(&rdev->wiphy,
+							    wdev->netdev,
+							    channel);
 	}
 
 	if (wdev->mesh_id_len)
 		return -EBUSY;
 
-	channel = rdev_freq_to_chan(rdev, freq, channel_type);
-	if (!channel || !cfg80211_can_beacon_sec_chan(&rdev->wiphy,
-						      channel,
-						      channel_type)) {
-		return -EINVAL;
-	}
 	wdev->preset_chan = channel;
 	wdev->preset_chantype = channel_type;
 	return 0;

commit cc1d2806bf06ab92268343d26eb3d8d8f00f8bc9
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 16 23:50:20 2012 +0200

    cfg80211: provide channel to join_mesh function
    
    Just like the AP mode patch, instead of setting
    the channel and then joining the mesh network,
    provide the channel to join the network on to
    the join_mesh() function.
    
    Like in AP mode, you can also give the channel
    to the join-mesh nl80211 command now.
    
    Unlike AP mode, it picks a default channel if
    none was given.
    
    As libertas uses mesh mode interfaces but has
    no join_mesh callback and we can't simply break
    it, keep some compatibility code for that case
    and configure the channel directly for it.
    
    In the non-libertas case, where we store the
    channel until join, allow setting it while the
    interface is down.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 2749cb86b462..2e3b700eba32 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -65,6 +65,9 @@ const struct mesh_config default_mesh_config = {
 };
 
 const struct mesh_setup default_mesh_setup = {
+	/* cfg80211_join_mesh() will pick a channel if needed */
+	.channel = NULL,
+	.channel_type = NL80211_CHAN_NO_HT,
 	.sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
 	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
@@ -75,7 +78,7 @@ const struct mesh_setup default_mesh_setup = {
 
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
-			 const struct mesh_setup *setup,
+			 struct mesh_setup *setup,
 			 const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -101,6 +104,51 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (!rdev->ops->join_mesh)
 		return -EOPNOTSUPP;
 
+	if (!setup->channel) {
+		/* if no channel explicitly given, use preset channel */
+		setup->channel = wdev->preset_chan;
+		setup->channel_type = wdev->preset_chantype;
+	}
+
+	if (!setup->channel) {
+		/* if we don't have that either, use the first usable channel */
+		enum ieee80211_band band;
+
+		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+			struct ieee80211_supported_band *sband;
+			struct ieee80211_channel *chan;
+			int i;
+
+			sband = rdev->wiphy.bands[band];
+			if (!sband)
+				continue;
+
+			for (i = 0; i < sband->n_channels; i++) {
+				chan = &sband->channels[i];
+				if (chan->flags & (IEEE80211_CHAN_NO_IBSS |
+						   IEEE80211_CHAN_PASSIVE_SCAN |
+						   IEEE80211_CHAN_DISABLED |
+						   IEEE80211_CHAN_RADAR))
+					continue;
+				setup->channel = chan;
+				break;
+			}
+
+			if (setup->channel)
+				break;
+		}
+
+		/* no usable channel ... */
+		if (!setup->channel)
+			return -EINVAL;
+
+		setup->channel_type = NL80211_CHAN_NO_HT;
+	}
+
+	if (!cfg80211_can_beacon_sec_chan(&rdev->wiphy, setup->channel,
+					  setup->channel_type))
+		return -EINVAL;
+
 	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, setup);
 	if (!err) {
 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
@@ -112,7 +160,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       const struct mesh_setup *setup,
+		       struct mesh_setup *setup,
 		       const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -125,6 +173,45 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	return err;
 }
 
+int cfg80211_set_mesh_freq(struct cfg80211_registered_device *rdev,
+			   struct wireless_dev *wdev, int freq,
+			   enum nl80211_channel_type channel_type)
+{
+	struct ieee80211_channel *channel;
+
+	/*
+	 * Workaround for libertas (only!), it puts the interface
+	 * into mesh mode but doesn't implement join_mesh. Instead,
+	 * it is configured via sysfs and then joins the mesh when
+	 * you set the channel. Note that the libertas mesh isn't
+	 * compatible with 802.11 mesh.
+	 */
+	if (!rdev->ops->join_mesh) {
+		int err;
+
+		if (!netif_running(wdev->netdev))
+			return -ENETDOWN;
+		wdev_lock(wdev);
+		err = cfg80211_set_freq(rdev, wdev, freq, channel_type);
+		wdev_unlock(wdev);
+
+		return err;
+	}
+
+	if (wdev->mesh_id_len)
+		return -EBUSY;
+
+	channel = rdev_freq_to_chan(rdev, freq, channel_type);
+	if (!channel || !cfg80211_can_beacon_sec_chan(&rdev->wiphy,
+						      channel,
+						      channel_type)) {
+		return -EINVAL;
+	}
+	wdev->preset_chan = channel;
+	wdev->preset_chantype = channel_type;
+	return 0;
+}
+
 void cfg80211_notify_new_peer_candidate(struct net_device *dev,
 		const u8 *macaddr, const u8* ie, u8 ie_len, gfp_t gfp)
 {

commit 70c33eaae79e53f9e48324736c0cb85534d3f093
Author: Ashok Nagarajan <ashok@cozybit.com>
Date:   Mon Apr 30 14:20:32 2012 -0700

    {nl,cfg,mac}80211: Allow user to see/configure HT protection mode
    
    This patch introduces a new mesh configuration parameter "ht_opmode" and will
    allow user to check the current HT protection mode selected. Users could
    configure the protection mode by the command "iw mesh_iface set mesh_param
    mesh_ht_protection_mode=2". The default protection mode of mesh is set to
    non-HT mixed mode.
    
    Signed-off-by: Ashok Nagarajan <ashok@cozybit.com>
    Reviewed-by: Thomas Pedersen <thomas@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 8c747fa9319b..2749cb86b462 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -61,6 +61,7 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshGateAnnouncementProtocol = false,
 	.dot11MeshForwarding = true,
 	.rssi_threshold = MESH_RSSI_THRESHOLD,
+	.ht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit d299a1f21ea7ffd5114d099b2f92c867c495e8b3
Author: Javier Cardona <javier@cozybit.com>
Date:   Sat Mar 31 11:31:33 2012 -0700

    {nl,cfg}80211: Support for mesh synchronization
    
    Report Toffset to userspace.
    Let userspace select the mesh synchronization method.
    
    Signed-off-by: Marco Porsch <marco.porsch@s2005.tu-chemnitz.de>
    Signed-off-by: Pavel Zubarev <pavel.zubarev@gmail.com>
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index ba21ab22187b..8c747fa9319b 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -38,6 +38,7 @@
 
 #define MESH_MAX_PREQ_RETRIES	4
 
+#define MESH_SYNC_NEIGHBOR_OFFSET_MAX 50
 
 const struct mesh_config default_mesh_config = {
 	.dot11MeshRetryTimeout = MESH_RET_T,
@@ -48,6 +49,7 @@ const struct mesh_config default_mesh_config = {
 	.element_ttl = MESH_DEFAULT_ELEMENT_TTL,
 	.auto_open_plinks = true,
 	.dot11MeshMaxPeerLinks = MESH_MAX_ESTAB_PLINKS,
+	.dot11MeshNbrOffsetMaxNeighbor = MESH_SYNC_NEIGHBOR_OFFSET_MAX,
 	.dot11MeshHWMPactivePathTimeout = MESH_PATH_TIMEOUT,
 	.dot11MeshHWMPpreqMinInterval = MESH_PREQ_MIN_INT,
 	.dot11MeshHWMPperrMinInterval = MESH_PERR_MIN_INT,
@@ -62,6 +64,7 @@ const struct mesh_config default_mesh_config = {
 };
 
 const struct mesh_setup default_mesh_setup = {
+	.sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
 	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
 	.ie = NULL,

commit 5533513784a88049e19dd2ab380a452b61e5171e
Author: Ashok Nagarajan <ashok@cozybit.com>
Date:   Tue Feb 28 17:04:08 2012 -0800

    {nl,cfg,mac}80211: Implement RSSI threshold for mesh peering
    
    Mesh peer links are established only if average rssi of the peer
    candidate satisfies the threshold. This is not in 802.11s specification
    but was requested by David Fulgham, an open80211s user. This is a way to avoid
    marginal peer links with stations that are barely within range.
    
    This patch adds a new mesh configuration parameter, mesh_rssi_threshold. This
    feature is supported only for hardwares that report signal in dBm.
    
    Signed-off-by: Ashok Nagarajan <ashok@cozybit.com>
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 9d3e3b6bfcf4..ba21ab22187b 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -23,6 +23,8 @@
 #define MESH_PERR_MIN_INT	100
 #define MESH_DIAM_TRAVERSAL_TIME 50
 
+#define MESH_RSSI_THRESHOLD	0
+
 /*
  * A path will be refreshed if it is used PATH_REFRESH_TIME milliseconds
  * before timing out.  This way it will remain ACTIVE and no data frames
@@ -56,6 +58,7 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshHWMPRannInterval = MESH_RANN_INTERVAL,
 	.dot11MeshGateAnnouncementProtocol = false,
 	.dot11MeshForwarding = true,
+	.rssi_threshold = MESH_RSSI_THRESHOLD,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit 94f9065648a2645b28187b44ec7778c30cf58758
Author: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
Date:   Sat Jan 21 01:02:16 2012 +0800

    {nl,cfg,mac}80211: Add support of setting non-forwarding entity in Mesh
    
    A mesh node that joins the mesh network is by default a forwarding entity. This patch allows
    the mesh node to set as non-forwarding entity. Whenever dot11MeshForwarding is set to 0, the
    mesh node can prevent itself from forwarding the traffic which is not destined to him.
    
    Signed-off-by: Chun-Yeow Yeoh <yeohchunyeow@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 8c550df13037..9d3e3b6bfcf4 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -55,6 +55,7 @@ const struct mesh_config default_mesh_config = {
 	.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,
 	.dot11MeshHWMPRannInterval = MESH_RANN_INTERVAL,
 	.dot11MeshGateAnnouncementProtocol = false,
+	.dot11MeshForwarding = true,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit dca7e9430cb3e492437a5ce891b8b3e315c147ca
Author: Thomas Pedersen <thomas@cozybit.com>
Date:   Thu Nov 24 17:15:24 2011 -0800

    {nl,cfg,mac}80211: implement dot11MeshHWMPperrMinInterval
    
    As per 802.11mb 13.9.11.3
    
    Signed-off-by: Thomas Pedersen <thomas@cozybit.com>
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index b7b7868f4128..8c550df13037 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -20,6 +20,7 @@
  * interface
  */
 #define MESH_PREQ_MIN_INT	10
+#define MESH_PERR_MIN_INT	100
 #define MESH_DIAM_TRAVERSAL_TIME 50
 
 /*
@@ -47,6 +48,7 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshMaxPeerLinks = MESH_MAX_ESTAB_PLINKS,
 	.dot11MeshHWMPactivePathTimeout = MESH_PATH_TIMEOUT,
 	.dot11MeshHWMPpreqMinInterval = MESH_PREQ_MIN_INT,
+	.dot11MeshHWMPperrMinInterval = MESH_PERR_MIN_INT,
 	.dot11MeshHWMPnetDiameterTraversalTime = MESH_DIAM_TRAVERSAL_TIME,
 	.dot11MeshHWMPmaxPREQretries = MESH_MAX_PREQ_RETRIES,
 	.path_refresh_time = MESH_PATH_REFRESH_TIME,

commit bc3b2d7fb9b014d75ebb79ba371a763dbab5e8cf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 11:47:34 2011 -0400

    net: Add export.h for EXPORT_SYMBOL/THIS_MODULE to non-modules
    
    These files are non modular, but need to export symbols using
    the macros now living in export.h -- call out the include so
    that things won't break when we remove the implicit presence
    of module.h from everywhere.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 4423e64c7d98..b7b7868f4128 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -1,4 +1,5 @@
 #include <linux/ieee80211.h>
+#include <linux/export.h>
 #include <net/cfg80211.h>
 #include "nl80211.h"
 #include "core.h"

commit 16dd7267f460739b3e29d984e73f05c5ffe2b142
Author: Javier Cardona <javier@cozybit.com>
Date:   Tue Aug 9 16:45:11 2011 -0700

    {nl,cfg,mac}80211: let userspace make meshif mesh gate
    
    Allow userspace to set NL80211_MESHCONF_GATE_ANNOUNCEMENTS attribute,
    which will advertise this mesh node as being a mesh gate.
    NL80211_HWMP_ROOTMODE must be set or this will do nothing.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index b5a39d4d1dcf..4423e64c7d98 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -51,6 +51,7 @@ const struct mesh_config default_mesh_config = {
 	.path_refresh_time = MESH_PATH_REFRESH_TIME,
 	.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,
 	.dot11MeshHWMPRannInterval = MESH_RANN_INTERVAL,
+	.dot11MeshGateAnnouncementProtocol = false,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit 0507e159a2b590666982b53ecf6fb2843a5bb423
Author: Javier Cardona <javier@cozybit.com>
Date:   Tue Aug 9 16:45:10 2011 -0700

    {nl,cfg,mac}80211: let userspace set RANN interval
    
    Allow userspace to set Root Announcement Interval for our mesh
    interface. Also, RANN interval is now in proper units of TUs.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 5c116083eeca..b5a39d4d1dcf 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -12,6 +12,7 @@
 #define MESH_HOLD_T 		100
 
 #define MESH_PATH_TIMEOUT	5000
+#define MESH_RANN_INTERVAL      5000
 
 /*
  * Minimum interval between two consecutive PREQs originated by the same
@@ -49,6 +50,7 @@ const struct mesh_config default_mesh_config = {
 	.dot11MeshHWMPmaxPREQretries = MESH_MAX_PREQ_RETRIES,
 	.path_refresh_time = MESH_PATH_REFRESH_TIME,
 	.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,
+	.dot11MeshHWMPRannInterval = MESH_RANN_INTERVAL,
 };
 
 const struct mesh_setup default_mesh_setup = {

commit c93b5e717ec47b57abfe0229360bc11e77520984
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Apr 7 15:08:34 2011 -0700

    nl80211: New notification to discover mesh peer candidates.
    
    Notify userspace when a beacon/presp is received from a suitable mesh
    peer candidate for whom no sta information exists.  Userspace can then
    decide to create a sta info for the candidate.  If userspace is not
    ready to authenticate the peer right away, it can create the sta info
    with the authenticated flag unset and set it later.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index e0226e8265a3..5c116083eeca 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -1,5 +1,6 @@
 #include <linux/ieee80211.h>
 #include <net/cfg80211.h>
+#include "nl80211.h"
 #include "core.h"
 
 /* Default values, timeouts in ms */
@@ -110,6 +111,19 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	return err;
 }
 
+void cfg80211_notify_new_peer_candidate(struct net_device *dev,
+		const u8 *macaddr, const u8* ie, u8 ie_len, gfp_t gfp)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+
+	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))
+		return;
+
+	nl80211_send_new_peer_candidate(wiphy_to_dev(wdev->wiphy), dev,
+			macaddr, ie, ie_len, gfp);
+}
+EXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);
+
 static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 				 struct net_device *dev)
 {

commit 5cff5e01e818029a5d2c3c31b7ae5e5e7ee70452
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Apr 7 15:08:29 2011 -0700

    mac80211: ignore peers if security is enabled for this mesh
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0e5c122ce324..e0226e8265a3 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -55,6 +55,7 @@ const struct mesh_setup default_mesh_setup = {
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
 	.ie = NULL,
 	.ie_len = 0,
+	.is_secure = false,
 };
 
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,

commit 15d5dda623139bbf6165030fc251bbd5798f4130
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Apr 7 15:08:28 2011 -0700

    cfg80211/nl80211: Add userspace authentication flag to mesh setup
    
    During mesh setup, use NL80211_MESH_SETUP_USERSPACE_AUTH flag to create
    a secure mesh and route management frames to userspace.
    
    Also, NL80211_CMD_GET_WIPHY now returns a flag NL80211_SUPPORT_MESH_AUTH
    if the wiphy's mesh implementation supports routing of mesh auth frames
    to userspace.  This is useful for forward compatibility between old
    kernels and new userspace tools.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: Thomas Pedersen <thomas@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0d4b2260f96f..0e5c122ce324 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -72,6 +72,10 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
 		return -EOPNOTSUPP;
 
+	if (!(rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&
+	      setup->is_secure)
+		return -EOPNOTSUPP;
+
 	if (wdev->mesh_id_len)
 		return -EALREADY;
 

commit 581a8b0feeed8877aab3a8ca4c972419790cd07f
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Apr 7 15:08:27 2011 -0700

    nl80211: rename NL80211_MESH_SETUP_VENDOR_PATH_SEL_IE
    
    To NL80211_MESH_SETUP_IE. This reflects our ability to insert any ie
    into a mesh beacon, not simply path selection ies.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 73e39c171ffb..0d4b2260f96f 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -53,8 +53,8 @@ const struct mesh_config default_mesh_config = {
 const struct mesh_setup default_mesh_setup = {
 	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
 	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
-	.vendor_ie = NULL,
-	.vendor_ie_len = 0,
+	.ie = NULL,
+	.ie_len = 0,
 };
 
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,

commit c80d545da3f7c0e534ccd4a780f322f80a92cff1
Author: Javier Cardona <javier@cozybit.com>
Date:   Thu Dec 16 17:37:49 2010 -0800

    mac80211: Let userspace enable and configure vendor specific path selection.
    
    Userspace will now be allowed to toggle between the default path
    selection algorithm (HWMP, implemented in the kernel), and a vendor
    specific alternative.  Also in the same patch, allow userspace to add
    information elements to mesh beacons.  This is accordance with the
    Extensible Path Selection Framework specified in version 7.0 of the
    802.11s draft.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index e0b9747fe50a..73e39c171ffb 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -50,17 +50,19 @@ const struct mesh_config default_mesh_config = {
 	.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,
 };
 
+const struct mesh_setup default_mesh_setup = {
+	.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
+	.path_metric = IEEE80211_PATH_METRIC_AIRTIME,
+	.vendor_ie = NULL,
+	.vendor_ie_len = 0,
+};
 
 int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 			 struct net_device *dev,
-			 const u8 *mesh_id, u8 mesh_id_len,
+			 const struct mesh_setup *setup,
 			 const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	struct mesh_setup setup = {
-		.mesh_id = mesh_id,
-		.mesh_id_len = mesh_id_len,
-	};
 	int err;
 
 	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
@@ -73,16 +75,16 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 	if (wdev->mesh_id_len)
 		return -EALREADY;
 
-	if (!mesh_id_len)
+	if (!setup->mesh_id_len)
 		return -EINVAL;
 
 	if (!rdev->ops->join_mesh)
 		return -EOPNOTSUPP;
 
-	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, &setup);
+	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, setup);
 	if (!err) {
-		memcpy(wdev->ssid, mesh_id, mesh_id_len);
-		wdev->mesh_id_len = mesh_id_len;
+		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
+		wdev->mesh_id_len = setup->mesh_id_len;
 	}
 
 	return err;
@@ -90,14 +92,14 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 		       struct net_device *dev,
-		       const u8 *mesh_id, u8 mesh_id_len,
+		       const struct mesh_setup *setup,
 		       const struct mesh_config *conf)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
 	wdev_lock(wdev);
-	err = __cfg80211_join_mesh(rdev, dev, mesh_id, mesh_id_len, conf);
+	err = __cfg80211_join_mesh(rdev, dev, setup, conf);
 	wdev_unlock(wdev);
 
 	return err;

commit 29cbe68c516a48a9a88b3226878570c6cbd83c02
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Dec 3 09:20:44 2010 +0100

    cfg80211/mac80211: add mesh join/leave commands
    
    Instead of tying mesh activity to interface up,
    add join and leave commands for mesh. Since we
    must be backward compatible, let cfg80211 handle
    joining a mesh if a mesh ID was pre-configured
    when the device goes up.
    
    Note that this therefore must modify mac80211 as
    well since mac80211 needs to lose the logic to
    start the mesh on interface up.
    
    We now allow querying mesh parameters before the
    mesh is connected, which simply returns defaults.
    Setting them (internally renamed to "update") is
    only allowed while connected. Specify them with
    the new mesh join command instead where needed.
    
    In mac80211, beaconing must now also follow the
    mesh enabled/not enabled state, which is done
    by testing the mesh ID.
    
    Signed-off-by: Javier Cardona <javier@cozybit.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
new file mode 100644
index 000000000000..e0b9747fe50a
--- /dev/null
+++ b/net/wireless/mesh.c
@@ -0,0 +1,140 @@
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+#include "core.h"
+
+/* Default values, timeouts in ms */
+#define MESH_TTL 		31
+#define MESH_DEFAULT_ELEMENT_TTL 31
+#define MESH_MAX_RETR	 	3
+#define MESH_RET_T 		100
+#define MESH_CONF_T 		100
+#define MESH_HOLD_T 		100
+
+#define MESH_PATH_TIMEOUT	5000
+
+/*
+ * Minimum interval between two consecutive PREQs originated by the same
+ * interface
+ */
+#define MESH_PREQ_MIN_INT	10
+#define MESH_DIAM_TRAVERSAL_TIME 50
+
+/*
+ * A path will be refreshed if it is used PATH_REFRESH_TIME milliseconds
+ * before timing out.  This way it will remain ACTIVE and no data frames
+ * will be unnecessarily held in the pending queue.
+ */
+#define MESH_PATH_REFRESH_TIME			1000
+#define MESH_MIN_DISCOVERY_TIMEOUT (2 * MESH_DIAM_TRAVERSAL_TIME)
+
+/* Default maximum number of established plinks per interface */
+#define MESH_MAX_ESTAB_PLINKS	32
+
+#define MESH_MAX_PREQ_RETRIES	4
+
+
+const struct mesh_config default_mesh_config = {
+	.dot11MeshRetryTimeout = MESH_RET_T,
+	.dot11MeshConfirmTimeout = MESH_CONF_T,
+	.dot11MeshHoldingTimeout = MESH_HOLD_T,
+	.dot11MeshMaxRetries = MESH_MAX_RETR,
+	.dot11MeshTTL = MESH_TTL,
+	.element_ttl = MESH_DEFAULT_ELEMENT_TTL,
+	.auto_open_plinks = true,
+	.dot11MeshMaxPeerLinks = MESH_MAX_ESTAB_PLINKS,
+	.dot11MeshHWMPactivePathTimeout = MESH_PATH_TIMEOUT,
+	.dot11MeshHWMPpreqMinInterval = MESH_PREQ_MIN_INT,
+	.dot11MeshHWMPnetDiameterTraversalTime = MESH_DIAM_TRAVERSAL_TIME,
+	.dot11MeshHWMPmaxPREQretries = MESH_MAX_PREQ_RETRIES,
+	.path_refresh_time = MESH_PATH_REFRESH_TIME,
+	.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,
+};
+
+
+int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
+			 const u8 *mesh_id, u8 mesh_id_len,
+			 const struct mesh_config *conf)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct mesh_setup setup = {
+		.mesh_id = mesh_id,
+		.mesh_id_len = mesh_id_len,
+	};
+	int err;
+
+	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
+
+	ASSERT_WDEV_LOCK(wdev);
+
+	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
+		return -EOPNOTSUPP;
+
+	if (wdev->mesh_id_len)
+		return -EALREADY;
+
+	if (!mesh_id_len)
+		return -EINVAL;
+
+	if (!rdev->ops->join_mesh)
+		return -EOPNOTSUPP;
+
+	err = rdev->ops->join_mesh(&rdev->wiphy, dev, conf, &setup);
+	if (!err) {
+		memcpy(wdev->ssid, mesh_id, mesh_id_len);
+		wdev->mesh_id_len = mesh_id_len;
+	}
+
+	return err;
+}
+
+int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
+		       struct net_device *dev,
+		       const u8 *mesh_id, u8 mesh_id_len,
+		       const struct mesh_config *conf)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int err;
+
+	wdev_lock(wdev);
+	err = __cfg80211_join_mesh(rdev, dev, mesh_id, mesh_id_len, conf);
+	wdev_unlock(wdev);
+
+	return err;
+}
+
+static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+				 struct net_device *dev)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int err;
+
+	ASSERT_WDEV_LOCK(wdev);
+
+	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
+		return -EOPNOTSUPP;
+
+	if (!rdev->ops->leave_mesh)
+		return -EOPNOTSUPP;
+
+	if (!wdev->mesh_id_len)
+		return -ENOTCONN;
+
+	err = rdev->ops->leave_mesh(&rdev->wiphy, dev);
+	if (!err)
+		wdev->mesh_id_len = 0;
+	return err;
+}
+
+int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+			struct net_device *dev)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int err;
+
+	wdev_lock(wdev);
+	err = __cfg80211_leave_mesh(rdev, dev);
+	wdev_unlock(wdev);
+
+	return err;
+}
