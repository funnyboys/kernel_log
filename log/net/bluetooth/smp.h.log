commit cb28c306b93b71f2741ce1a5a66289db26715f4d
Author: Matias Karhumaa <matias.karhumaa@gmail.com>
Date:   Wed Sep 26 09:13:46 2018 +0300

    Bluetooth: SMP: fix crash in unpairing
    
    In case unpair_device() was called through mgmt interface at the same time
    when pairing was in progress, Bluetooth kernel module crash was seen.
    
    [  600.351225] general protection fault: 0000 [#1] SMP PTI
    [  600.351235] CPU: 1 PID: 11096 Comm: btmgmt Tainted: G           OE     4.19.0-rc1+ #1
    [  600.351238] Hardware name: Dell Inc. Latitude E5440/08RCYC, BIOS A18 05/14/2017
    [  600.351272] RIP: 0010:smp_chan_destroy.isra.10+0xce/0x2c0 [bluetooth]
    [  600.351276] Code: c0 0f 84 b4 01 00 00 80 78 28 04 0f 84 53 01 00 00 4d 85 ed 0f 85 ab 00 00 00 48 8b 08 48 8b 50 08 be 10 00 00 00 48 89 51 08 <48> 89 0a 48 b9 00 02 00 00 00 00 ad de 48 89 48 08 48 8b 83 00 01
    [  600.351279] RSP: 0018:ffffa9be839b3b50 EFLAGS: 00010246
    [  600.351282] RAX: ffff9c999ac565a0 RBX: ffff9c9996e98c00 RCX: ffff9c999aa28b60
    [  600.351285] RDX: dead000000000200 RSI: 0000000000000010 RDI: ffff9c999e403500
    [  600.351287] RBP: ffffa9be839b3b70 R08: 0000000000000000 R09: ffffffff92a25c00
    [  600.351290] R10: ffffa9be839b3ae8 R11: 0000000000000001 R12: ffff9c995375b800
    [  600.351292] R13: 0000000000000000 R14: ffff9c99619a5000 R15: ffff9c9962a01c00
    [  600.351295] FS:  00007fb2be27c700(0000) GS:ffff9c999e880000(0000) knlGS:0000000000000000
    [  600.351298] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  600.351300] CR2: 00007fb2bdadbad0 CR3: 000000041c328001 CR4: 00000000001606e0
    [  600.351302] Call Trace:
    [  600.351325]  smp_failure+0x4f/0x70 [bluetooth]
    [  600.351345]  smp_cancel_pairing+0x74/0x80 [bluetooth]
    [  600.351370]  unpair_device+0x1c1/0x330 [bluetooth]
    [  600.351399]  hci_sock_sendmsg+0x960/0x9f0 [bluetooth]
    [  600.351409]  ? apparmor_socket_sendmsg+0x1e/0x20
    [  600.351417]  sock_sendmsg+0x3e/0x50
    [  600.351422]  sock_write_iter+0x85/0xf0
    [  600.351429]  do_iter_readv_writev+0x12b/0x1b0
    [  600.351434]  do_iter_write+0x87/0x1a0
    [  600.351439]  vfs_writev+0x98/0x110
    [  600.351443]  ? ep_poll+0x16d/0x3d0
    [  600.351447]  ? ep_modify+0x73/0x170
    [  600.351451]  do_writev+0x61/0xf0
    [  600.351455]  ? do_writev+0x61/0xf0
    [  600.351460]  __x64_sys_writev+0x1c/0x20
    [  600.351465]  do_syscall_64+0x5a/0x110
    [  600.351471]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [  600.351474] RIP: 0033:0x7fb2bdb62fe0
    [  600.351477] Code: 73 01 c3 48 8b 0d b8 6e 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 69 c7 2c 00 00 75 10 b8 14 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 de 80 01 00 48 89 04 24
    [  600.351479] RSP: 002b:00007ffe062cb8f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000014
    [  600.351484] RAX: ffffffffffffffda RBX: 000000000255b3d0 RCX: 00007fb2bdb62fe0
    [  600.351487] RDX: 0000000000000001 RSI: 00007ffe062cb920 RDI: 0000000000000004
    [  600.351490] RBP: 00007ffe062cb920 R08: 000000000255bd80 R09: 0000000000000000
    [  600.351494] R10: 0000000000000353 R11: 0000000000000246 R12: 0000000000000001
    [  600.351497] R13: 00007ffe062cbbe0 R14: 0000000000000000 R15: 0000000000000000
    [  600.351501] Modules linked in: algif_hash algif_skcipher af_alg cmac ipt_MASQUERADE nf_conntrack_netlink nfnetlink xfrm_user xfrm_algo iptable_nat nf_nat_ipv4 xt_addrtype iptable_filter ip_tables xt_conntrack x_tables nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c br_netfilter bridge stp llc overlay arc4 nls_iso8859_1 dm_crypt intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp dell_laptop kvm_intel crct10dif_pclmul dell_smm_hwmon crc32_pclmul ghash_clmulni_intel pcbc aesni_intel aes_x86_64 crypto_simd cryptd glue_helper intel_cstate intel_rapl_perf uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_v4l2 videobuf2_common videodev media hid_multitouch input_leds joydev serio_raw dell_wmi snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic dell_smbios dcdbas sparse_keymap
    [  600.351569]  snd_hda_intel btusb snd_hda_codec btrtl btbcm btintel snd_hda_core bluetooth(OE) snd_hwdep snd_pcm iwlmvm ecdh_generic wmi_bmof dell_wmi_descriptor snd_seq_midi mac80211 snd_seq_midi_event lpc_ich iwlwifi snd_rawmidi snd_seq snd_seq_device snd_timer cfg80211 snd soundcore mei_me mei dell_rbtn dell_smo8800 mac_hid parport_pc ppdev lp parport autofs4 hid_generic usbhid hid i915 nouveau kvmgt vfio_mdev mdev vfio_iommu_type1 vfio kvm irqbypass i2c_algo_bit ttm drm_kms_helper syscopyarea sysfillrect sysimgblt mxm_wmi psmouse ahci sdhci_pci cqhci libahci fb_sys_fops sdhci drm e1000e video wmi
    [  600.351637] ---[ end trace e49e9f1df09c94fb ]---
    [  600.351664] RIP: 0010:smp_chan_destroy.isra.10+0xce/0x2c0 [bluetooth]
    [  600.351666] Code: c0 0f 84 b4 01 00 00 80 78 28 04 0f 84 53 01 00 00 4d 85 ed 0f 85 ab 00 00 00 48 8b 08 48 8b 50 08 be 10 00 00 00 48 89 51 08 <48> 89 0a 48 b9 00 02 00 00 00 00 ad de 48 89 48 08 48 8b 83 00 01
    [  600.351669] RSP: 0018:ffffa9be839b3b50 EFLAGS: 00010246
    [  600.351672] RAX: ffff9c999ac565a0 RBX: ffff9c9996e98c00 RCX: ffff9c999aa28b60
    [  600.351674] RDX: dead000000000200 RSI: 0000000000000010 RDI: ffff9c999e403500
    [  600.351676] RBP: ffffa9be839b3b70 R08: 0000000000000000 R09: ffffffff92a25c00
    [  600.351679] R10: ffffa9be839b3ae8 R11: 0000000000000001 R12: ffff9c995375b800
    [  600.351681] R13: 0000000000000000 R14: ffff9c99619a5000 R15: ffff9c9962a01c00
    [  600.351684] FS:  00007fb2be27c700(0000) GS:ffff9c999e880000(0000) knlGS:0000000000000000
    [  600.351686] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  600.351689] CR2: 00007fb2bdadbad0 CR3: 000000041c328001 CR4: 00000000001606e0
    
    Crash happened because list_del_rcu() was called twice for smp->ltk. This
    was possible if unpair_device was called right after ltk was generated
    but before keys were distributed.
    
    In this commit smp_cancel_pairing was refactored to cancel pairing if it
    is in progress and otherwise just removes keys. Once keys are removed from
    rcu list, pointers to smp context's keys are set to NULL to make sure
    removed list items are not accessed later.
    
    This commit also adjusts the functionality of mgmt unpair_device() little
    bit. Previously pairing was canceled only if pairing was in state that
    keys were already generated. With this commit unpair_device() cancels
    pairing already in earlier states.
    
    Bug was found by fuzzing kernel SMP implementation using Synopsys
    Defensics.
    
    Reported-by: Pekka Oikarainen <pekka.oikarainen@synopsys.com>
    Signed-off-by: Matias Karhumaa <matias.karhumaa@gmail.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 0ff6247eaa6c..121edadd5f8d 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -181,7 +181,8 @@ enum smp_key_pref {
 };
 
 /* SMP Commands */
-void smp_cancel_pairing(struct hci_conn *hcon);
+int smp_cancel_and_remove_pairing(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				  u8 addr_type);
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,
 			     enum smp_key_pref key_pref);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);

commit a62da6f14db79bd7ea435ab095e998b31b3dbb22
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Dec 8 08:32:54 2016 +0200

    Bluetooth: SMP: Add support for H7 crypto function and CT2 auth flag
    
    Bluetooth 5.0 introduces a new H7 key generation function that's used
    when both sides of the pairing set the CT2 authentication flag to 1.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index ffcc70b6b199..0ff6247eaa6c 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -57,6 +57,7 @@ struct smp_cmd_pairing {
 #define SMP_AUTH_MITM		0x04
 #define SMP_AUTH_SC		0x08
 #define SMP_AUTH_KEYPRESS	0x10
+#define SMP_AUTH_CT2		0x20
 
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {

commit c81d555a264bde740adc314f3931046994534106
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Oct 22 09:38:35 2015 +0300

    Bluetooth: Fix crash in SMP when unpairing
    
    When unpairing the keys stored in hci_dev are removed. If SMP is
    ongoing the SMP context will also have references to these keys, so
    removing them from the hci_dev lists will make the pointers invalid.
    This can result in the following type of crashes:
    
     BUG: unable to handle kernel paging request at 6b6b6b6b
     IP: [<c11f26be>] __list_del_entry+0x44/0x71
     *pde = 00000000
     Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC
     Modules linked in: hci_uart btqca btusb btintel btbcm btrtl hci_vhci rfcomm bluetooth_6lowpan bluetooth
     CPU: 0 PID: 723 Comm: kworker/u5:0 Not tainted 4.3.0-rc3+ #1379
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.1-20150318_183358- 04/01/2014
     Workqueue: hci0 hci_rx_work [bluetooth]
     task: f19da940 ti: f1a94000 task.ti: f1a94000
     EIP: 0060:[<c11f26be>] EFLAGS: 00010202 CPU: 0
     EIP is at __list_del_entry+0x44/0x71
     EAX: c0088d20 EBX: f30fcac0 ECX: 6b6b6b6b EDX: 6b6b6b6b
     ESI: f4b60000 EDI: c0088d20 EBP: f1a95d90 ESP: f1a95d8c
      DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
     CR0: 8005003b CR2: 6b6b6b6b CR3: 319e5000 CR4: 00000690
     Stack:
      f30fcac0 f1a95db0 f82dc3e1 f1bfc000 00000000 c106524f f1bfc000 f30fd020
      f1a95dc0 f1a95dd0 f82dcbdb f1a95de0 f82dcbdb 00000067 f1bfc000 f30fd020
      f1a95de0 f1a95df0 f82d1126 00000067 f82d1126 00000006 f30fd020 f1bfc000
     Call Trace:
      [<f82dc3e1>] smp_chan_destroy+0x192/0x240 [bluetooth]
      [<c106524f>] ? trace_hardirqs_on_caller+0x14e/0x169
      [<f82dcbdb>] smp_teardown_cb+0x47/0x64 [bluetooth]
      [<f82dcbdb>] ? smp_teardown_cb+0x47/0x64 [bluetooth]
      [<f82d1126>] l2cap_chan_del+0x5d/0x14d [bluetooth]
      [<f82d1126>] ? l2cap_chan_del+0x5d/0x14d [bluetooth]
      [<f82d40ef>] l2cap_conn_del+0x109/0x17b [bluetooth]
      [<f82d40ef>] ? l2cap_conn_del+0x109/0x17b [bluetooth]
      [<f82c0205>] ? hci_event_packet+0x5b1/0x2092 [bluetooth]
      [<f82d41aa>] l2cap_disconn_cfm+0x49/0x50 [bluetooth]
      [<f82d41aa>] ? l2cap_disconn_cfm+0x49/0x50 [bluetooth]
      [<f82c0228>] hci_event_packet+0x5d4/0x2092 [bluetooth]
      [<c1332c16>] ? skb_release_data+0x6a/0x95
      [<f82ce5d4>] ? hci_send_to_monitor+0xe7/0xf4 [bluetooth]
      [<c1409708>] ? _raw_spin_unlock_irqrestore+0x44/0x57
      [<f82b3bb0>] hci_rx_work+0xf1/0x28b [bluetooth]
      [<f82b3bb0>] ? hci_rx_work+0xf1/0x28b [bluetooth]
      [<c10635a0>] ? __lock_is_held+0x2e/0x44
      [<c104772e>] process_one_work+0x232/0x432
      [<c1071ddc>] ? rcu_read_lock_sched_held+0x50/0x5a
      [<c104772e>] ? process_one_work+0x232/0x432
      [<c1047d48>] worker_thread+0x1b8/0x255
      [<c1047b90>] ? rescuer_thread+0x23c/0x23c
      [<c104bb71>] kthread+0x91/0x96
      [<c14096a7>] ? _raw_spin_unlock_irq+0x27/0x44
      [<c1409d61>] ret_from_kernel_thread+0x21/0x30
      [<c104bae0>] ? kthread_parkme+0x1e/0x1e
    
    To solve the issue, introduce a new smp_cancel_pairing() API that can
    be used to clean up the SMP state before touching the hci_dev lists.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 6cf872563ea7..ffcc70b6b199 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -180,6 +180,7 @@ enum smp_key_pref {
 };
 
 /* SMP Commands */
+void smp_cancel_pairing(struct hci_conn *hcon);
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,
 			     enum smp_key_pref key_pref);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);

commit 60a27d653d972584e5e98ab3558c62c3d3bc547a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Mar 16 01:10:22 2015 -0700

    Bluetooth: Add function for generating LE SC out-of-band data
    
    This patch adds a smp_generate_oob function that allows to create
    local out-of-band data that can be used for pairing and also provides
    the confirmation and random value.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 60c5b73fcb4b..6cf872563ea7 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -188,6 +188,7 @@ int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 bool smp_irk_matches(struct hci_dev *hdev, const u8 irk[16],
 		     const bdaddr_t *bdaddr);
 int smp_generate_rpa(struct hci_dev *hdev, const u8 irk[16], bdaddr_t *rpa);
+int smp_generate_oob(struct hci_dev *hdev, u8 hash[16], u8 rand[16]);
 
 int smp_register(struct hci_dev *hdev);
 void smp_unregister(struct hci_dev *hdev);

commit 0a2b0f0452e2499a1037305fcfc314d0cdeb5260
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Dec 30 09:50:39 2014 +0200

    Bluetooth: Add skeleton for SMP self-tests
    
    This patch adds the initial skeleton and kernel config option for SMP
    self-tests.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 3296bf42ae80..60c5b73fcb4b 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -192,4 +192,17 @@ int smp_generate_rpa(struct hci_dev *hdev, const u8 irk[16], bdaddr_t *rpa);
 int smp_register(struct hci_dev *hdev);
 void smp_unregister(struct hci_dev *hdev);
 
+#if IS_ENABLED(CONFIG_BT_SELFTEST_SMP)
+
+int bt_selftest_smp(void);
+
+#else
+
+static inline int bt_selftest_smp(void)
+{
+	return 0;
+}
+
+#endif
+
 #endif /* __SMP_H */

commit cd0827976205f842cc722f48a1427c9b77c3ca28
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Dec 2 13:37:41 2014 +0200

    Bluetooth: Fix missing const declarations in SMP functions
    
    Several SMP functions take read-only data. This patch fixes the
    declaration of these parameters to use the const specifier as
    appropriate.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f955d6b7ceb2..3296bf42ae80 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -185,8 +185,9 @@ bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
-bool smp_irk_matches(struct hci_dev *hdev, u8 irk[16], bdaddr_t *bdaddr);
-int smp_generate_rpa(struct hci_dev *hdev, u8 irk[16], bdaddr_t *rpa);
+bool smp_irk_matches(struct hci_dev *hdev, const u8 irk[16],
+		     const bdaddr_t *bdaddr);
+int smp_generate_rpa(struct hci_dev *hdev, const u8 irk[16], bdaddr_t *rpa);
 
 int smp_register(struct hci_dev *hdev);
 void smp_unregister(struct hci_dev *hdev);

commit 8f5eeca321b4a618550a0c4c2d3da935aa7073b0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri May 23 13:36:10 2014 +0300

    Bluetooth: Set the correct security level for SC LTKs
    
    When the looked-up LTK is one generated by Secure Connections pairing
    the security level it gives is BT_SECURITY_FIPS. This patch updates the
    LTK request event handler to correctly set this level.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 81d24c0ea08b..f955d6b7ceb2 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -163,8 +163,12 @@ static inline bool smp_ltk_is_sc(struct smp_ltk *key)
 
 static inline u8 smp_ltk_sec_level(struct smp_ltk *key)
 {
-	if (key->authenticated)
-		return BT_SECURITY_HIGH;
+	if (key->authenticated) {
+		if (smp_ltk_is_sc(key))
+			return BT_SECURITY_FIPS;
+		else
+			return BT_SECURITY_HIGH;
+	}
 
 	return BT_SECURITY_MEDIUM;
 }

commit 23fb8de376181a30c35195351ec6230167098b48
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri May 23 13:15:37 2014 +0300

    Bluetooth: Add mgmt support for LE Secure Connections LTK types
    
    We need a dedicated LTK type for LTK resulting from a Secure Connections
    based SMP pairing. This patch adds a new define for it and ensures that
    both the New LTK event as well as the Load LTKs command supports it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 7c3c351909f5..81d24c0ea08b 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -146,8 +146,21 @@ enum {
 	SMP_STK,
 	SMP_LTK,
 	SMP_LTK_SLAVE,
+	SMP_LTK_P256,
+	SMP_LTK_P256_DEBUG,
 };
 
+static inline bool smp_ltk_is_sc(struct smp_ltk *key)
+{
+	switch (key->type) {
+	case SMP_LTK_P256:
+	case SMP_LTK_P256_DEBUG:
+		return true;
+	}
+
+	return false;
+}
+
 static inline u8 smp_ltk_sec_level(struct smp_ltk *key)
 {
 	if (key->authenticated)

commit e65392e2ccbea210da1d8d8571de0d9821c42e7c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu May 8 14:02:22 2014 +0300

    Bluetooth: Add basic SMP defines for LE Secure Connections
    
    This patch adds basic SMP defines for commands, error codes and PDU
    definitions for the LE Secure Connections feature.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f76083b85005..7c3c351909f5 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -50,10 +50,13 @@ struct smp_cmd_pairing {
 #define SMP_DIST_ENC_KEY	0x01
 #define SMP_DIST_ID_KEY		0x02
 #define SMP_DIST_SIGN		0x04
+#define SMP_DIST_LINK_KEY	0x08
 
 #define SMP_AUTH_NONE		0x00
 #define SMP_AUTH_BONDING	0x01
 #define SMP_AUTH_MITM		0x04
+#define SMP_AUTH_SC		0x08
+#define SMP_AUTH_KEYPRESS	0x10
 
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {
@@ -102,7 +105,23 @@ struct smp_cmd_security_req {
 	__u8	auth_req;
 } __packed;
 
-#define SMP_CMD_MAX		0x0b
+#define SMP_CMD_PUBLIC_KEY	0x0c
+struct smp_cmd_public_key {
+	__u8	x[32];
+	__u8	y[32];
+} __packed;
+
+#define SMP_CMD_DHKEY_CHECK	0x0d
+struct smp_cmd_dhkey_check {
+	__u8	e[16];
+} __packed;
+
+#define SMP_CMD_KEYPRESS_NOTIFY	0x0e
+struct smp_cmd_keypress_notify {
+	__u8	value;
+} __packed;
+
+#define SMP_CMD_MAX		0x0e
 
 #define SMP_PASSKEY_ENTRY_FAILED	0x01
 #define SMP_OOB_NOT_AVAIL		0x02
@@ -114,6 +133,10 @@ struct smp_cmd_security_req {
 #define SMP_UNSPECIFIED			0x08
 #define SMP_REPEATED_ATTEMPTS		0x09
 #define SMP_INVALID_PARAMS		0x0a
+#define SMP_DHKEY_CHECK_FAILED		0x0b
+#define SMP_NUMERIC_COMP_FAILED		0x0c
+#define SMP_BREDR_PAIRING_IN_PROGRESS	0x0d
+#define SMP_CROSS_TRANSP_NOT_ALLOWED	0x0e
 
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16

commit 35dc6f834c9dc888391c7b700130d0831a907ca1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 13 10:55:18 2014 +0200

    Bluetooth: Add key preference parameter to smp_sufficient_security
    
    So far smp_sufficient_security() has returned false if we're encrypted
    with an STK but do have an LTK available. However, for the sake of LE
    CoC servers we do want to let the incoming connection through even
    though we're only encrypted with the STK.
    
    This patch adds a key preference parameter to smp_sufficient_security()
    with two possible values (enum used instead of bool for readability).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 86a683a8b491..f76083b85005 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -133,8 +133,15 @@ static inline u8 smp_ltk_sec_level(struct smp_ltk *key)
 	return BT_SECURITY_MEDIUM;
 }
 
+/* Key preferences for smp_sufficient security */
+enum smp_key_pref {
+	SMP_ALLOW_STK,
+	SMP_USE_LTK,
+};
+
 /* SMP Commands */
-bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
+bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level,
+			     enum smp_key_pref key_pref);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 

commit a6f7833ca353d50de46e3532afebe4abfc5dc4d9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Sep 10 17:37:45 2014 -0700

    Bluetooth: Add smp_ltk_sec_level() helper function
    
    There are several places that need to determine the security level that
    an LTK can provide. This patch adds a convenience function for this to
    help make the code more readable.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 5240537efde3..86a683a8b491 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -125,6 +125,14 @@ enum {
 	SMP_LTK_SLAVE,
 };
 
+static inline u8 smp_ltk_sec_level(struct smp_ltk *key)
+{
+	if (key->authenticated)
+		return BT_SECURITY_HIGH;
+
+	return BT_SECURITY_MEDIUM;
+}
+
 /* SMP Commands */
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);

commit b28b4943660f4e36f118b751ec606c103ba6b1cc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Sep 5 22:19:55 2014 +0300

    Bluetooth: Add strict checks for allowed SMP PDUs
    
    SMP defines quite clearly when certain PDUs are to be expected/allowed
    and when not, but doesn't have any explicit request/response definition.
    So far the code has relied on each PDU handler to behave correctly if
    receiving PDUs at an unexpected moment, however this requires many
    different checks and is prone to errors.
    
    This patch introduces a generic way to keep track of allowed PDUs and
    thereby reduces the responsibility & load on individual command
    handlers. The tracking is implemented using a simple bit-mask where each
    opcode maps to its own bit. If the bit is set the corresponding PDU is
    allow and if the bit is not set the PDU is not allowed.
    
    As a simple example, when we send the Pairing Request we'd set the bit
    for Pairing Response, and when we receive the Pairing Response we'd
    clear the bit for Pairing Response.
    
    Since the disallowed PDU rejection is now done in a single central place
    we need to be a bit careful of which action makes most sense to all
    cases. Previously some, such as Security Request, have been simply
    ignored whereas others have caused an explicit disconnect.
    
    The only PDU rejection action that keeps good interoperability and can
    be used for all the applicable use cases is to drop the data. This may
    raise some concerns of us now being more lenient for misbehaving (and
    potentially malicious) devices, but the policy of simply dropping data
    has been a successful one for many years e.g. in L2CAP (where this is
    the *only* policy for such cases - we never request disconnection in
    l2cap_core.c because of bad data). Furthermore, we cannot prevent
    connected devices from creating the SMP context (through a Security or
    Pairing Request), and once the context exists looking up the
    corresponding bit for the received opcode and deciding to reject it is
    essentially an equally lightweight operation as the kind of rejection
    that l2cap_core.c already successfully does.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index cf1094617c69..5240537efde3 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -102,6 +102,8 @@ struct smp_cmd_security_req {
 	__u8	auth_req;
 } __packed;
 
+#define SMP_CMD_MAX		0x0b
+
 #define SMP_PASSKEY_ENTRY_FAILED	0x01
 #define SMP_OOB_NOT_AVAIL		0x02
 #define SMP_AUTH_REQUIREMENTS		0x03

commit 6f48e260a95c1a0161e5be39adb0f20c737fe459
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 11 22:06:44 2014 +0300

    Bluetooth: Make smp_chan_destroy() private to smp.c
    
    There are no external users of smp_chan_destroy() so make it private to
    smp.c. The patch also moves the function higher up in the c-file in
    order to avoid forward declarations.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 59a594278a85..cf1094617c69 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -128,8 +128,6 @@ bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
-void smp_chan_destroy(struct l2cap_conn *conn);
-
 bool smp_irk_matches(struct hci_dev *hdev, u8 irk[16], bdaddr_t *bdaddr);
 int smp_generate_rpa(struct hci_dev *hdev, u8 irk[16], bdaddr_t *rpa);
 

commit 44f1a7ab51ebe1ca189445837e0599a5edc6efb1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 11 22:06:36 2014 +0300

    Bluetooth: Use L2CAP resume callback to call smp_distribute_keys
    
    There's no need to export the smp_distribute_keys() function since the
    resume callback is called in the same scenario. This patch makes the
    smp_notify_keys function private (at the same time moving it higher up
    in smp.c to avoid forward declarations) and adds a resume callback for
    SMP to call it from there instead.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 161ace3c3234..59a594278a85 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -126,7 +126,6 @@ enum {
 /* SMP Commands */
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
-int smp_distribute_keys(struct l2cap_conn *conn);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
 void smp_chan_destroy(struct l2cap_conn *conn);

commit 5d88cc73dded31a93fcc4821f33a8c3d755bf454
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 8 09:37:18 2014 +0300

    Bluetooth: Convert SMP to use l2cap_chan infrastructure
    
    Now that we have all the necessary pieces in place we can fully convert
    SMP to use the L2CAP channel infrastructure. This patch adds the
    necessary callbacks and removes the now unneeded conn->smp_chan pointer.
    
    One notable behavioral change in this patch comes from the following
    code snippet:
    
    -       case L2CAP_CID_SMP:
    -               if (smp_sig_channel(conn, skb))
    -                       l2cap_conn_del(conn->hcon, EACCES);
    
    This piece of code was essentially forcing a disconnection if garbage
    SMP data was received. The l2cap_conn_del() function is private to
    l2cap_conn.c so we don't have access to it anymore when using the L2CAP
    channel callbacks. Therefore, the behavior of the new code is simply to
    return errors in the recv() callback (which is simply the old
    smp_sig_channel()), but no disconnection will occur.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index d3f6bd617940..161ace3c3234 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -126,7 +126,6 @@ enum {
 /* SMP Commands */
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
-int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
 int smp_distribute_keys(struct l2cap_conn *conn);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 

commit defce9e83666658d4420d65e45ab1ad190992f72
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 8 09:37:17 2014 +0300

    Bluetooth: Make AES crypto context private to SMP
    
    Now that we have per-adapter SMP data thanks to the root SMP L2CAP
    channel we can take advantage of it and attach the AES crypto context
    (only used for SMP) to it. This means that the smp_irk_matches() and
    smp_generate_rpa() function can be converted to internally handle the
    AES context.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 6e29359f60a3..d3f6bd617940 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -132,9 +132,8 @@ int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
 void smp_chan_destroy(struct l2cap_conn *conn);
 
-bool smp_irk_matches(struct crypto_blkcipher *tfm, u8 irk[16],
-		     bdaddr_t *bdaddr);
-int smp_generate_rpa(struct crypto_blkcipher *tfm, u8 irk[16], bdaddr_t *rpa);
+bool smp_irk_matches(struct hci_dev *hdev, u8 irk[16], bdaddr_t *bdaddr);
+int smp_generate_rpa(struct hci_dev *hdev, u8 irk[16], bdaddr_t *rpa);
 
 int smp_register(struct hci_dev *hdev);
 void smp_unregister(struct hci_dev *hdev);

commit 711eafe345d993cf4831e890fa989d02c06cad62
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 8 09:32:52 2014 +0300

    Bluetooth: Move SMP (de)initialization to smp.c
    
    As preparation for moving SMP to use l2cap_chan infrastructure we need
    to move the (de)initialization functions to smp.c (where they'll
    eventually need access to the local L2CAP channel callbacks).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 796f4f45f92f..6e29359f60a3 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -136,4 +136,7 @@ bool smp_irk_matches(struct crypto_blkcipher *tfm, u8 irk[16],
 		     bdaddr_t *bdaddr);
 int smp_generate_rpa(struct crypto_blkcipher *tfm, u8 irk[16], bdaddr_t *rpa);
 
+int smp_register(struct hci_dev *hdev);
+void smp_unregister(struct hci_dev *hdev);
+
 #endif /* __SMP_H */

commit 2ceba53936d6f2071659b87748d723021937d035
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jun 16 19:25:16 2014 +0300

    Bluetooth: Remove HCI prefix from SMP LTK defines
    
    The LTK type has really nothing to do with HCI so it makes more sense to
    have these in smp.h than hci.h. This patch moves the defines to smp.h
    and removes the HCI_ prefix in the same go.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 5a8dc36460a1..796f4f45f92f 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -116,6 +116,13 @@ struct smp_cmd_security_req {
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16
 
+/* LTK types used in internal storage (struct smp_ltk) */
+enum {
+	SMP_STK,
+	SMP_LTK,
+	SMP_LTK_SLAVE,
+};
+
 /* SMP Commands */
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);

commit 4bc58f51e156227d139668199ffe5df2ccb2f3c2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue May 20 09:45:47 2014 +0300

    Bluetooth: Make SMP context private to smp.c
    
    There are no users of the smp_chan struct outside of smp.c so move it
    away from smp.h. The addition of the l2cap.h include to hci_core.c,
    hci_conn.c and mgmt.c is something that should have been there already
    previously to avoid warnings of undeclared struct l2cap_conn, but the
    compiler warning was apparently shadowed away by the mention of
    l2cap_conn in the struct smp_chan definition.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index afd16231db13..5a8dc36460a1 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -116,35 +116,6 @@ struct smp_cmd_security_req {
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16
 
-#define SMP_FLAG_TK_VALID	1
-#define SMP_FLAG_CFM_PENDING	2
-#define SMP_FLAG_MITM_AUTH	3
-#define SMP_FLAG_COMPLETE	4
-#define SMP_FLAG_INITIATOR	5
-
-struct smp_chan {
-	struct l2cap_conn *conn;
-	u8		preq[7]; /* SMP Pairing Request */
-	u8		prsp[7]; /* SMP Pairing Response */
-	u8		prnd[16]; /* SMP Pairing Random (local) */
-	u8		rrnd[16]; /* SMP Pairing Random (remote) */
-	u8		pcnf[16]; /* SMP Pairing Confirm */
-	u8		tk[16]; /* SMP Temporary Key */
-	u8		enc_key_size;
-	u8		remote_key_dist;
-	bdaddr_t	id_addr;
-	u8		id_addr_type;
-	u8		irk[16];
-	struct smp_csrk	*csrk;
-	struct smp_csrk	*slave_csrk;
-	struct smp_ltk	*ltk;
-	struct smp_ltk	*slave_ltk;
-	struct smp_irk	*remote_irk;
-	unsigned long	smp_flags;
-	struct work_struct confirm;
-	struct work_struct random;
-};
-
 /* SMP Commands */
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);

commit 38e4a915663f3f3c03b753d90a34fbb6164ea55d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu May 8 14:19:11 2014 +0300

    Bluetooth: Add support for SMP Invalid Parameters error code
    
    The Invalid Parameters error code is used to indicate that the command
    length is invalid or that a parameter is outside of the specified range.
    This error code wasn't clearly specified in the Bluetooth 4.0
    specification but since 4.1 this has been fixed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 1277147a9150..afd16231db13 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -111,6 +111,7 @@ struct smp_cmd_security_req {
 #define SMP_CMD_NOTSUPP			0x07
 #define SMP_UNSPECIFIED			0x08
 #define SMP_REPEATED_ATTEMPTS		0x09
+#define SMP_INVALID_PARAMS		0x0a
 
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16

commit 1d98bf4fda5f76563a9718b59e3ac5a65fd36a51
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Mar 24 14:39:08 2014 +0200

    Bluetooth: Remove LTK re-encryption procedure
    
    Due to several devices being unable to handle this procedure reliably
    (resulting in forced disconnections before pairing completes) it's
    better to remove it altogether.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 0d536b8b3f9a..1277147a9150 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -118,11 +118,8 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_TK_VALID	1
 #define SMP_FLAG_CFM_PENDING	2
 #define SMP_FLAG_MITM_AUTH	3
-#define SMP_FLAG_LTK_ENCRYPT	4
-#define SMP_FLAG_COMPLETE	5
-#define SMP_FLAG_INITIATOR	6
-
-#define SMP_REENCRYPT_TIMEOUT	msecs_to_jiffies(500)
+#define SMP_FLAG_COMPLETE	4
+#define SMP_FLAG_INITIATOR	5
 
 struct smp_chan {
 	struct l2cap_conn *conn;
@@ -145,7 +142,6 @@ struct smp_chan {
 	unsigned long	smp_flags;
 	struct work_struct confirm;
 	struct work_struct random;
-	struct delayed_work reencrypt;
 };
 
 /* SMP Commands */

commit edca792c036f48b15ee4d70045fb6722e8797281
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Mar 24 15:54:11 2014 +0200

    Bluetooth: Add SMP flag to track which side is the initiator
    
    For remotely initiated just-works pairings we want to show the user a
    confirmation dialog for the pairing. However, we can only know which
    side was the initiator by tracking which side sends the first Security
    Request or Pairing Request PDU. This patch adds a new SMP flag to
    indicate whether our side was the initiator for the pairing.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index b6913471815a..0d536b8b3f9a 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -120,6 +120,7 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_MITM_AUTH	3
 #define SMP_FLAG_LTK_ENCRYPT	4
 #define SMP_FLAG_COMPLETE	5
+#define SMP_FLAG_INITIATOR	6
 
 #define SMP_REENCRYPT_TIMEOUT	msecs_to_jiffies(500)
 

commit 5ed884d765a240593c721711eb9e6d24ceba5e8b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Mar 19 14:14:52 2014 +0200

    Bluetooth: Increase SMP re-encryption delay to 500ms
    
    In some cases the current 250ms delay is not enough for the remote to
    receive the keys, as can be witnessed by the following log:
    
    > ACL Data RX: Handle 64 flags 0x02 dlen 21               [hci1] 231.414217
          SMP: Signing Information (0x0a) len 16
            Signature key: 555bb66b7ab3abc9d5c287c97fe6eb29
    < ACL Data TX: Handle 64 flags 0x00 dlen 21               [hci1] 231.414414
          SMP: Encryption Information (0x06) len 16
            Long term key: 2a7cdc233c9a4b1f3ed31dd9843fea29
    < ACL Data TX: Handle 64 flags 0x00 dlen 15               [hci1] 231.414466
          SMP: Master Identification (0x07) len 10
            EDIV: 0xeccc
            Rand: 0x322e0ef50bd9308a
    < ACL Data TX: Handle 64 flags 0x00 dlen 21               [hci1] 231.414505
          SMP: Signing Information (0x0a) len 16
            Signature key: bbda1b2076e2325aa66fbcdd5388f745
    > HCI Event: Number of Completed Packets (0x13) plen 5    [hci1] 231.483130
            Num handles: 1
            Handle: 64
            Count: 2
    < HCI Command: LE Start Encryption (0x08|0x0019) plen 28  [hci1] 231.664211
            Handle: 64
            Random number: 0x5052ad2b75fed54b
            Encrypted diversifier: 0xb7c2
            Long term key: a336ede66711b49a84bde9b41426692e
    > HCI Event: Command Status (0x0f) plen 4                 [hci1] 231.666937
          LE Start Encryption (0x08|0x0019) ncmd 1
            Status: Success (0x00)
    > HCI Event: Number of Completed Packets (0x13) plen 5    [hci1] 231.712646
            Num handles: 1
            Handle: 64
            Count: 1
    > HCI Event: Disconnect Complete (0x05) plen 4            [hci1] 232.562587
            Status: Success (0x00)
            Handle: 64
            Reason: Remote User Terminated Connection (0x13)
    
    As can be seen, the last key (Signing Information) is sent at 231.414505
    but the completed packets event for it comes only at 231.712646,
    i.e. roughly 298ms later.
    
    To have a better margin of error this patch increases the delay to
    500ms.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f223b9d38b61..b6913471815a 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -121,7 +121,7 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_LTK_ENCRYPT	4
 #define SMP_FLAG_COMPLETE	5
 
-#define SMP_REENCRYPT_TIMEOUT	msecs_to_jiffies(250)
+#define SMP_REENCRYPT_TIMEOUT	msecs_to_jiffies(500)
 
 struct smp_chan {
 	struct l2cap_conn *conn;

commit 7ee4ea3692f20b87b0e0d3884d5b2d22ec1a2df0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 9 12:19:17 2014 -0700

    Bluetooth: Add support for handling signature resolving keys
    
    The connection signature resolving key (CSRK) is used for attribute
    protocol signed write procedures. This change generates a new local
    key during pairing and requests the peer key as well.
    
    Newly generated key and received key will be provided to userspace
    using the New Signature Resolving Key management event.
    
    The Master CSRK can be used for verification of remote signed write
    PDUs and the Slave CSRK can be used for sending signed write PDUs
    to the remote device.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f55d83617218..f223b9d38b61 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -136,6 +136,8 @@ struct smp_chan {
 	bdaddr_t	id_addr;
 	u8		id_addr_type;
 	u8		irk[16];
+	struct smp_csrk	*csrk;
+	struct smp_csrk	*slave_csrk;
 	struct smp_ltk	*ltk;
 	struct smp_ltk	*slave_ltk;
 	struct smp_irk	*remote_irk;

commit e3098be40bbde0fdd5fcfa6bf28491db421d333a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 18:10:03 2014 +0200

    Bluetooth: Delay LTK encryption to let remote receive all keys
    
    Some devices may refuse to re-encrypt with the LTK if they haven't
    received all our keys yet. This patch adds a 250ms delay before
    attempting re-encryption with the LTK.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 676395f93702..f55d83617218 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -121,6 +121,8 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_LTK_ENCRYPT	4
 #define SMP_FLAG_COMPLETE	5
 
+#define SMP_REENCRYPT_TIMEOUT	msecs_to_jiffies(250)
+
 struct smp_chan {
 	struct l2cap_conn *conn;
 	u8		preq[7]; /* SMP Pairing Request */
@@ -140,6 +142,7 @@ struct smp_chan {
 	unsigned long	smp_flags;
 	struct work_struct confirm;
 	struct work_struct random;
+	struct delayed_work reencrypt;
 };
 
 /* SMP Commands */

commit 38ccdc93326f61b84734028e586ed522a53b733a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 18:10:02 2014 +0200

    Bluetooth: Re-encrypt link after receiving an LTK
    
    It's not strictly speaking required to re-encrypt a link once we receive
    an LTK since the connection is already encrypted with the STK. However,
    re-encrypting with the LTK allows us to verify that we've received an
    LTK that actually works.
    
    This patch updates the SMP code to request encrypting with the LTK in
    case we're in master role and waits until the key refresh complete event
    before notifying user space of the distributed keys.
    
    A new flag is also added for the SMP context to ensure that we
    re-encryption only once in case of multiple calls to smp_distribute_keys.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index a11d4281542c..676395f93702 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -118,7 +118,8 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_TK_VALID	1
 #define SMP_FLAG_CFM_PENDING	2
 #define SMP_FLAG_MITM_AUTH	3
-#define SMP_FLAG_COMPLETE	4
+#define SMP_FLAG_LTK_ENCRYPT	4
+#define SMP_FLAG_COMPLETE	5
 
 struct smp_chan {
 	struct l2cap_conn *conn;

commit fe39c7b2dacf7fd4dcddc26704d01315ab92b7cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 27 16:00:28 2014 -0800

    Bluetooth: Use __le64 type for LE random numbers
    
    The random numbers in Bluetooth Low Energy are 64-bit numbers and should
    also be little endian since the HCI specification is little endian.
    
    Change the whole Low Energy pairing to use __le64 instead of a byte
    array.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 1b8af35b292c..a11d4281542c 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -78,7 +78,7 @@ struct smp_cmd_encrypt_info {
 #define SMP_CMD_MASTER_IDENT	0x07
 struct smp_cmd_master_ident {
 	__le16	ediv;
-	__u8	rand[8];
+	__le64	rand;
 } __packed;
 
 #define SMP_CMD_IDENT_INFO	0x08

commit 4bd6d38e7f58b163138d3fea8fa135de523bfb92
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 26 23:33:45 2014 +0200

    Bluetooth: Remove unneeded "force" parameter from smp_distribute_keys()
    
    Now that to-be-received keys are properly tracked we no-longer need the
    "force" parameter to smp_distribute_keys(). It was essentially acting as
    an indicator whether all keys have been received, but now it's just
    redundant together with smp->remote_key_dist.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f32f1212f650..1b8af35b292c 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -145,7 +145,7 @@ struct smp_chan {
 bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
-int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+int smp_distribute_keys(struct l2cap_conn *conn);
 int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
 void smp_chan_destroy(struct l2cap_conn *conn);

commit b1e2b3ae97620752905e58a9682fad7222796566
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:19 2014 +0200

    Bluetooth: Add SMP function for generating RPAs
    
    We need a function in smp.c to generate Resolvable Random Addresses in
    order to support privacy. The local RPA will need to be generated before
    advertising, scanning or connecting and regenerated at periodic
    intervals. This patch adds the necessary function for RPA generation.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index d8cc543f523c..f32f1212f650 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -152,5 +152,6 @@ void smp_chan_destroy(struct l2cap_conn *conn);
 
 bool smp_irk_matches(struct crypto_blkcipher *tfm, u8 irk[16],
 		     bdaddr_t *bdaddr);
+int smp_generate_rpa(struct crypto_blkcipher *tfm, u8 irk[16], bdaddr_t *rpa);
 
 #endif /* __SMP_H */

commit 23d0e128e38049734c7ecc0987de02486d1ded3e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 19 14:57:46 2014 +0200

    Bluetooth: Track SMP keys in the SMP context
    
    As preparation to do mgmt notification in a single place at the end of
    the key distribution, store the keys that need to be notified within the
    SMP context.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 675fd3b21d2c..d8cc543f523c 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -133,6 +133,9 @@ struct smp_chan {
 	bdaddr_t	id_addr;
 	u8		id_addr_type;
 	u8		irk[16];
+	struct smp_ltk	*ltk;
+	struct smp_ltk	*slave_ltk;
+	struct smp_irk	*remote_irk;
 	unsigned long	smp_flags;
 	struct work_struct confirm;
 	struct work_struct random;

commit f4a407bef20c0e63fcd910a9404418522abff4ab
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 21:41:34 2014 +0200

    Bluetooth: Wait for SMP key distribution completion when pairing
    
    When we initiate pairing through mgmt_pair_device the code has so far
    been waiting for a successful HCI Encrypt Change event in order to
    respond to the mgmt command. However, putting privacy into the play we
    actually want the key distribution to be complete before replying so
    that we can include the Identity Address in the mgmt response.
    
    This patch updates the various hci_conn callbacks for LE in mgmt.c to
    only respond in the case of failure, and adds a new mgmt_smp_complete
    function that the SMP code will call once key distribution has been
    completed.
    
    Since the smp_chan_destroy function that's used to indicate completion
    and clean up the SMP context can be called from various places,
    including outside of smp.c, the easiest way to track failure vs success
    is a new flag that we set once key distribution has been successfully
    completed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 8f54c9b152de..675fd3b21d2c 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -118,6 +118,7 @@ struct smp_cmd_security_req {
 #define SMP_FLAG_TK_VALID	1
 #define SMP_FLAG_CFM_PENDING	2
 #define SMP_FLAG_MITM_AUTH	3
+#define SMP_FLAG_COMPLETE	4
 
 struct smp_chan {
 	struct l2cap_conn *conn;

commit 893ce8b1b3d92cbddcf34bb92c7d24720efc7fed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 21:41:31 2014 +0200

    Bluetooth: Remove SMP data specific crypto context
    
    Now that each HCI device has its own AES crypto context we don't need
    the one stored in the SMP data any more. This patch removes the variable
    from struct smp_chan and updates the SMP code to use the per-hdev crypto
    context.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 4f373bc56ad7..8f54c9b152de 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -133,7 +133,6 @@ struct smp_chan {
 	u8		id_addr_type;
 	u8		irk[16];
 	unsigned long	smp_flags;
-	struct crypto_blkcipher	*tfm;
 	struct work_struct confirm;
 	struct work_struct random;
 };

commit fd349c020c5b6f7a6e17cb8b4e821ff9b6f71ba6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:19:36 2014 +0200

    Bluetooth: Enable support for remote IRK distribution
    
    This patch does the necessary changes to request the remote device to
    distribute its IRK to us during the SMP pairing procedure. This includes
    setting the right key distribution values in the pairing
    request/response and handling of the two related SMP PDUs, i.e. Identity
    Information and Identity Address Information.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 950d039c2ea2..4f373bc56ad7 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -128,6 +128,10 @@ struct smp_chan {
 	u8		pcnf[16]; /* SMP Pairing Confirm */
 	u8		tk[16]; /* SMP Temporary Key */
 	u8		enc_key_size;
+	u8		remote_key_dist;
+	bdaddr_t	id_addr;
+	u8		id_addr_type;
+	u8		irk[16];
 	unsigned long	smp_flags;
 	struct crypto_blkcipher	*tfm;
 	struct work_struct confirm;

commit 60478054a6af7aa8cceb8218d29d27f165f1c9d3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:19:31 2014 +0200

    Bluetooth: Add smp_irk_matches helper function
    
    This patch adds a helper function to check whether a given IRK matches a
    given Resolvable Private Address (RPA). The function will be needed for
    implementing the rest of address resolving support.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index 777ee93a6c9b..950d039c2ea2 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -143,4 +143,7 @@ int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
 
 void smp_chan_destroy(struct l2cap_conn *conn);
 
+bool smp_irk_matches(struct crypto_blkcipher *tfm, u8 irk[16],
+		     bdaddr_t *bdaddr);
+
 #endif /* __SMP_H */

commit 6bfdfe3cd68d5a797e0ebfb57068fe7f9c20c93a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:19:30 2014 +0200

    Bluetooth: Fix minor whitespace issues in SMP code
    
    This patch fixes a couple of unnecessary empty lines in the SMP code.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index a700bcb490d7..777ee93a6c9b 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -132,7 +132,6 @@ struct smp_chan {
 	struct crypto_blkcipher	*tfm;
 	struct work_struct confirm;
 	struct work_struct random;
-
 };
 
 /* SMP Commands */

commit ad32a2f5ced269f5516950fc8f52b6673462d208
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue May 14 18:05:12 2013 +0300

    Bluetooth: Add smp_sufficient_security helper function
    
    This function is needed both by the smp_conn_security function as well
    as upcoming code to check for the security requirements when receiving
    an L2CAP connect request over LE.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
index f8ba07f3e5fa..a700bcb490d7 100644
--- a/net/bluetooth/smp.h
+++ b/net/bluetooth/smp.h
@@ -136,6 +136,7 @@ struct smp_chan {
 };
 
 /* SMP Commands */
+bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level);
 int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
 int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);

commit ac4b7236610cef99821f40f44a74030b85d85270
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 10 14:54:16 2013 -0700

    Bluetooth: Move smp.h header file into net/bluetooth/
    
    The smp.h header file is only used internally by the bluetooth.ko
    module and is not a public API. So make it local to the core
    Bluetooth module.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/smp.h b/net/bluetooth/smp.h
new file mode 100644
index 000000000000..f8ba07f3e5fa
--- /dev/null
+++ b/net/bluetooth/smp.h
@@ -0,0 +1,146 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __SMP_H
+#define __SMP_H
+
+struct smp_command_hdr {
+	__u8	code;
+} __packed;
+
+#define SMP_CMD_PAIRING_REQ	0x01
+#define SMP_CMD_PAIRING_RSP	0x02
+struct smp_cmd_pairing {
+	__u8	io_capability;
+	__u8	oob_flag;
+	__u8	auth_req;
+	__u8	max_key_size;
+	__u8	init_key_dist;
+	__u8	resp_key_dist;
+} __packed;
+
+#define SMP_IO_DISPLAY_ONLY	0x00
+#define SMP_IO_DISPLAY_YESNO	0x01
+#define SMP_IO_KEYBOARD_ONLY	0x02
+#define SMP_IO_NO_INPUT_OUTPUT	0x03
+#define SMP_IO_KEYBOARD_DISPLAY	0x04
+
+#define SMP_OOB_NOT_PRESENT	0x00
+#define SMP_OOB_PRESENT		0x01
+
+#define SMP_DIST_ENC_KEY	0x01
+#define SMP_DIST_ID_KEY		0x02
+#define SMP_DIST_SIGN		0x04
+
+#define SMP_AUTH_NONE		0x00
+#define SMP_AUTH_BONDING	0x01
+#define SMP_AUTH_MITM		0x04
+
+#define SMP_CMD_PAIRING_CONFIRM	0x03
+struct smp_cmd_pairing_confirm {
+	__u8	confirm_val[16];
+} __packed;
+
+#define SMP_CMD_PAIRING_RANDOM	0x04
+struct smp_cmd_pairing_random {
+	__u8	rand_val[16];
+} __packed;
+
+#define SMP_CMD_PAIRING_FAIL	0x05
+struct smp_cmd_pairing_fail {
+	__u8	reason;
+} __packed;
+
+#define SMP_CMD_ENCRYPT_INFO	0x06
+struct smp_cmd_encrypt_info {
+	__u8	ltk[16];
+} __packed;
+
+#define SMP_CMD_MASTER_IDENT	0x07
+struct smp_cmd_master_ident {
+	__le16	ediv;
+	__u8	rand[8];
+} __packed;
+
+#define SMP_CMD_IDENT_INFO	0x08
+struct smp_cmd_ident_info {
+	__u8	irk[16];
+} __packed;
+
+#define SMP_CMD_IDENT_ADDR_INFO	0x09
+struct smp_cmd_ident_addr_info {
+	__u8	addr_type;
+	bdaddr_t bdaddr;
+} __packed;
+
+#define SMP_CMD_SIGN_INFO	0x0a
+struct smp_cmd_sign_info {
+	__u8	csrk[16];
+} __packed;
+
+#define SMP_CMD_SECURITY_REQ	0x0b
+struct smp_cmd_security_req {
+	__u8	auth_req;
+} __packed;
+
+#define SMP_PASSKEY_ENTRY_FAILED	0x01
+#define SMP_OOB_NOT_AVAIL		0x02
+#define SMP_AUTH_REQUIREMENTS		0x03
+#define SMP_CONFIRM_FAILED		0x04
+#define SMP_PAIRING_NOTSUPP		0x05
+#define SMP_ENC_KEY_SIZE		0x06
+#define SMP_CMD_NOTSUPP			0x07
+#define SMP_UNSPECIFIED			0x08
+#define SMP_REPEATED_ATTEMPTS		0x09
+
+#define SMP_MIN_ENC_KEY_SIZE		7
+#define SMP_MAX_ENC_KEY_SIZE		16
+
+#define SMP_FLAG_TK_VALID	1
+#define SMP_FLAG_CFM_PENDING	2
+#define SMP_FLAG_MITM_AUTH	3
+
+struct smp_chan {
+	struct l2cap_conn *conn;
+	u8		preq[7]; /* SMP Pairing Request */
+	u8		prsp[7]; /* SMP Pairing Response */
+	u8		prnd[16]; /* SMP Pairing Random (local) */
+	u8		rrnd[16]; /* SMP Pairing Random (remote) */
+	u8		pcnf[16]; /* SMP Pairing Confirm */
+	u8		tk[16]; /* SMP Temporary Key */
+	u8		enc_key_size;
+	unsigned long	smp_flags;
+	struct crypto_blkcipher	*tfm;
+	struct work_struct confirm;
+	struct work_struct random;
+
+};
+
+/* SMP Commands */
+int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
+int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
+int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
+
+void smp_chan_destroy(struct l2cap_conn *conn);
+
+#endif /* __SMP_H */
